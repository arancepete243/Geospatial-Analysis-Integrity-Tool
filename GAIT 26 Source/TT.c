/************
The GAIT Tool was developed at the National Geospatial-Intelligence Agency (NGA) in collaboration with the   
Institute for Defense Analyses (IDA) under a Government contract. The government is releasing this software   
to increase the impact of government investments by providing developers with the opportunity to take things   
in new directions. The software use, modification, and distribution rights are stipulated within the MIT license.

As-is warranty is covered within the MIT license but it's re-stated here for clarity: The GAIT tool contains several   
software components. The software is provided "as is," and no warranty, express or implied, including but not limited   
to the implied warranties of merchantability and fitness for particular purpose or arising by statute or otherwise in   
law or from a course of dealing or usage in trade, is made with respect to the accuracy or functioning of the software.   
Neither NGA or IDA are liable for any claims, losses, or damages arising from or connected with the use of the software.   
The user's sole and exclusive remedy is to stop using the software.
************/

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <string.h>
#include <time.h>


#include "share.h"
#include "TTshare.h"


#ifndef DATA_TYPE
#define DATA_TYPE void *
#endif
#ifdef DMALLOC
#include <dmalloc.h>
#endif

#define MONOBUMP 50


/*** type definitions ****/

struct AreaRing *ringc, *ringp;
struct AreaAndHoles *AHroot, *AHc, *AHp;

struct ConditionList *CTD = NULL;



struct InfoPrintContent IPC;
struct TearErrorSortList
   {
   int keyval;
   int Cnumber;
   double magnitude;
   int index1,index2;
   char gform1, gform2;
   int IDN1, IDN2;
   unsigned int Lindex1, Lindex2;
   double localID1, localID2;
   double radius1, height1, radius2, height2;
   int numverts1, numverts2;
   double x1[2], y1[2], z1[2];
   double x2[2], y2[2], z2[2];
   struct TearErrorSortList * next;
   };
struct CondToCollect *CTCroot, *CTCc, *CTCp;
struct LongList
   {
   long int fp;
   int fn;
   struct LongList * next;
   };
struct LongSkipList
   {
   long int val;
   struct LongList *entry;
   };
struct AttributeList
   {
   char nametag[6];
   int valtype;
   union  {
      long int ival;
      double dval;
      char * cval;
      } uval;
   struct AttributeList * next;
   };
struct LargeAreals
{
   long int fp;
   int fnumber;
   struct RawAreal * ra;
   struct LargeAreals * next;
} *ARlargeRoot;
struct guide
   {
   double adjacentdist;
   double closest;
   int index;
   int forwardindex;
   int reset;
   } *SliverGuide;

/***********/
struct RawGrid
   {
   int idn;
   double *X;
   double *Y;
   double *Elev;
   };
/************/

struct MultiGrids *MG = NULL;
struct PointerTable
   {
   int number;
   long int fileposn;
   };
struct NeighborPolys
   {
   struct ThePolys * p;
   struct NeighborPolys * next;
   };
struct PolyExtra
   {
   unsigned char copy;
   double sliver;
   double area;
   int roadpoly;
   struct NeighborPolys * N;
   };

struct ToBeLoaded
   {
   int index1;
   int index2;
   int isum;
   struct ToBeLoaded *next;
   };
struct CloseVertex *CVc, *CVn, *CVp;
struct LIDlist *LIDc, *LIDp, *LIDn;
struct CoordList *CLc, *CLn;
struct NetworkNode *BucketsOfNets, *NNc, *NNn, *NNt, *BucketsOfTransNets;
struct GlobalGridInfo *GridHeader;
struct NewGridLookup * NGT = NULL;
struct ListOfArealEdges *LAEroot, *LAEc, *LAEn, *LAEp, *KnownRoot, *ProcessRoot, *EdgeAddRoot, *LAEadded, *LAEadded2;
struct DoublePolySkipList
   {
   double val;
   struct ThePolys *entry;
   };
struct DoubleEdgeSkipList
   {
   double val;
   struct ListOfEdges *entry;
   };
struct CombinedChecks *ActiveChecks;  /*** should be an array of size CONDITION_DEFINITIONS + CLONE_DEFINITIONS ***/
struct ListOfAreals
   {
   int Lindex;
   int Sindex;
   int idn;
   int featureid;
   int ishole;
   int temp;
   int notclosed;
   double localID;
   unsigned char config;
   unsigned char stratum;
   unsigned char domain;
   double areaattr;
   double hgtattr;
   double zv2attr;
   double lenattr;
   double namattr;
   char * lenstr;
   char * namstr;
   char * areastr;
   char * hgtstr;
   char * zv2str;
   double minxvtx;
   double perimlength;
   double area;
   int numverts;
   double * x;
   double * y;
   double * z;
   struct RawAreal * holes;
   struct ListOfAreals * next;
   } *ArealListRoot, *alrc, *alrp, *alrn;
struct PointAndID *PIroot, *pic, *pic2, *LAINTroot, *LSLICEroot;
struct DuplicateHoles
   {
   int thisidn;
   int dupidn;
   struct DuplicateHoles * next;
   } *DHroot, *DHc, *DHp, *DHn;
struct MasterCandVlist
   {
   int ECC;
   int code;
   char ismeta;
   double match;
   int nomatch;
   char islen;
   double value;
   char * strval;
   struct MasterCandVlist * next;
   } *CV_Master, *cvp, *cvm;


struct AttrsCountForBndryMatch
{
int acode;
int fcode;
int allow_nunanpo;
char fgeom;
struct AttrsCountForBndryMatch *next;
} *ACBMroot, *ACBMc, *ACBMp, *ACBMn;
struct InputFiles *ArealFiles, *LinearFiles;

struct OverlapIDinstance
   {
   char gform;
   char part;
   int checknumb;
   int idn;
   double lid;
   int Lindex;
   int Sindex;
   int numvert;
   double x[2], y[2], z[2];
   struct OverlapIDinstance * next;
   } *olidc, *olidp;
struct OverlapID
   {
   char * IDstr;
   struct OverlapIDinstance *inst;
   } *ID_O;
int ID_O_count = 0;
struct PairsChecked *LPc, *LPp, *LPn, *APc, *APp, *APn;
struct PairsCheckedEntry *AreaPairRoot, *LinePairRoot;
struct pairedwith *PWc, *PWn, *PWp;
struct ARangeUNM *LatRoot, *LonRoot, *ARUc, *ARUn, *ARUp;
int SzARU = sizeof(struct ARangeUNM);



rb_red_blk_tree* RBTreeCreate(int  (*CompFunc)(const void*, const void*),
                             void (*DestFunc)(void*),
                             void (*InfoDestFunc)(void*),
                             void (*PrintFunc)(const void*),
                             void (*PrintInfo)(void*));
rb_red_blk_node * RBTreeInsert(rb_red_blk_tree*, void* key, void* info);
void RBDelete(rb_red_blk_tree* , rb_red_blk_node* );
void RBTreeDestroy(rb_red_blk_tree*);
rb_red_blk_node* TreePredecessor(rb_red_blk_tree*,rb_red_blk_node*);
rb_red_blk_node* TreeSuccessor(rb_red_blk_tree*,rb_red_blk_node*);
rb_red_blk_node* RBExactQuery(rb_red_blk_tree*, void*);
stk_stack * RBEnumerate(rb_red_blk_tree* tree,void* low, void* high);
void NullFunction(void*);

int PointInsidePoly(double px,double py,double * x,double * y,int numb);

stk_stack * StackCreate();
void StackPush(stk_stack * theStack, DATA_TYPE newInfoPointer);


void FwriteObjectAndMessage(int keyval, int Cnumber,
                            int IDN, char gform, int Lindex, double localid, int index, double radius, double height,
                            double *x, double *y, double *z, int numverts, char *msg);

int TtlCombinedChecks = 0;
int TtlActiveChecks = 0;
int SmryMagic = 1234321;
double PI = PIvalue;
int NewNetNumber = 0;
int TtlCoverFailures = 0;
int SzDH = sizeof(struct DuplicateHoles);
double * ShadowElevations; /*** used as vertex elevations for DEM and Feature checks ***/
int NumShadowElevations = 0;
unsigned long int CONDITION_LIMIT  = 500000;
int OmitGridSentinels = 1;


/*** global variables declared in interface.c and used here ***/
extern double xunits; /** if < 100, draw marker symbol ***/
extern int INTERSECTION_BASED;
extern int CLONE_DEFINITIONS;
extern int STOP_FLAG;
extern int NetRouteType;
extern unsigned char DrawByConfig[NUM_C];
extern unsigned char DrawByStratum[NUM_S];
extern unsigned char DrawByDomain[NUM_D];
extern int file_endianness;
extern int DRAW_ONLY;
extern double OutGridX,OutGridY;
extern double OutGridSpace;
extern int OutGridYNum,OutGridXNum;
extern double OutGridND;
extern int CLAMPFEATURES;
extern char outgrid[]; /** file name for the grid ascii dem **/
extern char outgrid2[]; /** file name for the SEE-IT binary format dem **/
extern char outgrid3[]; /** file name for the dem shaded relief pgm **/
extern int SunAzimuth;  /** azimuth to sun, 0 - 360 degrees **/
extern int SunAngle; /** angle between earth plane and sun elevation - 15 to 75 degrees **/
extern int VertExag; /** amount of vertical exag for shaded relief **/
extern int ZoomSunAzimuth; /** same kind of params, but effective on zooming **/
extern int ZoomSunAngle;
extern double ZoomVertExag;
extern int CDFREPORT;  /** in interface.c do we need to make comma-delimited format condition reports **/
extern int SLASHTYPE;
extern int DRAW_NOW;
extern struct ToCollect *TCroot, *TCn, *TCp, *TCc;
extern struct LM_ConflateStats *CSroot, *CSn, *CSp, *CSc;

extern int SzI;
extern int SzF;
extern int SzD;   /* unified all sizes.  defined in interface.c */
extern int SzUC;
extern int SzL;
extern int SzShort;

extern int running;  /** set in interface, value > 0 when checking, 0 otherwise ***/

extern int AbortZoom();
extern int GetNum2(char *eac);
extern int SilentGetCodeIndex(char *ecc);
extern int SilentGetAttrIndex(char *eac);
extern int ATTRTYPE_GGDM3();

extern void ReleaseFileNames(int allfiles);
extern int GetCodeIndex(char *ecc);
extern void ConstructFileNames(char * filepath, int allfiles);
extern int SetNUNANPO();
extern char * allowedSAC;
extern int NowFormatting;
extern int UseNUNANPO;
extern char *GetFrontPart();
extern char *GetFrontPart2();
extern int GetAttrIndex(char *ecc);
extern void DrawShadedGrid(char * filename,long int fileposn);
extern char * GetFileNamefile();
extern int IsJunkValue(int datatype,int Ivalue, double Fvalue, char *Svalue, int Evalue, char *Elabel);
extern int route_time_update(int type, char *message);


/*** end of external global variables ****/

extern void InitializationAdvice(double PCacount, double IndexPrep, double PCattr, double PCattrval, double ECCdone, int DON);


extern char * GetECCLabel(int code);
extern char * GetEACLabel(int code);
extern char * GetUnitsLabel(int code);
extern char * GetScaleLabel(int code);
extern char *GetDataContent(int type);
extern char *GetVariousPeices(int type);
extern char * SetThisClassLevel(int returnearly, int useextract);

/*** function defined in moregeomchecks.c ****/
extern void BB_FwriteDynamicInfo(FILE * bbout, int keyval, int Cnumber,
                                  int cinstance, double Wflag, int PtUsed, int MagUsed, int NumObjects,
                                  char *msg, double magnitude, double pointX, double pointY, double pointZ,
                                  int index1, char gform1, int Lindex1, double localid1, int IDN1,
                                  double radius1, double height1,
                                  double *x1, double *y1, double *z1, int numverts1,
                                  int index2, char gform2, int Lindex2, double localid2, int IDN2,
                                  double radius2, double height2,
                                  double *x2, double *y2, double *z2, int numverts2);
extern void MakeBillBoardFromPoints_DynamicInfo(FILE *infile, int TargetCheck, int SortOrder);
extern void FwriteDynamicInfo(int keyval, int Cnumber, int PtUsed, int MagUsed, int NumObjects,
                                  char *msg, double magnitude, double pointX, double pointY, double pointZ,
                                  int index1, char gform1, int Lindex1, double localid1, int IDN1,
                                  double radius1, double height1,
                                  double *x1, double *y1, double *z1, int numverts1,
                                  int index2, char gform2, int Lindex2, double localid2, int IDN2,
                                  double radius2, double height2,
                                  double *x2, double *y2, double *z2, int numverts2);
extern double GenerateKernelStats(int PassNumber, int Lindex1,int Uindex1, int Lindex2, int Uindex2,
                 double AvgElevErr, double *RMSE, long int *NZpoints, double *MaxDiff, double *MD_X, double *MD_Y,
                   int *SrcLindex, int *RefLindex, int *MLindex);
extern double GenerateNearestNeighborStats(int PassNumber, int Lindex1,int Uindex1, int Lindex2, int Uindex2,
                 double AvgElevErr, double *RMSE, long int *NZpoints, double *MaxDiff, double *MD_X, double *MD_Y,
                  int *SrcLindex, int *RefLindex, int *MLindex);


/*** extern function declared in errors.c, used when sorting the error file **/
extern void ReRackAllConditions(int UseButton, int ZeroIngOut, int ErrorToZero, int InstanceToZero);
extern void DrawConditionObjects(struct ConditionList * ConditionToDraw);


/** functions in geomchecks.c ***/
extern void PerformAttrEdgeMatchChecks(char * prompt, int cindex,struct RawLinear *root,double minx,double miny,double maxx,double maxy, double multiplier,
    int NorthCount, int SouthCount, int EastCount, int WestCount,
    struct RawAreal *Aroot, struct RawBridge *Broot, struct RawPoint *Proot, struct ListOfEdges *PEroot, struct ListOfEdges *VPEroot,
    struct RawLinear *NLroot, struct ThePolys * Polyroot);
extern void PerformEdgeMatchChecks(char * prompt, int cindex,struct RawLinear *root,double minx,double miny,double maxx,double maxy, double multiplier,
   int NorthCount, int SouthCount, int EastCount, int WestCount,
    struct RawAreal *Aroot, struct RawBridge *Broot, struct RawPoint *Proot, struct ListOfEdges *PEroot, struct ListOfEdges *VPEroot,
    struct RawLinear *NLroot, struct ThePolys * Polyroot);
extern void FindApplicableNeighborFeatures(int cindex, FILE *ptsin, double minx, double maxx, double miny, double maxy,
                                       int LoadAreas, int LoadLines, int LoadPoints, int LoadTertiary);
extern void PerformAllGeomChecks(char * prompt, int cindex,struct RawLinear *Lroot,      double minx,double miny,double maxx,double maxy, double multiplier,
     struct RawAreal *Aroot, struct RawBridge *Broot, struct RawPoint *Proot, struct ListOfEdges *PEroot,
     struct ListOfEdges *VPEroot, struct RawLinear *NLroot, struct ThePolys * Polyroot, int SzPC, int SzPW, int IndexLimit);
extern void PerformLinearOverUnderChecks(char * prompt, int cindex,struct RawLinear *root,
    double minx,double miny,double maxx,double maxy, double multiplier,
    int NorthCount, int SouthCount, int EastCount, int WestCount,
    struct RawAreal *Aroot, struct RawAreal *NeighborARoot, struct RawBridge *Broot, struct RawPoint *Proot, struct ListOfEdges *PEroot, struct ListOfEdges *VPEroot,
    struct RawLinear *NLroot, struct ThePolys * Polyroot);
extern void PruneCheckedLinePairs(int Limit,int index);
extern void FreeCheckedLinePairs(int index);
extern void PruneCheckedAreaPairs(int Limit, int index);
extern void PerformMoreLinearRelatedChecks(char * prompt, int cindex,struct RawLinear *root,double minx,double miny,double maxx,double maxy, double multiplier,
    int NorthCount, int SouthCount, int EastCount, int WestCount,
    struct RawAreal *Aroot, struct RawBridge *Broot, struct RawPoint *Proot, struct ListOfEdges *PEroot, struct ListOfEdges *VPEroot,
    struct RawLinear *NLroot, struct RawAreal *NAroot, struct ThePolys * Polyroot, int SzPC, int SzPW, int IndexLimit);
extern void PerformLinearRelatedChecks(char * prompt, int cindex,struct RawLinear *root,double minx,double miny,double maxx,double maxy, double multiplier,
    int NorthNeighborCount, int SouthNeighborCount, int EastNeighborCount, int WestNeighborCount,
    struct RawAreal *Aroot, struct RawBridge *Broot, struct RawPoint *Proot, struct ListOfEdges *PEroot, struct ListOfEdges *VPEroot,
    struct RawLinear *NLroot, struct RawAreal *NAroot,struct ThePolys * Polyroot, int SzPC, int SzPW, int IndexLimit);
extern void PerformRangeLimitedEdgeMatchChecks(char * prompt, int cindex,
    struct RawLinear *Lroot,double minx,double miny,double maxx,double maxy, double multiplier,
    int NorthCount, int SouthCount, int EastCount, int WestCount,
    struct RawAreal *Aroot, struct RawBridge *Broot, struct RawPoint *Proot, struct ListOfEdges *PEroot, struct ListOfEdges *VPEroot,
    struct RawLinear *NLroot, struct ThePolys * Polyroot);
extern void PruneLandCoverErrorList(double xmin, double xmax, double ymin, double ymax);
extern int MatchAreaEdge(double x1, double y1, double z1, double x2, double y2, double z2,
                         double UniqueID, int cnumb, int idn, int Sindex, int Lindex);
extern void FreeCheckedAreaPairs(int index);
extern void PrintAndFreeCTC(int cindex);
extern void PerformArealRelatedChecks(char * prompt, int cindex,struct RawAreal *root,
    double minx,double miny,double maxx,double maxy, double multiplier,
    int NorthCount, int SouthCount, int EastCount, int WestCount,
    struct RawLinear *Lroot, struct RawBridge *Broot, struct RawPoint *Proot, struct ListOfEdges *PEroot,
     struct RawAreal * NeighborARoot, int IndexLimit, int SzPC, int SzPW);

/** functions in moregeomchecks.c *****/
extern void PerformTransitiveChecks(char * prompt, int cindex,struct RawAreal *root,
    double minx,double miny,double maxx,double maxy, double multiplier,
    int  NorthCount, int SouthCount, int EastCount, int WestCount,
    struct RawLinear *Lroot, struct RawBridge *Broot, struct RawPoint *Proot, struct ListOfEdges *PEroot,
    struct RawAreal * NeighborARoot, int IndexLimit, int SzPC, int SzPW);
extern void PropagateTransitiveCounters(rb_red_blk_tree* tree, rb_red_blk_node* x);
extern char * FindCONFLATEsourceFile(int localid, int * entry);
extern void PerformConflationAnalyses(char * prompt, int cindex,struct RawLinear *root,
                   double minx,double miny,double maxx,double maxy, double multiplier,
                    int NorthCount, int SouthCount, int EastCount, int WestCount,
                    struct RawAreal *Aroot, struct RawBridge *Broot, struct RawPoint *Proot, struct ListOfEdges *PEroot,
                    struct ListOfEdges *VPEroot, struct RawLinear *NLroot, struct ThePolys * Polyroot,
                     int SzPC, int SzPW, int IndexLimit);
extern void FwriteStatsTreeInorder(rb_red_blk_tree* tree, rb_red_blk_node* x, FILE *fout, FILE *Source_filesin);
extern void AddPseudoNodesAtIntersections(struct RawLinear **Lroot, struct RawAreal **Aroot, struct RawPoint *Proot,
                        int compositeindex, int checkinstance,
                        double MIX, double MIY, double MAX, double MAY);
extern void InitConflateStatsCapture(void);
extern void FreeConflateStatsCapture(int AllOrLMonly);
extern void InitializeBucketsOfTransNets(void);
extern void AddEdgesToTransNetwork(struct RawLinear *Lroot, struct RawAreal *Aroot, struct RawPoint *Proot,
                       int compositeindex, int checkinstance,
                        int  NorthCount, int SouthCount, int EastCount, int WestCount,
                        double MIX, double MIY, double MAX, double MAY, int PseudoAdded);
void CheckForBndryRemoval(int cindex, struct RawLinear *Lroot, struct RawAreal *Aroot, struct RawPoint *Proot,
                              int  NorthCount, int SouthCount, int EastCount, int WestCount);
extern void AddPseudoNodeFromOuterToInnerRings(struct RawAreal *Aroot, int compositeindex);
extern void RemoveInnerRingPseudoNode(struct RawAreal *Aroot, int compositeindex);
extern void FreeAndWriteTransNetStructs(void);

/** function in TTformat.c ****/
extern int TTF_StdStrComp(const void * a, const void * b);



/*** global variables referenced in this file only ***/
struct PolyAsRead PolyFromFile;
struct ArealAsRead ArealFromFile;
struct RawAreal *TgtAroot;
struct LinearAsRead LinearFromFile;
struct RawLinear *TgtLroot;
struct PointAsRead PointFromFile;
struct RawPoint *TgtProot;
struct BridgeAsRead BridgeFromFile;
struct SCCdata * SCCtable = NULL;
struct AttributeList *AttrAsRead;
struct LongList * LongListRoot = NULL;
struct TearErrorSortList * TearRoot = NULL;
/**struct LongSkipList *SkipList; **/
struct ObjectLookup * PolyTable;
struct ObjectLookup * ArealTable;
struct ObjectLookup * LinearTable;
struct ObjectLookup * PointTable;
struct ObjectLookup * BridgeTable;
struct ObjectLookup * ModelPolyTable;
struct reflist *BillBoardChecks;
struct reflist *BillBoardChecks2;
struct ThePolys * PolyRoot = NULL;
struct CrossWalk  *CrsWlk = NULL;  /** int array; cross walk between long list attributes and ModelNames Unique SCC/Name array**/
struct MoreAttrErrIndices *MAEc, *MAEn;
struct CloneArealAsRead
   {
   double *x;
   double *y;
   double *z;
   int numverts;
   } ArealForAreaCalculation;
int * Areal1ForIntersections;
int * Areal2ForIntersections;
int * Areal1Shared = NULL;
int * Areal2Shared = NULL;
int * MetaDataAttrCodes = NULL;
int NumMetaDataCodes = 0;
int NeedIntersectingArealCalc = 0;
int NeedSliverGuide = 0;
int FeatsInNet = 0;
int FeatsAddedToNet = 0;
int  NetFeatureMin = 0; /** if == 0, all nets displayed, if == 101, any net touching the boundary will NOT be displayed,
                           else if >= 1, nets with # features <= NetFeatureMin and touching a project boundary
                            are discarded  (not displayed)   ***/
struct MultipartObj
   {
   int featureid;
   int used;
   int counted;
   int numverts;
   double *x;
   double *y;
   double *z;
   struct MultipartObj * next;
   }  *MultiLineRoot, *MultiPointRoot, *MultiAreaRoot, *mpoc, *mpon;
int NeedAreaCalculation = 0;
int ChkAreaClosure = 0;
double LAEminx,LAEminy,LAEmaxx,LAEmaxy;
double CF_LAEminx, CF_LAEminy, CF_LAEmaxx, CF_LAEmaxy;


struct LODdisplay *LODindex = NULL;
int NumLODbands = 0;
int MaxGridsPerRegion = 0;
struct RawGrid * RGrid = NULL;
int UseRGridStruct = 0; 
int GridDimension = 0;
int GridNowLoaded = -1;
int LoadedGridRows = 0;
int LoadedGridCols = 0;
int LoadedGridMres = 0;
int BytesPerGridValue = 8;
int GridFileInUse = -10;
int AttributionAnalysisComplete = 0;
int MaxInputFileNumber = 0;
int RemoveDupsBeforeCheck = 1;
int DrawHighlightedOnly = 0;
int *PF_Lindex;
int *PF_Iindex;
int NumberPF = -1;

double MinSurfXcoord;
double MaxSurfXcoord;
double MinSurfYcoord;
double MaxSurfYcoord;
extern double MinXcoord;
extern double MaxXcoord;
extern double MinYcoord;
extern double MaxYcoord;
double MinNativeX;
double MinNativeY;
double MinLAEx, MinLAEy;
/**** below declared in SEEIT_API,c ***/
extern int UseDMScoordinates;

double HalfPI = PIvalue / 2.0;
double DistTolerance, SqDistTolerance;

int SzSkip = sizeof(struct LongSkipList);
int SzLAE = sizeof(struct ListOfArealEdges);
char MessageLine[500];
char BndAttrMismatch[500];

int OutputFilesInUse = 0;
int MemoryAllocated = 0;
int IgnoreDrawingSettings = 0;
int AlwaysUseEuclidean = 0;
/*****/
int MaxArealVerts = 0;
/*****/
int SACfull;
int TotalSCC = 0;
int NumberOfGrids = 0;
long int TotalPolygons = 0;
int OnlyUsePolysForElevLookup = 0;

double ShadedIp = 1.0;
double ShadedKd = 0.95;
double PTL_Dist_Xi, PTL_Dist_Yi;  

/** these are used in interface3.c to summarize route planning problems by printing to the console **/
int RouteProblem1 = 0; /** route planner called with no POI loaded ***/
int RouteProblem2 = 0; /** route planner caller with no Start and Goal for Network **/
int RouteProblem3 = 0; /** route planner called with start / goal too far from specified network node **/
int RouteProblem4 = 0; /** no route exists in specified network from specified start to specified goal **/
int RoutePlanningAttempts = 0; /** number of times attempted to plan a route **/


int NetworkNameSize = 0;
char ** NetworkNames = NULL;
char * infile = NULL;
char * SCCdefsfile = NULL;
char * bridgesin = NULL;
char * bridgetablein = NULL;
char * MPtablein = NULL;
char * MPdatain = NULL;
char * modelsin = NULL;
char * modeltablein = NULL;
char * arealtablein = NULL;
char * arealsin = NULL;
char * arealholesin = NULL;
char * gridtablein = NULL;
char * gridsin = NULL;
char * gridheaderin = NULL;
char * IDproblems = NULL;
char * gridtopimage = NULL;
char * lineartablein = NULL;
char * linearsin = NULL;
char * pointtablein = NULL;
char * pointsin = NULL;
char * tablein = NULL;
char * metadata = NULL;
char * LODbands = NULL;
char * sccuniquelist = NULL;
char * scctablefile = NULL;
char * fidtablefile = NULL;
char * attrgigs = NULL;
char * StoLmapping = NULL;
char * ConflateSourceFiles = NULL;

char * binsmrylog = NULL;
char * networksfound = NULL;

char unsortlog[500];
char errtypelog[500];
char billboardlog[500];
char CDFlog[500];


FILE *fin = NULL;
FILE *unsortout = NULL;
FILE *billbout = NULL;
FILE *billbout2 = NULL;
FILE *errtypeinout = NULL;
FILE *binsmryout = NULL;
FILE *smryout = NULL;
FILE *CDFout = NULL;


int VTEARdebug = 0;
int VTEARdebud_2 = 0;
int VTEARdebud_3 = 0;
int InternalIDdebug = 0;
int EdgeCount = 0;
int VertEdgeCount = 0;
int InsertCount = 0;
int AdjEdgeCount = 0;
int debuglarge = 0;
/***int POLY_R,POLY_A,POLY_F;***/

/********** end of globals used in this file only ***********/

/********** global variables ***********/
int BillBoardPtsWritten = 0;             /** if never wrote anything to the file, this will be zero **/
extern int CoordinateSystem;            /** a flag on how to handle, print coord system **/
int VerboseInfoMode = 1;             /** for get info - print all SAC with object if == 1 **/
                                     /** if == 2, then just print list of EAC without values ***/
                                     /** if == 0, do not print attributes ***/
int VerboseVertexMode = 0;           /** to print all object vertices, regardless of # of vertices **/
extern int VertexPrintLimit;           /** limit on number of vertices to be printed ***/
double ContourInterval = 50.0;       /** meters between adjacent contour intervals, approximate **/
unsigned char DrawContourLines = 0;  /** toggle, calc and draw them or not  **/

/*** for use with the MASKMONO inspection  ****/
struct FlowDirection
   {
   char * PointFlow;
   int NumX;
   int NumY;
   int Lindex;
   int Cindex;
   int GridHeadIndex;
   double Xspacing;
   double Yspacing;
   } FlowFlags;

extern double Xtranslation ;
extern double Ytranslation ;

/** below, tolerance for most == numeric checks; should be available for user set **/
double SMIDGE = 0.005;
double NEGSMIDGE = -0.005;
double SMIDGE2 = 0.00005;


/****** global variables referenced in markers.c ****/
struct StaticModel * ModelRoot = NULL;
struct StampModel * StampRoot = NULL;
struct LindexLookup * LindexTable = NULL;
struct LindexLookup * FIDindexTable = NULL;


/****** global variables to share as listed in share.h ****/

int AbsoluteAccuracy = 0;
int SignificantDecimals = 3;

double RegionSize;
unsigned long int fileoffset = 2000000000;

unsigned long int NUMBEROFCONDITIONS;

/*** following struct types are declared in share.h **/
extern struct ErrorTable ErrorLookup[]; /** var declared and storage allocated in errors.c **/
extern struct CloneErrorTable *CloneErrorLookup;  /** declared in errors.c **/
struct ProfileList * ProfileRoot = NULL;
struct ProfileList * DrawProfileRoot = NULL;
struct FilterList * FilterRoot = NULL;
struct ModelNames * MdlNames = NULL;
struct AttrList * MdlNames2 = NULL;
struct AttributionErrors *AttrErr = NULL; /** array of text messages on attribution errors **/
int NumAttrErr = 0;

int NumberOfModels = 0;
int NumberOfAttributesEntries = 0;
int OSIDE_LatLon_Count = 0;
int OSIDE_LL_Limit = 5000;

char indirectory[500];
char outdirectory[500];

extern char outsumdirectory[1000];

int MinXindex = 500;
int MaxXindex = 0;
int MinYindex = 500;
int MaxYindex = 0;

long int PolyThreshold = 500; /* limit on polys in a single patch */


/*** RB tree variables ***/
rb_red_blk_node * RB_newNode;
rb_red_blk_tree * RB_tree;
rb_red_blk_tree * RB_LC_tree;
rb_red_blk_tree * Check_RB_Tree;
rb_red_blk_tree * Trans_RB_Tree;
rb_red_blk_tree * Stats_RB_Tree;
stk_stack * RB_enumResult;
int RB_newKey; 
double RB_newKey2;
int * RB_newInt;
double * RB_newDbl;




/****************** end of shared global variables **********************/




/**** function prototypes */

double TriangleSurfaceArea(double x[3],double y[3],double z[3]);
double TriangleXYsurfaceArea(double x[3], double y[3]);
void MakeActiveChecks(int FreeMemoryOnly);
int PointOnLineSegment(double px,double py,double x1,double y1,double x2,double y2, double slack);
double Distance(double x1,double y1,double x2,double y2);
double EuclideanDistance(double x1,double y1,double x2,double y2);
double PointToLineDist2D(double xj,double yj,double xk,double yk,double xl,double yl);
int NotSameString(int a, int b);
void FwriteTwoObjects(int keyval, int Cnumber,
                  int IDN1, char gform1, int Lindex1, double localid1, int index1, double radius1, double height1,
                  int numverts1, double *x1, double *y1,  double *z1,
                  int IDN2, char gform2, int Lindex2, double localid2, int index2, double radius2, double height2,
                  int numverts2, double *x2, double *y2,  double *z2);
int NearlyEqual(double v1, double v2);
int CombinedCheckApplies(int IDlookupkey,int Instance, int TgtCheckType, int LongListIndx, int ShortListIndx,
                         int config, int stratum, int domain, int *p1, int *p2, int *p3);

struct ProfileList * AssembleDrawProfilePoints(double x1,double y1,double x2,double y2,
   double *minElev,double *maxElev,int SingleList);
void GetLOSendPoint(double xo,double yo,double *xe,double *ye,
    double radius, double azimuth);
struct ToBeLoaded * LoadRegionIfNecessary(struct ToBeLoaded *Loaded, int index1, int index2,
   double x1,double y1,double x2,double y2);
struct ToBeLoaded * IdentifyLoadRegions(double x1,double y1,double x2,double y2);
void FwritePointAndObject(int keyval, int Cnumber, double pointX, double pointY, double pointZ, int pointIDN,
                                  int index1, char gform1, int Lindex, double localid, int IDN1, double radius1, double height1,
                                  double *x1, double *y1, double *z1, int numverts1);
int DrawSubnetPathAndFeatures(char * fname, int TgtCheck, int TgtCnumber, int TgtIndexStart, int TgtIndexStop);

void IntDest(void * a)
{
   free((int *) a);
}

int DblComp(const void * a, const void * b)
{
   if( * (double *) a > * (double *) b)
      return(1);
   else if( * (double *) a < * (double *) b)
       return(-1);
   else
      return(0);
}


int IntComp(const void * a, const void * b)
{
   if( * (int *) a > * (int *) b) 
      return(1);
   else if( * (int *) a < * (int *) b)
       return(-1);
   else
      return(0);
}


void IntPrint(const void * a)
{
   printf("%d", * (int *) a);
}




void InfoPrint(void * a)
{
   return;
}

void InfoDest(void * a)
{
struct ConditionCollection *C;
struct EdgeIntervals *Ec, *Ep;

   if(a == NULL)
      return;
   C = (struct ConditionCollection *) a;

   if(C->x != NULL)
      free(C->x);
   if(C->y != NULL)
      free(C->y);
   if(C->z != NULL)
      free(C->z);
   Ec = C->index_from_to;
   while(Ec != NULL)
      {
      Ep = Ec;
      Ec = Ec->next;
      free(Ep);
      }
   free(C);
   
   return;
}


void ConStatsStrDest(void * a)
{
   free((char *) a);
   return;
}



void ConStatsInfoDest(void * a)
{
struct ConflateStats *cs;
   cs = (struct ConflateStats *) a;
   free(cs);

   return;
}


void TransInfoDest(void * a)
{
struct TransitiveCollection *TC;
struct DirectConnect *Cc, *Cp;

   TC = (struct TransitiveCollection *) a;

   free(TC->x);
   free(TC->y);
   free(TC->z);
   Cc = TC->connect;
   while(Cc != NULL)
      {
      Cp = Cc;
      Cc = Cc->next;
      free(Cp);
      }
   free(TC);

   return;
}



void EdgeInfoDest(void * e)
{
struct RB_Edgelist *ec, *en;

   ec = (struct RB_Edgelist *) e;
   while(ec != NULL)
      {
      en = ec;
      ec = ec->next;
      free(en);
      }

   return;
}

void LC_EdgeInfoDest(void * e)
{
struct RB_LC_Edgelist *ec, *en;

   ec = (struct RB_LC_Edgelist *) e;
   while(ec != NULL)
      {
      en = ec;
      ec = ec->next;
      free(en);
      }

   return;
}

/**** end RB-tree helper functions ***/





void * SafeMalloc(size_t size) {
  void * result;

  if ( (result = malloc(size)) ) { /* assignment intentional */
    return(result);
  } else {
    printf("memory overflow: malloc failed in SafeMalloc.");
    printf("  Exiting Program.\n");
    exit(-1);
    return(0);
  }
}
/*  NullFunction does nothing it is included so that it can be passed */
/*  as a function to RBTreeCreate when no other suitable function has */
/*  been defined */

void NullFunction(void * junk) { ; }



stk_stack * StackCreate() {
  stk_stack * newStack;
  
  newStack=(stk_stack *) SafeMalloc(sizeof(stk_stack));
  newStack->top=newStack->tail=NULL;
  return(newStack);
}


void StackPush(stk_stack * theStack, DATA_TYPE newInfoPointer) {
  stk_stack_node * newNode;

  if(!theStack->top) {
    newNode=(stk_stack_node *) SafeMalloc(sizeof(stk_stack_node));
    newNode->info=newInfoPointer;
    newNode->next=theStack->top;
    theStack->top=newNode;
    theStack->tail=newNode;
  } else {
    newNode=(stk_stack_node *) SafeMalloc(sizeof(stk_stack_node));
    newNode->info=newInfoPointer;
    newNode->next=theStack->top;
    theStack->top=newNode;
  }
  
}






rb_red_blk_tree* RBTreeCreate( int (*CompFunc) (const void*,const void*),
			      void (*DestFunc) (void*),
			      void (*InfoDestFunc) (void*),
			      void (*PrintFunc) (const void*),
			      void (*PrintInfo)(void*)) {
  rb_red_blk_tree* newTree;
  rb_red_blk_node* temp;

  newTree=(rb_red_blk_tree*) SafeMalloc(sizeof(rb_red_blk_tree));
  newTree->Compare=  CompFunc;
  newTree->DestroyKey= DestFunc;
  newTree->PrintKey= PrintFunc;
  newTree->PrintInfo= PrintInfo;
  newTree->DestroyInfo= InfoDestFunc;

  /*  see the comment in the rb_red_blk_tree structure in red_black_tree.h */
  /*  for information on nil and root */
  temp=newTree->nil= (rb_red_blk_node*) SafeMalloc(sizeof(rb_red_blk_node));
  temp->parent=temp->left=temp->right=temp;
  temp->red=0;
  temp->key=0;
  temp=newTree->root= (rb_red_blk_node*) SafeMalloc(sizeof(rb_red_blk_node));
  temp->parent=temp->left=temp->right=newTree->nil;
  temp->key=0;
  temp->red=0;
  return(newTree);
}


void LeftRotate(rb_red_blk_tree* tree, rb_red_blk_node* x) {
  rb_red_blk_node* y;
  rb_red_blk_node* nil=tree->nil;

  y=x->right;
  x->right=y->left;

  if (y->left != nil) y->left->parent=x; /* used to use sentinel here */
  
  y->parent=x->parent;   

  if( x == x->parent->left) {
    x->parent->left=y;
  } else {
    x->parent->right=y;
  }
  y->left=x;
  x->parent=y;

}



void RightRotate(rb_red_blk_tree* tree, rb_red_blk_node* y) {
  rb_red_blk_node* x;
  rb_red_blk_node* nil=tree->nil;

  x=y->left;
  y->left=x->right;

  if (nil != x->right)  x->right->parent=y; /*used to use sentinel here */

  x->parent=y->parent;
  if( y == y->parent->left) {
    y->parent->left=x;
  } else {
    y->parent->right=x;
  }
  x->right=y;
  y->parent=x;

}


void TreeInsertHelp(rb_red_blk_tree* tree, rb_red_blk_node* z) {
  /*  This function should only be called by InsertRBTree (see above) */
  rb_red_blk_node* x;
  rb_red_blk_node* y;
  rb_red_blk_node* nil=tree->nil;
  
  z->left=z->right=nil;
  y=tree->root;
  x=tree->root->left;
  while( x != nil) {
    y=x;
    if (1 == tree->Compare(x->key,z->key)) { /* x.key > z.key */
      x=x->left;
    } else { /* x,key <= z.key */
      x=x->right;
    }
  }
  z->parent=y;
  if ( (y == tree->root) ||
       (1 == tree->Compare(y->key,z->key))) { /* y.key > z.key */
    y->left=z;
  } else {
    y->right=z;
  }

}



rb_red_blk_node * RBTreeInsert(rb_red_blk_tree* tree, void* key, void* info)
{
  rb_red_blk_node * y;
  rb_red_blk_node * x;
  rb_red_blk_node * newNode;

  x=(rb_red_blk_node*) SafeMalloc(sizeof(rb_red_blk_node));
  x->key=key;
  x->info=info;


  TreeInsertHelp(tree,x);
  newNode=x;
  x->red=1;
  while(x->parent->red) { /* use sentinel instead of checking for root */
    if (x->parent == x->parent->parent->left) {
      y=x->parent->parent->right;
      if (y->red) {
	x->parent->red=0;
	y->red=0;
	x->parent->parent->red=1;
	x=x->parent->parent;
      } else {
	if (x == x->parent->right) {
	  x=x->parent;
	  LeftRotate(tree,x);
	}
	x->parent->red=0;
	x->parent->parent->red=1;
	RightRotate(tree,x->parent->parent);
      } 
    } else { /* case for x->parent == x->parent->parent->right */
      y=x->parent->parent->left;
      if (y->red) {
	x->parent->red=0;
	y->red=0;
	x->parent->parent->red=1;
	x=x->parent->parent;
      } else {
	if (x == x->parent->left) {
	  x=x->parent;
	  RightRotate(tree,x);
	}
	x->parent->red=0;
	x->parent->parent->red=1;
	LeftRotate(tree,x->parent->parent);
      } 
    }
  }
  tree->root->left->red=0;
  return(newNode);

}

  
rb_red_blk_node* TreeSuccessor(rb_red_blk_tree* tree,rb_red_blk_node* x) { 
  rb_red_blk_node* y;
  rb_red_blk_node* nil=tree->nil;
  rb_red_blk_node* root=tree->root;

  if (nil != (y = x->right)) { /* assignment to y is intentional */
    while(y->left != nil) { /* returns the minium of the right subtree of x */
      y=y->left;
    }
    return(y);
  } else {
    y=x->parent;
    while(x == y->right) { /* sentinel used instead of checking for nil */
      x=y;
      y=y->parent;
    }
    if (y == root) return(nil);
    return(y);
  }
}


rb_red_blk_node* TreePredecessor(rb_red_blk_tree* tree, rb_red_blk_node* x) {
  rb_red_blk_node* y;
  rb_red_blk_node* nil=tree->nil;
  rb_red_blk_node* root=tree->root;

  if (nil != (y = x->left)) { /* assignment to y is intentional */
    while(y->right != nil) { /* returns the maximum of the left subtree of x */
      y=y->right;
    }
    return(y);
  } else {
    y=x->parent;
    while(x == y->left) { 
      if (y == root) return(nil); 
      x=y;
      y=y->parent;
    }
    return(y);
  }
}


void InorderTreePrint(rb_red_blk_tree* tree, rb_red_blk_node* x) {
  rb_red_blk_node* nil=tree->nil;
  rb_red_blk_node* root=tree->root;
  if (x != tree->nil) {
    InorderTreePrint(tree,x->left);
    if(x->info != NULL)
       {
       printf("info=");
       tree->PrintInfo(x->info);
       }
    printf("  key="); 
    tree->PrintKey(x->key);
    printf("  l->key=");
    if( x->left == nil) printf("NULL"); else tree->PrintKey(x->left->key);
    printf("  r->key=");
    if( x->right == nil) printf("NULL"); else tree->PrintKey(x->right->key);
    printf("  p->key=");
    if( x->parent == root) printf("NULL"); else tree->PrintKey(x->parent->key);
    printf("  red=%i\n",x->red);
    InorderTreePrint(tree,x->right);
  }
}




void TreeDestHelper(rb_red_blk_tree* tree, rb_red_blk_node* x) {
  rb_red_blk_node* nil=tree->nil;
  if (x != nil) {
    TreeDestHelper(tree,x->left);
    TreeDestHelper(tree,x->right);
    tree->DestroyKey(x->key);
    if(x->info != NULL)
       tree->DestroyInfo(x->info);
    free(x);
  }
}



void RBTreeDestroy(rb_red_blk_tree* tree) {
  TreeDestHelper(tree,tree->root->left);
  free(tree->root);
  free(tree->nil);
  free(tree);
}



  
rb_red_blk_node* RBExactQuery(rb_red_blk_tree* tree, void* q) {
  rb_red_blk_node* x=tree->root->left;
  rb_red_blk_node* nil=tree->nil;
  int compVal;
  /***if(tree == nil) return(0); ***/
  if (x == nil) return(0);
  compVal=tree->Compare(x->key,(int*) q);
  while(0 != compVal) {/*assignemnt*/
    if (1 == compVal) { /* x->key > q */
      x=x->left;
    } else {
      x=x->right;
    }
    if ( x == nil) return(0);
    compVal=tree->Compare(x->key,(int*) q);
  }
  return(x);
}



void RBDeleteFixUp(rb_red_blk_tree* tree, rb_red_blk_node* x)
{
  rb_red_blk_node* root=tree->root->left;
  rb_red_blk_node* w;

  while( (!x->red) && (root != x)) {
    if (x == x->parent->left) {
      w=x->parent->right;
      if (w->red) {
	w->red=0;
	x->parent->red=1;
	LeftRotate(tree,x->parent);
	w=x->parent->right;
      }
      if ( (!w->right->red) && (!w->left->red) ) { 
	w->red=1;
	x=x->parent;
      } else {
	if (!w->right->red) {
	  w->left->red=0;
	  w->red=1;
	  RightRotate(tree,w);
	  w=x->parent->right;
	}
	w->red=x->parent->red;
	x->parent->red=0;
	w->right->red=0;
	LeftRotate(tree,x->parent);
	x=root; /* this is to exit while loop */
      }
    } else { 
      w=x->parent->left;
      if (w->red) {
	w->red=0;
	x->parent->red=1;
	RightRotate(tree,x->parent);
	w=x->parent->left;
      }
      if ( (!w->right->red) && (!w->left->red) ) { 
	w->red=1;
	x=x->parent;
      } else {
	if (!w->left->red) {
	  w->right->red=0;
	  w->red=1;
	  LeftRotate(tree,w);
	  w=x->parent->left;
	}
	w->red=x->parent->red;
	x->parent->red=0;
	w->left->red=0;
	RightRotate(tree,x->parent);
	x=root; /* this is to exit while loop */
      }
    }
  }
  x->red=0;

}



void RBDelete(rb_red_blk_tree* tree, rb_red_blk_node* z)
{
  rb_red_blk_node* y;
  rb_red_blk_node* x;
  rb_red_blk_node* nil=tree->nil;
  rb_red_blk_node* root=tree->root;

  y= ((z->left == nil) || (z->right == nil)) ? z : TreeSuccessor(tree,z);
  x= (y->left == nil) ? y->right : y->left;
  if (root == (x->parent = y->parent)) { /* assignment of y->p to x->p is intentional */
    root->left=x;
  } else {
    if (y == y->parent->left) {
      y->parent->left=x;
    } else {
      y->parent->right=x;
    }
  }
  if (y != z) { /* y should not be nil in this case */

    /* y is the node to splice out and x is its child */

    if (!(y->red)) RBDeleteFixUp(tree,x);
  
    tree->DestroyKey(z->key);
    tree->DestroyInfo(z->info);
    y->left=z->left;
    y->right=z->right;
    y->parent=z->parent;
    y->red=z->red;
    z->left->parent=z->right->parent=y;
    if (z == z->parent->left) {
      z->parent->left=y; 
    } else {
      z->parent->right=y;
    }
    free(z); 
  } else {
    tree->DestroyKey(y->key);
    tree->DestroyInfo(y->info);
    if (!(y->red)) RBDeleteFixUp(tree,x);
    free(y);
  }
  
}



stk_stack* RBEnumerate(rb_red_blk_tree* tree, void* low, void* high) {
  stk_stack* enumResultStack;
  rb_red_blk_node* nil=tree->nil;
  rb_red_blk_node* x=tree->root->left;
  rb_red_blk_node* lastBest=nil;

  enumResultStack=StackCreate();
  while(nil != x) {
    if ( 1 == (tree->Compare(x->key,high)) ) { /* x->key > high */
      x=x->left;
    } else {
      lastBest=x;
      x=x->right;
    }
  }
  while ( (lastBest != nil) && (1 != tree->Compare(low,lastBest->key))) {
    StackPush(enumResultStack,lastBest);
    lastBest=TreePredecessor(tree,lastBest);
  }
  return(enumResultStack);
}


int PointOnQuarterDegreeBoundary(double px, double py, double tolerance)
{
double temp, temp1, temp2, temp3;
int truncated;
int answer = 0;

   if(Ctype() == 1)
      {
      temp = py / 100000.0 + Ytranslation;
      if(temp >= 0)
         temp1 = temp + 0.125;
      else
         temp1 = temp - 0.125;
      temp1 = temp1 / 0.25;
      truncated = (int) temp1;
      temp2 = (double) truncated * 0.25; /*** should be the closest 1/4 degree boundary ***/

      temp1 = (temp2 - Ytranslation) * 100000.0; /** translate that boundary into GAIT coords ***/
      if(temp1 > py)
         temp3 = temp1 - py;
      else
         temp3 = py - temp1;
      temp3 = Distance(px,py,px,py+temp3); /** just looking at difference isn't quite accurate enough -
                                               answers don't match distance tool results at some longitudes ***/
      if(temp3 <= tolerance)
         answer = 1;

      if(answer == 0)
         {
         temp = px / 100000.0 + Xtranslation;
         if(temp >= 0)
            temp1 = temp + 0.125;
         else
            temp1 = temp - 0.125;
         temp1 = temp1 / 0.25;
         truncated = (int) temp1;
         temp2 = (double) truncated * 0.25;

         temp1 = (temp2 - Xtranslation) * 100000.0;
         if(temp1 > px)
            temp3 = temp1 - px;
         else
            temp3 = px - temp1;

         temp3 = Distance(px,py,px+temp3,py);
         if(temp3 <= tolerance)
            answer = 1;
         }

      }
   return(answer);
}


double RoundToNearestPartialDegree(int XorY, double ActualCoord, double increment)
{
double MyBelow, MyAbove, Dif1, Dif2;
double answer, temp, RealCoord;
double TranslationToUse;
int itemp;

   if(XorY == 1) /*** working the x coordinate ***/
      {
      TranslationToUse = Xtranslation;
      }
   else /*** must be the Y coordinate ...   ****/
      {
      TranslationToUse = Ytranslation;
      }

   RealCoord = temp = ActualCoord / 100000.0 + TranslationToUse;
   itemp = (int) temp;
   temp = (double) itemp;
   if(temp < RealCoord)
      {
      MyAbove = temp + increment;
      while(MyAbove < RealCoord)
         MyAbove += increment;
      MyBelow = MyAbove - increment;
      Dif1 = MyAbove - RealCoord;
      Dif2 = RealCoord - MyBelow;
      if(Dif1 < Dif2)
         answer = (MyAbove - TranslationToUse) * 100000.0;
      else
         answer = (MyBelow - TranslationToUse) * 100000.0;
      }
   else if(temp > RealCoord)
      {
      MyBelow = temp - increment;
      while(MyBelow > RealCoord)
         MyBelow -= increment;
      MyAbove = MyBelow + increment;
      Dif1 = MyAbove - RealCoord;
      Dif2 = RealCoord - MyBelow;
      if(Dif1 < Dif2)
         answer = (MyAbove - TranslationToUse) * 100000.0;
      else
         answer = (MyBelow - TranslationToUse) * 100000.0;
      }
   else /*** coord must be right on degree line already ****/
      answer = ActualCoord;

   return(answer);
}



double RoundToNearestWholeDegree(int XorY, double inval)
{
double answer;
int ianswer;

   answer = inval;
   if((Ctype() == 1) && (XorY > 0) && (XorY < 3))
      {
      if(XorY == 1)
         answer = answer / 100000.0 + Xtranslation;
      else if(XorY == 2)
         answer = answer / 100000.0 + Ytranslation;

      if(answer<0)
	  {
	    ianswer = (int)(answer - 0.5);
	  }
      else
	  {
	    ianswer = (int)(answer + 0.5);
	  }

 
     if(XorY == 1)
      {
        answer = (double) ianswer;
        answer = (answer - Xtranslation) * 100000.0;
      }
     else if(XorY == 2)
      {
        answer = (double) ianswer;
        answer = (answer - Ytranslation) * 100000.0;
      }
        
   }
       
   return(answer);

}


/*** should only be used for geodetic coords from NGA ***/
double SixPointFiveRound(int xyz, double inval)
{
double outval;
int tempval;
int tempV;

   outval = inval;

   if(Ctype() == 1)
      {
      if(xyz == 1)
         inval = inval / 100000.0 + Xtranslation;
      else if(xyz == 2)
         inval = inval / 100000.0 + Ytranslation;
/*** make sure we are working with just the fractional part before the multiply by 1000000.0 - avoid any
 *    overflow errors *****/
      tempV = (int) inval;
      inval = inval - (double) tempV;

      tempval = (int) (inval * 1000000.0);
      outval = (inval * 1000000.0) - (double) tempval;

      if(outval >= 0.5)
          outval = (double) (tempval * 10 + 5);
      else
          outval = (double) (tempval * 10);

      outval = outval / 10000000.0;

      outval = outval + (double) tempV;

      if(xyz == 1)
         outval = (outval - Xtranslation) * 100000.0;
      else if(xyz == 2)
         outval = (outval - Ytranslation) * 100000.0;
      }
   return(outval);
}


int IsSentinelZvalue(double v, int CountNUNANPOvaluesAs2D)
{
int answer = 0;
int ti;
double td;

   if(tempis2D(v) == 0)
      {
      if((ATTRTYPE_ANY_TDS() > 0) || (ATTRTYPE_ANY_GGDM() > 0)) /*** TDS***/ /*** GGDM ***/
         {
         if(v == -50000.0)
            answer = 1;
         }
      else
         {
         if(CountNUNANPOvaluesAs2D > 0)  /*** then NUNANPO values are allowed ***/
            {
            if((-32768 <= v) && (v <= -32764))
               {
               ti = (int) v;
               td = (double) ti;
               if(td == v)
                  answer = 1;
               }
            }
         if(v == -50000.0)
            answer = 1;
         }
      }
   else
      answer = 1;

   return(answer);
}


int IsFlakeyNUNANPOvalue(char *in_strvalue, double dvalue, int AllowUnknown)
{
int answer = 0;
char strvalue[1000];
int i,j,k;

   if(in_strvalue != NULL)
      {
      j = strlen(in_strvalue);
      k = 0;
      strvalue[k] = '\0';
      for(i=0; i<j; i++)
         {
         if(in_strvalue[i] != '"')
            {
            strvalue[k] = in_strvalue[i];
            ++k;
            strvalue[k] = '\0';
            }
         }
      }
   if(in_strvalue != NULL)
      {
      if(strcmp(strvalue,"-32768") == 0)
         answer = 1;
      else if(strcmp(strvalue,"-32768.0") == 0)
         answer = 1;
      else if(strcmp(strvalue,"-32766") == 0)
         answer = 1;
      else if(strcmp(strvalue,"-32766.0") == 0)
         answer = 1;
      else if(strcmp(strvalue,"-32765") == 0)
         answer = 1;
      else if(strcmp(strvalue,"-32765.0") == 0)
         answer = 1;
      else if(strcmp(strvalue,"-32764") == 0)
         answer = 1;
      else if(strcmp(strvalue,"-32764.0") == 0)
         answer = 1;
      else if(strcmp(strvalue,"996") == 0)
         answer = 1;
      else if(strcmp(strvalue,"997") == 0)
         answer = 1;
      else if(strcmp(strvalue,"998") == 0)
         answer = 1;
      else if(strcmp(strvalue,"999") == 0)
         answer = 1;
      else if(strcmp(strvalue,"Not Applicable") == 0)
         answer = 1;
      else if(strcmp(strvalue,"Unpopulated") == 0)
         answer = 1;
      else if(strcmp(strvalue,"Other") == 0)
         answer = 1;
      else if(strcmp(strvalue,"Multiple") == 0)
         answer = 1;
      else if(strcmp(strvalue,"N_A") == 0)
         answer = 1;
      else if(strcmp(strvalue,"OTH") == 0)
         answer = 1;
      else if(strcmp(strvalue,"N/A") == 0)
         answer = 1;
      else if(strcmp(strvalue,"Null") == 0)
         answer = 1;
      else if(strcmp(strvalue,"Null (Reserved)") == 0)
         answer = 1;
      else if(AllowUnknown == 2)
         {
         if(strcmp(strvalue,"-32767") == 0)
            answer = 1;
         else if(strcmp(strvalue,"-32767.0") == 0)
            answer = 1;
         else if(strcmp(strvalue,"0") == 0)
            answer = 1;
         else if(strcmp(strvalue,"Unknown") == 0)
            answer = 1;
         else if(strcmp(strvalue,"UNK") == 0)
            answer = 1;
         }
      }
   else
      {
      if(NearlyEqual(-32768.0, dvalue) > 0)
         answer = 1;
      else if(NearlyEqual(-32764.0, dvalue) > 0)
         answer = 1;
      else if(NearlyEqual(-32766.0, dvalue) > 0)
         answer = 1;
      else if(NearlyEqual(-32765.0, dvalue) > 0)
         answer = 1;
      else if((AllowUnknown == 2) && (NearlyEqual(-32767.0, dvalue) > 0))
         answer = 1;
      }

   return(answer);
}






void FreeMultiPartObjects(void)
{
   mpon = MultiPointRoot;
   while(mpon != NULL)
      {
      mpoc = mpon;
      mpon = mpon->next;
      free(mpoc->x);
      free(mpoc->y);
      free(mpoc->z);
      free(mpoc);
      }
   MultiPointRoot = NULL;

   mpon = MultiLineRoot;
   while(mpon != NULL)
      {
      mpoc = mpon;
      mpon = mpon->next;
      free(mpoc->x);
      free(mpoc->y);
      free(mpoc->z);
      free(mpoc);
      }
   MultiLineRoot = NULL;

   mpon = MultiAreaRoot;
   while(mpon != NULL)
      {
      mpoc = mpon;
      mpon = mpon->next;
      free(mpoc->x);
      free(mpoc->y);
      free(mpoc->z);
      free(mpoc);
      }
   MultiAreaRoot = NULL;
}


void ReadMultiPartObjects(void)
{
char filename[1000];
FILE *fin;
int SzMPO = sizeof(struct MultipartObj);
int numpoints, numlines, numareals;
int fid, ijunk,i;


   MultiLineRoot = MultiPointRoot = MultiAreaRoot = NULL;

   sprintf(filename,"%smultipart.txt",indirectory);
   fin = fopen(filename,"rt");
   if(fin == NULL)
      return;
   else
      {
      fscanf(fin,"%d %d %d",&numpoints, &numlines, &numareals);
      fclose(fin);
      if(numpoints > 0)
         {
         sprintf(filename,"%smultipartpoints.bin",indirectory);
         fin = fopen(filename,"rb");
         SEEIT_fread_int(&ijunk,fin); /** feature id ***/
         while(feof(fin) == 0)
            {
            mpon = (struct MultipartObj *) (malloc(SzMPO));
            if(mpon == NULL)
               {
               printf("memory has been exhausted during multi-part point feature read\n");
               exit(-1);
               }
            mpon->next = NULL;
            SEEIT_fread_int(&ijunk,fin); /** long index **/
            SEEIT_fread_int(&ijunk,fin); /** short index **/
            SEEIT_fread_int(&fid,fin); /** GIFD index **/
            ijunk = 1; /** num nodes  always == 1 for a point **/
            mpon->featureid = fid;
            mpon->used = 0;
            mpon->counted = 0;
            mpon->numverts = ijunk;
            mpon->x = (double *) (malloc(SzD));
            mpon->y = (double *) (malloc(SzD));
            mpon->z = (double *) (malloc(SzD));
            if(mpon->z == NULL)
               {
               printf("memory has been exhausted during multi-part point feature coordinate read\n");
               exit(-1);
               }
            for(i=0; i<ijunk; i++)
               {
               SEEIT_fread_double(&mpon->x[i],fin);
               SEEIT_fread_double(&mpon->y[i],fin);
               SEEIT_fread_double(&mpon->z[i],fin);

               if(Ctype() == 1)
                  {
                  mpon->x[i] = (mpon->x[i] - Xtranslation) * 100000.0;
                  mpon->y[i] = (mpon->y[i] - Ytranslation) * 100000.0;
                  }
               else if(Ctype() == 2)
                  {
                  mpon->x[i] = mpon->x[i] - Xtranslation;
                  mpon->y[i] = mpon->y[i] - Ytranslation;
                  }
               }
            mpon->next = MultiPointRoot;
            MultiPointRoot = mpon;

            SEEIT_fread_int(&ijunk,fin);
            }
         fclose(fin);
         }

      if(numlines > 0)
         {
         sprintf(filename,"%smultipartlines.bin",indirectory);
         fin = fopen(filename,"rb");
         SEEIT_fread_int(&ijunk,fin);
         while(feof(fin) == 0)
            {
            mpon = (struct MultipartObj *) (malloc(SzMPO));
            if(mpon == NULL)
               {
               printf("memory has been exhausted during multi-part line feature read\n");
               exit(-1);
               }
            mpon->next = NULL;
            SEEIT_fread_int(&ijunk,fin); /** long index **/
            SEEIT_fread_int(&ijunk,fin); /** short index **/
            SEEIT_fread_int(&fid,fin); /** GIFD index **/
            SEEIT_fread_int(&ijunk,fin); /** num nodes **/
            mpon->featureid = fid;
            mpon->used = 0;
            mpon->counted = 0;
            mpon->numverts = ijunk;
            mpon->x = (double *) (malloc(ijunk * SzD));
            mpon->y = (double *) (malloc(ijunk * SzD));
            mpon->z = (double *) (malloc(ijunk * SzD));
            if(mpon->z == NULL)
               {
               printf("memory has been exhausted during multi-part line feature coordinate read\n");
               exit(-1);
               }
            for(i=0; i<ijunk; i++)
               {
               SEEIT_fread_double(&mpon->x[i],fin);
               SEEIT_fread_double(&mpon->y[i],fin);
               SEEIT_fread_double(&mpon->z[i],fin);

               if(Ctype() == 1)
                  {
                  mpon->x[i] = (mpon->x[i] - Xtranslation) * 100000.0;
                  mpon->y[i] = (mpon->y[i] - Ytranslation) * 100000.0;
                  }
               else if(Ctype() == 2)
                  {
                  mpon->x[i] = mpon->x[i] - Xtranslation;
                  mpon->y[i] = mpon->y[i] - Ytranslation;
                  }
               }
            mpon->next = MultiLineRoot;
            MultiLineRoot = mpon;

            SEEIT_fread_int(&ijunk,fin);
            }
         fclose(fin);
         }


      if(numareals > 0)
         {
         sprintf(filename,"%smultipartareas.bin",indirectory);
         fin = fopen(filename,"rb");
         SEEIT_fread_int(&ijunk,fin);
         while(feof(fin) == 0)
            {
            mpon = (struct MultipartObj *) (malloc(SzMPO));
            if(mpon == NULL)
               {
               printf("memory has been exhausted during multi-part area feature read\n");
               exit(-1);
               }
            mpon->next = NULL;
            SEEIT_fread_int(&ijunk,fin); /** long index **/
            SEEIT_fread_int(&ijunk,fin); /** short index **/
            SEEIT_fread_int(&fid,fin); /** GIFD index **/
            SEEIT_fread_int(&ijunk,fin); /** num nodes **/
            mpon->featureid = fid;
            mpon->used = 0;
            mpon->counted = 0;
            mpon->numverts = ijunk;
            mpon->x = (double *) (malloc(ijunk * SzD));
            mpon->y = (double *) (malloc(ijunk * SzD));
            mpon->z = (double *) (malloc(ijunk * SzD));
            if(mpon->z == NULL)
               {
               printf("memory has been exhausted during multi-part area feature coordinate read\n");
               exit(-1);
               }
            for(i=0; i<ijunk; i++)
               {
               SEEIT_fread_double(&mpon->x[i],fin);
               SEEIT_fread_double(&mpon->y[i],fin);
               SEEIT_fread_double(&mpon->z[i],fin);

               if(Ctype() == 1)
                  {
                  mpon->x[i] = (mpon->x[i] - Xtranslation) * 100000.0;
                  mpon->y[i] = (mpon->y[i] - Ytranslation) * 100000.0;
                  }
               else if(Ctype() == 2)
                  {
                  mpon->x[i] = mpon->x[i] - Xtranslation;
                  mpon->y[i] = mpon->y[i] - Ytranslation;
                  }
               }
            mpon->next = MultiAreaRoot;
            MultiAreaRoot = mpon;

            SEEIT_fread_int(&ijunk,fin);
            }
         fclose(fin);
         }
      }

   return;

}



void FreeRGridStructure(void)
{
int i;

   if(RGrid != NULL)
      {
      for(i=0; i<GridDimension; i++)
         {
         free(RGrid[i].X);
         free(RGrid[i].Y);
         free(RGrid[i].Elev);
         }
      free(RGrid);
      RGrid = NULL;
      }

}




/** calculate implicit form eqn for a line between two points **/
void LineEquation(double x1,double y1,double x2,double y2,double * A,double * B,double * C)
{
double X,Y,RSG,RINV;
  X = x1 - x2;
  Y = y1 - y2;
  RSG = (X*X) + (Y*Y);
  RINV = 1.0 / (sqrt(RSG));
  if(y1 == y2)
     *A = 0;
  else
     *A = -1.0 * Y * RINV;
  if(x1 == x2)
    *B = 0;
  else
    *B = X * RINV;
  *C = 0 - (* A * x1) - (*B * y1);
}



double YCoordToProjectCoord(double y)
{
double answer;

   if(Ctype() == 1)
      answer = (y - Ytranslation) * 100000.0;
   else
      answer = y - Ytranslation;
   return(answer);
}


double XCoordToProjectCoord(double x)
{
double answer;

   if(Ctype() == 1)
      answer = (x - Xtranslation) * 100000.0;
   else
      answer = x - Xtranslation;
   return(answer);
}






void GetAppropIDnumber(int index, char * answer)
{
  int Ijunk,attr_type;
  double Djunk;
  extern int GetLongAttrVal(int type,int uniqueid,int *Ival,double *Dval,char *Cval);
  extern int C_TYPE;
  extern int LONG_ATTR_CHECK_ID     ;

  if(index < 0)
     {
     strcpy(answer,"Error");
     return;
     }

  attr_type = GetLongAttrVal(LONG_ATTR_CHECK_ID,index,&Ijunk,&Djunk,&answer[0]);

  if(attr_type!=C_TYPE)
  {
        printf("error in ID generation: expected %d, got %d\n",C_TYPE,attr_type);
        sprintf(answer,"%s Unavailable--See Console\n",GetFrontPart());
  }

}







char * ParseConfigurationClass(unsigned char keyval)
{
   switch(keyval)
      {
      case 0: return("Unassigned");
      case 1: return("Area");
      case 2: return("Directed Line");
      case 3: return("Footprint Model");
      case 4: return("Line");
      case 5: if(NGA_TYPE == 0) return("Point Feature");
              else return("Point");
      case 6: return("Point Model");
      case 7: return("Polygon");
      case 8: return("Dynamic Model");
      case 9: return("Grid");
      case 10: return("Spherical Collision Footprint");
      case 11: return("Parallelepiped Collision Footprint");
      case 12: return("Model Library Polygon");
      case 13: return("Feature Model Point Feature");
      case 14: return("Feature Model Linear Feature");
      case 15: return("Feature Model Area Feature");
      }
   return("Unrecognized Configuration Class");
}


char * ParseGAITgeometry(unsigned char geom, int CaseFlag)
{
   if(NGA_TYPE == 0)
      return(ParseConfigurationClass(geom));


   if(CaseFlag == 0) /*** return all upper case characters ***/
      {
      switch(geom)
         {
         case 0: return("UNASSIGNED");
         case 1: if((ATTRTYPE_ANY_TDS() > 0) || (ATTRTYPE_ANY_GGDM() > 0)) /*** TDS***/ /*** GGDM ***/
                    return("SURFACE");
                 else
                    return("AREA");
         case 4: if((ATTRTYPE_ANY_TDS() > 0) || (ATTRTYPE_ANY_GGDM() > 0)) /*** TDS***/ /*** GGDM ***/
                    return("CURVE");
                 else
                    return("LINE");
         case 5: return("POINT");
         case 9: return("GRID");
         default: return("UNKNOWN GEOMETRY TYPE");
         }
      }
   else if(CaseFlag == 1) /*** return all lower case characters ***/
      {
      switch(geom)
         {
         case 0: return("unassigned");
         case 1: if((ATTRTYPE_ANY_TDS() > 0) || (ATTRTYPE_ANY_GGDM() > 0)) /*** TDS***/ /*** GGDM ***/
                    return("surface");
                 else
                    return("area");
         case 4:  if((ATTRTYPE_ANY_TDS() > 0) || (ATTRTYPE_ANY_GGDM() > 0)) /*** TDS***/ /*** GGDM ***/
                    return("curve");
                 else
                    return("line");
         case 5: return("point");
         case 9: return("grid");
         default: return("unknown geometry type");
         }
      }
   else if(CaseFlag == 2) /*** return 1st char Upper Case, all others lower case characters ***/
      {
      switch(geom)
         {
         case 0: return("unassigned");
         case 1: if((ATTRTYPE_ANY_TDS() > 0) || (ATTRTYPE_ANY_GGDM() > 0)) /*** TDS***/ /*** GGDM ***/
                    return("Surface");
                 else
                    return("Area");
         case 4: if((ATTRTYPE_ANY_TDS() > 0) || (ATTRTYPE_ANY_GGDM() > 0)) /*** TDS***/ /*** GGDM ***/
                    return("Curve");
                 else
                    return("Line");
         case 5: return("Point");
         case 9: return("Grid");
         default: return("Unknown Geometry Type");
         }
      }
   else
      return("Error - invalid case flag as argument");
}




char * ParseDomainClass(unsigned char keyval)
{

  extern char *DNAME[NUM_D];

  return DNAME[keyval];
/***********
  switch(keyval)
    {
    case 0: return("Unassigned");
    case 1: return("Air Mobility");
    case 2: return("Air Obstacle");
    case 3: return("Boundary");
    case 4: return("Bridging");
    case 5: return("Cultural");
    case 6: return("Inland Water");
    case 7: return("Land Mobility");
    case 8: return("Land Obstacle");
    case 9: return("Military Use");
    case 10: return("Open Water");
    case 11: return("Terrain");
    case 12: return("Vegetation");
    case 13: return("Maritime Mobility");
    case 14: return("Maritime Obstacle");
    case 15: return("Maritime Culture");
    case 16: return("Weather");
    case 17: return("Space");
    case 18: return("Descriptive");
    }
  return("Unrecognized Domain Class");
**************/
}




char * TranslateConfigurationClass(unsigned char keyval)
{
   switch(keyval)
      {
      case 0: return("Unassigned");
      case 1: return("AREA");
      case 2: return("DIRECTED_LINE");
      case 3: return("FOOTPRINT_MODEL");
      case 4: return("LINE");
      case 5: return("POINT"); /** Point Feature **/
      case 6: return("POINT_MODEL"); /** Point Model **/
      case 7: return("POLYGON");
      case 8: return("MODEL_POLYGON"); /** was "Dynamic Model" **/
      case 9: return("GRID");
      case 10: return("SPHERE"); /**Spherical Collision Footprint**/
      case 11: return("PIPED"); /**Parallelepiped Collision Footprint**/
      case 12: return("MODEL_POLYGON"); /**Model Library Polygon**/
      case 13: return("POINT_FEATURE"); /**Feature Model Point Feature**/
      case 14: return("LINEAR_FEATURE"); /**Feature Model Linear Feature**/
      case 15: return("AREAL_FEATURE"); /**Feature Model Areal Feature**/
      }
   return("Unrecognized Configuration Class");
}



int FindSpecificSensitivity(int number, int checktype, int checknum, double *answer)
{
int foundit = 0;

   if((ActiveChecks[checknum].number != checktype) || (number < 1) || (number > 6))
      return(foundit);
   else if(ActiveChecks[checknum].numthresholds < number) /** asked for sensitivity number > those used ***/
      {
      return(foundit);
      }
   else
      {
      if(number == 1)
         {
         foundit = 1;
         *answer = ActiveChecks[checknum].sensitivity;
         }
      else if(number == 2)
         {
         foundit = 1;
         *answer = ActiveChecks[checknum].sensitivity2;
         }
      else if(number == 3)
         {
         foundit = 1;
         *answer = ActiveChecks[checknum].sensitivity3;
         }
      else if(number == 4)
         {
         foundit = 1;
         *answer = ActiveChecks[checknum].sensitivity4;
         }
      else if(number == 5)
         {
         foundit = 1;
         *answer = ActiveChecks[checknum].sensitivity5;
         }
      else if(number == 6)
         {
         foundit = 1;
         *answer = ActiveChecks[checknum].sensitivity6;
         }
      }

   return(foundit);

}






double FindRelevantSensitivity(int checktype, int checknum, double *sensitivity2)
{
double answer = 0.0;


   if(ActiveChecks[checknum].number != checktype)
      answer = 0;
   else if(ActiveChecks[checknum].numthresholds < 1)
      {
      answer = 0;
      *sensitivity2 = 0;
      }
   else
      {
      answer = ActiveChecks[checknum].sensitivity;
      if(ActiveChecks[checknum].numthresholds > 1)
         *sensitivity2 = ActiveChecks[checknum].sensitivity2;
      else
         *sensitivity2 = 0.0;
      }

   return(answer);
}


double FindMaxSensitivities(int checktype, double *sensitivity2)
{
double answer1 = 0.0;
double answer2 = 0.0;
int checkinstance;
   for(checkinstance = 0; checkinstance < TtlActiveChecks; checkinstance++)
      {
      if(ActiveChecks[checkinstance].number == checktype)
         {
         if(ActiveChecks[checkinstance].numthresholds < 1)
            {
            answer1 = 0;
            answer2 = 0;
            break;
            }
         else
            {
            if(ActiveChecks[checkinstance].sensitivity > answer1)
               answer1 = ActiveChecks[checkinstance].sensitivity;

            if(ActiveChecks[checkinstance].sensitivity2 > answer2)
               answer2 = ActiveChecks[checkinstance].sensitivity2;
            }
         }
      }

   *sensitivity2 = answer2;

   return(answer1);
}




int FindMinMaxSensitivities(int checktype, double *min1, double *max1, double *min2, double *max2, int *numT)
{
int setanswer;
int checkinstance;

   setanswer = 0;
   for(checkinstance = 0; checkinstance < TtlActiveChecks; checkinstance++)
      {
      if(ActiveChecks[checkinstance].number == checktype)
         {
         *numT = ActiveChecks[checkinstance].numthresholds;

         if(ActiveChecks[checkinstance].numthresholds < 1)
            {
            *min1 = *max1 = *min2 = *max2 = 0.0;
            break;
            }
         else
            {
            if(setanswer == 0)
               {
               *min1 = *max1 = ActiveChecks[checkinstance].sensitivity;
               if(ActiveChecks[checkinstance].numthresholds > 1)
                  *min2 = *max2 = ActiveChecks[checkinstance].sensitivity2;
               else
                  *min2 = *max2 = 0.0;
               setanswer = 1;
               }
            else
               {
               if(ActiveChecks[checkinstance].sensitivity > *max1)
                  *max1 = ActiveChecks[checkinstance].sensitivity;
               if(ActiveChecks[checkinstance].sensitivity < *min1)
                  *min1 = ActiveChecks[checkinstance].sensitivity;

               if(ActiveChecks[checkinstance].numthresholds > 1)
                  {
                  if(ActiveChecks[checkinstance].sensitivity2 > *max2)
                     *max2 = ActiveChecks[checkinstance].sensitivity2;
                  if(ActiveChecks[checkinstance].sensitivity2 < *min2)
                     *min2 = ActiveChecks[checkinstance].sensitivity2;
                  }
               }
            }
         }
      }

   return(setanswer);
}





int InSmidge(double a, double b)
{
  if((fabs(a-b))<SMIDGE)
    {
      return 1;
    }
  return 0;
}




void DrawNewCondition(int keyval, int Cnumber, double px, double py, double pz, int PtUsed,
             int Lindex1, int index1,  int gform1, char * IDStr1,
             double *x1, double *y1, double *z1, int numverts1,
             int Lindex2, int index2,  int gform2, char * IDStr2,
             double *x2, double *y2, double *z2, int numverts2)
{

   CTD->CONDITION_TYPE = keyval;
   CTD->CONDITION_INSTANCE = Cnumber;
   CTD->retainignore = 1;
   CTD->num_areals = 0;
   CTD->num_polys = 0;
   CTD->num_lines = 0;
   CTD->num_points = 0;
   CTD->num_circles = 0;
   CTD->num_piped = 0;
   CTD->num_cylinder = 0;
   CTD->num_gridpt = 0;
   CTD->num_sphere = 0;
   CTD->AdditionalPointUsed = PtUsed;
   if(PtUsed > 0)
      {
      CTD->pointx = px;
      CTD->pointy = py;
      CTD->pointz = pz;
      }
   CTD->AdditionalIDENT = NULL;
   CTD->ECC1 = CTD->ECC2 = 0;
   CTD->AttrErrMsg = NULL;
   CTD->Message = NULL;
   CTD->next = NULL;

   if(gform1 > 0)
      {
      switch(gform1)
         {
         case G_AREAL:
            CTD->num_areals += 1;
            CTD->areal1.Lindex = Lindex1;
            CTD->areal1.IDENT = IDStr1;
            CTD->areal1.x = x1;
            CTD->areal1.y = y1;
            CTD->areal1.z = z1;
            CTD->areal1.numverts = numverts1;
            break;
         case G_LINE:
            CTD->num_lines += 1;
            CTD->linear1.Lindex = Lindex1;
            CTD->linear1.IDENT = IDStr1;
            CTD->linear1.x = x1;
            CTD->linear1.y = y1;
            CTD->linear1.z = z1;
            CTD->linear1.numverts = numverts1;
            break;
         case G_POINT:
            CTD->num_points += 1;
            CTD->point1.Lindex = Lindex1;
            CTD->point1.IDENT = IDStr1;
            CTD->point1.x = x1[0];
            CTD->point1.y = y1[0];
            CTD->point1.z = z1[0];
            break;
         case G_GRIDPT:
            CTD->num_gridpt += 1;
            CTD->gridobj1.Lindex = Lindex1;
            CTD->gridobj1.IDENT = IDStr1;
            CTD->gridobj1.x = x1;
            CTD->gridobj1.y = y1;
            CTD->gridobj1.z = z1;
            CTD->gridobj1.numverts = numverts1;
            break;
         }
      }
   if(gform2 > 0)
      {
      switch(gform2)
         {
         case G_AREAL:
            CTD->num_areals += 1;
            if(CTD->num_areals == 1)
               {
               CTD->areal1.Lindex = Lindex2;
               CTD->areal1.IDENT = IDStr2;
               CTD->areal1.x = x2;
               CTD->areal1.y = y2;
               CTD->areal1.z = z2;
               CTD->areal1.numverts = numverts2;
               }
            else if(CTD->num_areals == 2)
               {
               CTD->areal2.Lindex = Lindex2;
               CTD->areal2.IDENT = IDStr2;
               CTD->areal2.x = x2;
               CTD->areal2.y = y2;
               CTD->areal2.z = z2;
               CTD->areal2.numverts = numverts2;
               }
            break;
         case G_LINE:
            CTD->num_lines += 1;
            if(CTD->num_lines == 1)
               {
               CTD->linear1.Lindex = Lindex2;
               CTD->linear1.IDENT = IDStr2;
               CTD->linear1.x = x2;
               CTD->linear1.y = y2;
               CTD->linear1.z = z2;
               CTD->linear1.numverts = numverts2;
               }
            else if(CTD->num_lines == 2)
               {
               CTD->linear2.Lindex = Lindex2;
               CTD->linear2.IDENT = IDStr2;
               CTD->linear2.x = x2;
               CTD->linear2.y = y2;
               CTD->linear2.z = z2;
               CTD->linear2.numverts = numverts2;
               }
            break;
         case G_POINT:
            CTD->num_points += 1;
            if(CTD->num_points == 1)
               {
               CTD->point1.Lindex = Lindex2;
               CTD->point1.IDENT = IDStr2;
               CTD->point1.x = x2[0];
               CTD->point1.y = y2[0];
               CTD->point1.z = z2[0];
               }
            else if(CTD->num_points == 2)
               {
               CTD->point2.Lindex = Lindex2;
               CTD->point2.IDENT = IDStr2;
               CTD->point2.x = x2[0];
               CTD->point2.y = y2[0];
               CTD->point2.z = z2[0];
               }
            break;
         case G_GRIDPT:
            CTD->num_gridpt += 1;
            if(CTD->num_gridpt == 1)
               {
               CTD->gridobj1.Lindex = Lindex2;
               CTD->gridobj1.IDENT = IDStr2;
               CTD->gridobj1.x = x2;
               CTD->gridobj1.y = y2;
               CTD->gridobj1.z = z2;
               CTD->gridobj1.numverts = numverts2;
               }
            else if(CTD->num_gridpt == 2)
               {
               CTD->gridobj2.Lindex = Lindex2;
               CTD->gridobj2.IDENT = IDStr2;
               CTD->gridobj2.x = x2;
               CTD->gridobj2.y = y2;
               CTD->gridobj2.z = z2;
               CTD->gridobj2.numverts = numverts2;
               }
            break;
         }
      }

   DrawConditionObjects(CTD);

   return;
}


void FwriteObject(int keyval, int Cnumber,
             int Lindex, int index, char gform, double LocalID, int IDN, double radius, double height,
             double *x, double *y, double *z, int numverts, int DrawNow)
{
int i;
char keepit = 1;
/** idea for keepit is for use during condition review: 1==>keep condition
 * 0==>discard condition
 * 2==>keep first object only
 * 3==>keep second object only
****/
/**FILE *fout; **/
   if(unsortout == NULL)
      return;

   SEEIT_fwrite_int(&keyval,unsortout);
   SEEIT_fwrite_int(&Cnumber,unsortout); 
   SEEIT_fwrite_int(&IDN,unsortout);
   GetAppropIDnumber(IDN, &MessageLine[0]);
   i = strlen(MessageLine);
   SEEIT_fwrite_int(&i,unsortout);
   fwrite(&MessageLine[0],i,1,unsortout); /** writing 'i' 1-byte chars, endian neutral, so just use a mass write **/
   SEEIT_fwrite_int(&SCCtable[index].ECC,unsortout);
   fwrite(&gform,1,1,unsortout);
   fwrite(&keepit,1,1,unsortout);
   SEEIT_fwrite_int(&Lindex,unsortout);
   SEEIT_fwrite_double(&LocalID, unsortout);
   SEEIT_fwrite_double(&radius, unsortout);
   SEEIT_fwrite_double(&height, unsortout);
   SEEIT_fwrite_int(&numverts,unsortout);


   for(i=0; i<numverts; i++)
      {
      SEEIT_fwrite_double(&x[i],unsortout);
      SEEIT_fwrite_double(&y[i],unsortout);
      SEEIT_fwrite_double(&z[i],unsortout);
      }
   if(DrawNow > 0)
      {
      DrawNewCondition(keyval, Cnumber, 0, 0, 0, 0,  /**** px, py, pz, PtUsed ***/
             Lindex, index, gform, MessageLine,
             x, y, z, numverts,
             0, 0, -1, NULL, NULL, NULL, NULL, 0);/*** Lindex2, index2, gform2, IDStr2, x,y,z,numverts2 ***/
      }

   NUMBEROFCONDITIONS += 1;

}


void FwriteTransTreeInorder(rb_red_blk_tree* tree, rb_red_blk_node* x)
{
struct TransitiveCollection *TC;

   if (x != tree->nil)
      {
      FwriteTransTreeInorder(tree,x->left);
      TC = (struct TransitiveCollection *) (x->info);

/** below, the TC->height field holds the area feature 'ishole' status - don't want to write a hole as a condition ***/
      if(((TC->keyval == NETISOA) || (TC->keyval == ANETISOA)) && (TC->counter == 0) && (TC->height <= 0))
         {
            FwriteObject(TC->keyval, TC->Cnumber, TC->Lindex, TC->Sindex, TC->gform, TC->localID, TC->IDN,
                     TC->radius, TC->height, TC->x, TC->y, TC->z, 2, 0);
         }
      FwriteTransTreeInorder(tree,x->right);
      }
}

/** if inspection progress is beyond last Load Module column where a feature can appear, write the condition now and remove
    the entry in the tree of conditions to save some memory ***/
void PruneAndWriteRBCheckTree(int thisindex, int thischeck, rb_red_blk_tree* tree, rb_red_blk_node* x)
{
struct ConditionCollection *C;

   if (x != tree->nil)
      {
      PruneAndWriteRBCheckTree(thisindex,thischeck,tree,x->left);

      C = (struct ConditionCollection *) (x->info);

      if((C != NULL) && (C->keyval == thischeck))
         {
         if((C->keyval == NOENDCON) && (thisindex > C->radius))
            {
            if(C->counter == 0)
               {
               FwritePointAndObject(C->keyval,C->Cnumber,C->x[0],C->y[0],C->z[0], -1,
                       C->Sindex, G_LINE, C->Lindex,C->localID,
                          C->IDN,10.0, 0.0,&C->x[C->numnodes - 2], &C->y[C->numnodes - 2], &C->z[C->numnodes - 2], 2);
               }

            if(C->x != NULL)
               free(C->x);
            if(C->y != NULL)
               free(C->y);
            if(C->z != NULL)
               free(C->z);
           
            free(C);
            x->info = NULL;
            }
         else if((C->keyval == ISOLINE) && (thisindex > C->radius))
            {
            if(C->counter == 1)
               {
               FwriteTwoObjects(C->keyval,C->Cnumber,
                    C->IDN,G_LINE,C->Lindex,C->localID,CrsWlk[C->Lindex].LtoSmapping,-1.0,-1.0,
                    2,&C->x[0],&C->y[0],&C->z[0],
                    C->featureidn, /** is really the area IDN **/
                    G_AREAL,C->Sindex, /** is really the area Lindex **/
                    C->magnitude, /** is really the area localID **/
                    CrsWlk[C->Sindex].LtoSmapping, /** should be the area Sindex **/
                    -1.0,-1.0,
                    2,&C->x[2],&C->y[2],&C->z[2]);
               }

            if(C->x != NULL)
               free(C->x);
            if(C->y != NULL)
               free(C->y);
            if(C->z != NULL)
               free(C->z);

            free(C);
            x->info = NULL;
            }
         else if((C != NULL) && (C->keyval == thischeck))
            {
            if((C->keyval == BOTHENDCON) && (thisindex > C->radius))
               {
               if(C->counter > 1)
                  {
                  FwritePointAndObject(C->keyval,C->Cnumber,C->x[0],C->y[0],C->z[0], -1,
                          C->Sindex, G_LINE, C->Lindex,C->localID,
                             C->IDN,10.0, 0.0,&C->x[C->numnodes - 2], &C->y[C->numnodes - 2], &C->z[C->numnodes - 2], 2);
                  }
   
               if(C->x != NULL)
                  free(C->x);
               if(C->y != NULL)
                  free(C->y);
               if(C->z != NULL)
                  free(C->z);
   
               free(C);
               x->info = NULL;
               }
            }
         }

      PruneAndWriteRBCheckTree(thisindex,thischeck,tree,x->right);
      }

}




void FwriteTreeInorder(rb_red_blk_tree* tree, rb_red_blk_node* x)
{
struct ConditionCollection *C;
struct EdgeIntervals *FTc;
void FwriteObjectAndMagnitude(int keyval, int Cnumber, int IDN,
                             int index, char gform, int Lindex, double localid,  double radius, double height,
                             double magnitude, double *x, double *y, double *z, int numverts, int DrawNow);
int unusedint;

   if (x != tree->nil)
      {
      FwriteTreeInorder(tree,x->left);

      C = (struct ConditionCollection *) (x->info);

      if(C != NULL)
         {

         if((C->keyval == LLNOINT) && (C->counter == 0))
            {
            FwriteObject(C->keyval, C->Cnumber, C->Lindex, C->Sindex, C->gform, C->localID, C->IDN,
                     C->radius, C->height, C->x, C->y, C->z, 2, 0);
            }
         else if((C->keyval == LFNOINT) && (C->counter == 0))
            {
            FwriteObject(C->keyval, C->Cnumber, C->Lindex, C->Sindex, C->gform, C->localID, C->IDN,
                     C->radius, C->height, C->x, C->y, C->z, 2, 0);
            }
         else if((C->keyval == OBJECTWITHOUT) && (C->counter == 0))
            {
            FwriteObject(C->keyval, C->Cnumber, C->Lindex, C->Sindex, C->gform, C->localID, C->IDN,
                     C->radius, C->height, C->x, C->y, C->z, 2, 0);
            }
         else if((C->keyval == OBJ_WO_TWO) && (C->counter == 2))
            {
            FwriteObject(C->keyval, C->Cnumber, C->Lindex, C->Sindex, C->gform, C->localID, C->IDN,
                     C->radius, C->height, C->x, C->y, C->z, 2, 0);
            }
         else if((C->keyval == AWITHOUTA) && (C->counter == 0))
            {
            /***FwriteObject(C->keyval, C->Cnumber, C->Lindex, C->Sindex, C->gform, C->localID, C->IDN,
                     C->radius, C->height, C->x, C->y, C->z, 2, 0); ***/
            FwriteDynamicInfo(C->keyval,C->Cnumber,1,0,1,NULL,0.0,C->x[0],C->y[0],C->z[0],
                             C->Sindex,C->gform,C->Lindex,C->localID,C->IDN,C->radius,C->height,
                             C->x,C->y,C->z,2,
                             C->Sindex,C->gform,C->Lindex,C->localID,C->IDN,C->radius,C->height,
                             C->x,C->y,C->z,2);
            }
         else if((C->keyval == FSFAIL) && (C->counter == 0))
            {
            FwriteObject(C->keyval, C->Cnumber, C->Lindex, C->Sindex, C->gform, C->localID, C->IDN,
                     C->radius, C->height, C->x, C->y, C->z, 2, 0);
            }
         else if((C->keyval == ISOLATEDA) && (C->counter == 0))
            {
            FwriteObject(C->keyval, C->Cnumber, C->Lindex, C->Sindex, C->gform, C->localID, C->IDN,
                     C->radius, C->height, C->x, C->y, C->z, 2, 0);
            }
         else if((C->keyval == COINCIDEFAIL) && (C->counter < 2))
            {
            FwriteObject(C->keyval, C->Cnumber, C->Lindex, C->Sindex, C->gform, C->localID, C->IDN,
                     C->radius, C->height, C->x, C->y, C->z, 2, 0);
            }
         else if((C->keyval == PSHAREFAIL) && (C->counter == 0))
            {
            FwriteObject(C->keyval, C->Cnumber, C->Lindex, C->Sindex, C->gform, C->localID, C->IDN,
                     C->radius, C->height, C->x, C->y, C->z, 2, 0);
            }
         else if((C->keyval == NOCOINCIDE) && (C->counter == 0))
            {
            FwriteObject(C->keyval, C->Cnumber, C->Lindex, C->Sindex, C->gform, C->localID, C->IDN,
                     C->radius, C->height, C->x, C->y, C->z, 2, 0);
            }
         else if(C->keyval == PERIMLEN)
            {
            if(C->magnitude >= 0)
               {
               FwriteObjectAndMagnitude(PERIMLEN,C->Cnumber, C->IDN,C->Sindex, C->gform, C->Lindex,
                                        C->localID, C->radius, C->height, C->magnitude, 
                                         C->x, C->y, C->z, 2, 1);
               }
            }
         else if((C->keyval == FACESIZE) && (C->counter == 0) && (C->magnitude >= 0))
            {
            FwriteObjectAndMagnitude(FACESIZE,C->Cnumber, C->IDN,C->Sindex, C->gform, C->Lindex,
                                        C->localID, C->radius, C->height, C->magnitude,
                                         C->x, C->y, C->z, C->numnodes, 1);
            }

         else if(((C->keyval == SMALLAREA) || (C->keyval == SMLCUTOUT)) && (C->magnitude >= 0))
            {
            FwriteObjectAndMagnitude(C->keyval,C->Cnumber, C->IDN,C->Sindex, C->gform, C->Lindex,
                                        C->localID, C->radius, C->height, C->magnitude,
                                         C->x, C->y, C->z, C->numnodes, 1);
            }

         else if((C->keyval == NOENDCON) && (C->counter == 0))
            {
            FwritePointAndObject(C->keyval,C->Cnumber,C->x[0],C->y[0],C->z[0], -1,
                       C->Sindex, G_LINE, C->Lindex,C->localID,
                          C->IDN,10.0, 0.0,&C->x[C->numnodes - 2], &C->y[C->numnodes - 2], &C->z[C->numnodes - 2], 2);
            }
         else if((C->keyval == ISOLINE) && (C->counter == 1))
            {
            FwriteTwoObjects(C->keyval,C->Cnumber,
                    C->IDN,G_LINE,C->Lindex,C->localID,CrsWlk[C->Lindex].LtoSmapping,-1.0,-1.0,
                    2,&C->x[0],&C->y[0],&C->z[0],
                    C->featureidn, /** is really the area IDN **/
                    G_AREAL,C->Sindex, /** is really the area Lindex **/
                    C->magnitude, /** is really the area localID **/
                    CrsWlk[C->Sindex].LtoSmapping, /** should be the area Sindex **/ /** 5 Apr changed C->Lndex to C->Sindex - Japan bug **/
                    -1.0,-1.0,
                    2,&C->x[2],&C->y[2],&C->z[2]);
            }
         else if((C->keyval == BOTHENDCON) && (C->counter > 1))
            {
            FwritePointAndObject(C->keyval,C->Cnumber,C->x[0],C->y[0],C->z[0], -1,
                       C->Sindex, G_LINE, C->Lindex,C->localID,
                          C->IDN,10.0, 0.0,&C->x[C->numnodes - 2], &C->y[C->numnodes - 2], &C->z[C->numnodes - 2], 2);
            }

         else if(C->keyval == CONNECTFAIL)
            {
            if((C->gform == G_LINE) && ((C->radius < 1) || (C->height < 1)))
               {
               if(C->radius < 1)
                  {
                  FwriteObject(C->keyval, C->Cnumber, C->Lindex, C->Sindex, C->gform, C->localID, C->IDN,
                     C->radius, C->height, C->x, C->y, C->z, 2, 0);
                  }
               else
                  {
                  FwriteObject(C->keyval, C->Cnumber, C->Lindex, C->Sindex, C->gform, C->localID, C->IDN,
                     C->radius, C->height, &C->x[2], &C->y[2], &C->z[2], 2, 0);
                  }
               }
            else if((C->gform == G_AREAL) && (C->counter == 0))
               {
               FwriteObject(C->keyval, C->Cnumber, C->Lindex, C->Sindex, C->gform, C->localID, C->IDN,
                     C->radius, C->height, C->x, C->y, C->z, 2, 0);
               }
            }
         else if(C->keyval == CONFLATE)
            {
            if(C->magnitude > 0.1)
               {
               FTc = C->index_from_to;
               while(FTc != NULL)
                  {
                  FwriteObjectAndMessage(C->keyval,C->Cnumber,
                       C->IDN,C->gform,C->Lindex,C->localID,C->Sindex,
                       C->radius, C->height, &C->x[FTc->start], &C->y[FTc->start], &C->z[FTc->start],
                       (FTc->stop - FTc->start + 1),FindCONFLATEsourceFile((int) C->IDN, &unusedint));
                  FTc = FTc->next;
                  }
               }
            }
         else if(C->keyval == LNOCOVERLA)
            {
            if(C->magnitude > 0.1)
               {
               FTc = C->index_from_to;
               while(FTc != NULL)
                  {
                  FwriteObject(C->keyval, C->Cnumber, C->Lindex, C->Sindex, C->gform, C->localID, C->IDN,
                        C->radius, C->height, &C->x[FTc->start], &C->y[FTc->start], &C->z[FTc->start],
                        (FTc->stop - FTc->start + 1), 0);

                  FTc = FTc->next;
                  }
               }
            }
          else if(C->keyval == LSPANFAIL)
            {

            if((C->magnitude > 0.1) || (C->height < 1) || (C->radius < 1))
               {
               if(C->index_from_to == NULL)
                  {
                  if(C->height < 1) /** final node is uncovered ***/
                     FwriteObject(C->keyval, C->Cnumber, C->Lindex, C->Sindex, C->gform, C->localID, C->IDN,
                        C->radius, C->height, &C->x[C->numnodes - 2], &C->y[C->numnodes - 2], &C->z[C->numnodes - 2],2,0);
                  else if(C->radius < 1)
                     FwriteObject(C->keyval, C->Cnumber, C->Lindex, C->Sindex, C->gform, C->localID, C->IDN,
                        C->radius, C->height, &C->x[0], &C->y[0], &C->z[0],2,0);
                  }
               else
                  {
                  FTc = C->index_from_to;
                  while(FTc != NULL)
                     {
                     FwriteObject(C->keyval, C->Cnumber, C->Lindex, C->Sindex, C->gform, C->localID, C->IDN,
                        C->radius, C->height, &C->x[FTc->start], &C->y[FTc->start], &C->z[FTc->start],
                        (FTc->stop - FTc->start + 1), 0);

                     FTc = FTc->next;
                     }
                  }
               }
            }
         }
      FwriteTreeInorder(tree,x->right);
      }
}




void FwriteMsgMagPointObjects(int keyval, int Cnumber, char *msg, double magnitude, double pointX, double pointY, double pointZ,
                                  int index1, char gform1, int Lindex1, double localid1, int IDN1, double radius1, double height1,
                                  double *x1, double *y1, double *z1, int numverts1,
                                  int index2, char gform2, int Lindex2, double localid2, int IDN2, double radius2, double height2,
                                  double *x2, double *y2, double *z2, int numverts2)
{
int i,slen;
char ML2[300];
/**FILE *fout;**/
   if(unsortout == NULL)
      return;


   SEEIT_fwrite_int(&keyval,unsortout);
   SEEIT_fwrite_int(&Cnumber,unsortout);
   if(msg != NULL)
      {
      slen = strlen(msg);
      SEEIT_fwrite_int(&slen,unsortout);
      fwrite(&msg[0],1,slen,unsortout);
      }
   else
      {
      slen = 0;
      SEEIT_fwrite_int(&slen,unsortout);
      }

   SEEIT_fwrite_double(&magnitude,unsortout);

   SEEIT_fwrite_double(&pointX,unsortout);
   SEEIT_fwrite_double(&pointY,unsortout);
   SEEIT_fwrite_double(&pointZ,unsortout);

   SEEIT_fwrite_int(&IDN1,unsortout);
   GetAppropIDnumber(IDN1, &MessageLine[0]);
   i = strlen(MessageLine);
   SEEIT_fwrite_int(&i,unsortout);
   fwrite(&MessageLine[0],i,1,unsortout); /** writing 'i' 1-byte chars, endian neutral, so just use a mass write **/
   SEEIT_fwrite_int(&SCCtable[index1].ECC,unsortout);
   fwrite(&gform1,1,1,unsortout);
   SEEIT_fwrite_int(&Lindex1,unsortout);
   SEEIT_fwrite_double(&localid1, unsortout);
   SEEIT_fwrite_double(&radius1, unsortout);
   SEEIT_fwrite_double(&height1, unsortout);
   SEEIT_fwrite_int(&numverts1,unsortout);


   for(i=0; i<numverts1; i++)
      {
      SEEIT_fwrite_double(&x1[i],unsortout);
      SEEIT_fwrite_double(&y1[i],unsortout);
      SEEIT_fwrite_double(&z1[i],unsortout);
      }

   SEEIT_fwrite_int(&IDN2,unsortout);
   GetAppropIDnumber(IDN2, &ML2[0]);
   i = strlen(ML2);
   SEEIT_fwrite_int(&i,unsortout);
   fwrite(&ML2[0],i,1,unsortout); /** writing 'i' 1-byte chars, endian neutral, so just use a mass write **/
   SEEIT_fwrite_int(&SCCtable[index2].ECC,unsortout);
   fwrite(&gform2,1,1,unsortout);
   SEEIT_fwrite_int(&Lindex2,unsortout);
   SEEIT_fwrite_double(&localid2, unsortout);
   SEEIT_fwrite_double(&radius2, unsortout);
   SEEIT_fwrite_double(&height2, unsortout);
   SEEIT_fwrite_int(&numverts2,unsortout);


   for(i=0; i<numverts2; i++)
      {
      SEEIT_fwrite_double(&x2[i],unsortout);
      SEEIT_fwrite_double(&y2[i],unsortout);
      SEEIT_fwrite_double(&z2[i],unsortout);
      }

   DrawNewCondition(keyval, Cnumber, pointX,pointY,pointZ,1,  /**** px, py, pz, PtUsed ***/
             Lindex1, index1, gform1, MessageLine,
             x1, y1, z1, numverts1,
             Lindex2, index2, gform2,ML2, x2,y2,z2,numverts2);

   NUMBEROFCONDITIONS += 1;
}





void FwriteMagnitudeAndTwoObjects(int keyval, int Cnumber, double magnitude, 
                        int index1, char gform1, int Lindex1, double LocalID1, int IDN1, double radius1, double height1,
                        double *x1, double *y1, double *z1, int numverts1,
                        int index2, char gform2, int Lindex2, double LocalID2, int IDN2, double radius2, double height2,
                        double *x2, double *y2, double *z2, int numverts2)
{
int i;
char ML2[300];
   if(unsortout == NULL)
      return;



   SEEIT_fwrite_int(&keyval,unsortout);
   SEEIT_fwrite_int(&Cnumber,unsortout);

   SEEIT_fwrite_double(&magnitude,unsortout);
   SEEIT_fwrite_int(&IDN1,unsortout);
   GetAppropIDnumber(IDN1, &MessageLine[0]);
   i = strlen(MessageLine);
   SEEIT_fwrite_int(&i,unsortout);
   fwrite(&MessageLine[0],i,1,unsortout); /** writing 'i' 1-byte chars, endian neutral, so just use a mass write **/
   SEEIT_fwrite_int(&SCCtable[index1].ECC, unsortout);

   fwrite(&gform1,1,1,unsortout);
   SEEIT_fwrite_int(&Lindex1,unsortout);
   SEEIT_fwrite_double(&LocalID1, unsortout);
   SEEIT_fwrite_double(&radius1, unsortout);
   SEEIT_fwrite_double(&height1, unsortout);
   SEEIT_fwrite_int(&numverts1,unsortout);


   for(i=0; i<numverts1; i++)
      {
      SEEIT_fwrite_double(&x1[i],unsortout);
      SEEIT_fwrite_double(&y1[i],unsortout);
      SEEIT_fwrite_double(&z1[i],unsortout);
      }

   /***SEEIT_fwrite_int(&index2,unsortout);***/
   SEEIT_fwrite_int(&IDN2,unsortout);
   GetAppropIDnumber(IDN2, &ML2[0]);
   i = strlen(ML2);
   SEEIT_fwrite_int(&i,unsortout);
   fwrite(&ML2[0],i,1,unsortout); /** writing 'i' 1-byte chars, endian neutral, so just use a mass write **/
   SEEIT_fwrite_int(&SCCtable[index2].ECC, unsortout);
   fwrite(&gform2,1,1,unsortout);
   SEEIT_fwrite_int(&Lindex2,unsortout);
   SEEIT_fwrite_double(&LocalID2, unsortout);
   SEEIT_fwrite_double(&radius2, unsortout);
   SEEIT_fwrite_double(&height2, unsortout);
   SEEIT_fwrite_int(&numverts2,unsortout);


   for(i=0; i<numverts2; i++)
      {
      SEEIT_fwrite_double(&x2[i],unsortout);
      SEEIT_fwrite_double(&y2[i],unsortout);
      SEEIT_fwrite_double(&z2[i],unsortout);
      }

   DrawNewCondition(keyval, Cnumber, 0, 0, 0, 0,  /**** px, py, pz, PtUsed ***/
             Lindex1, index1, gform1, MessageLine,
             x1, y1, z1, numverts1,
             Lindex2, index2, gform2,ML2, x2,y2,z2,numverts2);

   NUMBEROFCONDITIONS += 1;
}





void FwritePointAndObject(int keyval, int Cnumber, double pointX, double pointY, double pointZ, int pointIDN,
                                  int index1, char gform1, int Lindex, double localid, int IDN1, double radius1, double height1,
                                  double *x1, double *y1, double *z1, int numverts1)
{
int i;
   if(unsortout == NULL)
      return;

   SEEIT_fwrite_int(&keyval,unsortout);
   SEEIT_fwrite_int(&Cnumber,unsortout);
   SEEIT_fwrite_double(&pointX,unsortout);
   SEEIT_fwrite_double(&pointY,unsortout);
   SEEIT_fwrite_double(&pointZ,unsortout);
   SEEIT_fwrite_int(&pointIDN,unsortout);
   GetAppropIDnumber(pointIDN, &MessageLine[0]);
   i = strlen(MessageLine);
   SEEIT_fwrite_int(&i,unsortout);
   fwrite(&MessageLine[0],i,1,unsortout); /** writing 'i' 1-byte chars, endian neutral, so just use a mass write **/
   /***SEEIT_fwrite_int(&index1,unsortout);***/
   SEEIT_fwrite_int(&IDN1,unsortout);
   GetAppropIDnumber(IDN1, &MessageLine[0]);
   i = strlen(MessageLine);
   SEEIT_fwrite_int(&i,unsortout);
   fwrite(&MessageLine[0],i,1,unsortout); /** writing 'i' 1-byte chars, endian neutral, so just use a mass write **/
   SEEIT_fwrite_int(&SCCtable[index1].ECC, unsortout);
   fwrite(&gform1,1,1,unsortout);
   SEEIT_fwrite_int(&Lindex,unsortout);
   SEEIT_fwrite_double(&localid, unsortout);
   SEEIT_fwrite_double(&radius1, unsortout);
   SEEIT_fwrite_double(&height1, unsortout);
   SEEIT_fwrite_int(&numverts1,unsortout);


   for(i=0; i<numverts1; i++)
      {
      SEEIT_fwrite_double(&x1[i],unsortout);
      SEEIT_fwrite_double(&y1[i],unsortout);
      SEEIT_fwrite_double(&z1[i],unsortout);
      }

   DrawNewCondition(keyval, Cnumber, pointX,pointY,pointX,1,  /**** px, py, pz, PtUsed ***/
             Lindex, index1, gform1, MessageLine,
             x1, y1, z1, numverts1,
             0, 0, -1, NULL, NULL, NULL, NULL, 0);/*** Lindex2, index2, gform2, IDStr2, x,y,z,numverts2 ***/

   NUMBEROFCONDITIONS += 1;
}




void FwritePointAndTwoObjects(int keyval, int Cnumber, double pointX, double pointY, double pointZ,
                                  int index1, char gform1, int Lindex1, double localid1, int IDN1, double radius1, double height1,
                                  double *x1, double *y1, double *z1, int numverts1,
                                  int index2, char gform2, int Lindex2, double localid2, int IDN2, double radius2, double height2,
                                  double *x2, double *y2, double *z2, int numverts2)
{
int i;
char ML2[300];
/**FILE *fout;**/
   if(unsortout == NULL)
      return;


   SEEIT_fwrite_int(&keyval,unsortout);
   SEEIT_fwrite_int(&Cnumber,unsortout);
   SEEIT_fwrite_double(&pointX,unsortout);
   SEEIT_fwrite_double(&pointY,unsortout);
   SEEIT_fwrite_double(&pointZ,unsortout);
   /***SEEIT_fwrite_int(&index1,unsortout);***/
   SEEIT_fwrite_int(&IDN1,unsortout);
   GetAppropIDnumber(IDN1, &MessageLine[0]);
   i = strlen(MessageLine);
   SEEIT_fwrite_int(&i,unsortout);
   fwrite(&MessageLine[0],i,1,unsortout); /** writing 'i' 1-byte chars, endian neutral, so just use a mass write **/
   SEEIT_fwrite_int(&SCCtable[index1].ECC,unsortout);
   fwrite(&gform1,1,1,unsortout);
   SEEIT_fwrite_int(&Lindex1,unsortout);
   SEEIT_fwrite_double(&localid1, unsortout);
   SEEIT_fwrite_double(&radius1, unsortout);
   SEEIT_fwrite_double(&height1, unsortout);
   SEEIT_fwrite_int(&numverts1,unsortout);


   for(i=0; i<numverts1; i++)
      {
      SEEIT_fwrite_double(&x1[i],unsortout);
      SEEIT_fwrite_double(&y1[i],unsortout);
      SEEIT_fwrite_double(&z1[i],unsortout);
      }

   /****SEEIT_fwrite_int(&index2,unsortout);***/
   SEEIT_fwrite_int(&IDN2,unsortout);
   GetAppropIDnumber(IDN2, &ML2[0]);
   i = strlen(ML2);
   SEEIT_fwrite_int(&i,unsortout);
   fwrite(&ML2[0],i,1,unsortout); /** writing 'i' 1-byte chars, endian neutral, so just use a mass write **/
   SEEIT_fwrite_int(&SCCtable[index2].ECC,unsortout);
   fwrite(&gform2,1,1,unsortout);
   SEEIT_fwrite_int(&Lindex2,unsortout);
   SEEIT_fwrite_double(&localid2, unsortout);
   SEEIT_fwrite_double(&radius2, unsortout);
   SEEIT_fwrite_double(&height2, unsortout);
   SEEIT_fwrite_int(&numverts2,unsortout);


   for(i=0; i<numverts2; i++)
      {
      SEEIT_fwrite_double(&x2[i],unsortout);
      SEEIT_fwrite_double(&y2[i],unsortout);
      SEEIT_fwrite_double(&z2[i],unsortout);
      }

   DrawNewCondition(keyval, Cnumber, pointX,pointY,pointZ,1,  /**** px, py, pz, PtUsed ***/
             Lindex1, index1, gform1, MessageLine,
             x1, y1, z1, numverts1,
             Lindex2, index2, gform2,ML2, x2,y2,z2,numverts2);

   NUMBEROFCONDITIONS += 1;
}





void FwriteTwoObjects(int keyval, int Cnumber,
		  int IDN1, char gform1, int Lindex1, double localid1, int index1, double radius1, double height1,
                  int numverts1, double *x1, double *y1,  double *z1,
		  int IDN2, char gform2, int Lindex2, double localid2, int index2, double radius2, double height2,
                  int numverts2, double *x2, double *y2,  double *z2)
{
int i;
char ML2[300];

   if(unsortout == NULL)
      return;

   SEEIT_fwrite_int(&keyval,unsortout);
   SEEIT_fwrite_int(&Cnumber,unsortout);

   SEEIT_fwrite_int(&IDN1, unsortout);
   GetAppropIDnumber(IDN1, &MessageLine[0]);
   i = strlen(MessageLine);
   SEEIT_fwrite_int(&i,unsortout);
   MessageLine[i] = '\0';
   fwrite(&MessageLine[0],i,1,unsortout); /** writing 'i' 1-byte chars, endian neutral, so just use a mass write **/

   SEEIT_fwrite_int(&SCCtable[index1].ECC,unsortout);
   fwrite(&gform1,1,1,unsortout);

   SEEIT_fwrite_int(&Lindex1,unsortout);

   SEEIT_fwrite_double(&localid1,unsortout);

   SEEIT_fwrite_double(&radius1,unsortout);

   SEEIT_fwrite_double(&height1, unsortout);

   /*** SEEIT_fwrite_int(&index1, unsortout); ****/

   SEEIT_fwrite_int(&numverts1, unsortout);
   for (i=0; i<numverts1; i++)
      {
      SEEIT_fwrite_double(&x1[i], unsortout);
      SEEIT_fwrite_double(&y1[i], unsortout);
      SEEIT_fwrite_double(&z1[i], unsortout);
      }

   SEEIT_fwrite_int(&IDN2, unsortout);
   GetAppropIDnumber(IDN2, &MessageLine[0]);
   i = strlen(MessageLine);
   MessageLine[i] = '\0';
   SEEIT_fwrite_int(&i,unsortout);
   fwrite(&MessageLine[0],i,1,unsortout); /** writing 'i' 1-byte chars, endian neutral, so just use a mass write **/
   
   SEEIT_fwrite_int(&SCCtable[index2].ECC,unsortout);

   fwrite(&gform2,1,1,unsortout);

   SEEIT_fwrite_int(&Lindex2,unsortout);

   SEEIT_fwrite_double(&localid2,unsortout);

   SEEIT_fwrite_double(&radius2,unsortout);

   SEEIT_fwrite_double(&height2, unsortout);

   /***SEEIT_fwrite_int(&index2, unsortout);***/
   SEEIT_fwrite_int(&numverts2, unsortout);
   for (i=0; i<numverts2; i++)
      {
      SEEIT_fwrite_double(&x2[i], unsortout);
      SEEIT_fwrite_double(&y2[i], unsortout);
      SEEIT_fwrite_double(&z2[i], unsortout);
      }

   DrawNewCondition(keyval, Cnumber, 0, 0, 0, 0,  /**** px, py, pz, PtUsed ***/
             Lindex1, index1, gform1, MessageLine,
             x1, y1, z1, numverts1,
             Lindex2, index2, gform2,ML2, x2,y2,z2,numverts2);

   NUMBEROFCONDITIONS += 1;

   return;

}


void FwriteObjectAndMessage(int keyval, int Cnumber,
                            int IDN, char gform, int Lindex, double localid, int index, double radius, double height,
                            double *x, double *y, double *z, int numverts, char *msg)
{
int i;

   if(unsortout == NULL)
      return;

   SEEIT_fwrite_int(&keyval,unsortout);
   SEEIT_fwrite_int(&Cnumber,unsortout);
   SEEIT_fwrite_int(&IDN,unsortout);
   GetAppropIDnumber(IDN, &MessageLine[0]);
   i = strlen(MessageLine);
/***printf("writing %d strlen for message %s\n",i,MessageLine); ***/
   SEEIT_fwrite_int(&i,unsortout);
   fwrite(&MessageLine[0],i,1,unsortout); /** writing 'i' 1-byte chars, endian neutral, so just use a mass write **/

   SEEIT_fwrite_int(&SCCtable[index].ECC,unsortout);
   fwrite(&gform,1,1,unsortout);

   SEEIT_fwrite_int(&Lindex,unsortout);

   SEEIT_fwrite_double(&localid,unsortout);

   /***SEEIT_fwrite_int(&index,unsortout);***/
   SEEIT_fwrite_double(&radius,unsortout);

   SEEIT_fwrite_double(&height, unsortout);

   i = strlen(msg);

/***printf("   part 2: writing %d strlen for message %s\n",i,msg); ***/
   SEEIT_fwrite_int(&i,unsortout);
   fwrite(&msg[0],1,i,unsortout);
   SEEIT_fwrite_int(&numverts,unsortout);

   for(i=0; i<numverts; i++)
      {
      SEEIT_fwrite_double(&x[i],unsortout);
      SEEIT_fwrite_double(&y[i],unsortout);
      SEEIT_fwrite_double(&z[i],unsortout);
      }

   DrawNewCondition(keyval, Cnumber, 0, 0, 0, 0,  /**** px, py, pz, PtUsed ***/
             Lindex, index, gform, MessageLine,
             x, y, z, numverts,
             0,0,-1,NULL, NULL, NULL, NULL, 0);

   NUMBEROFCONDITIONS += 1;

}


void FwriteObjectAndMagnitude(int keyval, int Cnumber, int IDN,
                             int index, char gform, int Lindex, double localid,  double radius, double height,
                             double magnitude, double *x, double *y, double *z, int numverts, int DrawNow)
{
int i;
   if(unsortout == NULL)
      return;

   SEEIT_fwrite_int(&keyval,unsortout);
   SEEIT_fwrite_int(&Cnumber,unsortout);
/****printf("keyval is %d Cnumber is %d\n",keyval,Cnumber);****/
   SEEIT_fwrite_double(&magnitude,unsortout);
   SEEIT_fwrite_int(&IDN,unsortout);
   GetAppropIDnumber(IDN, &MessageLine[0]);
   i = strlen(MessageLine);
   SEEIT_fwrite_int(&i,unsortout);
   fwrite(&MessageLine[0],i,1,unsortout); /** writing 'i' 1-byte chars, endian neutral, so just use a mass write **/
   SEEIT_fwrite_int(&SCCtable[index].ECC,unsortout);
   fwrite(&gform,1,1,unsortout);
   SEEIT_fwrite_int(&Lindex,unsortout);
   SEEIT_fwrite_double(&localid,unsortout);
   /**SEEIT_fwrite_int(&index,unsortout);***/
   SEEIT_fwrite_double(&radius,unsortout);
   SEEIT_fwrite_double(&height, unsortout);
   SEEIT_fwrite_int(&numverts,unsortout);

   for(i=0; i<numverts; i++)
      {
      SEEIT_fwrite_double(&x[i],unsortout);
      SEEIT_fwrite_double(&y[i],unsortout);
      SEEIT_fwrite_double(&z[i],unsortout);
      }

   if(DrawNow > 0)
      {
      DrawNewCondition(keyval, Cnumber, 0, 0, 0, 0,  /**** px, py, pz, PtUsed ***/
             Lindex, index, gform, MessageLine,
             x, y, z, numverts,
             0,0,-1,NULL, NULL, NULL, NULL, 0);
      }

   NUMBEROFCONDITIONS += 1;
}


void FwritePointEdgeAndMagnitude(int keyval, int Cnumber,  double magnitude, int IDN1, char gform1,
                                 int Lindex1, double localid1,
                                 int index1, double px, double py, double pz, int index2, int IDN2, char gform2,
                                 int Lindex2, double localid2,
                                 double ex1, double ey1, double ez1, double ex2, double ey2, double ez2,
                                 double *x, double *y, double *z)
{
int i;
char ML2[300];

   if(unsortout == NULL)
      return;

   SEEIT_fwrite_int(&keyval,unsortout);
   SEEIT_fwrite_int(&Cnumber,unsortout);
   SEEIT_fwrite_double(&magnitude,unsortout);

   /***/SEEIT_fwrite_int(&IDN1,unsortout); /***/
   GetAppropIDnumber(IDN1, &MessageLine[0]);
   i = strlen(MessageLine);
   SEEIT_fwrite_int(&i,unsortout);
   fwrite(&MessageLine[0],i,1,unsortout); /** writing 'i' 1-byte chars, endian neutral, so just use a mass write **/
   SEEIT_fwrite_int(&SCCtable[index1].ECC, unsortout);
   fwrite(&gform1,1,1,unsortout);

   SEEIT_fwrite_int(&Lindex1,unsortout);
   SEEIT_fwrite_double(&localid1,unsortout);
   SEEIT_fwrite_double(&px,unsortout);
   SEEIT_fwrite_double(&py,unsortout);
   SEEIT_fwrite_double(&pz,unsortout);

   /***SEEIT_fwrite_int(&index1,unsortout);***/

   SEEIT_fwrite_int(&IDN2,unsortout);
   GetAppropIDnumber(IDN2, &ML2[0]);
   i = strlen(ML2);
   SEEIT_fwrite_int(&i,unsortout);
   fwrite(&ML2[0],i,1,unsortout); /** writing 'i' 1-byte chars, endian neutral, so just use a mass write **/
   SEEIT_fwrite_int(&SCCtable[index2].ECC, unsortout);
   fwrite(&gform2,1,1,unsortout);
   SEEIT_fwrite_int(&Lindex2,unsortout);
   SEEIT_fwrite_double(&localid2,unsortout);
   /***SEEIT_fwrite_int(&index2,unsortout);***/
   SEEIT_fwrite_double(&ex1,unsortout);
   SEEIT_fwrite_double(&ey1,unsortout);
   SEEIT_fwrite_double(&ez1,unsortout);
   SEEIT_fwrite_double(&ex2,unsortout);
   SEEIT_fwrite_double(&ey2,unsortout);
   SEEIT_fwrite_double(&ez2,unsortout);

   DrawNewCondition(keyval, Cnumber, px,py,pz,1,  /**** px, py, pz, PtUsed ***/
             Lindex1, index1, gform1, MessageLine,
             x, y, z, 1,
             Lindex2, index2, gform2,ML2, &x[1], &y[1], &z[1], 2);

   NUMBEROFCONDITIONS += 1;

   return;
}




void FwritePointObjectAndMagnitude(int keyval, int Cnumber,  double magnitude, int IDN1, char gform1,
                                 int Lindex1, double localid1,
                                 int index1, double px, double py, double pz, int index2, int IDN2, char gform2,
                                 int Lindex2, double localid2, int numverts, double *x, double *y, double *z)
{
int i;
char ML2[300];

   if(unsortout == NULL)
      return;

   SEEIT_fwrite_int(&keyval,unsortout);
   SEEIT_fwrite_int(&Cnumber,unsortout);
   SEEIT_fwrite_double(&magnitude,unsortout);

   /***/SEEIT_fwrite_int(&IDN1,unsortout);/***/
   GetAppropIDnumber(IDN1, &MessageLine[0]);
   i = strlen(MessageLine);
   SEEIT_fwrite_int(&i,unsortout);
   fwrite(&MessageLine[0],i,1,unsortout); /** writing 'i' 1-byte chars, endian neutral, so just use a mass write **/
   SEEIT_fwrite_int(&SCCtable[index1].ECC, unsortout);
   fwrite(&gform1,1,1,unsortout);
   SEEIT_fwrite_int(&Lindex1,unsortout);
   SEEIT_fwrite_double(&localid1,unsortout);
   SEEIT_fwrite_double(&px,unsortout);
   SEEIT_fwrite_double(&py,unsortout);
   SEEIT_fwrite_double(&pz,unsortout);

   /***SEEIT_fwrite_int(&index1,unsortout);***/

   SEEIT_fwrite_int(&IDN2,unsortout);
   GetAppropIDnumber(IDN2, &ML2[0]);
   i = strlen(ML2);
   SEEIT_fwrite_int(&i,unsortout);
   fwrite(&ML2[0],i,1,unsortout); /** writing 'i' 1-byte chars, endian neutral, so just use a mass write **/
   if((keyval == AREAKINK) || (keyval == INCLSLIVER))
      {
      i = -1;
      }
   else
      {
      i = SCCtable[index2].ECC;
      }

   SEEIT_fwrite_int(&i, unsortout);
   fwrite(&gform2,1,1,unsortout);
   SEEIT_fwrite_int(&Lindex2,unsortout);
   SEEIT_fwrite_double(&localid2,unsortout);
   SEEIT_fwrite_int(&numverts,unsortout);

   for(i=0; i<numverts; i++)
      {
      SEEIT_fwrite_double(&x[i],unsortout);
      SEEIT_fwrite_double(&y[i],unsortout);
      SEEIT_fwrite_double(&z[i],unsortout);
      }

   DrawNewCondition(keyval, Cnumber, 0,0,0,0,  /**** px, py, pz, PtUsed ***/
             Lindex1, index1, gform1, MessageLine,
             &px, &py, &pz, 1,
             Lindex2, index2, gform2,ML2, &x[0], &y[0], &z[0], numverts);

   NUMBEROFCONDITIONS += 1;

   return;
}





int InsertIntoLongList(long int value, int filenumber, int indexlimit, struct LongList **LongListRoot,
                       struct LongSkipList * Skip, int *SkipEntryIndex)
{
struct LongList *cll, *pll, *nll;

int SzLL = sizeof(struct LongList);
int i,j, k, counter;
int reinsert = 0;
int skipinterval = 1000;
int answer;

   if(*LongListRoot == NULL)
      {
      cll = (struct LongList *) (malloc(SzLL));
      if(cll == NULL)
         {
         printf("allocation memory exhausted during long list processing\n");
         exit(-1);
         }
      cll->fp = value;
      cll->fn = filenumber;
      cll->next = NULL;
      *LongListRoot = cll;
      answer = 1;
      *SkipEntryIndex = 0;
      }
   else
      {
      i = *SkipEntryIndex;
      if((Skip == NULL) || (indexlimit == 0))
         i = 0;
      else if((Skip[i].val > value) || (Skip[i].val < 0))
         i = 0;
      while((i < indexlimit) && (Skip[i].entry != NULL) && (Skip[i].val < value))
         ++i;
      if(i > 0)
         {
         --i;
         *SkipEntryIndex = i;
         j = counter = i * skipinterval;
         nll = Skip[i].entry;
         pll = nll->next;
         }
      else
         {
         nll = pll = *LongListRoot;
         counter = 1;
         j = 0;
         *SkipEntryIndex = 0;
         }
      while(pll != NULL)
         {
         if(pll->fp >= value)
            break;
         if((counter % skipinterval) == 0)
            {
            if(counter > j)
               {
               i = (counter / skipinterval) - 1;
               if(i < indexlimit)
                  {
                  Skip[i].val = pll->fp;
                  Skip[i].entry = nll;
                  }
               }
            }
         ++counter;
         nll = pll;
         pll = pll->next;
         }
      if((pll != NULL) && (pll->fp == value))
         {
         answer = 0;
         }
      else
         {
         answer = 1;
         cll = (struct LongList *) (malloc(SzLL));
         if(cll == NULL)
            {
            printf("allocation memory exhausted during long list processing\n");
            exit(-1);
            }
         cll->fp = value;
         cll->fn = filenumber;
         cll->next = NULL;

         if(pll == *LongListRoot)
            {
            cll->next = *LongListRoot;
            *LongListRoot = cll;
            }
         else if(pll == NULL)
            {
            cll->next = NULL;
            nll->next = cll;
            }
         else
            {
            if((nll->fp <= cll->fp) && (cll->fp <= pll->fp))
               {
               cll->next = pll;
               nll->next = cll;
               }
            else
               {
               nll = pll = *LongListRoot;
               counter = 1;
               while(pll != NULL)
                  {
                  if((reinsert == 0) && (pll->fp >= cll->fp))
                     {
                     reinsert = 1;
                     if(pll == *LongListRoot)
                        {
                        cll->next = *LongListRoot;
                        *LongListRoot = cll;
                        }
                     else
                        {
                        cll->next = pll;
                        nll->next = cll;
                        }
                     }
                  if((counter % skipinterval) == 0)
                     {
                     k = (counter / skipinterval) - 1;
                     if(k < indexlimit)
                        {
                        Skip[k].val = nll->fp;
                        Skip[k].entry = pll;
                        }
                     }
                  ++counter;
                  if(nll->next == cll)
                     nll = nll->next;
                  else
                     nll = pll;
                  pll = pll->next;
                  }
               }
            }
         }
      }
   return(answer);
}






void FreeLongList(struct LongList **LLroot)
{
struct LongList *cll, *pll;
   cll = *LLroot;
   while(cll != NULL)
      {
      pll = cll;
      cll= cll->next;
      free(pll);
      }
   *LLroot = NULL;
}



void InsertIntoEdgeList(struct ListOfEdges *e, struct ListOfEdges ** root,
                              struct DoubleEdgeSkipList *Skip, int indexlimit)
{
struct ListOfEdges *c, *p;
int k, kc, counter;
int reinsert = 0;
int skipinterval = 100;

   if(*root == NULL)
      {
      *root = e;
      }
   else
      {
      k = 0;
      while((k < indexlimit) && (Skip[k].entry != NULL) && (Skip[k].val < e->minx))
        ++k;
      if(k > 0)
         {
         --k;
         kc = counter = k * skipinterval;
         p = Skip[k].entry;
         c = p->next;
         }
      else
         {
         p = c = *root;
         counter = 1;
         kc = 0;
         }
      while((c != NULL) && (c->minx < e->minx))
         {
         if((counter % skipinterval) == 0)
            {
            if(counter > kc)
               {
               k = (counter / skipinterval) - 1;
               if(k < indexlimit)
                  {
                  Skip[k].val = p->minx;
                  Skip[k].entry = c;
                  }
               }
            }
         ++counter;
         p = c;
         c = c->next;
         }
      if(c == *root)
         {
         e->next = *root;
         *root = e;
         }
      else if(c == NULL)
         {
         p->next = e;
         e->next = NULL;
         }
      else
         {
         if((p->minx <= e->minx) && (e->minx <= c->minx))
            {
            p->next = e;
            e->next = c;
            }
         else /** need to re-rack the skip list **/
            {
            p = c = *root;
            counter = 1;
            while(c != NULL)
               {
               if((reinsert == 0) && (c->minx >= e->minx))
                  {
                  reinsert = 1;
                  if(c == *root)
                     {
                     e->next = *root;
                     *root = e;
                     }
                  else
                     {
                     e->next = c;
                     p->next = e;
                     }
                  }
               if((counter % skipinterval) == 0)
                  {
                  k = (counter / skipinterval) - 1;
                  if(k < indexlimit)
                     {
                     Skip[k].val = p->minx;
                     Skip[k].entry = c;
                     }
                  }
               ++counter;
               if(p->next == e)
                  p = p->next;
               else
                  p = c;
               c = c->next;
               }
            }

         }
      }
}




int InsertIntoTearErrList(struct TearErrorSortList * e)
{
  struct TearErrorSortList *ep, *ec;
  int answer;
  int i;
  
  if(VTEARdebud_3)
    ++InsertCount;
  e->next = NULL;
  if(TearRoot == NULL)
    {
      e->next = NULL;
      TearRoot = e;
      answer = 1;
    }
  else
    {
      ep = ec = TearRoot;
      while (ec != NULL)
	{
	  if(ec->magnitude < e->magnitude)  /** insert it here **/
            {
	      answer = 1;
	      if(ec == TearRoot)
		{
		  e->next = TearRoot;
		  TearRoot = e;
		}
	      else
		{
		  e->next = ec;
		  ep->next = e;
		}
	      break;
            }
	  else if(ec->magnitude == e->magnitude)
            {
	      /** may or may not be a duplicate **/
	      if((ec->gform1 == e->gform1) && (ec->gform2 == e->gform2) && (ec->Cnumber==e->Cnumber))
		{
		  if((ec->IDN1 == e->IDN1) && (ec->IDN2 == e->IDN2)) 
		    {
		      if((ec->numverts1 == e->numverts1) && (ec->numverts2 == e->numverts2))
			{
			  /** no need to insert as must be a duplicate ***/
			  answer = 0;
			  break;
			}
		      else if((ec->numverts1 > e->numverts1) || (ec->numverts2 > e->numverts2))
			{
			  /** no need to insert as one on list has an edge & new one is a 'T' ***/
			  answer = 0;
			  break;
			}
		      else if((ec->numverts1 < e->numverts1) || (ec->numverts2 < e->numverts2))
			{
			  /** need to replace entry in the list with the newer one ***/
			  answer = 0; /* free value on return **/
			  
			  ec->keyval = e->keyval;
			  ec->Cnumber = e->Cnumber;
			  ec->magnitude = e->magnitude;
			  ec->index1 = e->index1;
			  ec->index2 = e->index2;
			  ec->gform1 = e->gform1;
			  ec->gform2 = e->gform2;
			  ec->IDN1 = e->IDN1;
			  ec->IDN2 = e->IDN2;
                          ec->Lindex1 = e->Lindex1;
                          ec->Lindex2 = e->Lindex2;
                          ec->localID1 = e->localID1;
                          ec->localID2 = e->localID2;
			  ec->radius1 = e->radius1;
			  ec->height1 = e->height1;
			  ec->radius2 = e->radius2;
			  ec->height2 = e->height2;
			  ec->numverts1 = e->numverts1;
			  ec->numverts2 = e->numverts2;
			  for(i=0; i<2; i++)
			    {
			      ec->x1[i] = e->x1[i];
			      ec->y1[i] = e->y1[i];
			      ec->z1[i] = e->z1[i];
			      ec->x2[i] = e->x2[i];
			      ec->y2[i] = e->y2[i];
			      ec->z2[i] = e->z2[i];
			    }
			  break;
			}
		    }
		  else if((ec->IDN2 == e->IDN1) && (ec->IDN1 == e->IDN2))
		    {
		      if((ec->numverts2 == e->numverts1) && (ec->numverts1 == e->numverts2))
			{
			  /** no need to insert as must be a duplicate ***/
			  answer = 0;
			  break;
			}
		      else if((ec->numverts2 > e->numverts1) || (ec->numverts1 > e->numverts2))
			{
			  /** no need to insert as one on list has an edge & new one is a 'T' ***/
			  answer = 0;
			  break;
			}
		      else if((ec->numverts2 < e->numverts1) || (ec->numverts1 < e->numverts2))
			{
			  /** need to replace entry in the list with the newer one ***/
			  answer = 0; /* free value on return **/
			  
			  ec->keyval = e->keyval;
			  ec->Cnumber = e->Cnumber;
			  ec->magnitude = e->magnitude;
			  ec->index1 = e->index1;
			  ec->index2 = e->index2;
			  ec->gform1 = e->gform1;
			  ec->gform2 = e->gform2;
			  ec->IDN1 = e->IDN1;
			  ec->IDN2 = e->IDN2;
                          ec->Lindex1 = e->Lindex1;
                          ec->Lindex2 = e->Lindex2;
                          ec->localID1 = e->localID1;
                          ec->localID2 = e->localID2;
			  ec->radius1 = e->radius1;
			  ec->height1 = e->height1;
			  ec->radius2 = e->radius2;
			  ec->height2 = e->height2;
			  ec->numverts1 = e->numverts1;
			  ec->numverts2 = e->numverts2;
			  for(i=0; i<2; i++)
			    {
			      ec->x1[i] = e->x1[i];
			      ec->y1[i] = e->y1[i];
			      ec->z1[i] = e->z1[i];
			      ec->x2[i] = e->x2[i];
			      ec->y2[i] = e->y2[i];
			      ec->z2[i] = e->z2[i];
			    }
			  
			  break;
			}
		    }
		}
            }
	  ep = ec;
	  ec = ec->next;
	}
      if(ec == NULL)
	{
	  answer = 1; /** actually did the insertion **/
	  e->next = NULL;
	  ep->next = e;
	}
    }
  return(answer);
}




int ThreePointsAreColinear(double *x, double *y, double *z)
{
int answer = 0;
double t,t2;
   if(x[1] == x[2])
      {
      if(x[0] == x[1])
         {
         if(y[1] == y[2])
            {
            if(y[1] == y[0])
               answer = 1;
            }
         else if(z[1] == z[2])
            {
            if(z[1] == z[0])
               answer = 1;
            }
         else
            {
            t = (y[0] - y[1]) / (y[2] - y[1]);
            t2 = z[0] - (z[1] + (z[2] - z[1]) * t);
            if((-0.0001 < t2) && (t2 < 0.0001)) /***/
               answer = 1;
            }
         }
      }
   else
      {
      t = (x[0] - x[1]) / (x[2] - x[1]);
      t2 = y[0] - (y[1] + (y[2] - y[1]) * t);
      if((-0.0001 < t2) && (t2 < 0.0001))
         {
         t2 = z[0] - (z[1] + (z[2] - z[1]) * t);
         if((-0.0001 < t2) && (t2 < 0.0001))
            answer = 1;
         }
      }
   return(answer);
}






unsigned char AssignDrawingColor(int fid, unsigned char D, int crsindex)
{
  int LODnum;
  extern unsigned long mycolors[300];
  extern int DOMAIN_DEFAULT_COLOR[NUM_D];
  extern int LLFidTableCount;
  extern unsigned char *FidMarkTable;


  if (((crsindex >= 0) && (crsindex < SACfull) &&
       (CrsWlk[crsindex].toggle > 0)
       ) /** its on the marker list **/
      )
    {
      return HighLightColor;
    }


  if(fid>=0)
    {
      if(fid>=LLFidTableCount)
        {
          printf("error in ADC: passed fid %d but max is %d\n",fid,LLFidTableCount-1);
        }
      else if(FidMarkTable[fid]==1)
        {
          return HighLightColor;
        }
    }



  /* if there's an overriding LOD color, use that */

  if(crsindex>=0)
    {
      LODnum = CrsWlk[crsindex].LODband;
      if(LODnum > 0)
        {
          LODnum = LODnum - 1;
          if(LODindex[LODnum].color>=0)
            {
              mycolors[239] = LODindex[LODnum].color;
              return 239;
            }
        }
    }


  if(NGA_TYPE==1)
    {
      printf("GAIT color problem %d\n",crsindex);
    }

  /* should never happen */
  return DOMAIN_DEFAULT_COLOR[D];

}





int ReadPolySetup(double *digits, int index1, int index2, int *singles,
            int *multiples, int *compositeindex)
{
int HadToOpenFile = 0;

   *compositeindex = (index1 * (MaxYindex + 1)) + index2;
   *digits = SignificantDecimals;

   if(NGA_TYPE == 0)
      {
      if(fin == NULL)
         {
         fin = fopen(infile,"rb");
         if(fin == NULL)
            {
            printf("Could not open %s for processing \n",infile);
            printf("   3: No processing can occur without this basic input file\n");
            exit(-1);
            }
         else
            HadToOpenFile = 1;
         }
      fseek(fin,PolyTable[*compositeindex].fileptr,SEEK_SET);
      *singles = PolyTable[*compositeindex].numinside;
      *multiples = PolyTable[*compositeindex].numother;
      }
   else
      {
      *singles = 0;
      *multiples = 0;
      HadToOpenFile = 0;
      fin = NULL;
      }


   return(HadToOpenFile);
}




/***  the decimalplaces is a double to multiply the 'as read'
value by before casting to a long int, effecting truncation,
(and then dividing by decimalplaces to return to original scale).
For efficiency, this value is passed in, so it does not need to be
calculated on every polygon read  ***/
int ReadPolyFromFile(FILE * polyfile, double decimalplaces)
{
int i;
int vtxcnt = 0;
double xf, yf, zf;


   if(feof(polyfile) != 0)
      return(vtxcnt);

   SEEIT_fread_int(&PolyFromFile.SACindex,polyfile); /** index into list of SAC tags and values **/

   if(feof(polyfile) != 0)
      return(vtxcnt);

   SEEIT_fread_int(&PolyFromFile.SCCindex,polyfile);  /** index into SCC table **/
   SEEIT_fread_int(&PolyFromFile.idn,polyfile);  /** poly id # **/
   SEEIT_fread_int(&PolyFromFile.TblIdn,polyfile);  /** location (vertex) table id #, -1 if no location table used **/
   SEEIT_fread_int(&vtxcnt,polyfile); /** number of vertices **/


   PolyFromFile.numverts = (int) vtxcnt;


   i = (int) PolyFromFile.SCCindex;
   PolyFromFile.config = (unsigned char) SCCtable[i].C;
   PolyFromFile.stratum = (unsigned char) SCCtable[i].S;
   PolyFromFile.domain = (unsigned char) SCCtable[i].D;

   if(vtxcnt > 0)
      {
      PolyFromFile.x = (double *) (malloc(SzD * vtxcnt));
      PolyFromFile.y = (double *) (malloc(SzD * vtxcnt));
      PolyFromFile.z = (double *) (malloc(SzD * vtxcnt));
      if((PolyFromFile.x == NULL) || (PolyFromFile.y == NULL) || (PolyFromFile.z == NULL))
         {
         printf("allocation memory exhausted during attempt to read polygon with %d vertices\n",vtxcnt);
         printf("processing cannot continue without additional allocatable memory\n");
         exit(-1);
         }
      }
   for(i=0; i<vtxcnt; i++)
      {
      SEEIT_fread_double(&xf,polyfile);
      SEEIT_fread_double(&yf,polyfile);
      SEEIT_fread_double(&zf,polyfile);
      if(AbsoluteAccuracy == 1)
         {
         PolyFromFile.x[i] = xf;
         PolyFromFile.y[i] = yf;
         PolyFromFile.z[i] = zf;
         }
      else
         {
         PolyFromFile.x[i] = TruncNdigs(xf, decimalplaces);
         PolyFromFile.y[i] = TruncNdigs(yf, decimalplaces);
         PolyFromFile.z[i] = zf;
         }
      }
   if(DRAW_ONLY == 0)
      {
      PolyFromFile.minxvtx = PolyFromFile.maxxvtx = PolyFromFile.x[0];
      PolyFromFile.minyvtx = PolyFromFile.maxyvtx = PolyFromFile.y[0];
      for(i=1; i<vtxcnt; i++)
         {
         if(PolyFromFile.x[i] < PolyFromFile.minxvtx)
            PolyFromFile.minxvtx = PolyFromFile.x[i];
         if(PolyFromFile.x[i] > PolyFromFile.maxxvtx)
            PolyFromFile.maxxvtx = PolyFromFile.x[i];

         if(PolyFromFile.y[i] < PolyFromFile.minyvtx)
            PolyFromFile.minyvtx = PolyFromFile.y[i];
         if(PolyFromFile.y[i] > PolyFromFile.maxyvtx)
            PolyFromFile.maxyvtx = PolyFromFile.y[i];
         }
      }
   return(vtxcnt);
}



int CalculateGeodeticCoordArea(double minx,double miny, double *returnarea, double *returnperimeter, int startindex, int stopindex)
{
int i,numlegs;
double Xold, Yold;
double temp, xbase, ybase;
double tx1, ty1, tx2, ty2;
double avglatitude;
double area, perimlength, leglenth;
//double imaginelength;
double TX[3], TY[3];

   i = startindex + 3;
   numlegs = 0;
   if(i == stopindex)
      {
      perimlength = 0;
      for(i=startindex; i<stopindex; i++)
         {
         TX[i-startindex] = ArealFromFile.x[i];
         TY[i-startindex] = ArealFromFile.y[i];

         if(i > startindex)
            {
            leglenth = Distance(ArealFromFile.x[i-1],ArealFromFile.y[i-1],
               ArealFromFile.x[i],ArealFromFile.y[i]);
            perimlength += leglenth;
            ++numlegs;
            }
         else
            {
            perimlength = Distance(ArealFromFile.x[i],ArealFromFile.y[i],
                 ArealFromFile.x[stopindex-1],ArealFromFile.y[stopindex-1]);
            //imaginelength = perimlength;
            }
         }

      area = TriangleXYsurfaceArea(TX,TY);

      if(area < 0)
         area = 0.0 - area;

      *returnarea = area;
      *returnperimeter = perimlength;
         return(1);

      }

   tx1 = MinNativeX;
   ty1 = MinNativeY;
   tx2 = minx / 100000.0 + Xtranslation;
   ty2 = miny / 100000.0 + Ytranslation;

   avglatitude = (ty2 - ty1) / 2.0 + ty1;

    /** convert degrees to radians before call to cosine function ***/
   avglatitude = (avglatitude * PI) / 180.0;

   temp = WGS84degreeLength * cos(avglatitude);
   xbase = (tx2 - tx1) * temp;
   if(xbase < 0)
      xbase = 0 - xbase;


   ybase = WGS84degreeLength * (ty2 - ty1);
   if(ybase < 0)
      ybase = 0 - ybase;


   for(i=0; i<ArealFromFile.numverts; i++)
      {
      tx2 = ArealFromFile.x[i] / 100000.0 + Xtranslation;
      ty2 = ArealFromFile.y[i] / 100000.0 + Ytranslation;

      avglatitude = (ty2 - ty1) / 2.0 + ty1;

    /** convert degrees to radians before call to cosine function ***/
      avglatitude = (avglatitude * PI) / 180.0;

      temp = WGS84degreeLength * cos(avglatitude);
      temp = (tx2 - tx1) * temp;

      ArealForAreaCalculation.x[i] = temp - xbase;

      temp = WGS84degreeLength * (ty2 - ty1);

      ArealForAreaCalculation.y[i] = temp - ybase;

      }

   
   perimlength = 0.0;
   area = 0.0;
   if(stopindex == 0)
      {
      Xold = ArealForAreaCalculation.x[ArealFromFile.numverts - 1];
      Yold = ArealForAreaCalculation.y[ArealFromFile.numverts - 1];
      }
   else
      {
      Xold = ArealForAreaCalculation.x[stopindex - 1];
      Yold = ArealForAreaCalculation.y[stopindex - 1];
      }

   if(startindex < stopindex)
      {
      for(i=startindex; i<stopindex; i++)
         {
         if(i > startindex)
            {
            leglenth = Distance(ArealFromFile.x[i-1],ArealFromFile.y[i-1],
               ArealFromFile.x[i],ArealFromFile.y[i]);
            perimlength += leglenth;
            ++numlegs;
            }
         else
            {
            perimlength = Distance(ArealFromFile.x[i],ArealFromFile.y[i],
                 ArealFromFile.x[stopindex-1],ArealFromFile.y[stopindex-1]);
            //imaginelength = perimlength;
            }
         area += (Xold - ArealForAreaCalculation.x[i]) * (Yold + ArealForAreaCalculation.y[i] - miny);
         Xold = ArealForAreaCalculation.x[i];
         Yold = ArealForAreaCalculation.y[i];
         }
      }
   else
      {
      i = startindex;
      while(i != stopindex)
         {
         if(i > startindex)
            {
            leglenth = Distance(ArealFromFile.x[i-1],ArealFromFile.y[i-1],
               ArealFromFile.x[i],ArealFromFile.y[i]);
            perimlength += leglenth;
            ++numlegs;
            }
         else
            {
            perimlength = Distance(ArealFromFile.x[i],ArealFromFile.y[i],
                 ArealFromFile.x[stopindex-1],ArealFromFile.y[stopindex-1]);
            //imaginelength = perimlength;
            }

         area += (Xold - ArealForAreaCalculation.x[i]) * (Yold + ArealForAreaCalculation.y[i] - miny);
         Xold = ArealForAreaCalculation.x[i];
         Yold = ArealForAreaCalculation.y[i];

         ++i;
         if(i == stopindex)
            break;
         else if(i == ArealFromFile.numverts)
            i = 0;
         }
      }


   if(area < 0)
      area = 0.0 - area;
   area = 0.5 * area;
  
   *returnarea = area;
   *returnperimeter = perimlength;
         return(1);
}





int ReadArealFromFile(FILE * arealfile, double decimalplaces)
{
int i,attr_type;
int vtxcnt = 0;
double fx, fy, fz;
/*** double temp;  ***/
double minx, miny;
double perimlength = 0.0;
double area = 0.0;
/**long int Iarea, Iarea2; **/
double Xold, Yold;
char strtemp[100];
extern int NOTYPE;
extern int C_TYPE;
extern int D_TYPE;
extern int I_TYPE;
extern int LONG_ATTR_CHECK_AREA;
extern int LONG_ATTR_CHECK_HGT;
extern int LONG_ATTR_CHECK_ZV2;
extern int LONG_ATTR_CHECK_NAM;
extern int LONG_ATTR_CHECK_LEN;
extern int GetLongAttrVal(int type,int uniqueid,int *Ival,double *Dval,char *Cval);

   if((arealfile != NULL) && (feof(arealfile) == 0))
      {
      SEEIT_fread_int(&ArealFromFile.featureid,arealfile);
      SEEIT_fread_int(&ArealFromFile.ishole,arealfile);
      SEEIT_fread_int(&ArealFromFile.Lindex,arealfile);
      SEEIT_fread_int(&ArealFromFile.Sindex,arealfile);
      SEEIT_fread_int(&ArealFromFile.idn,arealfile);

      if(running > 0)
         {
         ArealFromFile.areastr[0] = '\0';
         ArealFromFile.hgtstr[0] = '\0';
         ArealFromFile.zv2str[0] = '\0';
         ArealFromFile.lenstr[0] = '\0';
         ArealFromFile.namstr[0] = '\0';
         ArealFromFile.zv2attr = MY2DSENTINEL;
         ArealFromFile.areaattr = MY2DSENTINEL;
         ArealFromFile.hgtattr = MY2DSENTINEL;
         ArealFromFile.lenattr = MY2DSENTINEL;
         ArealFromFile.namattr = MY2DSENTINEL;
         attr_type = GetLongAttrVal(LONG_ATTR_CHECK_AREA,ArealFromFile.idn,&i,&fx,&MessageLine[0]);
         if(attr_type == D_TYPE)
            ArealFromFile.areaattr = fx;
         else if(attr_type == NOTYPE)
            ArealFromFile.areaattr = MY2DSENTINEL;
         else if(attr_type == C_TYPE)
            {
            MessageLine[49] = '\0';
            strcpy(ArealFromFile.areastr,MessageLine); 
            }
         else if(attr_type == I_TYPE)
            ArealFromFile.areaattr = (double) i;

         attr_type = GetLongAttrVal(LONG_ATTR_CHECK_HGT,ArealFromFile.idn,&i,&fx,&MessageLine[0]);
         if(attr_type == D_TYPE)
            ArealFromFile.hgtattr = fx;
         else if(attr_type == NOTYPE)
            ArealFromFile.hgtattr = MY2DSENTINEL;
         else if(attr_type == C_TYPE)
            {
            MessageLine[49] = '\0';
            strcpy(ArealFromFile.hgtstr,MessageLine); 
            }
         else if(attr_type == I_TYPE)
            ArealFromFile.hgtattr = (double) i;
         attr_type = GetLongAttrVal(LONG_ATTR_CHECK_LEN,ArealFromFile.idn,&i,&fx,&MessageLine[0]);
         if(attr_type == D_TYPE)
            ArealFromFile.lenattr = fx;
         else if(attr_type == NOTYPE)
            ArealFromFile.lenattr = MY2DSENTINEL;
         else if(attr_type == C_TYPE)
            {
            MessageLine[49] = '\0';
            strcpy(ArealFromFile.lenstr,MessageLine);
            }
         else if(attr_type == I_TYPE)
            ArealFromFile.lenattr = (double) i;
         attr_type = GetLongAttrVal(LONG_ATTR_CHECK_NAM,ArealFromFile.idn,&i,&fx,&MessageLine[0]);
         if(attr_type == D_TYPE)
            ArealFromFile.namattr = fx;
         else if(attr_type == NOTYPE)
            ArealFromFile.namattr = MY2DSENTINEL;
         else if(attr_type == C_TYPE)
            {
            MessageLine[499] = '\0';
            ArealFromFile.namstr[0] = '"';
            ArealFromFile.namstr[1] = '\0';
            strcat(ArealFromFile.namstr,MessageLine);
            strcat(ArealFromFile.namstr,"\"");
            ArealFromFile.namattr = MY2DSENTINEL;
            //strcpy(ArealFromFile.namstr,MessageLine);
            }
         else if(attr_type == I_TYPE)
            ArealFromFile.namattr = (double) i;

         attr_type = GetLongAttrVal(LONG_ATTR_CHECK_ZV2,ArealFromFile.idn,&i,&fx,&MessageLine[0]);
         if(attr_type == D_TYPE)
            ArealFromFile.zv2attr = fx;
         else if(attr_type == NOTYPE)
            ArealFromFile.zv2attr = MY2DSENTINEL;
         else if(attr_type == C_TYPE)
            {
            MessageLine[49] = '\0';
            strcpy(ArealFromFile.zv2str,MessageLine); 
            }
         else if(attr_type == I_TYPE)
            ArealFromFile.zv2attr = (double) i;
         }
      else
         {
         ArealFromFile.areaattr = MY2DSENTINEL;
         ArealFromFile.hgtattr = MY2DSENTINEL;
         ArealFromFile.zv2attr = MY2DSENTINEL;
         ArealFromFile.lenattr = MY2DSENTINEL;
         ArealFromFile.namattr = MY2DSENTINEL;
         }

      SEEIT_fread_int(&ArealFromFile.numverts,arealfile);
      vtxcnt = ArealFromFile.numverts;
      ArealFromFile.config = (unsigned char) SCCtable[ArealFromFile.Sindex].C;
      ArealFromFile.stratum = (unsigned char) SCCtable[ArealFromFile.Sindex].S;
      ArealFromFile.domain = (unsigned char) SCCtable[ArealFromFile.Sindex].D;
      if(ArealFromFile.MaxVerts == 0)
         {
         ArealFromFile.x = (double *) (malloc(ArealFromFile.numverts * SzD));
         ArealFromFile.y = (double *) (malloc(ArealFromFile.numverts * SzD));
         ArealFromFile.z = (double *) (malloc(ArealFromFile.numverts * SzD));

         ArealFromFile.MaxVerts = ArealFromFile.numverts;

         if(NeedIntersectingArealCalc > 0)
            {
            Areal1ForIntersections = (int *) (malloc(ArealFromFile.MaxVerts  * SzI));
            Areal2ForIntersections = (int *) (malloc(ArealFromFile.MaxVerts  * SzI));
            Areal1Shared = (int *) (malloc(SzI* ArealFromFile.MaxVerts));
            Areal2Shared = (int *) (malloc(SzI* ArealFromFile.MaxVerts));
            }

         if(NeedSliverGuide > 0)
            {
            SliverGuide = (struct guide *) (malloc(sizeof(struct guide) * ArealFromFile.MaxVerts));
            }
         }
      else if(ArealFromFile.numverts > ArealFromFile.MaxVerts)
         {
         ArealFromFile.x = (double *) (realloc(ArealFromFile.x,ArealFromFile.numverts * SzD));
         ArealFromFile.y = (double *) (realloc(ArealFromFile.y,ArealFromFile.numverts * SzD));
         ArealFromFile.z = (double *) (realloc(ArealFromFile.z,ArealFromFile.numverts * SzD));

         ArealFromFile.MaxVerts = ArealFromFile.numverts;

         if(NeedIntersectingArealCalc > 0)
            {
            Areal1ForIntersections = (int *) (realloc(Areal1ForIntersections,ArealFromFile.numverts  * SzI));
            Areal2ForIntersections = (int *) (realloc(Areal2ForIntersections,ArealFromFile.numverts  * SzI));
            Areal1Shared = (int *) (realloc(Areal1Shared,ArealFromFile.numverts  * SzI));
            Areal2Shared = (int *) (realloc(Areal2Shared,ArealFromFile.numverts  * SzI));
            }

         if(NeedSliverGuide > 0)
            {
            free(SliverGuide);
            SliverGuide  = (struct guide *) (malloc(sizeof(struct guide) * ArealFromFile.MaxVerts));
            }
         }

      if(NeedAreaCalculation == 1)
         { 
         if(ArealForAreaCalculation.numverts == 0)
            {
            ArealForAreaCalculation.x = (double *) (malloc(ArealFromFile.numverts * SzD));
            ArealForAreaCalculation.y = (double *) (malloc(ArealFromFile.numverts * SzD));
            ArealForAreaCalculation.z = (double *) (malloc(ArealFromFile.numverts * SzD));
            ArealForAreaCalculation.numverts = ArealFromFile.numverts;
            }
         else if(ArealFromFile.numverts > ArealForAreaCalculation.numverts)
            {
            ArealForAreaCalculation.x = (double *) (realloc(ArealForAreaCalculation.x,ArealFromFile.numverts * SzD));
            ArealForAreaCalculation.y = (double *) (realloc(ArealForAreaCalculation.y,ArealFromFile.numverts * SzD));
            ArealForAreaCalculation.z = (double *) (realloc(ArealForAreaCalculation.z,ArealFromFile.numverts * SzD));
            ArealForAreaCalculation.numverts = ArealFromFile.numverts;
            }
         } 
      if((ArealFromFile.x == NULL) || (ArealFromFile.y == NULL) || (ArealFromFile.z == NULL))
         {
         printf("allocation memory exhausted during area feature read\n");
         exit(-1);
         }
      for(i=0; i<ArealFromFile.numverts; i++)
         {
         SEEIT_fread_double(&fx,arealfile);
         SEEIT_fread_double(&fy,arealfile);
         SEEIT_fread_double(&fz,arealfile);

         if(AbsoluteAccuracy == 1)
            {
            ArealFromFile.x[i] = fx;
            ArealFromFile.y[i] = fy;
            ArealFromFile.z[i] = fz;
            }
         else if(NGA_TYPE == 1)
            {
            ArealFromFile.x[i] = SixPointFiveRound(1,fx);
            ArealFromFile.y[i] = SixPointFiveRound(2,fy);
            ArealFromFile.z[i] = SixPointFiveRound(3,fz);
            }
         else
            {
            ArealFromFile.x[i] = TruncNdigs(fx, decimalplaces);
            ArealFromFile.y[i] = TruncNdigs(fy, decimalplaces);
            ArealFromFile.z[i] = fz;
         /**ArealFromFile.z[i] = TruncNdigs(fz, decimalplaces);***/
            }
         if(i == 0)
            {
            minx = ArealFromFile.x[i];
            miny = ArealFromFile.y[i];
            }
         else
            {
            if(ArealFromFile.x[i] < minx)
               minx = ArealFromFile.x[i];
            if(ArealFromFile.y[i] < miny)
               miny = ArealFromFile.y[i];
            }
         }

      if(vtxcnt > 1)
         {
         if((ArealFromFile.x[0] == ArealFromFile.x[vtxcnt-1]) &&
            (ArealFromFile.y[0] == ArealFromFile.y[vtxcnt-1]) &&
            (ArealFromFile.z[0] == ArealFromFile.z[vtxcnt-1]))
            {
            ArealFromFile.numverts -= 1;
            ChkAreaClosure = 0;
            }
         else
            {
            ArealFromFile.numverts -= 1; /*** added this as part of effort to prevent unclosed conditions ****/
                                         /*** from cascading effects to other inspections ****/

            ChkAreaClosure = 1;
            }
         }

      ArealFromFile.minxvtx = minx;

      area = 1;

      perimlength = 0.0;
      if(NeedAreaCalculation == 1)
         {
/*********************/
         if(Ctype() == 1)
            {
            CalculateGeodeticCoordArea(ArealFromFile.minxvtx,miny, &area, &perimlength, 0, ArealFromFile.numverts);
            }
         else
/********************/
            {
            Xold = ArealFromFile.x[ArealFromFile.numverts - 1];
            Yold = ArealFromFile.y[ArealFromFile.numverts - 1];
            for(i=0; i<ArealFromFile.numverts; i++)
               {
               if(i > 0)
                  perimlength += Distance(ArealFromFile.x[i-1],ArealFromFile.y[i-1],ArealFromFile.x[i],ArealFromFile.y[i]);
               else
                  {
                  perimlength += Distance(ArealFromFile.x[ArealFromFile.numverts-1],ArealFromFile.y[ArealFromFile.numverts-1],
                          ArealFromFile.x[i],ArealFromFile.y[i]);
                  }
               
               area += (Xold - ArealFromFile.x[i]) * (Yold + ArealFromFile.y[i] - miny);
               Xold = ArealFromFile.x[i];
               Yold = ArealFromFile.y[i];
               }
            if(area < 0)
               area = 0.0 - area;
            area = 0.5 * area;
            }
         }

      else
         {
         i = ArealFromFile.numverts - 1;
         perimlength = Distance(ArealFromFile.x[0],ArealFromFile.y[0],ArealFromFile.x[i],ArealFromFile.y[i]);
         for(i=1; i<ArealFromFile.numverts; i++)
            {
            perimlength += Distance(ArealFromFile.x[i-1],ArealFromFile.y[i-1],ArealFromFile.x[i],ArealFromFile.y[i]);
            }
         }

      ArealFromFile.perimlength = perimlength;
sprintf(strtemp,"%.6lf",area);
sscanf(strtemp,"%lf",&area);

      ArealFromFile.area = area;
      }
   return(vtxcnt);
}

int AnyEdgesInThisLoadModule(struct RawAreal *a,int cindex)
{
int answer;
/***struct RB_Edgelist * LRE; ***/
   if((a->RB_Tree_Edgelist == NULL) || (a->ismulti == 0))
      answer = -1;
   else
      {
      RB_newKey = cindex;
      if(( RB_newNode = RBExactQuery(a->RB_Tree_Edgelist,&RB_newKey)))
         answer = 1;
      else
         answer = 0;
      }
   return(answer);

}


int GetNextArealIndex(struct RawAreal *a, int lastusedindex, int firstuse, struct RB_Edgelist ** RE, int cindex, int *UsedTree)
{
int answer;
struct RB_Edgelist * LRE;
   if((a->RB_Tree_Edgelist == NULL) || (a->ismulti == 0))
      {
      *UsedTree = 0;
      if(firstuse > 0)
         answer = firstuse;
      else
         {
         answer = lastusedindex + 1;
         if(answer >= a->numverts)
            answer = -1;
         }
      }
   else
      {
      *UsedTree = 1;
      if(*RE == NULL)
         {
         RB_newKey = cindex;
         if(( RB_newNode = RBExactQuery(a->RB_Tree_Edgelist,&RB_newKey)))
            {
            LRE = (struct RB_Edgelist *) RB_newNode->info;
            *RE = LRE;
            }
         else
            {
            answer = -1;
            LRE = NULL;
            }
         }
      else
         LRE = *RE;

/***********
      if(lastusedindex >= 0)
         {
*************/
         while(LRE != NULL)
            {
/****
printf("considering index %d lastusedindex is %d\n",LRE->index,lastusedindex);
***/
            if((LRE->index == lastusedindex) || (lastusedindex < 0))
               {
               if(lastusedindex >= 0)
                  LRE = LRE->next;
               if(LRE == NULL)
                  answer = -1;
               else
                  answer = LRE->index;
               *RE = LRE;
               break;
               }
            LRE = LRE->next;
            }
         if(LRE == NULL)
            answer = -1;
      }

   return(answer);
}



int PointWithinToleranceOfLargeArealVertex(double px,double py, struct RawAreal *A, double *elev,double tolerance)
{
int ci1, ci2, cindex;
int MYI;
int LastI, i, UsedTree;
struct RB_Edgelist * LastEdge1;
double maxpx,minpx,maxpy,minpy,dist;
int answer;

   answer = 0;
   MYI = MaxYindex + 1;

   ci1 = (int) (px / RegionSize);
   ci2 = (int) (py / RegionSize);

   cindex = (ci1 * MYI) + ci2;

   maxpx = px + tolerance;
   minpx = px - tolerance;
   maxpy = py + tolerance;
   minpy = py - tolerance;

   LastEdge1 = NULL;
   LastI = -1;

   i = GetNextArealIndex(A, LastI, 1, &LastEdge1, cindex, &UsedTree);
   LastI = i;

   while(i >= 0)
      {
      if((A->x[i] == px) && (A->y[i] == py))
         {
         answer = 1;
         *elev = A->z[i];
         break;
         }
      else if((maxpx > A->x[i]) && (minpx < A->x[i]) && (maxpy > A->y[i]) && (minpy < A->y[i]))
         {
         dist = Distance(px,py,A->x[i],A->y[i]);
         if(dist <= tolerance)
            {
            answer = 1;
            *elev = A->z[i];
            break;
            }
         }

      i = GetNextArealIndex(A, LastI, 1, &LastEdge1, cindex, &UsedTree);
      LastI = i;
      }
   return(answer);
}





int PointIsLargeArealVertex(double px,double py, struct RawAreal *A, double *elev)
{
int ci1, ci2, cindex;
int MYI;
int LastI, i, UsedTree;
struct RB_Edgelist * LastEdge1;
int answer;

   answer = 0;
   MYI = MaxYindex + 1;

   ci1 = (int) (px / RegionSize);
   ci2 = (int) (py / RegionSize);

   cindex = (ci1 * MYI) + ci2;

   LastEdge1 = NULL;
   LastI = -1;

   i = GetNextArealIndex(A, LastI, 1, &LastEdge1, cindex, &UsedTree);
   LastI = i;

   while(i >= 0)
      {
      if((A->x[i] == px) && (A->y[i] == py))
         {
         answer = 1;
         *elev = A->z[i];
         break;
         }
      
      i = GetNextArealIndex(A, LastI, 1, &LastEdge1, cindex, &UsedTree);
      LastI = i;
      }
   return(answer);
}


int PointIsAlmostLargeArealVertex(double px,double py, struct RawAreal *A, double *elev)
{
int ci1, ci2, cindex;
int MYI;
int LastI, i, UsedTree;
struct RB_Edgelist * LastEdge1;
int answer;
double dx, dy;

   answer = 0;
   MYI = MaxYindex + 1;

   ci1 = (int) (px / RegionSize);
   ci2 = (int) (py / RegionSize);

   cindex = (ci1 * MYI) + ci2;

   LastEdge1 = NULL;
   LastI = -1;

   i = GetNextArealIndex(A, LastI, 1, &LastEdge1, cindex, &UsedTree);
   LastI = i;

   while(i >= 0)
      {
      if(A->x[i] > px)
         dx = A->x[i] - px;
      else
         dx = px - A->x[i];
      if(dx < 0.0001)
         {
         if(A->y[i] > py)
            dy = A->y[i] - py;
         else
            dy = py - A->y[i];
         if(dy < 0.0001)
            {
            answer = 1;
            *elev = A->z[i];
            break;
            }
         }

      i = GetNextArealIndex(A, LastI, 1, &LastEdge1, cindex, &UsedTree);
      LastI = i;
      }
   return(answer);
}




int PointWithinToleranceOfLargeArealEdge(double px,double py,struct RawAreal *A,double *elev,int *index,double tolerance)
{
int ci1, ci2, cindex;
int MYI;
int LastI, i, j, UsedTree;
struct RB_Edgelist * LastEdge1;
int answer;

   answer = 0;
   MYI = MaxYindex + 1;

   ci1 = (int) (px / RegionSize);
   ci2 = (int) (py / RegionSize);

   cindex = (ci1 * MYI) + ci2;

   LastEdge1 = NULL;
   LastI = -1;

   i = GetNextArealIndex(A, LastI, 1, &LastEdge1, cindex, &UsedTree);
   LastI = i;

   if(i >= 0)
      {
      j = (i + (A->numverts - 1)) % A->numverts;
      if(PointOnLineSegment(px,py,A->x[i],A->y[i],A->x[j],A->y[j],tolerance) > 0)
         {
         answer = 1;
         *index = i;
         *elev = InterpLinearElev(A->x[i],A->y[i],A->z[i],A->x[j],A->y[j],A->z[j],px,py);
         }
      else
         {
         while(i >= 0)
            {
            j = (i + 1) % A->numverts;
            if(PointOnLineSegment(px,py,A->x[i],A->y[i],A->x[j],A->y[j],tolerance) > 0)
               {
               answer = 1;
               *index = i;
               *elev = InterpLinearElev(A->x[i],A->y[i],A->z[i],A->x[j],A->y[j],A->z[j],px,py);
               break;
               }
            i = GetNextArealIndex(A, LastI, 1, &LastEdge1, ci1, &UsedTree);
            LastI = i;
            }
         }
      }

   return(answer);
}






int PointOnLargeArealEdge(double px,double py,struct RawAreal *A,double *elev,int *index)
{
int ci1, ci2, cindex;
int MYI;
int LastI, i, j, UsedTree;
struct RB_Edgelist * LastEdge1;
int answer;

   answer = 0; 
   MYI = MaxYindex + 1;

   ci1 = (int) (px / RegionSize);
   ci2 = (int) (py / RegionSize);

   cindex = (ci1 * MYI) + ci2;

   LastEdge1 = NULL;
   LastI = -1;

   i = GetNextArealIndex(A, LastI, 1, &LastEdge1, cindex, &UsedTree);
   LastI = i;

   if(i >= 0)
      {
      if(i > 0)
         j = i - 1;
      else
         j = A->numverts - 1;
      if(PointOnLineSegment(px,py,A->x[i],A->y[i],A->x[j],A->y[j],0.01) > 0)
         {
         answer = 1;
         *index = i;
         *elev = InterpLinearElev(A->x[i],A->y[i],A->z[i],A->x[j],A->y[j],A->z[j],px,py);
         }
      else
         {
         while(i >= 0)
            {
            if(i > 0)
               j = i - 1;
            else
               j = A->numverts - 1;
            if(PointOnLineSegment(px,py,A->x[i],A->y[i],A->x[j],A->y[j],0.01) > 0)
               {
               answer = 1;
               *index = i;
               *elev = InterpLinearElev(A->x[i],A->y[i],A->z[i],A->x[j],A->y[j],A->z[j],px,py);
               break;
               }

            j = i + 1;
            if(j >= A->numverts)
               j = 0;
            if(PointOnLineSegment(px,py,A->x[i],A->y[i],A->x[j],A->y[j],0.01) > 0)
               {
               answer = 1;
               *index = i;
               *elev = InterpLinearElev(A->x[i],A->y[i],A->z[i],A->x[j],A->y[j],A->z[j],px,py);
               break;
               }

            i = GetNextArealIndex(A, LastI, 1, &LastEdge1, ci1, &UsedTree);
            LastI = i;
            }
         }
      }

   return(answer);
}





int PointInsideLargeAreal(double px, double py, struct RawAreal * A, int *OnEdge)
{
int ci1, ci2, cindex1;
int MYI;
int LastI, i, j, k, klast, UsedTree, incr;
struct RB_Edgelist * LastEdge1;
int numints, answer;
double  nx, ny;
double disttoline;
double howclose;
int * UsedEdge;

   UsedEdge = (int *) (malloc(SzI * A->numverts));
   if(UsedEdge == NULL)
      {
      printf("memory available for use has been exhausted after request for %d bytes\n",SzI*A->numverts);
      printf("execution terminating in function 'PointInsideLargeAreal'\n");
      exit(-1);
      }

   for(i=0; i<A->numverts; i++)
      UsedEdge[i] = 0;

   MYI = MaxYindex + 1;

   ci1 = (int) (px / RegionSize);
   ci2 = (int) (py / RegionSize);

   cindex1 = (ci1 * MYI) + ci2;

   LastEdge1 = NULL;
   LastI = -1;
   numints = 0;
   howclose = 0.001;

   *OnEdge = 0;

   for(ci1=cindex1; ci1 <= A->ismulti; ci1 += MYI) 
      {
      i = GetNextArealIndex(A, LastI, 1, &LastEdge1, ci1, &UsedTree);
      LastI = i;

      while(i >= 0) 
         {
         if(UsedEdge[i] == 0)
            {
            UsedEdge[i] = 1;
j = i - 1;
if(j < 0)
  j = A->numverts + j;

                     disttoline = PointToLineDist2D(px,py,A->x[i],A->y[i],A->x[j],A->y[j]);
                     if(disttoline < howclose)
                        *OnEdge = 1;

            if((A->y[i] < py) && (py < A->y[j]))
               {
               if((A->x[i] > px) || (A->x[j] > px))
                  {
                  ny = (A->y[j] - py) / (A->y[j] - A->y[i]);
                  nx = A->x[j] - ((A->x[j] - A->x[i]) * ny);
                  if(nx > px)
                     {
                     ++numints;
                     }
                  }
               }
            else if((A->y[j] < py) && (py < A->y[i]))
               {
               if((A->x[i] > px) || (A->x[j] > px))
                  {
                  ny = (A->y[i] - py) / (A->y[i] - A->y[j]);
                  nx = A->x[i] - ((A->x[i] - A->x[j]) * ny);
                  if(nx > px)
                     {
                     ++numints;
                     }
                  }
               }
            else if((py == A->y[i]) && (px != A->x[i]) && (py != A->y[j]))
               {
               if(A->x[i] > px)
                  {
                  disttoline = PointToLineDist2D(px,py,A->x[i],A->y[i],A->x[j],A->y[j]);
                  if(disttoline < howclose)
                     *OnEdge = 1;
                  klast = i;
                  for(incr = 1; incr < A->numverts; incr++)
                     {
                     k = (i + incr) % A->numverts;  /** move forward to find the next approp segment ***/
                     disttoline = PointToLineDist2D(px,py,A->x[k],A->y[k],A->x[klast],A->y[klast]);
                     klast = k;
                     if(disttoline < howclose)
                        *OnEdge = 1;
                     if(A->y[k] != py)
                        break;
                     }
                  if((A->y[k] < py) && (py < A->y[j]))
                     {

                     ++numints;
                     }
                  else if((A->y[j] < py) && (py < A->y[k]))
                     {
                     ++numints;
                     }
                  }
               }
            }
i = GetNextArealIndex(A, LastI, 1, &LastEdge1, ci1, &UsedTree);
LastI = i;
/***/
         }  /** end while i >= 0 ***/
      }
   free(UsedEdge);

   answer = (numints % 2);
   if((answer == 1) && (*OnEdge == 0))
      {
/**** do this to get confirmation the old way if think that the point really is inside ***/
      answer = PointInsidePoly(px,py, A->x, A->y, A->numverts);
      }
   return(answer);
}








void AssembleAreals(int Lindex1,int Uindex1, int Lindex2, int Uindex2)
{
FILE *arin;
struct RawAreal * rac, *rap;
int index1, index2;
int OKtoUse;
int Config,  Domain;
int i, j, k;
int jj,kk;
int drawthisgeom;
int compositeindex;
int foundparent, NumHoles;
int NumberToCheck;
double multiplier;
int skiplimit;
struct LongList *cll;
struct LongSkipList *SkipList;
int SzLA = sizeof(struct ListOfAreals);
int SzRA = sizeof(struct RawAreal);
int SkipEntry = 0;
int filenumber;
char afilein[500];
char suffix[5];
unsigned long int fo;

   NumberToCheck = (Uindex1 - Lindex1 + 1) * (Uindex2 - Lindex2 + 1);
   if(NumberToCheck < 3001)
      skiplimit = 150;
   else
      skiplimit = (int) (ceil((double) (NumberToCheck) / 20.0));


   NeedAreaCalculation = 1;
   SkipList = (struct LongSkipList *) (malloc(SzSkip * skiplimit));
   multiplier = SignificantDecimals; 
   ArealListRoot = NULL;
   drawthisgeom = 0;
   for(j=0; j<TotalSCC; j++)
      {
      if((SCCtable[j].C == 1) && (DrawByConfig[1] > 0))
         {
         drawthisgeom = 1;
         break;
         }
      if((SCCtable[j].C == 15) && (DrawByConfig[15] > 0))
         {
         drawthisgeom = 1;
         break;
         }
      }

   arin = fopen(arealsin,"rb");
   filenumber = 0;
   if((arin != NULL) && (drawthisgeom > 0))
      {
      FreeLongList(&LongListRoot);
      LongListRoot = NULL;
      for(i=0; i<skiplimit; i++)
         {
         SkipList[i].val = -1;
         SkipList[i].entry = NULL;
         }


      for(index1 = Lindex1; index1 <= Uindex1; index1++)
         {
         for(index2 = Lindex2; index2 <= Uindex2; index2++)
            {
            compositeindex = (index1 * (MaxYindex + 1)) + index2;

            for(i=0; i<ArealTable[compositeindex].numother; i++)
               {
               fo = fileoffset * ArealTable[compositeindex].others[i].filenumber + ArealTable[compositeindex].others[i].fileptr;
               InsertIntoLongList(fo,ArealTable[compositeindex].others[i].filenumber,skiplimit,
                                  &LongListRoot,SkipList,&SkipEntry);
               }

            k = ArealTable[compositeindex].numinside;
            if((k > 0) && (ArealTable[compositeindex].filenumber != filenumber))
               {
               filenumber = ArealTable[compositeindex].filenumber;
               sprintf(suffix,"%d",filenumber);
               strcpy(afilein,arealsin);
               if(filenumber > 0)
                  strcat(afilein,suffix);
               fclose(arin);
               arin = fopen(afilein,"rb");
               if(arin == NULL)
                  {
                  printf("5 area feature data input file %s could not be opened for read\n",afilein);
                  exit(-1);
                  }
               }

            if(k > 0)
               {
               fseek(arin,ArealTable[compositeindex].fileptr,SEEK_SET);

/****printf("adding from single area list\n");***/
               i = 0;
               while(i < k)
                  {
                  j = ReadArealFromFile(arin, multiplier);
                  ++i;

                  Config = ArealFromFile.config;
                  Domain = ArealFromFile.domain;

                  OKtoUse = 1;
                  if(NumLODbands > 0)
                     {
                     jj = CrsWlk[ArealFromFile.Lindex].LODband;
                     if((jj > 0) && (LODindex[jj-1].active < 1))
                        OKtoUse = 0;
                     }
                  if((OKtoUse > 0) && (DrawByDomain[Domain] > 0)&& (DrawByConfig[Config] > 0))
                     {
                     alrc = (struct ListOfAreals *) (malloc(SzLA));
                     if(alrc == NULL)
                        {
                        printf("memory allocation failure during Area Feature Assembly\n");
                        exit(-1);
                        }
                     alrc->Lindex = ArealFromFile.Lindex;
                     alrc->Sindex = ArealFromFile.Sindex;
                     alrc->areaattr = ArealFromFile.areaattr;
                     if(ArealFromFile.areastr[0] == '\0')
                        alrc->areastr = NULL;
                     else
                        {
                        alrc->areastr = (char *) (malloc(strlen(ArealFromFile.areastr) + 2));
                        if(alrc->areastr != NULL)
                           strcpy(alrc->areastr,ArealFromFile.areastr);
                        }
                     alrc->hgtattr = ArealFromFile.hgtattr;
                     if(ArealFromFile.hgtstr[0] == '\0')
                        alrc->hgtstr = NULL;
                     else
                        {
                        alrc->hgtstr = (char *) (malloc(strlen(ArealFromFile.hgtstr) + 2));
                        if(alrc->hgtstr != NULL)
                           strcpy(alrc->hgtstr,ArealFromFile.hgtstr);
                        }
                     alrc->zv2attr = ArealFromFile.zv2attr;
                     if(ArealFromFile.zv2str[0] == '\0')
                        alrc->zv2str = NULL;
                     else
                        {
                        alrc->zv2str = (char *) (malloc(strlen(ArealFromFile.zv2str) + 2));
                        if(alrc->zv2str != NULL)
                           strcpy(alrc->zv2str,ArealFromFile.zv2str);
                        }
                     alrc->lenattr = ArealFromFile.lenattr;
                     if(ArealFromFile.lenstr[0] == '\0')
                        alrc->lenstr = NULL;
                     else
                        {
                        alrc->lenstr = (char *) (malloc(strlen(ArealFromFile.lenstr) + 2));
                        if(alrc->lenstr != NULL)
                           strcpy(alrc->lenstr,ArealFromFile.lenstr);
                        }
                     alrc->namattr = ArealFromFile.namattr;
                     if(ArealFromFile.namstr[0] == '\0')
                        alrc->namstr = NULL;
                     else
                        {
                        alrc->namstr = (char *) (malloc(strlen(ArealFromFile.namstr) + 2));
                        if(alrc->namstr != NULL)
                           strcpy(alrc->namstr,ArealFromFile.namstr);
                        }

                     alrc->idn = ArealFromFile.idn;
                     alrc->featureid = ArealFromFile.featureid;
                     alrc->ishole = ArealFromFile.ishole;
                     alrc->area = ArealFromFile.area;
                     alrc->perimlength = ArealFromFile.perimlength;
                     alrc->temp = 0;
                     if(ChkAreaClosure > 0)
                        {
                        ArealFromFile.numverts += 1;
                        alrc->notclosed = 1;
                        }
                     else
                        alrc->notclosed = 0;
                     alrc->perimlength = ArealFromFile.perimlength;
                     alrc->area = ArealFromFile.area;
                     alrc->minxvtx = ArealFromFile.minxvtx;
                     alrc->config = ArealFromFile.config;
                     alrc->stratum = ArealFromFile.stratum;
                     alrc->domain = ArealFromFile.domain;
                     alrc->numverts = ArealFromFile.numverts;
                     alrc->x = (double *) malloc(SzD * ArealFromFile.numverts);
                     alrc->y = (double *) malloc(SzD * ArealFromFile.numverts);
                     alrc->z = (double *) malloc(SzD * ArealFromFile.numverts);
                     for(jj = 0; jj<ArealFromFile.numverts; jj++)
                        {
                        alrc->x[jj] = ArealFromFile.x[jj];
                        alrc->y[jj] = ArealFromFile.y[jj];
                        alrc->z[jj] = ArealFromFile.z[jj];
                        }
                     alrc->holes = NULL;
                     alrc->next = ArealListRoot;

                     ArealListRoot = alrc;
                     }
                  }
               }
            }
         }
      cll = LongListRoot;

      while(cll != NULL)
         {
         if(cll->fn != filenumber)
            { 
            filenumber = cll->fn;
            sprintf(suffix,"%d",filenumber);
            strcpy(afilein,arealsin);
            if(filenumber > 0)
              strcat(afilein,suffix);
            fclose(arin);
            arin = fopen(afilein,"rb");
            if(arin == NULL)
               {
               printf("6 area feature data input file %s could not be opened for read\n",afilein);
               exit(-1);
               }
            }
         fo = cll->fp - (fileoffset * cll->fn);
         fseek(arin,fo,SEEK_SET);

         j = ReadArealFromFile(arin, multiplier);
         Config = ArealFromFile.config;
         Domain = ArealFromFile.domain;

         OKtoUse = 1;
         if(NumLODbands > 0)
            {
            jj = CrsWlk[ArealFromFile.Lindex].LODband;
            if((jj > 0) && (LODindex[jj-1].active < 1))
               OKtoUse = 0;
            }

         if((OKtoUse > 0)  && (DrawByDomain[Domain] > 0)&& (DrawByConfig[Config] > 0) && (ArealFromFile.ishole <= 0))
            {
            alrc = (struct ListOfAreals *) (malloc(SzLA));
            if(alrc == NULL)
               {
               printf("memory allocation failure during Area Feature Assembly\n");
               exit(-1);
               }
            alrc->Lindex = ArealFromFile.Lindex;
            alrc->Sindex = ArealFromFile.Sindex;
            alrc->idn = ArealFromFile.idn;
            alrc->areaattr = ArealFromFile.areaattr;
            if(ArealFromFile.areastr[0] == '\0')
               alrc->areastr = NULL;
             else
               {
               alrc->areastr = (char *) (malloc(strlen(ArealFromFile.areastr) + 2));
               if(alrc->areastr != NULL)
                  strcpy(alrc->areastr,ArealFromFile.areastr);
               }
            alrc->hgtattr = ArealFromFile.hgtattr;
            if(ArealFromFile.hgtstr[0] == '\0')
               alrc->hgtstr = NULL;
            else
               {
               alrc->hgtstr = (char *) (malloc(strlen(ArealFromFile.hgtstr) + 2));
               if(alrc->hgtstr != NULL)
                  strcpy(alrc->hgtstr,ArealFromFile.hgtstr);
               }
            alrc->zv2attr = ArealFromFile.zv2attr;
            if(ArealFromFile.zv2str[0] == '\0')
               alrc->zv2str = NULL;
            else
               {
               alrc->zv2str = (char *) (malloc(strlen(ArealFromFile.zv2str) + 2));
               if(alrc->zv2str != NULL)
                  strcpy(alrc->zv2str,ArealFromFile.zv2str);
               }
            alrc->lenattr = ArealFromFile.lenattr;
            if(ArealFromFile.lenstr[0] == '\0')
               alrc->lenstr = NULL;
            else
               {
               alrc->lenstr = (char *) (malloc(strlen(ArealFromFile.lenstr) + 2));
               if(alrc->lenstr != NULL)
                  strcpy(alrc->lenstr,ArealFromFile.lenstr);
               }
            alrc->namattr = ArealFromFile.namattr;
            if(ArealFromFile.namstr[0] == '\0')
               alrc->namstr = NULL;
            else
               {
               alrc->namstr = (char *) (malloc(strlen(ArealFromFile.namstr) + 2));
               if(alrc->namstr != NULL)
                  strcpy(alrc->namstr,ArealFromFile.namstr);
               }

            alrc->featureid = ArealFromFile.featureid;
            alrc->ishole = ArealFromFile.ishole;
            alrc->temp = 0;
            if(ChkAreaClosure > 0)
               {
               ArealFromFile.numverts += 1;
               alrc->notclosed = 1;
               }
            else
               alrc->notclosed = 0;
            alrc->perimlength = ArealFromFile.perimlength;
            alrc->area = ArealFromFile.area;
            alrc->minxvtx = ArealFromFile.minxvtx;
            alrc->config = ArealFromFile.config;
            alrc->stratum = ArealFromFile.stratum;
            alrc->domain = ArealFromFile.domain;
            alrc->numverts = ArealFromFile.numverts;
            alrc->x = (double *) malloc(SzD * ArealFromFile.numverts);
            alrc->y = (double *) malloc(SzD * ArealFromFile.numverts);
            alrc->z = (double *) malloc(SzD * ArealFromFile.numverts);
            for(jj = 0; jj<ArealFromFile.numverts; jj++)
               {
               alrc->x[jj] = ArealFromFile.x[jj];
               alrc->y[jj] = ArealFromFile.y[jj];
               alrc->z[jj] = ArealFromFile.z[jj];
               }
            alrc->holes = NULL;
            alrc->next = ArealListRoot;

            ArealListRoot = alrc;
            if(alrc->ishole < 0)
               {
               kk = 0;
               NumHoles = 0 - alrc->ishole;
               while(kk < NumHoles)
                  {
                  j = ReadArealFromFile(arin, multiplier);
if(ArealFromFile.idn == alrc->idn)
               {
               rac = (struct RawAreal *) (malloc(SzRA));
               if(rac == NULL)
                  {
                  printf("memory allocation failure during Area Feature Assembly\n");
                  exit(-1);
                  }
               rac->Lindex = ArealFromFile.Lindex;
               rac->Sindex = ArealFromFile.Sindex;
               rac->idn = ArealFromFile.idn;
               rac->areaattr = ArealFromFile.areaattr;
               if(ArealFromFile.areastr[0] == '\0')
                  rac->areastr = NULL;
               else
                  {
                  rac->areastr = (char *) (malloc(strlen(ArealFromFile.areastr) + 2));
                  if(rac->areastr != NULL)
                     strcpy(rac->areastr,ArealFromFile.areastr);
                  }
               rac->hgtattr = ArealFromFile.hgtattr;
               if(ArealFromFile.hgtstr[0] == '\0')
                  rac->hgtstr = NULL;
               else
                  {
                  rac->hgtstr = (char *) (malloc(strlen(ArealFromFile.hgtstr) + 2));
                  if(rac->hgtstr != NULL)
                     strcpy(rac->hgtstr,ArealFromFile.hgtstr);
                  }
               rac->zv2attr = ArealFromFile.zv2attr;
               if(ArealFromFile.zv2str[0] == '\0')
                  rac->zv2str = NULL;
               else
                  {
                  rac->zv2str = (char *) (malloc(strlen(ArealFromFile.zv2str) + 2));
                  if(rac->zv2str != NULL)
                     strcpy(rac->zv2str,ArealFromFile.zv2str);
                  }
               rac->lenattr = ArealFromFile.lenattr;
               if(ArealFromFile.lenstr[0] == '\0')
                  rac->lenstr = NULL;
               else
                  {
                  rac->lenstr = (char *) (malloc(strlen(ArealFromFile.lenstr) + 2));
                  if(rac->lenstr != NULL)
                     strcpy(rac->lenstr,ArealFromFile.lenstr);
                  }
               rac->namattr = ArealFromFile.namattr;
               if(ArealFromFile.namstr[0] == '\0')
                  rac->namstr = NULL;
               else
                  {
                  rac->namstr = (char *) (malloc(strlen(ArealFromFile.namstr) + 2));
                  if(rac->namstr != NULL)
                     strcpy(rac->namstr,ArealFromFile.namstr);
                  }

               rac->featureid = ArealFromFile.featureid;
               rac->ishole = ArealFromFile.ishole;
if(ChkAreaClosure > 0)
               {
               ArealFromFile.numverts += 1;
               rac->notclosed = 1;
               }
            else
               rac->notclosed = 0;
               rac->perimlength = ArealFromFile.perimlength;
               rac->area = ArealFromFile.area;
               rac->minxvtx = ArealFromFile.minxvtx;
               rac->numverts = ArealFromFile.numverts;
               rac->x = (double *) malloc(SzD * ArealFromFile.numverts);
               rac->y = (double *) malloc(SzD * ArealFromFile.numverts);
               rac->z = (double *) malloc(SzD * ArealFromFile.numverts);
               for(jj = 0; jj<ArealFromFile.numverts; jj++)
                  {
                  rac->x[jj] = ArealFromFile.x[jj];
                  rac->y[jj] = ArealFromFile.y[jj];
                  rac->z[jj] = ArealFromFile.z[jj];
                  }
               rac->next = alrc->holes;
               alrc->holes = rac;
               }
else
{
printf("problem in assembly of inner and outer rings for multi-region area\n");
exit(-1);
}

                  ++kk;
                  }
               }
            }
/*****************
         free(ArealFromFile.x);
         free(ArealFromFile.y);
         free(ArealFromFile.z);
**************/

         cll = cll->next;
         }

      FreeLongList(&LongListRoot);
      }
   if(arin != NULL)
      fclose(arin);

/**************
   if(ArealFromFile.MaxVerts > 0)
      {
      free(ArealFromFile.x);
      free(ArealFromFile.y);
      free(ArealFromFile.z);
      }
   ArealFromFile.MaxVerts = 0;
**************/
      
   if(ArealForAreaCalculation.numverts > 0)
      {
      free(ArealForAreaCalculation.x);
      free(ArealForAreaCalculation.y);
      free(ArealForAreaCalculation.z);
      ArealForAreaCalculation.numverts = 0;
      }

   NeedAreaCalculation = 0;


   alrp = alrc = ArealListRoot;

   while(alrc != NULL)
      {
      if(alrc->ishole > 0)
         {
         foundparent = 0;
         alrn = ArealListRoot;
         while(alrn != NULL)
            {
            if((alrn->ishole <= 0) /**&& (alrc != NULL)**/ && (alrn->idn == alrc->idn)) /*** was this way (alrn->featureid == alrc->featureid)) ***/
               {
               ++foundparent;
               rac = (struct RawAreal *) (malloc(SzRA));
               if(rac == NULL)
                  {
                  printf("memory allocation failure during Area Feature Assembly\n");
                  exit(-1);
                  }
               rac->Lindex = alrc->Lindex;
               rac->Sindex = alrc->Sindex;
               rac->idn = alrc->idn;
               rac->areaattr = alrc->areaattr;
               if(ArealFromFile.areastr[0] == '\0')
                  rac->areastr = NULL;
               else
                  {
                  rac->areastr = (char *) (malloc(strlen(ArealFromFile.areastr) + 2));
                  if(rac->areastr != NULL)
                     strcpy(rac->areastr,ArealFromFile.areastr);
                  }
               rac->hgtattr = alrc->hgtattr;
               if(ArealFromFile.hgtstr[0] == '\0')
                  rac->hgtstr = NULL;
               else
                  {
                  rac->hgtstr = (char *) (malloc(strlen(ArealFromFile.hgtstr) + 2));
                  if(rac->hgtstr != NULL)
                     strcpy(rac->hgtstr,ArealFromFile.hgtstr);
                  }
               rac->zv2attr = alrc->zv2attr;
               if(ArealFromFile.zv2str[0] == '\0')
                  rac->zv2str = NULL;
               else
                  {
                  rac->zv2str = (char *) (malloc(strlen(ArealFromFile.zv2str) + 2));
                  if(rac->zv2str != NULL)
                     strcpy(rac->zv2str,ArealFromFile.zv2str);
                  }
               rac->lenattr = ArealFromFile.lenattr;
               if(ArealFromFile.lenstr[0] == '\0')
                  rac->lenstr = NULL;
               else
                  {
                  rac->lenstr = (char *) (malloc(strlen(ArealFromFile.lenstr) + 2));
                  if(rac->lenstr != NULL)
                     strcpy(rac->lenstr,ArealFromFile.lenstr);
                  }
               rac->namattr = ArealFromFile.namattr;
               if(ArealFromFile.namstr[0] == '\0')
                  rac->namstr = NULL;
               else
                  {
                  rac->namstr = (char *) (malloc(strlen(ArealFromFile.namstr) + 2));
                  if(rac->namstr != NULL)
                     strcpy(rac->namstr,ArealFromFile.namstr);
                  }
               rac->featureid = alrc->featureid;
               rac->ishole = alrc->ishole;
               rac->notclosed = alrc->notclosed;
               rac->perimlength = alrc->perimlength;
               rac->area = alrc->area;
               rac->minxvtx = alrc->minxvtx;
               rac->numverts = alrc->numverts;
               rac->x = (double *) malloc(SzD * alrc->numverts);
               rac->y = (double *) malloc(SzD * alrc->numverts);
               rac->z = (double *) malloc(SzD * alrc->numverts);
               for(jj = 0; jj<alrc->numverts; jj++)
                  {
                  rac->x[jj] = alrc->x[jj];
                  rac->y[jj] = alrc->y[jj];
                  rac->z[jj] = alrc->z[jj];
                  }
               rac->next = alrn->holes;
               alrn->holes = rac;
/*** if just subtract the hole area, can end up with negative area for parts of a multi-part features ... ****/
               /**alrn->area -= rac->area; **/
               alrn = alrn->next;
               }
            else
               {
               alrn = alrn->next;
               }
            }
         if(foundparent == 0)
            {
            printf("failed to find parent for area feature hole\n");
            printf("hole idn %d featureid %d\n",alrc->idn,alrc->featureid);
            /***alrc->ishole = 1; ***/
            alrc = alrc->next;
            }
         else if(foundparent > 1) /** have to check to see hole is really inside - have multiple 'parents' w/ same idn **/
            {
            alrn = ArealListRoot;
            while(alrn != NULL)
               {
               if((alrn->ishole <= 0) && (alrn->idn == alrc->idn)) /*** was this way (alrn->featureid == alrc->featureid)) ***/
                  {
                  rap = rac = alrn->holes;
                  while(rac != NULL)
                     {
                     for(jj=0; jj<rac->numverts; jj++)
                        {
                        kk = PointInsidePoly(rac->x[jj],rac->y[jj],alrn->x,alrn->y,alrn->numverts);
                        if(kk != 1)
                           break;
                        }
                     if(kk != 1)
                        {
                        if(rac == alrn->holes)
                           {
                           alrn->holes = rac->next;
                           free(rac->x);
                           free(rac->y);
                           free(rac->z);
                           if(rac->areastr != NULL)
                              free(rac->areastr);
                           if(rac->zv2str != NULL)
                              free(rac->zv2str);
                           if(rac->hgtstr != NULL)
                              free(rac->hgtstr);
                           if(rac->lenstr != NULL)
                              free(rac->lenstr);
                           if(rac->namstr != NULL)
                              free(rac->namstr);
                           free(rac);
                           rap = rac = alrn->holes;
                           }
                        else
                           {
                           rap->next = rac->next;
                           free(rac->x);
                           free(rac->y);
                           free(rac->z);
                           if(rac->areastr != NULL)
                              free(rac->areastr);
                           if(rac->zv2str != NULL)
                              free(rac->zv2str);
                           if(rac->hgtstr != NULL)
                              free(rac->hgtstr);
                           if(rac->lenstr != NULL)
                              free(rac->lenstr);
                           if(rac->namstr != NULL)
                              free(rac->namstr);
                           free(rac);
                           rac = rap->next;
                           }
                        }
                     else
                        {
                        rap = rac;
                        rac = rac->next;
                        }
                     }
                  }
               alrn = alrn->next;
               }
            }
         if(foundparent > 0)
            {
               if(alrc == ArealListRoot)
                  {
                  ArealListRoot = ArealListRoot->next;
                  free(alrc->x);
                  free(alrc->y);
                  free(alrc->z);
                  if(alrc->areastr != NULL)
                     free(alrc->areastr);
                  if(alrc->zv2str != NULL)
                     free(alrc->zv2str);
                  if(alrc->hgtstr != NULL)
                     free(alrc->hgtstr);
                  if(alrc->lenstr != NULL)
                     free(alrc->lenstr);
                  if(alrc->namstr != NULL)
                     free(alrc->namstr);
                  free(alrc);
                  alrp = alrc = ArealListRoot;
                  }
               else
                  {
                  alrp->next = alrc->next;
                  free(alrc->x);
                  free(alrc->y);
                  free(alrc->z);
                  if(alrc->areastr != NULL)
                     free(alrc->areastr);
                  if(alrc->zv2str != NULL)
                     free(alrc->zv2str);
                  if(alrc->hgtstr != NULL)
                     free(alrc->hgtstr);
                  if(alrc->lenstr != NULL)
                     free(alrc->lenstr);
                  if(alrc->namstr != NULL)
                     free(alrc->namstr);
                  free(alrc);
                  alrc = alrp->next;
                  }
            }
         }
      else
         {
         alrp = alrc;
         alrc = alrc->next;
         }
      }

   free(SkipList);

   return;
}


FILE * OpenGridFile(int index,int findex)
{
static FILE * answer;
/***char gridfilename[200]; ***/


   if((NumberOfGrids > 0) && (NGT[index].FileNumber[findex] > 0))
      {
      if(NGT[index].FileNumber[findex] == 1)
         {
         sprintf(gridsin,"%sgrid.bin",indirectory);
         }
      else
         {
         sprintf(gridsin,"%sgrid%d.bin",indirectory,NGT[index].FileNumber[findex]);
         }

      GridFileInUse = NGT[index].FileNumber[findex];
      answer = fopen(gridsin,"rb");
      if(answer == NULL)
         {
         printf("grid input file %s could not be opened\n   Fatal Error\n",gridsin);
         exit(-1);
         }
      }
   else
      {
      answer = NULL;
      }

   return(answer);
}






void CloseGridFile(FILE * gridfile)
{
   if(gridfile != NULL)
      fclose(gridfile);
   GridFileInUse = -10;
   gridfile = NULL;
}




int ReadGridFromFile(int Gindex,FILE * gridfile, double decimalplaces, int index, int NGrids, int *Mcols, int *Mres)
{
extern void SEEIT_MassRead_double(double *d, int NumValues, FILE *fp);
extern void SEEIT_MassRead_short(short int *si, int NumValues, FILE *fp);
int i, j, k,ii,jj;
/** int ti; **/
int part1,part2,part3,LI2,SI2;
int arrayindex;
/**int total;**/
int rows;
int MGrows, MGcols;
int indL;
/***int ind3, ind4; **/

/**int valsread = 0; **/
int OKtoUse;
long int seekoffset;
/***short int SIelev; ***/
/***short int SIelevA[2000]; ***/
double cornerx, cornery;
/***float dzA[9100]; ***/
double dz;
/**double globalMaxX,globalMaxY,LMmaxX,LMmaxY; **/
/**double basex, basey; **/
/**double baseXspace; **/
/**double LowBaseXspace, LowBaseYspace;**/
/***double Ysmidge;***/

/*** addded to allow more appropriate grid file sizes ... ***/
char charelevS;
unsigned char charelev;
unsigned short int unsigned_shortint_elev;
short int shortint_elev;
float float_elev;
unsigned int unsigned_int_elev;
int int_elev;
extern int CalculateBytesPerGridValue(int flag);



   rows = 0;

   *Mres = 0;

   *Mcols = 0;

   if((gridfile != NULL) && (UseRGridStruct == 0) && (feof(gridfile) == 0) && (NGrids >= 1))
      {

      for(k = 0; k<NGT[index].NumGrids; k++)
         {
         ii = NGT[index].GridIndex[k];

         if(SCCtable[GridHeader[ii].Sindex].S == S_SURF) /*** a surface layer grid ***/
            OKtoUse = 1;
         else
            OKtoUse = 0;

         if(GridFileInUse != NGT[index].FileNumber[k])
            OKtoUse = 0;
         if((running == 0) && (OKtoUse > 0) && (NumLODbands >= 1))
            {
            indL = CrsWlk[GridHeader[ii].Lindex].LODband;

            if((indL > 0) && (LODindex[indL-1].active < 1))
               OKtoUse = 0;
            }

if((running > 0) && (OKtoUse > 0))
   {
   LI2 = GridHeader[ii].Lindex;
   SI2 = CrsWlk[LI2].LtoSmapping;
   OKtoUse = CombinedCheckApplies(GridHeader[ii].idn,-1,-1,LI2,SI2,
                       SCCtable[SI2].C, SCCtable[SI2].S, SCCtable[SI2].D, &part1,&part2,&part3);
   }
         if((OKtoUse > 0) && (NGT[index].NumRows[k] > 0))
            {
            BytesPerGridValue = GridHeader[ii].BPGV;
            fseek(gridfile,NGT[index].fileptr[k],SEEK_SET);
            MGcols = NGT[index].NumRows[k];
            MGrows = NGT[index].NumCols[k];

            cornerx = NGT[index].BaseX[k];
            cornery = NGT[index].BaseY[k];

            MG[k].localident = GridHeader[ii].idn;
            MG[k].OnEdge = NGT[index].OnEdge[k];
            MG[k].idn = index;
            MG[k].actualindex = NGT[index].GridIndex[k];
            MG[k].Xspace = GridHeader[ii].Xspacing;
            MG[k].Yspace =  GridHeader[ii].Yspacing;
            MG[k].SouthWestX = cornerx;
            MG[k].SouthWestY = cornery;
            MG[k].numX = MGrows;
            MG[k].numY = MGcols;

            seekoffset = GridHeader[ii].Xpts * CalculateBytesPerGridValue(BytesPerGridValue);
            jj = 0;
            ii = 0;
            for(i=0; i<NGT[index].NumRows[k]; i++)
               {
               ii = 0;
               fseek(gridfile,NGT[index].fileptr[k] + (i * seekoffset), SEEK_SET);
               for(j=0; j<NGT[index].NumCols[k]; j++)
                  {
                  switch(BytesPerGridValue)
                     {
                     case 1:
                        fread(&charelev, 1,1,gridfile);
                        dz = (double) charelev;
                        break;
                     case 2:
                         SEEIT_fread_short(&shortint_elev,gridfile);
                         dz = (double) shortint_elev;
                         break;
                     case 3:
                         SEEIT_fread_ushort(&unsigned_shortint_elev,gridfile);
                         dz = (double) unsigned_shortint_elev;
                         break;
                     case 4:
                         SEEIT_fread_int(&int_elev,gridfile);
                         dz = (double) int_elev;
                         break;
                     case 5:
                         SEEIT_fread_uint(&unsigned_int_elev,gridfile);
                         dz = (double) unsigned_int_elev;
                         break;
                     case 6:
                         SEEIT_fread_float(&float_elev,gridfile);
                         dz = (double) float_elev;
                         break;
                     case 7:
                        fread(&charelevS, 1,1,gridfile);
                        dz = (double) charelevS;
                        break;
                     case 9:
                         SEEIT_fread_double(&dz,gridfile);
                         break;
                     default:
                         printf("bad BPGV %d\n",BytesPerGridValue);
                         exit(-1);
                         break;
                     }
   
                  arrayindex = (NGT[index].NumRows[k] * j) + i;
                  MG[k].Elevs[arrayindex] = dz;
                  ++ii;
                  }
               jj += ii;
               }

            }  /** end if OKtoUse ***/
         } /*** end for k ***/
      }
   return(rows);
}




int ReadLinearFromFile(FILE * linearfile, double decimalplaces)
{
int i,indL,attr_type;
int vtxcnt = 0;
double fx, fy, fz, z1;
int OKtoUse = 1;
extern int NOTYPE;
extern int C_TYPE;
extern int D_TYPE;
extern int I_TYPE;
extern int LONG_ATTR_CHECK_AREA;
extern int LONG_ATTR_CHECK_HGT;
extern int LONG_ATTR_CHECK_ZV2;
extern int LONG_ATTR_CHECK_LEN;
extern int LONG_ATTR_CHECK_NAM;
extern int GetLongAttrVal(int type,int uniqueid,int *Ival,double *Dval,char *Cval);


   if((linearfile != NULL) && (feof(linearfile) == 0))
      {
      LinearFromFile.length = 0;
      SEEIT_fread_int(&LinearFromFile.featureid,linearfile);
      SEEIT_fread_int(&LinearFromFile.Lindex,linearfile);
      if((NGA_TYPE == 0) && (NumLODbands > 0))
         {
         indL = CrsWlk[LinearFromFile.Lindex].LODband;

         if((indL > 0) && (LODindex[indL-1].active < 1))
            {
            OKtoUse = 0;
            }
         }
      SEEIT_fread_int(&LinearFromFile.Sindex,linearfile);
      SEEIT_fread_int(&LinearFromFile.idn,linearfile);

      if(running)
         {
         LinearFromFile.areastr[0] = '\0';
         LinearFromFile.hgtstr[0] = '\0';
         LinearFromFile.zv2str[0] = '\0';
         LinearFromFile.lenstr[0] = '\0';
         LinearFromFile.namstr[0] = '\0';
         LinearFromFile.zv2attr = MY2DSENTINEL;
         LinearFromFile.areaattr = MY2DSENTINEL;
         LinearFromFile.hgtattr = MY2DSENTINEL;
         LinearFromFile.lenattr = MY2DSENTINEL;
         LinearFromFile.namattr = MY2DSENTINEL;
         attr_type = GetLongAttrVal(LONG_ATTR_CHECK_AREA,LinearFromFile.idn,&i,&fx,&MessageLine[0]);
         if(attr_type == D_TYPE)
            LinearFromFile.areaattr = fx;
         else if(attr_type == NOTYPE)
            LinearFromFile.areaattr = MY2DSENTINEL;
         else if(attr_type == C_TYPE)
            {
            MessageLine[49] = '\0';
            strcpy(LinearFromFile.areastr,MessageLine);
            LinearFromFile.areaattr = MY2DSENTINEL;
            }
         else if(attr_type == I_TYPE)
            LinearFromFile.areaattr = (double) i;

         attr_type = GetLongAttrVal(LONG_ATTR_CHECK_HGT,LinearFromFile.idn,&i,&fx,&MessageLine[0]);
         if(attr_type == D_TYPE)
            LinearFromFile.hgtattr = fx;
         else if(attr_type == NOTYPE)
            LinearFromFile.hgtattr = MY2DSENTINEL;
         else if(attr_type == C_TYPE)
            {
            MessageLine[49] = '\0';
            strcpy(LinearFromFile.hgtstr,MessageLine);
            LinearFromFile.hgtattr = MY2DSENTINEL;
            }
         else if(attr_type == I_TYPE)
            LinearFromFile.hgtattr = (double) i;

         attr_type = GetLongAttrVal(LONG_ATTR_CHECK_ZV2,LinearFromFile.idn,&i,&fx,&MessageLine[0]);
         if(attr_type == D_TYPE)
            LinearFromFile.zv2attr = fx;
         else if(attr_type == NOTYPE)
            LinearFromFile.zv2attr = MY2DSENTINEL;
         else if(attr_type == C_TYPE)
            {
            MessageLine[49] = '\0';
            strcpy(LinearFromFile.zv2str,MessageLine);
            LinearFromFile.zv2attr = MY2DSENTINEL;
            }
         else if(attr_type == I_TYPE)
            LinearFromFile.zv2attr = (double) i;
         attr_type = GetLongAttrVal(LONG_ATTR_CHECK_NAM,LinearFromFile.idn,&i,&fx,&MessageLine[0]);
         if(attr_type == D_TYPE)
            LinearFromFile.namattr = fx;
         else if(attr_type == NOTYPE)
            LinearFromFile.namattr = MY2DSENTINEL;
         else if(attr_type == C_TYPE)
            {
            MessageLine[499] = '\0';
            LinearFromFile.namstr[0] = '"';
            LinearFromFile.namstr[1] = '\0';
            strcat(LinearFromFile.namstr,MessageLine);
            strcat(LinearFromFile.namstr,"\"");
            LinearFromFile.namattr = MY2DSENTINEL;
            }
         else if(attr_type == I_TYPE)
            LinearFromFile.namattr = (double) i;
         attr_type = GetLongAttrVal(LONG_ATTR_CHECK_LEN,LinearFromFile.idn,&i,&fx,&MessageLine[0]);
         if(attr_type == D_TYPE)
            LinearFromFile.lenattr = fx;
         else if(attr_type == NOTYPE)
            LinearFromFile.lenattr = MY2DSENTINEL;
         else if(attr_type == C_TYPE)
            {
            MessageLine[49] = '\0';
            strcpy(LinearFromFile.lenstr,MessageLine);
            LinearFromFile.lenattr = MY2DSENTINEL;
            }
         else if(attr_type == I_TYPE)
            LinearFromFile.lenattr = (double) i;
         }
      else
         {
         LinearFromFile.areaattr = MY2DSENTINEL;
         LinearFromFile.hgtattr = MY2DSENTINEL;
         LinearFromFile.zv2attr = MY2DSENTINEL;
         LinearFromFile.lenattr = MY2DSENTINEL;
         LinearFromFile.namattr = MY2DSENTINEL;
         }

      SEEIT_fread_int(&LinearFromFile.numnodes,linearfile);
      if(LinearFromFile.numnodes <= 1)
         {
         vtxcnt = 2;
         LinearFromFile.badform = 1;
         }
      else
         {
         vtxcnt = LinearFromFile.numnodes;
         LinearFromFile.badform = 0;
         }
      if(OKtoUse > 0)
         {
         if(LinearFromFile.MaxNodes == 0)
            {
            LinearFromFile.x = (double *) (malloc(vtxcnt * SzD));
            LinearFromFile.y = (double *) (malloc(vtxcnt * SzD));
            LinearFromFile.z = (double *) (malloc(vtxcnt * SzD));
            LinearFromFile.MaxNodes = vtxcnt;
            }
         else if(LinearFromFile.numnodes > LinearFromFile.MaxNodes)
            {
            LinearFromFile.x = (double *) (realloc(LinearFromFile.x,LinearFromFile.numnodes * SzD));
            LinearFromFile.y = (double *) (realloc(LinearFromFile.y,LinearFromFile.numnodes * SzD));
            LinearFromFile.z = (double *) (realloc(LinearFromFile.z,LinearFromFile.numnodes * SzD));
            LinearFromFile.MaxNodes = LinearFromFile.numnodes;
            }
         if((LinearFromFile.x == NULL) ||
             (LinearFromFile.y == NULL) || (LinearFromFile.z == NULL))
            {
            printf("allocation memory exhausted during linear data read \n");
            exit(-1);
            }
         }
      if(AbsoluteAccuracy == 1)
         {
         for(i=0; i<LinearFromFile.numnodes; i++)
            {
            SEEIT_fread_double(&fx,linearfile);
            SEEIT_fread_double(&fy,linearfile);
            SEEIT_fread_double(&fz,linearfile);
            if(OKtoUse > 0)
               {
               if((NGA_TYPE == 0) && (DRAW_ONLY == 0) &&(CLAMPFEATURES > 0) && (GetPointElevation(fx,fy,&z1) > 0))
                  fz = z1; 
               LinearFromFile.x[i] = fx;
               LinearFromFile.y[i] = fy;
               LinearFromFile.z[i] = fz;
               }
            }
         }
      else
         {
         for(i=0; i<LinearFromFile.numnodes; i++)
            {
            SEEIT_fread_double(&fx,linearfile);
            SEEIT_fread_double(&fy,linearfile);
            SEEIT_fread_double(&fz,linearfile);
            if(OKtoUse > 0)
               {
               if((NGA_TYPE == 0) && (DRAW_ONLY == 0) &&(CLAMPFEATURES > 0) && (GetPointElevation(fx,fy,&z1) > 0))
                  fz = z1; 
               if(NGA_TYPE == 0)
                  {
                  LinearFromFile.x[i] = TruncNdigs(fx, decimalplaces);
                  LinearFromFile.y[i] = TruncNdigs(fy, decimalplaces);
                  LinearFromFile.z[i] = fz;
                  }
               else if(NGA_TYPE == 1)
                  {
                  LinearFromFile.x[i] = SixPointFiveRound(1,fx);
                  LinearFromFile.y[i] = SixPointFiveRound(2,fy);
                  LinearFromFile.z[i] = SixPointFiveRound(3,fz);
                  }
               }
            }
         }

      if(OKtoUse > 0)
         {
         LinearFromFile.config = (unsigned char) SCCtable[LinearFromFile.Sindex].C;
         LinearFromFile.stratum = (unsigned char) SCCtable[LinearFromFile.Sindex].S;
         LinearFromFile.domain = (unsigned char) SCCtable[LinearFromFile.Sindex].D;
         }
      }
   if(OKtoUse == 0)
      {
      vtxcnt = 0;
      }
   else
      {
      if(LinearFromFile.numnodes == 1)
         {
         LinearFromFile.x[1] = LinearFromFile.x[0];
         LinearFromFile.y[1] = LinearFromFile.y[0];
         LinearFromFile.z[1] = LinearFromFile.z[0];
         LinearFromFile.numnodes = 2;
         vtxcnt = 1;
         }
      else
         {
         vtxcnt = LinearFromFile.numnodes;
         LinearFromFile.length = Distance(LinearFromFile.x[0],LinearFromFile.y[0],
                   LinearFromFile.x[1],LinearFromFile.y[1]);
         for(i=2; i<LinearFromFile.numnodes; i++)
            LinearFromFile.length += Distance(LinearFromFile.x[i-1],LinearFromFile.y[i-1],
                   LinearFromFile.x[i],LinearFromFile.y[i]);
         }

      }
   return(vtxcnt);

}


void ReadAttrBoundaryMatchSpecification(void)
{
FILE *BMin;
char BMinName[500];
char linein[500];
char temp[500];
int SzACBM, i, j, k, acode, fcode, process_it;
char c;

extern char *GetBoundaryMatchFile();


   SzACBM = sizeof(struct AttrsCountForBndryMatch);



   strcpy(BMinName,GetBoundaryMatchFile());

   BMin = fopen(BMinName,"rt");

   if(BMin == NULL)
      {
      printf("failed to open %s\n",BMinName);
      printf("No attributes will be required to match during boundary matching inspections\n");
      return;
      }
   fgets(linein,399,BMin); /*** skip the header row ***/
   fgets(linein,99,BMin);
   while(feof(BMin) == 0)
      {
      if(((linein[0] == '1') || (linein[0] == '2') || (linein[0] == '3')) && (linein[1] == ','))
         {
         if((linein[2] == '0') || (linein[2] == '1'))
            {
            if(linein[3] == ',')
               {
               j = i = 4;
               k = 0;
               while(linein[j] != ',')
                  {
                  temp[k] = linein[j];
                  ++k;
                  ++j;
                  if(linein[j] < ' ')
                     break;
                  }
               temp[k] = '\0';
               acode = SilentGetAttrIndex(temp);
               if(acode >= 0)   /*** if a bad code, will see -1 as return value ***/
                  {
                  i = j + 1;
                  if((linein[i] == 'M') || (linein[i] == 'O'))
                     {
                     ++i;
                     if(linein[i] == ',')
                        {
                        ++i;
                        j = i;
                        k = 0;
                        while(linein[j] != ',')
                           {
                           temp[k] = linein[j];
                           ++k;
                           ++j;
                           if(linein[j] < ' ')
                              break;
                           }
                        temp[k] = '\0';
                        if(strcmp(temp,"All") == 0)  /** then this attribute spec applies to all features and geometries ***/
                           fcode = -999;
                        else
                           fcode = SilentGetCodeIndex(temp);
                        if((fcode >= 0) || (fcode == -999))   /*** if a bad code, will see -1 as return value ***/
                           {
                           ++j;
                           process_it = 1;
                           if((linein[j] == 'P') && (linein[j+1] < ' '))
                              c = linein[j];
                           else if((linein[j] == 'L') && (linein[j+1] < ' '))
                              c = linein[j];
                           else if((linein[j] == 'A') && (linein[j+1] < ' '))
                              c = linein[j];
                           else if((linein[j] == 'A') && (linein[j+1] == 'l') && (linein[j+2] == 'l') && (linein[j+3] < ' '))
                              c = 'Z';
                           else
                              process_it = 0;
                           if(process_it > 0)
                              {
                              ACBMn = (struct AttrsCountForBndryMatch *) malloc(SzACBM);
                              ACBMn->acode = acode;
                              ACBMn->fcode = fcode;
                              if(linein[0] == '2')
                                 ACBMn->allow_nunanpo = 1;
                              else if(linein[0] == '3')
                                 ACBMn->allow_nunanpo = 2;
                              else
                                 ACBMn->allow_nunanpo = 0;
                              ACBMn->fgeom = c;
                              ACBMn->next = NULL;
                              if(ACBMroot == NULL)
                                 ACBMroot = ACBMn;
                              else
                                 ACBMp->next = ACBMn;
                              ACBMp = ACBMn;
                              }
                           else
                              {
                              printf("bad specification in input line %s",linein);
                              printf("the entry in column 6 ('Geometry') must be one of 'L', 'A', or 'All'\n");
                              printf("(Note: GAIT does not apply boundary-matching inspections to point features)\n");
                              printf("ignoring this input attribute boundary matching specification\n");
                              }
                           }
                        else
                           {
                           printf("bad specification in input line %s",linein);
                           printf("the entry in column 5 ('Feature Code') must be valid as specified by the project schema\n");
                           printf("code %s does not appear to be a valid feature code in the current schema\n",temp);
                           printf("ignoring this input attribute boundary matching specification\n");
                           }
                        }
                     else
                        {
                        printf("bad specification in input line %s",linein);
                        printf("entries in column 4 ('Required') can only 1 character (be either 'M' or 'O')\n");
                        printf("the following character in the file must be a comma (',')\n");
                        printf("ignoring this input attribute boundary matching specification\n");
                        }
                     }
                  else
                     {
                     printf("bad specification in input line %s",linein);
                     printf("entries in column 4 ('Required') can only 1 character (be either 'M' or 'O')\n");
                     printf("the following character in the file must be a comma (',')\n");
                     printf("ignoring this input attribute boundary matching specification\n");
                     }
                  }
               else
                  {
                  printf("bad specification in input line %s",linein);
                  printf("the entry in column 3 ('Attribute Code') must be valid as specified by the project schema\n");
                  printf("code %s does not appear to be a valid attribute code in the current schema\n",temp);
                  printf("ignoring this input attribute boundary matching specification\n");
                  }
               }
            else
               {
               printf("bad specification in input line %s",linein);
               printf("entries in columns 1 and 2 ('On/Off' and 'Metadata') should both only 1 character (be either '0' or '1')\n");
               printf("the 4th character in the file must be a comma (',')\n");
               printf("ignoring this input attribute boundary matching specification\n");
               }
            }
         else
            {
            printf("bad specification in input line %s",linein);
            printf("entry in column 2 ('Metadata') should be either '0' or '1'\n");
            printf("ignoring this input attribute boundary matching specification\n");
            }
         }
      else if((linein[0] != '0') || (linein[1] != ','))
         {
         printf("bad specification in input line %s",linein);
         printf("entry in column 1 ('On/Off') should be either '0', '1', or '2'\n");
         printf("ignoring this input attribute boundary matching specification\n");
         }
      fgets(linein,99,BMin);
      }
   fclose(BMin);
}


int EqualWithinTolerance(double x1, double y1, double x2, double y2,double tolerance)
{
double upperx, lowerx, uppery, lowery, dist;

   upperx = x1 + tolerance;
   lowerx = x1 - tolerance;
   if((upperx > x2) && (lowerx < x2))
      {
      uppery = y1 + 0.1;
      lowery = y1 - 0.1;
      if((uppery > y2) && (lowery < y2))
         {
         dist = Distance(x1,y1,x2,y2);
         if(dist <= tolerance)
            return(1);
         else
            return(0);
         }
      else
         return(0);
      }
   else
      return(0);
}


int NearlyEqual(double v1, double v2)
{
double d;
  if(v1 > v2)
     d = v1 - v2;
  else
     d = v2 - v1;

  if(d < 0.0001)
     return(1);
  else
     return(0);
}




int ReadPointFromFile(FILE * pointfile, double decimalplaces)
{
int i, attr_type;
int vtxcnt = -3;
double fx, fy, fz, fh, frad;
extern int NOTYPE;
extern int C_TYPE;
extern int D_TYPE;
extern int I_TYPE;
extern int LONG_ATTR_CHECK_AREA;
extern int LONG_ATTR_CHECK_HGT;
extern int LONG_ATTR_CHECK_ZV2;
extern int LONG_ATTR_CHECK_LEN;
extern int LONG_ATTR_CHECK_NAM;
extern int GetLongAttrVal(int type,int uniqueid,int *Ival,double *Dval,char *Cval);



   if((pointfile != NULL) && (feof(pointfile) == 0))
      {
      fh = 0.0;
      SEEIT_fread_int(&PointFromFile.featureid,pointfile);
      SEEIT_fread_int(&PointFromFile.Lindex,pointfile);
      SEEIT_fread_int(&PointFromFile.Sindex,pointfile);
      SEEIT_fread_int(&PointFromFile.idn,pointfile);

      if(running)
         {
         PointFromFile.areastr[0] = '\0';
         PointFromFile.hgtstr[0] = '\0';
         PointFromFile.zv2str[0] = '\0';
         PointFromFile.lenstr[0] = '\0';
         PointFromFile.namstr[0] = '\0';
         PointFromFile.zv2attr = MY2DSENTINEL;
         PointFromFile.areaattr = MY2DSENTINEL;
         PointFromFile.hgtattr = MY2DSENTINEL;
         PointFromFile.lenattr = MY2DSENTINEL;
         PointFromFile.namattr = MY2DSENTINEL;
         attr_type = GetLongAttrVal(LONG_ATTR_CHECK_AREA,PointFromFile.idn,&i,&fx,&MessageLine[0]);
         if(attr_type == D_TYPE)
            PointFromFile.areaattr = fx;
         else if(attr_type == NOTYPE)
            PointFromFile.areaattr = MY2DSENTINEL;
         else if(attr_type == C_TYPE)
            {
            MessageLine[49] = '\0';
            strcpy(PointFromFile.areastr,MessageLine);
            PointFromFile.areaattr = MY2DSENTINEL;
            }
         else if(attr_type == I_TYPE)
            PointFromFile.areaattr = (double) i;

         attr_type = GetLongAttrVal(LONG_ATTR_CHECK_HGT,PointFromFile.idn,&i,&fx,&MessageLine[0]);
         if(attr_type == D_TYPE)
            PointFromFile.hgtattr = fx;
         else if(attr_type == NOTYPE)
            PointFromFile.hgtattr = MY2DSENTINEL;
         else if(attr_type == C_TYPE)
            {
            MessageLine[49] = '\0';
            strcpy(PointFromFile.areastr,MessageLine);
            PointFromFile.hgtattr = MY2DSENTINEL;
            }
         else if(attr_type == I_TYPE)
            PointFromFile.hgtattr = (double) i;

         attr_type = GetLongAttrVal(LONG_ATTR_CHECK_ZV2,PointFromFile.idn,&i,&fx,&MessageLine[0]);
         if(attr_type == D_TYPE)
            PointFromFile.zv2attr = fx;
         else if(attr_type == NOTYPE)
            PointFromFile.zv2attr = MY2DSENTINEL;
         else if(attr_type == C_TYPE)
            {
            MessageLine[49] = '\0';
            strcpy(PointFromFile.zv2str,MessageLine);
            PointFromFile.zv2attr = MY2DSENTINEL;
            }
         else if(attr_type == I_TYPE)
            PointFromFile.zv2attr = (double) i;
         attr_type = GetLongAttrVal(LONG_ATTR_CHECK_LEN,PointFromFile.idn,&i,&fx,&MessageLine[0]);
         if(attr_type == D_TYPE)
            PointFromFile.lenattr = fx;
         else if(attr_type == NOTYPE)
            PointFromFile.lenattr = MY2DSENTINEL;
         else if(attr_type == C_TYPE)
            {
            MessageLine[49] = '\0';
            strcpy(PointFromFile.lenstr,MessageLine);
            PointFromFile.lenattr = MY2DSENTINEL;
            }
         else if(attr_type == I_TYPE)
            PointFromFile.lenattr = (double) i;
         attr_type = GetLongAttrVal(LONG_ATTR_CHECK_NAM,PointFromFile.idn,&i,&fx,&MessageLine[0]);
         if(attr_type == D_TYPE)
            PointFromFile.namattr = fx;
         else if(attr_type == NOTYPE)
            PointFromFile.namattr = MY2DSENTINEL;
         else if(attr_type == C_TYPE)
            {
            MessageLine[499] = '\0';
            PointFromFile.namstr[0] = '"';
            PointFromFile.namstr[1] = '\0';
            strcat(PointFromFile.namstr,MessageLine);
            strcat(PointFromFile.namstr,"\"");
            PointFromFile.namattr = MY2DSENTINEL;
            }
         else if(attr_type == I_TYPE)
            PointFromFile.namattr = (double) i;

         }
      else
         {
         PointFromFile.areaattr = MY2DSENTINEL;
         PointFromFile.hgtattr = MY2DSENTINEL;
         PointFromFile.zv2attr = MY2DSENTINEL;
         PointFromFile.lenattr = MY2DSENTINEL;
         PointFromFile.namattr = MY2DSENTINEL;
         }


      SEEIT_fread_int(&PointFromFile.numverts,pointfile);
      SEEIT_fread_double(&frad,pointfile);
      
      if(AbsoluteAccuracy == 1)
         PointFromFile.rad  = frad;
      else
         {
         PointFromFile.rad = TruncNdigs(frad, decimalplaces);
         }
      if((PointFromFile.numverts < 1) && (PointFromFile.numverts > -3))
         vtxcnt = 1;
      else if(PointFromFile.numverts < -2)
         vtxcnt = 0 - PointFromFile.numverts;
      else
         vtxcnt = PointFromFile.numverts;
      if(PointFromFile.MaxVerts == 0)
         {
         PointFromFile.MaxVerts = vtxcnt + 10;
         PointFromFile.x = (double *) (malloc(PointFromFile.MaxVerts * SzD));
         PointFromFile.y = (double *) (malloc(PointFromFile.MaxVerts * SzD));
         PointFromFile.z = (double *) (malloc(PointFromFile.MaxVerts * SzD));
         PointFromFile.h = (double *) (malloc(PointFromFile.MaxVerts * SzD));
         if((PointFromFile.h == NULL) || (PointFromFile.x == NULL) ||
                 (PointFromFile.y == NULL) || (PointFromFile.z == NULL))
            {
            printf("allocation memory exhausted during point data read\n");
            exit(-1);
            }
         }
      else if(PointFromFile.MaxVerts < vtxcnt)
         {
         PointFromFile.MaxVerts = vtxcnt + 10;
         PointFromFile.x = (double *) (realloc(PointFromFile.x,PointFromFile.MaxVerts * SzD));
         PointFromFile.y = (double *) (realloc(PointFromFile.y,PointFromFile.MaxVerts * SzD));
         PointFromFile.z = (double *) (realloc(PointFromFile.z,PointFromFile.MaxVerts * SzD));
         PointFromFile.h = (double *) (realloc(PointFromFile.z,PointFromFile.MaxVerts * SzD));
      
         if((PointFromFile.h == NULL) || (PointFromFile.x == NULL) ||
                 (PointFromFile.y == NULL) || (PointFromFile.z == NULL))
            {
            printf("allocation memory exhausted during point data read\n");
            exit(-1);
            }
         }
      for(i=0; i<vtxcnt; i++)
         {
         SEEIT_fread_double(&fx,pointfile);
         SEEIT_fread_double(&fy,pointfile);
         SEEIT_fread_double(&fz,pointfile);
         if(PointFromFile.numverts == -1)
            {
            fh = 0.0;
            }
         else
            {
            SEEIT_fread_double(&fh,pointfile);
            }

         if(AbsoluteAccuracy == 1)
            {
            PointFromFile.x[i] = fx;
            PointFromFile.y[i] = fy;
            PointFromFile.z[i] = fz;
            PointFromFile.h[i] = fh;
            }
         else if(NGA_TYPE == 1)
            {
            PointFromFile.x[i] = SixPointFiveRound(1,fx);
            PointFromFile.y[i] = SixPointFiveRound(2,fy);
            PointFromFile.z[i] = SixPointFiveRound(3,fz);
            }
         else
            {
            PointFromFile.x[i] = TruncNdigs(fx, decimalplaces);
            PointFromFile.y[i] = TruncNdigs(fy, decimalplaces);
            PointFromFile.z[i] = fz;
            PointFromFile.h[i] = fh;
            }
         }
      PointFromFile.config = (unsigned char) SCCtable[PointFromFile.Sindex].C;
      PointFromFile.stratum = (unsigned char) SCCtable[PointFromFile.Sindex].S;
      PointFromFile.domain = (unsigned char) SCCtable[PointFromFile.Sindex].D;
      }
   return(vtxcnt);
}


int ReadBridgeFromFile(FILE * bridgefile, double decimalplaces)
{
int i;
int vtxcnt = 0;
double fx, fy, fz, fh;

   if((bridgefile != NULL) && (feof(bridgefile) == 0))
      {
      SEEIT_fread_int(&BridgeFromFile.Bindex,bridgefile);
      SEEIT_fread_int(&BridgeFromFile.Lindex,bridgefile);
      SEEIT_fread_int(&BridgeFromFile.Sindex,bridgefile);
      BridgeFromFile.idn = -1;
      SEEIT_fread_int(&BridgeFromFile.numverts,bridgefile);
      vtxcnt = BridgeFromFile.numverts;
      BridgeFromFile.x = (double *) (malloc(vtxcnt * SzD));
      BridgeFromFile.y = (double *) (malloc(vtxcnt * SzD));
      BridgeFromFile.z = (double *) (malloc(vtxcnt * SzD));
      BridgeFromFile.h = (double *) (malloc(vtxcnt * SzD));
      if((BridgeFromFile.h == NULL) || (BridgeFromFile.y == NULL) || (BridgeFromFile.z == NULL))
         {
         printf("allocation memory exhausted during bridge data read\n");
         exit(-1);
         }
      for(i=0; i<vtxcnt; i++)
         {
         SEEIT_fread_double(&fx,bridgefile);
         SEEIT_fread_double(&fy,bridgefile);
         SEEIT_fread_double(&fz,bridgefile);
         SEEIT_fread_double(&fh,bridgefile);
         if(AbsoluteAccuracy == 1)
            {
            BridgeFromFile.x[i] = fx;
            BridgeFromFile.y[i] = fy;
            BridgeFromFile.z[i] = fz;
            BridgeFromFile.z[i] = fh;
            }
         else
            {
            BridgeFromFile.x[i] = TruncNdigs(fx, decimalplaces);
            BridgeFromFile.y[i] = TruncNdigs(fy, decimalplaces);
            BridgeFromFile.z[i] = fz;
            BridgeFromFile.z[i] = fh;
            }
         }
      BridgeFromFile.config = (unsigned char) SCCtable[BridgeFromFile.Sindex].C;
      BridgeFromFile.stratum = (unsigned char) SCCtable[BridgeFromFile.Sindex].S;
      BridgeFromFile.domain = (unsigned char) SCCtable[BridgeFromFile.Sindex].D;
      }
   return(vtxcnt);
}



double TriangleXYsurfaceArea(double x[3], double y[3])
{
double answer;
double x10,x20,y10,y20;
   x10 = x[1] - x[0];
   x20 = x[2] - x[0];
   y10 = y[1] - y[0];
   y20 = y[2] - y[0];
   answer = (x10 * y20) - (x20 * y10);
   answer = answer * 0.5;
   if(answer < 0)
      answer = 0 - answer;
   return(answer);
}

double TriangleSurfaceArea(double x[3],double y[3],double z[3])
{
double x10, x20, y10, y20, z10, z20;
double answer;
   x10 =  (x[1] - x[0]);
   x20 =  (x[2] - x[0]);
   y10 =  (y[1] - y[0]);
   y20 =  (y[2] - y[0]);
   z10 =  (z[1] - z[0]);
   z20 =  (z[2] - z[0]);

   answer = (y10*z20 - z10*y20) * (y10*z20 - z10*y20);
   answer += (z10*x20 - x10*z20) * (z10*x20 - x10*z20);
   answer += (x10*y20 - y10*x20) * (x10*y20 - y10*x20);
   answer = sqrt(answer);
   answer = answer * 0.5;
   return(answer);
}


/*** this will calculate an incorrect area if the polygon is not convex***/
double SurfaceAreaByTriangles(int numverts, double * x, double * y, double * z)
{
  double trix[3], triy[3], triz[3];
  int i,j;
  double answer = 0.0;
  
  
  trix[0] = x[0];
  triy[0] = y[0];
  triz[0] = z[0];
  
  i = 1; j = 2;
  while(j < numverts)
    {
      trix[1] = x[i];
      triy[1] = y[i];
      triz[1] = z[i];
      
      trix[2] = x[j];
      triy[2] = y[j];
      triz[2] = z[j];
      
      answer += TriangleSurfaceArea(trix,triy,triz);
      i = j;
      j = j + 1;
    }
  return(answer);
}





double SpecialTriArea(double x1, double y1, double x2, double y2, double x3, double y3)
{
  return   
    (x1*y2  -  y1*x2   +
     y1*x3  -  x1*y3   +
     x2*y3  -  x3*y2);
}


/*** this will calculate a correct area even if the polygon is not convex***/
double XYSurfaceAreaByTriangles(int numverts, double * x, double * y)
{
  int i;
  double answer = 0.0;
  
  for(i=1;i<numverts-1;i++)
    {
      answer = answer + SpecialTriArea(x[0],  y[0],
				       x[i],  y[i],
				       x[i+1],y[i+1]);

    }

  answer = fabs(answer);
  
  return (answer/2.0);
}



double RadiansToDegrees(double radianmeasure)
{
  double degreemeasure;
  int DII;

  degreemeasure = radianmeasure * OneRadianInDegrees;
  DII = (long int) (degreemeasure * 100000.0);

  degreemeasure = ((double) DII)/ 100000.0;
  return(degreemeasure);
}


double AngleBetweenLineSegments(double lx1,double ly1,double lx2,double ly2,double x1,double y1,double x2,double y2)
{
double A1, B1, C1;
double A2, B2, C2;
double answer;
double d1, d2, d3;

   LineEquation(lx1,ly1,lx2,ly2, &A1, &B1, &C1); 
   LineEquation(x1,y1,x2,y2, &A2, &B2, &C2);

   d1 = (A1 * A2) + (B1 * B2);
   d2 = (A1 * A1) + (B1 * B1);
   d3 = (A2 * A2) + (B2 * B2);
   d2 = d2 * d3;
   d2 = sqrt(d2);

   answer = d1 / d2;

   return(answer);
}





int PointInsidePoly(double px,double py,double * x,double * y,int numb)
{
int numInts, i, j, k, incr;
double nx, ny;

   numInts = 0;
   for(i=0; i<numb; i++)
      {
      j = (i + 1) % numb;
      if((y[i] < py) && (py < y[j]))
         {
         if((x[i] > px) || (x[j] > px))
            {
            ny = (y[j] - py) / (y[j] - y[i]);
            nx = x[j] - ((x[j] - x[i]) * ny);
            if(nx > px)
               {
               ++numInts;
               }
            }
         }
      else if((y[j] < py) && (py < y[i]))
         {
         if((x[i] > px) || (x[j] > px))
            {
            ny = (y[i] - py) / (y[i] - y[j]);
            nx = x[i] - ((x[i] - x[j]) * ny);
            if(nx > px)
               {
               ++numInts;
               }
            }
         }
      else if((py == y[i]) && (px < x[i]) && (py != y[j]))
         {
         if(((x[j] <= px) && (x[i] > px)) ||
              ((x[j] >= px) && (x[i] < px)) ||
              ((x[j] >= px) && (x[i] > px)))
            {
            for(incr = 1; incr < numb; incr++)
               {
               k = (i + numb - incr) % numb;
               if(y[k] != py)
                  break;
               }
            if((y[k] < py) && (py < y[j]))
               {
               ++numInts;
               }
            else if((y[j] < py) && (py < y[k]))
               {
               ++numInts;
               }
            }
         }
      }
   j = (numInts % 2);
   return(j);
}


int PointInsideTriangle(double x,double y,double x1,double y1,double x2,double y2,double x3,double y3)
{
double c1, c2, c3;
double px[3], py[3];
double surfacearea2D;
int answer;

   px[0] = x1; px[1] = x2; px[2] = x3;
   py[0] = y1; py[1] = y2; py[2] = y3;
   surfacearea2D = TriangleXYsurfaceArea(px,py);
   if(surfacearea2D < 0.1)
      answer = PointInsidePoly(x,y,px,py,3);
   else
      {
      c1 = ((x - x1) * (y2 - y1)) - ((x2 - x1) * (y - y1));
      c2 = ((x - x2) * (y3 - y2)) - ((x3 - x2) * (y - y2));
      c3 = ((x - x3) * (y1 - y3)) - ((x1 - x3) * (y - y3));

      if((c1 <= 0) && (c2 <= 0) && (c3 <= 0))
         answer = 1;
      else if ((c1 >= 0) && (c2 >= 0) && (c3 >= 0))
         answer = 1;
      else
         answer = 0;
      }
   return(answer);
}





struct RawAreal * PointInsideComplexAreal(double x, double y, struct ListOfAreals * A, int * answer)
{

struct RawAreal * rac;

   *answer = 0;
   rac = NULL;

   if(A == NULL)
      *answer = 0;
   else
      {
      if(PointInsidePoly(x,y,A->x, A->y, A->numverts) > 0)
         {
         if(A->holes == NULL)
            {
            *answer = 1;
            }
         else
            {
            rac = A->holes;
            while(rac != NULL)
               {
               if(PointInsidePoly(x,y,rac->x,rac->y,rac->numverts) > 0)
                  break;
               rac = rac->next;
               }
            if(rac == NULL)
               *answer = 1;
            else
               *answer = 2;
            }
         }
      else
         *answer = 0;
      }

   return(rac);
}


int PointInsideArealWithHoles(double x, double y, struct RawAreal * List, struct RawAreal * A)
{
int answer;
struct RawAreal *hole;
int OnEdge;

   answer = 0;
   if(A->RB_Tree_Edgelist == NULL)
      {
      if((A->ishole <= 0) && (PointInsidePoly(x,y,A->x, A->y, A->numverts) > 0))
         {
         hole = List;
         while(hole != NULL)
            {
            if((hole->ishole >= 1) && (hole->idn == A->idn))
               {
               if(hole->RB_Tree_Edgelist == NULL)
                  {
                  if(PointInsidePoly(x,y,hole->x,hole->y,hole->numverts) > 0)
                     {
                     answer = 0;
                     break;
                     }
                  }
               else if(PointInsideLargeAreal(x,y,hole,&OnEdge))
                  {
                  answer = 0;
                  break;
                  }
               }
            hole = hole->next;
            }
         if(hole == NULL)
            answer = 1;
         }
      }
   else
      {
      if((A->ishole <= 0) && (PointInsideLargeAreal(x,y,A,&OnEdge) > 0))
         {
         hole = List;
         while(hole != NULL)
            {
            if((hole->ishole >= 1) && (hole->idn == A->idn))
               {
               if(hole->RB_Tree_Edgelist == NULL)
                  {
                  if(PointInsidePoly(x,y,hole->x,hole->y,hole->numverts) > 0)
                     {
                     answer = 0;
                     break;
                     }
                  }
               else if(PointInsideLargeAreal(x,y,hole,&OnEdge))
                  {
                  answer = 0;
                  break;
                  }
               }
            hole = hole->next;
            }
         if(hole == NULL)
            answer = 1;
         }
      }
   return(answer);
}







double EuclideanDistance(double x1,double y1,double x2,double y2)
{
double answer;

   answer = (x1 - x2) * (x1 - x2);
   answer += (y1 - y2) * (y1 - y2);
   answer = sqrt(answer);
   return(answer);
}

double SquaredDistance_GAITcoords(double x1,double y1,double x2,double y2)
{
double answer;
double d1, d2;

   d1 = x1 - x2;
   d2 = y1 - y2;
   answer = (d1 * d1) + (d2 * d2);

   return(answer);
}


double Distance(double x1,double y1,double x2,double y2)
{
double answer;
double tx1, tx2, ty1, ty2;
double temp, avglatitude;


   if(AlwaysUseEuclidean > 0)
      answer = EuclideanDistance(x1,y1,x2,y2);

   else if(Ctype() == 1)  /*** should be geodetic coord system ***/
      {
      tx1 = x1 / 100000.0 + Xtranslation;
      tx2 = x2 / 100000.0 + Xtranslation;
      ty1 = y1 / 100000.0 + Ytranslation;
      ty2 = y2 / 100000.0 + Ytranslation;


      avglatitude = (ty2 - ty1) / 2.0 + ty1;

    /** convert degrees to radians before call to cosine function ***/
      avglatitude = (avglatitude * PI) / 180.0;
/** this is the average latitude of the points for which want distance measurement ***/

      temp = WGS84degreeLength * cos(avglatitude); /** meters per degree at this average latitude ****/
      temp = (tx2 - tx1) * temp; /*** number of meters between the latitude coords ***/

      answer = temp * temp;

      temp = WGS84degreeLength * (ty2 - ty1);

      answer += temp * temp;
      if(answer < 0)
         answer = 0;
      else
         answer = sqrt(answer);

      }
   else
      {
      answer = (x1 - x2) * (x1 - x2);
      answer += (y1 - y2) * (y1 - y2);
      if(answer < 0)
         answer = 0;
      else
         answer = sqrt(answer);
      }
   return(answer);
}


double TwoDecimalDistance(double x1,double y1,double x2,double y2)
{
double answer;
   answer = Distance(x1,y1,x2,y2);
   answer = TruncateToNdigits( answer, 2 );
   return(answer);
}


double Distance3D(double x1,double y1,double z1,double x2,double y2,double z2)
{
double answer;

   answer = Distance(x1,y1,x2,y2);

   if((IsSentinelZvalue(z1,UseNUNANPO) > 0) || (IsSentinelZvalue(z2,UseNUNANPO) > 0))
      return(answer);

   answer = answer * answer;
   if((tempis2D(z1) == 0) && (tempis2D(z2) == 0))
      answer += (z1 - z2) * (z1 - z2);

   answer = sqrt(answer);
   return(answer);
}



double ApproxPointToLineDist2D(double xj,double yj,double xk,double yk,double xl,double yl)
{
double t,t2,t3,t4,xkj,xlk,ykj,ylk;

   xkj = xk - xj;
   xlk = xl - xk;
   ykj = yk - yj;
   ylk = yl - yk;

   if((xk == xl) && (yk == yl)) /** line segment is really a point ***/
      t2 =  (xkj*xkj) + (ykj * ykj);
   else
      {
      t = 0 - ((xkj * xlk) + (ykj * ylk));
      t2 = (xlk * xlk) + (ylk * ylk);
      t = t / t2;
      if(t <= 0)
         t2 = xkj*xkj + ykj * ykj;
      else if(t >= 1)
         t2 = (xj - xl) * (xj - xl) + (yj - yl) * (yj - yl);
      else
         {
         t4 = (xkj + (t * xlk));
         t3 = (ykj + (t * ylk));
         t2 = (t4 * t4) + (t3 * t3);
         
         }
      }
   return(t2);
}





double PointToLineDist2D(double xj,double yj,double xk,double yk,double xl,double yl)
{
double t,t2,t3,xkj,xlk,ykj,ylk;
double A, B, C, An, Bn, Cn, xi, yi;
   xkj = xk - xj;
   xlk = xl - xk;
   ykj = yk - yj;
   ylk = yl - yk;

   if((xk == xl) && (yk == yl)) /** line segment is really a point ***/
      t2 = Distance(xj,yj,xk,yk);
   else
      {
      t = 0 - ((xkj * xlk) + (ykj * ylk));
      t2 = (xlk * xlk) + (ylk * ylk);
      t = t / t2;
      if(t <= 0)
         t2 = Distance(xj,yj,xk,yk);
      else if(t >= 1)
         t2 = Distance(xj,yj,xl,yl);
      else
         {
         LineEquation(xk,yk, xl,yl, &A, &B, &C);
         An = B;
         Bn = 0 - A;
         Cn = (A * yj) - (B * xj);

         t3 = (A * Bn) - (An * B);
         t3 = 1.0 / t3;
         xi = ((B * Cn) - (Bn * C)) * t3;
         yi = ((An * C) - (A * Cn)) * t3;

         t2 = Distance(xj,yj,xi,yi);
         }
      }
   return(t2);
}




double PointToArealDist2D(double xp,double yp,struct RawAreal *Aroot)
{
int i;
struct RawAreal *rac;
double answer, temp;

   rac = Aroot;

   answer = PointToLineDist2D(xp,yp,rac->x[0],rac->y[0],rac->x[rac->numverts-1],rac->y[rac->numverts-1]);
   while(rac != NULL)
      {
      for(i=1; i<rac->numverts; i++)
         {
         temp = PointToLineDist2D(xp,yp,rac->x[i-1],rac->y[i-1],rac->x[i],rac->y[i]);
         if(temp < answer)
            answer = temp;
         }
break;
      rac = rac->next;
      }

   return(answer);
}


double PointToArealEdgeDist2D(double xp,double yp,struct RawAreal *Aroot, int *Index)
{
int i;
struct RawAreal *rac;
double answer, temp;

   rac = Aroot;

   answer = PointToLineDist2D(xp,yp,rac->x[0],rac->y[0],rac->x[rac->numverts-1],rac->y[rac->numverts-1]);
   *Index = 0;

   for(i=1; i<rac->numverts; i++)
      {
      temp = PointToLineDist2D(xp,yp,rac->x[i-1],rac->y[i-1],rac->x[i],rac->y[i]);
      if(temp < answer)
         {
         answer = temp;
         *Index = i;
         }
      }

   return(answer);
}




double PointToLineDist(double xp, double yp, double zp, double xl1, double yl1, double zl1, double xl2, double yl2, double zl2)
{
double f, g, h, t;
double xn, yn, zn;
double v1,v2;

   if((xl1 == xl2) && (yl1 == yl2) && (zl1 == zl2))
      t = -1;
   else
      {
      f =  (xl2 - xl1);
      g =  (yl2 - yl1);
      h =  (zl2 - zl1);
      v1 = f*f + g*g + h*h;

      t = f*(xp - xl1) + g*(yp-yl1) + h*(zp-zl1);
      t = t / v1;
      }

   if(t <= 0)
      {
      v2 =  Distance3D(xp,yp,zp,xl1,yl1,zl1);
      }
   else if(t >= 1)
      {
      v2 =  Distance3D(xp,yp,zp,xl2,yl2,zl2);
      }
   else
      {
      xn = xl1 + f*t;
      yn = yl1 + g*t;
      zn = zl1 + h*t;
      v2 = Distance3D(xp,yp,zp,xn,yn,zn);
      }
   return(v2);
}




double PointToLineDistWithFlag(double xp, double yp, double zp, double xl1, double yl1, double zl1, double xl2, double yl2, double zl2, double *T)
{
double f, g, h, t;
double xn, yn, zn;
double v1,v2;

   if((xl1 == xl2) && (yl1 == yl2) && (zl1 == zl2))
      t = -1;
   else
      {
      f =  (xl2 - xl1);
      g =  (yl2 - yl1);
      h =  (zl2 - zl1);
      v1 = f*f + g*g + h*h;

      t = f*(xp - xl1) + g*(yp-yl1) + h*(zp-zl1);
      t = t / v1;
      }

   if(t <= 0)
      {
      v2 =  Distance3D(xp,yp,zp,xl1,yl1,zl1);
      *T = -1.0;
      }
   else if(t >= 1)
      {
      v2 =  Distance3D(xp,yp,zp,xl2,yl2,zl2);
      *T = 2.0;
      }
   else
      {
      xn = xl1 + f*t;
      yn = yl1 + g*t;
      zn = zl1 + h*t;
      v2 = Distance3D(xp,yp,zp,xn,yn,zn);
      *T = 0.5;
      }

   return(v2);
}

/*** note that global vars PTL_Dist_Xi and PTL_Dist_Yi store the point on line segment closest to point (xj,yj) **/
double PointToLineDist2DwithFlag(double xj,double yj,double xk,double yk,double xl,double yl, double *T)
{
double t,t2,t3,xkj,xlk,ykj,ylk;
double A, B, C, An, Bn, Cn, xi, yi;
   xkj = xk - xj;
   xlk = xl - xk;
   ykj = yk - yj;
   ylk = yl - yk;

   if((xlk < 0.00001) && (xlk > -0.00001) && (ylk < 0.00001) && (ylk > -0.00001))
      {
      *T = -1;
      t2 = Distance(xj,yj,xk,yk);
      PTL_Dist_Xi = xk;
      PTL_Dist_Yi= yk;
      return(t2);
      }

   t = 0 - ((xkj * xlk) + (ykj * ylk));
   t2 = (xlk * xlk) + (ylk * ylk);
   t = t / t2;
   if(t <= 0)
      {
      t2 = Distance(xj,yj,xk,yk);
      *T = -1.0;
      PTL_Dist_Xi = xk;
      PTL_Dist_Yi= yk;
      }
   else if(t >= 1)
      {
      t2 = Distance(xj,yj,xl,yl);
      *T = 2.0;
      PTL_Dist_Xi = xl;
      PTL_Dist_Yi= yl;
      }
   else
      {
      *T = 0.5;

       LineEquation(xk,yk, xl,yl, &A, &B, &C);
       An = B;
       Bn = 0 - A;
       Cn = (A * yj) - (B * xj);

       t3 = (A * Bn) - (An * B);
       t3 = 1.0 / t3;
       xi = ((B * Cn) - (Bn * C)) * t3;
       yi = ((An * C) - (A * Cn)) * t3;

       t2 = Distance(xj,yj,xi,yi);
       PTL_Dist_Xi = xi;
       PTL_Dist_Yi= yi;

      }
   return(t2);
}






struct RawAreal * FindEdgeClosestToPoint(double px, double py,struct RawAreal * Aroot, struct RawAreal * Neighbors, struct RawAreal *tgt, int *answer)
{
struct RawAreal *ac;
struct RawAreal *featureanswer;
int i;
double mindist, ptldist;

   *answer = -1;
   featureanswer = tgt;
/*** below, note use of approx distance since don't really care about the actual distance, just want the closest ***/
   mindist = ApproxPointToLineDist2D(px,py,tgt->x[0],tgt->y[0],tgt->x[tgt->numverts-1],tgt->y[tgt->numverts-1]);
   for(i=1; i<tgt->numverts; i++)
      {
      ptldist = ApproxPointToLineDist2D(px,py,tgt->x[i],tgt->y[i],tgt->x[i-1],tgt->y[i-1]);
      if(ptldist < mindist)
         {
         mindist = ptldist;
         *answer = i;
         }
      }

/*** when considering inner rings as possibly the closest edge, note that do not really look at all the inner rings 
     in every case - are only looking at the area features (inner rings) in same and 8 immediate neighbor load modules
     so if the actual closest edge (from an inner ring) is far away (outside 3x3 load module area considered in this
     search) then the edges returned as the closest edge will not be identified ...    *******/
   if(tgt->ishole < 0) /*** then the tgt area feature has some holes - are any of the inner rings closest edge? ***/
      {
      ac = Aroot;
      while(ac != NULL)
         {
         if((ac->ishole > 0) && (ac->idn == tgt->idn))
            {
            ptldist = ApproxPointToLineDist2D(px,py,ac->x[0],ac->y[0],ac->x[ac->numverts-1],ac->y[ac->numverts-1]);
            if(ptldist < mindist)
               {
               mindist = ptldist;
               *answer = -1;
               featureanswer = ac;
               }
            for(i=1; i<ac->numverts; i++)
               {
               ptldist = ApproxPointToLineDist2D(px,py,ac->x[i],ac->y[i],ac->x[i-1],ac->y[i-1]);
               if(ptldist < mindist)
                  {
                  mindist = ptldist;
                  *answer = i;
                  featureanswer = ac;
                  }
               }
            }
         ac = ac->next;
         }

      ac = Neighbors;
      while(ac != NULL)
         {
         if((ac->ishole > 0) && (ac->idn == tgt->idn))
            {
            ptldist = ApproxPointToLineDist2D(px,py,ac->x[0],ac->y[0],ac->x[ac->numverts-1],ac->y[ac->numverts-1]);
            if(ptldist < mindist)
               {
               mindist = ptldist;
               *answer = -1;
               featureanswer = ac;
               }
            for(i=1; i<ac->numverts; i++)
               {
               ptldist = ApproxPointToLineDist2D(px,py,ac->x[i],ac->y[i],ac->x[i-1],ac->y[i-1]);
               if(ptldist < mindist)
                  {
                  mindist = ptldist;
                  *answer = i;
                  featureanswer = ac;
                  }
               }
            }
         ac = ac->next;
         }
      }

   return(featureanswer);
}





double SegmentToLargeArealDist2D(double lx1, double ly1, double lx2, double ly2,
                                 double minx,double miny,double maxx,double maxy,struct RawAreal *A, int *Aindex1, int *Aindex2)
{
int ci1, ci2, cindex;
int MYI;
int LastI, i, j, UsedTree, iindex, jindex;
struct RB_Edgelist * LastEdge1;
double px, py;
double answer, lmanswer;
double D, Dmin, tempT;
double minAx, maxAx, minAy, maxAy;

   answer = -100.0;
   MYI = MaxYindex + 1;

   for(px = lx1; px <= lx2; px += RegionSize);
      {
      ci1 = (int) (px / RegionSize);
      for(py = ly1; py <= ly2; py += RegionSize)
         {
         lmanswer = -100.0;
         ci2 = (int) (py / RegionSize);

         cindex = (ci1 * MYI) + ci2;

         LastEdge1 = NULL;
         LastI = -1;

         i = GetNextArealIndex(A, LastI, 1, &LastEdge1, cindex, &UsedTree);
         LastI = i;

         while(i >= 0)
            {
            if(lmanswer < 0)
               {
               j = (i + A->numverts - 1) % A->numverts;
               D = PointToLineDist2DwithFlag(px,py,A->x[i],A->y[i],A->x[j],A->y[j],&tempT);
               lmanswer = D;
               iindex = i;
               jindex = j;
               }
      
            j = (i + 1) % A->numverts;

            if(A->x[i] > A->x[j])
               {
               maxAx = A->x[i];
               minAx = A->x[j];
               }
            else
               {
               maxAx = A->x[j];
               minAx = A->x[i];
               }
            if(A->y[i] > A->y[j])
               {
               maxAy = A->y[i];
               minAy = A->y[j];
               }
            else
               {
               maxAy = A->y[j];
               minAy = A->y[i];
               }

            if((minAx < maxx) && (maxAx > minx) && (minAy < maxy) && (maxAy > miny))
               {
               Dmin = PointToLineDist2DwithFlag(lx1,ly1 ,A->x[i],A->y[i],A->x[j],A->y[j],&tempT);
               D = PointToLineDist2DwithFlag(lx2,ly2 ,A->x[i],A->y[i],A->x[j],A->y[j],&tempT);
               if(D < Dmin)
                  Dmin = D;
               D = PointToLineDist2DwithFlag(A->x[i],A->y[i],lx1,ly1,lx2,ly2,&tempT);
               if(D < Dmin)
                  Dmin = D;
               D = PointToLineDist2DwithFlag(A->x[j],A->y[j],lx1,ly1,lx2,ly2,&tempT);
               if(D < Dmin)
                  Dmin = D;
      
               if((lmanswer < 0) || (D < lmanswer))
                  {
                  lmanswer = Dmin;
                  iindex = i;
                  jindex = j;
                  }
               }
            i = GetNextArealIndex(A, LastI, 1, &LastEdge1, ci1, &UsedTree);
            LastI = i;
            }

         if((answer < 0) || (lmanswer < answer))
            {
            answer = lmanswer;
            *Aindex1 = jindex;
            *Aindex2 = iindex;
            }
         } /** end for py **/
      } /** end for px **/

   return(answer);
}
                                                                                                                                                            


double SegmentToSmallArealDist2D(double lx1, double ly1, double lx2, double ly2,
                                 double minx,double miny,double maxx,double maxy,struct RawAreal *A, int *Aindex1, int *Aindex2)
{
int i, j;
double answer;
double D, Dmin, tempT;
double minAx, maxAx, minAy, maxAy;

   answer = -100.0;
   for(i=0; i<A->numverts; i++)
      {
      j = (i + 1) % A->numverts;

      if(A->x[i] > A->x[j])
         {
         maxAx = A->x[i];
         minAx = A->x[j];
         }
      else
         {
         maxAx = A->x[j];
         minAx = A->x[i];
         }
      if(A->y[i] > A->y[j])
         {
         maxAy = A->y[i];
         minAy = A->y[j];
         }
      else
         {
         maxAy = A->y[j];
         minAy = A->y[i];
         }

      if((minAx < maxx) && (maxAx > minx) && (minAy < maxy) && (maxAy > miny))
         {
         Dmin = PointToLineDist2DwithFlag(lx1,ly1 ,A->x[i],A->y[i],A->x[j],A->y[j],&tempT);
         D = PointToLineDist2DwithFlag(lx2,ly2 ,A->x[i],A->y[i],A->x[j],A->y[j],&tempT);
         if(D < Dmin)
            Dmin = D;
         D = PointToLineDist2DwithFlag(A->x[i],A->y[i],lx1,ly1,lx2,ly2,&tempT);
         if(D < Dmin)
            Dmin = D;
         D = PointToLineDist2DwithFlag(A->x[j],A->y[j],lx1,ly1,lx2,ly2,&tempT);
         if(D < Dmin)
            Dmin = D;

         if((answer < 0) || (Dmin < answer))
            { 
            answer = Dmin;
            *Aindex1 = i;
            *Aindex2 = j;
            }
         }
      }

   return(answer);
}


double PickMinNonZeroValue(double d1, double d2, double d3)
{
double answer;

   if((d1 == 0) && (d2 == 0) && (d3 == 0))
      answer = 0;
   else if(d1 == 0)
      {
      if(d2 == 0)
         answer = d3;
      else if(d3 == 0)
         answer = d2;
      else if(d2 < d3)
         answer = d2;
      else
         answer = d3;
      }
   else if(d2 == 0)
      {
      if(d3 == 0)
         answer = d1;
      else if(d1 < d3)
         answer = d1;
      else
         answer = d3;
      }
   else if(d3 == 0)
      {
      if(d1 < d2)
         answer = d1;
      else
         answer = d2;
      }
   else /*** all 3 are non-zero ***/
      {
      if((d1 < d2) && (d1 < d3))
         answer = d1;
      else if((d2 < d1) && (d2 < d3))
         answer = d2;
      else
         answer = d3;
      }

   return(answer);
}
                                                                                                                                                 


double AvgSegmentToLargeArealDist2D(double lx1, double ly1, double lx2, double ly2,
                                 double minx,double miny,double maxx,double maxy,struct RawAreal *A, int *Aindex1, int *Aindex2)
{
int ci1, ci2, cindex;
int MYI,MoreToDo;
int LastI, i, j, UsedTree, iindex, jindex;
struct RB_Edgelist * LastEdge1;
double px, py;
double answer, lmanswer;
double D1, D2, D3, D4, Dmin,Dmin2, tempT;
double minAx, maxAx, minAy, maxAy;

   answer = -100.0;
   MYI = MaxYindex + 1;
   iindex = jindex = -110;

   MoreToDo = 1;
   px = lx1;
   while(MoreToDo > 0)
      {
      ci1 = (int) (px / RegionSize);
      py = ly1;
      while(MoreToDo > 0)
         {
         lmanswer = -100.0;
         ci2 = (int) (py / RegionSize);

         cindex = (ci1 * MYI) + ci2;

         LastEdge1 = NULL;
         LastI = -1;

         i = GetNextArealIndex(A, LastI, 1, &LastEdge1, cindex, &UsedTree);
         LastI = i;

         while(i >= 0)
            {
            j = (i + 1) % A->numverts;

            if(A->x[i] > A->x[j])
               {
               maxAx = A->x[i];
               minAx = A->x[j];
               }
            else
               {
               maxAx = A->x[j];
               minAx = A->x[i];
               }
            if(A->y[i] > A->y[j])
               {
               maxAy = A->y[i];
               minAy = A->y[j];
               }
            else
               {
               maxAy = A->y[j];
               minAy = A->y[i];
               }

            if((minAx < maxx) && (maxAx > minx) && (minAy < maxy) && (maxAy > miny))
               {
               D1 = PointToLineDist2DwithFlag(lx1,ly1 ,A->x[i],A->y[i],A->x[j],A->y[j],&tempT);
               D2 = PointToLineDist2DwithFlag(lx2,ly2 ,A->x[i],A->y[i],A->x[j],A->y[j],&tempT);
               D3 = PointToLineDist2DwithFlag(A->x[i],A->y[i],lx1,ly1,lx2,ly2,&tempT);
               D4 = PointToLineDist2DwithFlag(A->x[j],A->y[j],lx1,ly1,lx2,ly2,&tempT);

               if((D1 <= D2) && (D1 <= D3) && (D1 <= D4))
                  {
                  Dmin = D1;
                  Dmin2 = PickMinNonZeroValue(D2, D3, D4);
                  }
               else if((D2 <= D1) && (D2 <= D3) && (D2 <= D4))
                  {
                  Dmin = D2;
                  Dmin2 = PickMinNonZeroValue(D1, D3, D4);
                  }
               else if((D3 <= D1) && (D3 <= D2) && (D3 <= D4))
                  {
                  Dmin = D3;
                  Dmin2 = PickMinNonZeroValue(D1, D2, D4);
                  }
               else
                  {
                  Dmin = D4;
                  Dmin2 = PickMinNonZeroValue(D1, D2, D3);
                  }

               Dmin = (Dmin + Dmin2) / 2.0;
 
               if((lmanswer < 0) || (Dmin < lmanswer))
                  {
                  lmanswer = Dmin;
                  iindex = i;
                  jindex = j;
                  }
               }
            i = GetNextArealIndex(A, LastI, 1, &LastEdge1, ci1, &UsedTree);
            LastI = i;
            }

         if((answer < 0) || (lmanswer < answer))
            {
            answer = lmanswer;
            *Aindex1 = jindex;
            *Aindex2 = iindex;
            }
         if(ly2 > ly1)
            {
            py += RegionSize;
            if(py > ly2)
               MoreToDo = 0;
            }
         else if(ly2 < ly1)
            {
            py -= RegionSize;
            if(py < ly2)
               MoreToDo = 0;
            }
         else
            MoreToDo = 0;
         } /** end for py **/
      MoreToDo = 1;
      if(lx2 > lx1)
         {
         px += RegionSize;
         if(px > lx2)
            MoreToDo = 0;
         }
      else if(lx2 < lx1)
         {
         px -= RegionSize;
         if(px < lx2)
            MoreToDo = 0;
         }
      else
         MoreToDo = 0;
      } /** end for px **/

   return(answer);
}



double AvgSegmentToSmallArealDist2D(double lx1, double ly1, double lx2, double ly2,
                                 double minx,double miny,double maxx,double maxy,struct RawAreal *A, int *Aindex1, int *Aindex2)
{
int i, j;
double answer;
double D1, D2, D3, D4, Dmin, Dmin2, tempT;
double minAx, maxAx, minAy, maxAy;
double doffset;

   answer = -100.0;
   for(i=0; i<A->numverts; i++)
      {
      j = (i + 1) % A->numverts;

      if(A->x[i] > A->x[j])
         {
         maxAx = A->x[i];
         minAx = A->x[j];
         }
      else
         {
         maxAx = A->x[j];
         minAx = A->x[i];
         }
      if(A->y[i] > A->y[j])
         {
         maxAy = A->y[i];
         minAy = A->y[j];
         }
      else
         {
         maxAy = A->y[j];
         minAy = A->y[i];
         }

      if((minAx < maxx) && (maxAx > minx) && (minAy < maxy) && (maxAy > miny))
         {
         D1 = PointToLineDist2DwithFlag(lx1,ly1 ,A->x[i],A->y[i],A->x[j],A->y[j],&tempT);
         D2 = PointToLineDist2DwithFlag(lx2,ly2 ,A->x[i],A->y[i],A->x[j],A->y[j],&tempT);
         D3 = PointToLineDist2DwithFlag(A->x[i],A->y[i],lx1,ly1,lx2,ly2,&tempT);
         D4 = PointToLineDist2DwithFlag(A->x[j],A->y[j],lx1,ly1,lx2,ly2,&tempT);

         if((D1 <= D2) && (D1 <= D3) && (D1 <= D4))
            {
            Dmin = D1;
            Dmin2 = PickMinNonZeroValue(D2, D3, D4);
            }
         else if((D2 <= D1) && (D2 <= D3) && (D2 <= D4))
            {
            Dmin = D2;
            Dmin2 = PickMinNonZeroValue(D1, D3, D4);
            }
         else if((D3 <= D1) && (D3 <= D2) && (D3 <= D4))
            {
            Dmin = D3;
            Dmin2 = PickMinNonZeroValue(D1, D2, D4);
            }
         else
            {
            Dmin = D4;
            Dmin2 = PickMinNonZeroValue(D1, D2, D3);
            }

         Dmin = (Dmin + Dmin2) / 2.0;

         if((answer < 0) || (Dmin < answer))
            { 
            answer = Dmin;
            *Aindex1 = i;
            *Aindex2 = j;
            doffset = (D1 + D2 + D3 + D4) / 4.0;
            }
         else if(answer == Dmin)
            {
            D1 = (D1 + D2 + D3 + D4) / 4.0;
            if(D1 < doffset)
               {
               doffset = D1;
               answer = Dmin;
               *Aindex1 = i;
               *Aindex2 = j;
               }
            }
         }
      }

   return(answer);
}





double AvgSegmentToLineDist2D(double tgtslope, double lx1, double ly1, double lx2, double ly2,
                                 double minx,double miny,double maxx,double maxy,struct RawLinear *L, int *Lindex1, int *Lindex2)
{
int i, j;
double answer;
double D1, D2, D3, D4, Dmin, Dmin2, tempT;
double minLx, maxLx, minLy, maxLy;
double doffset, segmentslope, slopemin, slopemax;

   answer = -100.0;
   slopemin = tgtslope * 0.75;
   slopemax = tgtslope * 1.25;

   for(i=1; i<L->numnodes; i++)
      {
      j = i - 1;

      if(L->x[i] > L->x[j])
         {
         maxLx = L->x[i];
         minLx = L->x[j];
         if(L->y[i] != L->y[j])
            segmentslope = (maxLx - minLx) / (L->y[i] - L->y[j]);
         else
            segmentslope = (maxLx - minLx) / 0.00001;
         }
      else
         {
         maxLx = L->x[j];
         minLx = L->x[i];
         if(L->y[i] != L->y[j])
            segmentslope = (maxLx - minLx) / (L->y[j] - L->y[i]); 
         else
            segmentslope = (maxLx - minLx) / 0.00001;
         }
      if(L->y[i] > L->y[j])
         {
         maxLy = L->y[i];
         minLy = L->y[j];
         }
      else
         {
         maxLy = L->y[j];
         minLy = L->y[i];
         }

      if((segmentslope > slopemin) && (segmentslope < slopemax) &&
                (minLx < maxx) && (maxLx > minx) && (minLy < maxy) && (maxLy > miny))
         {
         D1 = PointToLineDist2DwithFlag(lx1,ly1 ,L->x[i],L->y[i],L->x[j],L->y[j],&tempT);
         D2 = PointToLineDist2DwithFlag(lx2,ly2 ,L->x[i],L->y[i],L->x[j],L->y[j],&tempT);
         D3 = PointToLineDist2DwithFlag(L->x[i],L->y[i],lx1,ly1,lx2,ly2,&tempT);
         D4 = PointToLineDist2DwithFlag(L->x[j],L->y[j],lx1,ly1,lx2,ly2,&tempT);

         if((D1 > 0) && (D2 > 0) && (D3 > 0) && (D4 > 0))
            {
            if((D1 <= D2) && (D1 <= D3) && (D1 <= D4))
               {
               Dmin = D1;
               Dmin2 = PickMinNonZeroValue(D2, D3, D4);
               }
            else if((D2 <= D1) && (D2 <= D3) && (D2 <= D4))
               {
               Dmin = D2;
               Dmin2 = PickMinNonZeroValue(D1, D3, D4);
               }
            else if((D3 <= D1) && (D3 <= D2) && (D3 <= D4))
               {
               Dmin = D3;
               Dmin2 = PickMinNonZeroValue(D1, D2, D4);
               }
            else
               {
               Dmin = D4;
               Dmin2 = PickMinNonZeroValue(D1, D2, D3);
               }
   
            Dmin = (Dmin + Dmin2) / 2.0;
   
            if((answer < 0) || (Dmin < answer))
               {
               answer = Dmin;
               *Lindex1 = i;
               *Lindex2 = j;
               doffset = (D1 + D2 + D3 + D4) / 4.0;
               }
            else if(answer == Dmin)
               {
               D1 = (D1 + D2 + D3 + D4) / 4.0;
               if(D1 < doffset)
                  {
                  doffset = D1;
                  answer = Dmin;
                  *Lindex1 = i;
                  *Lindex2 = j;
                  }
               }
            }
         }
      }

   return(answer);
}





double PointToLargeArealDist2D(double px,double py,struct RawAreal *A, int *index, double *T)
{
int ci1, ci2, cindex;
int MYI;
int LastI, i, j, UsedTree;
struct RB_Edgelist * LastEdge1;
double answer;
double D, tempT;

   answer = -100.0; 
   MYI = MaxYindex + 1;

   ci1 = (int) (px / RegionSize);
   ci2 = (int) (py / RegionSize);

   cindex = (ci1 * MYI) + ci2;

   LastEdge1 = NULL;
   LastI = -1;

   i = GetNextArealIndex(A, LastI, 1, &LastEdge1, cindex, &UsedTree);
   LastI = i;

   while(i >= 0)
      {
      if(answer < 0)
         {
         j = (i + A->numverts - 1) % A->numverts;
         D = PointToLineDist2DwithFlag(px,py,A->x[i],A->y[i],A->x[j],A->y[j],&tempT);
         answer = D;
         *T = tempT;
         if(i == 0)
            {
            if(tempT < 0)
               *index = i;
            else
               *index = j;
            }
         else
            {
            if(tempT < 0)
               *index = j;
            else 
               *index = i;
            }
         }

      j = (i + 1) % A->numverts;

      D = PointToLineDist2DwithFlag(px,py,A->x[i],A->y[i],A->x[j],A->y[j],&tempT);
      if((answer < 0) || (D < answer))
         {
         answer = D;
         *T = tempT;
         if(tempT < 0)
            *index = i;
         else 
            *index = j;
         }
      i = GetNextArealIndex(A, LastI, 1, &LastEdge1, ci1, &UsedTree);
      LastI = i;
      }

   return(answer);
}


double PointToSmallArealDist2D(double px,double py,struct RawAreal *A, int *index, double *T)
{
int i,j;
double answer;
double D, tempT;

   answer = -100.0;

   for(i=0; i<A->numverts; i++)
      {
      if(i == 0)
         j = A->numverts - 1;
      else
         j = i - 1;

      D = PointToLineDist2DwithFlag(px,py,A->x[i],A->y[i],A->x[j],A->y[j],&tempT);
      if((answer < 0) || (D < answer))
         {
         answer = D;
         *T = tempT;
         if(tempT > 1.5)
            *index = j;
         else
            *index = i;
         }

      }

   return(answer);
}





int PointOnLineSegment(double px,double py,double x1,double y1,double x2,double y2, double slack)
{
double minx, maxx, miny, maxy;
double temp;
int answer;


   answer = 0;

   if((px == x1) && (py == y1))
      {
      answer = 2;
      }
   else if((px == x2) && (py == y2))
      {
      answer = 3;
      }
   else
      {
      if(x1 < x2)
         {
         minx = x1 - slack;
         maxx = x2 + slack;
         }
      else
         {
         minx = x2 - slack;
         maxx = x1 + slack;
         }
      if(y1 < y2)
         {
         miny = y1 - slack;
         maxy = y2 + slack;
         }
      else
         {
         miny = y2 - slack;
         maxy = y1 + slack;
         }

      if((minx <= px) && (px <= maxx) && (miny <= py) && (py <= maxy))
         {
         temp = PointToLineDist2D(px,py,x1,y1,x2,y2);
         if((temp < slack) || (temp == 0.0))
            {
            answer = 1;
            } 
         }
      }
   return(answer);
}




int LineSegmentsConnect(double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4, double Slack)
{                             
int answer = 0;               
double d;                        
                                 
   d = Distance(x1,y1,x3,y3);    
   if(d <= Slack)             
      answer = 1;                
   else                          
      {                          
      d = Distance(x1,y1,x4,y4);    
      if(d <= Slack)                
         answer = 1;                   
      else                                
         {
         d = Distance(x2,y2,x3,y3);
         if(d <= Slack)
            answer = 1;             
         else                       
            {                    
            d = Distance(x2,y2,x4,y4);
            if(d < Slack)           
               answer = 1;          
            }                       
         }                       
      }                            
   return(answer);               
}                             


int CheapLineSegmentsConnect(double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4, double Sl)
{
int answer = 0;
double d,Slack;

   Slack = Sl * Sl;
   d = SquaredDistance_GAITcoords(x1,y1,x3,y3);
   if(d <= Slack)
      answer = 1;
   else
      {
      d = SquaredDistance_GAITcoords(x1,y1,x4,y4);
      if(d <= Slack)
         answer = 1;
      else
         {
         d = SquaredDistance_GAITcoords(x2,y2,x3,y3);
         if(d <= Slack)
            answer = 1;
         else
            {
            d = SquaredDistance_GAITcoords(x2,y2,x4,y4);
            if(d < Slack)
               answer = 1;
            }
         }
      }
   return(answer);
}




double SolveForY(int x,double A,double B,double C)
{
double y;
  if(B == 0)
     return((double) x);
  y = ((A*x) + C) / B;
  y = -1.0 * y;
  return(y);
}






int MergeSeg_LineSegmentsOverlap(double xl,double yl,double xk,double yk, /***double Alk, double Blk, double Clk, ****/
                        double xm,double ym,double xn,double yn,double x1min, double x1max, double y1min, double y1max,
                        double * xi1,double * yi1,double * xi2,double * yi2, double tolerance)
{
double /**SolveY,**/ Tk, Tl, Tm, Tn;
double Dk, Dl, Dm, Dn, Dt1;
double midx, midy, tx, ty, Det;
double /**A, B, C,**/ An, Bn, Cn, Alk, Blk, Clk, Amn, Bmn, Cmn;
double x2min,x2max,y2min,y2max;
int pass1, pass2, pass3, pass4;
int answer = 0;


   if(xm < xn)
      {
      x2min = xm;
      x2max = xn;
      }
   else
      {
      x2min = xn;
      x2max = xm;
      }
   if(ym < yn)
      {
      y2min = ym;
      y2max = yn;
      }
   else
      {
      y2min = yn;
      y2max = ym;
      }

   x1min -= tolerance;
   x1max += tolerance;
   y1min -= tolerance;
   y1max += tolerance;


   if((x2min > x1max) || (x2max < x1min) || (y2min > y1max) || (y2max < y1min))
      return(0);


   if((xl == xm) && (yl == ym))
      {
      if((xk == xn) && (yk == yn))
         {
         answer = 1;
         *xi1 = xl; *yi1 = yl;
         *xi2 = xk; *yi2 = yk;
         return(answer);
         }
      else
         {
         Dk = PointToLineDistWithFlag(xk,yk,1.0,xm,ym,1.0,xn,yn,1.0, &Tk);
         if((Dk < tolerance) && (Tk >0) && (Tk < 1))
            {
            answer = 1;
            *xi1 = xl; *yi1 = yl;
            *xi2 = xk; *yi2 = yk;
            return(answer);
            }
         Dn = PointToLineDistWithFlag(xn,yn,1.0,xk,yk,1.0,xl,yl,1.0, &Tn);
         if((Dn < tolerance) && (Tn >0) && (Tn < 1))
            {
            answer = 1;
            *xi1 = xl; *yi1 = yl;
            *xi2 = xn; *yi2 = yn;
            return(answer);
            }
         return(0);
         }
      }
   else if((xl == xn) && (yl == yn))
      {
      if((xk == xm) && (yk == ym))
         {
         answer = 1;
         *xi1 = xl; *yi1 = yl;
         *xi2 = xk; *yi2 = yk;
         return(answer);
         }
      else
         {
         Dk = PointToLineDistWithFlag(xk,yk,1.0,xm,ym,1.0,xn,yn,1.0, &Tk);
         if((Dk < tolerance) && (Tk >0) && (Tk < 1))
            {
            answer = 1;
            *xi1 = xl; *yi1 = yl;
            *xi2 = xk; *yi2 = yk;
            return(answer);
            }
         Dm = PointToLineDistWithFlag(xm,ym,1.0,xk,yk,1.0,xl,yl,1.0, &Tm);
         if((Dm < tolerance) && (Tm >0) && (Tm < 1))
            {
            answer = 1;
            *xi1 = xl; *yi1 = yl;
            *xi2 = xm; *yi2 = ym;
            return(answer);
            }
         return(0);
         }
      }
   else if((xk == xm) && (yk == ym))
      {
      if((xl == xn) && (yl == yn))
         {
         answer = 1;
         *xi1 = xk; *yi1 = yk;
         *xi2 = xl; *yi2 = yl;
         return(answer);
         }
      else
         {
         Dl = PointToLineDistWithFlag(xl,yl,1.0,xm,ym,1.0,xn,yn,1.0, &Tl);
         if((Dl < tolerance) && (Tl >0) && (Tl < 1))
            {
            answer = 1;
            *xi1 = xk; *yi1 = yk;
            *xi2 = xl; *yi2 = yl;
            return(answer);
            }
         Dn = PointToLineDistWithFlag(xn,yn,1.0,xl,yl,1.0,xk,yk,1.0, &Tn);
         if((Dn < tolerance) && (Tn >0) && (Tn < 1))
            {
            answer = 1;
            *xi1 = xk; *yi1 = yk;
            *xi2 = xn; *yi2 = yn;
            return(answer);
            }
         return(0);
         }
      }
   else if((xk == xn) && (yk == yn))
      {
      if((xl == xm) && (yl == ym))
         {
         answer = 1;
         *xi1 = xk; *yi1 = yk;
         *xi2 = xl; *yi2 = yl;
         return(answer);
         }
      else
         {
         Dl = PointToLineDistWithFlag(xl,yl,1.0,xn,yn,1.0,xm,ym,1.0, &Tl);
         if((Dl < tolerance) && (Tl >0) && (Tl < 1))
            {
            answer = 1;
            *xi1 = xk; *yi1 = yk;
            *xi2 = xl; *yi2 = yl;
            return(answer);
            }
         Dm = PointToLineDistWithFlag(xm,ym,1.0,xl,yl,1.0,xk,yk,1.0, &Tm);
         if((Dm < tolerance) && (Tm >0) && (Tm < 1))
            {
            answer = 1;
            *xi1 = xk; *yi1 = yk;
            *xi2 = xm; *yi2 = ym;
            return(answer);
            }
         return(0);
         }
      }

      pass1 = pass2 = pass3 = pass4 = 0;
if((NearlyEqual(xl,xn) > 0) && (NearlyEqual(yl,yn) > 0))
         {
         pass1 = 1;
         Dt1 = PointToLineDistWithFlag(xk,yk,1.0,xm,ym,1.0,xn,yn,1.0, &Tl);
         if(Dt1 > tolerance)
            {
            Dt1 = PointToLineDistWithFlag(xm,ym,1.0,xk,yk,1.0,xl,yl,1.0, &Tl);
            if(Dt1 > tolerance)
               return(0);
            }
         }
else if((NearlyEqual(xl,xm) > 0) && (NearlyEqual(yl,ym) > 0))
  {
  pass1 = 1;
  Dt1 = PointToLineDistWithFlag(xk,yk,1.0,xm,ym,1.0,xn,yn,1.0, &Tl);
  if(Dt1 > tolerance)
     {
     Dt1 = PointToLineDistWithFlag(xn,yn,1.0,xk,yk,1.0,xl,yl,1.0, &Tl);
     if(Dt1 > tolerance)
        return(0);
     }
  }
      else
         {
         Dl = PointToLineDistWithFlag(xl,yl,1.0,xm,ym,1.0,xn,yn,1.0, &Tl);
         if((Dl <= tolerance) && (Tl > 0) && (Tl < 1))
            pass1 = 1;
         }
if((NearlyEqual(xk,xn) > 0) && (NearlyEqual(yk,yn) > 0))
         {
         pass2 = 1;
         Dt1 = PointToLineDistWithFlag(xl,yl,1.0,xm,ym,1.0,xn,yn,1.0, &Tl);
         if(Dt1 > tolerance)
            {
            Dt1 = PointToLineDistWithFlag(xm,ym,1.0,xk,yk,1.0,xl,yl,1.0, &Tl);
            if(Dt1 > tolerance)
               return(0);
            }
         }
else if((NearlyEqual(xk,xm) > 0) && (NearlyEqual(yk,ym) > 0))
  {
  pass2 = 1;
  Dt1 = PointToLineDistWithFlag(xl,yl,1.0,xm,ym,1.0,xn,yn,1.0, &Tl);
  if(Dt1 > tolerance)
     {
     Dt1 = PointToLineDistWithFlag(xn,yn,1.0,xk,yk,1.0,xl,yl,1.0, &Tl);
     if(Dt1 > tolerance)
        return(0);
     }
  }
      else
         {
         Dk = PointToLineDistWithFlag(xk,yk,1.0,xm,ym,1.0,xn,yn,1.0, &Tk);
         if((Dk <= tolerance) && (Tk > 0) && (Tk < 1))
            pass2 = 1;
         }
    
      if((pass1 > 0) && (pass2 > 0))
         {
         *xi1 = xl; *yi1 = yl;
         *xi2 = xk; *yi2 = yk;
         answer = 1;
         }
      else
         {
if((NearlyEqual(xm,xk) > 0) && (NearlyEqual(ym,yk) > 0))
            pass3 = 1;
else if((NearlyEqual(xm,xl) > 0) && (NearlyEqual(ym,yl) > 0))
  pass3 = 1;
         else
            {
            Dm = PointToLineDistWithFlag(xm,ym,1.0,xl,yl,1.0,xk,yk,1.0, &Tm);
            if((Dm <= tolerance) && (Tm > 0) && (Tm < 1))
               pass3 = 1;
            }
         if(pass3 > 0)
            {
            *xi1 = xm;
            *yi1 = ym;
            if(pass1 > 0)
               {
               *xi2 = xl;
               *yi2 = yl;
               answer = 1;
               }
            if(pass2 > 0)
               {
               *xi2 = xk;
               *yi2 = yk;
               answer = 1;
               }
            else
               {
if((NearlyEqual(xn,xl) > 0) && (NearlyEqual(yn,yl) > 0))
                  pass4 = 1;
else if((NearlyEqual(xn,xk) > 0) && (NearlyEqual(yn,yk) > 0))
  pass4 = 1;
               else
                  {
                  Dn = PointToLineDistWithFlag(xn,yn,1.0,xl,yl,1.0,xk,yk,1.0, &Tn);
                  if((Dn <= tolerance) && (Tn > 0) && (Tn < 1))
                     pass4 = 1;
                  }
               if(pass4 > 0)
                  {
                  *xi2 = xn;
                  *yi2 = yn;
                  answer = 1;
                  }
               }
            }
         else if((pass1 > 0) || (pass2 > 0))
            {
if((NearlyEqual(xn,xl) > 0) && (NearlyEqual(yn,yl) > 0))
               pass4 = 1;
else if((NearlyEqual(xn,xk) > 0) && (NearlyEqual(yn,yk) > 0))
  pass4 = 1;
            else
               {
               Dn = PointToLineDistWithFlag(xn,yn,1.0,xl,yl,1.0,xk,yk,1.0, &Tn);
               if((Dn <= tolerance) && (Tn > 0) && (Tn < 1))
                  pass4 = 1;
               }
            if(pass4 > 0)
               {
               *xi1 = xn;
               *yi1 = yn;
               if(pass1 > 0)
                  {
                  *xi2 = xl;
                  *yi2 = yl;
                  answer = 1;
                  }
               else if(pass2 > 0)
                  {
                  *xi2 = xk;
                  *yi2 = yk;
                  answer = 1;
                  }
               }
            }
         }
   if(answer > 0)
      {
      Dn = AngleBetweenLineSegments(xl,yl,xk,yk,xm,ym,xn,yn);
      if((Dn > -0.985) && (Dn < 0.985))  /**** about 10 degrees ***/
         return(0);
      else
         {
         if(*xi1 == *xi2)
            midx = *xi1;
         else
            midx = *xi1 + ((*xi2 - *xi1) / 2.0);
         if(*yi1 == *yi2)
            midy = *yi1;
         else
            midy = *yi1 + ((*yi2 - *yi1) / 2.0);
         LineEquation(xm,ym,xn,yn,&Amn,&Bmn,&Cmn);
         LineEquation(xl,yl,xk,yk,&Alk,&Blk,&Clk); 
         An = Bmn;
         Bn = 0 - Amn;
         Cn = (Amn * midy) - (Bmn * midx);
         Det = (Alk * Bn) - (An * Blk);
         if(Det == 0)
            return(0);
         Det = 1.0 / Det;
         if(xl == xk)
            tx = xl;
         else
            tx = ((Blk * Cn) - (Bn * Clk)) * Det;
         if((tx < x1min) || (tx > x1max))
            return(0);
         else
            {
            if(yl == yk)
               ty = yl;
            else
               ty = ((An * Clk) - (Alk * Cn)) * Det;
            if((ty < y1min) || (ty > y1max))
               return(0);
            else
               {
               An = Blk;
               Bn = 0 - Alk;
               Cn = (Alk * midy) - (Blk * midx);
               Det = (Amn * Bn) - (An * Bmn);
               if(Det == 0)
                  return(0);
               Det = 1.0 / Det;
               if(xm == xn)
                  tx = xm;
               else
                  tx = ((Bmn * Cn) - (Bn * Cmn)) * Det;
               if((tx < x2min) || (tx > x2max))
                  return(0);
               else
                  {
                  if(ym == yn)
                     return(answer);  /**ty = ym; ***/
                  else
                     ty = ((An * Cmn) - (Amn * Cn)) * Det;
                  if((ty < y2min) || (ty > y2max))
                     return(0);
                  }
               }
            }
         }
      }
   return(answer);
}








int LineSegmentsOverlap(double xl,double yl,double xk,double yk,double xm,double ym,double xn,double yn,
                        double * xi1,double * yi1,double * xi2,double * yi2, double tolerance)
{
/**double xlk,ylk,xnm,ynm,det; **/
double x1min,x1max,y1min,y1max,x2min,x2max,y2min,y2max;
int answer = 0;


   if((xl == xm) && (yl == ym) & (xk == xn) && (yk == yn))
      {
      answer = 1;
      *xi1 = xl; *yi1 = yl;
      *xi2 = xk; *yi2 = yk;
      return(answer);
      }
   else if((xl == xn) && (yl == yn) & (xk == xm) && (yk == ym))
      {
      answer = 1;
      *xi1 = xl; *yi1 = yl;
      *xi2 = xk; *yi2 = yk;
      return(answer);
      }
   if(xl < xk)
      {
      x1min = xl;
      x1max = xk;
      }
   else
      {
      x1min = xk;
      x1max = xl;
      }
   if(yl < yk)
      {
      y1min = yl;
      y1max = yk;
      }
   else
      {
      y1min = yk;
      y1max = yl;
      }
   if(xm < xn)
      {
      x2min = xm;
      x2max = xn;
      }
   else
      {
      x2min = xn;
      x2max = xm;
      }
   if(ym < yn)
      {
      y2min = ym;
      y2max = yn;
      }
   else
      {
      y2min = yn;
      y2max = ym;
      }

   x1min -= tolerance;
   x1max += tolerance;
   y1min -= tolerance;
   y1max += tolerance;


   if((x2min < x1max) && (x2max > x1min) && (y2min < y1max) && (y2max > y1min))
      {
      if(PointOnLineSegment(xl,yl,xm,ym,xn,yn,tolerance))
         {
         *xi1 = xl;
         *yi1 = yl;
if(((NearlyEqual(xk,xl) == 0) || (NearlyEqual(yk,yl) == 0)) && (PointOnLineSegment(xk,yk,xm,ym,xn,yn,tolerance)))
            {
            *xi2 = xk;
            *yi2 = yk;
            answer = 1;
            }
else if(((NearlyEqual(xm,xl) == 0) || (NearlyEqual(ym,yl) == 0)) && (PointOnLineSegment(xm,ym,xl,yl,xk,yk,tolerance)))
            {
            *xi2 = xm;
            *yi2 = ym;
            answer = 1;
            }
else if(((NearlyEqual(xn,xl) == 0) || (NearlyEqual(yn,yl) == 0)) && (PointOnLineSegment(xn,yn,xl,yl,xk,yk,tolerance)))
            {
            *xi2 = xn;
            *yi2 = yn;
            answer = 1;
            }
         }
      else if(PointOnLineSegment(xk,yk,xm,ym,xn,yn,tolerance))
         {
         *xi1 = xk;
         *yi1 = yk;
if(((NearlyEqual(xm,xk) == 0) || (NearlyEqual(ym,yk) == 0)) && (PointOnLineSegment(xm,ym,xl,yl,xk,yk,tolerance)))
            {
            *xi2 = xm;
            *yi2 = ym;
            answer = 1;
            }
else if(((NearlyEqual(xn,xk) == 0) || (NearlyEqual(yn,yk) == 0)) && (PointOnLineSegment(xn,yn,xl,yl,xk,yk,tolerance)))
            {
            *xi2 = xn;
            *yi2 = yn;
            answer = 1;
            }
         }
      else if(PointOnLineSegment(xn,yn,xl,yl,xk,yk,tolerance))
         {
         *xi1 = xn;
         *yi1 = yn;
if(((NearlyEqual(xn,xm) == 0) || (NearlyEqual(yn,ym) == 0)) && (PointOnLineSegment(xm,ym,xl,yl,xk,yk,tolerance)))
            {
            *xi2 = xm;
            *yi2 = ym;
            answer = 1;
            }
         }
      }
   return(answer);
}




int SegmentsOffsetOverlap(double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4)
{
int answer = 0;

   if(x1 < x2)
      {
      if((x3 < x4) && (x3 < x2) && (x4 > x1)) /*** x coordinates overlap ***/
         answer = 1;
      else if((x4 < x2) && (x3 > x1))
         answer = 1;
      }
   else
      {
      if((x3 < x4) && (x3 < x1) && (x4 > x2)) /*** x coordinates overlap ***/
         answer = 1;
      else if((x4 < x1) && (x3 > x2))
         answer = 1;
      }
   if(answer == 1) /*** see if the y coordinates overlap ***/
      {
      answer = 0;
      if(y1 < y2)
         {
         if((y3 < y4) && (y3 < y2) && (y4 > y1)) /*** y coordinates overlap ***/
            answer = 1;
         else if((y4 < y2) && (y3 > y1))
            answer = 1;
         }
      else
         {
         if((y3 < y4) && (y3 < y1) && (y4 > y2)) /*** y coordinates overlap ***/
            answer = 1;
         else if((y4 < y1) && (y3 > y2))
            answer = 1;
         }
      }
   return(answer);
}


int LineSegmentsIntersect(double xl,double yl,double xk,double yk,double xm,double ym,double xn,double yn,double * xi,double * yi)
{
double xlk,ylk,xnm,ynm,xmk,ymk,s,t,det;

   if((xl == xm) && (yl == ym))
      {
      *xi = xm;
      *yi = ym;
      return(1);
      }

   if((xk == xm) && (yk == ym))
      {
      *xi = xm;
      *yi = ym;
      return(1);
      }

   if((xl == xn) && (yl == yn))
      {
      *xi = xn;
      *yi = yn;
      return(1);
      }

   if((xk == xn) && (yk == yn))
      {
      *xi = xn;
      *yi = yn;
      return(1);
      }
   xlk = xl - xk;
   ylk = yl - yk;
   xnm = xn - xm;
   ynm = yn - ym;
   xmk = xm - xk;
   ymk = ym - yk;

   det = (xnm * ylk) - (ynm * xlk);
   if((-0.00001 < det) && (det < 0.00001))  /** parallel lines **/
      {
      return(0);
      }
   det = 1.0 / det;
   s = ((xnm * ymk) - (ynm * xmk)) * det;
   if((s < 0.0) || (s > 1.0))
      {
      return(0);
      }
   t = (xlk * ymk - ylk * xmk) * det;
   if((t < 0.0) || (t > 1.0))
      {
      return(0);
      }
   else
      {
      *xi = xk + xlk * s;
      *yi = yk + ylk * s;
      return(1);
      }
}



double PointToFullLineDist2D(double px, double py, double lx1, double ly1, double lx2, double ly2)
{
double A, B, C;
double answer, temp, temp2;

   LineEquation(lx1,ly1,lx2,ly2, &A, &B, &C);
   temp = A * px;
   temp += B * py;
   temp += C;
   if(temp < 0)
      temp = 0 - temp;

   temp2 = sqrt((A * A) + (B * B));

   answer = temp / temp2;

   return(answer);
}



/** convert implicit Ax + By + C = 0 form to parametric form x = x0 +ft, y = y0 + gt ***/
void ImplicitLineToParametric(double A, double B, double C, double *X0, double *Y0, double *F, double *G)
{
double factor, root;

   root = 1.0 / (A * A + B * B);
   factor = -C * root;
   *X0 = A * factor;
   *Y0 = B * factor;
   root = sqrt(root);
   *F = B * root;
   *G = -A * root;
}


int LineCircleIntersection(double XJ,double YJ,double RJ,double X0,double Y0,double F,double G,
          double  *X1,double *Y1,double *X2,double *Y2)
{
int answer;
double FSQ, GSQ;
double FGSQ, FYGX;
double XJ0, YJ0, FXGY, ROOT, T, FGINV, T1, T2;


   FSQ = F * F;
   GSQ = G * G;
   FGSQ = FSQ + GSQ;
   if(FGSQ < 0.0001) /** bad line coefficients ***/
      answer = 0;
   else
      {
      XJ0 = XJ - X0;
      YJ0 = YJ - Y0;
      FYGX = (F * YJ0) - (G * XJ0);
      ROOT = (RJ * RJ * FGSQ) - (FYGX * FYGX);
      if(ROOT < 0)
         answer = 0; /** no intersection **/
      else
         {
         FXGY = (F * XJ0) + (G * YJ0);
         if(ROOT < 0.0001)   /*** line is tangent ***/
            {
            answer = 1;
            T = FXGY / FGSQ;
            *X1 = *X2 = X0 + (F * T);
            *Y1 = *Y2 = Y0 + (G * T);
            }
         else  /** two intersections ***/
            {
            answer = 2;
            ROOT = sqrt(ROOT);
            FGINV = 1.0 / FGSQ;
            T1 = (FXGY - ROOT) * FGINV;
            T2 = (FXGY + ROOT) * FGINV;
            *X1 = X0 + (F * T1);
            *Y1 = Y0 + (G * T1);
            *X2 = X0 + (F * T2);
            *Y2 = Y0 + (G * T2);
            }
         }
      }
   return(answer);
}






int InfiniteLinesIntersect(double x1,double y1,double x2,double y2,double x3,double y3,double x4,double y4,double * Xi,double * Yi)
{
double A1,B1,C1,A2,B2,C2;
double Det;


   LineEquation(x1,y1,x2,y2,&A1,&B1,&C1);
   LineEquation(x3,y3,x4,y4,&A2,&B2,&C2);
   Det = (A1 * B2) - (A2 * B1);
   if((Det > -0.0001) && (Det < 0.0001)) /* parallel lines **/
      return(0);
   else
      {
      *Xi = ((B1 * C2) - (B2 * C1)) / Det;
      *Yi = ((A2 * C1) - (A1 * C2)) / Det;
      }
   if((x3 > *Xi) || (x4 < *Xi))
      return(0);
   return(1);
}





double SolveForX(int y,double A,double B,double C)
{
double x;
   if(A == 0)
      return((double)y);
   x = ((B*y) + C) / A;
   x = -1.0 * x;
   return(x);
}



void SolveForZ(double A,double B,double C,double D,double x,double y,double *Z)
{
   *Z = ((-D)  - (A * x) - (B * y)) / (C);
}


void TwoDecimalSolveForZ(double A,double B,double C,double D,double x,double y,double *Z)
{
double Ztemp;
long int temp;
   Ztemp = ((-D)  - (A * x) - (B * y)) / (C);
   temp = (long int) (Ztemp * 100.0);
   *Z = ((double) temp) / 100.0;
}




int PlaneEquation(double *A,double *B,double *C,double *D,double *x,double *y,double *z,int numverts)
{
double *Nx, *Ny, *Nz;
int i, j, k, v, newV;
long int Zi;
double x10, y10, z10, x20, y20, z20;
double Tx[3], Ty[3], Tz[3];
double Z1, Z2;
int success = 1;

   if(numverts == 3)
      {
      x10 = x[1] - x[0];
      y10 = y[1] - y[0];
      z10 = z[1] - z[0];

      x20 = x[2] - x[0];
      y20 = y[2] - y[0];
      z20 = z[2] - z[0];

      *A = (y10 * z20) - (z10 * y20);
      *B = (z10 * x20) - (x10 * z20);
      *C = (x10 * y20) - (y10 * x20);

      *D = 0 - (*A * x[0]) - (*B * y[0]) - (*C * z[0]);
      }
   else
      {
      Nx = (double *) (malloc(SzD * numverts));
      Ny = (double *) (malloc(SzD * numverts));
      Nz = (double *) (malloc(SzD * numverts));
      if((Nx == NULL) || (Ny == NULL) || (Nz == NULL))
         {
         printf("PlaneEquation: out of allocation memory for poly with %d vertices\n",numverts);
         exit(-1);
         }
      v = numverts - 1;
      newV = 0;
      for(i=0; i<numverts; i++)
         {
         j = (i + 1) % numverts; /** j is index of vertex after vertex[i] **/
         k = (i + v) % numverts; /** k is index of vertex before vertex[i] **/
         Tx[0] = x[i]; Ty[0] = y[i]; Tz[0] = z[i];
         Tx[1] = x[k]; Ty[1] = y[k]; Tz[1] = z[k];
         Tx[2] = x[j]; Ty[2] = y[j]; Tz[2] = z[j];
         if(ThreePointsAreColinear(Tx,Ty,Tz) == 0) /** if not co-linear, keep the middle point at index i **/
            {
            Nx[newV] = x[i];
            Ny[newV] = y[i];
            Nz[newV] = z[i];
            ++newV;
            }
         }
      if(newV < 3)
         {
         *A = *B = *C = *D = 0.0;
         success = 2;
         }
      else
         {
         x10 = Nx[1] - Nx[0];
         y10 = Ny[1] - Ny[0];
         z10 = Nz[1] - Nz[0];

         x20 = Nx[2] - Nx[0];
         y20 = Ny[2] - Ny[0];
         z20 = Nz[2] - Nz[0];

         *A = (y10 * z20) - (z10 * y20);
         *B = (z10 * x20) - (x10 * z20);
         *C = (x10 * y20) - (y10 * x20);

         *D = 0 - (*A * Nx[0]) - (*B * Ny[0]) - (*C * Nz[0]);
         }
      if((newV > 3) && (*C != 0.0))
         {
         for(i=3; i<newV; i++)
            {
            TwoDecimalSolveForZ(*A,*B,*C,*D,Nx[i],Ny[i],&Z1);
            Zi = (long int) (Nz[i] * 100.0);
            Z2 = ((double) Zi) / 100.0;
            if(Z2 > Z1)
              Z2 = Z2 - Z1;
            else
              Z2 = Z1 - Z2;
            if(Z2 > 0.5)
               {
               success = 3;
               break;
               }
            }
         }
      free(Nx);
      free(Ny);
      free(Nz);
      }
   return(success);
}




int TwoLinesIntersect(struct RawLinear *l1, int l1index, struct RawLinear *l2)
{
int answer = 0;
int i,j;
int ii, jj;
int l1limit, l1start;
double xi, yi;
   l1start = 1; l1limit = l1->numnodes;

   ii = l1start - 1;
   for(i=l1start; i<l1limit; i++)
      {
      for(j=1; j<l2->numnodes; j++)
         {
         jj = j - 1;
         if(LineSegmentsIntersect(l1->x[ii],l1->y[ii],l1->x[i],l1->y[i],l2->x[jj],l2->y[jj],l2->x[j],l2->y[j], &xi, &yi) > 0)
            {
            answer = 1;
            break;
            }
         }
      if(answer > 0)
         break;
      ii = i;
      }
   return(answer);
}


int LimitedTwoLinesIntersect(struct RawLinear *l1, int l1index, struct RawLinear *l2)
{
int answer = 0;
int i,j;
int ii, jj;
int l1limit, l1start;
double xi, yi;

   if(l1index < 0) /*** then fully check both lines ***/
      {
      l1start = 1;
      l1limit = l1->numnodes;
      }
   else
      {
      if(l1index == 0) /** if send in start node, check first segment only **/
         {
         l1start = 1;
         l1limit = 2;
         }
      else if(l1index == (l1->numnodes -1) ) /**if send in end node, check last segment only **/
         {
         l1start = l1->numnodes - 1;
         l1limit = l1->numnodes;
         }
      else /** if send in interior node, check both segments connected to it ***/
         {
         l1start = l1index;
         l1limit = l1index + 2;
         }
      }

   ii = l1start - 1;
   for(i=l1start; i<l1limit; i++)
      {
      for(j=1; j<l2->numnodes; j++)
         {
         jj = j - 1;
         if(LineSegmentsIntersect(l1->x[ii],l1->y[ii],l1->x[i],l1->y[i],l2->x[jj],l2->y[jj],l2->x[j],l2->y[j], &xi, &yi) > 0)
            {
            answer = 1;
            break;
            }
         }
      if(answer > 0)
         break;
      ii = i;
      }
   return(answer);
}





void SetUpSunParameters(int AzimuthToSun, double SunElevationAngle, double *L1,
double *L2, double *L3)
{
double SunRadianAngle,SunTangent, d1, d2;
double Sazimuth, SunX, SunY;
double Cfactor;

   Cfactor = PI / 180.0;
   Sazimuth = AzimuthToSun % 90;
   Sazimuth = Sazimuth * Cfactor;
   d1 = 100000.0; /** (x,y) planar 'distance' to sun??? **/
   SunX = d1 * cos(Sazimuth);
   if(AzimuthToSun > 180)
      SunX = 0 - SunX;
   SunY = d1 * sin(Sazimuth);
   if((AzimuthToSun > 90) && (AzimuthToSun < 270))
      SunY = 0 - SunY;

   SunRadianAngle = SunElevationAngle * Cfactor;
   SunTangent = tan(SunRadianAngle);

   d2 = SunTangent * d1; /* z height at SunX,SunY, angle of SunElevationAngle */
   d1 = sqrt(SunX*SunX + SunY*SunY + d2*d2); /* "dist" to sun?? */
   *L1 = (double) SunX / d1;
/* below, left-hand coord system so 'fix' the y?? **/
   *L2 = (double) (0 - SunY) / d1;
   *L3 = d2 / d1;
 /* [L1 L2 L3] = normalized vector to the sun */
}


unsigned char AssignShadedColor(int fid, int crsindex, double *x, double *y, double *z, int numverts, double L1, double L2, double L3)
{
unsigned char color;
double a,b;
double A,B,C,D, length;
double TX[3], TY[3], TZ[3];
int i,j,k;
extern int LLFidTableCount;
extern unsigned char *FidMarkTable;

  if(fid>=0)
    {
      if(fid>=LLFidTableCount)
        {
          printf("error in ADC: passed fid %d but max is %d\n",fid,LLFidTableCount-1);
        }
      else if(FidMarkTable[fid]==1)
        {
          return HighLightColor;
        }
    }

   if(numverts < 3)
      color = 0;
   else if ( ((crsindex >= 0) && (crsindex < SACfull) && (CrsWlk[crsindex].toggle > 0)) //its on the marker list
	    )
      color = HighLightColor;
   else
      {
      i = 0;
      j = 1;
      k = 2;
      if(numverts > 3)
         {
         TX[0] = x[i]; TY[0] = y[i]; TZ[0] = z[i];
         while(k < numverts)
            {
            TX[1] = x[j]; TY[1] = y[j]; TZ[1] = z[j];
            TX[2] = x[k]; TY[2] = y[k]; TZ[2] = z[k];
            A = TriangleSurfaceArea(TX,TY,TZ);
            if(A > 0.00001)
               break;
            j = k;
            ++k;
            }
         if(k >= numverts)
            {
            --k;
            }

         if(ZoomVertExag > 1)
            {
            TZ[0] = TZ[0] * ZoomVertExag;
            TZ[1] = TZ[1] * ZoomVertExag;
            TZ[2] = TZ[2] * ZoomVertExag;
            }

         PlaneEquation(&A,&B,&C,&D,TX,TY,TZ,3);
         }
      else // numverts must == 3 
         {
         if(ZoomVertExag > 1)
            {
            z[0] = z[0] * ZoomVertExag;
            z[1] = z[1] * ZoomVertExag;
            z[2] = z[2] * ZoomVertExag;
            }

         PlaneEquation(&A,&B,&C,&D,x,y,z,3);
         }

      length = sqrt(A * A + B * B + C * C);

      A = A / length;
      B = B / length;
      C = C / length;
      a = A*L1 - B*L2 + C*L3;
      b = ShadedIp * ShadedKd * a * 63.0;
      if(b < 0) b = 0 - b;
      if(b > 63.0)
         {
         b = 63.0;
         }
      color = (unsigned char) b;
      color += 100;
if((color < 100) || (color > 163))
{
color = 101;
}
      }
   return(color);
}






double PolygonAngle(double A,double B,double C)
{
double t1, t2;
    if(C == 0)
       {
       t2 = HalfPI;
       }
    else if((A == 0) && (B == 0))
       t2 = 0;
    else
       {
       t1 = (A * A) + (B * B) + (C * C);
       t1 = sqrt(t1);
       if(C < 0) C = -C;
       t1 = C / t1;
       if(t1 >= 1.0)
          t2 = 0;
       else if(t1 <= 0.0)
          t2 = HalfPI;
       else
          t2 = acos(t1);
       }
    return(t2);
}



int StrictlyBetween(double x,double y,double x1,double y1,double x2,double y2)
{
int answer = 0;
   if((x1 <= x2) && (x1 < x) && (x < x2))
      answer = 1;
   else if((x2 <= x1) && (x2 < x) && (x < x1))
      answer = 1;
   else if((x1 == x2) && (x1 == x))
      answer = 1;
   if(answer == 1)
      {
      answer = 0;
      if((y1 <= y2) && (y1 < y) && (y < y2))
         answer = 1;
      else if((y2 <= y1) && (y2 < y) && (y < y1))
         answer = 1;
      else if((y2 == y1) && (y2 == y))
         answer = 1;
      }
   return(answer);
}



int Between(double x,double y,double x1,double y1,double x2,double y2)
{
int answer = 0;
   if((x1 <= x2) && (x1 <= x) && (x <= x2))
      answer = 1;
   else if((x2 <= x1) && (x2 <= x) && (x <= x1))
      answer = 1;
   if(answer == 1)
      {
      answer = 0;
      if((y1 <= y2) && (y1 <= y) && (y <= y2))
         answer = 1;
      else if((y2 <= y1) && (y2 <= y) && (y <= y1))
         answer = 1;
      }
   return(answer);
}






double InterpLinearElev(double X1,double Y1,double Z1,double X2,double Y2,double Z2,double x,double y)
{
double deltaZ, deltaX, deltaY;
double deltaT;
double answer;
int Z1bad, Z2bad;

   if(NGA_TYPE == 1)
      {
      Z1bad = IsSentinelZvalue(Z1,UseNUNANPO);
      Z2bad = IsSentinelZvalue(Z2,UseNUNANPO);
      if((Z1bad > 0) || (Z2bad > 0))
         {
         if((Z1bad > 0) && (Z2bad > 0))
            return(Z1);
         else if(Z1bad > 0)
            return(Z2);
         else if(Z2bad > 0)
            return(Z1);
         }
      }


   if(Z1 == Z2)
      answer = Z1;
   else
      {
      deltaZ = Z2 - Z1;
      deltaX = fabs(X2 - X1);
      deltaY = fabs(Y2 - Y1);
      if(deltaY > deltaX)
         {
         deltaY = Y2 - Y1;
         deltaT = y - Y1;
         answer = Z1 + (deltaZ / deltaY) * deltaT;
         }
      else
         {
         deltaX = X2 - X1;
         deltaT = x - X1;
         answer = Z1 + (deltaZ / deltaX) * deltaT;
         }
      }

   return(answer);
}



double FindXatYonSegment(double newy, double x1, double y1, double x2, double y2)
{
double tdiff, pdiff;
double answer;
   if(y1 < y2)
      {
      tdiff = y2 - y1;
      pdiff = newy - y1;
      answer = (x2 - x1) * pdiff;
      answer = answer / tdiff;
      answer = answer + x1;
      }
   else
      {
      tdiff = y1 - y2;
      pdiff = newy - y2;
      answer = (x1 - x2) * pdiff;
      answer = answer / tdiff;
      answer = answer + x2;
      }
   return(answer);
}





int ClipLineToRegion(double lx, double ly, double ux, double uy,
     double *x1, double *y1, double *z1, double *x2, double *y2, double *z2, unsigned char *cflag, double decimalplaces)
{
int answer = 0;
double ix[4], iy[4], iz[4];
int hit[4];
int i;

   if((*x1 == *x2) && (*y1 == *y2))
      {
      answer = 0;
      cflag = 0;
      }
   else if((*x1 == lx) && (*x2 < lx))
      {
      answer = 0;
      cflag = 0;
      }
   else if((*x2 == lx) && (*x1 < lx))
      {
      answer = 0;
      cflag = 0;
      }
   else if((*x1 == ux) && (*x2 > ux))
      {
      answer = 0;
      cflag = 0;
      }
   else if((*x2 == ux) && (*x1 > ux))
      {
      answer = 0;
      cflag = 0;
      }
   else if((*y1 == ly) && (*y2 < ly))
      {
      answer = 0;
      cflag = 0;
      }
   else if((*y2 == ly) && (*y1 < ly))
      {
      answer = 0;
      cflag = 0;
      }
   else if((*y1 == uy) && (*y2 > uy))
      {
      answer = 0;
      cflag = 0;
      }
   else if((*y2 == uy) && (*y1 > uy))
      {
      answer = 0;
      cflag = 0;
      }
   else if((*x1 >= lx) && (*x1 <= ux) && (*y1 >= ly) && (*y1 <= uy) &&
      (*x2 >= lx) && (*x2 <= ux) && (*y2 >= ly) && (*y2 <= uy))
      {
      answer = 1;
      *cflag = 0;
      }
   else
      {
      for(i=0; i<4; i++)
         hit[i] = 0;
      if(*x1 < *x2)
         {
         if((*y1 < ly) || (*y2 < ly))
            hit[0] = LineSegmentsIntersect(lx,ly,ux,ly,*x1,*y1,*x2,*y2,&ix[0],&iy[0]);
         if(hit[0] > 0)
            {
            iz[0] = InterpLinearElev(*x1, *y1, *z1, *x2, *y2, *z2, ix[0], iy[0]);
            }
         if((*x1 < lx) || (*x2 < lx))
            hit[1] = LineSegmentsIntersect(lx,ly,lx,uy,*x1,*y1,*x2,*y2,&ix[1],&iy[1]);
         if(hit[1] > 0)
            {
            iz[1] = InterpLinearElev(*x1, *y1, *z1, *x2, *y2, *z2, ix[1], iy[1]);
            }
         if((*y1 > uy) || (*y2 > uy))
            hit[2] = LineSegmentsIntersect(ux,uy,lx,uy,*x1,*y1,*x2,*y2,&ix[2],&iy[2]);
         if(hit[2] > 0)
            {
            iz[2] = InterpLinearElev(*x1, *y1, *z1, *x2, *y2, *z2, ix[2], iy[2]);
            }
         if((*x1 > ux) || (*x2 > ux))
            hit[3] = LineSegmentsIntersect(ux,uy,ux,ly,*x1,*y1,*x2,*y2,&ix[3],&iy[3]);
         if(hit[3] > 0)
            {
            iz[3] = InterpLinearElev(*x1, *y1, *z1, *x2, *y2, *z2, ix[3], iy[3]);
            }
         }
      else
         {
         if((*y1 < ly) || (*y2 < ly))
            hit[0] = LineSegmentsIntersect(lx,ly,ux,ly,*x2,*y2,*x1,*y1,&ix[0],&iy[0]);
         if(hit[0] > 0)
            {
            iz[0] = InterpLinearElev(*x2, *y2, *z2, *x1, *y1, *z1, ix[0], iy[0]);
            }
         if((*x1 < lx) || (*x2 < lx))
            hit[1] = LineSegmentsIntersect(lx,ly,lx,uy,*x2,*y2,*x1,*y1,&ix[1],&iy[1]);
         if(hit[1] > 0)
            {
            iz[1] = InterpLinearElev(*x2, *y2, *z2, *x1, *y1, *z1, ix[1], iy[1]);
            }
         if((*y1 > uy) || (*y2 > uy))
            hit[2] = LineSegmentsIntersect(ux,uy,lx,uy,*x2,*y2,*x1,*y1,&ix[2],&iy[2]);
         if(hit[2] > 0)
            {
            iz[2] = InterpLinearElev(*x2, *y2, *z2, *x1, *y1, *z1, ix[2], iy[2]);
            }
         if((*x1 > ux) || (*x2 > ux))
            hit[3] = LineSegmentsIntersect(ux,uy,ux,ly,*x2,*y2,*x1,*y1,&ix[3],&iy[3]);
         if(hit[3] > 0)
            {
            iz[3] = InterpLinearElev(*x2, *y2, *z2, *x1, *y1, *z1, ix[3], iy[3]);
            }
         }
      i = hit[0] + hit[1] + hit[2] + hit[3];
      answer = hit[0]*2 + hit[1]*4 + hit[2]*8 + hit[3]*16;
      if(i == 0) /** no intersections **/
         {
         *cflag = 0;
         }
      else if(i == 1) /** one point is inside region - which one ? **/
         {
         i = 0;
         while(hit[i] < 1)
            ++i;
         if(i > 3)
            {
            printf("unrecoverable problem during edge to region clipping\n");
            exit(-1);
            }

         if(AbsoluteAccuracy != 1)
            {
            if(NGA_TYPE == 0)
               {
               ix[i] = TruncNdigs(ix[i], decimalplaces);
               iy[i] = TruncNdigs(iy[i], decimalplaces);
               }
            else
               {
               ix[i] = SixPointFiveRound(1,ix[i]);
               iy[i] = SixPointFiveRound(2,iy[i]);
               }
            }

         if((*x1 >= lx) && (*x1 <= ux) && (*y1 >= ly) && (*y1 <= uy))
            {
            *x2 = ix[i];
            *y2 = iy[i];
            *z2 = iz[i];
            *cflag = 2; /** vertex 2 was replaced **/
            }
         else
            {
            *x1 = ix[i];
            *y1 = iy[i];
            *z1 = iz[i];
            *cflag = 1; /** vertex 1 was replaced **/
            }
         }
      else if(i == 2) /** 2 boundary intersections, so replace both line segment points **/
         {
         i = 0;
         while(hit[i] < 1)
            ++i;
         if(i > 3)
            {
            printf("unrecoverable problem during edge to region clipping\n");
            exit(-1);
            }

         if(AbsoluteAccuracy != 1)
            {
            if(NGA_TYPE == 0)
               {
               ix[i] = TruncNdigs(ix[i], decimalplaces);
               iy[i] = TruncNdigs(iy[i], decimalplaces);
               }
            else
               {
               ix[i] = SixPointFiveRound(1,ix[i]);
               iy[i] = SixPointFiveRound(2,iy[i]);
               }
            }

         *x1 = ix[i];
         *y1 = iy[i];
         *z1 = iz[i];
         ++i;
         while(hit[i] < 1)
            ++i;
         if(i > 3)
            {
            printf("unrecoverable problem during edge to region clipping\n");
            exit(-1);
            }

         if(AbsoluteAccuracy != 1)
            {
            if(NGA_TYPE == 0)
               {
               ix[i] = TruncNdigs(ix[i], decimalplaces);
               iy[i] = TruncNdigs(iy[i], decimalplaces);
               }
            else
               {
               ix[i] = SixPointFiveRound(1,ix[i]);
               iy[i] = SixPointFiveRound(2,iy[i]);
               }
            }

         *x2 = ix[i];
         *y2 = iy[i];
         *z2 = iz[i];
         *cflag = 3; /** both vertices were replaced **/
         }
      }
   return(answer);
}






double TurnAngle(double x1,double y1,double x2,double y2,double x3,double y3)
{
double A,B,C,NA,NB,NC,t,answer;

   if((x2 == x3) && (y2 == y3))
      answer = 0;
   else if((x1 == x2) && (y1 == y2))
      answer = 0;

   else if((x1 == x3) && (y1 == y3))
      answer = PI; 
   else
      {
      LineEquation(x1,y1,x2,y2,&A,&B,&C);
      LineEquation(x2,y2,x3,y3,&NA,&NB,&NC);
 
      t = A*NA + B*NB;

      if(t >= 1.0)
        answer = 0.0;
      else if(t <= -1.0)
         answer = PI;
      else
        answer = acos(t);
     }

   return(answer);
}




int PointWithinToleranceOfVertex(double px,double py,double *x,double *y,double *z,int vtxcnt,double *elev, double tolerance)
{
int i, answer;
double dx, maxpx,minpx,maxpy,minpy;

   answer = 0;
   maxpx = px + tolerance;
   minpx = px - tolerance;
   maxpy = py + tolerance;
   minpy = py - tolerance;
/******/
   for(i=0; i<vtxcnt; i++)
      {
      if((x[i] == px) && (y[i] == py))
         {
         answer = 1;
         *elev = z[i];
         break;
         }
      else if((maxpx > x[i]) && (minpx < x[i]) && (maxpy > y[i]) && (minpy < y[i]))
         {
         dx = Distance(px,py,x[i],y[i]);
         if(dx <= tolerance)
            {
            answer = 1;
            *elev = z[i];
            break;
            }
         }
      }
   return(answer);
}






int PointIsVertex(double px,double py,double *x,double *y,double *z,int vtxcnt,double *elev)
{
int i, answer;

   answer = 0;
   for(i=0; i<vtxcnt; i++)
      {
      if((x[i] == px) && (y[i] == py))
         {
         answer = 1;
         *elev = z[i];
         break;
         }
      }

   return(answer);
}

int PointIsAlmostVertex(double px,double py,double *x,double *y,double *z,int vtxcnt,double *elev)
{
int i, answer;
double dx, dy;

   answer = 0;
   for(i=0; i<vtxcnt; i++)
      {
      if(x[i] > px)
         dx = x[i] - px;
      else
         dx = px - x[i];
      if(dx < 0.0001)
         {
         if(y[i] > py)
            dy = y[i] - py;
         else
            dy = py - y[i];
         if(dy < 0.0001)
            {
            answer = 1;
            *elev = z[i];
            break;
            }
         }
      }

   return(answer);
}




int PointIsInside(double px,double py,double *x,double *y,double *z,int vtxcnt, unsigned char config, double *elev)
{
int answer,i,j;
double A,B,C,D, dmin;
double d[4];
double Gx[3], Gy[3], Gz[3];
int minx,maxx,miny,maxy;

   answer = 0;
   if(vtxcnt == 3)
      {
      if(PointInsideTriangle(px,py,x[0],y[0],x[1],y[1],x[2],y[2]) > 0)
         {
         answer = 1;
         PlaneEquation(&A,&B,&C,&D,x,y,z,vtxcnt);
         TwoDecimalSolveForZ(A,B,C,D,px,py,elev);
         }
      }
   else if((vtxcnt == 4) && (config == 9)) /** working with grid data **/
      {
      minx = maxx = 0;
      miny = maxy = 0;
      for(i=1; i<4; i++)
         {
         if(x[i] < x[minx])
            minx = i;
         if(x[i] > x[maxx])
            maxx = i;
         if(y[i] < y[miny])
            miny = i;
         if(y[i] > y[maxy])
            maxy = i;
         }
      if((x[minx] <= px) && (px <= x[maxx]) && (y[miny] <= py) && (py <= y[maxy]))
         {
         answer = 1;
         d[0] = (px - x[0]) * (px - x[0]) + (py - y[0]) * (py - y[0]);
         d[1] = (px - x[1]) * (px - x[1]) + (py - y[1]) * (py - y[1]);
         d[2] = (px - x[2]) * (px - x[2]) + (py - y[2]) * (py - y[2]);
         d[3] = (px - x[3]) * (px - x[3]) + (py - y[3]) * (py - y[3]);
         dmin = d[0];
         j = 0;
         for(i=1; i<4; i++)
            {
            if(d[i] < dmin)
               {
               j = i;
               dmin = d[j];
               }
            }
         
         i = (j + 3) % 4;
         Gx[0] = x[i];
         Gy[0] = y[i];
         Gz[0] = z[i];

         Gx[1] = x[j];
         Gy[1] = y[j];
         Gz[1] = z[j];

         i = (j + 1) % 4;
         Gx[2] = x[i];
         Gy[2] = y[i];
         Gz[2] = z[i];

         PlaneEquation(&A,&B,&C,&D,Gx,Gy,Gz,3);
         TwoDecimalSolveForZ(A,B,C,D,px,py,elev);
         }
      }
   else
      {
      if(PointInsidePoly(px,py,x,y,vtxcnt) > 0)
         {
         answer = 1;
         PlaneEquation(&A,&B,&C,&D,x,y,z,vtxcnt);
         TwoDecimalSolveForZ(A,B,C,D,px,py,elev);
         }
      }
   return(answer);
}


int PointWithinToleranceOfEdge(double px,double py,double *x,double *y,double *z,int vtxcnt,double *elev,int *index, double tolerance)
{
int answer;
int i,j;

   answer = 0;
   for(i=0; i<vtxcnt; i++)
      {
      j = (i + 1) % vtxcnt;
      if(PointOnLineSegment(px,py,x[i],y[i],x[j],y[j],tolerance) > 0)
         {
         answer = 1;
         *index = i;
         *elev = InterpLinearElev(x[i],y[i],z[i],x[j],y[j],z[j],px,py);
         break;
         }
      }

   return(answer);
}



int PointOnEdge(double px,double py,double *x,double *y,double *z,int vtxcnt,double *elev,int *index)
{
int answer;
int i,j;
  
   answer = 0;
   for(i=0; i<vtxcnt; i++)
      {
      j = (i + 1) % vtxcnt;
      if(PointOnLineSegment(px,py,x[i],y[i],x[j],y[j],0.01) > 0)
         {
         answer = 1;
         *index = i;
         *elev = InterpLinearElev(x[i],y[i],z[i],x[j],y[j],z[j],px,py);
         break;
         }
      }

   return(answer);
}





int PointInAreal(double px,double py,double * x,double * y,int numverts, int *OnEdge)
{
int i, j;
double mindist;
int IsInside;


   IsInside = PointInsidePoly(px,py,x, y, numverts);
   *OnEdge = 0;

   if(IsInside > 0)
      {
      for(i=0; i<numverts; i++)
         {
         if(i == 0)
            j = numverts - 1;
         else
            j = i - 1;
         mindist = PointToLineDist2D(px,py,x[j],y[j],x[i],y[i]);
         if(mindist < 0.00001)
            {
            *OnEdge = 1;
            break;
            }
         }
      }
   return(IsInside);
}
                                                                                                                                      



int LineExitsPoly(double x1,double y1,double x2,double y2,double *x,double *y,double *z,
    int vtxcnt,int Type,double vx,double vy,int index,double *dist,double *elev)
{
int answer;
int i,j;
double intX,intY;

   answer = 0;

/*** first check to see if a vertex of the poly is on the observer(x,y) - target(x,y) line **/
/** note that Type == 1 indicates that the point is a vertex **/
   for(i=0; i<vtxcnt; i++)
      {
      if((Type == 1) && ((x[i] != vx) || (y[i] != vy)) &&
            (PointOnLineSegment(x[i],y[i],x1,y1,x2,y2,0.01) > 0))
         {
         answer = 1;
         *dist = TwoDecimalDistance(x1,y1,x[i],y[i]);
         *elev = z[i];
         break;
         }
      else if((Type != 1) && (PointOnLineSegment(x[i],y[i],x1,y1,x2,y2,0.01) > 0))
         {
         answer = 1;
         *dist = TwoDecimalDistance(x1,y1,x[i],y[i]);
         *elev = z[i];
         break;
         }
      }

   if(answer == 0)
      {
      for(i=0; i<vtxcnt; i++)
         {
         j = (i + 1) % vtxcnt;
         if((Type == 3) &&
             (LineSegmentsIntersect(x1,y1,x2,y2,x[i],y[i],x[j],y[j],&intX,&intY) > 0))
            {
            answer = 1;
            *dist = TwoDecimalDistance(x1,y1,intX,intY);
            *elev = InterpLinearElev(x[i],y[i],z[i],x[j],y[j],z[j],intX,intY);
            break;
            }
         else if((Type == 2) && (i != index) &&
             (LineSegmentsIntersect(x1,y1,x2,y2,x[i],y[i],x[j],y[j],&intX,&intY) > 0))
            {
            answer = 1;
            *dist = TwoDecimalDistance(x1,y1,intX,intY);
            *elev = InterpLinearElev(x[i],y[i],z[i],x[j],y[j],z[j],intX,intY);
            break;
            }
         else if((Type == 1) && ((x[i] != vx) || (y[i] != vy)) && ((x[j] != vx) || (y[j] != vy)) &&
              (LineSegmentsIntersect(x1,y1,x2,y2,x[i],y[i],x[j],y[j],&intX,&intY) > 0))
            {
            answer = 1;
            *dist = TwoDecimalDistance(x1,y1,intX,intY);
            *elev = InterpLinearElev(x[i],y[i],z[i],x[j],y[j],z[j],intX,intY);
            break;
            }
         }
      }

   return(answer);
}



struct ProfileList * RecordInterval(double d1,double e1,double d2,double e2,
    int *Init,double *minE,double *maxE,int Sz,int dom_color, int LLindex, unsigned char strat)
{
struct ProfileList *cpl, *npl;
double lowest, highest;


   if(e1 < e2)
      {
      lowest = e1;
      highest = e2;
      }
   else
      {
      lowest = e2;
      highest = e1;
      }

   if(*Init == 0)
      {
      *minE = lowest;
      *maxE = highest;
      *Init = 1;
      }
   else
      {
      if(*minE > lowest)
         *minE = lowest;
      if(*maxE < highest)
         *maxE = highest;
      }

   cpl = (struct ProfileList *) (malloc(Sz));
   if(cpl == NULL)
      {
      printf("RecordInterval: Out of allocation memory\n");
      exit(-1);
      }
   cpl->dist = d1;
   cpl->elev = e1;
   cpl->ptype = dom_color;
   cpl->LLindex = LLindex;
   cpl->stratum = strat;

   npl = (struct ProfileList *) (malloc(Sz));
   if(npl == NULL)
      {
      printf("RecordInterval: Out of allocation memory\n");
      exit(-1);
      }
   npl->next = NULL;
   npl->dist = d2;
   npl->elev = e2;
   if(*minE > npl->elev)
      *minE = npl->elev;
   else if(*maxE < npl->elev)
      *maxE = npl->elev;
   npl->ptype = 1000;
   npl->LLindex = LLindex;
   npl->stratum = strat;

   cpl->next = npl;
  
   return(cpl);
}




double Line_LargeArealAngle(double px,double py,double ex, double ey, struct RawAreal *A, int *Aindex)
{
int ci1, ci2, cindex;
int MYI;
int LastI, i, j, k, UsedTree;
struct RB_Edgelist * LastEdge1;
double answer;
double D, temp;

   answer = -360.0;
   MYI = MaxYindex + 1;

   ci1 = (int) (ex / RegionSize);
   ci2 = (int) (ey / RegionSize);

   cindex = (ci1 * MYI) + ci2;

   LastEdge1 = NULL;
   LastI = -1;

   i = GetNextArealIndex(A, LastI, 1, &LastEdge1, cindex, &UsedTree);
   LastI = i;

   while(i >= 0)
      {

      j = (i + 1) % A->numverts;

      D = PointToLineDist2D(ex,ey,A->x[i],A->y[i],A->x[j],A->y[j]);
      if(D < 0.00001) /*** seems point is on the area perimeter **/
         {
         D = PointToLineDist2D(px,py,A->x[i],A->y[i],A->x[j],A->y[j]);
         if(D > 0.00001)
            {
            if((ex == A->x[i]) && (ey == A->y[i]))
               {
               k = (i + A->numverts - 1) % A->numverts;
               temp = TurnAngle(px,py,ex,ey,A->x[k],A->y[k]);
               answer = TurnAngle(px,py,ex,ey,A->x[j],A->y[j]);
               if(temp > answer)
                  {
                  answer = temp;
                  *Aindex = j;
                  }
               else
                  {
                  *Aindex = k;
                  }
               }
            else if((ex == A->x[j]) && (ey == A->y[j]))
               {
               k = (j + 1) % A->numverts;
               temp = TurnAngle(px,py,ex,ey,A->x[k],A->y[k]);
               answer = TurnAngle(px,py,ex,ey,A->x[i],A->y[i]);
               if(temp > answer)
                  {
                  answer = temp;
                  *Aindex = j;
                  }
               else
                  {
                  *Aindex = k;
                  }
               }
            else /*** ex,ey is not either area vertex - is just on the line segment ***/
               {
               temp = TurnAngle(px,py,ex,ey,A->x[j],A->y[j]);
               answer = TurnAngle(px,py,ex,ey,A->x[i],A->y[i]);
   
               if(temp > answer)
                  {
                  answer = temp;
                  *Aindex = j;
                  }
               else
                  {
                  *Aindex = i;
                  }
               }

            break;
            }
         }
      i = GetNextArealIndex(A, LastI, 1, &LastEdge1, ci1, &UsedTree);
      LastI = i;
      }

   if(answer > 0)
      {
      if(answer < PI)
         answer = RadiansToDegrees(answer);
      else
         answer = -360.0;
      }

   return(answer);
}


double Line_SmallArealAngle(double px,double py, double ex, double ey, struct RawAreal *A, int *Aindex)
{
int i,j,k;
double answer;
double D, temp;

   answer = -360.0;

   for(i=0; i<A->numverts; i++)
      {
      j = (i + 1) % A->numverts;

      D = PointToLineDist2D(ex,ey,A->x[i],A->y[i],A->x[j],A->y[j]);
      if(D < 0.00001) /*** seems point is on the area perimeter **/
         {
         D = PointToLineDist2D(px,py,A->x[i],A->y[i],A->x[j],A->y[j]);
         if(D > 0.00001) /*** seems point is on the area perimeter **/
            {
            if((ex == A->x[i]) && (ey == A->y[i]))
               {
               k = (i + A->numverts - 1) % A->numverts;
               temp = TurnAngle(px,py,ex,ey,A->x[k],A->y[k]);
               answer = TurnAngle(px,py,ex,ey,A->x[j],A->y[j]);
               if(temp > answer)
                  {
                  answer = temp;
                  *Aindex = k;
                  }
               else
                  {
                  *Aindex = j;
                  }
               }
            else if((ex == A->x[j]) && (ey == A->y[j]))
               {
               k = (j + 1) % A->numverts;
               temp = TurnAngle(px,py,ex,ey,A->x[k],A->y[k]);
               answer = TurnAngle(px,py,ex,ey,A->x[i],A->y[i]);
               if(temp > answer)
                  {
                  answer = temp;
                  *Aindex = k;
                  }
               else
                  {
                  *Aindex = j;
                  }
               }
            else /*** ex,ey is not either area vertex - is just on the line segment ***/
               {
               temp = TurnAngle(px,py,ex,ey,A->x[j],A->y[j]);
               answer = TurnAngle(px,py,ex,ey,A->x[i],A->y[i]);
               if(temp > answer)
                  {
                  answer = temp;
                  *Aindex = j;
                  }
               else
                  {
                  *Aindex = i;
                  }
               }

            break;
            }
         }
      }

   if(answer > 0)
      {
      if(answer < PI)
         answer = RadiansToDegrees(answer);
      else
         answer = -360.0;
      }

   return(answer);
}







int CalculateSliverRating(double *x,double *y,double *z,int vtxcnt,double *width,double *height, double *ratio)
{
int answer;
int i,j,k,v,newV;
double w;
double *Nx, *Ny, *Nz;
double Tx[3], Ty[3], Tz[3];

   if(vtxcnt > 0)
      {
      j = 0;
      newV = vtxcnt;
      i = 1;
      while(i < newV)
         {
         if((x[j] == x[i]) && (y[j] == y[i]) && (z[j] == z[i]))
            {
            --newV;
            for(k=i; k<vtxcnt; k++)
               {
               x[k-1] = x[k];
               y[k-1] = y[k];
               z[k-1] = z[k];
               }
            }
         j = i;
         ++i;
         }
      vtxcnt = newV;
      }

   Nx = Ny = Nz = NULL;
   if(vtxcnt == 3)
      {
      *width = PointToLineDist(x[0],y[0],z[0],x[1],y[1],z[1],x[2],y[2],z[2]);
      *height = *width;
      w = PointToLineDist(x[1],y[1],z[1],x[0],y[0],z[0],x[2],y[2],z[2]);
      if(w < *width)
         *width = w;
      if(w > *height)
         *height = w;
      w = PointToLineDist(x[2],y[2],z[2],x[0],y[0],z[0],x[1],y[1],z[1]);
      if(w < *width)
         *width = w;
      if(w > *height)
         *height = w;

      if(*height == 0)
         {
         *ratio = *width = *height = 0.0;
         }
      else
         *ratio = *width / *height;
      answer = 1;
      }
   else
      {
      Nx = (double *) (malloc(SzD * vtxcnt));
      Ny = (double *) (malloc(SzD * vtxcnt));
      Nz = (double *) (malloc(SzD * vtxcnt));
      if((Nx == NULL) || (Ny == NULL) || (Nz == NULL))
         {
         printf("CalculateSliverRating: out of allocation memory for poly with %d vertices\n",vtxcnt);
         exit(-1);
         }
      v = vtxcnt - 1;
      newV = 0;
      for(i=0; i<vtxcnt; i++)
         {
         j = (i + 1) % vtxcnt; /** j is index of vertex after vertex[i] **/
         k = (i + v) % vtxcnt; /** k is index of vertex before vertex[i] **/
         Tx[0] = x[i]; Ty[0] = y[i]; Tz[0] = z[i];
         Tx[1] = x[k]; Ty[1] = y[k]; Tz[1] = z[k];
         Tx[2] = x[j]; Ty[2] = y[j]; Tz[2] = z[j];
         if(ThreePointsAreColinear(Tx,Ty,Tz) == 0) /** if not co-linear, keep the middle point at index i **/
            {
            Nx[newV] = x[i];
            Ny[newV] = y[i];
            Nz[newV] = z[i];
            ++newV;
            if(newV > 4)
              break;
            }
         }
      if(newV < 3)
         {
         *ratio = *width = *height = 0.0;
         answer = 1;
         }
      else if(newV == 3)
         {
         *width = PointToLineDist(Nx[0],Ny[0],Nz[0],Nx[1],Ny[1],Nz[1],Nx[2],Ny[2],Nz[2]);
         *height = *width;
         for(i=0; i<newV; ++i)
            {
            j = (i + 1) % newV;
            k = (i + 2) % newV;
            while(k != i)
               {
               w = PointToLineDist(Nx[i],Ny[i],Nz[i],Nx[j],Ny[j],Nz[j],Nx[k],Ny[k],Nz[k]);
               if(w < *width)
                  *width = w;
               if(w > *height)
                  *height = w;
               j = k;
               k = (k + 1) % newV;
               }
            }
         if(*height == 0)
            {
            *ratio = *width = *height = 0.0;
            }
         else
            *ratio = *width / *height;
         answer = 1;
         }
      else
         answer = 0;

      free(Nx);
      free(Ny);
      free(Nz);
      }

   return(answer);
}








void FreeProfilePoints(struct ProfileList *Root)
{
struct ProfileList *cp, *pp;
   cp = Root;
   while(cp != NULL)
      {
      pp = cp;
      cp = cp->next;
      free(pp);
      }
   Root = NULL;
}





void FreeModelAllocations()
{
struct StaticModel *cm, *pm;
struct StampModel *cs, *ps;

   cm = ModelRoot;
   while(cm != NULL)
      {
      pm = cm;
      free(cm->x);
      free(cm->y);
      free(cm->z);
      free(cm->h);
      cm = cm->next;
      free(pm);
      }
   cs = StampRoot;
   while(cs!= NULL)
      {
      ps = cs;
      cs = cs->next;
      free(ps);
      }

   ModelRoot = NULL;
   StampRoot = NULL;
}




void ReleasePolyAllocations(void)
{
struct NeighborPolys *NP1, *NP2;
struct PolyExtra *PX;
struct ThePolys *P1, *P2, *p1, *p2;

   P1 = PolyRoot;
   while(P1 != NULL)
      {
      P2 = P1;
      PX = P2->Xtra;
      if(PX != NULL)
         {
         NP1 = PX->N;
         while(NP1 != NULL)
            {
            NP2 = NP1;
            p1 = NP2->p;
            while(p1 != NULL)
               {
               p2 = p1;
               p1 = p1->next;
               free(p2);
               }
            NP1 = NP1->next;
            free(NP2);
            }
         free(PX);
         }
      P1 = P1->next;

      free(P2->x);
      free(P2->y);
      free(P2->z);

      free(P2);
      }
   PolyRoot = NULL;
}



void FreeAttrErrStruct(void)
{
int i;
   if(AttrErr != NULL)
      {
      for(i=0; i<NumAttrErr; i++)
         {
         free(AttrErr[i].description);
         }
      free(AttrErr);
      }
   AttrErr = NULL;
   NumAttrErr = 0;

   if(CrsWlk != NULL) /*** could already be NULL if switching projects or ending GAIT session ***/
      {
      for(i = 0; i<SACfull; i++)
         {
         CrsWlk[i].AttrErr = -1;
   
         if(CrsWlk[i].MAE != NULL)
            {
            MAEc = CrsWlk[i].MAE;
            while(MAEc != NULL)
               { 
               MAEn = MAEc;
               MAEc = MAEc->next;
               free(MAEn);
               }
            CrsWlk[i].MAE = NULL;
            }
         }
      }

   return;
}



void FreeMemoryAsExit(int flag)
{
int i, j, listlength;

   if(MemoryAllocated == 0)
      return;

   if(MetaDataAttrCodes != NULL)
      free(MetaDataAttrCodes);
   MetaDataAttrCodes = NULL;
   NumMetaDataCodes = 0;

   ReleasePolyAllocations();

   FreeModelAllocations();

   MakeActiveChecks(1); /** frees ActiveChecks array when parameter is 1 **/

   if(ArealFromFile.MaxVerts > 0)
      {
      ArealFromFile.MaxVerts = 0;
      free(ArealFromFile.x);
      free(ArealFromFile.y);
      free(ArealFromFile.z);
      }

   if(LinearFromFile.MaxNodes > 0)
      {
      LinearFromFile.MaxNodes = 0;
      free(LinearFromFile.x);
      free(LinearFromFile.y);
      free(LinearFromFile.z);
      }

   if(PointFromFile.MaxVerts > 0)
      {
      free(PointFromFile.x);
      free(PointFromFile.y);
      free(PointFromFile.z);
      free(PointFromFile.h);
      }
   PointFromFile.MaxVerts = 0;

   for(i=0; i<TotalSCC; i++)
      {
      free(SCCtable[i].pname);
      }
   free(SCCtable);
   SCCtable = NULL;
   if(NumLODbands > 0)
      {
      if(LODindex != NULL)
         {
         for(i=0; i<NumLODbands; i++)
            {
            if(LODindex[i].title != NULL)
		free(LODindex[i].title);
            if(LODindex[i].filename != NULL)
		free(LODindex[i].filename);
            }
         free(LODindex);
         }
      }
   NumLODbands = 0;
   LODindex = NULL;

   listlength = (MaxXindex + 1) * (MaxYindex + 1);

   if(NGA_TYPE == 0)
      {
      for(i=0; i<listlength; i++)
         {
         if((PolyTable[i].numother > 0) && (PolyTable[i].others != NULL))
            {
            free(PolyTable[i].others);
            }
         }
      free(PolyTable);

      for(i=0; i<listlength; i++)
         {
         if((ModelPolyTable[i].numother > 0) && (ModelPolyTable[i].others != NULL))
            {
            free(ModelPolyTable[i].others);
            }
         }
      free(ModelPolyTable);

      for(i=0; i<listlength; i++)
         {
         if(BridgeTable[i].numother > 0)
            free(BridgeTable[i].others);
         }
      free(BridgeTable);

      }

   for(i=0; i<listlength; i++)
      {
      if(BucketsOfNets[i].next != NULL)
         { 
         NNc = BucketsOfNets[i].next;
         while(NNc != NULL)
            {
            NNn = NNc;
            NNc = NNc->next;
            CLc = NNn->CL;
            while(CLc != NULL)
               {
               CLn = CLc;
               CLc = CLc->next;
               free(CLn);
               }

            free(NNn);
            }
         }
      }
   NewNetNumber = 0;
   free(BucketsOfNets);

   for(i=0; i<listlength; i++)
      {
      if(ArealTable[i].numother > 0)
         {
         free(ArealTable[i].others);
         }
      }
   free(ArealTable);
   if(NumberOfGrids > 0)
      {
      for(i=0; i<=listlength; i++)
         {
         if(NGT[i].FileNumber != NULL)
            free(NGT[i].FileNumber);
         if(NGT[i].GridIndex != NULL)
            free(NGT[i].GridIndex);
         if(NGT[i].NumRows != NULL)
            free(NGT[i].NumRows);
         if(NGT[i].NumCols != NULL)
            free(NGT[i].NumCols);
         if(NGT[i].OnEdge != NULL)
            free(NGT[i].OnEdge);
         if(NGT[i].fileptr != NULL)
            free(NGT[i].fileptr);
         if(NGT[i].BaseX != NULL)
            free(NGT[i].BaseX);
         if(NGT[i].BaseY != NULL)
            free(NGT[i].BaseY);
         if(NGT[i].BaseZ != NULL)
            free(NGT[i].BaseZ);
         }
      free(GridHeader);
      free(NGT);

      if(FlowFlags.PointFlow != NULL)
         {
         free(FlowFlags.PointFlow);
         FlowFlags.PointFlow = NULL;
         FlowFlags.NumX = FlowFlags.NumY = 0;
         FlowFlags.Lindex = -99;
         FlowFlags.Xspacing = FlowFlags.Yspacing = 0.0;
         }
      }
   else
      {
      NGT = NULL;
      }

         

   for(i=0; i<listlength; i++)
      {
      if(LinearTable[i].numother > 0)
         free(LinearTable[i].others);
      }
   free(LinearTable);

   for(i=0; i<listlength; i++)
      {
      if(PointTable[i].numother > 0)
         free(PointTable[i].others);
      }
   free(PointTable);

   for(i=0; i<listlength; i++)
      {
      if(LindexTable[i].inside > 0)
         free(LindexTable[i].indices);
      }
   free(LindexTable);


   for(i=0; i<listlength; i++)
      {
      if((FIDindexTable[i].inside > 0) && (FIDindexTable[i].indices != NULL))
         {
         free(FIDindexTable[i].indices);
         FIDindexTable[i].inside = 0;
         FIDindexTable[i].indices = NULL;
         }
      }
   free(FIDindexTable);

   for(i=0; i<NumberOfModels; i++)
      {
      free(MdlNames[i].indices);
      free(MdlNames[i].AttrIndices);
      free(MdlNames[i].ValueIndices);
      if(MdlNames[i].LongListIndices != NULL)
         free(MdlNames[i].LongListIndices);
      free(MdlNames[i].ValueCounts);
      free(MdlNames[i].UniqueAttr);
      free(MdlNames[i].UniqueCounts);
      }

   free(MdlNames);
   MdlNames = NULL;
   NumberOfModels = 0;


   for(i=0; i<NumberOfAttributesEntries; i++)
      {
      for(j=0; j<MdlNames2[i].count; j++)
         {
         if((MdlNames2[i].values[j].type == 2) && (MdlNames2[i].values[j].label != NULL))
            free(MdlNames2[i].values[j].label);
         if(MdlNames2[i].values[j].LLindexcount > 0)
            free(MdlNames2[i].values[j].LongListIndices);
         if(MdlNames2[i].values[j].UniqueLLindexcount > 0)
            free(MdlNames2[i].values[j].UniqueLLindices);
         }
      if(MdlNames2[i].values != NULL)
         free(MdlNames2[i].values);
      }
   free(MdlNames2);
   MdlNames2 = NULL;
   NumberOfAttributesEntries = 0;


   for(i = 0; i<SACfull; i++)
      {
      if(CrsWlk[i].MAE != NULL)
         {
         MAEc = CrsWlk[i].MAE;
         while(MAEc != NULL)
            {
            MAEn = MAEc;
            MAEc = MAEc->next;
            free(MAEn);
            }
         }
      }
   free(CrsWlk);
   CrsWlk = NULL;

   if(RGrid != NULL)
      {
      FreeRGridStructure();
      }
   NumberOfGrids = 0;
   GridDimension = 0;
   if(MaxGridsPerRegion > 0)
      {
      for(i=0; i<MaxGridsPerRegion; i++)
         free(MG[i].Elevs);
      free(MG);
      MaxGridsPerRegion = 0;
      }

   if(infile != NULL)
      free(infile);
   if(allowedSAC != NULL)
      free(allowedSAC);
   if(SCCdefsfile != NULL)
      free(SCCdefsfile);
   if(bridgesin != NULL)
      free(bridgesin);
   if(bridgetablein != NULL)
      free(bridgetablein);
   if(modelsin != NULL)
      free(modelsin);
   if(modeltablein != NULL)
      free(modeltablein);
   if(arealtablein != NULL)
      free(arealtablein);
   if(arealsin != NULL)
      free(arealsin);
   if(ConflateSourceFiles != NULL)
      free(ConflateSourceFiles);
   if(arealholesin != NULL)
      free(arealholesin);
   if(MPtablein != NULL)
      free(MPtablein);
   if(MPdatain != NULL)
      free(MPdatain);
   if(gridtablein != NULL)
      free(gridtablein);
   if(gridsin != NULL)
      free(gridsin);
   if(gridheaderin != NULL)
      free(gridheaderin);
   if(IDproblems != NULL)
      free(IDproblems);
   if(gridtopimage != NULL)
      free(gridtopimage);
   if(lineartablein != NULL)
      free(lineartablein);
   if(linearsin != NULL)
      free(linearsin);
   if(pointtablein != NULL)
      free(pointtablein);
   if(pointsin != NULL)
      free(pointsin);
   if(tablein != NULL)
      free(tablein);
   if(metadata != NULL)
      free(metadata);
   if(LODbands != NULL)
      free(LODbands);
   if(sccuniquelist != NULL)
      free(sccuniquelist);
   if(StoLmapping != NULL)
      free(StoLmapping);
   if(scctablefile != NULL)
      free(scctablefile);
   if(fidtablefile != NULL)
      free(fidtablefile);
   if(attrgigs != NULL)
      free(attrgigs);

   if(flag == 1) /** free up the output file stuff when called by interface.c **/
      {
      if(binsmrylog != NULL)
         free(binsmrylog);
      if(networksfound != NULL)
         free(networksfound);
      binsmrylog = NULL;
      networksfound = NULL;
      }

   infile = NULL;
   allowedSAC = NULL;
   SCCdefsfile = NULL;
   bridgesin = NULL;
   bridgetablein = NULL;
   modelsin = NULL;
   modeltablein = NULL;
   arealtablein = NULL;
   arealsin = NULL;
   ConflateSourceFiles = NULL;
   arealholesin = NULL;
   MPtablein = NULL;
   MPdatain = NULL;
   gridtablein = NULL;
   gridsin = NULL;
   gridheaderin = NULL;
   IDproblems = NULL;
   gridtopimage = NULL;
   lineartablein = NULL;
   linearsin = NULL;
   pointtablein = NULL;
   pointsin = NULL;
   tablein = NULL;
   metadata = NULL;
   LODbands = NULL;
   sccuniquelist = NULL;
   StoLmapping = NULL;
   scctablefile = NULL;
   fidtablefile = NULL;
   attrgigs = NULL;


   FreeAttrErrStruct();

   MemoryAllocated = 0;
   return;
}




void ReadRecordedAttributionErrorIndices(void)
{
FILE *DataIn;
int i,j,k, jj;

   DataIn = fopen(attrgigs,"rb");
   if(DataIn != NULL)
      {
      AttributionAnalysisComplete = 1;
      SEEIT_fread_int(&i,DataIn);
      NumAttrErr = i;
      if(i < 0)
         printf("Attribution anlysis was not performed during project creation - no discrepancies noted\n");
      if(i >= 0)
         {
         printf("Number of recorded attribution discrepancy types (condition instances will be greater): %d\n",NumAttrErr);
         if(AttrErr != NULL)
            {
            FreeAttrErrStruct();
            }
         AttrErr = (struct AttributionErrors *) (malloc(sizeof(struct AttributionErrors) * i));
         if(AttrErr == NULL)
            {
            printf("allocation memory exhausted during attempt to read attribution errors text descriptions\n");
            exit(-1);
            }
         for(j=0; j<i; j++)
            {
            SEEIT_fread_int(&k,DataIn);
            AttrErr[j].description = (char *) (malloc(k + 5));
            fread(&AttrErr[j].description[0],1,k,DataIn);
            AttrErr[j].description[k] = '\0';
            for(jj=0; jj<k; jj++)
               {
               if(AttrErr[j].description[jj] == '"')
                  AttrErr[j].description[jj] = 39;
               }
            }
         SEEIT_fread_int(&j,DataIn);
         SEEIT_fread_int(&k,DataIn);
         while(feof(DataIn) == 0)
            {
            if(AttrErr[k].description[0] != '*')
               {
               if(CrsWlk[j].AttrErr < 0) /** should be set to -1 as initialize, so not used yet if true **/
                  {
                  CrsWlk[j].AttrErr = k;
                  CrsWlk[j].MAE = NULL;
                  }
               else
                  {
                  MAEc = (struct  MoreAttrErrIndices *) (malloc(sizeof(struct  MoreAttrErrIndices)));
                  if(MAEc == NULL)
                     {
                     printf("all available memory has been exhausted during allocation of attribute error notifications\n");
                     exit(-1);
                     }
                  MAEc->index = k;
                  MAEc->next = CrsWlk[j].MAE;
                  CrsWlk[j].MAE = MAEc;
                  }
               }
            SEEIT_fread_int(&j,DataIn);
            SEEIT_fread_int(&k,DataIn);
            }
         }
      else
         AttrErr = NULL;
      fclose(DataIn);
      }
}



int GetPointElevation(double pntx,double pnty,double *NewZ)
{
FILE *ptsin;
FILE *modelPin;
double answer;
double inactiveanswer;
int i,jj,ii;
int gi1;
int OKtoUse;
int index1, index2, HadToOpenFile;
int valuesread, foundOne, foundInactive;
int retval;
int NofCols;
int singles, multiples,totalpoly,compositeindex;
int iX, iY, grows, gcols;
/***int restoreUseRGridStruct; ***/
double digits;
double A, B, C, D;
double Xgrid[4], Ygrid[4], Zgrid[4];
double t,u,t1,u1;
int vtxcnt;
int findex = 0;

   index1 = (int) (pntx / RegionSize);
   index2 = (int) (pnty / RegionSize);
/***
int MinXindex = 500;
int MaxXindex = 0;
int MinYindex = 500;
int MaxYindex = 0;
***/

   if((index1 < MinXindex) || (index1 > MaxXindex) || (index2 < MinYindex) || (index2 > MaxYindex))
      {
      *NewZ = -999999.9;
      return(0);
      }
   valuesread = foundOne = foundInactive = 0;


   retval = 1;  /** assume we will find an answer (a containing poly) **/


   if(NGA_TYPE == 0)
      HadToOpenFile = ReadPolySetup(&digits, index1, index2, &singles, &multiples,&compositeindex);
   else
      {
      HadToOpenFile = 0;
      singles = multiples = 0;
      compositeindex = (index1 * (MaxYindex + 1)) + index2;
      digits = SignificantDecimals;
      }

   totalpoly = singles + multiples;
   multiples = 0;
   while(valuesread < totalpoly)
      {
      if(valuesread >= singles)
         {
         fseek(fin,PolyTable[compositeindex].others[multiples].fileptr,SEEK_SET);
         ++multiples;
         }
      vtxcnt = ReadPolyFromFile(fin,digits);
      ++valuesread;

      OKtoUse = 1;
      if(IgnoreDrawingSettings == 0)
         {
         if((DrawByConfig[PolyFromFile.config] == 0) || (DrawByStratum[PolyFromFile.stratum] == 0) ||
             (DrawByDomain[PolyFromFile.domain] == 0))
            OKtoUse = 0;
         }
      if((OKtoUse > 0) && (NumLODbands > 0))
         {
         jj = CrsWlk[PolyFromFile.SACindex].LODband;

         if(IgnoreDrawingSettings == 1) 
            {
            if(jj > 1)  /** should force answer from highest LOD **/
               OKtoUse = 0;
            }
         else /** else grab from some displayed band **/
            {
            if((jj > 0) && (LODindex[jj-1].active < 1))
               OKtoUse = 0;
            }
         }

      if((OKtoUse > 0) &&
           ((PolyFromFile.stratum == 5) ||  /** is a surface polygon **/
           (PolyFromFile.stratum == 3)))  /** is inactive layer ***/
         {
         if(vtxcnt == 3)
            i = PointInsideTriangle(pntx,pnty, PolyFromFile.x[0], PolyFromFile.y[0],
                       PolyFromFile.x[1], PolyFromFile.y[1], PolyFromFile.x[2], PolyFromFile.y[2]);
         else
            i = PointInsidePoly(pntx,pnty, PolyFromFile.x, PolyFromFile.y, vtxcnt);
         if(i == 1)
            {
            if(PolyFromFile.stratum == 3) /** is inactive layer **/
               {
               foundInactive = 1;
               PlaneEquation(&A,&B,&C,&D,PolyFromFile.x,PolyFromFile.y,PolyFromFile.z,vtxcnt);
               if((NEGSMIDGE < C) && (C < SMIDGE))
                  inactiveanswer = PolyFromFile.z[0];
               else
                  SolveForZ(A,B,C,D,pntx,pnty,&inactiveanswer);
               }
            else
               {
               foundOne = 1;
               PlaneEquation(&A,&B,&C,&D,PolyFromFile.x,PolyFromFile.y,PolyFromFile.z,vtxcnt);
               if((NEGSMIDGE < C) && (C < SMIDGE))
                  answer = PolyFromFile.z[0];
               else
                  SolveForZ(A,B,C,D,pntx,pnty,&answer);
               break;
               }
            }
         }
      free(PolyFromFile.x);
      free(PolyFromFile.y);
      free(PolyFromFile.z);
      }
   if((foundOne == 0) && (foundInactive == 0))
      {
      answer = -999999.9;
      retval = 0;
      }
   else if(foundOne == 0)
      answer = inactiveanswer;

   if(HadToOpenFile > 0)
      {
      fclose(fin);
      fin = NULL;
      HadToOpenFile = 0;
      }

   if((retval == 0) && (NumberOfGrids > 0) && (OnlyUsePolysForElevLookup == 0))
      {

      findex = 0;
      while((findex < NGT[compositeindex].NumGrids) && (retval == 0))
         {
      if((NGT[compositeindex].FileNumber != NULL) && (GridFileInUse != NGT[compositeindex].FileNumber[findex]))
         ptsin = OpenGridFile(compositeindex,findex);
      else
         ptsin = NULL;
      if(ptsin != NULL)
         {
         if(NumLODbands > 1)
            GridNowLoaded = -10;
         if(NGT[compositeindex].NumGrids > 0)
            {
ii = 0;
jj = ReadGridFromFile(ii,ptsin, digits,compositeindex,NumberOfGrids,&NofCols,&LoadedGridMres);
                        for(gi1=0; gi1<MaxGridsPerRegion; gi1++)
                           {
                           if((MG[gi1].numX > 0) && (MG[gi1].numY > 0))
                              {
                              iX = 0;
                              for(grows = 0; grows < MG[gi1].numX -1; grows++)
                                 {
/** for these indices, should be that [0] is lower left, [1] = upper left, [2] = upper right, [3] = lower right **/
                                 Xgrid[0] = MG[gi1].SouthWestX - SMIDGE + ((double) iX * MG[gi1].Xspace);
                                 Xgrid[1] = Xgrid[0];
                                 Xgrid[2] = Xgrid[0] + MG[gi1].Xspace + (2.0 * SMIDGE);
                                 Xgrid[3] = Xgrid[2];
                                 if((Xgrid[0] <= pntx) && (Xgrid[2] >= pntx))
                                    {
                                    iY = 0;
                                    for(gcols = 0; gcols < MG[gi1].numY - 1; gcols++)
                                       {
                                       Ygrid[0] = MG[gi1].SouthWestY - SMIDGE + ((double) iY * MG[gi1].Yspace);
                                       Ygrid[3] = Ygrid[0];
                                       Ygrid[1] = Ygrid[0] + MG[gi1].Yspace + (2.0 * SMIDGE);
                                       Ygrid[2] = Ygrid[1];

                                       if((Ygrid[0] <= pnty) && (Ygrid[1] >= pnty))
                                          {
                                          Zgrid[0] = MG[gi1].Elevs[(iX * MG[gi1].numY) + iY];
                                          Zgrid[3] = MG[gi1].Elevs[(iX * MG[gi1].numY) + iY + 1];
                                          Zgrid[2] = MG[gi1].Elevs[(iX * MG[gi1].numY) + MG[gi1].numY + iY + 1];
                                          Zgrid[1] = MG[gi1].Elevs[(iX * MG[gi1].numY) + MG[gi1].numY + iY];

                                          t = (pntx - Xgrid[0]) / (Xgrid[2] - Xgrid[0]);
                                          t1 = 1.0 - t;
                                          u = (pnty - Ygrid[0]) / (Ygrid[1] - Ygrid[0]);
                                          u1 = 1.0 - u;

                                          answer = t1 * u1 * Zgrid[0]; 
                                          answer += t * u1 * Zgrid[1]; 
                                          answer += t * u * Zgrid[2]; 
                                          answer += t1 * u * Zgrid[3]; 

                                          retval = 1;
                                          break;
                                          }
                                       ++iY;
                                       }
                                    }
                                 if(retval > 0)
                                    break;
                                 ++iX;
                                 }
                              }
                           }
            }
         CloseGridFile(ptsin);
         }

         ++findex;
         }
      }

   if((retval == 0) && (NGA_TYPE == 0))
      {
      foundOne = 0;
      modelPin = fopen(MPdatain,"rb");
      if(modelPin != NULL)
         {
         compositeindex = (index1 * (MaxYindex + 1)) + index2;
         fseek(modelPin,ModelPolyTable[compositeindex].fileptr,SEEK_SET);
         singles = ModelPolyTable[compositeindex].numinside;
         multiples = ModelPolyTable[compositeindex].numother;
         totalpoly = singles + multiples;
         multiples = 0;
         while(valuesread < totalpoly)
            {
            if(valuesread >= singles)
               {
               fseek(modelPin,ModelPolyTable[compositeindex].others[multiples].fileptr,SEEK_SET);
               ++multiples;
               }
            vtxcnt = ReadPolyFromFile(modelPin,digits);
            ++valuesread;

            OKtoUse = 1;
            if(IgnoreDrawingSettings == 0)
               {
               if((DrawByConfig[PolyFromFile.config] == 0) || (DrawByStratum[PolyFromFile.stratum] == 0) ||
                   (DrawByDomain[PolyFromFile.domain] == 0))
                  OKtoUse = 0;
               }

            if((OKtoUse > 0) && (PolyFromFile.stratum == 5))  /** is a surface polygon **/
               {
               if(vtxcnt == 3)
                  i = PointInsideTriangle(pntx,pnty, PolyFromFile.x[0], PolyFromFile.y[0],
                             PolyFromFile.x[1], PolyFromFile.y[1], PolyFromFile.x[2], PolyFromFile.y[2]);
               else
                  i = PointInsidePoly(pntx,pnty, PolyFromFile.x, PolyFromFile.y, vtxcnt);
               if(i == 1)
                  {
                  foundOne = 1;
                  PlaneEquation(&A,&B,&C,&D,PolyFromFile.x,PolyFromFile.y,PolyFromFile.z,vtxcnt);
                  if((NEGSMIDGE < C) && (C < SMIDGE))
                     answer = PolyFromFile.z[0];
                  else
                     SolveForZ(A,B,C,D,pntx,pnty,&answer);
                  retval = 1;
                  break;
                  }
               }
            free(PolyFromFile.x);
            free(PolyFromFile.y);
            free(PolyFromFile.z);
            }
         if(foundOne == 0)
            {
            answer = -999999.9;
            retval = 0;
            }
         fclose(modelPin);
         }
      }

   *NewZ = answer; 

   return(retval);
}



long int ReadCodesFullEntry(int *SEEITGeom, int PrintAsRead, FILE * fileptr, int Verbosity)
{
int ECC, seeitgeom,NumAttr,EAC,uom, uomscale,SEDRIStype,datatype,Idtvalue;
int IdtVal2;
double Fdtvalue;
double FdtVal2;
int IntervalType;
int numchar;
char title [500];
char longtitle[500];
int titlelength;
char tc;
int i,j,k;
long int fileposn;

   fileposn = ftell(fileptr);
   SEEIT_fread_int(&ECC,fileptr);
   if(feof(fileptr) == 0)
      {
      strcpy(title,GetECCLabel(ECC));
      titlelength = strlen(title);
    
      SEEIT_fread_int(&seeitgeom,fileptr);
      *SEEITGeom = seeitgeom;
      SEEIT_fread_int(&NumAttr,fileptr);
      if(PrintAsRead > 0)
         {
         if(NumAttr == 0)
            sprintf(MessageLine," No attributes listed for %s\n",title);
         else if(NumAttr == 1)
            sprintf(MessageLine," %s has one attribute\n",title);
         else
            sprintf(MessageLine," %d attributes listed for %s\n",NumAttr,title);
         infoprint(MessageLine);
         }

      for(k=1; k<=NumAttr; k++)
         {
         SEEIT_fread_int(&EAC,fileptr);
         if((PrintAsRead > 0) && (EAC >= 0))
            {
            if(Verbosity == 1)
               sprintf(MessageLine,"Attribute Label: %s\n",GetEACLabel(EAC));
            else
               sprintf(MessageLine," %s\n",GetEACLabel(EAC));
            infoprint(MessageLine);
            }
         if(EAC >= 0)
            {
            SEEIT_fread_int(&uom,fileptr);
            SEEIT_fread_int(&uomscale,fileptr);
            SEEIT_fread_int(&SEDRIStype,fileptr);
            SEEIT_fread_int(&datatype,fileptr);
            switch(datatype)
               {
               case 0: /** regular integer **/
                  SEEIT_fread_int(&Idtvalue,fileptr);
                  if((PrintAsRead > 0) && (Verbosity ==1))
                     {
                     sprintf(MessageLine,"integer value: %d\n",Idtvalue);
                     infoprint(MessageLine);
                     }
                  break;
               case 1: /** a double **/
                  SEEIT_fread_double(&Fdtvalue,fileptr);
                  if((PrintAsRead > 0) && (Verbosity ==1))
                     {
                     sprintf(MessageLine,"floating point value: %lf\n",Fdtvalue);
                     infoprint(MessageLine);
                     }
                  break;
               case 2: /** a string **/
                  SEEIT_fread_int(&numchar,fileptr);
                  if((PrintAsRead > 0) && (Verbosity ==1))
                     {
                     sprintf(MessageLine,"string value: ");
                     }
                  for(i=0; i<numchar; i++)
                     {
                     fread(&tc,1,1,fileptr);
                     if((PrintAsRead > 0) && (Verbosity ==1))
                        {
                        MessageLine[i+14] = tc;
                        }
                     }
                  if((PrintAsRead > 0) && (Verbosity ==1))
                     {
                     MessageLine[i+14] = '\n';
                     MessageLine[i+15] = '\0';
                     infoprint(MessageLine);
                     }
                  break;
               case 3: /** enum as int **/
                  SEEIT_fread_int(&Idtvalue,fileptr);
                  if((PrintAsRead > 0) && (Verbosity ==1))
                     {
                     sprintf(MessageLine,"Enumerant Label %s\n",GetEELabel(EAC,Idtvalue));
                     infoprint(MessageLine);
                     sprintf(MessageLine,"     %s\n",GetEEDefinition(EAC,Idtvalue));
                     infoprint(MessageLine);
                     }
                  break;
               case 4: /** metada as int **/
                  SEEIT_fread_int(&Idtvalue,fileptr);
                  if((PrintAsRead > 0) && (Verbosity ==1))
                     {
                     sprintf(MessageLine,"Metadata Label %s\n",GetEMLabel(Idtvalue));
                     infoprint(MessageLine);
                     sprintf(MessageLine,"     %s\n",GetEMDefinition(Idtvalue));
                     infoprint(MessageLine);
                     }
                  break;
               case 5: /** a float interval **/
                  SEEIT_fread_double(&Fdtvalue,fileptr);
                  SEEIT_fread_double(&FdtVal2,fileptr);
                  SEEIT_fread_int(&IntervalType,fileptr);
                  if((PrintAsRead > 0) && (Verbosity ==1))
                     {
                     infoprint(MessageLine);
                     }
                  break;
               case 6:
                  SEEIT_fread_int(&Idtvalue,fileptr);
                  SEEIT_fread_int(&IdtVal2,fileptr);
                  SEEIT_fread_int(&IntervalType,fileptr);
                  if((PrintAsRead > 0) && (Verbosity ==1))
                     {
                     infoprint(MessageLine);
                     }
                  break;
               case 7:
                  SEEIT_fread_int(&Idtvalue,fileptr);
                  SEEIT_fread_int(&IdtVal2,fileptr);
                  SEEIT_fread_int(&IntervalType,fileptr);


                  if((PrintAsRead > 0) && (Verbosity ==1))
                     {
		       sprintf(MessageLine,"\n interval stuff needs updating: (%d to %d)\n",Idtvalue,IdtVal2);
		       infoprint(MessageLine);
                     }
                  break;
               }
	    
	    


            if((PrintAsRead > 0) && (Verbosity == 1) && (NGA_TYPE != 1))
               {
               if((datatype < 2) || (datatype > 4))
                  {
                  sprintf(MessageLine,"   units: %s scale: %s\n",GetUnitsLabel(uom),GetScaleLabel(uomscale));
                  infoprint(MessageLine);
                  }
               }
            }
         else /** EAC of -1, -2, -3 indicates LOD name, Assgd model name, or poly flag string, respectively **/
            {
            SEEIT_fread_int(&numchar,fileptr);
            if(numchar < 499)
               fread(&longtitle[0],1,numchar,fileptr);
            longtitle[numchar] = '\0';
            if((PrintAsRead > 0) && (Verbosity == 1) && (EAC == -1))
               {
               if(NGA_TYPE == 1)
                  sprintf(MessageLine,"Layer: %s\n",longtitle);
               else
                  sprintf(MessageLine,"LOD: %s\n",longtitle);
               infoprint(MessageLine);
               }
            else if(EAC == -2)
               {
               j = titlelength + numchar;
               if(j < 499)
                  strcat(title,longtitle);
               if((PrintAsRead > 0) && (Verbosity ==1))
                  {
                  sprintf(MessageLine,"Model Name: %s\n",longtitle);
                  infoprint(MessageLine);
                  }
               }
            else if((PrintAsRead > 0) && (Verbosity == 1) && (EAC == -3))
               {
               sprintf(MessageLine,"Polygon Flag: %s\n",longtitle);
               infoprint(MessageLine);
               }
            }
         } /** end for number of attributes **/
      title[39] = '\0';
      }
   else
      fileposn = -1;

   if((PrintAsRead > 0) && (Verbosity == 1) && (EAC == -3))
      {
      sprintf(MessageLine,"\n");
      infoprint(MessageLine);
      }


   return(fileposn);

}





void ReadDynamicDefsFile(void)
{
FILE *tblin;
char junk[500];
int j;
int code,s;

   tblin = fopen(SCCdefsfile,"rb");
   if(tblin == NULL)
     {
      printf("Could not locate SCC value table %s\n",SCCdefsfile);
      exit(-1);
      }

   SEEIT_fread_int(&code,tblin);
   for(j=0; j<TotalSCC; j++)
      {
      SCCtable[j].ECC = code;
      strcpy(junk,GetECCLabel(code));


      s = strlen(junk) + 1;
      SCCtable[j].pname = (char *) (malloc(s));
      strcpy(&SCCtable[j].pname[0],junk);
      SCCtable[j].pname[s-1] = '\0';
      fread(&SCCtable[j].C,1,1,tblin);
      fread(&SCCtable[j].S,1,1,tblin);
      fread(&SCCtable[j].D,1,1,tblin);
      SEEIT_fread_int(&code,tblin);
      }
   fclose(tblin);
}




void InitializeFIDindexTable(void)
{
FILE *ftoread;
int i,j;
int listlength;

   listlength = (MaxXindex + 1) * (MaxYindex + 1);

   ftoread = fopen(fidtablefile,"rb");
   if(ftoread != NULL)
      {
      for(i=0; i<listlength; i++)
         {
         SEEIT_fread_int(&j,ftoread);
         if(j != i)
            {
            printf("index misallignment during FID index table read, %d not equal to %d\n",j,i);
            exit(-1);
            }
         SEEIT_fread_int(&FIDindexTable[i].inside,ftoread);
         if(FIDindexTable[i].inside > 0)
            FIDindexTable[i].indices = (int *) (malloc(SzI * FIDindexTable[i].inside));
         else
            FIDindexTable[i].indices = NULL;
         for(j=0; j< FIDindexTable[i].inside; j++)
            {
            SEEIT_fread_int(&FIDindexTable[i].indices[j],ftoread);
            }
         }
      fclose(ftoread);
      }

   return;
}


void FreeFIDindexTableEntries(void)
{
int listlength;
int i;

   listlength = (MaxXindex + 1) * (MaxYindex + 1);
   for(i=0; i<listlength; i++)
      {
      if((FIDindexTable[i].inside > 0) && (FIDindexTable[i].indices != NULL))
         {
         free(FIDindexTable[i].indices);
         FIDindexTable[i].inside = 0;
         FIDindexTable[i].indices = NULL;
         }
      }
   return;
}




void SetUpTable(int flag)
{
int i,j,k,kk,kk2,SzSCCtable;
/**int memreleased = 0;**/
int maxgrid,mingrid,GridPtsThisRegion;
int GridPtsPerRegion;
int MaxNumNodes;
int MaxGridStack /***, tMGS ***/;
int ii;
FILE *tblin;
long int pointverts;
long int ttlpolys;
long int ttlgridpoints;
long int lineverts;
long int arealverts;
long int nonzerobucket = 0;
unsigned char tchar;
char junk[500];
double minGspacing;
int listlength;
int SzPL, SzPtrList, SzAV;
int SzNGL = sizeof(struct NewGridLookup);
FILE * SCC1;
double PCdone;

   UseNUNANPO = 1;  

   MaxInputFileNumber = 0;

   ArealForAreaCalculation.numverts = 0;

   PointFromFile.MaxVerts = 0;

   FlowFlags.PointFlow = NULL;
   FlowFlags.NumX = 0;
   FlowFlags.NumY = 0;
   FlowFlags.Lindex = -99;
   FlowFlags.Xspacing = 0.0;
   FlowFlags.Yspacing = 0.0;

   SzSCCtable = sizeof(struct SCCdata);

   SzPL = sizeof(struct ObjectLookup);
   SzPtrList = sizeof(struct PtrList);
   SzAV = sizeof(struct AttrValList);


   tblin = fopen(metadata,"rb");
   if(tblin == NULL)
      {
      printf("could not open header information file %s\n",metadata);
      printf("can not continue without this file\n");
      exit(-1);
      }

   fread(&tchar,SzUC,1,tblin);
   CoordinateSystem = (int) tchar;


   SEEIT_fread_double(&MinXcoord,tblin);
   SEEIT_fread_double(&MinYcoord,tblin);
   SEEIT_fread_double(&MaxXcoord,tblin);
   SEEIT_fread_double(&MaxYcoord,tblin);

   MinNativeX = MinXcoord;
   MinNativeY = MinYcoord;



   SEEIT_fread_double(&MinSurfXcoord,tblin);
   SEEIT_fread_double(&MinSurfYcoord,tblin);
   SEEIT_fread_double(&MaxSurfXcoord,tblin);
   SEEIT_fread_double(&MaxSurfYcoord,tblin);


   SEEIT_fread_long(&ttlpolys,tblin);
   TotalPolygons = ttlpolys;

   SEEIT_fread_long(&ttlgridpoints,tblin);
   SEEIT_fread_long(&pointverts,tblin);
   SEEIT_fread_long(&lineverts,tblin);
   SEEIT_fread_long(&arealverts,tblin);

   SEEIT_fread_int(&NumberOfGrids,tblin);

   SEEIT_fread_int(&SACfull,tblin);


   SEEIT_fread_int(&TotalSCC,tblin);


/** now read translated & other header data **/

   SEEIT_fread_double(&RegionSize,tblin);

   SEEIT_fread_double(&MinXcoord,tblin);
   SEEIT_fread_double(&MinYcoord,tblin);
   SEEIT_fread_double(&MaxXcoord,tblin);
   SEEIT_fread_double(&MaxYcoord,tblin);


   MinXindex = 0;
   SEEIT_fread_int(&MaxXindex,tblin);
   MinYindex = 0;
   SEEIT_fread_int(&MaxYindex,tblin);

   SEEIT_fread_double(&Xtranslation,tblin);
   SEEIT_fread_double(&Ytranslation,tblin);

   if(Ctype()==2)
      {
      MinSurfXcoord -= Xtranslation;
      MaxSurfXcoord -= Xtranslation;
      MinSurfYcoord -= Ytranslation;
      MaxSurfYcoord -= Ytranslation;
      }
   else
      {
      MinSurfXcoord = (MinSurfXcoord - Xtranslation) * 100000.0;
      MaxSurfXcoord = (MaxSurfXcoord - Xtranslation) * 100000.0;
      MinSurfYcoord = (MinSurfYcoord - Ytranslation) * 100000.0;
      MaxSurfYcoord = (MaxSurfYcoord - Ytranslation) * 100000.0;
      }



   fclose(tblin);


   ArealFromFile.MaxVerts = 0;
   LinearFromFile.MaxNodes = 0;

   if(flag == 2)
      {
      return;
      }

   if(NumberOfGrids > 0)
      {
      GridHeader = (struct GlobalGridInfo *) (malloc(sizeof(struct GlobalGridInfo) * NumberOfGrids));
      if(GridHeader == NULL)
         {
         printf("allocation memory exhausted during grid data processing (file %s)\n",gridheaderin);
         exit(-1);
         }
      tblin = fopen(gridheaderin,"rb");
      if(tblin == NULL)
         {
         printf("could not open header record file %s\n",gridheaderin);
         }
      else
         {
         SEEIT_fread_int(&i,tblin);
         if(i != NumberOfGrids)
            {
            printf("grid data file %s seems to be corrunpted\n",gridheaderin);
            NumberOfGrids = 0;
            }
         i = 0;
         while((feof(tblin) == 0) && (i < NumberOfGrids))
            {
            SEEIT_fread_int(&GridHeader[i].Lindex,tblin);
            SEEIT_fread_int(&GridHeader[i].Sindex,tblin);
            SEEIT_fread_int(&GridHeader[i].Xpts,tblin);
            SEEIT_fread_int(&GridHeader[i].Ypts,tblin);
            SEEIT_fread_int(&GridHeader[i].BPGV,tblin);
            SEEIT_fread_int(&GridHeader[i].FileNumber,tblin);
            SEEIT_fread_long(&GridHeader[i].fileptr,tblin);
            SEEIT_fread_double(&GridHeader[i].BaseX,tblin);
            SEEIT_fread_double(&GridHeader[i].BaseY,tblin);
            SEEIT_fread_double(&GridHeader[i].Xspacing,tblin);
            SEEIT_fread_double(&GridHeader[i].Yspacing,tblin);

            GridHeader[i].idn = (-1 * (i + 1));

            if(i == 0)
               {
               if(GridHeader[i].Xspacing < GridHeader[i].Yspacing)
                  minGspacing = GridHeader[i].Xspacing;
               else
                  minGspacing = GridHeader[i].Yspacing;
               }
            else if(GridHeader[i].Xspacing < minGspacing)
               minGspacing = GridHeader[i].Xspacing;
            else if(GridHeader[i].Yspacing < minGspacing)
               minGspacing = GridHeader[i].Yspacing;
            ++i;
            }
         fclose(tblin);
         }
      }
   else
      {
      GridHeader = NULL;
      }

   listlength = (MaxXindex + 1) * (MaxYindex + 1);
   BucketsOfNets = (struct NetworkNode *) (malloc(sizeof(struct NetworkNode) * listlength));
   if(BucketsOfNets == NULL)
      {
      printf("allocation memory exhausted during network indexing initialization\n");
      exit(-1);
      }

   ArealTable = (struct ObjectLookup *) (malloc(SzPL * listlength));
   if(ArealTable == NULL)
      {
      printf("allocation memory exhausted during area feature table read operation\n");
      exit(-1);
      }
   LinearTable = (struct ObjectLookup *) (malloc(SzPL * listlength));
   if(LinearTable == NULL)
      {
      printf("allocation memory exhausted during line feature table read operation\n");
      exit(-1);
      }

   PointTable = (struct ObjectLookup *) (malloc(SzPL * listlength));
   if(PointTable == NULL)
      {
      printf("allocation memory exhausted during point feature table read operation\n");
      exit(-1);
      }

   if(NGA_TYPE == 0)
      {
      PolyTable = (struct ObjectLookup *) (malloc(SzPL * listlength));
      if(PolyTable == NULL)
         {
         printf("allocation memory exhausted during polygon table read operation\n");
         exit(-1);
         }
      ModelPolyTable = (struct ObjectLookup *) (malloc(SzPL * listlength));
      if(ModelPolyTable == NULL)
         {
         printf("allocation memory exhausted during model polygon table read operation\n");
         exit(-1);
         }
      BridgeTable = (struct ObjectLookup *) (malloc(SzPL * listlength));
      if(BridgeTable == NULL)
         {
         printf("allocation memory exhausted during bridge feature table read operation\n");
         exit(-1);
         }
      }


   if(NumberOfGrids > 0)
      {
      NGT = (struct NewGridLookup *) (malloc(SzNGL * (listlength + 1)));
      if(NGT == NULL)
         {
         printf("allocation memory exhausted during grid table read operation\n");
         exit(-1);
         }
      for(i=0; i<=listlength; i++)
         {
         NGT[i].NumGrids = 0;
         NGT[i].FileNumber = NULL;
         NGT[i].GridIndex = NULL;
         NGT[i].NumRows = NULL;
         NGT[i].NumCols = NULL;
         NGT[i].OnEdge = NULL;
         NGT[i].fileptr = NULL;
         NGT[i].BaseX = NULL;
         NGT[i].BaseY = NULL;
         NGT[i].BaseZ = NULL;
         }
      }
   else
      {
      NGT = NULL;
      }

   FIDindexTable = (struct LindexLookup *) (malloc(listlength * sizeof(struct LindexLookup)));
   if(FIDindexTable == NULL)
      {
      printf("allocation memory exhausted during FID lookup index table initialization operation\n");
      exit(-1);
      }
   for(i=0; i<listlength; i++)
      {
      FIDindexTable[i].inside = 0;
      FIDindexTable[i].indices = NULL;
      }

   LindexTable = (struct LindexLookup *) (malloc(listlength * sizeof(struct LindexLookup)));
   if(LindexTable == NULL)
      {
      printf("allocation memory exhausted during lookup index table read operation\n");
      exit(-1);
      }

   ++MemoryAllocated;


   for(i=0; i<listlength; i++)
      {
      PCdone = ((double) i) / ((double) (listlength * 8));
      PCdone *= 100.0;
      if(NowFormatting == 0)
         InitializationAdvice(PCdone,0.0, 0.0, 0.0, 0.0, 2);
      else
         BuildOpenMenu(0.0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, PCdone,0.0,0.0,0.0,2);

      if(NGA_TYPE == 0)
         {
         PolyTable[i].fileptr = -1;
         PolyTable[i].filenumber = -1;
         PolyTable[i].numinside = 0;
         PolyTable[i].numother = 0;
         PolyTable[i].others = NULL;

         ModelPolyTable[i].fileptr = -1;
         ModelPolyTable[i].filenumber = -1;
         ModelPolyTable[i].numinside = 0;
         ModelPolyTable[i].numother = 0;
         ModelPolyTable[i].others = NULL;

         BridgeTable[i].numinside = 0;
         BridgeTable[i].fileptr = -1;
         BridgeTable[i].filenumber = -1;
         BridgeTable[i].numother = 0;
         BridgeTable[i].others = NULL;
         }

      ArealTable[i].numinside = 0;
      ArealTable[i].fileptr = -1;
      ArealTable[i].numother = 0;
      ArealTable[i].filenumber = -1;
      ArealTable[i].others = NULL;

      LinearTable[i].numinside = 0;
      LinearTable[i].fileptr = -1;
      LinearTable[i].filenumber = -1;
      LinearTable[i].numother = 0;
      LinearTable[i].others = NULL;

      PointTable[i].numinside = 0;
      PointTable[i].fileptr = -1;
      PointTable[i].filenumber = -1;
      PointTable[i].numother = 0;
      PointTable[i].others = NULL;

      BucketsOfNets[i].netnumb = 0;
      BucketsOfNets[i].CL = NULL;
      BucketsOfNets[i].next = NULL;

      }

   if(NGA_TYPE == 0)
      {
      tblin = fopen(tablein,"rb");
      if(tblin == NULL)
         {
         printf("could not open table entry file %s\n",tablein);
         printf("can not continue without this file\n");
         exit(-1);
         }

      i = 0;
      while((feof(tblin) == 0) && (i < listlength))
         {
         SEEIT_fread_int(&PolyTable[i].numinside,tblin);
         SEEIT_fread_long(&PolyTable[i].fileptr,tblin);
         SEEIT_fread_int(&PolyTable[i].numother,tblin);
         if(PolyTable[i].numother > 0)
            {
            PolyTable[i].others = (struct PtrList *) (malloc(PolyTable[i].numother * SzPtrList));
            if(PolyTable[i].others == NULL)
               {
               printf("allocation memory exhausted during polygon table read operation\n");
               exit(-1);
               }
            for(j=0; j< PolyTable[i].numother; j++)
               {
               SEEIT_fread_long(&PolyTable[i].others[j].fileptr,tblin);
               }
            }
            PCdone = ((double) i) / ((double) (listlength * 8));
            PCdone *= 100.0;
            if(NowFormatting == 0)
               InitializationAdvice(PCdone,0.0, 0.0, 0.0, 0.0, 2);
            else
               BuildOpenMenu(0.0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, PCdone,0.0,0.0,0.0,2);

            nonzerobucket += 1;
            ++i;
            }
         fclose(tblin);

         tblin = fopen(MPtablein,"rb");
         if(tblin == NULL)
            {
            printf("could not open model library polygon table entry file %s\n",MPtablein);
            }
         else
            {
            i = 0;
         while((feof(tblin) == 0) && (i < listlength))
            {
            SEEIT_fread_int(&ModelPolyTable[i].numinside,tblin);
            SEEIT_fread_long(&ModelPolyTable[i].fileptr,tblin);
            SEEIT_fread_int(&ModelPolyTable[i].numother,tblin);
            if(ModelPolyTable[i].numother > 0)
               {
               ModelPolyTable[i].others = (struct PtrList *) (malloc(ModelPolyTable[i].numother * SzPtrList));
               if(ModelPolyTable[i].others == NULL)
                  {
                  printf("allocation memory exhausted during model polygon table read operation\n");
                  exit(-1);
                  }
               for(j=0; j< ModelPolyTable[i].numother; j++)
                  {
                  SEEIT_fread_long(&ModelPolyTable[i].others[j].fileptr,tblin);
                  }
               }
            PCdone = ((double) (i + listlength)) / ((double) (listlength * 8));
            PCdone *= 100.0;
            if(NowFormatting == 0)
               InitializationAdvice(PCdone, 0.0, 0.0, 0.0, 0.0, 2);
            else
               BuildOpenMenu(0.0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, PCdone, 0.0,0.0,0.0,2);
            ++i;
            }
         fclose(tblin);
         }
      tblin = fopen(bridgetablein,"rb");
      if(tblin == NULL)
         {
         printf("could not open table entry file %s\n",bridgetablein);
         }
      else
         {
         i = 0;
         while((feof(tblin) == 0) && (i < listlength))
            {
            SEEIT_fread_int(&BridgeTable[i].numinside,tblin);
            SEEIT_fread_long(&BridgeTable[i].fileptr,tblin);
            SEEIT_fread_int(&BridgeTable[i].numother,tblin);
            k = BridgeTable[i].numother;
            if(k > 0)
               {
               BridgeTable[i].others = (struct PtrList *) (malloc(k * SzPtrList));
               if(BridgeTable[i].others == NULL)
                  {
                  printf("allocation memory exhausted during bridge feature table read operation\n");
                  exit(-1);
                  }
               for(j=0; j< k; j++)
                  {
                  SEEIT_fread_long(&BridgeTable[i].others[j].fileptr,tblin);
                  }
               }
            PCdone = ((double) (i + (listlength * 6))) / ((double) (listlength * 8));
            PCdone *= 100.0;
            if(NowFormatting == 0)
               InitializationAdvice(PCdone, 0.0,  0.0, 0.0, 0.0, 2);
            else
               BuildOpenMenu(0.0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,PCdone, 0.0,0.0,0.0,2);
            ++i;
            }
         fclose(tblin);
         }
      }

   tblin = fopen(arealtablein,"rb");
   if(tblin == NULL)
      {
      printf("could not open table entry file %s\n",arealtablein);
      }
   else
      {
      i = 0;
      while((feof(tblin) == 0) && (i < listlength))
         {
         SEEIT_fread_int(&ArealTable[i].numinside,tblin);
         SEEIT_fread_long(&ArealTable[i].fileptr,tblin);
         SEEIT_fread_int(&ArealTable[i].filenumber,tblin);
         if(ArealTable[i].filenumber > MaxInputFileNumber)
            MaxInputFileNumber = ArealTable[i].filenumber;
         SEEIT_fread_int(&ArealTable[i].numother,tblin);
         k = ArealTable[i].numother;
         if(k > 0)
            {
            ArealTable[i].others = (struct PtrList *) (malloc(k * SzPtrList));
            if(ArealTable[i].others == NULL)
               {
               printf("allocation memory exhausted during area feature table read operation\n");
               exit(-1);
               }
            for(j=0; j< k; j++)
               {
               SEEIT_fread_long(&ArealTable[i].others[j].fileptr,tblin);
               SEEIT_fread_int(&ArealTable[i].others[j].filenumber,tblin);
               if(ArealTable[i].others[j].filenumber > MaxInputFileNumber)
                           MaxInputFileNumber = ArealTable[i].others[j].filenumber; 
               }
            }
         PCdone = ((double) (i + (listlength * 2))) / ((double) (listlength * 8));
         PCdone *= 100.0;
         if(NowFormatting == 0)
            InitializationAdvice(PCdone, 0.0, 0.0, 0.0, 0.0, 2);
         else
            BuildOpenMenu(0.0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, PCdone, 0.0, 0.0,0.0,2);
         ++i;
         }
      fclose(tblin);
      }


   if(MaxGridsPerRegion > 0)
      {
      for(i=0; i<MaxGridsPerRegion; i++)
         free(MG[i].Elevs);
      free(MG);
      MaxGridsPerRegion = 0;
      }

   if(RGrid != NULL)
      {
      FreeRGridStructure();
      }

   GridPtsPerRegion = 0;
   MaxGridStack = 0;
   if(NumberOfGrids > 0)
      {
      tblin = fopen(gridtablein,"rb");
      if(tblin == NULL)
         {
         printf("could not open table entry file TestTable.bin\n");
         exit(-1);
         }
      else
         {
         i = 0;
         GridDimension = 0;
         MaxNumNodes = 0;
         maxgrid = mingrid = 0;
         while((feof(tblin) == 0) && (i < listlength))
            {
            SEEIT_fread_int(&NGT[i].NumGrids,tblin);
            if(NGT[i].NumGrids > 0)
               {
               if(NGT[i].NumGrids > NGT[maxgrid].NumGrids)
                  maxgrid = i;
               if(NGT[i].NumGrids < NGT[mingrid].NumGrids)
                  mingrid = i;
               NGT[i].FileNumber = (int *) (malloc(NGT[i].NumGrids * SzI));
               NGT[i].GridIndex = (int *) (malloc(NGT[i].NumGrids * SzI));
               NGT[i].NumRows = (int *) (malloc(NGT[i].NumGrids * SzI));
               NGT[i].NumCols = (int *) (malloc(NGT[i].NumGrids * SzI));
               NGT[i].OnEdge = (char *) (malloc(NGT[i].NumGrids));
               NGT[i].fileptr = (long int *) (malloc(NGT[i].NumGrids * SzL));
               NGT[i].BaseX = (double *) (malloc(NGT[i].NumGrids * SzD));
               NGT[i].BaseY = (double *) (malloc(NGT[i].NumGrids * SzD));
               NGT[i].BaseZ = (double *) (malloc(NGT[i].NumGrids * SzD));
               if(NGT[i].BaseZ == NULL)
                  {
                  printf("allocation memory exhausted during grid table read operation\n");
                  exit(-1);
                  }
               for(k=0; k<NGT[i].NumGrids; k++)
                  {
                  SEEIT_fread_int(&NGT[i].NumRows[k],tblin);
                  SEEIT_fread_int(&NGT[i].NumCols[k],tblin);
                  if(NGT[i].NumCols[k] > MaxGridStack)
                     MaxGridStack = NGT[i].NumCols[k];
                  if(NGT[i].NumRows[k] > MaxGridStack)
                     MaxGridStack = NGT[i].NumRows[k];
                  GridPtsThisRegion = NGT[i].NumRows[k] * NGT[i].NumCols[k];
                  if(GridPtsThisRegion > GridPtsPerRegion)
                     GridPtsPerRegion = GridPtsThisRegion;
                  SEEIT_fread_int(&NGT[i].FileNumber[k],tblin);
                  fread(&NGT[i].OnEdge[k],1,1,tblin);
                  SEEIT_fread_long(&NGT[i].fileptr[k],tblin);
                  SEEIT_fread_int(&NGT[i].GridIndex[k],tblin);
                  SEEIT_fread_double(&NGT[i].BaseX[k],tblin);
                  SEEIT_fread_double(&NGT[i].BaseY[k],tblin);
                  SEEIT_fread_double(&NGT[i].BaseZ[k],tblin);
                  }
               }
            ++i;
            }
         fclose(tblin);
         MaxGridsPerRegion = NGT[maxgrid].NumGrids;


GridDimension = MaxGridStack + 5;

         MG = (struct MultiGrids *) (malloc(sizeof(struct MultiGrids) * MaxGridsPerRegion));
         if(MG == NULL)
            {
            printf("available memory exhausted during preparation for Grid processing\n");
            printf("1) Max Grids per Region: %d Max Nodes per Grid %d\n",MaxGridsPerRegion,GridPtsPerRegion + 2);
            exit(-1);
            }
         else
            {
            for(i=0; i< MaxGridsPerRegion; i++)
               {
               MG[i].idn = -1;
               MG[i].actualindex = -1;
               MG[i].Xspace = 0;
               MG[i].Yspace = 0;
               MG[i].SouthWestX = -1;
               MG[i].SouthWestY = -1;
               MG[i].numX = 0;
               MG[i].numY = 0;
               /***MG[i].Elevs = (double *) (malloc(SzD * GridPtsPerRegion)); ***/
               MaxNumNodes = GridPtsPerRegion + 2;
               MG[i].Elevs = (double *) (malloc(SzD * MaxNumNodes));
               if(MG[i].Elevs == NULL)
                  {
                  printf("available memory exhausted during preparation for Grid processing\n");
                  printf("2) Max Grids per Region: %d Max Nodes per Grid %d\n",MaxGridsPerRegion,MaxNumNodes);
                  exit(-1);
                  }
               for(j=0; j<MaxNumNodes; j++)
                  MG[i].Elevs[j] = -1;
               }
            }

         }

      }

   tblin = fopen(lineartablein,"rb");
   if(tblin == NULL)
      {
      printf("could not open table entry file %s\n",lineartablein);
      }
   else
      {
      i = 0;
      while((feof(tblin) == 0) && (i < listlength))
         {
         SEEIT_fread_int(&LinearTable[i].numinside,tblin);
         SEEIT_fread_long(&LinearTable[i].fileptr,tblin);
         SEEIT_fread_int(&LinearTable[i].filenumber,tblin);
         SEEIT_fread_int(&LinearTable[i].numother,tblin);
         if(LinearTable[i].filenumber > MaxInputFileNumber)
            MaxInputFileNumber = LinearTable[i].filenumber;
         k = LinearTable[i].numother;
         if(k > 0)
            {
            LinearTable[i].others = (struct PtrList *) (malloc(k * SzPtrList));
            if(LinearTable[i].others == NULL)
               {
               printf("allocation memory exhausted during linear feature table read operation\n");
               exit(-1);
               }
            for(j=0; j< k; j++)
               {
               SEEIT_fread_long(&LinearTable[i].others[j].fileptr,tblin);
               SEEIT_fread_int(&LinearTable[i].others[j].filenumber,tblin);
               if(LinearTable[i].others[j].filenumber > MaxInputFileNumber)
                  MaxInputFileNumber = LinearTable[i].others[j].filenumber;
               }
            }
         PCdone = ((double) (i + (listlength * 4))) / ((double) (listlength * 8));
         PCdone *= 100.0;
         if(NowFormatting == 0)
            InitializationAdvice( PCdone,0.0,  0.0, 0.0, 0.0, 2);
         else
            BuildOpenMenu(0.0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, PCdone, 0.0,0.0,0.0,2);
         ++i;
         }
      fclose(tblin);
      }

   MaxInputFileNumber += 2;

   tblin = fopen(pointtablein,"rb");
   if(tblin == NULL)
      {
      printf("could not open table entry file %s\n",pointtablein);
      }
   else
      {
      i = 0;
      while((feof(tblin) == 0) && (i < listlength))
         {
         SEEIT_fread_int(&PointTable[i].numinside,tblin);
         SEEIT_fread_long(&PointTable[i].fileptr,tblin);
         SEEIT_fread_int(&PointTable[i].numother,tblin);
         k = PointTable[i].numother;
         if(k > 0)
            {
            PointTable[i].others = (struct PtrList *) (malloc(k * SzPtrList));
            if(PointTable[i].others == NULL)
               {
               printf("allocation memory exhausted during point feature table read operation\n");
               exit(-1);
               }
            for(j=0; j< k; j++)
               {
               SEEIT_fread_long(&PointTable[i].others[j].fileptr,tblin);
               }
            }
         PCdone = ((double) (i + (listlength * 5))) / ((double) (listlength * 8));
         PCdone *= 100.0;
         if(NowFormatting == 0)
            InitializationAdvice( PCdone, 0.0,  0.0, 0.0, 0.0, 2);
         else
            BuildOpenMenu(0.0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, PCdone, 0.0, 0.0,0.0,2);
         ++i;
         }
      fclose(tblin);
      }

   SCCtable = (struct SCCdata *) (malloc(TotalSCC * SzSCCtable));
   if(SCCtable == NULL)
      {
      printf("allocation memory exhausted during attempt to read %d SCC table entries\n",i);
      exit(-1);
      }
   ReadDynamicDefsFile();


   if(CrsWlk != NULL)
      free(CrsWlk);
   SCC1 = fopen(sccuniquelist,"rb");
   if(SCC1 != NULL)
      {
      CrsWlk = (struct CrossWalk *) (malloc(sizeof(struct CrossWalk) * SACfull));
      if(CrsWlk == NULL)
         {
         printf("memory exhausted during SCC crosswalk setup\n");
         exit(-1);
         }
      for(i=0; i<SACfull; i++)
         {
         CrsWlk[i].toggle = 0;
         CrsWlk[i].FullFilePosn = 0;
         CrsWlk[i].LODband = 0;
         CrsWlk[i].AttrErr = -1;
         CrsWlk[i].geomtype = -1;
         /***CrsWlk[i].count = 0; ***/
         CrsWlk[i].crossindex = -1;
         CrsWlk[i].LtoSmapping = -1;
         CrsWlk[i].MAE = NULL;
         }

      SEEIT_fread_int(&i,SCC1); /** number of entries **/
      NumberOfModels = i;
      MdlNames = (struct ModelNames *) (malloc(i * sizeof(struct ModelNames)));

      if(MdlNames == NULL)
         {
         printf("allocation memory exhausted during SCC & Name read operation\n");
         exit(-1);
         }
      for (j = 0; j< i; j++)
         {

         PCdone = ((double) j) / ((double) i);
         PCdone *= 100.0;
         if(NowFormatting == 0)
             InitializationAdvice(100.0, PCdone, 0.0, 0.0, 0.0, 2);
         else
            BuildOpenMenu(0.0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,100.0, PCdone, 0.0, 0.0,2);

         MdlNames[j].numattributes = 0;
         SEEIT_fread_int(&MdlNames[j].code,SCC1);
         fread(&MdlNames[j].name[0],ModelNameMaxLength,1,SCC1);
         SEEIT_fread_double(&MdlNames[j].occurrences,SCC1);
         SEEIT_fread_int(&MdlNames[j].references,SCC1);
         MdlNames[j].indices = (int *) (malloc(SzI * MdlNames[j].references));
         if(MdlNames[j].indices == NULL)
            {
            printf("allocation memory has been ehausted during ECC template read\n  Can't continue\n");
            exit(-1);
            }
         for(k=0; k<MdlNames[j].references; k++)
            {
            SEEIT_fread_int(&MdlNames[j].indices[k],SCC1);
            CrsWlk[MdlNames[j].indices[k]].crossindex = j;
            }
         SEEIT_fread_int(&MdlNames[j].numuniqueAttr,SCC1);
         SEEIT_fread_int(&MdlNames[j].numattributes,SCC1);
         MdlNames[j].UniqueAttr = (int *) (malloc(SzI * MdlNames[j].numuniqueAttr));
         MdlNames[j].UniqueCounts = (double *) (malloc(SzD * MdlNames[j].numuniqueAttr));
         MdlNames[j].AttrIndices = (int *) (malloc(SzI * MdlNames[j].numattributes));
         MdlNames[j].ValueIndices = (int *) (malloc(SzI * MdlNames[j].numattributes));
         MdlNames[j].LongListIndices = NULL;
         MdlNames[j].ValueCounts = (double *) (malloc(SzD * MdlNames[j].numattributes));
         if(MdlNames[j].ValueCounts == NULL)
            {
            printf("allocation memory has been ehausted during EAC template read\n  Can't continue\n");
            exit(-1);
            }
         for(k=0; k<MdlNames[j].numattributes; k++)
            {
            SEEIT_fread_int(&MdlNames[j].AttrIndices[k],SCC1);
            SEEIT_fread_int(&MdlNames[j].ValueIndices[k],SCC1);
            /***SEEIT_fread_int(&MdlNames[j].LongListIndices[k],SCC1); ***/
            SEEIT_fread_double(&MdlNames[j].ValueCounts[k],SCC1);
            if(NowFormatting == 0)
               InitializationAdvice(100.0, PCdone, 0.0,  0.0, 0.0, 2);
            else
               BuildOpenMenu(0.0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,100.0, PCdone, 0.0, 0.0,2);
            }
         for(k=0; k<MdlNames[j].numuniqueAttr; k++)
            {
            SEEIT_fread_int(&MdlNames[j].UniqueAttr[k],SCC1);
            SEEIT_fread_double(&MdlNames[j].UniqueCounts[k],SCC1);
            }

         }
      fclose(SCC1);
      }


   if(CrsWlk != NULL) /** lets read file with long list to short list mapping **/
      {
      SCC1 = fopen(StoLmapping,"rb");
      if(SCC1 != NULL)
         {
         SEEIT_fread_int(&j,SCC1); /** should be an in-order long list index, 0 - SACfull **/
         while(feof(SCC1) == 0)
            {
            if(j >= SACfull)
               {
               printf("FATAL ERROR!! bad mapping from EA list to EC list!!\n");
               exit(-1);
               }
            SEEIT_fread_int(&k,SCC1); /** should be a frequency count of that LLentry **/
            SEEIT_fread_int(&CrsWlk[j].LtoSmapping,SCC1); /** corresponding short list index **/
            SEEIT_fread_int(&j,SCC1); /** next long list index **/
            }
         fclose(SCC1);
         }
      }



   sprintf(junk,"%seaclookup.bin",indirectory);
   SCC1 = fopen(junk,"rb");
   SEEIT_fread_int(&NumberOfAttributesEntries,SCC1); /** number of unique attributes **/
   MdlNames2 = (struct AttrList *) (malloc( NumberOfAttributesEntries * sizeof(struct AttrList)));

   if(MdlNames2 == NULL)
      {
      printf("allocation memory exhausted during EAC read operation\n");
      exit(-1);
      }

   for (j = 0; j< NumberOfAttributesEntries; j++)
      {
      PCdone = ((double) j) / ((double) NumberOfAttributesEntries);
      PCdone *= 100.0;
      if(NowFormatting == 0)
         InitializationAdvice(100.0, 100.0, PCdone, 0.0,  0.0, 2);
      else
         BuildOpenMenu(0.0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,100.0, 100.0, PCdone, 0.0,2);

      SEEIT_fread_double(&MdlNames2[j].occurrences,SCC1);
      SEEIT_fread_int(&MdlNames2[j].code,SCC1);
      SEEIT_fread_int(&MdlNames2[j].count,SCC1);
      if(MdlNames2[j].count == 0)
         MdlNames2[j].values = NULL;
      else
         MdlNames2[j].values = (struct AttrValList *) (malloc(SzAV * MdlNames2[j].count));
      if((MdlNames2[j].count > 0) && (MdlNames2[j].values == NULL))
         {
         printf("allocation memory has been ehausted during EAC values array template read\n  Can't continue\n");
         printf("# of attribute entries %d offending count for malloc %d\n",NumberOfAttributesEntries,MdlNames2[j].count);
         exit(-1);
         }
      for(k=0; k<MdlNames2[j].count; k++)
         {
         if(NowFormatting == 0)
            InitializationAdvice(100.0, 100.0, PCdone, 0.0,  0.0, 2);
         else
            BuildOpenMenu(0.0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,100.0, 100.0, PCdone, 0.0, 2);

         SEEIT_fread_double(&MdlNames2[j].values[k].occurrences,SCC1);
         SEEIT_fread_double(&MdlNames2[j].values[k].uniqueoccurrences,SCC1);
         /**SEEIT_fread_double(&MdlNames2[j].values[k].value,SCC1); ***/
         SEEIT_fread_int(&MdlNames2[j].values[k].type,SCC1);
         SEEIT_fread_int(&MdlNames2[j].values[k].uom,SCC1);
         SEEIT_fread_int(&MdlNames2[j].values[k].scale,SCC1);
         SEEIT_fread_double(&MdlNames2[j].values[k].value,SCC1);
         if(MdlNames2[j].values[k].type == 2) /** a string value follows **/
            {
            MdlNames2[j].values[k].label = (char *) (malloc((int) MdlNames2[j].values[k].value + 3));
            if(MdlNames2[j].values[k].label == NULL)
               {
               printf("allocation memory has been ehausted during EAC values array template read\n  Can't continue\n");
               printf("# of attribute entries %d offending count for char malloc %d\n",NumberOfAttributesEntries,(int)MdlNames2[j].values[k].value);
               exit(-1);
               }
            for(kk=0; kk<MdlNames2[j].values[k].value + 3; kk++)
               MdlNames2[j].values[k].label[kk] = '\0';
            fread(&MdlNames2[j].values[k].label[0],1,(int) MdlNames2[j].values[k].value, SCC1);
            }
         else
            MdlNames2[j].values[k].label = NULL;
         if((MdlNames2[j].values[k].type == 5) || (MdlNames2[j].values[k].type == 6) ||
              (MdlNames2[j].values[k].type == 7)) /*** an interval ***/
            {
            SEEIT_fread_double(&MdlNames2[j].values[k].value2,SCC1);
            SEEIT_fread_int(&MdlNames2[j].values[k].intervaltype,SCC1);
            }
         else
            {
            MdlNames2[j].values[k].value2 = -1;
            MdlNames2[j].values[k].intervaltype = -1;
            }

         SEEIT_fread_int(&MdlNames2[j].values[k].LLindexcount,SCC1);
         if(MdlNames2[j].values[k].LLindexcount > 0)
            {
            MdlNames2[j].values[k].LongListIndices = (int *) (malloc(SzI * MdlNames2[j].values[k].LLindexcount));
            if(MdlNames2[j].values[k].LongListIndices == NULL)
               {
               printf("allocation memory has been ehausted during EAC values array template read\n  Can't continue\n");
               printf("# of attribute entries %d offending LLindexcount %d\n",NumberOfAttributesEntries,MdlNames2[j].values[k].LLindexcount);
 
               exit(-1);
               }
            for(kk=0; kk<MdlNames2[j].values[k].LLindexcount; kk++)
               {
               SEEIT_fread_int(&MdlNames2[j].values[k].LongListIndices[kk],SCC1);
               if(NowFormatting == 0)
                  InitializationAdvice(100.0, 100.0, PCdone, 0.0,  0.0, 2);
               else
                  BuildOpenMenu(0.0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,100.0, 100.0, PCdone, 0.0, 2);


               }
            }
         else
            MdlNames2[j].values[k].LongListIndices = NULL;

         SEEIT_fread_int(&MdlNames2[j].values[k].UniqueLLindexcount,SCC1);
         /***if(MdlNames2[j].values[k].UniqueLLindexcount > MdlNames2[j].values[k].LLindexcount) ***/
        if(MdlNames2[j].values[k].UniqueLLindexcount > 0)
            {
            MdlNames2[j].values[k].UniqueLLindices = (int *) (malloc(SzI * MdlNames2[j].values[k].UniqueLLindexcount));
            if(MdlNames2[j].values[k].UniqueLLindices == NULL)
               {
               printf("allocation memory has been ehausted during EAC values array template read\n  Can't continue\n");
               exit(-1);
               }
            for(kk=0; kk<MdlNames2[j].values[k].UniqueLLindexcount; kk++)
               {
               SEEIT_fread_int(&MdlNames2[j].values[k].UniqueLLindices[kk],SCC1);
               if(NowFormatting == 0)
                  InitializationAdvice(100.0, 100.0, PCdone, 0.0,  0.0, 2);
               else
                  BuildOpenMenu(0.0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,100.0, 100.0, PCdone, 0.0, 2);


               }

            }
         else
            {
            MdlNames2[j].values[k].UniqueLLindices = NULL;
            for(kk=0; kk<MdlNames2[j].values[k].UniqueLLindexcount; kk++)
               {
               SEEIT_fread_int(&kk2,SCC1);
               if(NowFormatting == 0)
                  InitializationAdvice(100.0, 100.0, PCdone,0.0, 0.0, 2);
               else
                  BuildOpenMenu(0.0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,100.0, 100.0, PCdone, 0.0, 2);
               }
            }
         }
      }
   fclose(SCC1);


   sprintf(junk,"%scodesfull.bin",indirectory);
   SCC1 = fopen(junk,"rb");
   if(SCC1 == NULL)
      {
      printf("could not find required file %s\n",junk);
      exit(-1);
      }
   for(i=0; i<SACfull; i++)
      {
      CrsWlk[i].FullFilePosn = ReadCodesFullEntry(&CrsWlk[i].geomtype, 0, SCC1,0);
      PCdone = ((double) i) / ((double) SACfull);
      PCdone *= 100.0;
      if(NowFormatting == 0)
         InitializationAdvice(100.0, 100.0, 100.0, PCdone, 0.0, 2);
      else
         BuildOpenMenu(0.0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,100, 100.0, 100.0, 100.0, PCdone, 2);
      }
   fclose(SCC1);

   SCC1 = fopen(scctablefile,"rb");
   if(SCC1 != NULL)
      {
      for(i=0; i<listlength; i++)
         {
         PCdone = ((double) i) / ((double) listlength);
         PCdone *= 50.0;
         if(NowFormatting == 0)
            InitializationAdvice(100.0, 100.0, 100.0, 100.0, PCdone, 2);
         else
            BuildOpenMenu(0.0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,(int) PCdone,100.0, 100.0, 100.0, 100.0,2);

         SEEIT_fread_int(&j,SCC1);
         if(j != i)
            {
            printf("index misallignment during ECC index table read, %d not equal to %d\n",j,i);
            exit(-1);
            }
         SEEIT_fread_int(&LindexTable[i].inside,SCC1);
         if(LindexTable[i].inside > 0)
            LindexTable[i].indices = (int *) (malloc(SzI * LindexTable[i].inside));
         else
            LindexTable[i].indices = NULL;
         for(j=0; j< LindexTable[i].inside; j++)
            {
            SEEIT_fread_int(&LindexTable[i].indices[j],SCC1);
            }
         }
      fclose(SCC1);
      }

   if(NGA_TYPE == 0)
      {
      FreeAttrErrStruct();
      }
   AttrErr = NULL;
   NumAttrErr = 0;

   if(NGA_TYPE == 0)
      {
      ReadRecordedAttributionErrorIndices();
      }

   SCC1 = fopen(LODbands,"rb");
   if(SCC1 != NULL)
      {
      SEEIT_fread_int(&NumLODbands,SCC1);
      if(NumLODbands > 0)
         {
         LODindex = (struct LODdisplay *) (malloc(sizeof(struct LODdisplay) * NumLODbands));
         if(LODindex == NULL)
            {
            printf("allocation memory exhausted during LOD band read operation\n");
            printf("no further processing is possible without additional memory\n");
            exit(-1);
            }
         }
      else
         LODindex = NULL;
      for(j=0; j<NumLODbands; j++)
         {
         LODindex[j].temp_color = -1;
         LODindex[j].color = -1;

         LODindex[j].active = 1;
         for(i=0; i<NUM_C; i++)
            LODindex[j].geomtype[i] = 0;

         SEEIT_fread_int(&i,SCC1); /**  title string length **/
         LODindex[j].title = (char *) (malloc(i + 1));
         if(LODindex[j].title == NULL)
            {
            printf("allocation memory exhausted during LOD band read operation\n");
            printf("no further processing is possible without additional memory\n");
            exit(-1);
            }
         fread(&LODindex[j].title[0],1,i,SCC1);
         SEEIT_fread_int(&k,SCC1); /** number of Lindex references **/
         for(i=0; i<k; i++)
            {
            SEEIT_fread_int(&ii,SCC1);
            
            CrsWlk[ii].LODband = j + 1;
            if(CrsWlk[ii].geomtype < NUM_C)
               LODindex[j].geomtype[CrsWlk[ii].geomtype] += 1; /** count not really interesting, just non-zero useful **/
            else
               {
               printf("Cross Walk LOD band indexing exception\n");
               exit(-1);
               }
            }
         }
      
      fclose(SCC1);
      }


   if(NGA_TYPE == 1)
     {
     if((ATTRTYPE_D4() > 0) || (ATTRTYPE_FACC() > 0) || (ATTRTYPE_VMAP() > 0) ||
        (ATTRTYPE_UFD1() > 0) || (ATTRTYPE_UFD2() > 0) || (ATTRTYPE_UFD3() > 0))
        {
        NumMetaDataCodes = 32;
        if(MetaDataAttrCodes != NULL)
           free(MetaDataAttrCodes);
        MetaDataAttrCodes = (int *) (malloc(SzI * NumMetaDataCodes));
        if(MetaDataAttrCodes == NULL)
           NumMetaDataCodes = 0;
        else
           {
           MetaDataAttrCodes[0] = GetNum2("Absolute Circular Error");
           MetaDataAttrCodes[1] = GetNum2("Absolute Circular Error Evaluation Method");
           MetaDataAttrCodes[2] = GetNum2("Absolute Linear Error");
           MetaDataAttrCodes[3] = GetNum2("Absolute Linear Error Evaluation Method");
           MetaDataAttrCodes[4] = GetNum2("Comments");
           MetaDataAttrCodes[5] = GetNum2("Commercial Copyright Notice");
           MetaDataAttrCodes[6] = GetNum2("Distribution of Commercial Data");
           MetaDataAttrCodes[7] = GetNum2("Feature Creation Date");
           MetaDataAttrCodes[8] = GetNum2("Completeness Code");
           MetaDataAttrCodes[9] = GetNum2("Operator ID");
           MetaDataAttrCodes[10] = GetNum2("Originating Source Date");
           MetaDataAttrCodes[11] = GetNum2("Originating Source Information");
           MetaDataAttrCodes[12] = GetNum2("Originating Source Name");
           MetaDataAttrCodes[13] = GetNum2("Agency that Supplied the Data");
           MetaDataAttrCodes[14] = GetNum2("Restriction Declassification Exemptions");
           MetaDataAttrCodes[15] = GetNum2("Restriction Declassification");
           MetaDataAttrCodes[16] = GetNum2("Restrictions on Dissemination Control IC");
           MetaDataAttrCodes[17] = GetNum2("Restrictions on Dissemination Control Non-IC");
           MetaDataAttrCodes[18] = GetNum2("Restrctions on Foreign Government Access");
           MetaDataAttrCodes[19] = GetNum2("Restrictions on Releasibility");
           MetaDataAttrCodes[20] = GetNum2("Feature Scale (e.g., 50000, 100000)");
           MetaDataAttrCodes[21] = GetNum2("Security Codeword Control");
           MetaDataAttrCodes[22] = GetNum2("Security Classification");
           MetaDataAttrCodes[23] = GetNum2("Security Classification System Identifier");
           MetaDataAttrCodes[24] = GetNum2("Non-standard Classification Authority");
           MetaDataAttrCodes[25] = GetNum2("Multiple Classification Authority Sources");
           MetaDataAttrCodes[26] = GetNum2("Classification Authority");
           MetaDataAttrCodes[27] = GetNum2("Extraction Specification ID");
           MetaDataAttrCodes[28] = GetNum2("Update/Review Source Name");
           MetaDataAttrCodes[29] = GetNum2("Update/Review Source Date");
           MetaDataAttrCodes[30] = GetNum2("Update/Review Source Information");
           MetaDataAttrCodes[31] = GetNum2("Z-Coordinate Type");
           }
        }
     else if(ATTRTYPE_MGCP3() > 0)  /*** MGCP ***/
        {
        NumMetaDataCodes = 16;
        if(MetaDataAttrCodes != NULL)
           free(MetaDataAttrCodes);
        MetaDataAttrCodes = (int *) (malloc(SzI * NumMetaDataCodes));
        if(MetaDataAttrCodes == NULL)
           NumMetaDataCodes = 0;
        else
           {
           MetaDataAttrCodes[0] = GetNum2("Horizontal Accuracy Category");
           MetaDataAttrCodes[1] = GetNum2("Absolute Horizontal Accuracy");
           MetaDataAttrCodes[2] = GetNum2("Absolute Horizontal Accuracy Evaluation Method");
           MetaDataAttrCodes[3] = GetNum2("Absolute Vertical Accuracy");
           MetaDataAttrCodes[4] = GetNum2("Absolute Vertical Accuracy Evaluation Method");
           MetaDataAttrCodes[5] = GetNum2("Commercial Copyright Notice");
           MetaDataAttrCodes[6] = GetNum2("Source Date and Time");
           MetaDataAttrCodes[7] = GetNum2("Source Description");
           MetaDataAttrCodes[8] = GetNum2("Source Type");
           MetaDataAttrCodes[9] = GetNum2("Commercial Distribution Restriction");
           MetaDataAttrCodes[10] = GetNum2("Associated Text");
           MetaDataAttrCodes[11] = GetNum2("MGCP Feature universally unique identifier");
           MetaDataAttrCodes[12] = GetNum2("Review Source Date and Time");
           MetaDataAttrCodes[13] = GetNum2("Review Source Description");
           MetaDataAttrCodes[14] = GetNum2("Review Source Type");
           MetaDataAttrCodes[15] = GetNum2("Vertical Source Category");
           }
        }
     else if(ATTRTYPE_MGCP4() > 0)  /*** MGCP V4 ***/
        {
        NumMetaDataCodes = 7;
        if(MetaDataAttrCodes != NULL)
           free(MetaDataAttrCodes);
        MetaDataAttrCodes = (int *) (malloc(SzI * NumMetaDataCodes));
        if(MetaDataAttrCodes == NULL)
           NumMetaDataCodes = 0;
        else
           {
           MetaDataAttrCodes[0] = GetNum2("Horizontal Accuracy Category");
           MetaDataAttrCodes[1] = GetNum2("Commercial Copyright Notice");
           MetaDataAttrCodes[2] = GetNum2("Source Date and Time");
           MetaDataAttrCodes[3] = GetNum2("Source Description");
           MetaDataAttrCodes[4] = GetNum2("Source Type");
           MetaDataAttrCodes[5] = GetNum2("Associated Text");
           MetaDataAttrCodes[6] = GetNum2("MGCP Feature universally unique identifier");
           }
        }

     else if(ATTRTYPE_TDS4() > 0)
        {
        NumMetaDataCodes = 33;
        if(MetaDataAttrCodes != NULL)
           free(MetaDataAttrCodes);
        MetaDataAttrCodes = (int *) (malloc(SzI * NumMetaDataCodes));
        if(MetaDataAttrCodes == NULL)
           NumMetaDataCodes = 0;
        else
           {
           MetaDataAttrCodes[0] = GetNum2("Absolute Vertical Accuracy (90%)");
           MetaDataAttrCodes[1] = GetNum2("Cell Identifier");
           MetaDataAttrCodes[2] = GetNum2("Cell Partition Scheme");
           MetaDataAttrCodes[3] = GetNum2("Data Quality Statement");
           MetaDataAttrCodes[4] = GetNum2("Equivalent Scale Category");
           MetaDataAttrCodes[5] = GetNum2("Extraction Specification");
           MetaDataAttrCodes[6] = GetNum2("Extraction Specification Version");
           MetaDataAttrCodes[7] = GetNum2("Elevation Vertical Accuracy (90%)");
           MetaDataAttrCodes[8] = GetNum2("Height Vertical Accuracy (90%)");
           MetaDataAttrCodes[9] = GetNum2("Geodetic Datum");
           MetaDataAttrCodes[10] = GetNum2("ISO 3166-1 Country Code (alpha3)");
           MetaDataAttrCodes[11] = GetNum2("Maintenance Date and Time");
           MetaDataAttrCodes[12] = GetNum2("Memorandum");
           MetaDataAttrCodes[13] = GetNum2("Specified Domain Values(s)");
           MetaDataAttrCodes[14] = GetNum2("Resource Content Originator");
           MetaDataAttrCodes[15] = GetNum2("Unique Entity Identifier");
           MetaDataAttrCodes[16] = GetNum2("Unique Resource Identifier");
           MetaDataAttrCodes[17] = GetNum2("Vertical Datum");
           MetaDataAttrCodes[18] = GetNum2("Source Information : Non-spatial Source Date and Time");
           MetaDataAttrCodes[19] = GetNum2("Source Information : Non-spatial Source Description");
           MetaDataAttrCodes[20] = GetNum2("Source Information : Non-spatial Source Type");
           MetaDataAttrCodes[21] = GetNum2("Source Information : Spatial Source Date and Time");
           MetaDataAttrCodes[22] = GetNum2("Source Information : Spatial Source Description");
           MetaDataAttrCodes[23] = GetNum2("Source Information : Spatial Source Type");
           MetaDataAttrCodes[24] = GetNum2("Source Information : Vertical Source Category");
           MetaDataAttrCodes[25] = GetNum2("Source Information : Vertical Source Date and Time");
           MetaDataAttrCodes[26] = GetNum2("Source Information : Vertical Source Description");
           MetaDataAttrCodes[27] = GetNum2("Restriction Information : Commercial Copyright Notice");
           MetaDataAttrCodes[28] = GetNum2("Restriction Information : Commercial Distribution Restriction");
           MetaDataAttrCodes[29] = GetNum2("Process Step Information : Process Step Description");
           MetaDataAttrCodes[30] = GetNum2("Restriction Information : Security Attributes Group (resource classification)");
           MetaDataAttrCodes[31] = GetNum2("Restriction Information : Security Attributes Group (resource non-intelligence community markings)");
           MetaDataAttrCodes[32] = GetNum2("Restriction Information : Security Attributes Group (resource owner-producer)");
           }
        }
/**** Note that TDS6 does not have any designated metadata attributes - all done at the feature level ***/
     else if(ATTRTYPE_SAC() > 0) /*** SAC ***/
        {
        NumMetaDataCodes = 14;
        if(MetaDataAttrCodes != NULL)
           free(MetaDataAttrCodes);
        MetaDataAttrCodes = (int *) (malloc(SzI * NumMetaDataCodes));
        if(MetaDataAttrCodes == NULL)
           NumMetaDataCodes = 0;
        else
           {
           MetaDataAttrCodes[0] = GetNum2("World Aeronautical Chart-Installation Number");
           MetaDataAttrCodes[1] = GetNum2("Source Type Code");
           MetaDataAttrCodes[2] = GetNum2("Absolute Latitude Accuracy in Meters (WGS84)");
           MetaDataAttrCodes[3] = GetNum2("Absolute Longitude Accuracy in Meters (WGS84)");
           MetaDataAttrCodes[4] = GetNum2("Absolute Ellipsoid Height Accuracy in Meters");
           MetaDataAttrCodes[5] = GetNum2("Absolute Orthometric Height Accuracy in Meters");
           MetaDataAttrCodes[6] = GetNum2("Remarks");
           MetaDataAttrCodes[7] = GetNum2("Ellipsoid Height (Feet)");
           MetaDataAttrCodes[8] = GetNum2("Ellipsoid Height (Meters)");
           MetaDataAttrCodes[9] = GetNum2("Geoid Elevation (Feet)");
           MetaDataAttrCodes[10] = GetNum2("Geoid Elevation (Meters)");
           MetaDataAttrCodes[11] = GetNum2("Classification");
           MetaDataAttrCodes[12] = GetNum2("Releasability");
           MetaDataAttrCodes[13] = GetNum2("Universally Unique Identifier");
           }
        }
     else if(ATTRTYPE_ANY_GGDM() > 0) /*** GGDM ***/
        {
/*** for GGDM 2.2 ***/
        NumMetaDataCodes = 0;
        MetaDataAttrCodes = NULL;
        }
     }


      if(NowFormatting == 0)
         InitializationAdvice(100.0, 100.0, 100.0, 100.0, 100.0, 3);
}  /*** end SetUpTable **/





char * LODelevDiffCheckOK(void)
{
static char answer[1000];
#if (NGA_TYPE == 0)
int i,j,k;
FILE *AttrErrFile;
char AttrInSpec[500];
#endif


   answer[0] = '\0'; /** convention for OK to proceed, otherwise, answer contains an error message ***/
#if (NGA_TYPE == 0)
   if((NGA_TYPE == 0) && (ErrorLookup[ATTRERR].active == 1) && (AttributionAnalysisComplete == 0))
      {
      ConstructFileNames(indirectory, 0);
      sprintf(AttrInSpec,"%s%s",indirectory,allowedSAC);

      AttrErrFile = fopen(AttrInSpec,"rt");
      if(AttrErrFile == NULL)
         CheckAssignedSAC(allowedSAC,SACfull);
      else
         {
         fclose(AttrErrFile);

         CheckAssignedSAC(AttrInSpec,SACfull);
         }

      ReleaseFileNames(0);
      AttrErrFile = fopen(attrgigs,"rb");
      if(AttrErrFile != NULL)
         {
         AttributionAnalysisComplete = 1;
         SEEIT_fread_int(&i,AttrErrFile);
         NumAttrErr = i;
         printf("number of recorded attribution discrepancies: %d\n",NumAttrErr);
         if(i > 0)
            {
            AttrErr = (struct AttributionErrors *) (malloc(sizeof(struct AttributionErrors) * i));
            if(AttrErr == NULL)
               {
               printf("allocation memory exhausted during attempt to read attribution errors text descriptions\n");
               exit(-1);
               }
            for(j=0; j<i; j++)
               {
               SEEIT_fread_int(&k,AttrErrFile);
               AttrErr[j].description = (char *) (malloc(k + 5));
               fread(&AttrErr[j].description[0],1,k,AttrErrFile);
               AttrErr[j].description[k] = '\0';
               printf("(%d) %s\n",j+1,AttrErr[j].description);
               }
            SEEIT_fread_int(&j,AttrErrFile);
            SEEIT_fread_int(&k,AttrErrFile);
            while(feof(AttrErrFile) == 0)
               {
               if(AttrErr[k].description[0] != '*')
                  {
                  CrsWlk[j].AttrErr = k;
                  }
               SEEIT_fread_int(&j,AttrErrFile);
               SEEIT_fread_int(&k,AttrErrFile);
               }
            }
         else
            AttrErr = NULL;
         fclose(AttrErrFile);
         }
      else
         {
         strcat(answer,"\n\nCondition analysis \"Attribution\" is active\n\n");
         strcat(answer,"The file ");
         strcat(answer,indirectory);
         strcat(answer,"attribution.txt\n");
         strcat(answer,"is required to provide the specification for this analyses\n");
         strcat(answer,"and it could not be found\n");
         strcat(answer,"No condition analyses will be completed until this file\n");
         strcat(answer,"becomes available or the \"Attribution\" analysis is not active\n");
         }
      }
#endif

   return(answer);
}




void MakeInputFileNames()
{
int namesize;
FILE *fpin;
char headerfile[500];
char c;
double d;
long int li;
int i;

   FreeMemoryAsExit(2); 

   namesize = strlen(indirectory) + 50;

   if(infile != NULL)
      free(infile);
   infile  = (char *) (malloc(namesize));
   sprintf(infile,"%ssingleregion.bin",indirectory);

   if(tablein != NULL)
      free(tablein);
   tablein  = (char *) (malloc(namesize));
   sprintf(tablein,"%spolytable.bin",indirectory);

   if(allowedSAC != NULL)
      free(allowedSAC);
   allowedSAC  = (char *) (malloc(namesize));
   sprintf(allowedSAC,"%sattribution.txt",indirectory);

   if(arealtablein != NULL)
      free(arealtablein);
   arealtablein  = (char *) (malloc(namesize));
   sprintf(arealtablein,"%sarealtable.bin",indirectory);

   if(arealsin != NULL)
      free(arealsin);
   arealsin  = (char *) (malloc(namesize));
   sprintf(arealsin,"%sarealdata.bin",indirectory);

   if(ConflateSourceFiles != NULL)
      free(ConflateSourceFiles);
   ConflateSourceFiles = (char *) (malloc(namesize));
   sprintf(ConflateSourceFiles,"%s",GetFileNamefile());

   if(arealholesin != NULL)
      free(arealholesin);
   arealholesin  = (char *) (malloc(namesize));
   sprintf(arealholesin,"%sarealhole.bin",indirectory);

   if(MPtablein != NULL)
      free(MPtablein);
   MPtablein  = (char *) (malloc(namesize));
   sprintf(MPtablein,"%smodelpolytable.bin",indirectory);

   if(MPdatain != NULL)
      free(MPdatain);
   MPdatain  = (char *) (malloc(namesize));
   sprintf(MPdatain,"%smodelpolydata.bin",indirectory);

   if(gridtablein != NULL)
      free(gridtablein);
   gridtablein  = (char *) (malloc(namesize));
   sprintf(gridtablein,"%sgridtable.bin",indirectory);

   if(gridsin != NULL)
      free(gridsin);
   gridsin  = (char *) (malloc(namesize));
   sprintf(gridsin,"%sgriddata.bin",indirectory);
   /****UseRGridStruct = 0; ***/

   if(gridheaderin != NULL)
      free(gridheaderin);
   gridheaderin  = (char *) (malloc(namesize));
   sprintf(gridheaderin,"%sgridheader.bin",indirectory);

   if(IDproblems != NULL)
      free(IDproblems);
   IDproblems  = (char *) (malloc(namesize));
   sprintf(IDproblems,"%sID_Overload.txt",indirectory);

   if(gridtopimage != NULL)
      free(gridtopimage);
   gridtopimage  = (char *) (malloc(namesize));
   if(SLASHTYPE == DOS_TYPE)
      {
      sprintf(gridtopimage,"%sbitmaps\\GridLayer",indirectory);
      }
   else
      {
      sprintf(gridtopimage,"%sbitmaps/GridLayer",indirectory);
      }

   if(lineartablein != NULL)
      free(lineartablein);
   lineartablein  = (char *) (malloc(namesize));
   sprintf(lineartablein,"%slineartable.bin",indirectory);

   if(linearsin != NULL)
      free(linearsin);
   linearsin  = (char *) (malloc(namesize));
   sprintf(linearsin,"%slineardata.bin",indirectory);

   if(pointtablein != NULL)
      free(pointtablein);
   pointtablein  = (char *) (malloc(namesize));
   sprintf(pointtablein,"%spointtable.bin",indirectory);

   if(pointsin != NULL)
      free(pointsin);
   pointsin  = (char *) (malloc(namesize));
   sprintf(pointsin,"%spointdata.bin",indirectory);

   if(bridgesin != NULL)
      free(bridgesin);
   bridgesin  = (char *) (malloc(namesize));
   sprintf(bridgesin,"%sbridgedata.bin",indirectory);

   if(bridgetablein != NULL)
      free(bridgetablein);
   bridgetablein  = (char *) (malloc(namesize));
   sprintf(bridgetablein,"%sbridgetable.bin",indirectory);

   if(modelsin != NULL)
      free(modelsin);
   modelsin  = (char *) (malloc(namesize));
   sprintf(modelsin,"%sallmodels.bin",indirectory);

   if(modeltablein != NULL)
      free(modeltablein);
   modeltablein  = (char *) (malloc(namesize));
   sprintf(modeltablein,"%smodeltable.bin",indirectory);

   if(SCCdefsfile != NULL)
      free(SCCdefsfile);
   SCCdefsfile  = (char *) (malloc(namesize));
   sprintf(SCCdefsfile,"%sdynamicdefs.bin",indirectory);

   if(metadata != NULL)
      free(metadata);
   metadata  = (char *) (malloc(namesize));
   sprintf(metadata,"%sheader.bin",indirectory);

   if(LODbands != NULL)
      free(LODbands);
   LODbands  = (char *) (malloc(namesize));
   sprintf(LODbands,"%sLODbands.bin",indirectory);

   if(sccuniquelist != NULL)
      free(sccuniquelist);
   sccuniquelist  = (char *) (malloc(namesize));
   sprintf(sccuniquelist,"%secclist.bin",indirectory);

   if(StoLmapping != NULL)
      free(StoLmapping);
   StoLmapping  = (char *) (malloc(namesize));
   sprintf(StoLmapping,"%sLLfrequency.bin",indirectory);

   if(scctablefile != NULL)
      free(scctablefile);
   scctablefile  = (char *) (malloc(namesize));
   sprintf(scctablefile,"%secclookup.bin",indirectory);

   if(fidtablefile != NULL)
      free(fidtablefile);
   fidtablefile  = (char *) (malloc(namesize));
   sprintf(fidtablefile,"%sfidlookup.bin",indirectory);

   if(attrgigs != NULL)
      free(attrgigs);
   attrgigs = (char *) (malloc(namesize));
   sprintf(attrgigs,"%sattproblems.bin",indirectory);

   if(fin != NULL)
      {
      fclose(fin);
      fin = NULL;
      }

   if(NGA_TYPE > 0)
      {
      sprintf(headerfile,"%sheader.bin",indirectory);
      fpin = fopen(headerfile,"rb");
      if(fpin == NULL)
         {
         printf("required file %s could not be located\n",headerfile);
         printf("terminating\n");
         exit(-1);
         }


      sprintf(headerfile,"%s.hdr",binsmrylog);
         
      binsmryout = fopen(headerfile,"wb");

      c = (char) file_endianness;
      fwrite(&c,1,1,binsmryout);

      SEEIT_fwrite_int(&SmryMagic,binsmryout); /** use as a magic number ***/
      fread(&c,SzUC,1,fpin);
      fwrite(&c,SzUC,1,binsmryout); /** cood syst type ***/
      SEEIT_fread_double(&d,fpin);
      SEEIT_fwrite_double(&d,binsmryout);   /***MinXcoord***/

      SEEIT_fread_double(&d,fpin);
      SEEIT_fwrite_double(&d,binsmryout);  /***MinYcoord***/

      SEEIT_fread_double(&d,fpin);
      SEEIT_fwrite_double(&d,binsmryout);  /***MaxXcoord***/

      SEEIT_fread_double(&d,fpin);
      SEEIT_fwrite_double(&d,binsmryout);  /***MaxYcoord***/

      SEEIT_fread_double(&d,fpin);
      SEEIT_fwrite_double(&d,binsmryout);  /***minX***/

      SEEIT_fread_double(&d,fpin);
      SEEIT_fwrite_double(&d,binsmryout);  /***minY***/

      SEEIT_fread_double(&d,fpin);
      SEEIT_fwrite_double(&d,binsmryout);  /***maxX***/

      SEEIT_fread_double(&d,fpin);
      SEEIT_fwrite_double(&d,binsmryout);  /***maxY ***/

      SEEIT_fread_long(&li,fpin);
      SEEIT_fwrite_long(&li,binsmryout);    /***ttlpolys***/

      SEEIT_fread_long(&li,fpin);
      SEEIT_fwrite_long(&li,binsmryout);    /***ttlgridpoints***/

      SEEIT_fread_long(&li,fpin);
      SEEIT_fwrite_long(&li,binsmryout);    /***pointverts***/

      SEEIT_fread_long(&li,fpin);
      SEEIT_fwrite_long(&li,binsmryout);    /***lineverts***/

      SEEIT_fread_long(&li,fpin);
      SEEIT_fwrite_long(&li,binsmryout);    /***arealverts***/

      SEEIT_fread_int(&i,fpin);
      SEEIT_fwrite_int(&i,binsmryout);     /****numgrids***/

      SEEIT_fread_int(&i,fpin);
      SEEIT_fwrite_int(&i,binsmryout);     /****si1***/

      SEEIT_fread_int(&i,fpin);
      SEEIT_fwrite_int(&i,binsmryout);     /****si2***/

      SEEIT_fread_double(&d,fpin);
      SEEIT_fwrite_double(&d,binsmryout);      /****LRegionSize ****/

      SEEIT_fread_double(&d,fpin);
      SEEIT_fwrite_double(&d,binsmryout);      /****MinXcoord ****/

      SEEIT_fread_double(&d,fpin);
      SEEIT_fwrite_double(&d,binsmryout);      /****MinYcoord ****/

      SEEIT_fread_double(&d,fpin);
      SEEIT_fwrite_double(&d,binsmryout);      /****MaxXcoord ****/

      SEEIT_fread_double(&d,fpin);
      SEEIT_fwrite_double(&d,binsmryout);      /****MaxYcoord ****/

      SEEIT_fread_int(&i,fpin);
      SEEIT_fwrite_int(&i,binsmryout);     /****XindexExtent***/

      SEEIT_fread_int(&i,fpin);
      SEEIT_fwrite_int(&i,binsmryout);     /****YindexExtent***/

      SEEIT_fread_double(&d,fpin);
      SEEIT_fwrite_double(&d,binsmryout);      /****Xtranslation ****/

      SEEIT_fread_double(&d,fpin);
      SEEIT_fwrite_double(&d,binsmryout);      /****Ytranslation ****/

      fclose(fpin);
      fclose(binsmryout);
      }

   binsmryout = NULL;
}


int ZeroNetworkFile(char filename[])
{
int zeroval;
int answer = 1;
FILE *nettemp;

   zeroval = 0;
   nettemp = fopen(filename,"wb");
   if(nettemp == NULL)
      {
      return(zeroval);
      }
   SEEIT_fwrite_int(&zeroval,nettemp);
   fclose(nettemp);
   return(answer);
}


void MakeOutputFileNames()
{
int namesize;

   sprintf(unsortlog,"%snotsorted.bin",outdirectory);
   sprintf(errtypelog,"%serrtypes.bin",outdirectory); /** used in errors.c ***/
   sprintf(billboardlog,"%sbillb.bin",outdirectory);  /** make billboards instead of DEM point conditions ***/
   sprintf(CDFlog,"%sconditions.cdf",outdirectory); /** used in errors.c, ReRack function ***/


   namesize = strlen(outdirectory) + 50;

   if(binsmrylog != NULL)
      free(binsmrylog);
   binsmrylog  = (char *) (malloc(namesize));
   sprintf(binsmrylog,"%scondsummary.bin",outdirectory);

   if(networksfound != NULL)
      free(networksfound);
   networksfound = (char *) (malloc(namesize));
   sprintf(networksfound,"%snetworkdata.bin",outdirectory);
   ZeroNetworkFile(networksfound);

   OutputFilesInUse = 1;
}




void CloseAllFiles()
{
if(OutputFilesInUse > 0)
   {
   OutputFilesInUse = 0;
   }
}



void InitializeInStreams()
{

      AttributionAnalysisComplete = 0;

      MakeInputFileNames();
      SMIDGE = 0.005;
      NEGSMIDGE = -0.005;
      if((AbsoluteAccuracy == 0) && (SignificantDecimals == 1))
         {
         SMIDGE = 0.1;
         NEGSMIDGE = -0.1;
         }
      else if((AbsoluteAccuracy == 0) && (SignificantDecimals == 0))
         {
         SMIDGE = 1.0;
         NEGSMIDGE = -1.0;
         }

      SetUpTable(1);

}





void InitializeOutStreams()
{
   CloseAllFiles();
   if(outdirectory != NULL)
      MakeOutputFileNames();
 
}


int IsGridSentinel(double gvalue)
{
int answer = 0;

   if((gvalue <= -12000) || (gvalue >= 9000))
      answer = 1;

   return(answer);
}





void DrawContourLinesFromPoly(int vtxcnt, double *X, double *Y, double *Z, int lindex)
{
int i,m, mm, ii, m2, mm2, checkit;
double interval;
int *modvals;
double tgtelev;
double minelev,maxelev;
double deltaz, deltax, deltay;
double ratio1,ratio2;
double xm, ym, xm2, ym2;
int minmod,maxmod;
#define TESTNEW 0


   if((NGA_TYPE == 1) && (vtxcnt == 4))
      {
      DrawContourLinesFromPoly(3 , X, Y, Z,lindex);
      X[1] = X[3];
      Y[1] = Y[3];
      Z[1] = Z[3];
      DrawContourLinesFromPoly(3 , X, Y, Z,lindex);
      return;
      }

   if((OmitGridSentinels > 0) && ((IsGridSentinel(Z[0]) > 0) ||
                                 (IsGridSentinel(Z[1]) > 0) || (IsGridSentinel(Z[2]) > 0)))
      {
      return;
      }
   interval = ContourInterval;

   modvals = (int *) (malloc(SzI * vtxcnt));
   if(modvals == NULL)
      {
      printf("available memory has been exhausted during contour interval calculations\n");
      printf("processing can no longer continue\n");
      exit(-1);
      }

   modvals[0] = (int) (Z[0] / interval);
   minmod = maxmod = modvals[0];
   minelev = maxelev = Z[0];
   for(i=1; i<vtxcnt; i++)
      {
      modvals[i] = (int) (Z[i] / interval);
      if(modvals[i] < minmod)
         minmod = modvals[i];
      if(modvals[i] > maxmod)
         maxmod = modvals[i];
      if(minelev > Z[i])
         minelev = Z[i];
      if(maxelev < Z[i])
         maxelev = Z[i];
      }

   checkit = 0;
   if(maxmod > minmod) /*** then have crossed an interval boundary ***/
      checkit = 1;
   else if((maxelev - minelev) >= 0.0001) /**** then may have to draw a line at interval ***/
      {
      tgtelev = (double) (minmod) * interval;
      if((tgtelev != 0) && (minelev <= tgtelev) && (maxelev > tgtelev))
         checkit = 1;
/*********************
      if((tgtelev - minelev) < 0.0001)
         checkit = 1;
      else if((maxelev - tgtelev) < 0.0001)
         checkit = 1;
******************/
      }
  if(checkit > 0)
  /** then have some contour line(s) thru this polygon **/
      {
      for(m=0; m<vtxcnt; m++)
         {
         mm = (m + 1) % vtxcnt;
         if((modvals[mm] > modvals[m]) || (Z[mm] == Z[m]))
            {
            deltaz = Z[mm] - Z[m];
            deltax = X[mm] - X[m];
            deltay = Y[mm] - Y[m];
            for(ii = modvals[m]; ii <= modvals[mm]; ii++)
               {
               tgtelev = ((double) ii) * interval;
if(TESTNEW > 0)
{
if(tgtelev >= maxelev)
   tgtelev -= 0.0001;
else
   tgtelev += 0.0001;
}
               if((deltaz == 0) && (tgtelev == Z[mm]))
                  MAPdrawContourLine(ii,X[m],Y[m],X[mm],Y[mm],lindex);
               else if((Z[mm] >= tgtelev) && (tgtelev >= Z[m]))
                  {
                  ratio1 = (Z[mm] - tgtelev) / deltaz;
                  xm = X[mm] - (deltax * ratio1);
                  ym = Y[mm] - (deltay * ratio1);
                  m2 = mm;
                  mm2 = (m2 + 1) % vtxcnt;
                  do
                     {
                     if((Z[m2] == Z[mm2]) && (Z[m2] == tgtelev))
                        MAPdrawContourLine(ii,X[m2],Y[m2],X[mm2],Y[mm2],lindex);
                     else if((Z[m2] >= tgtelev) && (Z[mm2] <= tgtelev))
                        {
                        ratio2 = (Z[m2] - tgtelev) / (Z[m2] - Z[mm2]);
                        xm2 = X[m2] - ((X[m2] - X[mm2]) * ratio2);
                        ym2 = Y[m2] - ((Y[m2] - Y[mm2]) * ratio2);
                        MAPdrawContourLine(ii,xm,ym,xm2,ym2,lindex);
                        }
                     else if((Z[mm2] >= tgtelev) && (Z[m2] <= tgtelev))
                        {
                        ratio2 = (Z[mm2] - tgtelev) / (Z[mm2] - Z[m2]);
                        xm2 = X[mm2] - ((X[mm2] - X[m2]) * ratio2);
                        ym2 = Y[mm2] - ((Y[mm2] - Y[m2]) * ratio2);
                        MAPdrawContourLine(ii,xm,ym,xm2,ym2,lindex);
                        }
                     m2 = mm2;
                     mm2 = (mm2 + 1) % vtxcnt;
                     } while (m2 != mm);
                  }
               }
            }
         else if((modvals[m] > modvals[mm]) || (Z[mm] == Z[m]))
            {
            deltaz = Z[m] - Z[mm];
            deltax = X[m] - X[mm];
            deltay = Y[m] - Y[mm];
            for(ii = modvals[mm]; ii <= modvals[m]; ii++)
               {
               tgtelev = ((double) ii) * interval;
if(TESTNEW > 0)
{
if(tgtelev >= maxelev)
   tgtelev -= 0.0001;
else
   tgtelev += 0.0001;
}
               if((deltaz == 0) && (tgtelev == Z[mm]))
                  MAPdrawContourLine(ii,X[m],Y[m],X[mm],Y[mm],lindex);
               else if((Z[m] >= tgtelev) && (tgtelev >= Z[mm]))
                  {
                  ratio1 = (Z[m] - tgtelev) / deltaz;
                  xm = X[m] - (deltax * ratio1);
                  ym = Y[m] - (deltay * ratio1);
                  m2 = mm;
                  mm2 = (m2 + 1) % vtxcnt;
                  do
                     {
                     if((Z[m2] == Z[mm2]) && (Z[m2] == tgtelev))
                        MAPdrawContourLine(ii,X[m2],Y[m2],X[mm2],Y[mm2],lindex);
                     else if((Z[m2] >= tgtelev) && (Z[mm2] <= tgtelev))
                        {
                        ratio2 = (Z[m2] - tgtelev) / (Z[m2] - Z[mm2]);
                        xm2 = X[m2] - ((X[m2] - X[mm2]) * ratio2);
                        ym2 = Y[m2] - ((Y[m2] - Y[mm2]) * ratio2);
                        MAPdrawContourLine(ii,xm,ym,xm2,ym2,lindex);
                        }
                     else if((Z[mm2] >= tgtelev) && (Z[m2] <= tgtelev))
                        {
                        ratio2 = (Z[mm2] - tgtelev) / (Z[mm2] - Z[m2]);
                        xm2 = X[mm2] - ((X[mm2] - X[m2]) * ratio2);
                        ym2 = Y[mm2] - ((Y[mm2] - Y[m2]) * ratio2);
                        MAPdrawContourLine(ii,xm,ym,xm2,ym2,lindex);
                        }
                     m2 = mm2;
                     mm2 = (mm2 + 1) % vtxcnt;
                     } while(m2 != mm);
                  }
               }
            }
         }
      }
   else if((maxmod == 0) && (minmod == 0) && (minelev < 0) && (maxelev > 0))
/** then will have crossed thru the 0 elevation contour and this is the only relevant contour **/
      {
      tgtelev = 0.0;
if(TESTNEW > 0)
{
tgtelev = 0.0001;
}
      for(m=0; m<vtxcnt; m++)
         {
         mm = (m + 1) % vtxcnt;
         if(Z[mm] > Z[m])
            {
            deltaz = Z[mm] - Z[m];
            deltax = X[mm] - X[m];
            deltay = Y[mm] - Y[m];
            if((deltaz == 0) && (tgtelev == Z[mm]))
               MAPdrawContourLine(0,X[m],Y[m],X[mm],Y[mm],lindex);
            else if((Z[mm] >= tgtelev) && (tgtelev >= Z[m]))
               {
               ratio1 = (Z[mm] - tgtelev) / deltaz;
               xm = X[mm] - (deltax * ratio1);
               ym = Y[mm] - (deltay * ratio1);
               m2 = mm;
               mm2 = (m2 + 1) % vtxcnt;
               do
                  {
                  if((Z[m2] == Z[mm2]) && (Z[m2] == tgtelev))
                     MAPdrawContourLine(0,X[m2],Y[m2],X[mm2],Y[mm2],lindex);
                  else if((Z[m2] >= tgtelev) && (Z[mm2] <= tgtelev))
                     {
                     ratio2 = (Z[m2] - tgtelev) / (Z[m2] - Z[mm2]);
                     xm2 = X[m2] - ((X[m2] - X[mm2]) * ratio2);
                     ym2 = Y[m2] - ((Y[m2] - Y[mm2]) * ratio2);
                     MAPdrawContourLine(0,xm,ym,xm2,ym2,lindex);
                     }
                  else if((Z[mm2] >= tgtelev) && (Z[m2] <= tgtelev))
                     {
                     ratio2 = (Z[mm2] - tgtelev) / (Z[mm2] - Z[m2]);
                     xm2 = X[mm2] - ((X[mm2] - X[m2]) * ratio2);
                     ym2 = Y[mm2] - ((Y[mm2] - Y[m2]) * ratio2);
                     MAPdrawContourLine(0,xm,ym,xm2,ym2,lindex);
                     }
                  m2 = mm2;
                  mm2 = (mm2 + 1) % vtxcnt;
                  } while (m2 != mm);
               }
            }
         else if(Z[m] >= Z[mm])
            {
            deltaz = Z[m] - Z[mm];
            deltax = X[m] - X[mm];
            deltay = Y[m] - Y[mm];
            if((deltaz == 0) && (tgtelev == Z[mm]))
               MAPdrawContourLine(0,X[m],Y[m],X[mm],Y[mm],lindex);
            else if((Z[m] >= tgtelev) && (tgtelev >= Z[mm]))
               {
               ratio1 = (Z[m] - tgtelev) / deltaz;
               xm = X[m] - (deltax * ratio1);
               ym = Y[m] - (deltay * ratio1);
               m2 = mm;
               mm2 = (m2 + 1) % vtxcnt;
               do
               /**while(m2 != 0) **/  /** was (m2 != m) **/
                  {
                  if((Z[m2] == Z[mm2]) && (Z[m2] == tgtelev))
                     MAPdrawContourLine(0,X[m2],Y[m2],X[mm2],Y[mm2],lindex);
                  else if((Z[m2] >= tgtelev) && (Z[mm2] <= tgtelev))
                     {
                     ratio2 = (Z[m2] - tgtelev) / (Z[m2] - Z[mm2]);
                     xm2 = X[m2] - ((X[m2] - X[mm2]) * ratio2);
                     ym2 = Y[m2] - ((Y[m2] - Y[mm2]) * ratio2);
                     MAPdrawContourLine(0,xm,ym,xm2,ym2,lindex);
                     }
                  else if((Z[mm2] >= tgtelev) && (Z[m2] <= tgtelev))
                     {
                     ratio2 = (Z[mm2] - tgtelev) / (Z[mm2] - Z[m2]);
                     xm2 = X[mm2] - ((X[mm2] - X[m2]) * ratio2);
                     ym2 = Y[mm2] - ((Y[mm2] - Y[m2]) * ratio2);
                     MAPdrawContourLine(0,xm,ym,xm2,ym2,lindex);
                     }
                  m2 = mm2;
                  mm2 = (mm2 + 1) % vtxcnt;
                  } while(m2 != mm);
               }
            }
         }
      }

   free(modvals);
}












int Make_Correct(int keyval, int socalledinstance)
{
  int cloneindex;
  

  cloneindex = ActiveChecks[socalledinstance].clonenumber;


  if(cloneindex==-1)
    {
      return 0;
    }
  
  return GetCloneNumber(cloneindex,keyval);

}









int SensitivityCheck(int GT_LT_EQ, int checktype, int checknum, double checkvalue)
{
/**** GT_LT_EQ flags:
    LT 1--> < sensitivity
    LTEQ 2 --> <= sensitivity
    EQEQ 3 --> == sensitivity
    GTEQ 4 --> >= sensitivity
    GT 5 --> > sensitivity
    OPENINT 6 --> > sensitivity, < sensitivity2
    GTCLOSED 7 -->  >= sensitivity, < sensitivity2
    CLOSEDINT 8 --> >= sensitivity, <= sensitivity2
    LTCLOSED 9 --> > sensitivity, <= sensitivity2
********/
 double limit1, limit2;
 int answer;

   answer = 0;
   limit1 = limit2 = 0.0;
   if(ActiveChecks[checknum].numthresholds > 0)
      limit1 = ActiveChecks[checknum].sensitivity;
   if(ActiveChecks[checknum].numthresholds > 1)
      limit2 = ActiveChecks[checknum].sensitivity2;
      
   switch(GT_LT_EQ)
      {
      case LT:
         if(checkvalue < limit1)
            answer = 1;
         break;
      case LTEQ:
         if(checkvalue <= limit1)
            answer = 1;
         break;
      case EQEQ:
         if(checkvalue == limit1)
            answer = 1;
         break;
      case GTEQ:
         if(checkvalue >= limit1)
            answer = 1;
         break;
      case GT:
         if(checkvalue > limit1)
            answer = 1;
         break;
      case OPENINT:
         if((checkvalue > limit1) && (checkvalue < limit2))
            answer = 1;
         break;
      case GTCLOSED:
         if((checkvalue >= limit1) && (checkvalue < limit2))
            answer = 1;
         break;
      case CLOSEDINT:
         if((checkvalue >= limit1) && (checkvalue <= limit2))
            answer = 1;
         break;
      case LTCLOSED:
         if((checkvalue > limit1) && (checkvalue <= limit2))
            answer = 1;
         break;
      default:
         answer = 0;
         break;
      }

   return(answer);
}



void AddToBillBoardCheckList(int CheckIndex, int listtype)
{
struct reflist *BBrefc;
   if(listtype == 1)
      {
      if(BillBoardChecks == NULL)
         {
         BillBoardChecks = (struct reflist *) (malloc(sizeof(struct reflist)));
         BillBoardChecks->index = CheckIndex;
         BillBoardChecks->next = NULL;
         }
      else
         {
         BBrefc = BillBoardChecks;
         while(BBrefc != NULL)
            {
            if(BBrefc->index == CheckIndex)
               break;
            BBrefc = BBrefc->next;
            }
         if(BBrefc == NULL) /** a new check instance ***/
            {
            BBrefc = (struct reflist *) (malloc(sizeof(struct reflist)));
            BBrefc->index = CheckIndex;
            BBrefc->next = BillBoardChecks;
            BillBoardChecks = BBrefc;
            }
         }
      }
   else if(listtype == 2)
      {
      if(BillBoardChecks2 == NULL)
         {
         BillBoardChecks2 = (struct reflist *) (malloc(sizeof(struct reflist)));
         BillBoardChecks2->index = CheckIndex;
         BillBoardChecks2->next = NULL;
         }
      else
         {
         BBrefc = BillBoardChecks2;
         while(BBrefc != NULL)
            {
            if(BBrefc->index == CheckIndex)
               break;
            BBrefc = BBrefc->next;
            }
         if(BBrefc == NULL) /** a new check instance ***/
            {
            BBrefc = (struct reflist *) (malloc(sizeof(struct reflist)));
            BBrefc->index = CheckIndex;
            BBrefc->next = BillBoardChecks2;
            BillBoardChecks2 = BBrefc;
            }
         }
      }

   return;
}




void CheckGridFor_PUE_Shelf(int GridIDN, int Gindex, int Lindex,int NofRows, int NofCols,
                          int Cindex, int P2Index, int pseudolocalID, double minx, double miny, double maxx, double maxy)
{
int neighbors,checkit;
int jj,kk,TotalElevs;
int Z4Index, PlusIndex, MinusIndex, tIndex;
double t,u,u1,magnitude, localIDtouse;
int iX, iY;
int grows, gcols;
double Xgrid[9], Ygrid[9], Zgrid[9];
int rowstart,rowend,colstart,colend;
/****
 * extern double SpikeIgnore1;
 * extern double SpikeIgnore2;
 * extern int SpikeIgnoreT1;
 * extern int SpikeIgnoreT2;
 * **/
/**extern int SpikeNeighbors; ***/

  localIDtouse = (double) (0 - pseudolocalID);
  for(kk=0; kk<MaxGridsPerRegion; kk++)
     {
     TotalElevs = MG[kk].numX * MG[kk].numY;
     if((MG[kk].actualindex == pseudolocalID) && (MG[kk].numX > 0) && (MG[kk].numY > 0))
        {
        rowstart = colstart = 1;
        rowend = MG[kk].numX - 1;
        colend = MG[kk].numY - 1;
        GridIDN = MG[kk].localident;
        iX = 1;
        for(grows = rowstart; grows < rowend; grows++)
           {
           Xgrid[1] = Xgrid[4] = Xgrid[7] = MG[kk].SouthWestX + ((double) iX * MG[kk].Xspace);
           Xgrid[0] = Xgrid[3] = Xgrid[6] = Xgrid[4] - MG[kk].Xspace;
           Xgrid[2] = Xgrid[5] = Xgrid[8] = Xgrid[4] + MG[kk].Xspace;
           iY = 1;
           for(gcols = 1; gcols < colend; gcols++)
              {
              neighbors = 0;
              magnitude = 0.0;

              Ygrid[3] = Ygrid[4] = Ygrid[5] = MG[kk].SouthWestY + ((double) iY * MG[kk].Yspace);
              Ygrid[0] = Ygrid[1] = Ygrid[2] = Ygrid[4] - MG[kk].Yspace;
              Ygrid[6] = Ygrid[7] = Ygrid[8] = Ygrid[4] + MG[kk].Yspace;
             Z4Index = (iX * MG[kk].numY) + iY;
             PlusIndex = Z4Index + MG[kk].numY;
             MinusIndex = Z4Index - MG[kk].numY;

              checkit = 1;
              Zgrid[4] = MG[kk].Elevs[Z4Index];

              if((P2Index >= 0) && (MG[P2Index].Elevs[Z4Index] > ActiveChecks[Cindex].sensitivity6))
                 checkit = 0;
              tIndex = MinusIndex - 1;
              if((tIndex >= 0) && (tIndex <= TotalElevs))
                 {
                 if((P2Index >= 0) && (MG[P2Index].Elevs[tIndex] > ActiveChecks[Cindex].sensitivity6))
                    checkit = 0;
                 Zgrid[0] = MG[kk].Elevs[tIndex];
                 }
              else
                 Zgrid[0] = Zgrid[4];
              tIndex = MinusIndex;
              if((tIndex >= 0) && (tIndex <= TotalElevs))
                 {
                 if((P2Index >= 0) && (MG[P2Index].Elevs[tIndex] > ActiveChecks[Cindex].sensitivity6))
                    checkit = 0;
                 Zgrid[3] = MG[kk].Elevs[tIndex];
                 }
              else
                 Zgrid[3] = Zgrid[4];
              tIndex = MinusIndex + 1;
              if((tIndex >= 0) && (tIndex <= TotalElevs))
                 {
                 if((P2Index >= 0) && (MG[P2Index].Elevs[tIndex] > ActiveChecks[Cindex].sensitivity6))
                    checkit = 0;
                 Zgrid[6] = MG[kk].Elevs[tIndex];
                 }
              else
                 Zgrid[6] = Zgrid[4];
              tIndex = PlusIndex;
              if((tIndex >= 0) && (tIndex <= TotalElevs))
                 {
                 if((P2Index >= 0) && (MG[P2Index].Elevs[tIndex] > ActiveChecks[Cindex].sensitivity6))
                    checkit = 0;
                 Zgrid[5] = MG[kk].Elevs[tIndex];
                 }
              else
                 Zgrid[5] = Zgrid[4];
              tIndex = Z4Index - 1;
              if((tIndex >= 0) && (tIndex <= TotalElevs))
                 {
                 if((P2Index >= 0) && (MG[P2Index].Elevs[tIndex] > ActiveChecks[Cindex].sensitivity6))
                    checkit = 0;
                 Zgrid[1] = MG[kk].Elevs[tIndex];
                 }
              else
                 Zgrid[1] = Zgrid[4];
              tIndex = Z4Index + 1;
              if((tIndex >= 0) && (tIndex <= TotalElevs))
                 {
                 if((P2Index >= 0) && (MG[P2Index].Elevs[tIndex] > ActiveChecks[Cindex].sensitivity6))
                    checkit = 0;
                 Zgrid[7] = MG[kk].Elevs[tIndex];
                 }
              else
                 Zgrid[7] = Zgrid[4];
              tIndex = PlusIndex - 1;
              if((tIndex >= 0) && (tIndex <= TotalElevs))
                 {
                 if((P2Index >= 0) && (MG[P2Index].Elevs[tIndex] > ActiveChecks[Cindex].sensitivity6))
                    checkit = 0;
                 Zgrid[2] = MG[kk].Elevs[tIndex];
                 }
              else
                 Zgrid[2] = Zgrid[4];
              tIndex = PlusIndex + 1;
              if((tIndex >= 0) && (tIndex <= TotalElevs))
                 {
                 if((P2Index >= 0) && (MG[P2Index].Elevs[tIndex] > ActiveChecks[Cindex].sensitivity6))
                    checkit = 0;
                 Zgrid[8] = MG[kk].Elevs[tIndex];
                 }
              else
                 Zgrid[8] = Zgrid[4];


              if((checkit > 0) && (ActiveChecks[Cindex].use_sen6 > 0) && (Zgrid[4] <= -500))
                 checkit = 0;
                 
              if(checkit > 0)
                 {
                 for(jj = 0; jj < 9; jj++)
                    {
                    checkit = 1;
                    if(jj == 4)
                       checkit = 0;
                    else if((ActiveChecks[Cindex].use_sen6 > 0) && (Zgrid[jj] <= -500))
                       checkit = 0;


                    if(checkit > 0)
                       {
                       if(Zgrid[jj] > Zgrid[4])
                          t = Zgrid[jj] - Zgrid[4];
                       else
                          t = Zgrid[4] - Zgrid[jj];

                       if((t >= ActiveChecks[Cindex].sensitivity2) && (t <= ActiveChecks[Cindex].sensitivity3))
                          {
                          u = Distance(Xgrid[jj], Ygrid[jj], Xgrid[4], Ygrid[4]);
                          u1 = atan(t / u);

                          u1 = RadiansToDegrees(u1);

                          if(u1 >= ActiveChecks[Cindex].sensitivity) /** minimum angle **/
                             {
                             ++neighbors;
                             if(t > magnitude)
                                {
                                magnitude = t;
                                }
                             }
                          }
                       }
                    }

                 if(neighbors >= ActiveChecks[Cindex].sensitivity4) 
                    {
                     if(billbout == NULL)
                        billbout = fopen(billboardlog,"wb");
                     if(billbout != NULL)
                        {
                        AddToBillBoardCheckList(Cindex,1);
                        ++BillBoardPtsWritten;
                        BB_FwriteDynamicInfo(billbout,GSHELF,Make_Correct(GSHELF,Cindex),
                             Cindex,1, 0,1,1,NULL, /** parameter '1' after Cindex means always use billboards for this check ***/
                             magnitude, -1.0, -1.0, -1.0,
                             CrsWlk[Lindex].LtoSmapping,/** should be the Grid Sindex **/
                             G_GRIDPT,Lindex,localIDtouse,GridIDN,-1.0,-1.0,
                             &Xgrid[4], &Ygrid[4], &Zgrid[4], 1,
                             -1, -1,-1,-1,-1, -1.0, -1.0, /** for these 2 lines, there is no second object to write **/
                             &Xgrid[2], &Ygrid[2], &Zgrid[2], 0);
                        }
                    }
                 }

              ++iY;
              }
           ++iX;
           }
        }
     }
   return;
}


void CheckGridForSpikes(int GridIDN, int Gindex, int Lindex,int NofRows, int NofCols, 
                          int Cindex, int pseudolocalID, double minx, double miny, double maxx, double maxy)
{
int neighbors,checkit;
int jj,kk,TotalElevs;
int Z4Index, PlusIndex, MinusIndex, tIndex;
double t,u,u1,magnitude, localIDtouse;
int iX, iY;
int grows, gcols;
double Xgrid[9], Ygrid[9], Zgrid[9];
int rowstart,rowend,colstart,colend;
/****
extern double SpikeIgnore1;
extern double SpikeIgnore2;
extern int SpikeIgnoreT1;
extern int SpikeIgnoreT2;
**/
/**extern int SpikeNeighbors; ***/

  localIDtouse = (double) (0 - pseudolocalID);
  for(kk=0; kk<MaxGridsPerRegion; kk++)
     {
     TotalElevs = MG[kk].numX * MG[kk].numY;
     if((MG[kk].actualindex == pseudolocalID) && (MG[kk].numX > 0) && (MG[kk].numY > 0))
        {
        rowstart = colstart = 1;
        rowend = MG[kk].numX - 1;
        colend = MG[kk].numY - 1;
GridIDN = MG[kk].localident;
        iX = 1;
        for(grows = rowstart; grows < rowend; grows++)
           {
           Xgrid[1] = Xgrid[4] = Xgrid[7] = MG[kk].SouthWestX + ((double) iX * MG[kk].Xspace);
           Xgrid[0] = Xgrid[3] = Xgrid[6] = Xgrid[4] - MG[kk].Xspace;
           Xgrid[2] = Xgrid[5] = Xgrid[8] = Xgrid[4] + MG[kk].Xspace;
           iY = 1;
           for(gcols = 1; gcols < colend; gcols++)
              {
              neighbors = 0;
              magnitude = 0.0;

              Ygrid[3] = Ygrid[4] = Ygrid[5] = MG[kk].SouthWestY + ((double) iY * MG[kk].Yspace);
              Ygrid[0] = Ygrid[1] = Ygrid[2] = Ygrid[4] - MG[kk].Yspace;
              Ygrid[6] = Ygrid[7] = Ygrid[8] = Ygrid[4] + MG[kk].Yspace;

             Z4Index = (iX * MG[kk].numY) + iY;
             PlusIndex = Z4Index + MG[kk].numY;
             MinusIndex = Z4Index - MG[kk].numY;

              Zgrid[4] = MG[kk].Elevs[Z4Index];
              tIndex = MinusIndex - 1;
              if((tIndex >= 0) && (tIndex <= TotalElevs))
                 Zgrid[0] = MG[kk].Elevs[tIndex];
              else
                 Zgrid[0] = Zgrid[4];
              tIndex = MinusIndex;
              if((tIndex >= 0) && (tIndex <= TotalElevs))
                 Zgrid[3] = MG[kk].Elevs[tIndex];
              else
                 Zgrid[3] = Zgrid[4];
              tIndex = MinusIndex + 1;
              if((tIndex >= 0) && (tIndex <= TotalElevs))
                 Zgrid[6] = MG[kk].Elevs[tIndex];
              else
                 Zgrid[6] = Zgrid[4];
              tIndex = PlusIndex;
              if((tIndex >= 0) && (tIndex <= TotalElevs))
                 Zgrid[5] = MG[kk].Elevs[tIndex];
              else
                 Zgrid[5] = Zgrid[4];
              tIndex = Z4Index - 1;
              if((tIndex >= 0) && (tIndex <= TotalElevs))
                 Zgrid[1] = MG[kk].Elevs[tIndex];
              else
                 Zgrid[1] = Zgrid[4];
              tIndex = Z4Index + 1;
              if((tIndex >= 0) && (tIndex <= TotalElevs))
                 Zgrid[7] = MG[kk].Elevs[tIndex];
              else
                 Zgrid[7] = Zgrid[4];
              tIndex = PlusIndex - 1;
              if((tIndex >= 0) && (tIndex <= TotalElevs))
                 Zgrid[2] = MG[kk].Elevs[tIndex];
              else
                 Zgrid[2] = Zgrid[4];
              tIndex = PlusIndex + 1;
              if((tIndex >= 0) && (tIndex <= TotalElevs))
                 Zgrid[8] = MG[kk].Elevs[tIndex];
              else
                 Zgrid[8] = Zgrid[4];


              if((ActiveChecks[Cindex].use_sen1 > 0) && (Zgrid[4] == ActiveChecks[Cindex].sensitivity4))
                 checkit = 0;
              else if((ActiveChecks[Cindex].use_sen2 > 0) && (Zgrid[4] == ActiveChecks[Cindex].sensitivity5))
                 checkit = 0;
              else
                 {
                 for(jj = 0; jj < 9; jj++)
                    {
                    checkit = 1;
                    if(jj == 4)
                       checkit = 0;
                    if((checkit == 1) && (ActiveChecks[Cindex].use_sen1 > 0))
                       {
                       if(Zgrid[jj] == ActiveChecks[Cindex].sensitivity4)
                          checkit = 0;
                       else if(Zgrid[4] == ActiveChecks[Cindex].sensitivity4)
                          checkit = 0;
                       }
                    if((checkit == 1) && (ActiveChecks[Cindex].use_sen2 > 0))
                       {
                       if(Zgrid[jj] == ActiveChecks[Cindex].sensitivity5)
                          checkit = 0;
                       else if(Zgrid[4] == ActiveChecks[Cindex].sensitivity5)
                          checkit = 0;
                       }
                    if(checkit > 0)
                       {
                       if(Zgrid[jj] > Zgrid[4])
                          t = Zgrid[jj] - Zgrid[4];
                       else
                          t = Zgrid[4] - Zgrid[jj];
                       if(t >= ActiveChecks[Cindex].sensitivity2)
                          {
                          u = Distance(Xgrid[jj], Ygrid[jj], Xgrid[4], Ygrid[4]);
                          u1 = atan(t / u);

                          u1 = RadiansToDegrees(u1);

                          if(SensitivityCheck(GTEQ,GSPIKE,Cindex,u1) > 0)
                             {
                             ++neighbors;
                             if(u1 > magnitude)
                                {
                                magnitude = u1;
                                }
                             }
                          }
                       }
                    }
                 if(neighbors >= ActiveChecks[Cindex].sensitivity3) /***(neighbors > 4)***/
                    {
                    if((Xgrid[4] >= minx) && (Xgrid[4] <= maxx) && (Ygrid[4] >= miny) && (Ygrid[4] <= maxy))
                       {
                       FwriteObjectAndMagnitude(GSPIKE, Make_Correct(GSPIKE,Cindex), GridIDN,
                         Gindex, G_GRIDPT,Lindex, localIDtouse, -1.0, -1.0, magnitude, &Xgrid[4], &Ygrid[4], &Zgrid[4], 1, 1);
                       }
                    }
                 }

              ++iY;
              }
           ++iX;
           }
        }
     }
   return;
}





void CheckShorelineForRaisedPC(int GridIDN, int Gindex, int Lindex,int NofRows, int NofCols,
                          int Cindex, int pseudolocalID, int EDMindex, double minx, double miny, double maxx, double maxy)
{
int neighbors;
int jj,kk,EDMi,TotalElevs;
int Z4Index, PlusIndex, MinusIndex, tIndex;
double magnitude, localIDtouse, tgtlow,tgthigh;
int iX, iY;
int grows, gcols;
double Xgrid[9], Ygrid[9], Zgrid[9];
int rowstart,rowend,colstart,colend;
/****
extern double SpikeIgnore1;
extern double SpikeIgnore2;
extern int SpikeIgnoreT1;
extern int SpikeIgnoreT2;
**/
/**extern int SpikeNeighbors; ***/

  for(kk=0; kk<MaxGridsPerRegion; kk++)
     {
     if(MG[kk].actualindex == EDMindex)
        {
        EDMi = kk;
        break;
        }
     }
  if(EDMi >= MaxGridsPerRegion)
     return;

  tgtlow = ActiveChecks[Cindex].sensitivity - 0.1;
  tgthigh = tgtlow + 0.2;
  localIDtouse = (double) (0 - pseudolocalID);
  for(kk=0; kk<MaxGridsPerRegion; kk++)
     {
     TotalElevs = MG[kk].numX * MG[kk].numY;
     if((MG[kk].actualindex == pseudolocalID) && (MG[kk].numX > 0) && (MG[kk].numY > 0))
        {
        rowstart = colstart = 1;
        rowend = MG[kk].numX - 1;
        colend = MG[kk].numY - 1;
        GridIDN = MG[kk].localident;
        iX = 1;
        for(grows = rowstart; grows < rowend; grows++)
           {
           Xgrid[1] = Xgrid[4] = Xgrid[7] = MG[kk].SouthWestX + ((double) iX * MG[kk].Xspace);
           Xgrid[0] = Xgrid[3] = Xgrid[6] = Xgrid[4] - MG[kk].Xspace;
           Xgrid[2] = Xgrid[5] = Xgrid[8] = Xgrid[4] + MG[kk].Xspace;
           iY = 1;
           for(gcols = 1; gcols < colend; gcols++)
              {
              neighbors = 0;

              Ygrid[3] = Ygrid[4] = Ygrid[5] = MG[kk].SouthWestY + ((double) iY * MG[kk].Yspace);
              Ygrid[0] = Ygrid[1] = Ygrid[2] = Ygrid[4] - MG[kk].Yspace;
              Ygrid[6] = Ygrid[7] = Ygrid[8] = Ygrid[4] + MG[kk].Yspace;

              Z4Index = (iX * MG[kk].numY) + iY;
              PlusIndex = Z4Index + MG[kk].numY;
              MinusIndex = Z4Index - MG[kk].numY;

              magnitude = 0.0;
              if((MG[EDMi].Elevs[Z4Index] > tgtlow) && (MG[EDMi].Elevs[Z4Index] < tgthigh))
                 magnitude = 1.0;

              Zgrid[4] = MG[kk].Elevs[Z4Index];
              tIndex = MinusIndex - 1;
              if((tIndex >= 0) && (tIndex <= TotalElevs))
                 Zgrid[0] = MG[kk].Elevs[tIndex];
              else
                 Zgrid[0] = Zgrid[4];
              tIndex = MinusIndex;
              if((tIndex >= 0) && (tIndex <= TotalElevs))
                 Zgrid[3] = MG[kk].Elevs[tIndex];
              else
                 Zgrid[3] = Zgrid[4];
              tIndex = MinusIndex + 1;
              if((tIndex >= 0) && (tIndex <= TotalElevs))
                 Zgrid[6] = MG[kk].Elevs[tIndex];
              else
                 Zgrid[6] = Zgrid[4];
              tIndex = PlusIndex;
              if((tIndex >= 0) && (tIndex <= TotalElevs))
                 Zgrid[5] = MG[kk].Elevs[tIndex];
              else
                 Zgrid[5] = Zgrid[4];
              tIndex = Z4Index - 1;
              if((tIndex >= 0) && (tIndex <= TotalElevs))
                 Zgrid[1] = MG[kk].Elevs[tIndex];
              else
                 Zgrid[1] = Zgrid[4];
              tIndex = Z4Index + 1;
              if((tIndex >= 0) && (tIndex <= TotalElevs))
                 Zgrid[7] = MG[kk].Elevs[tIndex];
              else
                 Zgrid[7] = Zgrid[4];
              tIndex = PlusIndex - 1;
              if((tIndex >= 0) && (tIndex <= TotalElevs))
                 Zgrid[2] = MG[kk].Elevs[tIndex];
              else
                 Zgrid[2] = Zgrid[4];
              tIndex = PlusIndex + 1;
              if((tIndex >= 0) && (tIndex <= TotalElevs))
                 Zgrid[8] = MG[kk].Elevs[tIndex];
              else
                 Zgrid[8] = Zgrid[4];


              if(Zgrid[4] == 0)
                 {
                 neighbors = 0;
                 for(jj = 0; jj < 9; jj++)
                    {
                    if(jj != 4)
                       {
                       if((Zgrid[jj] >= ActiveChecks[Cindex].sensitivity2) &&
                           (Zgrid[jj] <= ActiveChecks[Cindex].sensitivity3))
                          {
                          ++neighbors;
                          break;
                          }
                       }
                    }
                 if(neighbors > 0)
                    {
                     if(billbout == NULL)
                        billbout = fopen(billboardlog,"wb");
                     if(billbout != NULL)
                        {
                        AddToBillBoardCheckList(Cindex,1);
                        ++BillBoardPtsWritten;
                        BB_FwriteDynamicInfo(billbout,RAISEDPC,Make_Correct(RAISEDPC,Cindex),
                             Cindex,ActiveChecks[Cindex].sensitivity5, 0,1,1,NULL,
                             magnitude, -1.0, -1.0, -1.0,
                             CrsWlk[Lindex].LtoSmapping,/** should be the Grid Sindex **/
                             G_GRIDPT,Lindex,localIDtouse,GridIDN,-1.0,-1.0,
                             &Xgrid[4], &Ygrid[4], &Zgrid[4], 1,
                             -1, -1,-1,-1,-1, -1.0, -1.0, /** for these 2 lines, there is no second object to write **/
                             &Xgrid[2], &Ygrid[2], &Zgrid[2], 0);
                        }
                    }
                 }

              ++iY;
              }
           ++iX;
           }
        }
     }
   return;
}




int CheckRiverBreaklineAngle(int index, /** is = compositeindex **/
                                     int Cindex,  /*** is the checkinstance ***/
                                      double minx, double miny, double maxx, double maxy) /** LM bounds in internal coords **/
{
int i, k, j, LM_index1, LM_index2;
int Lindex;
/** int  WriteSingle; **/
int SI1, SI2, DidTheCheck, iX, iY, Z4Index, tIndex;
int PlusIndex, MinusIndex, TotalElevs;
double localIDtouse;
double Xgrid[9], Ygrid[9], Zgrid[9], Vgrid[9];
double magnitude;
int grows, gcols, colend, GridIDN, Gindex;
int part1, part2, part3;
/***int Grid1IDN, Grid2IDN;***/
unsigned int LI1, LI2;

   DidTheCheck = 0;

   if(NGT[index].NumGrids < 2) /*** less than 2 grids to compare in this Cindex=Region ***/
      return(DidTheCheck);

   for(LM_index1=0; LM_index1<NGT[index].NumGrids; LM_index1++)
      {
      if((NGT[index].GridIndex != NULL) && (MG[LM_index1].numX > 0) && (MG[LM_index1].numY > 0))
         {
         k = NGT[index].GridIndex[LM_index1];

         LI1 = GridHeader[k].Lindex;
         SI1 = CrsWlk[LI1].LtoSmapping;
         if((CombinedCheckApplies(GridHeader[k].idn,Cindex,BREAKLINE,LI1,SI1,
                     SCCtable[SI1].C, SCCtable[SI1].S, SCCtable[SI1].D,
                     &part1,&part2,&part3) >  0) && (part1 > 0)) /*** this should be the mask ***/
            {
            for(LM_index2=0; LM_index2<NGT[index].NumGrids; LM_index2++)
               {
               if((LM_index2 != LM_index1) && (MG[LM_index2].numX == MG[LM_index1].numX) &&
                      (MG[LM_index2].numY == MG[LM_index1].numY) &&
                         (NearlyEqual(GridHeader[k].BaseX, GridHeader[NGT[index].GridIndex[LM_index2]].BaseX) > 0) &&
                            (NearlyEqual(GridHeader[k].BaseY, GridHeader[NGT[index].GridIndex[LM_index2]].BaseY) > 0))
                  {
                  j = NGT[index].GridIndex[LM_index2];

                  LI2 = GridHeader[j].Lindex;
                  SI2 = CrsWlk[LI2].LtoSmapping;
                  if((CombinedCheckApplies(GridHeader[j].idn,Cindex,BREAKLINE,LI2,SI2,
                       SCCtable[SI2].C, SCCtable[SI2].S, SCCtable[SI2].D,
                     &part1,&part2,&part3) >  0) && (part2 > 0)) /*** this should be the DEM ***/
                     {
                     DidTheCheck = 1;
                     TotalElevs = MG[LM_index2].numX * MG[LM_index2].numY;
                     GridIDN = GridHeader[j].idn;
                     Gindex = GridHeader[j].Sindex;
                     Lindex = GridHeader[j].Lindex;
                     localIDtouse = (double) (0 - j);

                     iX = 1;
                     for(grows = 0; grows < MG[LM_index1].numX; grows++)
                        {
                        Xgrid[1] = Xgrid[4] = Xgrid[7] = MG[LM_index2].SouthWestX + ((double) iX * MG[LM_index2].Xspace);
                        Xgrid[0] = Xgrid[3] = Xgrid[6] = Xgrid[4] - MG[LM_index2].Xspace;
                        Xgrid[2] = Xgrid[5] = Xgrid[8] = Xgrid[4] + MG[LM_index2].Xspace;
                        iY = 1;
                        colend = MG[LM_index2].numY - 1;
                        for(gcols = 1; gcols < colend; gcols++)
                           {
                           Ygrid[3] = Ygrid[4] = Ygrid[5] = MG[LM_index2].SouthWestY + ((double) iY * MG[LM_index2].Yspace);
                           Ygrid[0] = Ygrid[1] = Ygrid[2] = Ygrid[4] - MG[LM_index2].Yspace;
                           Ygrid[6] = Ygrid[7] = Ygrid[8] = Ygrid[4] + MG[LM_index2].Yspace;
                          Z4Index = (iX * MG[LM_index2].numY) + iY;
                          PlusIndex = Z4Index + MG[LM_index2].numY;
                          MinusIndex = Z4Index - MG[LM_index2].numY;

                           Zgrid[4] = MG[LM_index2].Elevs[Z4Index];
                           if((MG[LM_index1].Elevs[Z4Index] >= ActiveChecks[Cindex].sensitivity3) &&
                                (MG[LM_index1].Elevs[Z4Index] <= ActiveChecks[Cindex].sensitivity4))
                              Vgrid[4] = 1;
                           else
                              Vgrid[4] = 0;

                           tIndex = MinusIndex - 1;
                           if((tIndex >= 0) && (tIndex <= TotalElevs))
                              Zgrid[0] = MG[LM_index2].Elevs[tIndex];
                           else
                              Zgrid[0] = Zgrid[4];
                           if((tIndex >= 0) && (tIndex <= TotalElevs) &&
                                (MG[LM_index1].Elevs[tIndex] >= ActiveChecks[Cindex].sensitivity3) &&
                                (MG[LM_index1].Elevs[tIndex] <= ActiveChecks[Cindex].sensitivity4))
                              Vgrid[0] = 1;
                           else
                              Vgrid[0] = 0;

                           tIndex = MinusIndex;
                           if((tIndex >= 0) && (tIndex <= TotalElevs))
                              Zgrid[3] = MG[LM_index2].Elevs[tIndex];
                           else
                              Zgrid[3] = Zgrid[4];
                           if((tIndex >= 0) && (tIndex <= TotalElevs) &&
                                (MG[LM_index1].Elevs[tIndex] >= ActiveChecks[Cindex].sensitivity3) &&
                                (MG[LM_index1].Elevs[tIndex] <= ActiveChecks[Cindex].sensitivity4))
                              Vgrid[3] = 1;
                           else
                              Vgrid[3] = 0;

                           tIndex = MinusIndex + 1;
                           if((tIndex >= 0) && (tIndex <= TotalElevs))
                              Zgrid[6] = MG[LM_index2].Elevs[tIndex];
                           else
                              Zgrid[6] = Zgrid[4];
                           if((tIndex >= 0) && (tIndex <= TotalElevs) &&
                                (MG[LM_index1].Elevs[tIndex] >= ActiveChecks[Cindex].sensitivity3) &&
                                (MG[LM_index1].Elevs[tIndex] <= ActiveChecks[Cindex].sensitivity4))
                              Vgrid[6] = 1;
                           else
                              Vgrid[6] = 0;

                           tIndex = PlusIndex;
                           if((tIndex >= 0) && (tIndex <= TotalElevs))
                              Zgrid[5] = MG[LM_index2].Elevs[tIndex];
                           else
                              Zgrid[5] = Zgrid[4];
                           if((tIndex >= 0) && (tIndex <= TotalElevs) &&
                                (MG[LM_index1].Elevs[tIndex] >= ActiveChecks[Cindex].sensitivity3) &&
                                (MG[LM_index1].Elevs[tIndex] <= ActiveChecks[Cindex].sensitivity4))
                              Vgrid[5] = 1;
                           else
                              Vgrid[5] = 0;

                           tIndex = Z4Index - 1;
                           if((tIndex >= 0) && (tIndex <= TotalElevs))
                              Zgrid[1] = MG[LM_index2].Elevs[tIndex];
                           else
                              Zgrid[1] = Zgrid[4];
                           if((tIndex >= 0) && (tIndex <= TotalElevs) &&
                                (MG[LM_index1].Elevs[tIndex] >= ActiveChecks[Cindex].sensitivity3) &&
                                (MG[LM_index1].Elevs[tIndex] <= ActiveChecks[Cindex].sensitivity4))
                              Vgrid[1] = 1;
                           else
                              Vgrid[1] = 0;

                           tIndex = Z4Index + 1;
                           if((tIndex >= 0) && (tIndex <= TotalElevs))
                              Zgrid[7] = MG[LM_index2].Elevs[tIndex];
                           else
                              Zgrid[7] = Zgrid[4];
                           if((tIndex >= 0) && (tIndex <= TotalElevs) &&
                                (MG[LM_index1].Elevs[tIndex] >= ActiveChecks[Cindex].sensitivity3) &&
                                (MG[LM_index1].Elevs[tIndex] <= ActiveChecks[Cindex].sensitivity4))
                              Vgrid[7] = 1;
                           else
                              Vgrid[7] = 0;

                           tIndex = PlusIndex - 1;
                           if((tIndex >= 0) && (tIndex <= TotalElevs))
                              Zgrid[2] = MG[LM_index2].Elevs[tIndex];
                           else
                              Zgrid[2] = Zgrid[4];
                           if((tIndex >= 0) && (tIndex <= TotalElevs) &&
                                (MG[LM_index1].Elevs[tIndex] >= ActiveChecks[Cindex].sensitivity3) &&
                                (MG[LM_index1].Elevs[tIndex] <= ActiveChecks[Cindex].sensitivity4))
                              Vgrid[2] = 1;
                           else
                              Vgrid[2] = 0;

                           tIndex = PlusIndex + 1;
                           if((tIndex >= 0) && (tIndex <= TotalElevs))
                              Zgrid[8] = MG[LM_index2].Elevs[tIndex];
                           else
                              Zgrid[8] = Zgrid[4];
                           if((tIndex >= 0) && (tIndex <= TotalElevs) &&
                                (MG[LM_index1].Elevs[tIndex] >= ActiveChecks[Cindex].sensitivity3) &&
                                (MG[LM_index1].Elevs[tIndex] <= ActiveChecks[Cindex].sensitivity4))
                              Vgrid[8] = 1;
                           else
                              Vgrid[8] = 0;

                           magnitude = 0.0;
                           if(ActiveChecks[Cindex].sensitivity5 > 0.5)  /** then will need to write a billboard ***/
                              {
                              if(Vgrid[4] > 0)
                                 {
                                 for(i=0; i<9; i++)
                                    {
                                    magnitude = -1.0;
                                    if((i != 4) && (Vgrid[i] > 0) && (Zgrid[i] != Zgrid[4]))
                                       {
                                       magnitude = Zgrid[i] - Zgrid[4];
                                       if(magnitude < 0)
                                          magnitude = 0 - magnitude;
                                       break;
                                       }
                                    }
                                 if(magnitude >= 0.1)
                                    {
                                    if(billbout == NULL)
                                       billbout = fopen(billboardlog,"wb");
                                    if(billbout != NULL)
                                       {
                                       AddToBillBoardCheckList(Cindex,1);
                                       ++BillBoardPtsWritten;
                                       BB_FwriteDynamicInfo(billbout,BREAKLINE,Make_Correct(BREAKLINE,Cindex),
                                            Cindex,ActiveChecks[Cindex].sensitivity5, 0,1,1,NULL,
                                            Zgrid[4], -1.0, -1.0, -1.0,
                                            CrsWlk[Lindex].LtoSmapping,/** should be the Grid Sindex **/
                                            G_GRIDPT,Lindex,localIDtouse,GridIDN,-1.0,-1.0,
                                            &Xgrid[4], &Ygrid[4], &Zgrid[4], 1,
                                            -1, -1,-1,-1,-1, -1.0, -1.0,
                                            &Xgrid[2], &Ygrid[2], &Zgrid[2], 0);
                                       }
                                    }
                                 }
                              }

/************************************ not going to write points for this inspection ************/
/**********************************   but this would be the place to do so using something like the below ************
                           if((ActiveChecks[Cindex].sensitivity5 < 0.5) || (ActiveChecks[Cindex].sensitivity5 > 1.5))
                              {
                              WriteSingle = 0;
                              magnitude = 0;
                              if((Vgrid[1] > 0) && (Vgrid[4] > 0) && (Vgrid[7] > 0))
                                 {
                                 magnitude = (Zgrid[1] - Zgrid[4]) + (Zgrid[4] - Zgrid[7]);
                                 WriteSingle = 1;
                                 }
                              if((magnitude == 0) && (Vgrid[3] > 0) && (Vgrid[4] > 0) && (Vgrid[5] > 0))
                                 {
                                 magnitude = (Zgrid[3] - Zgrid[4]) + (Zgrid[4] - Zgrid[5]);
                                 WriteSingle = 1;
                                 }
                              if((magnitude == 0) && (Vgrid[0] > 0) && (Vgrid[4] > 0) && (Vgrid[8] > 0))
                                 {
                                 magnitude = (Zgrid[0] - Zgrid[4]) + (Zgrid[4] - Zgrid[8]);
                                 WriteSingle = 1;
                                 }
                              if((magnitude == 0) && (Vgrid[2] > 0) && (Vgrid[4] > 0) && (Vgrid[6] > 0))
                                 {
                                 magnitude = (Zgrid[2] - Zgrid[4]) + (Zgrid[4] - Zgrid[6]);
                                 WriteSingle = 1;
                                 }
                              if(WriteSingle > 0)
                                 {
                                 if(magnitude < 0)
                                    magnitude = 0 - magnitude;
                                 if(magnitude >= ActiveChecks[Cindex].sensitivity3)
                                    {
                                    FwriteDynamicInfo(BREAKLINE,Make_Correct(BREAKLINE,Cindex),0,1,1,NULL,
                                       magnitude, -1.0, -1.0, -1.0,CrsWlk[Lindex].LtoSmapping,
                                       G_GRIDPT,Lindex,localIDtouse,GridIDN,-1.0,-1.0,
                                       &Xgrid[4], &Ygrid[4], &Zgrid[4], 1,
                                       -1, -1,-1,-1,-1, -1.0, -1.0,
                                       &Xgrid[2], &Ygrid[2], &Zgrid[2], 0);
                                    }
                                 }
                              }
***********************************/
                           ++iY;
                           }
                        ++iX;
                        }
                     }
                  }
               }
            }
         }
      }

   return(DidTheCheck);
}






int CheckMaskAndGridsForStepSize(int index, /** is = compositeindex **/
                                     int Cindex,  /*** is the checkinstance ***/
                                      double minx, double miny, double maxx, double maxy) /** LM bounds in internal coords **/
{
int i, k, j, LM_index1, LM_index2;
int Lindex, WriteSingle;
int SI1, SI2, DidTheCheck, iX, iY, Z4Index, tIndex;
int PlusIndex, MinusIndex, TotalElevs;
double localIDtouse;
double Xgrid[9], Ygrid[9], Zgrid[9], Vgrid[9];
double magnitude;
int grows, gcols, colend, GridIDN, Gindex;
int part1, part2, part3;
/***int Grid1IDN, Grid2IDN;***/
unsigned int LI1, LI2;

   DidTheCheck = 0;

   if(NGT[index].NumGrids < 2) /*** less than 2 grids to compare in this Cindex=Region ***/
      return(DidTheCheck);

   for(LM_index1=0; LM_index1<NGT[index].NumGrids; LM_index1++)
      {
      if((NGT[index].GridIndex != NULL) && (MG[LM_index1].numX > 0) && (MG[LM_index1].numY > 0))
         {
         k = NGT[index].GridIndex[LM_index1];

         LI1 = GridHeader[k].Lindex;
         SI1 = CrsWlk[LI1].LtoSmapping;
         if((CombinedCheckApplies(GridHeader[k].idn,Cindex,FLOWSTEP,LI1,SI1,
                     SCCtable[SI1].C, SCCtable[SI1].S, SCCtable[SI1].D,
                     &part1,&part2,&part3) >  0) && (part1 > 0)) /*** this should be the mask ***/
            {
            for(LM_index2=0; LM_index2<NGT[index].NumGrids; LM_index2++)
               {
               if((LM_index2 != LM_index1) && (MG[LM_index2].numX == MG[LM_index1].numX) &&
                      (MG[LM_index2].numY == MG[LM_index1].numY) &&
                         (NearlyEqual(GridHeader[k].BaseX, GridHeader[NGT[index].GridIndex[LM_index2]].BaseX) > 0) &&
                            (NearlyEqual(GridHeader[k].BaseY, GridHeader[NGT[index].GridIndex[LM_index2]].BaseY) > 0))
                  {
                  j = NGT[index].GridIndex[LM_index2];

                  LI2 = GridHeader[j].Lindex;
                  SI2 = CrsWlk[LI2].LtoSmapping;
                  if((CombinedCheckApplies(GridHeader[j].idn,Cindex,FLOWSTEP,LI2,SI2,
                       SCCtable[SI2].C, SCCtable[SI2].S, SCCtable[SI2].D,
                     &part1,&part2,&part3) >  0) && (part2 > 0)) /*** this shoule be the DEM ***/
                     {
                     DidTheCheck = 1;
                     TotalElevs = MG[LM_index2].numX * MG[LM_index2].numY;
                     GridIDN = GridHeader[j].idn;
                     Gindex = GridHeader[j].Sindex;
                     Lindex = GridHeader[j].Lindex;
                     localIDtouse = (double) (0 - j);

                     iX = 1;
                     for(grows = 0; grows < MG[LM_index1].numX; grows++)
                        {
                        Xgrid[1] = Xgrid[4] = Xgrid[7] = MG[LM_index2].SouthWestX + ((double) iX * MG[LM_index2].Xspace);
                        Xgrid[0] = Xgrid[3] = Xgrid[6] = Xgrid[4] - MG[LM_index2].Xspace;
                        Xgrid[2] = Xgrid[5] = Xgrid[8] = Xgrid[4] + MG[LM_index2].Xspace;
                        iY = 1;
                        colend = MG[LM_index2].numY - 1;
                        for(gcols = 1; gcols < colend; gcols++)
                           {
                           Ygrid[3] = Ygrid[4] = Ygrid[5] = MG[LM_index2].SouthWestY + ((double) iY * MG[LM_index2].Yspace);
                           Ygrid[0] = Ygrid[1] = Ygrid[2] = Ygrid[4] - MG[LM_index2].Yspace;
                           Ygrid[6] = Ygrid[7] = Ygrid[8] = Ygrid[4] + MG[LM_index2].Yspace;
                          Z4Index = (iX * MG[LM_index2].numY) + iY;
                          PlusIndex = Z4Index + MG[LM_index2].numY;
                          MinusIndex = Z4Index - MG[LM_index2].numY;
             
                           Zgrid[4] = MG[LM_index2].Elevs[Z4Index];
                           if((MG[LM_index1].Elevs[Z4Index] >= ActiveChecks[Cindex].sensitivity) && 
                                (MG[LM_index1].Elevs[Z4Index] <= ActiveChecks[Cindex].sensitivity2))
                              Vgrid[4] = 1;
                           else
                              Vgrid[4] = 0;

                           tIndex = MinusIndex - 1;
                           if((tIndex >= 0) && (tIndex <= TotalElevs))
                              Zgrid[0] = MG[LM_index2].Elevs[tIndex];
                           else
                              Zgrid[0] = Zgrid[4];
                           if((tIndex >= 0) && (tIndex <= TotalElevs) &&
                                (MG[LM_index1].Elevs[tIndex] >= ActiveChecks[Cindex].sensitivity) &&
                                (MG[LM_index1].Elevs[tIndex] <= ActiveChecks[Cindex].sensitivity2))
                              Vgrid[0] = 1;
                           else
                              Vgrid[0] = 0;

                           tIndex = MinusIndex;
                           if((tIndex >= 0) && (tIndex <= TotalElevs))
                              Zgrid[3] = MG[LM_index2].Elevs[tIndex];
                           else
                              Zgrid[3] = Zgrid[4];
                           if((tIndex >= 0) && (tIndex <= TotalElevs) &&
                                (MG[LM_index1].Elevs[tIndex] >= ActiveChecks[Cindex].sensitivity) &&
                                (MG[LM_index1].Elevs[tIndex] <= ActiveChecks[Cindex].sensitivity2))
                              Vgrid[3] = 1; 
                           else
                              Vgrid[3] = 0;

                           tIndex = MinusIndex + 1;
                           if((tIndex >= 0) && (tIndex <= TotalElevs))
                              Zgrid[6] = MG[LM_index2].Elevs[tIndex];
                           else
                              Zgrid[6] = Zgrid[4];
                           if((tIndex >= 0) && (tIndex <= TotalElevs) &&
                                (MG[LM_index1].Elevs[tIndex] >= ActiveChecks[Cindex].sensitivity) &&
                                (MG[LM_index1].Elevs[tIndex] <= ActiveChecks[Cindex].sensitivity2))
                              Vgrid[6] = 1; 
                           else
                              Vgrid[6] = 0;

                           tIndex = PlusIndex;
                           if((tIndex >= 0) && (tIndex <= TotalElevs))
                              Zgrid[5] = MG[LM_index2].Elevs[tIndex];
                           else
                              Zgrid[5] = Zgrid[4];
                           if((tIndex >= 0) && (tIndex <= TotalElevs) &&
                                (MG[LM_index1].Elevs[tIndex] >= ActiveChecks[Cindex].sensitivity) &&
                                (MG[LM_index1].Elevs[tIndex] <= ActiveChecks[Cindex].sensitivity2))
                              Vgrid[5] = 1; 
                           else
                              Vgrid[5] = 0;

                           tIndex = Z4Index - 1;
                           if((tIndex >= 0) && (tIndex <= TotalElevs))
                              Zgrid[1] = MG[LM_index2].Elevs[tIndex];
                           else
                              Zgrid[1] = Zgrid[4];
                           if((tIndex >= 0) && (tIndex <= TotalElevs) &&
                                (MG[LM_index1].Elevs[tIndex] >= ActiveChecks[Cindex].sensitivity) &&
                                (MG[LM_index1].Elevs[tIndex] <= ActiveChecks[Cindex].sensitivity2))
                              Vgrid[1] = 1; 
                           else
                              Vgrid[1] = 0;

                           tIndex = Z4Index + 1;
                           if((tIndex >= 0) && (tIndex <= TotalElevs))
                              Zgrid[7] = MG[LM_index2].Elevs[tIndex];
                           else
                              Zgrid[7] = Zgrid[4];
                           if((tIndex >= 0) && (tIndex <= TotalElevs) &&
                                (MG[LM_index1].Elevs[tIndex] >= ActiveChecks[Cindex].sensitivity) &&
                                (MG[LM_index1].Elevs[tIndex] <= ActiveChecks[Cindex].sensitivity2))
                              Vgrid[7] = 1; 
                           else
                              Vgrid[7] = 0;

                           tIndex = PlusIndex - 1;
                           if((tIndex >= 0) && (tIndex <= TotalElevs))
                              Zgrid[2] = MG[LM_index2].Elevs[tIndex];
                           else
                              Zgrid[2] = Zgrid[4];
                           if((tIndex >= 0) && (tIndex <= TotalElevs) &&
                                (MG[LM_index1].Elevs[tIndex] >= ActiveChecks[Cindex].sensitivity) &&
                                (MG[LM_index1].Elevs[tIndex] <= ActiveChecks[Cindex].sensitivity2))
                              Vgrid[2] = 1; 
                           else
                              Vgrid[2] = 0;

                           tIndex = PlusIndex + 1;
                           if((tIndex >= 0) && (tIndex <= TotalElevs))
                              Zgrid[8] = MG[LM_index2].Elevs[tIndex];
                           else
                              Zgrid[8] = Zgrid[4];
                           if((tIndex >= 0) && (tIndex <= TotalElevs) &&
                                (MG[LM_index1].Elevs[tIndex] >= ActiveChecks[Cindex].sensitivity) &&
                                (MG[LM_index1].Elevs[tIndex] <= ActiveChecks[Cindex].sensitivity2))
                              Vgrid[8] = 1; 
                           else
                              Vgrid[8] = 0;

                           magnitude = 0.0;
                           if(ActiveChecks[Cindex].sensitivity4 > 0.5)  /** then will need to write a billboard ***/
                              {
                              if(Vgrid[4] > 0)
                                 {
                                 for(i=0; i<9; i++)
                                    {
                                    magnitude = -1.0;
                                    if((i != 4) && (Vgrid[i] > 0) && (Zgrid[i] != Zgrid[4]))
                                       {
                                       magnitude = 10.0;
                                       break;
                                       }
                                    }
                                 if(magnitude > 0)
                                    {
                                    if(billbout == NULL)
                                       billbout = fopen(billboardlog,"wb");
                                    if(billbout != NULL)
                                       {
                                       AddToBillBoardCheckList(Cindex,1);
                                       ++BillBoardPtsWritten;
                                       BB_FwriteDynamicInfo(billbout,FLOWSTEP,Make_Correct(FLOWSTEP,Cindex),
                                            Cindex,ActiveChecks[Cindex].sensitivity4, 0,1,1,NULL,
                                           /**/ Zgrid[4], -1.0, -1.0, -1.0, /**/
                                            /**magnitude, -1.0, -1.0, -1.0, **/
                                            CrsWlk[Lindex].LtoSmapping,/** should be the Grid Sindex **/
                                            G_GRIDPT,Lindex,localIDtouse,GridIDN,-1.0,-1.0,
                                            &Xgrid[4], &Ygrid[4], &Zgrid[4], 1,
  /** for the next 2 lines, there is no second object to write **/
                                            -1, -1,-1,-1,-1, -1.0, -1.0, 
                                            &Xgrid[2], &Ygrid[2], &Zgrid[2], 0);
                                       }
                                    }
                                 }
                              }

                           if((ActiveChecks[Cindex].sensitivity4 < 0.5) || (ActiveChecks[Cindex].sensitivity4 > 1.5))
                              {
                              WriteSingle = 0;
                              magnitude = 0;
                              if((Vgrid[1] > 0) && (Vgrid[4] > 0) && (Vgrid[7] > 0))
                                 {
                                 magnitude = (Zgrid[1] - Zgrid[4]) + (Zgrid[4] - Zgrid[7]);
                                 WriteSingle = 1;
                                 }
                              if((magnitude == 0) && (Vgrid[3] > 0) && (Vgrid[4] > 0) && (Vgrid[5] > 0))
                                 {
                                 magnitude = (Zgrid[3] - Zgrid[4]) + (Zgrid[4] - Zgrid[5]);
                                 WriteSingle = 1;
                                 }
                              if((magnitude == 0) && (Vgrid[0] > 0) && (Vgrid[4] > 0) && (Vgrid[8] > 0))
                                 {
                                 magnitude = (Zgrid[0] - Zgrid[4]) + (Zgrid[4] - Zgrid[8]);
                                 WriteSingle = 1;
                                 }
                              if((magnitude == 0) && (Vgrid[2] > 0) && (Vgrid[4] > 0) && (Vgrid[6] > 0))
                                 {
                                 magnitude = (Zgrid[2] - Zgrid[4]) + (Zgrid[4] - Zgrid[6]);
                                 WriteSingle = 1;
                                 }
                              if(WriteSingle > 0)
                                 {
                                 if(magnitude < 0)
                                    magnitude = 0 - magnitude;
                                 if(magnitude >= ActiveChecks[Cindex].sensitivity3)
                                    {
                                    FwriteDynamicInfo(FLOWSTEP,Make_Correct(FLOWSTEP,Cindex),0,1,1,NULL,
                                       /***Zgrid[4], -1.0, -1.0, -1.0,CrsWlk[Lindex].LtoSmapping, ***/
                                       magnitude, -1.0, -1.0, -1.0,CrsWlk[Lindex].LtoSmapping,
                                       G_GRIDPT,Lindex,localIDtouse,GridIDN,-1.0,-1.0,
                                       &Xgrid[4], &Ygrid[4], &Zgrid[4], 1,
                                       -1, -1,-1,-1,-1, -1.0, -1.0,
                                       &Xgrid[2], &Ygrid[2], &Zgrid[2], 0);
                                    }
                                 }
                              }
                           ++iY;
                           }
                        ++iX;
                        }
                     }
                  }
               }
            }
         }
      }

   return(DidTheCheck);
}





void CheckGridForAverageSpikes(int GridIDN, int Gindex, int Lindex,int NofRows, int NofCols,
                          int Cindex, int WBMindex, int pseudolocalID, double minx, double miny, double maxx, double maxy)
{
int neighbors,checkit, neighborsabove, neighborsbelow;
int jj,kk,TotalElevs;
/** int WBMindex; ***/
int Z4Index, PlusIndex, MinusIndex, tIndex;
double magnitude, localIDtouse, ElevSum;
int iX, iY;
int grows, gcols;
double Xgrid[9], Ygrid[9], Zgrid[9];
int rowstart,rowend,colstart,colend;
/****
extern double SpikeIgnore1;
extern double SpikeIgnore2;
extern int SpikeIgnoreT1;
extern int SpikeIgnoreT2;
**/
/**extern int SpikeNeighbors; ***/

  localIDtouse = (double) (0 - pseudolocalID);
  for(kk=0; kk<MaxGridsPerRegion; kk++)
     {
     TotalElevs = MG[kk].numX * MG[kk].numY;
     if((MG[kk].actualindex == pseudolocalID) && (MG[kk].numX > 0) && (MG[kk].numY > 0))
        {
        rowstart = colstart = 1;
        rowend = MG[kk].numX - 1;
        colend = MG[kk].numY - 1;
GridIDN = MG[kk].localident;
        iX = 1;
        for(grows = rowstart; grows < rowend; grows++)
           {
           Xgrid[1] = Xgrid[4] = Xgrid[7] = MG[kk].SouthWestX + ((double) iX * MG[kk].Xspace);
           Xgrid[0] = Xgrid[3] = Xgrid[6] = Xgrid[4] - MG[kk].Xspace;
           Xgrid[2] = Xgrid[5] = Xgrid[8] = Xgrid[4] + MG[kk].Xspace;
           iY = 1;
           for(gcols = 1; gcols < colend; gcols++)
              {
              neighbors = 0;
              magnitude = 0.0;

              Ygrid[3] = Ygrid[4] = Ygrid[5] = MG[kk].SouthWestY + ((double) iY * MG[kk].Yspace);
              Ygrid[0] = Ygrid[1] = Ygrid[2] = Ygrid[4] - MG[kk].Yspace;
              Ygrid[6] = Ygrid[7] = Ygrid[8] = Ygrid[4] + MG[kk].Yspace;

             Z4Index = (iX * MG[kk].numY) + iY;
             PlusIndex = Z4Index + MG[kk].numY;
             MinusIndex = Z4Index - MG[kk].numY;

              Zgrid[4] = MG[kk].Elevs[Z4Index];
              tIndex = MinusIndex - 1;
              if((tIndex >= 0) && (tIndex <= TotalElevs))
                 Zgrid[0] = MG[kk].Elevs[tIndex];
              else
                 Zgrid[0] = Zgrid[4];
              tIndex = MinusIndex;
              if((tIndex >= 0) && (tIndex <= TotalElevs))
                 Zgrid[3] = MG[kk].Elevs[tIndex];
              else
                 Zgrid[3] = Zgrid[4];
              tIndex = MinusIndex + 1;
              if((tIndex >= 0) && (tIndex <= TotalElevs))
                 Zgrid[6] = MG[kk].Elevs[tIndex];
              else
                 Zgrid[6] = Zgrid[4];
              tIndex = PlusIndex;
              if((tIndex >= 0) && (tIndex <= TotalElevs))
                 Zgrid[5] = MG[kk].Elevs[tIndex];
              else
                 Zgrid[5] = Zgrid[4];
              tIndex = Z4Index - 1;
              if((tIndex >= 0) && (tIndex <= TotalElevs))
                 Zgrid[1] = MG[kk].Elevs[tIndex];
              else
                 Zgrid[1] = Zgrid[4];
              tIndex = Z4Index + 1;
              if((tIndex >= 0) && (tIndex <= TotalElevs))
                 Zgrid[7] = MG[kk].Elevs[tIndex];
              else
                 Zgrid[7] = Zgrid[4];
              tIndex = PlusIndex - 1;
              if((tIndex >= 0) && (tIndex <= TotalElevs))
                 Zgrid[2] = MG[kk].Elevs[tIndex];
              else
                 Zgrid[2] = Zgrid[4];
              tIndex = PlusIndex + 1;
              if((tIndex >= 0) && (tIndex <= TotalElevs))
                 Zgrid[8] = MG[kk].Elevs[tIndex];
              else
                 Zgrid[8] = Zgrid[4];


              if((ActiveChecks[Cindex].use_sen1 > 0) && (Zgrid[4] == ActiveChecks[Cindex].sensitivity3))
                 checkit = 0;
              else if((ActiveChecks[Cindex].use_sen2 > 0) && (Zgrid[4] == ActiveChecks[Cindex].sensitivity4))
                 checkit = 0;
              else
                 {
                 ElevSum = 0;
                 neighborsabove = neighborsbelow = 0;
                 for(jj = 0; jj < 9; jj++)
                    {
                    checkit = 1;
                    if(jj == 4)
                       checkit = 0;
                    if((checkit == 1) && (ActiveChecks[Cindex].use_sen1 > 0))
                       {
                       if(Zgrid[jj] == ActiveChecks[Cindex].sensitivity3)
                          checkit = 0;
                       else if(Zgrid[4] == ActiveChecks[Cindex].sensitivity3)
                          checkit = 0;
                       }
                    if((checkit == 1) && (ActiveChecks[Cindex].use_sen2 > 0))
                       {
                       if(Zgrid[jj] == ActiveChecks[Cindex].sensitivity4)
                          checkit = 0;
                       else if(Zgrid[4] == ActiveChecks[Cindex].sensitivity4)
                          checkit = 0;
                       }
                    if(checkit > 0)
                       {
                       ElevSum += Zgrid[jj];
                       ++neighbors;
                       if(Zgrid[jj] > Zgrid[4])
                          ++neighborsabove;
                       else if(Zgrid[jj] < Zgrid[4])
                          ++neighborsbelow;
                       }
                    }
                 if(neighbors >= ActiveChecks[Cindex].sensitivity2) 
                    {
                    if((Xgrid[4] >= minx) && (Xgrid[4] <= maxx) && (Ygrid[4] >= miny) && (Ygrid[4] <= maxy))
                       {
                       if((Zgrid[4] != ActiveChecks[Cindex].sensitivity3) && (Zgrid[4] != ActiveChecks[Cindex].sensitivity4))
                          {
                          if((neighborsabove > ActiveChecks[Cindex].sensitivity5) ||
                                    (neighborsbelow > ActiveChecks[Cindex].sensitivity5))
                             {
                             ElevSum = ElevSum / ((double) neighbors);
                             if(ElevSum > Zgrid[4])
                                magnitude = ElevSum - Zgrid[4];
                             else
                                magnitude = Zgrid[4] - ElevSum;
                             if((magnitude >= ActiveChecks[Cindex].sensitivity) && (WBMindex >= 0))
                                {
                                if(MG[WBMindex].Elevs[Z4Index] > 0)
                                   magnitude = ActiveChecks[Cindex].sensitivity - 1.0;
                                }
                             if(magnitude >= ActiveChecks[Cindex].sensitivity)
                                {
                                if(ActiveChecks[Cindex].sensitivity6 < 1)
                                   {
                                   FwriteDynamicInfo(AVGSPIKE,Make_Correct(AVGSPIKE,Cindex),0,1,1,NULL,
                                    magnitude, -1.0, -1.0, -1.0,
                                    CrsWlk[Lindex].LtoSmapping,
                                    G_GRIDPT,Lindex,localIDtouse,GridIDN,-1.0,-1.0,
                                    &Xgrid[4], &Ygrid[4], &Zgrid[4], 1,
                                    -1, -1,-1,-1,-1, -1.0, -1.0,
                                     &Xgrid[2], &Ygrid[2], &Zgrid[2], 0);
                                   }
                                else
                                   {
                                   if(billbout == NULL)
                                      billbout = fopen(billboardlog,"wb");
                                   if(billbout != NULL)
                                      {
                                      AddToBillBoardCheckList(Cindex,1);
                                      ++BillBoardPtsWritten;
                                      BB_FwriteDynamicInfo(billbout,AVGSPIKE,Make_Correct(AVGSPIKE,Cindex),
                                           Cindex,ActiveChecks[Cindex].sensitivity6, 0,1,1,NULL,
                                           magnitude, -1.0, -1.0, -1.0,
                                           CrsWlk[Lindex].LtoSmapping,
                                           G_GRIDPT,Lindex,localIDtouse,GridIDN,-1.0,-1.0,
                                           &Xgrid[4], &Ygrid[4], &Zgrid[4], 1,
                                           -1, -1,-1,-1,-1, -1.0, -1.0,
                                            &Xgrid[2], &Ygrid[2], &Zgrid[2], 0);
                                      }
                                   }
                                }
                             }
                          }
                       }
                    }
                 }

              ++iY;
              }
           ++iX;
           }



        }
     }
   return;
}






int InterpolateElevationInSpecificGrid(int gridindex, int gridheaderindex, double pntx, double pnty, double *pntz,
                          int UseIgnoreValue, double IgnoreValue, int checkindex)
{
int iX, iY, grows, gcols, retval,checkit,foundit;
double answer;
double Xgrid[4];
double Ygrid[4];
double Zgrid[4];
double t,u,t1,u1;
/****
extern double CompareIgnore1;
extern double CompareIgnore2;
extern int CompareIgnoreT1;
extern int CompareIgnoreT2;
******/

   retval = 0;

   Xgrid[0] = GridHeader[gridheaderindex].BaseX - 0.0001;
   Xgrid[2] = Xgrid[0] + 0.0002 + ((double) (GridHeader[gridheaderindex].Xpts - 1) * GridHeader[gridheaderindex].Xspacing);
   if((pntx < Xgrid[0]) || (pntx > Xgrid[2]))
      return(retval);
   Ygrid[0] = GridHeader[gridheaderindex].BaseY - 0.0001;
   Ygrid[1] = Ygrid[0] + 0.0002 + ((double) (GridHeader[gridheaderindex].Ypts - 1) * GridHeader[gridheaderindex].Yspacing);
   if((pnty < Ygrid[0]) || (pnty > Ygrid[1]))
      return(retval);


   if((MG[gridindex].numX > 0) && (MG[gridindex].numY > 0))
      {
      iX = 0;
      foundit = 0;
      for(grows = 0; grows < MG[gridindex].numX; grows++)
         {
         Xgrid[0] = MG[gridindex].SouthWestX /**- SMIDGE**/ + ((double) iX * MG[gridindex].Xspace);
         Xgrid[1] = Xgrid[0];
         Xgrid[2] = Xgrid[0] + MG[gridindex].Xspace /**+ (2.0 * SMIDGE)**/;
         Xgrid[3] = Xgrid[2];
         if(((Xgrid[0] - 0.00001) <= pntx) && ((Xgrid[2] + 0.00001) >= pntx))
            {
            iY = 0;
            for(gcols = 0; gcols < MG[gridindex].numY; gcols++)
               {
               Ygrid[0] = MG[gridindex].SouthWestY /**- SMIDGE**/ + ((double) iY * MG[gridindex].Yspace);
               Ygrid[3] = Ygrid[0];
               Ygrid[1] = Ygrid[0] + MG[gridindex].Yspace /**+ (2.0 * SMIDGE)**/;
               Ygrid[2] = Ygrid[1];

               if(((Ygrid[0] - 0.01) <= pnty) && ((Ygrid[1] + 0.01) >= pnty))
                  {
                  foundit = 1;
                  checkit = 1;
                  Zgrid[0] = MG[gridindex].Elevs[(iX * MG[gridindex].numY) + iY];
                  if((UseIgnoreValue == -99) && (IgnoreValue == -99.9))
                     {
                  if((ActiveChecks[checkindex].use_sen2 == 1) && (Zgrid[0] == ActiveChecks[checkindex].sensitivity2))
                     checkit = 0;
                  else if((ActiveChecks[checkindex].use_sen3 == 1) && (Zgrid[0] == ActiveChecks[checkindex].sensitivity3))
                     checkit = 0;
                     }

                  if((UseIgnoreValue > 0) && (Zgrid[0] <= IgnoreValue))
                     checkit = 0;

                  if(checkit > 0)
                     {
                     Zgrid[3] = MG[gridindex].Elevs[(iX * MG[gridindex].numY) + iY + 1];
                     if((UseIgnoreValue == -99) && (IgnoreValue == -99.9))
                        {
                     if((ActiveChecks[checkindex].use_sen2 == 1) && (Zgrid[3] == ActiveChecks[checkindex].sensitivity2))
                        checkit = 0;
                     else if((ActiveChecks[checkindex].use_sen3 == 1) && (Zgrid[3] == ActiveChecks[checkindex].sensitivity3))
                        checkit = 0;
                        }
                     if((UseIgnoreValue > 0) && (Zgrid[3] <= IgnoreValue))
                        checkit = 0;
                     if(checkit > 0)
                        {
                        Zgrid[2] = MG[gridindex].Elevs[(iX * MG[gridindex].numY) + MG[gridindex].numY + iY + 1];
                        if((UseIgnoreValue == -99) && (IgnoreValue == -99.9))
                           {
                        if((ActiveChecks[checkindex].use_sen2 == 1) && (Zgrid[2] == ActiveChecks[checkindex].sensitivity2))
                           checkit = 0;
                        else if((ActiveChecks[checkindex].use_sen3 == 1) && (Zgrid[2] == ActiveChecks[checkindex].sensitivity3))
                           checkit = 0;
                           }
                        if((UseIgnoreValue > 0) && (Zgrid[2] <= IgnoreValue))
                           checkit = 0;
                        if(checkit > 0)
                           {
                           Zgrid[1] = MG[gridindex].Elevs[(iX * MG[gridindex].numY) + MG[gridindex].numY + iY];
                           if((UseIgnoreValue == -99) && (IgnoreValue == -99.9))
                              {
                           if((ActiveChecks[checkindex].use_sen2 == 1) && (Zgrid[1] == ActiveChecks[checkindex].sensitivity2))
                              checkit = 0;
                           else if((ActiveChecks[checkindex].use_sen3 == 1) && (Zgrid[1] == ActiveChecks[checkindex].sensitivity3))
                              checkit = 0;
                              }
                           if((UseIgnoreValue > 0) && (Zgrid[1] <= IgnoreValue))
                              checkit = 0;
                           if(checkit > 0)
                              {

                              t = (pntx - Xgrid[0]) / (Xgrid[2] - Xgrid[0]);
                              t1 = 1.0 - t;
                              u = (pnty - Ygrid[0]) / (Ygrid[1] - Ygrid[0]);
                              u1 = 1.0 - u;

                              answer = t1 * u1 * Zgrid[0]; 
                              answer += t * u1 * Zgrid[1];
                              answer += t * u * Zgrid[2];
                              answer += t1 * u * Zgrid[3];

                              *pntz = answer;

                              retval = 1;
                              break;
                              }
                           }
                        }
                     }
                  break;
                  }
               ++iY;
               }
            }
         if((foundit > 0)||  (retval > 0))
            break;
         ++iX;
         }
      }
   return(retval);

}



void PerformDEMandFeatureChecks(char * prompt, int cindex,struct RawLinear *Lroot,double minx,double miny,double maxx,double maxy,
    double multiplier, int NorthCount, int SouthCount, int EastCount, int WestCount,
    struct RawAreal *Aroot, struct RawBridge *Broot, struct RawPoint *Proot, struct ListOfEdges *PEroot, struct ListOfEdges *VPEroot,
    struct RawLinear *NLroot, struct ThePolys * Polyroot)
{
struct RawLinear *rlc, *rln;
struct RawPoint *rpc;
struct RawAreal *rac;
struct RB_Edgelist * LastEdge;
int * UsedShadow;
int i, j, jj, kk, ii3, ii4, Gindex, LI, SI, ii, checkinstance;
int part1, part2, part3, E, ThisGridIndex,LOS_ArrayIndex,LOS_CheckIndex, LOS_GHindex;
int LastI, UsedTree, found_one, iY, iX, grows, gcols;
int index, NumToAverage, NumGridPts, Inside, unusedint;
double * ShadowGrid;
double MeanValue, TotalForAverage,StdDevMeasure;
double pseudoLID1, unuseddbl;
double Znew, ElevDiff, z1, z2, z3, z4, temp, tgtx, tgty, tempx, tempy;
double minFx, maxFx, minFy, maxFy, gridx, gridy, featelev, Xgridcoordlimit, Ygridcoordlimit;
double minElev,maxElev;
double slopeangle1, slopeangle2;
double basedist, segdist;
double *LOS_GX, *LOS_GY, *LOS_GZ;
double AnchorX, AnchorY, CurX, CurY, NewY;
double X[4], Y[4], Z[4];
/****double MinElevation[25];
double MaxElevation[25];
double MaxElevDist[25];
double MinElevDist[25];***/
struct ProfileList *cp,*pp;
struct collection
   {
   int keyval;
   int Cnumber;
   double x[5];
   double y[5];
   double z[5];
   double magnitude;
   int IDN;
   unsigned int Sindex;
   int vertexindex1, vertexindex2;
   struct RawAreal *aa;
   struct RawPoint *pp;
   struct RawLinear *ll;
   struct collection * next;
   } *ERroot, *ERc, *ERn;
int SzC = sizeof(struct collection);


   if((NGT == NULL) || (NGT[cindex].NumGrids < 1)) /*** no dem grid here - then no point in going on ... ***/
      return;

   ERroot = NULL;
   LOS_GX = LOS_GY = LOS_GZ = NULL;

   for(checkinstance = 0; checkinstance < TtlActiveChecks; checkinstance++)
      {
      for(Gindex=0; Gindex<NGT[cindex].NumGrids; Gindex++)
         {
         if((MG[Gindex].numX > 0) && (MG[Gindex].numY > 0))
            {
            j = NGT[cindex].GridIndex[Gindex];

            LI = GridHeader[j].Lindex;
            SI = CrsWlk[LI].LtoSmapping;



            if((CombinedCheckApplies(GridHeader[j].idn,checkinstance,PT_GRID_DIF,LI,SI,
                 SCCtable[SI].C, SCCtable[SI].S, SCCtable[SI].D,
               &part1,&part2,&part3) >  0) && (part2 > 0))
               {
               Xgridcoordlimit = NGT[cindex].BaseX[Gindex] + (NGT[cindex].NumCols[Gindex] * GridHeader[j].Xspacing);
               Ygridcoordlimit = NGT[cindex].BaseY[Gindex] + (NGT[cindex].NumRows[Gindex] * GridHeader[j].Yspacing);

               ThisGridIndex = NGT[cindex].GridIndex[Gindex];
               rpc = Proot;
               while(rpc != NULL)
                  {
                  if(rpc->numverts == -1) /*** only looking at pure points, NGA-style ***/
                     {
                     if((CombinedCheckApplies(rpc->idn,checkinstance,PT_GRID_DIF,
                       rpc->Lindex,rpc->Sindex,
                        SCCtable[rpc->Sindex].C, SCCtable[rpc->Sindex].S, SCCtable[rpc->Sindex].D,
                               &part1,&part2,&part3) > 0) &&
                          (part1 > 0))
                        {

                        if((rpc->x[0] >= minx) && (rpc->x[0] <= maxx) &&
                                    (rpc->y[0] >= miny) && (rpc->y[0] <= maxy))
                           {
                           tempx = rpc->x[0] - MG[Gindex].SouthWestX;
                           unuseddbl = tempx / MG[Gindex].Xspace;
                           iX = (int) (unuseddbl + 0.001);
                           tempy = rpc->y[0] - MG[Gindex].SouthWestY;
                           temp = tempy / MG[Gindex].Yspace;
                           iY = (int) (temp + 0.001);
                           temp = Distance((double) iX * MG[Gindex].Xspace, (double) iY * MG[Gindex].Yspace,
                                             unuseddbl * MG[Gindex].Xspace, temp * MG[Gindex].Yspace);
                           if(temp <= ActiveChecks[checkinstance].sensitivity) /** feature pt and grid point are close enough to each other **/
                              {
                              Znew = MG[Gindex].Elevs[(int) ((iX * MG[Gindex].numY) + iY)];
                              if(rpc->z[0] > Znew)
                                 ElevDiff = rpc->z[0] - Znew;
                              else
                                 ElevDiff = Znew - rpc->z[0];

                              if(ElevDiff > ActiveChecks[checkinstance].sensitivity2)
                                 {
                                 FwriteDynamicInfo(PT_GRID_DIF,Make_Correct(PT_GRID_DIF,checkinstance),1,1,0,
                                                   NULL, ElevDiff,rpc->x[0],rpc->y[0],rpc->z[0],
                                                   -1, -1, -1,-1,-1, -1, -1,
                                                   NULL, NULL, NULL, 0,
                                                   -1, -1, -1,-1,-1, -1, -1,
                                                   NULL, NULL, NULL, 0);
                                 }
                              }
                           } /** end this point feature is a candidate ***/
                        }
                     }
                  rpc = rpc->next;
                  } /*** end considering points in this LM ***/
               } /** end PT_GRID_DIF check applies to grid [j] ***/


            if((CombinedCheckApplies(GridHeader[j].idn,checkinstance,CLAMP_DIF,LI,SI,
                 SCCtable[SI].C, SCCtable[SI].S, SCCtable[SI].D,
               &part1,&part2,&part3) >  0) && (part2 > 0))
               {
               Xgridcoordlimit = NGT[cindex].BaseX[Gindex] + (NGT[cindex].NumCols[Gindex] * GridHeader[j].Xspacing);
               Ygridcoordlimit = NGT[cindex].BaseY[Gindex] + (NGT[cindex].NumRows[Gindex] * GridHeader[j].Yspacing);

               ThisGridIndex = NGT[cindex].GridIndex[Gindex];
               rlc = Lroot;
               while(rlc != NULL)
                  {
                  if((CombinedCheckApplies(rlc->idn,checkinstance,CLAMP_DIF,rlc->Lindex,rlc->Sindex,
                     SCCtable[rlc->Sindex].C, SCCtable[rlc->Sindex].S, SCCtable[rlc->Sindex].D,
                             &part1,&part2,&part3) > 0) &&
                         (part1 > 0))
                     {
                     for(i=0; i<rlc->numnodes; i++)
                        {
                        if((rlc->z[i] > ActiveChecks[checkinstance].sensitivity2) &&
                                (rlc->x[i] >= minx) && (rlc->x[i] <= maxx) &&
                                    (rlc->y[i] >= miny) && (rlc->y[i] <= maxy))
                           {
                           E = InterpolateElevationInSpecificGrid(Gindex, ThisGridIndex, rlc->x[i], rlc->y[i], &Znew,
                                                          1, ActiveChecks[checkinstance].sensitivity3, checkinstance);
                           if(E > 0)
                              {
                              if(rlc->z[i] > Znew)
                                 ElevDiff = rlc->z[i] - Znew;
                              else
                                 ElevDiff = Znew - rlc->z[i];

                              if(SensitivityCheck(GTEQ,CLAMP_DIF,checkinstance,ElevDiff) > 0)
                                 {
                                 if(i > 0)
                                    ii = i - 1;
                                 else
                                    ii = i;
                                 FwritePointObjectAndMagnitude(CLAMP_DIF,Make_Correct(CLAMP_DIF,checkinstance),ElevDiff,rlc->idn,G_LINE,
                                    rlc->Lindex,rlc->localID, rlc->Sindex, rlc->x[i], rlc->y[i], rlc->z[i], rlc->Sindex, rlc->idn, G_LINE,
                                      rlc->Lindex, rlc->localID, 2, &rlc->x[ii], &rlc->y[ii], &rlc->z[ii]);
                                 }
                              }


                           if((i > 0) && (rlc->z[i-1] > ActiveChecks[checkinstance].sensitivity2) &&
                                     (ActiveChecks[checkinstance].sensitivity4 > 0))
                              {
                              ii = i - 1;
                              if(rlc->x[i] > rlc->x[ii])
                                 {
                                 minFx = rlc->x[ii];
                                 maxFx = rlc->x[i];
                                 }
                              else
                                 {
                                 minFx = rlc->x[i];
                                 maxFx = rlc->x[ii];
                                 }
                              gridx = NGT[cindex].BaseX[Gindex];
                              while(gridx <= maxFx)
                                 {
                                 if((gridx >= minFx) && (gridx <= maxFx) && (gridx >= minx) && (gridx <= maxx))
                                    {
                                    gridy =  FindXatYonSegment(gridx, rlc->y[i],rlc->x[i],rlc->y[ii],rlc->x[ii]); /* finding Y, not X, so all args switched ... */
                                    if((gridy >= miny) && (gridy <= maxy))
                                       {
                                       E = InterpolateElevationInSpecificGrid(Gindex, ThisGridIndex, gridx, gridy, &Znew,
                                                          1, ActiveChecks[checkinstance].sensitivity3, checkinstance);
                                       if(E > 0)
                                          {
                                          featelev = InterpLinearElev(rlc->x[i],rlc->y[i],rlc->z[i],rlc->x[ii],rlc->y[ii],rlc->z[ii],gridx,gridy);
                                          if(featelev > Znew)
                                             ElevDiff = featelev - Znew;
                                          else
                                             ElevDiff = Znew - featelev;

                                          if(SensitivityCheck(GTEQ,CLAMP_DIF,checkinstance,ElevDiff) > 0)
                                             {
                                             FwritePointObjectAndMagnitude(CLAMP_DIF,Make_Correct(CLAMP_DIF,checkinstance),ElevDiff,rlc->idn,G_LINE,
                                                rlc->Lindex,rlc->localID, rlc->Sindex, gridx,gridy,featelev, rlc->Sindex, rlc->idn, G_LINE,
                                                  rlc->Lindex, rlc->localID, 2, &rlc->x[ii], &rlc->y[ii], &rlc->z[ii]);
                                             }
                                          }
                                       }

                                    }
                                 gridx += GridHeader[j].Xspacing;
                                 if(gridx >= Xgridcoordlimit)
                                    break;
                                 }

                              if(rlc->y[i] > rlc->y[ii])
                                 {
                                 minFy = rlc->y[ii];
                                 maxFy = rlc->y[i];
                                 }
                              else
                                 {
                                 minFy = rlc->y[i];
                                 maxFy = rlc->y[ii];
                                 }
                              gridy = NGT[cindex].BaseY[Gindex];
                              while(gridy <= maxFy)
                                 {
                                 if((gridy >= minFy) && (gridy <= maxFy) && (gridy >= miny) && (gridy <= maxy))
                                    {
                                    gridx =  FindXatYonSegment(gridy, rlc->x[i],rlc->y[i],rlc->x[ii],rlc->y[ii]);
                                    if((gridx >= minx) && (gridx <= maxx))
                                       {
                                       E = InterpolateElevationInSpecificGrid(Gindex, ThisGridIndex, gridx, gridy, &Znew,
                                                          1, ActiveChecks[checkinstance].sensitivity3, checkinstance);
                                       if(E > 0)
                                          {
                                          featelev = InterpLinearElev(rlc->x[i],rlc->y[i],rlc->z[i],rlc->x[ii],rlc->y[ii],rlc->z[ii],gridx,gridy);
                                          if(featelev > Znew)
                                             ElevDiff = featelev - Znew;
                                          else
                                             ElevDiff = Znew - featelev;

                                          if(SensitivityCheck(GTEQ,CLAMP_DIF,checkinstance,ElevDiff) > 0)
                                             {
                                             FwritePointObjectAndMagnitude(CLAMP_DIF,Make_Correct(CLAMP_DIF,checkinstance),ElevDiff,rlc->idn,G_LINE,
                                                rlc->Lindex,rlc->localID, rlc->Sindex, gridx,gridy,featelev, rlc->Sindex, rlc->idn, G_LINE,
                                                  rlc->Lindex, rlc->localID, 2, &rlc->x[ii], &rlc->y[ii], &rlc->z[ii]);
                                                      ElevDiff = featelev - Znew;
                                             }
                                          }
                                       }

                                    }
                                 gridy += GridHeader[j].Yspacing;
                                 if(gridy >= Ygridcoordlimit)
                                    break;
                                 }

                              } /** end i > 0  ****/


                           } /** end this line vertex is a candidate ***/
                        } /** end for i goes thru line vertices ***/
                     } /** end check applies to the line feature ***/
                  rlc = rlc->next;
                  }

               rpc = Proot;
               while(rpc != NULL)
                  {
                  if(rpc->numverts == -1) /*** only looking at pure points, NGA-style ***/
                     {
                     if((CombinedCheckApplies(rpc->idn,checkinstance,CLAMP_DIF,
                       rpc->Lindex,rpc->Sindex,
                        SCCtable[rpc->Sindex].C, SCCtable[rpc->Sindex].S, SCCtable[rpc->Sindex].D,
                               &part1,&part2,&part3) > 0) &&
                          (part1 > 0))
                        {
                       
                        if((rpc->z[0] > ActiveChecks[checkinstance].sensitivity2) &&
                                (rpc->x[0] >= minx) && (rpc->x[0] <= maxx) &&
                                    (rpc->y[0] >= miny) && (rpc->y[0] <= maxy))
                           {
                           E = InterpolateElevationInSpecificGrid(Gindex, ThisGridIndex, rpc->x[0], rpc->y[0], &Znew,
                                                          1, ActiveChecks[checkinstance].sensitivity3, checkinstance);
                           if(E > 0)
                              {
                              if(rpc->z[0] > Znew)
                                 ElevDiff = rpc->z[0] - Znew;
                              else
                                 ElevDiff = Znew - rpc->z[0];

                              if(SensitivityCheck(GTEQ,CLAMP_DIF,checkinstance,ElevDiff) > 0)
                                 {
                                 FwritePointObjectAndMagnitude(CLAMP_DIF,Make_Correct(CLAMP_DIF,checkinstance),ElevDiff,rpc->idn,G_POINT,
                                    rpc->Lindex,rpc->localID, rpc->Sindex, rpc->x[0], rpc->y[0], rpc->z[0], rpc->Sindex, rpc->idn, G_POINT,
                                      rpc->Lindex, rpc->localID, 1, &rpc->x[0], &rpc->y[0], &rpc->z[0]);
                                 }
                              }
                           } /** end this point feature is a candidate ***/

                        }
                     }
                  rpc = rpc->next;
                  } /*** end considering points in this LM ***/

               rac = Aroot;
               while(rac != NULL)
                  {
                  if((CombinedCheckApplies(rac->idn,checkinstance,CLAMP_DIF,rac->Lindex,rac->Sindex,
                     SCCtable[rac->Sindex].C, SCCtable[rac->Sindex].S, SCCtable[rac->Sindex].D,
                             &part1,&part2,&part3) > 0) &&
                         (part1 > 0))
                     {
                     if(rac->RB_Tree_Edgelist != NULL)
                        {
                        LastEdge = NULL;
                        LastI = -1;
                        i = GetNextArealIndex(rac, LastI, 1, &LastEdge, cindex, &UsedTree);
                        LastI = i;
                        }
                     else
                        i = 0;
                     while(i >= 0)
                        {
                        if((rac->z[i] > ActiveChecks[checkinstance].sensitivity2) &&
                                (rac->x[i] >= minx) && (rac->x[i] <= maxx) &&
                                    (rac->y[i] >= miny) && (rac->y[i] <= maxy))
                           {
                           E = InterpolateElevationInSpecificGrid(Gindex, ThisGridIndex, rac->x[i], rac->y[i], &Znew,
                                                          1, ActiveChecks[checkinstance].sensitivity3, checkinstance);
                           if(E > 0)
                              {
                              if(rac->z[i] > Znew)
                                 ElevDiff = rac->z[i] - Znew;
                              else
                                 ElevDiff = Znew - rac->z[i];

                              if(SensitivityCheck(GTEQ,CLAMP_DIF,checkinstance,ElevDiff) > 0)
                                 {
                                 if(i > 0)
                                    ii = i - 1;
                                 else
                                    ii = i;
                                 FwritePointObjectAndMagnitude(CLAMP_DIF,Make_Correct(CLAMP_DIF,checkinstance),ElevDiff,rac->idn,G_AREAL,
                                    rac->Lindex,rac->localID, rac->Sindex, rac->x[i], rac->y[i], rac->z[i], rac->Sindex, rac->idn, G_AREAL,
                                      rac->Lindex, rac->localID, 2, &rac->x[ii], &rac->y[ii], &rac->z[ii]);
                                 }
                              }

                           if(i == 0)
                              ii = rac->numverts - 1;
                           else
                              ii = i - 1;
                           if((rac->z[ii] > ActiveChecks[checkinstance].sensitivity2) && (ActiveChecks[checkinstance].sensitivity4 > 0))
                              {
                              X[0] = rac->x[i];
                              Y[0] = rac->y[i];
                              Z[0] = rac->z[i];
                              if(i == 0)
                                 {
                                 X[1] = rac->x[rac->numverts-1];
                                 Y[1] = rac->y[rac->numverts-1];
                                 Z[1] = rac->z[rac->numverts-1];
                                 }
                              else
                                 {
                                 X[1] = rac->x[i-1];
                                 Y[1] = rac->y[i-1];
                                 Z[1] = rac->z[i-1];
                                 }
                              if(X[0] > X[1])
                                 {
                                 minFx = X[1];
                                 maxFx = X[0];
                                 }
                              else
                                 {
                                 minFx = X[0];
                                 maxFx = X[1];
                                 }
                              gridx = NGT[cindex].BaseX[Gindex];
                              while(gridx <= maxFx)
                                 {
                                 if((gridx >= minFx) && (gridx <= maxFx) && (gridx >= minx) && (gridx <= maxx))
                                    {
                                    gridy =  FindXatYonSegment(gridx, Y[0],X[0],Y[1],X[1]); /* finding Y, not X, so all args switched ... */
                                    if((gridy >= miny) && (gridy <= maxy))
                                       {
                                       E = InterpolateElevationInSpecificGrid(Gindex, ThisGridIndex, gridx, gridy, &Znew,
                                                          1, ActiveChecks[checkinstance].sensitivity3, checkinstance);
                                       if(E > 0)
                                          {
                                          featelev = InterpLinearElev(X[0],Y[0],Z[0],X[1],Y[1],Z[1],gridx,gridy);
                                          if(featelev > Znew)
                                             ElevDiff = featelev - Znew;
                                          else
                                             ElevDiff = Znew - featelev;

                                          if(SensitivityCheck(GTEQ,CLAMP_DIF,checkinstance,ElevDiff) > 0)
                                             {
                                             FwritePointObjectAndMagnitude(CLAMP_DIF,Make_Correct(CLAMP_DIF,checkinstance),ElevDiff,
                                                   rac->idn,G_AREAL,
                                                rac->Lindex,rac->localID, rac->Sindex, gridx,gridy,featelev, rac->Sindex, rac->idn, G_AREAL,
                                                  rac->Lindex, rac->localID, 2, &X[0], &Y[0], &Z[0]);
                                             }


                                          }
                                       }

                                    }
                                 gridx += GridHeader[j].Xspacing;
                                 if(gridx >= Xgridcoordlimit)
                                    break;
                                 }

                              if(Y[0] > Y[1])
                                 {
                                 minFy = Y[1];
                                 maxFy = Y[0];
                                 }
                              else
                                 {
                                 minFy = Y[0];
                                 maxFy = Y[1];
                                 }
                              gridy = NGT[cindex].BaseY[Gindex];
                              while(gridy <= maxFy)
                                 {
                                 if((gridy >= minFy) && (gridy <= maxFy) && (gridy >= miny) && (gridy <= maxy))
                                    {
                                    gridx =  FindXatYonSegment(gridy, X[0],Y[0],X[1],Y[1]);
                                    if((gridx >= minx) && (gridx <= maxx))
                                       {
                                       E = InterpolateElevationInSpecificGrid(Gindex, ThisGridIndex, gridx, gridy, &Znew,
                                                          1, ActiveChecks[checkinstance].sensitivity3, checkinstance);
                                       if(E > 0)
                                          {
                                          featelev = InterpLinearElev(X[0],Y[0],Z[0],X[1],Y[1],Z[1],gridx,gridy);
                                          if(featelev > Znew)
                                             ElevDiff = featelev - Znew;
                                          else
                                             ElevDiff = Znew - featelev;

                                          if(SensitivityCheck(GTEQ,CLAMP_DIF,checkinstance,ElevDiff) > 0)
                                             {
                                             FwritePointObjectAndMagnitude(CLAMP_DIF,Make_Correct(CLAMP_DIF,checkinstance),ElevDiff,
                                                   rac->idn,G_AREAL,
                                                rac->Lindex,rac->localID, rac->Sindex, gridx,gridy,featelev, rac->Sindex, rac->idn, G_AREAL,
                                                  rac->Lindex, rac->localID, 2, &X[0], &Y[0], &Z[0]);
                                             }
                                          }
                                       }

                                    }
                                 gridy += GridHeader[j].Yspacing;
                                 if(gridy >= Ygridcoordlimit)
                                    break;
                                 }

                              } /** end i > 0  ****/


                           } /** end this area feature vertex is a candidate ***/
                        if(rac->RB_Tree_Edgelist != NULL)
                           {
                           i = GetNextArealIndex(rac, LastI, 1, &LastEdge, cindex, &UsedTree);
                           LastI = i;
                           }
                        else
                           {
                           ++i;
                           if(i >= rac->numverts)
                              i = -1;
                           }
                        } /** end for i goes thru area vertices ***/
                     } /** end check applies to the area feature ***/
                  rac = rac->next;
                  } /*** end looking at area features in this LM ***/

               } /** end CLAMP_DIF check applies to grid [j] ***/



            if((CombinedCheckApplies(GridHeader[j].idn,checkinstance,GRID_STD_DEV,LI,SI,
                 SCCtable[SI].C, SCCtable[SI].S, SCCtable[SI].D,
               &part1,&part2,&part3) >  0) && (part1 > 0))
               {
               ShadowGrid = NULL;
               NumGridPts = MG[Gindex].numX * MG[Gindex].numY;
               ThisGridIndex = NGT[cindex].GridIndex[Gindex];
               rac = Aroot;
               while(rac != NULL)
                  {
                  if((CombinedCheckApplies(rac->idn,checkinstance,GRID_STD_DEV,rac->Lindex,rac->Sindex,
                     SCCtable[rac->Sindex].C, SCCtable[rac->Sindex].S, SCCtable[rac->Sindex].D,
                             &part1,&part2,&part3) > 0) &&
                         (part2 > 0))
                     {
                     if(ShadowGrid == NULL)
                        {
                        ShadowGrid = (double *) (malloc(SzD * (NumGridPts + 1)));
                        UsedShadow = (int *) (malloc(SzI * (NumGridPts + 1)));
                        }
                     for(i = 0; i <= NumGridPts; i++)
                        UsedShadow[i] = 0;

                     iX = 0;
                     NumToAverage = 0;
                     TotalForAverage = 0.0;
                     for(grows = 0; grows < MG[Gindex].numX; grows++)
                        {
                        gridx = MG[Gindex].SouthWestX + ((double) iX * MG[Gindex].Xspace);
                        if((gridx >= minx) && (gridx <= maxx))
                           {
                           iY = 0;
                           for(gcols = 0; gcols < MG[Gindex].numY; gcols++)
                              {
                              gridy = MG[Gindex].SouthWestY + ((double) iY * MG[Gindex].Yspace);
            
                              if((gridy >= miny) && (gridy <= maxy))
                                 {
                                 index = (iX * MG[Gindex].numY) + iY;
                                 Znew = MG[Gindex].Elevs[index];
                                 if(Znew > ActiveChecks[checkinstance].sensitivity2)
                                    {
                                    Inside = 0;
                                    if(rac->RB_Tree_Edgelist == NULL)
                                       {
                                       Inside = PointIsInside(gridx,gridy,rac->x,rac->y,rac->z,rac->numverts,C_AREA,&unuseddbl);
                                       }
                                    else
                                       {
                                       Inside = PointInsideLargeAreal(gridx, gridy, rac,&unusedint);
                                       }
                                    if(Inside > 0)
                                       {
                                       index = (iX * MG[Gindex].numY) + iY;
                                       ShadowGrid[index] = MG[Gindex].Elevs[index];
                                       UsedShadow[index] = 1;
                                       NumToAverage += 1;
                                       TotalForAverage += MG[Gindex].Elevs[index];
                                       }
                                    }
                                 } /** end gridy is in LM ***/
                              ++iY;
                              } /*** end for gcols ***/
                           } /** end gridx is in LM ***/
                        ++iX;
                       } /** end for grows ****/
                    if(NumToAverage > 0)
                       {
                       MeanValue = TotalForAverage / ((double) NumToAverage);
                       iX = 0;
                       for(grows = 0; grows < MG[Gindex].numX; grows++)
                          {
                          gridx = MG[Gindex].SouthWestX + ((double) iX * MG[Gindex].Xspace);
                          if((gridx >= minx) && (gridx <= maxx))
                             {
                             iY = 0;
                             for(gcols = 0; gcols < MG[Gindex].numY; gcols++)
                                {
                                gridy = MG[Gindex].SouthWestY + ((double) iY * MG[Gindex].Yspace);
  
                                if((gridy >= miny) && (gridy <= maxy))
                                   {
                                   index = (iX * MG[Gindex].numY) + iY;
                                   if(UsedShadow[index] == 1)
                                      {
                                      StdDevMeasure = ShadowGrid[index] - MeanValue;
                                      if(StdDevMeasure < 0)
                                         StdDevMeasure = 0 - StdDevMeasure;
                                      if(SensitivityCheck(GT, GRID_STD_DEV, checkinstance, StdDevMeasure) > 0)
                                         {
                                         pseudoLID1 = (j+ 1) * (gridx + (1.0 / gridy));
                                         FwriteObjectAndMagnitude(GRID_STD_DEV,Make_Correct(GRID_STD_DEV,checkinstance),
                                             GridHeader[j].idn, SI, G_GRIDPT,LI,pseudoLID1, -1.0,-1.0,
                                              StdDevMeasure, &gridx, &gridy, &ShadowGrid[index], 1, 1);

                                         }
                                      }
                                   } /** end gridy is in LM ***/
                                ++iY;
                                } /*** end for gcols ***/
                             } /** end gridx is in LM ***/
                         ++iX;
                         } /** end for grows ****/
                       }
                     } /** end check applies to the area feature ***/
                  rac = rac->next;
                  } /*** end looking at area features in this LM ***/

               if(ShadowGrid != NULL)
                  {
                  free(ShadowGrid);
                  free(UsedShadow);
                  ShadowGrid = NULL;
                  UsedShadow = NULL;
                  }
               } /** end GRID_STD_DEV check applies to grid [j] ***/





            if((CombinedCheckApplies(GridHeader[j].idn,checkinstance,CLAMP_SEG,LI,SI,
                 SCCtable[SI].C, SCCtable[SI].S, SCCtable[SI].D,
               &part1,&part2,&part3) >  0) && (part2 > 0))
               {
               Xgridcoordlimit = NGT[cindex].BaseX[Gindex] + (NGT[cindex].NumCols[Gindex] * GridHeader[j].Xspacing);
               Ygridcoordlimit = NGT[cindex].BaseY[Gindex] + (NGT[cindex].NumRows[Gindex] * GridHeader[j].Yspacing);
               ThisGridIndex = NGT[cindex].GridIndex[Gindex];
               rlc = Lroot;
               while(rlc != NULL)
                  {
                  if((CombinedCheckApplies(rlc->idn,checkinstance,CLAMP_SEG,rlc->Lindex,rlc->Sindex,
                     SCCtable[rlc->Sindex].C, SCCtable[rlc->Sindex].S, SCCtable[rlc->Sindex].D,
                             &part1,&part2,&part3) > 0) &&
                         (part1 > 0))
                     {
                     for(i=0; i<rlc->numnodes; i++)
                        {
                        if((tempis2D(rlc->z[i]) == 0) && (rlc->z[i] > ActiveChecks[checkinstance].sensitivity2) &&
                                (rlc->x[i] >= minx) && (rlc->x[i] <= maxx) &&
                                    (rlc->y[i] >= miny) && (rlc->y[i] <= maxy))
                           {
                           E = InterpolateElevationInSpecificGrid(Gindex, ThisGridIndex, rlc->x[i], rlc->y[i], &Znew,
                                                          1, ActiveChecks[checkinstance].sensitivity3, checkinstance);
                           if(E > 0)
                              {
                              ElevDiff = rlc->z[i] - Znew;

                              if(SensitivityCheck(LTEQ,CLAMP_SEG,checkinstance,ElevDiff) > 0)
                                 {
                                 if(i > 0)
                                    ii = i - 1;
                                 else
                                    ii = i;
                                 pseudoLID1 = (j+ 1) * (rlc->x[i] + (1.0 / rlc->y[i]));
                                 FwriteMagnitudeAndTwoObjects(CLAMP_SEG,Make_Correct(CLAMP_SEG,checkinstance),ElevDiff,
                                           SI,G_GRIDPT,LI,pseudoLID1,GridHeader[j].idn,-1.0,-1.0,
                                           &rlc->x[i], &rlc->y[i], &Znew, 1,
                                           rlc->Sindex, G_LINE,rlc->Lindex,rlc->localID,rlc->idn, -1.0, -1.0,
                                            &rlc->x[ii], &rlc->y[ii], &rlc->z[ii], 2);
                                 }
                              }
                           if((i > 0) && (rlc->z[i-1] > ActiveChecks[checkinstance].sensitivity2))
                              {
                              ii = i - 1;
                              if(rlc->x[i] > rlc->x[ii])
                                 {
                                 minFx = rlc->x[ii];
                                 maxFx = rlc->x[i];
                                 }
                              else
                                 {
                                 minFx = rlc->x[i];
                                 maxFx = rlc->x[ii];
                                 }
                              gridx = NGT[cindex].BaseX[Gindex];
                              while(gridx <= maxFx)
                                 {
                                 if((gridx >= minFx) && (gridx <= maxFx) && (gridx >= minx) && (gridx <= maxx))
                                    {
                                    gridy =  FindXatYonSegment(gridx, rlc->y[i],rlc->x[i],rlc->y[ii],rlc->x[ii]); /* finding Y, not X, so all args switched ... */
                                    if((gridy >= miny) && (gridy <= maxy))
                                       {
                                       E = InterpolateElevationInSpecificGrid(Gindex, ThisGridIndex, gridx, gridy, &Znew,
                                                          1, ActiveChecks[checkinstance].sensitivity3, checkinstance);
                                       if(E > 0)
                                          {
                                          featelev = InterpLinearElev(rlc->x[i],rlc->y[i],rlc->z[i],rlc->x[ii],rlc->y[ii],rlc->z[ii],gridx,gridy);
                                          ElevDiff = featelev - Znew;
         
                                          if(SensitivityCheck(LTEQ,CLAMP_SEG,checkinstance,ElevDiff) > 0)
                                             {
                                             pseudoLID1 = (j+ 1) * (gridx + (1.0 / gridy));
                                             FwriteMagnitudeAndTwoObjects(CLAMP_SEG,Make_Correct(CLAMP_SEG,checkinstance),ElevDiff,
                                               SI,G_GRIDPT,LI,pseudoLID1,GridHeader[j].idn,-1.0,-1.0,
                                               &gridx, &gridy, &Znew, 1,
                                               rlc->Sindex, G_LINE,rlc->Lindex,rlc->localID,rlc->idn, -1.0, -1.0,
                                                &rlc->x[ii], &rlc->y[ii], &rlc->z[ii], 2);
                                             }
                                          }
                                       }

                                    }
                                 gridx += GridHeader[j].Xspacing;
                                 if(gridx >= Xgridcoordlimit)
                                    break;
                                 }

                              if(rlc->y[i] > rlc->y[ii])
                                 {
                                 minFy = rlc->y[ii];
                                 maxFy = rlc->y[i];
                                 }
                              else
                                 {
                                 minFy = rlc->y[i];
                                 maxFy = rlc->y[ii];
                                 }
                              gridy = NGT[cindex].BaseY[Gindex];
                              while(gridy <= maxFy)
                                 {
                                 if((gridy >= minFy) && (gridy <= maxFy) && (gridy >= miny) && (gridy <= maxy))
                                    {
                                    gridx =  FindXatYonSegment(gridy, rlc->x[i],rlc->y[i],rlc->x[ii],rlc->y[ii]); 
                                    if((gridx >= minx) && (gridx <= maxx))
                                       {
                                       E = InterpolateElevationInSpecificGrid(Gindex, ThisGridIndex, gridx, gridy, &Znew,
                                                          1, ActiveChecks[checkinstance].sensitivity3, checkinstance);
                                       if(E > 0)
                                          {
                                          featelev = InterpLinearElev(rlc->x[i],rlc->y[i],rlc->z[i],rlc->x[ii],rlc->y[ii],rlc->z[ii],gridx,gridy);
                                          ElevDiff = featelev - Znew;

                                          if(SensitivityCheck(LTEQ,CLAMP_SEG,checkinstance,ElevDiff) > 0)
                                             {
                                             pseudoLID1 = (j+ 1) * (gridx + (1.0 / gridy));
                                             FwriteMagnitudeAndTwoObjects(CLAMP_SEG,Make_Correct(CLAMP_SEG,checkinstance),ElevDiff,
                                               SI,G_GRIDPT,LI,pseudoLID1,GridHeader[j].idn,-1.0,-1.0,
                                               &gridx, &gridy, &Znew, 1,
                                               rlc->Sindex, G_LINE,rlc->Lindex,rlc->localID,rlc->idn, -1.0, -1.0,
                                                &rlc->x[ii], &rlc->y[ii], &rlc->z[ii], 2);
                                             }
                                          }
                                       }

                                    }
                                 gridy += GridHeader[j].Yspacing;
                                 if(gridy >= Ygridcoordlimit)
                                    break;
                                 }

                              } /** end i > 0  ****/
                           } /** end this line vertex is a candidate ***/
                        } /** end for i goes thru line vertices ***/
                     } /** end check applies to the line feature ***/
                  rlc = rlc->next;
                  }

               rac = Aroot;
               while(rac != NULL)
                  {
                  if((CombinedCheckApplies(rac->idn,checkinstance,CLAMP_SEG,rac->Lindex,rac->Sindex,
                     SCCtable[rac->Sindex].C, SCCtable[rac->Sindex].S, SCCtable[rac->Sindex].D,
                             &part1,&part2,&part3) > 0) &&
                         (part1 > 0))
                     {
                     if(rac->RB_Tree_Edgelist != NULL)
                        {
                        LastEdge = NULL;
                        LastI = -1;
                        i = GetNextArealIndex(rac, LastI, 1, &LastEdge, cindex, &UsedTree);
                        LastI = i;
                        }
                     else
                        i = 0;
                     while(i >= 0)
                        {
                        if((tempis2D(rac->z[i]) == 0) && (rac->z[i] > ActiveChecks[checkinstance].sensitivity2) &&
                                (rac->x[i] >= minx) && (rac->x[i] <= maxx) &&
                                    (rac->y[i] >= miny) && (rac->y[i] <= maxy))
                           {
                           E = InterpolateElevationInSpecificGrid(Gindex, ThisGridIndex, rac->x[i], rac->y[i], &Znew,
                                                          1, ActiveChecks[checkinstance].sensitivity3, checkinstance);
                           if(E > 0)
                              {
                              ElevDiff = rac->z[i] - Znew;

                              if(SensitivityCheck(LTEQ,CLAMP_SEG,checkinstance,ElevDiff) > 0)
                                 {
                                 if(i > 0)
                                    ii = i - 1;
                                 else
                                    ii = i;
                                 pseudoLID1 = (j+ 1) * (rac->x[i] + (1.0 / rac->y[i]));
                                 FwriteMagnitudeAndTwoObjects(CLAMP_SEG,Make_Correct(CLAMP_SEG,checkinstance),ElevDiff,
                                           SI,G_GRIDPT,LI,pseudoLID1,GridHeader[j].idn,-1.0,-1.0,
                                           &rac->x[i], &rac->y[i], &Znew, 1,
                                           rac->Sindex, G_AREAL,rac->Lindex,rac->localID,rac->idn, -1.0, -1.0,
                                            &rac->x[ii], &rac->y[ii], &rac->z[ii], 2);
                                 }
                              }
                           if(i == 0)
                              ii = rac->numverts - 1;
                           else
                              ii = i - 1;
                           if((rac->z[ii] > ActiveChecks[checkinstance].sensitivity2))
                              {
                              X[0] = rac->x[i];
                              Y[0] = rac->y[i];
                              Z[0] = rac->z[i];
                              if(i == 0)
                                 {
                                 X[1] = rac->x[rac->numverts-1];
                                 Y[1] = rac->y[rac->numverts-1];
                                 Z[1] = rac->z[rac->numverts-1];
                                 }
                              else
                                 {
                                 X[1] = rac->x[i-1];
                                 Y[1] = rac->y[i-1];
                                 Z[1] = rac->z[i-1];
                                 }
                              if(X[0] > X[1])
                                 {
                                 minFx = X[1];
                                 maxFx = X[0];
                                 }
                              else
                                 {
                                 minFx = X[0];
                                 maxFx = X[1];
                                 }
                              gridx = NGT[cindex].BaseX[Gindex];
                              while(gridx <= maxFx)
                                 {
                                 if((gridx >= minFx) && (gridx <= maxFx) && (gridx >= minx) && (gridx <= maxx))
                                    {
                                    gridy =  FindXatYonSegment(gridx, Y[0],X[0],Y[1],X[1]); /* finding Y, not X, so all args switched ... */
                                    if((gridy >= miny) && (gridy <= maxy))
                                       {
                                       E = InterpolateElevationInSpecificGrid(Gindex, ThisGridIndex, gridx, gridy, &Znew,
                                                          1, ActiveChecks[checkinstance].sensitivity3, checkinstance);
                                       if(E > 0)
                                          {
                                          featelev = InterpLinearElev(X[0],Y[0],Z[0],X[1],Y[1],Z[1],gridx,gridy);
                                          ElevDiff = featelev - Znew;

                                          if(SensitivityCheck(LTEQ,CLAMP_SEG,checkinstance,ElevDiff) > 0)
                                             {
                                             pseudoLID1 = (j+ 1) * (gridx + (1.0 / gridy));
                                             FwriteMagnitudeAndTwoObjects(CLAMP_SEG,Make_Correct(CLAMP_SEG,checkinstance),ElevDiff,
                                               SI,G_GRIDPT,LI,pseudoLID1,GridHeader[j].idn,-1.0,-1.0,
                                               &gridx, &gridy, &Znew, 1,
                                               rac->Sindex, G_AREAL,rac->Lindex,rac->localID,rac->idn, -1.0, -1.0,
                                                &X[0], &Y[0], &Z[0], 2);
                                             }
                                          }
                                       }

                                    }
                                 gridx += GridHeader[j].Xspacing;
                                 if(gridx >= Xgridcoordlimit)
                                    break;
                                 }

                              if(Y[0] > Y[1])
                                 {
                                 minFy = Y[1];
                                 maxFy = Y[0];
                                 }
                              else
                                 {
                                 minFy = Y[0];
                                 maxFy = Y[1];
                                 }
                              gridy = NGT[cindex].BaseY[Gindex];
                              while(gridy <= maxFy)
                                 {
                                 if((gridy >= minFy) && (gridy <= maxFy) && (gridy >= miny) && (gridy <= maxy))
                                    {
                                    gridx =  FindXatYonSegment(gridy, X[0],Y[0],X[1],Y[1]);
                                    if((gridx >= minx) && (gridx <= maxx))
                                       {
                                       E = InterpolateElevationInSpecificGrid(Gindex, ThisGridIndex, gridx, gridy, &Znew,
                                                          1, ActiveChecks[checkinstance].sensitivity3, checkinstance);
                                       if(E > 0)
                                          {
                                          featelev = InterpLinearElev(X[0],Y[0],Z[0],X[1],Y[1],Z[1],gridx,gridy);
                                          ElevDiff = featelev - Znew;

                                          if(SensitivityCheck(LTEQ,CLAMP_SEG,checkinstance,ElevDiff) > 0)
                                             {
                                             pseudoLID1 = (j+ 1) * (gridx + (1.0 / gridy));
                                             FwriteMagnitudeAndTwoObjects(CLAMP_SEG,Make_Correct(CLAMP_SEG,checkinstance),ElevDiff,
                                               SI,G_GRIDPT,LI,pseudoLID1,GridHeader[j].idn,-1.0,-1.0,
                                               &gridx, &gridy, &Znew, 1,
                                               rac->Sindex, G_AREAL,rac->Lindex,rac->localID,rac->idn, -1.0, -1.0,
                                                &X[0], &Y[0], &Z[0], 2);
                                             }
                                          }
                                       }

                                    }
                                 gridy += GridHeader[j].Yspacing;
                                 if(gridy >= Ygridcoordlimit)
                                    break;
                                 }

                              } /** end i > 0  ****/
                           } /** end this area vertex is a candidate ***/
                        if(rac->RB_Tree_Edgelist != NULL)
                           {
                           i = GetNextArealIndex(rac, LastI, 1, &LastEdge, cindex, &UsedTree);
                           LastI = i;
                           }
                        else
                           {
                           ++i;
                           if(i >= rac->numverts)
                              i = -1;
                           }

                        } /** end for i goes thru area vertices ***/
                     } /** end check applies to the area feature ***/
                  rac = rac->next;
                  }


               } /** end CLAMP_SEG check applies to grid as secondary ***/



            if((CombinedCheckApplies(GridHeader[j].idn,checkinstance,CLAMP_SDC,LI,SI,
                 SCCtable[SI].C, SCCtable[SI].S, SCCtable[SI].D,
                             &part1,&part2,&part3) >  0) && (part2 > 0))
               {
               ThisGridIndex = NGT[cindex].GridIndex[Gindex];
               rlc = Lroot;
               while(rlc != NULL)
                  {
                  if((CombinedCheckApplies(rlc->idn,checkinstance,CLAMP_SDC,rlc->Lindex,rlc->Sindex,
                     SCCtable[rlc->Sindex].C, SCCtable[rlc->Sindex].S, SCCtable[rlc->Sindex].D,
                             &part1,&part2,&part3) > 0) &&
                         (part1 > 0))
                     {
                     if(rlc->numnodes > NumShadowElevations)
                        {
                        NumShadowElevations = rlc->numnodes + 100;
                        ShadowElevations = (double *) (realloc(ShadowElevations,SzD * NumShadowElevations));
                        }
                     for(i = 0; i< rlc->numnodes; i++)
                        ShadowElevations[i] = -59999.90909;
                     for(i=0; i<rlc->numnodes; i++)
                        {
                        if((rlc->x[i] >= minx) && (rlc->x[i] <= maxx) &&
                                    (rlc->y[i] >= miny) && (rlc->y[i] <= maxy))
                           {
                           E = InterpolateElevationInSpecificGrid(Gindex, ThisGridIndex, rlc->x[i], rlc->y[i], &Znew,
                                                          0, ActiveChecks[checkinstance].sensitivity3, checkinstance);
                           if(E > 0)
                              {
                              ShadowElevations[i] = Znew;
                              }
                           } /** end this line vertex is in the LM ***/
                        } /** end reset ShadowElevation Values ***/

                     ii = j = rlc->numnodes;
                     for(i=0; i< rlc->numnodes; i++)
                        {
                        if((ShadowElevations[i] != -59999.90909) && (IsSentinelZvalue(ShadowElevations[i],UseNUNANPO) == 0))
                           {
                           ii = i;
                           break;
                           }
                        }
                     for(i=ii+1; i<rlc->numnodes; i++)
                        {
                        if((ShadowElevations[i] != -59999.90909) && (IsSentinelZvalue(ShadowElevations[i],UseNUNANPO) == 0))
                           {
                           j = i;
                           break;
                           }
                        }
                     for(i=j+1; i < rlc->numnodes; i++)
                        {
                        kk = 0;
                        ii3 = 0;
                        if((ShadowElevations[i] != -59999.90909) && (IsSentinelZvalue(ShadowElevations[i],UseNUNANPO) == 0))
                           {
                           ii3 = 1;
                           kk = 0;
                           if((ShadowElevations[ii] > ShadowElevations[j]) && (ShadowElevations[i] > ShadowElevations[j]))
                              kk = 1; /** may have a condition ***/
                           else if((ShadowElevations[ii] < ShadowElevations[j]) && (ShadowElevations[i] < ShadowElevations[j]))
                              kk = 1; /** may have a condition ***/
                           }
                        if((kk > 0) && ((ii + 1) == j) && ((j + 1) == i))
                           {
                           basedist = Distance(rlc->x[ii],rlc->y[ii],rlc->x[j],rlc->y[j]);
                           segdist = Distance(rlc->x[i],rlc->y[i],rlc->x[j],rlc->y[j]);
                           z4 = ShadowElevations[j] - ShadowElevations[ii];
                           z3 = ShadowElevations[i] - ShadowElevations[j];
                           slopeangle1 = atan(z3 / segdist);
                           slopeangle2 = atan(z4 / basedist);

                           if(slopeangle2 > slopeangle1)
                              temp = slopeangle2 - slopeangle1;
                           else
                              temp = slopeangle1 - slopeangle2;

                           temp = RadiansToDegrees(temp);

                           z3 = -100.0;

                           if(SensitivityCheck(GTEQ, CLAMP_SDC, checkinstance, temp) > 0)
                              {
                              if((ShadowElevations[j] > ShadowElevations[i]) && (ShadowElevations[j] > ShadowElevations[ii]))
                                 {
                                 z1 = ShadowElevations[j] - ShadowElevations[ii];
                                 z2 = ShadowElevations[j] - ShadowElevations[i];
                                 if(z1 < z2)
                                    z3 = z1;
                                 else
                                    z3 = z2;
                                 }
                              else
                                 {
                                 z1 = ShadowElevations[ii] - ShadowElevations[j];
                                 z2 = ShadowElevations[i] - ShadowElevations[j];
                                 if(z1 < z2)
                                    z3 = z1;
                                 else
                                    z3 = z2;
                                 }
                              }
                           if(z3 > ActiveChecks[checkinstance].sensitivity2)
                              {
                              ERc = (struct collection *) (malloc(SzC));
                              if(ERc == NULL)
                                 {
                                 printf("allocation memory exhausted during linear feature condition analysis\n");
                                 printf("processing cannot continue\n");
                                 exit(-1);
                                 }
                              ERc->x[0] = rlc->x[ii];
                              ERc->y[0] = rlc->y[ii];
                              ERc->z[0] = ShadowElevations[ii];
                              ERc->magnitude = temp;
                              ERc->keyval = CLAMP_SDC;
                              ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                              ERc->ll = rlc;
                              ERc->Sindex = rlc->Sindex;
                              ERc->aa = NULL;
                              ERc->pp = NULL;
                              ERc->next = NULL;
                              if(ERroot == NULL)
                                 {
                                 ERc->x[1] = rlc->x[j];
                                 ERc->y[1] = rlc->y[j];
                                 ERc->z[1] = ShadowElevations[j];
                                 ERc->x[2] = rlc->x[i];
                                 ERc->y[2] = rlc->y[i];
                                 ERc->z[2] = ShadowElevations[i];
                                 ERroot = ERc;
                                 }
                              else
                                 {
                                 ERn = ERroot;
                                 while(ERn != NULL)
                                    {
                                    if((ERn->Cnumber == ERc->Cnumber) && (ERn->keyval == ERc->keyval) &&
                                        (ERn->magnitude == ERc->magnitude) && (ERn->ll == ERc->ll))
                                       break;
   /*****/
                                    ERn = ERn->next;
                                    }
                                 if(ERn == NULL)
                                    {
                                    ERc->x[1] = rlc->x[j];
                                    ERc->y[1] = rlc->y[j];
                                    ERc->z[1] = ShadowElevations[j];
                                    ERc->x[2] = rlc->x[i];
                                    ERc->y[2] = rlc->y[i];
                                    ERc->z[2] = ShadowElevations[i];
                                    ERc->next = ERroot;
                                    ERroot = ERc;
                                    }
                                 else
                                    free(ERc);
                                 }
                              }
                           }
                        if(ii3 > 0)
                           {
                           ii = j;
                           j = i;
                           }
                        }
                     } /** end check applies to the line feature ***/
                  rlc = rlc->next;
                  }


               rac = Aroot;
               while(rac != NULL)
                  {
                  if((CombinedCheckApplies(rac->idn,checkinstance,CLAMP_SDC,rac->Lindex,rac->Sindex,
                     SCCtable[rac->Sindex].C, SCCtable[rac->Sindex].S, SCCtable[rac->Sindex].D,
                             &part1,&part2,&part3) > 0) &&
                         (part1 > 0))
                     {
                     if(rac->numverts > NumShadowElevations)
                        {
                        NumShadowElevations = rac->numverts + 100;
                        ShadowElevations = (double *) (realloc(ShadowElevations,SzD * NumShadowElevations));
                        }
                     for(i = 0; i< rac->numverts; i++)
                        ShadowElevations[i] = -59999.90909;
                     for(i=0; i<rac->numverts; i++)
                        {
                        if((rac->x[i] >= minx) && (rac->x[i] <= maxx) &&
                                    (rac->y[i] >= miny) && (rac->y[i] <= maxy))
                           {
                           E = InterpolateElevationInSpecificGrid(Gindex, ThisGridIndex, rac->x[i], rac->y[i], &Znew,
                                                          0, ActiveChecks[checkinstance].sensitivity3, checkinstance);
                           if(E > 0)
                              {
                              ShadowElevations[i] = Znew;
                              }
                           } /** end this line vertex is in the LM ***/
                        } /** end reset ShadowElevation Values ***/

                     ii = j = rac->numverts;
                     for(i=0; i< rac->numverts; i++)
                        {
                        if((ShadowElevations[i] != -59999.90909) && (IsSentinelZvalue(ShadowElevations[i],UseNUNANPO) == 0))
                           {
                           ii = i;
                           break;
                           }
                        }
                     for(i=ii+1; i<rac->numverts; i++)
                        {
                        if((ShadowElevations[i] != -59999.90909) && (IsSentinelZvalue(ShadowElevations[i],UseNUNANPO) == 0))
                           {
                           j = i;
                           break;
                           }
                        }
                     for(i=j+1; i < rac->numverts; i++)
                        {
                        kk = 0;
                        ii3 = 0;
                        if((ShadowElevations[i] != -59999.90909) && (IsSentinelZvalue(ShadowElevations[i],UseNUNANPO) == 0))
                           {
                           ii3 = 1;
                           kk = 0;
                           if((ShadowElevations[ii] > ShadowElevations[j]) && (ShadowElevations[i] > ShadowElevations[j]))
                              kk = 1; /** may have a condition ***/
                           else if((ShadowElevations[ii] < ShadowElevations[j]) && (ShadowElevations[i] < ShadowElevations[j]))
                              kk = 1; /** may have a condition ***/
                           }
                        if(kk > 0)
                           {
                           basedist = Distance(rac->x[ii],rac->y[ii],rac->x[j],rac->y[j]);
                           segdist = Distance(rac->x[i],rac->y[i],rac->x[j],rac->y[j]);
                           z4 = ShadowElevations[j] - ShadowElevations[ii];
                           z3 = ShadowElevations[i] - ShadowElevations[j];
                           slopeangle1 = atan(z3 / segdist);
                           slopeangle2 = atan(z4 / basedist);

                           if(slopeangle2 > slopeangle1)
                              temp = slopeangle2 - slopeangle1;
                           else
                              temp = slopeangle1 - slopeangle2;

                           temp = RadiansToDegrees(temp);

                           z1 = -1000.0;
                           if(SensitivityCheck(GTEQ, CLAMP_SDC, checkinstance, temp) > 0)
                              {
                              if((ShadowElevations[j] > ShadowElevations[i]) && (ShadowElevations[j] > ShadowElevations[ii]))
                                 {
                                 z1 = ShadowElevations[j] - ShadowElevations[ii];
                                 z2 = ShadowElevations[j] - ShadowElevations[i];
                                 if(z1 < z2)
                                    z3 = z1;
                                 else
                                    z3 = z2;
                                 }
                              else
                                 {
                                 z1 = ShadowElevations[ii] - ShadowElevations[j];
                                 z2 = ShadowElevations[i] - ShadowElevations[j];
                                 if(z1 < z2)
                                    z3 = z1;
                                 else
                                    z3 = z2;
                                 }

                              }
                           if(z1 > ActiveChecks[checkinstance].sensitivity2)
                              {
                              ERc = (struct collection *) (malloc(SzC));
                              if(ERc == NULL)
                                 {
                                 printf("allocation memory exhausted during linear feature condition analysis\n");
                                 printf("processing cannot continue\n");
                                 exit(-1);
                                 }
                              ERc->x[0] = rac->x[ii];
                              ERc->y[0] = rac->y[ii];
                              ERc->z[0] = ShadowElevations[ii];
                              ERc->magnitude = temp;
                              ERc->keyval = CLAMP_SDC;
                              ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                              ERc->aa = rac;
                              ERc->Sindex = rac->Sindex;
                              ERc->ll = NULL;
                              ERc->pp = NULL;
                              ERc->next = NULL;
                              if(ERroot == NULL)
                                 {
                                 ERc->x[1] = rac->x[j];
                                 ERc->y[1] = rac->y[j];
                                 ERc->z[1] = ShadowElevations[j];
                                 ERc->x[2] = rac->x[i];
                                 ERc->y[2] = rac->y[i];
                                 ERc->z[2] = ShadowElevations[i];
                                 ERroot = ERc;
                                 }
                              else
                                 {
                                 ERn = ERroot;
                                 while(ERn != NULL)
                                    {
                                    if((ERn->Cnumber == ERc->Cnumber) && (ERn->keyval == ERc->keyval) &&
                                        (ERn->magnitude == ERc->magnitude) && (ERn->aa == ERc->aa))
                                       break;
   /*****/
                                    ERn = ERn->next;
                                    }
                                 if(ERn == NULL)
                                    {
                                    ERc->x[1] = rac->x[j];
                                    ERc->y[1] = rac->y[j];
                                    ERc->z[1] = ShadowElevations[j];
                                    ERc->x[2] = rac->x[i];
                                    ERc->y[2] = rac->y[i];
                                    ERc->z[2] = ShadowElevations[i];
                                    ERc->next = ERroot;
                                    ERroot = ERc;
                                    }
                                 else
                                    free(ERc);
                                 }
                              }
                           }
                        if(ii3 > 0)
                           {
                           ii = j;
                           j = i;
                           }
                        }
                     } /** end check applies to the line feature ***/
                  rac = rac->next;
                  }

               } /*** end CLAMP_SDC check applies to the grid ****/




            if((CombinedCheckApplies(GridHeader[j].idn,checkinstance,CLAMP_JOINSDC,LI,SI,
                 SCCtable[SI].C, SCCtable[SI].S, SCCtable[SI].D,
                             &part1,&part2,&part3) >  0) && (part3 > 0))
               {
               ThisGridIndex = NGT[cindex].GridIndex[Gindex];
               rlc = Lroot;
               while(rlc != NULL)
                  {
                  if((CombinedCheckApplies(rlc->idn,checkinstance,CLAMP_JOINSDC,rlc->Lindex,rlc->Sindex,
                     SCCtable[rlc->Sindex].C, SCCtable[rlc->Sindex].S, SCCtable[rlc->Sindex].D,
                             &part1,&part2,&part3) > 0) &&
                         (part1 > 0))
                     {
                     i = 0;
                     while(i < rlc->numnodes)
                        {
                        found_one = -1;
                        if((rlc->x[i] >= minx) && (rlc->x[i] <= maxx) &&
                                    (rlc->y[i] >= miny) && (rlc->y[i] <= maxy))
                           {
                           X[1] = rlc->x[i];
                           Y[1] = rlc->y[i];
                           E = InterpolateElevationInSpecificGrid(Gindex, ThisGridIndex, rlc->x[i], rlc->y[i], &Znew,
                                                          0, ActiveChecks[checkinstance].sensitivity3, checkinstance);
                           if(E > 0)
                              {
                              Z[1] = Znew;
                              if(i == 0)
                                j = 1;
                              else
                                j = i - 1;
                              X[0] = rlc->x[j];
                              Y[0] = rlc->y[j];
                              E = InterpolateElevationInSpecificGrid(Gindex, ThisGridIndex, rlc->x[j], rlc->y[j], &Znew,
                                                             0, ActiveChecks[checkinstance].sensitivity3, checkinstance);
                              if((E > 0) && (Znew != Z[1])) /*** give up if have no slope  ****/
                                 {
                                 Z[0] = Znew;
                                 rln = Lroot;
                                 while(rln != NULL)
                                    {
                                    if((rln != rlc) &&
                                      (CombinedCheckApplies(rln->idn,checkinstance,CLAMP_JOINSDC,rln->Lindex,rln->Sindex,
                                       SCCtable[rln->Sindex].C, SCCtable[rln->Sindex].S, SCCtable[rln->Sindex].D,
                                               &part1,&part2,&part3) > 0) &&
                                           (part2 > 0))
                                       {
                                       ii = 0;
                                       }
                                    else
                                       {
                                       ii = rln->numnodes * 2;
                                       }

                                    while(ii < rln->numnodes) /*** did not use a for ii loop since every interior point on rln
                                                                   should have both up and downhill directions, so can't get an error ***/
                                       {
                                       if(EqualWithinTolerance(rlc->x[i],rlc->y[i],rln->x[ii],rln->y[ii],
                                                ActiveChecks[checkinstance].sensitivity3) > 0)
                                          {
                                          if(ii == 0)
                                             {
                                             jj = 1;
                                             kk = 1;
                                             }
                                          else if(ii == (rln->numnodes - 1))
                                             {
                                             jj = kk = ii - 1;
                                             }
                                          else
                                             {
                                             jj = ii - 1;
                                             kk = ii + 1;
                                             }
                                          if(jj != kk)
                                             {
                                             E = InterpolateElevationInSpecificGrid(Gindex, ThisGridIndex, rln->x[jj], rln->y[jj], &Znew,
                                                             0, ActiveChecks[checkinstance].sensitivity3, checkinstance);
                                             if(E > 0)
                                                {
                                                X[2] = rln->x[jj];
                                                Y[2] = rln->y[jj];
                                                Z[2] = Znew;
                                                E = InterpolateElevationInSpecificGrid(Gindex, ThisGridIndex, rln->x[kk], rln->y[kk], &Znew,
                                                             0, ActiveChecks[checkinstance].sensitivity3, checkinstance);
                                                if(E > 0)
                                                   {
                                                   if(Z[1] < Z[0]) /*** going downhill at end node ***/
                                                      {
                                                      if(Znew < Z[2]) /** keep going max downhill ****/
                                                         {
                                                         X[2] = rln->x[kk];
                                                         Y[2] = rln->y[kk];
                                                         Z[2] = Znew;
                                                         }
                                                      }
                                                   else if(Z[1] > Z[0]) /*** going uphill at end node ***/
                                                      {
                                                      if(Znew > Z[2]) /** keep going max uphill ****/
                                                         {
                                                         X[2] = rln->x[kk];
                                                         Y[2] = rln->y[kk];
                                                         Z[2] = Znew;
                                                         }
                                                      }
                                                   }
                                                else
                                                   kk = jj;
                                                }
                                             else
                                                {
                                                jj = kk;
                                                E = InterpolateElevationInSpecificGrid(Gindex, ThisGridIndex, rln->x[kk], rln->y[kk], &Znew,
                                                             0, ActiveChecks[checkinstance].sensitivity3, checkinstance);
                                                if(E > 0)
                                                   {
                                                   X[2] = rln->x[kk];
                                                   Y[2] = rln->y[kk];
                                                   Z[2] = Znew;
                                                   }
                                                else
                                                   kk = jj;
                                                }
                                             }
                                          else /** jj == kk  which should be the case unless switch to using interior nodes on rln***/
                                             {
                                             E = InterpolateElevationInSpecificGrid(Gindex, ThisGridIndex, rln->x[jj], rln->y[jj], &Znew,
                                                             0, ActiveChecks[checkinstance].sensitivity3, checkinstance);
                                             if(E > 0)
                                                {
                                                if(found_one < 0)
                                                   found_one = 0;
                                                X[2] = rln->x[jj];
                                                Y[2] = rln->y[jj];
                                                Z[2] = Znew;

                                                if(Z[1] > Z[0]) /*** going uphill at end node ***/
                                                   {
                                                   if(Z[2] > Z[1])
                                                      found_one = 1;
                                                   }
                                                else if(Z[2] < Z[1])
                                                   found_one = 1;

                                                if(found_one == 0)
                                                   {
                                                   basedist = Distance(X[0],Y[0],X[1],Y[1]);
                                                   segdist = Distance(X[1],Y[1],X[2],Y[2]);
                                                   z4 = Z[1] - Z[0];
                                                   z3 = Z[2] - Z[1];
                                                   slopeangle1 = atan(z3 / segdist);
                                                   slopeangle2 = atan(z4 / basedist);

                                                   if(slopeangle2 > slopeangle1)
                                                      temp = slopeangle2 - slopeangle1;
                                                   else
                                                      temp = slopeangle1 - slopeangle2;

                                                   temp = RadiansToDegrees(temp);
                        
                                                   z3 = -100.0;

                                                   if(SensitivityCheck(GTEQ, CLAMP_JOINSDC, checkinstance, temp) > 0)
                                                      {
                                                      if((Z[1] > Z[0]) && (Z[1] > Z[2]))
                                                         {
                                                         z1 = Z[1] - Z[0];
                                                         z2 = Z[1] - Z[2];
                                                         if(z1 < z2)
                                                            z3 = z1;
                                                         else
                                                            z3 = z2;
                                                         }
                                                      else
                                                         {
                                                         z1 = Z[0] - Z[1];
                                                         z2 = Z[2] - Z[1];
                                                         if(z1 < z2)
                                                            z3 = z1;
                                                         else
                                                            z3 = z2;
                                                         }
                                                      }
                                                   if(z3 < ActiveChecks[checkinstance].sensitivity2)
                                                      found_one = 1;
                                                   }
                                                }
                                             }
                                          }
                                       if(found_one > 0)
                                          break;
                                       ii += rln->numnodes - 1;
                                       }
                                    if(found_one > 0)
                                      break;
                                    rln = rln->next;
                                    } /*** end while rln ****/
                                 }
                              }
                           if(found_one == 0) /*** if == -1, never found a line to connect to, if == 1, found a good join   ****/
                              {
                              ERc = (struct collection *) (malloc(SzC));
                              if(ERc == NULL)
                                 {
                                 printf("allocation memory exhausted during linear feature condition analysis\n");
                                 printf("processing cannot continue\n");
                                 exit(-1);
                                 }
                              ERc->x[0] = X[0];
                              ERc->y[0] = Y[0];
                              ERc->z[0] = Z[0];
                              ERc->magnitude = temp;
                              ERc->keyval = CLAMP_JOINSDC;
                              ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                              ERc->ll = rlc;
                              ERc->Sindex = rlc->Sindex;
                              ERc->aa = NULL;
                              ERc->pp = NULL;
                              ERc->next = NULL;
                              if(ERroot == NULL)
                                 {
                                 ERc->x[1] = X[1];
                                 ERc->y[1] = Y[1];
                                 ERc->z[1] = Z[1];
                                 ERc->x[2] = X[2];
                                 ERc->y[2] = Y[2];
                                 ERc->z[2] = Z[2];
                                 ERroot = ERc;
                                 }
                              else
                                 {
                                 ERn = ERroot;
                                 while(ERn != NULL)
                                    {
                                    if((ERn->Cnumber == ERc->Cnumber) && (ERn->keyval == ERc->keyval) &&
                                         (ERn->x[1] == X[1]) && (ERn->y[1] == Y[1]))
                                       break;
                                    ERn = ERn->next;
                                    }
                                 if(ERn == NULL)
                                    {
                                    ERc->x[1] = X[1];
                                    ERc->y[1] = Y[1];
                                    ERc->z[1] = Z[1];
                                    ERc->x[2] = X[2];
                                    ERc->y[2] = Y[2];
                                    ERc->z[2] = Z[2];
                                    ERc->next = ERroot;
                                    ERroot = ERc;
                                    }
                                 else
                                    free(ERc);
                                 }
                              }
                           } /** end rlc node is in the LM ****/
                        i += rlc->numnodes - 1;
                        }
                     } /** end check applies to the line feature ***/
                  rlc = rlc->next;
                  }
               } /*** end CLAMP_JOINSDC check applies to the grid ****/



            if((CombinedCheckApplies(GridHeader[j].idn,checkinstance,LOSMINHGT,LI,SI,
                 SCCtable[SI].C, SCCtable[SI].S, SCCtable[SI].D,
                             &part1,&part2,&part3) >  0) && (part1 > 0))
               {
               ThisGridIndex = NGT[cindex].GridIndex[Gindex];

               rac = Aroot;
               while(rac != NULL)
                  {
                  if((CombinedCheckApplies(rac->idn,checkinstance,LOSMINHGT,rac->Lindex,rac->Sindex,
                     SCCtable[rac->Sindex].C, SCCtable[rac->Sindex].S, SCCtable[rac->Sindex].D,
                             &part1,&part2,&part3) > 0) && (part2 > 0))
                     {
                     tgtx = (ActiveChecks[checkinstance].sensitivity2 - Xtranslation) * 100000.0;
                     tgty = (ActiveChecks[checkinstance].sensitivity3 - Ytranslation) * 100000.0;
                       iX = 0;
                       for(grows = 0; grows < MG[Gindex].numX; grows++)
                          {
                          gridx = MG[Gindex].SouthWestX + ((double) iX * MG[Gindex].Xspace);
                          if((gridx >= minx) && (gridx <= maxx))
                             {
                             iY = 0;
                             for(gcols = 0; gcols < MG[Gindex].numY; gcols++)
                                {
                                gridy = MG[Gindex].SouthWestY + ((double) iY * MG[Gindex].Yspace);

                                if((gridy >= miny) && (gridy <= maxy))
                                   {
                                   found_one = 0;
                                   index = (iX * MG[Gindex].numY) + iY;
                                   Znew = MG[Gindex].Elevs[index];

                                   if(rac->RB_Tree_Edgelist == NULL)
                                      {
                                      if(PointIsInside(gridx, gridy, rac->x,rac->y,rac->x,rac->numverts,C_AREA,&unuseddbl) > 0)
                                         {
                                         if(Distance(gridx,gridy,tgtx,tgty) < ActiveChecks[checkinstance].sensitivity)
                                            found_one = 1;
                                         }
                                      }
                                   else if(PointInsideLargeAreal(gridx, gridy, rac,&unusedint) > 0)
                                      {
                                      if(Distance(gridx,gridy,tgtx,tgty) < ActiveChecks[checkinstance].sensitivity)
                                         found_one = 1;
                                      }
                                   if(found_one > 0)
                                      {
                                      if((LOS_GX == NULL) || (LOS_GY == NULL))
                                         {
                                         NumGridPts = MG[Gindex].numX * MG[Gindex].numY;
                                         LOS_GX = (double *) (malloc(SzD * (NumGridPts + 1)));
                                         LOS_GY = (double *) (malloc(SzD * (NumGridPts + 1)));
                                         LOS_GZ = (double *) (malloc(SzD * (NumGridPts + 1)));
                                         LOS_ArrayIndex = 0;
                                         LOS_CheckIndex = checkinstance;
                                         }

                                      LOS_GX[LOS_ArrayIndex] = gridx;
                                      LOS_GY[LOS_ArrayIndex] = gridy;
                                      LOS_GZ[LOS_ArrayIndex] = Znew;
                                      ++LOS_ArrayIndex;
                                      LOS_GHindex = j;

                                      }
                                   } /** end gridy is in LM ***/
                                ++iY;
                                } /*** end for gcols ***/
                             } /** end gridx is in LM ***/
                         ++iX;
                         } /** end for grows ****/
                     }
                  rac  = rac->next;
                  }
               }



            if((CombinedCheckApplies(GridHeader[j].idn,checkinstance,CLAMP_NFLAT,LI,SI,
                 SCCtable[SI].C, SCCtable[SI].S, SCCtable[SI].D,
                             &part1,&part2,&part3) >  0) && (part2 > 0))
               {
               ThisGridIndex = NGT[cindex].GridIndex[Gindex];

               rac = Aroot;
               while(rac != NULL)
                  {
                  if((CombinedCheckApplies(rac->idn,checkinstance,CLAMP_NFLAT,rac->Lindex,rac->Sindex,
                     SCCtable[rac->Sindex].C, SCCtable[rac->Sindex].S, SCCtable[rac->Sindex].D,
                             &part1,&part2,&part3) > 0) && (part1 > 0))
                     {
                     if(rac->numverts > NumShadowElevations)
                        {
                        NumShadowElevations = rac->numverts + 100;
                        ShadowElevations = (double *) (realloc(ShadowElevations,SzD * NumShadowElevations));
                        }
                     for(i = 0; i< rac->numverts; i++)
                        ShadowElevations[i] = -59999.90909;
                     if(rac->RB_Tree_Edgelist != NULL)
                        {
                        LastEdge = NULL;
                        LastI = -1;
                        i = GetNextArealIndex(rac, LastI, 1, &LastEdge, cindex, &UsedTree);
                        LastI = i;
                        }
                     else
                        i = 0;
                     while(i >= 0)
                        {
                        if((rac->x[i] >= minx) && (rac->x[i] <= maxx) &&
                                    (rac->y[i] >= miny) && (rac->y[i] <= maxy))
                           {
                           E = InterpolateElevationInSpecificGrid(Gindex, ThisGridIndex, rac->x[i], rac->y[i], &Znew,
                                                          1, ActiveChecks[checkinstance].sensitivity3, checkinstance);
                           if(E > 0)
                              {
                              ShadowElevations[i] = Znew;
                              }
                           } /** end this line vertex is in the LM ***/
                        if(rac->RB_Tree_Edgelist != NULL)
                           {
                           i = GetNextArealIndex(rac, LastI, 1, &LastEdge, cindex, &UsedTree);
                           LastI = i;
                           }
                        else
                           {
                           ++i;
                           if(i >= rac->numverts)
                              i = -1;
                           }

                        } /** end reset ShadowElevation Values ***/

                     found_one = 0;
                     for(kk=0; kk<rac->numverts; kk++)
                        {
                        if((ShadowElevations[kk] != -59999.90909) &&
                                  (IsSentinelZvalue(ShadowElevations[kk],UseNUNANPO) == 0))
                           {
                           z1 = z2 = ShadowElevations[kk];
                           ii = jj = kk;
                           found_one = 1;
                           break;
                           }
                        }
                     for(i=kk+1; i< rac->numverts; i++)
                        {
                        if((ShadowElevations[i] != -59999.90909) &&
                                   (IsSentinelZvalue(ShadowElevations[i],UseNUNANPO) == 0))
                           {
                           if(ShadowElevations[i] < z1)
                              {
                              z1 = ShadowElevations[i];  /** use z1 to store min elevation value ***/
                              ii = i;  /*** use ii to store index of coord with min elev value ***/
                              }
                           if(ShadowElevations[i] > z2)
                              {
                              z2 = ShadowElevations[i];  /*** use z2 to store max elevation value ***/
                              jj = i;  /*** use jj to store index of coord with max elev value ***/
                              }
                           }
                        }
                     if(found_one > 0)
                        {
                        z3 = z2 - z1;
                        if(SensitivityCheck(GT, CLAMP_NFLAT, checkinstance, z3) > 0)
                           {
                           ERc = (struct collection *) (malloc(SzC));
                           if(ERc == NULL)
                              {
                              printf("allocation memory exhausted during linear feature condition analysis\n");
                              printf("processing cannot continue\n");
                              exit(-1);
                              }
                           ERc->x[0] = rac->x[ii];
                           ERc->y[0] = rac->y[ii];
                           ERc->z[0] = ShadowElevations[ii];
                           ERc->x[1] = rac->x[jj];
                           ERc->y[1] = rac->y[jj];
                           ERc->z[1] = ShadowElevations[jj];
                           ERc->magnitude = z3;
                           ERc->keyval = CLAMP_NFLAT;
                           ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                           ERc->Sindex = rac->Sindex;
                           ERc->aa = rac; /** RawAreal **/
                           ERc->pp = NULL; /** RawPoint **/
                           ERc->ll = NULL; /** RawLinear **/
                           ERc->next = NULL;
                           if(ERroot == NULL)
                              {
                              ERroot = ERc;
                              }
                           else
                              {
                              ERn = ERroot;
                              while(ERn != NULL)
                                 {
                                 if((ERn->Cnumber == ERc->Cnumber) && (ERn->keyval == ERc->keyval) && (ERn->aa == ERc->aa) &&
                                     (ERn->magnitude == ERc->magnitude) && (ERn->aa->idn == ERc->aa->idn))
                                    break;
     
                                 ERn = ERn->next;
                                 }
                              if(ERn == NULL)
                                {
                                 ERc->next = ERroot;
                                 ERroot = ERc;
                                 }
                              else
                                 free(ERc);
                              }
                           } /*** end if sensitivity check ***/
                        } /** end if found_one ***/
                     } /*** end if part1 ***/

                  rac = rac->next;
                  } /*** end while rac != NULL ***/

               } /*** end CLAMP_NFLAT check applies to the grid ****/



            } /** end grid has some elevation values in this LM ***/
         } /** end for Gindex ... ***/
      } /** end for checkinstance ***/

      ERc = ERroot;
   while(ERc != NULL)
      {
      switch(ERc->keyval)
         {
         case CLAMP_SDC:
         case CLAMP_JOINSDC: /** slope direction change at line feature connection when both are clamped to DEM ***/
            X[0] = ERc->x[0];
            Y[0] = ERc->y[0];
            Z[0] = ERc->z[0];
            X[1] = ERc->x[1];
            Y[1] = ERc->y[1];
            Z[1] = ERc->z[1];
            X[2] = ERc->x[2];
            Y[2] = ERc->y[2];
            Z[2] = ERc->z[2];
            if(ERc->ll != NULL)
               FwriteObjectAndMagnitude(ERc->keyval,ERc->Cnumber,
                        ERc->ll->idn, ERc->Sindex,G_LINE,ERc->ll->Lindex,ERc->ll->localID,-1.0,-1.0,ERc->magnitude,X,Y,Z,3, 1);
            else if(ERc->aa != NULL)
               FwriteObjectAndMagnitude(ERc->keyval,ERc->Cnumber,
                        ERc->aa->idn, ERc->Sindex,G_AREAL,ERc->aa->Lindex,ERc->aa->localID,-1.0,-1.0,ERc->magnitude,X,Y,Z,3, 1);
            break;
         case CLAMP_NFLAT:
            FwritePointObjectAndMagnitude(ERc->keyval, ERc->Cnumber,  ERc->magnitude, ERc->aa->idn, G_AREAL,
                                 ERc->aa->Lindex,ERc->aa->localID,
                                 ERc->Sindex, ERc->x[0], ERc->y[0], ERc->z[0], ERc->Sindex, ERc->aa->idn, G_AREAL,ERc->aa->Lindex,
                                 ERc->aa->localID, 1, &ERc->x[1], &ERc->y[1], &ERc->z[1]);
            break;

         default:
            printf("unrecognized key condition flag received during DEM and feature combination analysis\n");
            break;
         }
      ERn = ERc;
      ERc = ERc->next;
      free(ERn);
      }

   if((LOS_GX != NULL) && (LOS_GY != NULL) && (LOS_GZ != NULL))
      {
      LI = GridHeader[LOS_GHindex].Lindex;
      SI = CrsWlk[LI].LtoSmapping;
      for(ii4=0; ii4 < LOS_ArrayIndex; ii4++)
         {
         gridx = LOS_GX[ii4];
         gridy = LOS_GY[ii4];
         tempx = tgtx - gridx;
         if(gridx > tgtx)
            tempx = gridx - tgtx;
         tempy = tgty - gridy;
         if(gridy > tgty)
            tempy = gridy - tgty;
         if((tempx > 1) && (tempy > 1))
            {
            Znew = LOS_GZ[ii4];
            CreateDrawProfile(tgtx,tgty,gridx,gridy,&minElev,&maxElev);
            cp = ProfileRoot;
            if((cp != NULL) && (cp->next != NULL) && (cp->next->next != NULL))
               {
               cp = ProfileRoot;
/** note that the list may not be perfectly sorted by cp->dist in increasing order, so this test with temp is necessasry ****/
               temp = AnchorX = cp->dist;
               AnchorY = cp->elev;
               cp = cp->next;
               while(cp->dist <= temp)
                  cp = cp->next;
               temp = cp->dist;
               CurX = cp->dist;
               CurY = cp->elev;
               NewY = cp->elev;
               cp = cp->next;
               while(cp != NULL)
                  {
                  if((cp->ptype == 5) && (temp < cp->dist))
                     {
        /* below, finding Y, not X, so all args switched ... */
                     temp = cp->dist;
                     NewY = FindXatYonSegment(cp->dist,AnchorY,AnchorX,CurY,CurX);
                     if(NewY < cp->elev)
                        {
                        CurX = cp->dist;
                        CurY = cp->elev;
                        }
                     }
                  if(cp->next == NULL)
                     NewY = NewY - cp->elev;
                  cp = cp->next;
                  }
               pseudoLID1 = (LOS_GHindex+ 1) * (gridx + (1.0 / gridy));
               FwriteDynamicInfo(LOSMINHGT,Make_Correct(LOSMINHGT,LOS_CheckIndex),0,1,1,NULL,
                 NewY, -1.0, -1.0, -1.0,
                SI,G_GRIDPT,LI,pseudoLID1,GridHeader[LOS_GHindex].idn,-1.0,-1.0,
                &gridx, &gridy, &Znew, 1,
                SI,G_GRIDPT,LI,pseudoLID1,GridHeader[LOS_GHindex].idn,-1.0,-1.0,
                &gridx, &gridy, &Znew, 1);
               cp = ProfileRoot;
               while(cp != NULL)
                  {
                  pp = cp;
                  cp = cp->next;
                  free(pp);
                  }
               ProfileRoot = NULL;
               cp = DrawProfileRoot;
               while(cp != NULL)
                  {
                  pp = cp;
                  cp = cp->next;
                  free(pp);
                  }
               DrawProfileRoot = NULL;
               }
            }
         }
      free(LOS_GX);
      free(LOS_GY);
      free(LOS_GZ);
      }



   return;
}




int MatchElevationAtGridCoord(int gridindex, int gridheaderindex, double pntx, double pnty, double *pntz,
                          int UseIgnoreValue, double IgnoreValue, int checkindex)
{
int iX, iY, grows, gcols, retval,checkit,foundit;
double answer;
double Xlimit1,Xlimit2,Ylimit1,Ylimit2, XtoCompare, YtoCompare;

   retval = 0;

   Xlimit1 = GridHeader[gridheaderindex].BaseX - 0.0001;
   Xlimit2 = Xlimit1 + 0.0002 + ((double) (GridHeader[gridheaderindex].Xpts - 1) * GridHeader[gridheaderindex].Xspacing);
   if((pntx < Xlimit1) || (pntx > Xlimit2))
      return(retval);
   Ylimit1 = GridHeader[gridheaderindex].BaseY - 0.0001;
   Ylimit2 = Ylimit1 + 0.0002 + ((double) (GridHeader[gridheaderindex].Ypts - 1) * GridHeader[gridheaderindex].Yspacing);
   if((pnty < Ylimit1) || (pnty > Ylimit2))
      return(retval);


   if((MG[gridindex].numX > 0) && (MG[gridindex].numY > 0))
      {
      iX = 0;
      foundit = 0;
      for(grows = 0; grows < MG[gridindex].numX; grows++)
         {
         XtoCompare = MG[gridindex].SouthWestX /**- SMIDGE**/ + ((double) iX * MG[gridindex].Xspace);
         if(((XtoCompare - 0.00001) <= pntx) && ((XtoCompare + 0.00001) >= pntx))
            {
            iY = 0;
            for(gcols = 0; gcols < MG[gridindex].numY; gcols++)
               {
               YtoCompare = MG[gridindex].SouthWestY /**- SMIDGE**/ + ((double) iY * MG[gridindex].Yspace);

               if(((YtoCompare - 0.01) <= pnty) && ((YtoCompare + 0.01) >= pnty))
                  {
                  foundit = 1;
                  checkit = 1;
                  answer = MG[gridindex].Elevs[(iX * MG[gridindex].numY) + iY];
                  if((UseIgnoreValue == -99) && (IgnoreValue == -99.9))
                     {
                     if((ActiveChecks[checkindex].use_sen2 == 1) && (answer == ActiveChecks[checkindex].sensitivity2))
                        checkit = 0;
                     else if((ActiveChecks[checkindex].use_sen3 == 1) && (answer == ActiveChecks[checkindex].sensitivity3))
                        checkit = 0;
                     }
                  if((UseIgnoreValue > 0) && (answer <= IgnoreValue))
                     checkit = 0;
                  if(checkit > 0)
                     {
                     *pntz = answer;

                     retval = 1;
                     break;
                     }
                  }
               ++iY;
               }
            }
         if((foundit > 0)||  (retval > 0))
            break;
         ++iX;
         }
      }
   return(retval);

}


int CheckMatchingGridsForElevDifferences(int index, /** is = compositeindex **/
                                     int Cindex,  /*** is the checkinstance ***/
                                      double minx, double miny, double maxx, double maxy) /** LM bounds in internal coords **/
{
int k, j, E, kk, LM_index1, LM_index2, LM_i1, LM_i2;
int index1, index2;
int Sindex1, Sindex2;
int Lindex1, Lindex2;
int SI1, SI2;
double XG, YG, ZG;
double Znew, pseudoLID1, pseudoLID2/***,pl1,pl2***/;
/**double globalMaxX1,globalMaxY1,globalMaxX2,globalMaxY2; **/
int grows, gcols;
int part1, part2, part3, checkit;
double Zdiff;
int Grid1IDN, Grid2IDN;
unsigned int LI1, LI2;
int DidTheCheck;
   DidTheCheck = 0;
   if(NGT[index].NumGrids < 2) /*** less than 2 grids to compare in this Cindex=Region ***/
      return(DidTheCheck);

   for(LM_index1=0; LM_index1<NGT[index].NumGrids; LM_index1++)
      {
      if((NGT[index].GridIndex != NULL) && (MG[LM_index1].numX > 0) && (MG[LM_index1].numY > 0))
         {
         k = NGT[index].GridIndex[LM_index1];

         LI1 = GridHeader[k].Lindex;
         SI1 = CrsWlk[LI1].LtoSmapping;
         if((CombinedCheckApplies(GridHeader[k].idn,Cindex,GRIDEXACTDIF,LI1,SI1,
                     SCCtable[SI1].C, SCCtable[SI1].S, SCCtable[SI1].D,
                     &part1,&part2,&part3) >  0) && (part1 > 0))
            {
            for(LM_index2=0; /*LM_index1+1;*/ LM_index2<NGT[index].NumGrids; LM_index2++)
               {
               if((LM_index2 != LM_index1) && (MG[LM_index2].numX > 0) && (MG[LM_index2].numY > 0))
                  {
                  j = NGT[index].GridIndex[LM_index2];

                  LI2 = GridHeader[j].Lindex;
                  SI2 = CrsWlk[LI2].LtoSmapping;
                  if((CombinedCheckApplies(GridHeader[j].idn,Cindex,GRIDEXACTDIF,LI2,SI2,
                       SCCtable[SI2].C, SCCtable[SI2].S, SCCtable[SI2].D,
                     &part1,&part2,&part3) >  0) && (part2 > 0))
                     {
                     DidTheCheck = 1;
                     if((MG[LM_index1].Xspace + MG[LM_index1].Yspace) > (MG[LM_index2].Xspace + MG[LM_index2].Yspace))
                        {
                        index1 = k;
                        index2 = j;
                        LM_i1 = LM_index1;
                        LM_i2 = LM_index2;
                        }
                     else
                        {
                        index1 = j;
                        index2 = k;
                        LM_i1 = LM_index2;
                        LM_i2 = LM_index1;
                        }
                     Grid1IDN = GridHeader[index1].idn;
                     Grid2IDN = GridHeader[index2].idn;
                     Lindex1 = GridHeader[index1].Lindex;
                     Lindex2 = GridHeader[index2].Lindex;
                     Sindex1 = CrsWlk[Lindex1].LtoSmapping;
                     Sindex2 = CrsWlk[Lindex2].LtoSmapping;

                     for(grows = 0; grows < MG[LM_i1].numX; grows++)
                        {
                        XG = MG[LM_i1].SouthWestX  + ((double) grows * MG[LM_i1].Xspace);
                        if((XG >= minx) && (XG <= maxx))
                           {
                           for(gcols = 0; gcols < MG[LM_i1].numY; gcols++)
                              {
                              YG = MG[LM_i1].SouthWestY + ((double) gcols * MG[LM_i1].Yspace);
                              checkit = 1;
                              if(checkit > 0)
                                 {
                                 kk = (grows * MG[LM_i1].numY) + gcols;
                                 ZG = MG[LM_i1].Elevs[kk];

                                 if((ActiveChecks[Cindex].use_sen1 == 1) && (ZG == ActiveChecks[Cindex].sensitivity2))
                                    checkit = 0;
                                 else if((ActiveChecks[Cindex].use_sen2 == 1) && (ZG == ActiveChecks[Cindex].sensitivity3))
                                    checkit = 0;
                                 }
                              if((checkit > 0) && (YG >= miny) && (YG <= maxy))
                                 {

                                 E = MatchElevationAtGridCoord(LM_i2, index2, XG, YG, &Znew, -99, -99.9, Cindex);

                                 if(E > 0)
                                    {
                                    if(ZG > Znew)
                                       Zdiff = ZG - Znew;
                                    else
                                       Zdiff = Znew - ZG;
                                    if((Zdiff < 32000) &&
                                         (SensitivityCheck(GT, GRIDEXACTDIF, Cindex, Zdiff) > 0))
                                       {
                                       pseudoLID1 = (index1+ 1) * (XG + (1.0 / YG));
                                       pseudoLID2 = (index2+ 1) * (XG + (1.0 / YG));

                                       FwriteMagnitudeAndTwoObjects(GRIDEXACTDIF,Make_Correct(GRIDEXACTDIF,Cindex),Zdiff,
                                           Sindex1,G_GRIDPT,Lindex1,pseudoLID1,Grid1IDN,-1.0,-1.0,
                                           &XG, &YG, &ZG, 1,
                                           Sindex2, G_GRIDPT,Lindex2,pseudoLID2,Grid2IDN, -1.0, -1.0,
                                            &XG, &YG, &Znew, 1);
                                       }
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }

   return(DidTheCheck);
}










int Check2GridsForElevDifferences(int index, /** is = compositeindex **/
                                     int Cindex,  /*** is the checkinstance ***/
                                      double minx, double miny, double maxx, double maxy) /** LM bounds in internal coords **/
{
int k, j, E, kk, LM_index1, LM_index2, LM_i1, LM_i2;
int index1, index2;
int Sindex1, Sindex2;
int Lindex1, Lindex2;
int SI1, SI2;
double XG, YG, ZG;
double Znew, pseudoLID1, pseudoLID2/***,pl1,pl2***/;
/**double globalMaxX1,globalMaxY1,globalMaxX2,globalMaxY2; **/
int grows, gcols;
int part1, part2, part3, checkit;
double Zdiff;
int Grid1IDN, Grid2IDN;
unsigned int LI1, LI2;
int DidTheCheck;
/**************
extern double CompareIgnore1;
extern double CompareIgnore2;
extern int CompareIgnoreT1;
extern int CompareIgnoreT2;
***************/


   DidTheCheck = 0;
   if(NGT[index].NumGrids < 2) /*** less than 2 grids to compare in this Cindex=Region ***/
      return(DidTheCheck);

   for(LM_index1=0; LM_index1<NGT[index].NumGrids; LM_index1++)
      {
      if((NGT[index].GridIndex != NULL) && (MG[LM_index1].numX > 0) && (MG[LM_index1].numY > 0))
         {
         k = NGT[index].GridIndex[LM_index1];

         LI1 = GridHeader[k].Lindex;
         SI1 = CrsWlk[LI1].LtoSmapping;
         if((CombinedCheckApplies(GridHeader[k].idn,Cindex,LODELEVDIF,LI1,SI1,
                     SCCtable[SI1].C, SCCtable[SI1].S, SCCtable[SI1].D,
                     &part1,&part2,&part3) >  0) && (part1 > 0))
            {
            for(LM_index2=0; /*LM_index1+1;*/ LM_index2<NGT[index].NumGrids; LM_index2++)
               {
               if((LM_index2 != LM_index1) && (MG[LM_index2].numX > 0) && (MG[LM_index2].numY > 0))
                  {
                  j = NGT[index].GridIndex[LM_index2];

                  LI2 = GridHeader[j].Lindex;
                  SI2 = CrsWlk[LI2].LtoSmapping;
                  if((CombinedCheckApplies(GridHeader[j].idn,Cindex,LODELEVDIF,LI2,SI2,
                       SCCtable[SI2].C, SCCtable[SI2].S, SCCtable[SI2].D,
                     &part1,&part2,&part3) >  0) && (part2 > 0))
                     {
                     DidTheCheck = 1;
                     /**if((NGT[index].NumRows[LM_index1] * NGT[index].NumCols[LM_index1]) <=  *** was >,   25 Feb 2011****
                           (NGT[index].NumRows[LM_index2] * NGT[index].NumCols[LM_index2])) **/
                     if((MG[LM_index1].Xspace + MG[LM_index1].Yspace) > (MG[LM_index2].Xspace + MG[LM_index2].Yspace))
                        {
                        index1 = k;
                        index2 = j;
                        LM_i1 = LM_index1;
                        LM_i2 = LM_index2;
                        }
                     else
                        {
                        index1 = j;
                        index2 = k;
                        LM_i1 = LM_index2;
                        LM_i2 = LM_index1;
                        }
                     Grid1IDN = GridHeader[index1].idn;
                     Grid2IDN = GridHeader[index2].idn;
                     Lindex1 = GridHeader[index1].Lindex;
                     Lindex2 = GridHeader[index2].Lindex;
                     Sindex1 = CrsWlk[Lindex1].LtoSmapping;
                     Sindex2 = CrsWlk[Lindex2].LtoSmapping;

                     for(grows = 0; grows < MG[LM_i1].numX; grows++)
                        {
                        XG = MG[LM_i1].SouthWestX  + ((double) grows * MG[LM_i1].Xspace);
                        if((XG >= minx) && (XG <= maxx))
                           {
                           for(gcols = 0; gcols < MG[LM_i1].numY; gcols++)
                              {
                              YG = MG[LM_i1].SouthWestY + ((double) gcols * MG[LM_i1].Yspace);

                              checkit = 1;
                              if(checkit > 0)
                                 {
                                 kk = (grows * MG[LM_i1].numY) + gcols;
                                 ZG = MG[LM_i1].Elevs[kk];

                                 if((ActiveChecks[Cindex].use_sen1 == 1) && (ZG == ActiveChecks[Cindex].sensitivity2))
                                    checkit = 0;
                                 else if((ActiveChecks[Cindex].use_sen2 == 1) && (ZG == ActiveChecks[Cindex].sensitivity3))
                                    checkit = 0;
                                 }
                              if((checkit > 0) && (YG >= miny) && (YG <= maxy))
                                 {
               
                                 E = InterpolateElevationInSpecificGrid(LM_i2, index2, XG, YG, &Znew, -99, -99.9, Cindex);

                                 if(E > 0)
                                    {
                                    if(ZG > Znew)
                                       Zdiff = ZG - Znew;
                                    else
                                       Zdiff = Znew - ZG;

                                    if((Zdiff < 32000) &&
                                         (SensitivityCheck(GT, LODELEVDIF, Cindex, Zdiff) > 0))
                                       {
pseudoLID1 = (index1+ 1) * (XG + (1.0 / YG));
pseudoLID2 = (index2+ 1) * (XG + (1.0 / YG));

                                       FwriteMagnitudeAndTwoObjects(LODELEVDIF,Make_Correct(LODELEVDIF,Cindex),Zdiff,
                                           Sindex1,G_GRIDPT,Lindex1,pseudoLID1,Grid1IDN,-1.0,-1.0,
                                           &XG, &YG, &ZG, 1,
                                           Sindex2, G_GRIDPT,Lindex2,pseudoLID2,Grid2IDN, -1.0, -1.0,
                                            &XG, &YG, &Znew, 1);
                                       }
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }

   return(DidTheCheck);
}




int CheckTwoMasksForAgreement(/**int GridIndex, **/      int index, /** is = compositeindex **/
                                  int Cindex,  /*** is the checkinstance ***/
                                  double minx, double miny, double maxx, double maxy) /** LM bounds in internal coords **/
{
int k, j, kk, LM_index1, LM_index2;
int Sindex1, Sindex2;
int Lindex1, Lindex2;
int SI1, SI2, DidTheCheck;
int  WriteError;
double XG, YG, ZG;
double Znew, pseudoLID1, pseudoLID2, unuseddbl;
double LowerTol1, UpperTol1, LowerTol2, UpperTol2;
int grows, gcols;
int part1, part2, part3, checkit;
int Grid1IDN, Grid2IDN;
unsigned int LI1, LI2;

   unuseddbl = 0.0;
   DidTheCheck = 0;
   if(NGT[index].NumGrids < 2) /*** less than 2 grids to compare in this Cindex=Region ***/
      return(DidTheCheck);

   for(LM_index1=0; LM_index1<NGT[index].NumGrids; LM_index1++)
      {
      if((NGT[index].GridIndex != NULL) && (MG[LM_index1].numX > 0) && (MG[LM_index1].numY > 0))
         {
         k = NGT[index].GridIndex[LM_index1];

         LI1 = GridHeader[k].Lindex;
         SI1 = CrsWlk[LI1].LtoSmapping;
         if((CombinedCheckApplies(GridHeader[k].idn,Cindex,MASKCONFLICT,LI1,SI1,
                     SCCtable[SI1].C, SCCtable[SI1].S, SCCtable[SI1].D,
                     &part1,&part2,&part3) >  0) && (part1 > 0)) /*** this should be the first mask ***/
            {

            if(FindSpecificSensitivity(1,MASKCONFLICT,Cindex,&LowerTol1) < 1)
               continue;
            if(FindSpecificSensitivity(2,MASKCONFLICT,Cindex,&UpperTol1) < 1)
               continue;
            for(LM_index2=0; LM_index2<NGT[index].NumGrids; LM_index2++)
               {
               if((LM_index2 != LM_index1) && (MG[LM_index2].numX == MG[LM_index1].numX) &&
                      (MG[LM_index2].numY == MG[LM_index1].numY) &&
                         (NearlyEqual(GridHeader[k].BaseX,GridHeader[NGT[index].GridIndex[LM_index2]].BaseX) > 0) &&
                           (NearlyEqual(GridHeader[k].BaseY,GridHeader[NGT[index].GridIndex[LM_index2]].BaseY) > 0))
                  {
                  j = NGT[index].GridIndex[LM_index2];

                  LI2 = GridHeader[j].Lindex;
                  SI2 = CrsWlk[LI2].LtoSmapping;
                  if((CombinedCheckApplies(GridHeader[j].idn,Cindex,MASKCONFLICT,LI2,SI2,
                       SCCtable[SI2].C, SCCtable[SI2].S, SCCtable[SI2].D,
                     &part1,&part2,&part3) >  0) && (part2 > 0)) /*** this should be the secondary mask ***/
                     {

                     DidTheCheck = 1;

                     Grid1IDN = GridHeader[k].idn;
                     Grid2IDN = GridHeader[j].idn;
                     Lindex1 = GridHeader[k].Lindex;
                     Lindex2 = GridHeader[j].Lindex;
                     Sindex1 = CrsWlk[Lindex1].LtoSmapping;
                     Sindex2 = CrsWlk[Lindex2].LtoSmapping;

                     if(FindSpecificSensitivity(3,MASKCONFLICT,Cindex,&LowerTol2) < 1)
                        continue;
                     if(FindSpecificSensitivity(4,MASKCONFLICT,Cindex,&UpperTol2) < 1)
                        continue;


                     for(grows = 0; grows < MG[LM_index1].numX; grows++)
                        {
                        XG = MG[LM_index1].SouthWestX  + ((double) grows * MG[LM_index1].Xspace);
                        if((XG >= minx) && (XG <= maxx))
                           {
                           for(gcols = 0; gcols < MG[LM_index1].numY; gcols++)
                              {
                              YG = MG[LM_index1].SouthWestY + ((double) gcols * MG[LM_index1].Yspace);

                              kk = (grows * MG[LM_index1].numY) + gcols;

                              ZG = MG[LM_index1].Elevs[kk];
                              checkit = 0;
                              if((ZG >= LowerTol1) && (ZG <= UpperTol1))
                                 checkit = 1;

                              if((checkit > 0) && (YG >= miny) && (YG <= maxy))
                                 {
                                 WriteError = 0;
                                 Znew = MG[LM_index2].Elevs[kk];

                                 if((Znew < LowerTol2) || (Znew > UpperTol2))
                                    WriteError = 1;

                                 if(WriteError > 0)
                                    {
                                    WriteError = 0;
                                    pseudoLID1 = 0 - k;  /**(k+ 1) * (XG + (1.0 / YG)); *****/
                                    pseudoLID2 = 0 - j;  /**(j+ 1) * (XG + (1.0 / YG)); *****/
                                    if(ActiveChecks[Cindex].sensitivity5 < 1)
                                       {
                                       FwriteDynamicInfo(MASKCONFLICT,Make_Correct(MASKCONFLICT,Cindex),0,0,2,NULL,
                                         unuseddbl, -1.0, -1.0, -1.0,
                                        Sindex1,G_GRIDPT,Lindex1,pseudoLID1,Grid1IDN,-1.0,-1.0,
                                        &XG, &YG, &ZG, 1,
                                        Sindex2, G_GRIDPT,Lindex2,pseudoLID2,Grid2IDN, -1.0, -1.0,
                                         &XG, &YG, &Znew, 1);
                                       }
                                    else
                                       {
                                       if(billbout == NULL)
                                          billbout = fopen(billboardlog,"wb");
                                       if(billbout != NULL)
                                          {
                                          AddToBillBoardCheckList(Cindex,1);
                                          ++BillBoardPtsWritten;
                                          BB_FwriteDynamicInfo(billbout,MASKCONFLICT,Make_Correct(MASKCONFLICT,Cindex),
                                               Cindex,ActiveChecks[Cindex].sensitivity5, 0,0,2,NULL,
                                               unuseddbl, -1.0, -1.0, -1.0,
                                               Sindex1,G_GRIDPT,Lindex1,pseudoLID1,Grid1IDN,-1.0,-1.0,
                                               &XG, &YG, &ZG, 1,
                                               Sindex2, G_GRIDPT,Lindex2,pseudoLID2,Grid2IDN, -1.0, -1.0,
                                               &XG, &YG, &Znew, 1);
                                          }
                                       }

                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }

         if((CombinedCheckApplies(GridHeader[k].idn,Cindex,MASKCONF2,LI1,SI1,
                     SCCtable[SI1].C, SCCtable[SI1].S, SCCtable[SI1].D,
                     &part1,&part2,&part3) >  0) && (part1 > 0)) /*** this should be the first mask ***/
            {

            if(FindSpecificSensitivity(1,MASKCONF2,Cindex,&LowerTol1) < 1)
               continue;
            if(FindSpecificSensitivity(2,MASKCONF2,Cindex,&UpperTol1) < 1)
               continue;
            for(LM_index2=0; LM_index2<NGT[index].NumGrids; LM_index2++)
               {
               if((LM_index2 != LM_index1) && (MG[LM_index2].numX == MG[LM_index1].numX) &&
                      (MG[LM_index2].numY == MG[LM_index1].numY) &&
                         (NearlyEqual(GridHeader[k].BaseX,GridHeader[NGT[index].GridIndex[LM_index2]].BaseX) > 0) &&
                           (NearlyEqual(GridHeader[k].BaseY,GridHeader[NGT[index].GridIndex[LM_index2]].BaseY) > 0))
                  {
                  j = NGT[index].GridIndex[LM_index2];

                  LI2 = GridHeader[j].Lindex;
                  SI2 = CrsWlk[LI2].LtoSmapping;
                  if((CombinedCheckApplies(GridHeader[j].idn,Cindex,MASKCONF2,LI2,SI2,
                       SCCtable[SI2].C, SCCtable[SI2].S, SCCtable[SI2].D,
                     &part1,&part2,&part3) >  0) && (part2 > 0)) /*** this should be the secondary mask ***/
                     {

                     DidTheCheck = 1;

                     Grid1IDN = GridHeader[k].idn;
                     Grid2IDN = GridHeader[j].idn;
                     Lindex1 = GridHeader[k].Lindex;
                     Lindex2 = GridHeader[j].Lindex;
                     Sindex1 = CrsWlk[Lindex1].LtoSmapping;
                     Sindex2 = CrsWlk[Lindex2].LtoSmapping;

                     if(FindSpecificSensitivity(3,MASKCONF2,Cindex,&LowerTol2) < 1)
                        continue;
                     if(FindSpecificSensitivity(4,MASKCONF2,Cindex,&UpperTol2) < 1)
                        continue;


                     for(grows = 0; grows < MG[LM_index1].numX; grows++)
                        {
                        XG = MG[LM_index1].SouthWestX  + ((double) grows * MG[LM_index1].Xspace);
                        if((XG >= minx) && (XG <= maxx))
                           {
                           for(gcols = 0; gcols < MG[LM_index1].numY; gcols++)
                              {
                              YG = MG[LM_index1].SouthWestY + ((double) gcols * MG[LM_index1].Yspace);

                              kk = (grows * MG[LM_index1].numY) + gcols;

                              ZG = MG[LM_index1].Elevs[kk];
                              checkit = 0;
                              if((ZG >= LowerTol1) && (ZG <= UpperTol1))
                                 checkit = 1;

                              if((checkit > 0) && (YG >= miny) && (YG <= maxy))
                                 {
                                 WriteError = 0;
                                 Znew = MG[LM_index2].Elevs[kk];

                                 if((Znew >= LowerTol2) && (Znew <= UpperTol2))
                                    WriteError = 1;

                                 if(WriteError > 0)
                                    {
                                    WriteError = 0;
                                    pseudoLID1 = 0 - k;  /**(k+ 1) * (XG + (1.0 / YG)); ***/
                                    pseudoLID2 = 0 - j;  /**(j+ 1) * (XG + (1.0 / YG)); ***/

                                    if(ActiveChecks[Cindex].sensitivity5 < 1)
                                       {
                                       FwriteDynamicInfo(MASKCONF2,Make_Correct(MASKCONF2,Cindex),0,0,2,NULL,
                                         unuseddbl, -1.0, -1.0, -1.0,
                                        Sindex1,G_GRIDPT,Lindex1,pseudoLID1,Grid1IDN,-1.0,-1.0,
                                        &XG, &YG, &ZG, 1,
                                        Sindex2, G_GRIDPT,Lindex2,pseudoLID2,Grid2IDN, -1.0, -1.0,
                                         &XG, &YG, &Znew, 1);
                                       }
                                    else
                                       {
                                       if(billbout == NULL)
                                          billbout = fopen(billboardlog,"wb");
                                       if(billbout != NULL)
                                          {
                                          AddToBillBoardCheckList(Cindex,1);
                                          ++BillBoardPtsWritten;
                                          BB_FwriteDynamicInfo(billbout,MASKCONF2,Make_Correct(MASKCONF2,Cindex),
                                               Cindex,ActiveChecks[Cindex].sensitivity5, 0,0,2,NULL,
                                               unuseddbl, -1.0, -1.0, -1.0,
                                               Sindex1,G_GRIDPT,Lindex1,pseudoLID1,Grid1IDN,-1.0,-1.0,
                                               &XG, &YG, &ZG, 1,
                                               Sindex2, G_GRIDPT,Lindex2,pseudoLID2,Grid2IDN, -1.0, -1.0,
                                               &XG, &YG, &Znew, 1);
                                          }
                                       }

                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }

         }
      }

   return(DidTheCheck);
}







int CheckMaskAndGridsForZeroElev(int index, /** is = compositeindex **/
                                     int Cindex,  /*** is the checkinstance ***/
                                      double minx, double miny, double maxx, double maxy) /** LM bounds in internal coords **/
{
int k, j, kk, LM_index1, LM_index2, LM_i1, LM_i2;
int index1, index2;
int Sindex1, Sindex2;
int Lindex1, Lindex2;
int SI1, SI2, DidTheCheck;
double XG, YG, ZG;
double Znew, pseudoLID1, pseudoLID2/***,pl1,pl2***/;
double t1,t2;
int grows, gcols;
int part1, part2, part3, checkit;
double Zdiff;
int Grid1IDN, Grid2IDN;
unsigned int LI1, LI2;

   DidTheCheck = 0;
   if(NGT[index].NumGrids < 2) /*** less than 2 grids to compare in this Cindex=Region ***/
      return(DidTheCheck);

   for(LM_index1=0; LM_index1<NGT[index].NumGrids; LM_index1++)
      {
      if((NGT[index].GridIndex != NULL) && (MG[LM_index1].numX > 0) && (MG[LM_index1].numY > 0))
         {
         k = NGT[index].GridIndex[LM_index1];

         LI1 = GridHeader[k].Lindex;
         SI1 = CrsWlk[LI1].LtoSmapping;
         if((CombinedCheckApplies(GridHeader[k].idn,Cindex,MASKZERO,LI1,SI1,
                     SCCtable[SI1].C, SCCtable[SI1].S, SCCtable[SI1].D,
                     &part1,&part2,&part3) >  0) && (part1 > 0)) /*** this should be the mask ***/
            {
            for(LM_index2=0; /*LM_index1+1;*/ LM_index2<NGT[index].NumGrids; LM_index2++)
               {
               if((LM_index2 != LM_index1) && (MG[LM_index2].numX == MG[LM_index1].numX) &&
                      (MG[LM_index2].numY == MG[LM_index1].numY) &&
                         (NearlyEqual(GridHeader[k].BaseX,GridHeader[NGT[index].GridIndex[LM_index2]].BaseX) > 0) &&
                           (NearlyEqual(GridHeader[k].BaseY,GridHeader[NGT[index].GridIndex[LM_index2]].BaseY) > 0))
                  {
                  j = NGT[index].GridIndex[LM_index2];

                  LI2 = GridHeader[j].Lindex;
                  SI2 = CrsWlk[LI2].LtoSmapping;
                  if((CombinedCheckApplies(GridHeader[j].idn,Cindex,MASKZERO,LI2,SI2,
                       SCCtable[SI2].C, SCCtable[SI2].S, SCCtable[SI2].D,
                     &part1,&part2,&part3) >  0) && (part2 > 0)) /*** this shoule be the DEM ***/
                     {
                     DidTheCheck = 1;
                     t1 = MG[LM_index1].Xspace + MG[LM_index1].Yspace;
                     t2 = MG[LM_index2].Xspace + MG[LM_index2].Yspace;
                     t1 = t1 - t2;
                     if((-0.001 < t1) && (t1 < 0.001))
                        {
                        index1 = k;
                        index2 = j;
                        LM_i1 = LM_index1;
                        LM_i2 = LM_index2;
                        }
                     else
                        {
                        return(DidTheCheck);
                        }
                     Grid1IDN = GridHeader[index1].idn;
                     Grid2IDN = GridHeader[index2].idn;
                     Lindex1 = GridHeader[index1].Lindex;
                     Lindex2 = GridHeader[index2].Lindex;
                     Sindex1 = CrsWlk[Lindex1].LtoSmapping;
                     Sindex2 = CrsWlk[Lindex2].LtoSmapping;

                     for(grows = 0; grows < MG[LM_i1].numX; grows++)
                        {
                        XG = MG[LM_i1].SouthWestX  + ((double) grows * MG[LM_i1].Xspace);
                        if((XG >= minx) && (XG <= maxx))
                           {
                           for(gcols = 0; gcols < MG[LM_i1].numY; gcols++)
                              {
                              YG = MG[LM_i1].SouthWestY + ((double) gcols * MG[LM_i1].Yspace);

                              kk = (grows * MG[LM_i1].numY) + gcols;
                              ZG = MG[LM_i1].Elevs[kk];

                              checkit = 1;
/*** the flag value (i.e., ZG value) should be '1' to signal zero elevation DEM surface ***/
                              if((ZG < ActiveChecks[Cindex].sensitivity - ActiveChecks[Cindex].sensitivity2) ||
                                    (ZG > ActiveChecks[Cindex].sensitivity + ActiveChecks[Cindex].sensitivity2))
                                 checkit = 0;
                              if((checkit > 0) && (YG >= miny) && (YG <= maxy))
                                 {
                                 Znew = MG[LM_i2].Elevs[kk];
                                    if(0 > Znew)
                                       Zdiff = 0 - Znew;
                                    else
                                       Zdiff = Znew - 0;
                                    if(Zdiff > ActiveChecks[Cindex].sensitivity2)
                                       {
pseudoLID1 = 0 - index1; /***(index1+ 1) * (XG + (1.0 / YG)); ***/
pseudoLID2 = 0 - index2; /***(index2+ 1) * (XG + (1.0 / YG)); ***/

                                       if(ActiveChecks[Cindex].sensitivity3 < 1)
                                          {
                                          FwriteDynamicInfo(MASKZERO,Make_Correct(MASKZERO,Cindex),0,1,2,NULL,
                                            Zdiff, -1.0, -1.0, -1.0,
                                           Sindex1,G_GRIDPT,Lindex1,pseudoLID1,Grid1IDN,-1.0,-1.0,
                                           &XG, &YG, &ZG, 1,
                                           Sindex2, G_GRIDPT,Lindex2,pseudoLID2,Grid2IDN, -1.0, -1.0,
                                            &XG, &YG, &Znew, 1);
                                          }
                                       else
                                          {
                                          if(billbout == NULL)
                                             billbout = fopen(billboardlog,"wb");
                                          if(billbout != NULL)
                                             {
                                             AddToBillBoardCheckList(Cindex,1);
                                             ++BillBoardPtsWritten;
                                             BB_FwriteDynamicInfo(billbout,MASKZERO,Make_Correct(MASKZERO,Cindex),
                                                  Cindex,ActiveChecks[Cindex].sensitivity3, 0,1,2,NULL,
                                                  Zdiff, -1.0, -1.0, -1.0,
                                                  Sindex1,G_GRIDPT,Lindex1,pseudoLID1,Grid1IDN,-1.0,-1.0,
                                                  &XG, &YG, &ZG, 1,
                                                  Sindex2, G_GRIDPT,Lindex2,pseudoLID2,Grid2IDN, -1.0, -1.0,
                                                  &XG, &YG, &Znew, 1);
                                             }
                                          }

                                       }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }

   return(DidTheCheck);
}




int CheckMaskAndGridsForShorelineContainment(int index, /** is = compositeindex **/

                                     int Cindex,  /*** is the checkinstance ***/
                                      double minx, double miny, double maxx, double maxy) /** LM bounds in internal coords **/
{
int k, j, kk, LM_index1, LM_index2;
int Sindex1, Sindex2;
int Lindex1, Lindex2;
int SI1, SI2, DidTheCheck;
int tIndex, PlusIndex, MinusIndex, TotalElevs,WriteError;
double XG, YG, ZG;
double Znew, Zdiff, pseudoLID1, pseudoLID2;
double ShoreOffset;
int grows, gcols;
int part1, part2, part3, checkit;
int Grid1IDN, Grid2IDN;
unsigned int LI1, LI2;

   DidTheCheck = 0;

   if(NGT[index].NumGrids < 2) /*** less than 2 grids to compare in this Cindex=Region ***/
      return(DidTheCheck);

   for(LM_index1=0; LM_index1<NGT[index].NumGrids; LM_index1++)
      {
      if((NGT[index].GridIndex != NULL) && (MG[LM_index1].numX > 0) && (MG[LM_index1].numY > 0))
         {
         k = NGT[index].GridIndex[LM_index1];

         LI1 = GridHeader[k].Lindex;
         SI1 = CrsWlk[LI1].LtoSmapping;
         if((CombinedCheckApplies(GridHeader[k].idn,Cindex,MASKSHOREL,LI1,SI1,
                     SCCtable[SI1].C, SCCtable[SI1].S, SCCtable[SI1].D,
                     &part1,&part2,&part3) >  0) && (part1 > 0)) /*** this should be the mask ***/
            {
            if(FindSpecificSensitivity(3,MASKSHOREL,Cindex,&ShoreOffset) < 1)
               continue;
            for(LM_index2=0; LM_index2<NGT[index].NumGrids; LM_index2++)
               {
               if((LM_index2 != LM_index1) && (MG[LM_index2].numX == MG[LM_index1].numX) &&
                      (MG[LM_index2].numY == MG[LM_index1].numY) &&
                         (NearlyEqual(GridHeader[k].BaseX,GridHeader[NGT[index].GridIndex[LM_index2]].BaseX) > 0) &&
                            (NearlyEqual(GridHeader[k].BaseY,GridHeader[NGT[index].GridIndex[LM_index2]].BaseY) > 0))
                  {
                  j = NGT[index].GridIndex[LM_index2];

                  LI2 = GridHeader[j].Lindex;
                  SI2 = CrsWlk[LI2].LtoSmapping;
                  if((CombinedCheckApplies(GridHeader[j].idn,Cindex,MASKSHOREL,LI2,SI2,
                       SCCtable[SI2].C, SCCtable[SI2].S, SCCtable[SI2].D,
                     &part1,&part2,&part3) >  0) && (part2 > 0)) /*** this shoule be the DEM ***/
                     {
                     DidTheCheck = 1;
                     Grid1IDN = GridHeader[k].idn;
                     Grid2IDN = GridHeader[j].idn;
                     Lindex1 = GridHeader[k].Lindex;
                     Lindex2 = GridHeader[j].Lindex;
                     Sindex1 = CrsWlk[Lindex1].LtoSmapping;
                     Sindex2 = CrsWlk[Lindex2].LtoSmapping;
                     TotalElevs = MG[LM_index2].numX * MG[LM_index2].numY;
TotalElevs -= 1;


                     for(grows = 0; grows < MG[LM_index1].numX; grows++)
                        {
                        XG = MG[LM_index1].SouthWestX  + ((double) grows * MG[LM_index1].Xspace);
                        if((XG >= minx) && (XG <= maxx))
                           {
                           for(gcols = 0; gcols < MG[LM_index1].numY; gcols++)
                              {
                              YG = MG[LM_index1].SouthWestY + ((double) gcols * MG[LM_index1].Yspace);

                              kk = (grows * MG[LM_index1].numY) + gcols;
                              PlusIndex = kk + MG[LM_index1].numY;
                              MinusIndex = kk - MG[LM_index1].numY;

                              ZG = MG[LM_index1].Elevs[kk];

                              checkit = 0;
                              if(ZG == 0)
                                 checkit = 1;
                              if((checkit > 0) && (YG >= miny) && (YG <= maxy))
                                 {
                                 WriteError = 0;
                                 Znew = MG[LM_index2].Elevs[kk];

                                 tIndex = MinusIndex - 1;
                                 if((tIndex >= 0) && (tIndex <= TotalElevs) && (gcols > 0))
                                    {
                                    ZG = MG[LM_index1].Elevs[tIndex];
                                    if((ZG >= ActiveChecks[Cindex].sensitivity) &&
                                       (ZG <= ActiveChecks[Cindex].sensitivity2))
                                       {
                                       if(Znew <= MG[LM_index2].Elevs[tIndex])
                                          {
                                          WriteError += 1;
                                          Zdiff = Znew - MG[LM_index2].Elevs[tIndex];
                                          }
                                       }
                                    }
                                 if(WriteError == 0)
                                    {
                                    tIndex = MinusIndex;
                                    if((tIndex >= 0) && (tIndex <= TotalElevs))
                                       {
                                       ZG = MG[LM_index1].Elevs[tIndex];
                                       if((ZG >= ActiveChecks[Cindex].sensitivity) &&
                                             (ZG <= ActiveChecks[Cindex].sensitivity2))
                                          {
                                          if(Znew <= (MG[LM_index2].Elevs[tIndex] + ShoreOffset))
                                             {
                                             WriteError += 1;
                                             Zdiff = Znew - MG[LM_index2].Elevs[tIndex];
                                             }
                                          }
                                       }
                                    }
                                 if(WriteError == 0)
                                    {
                                    tIndex = MinusIndex + 1;
                                    if((tIndex >= 0) && (tIndex <= TotalElevs) && (gcols < (MG[LM_index1].numY - 1)))
                                       {
                                       ZG = MG[LM_index1].Elevs[tIndex];
                                       if((ZG >= ActiveChecks[Cindex].sensitivity) &&
                                             (ZG <= ActiveChecks[Cindex].sensitivity2))
                                          {
                                          if(Znew <= (MG[LM_index2].Elevs[tIndex] + ShoreOffset))
                                             {
                                             WriteError += 1;
                                             Zdiff = Znew - MG[LM_index2].Elevs[tIndex];
                                             }
                                          }
                                       }
                                    }
                                 if(WriteError == 0)
                                    {
                                    tIndex = PlusIndex - 1;
                                    if((tIndex >= 0) && (tIndex <= TotalElevs) && (gcols > 0))
                                       {
                                       ZG = MG[LM_index1].Elevs[tIndex];
                                       if((ZG >= ActiveChecks[Cindex].sensitivity) &&
                                             (ZG <= ActiveChecks[Cindex].sensitivity2))
                                          {
                                          if(Znew <= (MG[LM_index2].Elevs[tIndex] + ShoreOffset))
                                             {
                                             WriteError += 1;
                                             Zdiff = Znew - MG[LM_index2].Elevs[tIndex];
                                             }
                                          }
                                       }
                                    }
                                 if(WriteError == 0)
                                    {
                                    tIndex = PlusIndex;
                                    if((tIndex >= 0) && (tIndex <= TotalElevs))
                                       {
                                       ZG = MG[LM_index1].Elevs[tIndex];
                                       if((ZG >= ActiveChecks[Cindex].sensitivity) &&
                                             (ZG <= ActiveChecks[Cindex].sensitivity2))
                                          {
                                          if(Znew <= (MG[LM_index2].Elevs[tIndex] + ShoreOffset))
                                             {
                                             WriteError += 1;
                                             Zdiff = Znew - MG[LM_index2].Elevs[tIndex];
                                             }
                                          }
                                       }
                                    }
                                 if(WriteError == 0)
                                    {
                                    tIndex = PlusIndex + 1;
                                    if((tIndex >= 0) && (tIndex <= TotalElevs) && (gcols < (MG[LM_index1].numY - 1)))
                                       {
                                       ZG = MG[LM_index1].Elevs[tIndex];
                                       if((ZG >= ActiveChecks[Cindex].sensitivity) &&
                                             (ZG <= ActiveChecks[Cindex].sensitivity2))
                                          {
                                          if(Znew <= (MG[LM_index2].Elevs[tIndex] + ShoreOffset))
                                             {
                                             WriteError += 1;
                                             Zdiff = Znew - MG[LM_index2].Elevs[tIndex];
                                             }
                                          }
                                       }
                                    }

                                 if(WriteError == 0)
                                    {
                                    tIndex = kk - 1;
                                    if((tIndex >= 0) && (tIndex <= TotalElevs) && (gcols > 0))
                                       {
                                       ZG = MG[LM_index1].Elevs[tIndex];
                                       if((ZG >= ActiveChecks[Cindex].sensitivity) &&
                                             (ZG <= ActiveChecks[Cindex].sensitivity2))
                                          {
                                          if(Znew <= (MG[LM_index2].Elevs[tIndex] + ShoreOffset))
                                             {
                                             WriteError += 1;
                                             Zdiff = Znew - MG[LM_index2].Elevs[tIndex];
                                             }
                                          }
                                       }
                                    }

                                 if(WriteError == 0)
                                    {
                                    tIndex = kk + 1;
                                    if((tIndex >= 0) && (tIndex <= TotalElevs) && (gcols < (MG[LM_index1].numY - 1)))
                                       {
                                       ZG = MG[LM_index1].Elevs[tIndex];
                                       if((ZG >= ActiveChecks[Cindex].sensitivity) &&
                                             (ZG <= ActiveChecks[Cindex].sensitivity2))
                                          {
                                          if(Znew <= (MG[LM_index2].Elevs[tIndex] + ShoreOffset))
                                             {
                                             WriteError += 1;
                                             Zdiff = Znew - MG[LM_index2].Elevs[tIndex];
                                             }
                                          }
                                       }
                                    }

                                 if(WriteError > 0)
                                    {
                                    WriteError = 0;
                                    pseudoLID1 = (k+ 1) * (XG + (1.0 / YG));
                                    pseudoLID2 = (j+ 1) * (XG + (1.0 / YG));

                                    FwriteMagnitudeAndTwoObjects(MASKSHOREL,Make_Correct(MASKSHOREL,Cindex),Zdiff,
                                        Sindex1,G_GRIDPT,Lindex1,pseudoLID1,Grid1IDN,-1.0,-1.0,
                                        &XG, &YG, &ZG, 1,
                                        Sindex2, G_GRIDPT,Lindex2,pseudoLID2,Grid2IDN, -1.0, -1.0,
                                         &XG, &YG, &Znew, 1);
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }

   return(DidTheCheck);
}






int CheckMaskAndGridsForConstantElev(int index, /** is = compositeindex **/
                                     int Cindex,  /*** is the checkinstance ***/
                                      double minx, double miny, double maxx, double maxy) /** LM bounds in internal coords **/
{
int k, j, kk, LM_index1, LM_index2;
int Sindex1, Sindex2;
int Lindex1, Lindex2;
int SI1, SI2, DidTheCheck;
int tIndex, PlusIndex, MinusIndex, TotalElevs,WriteError;
double XG, YG, ZG;
double Znew, Zdiff, pseudoLID1, pseudoLID2;
double OtherXmax,OtherYmax;
int grows, gcols;
int part1, part2, part3, checkit;
int Grid1IDN, Grid2IDN;
unsigned int LI1, LI2;

   DidTheCheck = 0;

   if(NGT[index].NumGrids < 2) /*** less than 2 grids to compare in this Cindex=Region ***/
      return(DidTheCheck);

   for(LM_index1=0; LM_index1<NGT[index].NumGrids; LM_index1++)
      {
      if((NGT[index].GridIndex != NULL) && (MG[LM_index1].numX > 0) && (MG[LM_index1].numY > 0))
         {
         k = NGT[index].GridIndex[LM_index1];

         LI1 = GridHeader[k].Lindex;
         SI1 = CrsWlk[LI1].LtoSmapping;
         if((CombinedCheckApplies(GridHeader[k].idn,Cindex,MASKCONSTANT,LI1,SI1,
                     SCCtable[SI1].C, SCCtable[SI1].S, SCCtable[SI1].D,
                     &part1,&part2,&part3) >  0) && (part1 > 0)) /*** this should be the mask ***/
            {
            for(LM_index2=0; LM_index2<NGT[index].NumGrids; LM_index2++)
               {
               if((LM_index2 != LM_index1) && (MG[LM_index2].numX == MG[LM_index1].numX) &&
                      (MG[LM_index2].numY == MG[LM_index1].numY) &&
                         (NearlyEqual(GridHeader[k].BaseX,GridHeader[NGT[index].GridIndex[LM_index2]].BaseX) > 0) &&
                            (NearlyEqual(GridHeader[k].BaseY, GridHeader[NGT[index].GridIndex[LM_index2]].BaseY) > 0))
                  {
                  j = NGT[index].GridIndex[LM_index2];

                  LI2 = GridHeader[j].Lindex;
                  SI2 = CrsWlk[LI2].LtoSmapping;
                  if((CombinedCheckApplies(GridHeader[j].idn,Cindex,MASKCONSTANT,LI2,SI2,
                       SCCtable[SI2].C, SCCtable[SI2].S, SCCtable[SI2].D,
                     &part1,&part2,&part3) >  0) && (part2 > 0)) /*** this shoule be the DEM ***/
                     {
                     DidTheCheck = 1;

                     Grid1IDN = GridHeader[k].idn;
                     Grid2IDN = GridHeader[j].idn;
                     Lindex1 = GridHeader[k].Lindex;
                     Lindex2 = GridHeader[j].Lindex;
                     Sindex1 = CrsWlk[Lindex1].LtoSmapping;
                     Sindex2 = CrsWlk[Lindex2].LtoSmapping;
                     TotalElevs = MG[LM_index2].numX * MG[LM_index2].numY;
TotalElevs -= 1;

                     for(grows = 0; grows < MG[LM_index1].numX; grows++)
                        {
                        XG = MG[LM_index1].SouthWestX  + ((double) grows * MG[LM_index1].Xspace);
                        if((XG >= minx) && (XG <= maxx))
                           {
                           for(gcols = 0; gcols < MG[LM_index1].numY; gcols++)
                              {
                              YG = MG[LM_index1].SouthWestY + ((double) gcols * MG[LM_index1].Yspace);

                              kk = (grows * MG[LM_index1].numY) + gcols;
                              PlusIndex = kk + MG[LM_index1].numY;
                              MinusIndex = kk - MG[LM_index1].numY;
/*** this is the internal coordinate form of the max x and y for the points in this LM ***/
/**  don't want to try and reference data outside those limits - note the min is BaseX or BaseY ***/
OtherYmax = GridHeader[LM_index2].BaseY + (GridHeader[LM_index2].Yspacing * (GridHeader[LM_index2].Ypts - 2));
OtherXmax = GridHeader[LM_index2].BaseX + (GridHeader[LM_index2].Xspacing * (GridHeader[LM_index2].Xpts - 2));

                              ZG = MG[LM_index1].Elevs[kk];

                              checkit = 1;
                              if((ZG < ActiveChecks[Cindex].sensitivity - ActiveChecks[Cindex].sensitivity2) ||
                                    (ZG > ActiveChecks[Cindex].sensitivity + ActiveChecks[Cindex].sensitivity2))
                                 checkit = 0;
                              if((checkit > 0) && (YG >= miny) && (YG <= maxy))
                                 {
                                 WriteError = 0;
                                 Znew = MG[LM_index2].Elevs[kk];

if(XG >= GridHeader[LM_index2].BaseX)
{
                                 tIndex = MinusIndex - 1;
                                 if((YG > GridHeader[LM_index2].BaseY) && (tIndex >= 0) && (tIndex <= TotalElevs))
                                    {
                                    ZG = MG[LM_index1].Elevs[tIndex];
                                    if((ZG >= ActiveChecks[Cindex].sensitivity - ActiveChecks[Cindex].sensitivity2) &&
                                       (ZG <= ActiveChecks[Cindex].sensitivity + ActiveChecks[Cindex].sensitivity2))
                                       {
                                       if(Znew != MG[LM_index2].Elevs[tIndex])
                                          {
                                          WriteError += 1;
                                          if(Znew > MG[LM_index2].Elevs[tIndex])
                                             Zdiff = Znew - MG[LM_index2].Elevs[tIndex];
                                          else
                                             Zdiff = MG[LM_index2].Elevs[tIndex] - Znew;
                                          }
                                       }
                                    }
                                 if(WriteError == 0)
                                    {
                                    tIndex = MinusIndex;
                                    if((tIndex >= 0) && (tIndex <= TotalElevs))
                                       {
                                       ZG = MG[LM_index1].Elevs[tIndex];
                                       if((ZG >= ActiveChecks[Cindex].sensitivity - ActiveChecks[Cindex].sensitivity2) &&
                                          (ZG <= ActiveChecks[Cindex].sensitivity + ActiveChecks[Cindex].sensitivity2))
                                          {
                                          if(Znew != MG[LM_index2].Elevs[tIndex])
                                             {
                                             WriteError += 1;
                                             if(Znew > MG[LM_index2].Elevs[tIndex])
                                                Zdiff = Znew - MG[LM_index2].Elevs[tIndex];
                                             else
                                                Zdiff = MG[LM_index2].Elevs[tIndex] - Znew;
                                             }
                                          }
                                       }
                                    }
                                 if(WriteError == 0)
                                    {
                                    tIndex = MinusIndex + 1;
                                    if((YG <= OtherYmax) && (tIndex >= 0) && (tIndex <= TotalElevs))
                                       {
                                       ZG = MG[LM_index1].Elevs[tIndex];
                                       if((ZG >= ActiveChecks[Cindex].sensitivity - ActiveChecks[Cindex].sensitivity2) &&
                                          (ZG <= ActiveChecks[Cindex].sensitivity + ActiveChecks[Cindex].sensitivity2))
                                          {
                                          if(Znew != MG[LM_index2].Elevs[tIndex])
                                             {
                                             WriteError += 1;
                                             if(Znew > MG[LM_index2].Elevs[tIndex])
                                                Zdiff = Znew - MG[LM_index2].Elevs[tIndex];
                                             else
                                                Zdiff = MG[LM_index2].Elevs[tIndex] - Znew;
                                             }
                                          }
                                       }
                                    }
}
if(XG <= OtherXmax)
{
                                 if(WriteError == 0)
                                    {
                                    tIndex = PlusIndex - 1;
                                    if((YG > GridHeader[LM_index2].BaseY) && (tIndex >= 0) && (tIndex <= TotalElevs))
                                       {
                                       ZG = MG[LM_index1].Elevs[tIndex];
                                       if((ZG >= ActiveChecks[Cindex].sensitivity - ActiveChecks[Cindex].sensitivity2) &&
                                          (ZG <= ActiveChecks[Cindex].sensitivity + ActiveChecks[Cindex].sensitivity2))
                                          {
                                          if(Znew != MG[LM_index2].Elevs[tIndex])
                                             {
                                             WriteError += 1;
                                             if(Znew > MG[LM_index2].Elevs[tIndex])
                                                Zdiff = Znew - MG[LM_index2].Elevs[tIndex];
                                             else
                                                Zdiff = MG[LM_index2].Elevs[tIndex] - Znew;
                                             }
                                          }
                                       }
                                    }
                                 if(WriteError == 0)
                                    {
                                    tIndex = PlusIndex;
                                    if((tIndex >= 0) && (tIndex <= TotalElevs))
                                       {
                                       ZG = MG[LM_index1].Elevs[tIndex];
                                       if((ZG >= ActiveChecks[Cindex].sensitivity - ActiveChecks[Cindex].sensitivity2) &&
                                          (ZG <= ActiveChecks[Cindex].sensitivity + ActiveChecks[Cindex].sensitivity2))
                                          {
                                          if(Znew != MG[LM_index2].Elevs[tIndex])
                                             {
                                             WriteError += 1;
                                             if(Znew > MG[LM_index2].Elevs[tIndex])
                                                Zdiff = Znew - MG[LM_index2].Elevs[tIndex];
                                             else
                                                Zdiff = MG[LM_index2].Elevs[tIndex] - Znew;
                                             }
                                          }
                                       }
                                    }
                                 if(WriteError == 0)
                                    {
                                    tIndex = PlusIndex + 1;
                                    if((YG <= OtherYmax) && (tIndex >= 0) && (tIndex <= TotalElevs))
                                       {
                                       ZG = MG[LM_index1].Elevs[tIndex];
                                       if((ZG >= ActiveChecks[Cindex].sensitivity - ActiveChecks[Cindex].sensitivity2) &&
                                          (ZG <= ActiveChecks[Cindex].sensitivity + ActiveChecks[Cindex].sensitivity2))
                                          {
                                          if(Znew != MG[LM_index2].Elevs[tIndex])
                                             {
                                             WriteError += 1;
                                             if(Znew > MG[LM_index2].Elevs[tIndex])
                                                Zdiff = Znew - MG[LM_index2].Elevs[tIndex];
                                             else
                                                Zdiff = MG[LM_index2].Elevs[tIndex] - Znew;
                                             }
                                          }
                                       }
                                    }
}

                                 if(WriteError == 0)
                                    {
                                    tIndex = kk - 1;
                                    if((YG > GridHeader[LM_index2].BaseY) && (tIndex >= 0) && (tIndex <= TotalElevs))
                                       {
                                       ZG = MG[LM_index1].Elevs[tIndex];
                                       if((ZG >= ActiveChecks[Cindex].sensitivity - ActiveChecks[Cindex].sensitivity2) &&
                                          (ZG <= ActiveChecks[Cindex].sensitivity + ActiveChecks[Cindex].sensitivity2))
                                          {
                                          if(Znew != MG[LM_index2].Elevs[tIndex])
                                             {
                                             WriteError += 1;
                                             if(Znew > MG[LM_index2].Elevs[tIndex])
                                                Zdiff = Znew - MG[LM_index2].Elevs[tIndex];
                                             else
                                                Zdiff = MG[LM_index2].Elevs[tIndex] - Znew;
                                             }
                                          }
                                       }
                                    }
                                 if(WriteError == 0)
                                    {
                                    tIndex = kk + 1;
                                    if((YG <= OtherYmax) && (tIndex >= 0) && (tIndex <= TotalElevs))
                                       {
                                       ZG = MG[LM_index1].Elevs[tIndex];
                                       if((ZG >= ActiveChecks[Cindex].sensitivity - ActiveChecks[Cindex].sensitivity2) &&
                                          (ZG <= ActiveChecks[Cindex].sensitivity + ActiveChecks[Cindex].sensitivity2))
                                          {
                                          if(Znew != MG[LM_index2].Elevs[tIndex])
                                             {
                                             WriteError += 1;
                                             if(Znew > MG[LM_index2].Elevs[tIndex])
                                                Zdiff = Znew - MG[LM_index2].Elevs[tIndex];
                                             else
                                                Zdiff = MG[LM_index2].Elevs[tIndex] - Znew;
                                             }
                                          }
                                       }
                                    }
                                 if(WriteError > 0)
                                    {
                                    pseudoLID1 = 0 - LM_index1;  /**(k+ 1) * (XG + (1.0 / YG));**/
                                    pseudoLID2 = 0 - LM_index2; /**(j+ 1) * (XG + (1.0 / YG)); **/
                                    if(ActiveChecks[Cindex].sensitivity3 < 1)
                                       {
                                       FwriteDynamicInfo(MASKCONSTANT,Make_Correct(MASKCONSTANT,Cindex),0,1,2,NULL,
                                         Zdiff, -1.0, -1.0, -1.0,
                                        Sindex1,G_GRIDPT,Lindex1,pseudoLID1,Grid1IDN,-1.0,-1.0,
                                        &XG, &YG, &ZG, 1,
                                        Sindex2, G_GRIDPT,Lindex2,pseudoLID2,Grid2IDN, -1.0, -1.0,
                                         &XG, &YG, &Znew, 1);
                                       }
                                    else
                                       {
                                       if(billbout == NULL)
                                          billbout = fopen(billboardlog,"wb");
                                       if(billbout != NULL)
                                          {
                                          AddToBillBoardCheckList(Cindex,1);
                                          ++BillBoardPtsWritten;
                                          BB_FwriteDynamicInfo(billbout,MASKCONSTANT,Make_Correct(MASKCONSTANT,Cindex),
                                               Cindex,ActiveChecks[Cindex].sensitivity3, 0,1,2,NULL,
                                               Zdiff, -1.0, -1.0, -1.0,
                                               Sindex1,G_GRIDPT,Lindex1,pseudoLID1,Grid1IDN,-1.0,-1.0,
                                               &XG, &YG, &ZG, 1,
                                               Sindex2, G_GRIDPT,Lindex2,pseudoLID2,Grid2IDN, -1.0, -1.0,
                                               &XG, &YG, &Znew, 1);
                                          }
                                       }
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }

   return(DidTheCheck);
}




int PickFlowAnchorPoints(int start, int realrow, int realcol)
{
int ToShore[8];
int i,j,row,col, mindir, maxdir;
int d1, d2;

   row = realrow;
   col = realcol;

   for(i=0; i<8; i++)
      ToShore[i] = -1;



   for(i=1; i< 100; i++)
      {
      if(col < (FlowFlags.NumX - i))
         {
         j = start + (i * FlowFlags.NumY);
         if(FlowFlags.PointFlow[j] <= 0) /** hit the shoreline **/
            {
            ToShore[2] = i;
            break;
            }
         ++col;
         }
      else
         break;
      }
   col = realcol;

   for(i=1; i< 100; i++)
      {
      if(col > i)
         {
         j = start - (i * FlowFlags.NumY);
         if(FlowFlags.PointFlow[j] <= 0)
            {
            ToShore[6] = i;
            break;
            }
         --col;
         }
      else
         break;
      }
   col = realcol;

   for(i=1; i<100; i++)
      {
      if(row < (FlowFlags.NumY - i))
         {
         j = start + i;
         if(FlowFlags.PointFlow[j] <= 0)
            {
            ToShore[0] = i;
            break;
            }
         ++row;
         }
      else
         break;
      }
   row = realrow;
   for(i=1; i<100; i++)
      {
      if(row > i)
         {
         j = start - i;
         if(FlowFlags.PointFlow[j] <= 0)
            {
            ToShore[4] = i;
            break;
            }
         --row;
         }
      else
         break;
      }
   row = realrow;

   for(i=1; i< 100; i++)
      {
      if((row > i) && (col > i))
         {
         j = start - i - (i * FlowFlags.NumY);
         if(FlowFlags.PointFlow[j] <= 0)
            {
            ToShore[5] = i;
            break;
            }
         --row;
         --col;
         }
      else
         break;
      }
   row = realrow;
   col = realcol;

   for(i=1; i< 100; i++)
      {
      if((row < (FlowFlags.NumY - i)) && (col < (FlowFlags.NumX - i)))
         {
         j = start + i + (i * FlowFlags.NumY);
         if(FlowFlags.PointFlow[j] <= 0)
            {
            ToShore[1] = i;
            break;
            }
         ++row;
         ++col;
         }
      else
         break;
      }
   row = realrow;
   col = realcol;

   for(i=1; i< 100; i++)
      {
      if((row > i) && (col < (FlowFlags.NumX - i)))
         {
         j = start - i + (i * FlowFlags.NumY);
         if(FlowFlags.PointFlow[j] <= 0)
            {
            ToShore[3] = i;
            break;
            }
         --row;
         ++col;
         }
      else
         break;
      }
   row = realrow;
   col = realcol;

   for(i=1; i< 100; i++)
      {
      if((row < (FlowFlags.NumY - i)) && (col > i))
         {
         j = start + i - (i * FlowFlags.NumY);
         if(FlowFlags.PointFlow[j] <= 0)
            {
            ToShore[7] = i;
            break;
            }
         ++row;
         --col;
         }
      else
         break;
      }

   row = realrow;
   col = realcol;

   d1 = 0;
   maxdir = ToShore[0];
   for(i=1; i<8; i++)
      {
      if(ToShore[i] > maxdir)
         {
         maxdir = ToShore[i];
         d1 = i;
         }
      }
   d2 = (int) (maxdir / 2);
mindir = maxdir;
   for(i=0; i<8; i++)
      {
      if((ToShore[i] >= 0) && (ToShore[i] < mindir))
         mindir = ToShore[i];
      }
if(mindir > 0)
      {
      switch(d1)
         {
         case 0:
            j = start + d2;
            if(FlowFlags.PointFlow[j] != 30)
               FlowFlags.PointFlow[j] = 35;
            break;
         case 1:
            j = start + d2 + (d2 * FlowFlags.NumY);
            if(FlowFlags.PointFlow[j] != 30)
               FlowFlags.PointFlow[j] = 35;
            break;
         case 2:
            j = start + (d2 * FlowFlags.NumY);
            if(FlowFlags.PointFlow[j] != 30)
               FlowFlags.PointFlow[j] = 35;
            break;
         case 3:
            j = start - d2 + (d2 * FlowFlags.NumY);
            if(FlowFlags.PointFlow[j] != 30)
               FlowFlags.PointFlow[j] = 35;
            break;
         case 4:
            j = start - d2;
            if(FlowFlags.PointFlow[j] != 30)
               FlowFlags.PointFlow[j] = 35;
            break;
         case 5:
            j = start - d2 - (d2 * FlowFlags.NumY);
            if(FlowFlags.PointFlow[j] != 30)
               FlowFlags.PointFlow[j] = 35;
            break;
         case 6:
            j = start - (d2 * FlowFlags.NumY);
            if(FlowFlags.PointFlow[j] != 30)
               FlowFlags.PointFlow[j] = 35;
            break;
         case 7:
            j = start + d2 - (d2 * FlowFlags.NumY);
            if(FlowFlags.PointFlow[j] != 30)
               FlowFlags.PointFlow[j] = 35;
            break;
         }
      }

   return(maxdir + 2);
}



int FlowByShoreline(int start, int realrow, int realcol)
{
int ToShore[8];
int i,j,row,col,mindiff, maxdir,MonoSensitivity;
int d1, d3/***, d2, d4***/;
int collision, checkinstance;
double realdist;

   row = realrow;
   col = realcol;

   maxdir = -2;

   MonoSensitivity = 0;
/** can use the below since there is only one instance of MASKMONO allowed at any one time (no new instaces allowed) **/
   for(checkinstance = 0; checkinstance < TtlActiveChecks; checkinstance++)
      {
      if(ActiveChecks[checkinstance].number == MASKMONO)
         {
         if(ActiveChecks[checkinstance].sensitivity3 != 0)
            MonoSensitivity = 1;
         break;
         }
      }

   for(i=0; i<8; i++)
      ToShore[i] = -1;



   for(i=1; i< 100; i++)
      {
      if(col < (FlowFlags.NumY - i))
         {
         j = start + (i * FlowFlags.NumY);
         if((FlowFlags.PointFlow[j] <= 0) || (FlowFlags.PointFlow[j] == 30))
            {
            ToShore[2] = i;
            break;
            }
         ++col;
         }
      else
         break;
      }
   col = realcol;

   for(i=1; i< 100; i++)
      {
      if(col > i)
         {
         j = start - (i * FlowFlags.NumY);
         if((FlowFlags.PointFlow[j] <= 0) || (FlowFlags.PointFlow[j] == 30))
            {
            ToShore[6] = i;
            break;
            }
         --col;
         }
      else
         break;
      }
   col = realcol;

   for(i=1; i<100; i++)
      {
      if(row < (FlowFlags.NumX - i))
         {
         j = start + i;
         if((FlowFlags.PointFlow[j] <= 0) || (FlowFlags.PointFlow[j] == 30))
            {
            ToShore[0] = i;
            break;
            }
         ++row;
         }
      else
         break;
      }
   row = realrow;
   for(i=1; i<100; i++)
      {
      if(row > i)
         {
         j = start - i;
         if((FlowFlags.PointFlow[j] <= 0) || (FlowFlags.PointFlow[j] == 30))
            {
            ToShore[4] = i;
            break;
            }
         --row;
         }
      else
         break;
      }
   row = realrow;

   for(i=1; i< 100; i++)
      {
      if((row > i) && (col > i))
         {
         j = start - i - (i * FlowFlags.NumY);
         if((FlowFlags.PointFlow[j] <= 0) || (FlowFlags.PointFlow[j] == 30))
            {
            ToShore[5] = i;
            break;
            }
         --row;
         --col;
         }
      else
         break;
      }
   row = realrow;
   col = realcol;

   for(i=1; i< 100; i++)
      {
      if((row < (FlowFlags.NumX - i)) && (col < (FlowFlags.NumY - i)))
         {
         j = start + i + (i * FlowFlags.NumY);
         if((FlowFlags.PointFlow[j] <= 0) || (FlowFlags.PointFlow[j] == 30))
            {
            ToShore[1] = i;
            break;
            }
         ++row;
         ++col;
         }
      else
         break;
      }
   row = realrow;
   col = realcol;

   for(i=1; i< 100; i++)
      {
      if((row > i) && (col < (FlowFlags.NumY - i)))
         {
         j = start - i + (i * FlowFlags.NumY);
         if((FlowFlags.PointFlow[j] <= 0) || (FlowFlags.PointFlow[j] == 30))
            {
            ToShore[3] = i;
            break;
            }
         --row;
         ++col;
         }
      else
         break;
      }
   row = realrow;
   col = realcol;

   for(i=1; i< 100; i++)
      {
      if((row < (FlowFlags.NumX - i)) && (col > i))
         {
         j = start + i - (i * FlowFlags.NumY);
         if((FlowFlags.PointFlow[j] <= 0) || (FlowFlags.PointFlow[j] == 30))
            {
            ToShore[7] = i;
            break;
            }
         ++row;
         --col;
         }
      else
         break;
      }
   row = realrow;
   col = realcol;

   
   for(d1 = 0; d1 < 8; d1++)
      {
      if(ToShore[d1] <= 0)
         break;
      }
   if(d1 >= 8) 
      {
   d1 = ToShore[0] + ToShore[4];
   maxdir = 1;
   mindiff = d1;

   realdist = (double) (ToShore[1] + ToShore[5]) * 1.414;

   if(realdist < (double) (mindiff))
      {
      maxdir = 2;
      mindiff = ((int) realdist);
      }

   d3 = ToShore[2] + ToShore[6];
   if(d3 < mindiff)
      {
      maxdir = 3;
      mindiff = d3;
      }

   realdist = (double) (ToShore[3] + ToShore[7]) * 1.414;

   if(realdist < (double) (mindiff))
      {
      maxdir = 4;
      mindiff = ((int) realdist);
      }
   collision = 0;
   if((mindiff  > 7) && (MonoSensitivity == 0))
      {
      switch(maxdir)
         {
         case 1:
            j = start - ToShore[4];
            for(i = 1; i < ToShore[4] + ToShore[0]; i++)
               {
               j++;
               if((FlowFlags.PointFlow[j] != 17) && (FlowFlags.PointFlow[j] != 0) &&
                  (FlowFlags.PointFlow[j] != 30) && (FlowFlags.PointFlow[j] != 35))
                  {
                  ++collision;
                  }
               }
            break;
         case 2:
            j = start - (ToShore[5] + (ToShore[5] * (FlowFlags.NumY)));
            for(i = 1; i < ToShore[1] + ToShore[5]; i++)
               {
               j += 1 + FlowFlags.NumY;
               if((FlowFlags.PointFlow[j] != 17) && (FlowFlags.PointFlow[j] != 0) &&
                  (FlowFlags.PointFlow[j] != 30) && (FlowFlags.PointFlow[j] != 35))
                  {
                  ++collision;
                  }
               }
            break;
         case 3:
            j = start - (ToShore[6] * FlowFlags.NumY);
            for(i=1; i< (ToShore[2] + ToShore[6]); i++)
               {
               j += FlowFlags.NumY;
               if((FlowFlags.PointFlow[j] != 17) && (FlowFlags.PointFlow[j] != 0) &&
                  (FlowFlags.PointFlow[j] != 30) && (FlowFlags.PointFlow[j] != 35))
                  {
                  ++collision;
                  }
               }
            break;
         case 4:
            j = start + ToShore[7] - (ToShore[7] * (FlowFlags.NumY));
            for(i = 1; i < ToShore[7] + ToShore[3]; i++)
               {
               j = j - 1 + FlowFlags.NumY;
               if((FlowFlags.PointFlow[j] != 17) && (FlowFlags.PointFlow[j] != 0) &&
                  (FlowFlags.PointFlow[j] != 30) && (FlowFlags.PointFlow[j] != 35))
                  {
                  ++collision;
                  }
               }
            break;
         }
      }


   if((mindiff  > 7) && (collision == 0))
      {
      switch(maxdir)
         {
         case 1:
            j = ToShore[0] + ToShore[4];
/*** below - testing to see that flow direction isnot perpendicula to closest shore direction **/
            if((j < ToShore[2]) && (j < ToShore[6]))
               {
               j = start - ToShore[4];
               for(i = 1; i < ToShore[4] + ToShore[0]; i++)
                  {
                  j++;
                  if((FlowFlags.PointFlow[j] > 15) && (FlowFlags.PointFlow[j] < MONOBUMP))
                     FlowFlags.PointFlow[j] = 36;
                  }
               }
            break;
         case 2:
            j = ToShore[1] + ToShore[5];
            if((j < ToShore[7]) && (j < ToShore[3]))
               {
               j = start - (ToShore[5] + (ToShore[5] * (FlowFlags.NumY)));
               for(i = 1; i < ToShore[1] + ToShore[5]; i++)
                  {
                  j += 1 + FlowFlags.NumY;
                  if((FlowFlags.PointFlow[j] > 15) && (FlowFlags.PointFlow[j] < MONOBUMP))
                     FlowFlags.PointFlow[j] = 37;
                  }
               }
            break;
         case 3:
            j = ToShore[2] + ToShore[6];
            if((j < ToShore[0]) && (j < ToShore[4]))
               {
               j = start - (ToShore[6] * FlowFlags.NumY);
               for(i=1; i< (ToShore[2] + ToShore[6]); i++)
                  {
                  j += FlowFlags.NumY;
                  if((FlowFlags.PointFlow[j] > 15) && (FlowFlags.PointFlow[j] < MONOBUMP))
                     FlowFlags.PointFlow[j] = 38;
                  }
               }
            break;
         case 4:
            j = ToShore[3] + ToShore[7];
            if((j < ToShore[1]) && (j < ToShore[5]))
               {
               j = start + ToShore[7] - (ToShore[7] * (FlowFlags.NumY));
               for(i = 1; i < ToShore[7] + ToShore[3]; i++)
                  {
                  j = j - 1 + FlowFlags.NumY;
                  if((FlowFlags.PointFlow[j] > 15) && (FlowFlags.PointFlow[j] < MONOBUMP))
                     FlowFlags.PointFlow[j] = 39;
                  }
               }
            break;
         } /*** end switch **/

      }
   }


   return(maxdir + 2);
}




void ModifiedFlowDirection(int DEMflow, int FlowConstraint, int *SameFlow, int *OppositeFlow)
{
int bd1, bd2;
int tf1, tf2;

   switch(FlowConstraint)
      {
      case 36:
         bd1 = 3;
         bd2 = 7;
         break;
      case 37:
         bd1 = 4;
         bd2 = 8;
         break;
      case 38:
         bd1 = 5;
         bd2 = 1;
         break;
      case 39:
         bd1 = 6;
         bd2 = 2;
         break;
      default:
         printf("bad news in flow signal - received %d\n",FlowConstraint);
         break;
      }

   if(DEMflow > bd1)
      tf1 = DEMflow - bd1;
   else
      tf1 = bd1 - DEMflow;

   if(DEMflow > bd2)
      tf2 = DEMflow - bd2;
   else
      tf2 = bd2 - DEMflow;

   if(tf1 > 4)
      tf1 = 8 - tf1;
   if(tf2 > 4)
      tf2 = 8 - tf2;

   if(tf1 > tf2)
      *OppositeFlow += 1;
   else if(tf2 > tf1)
      *SameFlow += 1;
   else
      {
      *SameFlow += 1;
      *OppositeFlow += 1;
      }

   return;
}


void DeconflictActualFlows()
{
int ttl,i,ii,j,k,kk, maxcount, maxindex;
int rowindex, colindex;
int  numpoints, quelen, avgdirection;
double unuseddbl, XG, YG, ZG;
/***double avgx, avgy; ***/
/**int Xvals[500];
 * int Yvals[500];**/
int Indices[500];
int Que[500];
int Dir[10];
char tc;


   ttl = FlowFlags.NumX * FlowFlags.NumY;
/***
 * when i is the index into FlowFlags.PointFlow[i], then PointFlow[i-1] is point to south,
 * PointFlow[i+i] is point to north, PointFlow[i-FlowFlags.NumY] is point to west, and 
 * PointFlow.FlowFlags[i+FlowFlags.NumY] is point to the East
 * ***/
   for(i=0; i<ttl; i++)
      {
      if(FlowFlags.PointFlow[i] > MONOBUMP)
         {
         numpoints = 0;
         Indices[numpoints] = i;
         numpoints += 1;
         avgdirection = FlowFlags.PointFlow[i];
         quelen = 1;
         Que[0] = i;
         FlowFlags.PointFlow[i] -= 10;
         for(j=0; j< 10; j++)
            Dir[j] = 0;
         while(quelen > 0)
            {
            quelen -= 1;
            j = Que[quelen];
            k = j - 1;
            if(k >= 0)
               {
               if(FlowFlags.PointFlow[k] > MONOBUMP)
                  {
                  Indices[numpoints] = k;
                  numpoints += 1;
                  kk = FlowFlags.PointFlow[k] - MONOBUMP;
                  Dir[kk] += 1;
                  Que[quelen] = k;
                  FlowFlags.PointFlow[k] -= 10;
                  ++quelen;
                  }
               }
            k = j + 1;
            if(k < ttl)
               {
               if(FlowFlags.PointFlow[k] > MONOBUMP)
                  {
                  Indices[numpoints] = k;
                  numpoints += 1;
                  kk = FlowFlags.PointFlow[k] - MONOBUMP;
                  Dir[kk] += 1;
                  FlowFlags.PointFlow[k] -= 10;
                  Que[quelen] = k;
                  ++quelen;
                  }
               }
            k = j - FlowFlags.NumY;
            if(k >= 0)
               {
               if(FlowFlags.PointFlow[k] > MONOBUMP)
                  {
                  Indices[numpoints] = k;
                  numpoints += 1;
                  kk = FlowFlags.PointFlow[k] - MONOBUMP;
                  Dir[kk] += 1;
                  FlowFlags.PointFlow[k] -= 10;
                  Que[quelen] = k;
                  ++quelen;
                  }
               }
            k = j - FlowFlags.NumY - 1;
            if(k >= 0)
               {
               if(FlowFlags.PointFlow[k] > MONOBUMP)
                  {
                  Indices[numpoints] = k;
                  numpoints += 1;
                  kk = FlowFlags.PointFlow[k] - MONOBUMP;
                  Dir[kk] += 1;
                  FlowFlags.PointFlow[k] -= 10;
                  Que[quelen] = k;
                  ++quelen;
                  }
               }
            k = j - FlowFlags.NumY + 1;
            if(k >= 0)
               {
               if(FlowFlags.PointFlow[k] > MONOBUMP)
                  {
                  Indices[numpoints] = k;
                  numpoints += 1;
                  kk = FlowFlags.PointFlow[k] - MONOBUMP;
                  Dir[kk] += 1;
                  FlowFlags.PointFlow[k] -= 10;
                  Que[quelen] = k;
                  ++quelen;
                  }
               }
            k = j + FlowFlags.NumY;
            if(k < ttl)
               {
               if(FlowFlags.PointFlow[k] > MONOBUMP)
                  {
                  Indices[numpoints] = k;
                  numpoints += 1;
                  kk = FlowFlags.PointFlow[k] - MONOBUMP;
                  Dir[kk] += 1;
                  FlowFlags.PointFlow[k] -= 10;
                  Que[quelen] = k;
                  ++quelen;
                  }
               }
            k = j + FlowFlags.NumY + 1;
            if(k < ttl)
               {
               if(FlowFlags.PointFlow[k] > MONOBUMP)
                  {
                  Indices[numpoints] = k;
                  numpoints += 1;
                  kk = FlowFlags.PointFlow[k] - MONOBUMP;
                  Dir[kk] += 1;
                  FlowFlags.PointFlow[k] -= 10;
                  Que[quelen] = k;
                  ++quelen;
                  }
               }
            k = j + FlowFlags.NumY - 1;
            if(k < ttl)
               {
               if(FlowFlags.PointFlow[k] > MONOBUMP)
                  {
                  Indices[numpoints] = k;
                  numpoints += 1;
                  kk = FlowFlags.PointFlow[k] - MONOBUMP;
                  Dir[kk] += 1;
                  FlowFlags.PointFlow[k] -= 10;
                  Que[quelen] = k;
                  ++quelen;
                  }
               }
            if(numpoints > 490)
               break;
            }  /** end while(quelen > 0)   **/
         maxcount = Dir[0];
         maxindex = 0;
         unuseddbl = 0.0;
         for(kk=1; kk< 9; kk++)
            {
            unuseddbl += (double) Dir[kk];
            if(Dir[kk] > maxcount)
               {
               maxcount = Dir[kk];
               maxindex = kk;
               }
            }
         unuseddbl = unuseddbl * 0.75;
         if(maxcount > unuseddbl)
            {
            tc = (char) (MONOBUMP - 10 + maxindex);
            for(kk = 0; kk< numpoints; kk++)
               {
               if(tc > FlowFlags.PointFlow[Indices[kk]])
                  ii = (int) (tc - FlowFlags.PointFlow[Indices[kk]]);
               else
                  ii = (int) (FlowFlags.PointFlow[Indices[kk]] - tc);
               if(ii != 4)
                  FlowFlags.PointFlow[Indices[kk]] = tc;
               }
            }
         else if(((Dir[1] > 0) && (Dir[5] > 0)) || ((Dir[2] > 0) && (Dir[6] > 0)) ||
                   ((Dir[3] > 0) && (Dir[7] > 0)) || ((Dir[4] > 0) && (Dir[8] > 0)))
            {
            for(kk = 0; kk < numpoints; kk++)
               {
               ii = Indices[kk];
               rowindex = (int) (((double) ii) / ((double) FlowFlags.NumY));
               colindex = ii - (int) (((double) rowindex) * FlowFlags.NumY);
               XG = ((double) rowindex) * FlowFlags.Xspacing;
               YG = ((double) colindex) * FlowFlags.Yspacing;
               XG += GridHeader[FlowFlags.GridHeadIndex].BaseX;
               YG += GridHeader[FlowFlags.GridHeadIndex].BaseY;
               ZG = ActiveChecks[FlowFlags.Cindex].sensitivity;
               FwriteObject(MASKMONO,Make_Correct(MASKMONO,FlowFlags.Cindex),FlowFlags.Lindex,
                GridHeader[FlowFlags.GridHeadIndex].Sindex,G_GRIDPT,
                GridHeader[FlowFlags.GridHeadIndex].idn,
                GridHeader[FlowFlags.GridHeadIndex].idn, -1.0, -1.0,
                  &XG,&YG,&ZG,1,1);

               }
            }

         } /*** end if(FlowFlags.PointFlow[i] > MONOBUMP)  ***/
      } /*** end for i < ttl **/

   tc = MONOBUMP - 10;
   for(i=0; i<ttl; i++)
      {
      if(FlowFlags.PointFlow[i] >= tc)
         {
         FlowFlags.PointFlow[i] += 10;
         }
      }

}  /*** end DeconflictActualFlows()  ***/



/************
PointFlow = 0 --> not in the water
PointFlow == 1 ==> point in water at unknown posn, flow by function ModifiedFlowDirection is North
PointFlow == 2 ==> point in water at unknown posn, flow by function ModifiedFlowDirection is NorthEast
PointFlow == 3 ==> point in water at unknown posn, flow by function ModifiedFlowDirection is East
PointFlow == 4 ==> point in water at unknown posn, flow by function ModifiedFlowDirection is SouthEast
PointFlow == 5 ==> point in water at unknown posn, flow by function ModifiedFlowDirection is South
PointFlow == 6 ==> point in water at unknown posn, flow by function ModifiedFlowDirection is SouthWest
PointFlow == 7 ==> point in water at unknown posn, flow by function ModifiedFlowDirection is West
PointFlow == 8 ==> point in water at unknown posn, flow by function ModifiedFlowDirection is NorthWest
PointFlow == 17 ==> point in water, but flow is still unknown
PointFlow == 30 ==> point is water adjacent to shore and geometry is ok
PointFlow == 35 ==> point in water and is a flow anchor point
PointFlow == 36 ==> point in water and flow is along the West to East direction
PointFlow == 37 ==> point in water and flow is along the NW to SE diagonal
PointFlow == 38 ==> point in water and flow is along the North to South direction
PointFlow == 39 ==> point in water and flow is along the SW to NE diagonal
PointFlow == 51 ==> point in water at elev change posn, flow by elev change is North
PointFlow == 52 ==> point in water at elev change posn, flow by elev change is NorthEast
PointFlow == 53 ==> point in water at elev change posn, flow by elev change is East
PointFlow == 54 ==> point in water at elev change posn, flow by elev change is SouthEast
PointFlow == 55 ==> point in water at elev change posn, flow by elev change is South
PointFlow == 56 ==> point in water at elev change posn, flow by elev change is SouthWest
PointFlow == 57 ==> point in water at elev change posn, flow by elev change is West
PointFlow == 58 ==> point in water at elev change posn, flow by elev change is NorthWest
********/
void PropagateFlowDirection(void)
{
int row, col, attempts, rowindex,colindex, checkinstance, MonoSensitivity;
int i, j,ttl, TtlLimit, madechange, k,kk,diff, flow1, flow2;
double XG, YG, ZG, unuseddbl;

   ttl = FlowFlags.NumX * FlowFlags.NumY;
   attempts = 0;

   row = col = 0;
   for(i=0; i<ttl; i++)
      {
      if(FlowFlags.PointFlow[i] == 30)
          PickFlowAnchorPoints(i, row, col);
      ++row;
      if(row >= FlowFlags.NumX)
         {
         ++col;
         row = 0;
         }
      }

   row = col = 0;
   for(i=0; i<ttl; i++)
      {
      if(FlowFlags.PointFlow[i] == 35)
         FlowByShoreline(i, row, col);
      ++row;
      if(row >= FlowFlags.NumX)
         {
         ++col;
         row = 0;
         }
      }

/** can use the below since there is only one instance of MASKMONO allowed at any one time (no new instaces allowed) **/
   MonoSensitivity = 0;
   for(checkinstance = 0; checkinstance < TtlActiveChecks; checkinstance++)
      {
      if(ActiveChecks[checkinstance].number == MASKMONO)
         {
         if(ActiveChecks[checkinstance].sensitivity3 != 0)
            MonoSensitivity = 1;
         break;
         }
      }

   ttl = FlowFlags.NumX * FlowFlags.NumY;
   attempts = 0;
   do
      {
      row = col = 0;
      madechange = 0;
      for(i=0; i<ttl; i++)
         {
         k = 0;
         if(FlowFlags.PointFlow[i] == 17) /** flow unknown here ***/
            {
            if(col > 0)
               {
               j = i - FlowFlags.NumY;
               if((FlowFlags.PointFlow[j] > 0) && (FlowFlags.PointFlow[j] < 10)) /** pull an actual flow value ***/
                  {
                  FlowFlags.PointFlow[i] = FlowFlags.PointFlow[j];
                  ++madechange;
                  ++k;
                  }
               else if((FlowFlags.PointFlow[j] > 0) && (FlowFlags.PointFlow[j] > MONOBUMP)) /** pull an actual flow value ***/
                  {
                  FlowFlags.PointFlow[i] = FlowFlags.PointFlow[j] - MONOBUMP;
                  ++madechange;
                  ++k;
                  }
               }
            if((k == 0)  && (row > 0))
               {
               j = i - 1;
               if((FlowFlags.PointFlow[j] > 0) && (FlowFlags.PointFlow[j] < 10)) /** pull an actual flow value ***/
                  {
                  FlowFlags.PointFlow[i] = FlowFlags.PointFlow[j];
                  ++madechange;
                  ++k;
                  }
               else if((FlowFlags.PointFlow[j] > 0) && (FlowFlags.PointFlow[j] > MONOBUMP)) /** pull an actual flow value ***/
                  {
                  FlowFlags.PointFlow[i] = FlowFlags.PointFlow[j] - MONOBUMP;
                  ++madechange;
                  ++k;
                  }
               }
            if((k == 0)  && (row > 0) && (col > 0))
               {
               j = i - FlowFlags.NumY - 1;
               if((FlowFlags.PointFlow[j] > 0) && (FlowFlags.PointFlow[j] < 10)) /** pull an actual flow value ***/
                  {
                  FlowFlags.PointFlow[i] = FlowFlags.PointFlow[j];
                  ++madechange;
                  ++k;
                  }
               else if((FlowFlags.PointFlow[j] > 0) && (FlowFlags.PointFlow[j] > MONOBUMP)) /** pull an actual flow value ***/
                  {
                  FlowFlags.PointFlow[i] = FlowFlags.PointFlow[j] - MONOBUMP;
                  ++madechange;
                  ++k;
                  }
               }

            if((k == 0)  && (col > 0) && (row < (FlowFlags.NumY - 1)))
               {
               j = i - FlowFlags.NumY + 1;
               if((FlowFlags.PointFlow[j] > 0) && (FlowFlags.PointFlow[j] < 10)) /** pull an actual flow value ***/
                  {
                  FlowFlags.PointFlow[i] = FlowFlags.PointFlow[j];
                  ++madechange;
                  ++k;
                  }
               else if((FlowFlags.PointFlow[j] > 0) && (FlowFlags.PointFlow[j] > MONOBUMP)) /** pull an actual flow value ***/
                  {
                  FlowFlags.PointFlow[i] = FlowFlags.PointFlow[j] - MONOBUMP;
                  ++madechange;
                  ++k;
                  }
               }
            if((k == 0) && (row < (FlowFlags.NumY - 1)))
               {
               j = i + 1;
               if((FlowFlags.PointFlow[j] > 0) && (FlowFlags.PointFlow[j] < 10)) /** pull an actual flow value ***/
                  {
                  FlowFlags.PointFlow[i] = FlowFlags.PointFlow[j];
                  ++madechange;
                  ++k;
                  }
               else if((FlowFlags.PointFlow[j] > 0) && (FlowFlags.PointFlow[j] > MONOBUMP)) /** pull an actual flow value ***/
                  {
                  FlowFlags.PointFlow[i] = FlowFlags.PointFlow[j] - MONOBUMP;
                  ++madechange;
                  ++k;
                  }
               }


            }
         else if((FlowFlags.PointFlow[i] >= 36) && (FlowFlags.PointFlow[i] < MONOBUMP)) /** flow unknown, but constrained by shoreline here ***/
            {
            unuseddbl = 0;
            kk = 0;
            flow1 = flow2 = 0;
            if(col > 0)
               {
               j = i - FlowFlags.NumY;
               if((FlowFlags.PointFlow[j] > 0) && (FlowFlags.PointFlow[j] < 10)) /** pole an actual flow value ***/
                  {
                  unuseddbl += (double) FlowFlags.PointFlow[j];
                  ++k;
                  ModifiedFlowDirection(FlowFlags.PointFlow[j],FlowFlags.PointFlow[i],&flow1,&flow2);
                  }
               else if((FlowFlags.PointFlow[j] > 0) && (FlowFlags.PointFlow[j] > MONOBUMP)) /** pull an actual flow value ***/
                  {
                  unuseddbl += (double) (FlowFlags.PointFlow[j] - MONOBUMP);
                  ++k;
                  ModifiedFlowDirection(FlowFlags.PointFlow[j]-MONOBUMP,FlowFlags.PointFlow[i],&flow1,&flow2);
                  }
               }
            if(row > 0)
               {
               j = i - 1;
               if((FlowFlags.PointFlow[j] > 0) && (FlowFlags.PointFlow[j] < 10)) /** pole an actual flow value ***/
                  {
                  unuseddbl += (double) FlowFlags.PointFlow[j];
                  ++k;
                  ModifiedFlowDirection(FlowFlags.PointFlow[j],FlowFlags.PointFlow[i],&flow1,&flow2);
                  }
               else if((FlowFlags.PointFlow[j] > 0) && (FlowFlags.PointFlow[j] > MONOBUMP)) /** pull an actual flow value ***/
                  {
                  unuseddbl += (double) (FlowFlags.PointFlow[j] - MONOBUMP);
                  ++k;
                  ModifiedFlowDirection(FlowFlags.PointFlow[j]-MONOBUMP,FlowFlags.PointFlow[i],&flow1,&flow2);
                  }
               }
            if((row > 0) && (col > 0))
               {
               j = i - FlowFlags.NumY - 1;
               if((FlowFlags.PointFlow[j] > 0) && (FlowFlags.PointFlow[j] < 10)) /** pole an actual flow value ***/
                  {
                  unuseddbl += (double) FlowFlags.PointFlow[j];
                  ++k;
                  ModifiedFlowDirection(FlowFlags.PointFlow[j],FlowFlags.PointFlow[i],&flow1,&flow2);
                  }
               else if((FlowFlags.PointFlow[j] > 0) && (FlowFlags.PointFlow[j] > MONOBUMP)) /** pull an actual flow value ***/
                  {
                  unuseddbl += (double) (FlowFlags.PointFlow[j] - MONOBUMP);
                  ++k;
                  ModifiedFlowDirection(FlowFlags.PointFlow[j]-MONOBUMP,FlowFlags.PointFlow[i],&flow1,&flow2);
                  }
               }
            if((col > 0) && (row < (FlowFlags.NumY - 1)))
               {
               j = i - FlowFlags.NumY + 1;
               if((FlowFlags.PointFlow[j] > 0) && (FlowFlags.PointFlow[j] < 10)) /** pole an actual flow value ***/
                  {
                  unuseddbl += (double) FlowFlags.PointFlow[j];
                  ++k;
                  ModifiedFlowDirection(FlowFlags.PointFlow[j],FlowFlags.PointFlow[i],&flow1,&flow2);
                  }
               else if((FlowFlags.PointFlow[j] > 0) && (FlowFlags.PointFlow[j] > MONOBUMP)) /** pull an actual flow value ***/
                  {
                  unuseddbl += (double) (FlowFlags.PointFlow[j] - MONOBUMP);
                  ++k;
                  ModifiedFlowDirection(FlowFlags.PointFlow[j]-MONOBUMP,FlowFlags.PointFlow[i],&flow1,&flow2);
                  }
               }
            if((k == 0) && (row < (FlowFlags.NumY - 1)))
               {
               j = i + 1;
               if((FlowFlags.PointFlow[j] > 0) && (FlowFlags.PointFlow[j] < 10)) /** pole an actual flow value ***/
                  {
                  unuseddbl += (double) FlowFlags.PointFlow[j];
                  ++k;
                  ModifiedFlowDirection(FlowFlags.PointFlow[j],FlowFlags.PointFlow[i],&flow1,&flow2);
                  }
               else if((FlowFlags.PointFlow[j] > 0) && (FlowFlags.PointFlow[j] > MONOBUMP)) /** pull an actual flow value ***/
                  {
                  unuseddbl += (double) (FlowFlags.PointFlow[j] - MONOBUMP);
                  ++k;
                  ModifiedFlowDirection(FlowFlags.PointFlow[j]-MONOBUMP,FlowFlags.PointFlow[i],&flow1,&flow2);
                  }
               }
            if((flow1 > 1) && (flow1 > flow2))
               {
               FlowFlags.PointFlow[i] = FlowFlags.PointFlow[i] - 35;
               FlowFlags.PointFlow[i] = FlowFlags.PointFlow[i] + 2;
               ++madechange;
               ++k;
               }
            else if((flow2 > 1) && (flow2 > flow1))
               {
               FlowFlags.PointFlow[i] = FlowFlags.PointFlow[i] - 35;
               FlowFlags.PointFlow[i] = FlowFlags.PointFlow[i] + 6;
               if(FlowFlags.PointFlow[i] > 8)
                  FlowFlags.PointFlow[i] =  FlowFlags.PointFlow[i] - 8;
               ++madechange;
               ++k;
               }
             else if((flow1 > 1) && (flow1 == flow2) && (k > 0))
               {
               FlowFlags.PointFlow[i] = (int) (unuseddbl / ((double) k));
               }
            }


         ++row;
         if(row >= FlowFlags.NumY)
            {
            ++col;
            row = 0;
            }
         }


      row = FlowFlags.NumY;
      col = FlowFlags.NumX;
      for(i=ttl - 1; i>= 0; i--)
         {

         k = 0;
         if(FlowFlags.PointFlow[i] == 17) /** flow unknown here ***/
            {
            if(row < (FlowFlags.NumY - 1))
               {
               j = i + 1;
               if((FlowFlags.PointFlow[j] > 0) && (FlowFlags.PointFlow[j] < 10)) /** pull an actual flow value ***/
                  {
                  FlowFlags.PointFlow[i] = FlowFlags.PointFlow[j];
                  ++madechange;
                  ++k;
                  }
               else if((FlowFlags.PointFlow[j] > 0) && (FlowFlags.PointFlow[j] > MONOBUMP)) /** pull an actual flow value ***/
                  {
                  FlowFlags.PointFlow[i] = FlowFlags.PointFlow[j] - MONOBUMP;
                  ++madechange;
                  ++k;
                  }
               }

            if((k == 0) && (col < (FlowFlags.NumX - 1)))
               {
               j = i + FlowFlags.NumY;
               if((FlowFlags.PointFlow[j] > 0) && (FlowFlags.PointFlow[j] < 10)) /** pull an actual flow value ***/
                  {
                  FlowFlags.PointFlow[i] = FlowFlags.PointFlow[j];
                  ++madechange;
                  ++k;
                  }
               else if((FlowFlags.PointFlow[j] > 0) && (FlowFlags.PointFlow[j] > MONOBUMP)) /** pull an actual flow value ***/
                  {
                  FlowFlags.PointFlow[i] = FlowFlags.PointFlow[j] - MONOBUMP;
                  ++madechange;
                  ++k;
                  }
               }
            if((k == 0) && (row < (FlowFlags.NumY - 1)) && (col < (FlowFlags.NumX - 1)))
               {
               j = i + FlowFlags.NumY + 1;
               if((FlowFlags.PointFlow[j] > 0) && (FlowFlags.PointFlow[j] < 10)) /** pull an actual flow value ***/
                  {
                  FlowFlags.PointFlow[i] = FlowFlags.PointFlow[j];
                  ++madechange;
                  ++k;
                  }
               else if((FlowFlags.PointFlow[j] > 0) && (FlowFlags.PointFlow[j] > MONOBUMP)) /** pull an actual flow value ***/
                  {
                  FlowFlags.PointFlow[i] = FlowFlags.PointFlow[j] - MONOBUMP;
                  ++madechange;
                  ++k;
                  }
               }
            if((k == 0) && (row > 0) && (col < (FlowFlags.NumX - 1)))
               {
               j = i + FlowFlags.NumY - 1;
               if((FlowFlags.PointFlow[j] > 0) && (FlowFlags.PointFlow[j] < 10)) /** pull an actual flow value ***/
                  {
                  FlowFlags.PointFlow[i] = FlowFlags.PointFlow[j];
                  ++madechange;
                  ++k;
                  }
               else if((FlowFlags.PointFlow[j] > 0) && (FlowFlags.PointFlow[j] > MONOBUMP)) /** pull an actual flow value ***/
                  {
                  FlowFlags.PointFlow[i] = FlowFlags.PointFlow[j] - MONOBUMP;
                  ++madechange;
                  ++k;
                  }
               }
            if((k == 0) && (row > 0))
               {
               j = i - 1;
               if((FlowFlags.PointFlow[j] > 0) && (FlowFlags.PointFlow[j] < 10)) /** pull an actual flow value ***/
                  {
                  FlowFlags.PointFlow[i] = FlowFlags.PointFlow[j];
                  ++madechange;
                  ++k;
                  }
               else if((FlowFlags.PointFlow[j] > 0) && (FlowFlags.PointFlow[j] > MONOBUMP)) /** pull an actual flow value ***/
                  {
                  FlowFlags.PointFlow[i] = FlowFlags.PointFlow[j] - MONOBUMP;
                  ++madechange;
                  ++k;
                  }
               }
            }
         else if((FlowFlags.PointFlow[i] >= 36) && (FlowFlags.PointFlow[i] < MONOBUMP)) /** flow unknown, but constrained by shoreline here ***/
            {
            flow1 = flow2 = 0;
            unuseddbl = 0;
            kk = 0;
            if(row < (FlowFlags.NumY - 1))
               {
               j = i + 1;
               if((FlowFlags.PointFlow[j] > 0) && (FlowFlags.PointFlow[j] < 10)) /** pull an actual flow value ***/
                  {
                  unuseddbl += (double) FlowFlags.PointFlow[j];
                  ++k;
                  ModifiedFlowDirection(FlowFlags.PointFlow[j],FlowFlags.PointFlow[i],&flow1,&flow2);
                  }
               else if((FlowFlags.PointFlow[j] > 0) && (FlowFlags.PointFlow[j] > MONOBUMP)) /** pull an actual flow value ***/
                  {
                  unuseddbl += (double) (FlowFlags.PointFlow[j] - MONOBUMP);
                  ++k;
                  ModifiedFlowDirection(FlowFlags.PointFlow[j]-MONOBUMP,FlowFlags.PointFlow[i],&flow1,&flow2);
                  }
               }

            if(col < (FlowFlags.NumX - 1))
               {
               j = i + FlowFlags.NumY;
               if((FlowFlags.PointFlow[j] > 0) && (FlowFlags.PointFlow[j] < 10)) /** pull an actual flow value ***/
                  {
                  unuseddbl += (double) FlowFlags.PointFlow[j];
                  ++k;
                  ModifiedFlowDirection(FlowFlags.PointFlow[j],FlowFlags.PointFlow[i],&flow1,&flow2);
                  }
               else if((FlowFlags.PointFlow[j] > 0) && (FlowFlags.PointFlow[j] > MONOBUMP)) /** pull an actual flow value ***/
                  {
                  unuseddbl += (double) (FlowFlags.PointFlow[j] - MONOBUMP);
                  ++k;
                  ModifiedFlowDirection(FlowFlags.PointFlow[j]-MONOBUMP,FlowFlags.PointFlow[i],&flow1,&flow2);
                  }
               }
            if((row < (FlowFlags.NumY - 1)) && (col < (FlowFlags.NumX - 1)))
               {
               j = i + FlowFlags.NumY + 1;
               if((FlowFlags.PointFlow[j] > 0) && (FlowFlags.PointFlow[j] < 10)) /** pull an actual flow value ***/
                  {
                  unuseddbl += (double) FlowFlags.PointFlow[j];
                  ++k;
                  ModifiedFlowDirection(FlowFlags.PointFlow[j],FlowFlags.PointFlow[i],&flow1,&flow2);
                  }
               else if((FlowFlags.PointFlow[j] > 0) && (FlowFlags.PointFlow[j] > MONOBUMP)) /** pull an actual flow value ***/
                  {
                  unuseddbl += (double) (FlowFlags.PointFlow[j] - MONOBUMP);
                  ++k;
                  ModifiedFlowDirection(FlowFlags.PointFlow[j]-MONOBUMP,FlowFlags.PointFlow[i],&flow1,&flow2);
                  }
               }
            if((row > 0) && (col < (FlowFlags.NumX - 1)))
               {
               j = i + FlowFlags.NumY - 1;
               if((FlowFlags.PointFlow[j] > 0) && (FlowFlags.PointFlow[j] < 10)) /** pull an actual flow value ***/
                  {
                  unuseddbl += (double) FlowFlags.PointFlow[j];
                  ++k;
                  ModifiedFlowDirection(FlowFlags.PointFlow[j],FlowFlags.PointFlow[i],&flow1,&flow2);
                  }
               else if((FlowFlags.PointFlow[j] > 0) && (FlowFlags.PointFlow[j] > MONOBUMP)) /** pull an actual flow value ***/
                  {
                  unuseddbl += (double) (FlowFlags.PointFlow[j] - MONOBUMP);
                  ++k;
                  ModifiedFlowDirection(FlowFlags.PointFlow[j]-MONOBUMP,FlowFlags.PointFlow[i],&flow1,&flow2);
                  }
               }
            if(row > 0)
               {
               j = i - 1;
               if((FlowFlags.PointFlow[j] > 0) && (FlowFlags.PointFlow[j] < 10)) /** pull an actual flow value ***/
                  {
                  unuseddbl += (double) FlowFlags.PointFlow[j];
                  ++k;
                  ModifiedFlowDirection(FlowFlags.PointFlow[j],FlowFlags.PointFlow[i],&flow1,&flow2);
                  }
               else if((FlowFlags.PointFlow[j] > 0) && (FlowFlags.PointFlow[j] > MONOBUMP)) /** pull an actual flow value ***/
                  {
                  unuseddbl += (double) (FlowFlags.PointFlow[j] - MONOBUMP);
                  ++k;
                  ModifiedFlowDirection(FlowFlags.PointFlow[j]-MONOBUMP,FlowFlags.PointFlow[i],&flow1,&flow2);
                  }
               }

            if((flow1 > 1) && (flow1 > flow2))
               {
               FlowFlags.PointFlow[i] = FlowFlags.PointFlow[i] - 35;
               FlowFlags.PointFlow[i] = FlowFlags.PointFlow[i] + 2;
               ++madechange;
               ++k;
               }
            else if((flow2 > 1) && (flow2 > flow1))
               {
               FlowFlags.PointFlow[i] = FlowFlags.PointFlow[i] - 35;
               FlowFlags.PointFlow[i] = FlowFlags.PointFlow[i] + 6;
               if(FlowFlags.PointFlow[i] > 8)
                  FlowFlags.PointFlow[i] =  FlowFlags.PointFlow[i] - 8;
               ++madechange;
               ++k;
               }

            }

         --row;
         if(row < 0)
            {
            --col;
            row = FlowFlags.NumY;
            }
         }



      ++attempts;
      } while((madechange > 0) && (attempts < 100));

      TtlLimit = ttl - FlowFlags.NumY - 1;
      col = row = 0;
      for(i=0; i<TtlLimit; i++)
         {
         k = 0;
         if(FlowFlags.PointFlow[i] > MONOBUMP)
            k = 1;
         else if((row < (FlowFlags.NumY - 1)) && (FlowFlags.PointFlow[i + 1] > MONOBUMP))
            k = 1;
         else if((row < (FlowFlags.NumY - 1)) && (col < (FlowFlags.NumX - 1)) &&
                      (FlowFlags.PointFlow[i + 1 + FlowFlags.NumY] > MONOBUMP))
            k = 1;
         else if((col < (FlowFlags.NumX - 1)) && (FlowFlags.PointFlow[i + FlowFlags.NumY] > MONOBUMP))
            k = 1;

         if((MonoSensitivity > 0) && (FlowFlags.PointFlow[i] > 0))
            k = 1;
         
         if(k > 0)
            {
            k = (int) FlowFlags.PointFlow[i];
            if(k > MONOBUMP)
               k -= MONOBUMP;
            if((FlowFlags.PointFlow[i] > 0) && ((FlowFlags.PointFlow[i] < 10) || (FlowFlags.PointFlow[i] > MONOBUMP)))
               {
               for(attempts = 0; attempts < 3; attempts++)
                  {
                  j = -1;
                  switch(attempts)
                     {
                     case 0:  // look up 
                        if(row < (FlowFlags.NumY - 1))
                           {
                           j = i + 1;
                           }
                        break;
                     case 1:  //look up and to right
                        if((row < (FlowFlags.NumY - 1)) && (col < (FlowFlags.NumX - 1)))
                           {
                           j = i + 1 + FlowFlags.NumY;
                           }
                        break;
                     case 2:  // look right
                        if(col < (FlowFlags.NumX - 1))
                           {
                           j = i + FlowFlags.NumY;
                           }
                        break;
                     }
                  if((j > 0) && (FlowFlags.PointFlow[j] > 0))
                     {
                     kk = (int) (FlowFlags.PointFlow[j]);
                     if(kk > MONOBUMP)
                        kk -= MONOBUMP;
                     if(kk > k)
                        {
                        diff = kk - k;
                        }
                     else
                        {
                        diff = k - kk;
                        }
                     if(diff == 4)
                        {

                        unuseddbl = ((double) i) / ((double) FlowFlags.NumY);
                        rowindex = (int) unuseddbl;
                        colindex = i - (int) (((double) rowindex) * FlowFlags.NumY);
                        XG = ((double) rowindex) * FlowFlags.Xspacing;
                        XG += GridHeader[FlowFlags.GridHeadIndex].BaseX;
                        YG = ((double) colindex) * FlowFlags.Yspacing;
                        YG += GridHeader[FlowFlags.GridHeadIndex].BaseY;
                        ZG = ActiveChecks[FlowFlags.Cindex].sensitivity;
                        unuseddbl = (double) FlowFlags.PointFlow[i];
                        FwriteObject(MASKMONO,Make_Correct(MASKMONO,FlowFlags.Cindex),FlowFlags.Lindex,
                                          GridHeader[FlowFlags.GridHeadIndex].Sindex,G_GRIDPT,
                                           GridHeader[FlowFlags.GridHeadIndex].idn,
                                        GridHeader[FlowFlags.GridHeadIndex].idn, -1.0, -1.0,
                                        &XG,&YG,&ZG,1,1);
                        }
                     }
                  }
               }
            ++row;
            if(row >= FlowFlags.NumY)
               {
               ++col;
               row = 0;
               }
            }
         }

}




int CheckMaskAndGridsForMonotonicity(int index, /** is = compositeindex **/
                                     int Cindex,  /*** is the checkinstance ***/
                                      double minx, double miny, double maxx, double maxy) /** LM bounds in internal coords **/
{
int k, j, jj, js, jmid, kk, LM_index1, LM_index2, checkacross;
/**int Lindex1, Lindex2; **/
int composite_index, shoreline;
int SI1, SI2, DidTheCheck;
int t1Index, PlusIndex, MinusIndex, TotalElevs;
double XG, YG, ZG, unuseddbl;
double Znew; //, pseudoLID1, pseudoLID2;
double MaxZdiffPlus, MaxZdiffMinus;
int NumQualify, NumHigher, NumLower;
int grows, gcols;
int part1, part2, part3, checkit;
/***int Grid1IDN, Grid2IDN;***/
unsigned int LI1, LI2;
double AllFlow[10];
double ShoreFlow[10];

   DidTheCheck = 0;

   if(NGT[index].NumGrids < 2) /*** less than 2 grids to compare in this Cindex=Region ***/
      return(DidTheCheck);

   for(LM_index1=0; LM_index1<NGT[index].NumGrids; LM_index1++)
      {
      if((NGT[index].GridIndex != NULL) && (MG[LM_index1].numX > 0) && (MG[LM_index1].numY > 0))
         {
         k = NGT[index].GridIndex[LM_index1];

         LI1 = GridHeader[k].Lindex;
         SI1 = CrsWlk[LI1].LtoSmapping;
         if((CombinedCheckApplies(GridHeader[k].idn,Cindex,MASKMONO,LI1,SI1,
                     SCCtable[SI1].C, SCCtable[SI1].S, SCCtable[SI1].D,
                     &part1,&part2,&part3) >  0) && (part1 > 0)) /*** this should be the mask ***/
            {
            for(LM_index2=0; LM_index2<NGT[index].NumGrids; LM_index2++)
               {
               if((LM_index2 != LM_index1) && (MG[LM_index2].numX == MG[LM_index1].numX) &&
                      (MG[LM_index2].numY == MG[LM_index1].numY) &&
                         (NearlyEqual(GridHeader[k].BaseX, GridHeader[NGT[index].GridIndex[LM_index2]].BaseX) > 0) &&
                            (NearlyEqual(GridHeader[k].BaseY, GridHeader[NGT[index].GridIndex[LM_index2]].BaseY) > 0))
                  {
                  j = NGT[index].GridIndex[LM_index2];

                  LI2 = GridHeader[j].Lindex;
                  SI2 = CrsWlk[LI2].LtoSmapping;
                  if((CombinedCheckApplies(GridHeader[j].idn,Cindex,MASKMONO,LI2,SI2,
                       SCCtable[SI2].C, SCCtable[SI2].S, SCCtable[SI2].D,
                     &part1,&part2,&part3) >  0) && (part2 > 0)) /*** this shoule be the DEM ***/
                     {
                     DidTheCheck = 1;
                     TotalElevs = MG[LM_index2].numX * MG[LM_index2].numY;


                     for(grows = 1; grows < MG[LM_index1].numX - 1; grows++)
                        {
                        XG = (MG[LM_index1].SouthWestX - GridHeader[j].BaseX)  + ((double) grows * MG[LM_index1].Xspace);
                        if((XG >= minx) && (XG <= maxx))
                           {
                           for(gcols = 1; gcols < MG[LM_index1].numY - 1; gcols++)
                              {
                              YG = (MG[LM_index1].SouthWestY - GridHeader[j].BaseY) + ((double) gcols * MG[LM_index1].Yspace);

                              kk = (grows * MG[LM_index1].numY) + gcols;
                              PlusIndex = kk + MG[LM_index1].numY;
                              MinusIndex = kk - MG[LM_index1].numY;

                              ZG = MG[LM_index1].Elevs[kk];

                              checkit = 1;
                              if((ZG < ActiveChecks[Cindex].sensitivity - ActiveChecks[Cindex].sensitivity2) ||
                                    (ZG > ActiveChecks[Cindex].sensitivity + ActiveChecks[Cindex].sensitivity2))
                                 checkit = 0;
                              if((checkit > 0) && (YG >= miny) && (YG <= maxy))
                                 {
                                 MaxZdiffPlus = MaxZdiffMinus = 0.0;
                                 Znew = MG[LM_index2].Elevs[kk];

                                 for(jj = 0; jj < 10; jj++)
                                    {
                                    AllFlow[jj] = -10.0;
                                    ShoreFlow[jj] = 0.0;
                                    }
                                 shoreline = 0;
                                 NumQualify = NumHigher = NumLower = 0;
                                 for(checkacross = 0; checkacross < 8; ++checkacross)
                                    {
                                    switch(checkacross)
                                       {
                                       case 0:
                                          t1Index = kk + 1; //PlusIndex;
                                          break;
                                       case 1:
                                          t1Index = PlusIndex + 1;
                                          break;
                                       case 2:
                                          t1Index = PlusIndex; //kk - 1;
                                          break;
                                       case 3:
                                          t1Index = PlusIndex - 1;
                                          break;
                                       case 4:
                                          t1Index = kk - 1; //MinusIndex;
                                          break;
                                       case 5:
                                          t1Index = MinusIndex - 1;
                                          break;
                                       case 6:
                                          t1Index = MinusIndex; //kk - 1;
                                          break;
                                       case 7:
                                          t1Index = MinusIndex + 1;
                                          break;
                                       }
                                    if((t1Index >= 0) && (t1Index <= TotalElevs))
                                       {
                                       ZG = MG[LM_index1].Elevs[t1Index];
                                       if((ZG >= ActiveChecks[Cindex].sensitivity - ActiveChecks[Cindex].sensitivity2) &&
                                          (ZG <= ActiveChecks[Cindex].sensitivity + ActiveChecks[Cindex].sensitivity2))
                                          {
                                          ++NumQualify;
                                          if(Znew < MG[LM_index2].Elevs[t1Index])
                                             ++NumLower;
                                          else if(Znew > MG[LM_index2].Elevs[t1Index])
                                             ++NumHigher;
                                          AllFlow[checkacross] = 1;
                                          unuseddbl = Znew - MG[LM_index2].Elevs[t1Index];
                                          if(unuseddbl > 0)
                                             ShoreFlow[checkacross] = unuseddbl;
                                          if(unuseddbl > 0)
                                             {
                                             if(unuseddbl > MaxZdiffPlus)
                                                {
                                                MaxZdiffPlus = unuseddbl;
                                                }
                                             }
                                          }
                                       }
                                    }

                                 if(NumQualify > 3)
                                    {
                                    if((NumQualify == NumLower) || (NumQualify == NumHigher))
                                       {
                                       FwriteObject(MASKMONO,Make_Correct(MASKMONO,Cindex),LI2, SI2,G_GRIDPT,
                                           GridHeader[j].idn, GridHeader[j].idn, -1.0, -1.0,
                                        &XG,&YG,&Znew,1,1);
                                       }
                                    }


                                 if((AllFlow[5] < 0) && (AllFlow[4] < 0) && (AllFlow[3] < 0) &&
                                    (AllFlow[0] > 0) && (AllFlow[1] > 0) && (AllFlow[2] > 0) && (AllFlow[6] > 0) && (AllFlow[7] > 0))
                                    shoreline = 1;
                                 else if((AllFlow[6] < 0) && (AllFlow[5] < 0) && (AllFlow[4] < 0) &&
                                    (AllFlow[0] > 0) && (AllFlow[1] > 0) && (AllFlow[2] > 0) && (AllFlow[3] > 0) && (AllFlow[7] > 0))
                                    shoreline = 1;
                                 else if((AllFlow[7] < 0) && (AllFlow[6] < 0) && (AllFlow[5] < 0) &&
                                    (AllFlow[0] > 0) && (AllFlow[1] > 0) && (AllFlow[2] > 0) && (AllFlow[3] > 0) && (AllFlow[4] > 0))
                                    shoreline = 1;

                                 composite_index = (int) (((XG / FlowFlags.Xspacing) * ((double) FlowFlags.NumY) + (YG / FlowFlags.Yspacing)) + 0.01);
                                if(MaxZdiffPlus > 0)
                                   {
                                   jmid = 0;
                                   for(jj=0; jj<8; jj++)
                                      {
                                      if(ShoreFlow[jj] == MaxZdiffPlus)
                                         ++jmid;
                                      }
                                   for(jj=0; jj < 8; jj++)
                                      {
                                      if((jj == 0) && (ShoreFlow[jj] == MaxZdiffPlus))
                                         {
                                         if(ShoreFlow[7] != MaxZdiffPlus)
                                            js = 0;
                                         }
                                      else if((ShoreFlow[jj] == MaxZdiffPlus) && (ShoreFlow[jj-1] != MaxZdiffPlus))
                                         js = jj;
                                      }
                                   unuseddbl = ((double) (jmid)) / 2.0;
                                   jj = js;
                                   js = (int) (unuseddbl + 0.5);
                                   jmid = 0;
                                   while(jmid < js)
                                      {
                                      if(ShoreFlow[jj] == MaxZdiffPlus)
                                         ++jmid;
                                      if(jmid >= js)
                                         break;
                                      jj += 1;
                                      if(jj > 7)
                                         jj = 0;
                                      }
                                   FlowFlags.PointFlow[composite_index] = (char) (MONOBUMP + jj + 1);
                                   }
                                else
                                   {
                                   if(shoreline > 0) 
                                      FlowFlags.PointFlow[composite_index] = (char) 30;
                                   else
                                      FlowFlags.PointFlow[composite_index] = (char) 17;
                                   }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }

   return(DidTheCheck);
}



int CheckMaskAndGridsForEditedElev(int checktype, /** the define number for the inspection to apply **/
                                    int index, /** is = compositeindex **/
                                     int Cindex,  /*** is the checkinstance ***/
                                      double minx, double miny, double maxx, double maxy) /** LM bounds in internal coords **/
{
int k, j, j3, kk, LM_index1, LM_index2, LM_index3;
int Sindex2, Sindex3;
int Lindex2, Lindex3;
int SI1, SI2, SI3, DidTheCheck;
int WriteError;
double XG, YG, ZG;
double Znew, Zdiff, pseudoLID2, pseudoLID3;
int grows, gcols;
int part1, part2, part3;
int /**Grid1IDN,**/ Grid2IDN, Grid3IDN;
unsigned int LI1, LI2, LI3;

   DidTheCheck = 0;
   if(NGT[index].NumGrids < 3) /*** less than 3 grids to compare in this Cindex=Region ***/
      return(DidTheCheck);

   for(LM_index1=0; LM_index1<NGT[index].NumGrids; LM_index1++)
      {
      if((NGT[index].GridIndex != NULL) && (MG[LM_index1].numX > 0) && (MG[LM_index1].numY > 0))
         {
         k = NGT[index].GridIndex[LM_index1];

         LI1 = GridHeader[k].Lindex;
         SI1 = CrsWlk[LI1].LtoSmapping;
         if((CombinedCheckApplies(GridHeader[k].idn,Cindex,checktype,LI1,SI1,
                     SCCtable[SI1].C, SCCtable[SI1].S, SCCtable[SI1].D,
                     &part1,&part2,&part3) >  0) && (part1 > 0)) /*** this should be the edit mask ***/
            {
            for(LM_index2=0; LM_index2<NGT[index].NumGrids; LM_index2++)
               {
               if((LM_index2 != LM_index1) && (MG[LM_index2].numX == MG[LM_index1].numX) &&
                      (MG[LM_index2].numY == MG[LM_index1].numY) &&
                         (NearlyEqual(GridHeader[k].BaseX, GridHeader[NGT[index].GridIndex[LM_index2]].BaseX) > 0) &&
                            (NearlyEqual(GridHeader[k].BaseY, GridHeader[NGT[index].GridIndex[LM_index2]].BaseY) > 0))
                  {
                  j = NGT[index].GridIndex[LM_index2];

                  LI2 = GridHeader[j].Lindex;
                  SI2 = CrsWlk[LI2].LtoSmapping;
                  if((CombinedCheckApplies(GridHeader[j].idn,Cindex,checktype,LI2,SI2,
                       SCCtable[SI2].C, SCCtable[SI2].S, SCCtable[SI2].D,
                     &part1,&part2,&part3) >  0) && (part2 > 0)) /*** this should be the first DEM ***/
                     {
                     for(LM_index3=0; LM_index3<NGT[index].NumGrids; LM_index3++)
                        {
                        if((LM_index3 != LM_index2) && (MG[LM_index3].numX == MG[LM_index2].numX) &&
                               (MG[LM_index3].numY == MG[LM_index2].numY) &&
                                  (NearlyEqual(GridHeader[j].BaseX, GridHeader[NGT[index].GridIndex[LM_index3]].BaseX) > 0) &&
                                     (NearlyEqual(GridHeader[j].BaseY, GridHeader[NGT[index].GridIndex[LM_index3]].BaseY) > 0))
                           {
                           j3 = NGT[index].GridIndex[LM_index3];
         
                           LI3 = GridHeader[j3].Lindex;
                           SI3 = CrsWlk[LI3].LtoSmapping;
                           if((CombinedCheckApplies(GridHeader[j3].idn,Cindex,checktype,LI3,SI3,
                                SCCtable[SI3].C, SCCtable[SI3].S, SCCtable[SI3].D,
                              &part1,&part2,&part3) >  0) && (part3 > 0)) /*** this should be the second DEM ***/
                              {
                              DidTheCheck = 1;
                              Grid2IDN = GridHeader[j].idn;
                              Grid3IDN = GridHeader[j3].idn;
                              Lindex2 = GridHeader[j].Lindex;
                              Lindex3 = GridHeader[j3].Lindex;
                              Sindex2 = CrsWlk[Lindex2].LtoSmapping;
                              Sindex3 = CrsWlk[Lindex3].LtoSmapping;

                              for(grows = 0; grows < MG[LM_index1].numX; grows++)
                                 {
                                 XG = MG[LM_index1].SouthWestX  + ((double) grows * MG[LM_index1].Xspace);
                                 if((XG >= minx) && (XG <= maxx))
                                    {
                                    for(gcols = 0; gcols < MG[LM_index1].numY; gcols++)
                                       {
                                       YG = MG[LM_index1].SouthWestY + ((double) gcols * MG[LM_index1].Yspace);

                                       if((YG >= miny) && (YG <= maxy))
                                          {

                                          kk = (grows * MG[LM_index1].numY) + gcols;

                                          if((checktype == MASKEDIT_0) || (checktype == MASKEDIT_1))
                                             {
                                             if(MG[LM_index1].Elevs[kk] == ActiveChecks[Cindex].sensitivity)
                                                ZG = 1;
                                             else
                                                ZG = -1234;
                                             }
                                          else
                                             ZG = MG[LM_index1].Elevs[kk];

                                          Znew = 0;
                                          if((checktype == MASKEDIT_1) && 
                                                 (NearlyEqual(MG[LM_index2].Elevs[kk], ActiveChecks[Cindex].sensitivity3) > 0))
                                             Znew = 0;
                                          else if((checktype == MASKEDIT_1) &&
                                                 (NearlyEqual(MG[LM_index2].Elevs[kk], ActiveChecks[Cindex].sensitivity4) > 0))
                                             Znew = 0;
                                          else if((checktype == MASKEDIT_1) &&
                                                 (NearlyEqual(MG[LM_index3].Elevs[kk], ActiveChecks[Cindex].sensitivity3) > 0))
                                             Znew = 0;
                                          else if((checktype == MASKEDIT_1) &&
                                                 (NearlyEqual(MG[LM_index3].Elevs[kk], ActiveChecks[Cindex].sensitivity4) > 0))
                                             Znew = 0;
                                          else
                                             {
                                             if(MG[LM_index2].Elevs[kk] > MG[LM_index3].Elevs[kk])
                                                Znew = MG[LM_index2].Elevs[kk] - MG[LM_index3].Elevs[kk];
                                             else if(MG[LM_index2].Elevs[kk] < MG[LM_index3].Elevs[kk])
                                                Znew = MG[LM_index3].Elevs[kk] - MG[LM_index2].Elevs[kk];
                                             }

                                          WriteError =  0;
                                    
                                          if((checktype == MASKEDIT_0) && (ZG == 1) && (Znew > ActiveChecks[Cindex].sensitivity3))
                                             {
                                             WriteError = 1;
                                             }
                                          else if((checktype == MASKEDIT_1) && (ZG == 1) && (Znew > ActiveChecks[Cindex].sensitivity2)) 
                                             {
                                             WriteError = 1;
                                             }
   
                                          if(WriteError > 0)
                                             {
                                             if((checktype == MASKEDIT_0) || (checktype == MASKEDIT_1))
                                                Zdiff = Znew;
                                             else
                                                Zdiff = (double) MG[LM_index1].Elevs[kk];
                                             pseudoLID2 = 0 - j; /**(j+ 1) * (XG + (1.0 / YG)); **/
                                             pseudoLID3 = 0 - j3;  /**(j3+ 1) * (XG + (1.0 / YG)); **/
   
                                             ZG = MG[LM_index2].Elevs[kk];
                                             Znew = MG[LM_index3].Elevs[kk];
                                             if(checktype == MASKEDIT_0)
                                                {
                                                if(ActiveChecks[Cindex].sensitivity2 < 1)
                                                   {
                                                   FwriteDynamicInfo(checktype,Make_Correct(checktype,Cindex),0,1,2,NULL,
                                                     Zdiff, -1.0, -1.0, -1.0,
                                                    Sindex2,G_GRIDPT,Lindex2,pseudoLID2,Grid2IDN,-1.0,-1.0,
                                                    &XG, &YG, &ZG, 1,
                                                    Sindex3, G_GRIDPT,Lindex3,pseudoLID3,Grid3IDN, -1.0, -1.0,
                                                     &XG, &YG, &Znew, 1);
                                                   }
                                                else
                                                   {
                                                   if(billbout == NULL)
                                                      billbout = fopen(billboardlog,"wb");
                                                   if(billbout != NULL)
                                                      {
                                                      AddToBillBoardCheckList(Cindex,1);
                                                      ++BillBoardPtsWritten;
                                                      BB_FwriteDynamicInfo(billbout,checktype,Make_Correct(checktype,Cindex),
                                                           Cindex,ActiveChecks[Cindex].sensitivity2, 0,1,2,NULL,
                                                           Zdiff, -1.0, -1.0, -1.0,
                                                           Sindex2,G_GRIDPT,Lindex2,pseudoLID2,Grid2IDN,-1.0,-1.0,
                                                           &XG, &YG, &ZG, 1,
                                                           Sindex3, G_GRIDPT,Lindex3,pseudoLID3,Grid3IDN, -1.0, -1.0,
                                                           &XG, &YG, &Znew, 1);
                                                      }
                                                   }
                                                }
                                             else if(checktype == MASKEDIT_1)
                                                {
                                                if(ActiveChecks[Cindex].sensitivity5 < 1)
                                                   {
                                                   FwriteDynamicInfo(checktype,Make_Correct(checktype,Cindex),0,1,2,NULL,
                                                     Zdiff, -1.0, -1.0, -1.0,
                                                    Sindex2,G_GRIDPT,Lindex2,pseudoLID2,Grid2IDN,-1.0,-1.0,
                                                    &XG, &YG, &ZG, 1,
                                                    Sindex3, G_GRIDPT,Lindex3,pseudoLID3,Grid3IDN, -1.0, -1.0,
                                                     &XG, &YG, &Znew, 1);
                                                   }
                                                else
                                                   {
                                                   if(billbout == NULL)
                                                      billbout = fopen(billboardlog,"wb");
                                                   if(billbout != NULL)
                                                      {
                                                      AddToBillBoardCheckList(Cindex,1);
                                                      ++BillBoardPtsWritten;
                                                      BB_FwriteDynamicInfo(billbout,checktype,Make_Correct(checktype,Cindex),
                                                           Cindex,ActiveChecks[Cindex].sensitivity5, 0,1,2,NULL,
                                                           Zdiff, -1.0, -1.0, -1.0,
                                                           Sindex2,G_GRIDPT,Lindex2,pseudoLID2,Grid2IDN,-1.0,-1.0,
                                                           &XG, &YG, &ZG, 1,
                                                           Sindex3, G_GRIDPT,Lindex3,pseudoLID3,Grid3IDN, -1.0, -1.0,
                                                           &XG, &YG, &Znew, 1);
                                                      }
                                                   }
                                                }


                                             }
                                          }

                                       }
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }

   return(DidTheCheck);
}




void CheckGridForElevationValues(int checktype, int GridIDN,int Gindex, int Lindex, int NofRows, int NofCols, 
                                 int Cindex, int pseudoLocalID, double minx, double miny, double maxx, double maxy)
{
int kk, iX, iY, grows, gcols;
double Xgrid, Ygrid, Zgrid;
double localIDtouse;
int rowstart,rowend,colstart,colend;


   localIDtouse = (double) (0 - pseudoLocalID);
   for(kk=0; kk<MaxGridsPerRegion; kk++)
      {
      if((MG[kk].actualindex == pseudoLocalID) && (MG[kk].numX > 0) && (MG[kk].numY > 0))
         {
         rowstart = colstart = 0;
         rowend = MG[kk].numX;
         colend = MG[kk].numY;
GridIDN = MG[kk].localident;
         iX = 0;
         for(grows = rowstart; grows < rowend; grows++)
            {
            Xgrid = MG[kk].SouthWestX + ((double) iX * MG[kk].Xspace);
            if((Xgrid >= minx) && (Xgrid <= maxx))
               {
               iY = 0;
               for(gcols = colstart; gcols < colend; gcols++)
                  {
                  Ygrid = MG[kk].SouthWestY + ((double) iY * MG[kk].Yspace);

                  if((Ygrid >= miny) && (Ygrid <= maxy))
                     {
                     Zgrid = MG[kk].Elevs[(iX * MG[kk].numY) + iY];

                     if((checktype == GT) && (SensitivityCheck(GT, ELEVGT, Cindex, Zgrid) > 0))
                        {
                        if(ActiveChecks[Cindex].sensitivity2 < 1)
                           {
                           FwriteDynamicInfo(ELEVGT,Make_Correct(ELEVGT,Cindex),0,1,1,NULL,
                             Zgrid, -1.0, -1.0, -1.0,
                            CrsWlk[Lindex].LtoSmapping,/** should be the Grid Sindex **/
                            G_GRIDPT,Lindex,localIDtouse,GridIDN,-1.0,-1.0,
                            &Xgrid, &Ygrid, &Zgrid, 1,
/** the below args are don't care since only writing 1 feature ***/
                            CrsWlk[Lindex].LtoSmapping,G_GRIDPT,Lindex,localIDtouse,GridIDN,-1.0,-1.0,
                            &Xgrid, &Ygrid, &Zgrid, 1);
                           }
                        else
                           {
                           if(billbout == NULL)
                              billbout = fopen(billboardlog,"wb");
                           if(billbout != NULL)
                              {
                              AddToBillBoardCheckList(Cindex,1);
                              ++BillBoardPtsWritten;
                              BB_FwriteDynamicInfo(billbout,ELEVGT,Make_Correct(ELEVGT,Cindex),
                                Cindex,ActiveChecks[Cindex].sensitivity2, 0,1,1,NULL,
                                Zgrid, -1.0, -1.0, -1.0,
                                CrsWlk[Lindex].LtoSmapping,/** should be the Grid Sindex **/
                                G_GRIDPT,Lindex,localIDtouse,GridIDN,-1.0,-1.0,
                                &Xgrid, &Ygrid, &Zgrid, 1,
                                 CrsWlk[Lindex].LtoSmapping,G_GRIDPT,Lindex,localIDtouse,GridIDN,-1.0,-1.0,
                                 &Xgrid, &Ygrid, &Zgrid, 1);
                              }
                           }
                        }
                     else if((checktype == LT) && (SensitivityCheck(LT, ELEVLT, Cindex, Zgrid) > 0))
                        {
                        if(ActiveChecks[Cindex].sensitivity2 < 1)
                           {
                           FwriteDynamicInfo(ELEVLT,Make_Correct(ELEVLT,Cindex),0,1,1,NULL,
                             Zgrid, -1.0, -1.0, -1.0,
                            CrsWlk[Lindex].LtoSmapping,/** should be the Grid Sindex **/
                            G_GRIDPT,Lindex,localIDtouse,GridIDN,-1.0,-1.0,
                            &Xgrid, &Ygrid, &Zgrid, 1,
                            CrsWlk[Lindex].LtoSmapping,G_GRIDPT,Lindex,localIDtouse,GridIDN,-1.0,-1.0,
                            &Xgrid, &Ygrid, &Zgrid, 1);
                           }
                        else
                           {
                           if(billbout == NULL)
                              billbout = fopen(billboardlog,"wb");
                           if(billbout != NULL)
                              {
                              AddToBillBoardCheckList(Cindex,1);
                              ++BillBoardPtsWritten;
                              BB_FwriteDynamicInfo(billbout,ELEVLT,Make_Correct(ELEVLT,Cindex),
                                Cindex,ActiveChecks[Cindex].sensitivity2, 0,1,1,NULL,
                                Zgrid, -1.0, -1.0, -1.0,
                                CrsWlk[Lindex].LtoSmapping,/** should be the Grid Sindex **/
                                G_GRIDPT,Lindex,localIDtouse,GridIDN,-1.0,-1.0,
                                &Xgrid, &Ygrid, &Zgrid, 1,
                                 CrsWlk[Lindex].LtoSmapping,G_GRIDPT,Lindex,localIDtouse,GridIDN,-1.0,-1.0,
                                 &Xgrid, &Ygrid, &Zgrid, 1);
                              }
                           }
                        }
                     else if((ActiveChecks[Cindex].number == ELEVEQ) &&
                           (checktype == CLOSEDINT) && (SensitivityCheck(CLOSEDINT, ELEVEQ, Cindex, Zgrid) > 0))
                        {
                        if(ActiveChecks[Cindex].sensitivity3 < 1)
                           {
                           FwriteDynamicInfo(ELEVEQ,Make_Correct(ELEVEQ,Cindex),0,1,1,NULL,
                             Zgrid, -1.0, -1.0, -1.0,
                            CrsWlk[Lindex].LtoSmapping,/** should be the Grid Sindex **/
                            G_GRIDPT,Lindex,localIDtouse,GridIDN,-1.0,-1.0,
                            &Xgrid, &Ygrid, &Zgrid, 1,
                            CrsWlk[Lindex].LtoSmapping,G_GRIDPT,Lindex,localIDtouse,GridIDN,-1.0,-1.0,
                            &Xgrid, &Ygrid, &Zgrid, 1);
                           }
                        else
                           {
                           if(billbout == NULL)
                              billbout = fopen(billboardlog,"wb");
                           if(billbout != NULL)
                              {
                              AddToBillBoardCheckList(Cindex,1);
                              ++BillBoardPtsWritten;
                              BB_FwriteDynamicInfo(billbout,ELEVEQ,Make_Correct(ELEVEQ,Cindex),
                                Cindex,ActiveChecks[Cindex].sensitivity3, 0,1,1,NULL,
                                Zgrid, -1.0, -1.0, -1.0,
                                CrsWlk[Lindex].LtoSmapping,/** should be the Grid Sindex **/
                                G_GRIDPT,Lindex,localIDtouse,GridIDN,-1.0,-1.0,
                                &Xgrid, &Ygrid, &Zgrid, 1,
                                 CrsWlk[Lindex].LtoSmapping,G_GRIDPT,Lindex,localIDtouse,GridIDN,-1.0,-1.0,
                                 &Xgrid, &Ygrid, &Zgrid, 1);
                              }
                           }
                        }
                     else if((ActiveChecks[Cindex].number == WATERMMU) &&
                           (checktype == CLOSEDINT) && (SensitivityCheck(CLOSEDINT, WATERMMU, Cindex, Zgrid) > 0))
                        {
                        if(billbout == NULL)
                           billbout = fopen(billboardlog,"wb");
                        if(billbout != NULL)
                           {
                           AddToBillBoardCheckList(Cindex,1);
                           ++BillBoardPtsWritten;
                           BB_FwriteDynamicInfo(billbout,WATERMMU,Make_Correct(WATERMMU,Cindex),
                                Cindex,ActiveChecks[Cindex].sensitivity4, 0,1,1,NULL,
                                Zgrid, -1.0, -1.0, -1.0,CrsWlk[Lindex].LtoSmapping,
                                G_GRIDPT,Lindex,localIDtouse,GridIDN,-1.0,-1.0,
                                &Xgrid, &Ygrid, &Zgrid, 1,
                                 -1, -1,-1,-1,-1, -1.0, -1.0, 
                                 &Xgrid, &Ygrid, &Zgrid, 0);
                           }
                        }
                     else if((checktype == OPENINT) && (SensitivityCheck(OPENINT, ELEVEQOPEN, Cindex, Zgrid) > 0))
                        {
                        if(ActiveChecks[Cindex].sensitivity3 < 1)
                           {
                           FwriteDynamicInfo(ELEVEQOPEN,Make_Correct(ELEVEQOPEN,Cindex),0,1,1,NULL,
                             Zgrid, -1.0, -1.0, -1.0,
                            CrsWlk[Lindex].LtoSmapping,/** should be the Grid Sindex **/
                            G_GRIDPT,Lindex,localIDtouse,GridIDN,-1.0,-1.0,
                            &Xgrid, &Ygrid, &Zgrid, 1,
                            CrsWlk[Lindex].LtoSmapping,G_GRIDPT,Lindex,localIDtouse,GridIDN,-1.0,-1.0,
                            &Xgrid, &Ygrid, &Zgrid, 1);
                           }
                        else
                           {
                           if(billbout == NULL)
                              billbout = fopen(billboardlog,"wb");
                           if(billbout != NULL)
                              {
                              AddToBillBoardCheckList(Cindex,1);
                              ++BillBoardPtsWritten;
                              BB_FwriteDynamicInfo(billbout,ELEVEQOPEN,Make_Correct(ELEVEQOPEN,Cindex),
                                Cindex,ActiveChecks[Cindex].sensitivity3, 0,1,1,NULL,
                                Zgrid, -1.0, -1.0, -1.0,
                                CrsWlk[Lindex].LtoSmapping,/** should be the Grid Sindex **/
                                G_GRIDPT,Lindex,localIDtouse,GridIDN,-1.0,-1.0,
                                &Xgrid, &Ygrid, &Zgrid, 1,
                                 CrsWlk[Lindex].LtoSmapping,G_GRIDPT,Lindex,localIDtouse,GridIDN,-1.0,-1.0,
                                 &Xgrid, &Ygrid, &Zgrid, 1);
                              }
                           }
                        }
                     }

                  ++iY;
                  }
               }
            ++iX;
            }
         }
      }

   return;

}




void ReParentInnerRings(struct AreaAndHoles *Afirst)
{
struct AreaRing *ringroot1, *ringroot2, *ring1, *ring2;
struct AreaAndHoles *Ap, *Ac;
int i, targetidn, keepit, moveit;

   ringroot1 = NULL;
   targetidn = Afirst->idn;
   Ap = Afirst;
   while((Ap != NULL) && (Ap->idn == targetidn))
      {
/** first, see if any inner rings assigned to AP do not actually belong there ****/
      ringroot2 = NULL;
      ring2 = ring1 = Ap->inner;
      while(ring1 != NULL)
         {
         keepit = 0;
         if(Ap->outer->numverts == 3)
            {
            if(PointInsideTriangle(ring1->x[0], ring1->y[0], Ap->outer->x[0], Ap->outer->y[0],
                                   Ap->outer->x[1], Ap->outer->y[1],Ap->outer->x[2], Ap->outer->y[2]))
               {
               keepit = 1;
               }
            }
         else if(PointInsidePoly(ring1->x[0], ring1->y[0], Ap->outer->x, Ap->outer->y,Ap->outer->numverts))
            {
            keepit = 1;
            }
/*** if found a inner ring not inside the associated parent, remove it and keep it in ringroot2 - find actual parent later ***/
         if(keepit == 0)
            {
            if(ring1 == Ap->inner)
               {
               Ap->inner = Ap->inner->next;
               ring1->next = ringroot2;
               ringroot2 = ring1;
               ring2 = ring1 = Ap->inner;
               }
            else
               {
               ring2->next = ring1->next;
               ring1->next = ringroot2;
               ringroot2 = ring1;
               ring1 = ring2->next;
               }
            }
         else
            {
            ring2 = ring1;
            ring1 = ring1->next;
            }
         }
/*** check ringroot1 to see if any rings there belong to Ap ****/
      ring1 = ring2 = ringroot1;
      while(ring1 != NULL)
         {
         moveit = 0;
         if(Ap->outer->numverts == 3)
            {
            if(PointInsideTriangle(ring1->x[0], ring1->y[0], Ap->outer->x[0], Ap->outer->y[0],
                                   Ap->outer->x[1], Ap->outer->y[1],Ap->outer->x[2], Ap->outer->y[2]))
               {
               moveit = 1;
               }
            }
         else if(PointInsidePoly(ring1->x[0], ring1->y[0], Ap->outer->x, Ap->outer->y,Ap->outer->numverts))
            {
            moveit = 1;
            }
         if(moveit == 1)
            {
            if(ring1 == ringroot1)
               {
               ringroot1 = ringroot1->next;
               ring1->next = Ap->inner;
               Ap->inner = ring1;
               ring2 = ring1 = ringroot1;
               }
            else
               {
               ring2->next = ring1->next;
               ring1->next = Ap->inner;
               Ap->inner = ring1;
               ring1 = ring2->next;
               }
            }
         else
            {
            ring2 = ring1;
            ring1 = ring1->next;
            }
         }

/*** add ringroot2 to ringroot1 ***/
      if(ringroot1 == NULL)
         ringroot1 = ringroot2;
      else
         {
         ring1 = ringroot1;
         while(ring1->next != NULL)
            ring1 = ring1->next;
         ring1->next = ringroot2;
         }
      Ap = Ap->next;
      }
/*** npw see if any inner rings should be associated with more than 1 outer ring ***/
   Ap = Afirst;
   while((Ap != NULL) && (Ap->idn == targetidn))
      {
      Ac = Ap->next;
      while((Ac != NULL) && (Ac->idn == targetidn))
         {
         ring1 = Ac->inner;
         while(ring1 != NULL)
            {
            if(PointInsidePoly(ring1->x[0], ring1->y[0], Ap->outer->x, Ap->outer->y,Ap->outer->numverts) > 0)
               {
               ring2 = (struct AreaRing *) (malloc(sizeof(struct AreaRing)));
               if(ring2 == NULL)
                  {
                  printf("all available system memory has been consumed - processing must terminate now\n");
                  exit(-1);
                  }
               ring2->x = (double *) (malloc(SzD * ring1->numverts));
               ring2->y = (double *) (malloc(SzD * ring1->numverts));
               if(ring2->y == NULL)
                  {
                  printf("all available system memory has been consumed - processing must terminate now\n");
                  exit(-1);
                  }
               ring2->numverts = ring1->numverts;
               ring2->seekposn = ring1->seekposn;
               for(i=0; i<ring1->numverts; i++)
                  {
                  ring2->x[i] = ring1->x[i];
                  ring2->y[i] = ring1->y[i];
                  }
               ring2->next = Ap->inner;
               Ap->inner = ring2;
               }
            ring1 = ring1->next;
            }
         Ac = Ac->next;
         }
      Ap = Ap->next;
      }

   
}



void MakeArealWithHole(int SzAH, int SzAR, unsigned char drawcolor, long int fp)
{
int jj;
double maxx;
int ismultipart = 0;
   ismultipart = 0;
   mpoc = MultiAreaRoot;
   while(mpoc != NULL)
      {
      if(mpoc->featureid == ArealFromFile.idn) 
         {
         ismultipart = 1;
         break;
         }
      mpoc = mpoc->next;
      }

   if(ArealFromFile.ishole < 0)  /** is a parent, outer ring ***/
      {
      AHp = AHroot;
      while(AHp != NULL)
         {
         if((AHp->idn == ArealFromFile.idn) && (AHp->Lindex == ArealFromFile.Lindex))
            {
            if((ismultipart > 0) && (AHp->inner != NULL))
               {
               if(PointInsidePoly(AHp->inner->x[0], AHp->inner->y[0], ArealFromFile.x, ArealFromFile.y, ArealFromFile.numverts) > 0)
                  break;
               }
            else
               break;
            }
         AHp = AHp->next;
         }
      if((AHp != NULL) && (AHp->idn == ArealFromFile.idn) && (AHp->Lindex == ArealFromFile.Lindex))
         {
         if(AHp->outer == NULL) /*** then have already added inner rings with this idn ***/
            {
            AHp->numholes = 0 - ArealFromFile.ishole;
            AHp->outer = (struct AreaRing *) (malloc(SzAR));
            if(AHp->outer == NULL)
               {
               printf("memory has been totally consumed drawing area feature inner and outer rings\n");
               exit(-1);
               }
            AHp->outer->numverts = ArealFromFile.numverts;
            AHp->outer->seekposn = fp;
            AHp->outer->x = (double *) (malloc(SzD * ArealFromFile.numverts));
            AHp->outer->y = (double *) (malloc(SzD * ArealFromFile.numverts));
            if(AHp->outer->y == NULL)
               {
               printf("memory has been totally consumed drawing area feature inner and outer rings\n");
               exit(-1);
               }
            maxx = ArealFromFile.x[0];
            for(jj = 0; jj< ArealFromFile.numverts; jj++)
               {
               AHp->outer->x[jj] = ArealFromFile.x[jj];
               AHp->outer->y[jj] = ArealFromFile.y[jj];
               if(ArealFromFile.x[jj] > maxx)
                  maxx = ArealFromFile.x[jj];
               }
            AHp->maxXindex = (int) (maxx / RegionSize);

            }
        else if(AHp->outer->seekposn != fp) /*** already have this idn as an outer ring - could be a multipart area feature ***/
/**** if have same filepointer, then is just an additional encounter with this outer ring ***/
            {
            AHc = (struct AreaAndHoles *) (malloc(SzAH));
            if(AHc == NULL)
               {
               printf("memory has been totally consumed drawing area feature inner and outer rings\n");
               exit(-1);
               }
            AHc->idn = ArealFromFile.idn;
            AHc->Lindex = ArealFromFile.Lindex;
            AHc->numholes = 0 - ArealFromFile.ishole;
            AHc->drawcolor = drawcolor;
            AHc->inner = NULL;
            ringc = (struct AreaRing *) (malloc(SzAR));
            if(ringc == NULL)
               {
               printf("memory has been totally consumed drawing area feature inner and outer rings\n");
               exit(-1);
               }
            ringc->seekposn = fp;
            ringc->numverts = ArealFromFile.numverts;
            ringc->x = (double *) (malloc(SzD * ArealFromFile.numverts));
            ringc->y = (double *) (malloc(SzD * ArealFromFile.numverts));
            if(ringc->y == NULL)
               {
               printf("memory has been totally consumed drawing area feature inner and outer rings\n");
               exit(-1);
               }
            maxx = ArealFromFile.x[0];
            for(jj = 0; jj< ArealFromFile.numverts; jj++)
               {
               ringc->x[jj] = ArealFromFile.x[jj];
               ringc->y[jj] = ArealFromFile.y[jj];
               if(ArealFromFile.x[jj] > maxx)
                     maxx = ArealFromFile.x[jj];
               }
            AHc->maxXindex = (int) (maxx / RegionSize);
            AHc->outer = ringc;
            AHc->next = AHp->next;
            AHp->next = AHc;

            ReParentInnerRings(AHp);
            }

         }
      else /*** AHp must be NULL ***/
         {
         AHc = (struct AreaAndHoles *) (malloc(SzAH));
         if(AHc == NULL)
            {
            printf("memory has been totally consumed drawing area feature inner and outer rings\n");
            exit(-1);
            }
         AHc->idn = ArealFromFile.idn;
         AHc->Lindex = ArealFromFile.Lindex;
         AHc->numholes = 0 - ArealFromFile.ishole;
         AHc->drawcolor = drawcolor;
         AHc->inner = NULL;
         ringc = (struct AreaRing *) (malloc(SzAR));
         if(ringc == NULL)
            {
            printf("memory has been totally consumed drawing area feature inner and outer rings\n");
            exit(-1);
            }
         ringc->seekposn = fp;
         ringc->numverts = ArealFromFile.numverts;
         ringc->x = (double *) (malloc(SzD * ArealFromFile.numverts));
         ringc->y = (double *) (malloc(SzD * ArealFromFile.numverts));
         if(ringc->y == NULL)
            {
            printf("memory has been totally consumed drawing area feature inner and outer rings\n");
            exit(-1);
            }
         maxx = ArealFromFile.x[0];
         for(jj = 0; jj< ArealFromFile.numverts; jj++)
            {
            ringc->x[jj] = ArealFromFile.x[jj];
            ringc->y[jj] = ArealFromFile.y[jj];
            if(ArealFromFile.x[jj] > maxx)
                  maxx = ArealFromFile.x[jj];
            }
         AHc->maxXindex = (int) (maxx / RegionSize);
         AHc->outer = ringc;
         AHc->next = AHroot;
         AHroot = AHc;
         }
      }



   else if(ArealFromFile.ishole >= 1)  /** is a cut-out, inner ring ***/
      {
      AHp = AHroot;
      while(AHp != NULL)
         {
         if((AHp->idn == ArealFromFile.idn) && (AHp->Lindex == ArealFromFile.Lindex))
            {
            if((ismultipart > 0) && (AHp->outer != NULL))
               {
               if(PointInsidePoly(ArealFromFile.x[0], ArealFromFile.y[0],AHp->outer->x, AHp->outer->y, AHp->outer->numverts) > 0)
                  break;
               }
            else
               break;
            }
         AHp = AHp->next;
         }
      if((AHp != NULL) && (AHp->idn == ArealFromFile.idn) && (AHp->Lindex == ArealFromFile.Lindex))
         {
         if(AHp->outer == NULL)
            {
               ringc = (struct AreaRing *) (malloc(SzAR));
               if(ringc == NULL)
                  {
                  printf("memory has been totally consumed drawing area feature inner and outer rings\n");
                  exit(-1);
                  }
               ringc->seekposn = fp;
               ringc->numverts = ArealFromFile.numverts;
               ringc->x = (double *) (malloc(SzD * ArealFromFile.numverts));
               ringc->y = (double *) (malloc(SzD * ArealFromFile.numverts));
               if(ringc->y == NULL)
                  {
                  printf("memory has been totally consumed drawing area feature inner and outer rings\n");
                  exit(-1);
                  }
               for(jj = 0; jj< ArealFromFile.numverts; jj++)
                  {
                  ringc->x[jj] = ArealFromFile.x[jj];
                  ringc->y[jj] = ArealFromFile.y[jj];
                  }
               ringc->next = AHp->inner;
               AHp->inner = ringc;
            }
         else if((AHp->next != NULL) && (AHp->idn == AHp->next->idn) && (AHp->Lindex == AHp->next->Lindex))
            {
            while((AHp != NULL) && (AHp->idn == ArealFromFile.idn) && (AHp->Lindex == ArealFromFile.Lindex))
               {
               if(AHp->outer->numverts == 3)
                  {
                  if(PointInsideTriangle(ArealFromFile.x[0], ArealFromFile.y[0], AHp->outer->x[0], AHp->outer->y[0],
                                         AHp->outer->x[1], AHp->outer->y[1],AHp->outer->x[2], AHp->outer->y[2]))
                     {
                     break;
                     }
                  }
               else if(PointInsidePoly(ArealFromFile.x[0], ArealFromFile.y[0], AHp->outer->x, AHp->outer->y,AHp->outer->numverts))
                  {
                  break;
                  }
               AHp = AHp->next;
               }
            if((AHp == NULL) || (AHp->idn != ArealFromFile.idn) || (AHp->Lindex != ArealFromFile.Lindex))
               {
               AHc = (struct AreaAndHoles *) (malloc(SzAH));
               if(AHc == NULL)
                  {
                  printf("memory has been totally consumed drawing area feature inner and outer rings\n");
                  exit(-1);
                  }
               AHc->idn = ArealFromFile.idn;
               AHc->Lindex = ArealFromFile.Lindex;
               AHc->numholes = 0;
               AHc->drawcolor = drawcolor;
               AHc->maxXindex = MaxXindex;
               AHc->outer = NULL;
               ringc = (struct AreaRing *) (malloc(SzAR));
               if(ringc == NULL)
                  {
                  printf("memory has been totally consumed drawing area feature inner and outer rings\n");
                  exit(-1);
                  }
               ringc->seekposn = fp;
               ringc->numverts = ArealFromFile.numverts;
               ringc->x = (double *) (malloc(SzD * ArealFromFile.numverts));
               ringc->y = (double *) (malloc(SzD * ArealFromFile.numverts));
               if(ringc->y == NULL)
                  {
                  printf("memory has been totally consumed drawing area feature inner and outer rings\n");
                  exit(-1);
                  }
               for(jj = 0; jj< ArealFromFile.numverts; jj++)
                  {
                  ringc->x[jj] = ArealFromFile.x[jj];
                  ringc->y[jj] = ArealFromFile.y[jj];
                  }
               ringc->next = NULL;
               AHc->inner = ringc;
               AHc->next = AHroot;
               AHroot = AHc;
               }
            else
               {
               ringp = AHp->inner;
               while(ringp != NULL)
                  {
                  if(ringp->seekposn == fp)
                     break;
                  ringp = ringp->next;
                  }
               if(ringp == NULL)
                  {
                  ringc = (struct AreaRing *) (malloc(SzAR));
                  if(ringc == NULL)
                     {
                     printf("memory has been totally consumed drawing area feature inner and outer rings\n");
                     exit(-1);
                     }
                  ringc->numverts = ArealFromFile.numverts;
                  ringc->seekposn = fp;
                  ringc->x = (double *) (malloc(SzD * ArealFromFile.numverts));
                  ringc->y = (double *) (malloc(SzD * ArealFromFile.numverts));
                  if(ringc->y == NULL)
                     {
                     printf("memory has been totally consumed drawing area feature inner and outer rings\n");
                     exit(-1);
                     }
                  for(jj = 0; jj< ArealFromFile.numverts; jj++)
                     {
                     ringc->x[jj] = ArealFromFile.x[jj];
                     ringc->y[jj] = ArealFromFile.y[jj];
                     }
                  ringc->next = AHp->inner;
                  AHp->inner = ringc;
                  }
               }
            }
         else
            {
            ringp = AHp->inner;
            while(ringp != NULL)
               {
               if(ringp->seekposn == fp)
                  break;
               ringp = ringp->next;
               }
            if(ringp == NULL)
               {
               ringc = (struct AreaRing *) (malloc(SzAR));
               if(ringc == NULL)
                  {
                  printf("memory has been totally consumed drawing area feature inner and outer rings\n");
                  exit(-1);
                  }
               ringc->numverts = ArealFromFile.numverts;
               ringc->seekposn = fp;
               ringc->x = (double *) (malloc(SzD * ArealFromFile.numverts));
               ringc->y = (double *) (malloc(SzD * ArealFromFile.numverts));
               if(ringc->y == NULL)
                  {
                  printf("memory has been totally consumed drawing area feature inner and outer rings\n");
                  exit(-1);
                  }
               for(jj = 0; jj< ArealFromFile.numverts; jj++)
                  {
                  ringc->x[jj] = ArealFromFile.x[jj];
                  ringc->y[jj] = ArealFromFile.y[jj];
                  }
               ringc->next = AHp->inner;
               AHp->inner = ringc;
               }
            }
         }
      else /*** AHp must be NULL ***/
         {
         AHc = (struct AreaAndHoles *) (malloc(SzAH));
         if(AHc == NULL)
            {
            printf("memory has been totally consumed drawing area feature inner and outer rings\n");
            exit(-1);
            }
         AHc->idn = ArealFromFile.idn;
         AHc->Lindex = ArealFromFile.Lindex;
         AHc->numholes = 0;
         AHc->drawcolor = drawcolor;
         AHc->maxXindex = MaxXindex;
         AHc->outer = NULL;
         ringc = (struct AreaRing *) (malloc(SzAR));
         if(ringc == NULL)
            {
            printf("memory has been totally consumed drawing area feature inner and outer rings\n");
            exit(-1);
            }
         ringc->seekposn = fp;
         ringc->numverts = ArealFromFile.numverts;
         ringc->x = (double *) (malloc(SzD * ArealFromFile.numverts));
         ringc->y = (double *) (malloc(SzD * ArealFromFile.numverts));
         if(ringc->y == NULL)
            {
            printf("memory has been totally consumed drawing area feature inner and outer rings\n");
            exit(-1);
            }
         for(jj = 0; jj< ArealFromFile.numverts; jj++)
            {
            ringc->x[jj] = ArealFromFile.x[jj];
            ringc->y[jj] = ArealFromFile.y[jj];
            }
         ringc->next = NULL;
         AHc->inner = ringc;
         AHc->next = AHroot;
         AHroot = AHc;
         }
      }
}


void SendAreaAndHoles(int xindex, double minx, double miny, double maxx, double maxy)
{
  extern void DrawPolyWithHoles(int num_external_verts, double *externalX, double *externalY, 
				int color, int numholes, struct AreaRing *holes, int Lindex);

 
  AHc = AHp = AHroot;
  while(AHc != NULL)
    {
      if((AHc->outer != NULL) && (AHc->maxXindex <= xindex))
	{
          AHc->drawcolor = AssignDrawingColor(AHc->idn,(unsigned char)SCCtable[CrsWlk[AHc->Lindex].LtoSmapping].D, AHc->Lindex);

	  DrawPolyWithHoles(AHc->outer->numverts,AHc->outer->x,AHc->outer->y,
			    AHc->drawcolor, AHc->numholes,AHc->inner, AHc->Lindex);
	  

	  ringc = AHc->inner;
	  
	  while(ringc != NULL)
            {
	      ringp = ringc;
	      ringc = ringc->next;
	      free(ringp->x);
	      free(ringp->y);
	      free(ringp);
            }


	  if(AHc == AHroot)
            {
	      AHroot = AHroot->next;
	      free(AHc->outer->x);
	      free(AHc->outer->y);
	      free(AHc->outer);
	      free(AHc);
	      AHp = AHc = AHroot;
            }
	  else
            {
	      AHp->next = AHc->next;
	      free(AHc->outer->x);
	      free(AHc->outer->y);
	      free(AHc->outer);
	      free(AHc);
	      AHc = AHp->next;
            }
	}
      else
	{
	  AHp = AHc;
	  AHc = AHc->next;
	}
    }
}



FILE * GlobalUseOpenGridFile(int filenumber)
{
static FILE * answer;

   if(NumberOfGrids > 0)
      {
      if(filenumber == 1)
         {
         sprintf(gridsin,"%sgrid.bin",indirectory);
         }
      else
         {
         sprintf(gridsin,"%sgrid%d.bin",indirectory,filenumber);
         }
      GridFileInUse = filenumber;
      answer = fopen(gridsin,"rb");
      if(answer == NULL)
         {
         printf("grid input file %s could not be opened\n   Fatal Error\n",gridsin);
         exit(-1);
         }
      }
   else
      {
      answer = NULL;
      }

   return(answer);
}






int ExposeLayerOfRegionContent(int DrawElevationContours, int Lindex1,int Uindex1, int Lindex2, int Uindex2, int StratToDraw[],
         struct RawAreal **ARredrawRT, struct RawLinear **RLredrawRT, struct RawPoint **RPredrawRT, struct RawBridge **RBredrawRT,
          struct ThePolys **TPredrawRT)
{
FILE *arin;
FILE *linin;
FILE *ptsin;
FILE *brdgin;
FILE *modelPin;
int index1, index2;
int OKtoUse;
/** int DrawGridPolyOnly;**/
/**double dminx,dminy; **/
/** double dmaxx, dmaxy; **/
int minx, maxx,miny,maxy;
int i, j, k;
//int iX, iY;
int ii,jj, kkk, k4;
/***int checkinstance, part1, part2, part3;***/
//int ii2, kk;
/**int jj2; **/
int drawthisgeom;
int HadToOpenFile, vtxcnt;
//int grows, gcols,NofCols,NofRows;
int Config, Strat, Domain;
int valuesread = 0;
int singles;
int multiples;
int compositeindex;
int AbortDraw = 0;
int * GridIsFinished = NULL;
//int AllGridsFinished;
double multiplier;
/***double Xdiamond[4];
double Ydiamond[4];***/
double Xgrid[4], Ygrid[4] /***,Zgrid[4]**/;

struct RawAreal *ARredraw, *ARc;
struct RawLinear *RLredraw, *RLc;
struct RawPoint *RPredraw, *RPc;
struct RawBridge *RBredraw, *RBc;
struct ThePolys *TPredraw, *TPc;
double SA, SB, SC;
int skiplimit;
//int DrawStarsOrOutline;
unsigned long int fo;
unsigned char drawcolor;
unsigned char Tdrawcolor;
struct LongList *cll;
struct LongSkipList *SkipList;
int SzRA = sizeof(struct RawAreal);
int SzRL = sizeof(struct RawLinear);
int SzRP = sizeof(struct RawPoint);
int SzRB = sizeof(struct RawBridge);
int SzTP = sizeof(struct ThePolys);
int SzAH = sizeof(struct AreaAndHoles);
int SzAR = sizeof(struct AreaRing);
int SkipEntry = 0;
int filenumber;
/**int findex = 0;**/
char afilein[1000];
char gfilein[1000];
char suffix[5];
/***int RestoreUseRGridVal; ***/

extern int FILL_FLAG;
extern int PROCESS_GRID_VALUES;
extern void ShapeExportBridge();
extern void ShapeExportPoint();
extern void ShapeExportLine();
extern void ShapeExportAreal();
extern void ShapeExportPoly(int type);
extern void ShapeExportGrid(double x, double y, int idn, int Lindex);
extern int CalculatePixel(double llx, double lly,double urx, double ury);


   if(SCCtable == NULL)
      {
      printf("skipping layer exposure given NULL SCCtable\n");
      AbortDraw = AbortZoom();
      return(AbortDraw);
      }

   ARredraw = NULL;
   RLredraw = NULL;
   RPredraw = NULL;
   RBredraw = NULL;
   TPredraw = NULL;

   skiplimit = 1000;

   SkipList = (struct LongSkipList *) (malloc(SzSkip * skiplimit));

   multiplier = SignificantDecimals;

   NeedAreaCalculation = 0;

   drawthisgeom = 0;
   for(j=0; j<TotalSCC; j++)
      {
      if((SCCtable[j].C == 7) && (StratToDraw[SCCtable[j].S] > 0))
         {
         drawthisgeom = 1;
         break;
         }
      }


   if((DrawByConfig[7] > 0) && (drawthisgeom > 0)) /** yes, we are drawing polygons in specified layer **/
      {
      FreeLongList(&LongListRoot);
      LongListRoot = NULL;
      for(i=0; i<skiplimit; i++)
         {
         SkipList[i].val = -1;
         SkipList[i].entry = NULL;
         }
   HadToOpenFile = 0;
   if(fin == NULL)
      {
      fin = fopen(infile,"rb");
      if(fin == NULL)
         {
         printf("Could not open %s for processing \n",infile);
         printf("   1: No processing can occur without this basic input file\n");
         exit(-1);
         }
      else
         {
         HadToOpenFile = 1;
         }
      }

      SetUpSunParameters(ZoomSunAzimuth, ZoomSunAngle, &SA, &SB, &SC);

      for(index1 = Lindex1; index1 <= Uindex1; index1++)
         {
         for(index2 = Lindex2; index2 <= Uindex2; index2++)
            {
            minx = (int) (index1 * RegionSize);
            maxx = (int) (minx + RegionSize);
            miny = (int) (index2 * RegionSize);
            maxy = (int) (miny + RegionSize);

            compositeindex = (index1 * (MaxYindex + 1)) + index2;
            if(NGA_TYPE == 0)
               {
               fseek(fin,PolyTable[compositeindex].fileptr,SEEK_SET);
               singles = PolyTable[compositeindex].numinside;
               multiples = PolyTable[compositeindex].numother;
      
               for(i=0; i<PolyTable[compositeindex].numother; i++)
                  {
                  InsertIntoLongList(PolyTable[compositeindex].others[i].fileptr,0,skiplimit,
                                  &LongListRoot,SkipList,&SkipEntry);
                  }
               }
            else
               {
               singles = multiples = 0;
               LongListRoot = NULL;
               }

            valuesread = 0;

            while(valuesread < singles)
               {
               if(feof(fin) != 0)
                  break;
               vtxcnt = ReadPolyFromFile(fin,multiplier);
    
               Config = PolyFromFile.config;
               Strat = PolyFromFile.stratum;
               Domain = PolyFromFile.domain;

               OKtoUse = 1;

               if(NumLODbands > 0)
                  {
                  jj = CrsWlk[PolyFromFile.SACindex].LODband;
                  if((jj > 0) && (LODindex[jj-1].active < 1))
                     OKtoUse = 0;
                  }
   
               if((OKtoUse > 0) && (StratToDraw[Strat] > 0) && (DrawByDomain[Domain] > 0))
                  {
                  if(DrawElevationContours == 0)
                     {

                     if((Strat == 5) && ((FILL_FLAG == 4) || (FILL_FLAG == 5)))
                        drawcolor = AssignShadedColor(PolyFromFile.idn,PolyFromFile.SACindex,PolyFromFile.x, PolyFromFile.y, PolyFromFile.z,vtxcnt, SA,SB,SC);
                     else
                        drawcolor = AssignDrawingColor(PolyFromFile.idn, (unsigned char)Domain, PolyFromFile.SACindex);
                     if((NGA_TYPE == 0) && (drawcolor == HighLightColor))
                        {
                        TPc = (struct ThePolys *) (malloc(SzTP));
                        TPc->x = (double *) malloc(SzD * vtxcnt);
                        TPc->y = (double *) malloc(SzD * vtxcnt);
                        for(jj = 0; jj<vtxcnt; jj++)
                           {
                           TPc->x[jj] = PolyFromFile.x[jj];
                           TPc->y[jj] = PolyFromFile.y[jj];
                           }
                        TPc->numverts = vtxcnt;
                        TPc->next = TPredraw;
                        TPredraw = TPc;
                        }
                    if(DrawHighlightedOnly == 0)
                         MAPdrawpoly(vtxcnt,PolyFromFile.x, PolyFromFile.y,drawcolor,0,1,1,PolyFromFile.SACindex);
                     }
                  if((DrawElevationContours > 0) && (Strat == 5))
                     DrawContourLinesFromPoly(vtxcnt,PolyFromFile.x,PolyFromFile.y,PolyFromFile.z,PolyFromFile.SACindex);
                  }
               ++valuesread;
               free(PolyFromFile.x);
               free(PolyFromFile.y);
               free(PolyFromFile.z);
               
               AbortDraw = AbortZoom();
               if(AbortDraw == 1)
                  {
                  if(HadToOpenFile > 0)
                     {
                     fclose(fin);
                     fin = NULL;
                     HadToOpenFile = 0;
                     }
                  FreeLongList(&LongListRoot);
                  LongListRoot = NULL;
                  free(SkipList);
   
                  return(AbortDraw);
                  }
               }
            }
         }

      cll = LongListRoot;
      while(cll != NULL)
         {
         fseek(fin,cll->fp,SEEK_SET);
         vtxcnt = ReadPolyFromFile(fin,multiplier);

         Config = PolyFromFile.config;
         Strat = PolyFromFile.stratum;
         Domain = PolyFromFile.domain;

         OKtoUse = 1;
         if(NumLODbands > 0)
            {
            jj = CrsWlk[PolyFromFile.SACindex].LODband;
            if((jj > 0) && (LODindex[jj-1].active < 1))
               OKtoUse = 0;
            }
         if((OKtoUse > 0) && (StratToDraw[Strat] > 0) && (DrawByDomain[Domain] > 0))
            {
            if(DrawElevationContours == 0)
               {
               if((Strat == 5) && ((FILL_FLAG == 4)  || (FILL_FLAG == 5)))
                  drawcolor = AssignShadedColor(PolyFromFile.idn,PolyFromFile.SACindex,PolyFromFile.x, PolyFromFile.y, PolyFromFile.z,vtxcnt, SA,SB,SC);
               else
                  drawcolor = AssignDrawingColor(PolyFromFile.idn, (unsigned char)Domain, PolyFromFile.SACindex);
               if((NGA_TYPE == 0) && (drawcolor == HighLightColor))
                  {
                  TPc = (struct ThePolys *) (malloc(SzTP));
                  TPc->x = (double *) malloc(SzD * vtxcnt);
                  TPc->y = (double *) malloc(SzD * vtxcnt);
                  for(jj = 0; jj<vtxcnt; jj++)
                     {
                     TPc->x[jj] = PolyFromFile.x[jj];
                     TPc->y[jj] = PolyFromFile.y[jj];
                     }
                  TPc->numverts = vtxcnt;
                  TPc->next = TPredraw;
                  TPredraw = TPc;
                  }
              if(DrawHighlightedOnly == 0)
                   MAPdrawpoly(vtxcnt,PolyFromFile.x, PolyFromFile.y,drawcolor,0,1,1,PolyFromFile.SACindex);

               }
            if((DrawElevationContours > 0) && (Strat == 5))
               DrawContourLinesFromPoly(vtxcnt,PolyFromFile.x,PolyFromFile.y,PolyFromFile.z,PolyFromFile.SACindex);
            }


         cll = cll->next;
         free(PolyFromFile.x);
         free(PolyFromFile.y);
         free(PolyFromFile.z);

         AbortDraw = AbortZoom();
         if(AbortDraw == 1)
            {
            if(HadToOpenFile > 0)
               {
               fclose(fin);
               fin = NULL;
               HadToOpenFile = 0;
               }
            FreeLongList(&LongListRoot);
            LongListRoot = NULL;
            free(SkipList);

            return(AbortDraw);
            }
         }

      FreeLongList(&LongListRoot);
      LongListRoot = NULL;
   
      if(HadToOpenFile > 0)
         {
         fclose(fin);
         fin = NULL;
         HadToOpenFile = 0;
         }
      }

   GridNowLoaded =  -500;

   drawthisgeom = 0;
   if(NumberOfGrids > 0)
      {
      for(j=0; j<TotalSCC; j++)
         {
         if((SCCtable[j].C == 9) && (StratToDraw[SCCtable[j].S] > 0))
            {
            drawthisgeom = 1;
            break;
            }
         }
      }

   ptsin = NULL;
   if((NumberOfGrids > 0) && (DrawByConfig[9] > 0) && (drawthisgeom > 0))  /** drawing grid data in specified layer ***/
      {
      Config = 9;

      GridIsFinished = (int * ) (malloc(NumberOfGrids * SzI));
      if(GridIsFinished == NULL)
         {
         printf("memory has been exhausted during elevation grid drawing - exiting now!!\n");
         exit(-1);
         }

      for(k=0; k < NumberOfGrids; k++)
         {
         GridIsFinished[k] = 0;
         }


      for(kkk = 0; kkk<NumberOfGrids;kkk++)
         {
         k4 = DrawGridShaded(GridHeader[kkk].Lindex);
         if((k4 == 1) || (k4 == 2))
            {

            if(AbortDraw == 1)
               {
               CloseGridFile(ptsin);
               FreeLongList(&LongListRoot);
               LongListRoot = NULL;
               free(SkipList);

               return(AbortDraw);
               }

            jj = CrsWlk[GridHeader[kkk].Lindex].LODband;
            OKtoUse = 1;
            if((jj > 0) && (LODindex[jj-1].active < 1)) /** then grid is active for drawing ***/
               {
               OKtoUse = 0;
               Tdrawcolor = AssignDrawingColor(GridHeader[kkk].idn, (unsigned char)Domain, GridHeader[kkk].Lindex);
               if(Tdrawcolor != HighLightColor)
                  GridIsFinished[kkk] = 1;
               }
            if(OKtoUse > 0)
               {
               Strat = SCCtable[GridHeader[kkk].Sindex].S;
               Domain = SCCtable[GridHeader[kkk].Sindex].D;
               if(GridFileInUse != GridHeader[kkk].FileNumber)
                  {
                  if(ptsin != NULL)
                     CloseGridFile(ptsin);
                  ptsin = GlobalUseOpenGridFile(GridHeader[kkk].FileNumber);
                  }
               if(ptsin != NULL)
                  {
                  if((OKtoUse > 0) && (StratToDraw[Strat] > 0) && (DrawByDomain[Domain] > 0))
                     {
                     if(k4 == 2)  /*** want to just draw a poly of the extent outline  **/
                        {
                        if(GridIsFinished[kkk] == 0)
                           {
                           Xgrid[0] = Xgrid[1] = GridHeader[kkk].BaseX;
                           Xgrid[2] = Xgrid[3] = Xgrid[0] + ((double) (GridHeader[kkk].Xpts - 1) * GridHeader[kkk].Xspacing);

                           Ygrid[0] =Ygrid[3] = GridHeader[kkk].BaseY;
                           Ygrid[1] = Ygrid[2] = Ygrid[0] + ((double) (GridHeader[kkk].Ypts - 1) * GridHeader[kkk].Yspacing);

                           drawcolor = AssignDrawingColor(GridHeader[kkk].idn, (unsigned char)Domain, GridHeader[kkk].Lindex);

                           PROCESS_GRID_VALUES = 1;
                           PrepareForGridMasking(GridHeader[kkk].FileNumber,GridHeader[kkk].fileptr,jj,1,1);
                           PROCESS_GRID_VALUES = 0;

                           MAPdrawpoly(4,Xgrid,Ygrid,drawcolor,1,1,0,GridHeader[kkk].Lindex);

                           EndGridMasking();
                           }
                        Tdrawcolor = AssignDrawingColor(GridHeader[kkk].idn, (unsigned char)Domain, GridHeader[kkk].Lindex);
                        if(Tdrawcolor != HighLightColor)
                           GridIsFinished[kkk] = 1;
                        }

                     else if((Strat == 5) && (DrawHighlightedOnly == 0) &&
                                      (k4 == 1))
                        {
                        if(GridHeader[kkk].FileNumber == 1)
                           {
                           sprintf(gfilein,"%sgrid.bin",indirectory);
                           }
                        else
                           {
                           sprintf(gfilein,"%sgrid%d.bin",indirectory,GridHeader[kkk].FileNumber);
                           }
                        DrawShadedGrid(gfilein,GridHeader[kkk].fileptr);

                        Tdrawcolor = AssignDrawingColor(GridHeader[kkk].idn, (unsigned char)Domain, GridHeader[kkk].Lindex);
                        if(Tdrawcolor != HighLightColor)
                           GridIsFinished[kkk] = 1;
                        }

                     }
                  }
               }
            }
         }




      if(NGA_TYPE == 1)
         CombIntDrawingLayers(C_GRID);
      CloseGridFile(ptsin);
      if(GridIsFinished != NULL)
         {
         free(GridIsFinished);
         }
      }



   drawthisgeom = 0;
   for(j=0; j<TotalSCC; j++)
      {
      if((SCCtable[j].C == 12) && (StratToDraw[SCCtable[j].S] > 0))
         {
         drawthisgeom = 1;
         break;
         }
      }

   if((DrawByConfig[12] > 0) && (drawthisgeom > 0)) /** yes, we are drawing model library polygons  in specified layer**/
      {
      FreeLongList(&LongListRoot);
      LongListRoot = NULL;
      for(i=0; i<skiplimit; i++)
         {
         SkipList[i].val = -1;
         SkipList[i].entry = NULL;
         }
      modelPin = fopen(MPdatain,"rb");
      if((NGA_TYPE == 0) && (modelPin != NULL))
         {
            
         SetUpSunParameters(ZoomSunAzimuth, ZoomSunAngle, &SA, &SB, &SC);

         for(index1 = Lindex1; index1 <= Uindex1; index1++)
            {
            for(index2 = Lindex2; index2 <= Uindex2; index2++)
               {
               minx = (int) (index1 * RegionSize);
               maxx = (int) (minx + RegionSize);
               miny = (int) (index2 * RegionSize);
               maxy = (int) (miny + RegionSize);

               compositeindex = (index1 * (MaxYindex + 1)) + index2;
               if(NGA_TYPE == 0)
                  {
                  fseek(modelPin,ModelPolyTable[compositeindex].fileptr,SEEK_SET);
                  singles = ModelPolyTable[compositeindex].numinside;
                  multiples = ModelPolyTable[compositeindex].numother;
     
                  for(i=0; i<ModelPolyTable[compositeindex].numother; i++)
                     {
                     InsertIntoLongList(ModelPolyTable[compositeindex].others[i].fileptr,0,skiplimit,
                                     &LongListRoot,SkipList,&SkipEntry);
                     }
                  }
               else
                  {
                  singles = multiples = 0;
                  LongListRoot = NULL;
                  }
   
               valuesread = 0;

               while(valuesread < singles)
                  {
                  if(feof(modelPin) != 0)
                     break;
                  vtxcnt = ReadPolyFromFile(modelPin,multiplier);

                  Config = PolyFromFile.config;
                  Strat = PolyFromFile.stratum;
                  Domain = PolyFromFile.domain;

                  OKtoUse = 1;
                  if(NumLODbands > 0)
                     {
                     jj = CrsWlk[PolyFromFile.SACindex].LODband;
                     if((jj > 0) && (LODindex[jj-1].active < 1))
                        OKtoUse = 0;
                     }

                  if((OKtoUse > 0) &&(StratToDraw[Strat] > 0) && (DrawByDomain[Domain] > 0))
                     {
                     if((Strat == 5) && ((FILL_FLAG == 4) || (FILL_FLAG == 5)))
                        drawcolor = AssignShadedColor(PolyFromFile.idn,PolyFromFile.SACindex,PolyFromFile.x, PolyFromFile.y, PolyFromFile.z,vtxcnt,SA,SB,SC);
                     else
                        drawcolor = AssignDrawingColor(PolyFromFile.idn, (unsigned char)Domain, PolyFromFile.SACindex);
                     /**if(drawcolor == HighLightColor) **/
                     if((NGA_TYPE == 0) && (drawcolor == HighLightColor))
                        {
                        TPc = (struct ThePolys *) (malloc(SzTP));
                        TPc->x = (double *) malloc(SzD * vtxcnt);
                        TPc->y = (double *) malloc(SzD * vtxcnt);
                        for(jj = 0; jj<vtxcnt; jj++)
                           {
                           TPc->x[jj] = PolyFromFile.x[jj];
                           TPc->y[jj] = PolyFromFile.y[jj];
                           }
                        TPc->numverts = vtxcnt;
                        TPc->next = TPredraw;
                        TPredraw = TPc;
                        }
                    if(DrawHighlightedOnly == 0)
			 /***MapDrawPoly(1,PolyFromFile.x,PolyFromFile.y,
				     vtxcnt,minx, miny, maxx, maxy, drawcolor,1);***/
                         MAPdrawpoly(vtxcnt,PolyFromFile.x, PolyFromFile.y,drawcolor,0,1,1,PolyFromFile.SACindex);
                     }
                  ++valuesread;
                  free(PolyFromFile.x);
                  free(PolyFromFile.y);
                  free(PolyFromFile.z);
                  
                  AbortDraw = AbortZoom();
                  if(AbortDraw == 1)
                     {
                     fclose(modelPin);
                     modelPin = NULL;
                     FreeLongList(&LongListRoot);
                     LongListRoot = NULL;
                     free(SkipList);

                     return(AbortDraw);
                     }
                  }
               }
            }
   
         cll = LongListRoot;
         while(cll != NULL)
            {
            fseek(modelPin,cll->fp,SEEK_SET);
            vtxcnt = ReadPolyFromFile(modelPin,multiplier);
   
            Config = PolyFromFile.config;
            Strat = PolyFromFile.stratum;
            Domain = PolyFromFile.domain;

            OKtoUse = 1;
            if(NumLODbands > 0)
               {
               jj = CrsWlk[PolyFromFile.SACindex].LODband;
               if((jj > 0) && (LODindex[jj-1].active < 1))
                  OKtoUse = 0;
               }
   
            if((OKtoUse > 0) && (StratToDraw[Strat] > 0) && (DrawByDomain[Domain] > 0))
               {
               if((Strat == 5) && ((FILL_FLAG == 4) || (FILL_FLAG == 5)))
                  drawcolor = AssignShadedColor(PolyFromFile.idn,PolyFromFile.SACindex,PolyFromFile.x, PolyFromFile.y, PolyFromFile.z,vtxcnt,SA,SB,SC);
               else
                  drawcolor = AssignDrawingColor(PolyFromFile.idn, (unsigned char)Domain, PolyFromFile.SACindex);
               if((NGA_TYPE == 0) && (drawcolor == HighLightColor))
                  {
                  TPc = (struct ThePolys *) (malloc(SzTP));
                  TPc->x = (double *) malloc(SzD * vtxcnt);
                  TPc->y = (double *) malloc(SzD * vtxcnt);
                  for(jj = 0; jj<vtxcnt; jj++)
                     {
                     TPc->x[jj] = PolyFromFile.x[jj];
                     TPc->y[jj] = PolyFromFile.y[jj];
                     }
                  TPc->numverts = vtxcnt;
                  TPc->next = TPredraw;
                  TPredraw = TPc;
                  }
              if(DrawHighlightedOnly == 0)
                   MAPdrawpoly(vtxcnt,PolyFromFile.x, PolyFromFile.y,drawcolor,0,1,1,PolyFromFile.SACindex);
               }
   
   
            cll = cll->next;
            free(PolyFromFile.x);
            free(PolyFromFile.y);
            free(PolyFromFile.z);
            AbortDraw = AbortZoom();
            if(AbortDraw == 1)
               {
               fclose(modelPin);
               modelPin = NULL;
               FreeLongList(&LongListRoot);
               LongListRoot = NULL;
               free(SkipList);

               return(AbortDraw);
               }
            }

         FreeLongList(&LongListRoot);
         LongListRoot = NULL;
  
         fclose(modelPin);
         modelPin = NULL;
         }
      } /** end drawing model library polygons ***/




/** draw any areals in the region **/

   drawthisgeom = 0;
   for(j=0; j<TotalSCC; j++)
      {
      if((SCCtable[j].C == 1) && (DrawByConfig[1] > 0) && (StratToDraw[SCCtable[j].S] > 0))
         {
         drawthisgeom = 1;
         break;
         }
      if((SCCtable[j].C == 15) && (DrawByConfig[15] > 0) && (StratToDraw[SCCtable[j].S] > 0))
         {
         drawthisgeom = 1;
         break;
         }
      }

   arin = fopen(arealsin,"rb");
   filenumber = 0;

   if((arin != NULL) && (drawthisgeom > 0)) 
      {
      FreeLongList(&LongListRoot);
      LongListRoot = NULL;
      for(i=0; i<skiplimit; i++)
         {
         SkipList[i].val = -1;
         SkipList[i].entry = NULL;
         }

      for(index1 = Lindex1; index1 <= Uindex1; index1++)
         {
         for(index2 = Lindex2; index2 <= Uindex2; index2++)
            {
            minx = (int) (index1 * RegionSize);
            maxx = (int) (minx + RegionSize);
            miny = (int) (index2 * RegionSize);
            maxy = (int) (miny + RegionSize);
            compositeindex = (index1 * (MaxYindex + 1)) + index2;
 
            for(i=0; i<ArealTable[compositeindex].numother; i++)
               {
               fo = fileoffset * ArealTable[compositeindex].others[i].filenumber + ArealTable[compositeindex].others[i].fileptr;
               InsertIntoLongList(fo,ArealTable[compositeindex].others[i].filenumber,skiplimit,
                                  &LongListRoot,SkipList,&SkipEntry);
               }

            k = ArealTable[compositeindex].numinside;
            if(k > 0)
               {
               if(ArealTable[compositeindex].filenumber != filenumber)
                  {
                  filenumber = ArealTable[compositeindex].filenumber;
                  sprintf(suffix,"%d",filenumber);
                  strcpy(afilein,arealsin);
                  if(filenumber > 0)
                     strcat(afilein,suffix);
                  fclose(arin);
                  arin = fopen(afilein,"rb");
                  if(arin == NULL)
                     {
                     printf("7 area feature data input file %s could not be opened for read\n",afilein);
                     exit(-1);
                     }
                  }
               fseek(arin,ArealTable[compositeindex].fileptr,SEEK_SET);
               i = 0;
               while(i < k)
                  {
                  j = ReadArealFromFile(arin, multiplier);
                  ++i;

                  Config = ArealFromFile.config;
                  Strat = ArealFromFile.stratum;
                  Domain = ArealFromFile.domain;

                  OKtoUse = 1;
                  if(NumLODbands > 0)
                     {
                     jj = CrsWlk[ArealFromFile.Lindex].LODband;
                     if((jj > 0) && (LODindex[jj-1].active < 1))
                        OKtoUse = 0;
                     }
                  if((OKtoUse > 0) && (StratToDraw[Strat] > 0) && (DrawByDomain[Domain] > 0)&& (DrawByConfig[Config] > 0))
                     {
                     drawcolor = AssignDrawingColor(ArealFromFile.idn, (unsigned char)Domain, ArealFromFile.Lindex);
                     /***if((FILL_FLAG == 1) || (FILL_FLAG == 3)) ***/
                     if(DrawAreaFilled(ArealFromFile.Lindex) > 0)
                        {
                        if(ArealFromFile.ishole == 0)
                           {
                           if((NGA_TYPE == 0) && (drawcolor == HighLightColor))
                              {
                              ARc = (struct RawAreal *) (malloc(SzRA));
                              ARc->x = (double *) malloc(SzD * ArealFromFile.numverts);
                              ARc->y = (double *) malloc(SzD * ArealFromFile.numverts);
                              for(jj = 0; jj<ArealFromFile.numverts; jj++)
                                 {
                                 ARc->x[jj] = ArealFromFile.x[jj];
                                 ARc->y[jj] = ArealFromFile.y[jj];
                                 }
                              ARc->numverts = ArealFromFile.numverts;
                              ARc->Lindex = ArealFromFile.Lindex;
                              ARc->next = ARredraw;
                              ARredraw = ARc;
                              }
                          if(DrawHighlightedOnly == 0)
                              MAPdrawpoly(ArealFromFile.numverts,ArealFromFile.x, ArealFromFile.y,drawcolor,0,1,1,ArealFromFile.Lindex);
                           }
                        else if(ArealFromFile.ishole < 0)  /** is a parent, outer ring ***/
                           {
                           MakeArealWithHole(SzAH, SzAR, (unsigned char) Domain,ArealTable[compositeindex].fileptr+i);
                           }
                        else if(ArealFromFile.ishole >= 1)  /** is a cut-out, inner ring ***/
                           {
                           MakeArealWithHole(SzAH, SzAR, (unsigned char) Domain,ArealTable[compositeindex].fileptr);
                           }
                        }
                     else
                        {
                        if((NGA_TYPE == 0) && (drawcolor == HighLightColor))
                           {
                           ARc = (struct RawAreal *) (malloc(SzRA));
                           ARc->x = (double *) malloc(SzD * ArealFromFile.numverts);
                           ARc->y = (double *) malloc(SzD * ArealFromFile.numverts);
                           for(jj = 0; jj<ArealFromFile.numverts; jj++)
                              {
                              ARc->x[jj] = ArealFromFile.x[jj];
                              ARc->y[jj] = ArealFromFile.y[jj];
                              }
                           ARc->numverts = ArealFromFile.numverts;
                           ARc->Lindex = ArealFromFile.Lindex;
                           ARc->next = ARredraw;
                           ARredraw = ARc;
                           }
                       if(DrawHighlightedOnly == 0)
                            MAPdrawpoly(ArealFromFile.numverts,ArealFromFile.x, ArealFromFile.y,drawcolor,0,1,1,ArealFromFile.Lindex);
                        }
                     }
               
                  AbortDraw = AbortZoom();
                  if(AbortDraw == 1)
                     {
                     fclose(arin);
                     arin = NULL;
                     FreeLongList(&LongListRoot);
                     LongListRoot = NULL;
                     free(SkipList);

                     return(AbortDraw);
                     }
                  }
               }
            }

         SendAreaAndHoles(index1, minx, miny, maxx, maxy); 

         }

  
      cll = LongListRoot;
      while(cll != NULL)
         {
         if(cll->fn != filenumber)
            {
            filenumber = cll->fn;
            sprintf(suffix,"%d",filenumber);
            strcpy(afilein,arealsin);
            if(filenumber > 0) 
               strcat(afilein,suffix);
            fclose(arin);
            arin = fopen(afilein,"rb");
            if(arin == NULL)
               {
               printf("8 area feature data input file %s could not be opened for read\n",afilein);
               exit(-1);
               }
            }
         fo = cll->fp - (fileoffset * cll->fn);
         fseek(arin,fo,SEEK_SET);

         j = ReadArealFromFile(arin, multiplier);

         Config = ArealFromFile.config;
         Strat = ArealFromFile.stratum;
         Domain = ArealFromFile.domain;

         OKtoUse = 1;
         if(NumLODbands > 0)
            {
            jj = CrsWlk[ArealFromFile.Lindex].LODband;
            if((jj > 0) && (LODindex[jj-1].active < 1))
               OKtoUse = 0;
            }


         if((OKtoUse > 0) && (StratToDraw[Strat] > 0) && (DrawByDomain[Domain] > 0)&& (DrawByConfig[Config] > 0))
            {
            drawcolor = AssignDrawingColor(ArealFromFile.idn, (unsigned char)Domain, ArealFromFile.Lindex);
            if(DrawAreaFilled(ArealFromFile.Lindex) > 0)
               {
               if(ArealFromFile.ishole == 0)
                  {
                  if((NGA_TYPE == 0) && (drawcolor == HighLightColor))
                     {
                     ARc = (struct RawAreal *) (malloc(SzRA));
                     ARc->x = (double *) malloc(SzD * ArealFromFile.numverts);
                     ARc->y = (double *) malloc(SzD * ArealFromFile.numverts);
                     for(jj = 0; jj<ArealFromFile.numverts; jj++)
                        {
                        ARc->x[jj] = ArealFromFile.x[jj];
                        ARc->y[jj] = ArealFromFile.y[jj];
                        }
                     ARc->numverts = ArealFromFile.numverts;
                     ARc->Lindex = ArealFromFile.Lindex;
                     ARc->next = ARredraw;
                     ARredraw = ARc;
                     }
                 if(DrawHighlightedOnly == 0)
                      MAPdrawpoly(ArealFromFile.numverts,ArealFromFile.x, ArealFromFile.y,drawcolor,0,1,1,ArealFromFile.Lindex);
                  }
               else if(ArealFromFile.ishole < 0)  /** is a parent, outer ring ***/
                  {
                  MakeArealWithHole(SzAH, SzAR, (unsigned char) Domain,fo);
                  }
               else if(ArealFromFile.ishole >= 1)  /** is a cut-out, inner ring ***/
                  {
                  MakeArealWithHole(SzAH, SzAR, (unsigned char) Domain,fo);
                  }
               }
            else
               {
               if((NGA_TYPE == 0) && (drawcolor == HighLightColor))
                  {  
                  ARc = (struct RawAreal *) (malloc(SzRA));
                  ARc->x = (double *) malloc(SzD * ArealFromFile.numverts);
                  ARc->y = (double *) malloc(SzD * ArealFromFile.numverts);
                  for(jj = 0; jj<ArealFromFile.numverts; jj++)
                     {     
                     ARc->x[jj] = ArealFromFile.x[jj];
                     ARc->y[jj] = ArealFromFile.y[jj];
                     }        
                  ARc->numverts = ArealFromFile.numverts;
                  ARc->Lindex = ArealFromFile.Lindex;
                  ARc->next = ARredraw;
                  ARredraw = ARc;
                  }        
              if(DrawHighlightedOnly == 0)
                 MAPdrawpoly(ArealFromFile.numverts,ArealFromFile.x, ArealFromFile.y,drawcolor,0,1,1,ArealFromFile.Lindex);
               }
            }

         cll = cll->next;

         AbortDraw = AbortZoom();
         if(AbortDraw == 1)
            {
            fclose(arin);
            arin = NULL;
            FreeLongList(&LongListRoot);
            LongListRoot = NULL;
            free(SkipList);
            return(AbortDraw);
            }
         }

      FreeLongList(&LongListRoot);

      minx = (int) (Lindex1 * RegionSize);
      maxx = (int) (Uindex1 * RegionSize);
      miny = (int) (Lindex2 * RegionSize);
      maxy = (int) (Uindex2 * RegionSize);
      SendAreaAndHoles(MaxXindex, minx, miny, maxx, maxy);
      }

   if(arin != NULL)
      {
      if(NGA_TYPE == 1)
         CombIntDrawingLayers(C_AREA);
      fclose(arin);
      }


/** draw any linears in the region **/
   if(LinearFromFile.MaxNodes == 0)
      {
      LinearFromFile.MaxNodes = 1000;
      LinearFromFile.x = (double *) (malloc(LinearFromFile.MaxNodes * SzD));
      LinearFromFile.y = (double *) (malloc(LinearFromFile.MaxNodes * SzD));
      LinearFromFile.z = (double *) (malloc(LinearFromFile.MaxNodes * SzD));
      }

   drawthisgeom = 0;
   for(j=0; j<TotalSCC; j++)
      {
      if((SCCtable[j].C == 2) && (DrawByConfig[2] > 0) && (StratToDraw[SCCtable[j].S] > 0))
         {
         drawthisgeom = 1;
         break;
         }
      if((SCCtable[j].C == 4) && (DrawByConfig[4] > 0) && (StratToDraw[SCCtable[j].S] > 0))
         {
         drawthisgeom = 1;
         break;
         }
      if((SCCtable[j].C == 14) && (DrawByConfig[14] > 0) && (StratToDraw[SCCtable[j].S] > 0))
         {
         drawthisgeom = 1;
         break;
         }
      }

   linin = fopen(linearsin,"rb");
   filenumber = 0;

   if((linin != NULL) && (drawthisgeom > 0))
      {
      FreeLongList(&LongListRoot);
      for(i=0; i<skiplimit; i++)
         {
         SkipList[i].val = -1;
         SkipList[i].entry = NULL;
         }

      for(index1 = Lindex1; index1 <= Uindex1; index1++)
         {
         for(index2 = Lindex2; index2 <= Uindex2; index2++)
            {

            minx = (int) (index1 * RegionSize);
            maxx = (int) (minx + RegionSize);
            miny = (int) (index2 * RegionSize);
            maxy = (int) (miny + RegionSize);

            compositeindex = (index1 * (MaxYindex + 1)) + index2;

            for(i=0; i<LinearTable[compositeindex].numother; i++)
               {
               fo = fileoffset * LinearTable[compositeindex].others[i].filenumber + LinearTable[compositeindex].others[i].fileptr;
               InsertIntoLongList(fo,LinearTable[compositeindex].others[i].filenumber,skiplimit,
                                  &LongListRoot,SkipList,&SkipEntry);
               }

            k = LinearTable[compositeindex].numinside;
            if(k > 0)
               {
               if(LinearTable[compositeindex].filenumber != filenumber)
                  {
                  filenumber = LinearTable[compositeindex].filenumber;
                  sprintf(suffix,"%d",filenumber);
                  strcpy(afilein,linearsin);
                  if(filenumber > 0)
                     strcat(afilein,suffix);
                  fclose(linin);
                  linin = fopen(afilein,"rb");
                  if(linin == NULL)
                     {
                     printf("5 linear data input file %s could not be opened for read\n",afilein);
                     exit(-1);
                     }
                  }
               fseek(linin,LinearTable[compositeindex].fileptr,SEEK_SET);
               i = 0;
               while(i < k)
                  {
                  j = ReadLinearFromFile(linin, multiplier);
                  ++i;
                  if(j > 0)
                     {
                     Config = LinearFromFile.config;
                     Strat = LinearFromFile.stratum;
                     Domain = LinearFromFile.domain;

                     OKtoUse = 1;
                     if(NumLODbands > 0)
                        {
                        jj = CrsWlk[LinearFromFile.Lindex].LODband;
                        if((jj > 0) && (LODindex[jj-1].active < 1))
                           OKtoUse = 0;
                        }

                     if((OKtoUse > 0) && (DrawByConfig[Config] > 0) && (StratToDraw[Strat] > 0) && (DrawByDomain[Domain] > 0))
                        {
                        drawcolor = AssignDrawingColor(LinearFromFile.idn, (unsigned char)Domain, LinearFromFile.Lindex);
                        /***if(drawcolor == HighLightColor) ***/
                        if((NGA_TYPE == 0) && (drawcolor == HighLightColor))
                           {
                           RLc = (struct RawLinear *) (malloc(SzRL));
                           RLc->x = (double *) malloc(SzD * LinearFromFile.numnodes);
                           RLc->y = (double *) malloc(SzD * LinearFromFile.numnodes);
                           for(jj = 0; jj<LinearFromFile.numnodes; jj++)
                              {
                              RLc->x[jj] = LinearFromFile.x[jj];
                              RLc->y[jj] = LinearFromFile.y[jj];
                              }
                           RLc->length = LinearFromFile.length;
                           RLc->numnodes = LinearFromFile.numnodes;
                           RLc->next = RLredraw;
                           RLredraw = RLc;
                           }
                       if(DrawHighlightedOnly == 0)
                             MAPdrawfullline(LinearFromFile.x,LinearFromFile.y,LinearFromFile.numnodes,drawcolor,LinearFromFile.Lindex);
                        }
                     }
               
                  AbortDraw = AbortZoom();
                  if(AbortDraw == 1)
                     {
                     fclose(linin);
                     linin = NULL;
                     FreeLongList(&LongListRoot);
                     LongListRoot = NULL;
                     free(SkipList);
                     return(AbortDraw);
                     }
                  }
               }
            }
         }
      cll = LongListRoot;
      while(cll != NULL)
         {
         if(cll->fn != filenumber)
            {
            filenumber = cll->fn;
            sprintf(suffix,"%d",filenumber);
            strcpy(afilein,linearsin);
            if(filenumber > 0)
              strcat(afilein,suffix);
            fclose(linin);
            linin = fopen(afilein,"rb");
            if(linin == NULL)
               {
               printf("6 linear data input file %s could not be opened for read\n",afilein);
               exit(-1);
               }
            }
         fo = cll->fp - (fileoffset * cll->fn);
         fseek(linin,fo,SEEK_SET);

         j = ReadLinearFromFile(linin, multiplier);
         if(j > 0)
            {
            Config = LinearFromFile.config;
            Strat = LinearFromFile.stratum;
            Domain = LinearFromFile.domain;
            ++i;

            OKtoUse = 1;
            if(NumLODbands > 0)
               {
               jj = CrsWlk[LinearFromFile.Lindex].LODband;
               if((jj > 0) && (LODindex[jj-1].active < 1))
                  OKtoUse = 0;
               }

            if((OKtoUse > 0) && (DrawByConfig[Config] > 0) && (StratToDraw[Strat] > 0) && (DrawByDomain[Domain] > 0))
               {
               drawcolor = AssignDrawingColor(LinearFromFile.idn, (unsigned char)Domain, LinearFromFile.Lindex);
               if((NGA_TYPE == 0) && (drawcolor == HighLightColor))
                  {
                  RLc = (struct RawLinear *) (malloc(SzRL));
                  RLc->x = (double *) malloc(SzD * LinearFromFile.numnodes);
                  RLc->y = (double *) malloc(SzD * LinearFromFile.numnodes);
                  for(jj = 0; jj<LinearFromFile.numnodes; jj++)
                     {
                     RLc->x[jj] = LinearFromFile.x[jj];
                     RLc->y[jj] = LinearFromFile.y[jj];
                     }
                  RLc->numnodes = LinearFromFile.numnodes;
                  RLc->next = RLredraw;
                  RLredraw = RLc;
                  }
              if(DrawHighlightedOnly == 0)
                    MAPdrawfullline(LinearFromFile.x,LinearFromFile.y,LinearFromFile.numnodes,drawcolor,LinearFromFile.Lindex);
               }
            }

         AbortDraw = AbortZoom();
         if(AbortDraw == 1)
            {
            fclose(linin);
            linin = NULL;
            FreeLongList(&LongListRoot);
            LongListRoot = NULL;
            free(SkipList);
            return(AbortDraw);
            }


         cll = cll->next;
         }

      FreeLongList(&LongListRoot);
      }
   if(linin != NULL)
      {
      if(NGA_TYPE == 1)
         CombIntDrawingLayers(C_LINE);
      fclose(linin);
      }


/** draw any points in the region **/
   drawthisgeom = 0;
   for(j=0; j<TotalSCC; j++)
      {
      if((SCCtable[j].C == 3) && (StratToDraw[SCCtable[j].S] > 0))
         {
         drawthisgeom = 1;
         break;
         }
      else if((SCCtable[j].C == 5) && (StratToDraw[SCCtable[j].S] > 0))
         {
         drawthisgeom = 1;
         break;
         }
      else if((SCCtable[j].C == 6) && (StratToDraw[SCCtable[j].S] > 0))
         {
         drawthisgeom = 1;
         break;
         }
      else if((SCCtable[j].C == 10) && (StratToDraw[SCCtable[j].S] > 0))
         {
         drawthisgeom = 1;
         break;
         }
      else if((SCCtable[j].C == 11) && (StratToDraw[SCCtable[j].S] > 0))
         {
         drawthisgeom = 1;
         break;
         }
      else if((SCCtable[j].C == 13) && (StratToDraw[SCCtable[j].S] > 0))  /** tim **/
         {
         drawthisgeom = 1;
         break;
         }
      }

   index1 = 0;
   if(drawthisgeom > 0)
      {
      index1 = DrawByConfig[3] + DrawByConfig[5] + DrawByConfig[6];
      index1 += DrawByConfig[10] + DrawByConfig[11] + DrawByConfig[13];  /** tim **/
      }
   ptsin = NULL;
   if(index1 > 0)
      ptsin = fopen(pointsin,"rb");
   if(ptsin != NULL)
      {
      for(index1 = Lindex1; index1 <= Uindex1; index1++)
         {
         for(index2 = Lindex2; index2 <= Uindex2; index2++)
            {

            minx = (int) (index1 * RegionSize);
            maxx = (int) (minx + RegionSize);
            miny = (int) (index2 * RegionSize);
            maxy = (int) (miny + RegionSize);

            compositeindex = (index1 * (MaxYindex + 1)) + index2;

            k = PointTable[compositeindex].numinside + PointTable[compositeindex].numother;
            if(k > 0)
               {
               fseek(ptsin,PointTable[compositeindex].fileptr,SEEK_SET);
               ii = i = 0;
               while(i < k)
                  {
                  if(i >= PointTable[compositeindex].numinside)
                     {
                     fseek(ptsin,PointTable[compositeindex].others[ii].fileptr,SEEK_SET);
                     ++ii;
                     }
                  vtxcnt = ReadPointFromFile(ptsin, multiplier);
                  Config = PointFromFile.config;
                  Strat = PointFromFile.stratum;
                  Domain = PointFromFile.domain;

                  OKtoUse = 1;
                  if(NumLODbands > 0)
                     {
                     jj = CrsWlk[PointFromFile.Lindex].LODband;
                     if((jj > 0) && (LODindex[jj-1].active < 1))
                        OKtoUse = 0;
                     }

                  if((OKtoUse > 0) && (DrawByConfig[Config] > 0) && (StratToDraw[Strat] > 0) && (DrawByDomain[Domain] > 0)) 
                     {
                     drawcolor = AssignDrawingColor(PointFromFile.idn, (unsigned char)Domain, PointFromFile.Lindex);
                     if((NGA_TYPE == 0) && (drawcolor == HighLightColor))
                        {
                        RPc = (struct RawPoint *) (malloc(SzRP));
                        if((PointFromFile.numverts < 1) && (PointFromFile.numverts > -3))
                           {
                           RPc->x = (double *) malloc(SzD);
                           RPc->y = (double *) malloc(SzD);
                           RPc->x[0] = PointFromFile.x[0];
                           RPc->y[0] = PointFromFile.y[0];
                           }
                        else if (PointFromFile.numverts < -2)
                           {
                           RPc->x = (double *) malloc(SzD * vtxcnt);
                           RPc->y = (double *) malloc(SzD * vtxcnt);
                           for(jj = 0; jj<vtxcnt; jj++)
                              {
                              RPc->x[jj] = PointFromFile.x[jj];
                              RPc->y[jj] = PointFromFile.y[jj];
                              }
                           }
                        else
                           {
                           RPc->x = (double *) malloc(SzD * PointFromFile.numverts);
                           RPc->y = (double *) malloc(SzD * PointFromFile.numverts);
                           for(jj = 0; jj<PointFromFile.numverts; jj++)
                              {
                              RPc->x[jj] = PointFromFile.x[jj];
                              RPc->y[jj] = PointFromFile.y[jj];
                              }
                           }
                        RPc->numverts = PointFromFile.numverts;
                        RPc->rad = PointFromFile.rad;
                        RPc->next = RPredraw;
                        RPredraw = RPc;
                        }
                    if(DrawHighlightedOnly == 0)
                      {
		      if(PointFromFile.numverts == -1)
                           MAPdrawX(PointFromFile.x[0],PointFromFile.y[0],drawcolor,PointFromFile.Lindex);
                      else if((PointFromFile.numverts == 0) || (PointFromFile.numverts == -2))
                        {
                        MAPdrawcircle(PointFromFile.x[0],PointFromFile.y[0],PointFromFile.rad*2.0,drawcolor,PointFromFile.Lindex); 
                        }
                      else
                        MAPdrawpoly(1,PointFromFile.x, PointFromFile.y,drawcolor,0,1,1,PointFromFile.Lindex);
                       }
                     }
                  ++i;
               
                  AbortDraw = AbortZoom();
                  if(AbortDraw == 1)
                     {
                     fclose(ptsin);
                     ptsin = NULL;
                     FreeLongList(&LongListRoot);
                     LongListRoot = NULL;
                     free(SkipList);

                     return(AbortDraw);
                     }
                  }
               }

            }
         }
      if(NGA_TYPE == 1)
         CombIntDrawingLayers(C_POFE);
      fclose(ptsin);
      }

/** draw any bridges in the region **/
   drawthisgeom = 0;
   if(NGA_TYPE == 0)
      {
      for(j=0; j<TotalSCC; j++)
         {
         if((SCCtable[j].C == 3) && (StratToDraw[SCCtable[j].S] > 0))
            {
            drawthisgeom = 1;
            break;
            }
         else if((SCCtable[j].C == 5) && (StratToDraw[SCCtable[j].S] > 0))
            {
            drawthisgeom = 1;
            break;
            }
         else if((SCCtable[j].C == 6) && (StratToDraw[SCCtable[j].S] > 0))
            {
            drawthisgeom = 1;
            break;
            }
         }
      }
   index1 = 0;
   brdgin = NULL;
   if(drawthisgeom > 0)
      index1 = DrawByConfig[3] + DrawByConfig[5] + DrawByConfig[6];
   if(index1 > 0)
      brdgin = fopen(bridgesin,"rb");
   if(brdgin != NULL)
      {
      for(index1 = Lindex1; index1 <= Uindex1; index1++)
         {
         for(index2 = Lindex2; index2 <= Uindex2; index2++)
            {

            minx = (int) (index1 * RegionSize);
            maxx = (int) (minx + RegionSize);
            miny = (int) (index2 * RegionSize);
            maxy = (int) (miny + RegionSize);

            compositeindex = (index1 * (MaxYindex + 1)) + index2;

            k = BridgeTable[compositeindex].numinside + BridgeTable[compositeindex].numother;
            if(k > 0)
               {
               fseek(brdgin,BridgeTable[compositeindex].fileptr,SEEK_SET);
               ii = i = 0;
               while(i < k)
                  {
                  if(i >= BridgeTable[compositeindex].numinside)
                     {
                     fseek(brdgin,BridgeTable[compositeindex].others[ii].fileptr,SEEK_SET);
                     ++ii;
                     }
                  vtxcnt = ReadBridgeFromFile(brdgin, multiplier);
                  Config = BridgeFromFile.config;
                  Strat = BridgeFromFile.stratum;
                  Domain = BridgeFromFile.domain;

                  OKtoUse = 1;
                  if(NumLODbands > 0)
                     {
                     jj = CrsWlk[BridgeFromFile.Lindex].LODband;
                     if((jj > 0) && (LODindex[jj-1].active < 1))
                        OKtoUse = 0;
                     }

                  if((OKtoUse > 0) && (DrawByConfig[Config] > 0) && (StratToDraw[Strat] > 0) && (DrawByDomain[Domain] > 0))
                     {
                     drawcolor = AssignDrawingColor(BridgeFromFile.idn, (unsigned char)Domain, BridgeFromFile.Lindex);
                     /***if(drawcolor == HighLightColor) ***/
                     if((NGA_TYPE == 0) && (drawcolor == HighLightColor))
                        {
                        RBc = (struct RawBridge *) (malloc(SzRB));
                        RBc->x = (double *) malloc(SzD * BridgeFromFile.numverts);
                        RBc->y = (double *) malloc(SzD * BridgeFromFile.numverts);
                        for(jj = 0; jj<BridgeFromFile.numverts; jj++)
                           {
                           RBc->x[jj] = BridgeFromFile.x[jj];
                           RBc->y[jj] = BridgeFromFile.y[jj];
                           }
                        RBc->numverts = BridgeFromFile.numverts;
                        RBc->next = RBredraw;
                        RBredraw = RBc;
                        }
                    if(DrawHighlightedOnly == 0)
                         MAPdrawpoly(BridgeFromFile.numverts,BridgeFromFile.x, BridgeFromFile.y,drawcolor,0,1,1,BridgeFromFile.Lindex);
                     }
                  free(BridgeFromFile.x);
                  free(BridgeFromFile.y);
                  free(BridgeFromFile.z);
                  free(BridgeFromFile.h);
                  ++i;
               
                  AbortDraw = AbortZoom();
                  if(AbortDraw == 1)
                     {
                     fclose(brdgin);
                     brdgin = NULL;
                     FreeLongList(&LongListRoot);
                     LongListRoot = NULL;
                     free(SkipList);

                     return(AbortDraw);
                     }
                  }
               }

            }
         }
      fclose(brdgin);
      }
   if(NGA_TYPE == 0)
      {
      if(TPredraw != NULL)
         {
         TPc = TPredraw;
         while(TPc->next != NULL)
            {
            TPc = TPc->next;
            }
         TPc->next = *TPredrawRT;
         *TPredrawRT = TPredraw;
         }
      if(ARredraw != NULL)
         {
         ARc = ARredraw;
         while(ARc->next != NULL)
            {
            ARc = ARc->next;
            }
         ARc->next = *ARredrawRT;
         *ARredrawRT = ARredraw;
         }
      if(RLredraw != NULL)
         {
         RLc = RLredraw;
         while(RLc->next != NULL)
            {
            RLc = RLc->next;
            }
         RLc->next = *RLredrawRT;
         *RLredrawRT = RLredraw;
         }
      if(RPredraw != NULL)
         {
         RPc = RPredraw;
         while(RPc->next != NULL)
            {
            RPc = RPc->next;
            }
         RPc->next = *RPredrawRT;
         *RPredrawRT = RPredraw;
         }
      if(RBredraw != NULL)
         {
         RBc = RBredraw;
         while(RBc->next != NULL)
            {
            RBc = RBc->next;
               }
         RBc->next = *RBredrawRT;
         *RBredrawRT = RBredraw;
         }
      }

   free(SkipList);


   return(AbortDraw);
}









void DrawRegionContent(int Lindex1,int Uindex1, int Lindex2, int Uindex2)
{
int Layers[NUM_S];
int i,j;
/**int minx, maxx;**/
/**int miny,maxy; **/
int ClampValueRestore;
int DrawAborted;
struct RawAreal *ARredrawRoot, *ARc, *ARn;
struct RawLinear *RLredrawRoot, *RLc, *RLn;
struct RawPoint *RPredrawRoot, *RPc, *RPn;
struct RawBridge *RBredrawRoot, *RBc, *RBn;
struct ThePolys *TPredrawRoot, *TPc, *TPn;


   ARredrawRoot = NULL;
   RLredrawRoot = NULL;
   RPredrawRoot = NULL;
   RBredrawRoot = NULL;
   TPredrawRoot = NULL;


   ClampValueRestore = CLAMPFEATURES;
   CLAMPFEATURES = 0; /** note that we do not want to incur the expense of clamping if just reading for a 2D drawing ***/

   DrawAborted = 0;

   AHroot = NULL;

   ReadMultiPartObjects();

   for(i=0; i<NUM_S; i++)
      Layers[i] = 0;
   if(DrawByStratum[4] > 0)
      {
      Layers[4] = 1;
      DrawAborted = ExposeLayerOfRegionContent(0,Lindex1,Uindex1, Lindex2, Uindex2, Layers, &ARredrawRoot,
        &RLredrawRoot, &RPredrawRoot, &RBredrawRoot, &TPredrawRoot);
      Layers[4] = 0;
      }
   if((DrawAborted == 0) && (DrawByStratum[3] > 0))
      {
      Layers[3] = 1;
      DrawAborted = ExposeLayerOfRegionContent(0,Lindex1,Uindex1, Lindex2, Uindex2, Layers, &ARredrawRoot,
        &RLredrawRoot, &RPredrawRoot, &RBredrawRoot, &TPredrawRoot);
      Layers[3] = 0;
      }
   if((DrawAborted == 0) && (DrawByStratum[5] > 0))
      {
      Layers[5] = 1;
      /**/DrawAborted = ExposeLayerOfRegionContent(0,Lindex1,Uindex1, Lindex2, Uindex2, Layers, &ARredrawRoot,
        &RLredrawRoot, &RPredrawRoot, &RBredrawRoot, &TPredrawRoot);/**/
      Layers[5] = 0;
      }
   j = 0;
   for(i=0; i<NUM_S; i++)
      {
      if((i >= 3) && (i <= 5))
         Layers[i] = 0;
      else
         {
         Layers[i] = DrawByStratum[i];
         ++j;
         }
      }
   if((DrawAborted == 0) && (j > 0))
      {
      DrawAborted = ExposeLayerOfRegionContent(0,Lindex1,Uindex1, Lindex2, Uindex2, Layers, &ARredrawRoot,
        &RLredrawRoot, &RPredrawRoot, &RBredrawRoot, &TPredrawRoot);
      }


/*** if not NGA type files, draw any highlighted objects as the final layer - also free up assoc memory **/
   if(NGA_TYPE == 0)
      {
      TPc = TPredrawRoot;
      while(TPc != NULL)
         {
         if(DrawAborted == 0)
            MAPdrawpoly(TPc->numverts,TPc->x, TPc->y,HighLightColor,0,1,1,DRAW_NOW);
         free(TPc->x);
         free(TPc->y);
         TPn = TPc;
         TPc = TPc->next;
         free(TPn);
         }
      ARc = ARredrawRoot;
      while(ARc != NULL)
         {
         if(DrawAborted == 0)
            MAPdrawpoly(ARc->numverts,ARc->x, ARc->y,299,/***HighLightColor,**/0,1,1,ARc->Lindex/**DRAW_NOW**/);
         ARn = ARc;
         ARc = ARc->next;
         free(ARn->x);
         free(ARn->y);
         free(ARn);
         }
      RLc = RLredrawRoot;
      while(RLc != NULL)
         {
         if(DrawAborted == 0)
            {
            for(j=1; j<RLc->numnodes; j++)
               MAPdrawline(0,RLc->x[j-1],RLc->y[j-1],RLc->x[j],RLc->y[j],HighLightColor,DRAW_NOW);
            MAPdrawline(1,RLc->x[0],RLc->y[0],RLc->x[1],RLc->y[1],HighLightColor,DRAW_NOW);
               MAPdrawline(2,RLc->x[j-2],RLc->y[j-2],RLc->x[j-1],RLc->y[j-1],HighLightColor,DRAW_NOW);
            }
         RLn = RLc;
         RLc = RLc->next;
         free(RLn->x);
         free(RLn->y);
         free(RLn);
         }
      RPc = RPredrawRoot;
      while(RPc != NULL)
         {
         if(DrawAborted == 0)
            {
            if(RPc->numverts == -1)
               MAPdrawX(RPc->x[0],RPc->y[0],HighLightColor,DRAW_NOW);
            else if((RPc->numverts == 0) || (RPc->numverts == -2))
               MAPdrawcircle(RPc->x[0],RPc->y[0],RPc->rad*2.0,HighLightColor,DRAW_NOW);
            else if(RPc->numverts < -2)
               MAPdrawpoly(0-RPc->numverts,RPc->x, RPc->y,HighLightColor,0,1,1,DRAW_NOW);
            else
               MAPdrawpoly(RPc->numverts,RPc->x, RPc->y,HighLightColor,0,1,1,DRAW_NOW);
            }
         RPn = RPc;
         RPc = RPc->next;
         free(RPn->x);
         free(RPn->y);
         free(RPn);
         }
      RBc = RBredrawRoot;
      while(RBc != NULL)
         {
         MAPdrawpoly(RBc->numverts,RBc->x, RBc->y,HighLightColor,0,1,1,DRAW_NOW);
         RBn = RBc;
         RBc = RBc->next;
         free(RBn->x);
         free(RBn->y);
         free(RBn);
         }
      }

   FreeMultiPartObjects();

   CLAMPFEATURES = ClampValueRestore; /** reset global to value before this function call ***/
}



void PrintIPCitem()
{
int i;
FILE *IPCout;
FILE *CSV;
char ACC[100];
char EXS[100];
char MED[100];
char WD1[100];
char RST[100];
char WTC[100];
char TUC[100];
char LEN[100];
double dist,rise,grade;


   if(IPC.geom == C_GRID)
      return;

   IPCout = fopen("InfoItemList.txt","at");
   CSV = fopen("InfoItemList.csv","at");

   fprintf(IPCout,"%s,%s,",GetECCCode(IPC.ECC),GetECCLabel(IPC.ECC));
   if(IPC.numcoords > 0)
      fprintf(IPCout,"%.1lf, , , , \n",IPC.length);
   else
      fprintf(IPCout,"0, , , , \n");
   strcpy(ACC,"  ");
   strcpy(EXS,"  ");
   strcpy(MED,"  ");
   strcpy(WD1,"  ");
   strcpy(RST,"  ");
   strcpy(WTC,"  ");
   strcpy(TUC,"  ");
   strcpy(LEN,"  ");

   for(i=0; i<IPC.numattr; i++)
      {
      if(strcmp(IPC.A[i].code,"ACC") == 0)
         {
         if(IPC.A[i].valueLabel != NULL)
            strcpy(ACC, IPC.A[i].valueLabel);
         else
            strcpy(ACC, IPC.A[i].value);
         }
      else if(strcmp(IPC.A[i].code,"EXS") == 0)
         {
         if(IPC.A[i].valueLabel != NULL)
            strcpy(EXS, IPC.A[i].valueLabel);
         else
            strcpy(EXS, IPC.A[i].value);
         }
      else if(strcmp(IPC.A[i].code,"MED") == 0)
         {
         if(IPC.A[i].valueLabel != NULL)
            strcpy(MED, IPC.A[i].valueLabel);
         else
            strcpy(MED, IPC.A[i].value);
         }
      else if(strcmp(IPC.A[i].code,"WD1") == 0)
         {
         if(IPC.A[i].valueLabel != NULL)
            strcpy(WD1, IPC.A[i].valueLabel);
         else
            strcpy(WD1, IPC.A[i].value);
         }
      else if(strcmp(IPC.A[i].code,"RST") == 0)
         {
         if(IPC.A[i].valueLabel != NULL)
            strcpy(RST, IPC.A[i].valueLabel);
         else
            strcpy(RST, IPC.A[i].value);
         }
      else if(strcmp(IPC.A[i].code,"WTC") == 0)
         {
         if(IPC.A[i].valueLabel != NULL)
            strcpy(WTC, IPC.A[i].valueLabel);
         else
            strcpy(WTC, IPC.A[i].value);
         }
      else if(strcmp(IPC.A[i].code,"TUC") == 0)
         {
         if(IPC.A[i].valueLabel != NULL)
            strcpy(TUC, IPC.A[i].valueLabel);
         else
            strcpy(TUC, IPC.A[i].value);
         }
      else if(strcmp(IPC.A[i].code,"LEN") == 0)
         {
         if(IPC.A[i].valueLabel != NULL)
            strcpy(LEN, IPC.A[i].valueLabel);
         else
            strcpy(LEN, IPC.A[i].value);
         }
      }

   fprintf(CSV,"%s,%s,",GetECCCode(IPC.ECC),GetECCLabel(IPC.ECC));
   if(IPC.numcoords > 0)
      fprintf(CSV,"%.1lf,",IPC.length);
   else
      fprintf(CSV,"0,");

   fprintf(CSV,"%s,%s,%s,%s,%s,%s,%s,%s\n",ACC,EXS,WD1,TUC,RST,WTC,MED,LEN);
   
   for(i=0; i<IPC.numcoords; i++)
      {
      fprintf(IPCout," , , ,%.4lf,%.4lf,%.2lf,",IPC.X[i]/100000.0 + Xtranslation, IPC.Y[i]/100000.0 + Ytranslation,IPC.Z[i]);
      if(i > 0)
         {
         dist = Distance(IPC.X[i-1],IPC.Y[i-1],IPC.X[i],IPC.Y[i]);
         rise = IPC.Z[i] - IPC.Z[i-1];
         grade = 100.0 * (rise / dist);
         fprintf(IPCout,"%.1lf,%.2lf,%.2lf,",rise,dist,grade);
         }
      else
         fprintf(IPCout," , , ,");
      }

   fclose(IPCout);
   fclose(CSV);
}







void TempInfoPrint(int UniqueID)
{
int i;
extern void NewInfoPrint(int UUID);
struct AreaRing *IPCc, *IPCp;


 IPC.numholes = 0;
 if(IPC.innerings != NULL)
    {
    IPCc = IPC.innerings;
    while(IPCc != NULL)
       {
       IPC.numholes += 1;
       IPCc = IPCc->next;
       }
    }

 NewInfoPrint(UniqueID);




 if(IPC.numcoords > 0)
    {
    free(IPC.X);
    free(IPC.Y);
    free(IPC.Z);

    IPC.numcoords = 0;
    }

 if(IPC.innerings != NULL)
    {
    IPCc = IPC.innerings;
    while(IPCc != NULL)
       {
       IPCp = IPCc;
       if(IPCp->numverts > 0)
          {
          free(IPCp->x);
          free(IPCp->y);
          free(IPCp->z);
          }
       IPCc = IPCc->next;
       free(IPCp);
       }
    IPC.innerings = NULL;
    }


 for(i=0; i<IPC.numattr; i++)
   {
     if(IPC.A[i].code != NULL)
       {
         free(IPC.A[i].code);
         IPC.A[i].code = NULL;
       }

     free(IPC.A[i].Label);
     IPC.A[i].Label = NULL;

     free(IPC.A[i].value);
     IPC.A[i].value = NULL;

     if(IPC.A[i].valueLabel != NULL)
       {
         free(IPC.A[i].valueLabel);
         IPC.A[i].valueLabel = NULL;
       }

     if(IPC.A[i].SEDRISxtra != NULL)
       {
         free(IPC.A[i].SEDRISxtra);
         IPC.A[i].SEDRISxtra = NULL;
       }
   }

 if(IPC.A != NULL)
   {
     free(IPC.A);
     IPC.A = NULL;
   }

 if(IPC.IDstr != NULL)
   {
     free(IPC.IDstr);
     IPC.IDstr = NULL;
   }
}


  

void FillInAttributeFields(int Lindex, FILE * fileptr)
{
int ECC, seeitgeom,numchar;
int EAC, uom, uomscale, SEDRIStype, datatype, Idtvalue, IdtVal2;
int IntervalType;
int i,k;
double Fdtvalue, FdtVal2;
char longtitle[500];
char tc;
int Sindex;


   IPC.longindex = Lindex;

   fseek(fileptr,CrsWlk[Lindex].FullFilePosn,SEEK_SET);

   Sindex = CrsWlk[Lindex].LtoSmapping;

   IPC.domain = SCCtable[Sindex].D;

   SEEIT_fread_int(&ECC,fileptr);
   if(feof(fileptr) == 0)
      {
      SEEIT_fread_int(&seeitgeom,fileptr);
      SEEIT_fread_int(&IPC.numattr,fileptr);
      if(IPC.numattr > 0)
         {
         IPC.A = (struct AStrings *) (malloc(sizeof(struct AStrings) * IPC.numattr));
         if(IPC.A == NULL)
            {
            printf("available memory has been exhausted during attribute printing\n");
            printf("requested memory to print %d attributes\n",IPC.numattr);
            exit(-1);
            }
         }
      else
         IPC.A = NULL;
      for(k=0; k<IPC.numattr; k++)
         {
         SEEIT_fread_int(&EAC,fileptr);

         if(EAC >= 0)
            {
	      if(NGA_TYPE==1)
		{
		  strcpy(MessageLine,GetEACCode(EAC));
		}
	      else
		{
		  strcpy(MessageLine,GetEACLabel(EAC));
		}


            i = strlen(MessageLine);
            IPC.A[k].code = (char *) (malloc(i + 2));
            if(IPC.A[k].code == NULL)
               {
               printf("available memory has been exhausted during alocation for Attribute code of length %d\n",i);
               exit(-1);
               }
            strcpy(IPC.A[k].code,MessageLine);
      
            strcpy(MessageLine,GetEACLabel(EAC));
            i = strlen(MessageLine);
            IPC.A[k].Label = (char *) (malloc(i+1));
            strcpy(IPC.A[k].Label,MessageLine);
            IPC.A[k].valueLabel = NULL;
            IPC.A[k].SEDRISxtra = NULL;

         
            SEEIT_fread_int(&uom,fileptr);
            SEEIT_fread_int(&uomscale,fileptr);
            SEEIT_fread_int(&SEDRIStype,fileptr);
            SEEIT_fread_int(&datatype,fileptr);
            switch(datatype)
               {
               case 0: /** regular integer **/
                  SEEIT_fread_int(&Idtvalue,fileptr);
                  sprintf(MessageLine,"%d",Idtvalue);
                  i = strlen(MessageLine);
                  IPC.A[k].value = (char *) (malloc(i + 1));
                  strcpy(IPC.A[k].value,MessageLine);
                  break;
               case 1: /** a double **/
                  SEEIT_fread_double(&Fdtvalue,fileptr);
                  sprintf(MessageLine,"%lf",Fdtvalue);
                  i = strlen(MessageLine);
                  IPC.A[k].value = (char *) (malloc(i + 1));
                  strcpy(IPC.A[k].value,MessageLine);
                  break;
               case 2: /** a string **/
                  SEEIT_fread_int(&numchar,fileptr);
                  for(i=0; i<numchar; i++)
                     {
                     fread(&tc,1,1,fileptr);
                     MessageLine[i] = tc;
                     }
                  MessageLine[i] = '\0';
                  IPC.A[k].value = (char *) (malloc(i + 2));
                  strcpy(IPC.A[k].value,MessageLine);
                  break;
               case 3: /** enum as int **/
                  SEEIT_fread_int(&Idtvalue,fileptr);
                  sprintf(MessageLine,"%d",Idtvalue);
                  i = strlen(MessageLine);
                  IPC.A[k].value = (char *) (malloc(i + 1));
                  strcpy(IPC.A[k].value,MessageLine);
                  sprintf(MessageLine,"%s",GetEELabel(EAC,Idtvalue));
                  i = strlen(MessageLine); 
                  IPC.A[k].valueLabel = (char *) (malloc(i + 1));
                  strcpy(IPC.A[k].valueLabel,MessageLine);
                  break;
               case 4: /** metada as int **/
                  SEEIT_fread_int(&Idtvalue,fileptr);
                  sprintf(MessageLine,"%d",Idtvalue);
                  i = strlen(MessageLine);
                  IPC.A[k].value = (char *) (malloc(i + 1));
                  strcpy(IPC.A[k].value,MessageLine);
                  break;



               case 5: /** a float interval **/
                  SEEIT_fread_double(&Fdtvalue,fileptr);
                  SEEIT_fread_double(&FdtVal2,fileptr);
                  SEEIT_fread_int(&IntervalType,fileptr);

                  i = strlen(MessageLine);
                  IPC.A[k].value = (char *) (malloc(i + 1));
                  strcpy(IPC.A[k].value,MessageLine);
                     
                  break;




               case 6:
		 SEEIT_fread_int(&Idtvalue,fileptr);
		 SEEIT_fread_int(&IdtVal2,fileptr);
		 SEEIT_fread_int(&IntervalType,fileptr);
		 
		 
		 i = strlen(MessageLine);
		 IPC.A[k].value = (char *) (malloc(i + 1));
		 strcpy(IPC.A[k].value,MessageLine);
		 break;
               case 7:
		 
		 SEEIT_fread_int(&Idtvalue,fileptr);
		 SEEIT_fread_int(&IdtVal2,fileptr);
		 SEEIT_fread_int(&IntervalType,fileptr);
		 
		 sprintf(MessageLine,"\n interval stuff need updating: (%d to %d)\n",Idtvalue,IdtVal2);
		 infoprint(MessageLine);
		 
		 


                  i = strlen(MessageLine);
                  IPC.A[k].value = (char *) (malloc(i + 1));
                  strcpy(IPC.A[k].value,MessageLine);
                  break;
               }
            if(NGA_TYPE != 1)
               {
               if((datatype < 2) || (datatype > 4))
                  {
                  sprintf(MessageLine,"   units: %s scale: %s\n",GetUnitsLabel(uom),GetScaleLabel(uomscale));
                  i = strlen(MessageLine);
                  IPC.A[k].SEDRISxtra = (char *) (malloc(i + 1));
                  strcpy(IPC.A[k].SEDRISxtra,MessageLine);
                  }
               }
            }
         else
            {
            SEEIT_fread_int(&numchar,fileptr);
            if(numchar < 499)
               fread(&longtitle[0],1,numchar,fileptr);
            longtitle[numchar] = '\0';

            IPC.A[k].code = (char *) (malloc(2));
            IPC.A[k].code[0] = ' ';
            IPC.A[k].code[1] = '\0';

            IPC.A[k].value = (char *) (malloc(2));
            IPC.A[k].value[0] = ' ';
            IPC.A[k].value[1] = '\0';

            IPC.A[k].SEDRISxtra = NULL;

            if(EAC == -1)
               {
               if(NGA_TYPE == 1)
                  {
                  IPC.A[k].Label = (char *) (malloc(7));
                  strcpy(IPC.A[k].Label,"*Layer");
                  }
               else
                  {
                  IPC.A[k].Label = (char *) (malloc(5));
                  strcpy(IPC.A[k].Label,"*LOD");
                  }
               }
            else if(EAC == -2)
               {
               IPC.A[k].Label = (char *) (malloc(12));
               strcpy(IPC.A[k].Label,"*Model Name");
               }
            else if(EAC == -3)
               {
               IPC.A[k].Label = (char *) (malloc(14));
               strcpy(IPC.A[k].Label,"*Polygon Flag");
               }

            IPC.A[k].valueLabel = (char *) (malloc(numchar + 2));
            strcpy(IPC.A[k].valueLabel,longtitle);
            }
         } /** end for number of attributes **/
      }
}



int DoCareAboutEntry(int code, int fcode, char geom)
{
int answer;

   answer = 0;

   ACBMc = ACBMroot;
   while(ACBMc != NULL)
      {
      if(ACBMc->acode == code)
         {
         if((ACBMc->fcode == -999) || (ACBMc->fcode == fcode))
            {
            if((ACBMc->fgeom == 'Z') || (ACBMc->fgeom == geom))
               {
               if(ACBMc->allow_nunanpo > 0)
                  {
                  answer = ACBMc->allow_nunanpo + 1; /*** the value should be 2 for allow all nunanpo and 3 for all less 'Unknown' ***/
                  }
               else
                  answer = 1;
               break;
               }
            }
         }
      ACBMc = ACBMc->next;
      }
   
   return(answer);
}





void CountConnectingNodeInts(int ECC, int NodePresent)
{
int SzMCVL = sizeof(struct MasterCandVlist);
struct MasterCandVlist *cvl, /**   *cvthis,**/ *cvp, *cvn;

   if(CV_Master == NULL)
      {
      cvl = (struct MasterCandVlist *) (malloc(SzMCVL));
      cvl->ECC = ECC;
      cvl->code = -99;
      cvl->ismeta = 0;
      cvl->match = 0;
      cvl->nomatch = 0;
      if(NodePresent > 0)
         cvl->match = 1;
      else
         cvl->nomatch = 1;
      cvl->islen = 0;
      cvl->value = 0;
      cvl->strval = NULL;
      cvl->next = NULL;
      CV_Master = cvl;
      }
   else
      {
      cvl = cvp = CV_Master;
      while((cvl!= NULL) && (ECC < cvl->ECC))
         {
         cvp = cvl;
         cvl = cvl->next;
         }
      if((cvl != NULL) && (cvl->ECC == ECC))
         {
         if(NodePresent > 0)
            cvl->match += 1;
         else
            cvl->nomatch += 1;
         }
      else
         {
         cvn = (struct MasterCandVlist *) (malloc(SzMCVL));
         cvn->ECC = ECC;
         cvn->code = -99;
         cvn->ismeta = 0;
         cvn->match = 0;
         cvn->nomatch = 0;
         if(NodePresent > 0)
            cvn->match = 1;
         else
            cvn->nomatch = 1;
         cvn->islen = 0;
         cvn->value = 0;
         cvn->strval = NULL;
         if(cvl == CV_Master)
            {
            cvn->next = CV_Master;
            CV_Master = cvn;
            }
         else
            {
            cvp->next = cvn;
            cvn->next = cvl;
            }
         }
      }
   return;
}





int AddToSameAttrAndVals(char geom, int ECC, struct CodesAndValue * CV1, struct CodesAndValue * CV2)
{
int i,j, answer, checkit, retval,noted;
int howtocheck;
int FakeECC = -99;
/**int MetaDataCounts = 1; **/
int SzMCVL = sizeof(struct MasterCandVlist);
struct MasterCandVlist *cvl, *cvthis, *cvp, *cvn;


   checkit = 1;
   retval = 0;
   noted = 0;
   strcpy(BndAttrMismatch,"Attribute Mismatch: ");
   for(i=0; i<CV1->numttl; i++)
      {
      howtocheck = checkit = 0;
      if(CV1->cv[i].code >= 0)
         {
         howtocheck = DoCareAboutEntry(CV1->cv[i].code,ECC,geom);
         }
      if(howtocheck > 0)
         {
         answer = 0;
         checkit = 1;
         for(j=0; j<CV2->numttl; j++)
            {
            if(CV1->cv[i].code == CV2->cv[j].code)
               {
               if((CV1->cv[i].strval != NULL) && (CV2->cv[j].strval != NULL) && (strcmp(CV1->cv[i].strval,CV2->cv[j].strval) == 0))
                  {
                  answer = 1;
                  break;
                  }
               else if((CV1->cv[i].strval == NULL) && (CV2->cv[j].strval == NULL) && (CV1->cv[i].value == CV2->cv[j].value))
                  {
                  answer = 1;
                  break;
                  }
               else if(howtocheck >= 2)
                  {
                  if((IsFlakeyNUNANPOvalue(CV1->cv[i].strval,CV1->cv[i].value,howtocheck) > 0) ||
                      (IsFlakeyNUNANPOvalue(CV2->cv[j].strval,CV2->cv[j].value,howtocheck) > 0))
                     {
                     answer = 1;
                     break;
                     }
                  }
               }
            }
         }
      else
         checkit = 0;

      if(checkit > 0)
         {
         if(CV_Master == NULL)
            {
            checkit = 0;
            cvl = (struct MasterCandVlist *) (malloc(SzMCVL));
            cvl->ECC = ECC;
            cvl->code = CV1->cv[i].code;
            cvl->ismeta = CV1->cv[i].ismeta;
            if(answer == 1)
               {
               cvl->match = 1;
               cvl->nomatch = 0;
               }
            else
               {
               cvl->match = 0;
               cvl->nomatch = 1;
               if(noted == 0)
                  {
                  strcat(BndAttrMismatch," ");
                  strcat(BndAttrMismatch,GetEACCode(cvl->code));
                  ++noted;
                  }
               else
                  {
                  noted = 0;
                  }
               retval = 1;
               /**if(DontCareCode(CV1->cv[i].code,ECC,geom) == 0)
                  retval = 0;**/
               }
            cvl->next = NULL;
            if(CV1->cv[i].strval != NULL)
               {
               cvl->strval = (char *) malloc(strlen(CV1->cv[i].strval) + 1);
               strcpy(cvl->strval,CV1->cv[i].strval);
               }
            else
               {
               cvl->strval = NULL;
               cvl->value = CV1->cv[i].value;
               }
            CV_Master = cvl;

            cvl = (struct MasterCandVlist *) (malloc(SzMCVL));
            cvl->ECC = FakeECC;
            cvl->code = CV1->cv[i].code;
            cvl->ismeta = CV1->cv[i].ismeta;
            if(answer == 1)
               {
               cvl->match = 1;
               cvl->nomatch = 0;
               }
            else
               {
               cvl->match = 0;
               cvl->nomatch = 1;
               if(noted == 0)
                  {
                  strcat(BndAttrMismatch," ");
                  strcat(BndAttrMismatch,GetEACCode(cvl->code));
                  ++noted;
                  }
               else
                  {
                  noted = 0;
                  }

               retval = 1;
               /**if(DontCareCode(CV1->cv[i].code,ECC,geom) == 0)
                  retval = 0;**/
               }
            cvl->next = CV_Master;
            cvl->value = 0;
            cvl->strval = NULL;
            CV_Master = cvl;
            }
         else
            {
            cvp = cvthis = CV_Master;
            while(cvthis != NULL)
               {
               if((cvthis->ECC == ECC) && (cvthis->code == CV1->cv[i].code))
                  {
                  if((CV1->cv[i].strval != NULL) && (cvthis->strval != NULL) && (strcmp(CV1->cv[i].strval,cvthis->strval) == 0))
                     {
                     if(answer == 1)
                        cvthis->match += 1;
                     else
                        {
                        cvthis->nomatch += 1;
                        if(noted == 0)
                           {
                           strcat(BndAttrMismatch," ");
                           strcat(BndAttrMismatch,GetEACCode(cvthis->code));
                           ++noted;
                           }
                        else
                           {
                           noted = 0;
                           }

                        retval = 1;
                        }
                     break;
                     }
                  else if((CV1->cv[i].strval == NULL) && (cvthis->strval == NULL) && (CV1->cv[i].value == cvthis->value))
                     {
                     if(answer == 1)
                        cvthis->match += 1;
                     else
                        {
                        cvthis->nomatch += 1;
                        if(noted == 0)
                           {
                           strcat(BndAttrMismatch," ");
                           strcat(BndAttrMismatch,GetEACCode(cvthis->code));
                           ++noted;
                           }
                        else
                           {
                           noted = 0;
                           }
                        retval = 1;
                        }
                     break;
                     }
                  }
               cvp = cvthis;
               cvthis = cvthis->next;

               }
            }
         }
      if((checkit == 1) && (cvthis == NULL))
         {
            cvl = (struct MasterCandVlist *) (malloc(SzMCVL));
            cvl->ECC = ECC;
         cvl->code = CV1->cv[i].code;
         cvl->ismeta = CV1->cv[i].ismeta;
         if(answer == 1)
            {
            cvl->nomatch = 0;
            cvl->match = 1;
            }
         else
            {
            cvl->nomatch = 1;
            cvl->match = 0;
            if(noted == 0)
               {
               strcat(BndAttrMismatch," ");
               strcat(BndAttrMismatch,GetEACCode(cvl->code));
               ++noted;
               }
            else
               {
               noted = 0;
               }

            retval = 1;
            /**if(DontCareCode(CV1->cv[i].code,ECC,geom) == 0)
               retval = 0;**/
            }
         cvl->next = NULL;
         if(CV1->cv[i].strval != NULL)
            {
            cvl->strval = (char *) malloc(strlen(CV1->cv[i].strval) + 1);
            strcpy(cvl->strval,CV1->cv[i].strval);
            }
         else
            {
            cvl->strval = NULL;
            cvl->value = CV1->cv[i].value;
            }
         cvp = cvn = CV_Master;
         while((cvn != NULL ) && (cvn->ECC < ECC))
            {
            cvp = cvn;
            cvn = cvn->next;
            }
         if((cvn != NULL) && (cvn->ECC == ECC))
            {
            if(cvl->code <= cvn->code)
               {
               cvl->next = cvn;
               if(cvn == CV_Master)
                  {
                  CV_Master = cvl;
                  }
               else
                  {
                  cvp->next = cvl;
                  }
               }
            else
               {
               while((cvn != NULL) && (cvn->ECC == ECC) && (cvn->code < cvl->code))
                  {
                  cvp = cvn;
                  cvn = cvn->next;
                  }
               cvl->next = cvn;
               cvp->next = cvl;
               }
            }
         else
            {
            if(cvn == CV_Master)
               {
               cvl->next = cvn;
               CV_Master = cvl;
               }
            else
               {
               cvl->next = cvn;
               cvp->next = cvl;
               }
            }
         }

      if(checkit == 1) 
         {
         cvp = cvn = CV_Master;
         while(cvn->ECC < FakeECC)
            {
            cvp = cvn;
            cvn = cvn->next;
            if(cvn == NULL)
               break;
            }
         if((cvn != NULL) && (cvn->ECC == FakeECC))
            {
            while((cvn->ECC == FakeECC) && (cvn->code < CV1->cv[i].code))
               {
               cvp = cvn;
               cvn = cvn->next;
               }
            if((cvn->ECC == FakeECC) && (cvn->code == CV1->cv[i].code))
               {
               if(answer == 1)
                  cvn->match += 1;
               else
                  {
                  cvn->nomatch += 1;
                  retval = 1;
                  if(noted == 0)
                     {
                     strcat(BndAttrMismatch," ");
                     strcat(BndAttrMismatch,GetEACCode(cvn->code));
                     ++noted;
                     }
                  else
                     {
                     noted = 0;
                     }
                  }
               }
            else
               {
               cvl = (struct MasterCandVlist *) (malloc(SzMCVL));
               cvl->ECC = FakeECC;
               cvl->code = CV1->cv[i].code;
               cvl->ismeta = CV1->cv[i].ismeta;
               if(answer == 1)
                  {
                  cvl->match = 1;
                  cvl->nomatch = 0;
                  }
               else
                  {
                  cvl->match = 0;
                  cvl->nomatch = 1;
                  if(noted == 0)
                     {
                     strcat(BndAttrMismatch," ");
                     strcat(BndAttrMismatch,GetEACCode(cvl->code));
                     ++noted;
                     }
                  else
                     {
                     noted = 0;
                     }
                  retval = 1;
                  /**if(DontCareCode(CV1->cv[i].code,ECC,geom) == 0)
                     retval = 0;**/
                  }
               cvl->next = NULL;
               cvl->value = 0;
               cvl->strval = NULL;
               if(cvn == CV_Master)
                  {
                  cvl->next = CV_Master;
                  CV_Master = cvl;
                  }
               else
                  {
                  cvl->next = cvn;
                  cvp->next = cvl;
                  }
               }
            }
         else
            {
            cvl = (struct MasterCandVlist *) (malloc(SzMCVL));
            cvl->ECC = FakeECC;
            cvl->code = CV1->cv[i].code;
            cvl->ismeta = CV1->cv[i].ismeta;
            if(answer == 1)
               {
               cvl->match = 1;
               cvl->nomatch = 0;
               }
            else
               {
               cvl->match = 0;
               cvl->nomatch = 1;
               if(noted == 0)
                  {
                  strcat(BndAttrMismatch," ");
                  strcat(BndAttrMismatch,GetEACCode(cvl->code));
                  ++noted;
                  }
               else
                  {
                  noted = 0;
                  }
               retval = 1;
               /**if(DontCareCode(CV1->cv[i].code,ECC,geom) == 0)
                  retval = 0;**/
               }
            cvl->next = NULL;
            cvl->value = 0;
            cvl->strval = NULL;
            if(cvn == CV_Master)
               {
               cvl->next = CV_Master;
               CV_Master = cvl;
               }
            else
               {
               cvl->next = cvn;
               cvp->next = cvl;
               }
            }
         }

      }
   return(retval);
}



int SameAttrAndVals(struct CodesAndValue * CV1, struct CodesAndValue * CV2, int MetaDataCounts)
{
int i,j, answer, checkit;

   if((MetaDataCounts > 0) && (CV1->numttl != CV2->numttl))
      return(0);
   else if(MetaDataCounts == 0)
      {
      i = CV1->numttl - CV2->nummeta;
      j = CV2->numttl - CV2->nummeta;
      if(i != j)
         return(0);
      }

   for(i=0; i<CV1->numttl; i++)
      {
      answer = 0;
      checkit = 1;
      if((MetaDataCounts == 0) && (CV1->cv[i].ismeta > 0))
         {
         answer = 1;
         checkit = 0;
         }
      else if(CV1->cv[i].code < 0)
         {
         answer = 1;
         checkit = 0;
         }

      if(CV1->cv[i].islen > 0) /*** note that only set this > 0 if want to disregard length attr ***/
         {
         answer = 1;
         checkit = 0;
         }

      if(checkit > 0)
         {
         for(j=0; j<CV2->numttl; j++)
            {
            if(CV1->cv[i].code == CV2->cv[j].code)
               {
               if((CV1->cv[i].strval != NULL) && (CV2->cv[j].strval != NULL) && (strcmp(CV1->cv[i].strval,CV2->cv[j].strval) == 0))
                  {
                  answer = 1;
                  break;
                  }
               else if((CV1->cv[i].strval == NULL) && (CV2->cv[j].strval == NULL) && (CV1->cv[i].value == CV2->cv[j].value))
                  {
                  answer = 1;
                  break;
                  }
               }
            }
         }
      if(answer == 0)
         {
         break;
         }
      }
   return(answer);
}



struct CodesAndValue * GetAttrCodesAndValues(int Lindex, int idn, FILE * fileptr, int SzCV, int SzCVl, int DiscardLengthAttr)
{
struct CodesAndValue *CV;
/***struct CandVlist *CVl;***/
int ECC, seeitgeom,numchar,numattr,NumAttrToRead;
int /**EAC,**/ uom, uomscale, SEDRIStype, datatype, Idtvalue, IdtVal2;
int IntervalType, HGT_type, ZV2_type, NAM_type, LEN_type;
int i,j, Lcode1, Lcode2, Lcode3, ZV2code,HGTcode,NAMcode;
int I_HGTval, I_ZV2val, I_NAMval, I_LENval;
double D_HGTval, D_ZV2val, D_NAMval, D_LENval;
char S_HGTval[1000];
char S_ZV2val[1000];
char S_NAMval[1000];
char S_LENval[1000];
double Fdtvalue, FdtVal2;
char longtitle[500];
char tc;
extern int LONG_ATTR_CHECK_HGT;
extern int LONG_ATTR_CHECK_ZV2;
extern int LONG_ATTR_CHECK_NAM;
extern int LONG_ATTR_CHECK_LEN;
extern int LONG_ATTR_CHECK_AREA;
extern int I_TYPE, D_TYPE, C_TYPE, NOTYPE;
extern int GetLongAttrVal(int type,int uniqueid,int *Ival,double *Dval,char *Cval);
extern int GetLENCode();
extern int GetZVCode();
extern int GetHGTCode();
extern int GetNAMCode();
/***int Sindex;***/

   Lcode1 = Lcode2 = Lcode3 = -100;
   ZV2code = HGTcode = NAMcode = -100;
   if((NGA_TYPE == 1) && (DiscardLengthAttr > 0))
      {
      Lcode1 = GetLENCode();
      ZV2code = GetZVCode();
      HGTcode = GetHGTCode();
      NAMcode = GetNAMCode();
      if(ATTRTYPE_D4() > 0) /*** GIFD D4 model ***/
         {
         Lcode2 = GetAttrIndex("LEG");
         }
      else if(ATTRTYPE_FACC() > 0) /*** FACC+ model ***/
         {
         Lcode2 = GetAttrIndex("LEG");
         }
      else if((ATTRTYPE_UFD1() > 0) || (ATTRTYPE_UFD2() > 0)) /** UFD2 model ***/ /*** UFD1 model ***/
         {
         Lcode2 = GetAttrIndex("LEG");
         }
      else if(ATTRTYPE_UFD3() > 0) /*** UFD3 model ***/
         {
         Lcode2 = GetAttrIndex("LEG");
         Lcode3 = GetAttrIndex("LEN_");
         }
      }
   fseek(fileptr,CrsWlk[Lindex].FullFilePosn,SEEK_SET);
 
   SEEIT_fread_int(&ECC,fileptr);
   CV = (struct CodesAndValue *) (malloc(SzCV));
   if(CV == NULL)
      return(CV);

   if(feof(fileptr) == 0)
      {
      SEEIT_fread_int(&seeitgeom,fileptr);
      SEEIT_fread_int(&NumAttrToRead,fileptr);
      numattr = NumAttrToRead + 4;  /*** adding 4 to account for LEN, NAM, ZV2 and HGT that are not in long list ... ***/
      if(numattr > 0)
         {
         CV->cv = (struct CandVlist *) (malloc(SzCVl * numattr)); 
         if(CV->cv == NULL)
            {
            free(CV);
            return(NULL);
            }
         CV->numttl = numattr;
         CV->nummeta = 0;
         for(i=0; i<numattr; i++)
            {
            CV->cv[i].value = 0.0;
            CV->cv[i].used = 0;
            CV->cv[i].ismeta = 0;
            CV->cv[i].islen = 0;
            CV->cv[i].strval = NULL;
            CV->cv[i].code = -100;
            }
         HGT_type = GetLongAttrVal(LONG_ATTR_CHECK_HGT,idn,&I_HGTval,&D_HGTval,&S_HGTval[0]);
         ZV2_type = GetLongAttrVal(LONG_ATTR_CHECK_ZV2,idn,&I_ZV2val,&D_ZV2val,&S_ZV2val[0]);
         NAM_type = GetLongAttrVal(LONG_ATTR_CHECK_NAM,idn,&I_NAMval,&D_NAMval,&S_NAMval[0]);
         CV->cv[0].code = ZV2code;
         if(ZV2_type  == I_TYPE)
            {
            CV->cv[0].value = (double) I_ZV2val;
            CV->cv[0].strval = NULL;
            }
         else if(ZV2_type == D_TYPE)
            {
            CV->cv[0].value = D_ZV2val;
            CV->cv[0].strval = NULL;
            }
         else if(ZV2_type == C_TYPE)
            {
            CV->cv[0].value = 0.0;
            numchar = strlen(S_ZV2val) + 2;
            CV->cv[0].strval = (char *) (malloc(numchar));
            if(CV->cv[0].strval != NULL)
               strcpy(CV->cv[0].strval,S_ZV2val);
            }
         else if(ZV2_type == NOTYPE)
            CV->cv[0].code = -99;

         CV->cv[1].code = HGTcode;
         if(HGT_type  == I_TYPE)
            {
            CV->cv[1].value = (double) I_HGTval;
            CV->cv[1].strval = NULL;
            }
         else if(HGT_type == D_TYPE)
            {
            CV->cv[1].value = D_HGTval;
            CV->cv[1].strval = NULL;
            }
         else if(HGT_type == C_TYPE)
            {
            CV->cv[1].value = 0.0;
            numchar = strlen(S_HGTval) + 2;
            CV->cv[1].strval = (char *) (malloc(numchar));
            if(CV->cv[1].strval != NULL)
               strcpy(CV->cv[1].strval,S_HGTval);
            }
         else if(HGT_type == NOTYPE)
            CV->cv[1].code = -99;
         CV->cv[2].code = NAMcode;
         if(NAM_type  == I_TYPE)
            {
            CV->cv[2].value = (double) I_NAMval;
            CV->cv[2].strval = NULL;
            }
         else if(NAM_type == D_TYPE)
            {
            CV->cv[2].value = D_NAMval;
            CV->cv[2].strval = NULL;
            }
         else if(NAM_type == C_TYPE)
            {
            CV->cv[2].value = 0.0;
            numchar = strlen(S_NAMval) + 2;
            CV->cv[2].strval = (char *) (malloc(numchar));
            if(CV->cv[2].strval != NULL)
               strcpy(CV->cv[2].strval,S_NAMval);
            }
         else if(NAM_type == NOTYPE)
            CV->cv[2].code = -99;

         if(DiscardLengthAttr == 0)
            {
            LEN_type = GetLongAttrVal(LONG_ATTR_CHECK_LEN,idn,&I_LENval,&D_LENval,&S_LENval[0]);
            CV->cv[3].code = Lcode1;
            if(LEN_type  == I_TYPE)
               {
               CV->cv[3].value = (double) I_LENval;
               CV->cv[3].strval = NULL;
               }
            else if(LEN_type == D_TYPE)
               {
               CV->cv[3].value = D_LENval;
               CV->cv[3].strval = NULL;
               }
            else if(LEN_type == C_TYPE)
               {
               CV->cv[3].value = 0.0;
               numchar = strlen(S_LENval) + 2;
               CV->cv[3].strval = (char *) (malloc(numchar));
               if(CV->cv[3].strval != NULL)
                  strcpy(CV->cv[3].strval,S_LENval);
               }
            else if(LEN_type == NOTYPE)
               CV->cv[3].code = -99;
            }
		 else
		 {
           CV->cv[3].code = -99;
		 }





         for(i=4; i<numattr; i++)
            {
            SEEIT_fread_int(&CV->cv[i].code,fileptr);

            if(DiscardLengthAttr == 1)
               {
               if((CV->cv[i].code == Lcode1) || (CV->cv[i].code == Lcode2) || (CV->cv[i].code == Lcode3))
                  CV->cv[i].islen = 1;
               }
            for(j=0; j<NumMetaDataCodes; j++)
               {
               if(MetaDataAttrCodes[j] == CV->cv[i].code) /** then this attr is metadata, so mark it **/
                  {
                  CV->cv[i].ismeta = 1;
                  break;
                  }
               }
            if(CV->cv[i].code < 0)
               {
               CV->cv[i].value = 0;
               CV->cv[i].strval = NULL;
               SEEIT_fread_int(&numchar,fileptr);
/** in this function, just read it to get past it and then throw it away ...    ***/
               if(numchar < 499)
                  fread(&longtitle[0],1,numchar,fileptr);
               longtitle[numchar] = '\0';
               }
            else
               {
               SEEIT_fread_int(&uom,fileptr);
               SEEIT_fread_int(&uomscale,fileptr);
               SEEIT_fread_int(&SEDRIStype,fileptr);
               SEEIT_fread_int(&datatype,fileptr);
               switch(datatype)
                  {
                  case 0: /** regular integer **/
                     SEEIT_fread_int(&Idtvalue,fileptr);
                     CV->cv[i].value = (double) Idtvalue;
                     CV->cv[i].strval = NULL;
                     break;
                  case 1: /** a double **/
                     SEEIT_fread_double(&Fdtvalue,fileptr);
                     CV->cv[i].value = Fdtvalue;
                     CV->cv[i].strval = NULL;
                     break;
                  case 2: /** a string **/
                     SEEIT_fread_int(&numchar,fileptr);
                     for(j=0; j<numchar; j++)
                        {
                        fread(&tc,1,1,fileptr);
                        MessageLine[j] = tc;
                        }
                     MessageLine[j] = '\0';
                     CV->cv[i].value = 0;
                     CV->cv[i].strval = (char *) (malloc(numchar + 1));
                     if(CV->cv[i].strval != NULL)
                        strcpy(CV->cv[i].strval,MessageLine);
                     break;
                  case 3: /** enum as int **/
                     SEEIT_fread_int(&Idtvalue,fileptr);
strcpy(MessageLine,GetEELabel(CV->cv[i].code,Idtvalue));
CV->cv[i].value = 0;
CV->cv[i].strval = (char *) (malloc(strlen(MessageLine) + 2));
strcpy(CV->cv[i].strval,MessageLine);
                     break;
                  case 4: /** metadata as int **/
                     SEEIT_fread_int(&Idtvalue,fileptr);
                     CV->cv[i].value = (double) Idtvalue;
                     CV->cv[i].strval = NULL;
                     break;
                  case 5: /** a float interval for SEDRIS only **/
                     SEEIT_fread_double(&Fdtvalue,fileptr);
                     SEEIT_fread_double(&FdtVal2,fileptr);
                     SEEIT_fread_int(&IntervalType,fileptr);
                     CV->cv[i].value = (double) Idtvalue;
                     CV->cv[i].strval = NULL;
                     break;
                  case 6: /** int interval - for SEDRIS, not NGA ***/
                    SEEIT_fread_int(&Idtvalue,fileptr);
                    SEEIT_fread_int(&IdtVal2,fileptr);
                    SEEIT_fread_int(&IntervalType,fileptr);
                     CV->cv[i].value = (double) Idtvalue;
                     CV->cv[i].strval = NULL;
                    break;
                  case 7:
                 /* this case is not possible at this time */
                    SEEIT_fread_int(&Idtvalue,fileptr);
                    SEEIT_fread_int(&IdtVal2,fileptr);
                    SEEIT_fread_int(&IntervalType,fileptr);
                     CV->cv[i].value = (double) Idtvalue;
                     CV->cv[i].strval = NULL;
                    sprintf(MessageLine,"\n interval stuff need updating: (%d to %d)\n",Idtvalue,IdtVal2);
                    infoprint(MessageLine);
                    break;
                  }
               }
            }
         }
      else
         CV->cv = NULL;
      }
   else
      {
      free(CV);
      return(NULL);
      }

   return(CV);
}




int LineWithinQueryBox(double lx, double ly, double ux, double uy, double x1, double y1, double z1,
                              double x2, double y2, double z2, int Sindex, int Lindex, /**double width, double height,**/
                              /**char * IDn, **/  unsigned char Strat, unsigned char Domain, int featureID, /***char * LID, ***/
                               FILE * fileptr)
{
int answer;
double nx,ny;
double lowx,lowy,highx,highy,testpt;
int i;

   answer = 0;
   if((x1 >= lx) && (x1 <= ux) && (y1 >= ly) && (y1 <= uy))
      answer = 1;
   if((x2 >= lx) && (x2 <= ux) && (y2 >= ly) && (y2 <= uy))
      answer = 1;

   if(answer == 0)
      {
      if(x1 <= x2)
         {
         lowx = x1;
         highx = x2;
         }
      else
         {
         lowx = x2;
         highx = x1;
         }
      if(y1 <= y2)
         {
         lowy = y1;
         highy = y2;
         }
      else
         {
         lowy = y2;
         highy = y1;
         }
      if((lx >= lowx) && (lx <= highx))
         {
         testpt =  FindXatYonSegment(lx, y1, x1, y2,  x2); /** finding Y, not X, so all args switched ... ***/
         if((testpt >= ly) && (testpt <= uy))
            answer = 1;
         }
      if(answer == 0)
         {
         if((ux >= lowx) && (ux <= highx))
            {
            testpt =  FindXatYonSegment(ux, y1, x1, y2,  x2); /** finding Y, not X, so all args switched ... ***/
            if((testpt >= ly) && (testpt <= uy))
               answer = 1;
            }
         if(answer == 0)
            {
            if((ly >= lowy) && (ly <= highy))
               {
               testpt =  FindXatYonSegment(ly, x1, y1, x2,  y2);
               if((testpt >= lx) && (testpt <= ux))
                  answer = 1;
               }
            if(answer == 0)
               {
               if((uy >= lowy) && (uy <= highy))
                  {
                  testpt =  FindXatYonSegment(uy, x1, y1, x2,  y2);
                  if((testpt >= lx) && (testpt <= ux))
                     answer = 1;
                  }
               }
            }
         }
      }
      
   if((answer == 0) && (LinearFromFile.badform != 1))  /** check for segment intersection with query box **/
      {
      if(LineSegmentsIntersect(x1,y1,x2,y2,lx,ly,lx,uy,&nx,&ny))
         answer = 1;
      else if(LineSegmentsIntersect(x1,y1,x2,y2,ux,ly,ux,uy,&nx,&ny))
         answer = 1;
      else if(LineSegmentsIntersect(x1,y1,x2,y2,lx,ly,ux,ly,&nx,&ny))
         answer = 1;
      else if(LineSegmentsIntersect(x1,y1,x2,y2,lx,uy,ux,uy,&nx,&ny))
         answer = 1;
      }

   if(answer == 1)
      {

      IPC.ECC = SCCtable[Sindex].ECC;
      IPC.geom = C_LINE;
      IPC.area = 0.0;
      IPC.length = LinearFromFile.length;
      IPC.FID = featureID;
      IPC.numcoords = LinearFromFile.numnodes;
      IPC.IDstr = NULL;

      if(IPC.numcoords > 0)
         {
         IPC.X = (double *) (malloc(SzD * IPC.numcoords));
         IPC.Y = (double *) (malloc(SzD * IPC.numcoords));
         IPC.Z = (double *) (malloc(SzD * IPC.numcoords));
         if(IPC.Z == NULL)
            {
            printf("available memory has been exhausted during coordinate printing\n");
            printf("requested memory allocation to print %d coordinates\n",IPC.numcoords);
            exit(-1);
            }
         }
      else
         {
         IPC.X = NULL;
         IPC.Y = NULL;
         IPC.Z = NULL;
         }
      
      for(i=0; i<IPC.numcoords; i++)
         {
         IPC.X[i] = LinearFromFile.x[i];
         IPC.Y[i] = LinearFromFile.y[i];
         IPC.Z[i] = LinearFromFile.z[i];

         }
      
      FillInAttributeFields(Lindex, fileptr);

      TempInfoPrint(LinearFromFile.idn);

      }
   
   return(answer);
}





int BoxIntersectPerimeter(double x1,double y1,double x2,double y2,int numverts,double *x,double *y)
{
int answer;
int i;
double ix, iy;

   for(i=1; i<numverts; i++)
      {
      if(LineSegmentsIntersect(x1,y1,x1,y2,x[i-1],y[i-1],x[i],y[i],&ix,&iy) > 0)
         break;
      if(LineSegmentsIntersect(x1,y1,x2,y1,x[i-1],y[i-1],x[i],y[i],&ix,&iy) > 0)
         break;
      if(LineSegmentsIntersect(x2,y2,x1,y2,x[i-1],y[i-1],x[i],y[i],&ix,&iy) > 0)
         break;
      if(LineSegmentsIntersect(x2,y2,x2,y1,x[i-1],y[i-1],x[i],y[i],&ix,&iy) > 0)
         break;
      }
   if(i < numverts)
      answer = 1;
   else
      {
      answer = 0;
      if(LineSegmentsIntersect(x1,y1,x1,y2,x[numverts - 1],y[numverts - 1],x[0],y[0],&ix,&iy) > 0)
         answer = 1;
      else if(LineSegmentsIntersect(x1,y1,x2,y1,x[numverts - 1],y[numverts - 1],x[0],y[0],&ix,&iy) > 0)
         answer = 1;
      else if(LineSegmentsIntersect(x2,y2,x1,y2,x[numverts - 1],y[numverts - 1],x[0],y[0],&ix,&iy) > 0)
         answer = 1;
      else if(LineSegmentsIntersect(x2,y2,x2,y1,x[numverts - 1],y[numverts - 1],x[0],y[0],&ix,&iy) > 0)
         answer = 1;
      }

   return(answer);
}




void DescribeRegionContents(double x1,double y1,double x2,double y2, int IsPoint)
{
FILE *linin;
FILE *arin;
FILE *ptsin;
FILE *brdgin;
FILE *modelPin;
FILE *attrfileptr;
struct LongList *cll;
struct LongList * LongListRoot = NULL;
struct LongSkipList *SkipList = NULL;
int vtxcnt;
double surfacearea, /**surfacearea2D,**/ PA, PB, PC, PD;
/*** double  angle; **/
double tolerance,nx,ny;
double multiplier;
double GridX, GridY, GridZ;
double minx, maxx,miny,maxy;
/**double globalMaxX,globalMaxY,LMmaxX,LMmaxY; **/
int OKtoUse;
int HoleDescribed;
int SzInner = sizeof(struct AreaRing);
struct AreaRing *IPCring;
int index1, index2;
int valuesread;
int SXindex, SYindex, EXindex, EYindex;
int HadToOpenFile, InRegion,PointQuery;
int i,ii,j, k, inareal;
int jj, kk, ii2, iX, iY;
/** int ti; **/
int iStart, iEnd, jStart, jEnd;
/**int IDnumberRecordSize; **/
int grows, gcols, NofCols;
/**int totalpoly;**/
int compositeindex;
int singles, multiples;
double PointX,PointY;
int * GridsDone;
double digits;
unsigned char Config, Strat, Domain;
int skiplimit = 0; /** note that this 'turns off' list skipping ***/
extern int DO_DESCRIBE;
/***char LinearID[500]; ***/
int SkipEntry = 0;
struct RawAreal *rac, *rap;
int filenumber;
/**int findex = 0;**/
unsigned long int fo;
char suffix[5];
char afilein[200];


   HadToOpenFile = 0;



   multiplier = SignificantDecimals;

   if(NumLODbands > 0)
      GridsDone = (int *) (malloc(SzI * NumberOfGrids));
   else
      GridsDone = NULL;

   if(NGA_TYPE == 0)
      HadToOpenFile = ReadPolySetup(&digits, 0, 0, &singles, &multiples,&compositeindex);
   else
      {
      HadToOpenFile = 0;
      singles = multiples = 0;
      digits = SignificantDecimals;
      }


   if(x2 < x1)
      {
      nx = x1;
      x1 = x2;
      x2 = nx;
      }
   if(y2 < y1)
      {
      ny = y1;
      y1 = y2;
      y2 = ny;
      }

   if(IsPoint > 0)
      {
      PointX = x1 + (x2 - x2) / 2.0;
      PointY = y1 + (y2 - y1) / 2.0;
      PointQuery = 1;
      }
   else
     PointQuery = 0;


   SXindex = (int) (x1 / RegionSize);
   SYindex = (int) (y1 / RegionSize);
   EXindex = (int) (x2 / RegionSize);
   EYindex = (int) (y2 / RegionSize);

   if(SXindex < 0) SXindex = 0;
   if(SYindex < 0) SYindex = 0;
   if(EXindex > MaxXindex) EXindex = MaxXindex;
   if(EYindex > MaxYindex) EYindex = MaxYindex;

   sprintf(MessageLine,"%scodesfull.bin",indirectory);
   attrfileptr = fopen(MessageLine,"rb");
   if(attrfileptr == NULL)
      {
      printf("could not find required file %s\n",MessageLine);
      exit(-1);
      }



   if((NGA_TYPE == 0) && (DrawByConfig[7] > 0)) /** are polygons to be described ? **/
      {
      FreeLongList(&LongListRoot);
      LongListRoot = NULL;
/** note, since skiplimit is 0, are not using skip list, so no need to reintialize with each free long list **/
      for(index1 = SXindex; index1 <= EXindex; index1 ++)
         {
         for(index2 = SYindex; index2 <= EYindex; index2 ++)
            {
            valuesread = 0;
            compositeindex = (index1 * (MaxYindex + 1)) + index2;
            if(NGA_TYPE == 0)
               {
               fseek(fin,PolyTable[compositeindex].fileptr,SEEK_SET);
               singles = PolyTable[compositeindex].numinside;
               multiples = PolyTable[compositeindex].numother;

               if(multiples > 0)
                  {
                  for(i=0; i<PolyTable[compositeindex].numother; i++)
                     {
                     InsertIntoLongList(PolyTable[compositeindex].others[i].fileptr,0,skiplimit,
                                     &LongListRoot,SkipList,&SkipEntry);
                     }
                  }
               }
            else
               {
               singles = multiples = 0;
               LongListRoot = NULL;
               }

 /** below while loop looks at all inside region polygon objects **/
            multiples = 0;
            while(valuesread < singles)
               {
               vtxcnt = ReadPolyFromFile(fin,digits);
               ++valuesread; 

               if(DO_DESCRIBE == 0)
                  {
                  free(PolyFromFile.x);
                  free(PolyFromFile.y);
                  free(PolyFromFile.z);
                  FreeLongList(&LongListRoot);
                  LongListRoot = NULL;
                  if(HadToOpenFile > 0)
                     {
                     fclose(fin);
                     fin = NULL;
                     HadToOpenFile = 0;
                     }
                  if(attrfileptr != NULL)
                     fclose(attrfileptr);
                  return;
                  }
   
               Config = PolyFromFile.config;
               Strat = PolyFromFile.stratum;
               Domain = PolyFromFile.domain;

               OKtoUse = 1;
               if(NumLODbands > 0)
                  {
                  jj = CrsWlk[PolyFromFile.SACindex].LODband;
                  if((jj > 0) && (LODindex[jj-1].active < 1))
                     OKtoUse = 0;
                  }

               if((OKtoUse > 0) && (DrawByStratum[Strat] > 0) && (DrawByDomain[Domain] > 0))
                  {
                  InRegion = 0;
                  if(PointQuery == 1)
                     {
                     if(vtxcnt == 3)
                        {
                        if(PointInsideTriangle(PointX,PointY,PolyFromFile.x[0],PolyFromFile.y[0],
                                PolyFromFile.x[1],PolyFromFile.y[1],PolyFromFile.x[2],PolyFromFile.y[2]))
                           {
                           InRegion = 3;
                           }
                        }
                     else if(PointInsidePoly(PointX,PointY,PolyFromFile.x,PolyFromFile.y,vtxcnt))
                        {
                        InRegion = vtxcnt;
                        }
                     }
                  else
                     {
                     for(i=0; i<vtxcnt; i++)
                        {
                        if((PolyFromFile.x[i] >= x1) && (PolyFromFile.x[i] <= x2) &&
                                 (PolyFromFile.y[i] >= y1) && (PolyFromFile.y[i] <= y2))
                           ++InRegion;
                        else
                           break;
                        }
                     if(InRegion < vtxcnt)
                        {
                        if(BoxIntersectPerimeter(x1,y1,x2,y2,vtxcnt,PolyFromFile.x,PolyFromFile.y) > 0)
                           InRegion = vtxcnt;
                        }
                     }
                  if(InRegion == vtxcnt)
                     {
                     if(vtxcnt == 3)
                        {
                        surfacearea = TriangleSurfaceArea(PolyFromFile.x,PolyFromFile.y,PolyFromFile.z);
                        }
                     else
                        {
                        surfacearea = SurfaceAreaByTriangles(vtxcnt,PolyFromFile.x,PolyFromFile.y,PolyFromFile.z);
                        }
                     PlaneEquation(&PA,&PB,&PC,&PD,PolyFromFile.x,PolyFromFile.y,PolyFromFile.z,vtxcnt);
                     IPC.ECC = SCCtable[PolyFromFile.SCCindex].ECC;
                     IPC.geom = C_POLY;
                     IPC.innerings = NULL;
                     IPC.area = surfacearea;
                     IPC.FID = -1;
                     IPC.numcoords = PolyFromFile.numverts;
                     IPC.IDstr = NULL;
                     if(IPC.numcoords > 0)
                        {
                        IPC.X = (double *) (malloc(SzD * IPC.numcoords));
                        IPC.Y = (double *) (malloc(SzD * IPC.numcoords));
                        IPC.Z = (double *) (malloc(SzD * IPC.numcoords));
                        if(IPC.Z == NULL)
                           {
                           printf("available memory has been exhausted during coordinate printing\n");
                           printf("requested memory allocation to print %d coordinates\n",IPC.numcoords);
                           exit(-1);
                           }
                        }
                     else
                        {
                        IPC.X = NULL;
                        IPC.Y = NULL;
                        IPC.Z = NULL;
                        }
                     for(j=0; j<IPC.numcoords; j++) 
                        {
                        IPC.X[j] = PolyFromFile.x[j];
                        IPC.Y[j] = PolyFromFile.y[j];
                        IPC.Z[j] = PolyFromFile.z[j];
		        }

                     FillInAttributeFields(PolyFromFile.SACindex, attrfileptr);

                     TempInfoPrint(PolyFromFile.idn);

                     }
                  }
               free(PolyFromFile.x);
               free(PolyFromFile.y);
               free(PolyFromFile.z);
               }
            } /** end for index2 **/
         }  /** end for index1 **/

      cll = LongListRoot;
      while(cll != NULL)
         {
         fseek(fin,cll->fp,SEEK_SET);
         vtxcnt = ReadPolyFromFile(fin,multiplier);
         if(feof(fin) != 0)
            break;

         if(DO_DESCRIBE == 0)
            {
            free(PolyFromFile.x);
            free(PolyFromFile.y);
            free(PolyFromFile.z);
            FreeLongList(&LongListRoot);
            LongListRoot = NULL;
            if(HadToOpenFile > 0)
               {
               fclose(fin);
               fin = NULL;
               HadToOpenFile = 0;
               }
            if(attrfileptr != NULL)
               fclose(attrfileptr);
            return;
            }

         Config = PolyFromFile.config;
         Strat = PolyFromFile.stratum;
         Domain = PolyFromFile.domain;

         OKtoUse = 1;
         if(NumLODbands > 0)
            {
            jj = CrsWlk[PolyFromFile.SACindex].LODband;
            if((jj > 0) && (LODindex[jj-1].active < 1))
               OKtoUse = 0;
            }

         if((OKtoUse > 0) && (DrawByStratum[Strat] > 0) && (DrawByDomain[Domain] > 0))
            {
            InRegion = 0;
            if(PointQuery == 1)
               {
               if(vtxcnt == 3)
                  {
                  if(PointInsideTriangle(PointX,PointY,PolyFromFile.x[0],PolyFromFile.y[0],
                          PolyFromFile.x[1],PolyFromFile.y[1],PolyFromFile.x[2],PolyFromFile.y[2]))
                     {
                     InRegion = 3;
                     }
                  }
               else if(PointInsidePoly(PointX,PointY,PolyFromFile.x,PolyFromFile.y,vtxcnt))
                  {
                  InRegion = vtxcnt;
                  }
               }
            else
               {
               for(i=0; i<vtxcnt; i++)
                  {
                  if((PolyFromFile.x[i] >= x1) && (PolyFromFile.x[i] <= x2) &&
                           (PolyFromFile.y[i] >= y1) && (PolyFromFile.y[i] <= y2))
                     ++InRegion;
                  else
                     break;
                  } 
               if(InRegion < vtxcnt)
                  {
                  if(BoxIntersectPerimeter(x1,y1,x2,y2,vtxcnt,PolyFromFile.x,PolyFromFile.y) > 0)
                     InRegion = vtxcnt;
                  }
               }
            if(InRegion == vtxcnt)
               {
               if(vtxcnt == 3)
                  {
                  surfacearea = TriangleSurfaceArea(PolyFromFile.x,PolyFromFile.y,PolyFromFile.z);
                  }
               else
                  {
                  surfacearea = SurfaceAreaByTriangles(vtxcnt,PolyFromFile.x,PolyFromFile.y,PolyFromFile.z);
                  }
               PlaneEquation(&PA,&PB,&PC,&PD,PolyFromFile.x,PolyFromFile.y,PolyFromFile.z,vtxcnt);
               IPC.ECC = SCCtable[PolyFromFile.SCCindex].ECC;
               IPC.geom = C_POLY;
               IPC.innerings = NULL;
               IPC.area = surfacearea;
               IPC.FID = -1;
               IPC.numcoords = PolyFromFile.numverts;
               IPC.IDstr = NULL;
               if(IPC.numcoords > 0)
                  {
                  IPC.X = (double *) (malloc(SzD * IPC.numcoords));
                  IPC.Y = (double *) (malloc(SzD * IPC.numcoords));
                  IPC.Z = (double *) (malloc(SzD * IPC.numcoords));
                  if(IPC.Z == NULL)
                     {
                     printf("available memory has been exhausted during coordinate printing\n");
                     printf("requested memory allocation to print %d coordinates\n",IPC.numcoords);
                     exit(-1);
                     }
                  }
               else
                  {
                  IPC.X = NULL;
                  IPC.Y = NULL;
                  IPC.Z = NULL;
                  }
               for(j=0; j<IPC.numcoords; j++)
                  {
                  IPC.X[j] = PolyFromFile.x[j];
                  IPC.Y[j] = PolyFromFile.y[j];
                  IPC.Z[j] = PolyFromFile.z[j];
                  }

               FillInAttributeFields(PolyFromFile.SACindex, attrfileptr);

               TempInfoPrint(PolyFromFile.idn);
               }
            }

         cll = cll->next;
         free(PolyFromFile.x);
         free(PolyFromFile.y);
         free(PolyFromFile.z);
         }

      FreeLongList(&LongListRoot);
      LongListRoot = NULL;

      if(HadToOpenFile > 0)
         {
         fclose(fin);
         fin = NULL;
         HadToOpenFile = 0;
         }
      }



   if(DrawByConfig[12] > 0) /** are model library polygons to be described ? **/
      {
      FreeLongList(&LongListRoot);
      LongListRoot = NULL;
      modelPin = fopen(MPdatain,"rb");
      if(modelPin != NULL)
         {
         for(index1 = SXindex; index1 <= EXindex; index1 ++)
            {
            for(index2 = SYindex; index2 <= EYindex; index2 ++)
               {
               valuesread = 0;
               compositeindex = (index1 * (MaxYindex + 1)) + index2;
               if(NGA_TYPE == 0)
                  {
                  fseek(modelPin,ModelPolyTable[compositeindex].fileptr,SEEK_SET);
                  singles = ModelPolyTable[compositeindex].numinside;
                  multiples = ModelPolyTable[compositeindex].numother;

                  if(multiples > 0)
                     {
                     for(i=0; i<ModelPolyTable[compositeindex].numother; i++)
                        {
                        InsertIntoLongList(ModelPolyTable[compositeindex].others[i].fileptr,0,skiplimit,
                                        &LongListRoot,SkipList,&SkipEntry);
                        }
                     }
                  }
               else
                  {
                  singles = multiples = 0;
                  LongListRoot = NULL;
                  }

 /** below while loop looks at all inside region polygon objects **/
               multiples = 0;
               while(valuesread < singles)
                  {
                  vtxcnt = ReadPolyFromFile(modelPin,digits);
                  ++valuesread;
   
                  if(DO_DESCRIBE == 0)
                     {
                     free(PolyFromFile.x);
                     free(PolyFromFile.y);
                     free(PolyFromFile.z);
                     FreeLongList(&LongListRoot);
                     LongListRoot = NULL;
                     fclose(modelPin);
                     modelPin = NULL;
                     if(attrfileptr != NULL)
                        fclose(attrfileptr);
                     return;
                     }
  
                  Config = PolyFromFile.config;
                  Strat = PolyFromFile.stratum;
                  Domain = PolyFromFile.domain;

                  OKtoUse = 1;
                  if(NumLODbands > 0)
                     {
                     jj = CrsWlk[PolyFromFile.SACindex].LODband;
                     if((jj > 0) && (LODindex[jj-1].active < 1))
                        OKtoUse = 0;
                     }
                  if((OKtoUse > 0) && (DrawByStratum[Strat] > 0) && (DrawByDomain[Domain] > 0))
                     {
                     InRegion = 0;
                     if(PointQuery == 1)
                        {
                        if(vtxcnt == 3)
                           {
                           if(PointInsideTriangle(PointX,PointY,PolyFromFile.x[0],PolyFromFile.y[0],
                                   PolyFromFile.x[1],PolyFromFile.y[1],PolyFromFile.x[2],PolyFromFile.y[2]))
                              {
                              InRegion = 3;
                              }
                           }
                        else if(PointInsidePoly(PointX,PointY,PolyFromFile.x,PolyFromFile.y,vtxcnt))
                           {
                           InRegion = vtxcnt;
                           }
                        }
                     else
                        {
                        for(i=0; i<vtxcnt; i++)
                           {
                           if((PolyFromFile.x[i] >= x1) && (PolyFromFile.x[i] <= x2) &&
                                    (PolyFromFile.y[i] >= y1) && (PolyFromFile.y[i] <= y2))
                              ++InRegion;
                           else
                              break;
                           } 
                        if(InRegion < vtxcnt)
                           {
                           if(BoxIntersectPerimeter(x1,y1,x2,y2,vtxcnt,PolyFromFile.x,PolyFromFile.y) > 0)
                              InRegion = vtxcnt;
                           }
                        }
                     if(InRegion == vtxcnt)
                        {
                        if(vtxcnt == 3)
                           {
                           surfacearea = TriangleSurfaceArea(PolyFromFile.x,PolyFromFile.y,PolyFromFile.z);
                           }
                        else
                           {
                           surfacearea = SurfaceAreaByTriangles(vtxcnt,PolyFromFile.x,PolyFromFile.y,PolyFromFile.z);
                           }
                        PlaneEquation(&PA,&PB,&PC,&PD,PolyFromFile.x,PolyFromFile.y,PolyFromFile.z,vtxcnt);
                        IPC.ECC = SCCtable[PolyFromFile.SCCindex].ECC;
                        IPC.geom = C_MOLI;
                        IPC.innerings = NULL;
                        IPC.area = surfacearea;
                        IPC.FID = -1;
                        IPC.numcoords = PolyFromFile.numverts;
                        IPC.IDstr = NULL;
                        if(IPC.numcoords > 0)
                           {
                           IPC.X = (double *) (malloc(SzD * IPC.numcoords));
                           IPC.Y = (double *) (malloc(SzD * IPC.numcoords));
                           IPC.Z = (double *) (malloc(SzD * IPC.numcoords));
                           if(IPC.Z == NULL)
                              {
                              printf("available memory has been exhausted during coordinate printing\n");
                              printf("requested memory allocation to print %d coordinates\n",IPC.numcoords);
                              exit(-1);
                              }
                           }
                        else
                           {
                           IPC.X = NULL;
                           IPC.Y = NULL;
                           IPC.Z = NULL;
                           }
                        for(j=0; j<IPC.numcoords; j++)
                           {
                           IPC.X[j] = PolyFromFile.x[j];
                           IPC.Y[j] = PolyFromFile.y[j];
                           IPC.Z[j] = PolyFromFile.z[j];
                           }

                        FillInAttributeFields(PolyFromFile.SACindex, attrfileptr);

                        TempInfoPrint(PolyFromFile.idn);
                        }
                     }
                  free(PolyFromFile.x);
                  free(PolyFromFile.y);
                  free(PolyFromFile.z);
                  }
               } /** end for index2 **/
            }  /** end for index1 **/
   
         cll = LongListRoot;
         while(cll != NULL)
            {
            fseek(modelPin,cll->fp,SEEK_SET);
            vtxcnt = ReadPolyFromFile(modelPin,multiplier);
            if(feof(modelPin) != 0)
               break;

            if(DO_DESCRIBE == 0)
               {
               free(PolyFromFile.x);
               free(PolyFromFile.y);
               free(PolyFromFile.z);
               FreeLongList(&LongListRoot);
               LongListRoot = NULL;
               fclose(modelPin);
               modelPin = NULL;
               if(attrfileptr != NULL)
                  fclose(attrfileptr);
               return;
               }

            Config = PolyFromFile.config;
            Strat = PolyFromFile.stratum;
            Domain = PolyFromFile.domain;

            OKtoUse = 1;
            if(NumLODbands > 0)
               {
               jj = CrsWlk[PolyFromFile.SACindex].LODband;
               if((jj > 0) && (LODindex[jj-1].active < 1))
                  OKtoUse = 0;
               }

            if((OKtoUse > 0)  && (DrawByStratum[Strat] > 0) && (DrawByDomain[Domain] > 0))
               {
               InRegion = 0;
               if(PointQuery == 1)
                  {
                  if(vtxcnt == 3)
                     {
                     if(PointInsideTriangle(PointX,PointY,PolyFromFile.x[0],PolyFromFile.y[0],
                             PolyFromFile.x[1],PolyFromFile.y[1],PolyFromFile.x[2],PolyFromFile.y[2]))
                        {
                        InRegion = 3;
                        }
                     }
                  else if(PointInsidePoly(PointX,PointY,PolyFromFile.x,PolyFromFile.y,vtxcnt))
                     {
                     InRegion = vtxcnt;
                     }
                  }
               else
                  {
                  for(i=0; i<vtxcnt; i++)
                     {
                     if((PolyFromFile.x[i] >= x1) && (PolyFromFile.x[i] <= x2) &&
                              (PolyFromFile.y[i] >= y1) && (PolyFromFile.y[i] <= y2))
                        ++InRegion;
                        else
                           break;
                     } 
                  if(InRegion < vtxcnt)
                     {
                     if(BoxIntersectPerimeter(x1,y1,x2,y2,vtxcnt,PolyFromFile.x,PolyFromFile.y) > 0)
                        InRegion = vtxcnt;
                     }
                  }
               if(InRegion == vtxcnt)
                  {
                  if(vtxcnt == 3)
                     {
                     surfacearea = TriangleSurfaceArea(PolyFromFile.x,PolyFromFile.y,PolyFromFile.z);
                     }
                  else
                     {
                     surfacearea = SurfaceAreaByTriangles(vtxcnt,PolyFromFile.x,PolyFromFile.y,PolyFromFile.z);
                     }
                  PlaneEquation(&PA,&PB,&PC,&PD,PolyFromFile.x,PolyFromFile.y,PolyFromFile.z,vtxcnt);
               IPC.ECC = SCCtable[PolyFromFile.SCCindex].ECC;
               IPC.geom = C_MOLI;
               IPC.innerings = NULL;
               IPC.area = surfacearea;
               IPC.FID = -1;
               IPC.numcoords = PolyFromFile.numverts;
               IPC.IDstr = NULL;
               if(IPC.numcoords > 0)
                  {
                  IPC.X = (double *) (malloc(SzD * IPC.numcoords));
                  IPC.Y = (double *) (malloc(SzD * IPC.numcoords));
                  IPC.Z = (double *) (malloc(SzD * IPC.numcoords));
                  if(IPC.Z == NULL)
                     {
                     printf("available memory has been exhausted during coordinate printing\n");
                     printf("requested memory allocation to print %d coordinates\n",IPC.numcoords);
                     exit(-1);
                     }
                  }
               else
                  {
                  IPC.X = NULL;
                  IPC.Y = NULL;
                  IPC.Z = NULL;
                  }
               for(j=0; j<IPC.numcoords; j++)
                  {
                  IPC.X[j] = PolyFromFile.x[j];
                  IPC.Y[j] = PolyFromFile.y[j];
                  IPC.Z[j] = PolyFromFile.z[j];
                  }

               FillInAttributeFields(PolyFromFile.SACindex, attrfileptr);

               TempInfoPrint(PolyFromFile.idn);
                  }
               }
   
            cll = cll->next;
            free(PolyFromFile.x);
            free(PolyFromFile.y);
            free(PolyFromFile.z);
            }
   
         FreeLongList(&LongListRoot);
         LongListRoot = NULL;
   
         fclose(modelPin);
         modelPin = NULL;
         }
      }





   linin = fopen(linearsin,"rb");
   filenumber = 0;

   if(LinearFromFile.MaxNodes == 0)
      {
      LinearFromFile.MaxNodes = 1000;
      LinearFromFile.x = (double *) (malloc(LinearFromFile.MaxNodes * SzD));
      LinearFromFile.y = (double *) (malloc(LinearFromFile.MaxNodes * SzD));
      LinearFromFile.z = (double *) (malloc(LinearFromFile.MaxNodes * SzD));
      }


   if((linin != NULL) && ((DrawByConfig[2] > 0) || (DrawByConfig[4] > 0) || (DrawByConfig[14] > 0))) /* tim */
      {
      tolerance = (10.0 * RegionSize) / xunits;
      if(tolerance > 3.0)
         tolerance = 3.0;

      FreeLongList(&LongListRoot);

      for(index1 = SXindex; index1 <= EXindex; index1++)
         {
         for(index2 = SYindex; index2 <= EYindex; index2++)
            {
            compositeindex = (index1 * (MaxYindex + 1)) + index2;

            for(i=0; i<LinearTable[compositeindex].numother; i++)
               {
               fo = fileoffset * LinearTable[compositeindex].others[i].filenumber + LinearTable[compositeindex].others[i].fileptr;
               InsertIntoLongList(fo,LinearTable[compositeindex].others[i].filenumber,skiplimit,
                                  &LongListRoot,SkipList,&SkipEntry);
               }

            k = LinearTable[compositeindex].numinside;

            if(k > 0)
               {
               if(LinearTable[compositeindex].filenumber != filenumber)
                  {
                  filenumber = LinearTable[compositeindex].filenumber;
                  sprintf(suffix,"%d",filenumber);
                  strcpy(afilein,linearsin);
                  if(filenumber > 0)
                     strcat(afilein,suffix);
                  fclose(linin);
                  linin = fopen(afilein,"rb");
                  if(linin == NULL)
                     {
                     printf("5 linear data input file %s could not be opened for read\n",afilein);
                     exit(-1);
                     }
                  }
               fseek(linin,LinearTable[compositeindex].fileptr,SEEK_SET);

               i = 0;
               while(i < k)
                  {
                  j = ReadLinearFromFile(linin, multiplier);
                  ++i;
                  if(j > 0)
                     {

                     if(DO_DESCRIBE == 0)
                        {
                        FreeLongList(&LongListRoot);
                        LongListRoot = NULL;
                        if(linin != NULL)
                           fclose(linin);
                        if(attrfileptr != NULL)
                           fclose(attrfileptr);
                        return;
                        }
                     Config = LinearFromFile.config;
                     Strat = LinearFromFile.stratum;
                     Domain = LinearFromFile.domain;

                     OKtoUse = 1;
                     if(NumLODbands > 0)
                        {
                        jj = CrsWlk[LinearFromFile.Lindex].LODband;
                        if((jj > 0) && (LODindex[jj-1].active < 1))
                           OKtoUse = 0;
                        }

                     if((OKtoUse > 0) && (DrawByStratum[Strat] > 0) && (DrawByDomain[Domain] > 0) && (DrawByConfig[Config] > 0))
                        {
                        for(j=1; j<LinearFromFile.numnodes; j++)
                           {
                           InRegion = LineWithinQueryBox(x1, y1, x2, y2,LinearFromFile.x[j-1],LinearFromFile.y[j-1],LinearFromFile.z[j-1],
                                           LinearFromFile.x[j],LinearFromFile.y[j], LinearFromFile.z[j], LinearFromFile.Sindex,
                                           LinearFromFile.Lindex,
                                           /***LinearID,**/Strat,Domain, LinearFromFile.featureid,/**LinearID,**/attrfileptr);
                           if(InRegion > 0)
                              break;
                           }
                        }
                     }
                  }
               }
            }
         }
      cll = LongListRoot;
      while(cll != NULL)
         {
         if(cll->fn != filenumber)
            {
            filenumber = cll->fn;
            sprintf(suffix,"%d",filenumber);
            strcpy(afilein,linearsin);
            if(filenumber > 0)
              strcat(afilein,suffix);
            fclose(linin);
            linin = fopen(afilein,"rb");
            if(linin == NULL)
               {
               printf("6 linear data input file %s could not be opened for read\n",afilein);
               exit(-1);
               }
            }
         fo = cll->fp - (fileoffset * cll->fn);
         fseek(linin,fo,SEEK_SET);


         j = ReadLinearFromFile(linin, multiplier);
         if(j > 0)
            {
            Config = LinearFromFile.config;
            Strat = LinearFromFile.stratum;
            Domain = LinearFromFile.domain;

            if(DO_DESCRIBE == 0)
               {
               FreeLongList(&LongListRoot);
               LongListRoot = NULL;
               if(linin != NULL)
                  fclose(linin);
               if(attrfileptr != NULL)
                  fclose(attrfileptr);
               return;
               }

            OKtoUse = 1;
            if(NumLODbands > 0)
               {
               jj = CrsWlk[LinearFromFile.Lindex].LODband;
               if((jj > 0) && (LODindex[jj-1].active < 1))
                  OKtoUse = 0;
               }

            if((OKtoUse > 0) && (DrawByStratum[Strat] > 0) && (DrawByDomain[Domain] > 0) && (DrawByConfig[Config] > 0))
               {
               for(j=1; j<LinearFromFile.numnodes; j++)
                  {
                  InRegion = LineWithinQueryBox(x1, y1, x2, y2,LinearFromFile.x[j-1],LinearFromFile.y[j-1],LinearFromFile.z[j-1],
                               LinearFromFile.x[j],LinearFromFile.y[j], LinearFromFile.z[j],
                               LinearFromFile.Sindex,LinearFromFile.Lindex,
                                         /**LinearID,**/Strat,Domain, LinearFromFile.featureid,/**LinearID,**/attrfileptr);
                  if(InRegion > 0)
                     {
                     break;
                     }
                  }
               }
            }

         cll = cll->next;
         }

      FreeLongList(&LongListRoot);
      }
   if(linin != NULL)
      fclose(linin);





   arin = fopen(arealsin,"rb");
   if(
      (arin != NULL) && 
      (  (DrawByConfig[1] > 0) || (DrawByConfig[15] > 0) )  /* tim */
      )

      {
      FreeLongList(&LongListRoot);

      AssembleAreals(SXindex,EXindex,SYindex,EYindex);

      alrc = ArealListRoot;
      while(alrc != NULL)
         {
         if(alrc->ishole < 0)
            alrc->ishole = 0;
         alrc = alrc->next;
         }

      alrc = ArealListRoot;
      while(alrc != NULL)
         {
         HoleDescribed = 0;
         InRegion = 0;
         if(PointQuery > 0)
            {
            rac = PointInsideComplexAreal(PointX,PointY,alrc,&inareal);
            if(inareal == 1)
               {
               InRegion = 1;
               }
            else if(inareal == 2)
               {
               ++HoleDescribed;

               IPC.ECC = SCCtable[alrc->Sindex].ECC;
               IPC.geom = C_AREA;
               IPC.innerings = NULL;
               IPC.ishole = rac->ishole + (3 * rac->notclosed);
               IPC.area = rac->area; 
               IPC.length = rac->perimlength;
               IPC.FID = alrc->featureid;
               IPC.numcoords = rac->numverts;
               IPC.IDstr = NULL;
               if(IPC.numcoords > 0)
                  {
                  IPC.X = (double *) (malloc(SzD * IPC.numcoords));
                  IPC.Y = (double *) (malloc(SzD * IPC.numcoords));
                  IPC.Z = (double *) (malloc(SzD * IPC.numcoords));
                  if(IPC.Z == NULL)
                     {
                     printf("available memory has been exhausted during coordinate printing\n");
                     printf("requested memory allocation to print %d coordinates\n",IPC.numcoords);
                     exit(-1);
                     }
                  }
               else
                  {
                  IPC.X = NULL;
                  IPC.Y = NULL;
                  IPC.Z = NULL;
                  }
               for(j=0; j<IPC.numcoords; j++)
                  {
                  IPC.X[j] = rac->x[j];
                  IPC.Y[j] = rac->y[j];
                  IPC.Z[j] = rac->z[j];
                  }

               FillInAttributeFields(alrc->Lindex, attrfileptr);

               TempInfoPrint(alrc->idn);
               }
            }
         else if(PointQuery == 0)
            {
            for(j=0; j<alrc->numverts; j++)
               {
               if((alrc->x[j] >= x1) && (alrc->x[j] <= x2) &&
                        (alrc->y[j] >= y1) && (alrc->y[j] <= y2))
                  ++InRegion;
               else
                  break;
               }
            if(j < alrc->numverts)
               InRegion = 0;
            rac = alrc->holes;
            while(rac != NULL)
               {
/** if box contains areal, then it also contains all area feature cut outs ***/
/** otherwise, box might contain some cut outs (but not the parent areal) **/
               if(InRegion == 0) 
                  {
                  inareal = 0;
                  for(j=0; j<rac->numverts; j++)
                     {
                     if((rac->x[j] >= x1) && (rac->x[j] <= x2) &&
                              (rac->y[j] >= y1) && (rac->y[j] <= y2))
                        ++inareal;
                     else
                        break;
                     }
                  if(j < rac->numverts)
                     inareal = 0;
                  }
               if((InRegion > 0) || (inareal > 0))
                  {
                  ++HoleDescribed;

                  IPC.ECC = SCCtable[alrc->Sindex].ECC;
                  IPC.geom = C_AREA;
                  IPC.ishole = rac->ishole + (3 * rac->notclosed);
                  IPC.area = rac->area;
                  IPC.innerings = NULL;
                  IPC.length = rac->perimlength;
                  IPC.FID = alrc->featureid;
                  IPC.numcoords = rac->numverts;
                  IPC.IDstr = NULL;
                  if(IPC.numcoords > 0)
                     {
                     IPC.X = (double *) (malloc(SzD * IPC.numcoords));
                     IPC.Y = (double *) (malloc(SzD * IPC.numcoords));
                     IPC.Z = (double *) (malloc(SzD * IPC.numcoords));
                     if(IPC.Z == NULL)
                        {
                        printf("available memory has been exhausted during coordinate printing\n");
                        printf("requested memory allocation to print %d coordinates\n",IPC.numcoords);
                        exit(-1);
                        }
                     }
                  else
                     {
                     IPC.X = NULL;
                     IPC.Y = NULL;
                     IPC.Z = NULL;
                     }
                  for(j=0; j<IPC.numcoords; j++)
                     {
                     IPC.X[j] = rac->x[j];
                     IPC.Y[j] = rac->y[j];
                     IPC.Z[j] = rac->z[j];
                     }

                  FillInAttributeFields(alrc->Lindex, attrfileptr);

                  TempInfoPrint(alrc->idn);
                  }
               rac = rac->next;
               }
            }
if((InRegion == 0) && (PointQuery == 0))
            {
            if(BoxIntersectPerimeter(x1,y1,x2,y2,alrc->numverts,alrc->x,alrc->y) > 0)
               {
               InRegion = 1;
               }
            rac = alrc->holes;
            while(rac != NULL)
               {
               if(BoxIntersectPerimeter(x1,y1,x2,y2,rac->numverts,rac->x,rac->y) > 0)
                  {
                  if(InRegion == 0)
                     alrc->temp += 1;


                  IPC.ECC = SCCtable[alrc->Sindex].ECC;
                  IPC.geom = C_AREA;
                  IPC.ishole = rac->ishole + (3 * rac->notclosed);
                  IPC.area = rac->area;
                  IPC.innerings = NULL;
                  IPC.length = rac->perimlength;
                  IPC.FID = alrc->featureid;
                  IPC.numcoords = rac->numverts;
                  IPC.IDstr = NULL;
                  if(IPC.numcoords > 0)
                     {
                     IPC.X = (double *) (malloc(SzD * IPC.numcoords));
                     IPC.Y = (double *) (malloc(SzD * IPC.numcoords));
                     IPC.Z = (double *) (malloc(SzD * IPC.numcoords));
                     if(IPC.Z == NULL)
                        {
                        printf("available memory has been exhausted during coordinate printing\n");
                        printf("requested memory allocation to print %d coordinates\n",IPC.numcoords);
                        exit(-1);
                        }
                     }
                  else
                     {
                     IPC.X = NULL;
                     IPC.Y = NULL;
                     IPC.Z = NULL;
                     }
                  for(j=0; j<IPC.numcoords; j++)
                     {
                     IPC.X[j] = rac->x[j];
                     IPC.Y[j] = rac->y[j];
                     IPC.Z[j] = rac->z[j];
                     }
   
                  FillInAttributeFields(alrc->Lindex, attrfileptr);

                  TempInfoPrint(alrc->idn);
                  }
               rac = rac->next;
               }
            }


         if((InRegion == 0) && (PointQuery == 0))
            {
            if(MAKEBOXLIKEPOINTQUERY > 0)
               {
               rac = PointInsideComplexAreal(x1,y1,alrc,&inareal);
               if(inareal == 1)
                  {
                  InRegion = 1;
                  }
               else if(inareal == 2)
                  { 
                  ++HoleDescribed;
   
                  IPC.ECC = SCCtable[alrc->Sindex].ECC;
                  IPC.geom = C_AREA;
                  IPC.ishole = rac->ishole + (3 * rac->notclosed);
                  IPC.area = rac->area;
                  IPC.innerings = NULL;
                  IPC.length = rac->perimlength;
                  IPC.FID = alrc->featureid;
                  IPC.numcoords = rac->numverts;
                  IPC.IDstr = NULL;
                  if(IPC.numcoords > 0)
                     {
                     IPC.X = (double *) (malloc(SzD * IPC.numcoords));
                     IPC.Y = (double *) (malloc(SzD * IPC.numcoords));
                     IPC.Z = (double *) (malloc(SzD * IPC.numcoords));
                     if(IPC.Z == NULL)
                        {
                        printf("available memory has been exhausted during coordinate printing\n");
                        printf("requested memory allocation to print %d coordinates\n",IPC.numcoords);
                        exit(-1);
                        }
                     }
                  else
                     {
                     IPC.X = NULL;
                     IPC.Y = NULL;
                     IPC.Z = NULL;
                     }
                  for(j=0; j<IPC.numcoords; j++)
                     {
                     IPC.X[j] = rac->x[j];
                     IPC.Y[j] = rac->y[j];
                     IPC.Z[j] = rac->z[j];
                     }
                  FillInAttributeFields(alrc->Lindex, attrfileptr);

                  TempInfoPrint(alrc->idn);
                  }
               }
            }


         if(InRegion > 0)
            {
            IPC.ECC = SCCtable[alrc->Sindex].ECC;
            IPC.geom = C_AREA;
            IPC.ishole = alrc->ishole + (3 * alrc->notclosed);
            IPC.area = alrc->area;
            IPC.innerings = NULL;
            IPC.length = alrc->perimlength;
            IPC.FID = alrc->featureid;
            IPC.numcoords = alrc->numverts;
            IPC.IDstr = NULL;
            if(IPC.numcoords > 0)
               {
               IPC.X = (double *) (malloc(SzD * IPC.numcoords));
               IPC.Y = (double *) (malloc(SzD * IPC.numcoords));
               IPC.Z = (double *) (malloc(SzD * IPC.numcoords));
               if(IPC.Z == NULL)
                  {
                  printf("available memory has been exhausted during coordinate printing\n");
                  printf("requested memory allocation to print %d coordinates\n",IPC.numcoords);
                  exit(-1);
                  }
               }
            else
               {
               IPC.X = NULL;
               IPC.Y = NULL;
               IPC.Z = NULL;
               }
            for(j=0; j<IPC.numcoords; j++)
               {
               IPC.X[j] = alrc->x[j];
               IPC.Y[j] = alrc->y[j];
               IPC.Z[j] = alrc->z[j];
               }

            FillInAttributeFields(alrc->Lindex, attrfileptr);

            if(alrc->holes == NULL)
               {
               IPC.innerings = NULL;
               }
            else
               {
               IPC.innerings = NULL;
               rac = alrc->holes;
               while(rac != NULL)
                  {
                  IPCring = (struct AreaRing *) (malloc(SzInner));
                  if(IPCring == NULL)
                     {
                     printf("all available memory has been allocated during area feature inner ring assembly for query response\n");
                     break;
                     }
                  else
                     {
                     IPCring->numverts = rac->numverts;
                     IPCring->x = (double *) (malloc(SzD * rac->numverts + 1));
                     IPCring->y = (double *) (malloc(SzD * rac->numverts + 1));
                     IPCring->z = (double *) (malloc(SzD * rac->numverts + 1));
                     if(IPCring->z == NULL)
                        {
                        printf("all available memory has been allocated during area feature inner ring assembly for query response\n");
                        if(IPCring->y != NULL)
                          free(IPCring->y);
                        if(IPCring->x != NULL)
                          free(IPCring->x);
                        if(IPCring != NULL)
                          free(IPCring);
                        break;
                        }
                     else
                        {
                        for(j=0; j<rac->numverts; j++)
                           {
                           IPCring->x[j] = rac->x[j];
                           IPCring->y[j] = rac->y[j];
                           IPCring->z[j] = rac->z[j];
                           }
                        IPCring->next = IPC.innerings;
                        IPC.innerings = IPCring;
                        }
                     }
                  rac = rac->next;
                  }
               }

            TempInfoPrint(alrc->idn);
            }


         alrc = alrc->next;
         
         }

      alrc = ArealListRoot;
      while(alrc != NULL)
         {
/*** if an area feature cut-out was intesected by a query box, then should have set the parent temp field to be > 0
 * will also draw the parent in info mode here since (technically) intersected a inner perimeter of the parent ***/
         if(alrc->temp > 0)
            {
            IPC.ECC = SCCtable[alrc->Sindex].ECC;
            IPC.geom = C_AREA;
            IPC.ishole = alrc->ishole + (3 * alrc->notclosed);
            IPC.area = alrc->area;
            IPC.length = alrc->perimlength;
            IPC.FID = alrc->featureid;
            IPC.numcoords = alrc->numverts;
            IPC.IDstr = NULL;
            if(IPC.numcoords > 0)
               {
               IPC.X = (double *) (malloc(SzD * IPC.numcoords));
               IPC.Y = (double *) (malloc(SzD * IPC.numcoords));
               IPC.Z = (double *) (malloc(SzD * IPC.numcoords));
               if(IPC.Z == NULL)
                  {
                  printf("available memory has been exhausted during coordinate printing\n");
                  printf("requested memory allocation to print %d coordinates\n",IPC.numcoords);
                  exit(-1);
                  }
               }
            else
               {
               IPC.X = NULL;
               IPC.Y = NULL;
               IPC.Z = NULL;
               }
            for(j=0; j<IPC.numcoords; j++)
               {
               IPC.X[j] = alrc->x[j];
               IPC.Y[j] = alrc->y[j];
               IPC.Z[j] = alrc->z[j];
               }

            if(alrc->holes == NULL)
               {
               IPC.innerings = NULL;
               }
            else
               {
               IPC.innerings = NULL;
               rac = alrc->holes;
               while(rac != NULL)
                  {
                  IPCring = (struct AreaRing *) (malloc(SzInner));
                  if(IPCring == NULL)
                     {
                     printf("all available memory has been allocated during area feature inner ring assembly for query response\n");
                     break;
                     }
                  else
                     {
                     IPCring->numverts = rac->numverts;
                     IPCring->x = (double *) (malloc(SzD * rac->numverts + 1));
                     IPCring->y = (double *) (malloc(SzD * rac->numverts + 1));
                     IPCring->z = (double *) (malloc(SzD * rac->numverts + 1));
                     if(IPCring->z == NULL)
                        {
                        printf("all available memory has been allocated during area feature inner ring assembly for query response\n");
                        if(IPCring->y != NULL)
                          free(IPCring->y);
                        if(IPCring->x != NULL)
                          free(IPCring->x);
                        if(IPCring != NULL)
                          free(IPCring);
                        break;
                        }
                     else
                        {
                        for(j=0; j<rac->numverts; j++)
                           {
                           IPCring->x[j] = rac->x[j];
                           IPCring->y[j] = rac->y[j];
                           IPCring->z[j] = rac->z[j];
                           }
                        IPCring->next = IPC.innerings;
                        IPC.innerings = IPCring;
                        }
                     }
                  rac = rac->next;
                  }
               }


            FillInAttributeFields(alrc->Lindex, attrfileptr);

            TempInfoPrint(alrc->idn);
            }

         alrp = alrc;
         alrc = alrc->next;
         if(alrp->holes != NULL)
            {
            rac = alrp->holes;
            while(rac != NULL)
               {
               rap = rac;
               rac = rac->next;
               free(rap->x);
               free(rap->y);
               free(rap->z);
               if(rap->areastr != NULL)
                  free(rap->areastr);
               if(rap->zv2str != NULL)
                  free(rap->zv2str);
               if(rap->hgtstr != NULL)
                  free(rap->hgtstr);
               if(rap->lenstr != NULL)
                  free(rap->lenstr);
               if(rap->namstr != NULL)
                  free(rap->namstr);
               free(rap);
               }
            }
         free(alrp->x);
         free(alrp->y);
         free(alrp->z);
         if(alrp->areastr != NULL)
            free(alrp->areastr);
         if(alrp->zv2str != NULL)
            free(alrp->zv2str);
         if(alrp->hgtstr != NULL)
            free(alrp->hgtstr);
         if(alrp->lenstr != NULL)
            free(alrp->lenstr);
         if(alrp->namstr != NULL)
            free(alrp->namstr);
         free(alrp);
         }
      ArealListRoot = NULL;


      }

   index1 = DrawByConfig[3] + DrawByConfig[5] + DrawByConfig[6];
   index1 += DrawByConfig[10] + DrawByConfig[11] + DrawByConfig[13]; /* tim */
   ptsin = NULL;
   if(index1 > 0)
      ptsin = fopen(pointsin,"rb");
   if(ptsin != NULL)
      {
      FreeLongList(&LongListRoot);

      for(index1 = SXindex; index1 <= EXindex; index1++)
         {
         for(index2 = SYindex; index2 <= EYindex; index2++)
            {
            compositeindex = (index1 * (MaxYindex + 1)) + index2;

            for(i=0; i<PointTable[compositeindex].numother; i++)
               {
               InsertIntoLongList(PointTable[compositeindex].others[i].fileptr,0,skiplimit,
                                  &LongListRoot,SkipList,&SkipEntry);
               }
            if( PointTable[compositeindex].numinside > 0)
               {
               fseek(ptsin,PointTable[compositeindex].fileptr,SEEK_SET);
               i = 0;
               while(i <  PointTable[compositeindex].numinside)
                  {
                  vtxcnt = ReadPointFromFile(ptsin, multiplier);
                  Config = PointFromFile.config;
                  Strat = PointFromFile.stratum;
                  Domain = PointFromFile.domain;

                  if(DO_DESCRIBE == 0)
                     {
                     FreeLongList(&LongListRoot);
                     LongListRoot = NULL;
                     if(ptsin != NULL)
                        fclose(ptsin);
                     if(attrfileptr != NULL)
                        fclose(attrfileptr);
                     return;
                     }

                  OKtoUse = 1;
                  if(NumLODbands > 0)
                     {
                     jj = CrsWlk[PointFromFile.Lindex].LODband;
                     if((jj > 0) && (LODindex[jj-1].active < 1))
                        OKtoUse = 0;
                     }

                  if((OKtoUse > 0) && (DrawByConfig[Config] > 0) && (DrawByStratum[Strat] > 0) && (DrawByDomain[Domain] > 0))
                     {
                     InRegion = 0;
                     if(PointQuery == 1)
                        {
                        if((PointFromFile.numverts < 1) && (PointFromFile.numverts > -3))
                           {
                           if((x1 <= PointFromFile.x[0]) && (PointFromFile.x[0] <= x2) && 
                                 (y1 <= PointFromFile.y[0]) && (PointFromFile.y[0] <= y2))
                              InRegion = 1;
                           }
                        else if(PointInsidePoly(x1, y1,PointFromFile.x,PointFromFile.y,vtxcnt))
                           InRegion = 1;
                        }
                     else /** a box type query **/
                        {
                        if((PointFromFile.numverts < 1) && (PointFromFile.numverts > -3))
                           {
                           if((x1 <= PointFromFile.x[0]) && (PointFromFile.x[0] <= x2) &&
                                 (y1 <= PointFromFile.y[0]) && (PointFromFile.y[0] <= y2))
                              InRegion = 1;
                           }
                        else
                           {
                           for(j=0; j<vtxcnt; j++)
                              {
                              if((PointFromFile.x[j] >= x1) && (PointFromFile.x[j] <= x2) &&
                                     (PointFromFile.y[j] >= y1) && (PointFromFile.y[j] <= y2))
                                 ++InRegion;
                              else
                                 break;
                              }
                           if(j < vtxcnt)
                              InRegion = 0;
                           }
                        }
                     if(InRegion > 0)
                        {

                        IPC.ECC = SCCtable[PointFromFile.Sindex].ECC;
                        IPC.length = 0.0;
                        if(PointFromFile.numverts == 0)
                           IPC.geom = C_POMO;
                        else if(PointFromFile.numverts == -1)
                           IPC.geom = C_POFE;
                        else if(PointFromFile.numverts == -2)
                           IPC.geom = C_COVS;
                        else if(PointFromFile.numverts <= -3)
                           IPC.geom = C_COVP;
                        else
                           {
                           printf("unexpected number of vertices flag on point data: %d\n",PointFromFile.numverts);
                           exit(-1);
                           }
                        IPC.FID = PointFromFile.featureid;
                        IPC.numcoords = vtxcnt;
                        IPC.innerings = NULL;
                        IPC.IDstr = NULL;
                        if(IPC.numcoords > 0)
                           {
                           IPC.X = (double *) (malloc(SzD * IPC.numcoords));
                           IPC.Y = (double *) (malloc(SzD * IPC.numcoords));
                           IPC.Z = (double *) (malloc(SzD * IPC.numcoords));
                           if(IPC.Z == NULL)
                              {
                              printf("available memory has been exhausted during coordinate printing\n");
                              printf("requested memory allocation to print %d coordinates\n",IPC.numcoords);
                              exit(-1);
                              }
                           }
                        else
                           {
                           IPC.X = NULL;
                           IPC.Y = NULL;
                           IPC.Z = NULL;
                           }
                        for(j=0; j<IPC.numcoords; j++)
                           {
                           IPC.X[j] = PointFromFile.x[j];
                           IPC.Y[j] = PointFromFile.y[j];
                           IPC.Z[j] = PointFromFile.z[j];
                           }

                        FillInAttributeFields(PointFromFile.Lindex, attrfileptr);
			IPC.radius = PointFromFile.rad;
                        TempInfoPrint(PointFromFile.idn);

                        }
                     }
                  ++i;
                  }
               }
            }
         }
      cll = LongListRoot;
      while(cll != NULL)
         {
         fseek(ptsin,cll->fp,SEEK_SET);
         vtxcnt = ReadPointFromFile(ptsin, multiplier);
         Config = PointFromFile.config;
         Strat = PointFromFile.stratum;
         Domain = PointFromFile.domain;

         if(DO_DESCRIBE == 0)
            {
            FreeLongList(&LongListRoot);
            LongListRoot = NULL;
            if(ptsin != NULL)
               fclose(ptsin);
            if(attrfileptr != NULL)
               fclose(attrfileptr);
            return;
            }

         OKtoUse = 1;
         if(NumLODbands > 0)
            {
            jj = CrsWlk[PointFromFile.Lindex].LODband;
            if((jj > 0) && (LODindex[jj-1].active < 1))
               OKtoUse = 0;
            }

         if((OKtoUse > 0) && (DrawByConfig[Config] > 0) && (DrawByStratum[Strat] > 0) && (DrawByDomain[Domain] > 0))
            {
            InRegion = 0;
            if(PointQuery == 1)
               {
               if((PointFromFile.numverts > -3) && (PointFromFile.numverts < 1))
                  {
                  if((x1 <= PointFromFile.x[0]) && (PointFromFile.x[0] <= x2) &&
                        (y1 <= PointFromFile.y[0]) && (PointFromFile.y[0] <= y2))
                     InRegion = 1;
                  }
               else if(PointInsidePoly(x1, y1,PointFromFile.x,PointFromFile.y,vtxcnt))
                  InRegion = 1;
               }
            else /** a box type query **/
               {
               if((PointFromFile.numverts < 1) && (PointFromFile.numverts > -3))
                  {
                  if((x1 <= PointFromFile.x[0]) && (PointFromFile.x[0] <= x2) &&
                       (PointFromFile.y[0] <= y1) && (PointFromFile.y[0] <= y2))
                     InRegion = 1;
                  }
               else
                  {
                  for(j=0; j<vtxcnt; j++)
                     {
                     if((PointFromFile.x[j] >= x1) && (PointFromFile.x[j] <= x2) &&
                             (PointFromFile.y[j] >= y1) && (PointFromFile.y[j] <= y2))
                        ++InRegion;
                     else
                        break;
                     }
                  if(j < vtxcnt)
                     InRegion = 0;
                  }
               }
            if(InRegion > 0)
               {
               IPC.length = 0.0;
               IPC.ECC = SCCtable[PointFromFile.Sindex].ECC;
               if(PointFromFile.numverts == 0)
                  IPC.geom = C_POMO;
               else if(PointFromFile.numverts == -1)
                  IPC.geom = C_POFE;
               else if(PointFromFile.numverts == -2)
                  IPC.geom = C_COVS;
               else if(PointFromFile.numverts <= -3)
                  IPC.geom = C_COVP;
               else
                  {
                  printf("unexpected number of vertices flag on point data: %d\n",PointFromFile.numverts);
                  exit(-1);
                  }
               IPC.FID = PointFromFile.featureid;
               IPC.innerings = NULL;
               IPC.numcoords = vtxcnt;
               IPC.IDstr = NULL;
               if(IPC.numcoords > 0)
                  {
                  IPC.X = (double *) (malloc(SzD * IPC.numcoords));
                  IPC.Y = (double *) (malloc(SzD * IPC.numcoords));
                  IPC.Z = (double *) (malloc(SzD * IPC.numcoords));
                  if(IPC.Z == NULL)
                     {
                     printf("available memory has been exhausted during coordinate printing\n");
                     printf("requested memory allocation to print %d coordinates\n",IPC.numcoords);
                     exit(-1);
                     }
                  }
               else
                  {
                  IPC.X = NULL;
                  IPC.Y = NULL;
                  IPC.Z = NULL;
                  }
               for(j=0; j<IPC.numcoords; j++)
                  {
                  IPC.X[j] = PointFromFile.x[j];
                  IPC.Y[j] = PointFromFile.y[j];
                  IPC.Z[j] = PointFromFile.z[j];
                  }

               FillInAttributeFields(PointFromFile.Lindex, attrfileptr);
	       IPC.radius = PointFromFile.rad;
               TempInfoPrint(PointFromFile.idn);
               }
            }

         cll = cll->next;
         }
      FreeLongList(&LongListRoot);
      if(ptsin != NULL)
         fclose(ptsin);
      }


   index1 = 0;
   brdgin = NULL;
   if(NGA_TYPE == 0)
      index1 = DrawByConfig[3] + DrawByConfig[5] + DrawByConfig[6];
   if(index1 > 0)
      brdgin = fopen(bridgesin,"rb");
   if(brdgin != NULL)
      {
      for(index1 = SXindex; index1 <= EXindex; index1++)
         {
         for(index2 = SYindex; index2 <= EYindex; index2++)
            {
            compositeindex = (index1 * (MaxYindex + 1)) + index2;

            k = BridgeTable[compositeindex].numinside + BridgeTable[compositeindex].numother;
            if(k > 0)
               {
               fseek(brdgin,BridgeTable[compositeindex].fileptr,SEEK_SET);
               ii = i = 0;
               while(i < k)
                  {
                  if(i >= BridgeTable[compositeindex].numinside)
                     {
                     fseek(brdgin,BridgeTable[compositeindex].others[ii].fileptr,SEEK_SET);
                     ++ii;
                     }
                  vtxcnt = ReadBridgeFromFile(brdgin, multiplier);
                  Config = BridgeFromFile.config;
                  Strat = BridgeFromFile.stratum;
                  Domain = BridgeFromFile.domain;

                  if(DO_DESCRIBE == 0)
                     {
                     free(BridgeFromFile.x);
                     free(BridgeFromFile.y);
                     free(BridgeFromFile.z);
                     free(BridgeFromFile.h);
                     if(brdgin != NULL)
                        fclose(brdgin);
                     if(attrfileptr != NULL)
                        fclose(attrfileptr);
                     return;
                     }

                  OKtoUse = 1;
                  if(NumLODbands > 0)
                     {
                     jj = CrsWlk[BridgeFromFile.Lindex].LODband;
                     if((jj > 0) && (LODindex[jj-1].active < 1))
                        OKtoUse = 0;
                     }

                  if((OKtoUse > 0) && (DrawByConfig[Config] > 0) && (DrawByStratum[Strat] > 0) && (DrawByDomain[Domain] > 0))
                     {
                     InRegion = 0;
                     if((PointQuery > 0) &&
                           (PointInsidePoly(PointX,PointY,BridgeFromFile.x,BridgeFromFile.y,BridgeFromFile.numverts)) > 0)
                        {
                        InRegion = 1;
                        }
                     else if(PointQuery == 0)
                        {
                        for(j=0; j<BridgeFromFile.numverts; j++)
                           {
                           if((BridgeFromFile.x[j] >= x1) && (BridgeFromFile.x[j] <= x2) &&
                                    (BridgeFromFile.y[j] >= y1) && (BridgeFromFile.y[j] <= y2))
                              ++InRegion;
                           else
                              break;
                           }
                        if(j < BridgeFromFile.numverts)
                           { 
                           if(BoxIntersectPerimeter(x1,y1,x2,y2,vtxcnt,PolyFromFile.x,PolyFromFile.y) > 0)
                              InRegion = vtxcnt;
                           else
                              InRegion = 0;
                           }
                        }
                     if(InRegion > 0)
                        {
                        IPC.ECC = SCCtable[BridgeFromFile.Sindex].ECC;
                        if(BridgeFromFile.numverts == 1)
                           IPC.geom = C_POMO;
                        if(BridgeFromFile.numverts == 2)
                           IPC.geom = C_LINE;
                        else
                           IPC.geom = C_FOMO;
                        IPC.FID = -1;
                        IPC.numcoords = BridgeFromFile.numverts;
                        IPC.innerings = NULL;
                        IPC.IDstr = NULL;
                        if(IPC.numcoords > 0)
                           {
                           IPC.X = (double *) (malloc(SzD * IPC.numcoords));
                           IPC.Y = (double *) (malloc(SzD * IPC.numcoords));
                           IPC.Z = (double *) (malloc(SzD * IPC.numcoords));
                           if(IPC.Z == NULL)
                              {
                              printf("available memory has been exhausted during coordinate printing\n");
                              printf("requested memory allocation to print %d coordinates\n",IPC.numcoords);
                              exit(-1);
                              }
                           }
                        else
                           {
                           IPC.X = NULL;
                           IPC.Y = NULL;
                           IPC.Z = NULL;
                           }
                        for(j=0; j<IPC.numcoords; j++)
                           {
                           IPC.X[j] = BridgeFromFile.x[j];
                           IPC.Y[j] = BridgeFromFile.y[j];
                           IPC.Z[j] = BridgeFromFile.z[j];
                           }

                        FillInAttributeFields(BridgeFromFile.Lindex, attrfileptr);

                        TempInfoPrint(BridgeFromFile.idn);
                        }
                     }
                  free(BridgeFromFile.x);
                  free(BridgeFromFile.y);
                  free(BridgeFromFile.z);
                  free(BridgeFromFile.h);
                  ++i;
                  }
               }
            }
         }
      if(brdgin != NULL)
         fclose(brdgin);
      }

   ptsin = NULL;
   if((NumberOfGrids > 0) && (DrawByConfig[9] > 0))  /** describing grid data ***/
      {
      Config = 9;
      ptsin = NULL;
      InRegion = 0;
      for(index1 = SXindex; index1 <= EXindex; index1++)
         {
         for(index2 = SYindex; index2 <= EYindex; index2++)
            {
            minx = (double) (index1) * RegionSize;
            maxx =  minx + RegionSize;
            miny = (double) (index2) * RegionSize;
            maxy =  miny + RegionSize;
            if(NumLODbands > 0)
               {
               for(k = 0; k < NumberOfGrids; k++)
                  {
                  jj = CrsWlk[GridHeader[k].Lindex].LODband;
                  if((jj > 0) && (LODindex[jj-1].active < 1))
                     GridsDone[k] = 1;
                  else
                     GridsDone[k] = 0;
                  }
               }
            compositeindex = (index1 * (MaxYindex + 1)) + index2;
            if((NGT[compositeindex].FileNumber != NULL) && (GridFileInUse != NGT[compositeindex].FileNumber[0]))
               {
               if(ptsin != NULL)
                  CloseGridFile(ptsin);
               ptsin = OpenGridFile(compositeindex,0);
               }

            k = NGT[compositeindex].NumGrids;
            if(k > 0) 
               {
               for(ii = 0; ii < k; ii++)
                  {

                  if(GridFileInUse != NGT[compositeindex].FileNumber[ii])
                     {
                     if(ptsin != NULL)
                        CloseGridFile(ptsin);
                     ptsin = OpenGridFile(compositeindex,ii);
                     }
                  if(ptsin == NULL)
                     continue;
                  ii2 = NGT[compositeindex].GridIndex[ii];
                  Strat = SCCtable[GridHeader[ii2].Sindex].S;
                  Domain = SCCtable[GridHeader[ii2].Sindex].D;

                  jj = 1;
                  if((jj > 0) && (NGA_TYPE == 1))
                     jj = DrawByDomain[Domain];
                  else
                     {
                     if((DrawByStratum[Strat] == 0) || (DrawByDomain[Domain] == 0))
                        jj = 0;
                     }
                  if(jj > 0) 
                     {
                     if(NGT[compositeindex].fileptr[ii] >= 0)
                        {
                        jj = ReadGridFromFile(ii2,ptsin, multiplier,compositeindex,NumberOfGrids,&NofCols,&LoadedGridMres);
                        GridNowLoaded = compositeindex;
                        LoadedGridRows = jj;
                        LoadedGridCols = NofCols;

                        if(NumLODbands > 0)
                           {
                           for(kk = 0; kk < NumberOfGrids; kk++)
                              {
                              if(CrsWlk[GridHeader[kk].Lindex].LODband == CrsWlk[GridHeader[ii2].Lindex].LODband)
                                 GridsDone[kk] = 1;
                              }
                           }


                        OKtoUse = 1;
                        jj = CrsWlk[GridHeader[ii2].Lindex].LODband;
                        if((jj > 0) && (LODindex[jj-1].active < 1))
                           OKtoUse = 0;
                        if(NumLODbands > 0)
                           kk = ii;
                        else
                           kk = 0;

                        if((OKtoUse > 0) && (MG[kk].numX > 0) && (MG[kk].numY > 0))
                           {
iStart = 0;
iEnd = MG[kk].numX;
jStart = 0;
jEnd = MG[kk].numY;


                           iX = iStart;
                           for(grows = iStart; grows < iEnd; grows++)
                              {
                              GridX = MG[kk].SouthWestX + ((double) iX * MG[kk].Xspace);
                              if((GridX >= minx) && (GridX <= maxx))
                                 {
                              iY = jStart;
                              for(gcols = jStart; gcols < jEnd; gcols++)
                                 {
                                 GridY = MG[kk].SouthWestY + ((double) iY * MG[kk].Yspace);

                                 if((GridY >= miny) && (GridY <= maxy))
                                    {
                                 if(DO_DESCRIBE == 0)
                                    break;
                                 if(PointQuery == 1)
                                    {
                                    if((x1 <= GridX) && (GridX <= x2) &&
                                          (y1 <= GridY) && (GridY <= y2))
                                       InRegion = 1;
                                    }
                                 else  /** a box area query **/
                                    {
                                    if((x1 <= GridX) && (GridX <= x2) &&
                                       (y1 <= GridY) && (GridY <= y2))
                                       InRegion = 1;
                                    }
                                 if(InRegion > 0)
                                    {
                                    GridZ = MG[kk].Elevs[(iX * MG[kk].numY) + iY];
                                    InRegion = 0;
                                    IPC.ECC = SCCtable[GridHeader[ii2].Sindex].ECC;
                                    IPC.FID = -100;
                                    IPC.innerings = NULL;
                                    IPC.geom = C_GRID;
                                    IPC.numcoords = 1;
                                    IPC.IDstr = NULL;
                                    if(IPC.numcoords > 0)
                                       {
                                       IPC.X = (double *) (malloc(SzD * IPC.numcoords));
                                       IPC.Y = (double *) (malloc(SzD * IPC.numcoords));
                                       IPC.Z = (double *) (malloc(SzD * IPC.numcoords));
                                       if(IPC.Z == NULL)
                                          {
                                          printf("available memory has been exhausted during coordinate printing\n");
                                          printf("requested memory allocation to print %d coordinates\n",IPC.numcoords);
                                          exit(-1);
                                          }
                                       }
                                    else
                                       {
                                       IPC.X = NULL;
                                       IPC.Y = NULL;
                                       IPC.Z = NULL;
                                       }
                                    for(j=0; j<IPC.numcoords; j++)
                                    {
                                       IPC.X[j] = GridX;
                                       IPC.Y[j] = GridY;
                                       IPC.Z[j] = GridZ;
                                       }

                                    FillInAttributeFields(GridHeader[ii2].Lindex, attrfileptr);
                        
                                    TempInfoPrint(GridHeader[ii2].idn);

                                    }
}

                                 ++iY;
                                 }
                                 }
                              ++iX;
                              }
                           } /*** end if if((MG[kk].numX > 0) && (MG[kk].numY > 0)) ***/


                        if(DO_DESCRIBE == 0)
                           {
                           if(GridsDone != NULL)
                              free(GridsDone);
                           if(ptsin != NULL)
                              CloseGridFile(ptsin);
                           if(attrfileptr != NULL)
                              fclose(attrfileptr);
                           return;
                           }
                        if(NumLODbands == 0)
                           break; /** from for(ii = 0; ii < NumberOfGrids; ii++) ****/
                        }
                     }
                  }
               }
            }
         }
      CloseGridFile(ptsin);
      }

   if(GridsDone != NULL)
      free(GridsDone);
   if(attrfileptr != NULL)
      fclose(attrfileptr);
}






void ReadProfileData(double x1,double y1,double x2,double y2)
{
FILE *ptsin;
int SzPoly;
int SzStamp = sizeof(struct StampModel);
int SzStatic = sizeof(struct StaticModel);
double minx, maxx,miny,maxy;
int NofCols;
int i,j, k, ii, kk, ii2, kk2;
int index1, index2, HadToOpenFile, Sx,Sy, Ex,Ey;
int valuesread, foundOne;
int OKtoUse;
int compositeindex,totalpoly,singles,multiples;
double digits;
double nx, ny, mingridx,maxgridx,mingridy,maxgridy;
int vtxcnt;
int gridallocsize;
int listlength;
double Xgrid[4], Ygrid[4], Zgrid[4];
int iX, iY;
int gcols,grows;
int GridID;
int processregion, duplicate, processgridsquare,PassTest;
/**int findex = 0;**/
struct StampModel *cstamp,*nstamp;
struct StaticModel *cstatic, *nstatic;
struct ThePolys *cpoly, *npoly;
   if(x1 < x2)
      {
      Sx = (int) (x1 / RegionSize);
      Ex = (int) (x2 / RegionSize);
      }
   else
      {
      Sx = (int) (x2 / RegionSize);
      Ex = (int) (x1 / RegionSize);
      }
   if(y1 < y2)
      {
      Sy = (int) (y1 / RegionSize);
      Ey = (int) (y2 / RegionSize);
      }
   else
      {
      Sy = (int) (y2 / RegionSize);
      Ey = (int) (y1 / RegionSize);
      }
   HadToOpenFile = foundOne = 0;

   SzPoly = sizeof(struct ThePolys);

   DrawProfileRoot = NULL;

/** below, just to ensure that all global root pointers are NULL and memory is freed **/
   FreeModelAllocations();
   ReleasePolyAllocations();

   if(NGA_TYPE == 0)
      HadToOpenFile = ReadPolySetup(&digits, 0, 0, &singles, &multiples,&compositeindex);
   else
      {
      HadToOpenFile = 0;
      singles = multiples = 0;
      digits = SignificantDecimals;
      }

   GridID = -1;
   gridallocsize = SzD * 4;

   for(index1 = Sx; index1 <= Ex; index1++)
      {
      for(index2 = Sy; index2 <= Ey; index2++)
         {
         minx = (double) (index1 * RegionSize);
         maxx = (double) (minx + RegionSize);
         miny = (double) (index2 * RegionSize);
         maxy = (double) (miny + RegionSize);
         processregion = 0;
         if((index1 == Sx) && (index2 == Sy))
            processregion = 1;
         else if((index1 == Ex) && (index2 == Ey))
            processregion = 1;
         else
            {
            if(LineSegmentsIntersect(x1,y1,x2,y2,minx,miny,maxx,miny,&nx,&ny) > 0)
               processregion = 1;
            else if(LineSegmentsIntersect(x1,y1,x2,y2,minx,miny,minx,maxy,&nx,&ny) > 0)
               processregion = 1;
            else if(LineSegmentsIntersect(x1,y1,x2,y2,maxx,maxy,minx,maxy,&nx,&ny) > 0)
               processregion = 1;
            else if(LineSegmentsIntersect(x1,y1,x2,y2,maxx,maxy,maxx,miny,&nx,&ny) > 0)
               processregion = 1;
            }
         if(processregion > 0)
            {
            compositeindex = (index1 * (MaxYindex + 1)) + index2;
            if(NGA_TYPE == 0)
               {
               fseek(fin,PolyTable[compositeindex].fileptr,SEEK_SET);
               singles = PolyTable[compositeindex].numinside;
               multiples = PolyTable[compositeindex].numother;
               }
            else
               {
               singles = multiples = 0;
               }
               
            valuesread = 0;

/*** the below while loop reads all polygon objects into global pointer list PolyRoot **/
            totalpoly = singles + multiples;
            multiples = 0;
            while(valuesread < totalpoly)
               {
               if(valuesread >= singles)
                  {
                  fseek(fin,PolyTable[compositeindex].others[multiples].fileptr,SEEK_SET);
                  ++multiples;
                  }
               vtxcnt = ReadPolyFromFile(fin,digits);
               ++valuesread;
               OKtoUse = 0;
               if((DrawByConfig[PolyFromFile.config] > 0) && (DrawByStratum[PolyFromFile.stratum] > 0) &&
                  (DrawByDomain[PolyFromFile.domain] > 0))
                  OKtoUse = 1;
               if((OKtoUse) && (NumLODbands > 0))
                  {
                  i = CrsWlk[PolyFromFile.SACindex].LODband;
                  if((i > 0) && (LODindex[i-1].active < 1))
                     OKtoUse = 0;
                  }
               if((vtxcnt > 0) && (OKtoUse > 0))
                  {
                  cpoly = (struct ThePolys *) (malloc(SzPoly));
                  if(cpoly == NULL)
                     {
                     printf("ReadProfileData:Out of allocation memory\n");
                     exit(-1);
                     }
                  cpoly->numverts = vtxcnt;
                  cpoly->config = PolyFromFile.config;
                  cpoly->stratum = PolyFromFile.stratum;
                  cpoly->domain = PolyFromFile.domain;
                  cpoly->idn = PolyFromFile.idn;
                  cpoly->next = NULL;
                  cpoly->Xtra = NULL;
                  cpoly->SACindex = PolyFromFile.SACindex;
                  cpoly->SCCindex = PolyFromFile.SCCindex;

                  cpoly->x = (double *) (malloc(SzD * vtxcnt));
                  cpoly->y = (double *) (malloc(SzD * vtxcnt));
                  cpoly->z = (double *) (malloc(SzD * vtxcnt));

                  if(cpoly->z == NULL)
                     {
                     printf("ReadProfileData:Out of allocation memory\n");
                     exit(-1);
                     }
                  for(i=0; i<vtxcnt; i++)
                     {
                     cpoly->x[i] = PolyFromFile.x[i];
                     cpoly->y[i] = PolyFromFile.y[i];
                     cpoly->z[i] = PolyFromFile.z[i];
                     }
                  duplicate = 0;
                  npoly = PolyRoot;
                  while(npoly != NULL)
                     {
                     if(npoly->numverts == cpoly->numverts)
                        {
                        for(j=0; j<cpoly->numverts; j++)
                           {
                           for(i=0; i<npoly->numverts; i++)
                              {
                              if((cpoly->x[j] == npoly->x[i]) && (cpoly->y[j] == npoly->y[i]) &&
                                      (cpoly->z[j] == npoly->z[i]))
                                 {
                                 ++duplicate;
                                 --i;
                                 break;
                                 }
                              }
                           if(i >= npoly->numverts) /** didn't find a clone of last vertex **/
                              break;
                           }
                        }
                     if(duplicate == cpoly->numverts)
                        {
/*** found a duplicate, so put the last one, which wil appear on screen, in the list ***/
                        npoly->config = cpoly->config;
                        npoly->stratum = cpoly->stratum;
                        npoly->domain = cpoly->domain;
                        npoly->idn = cpoly->idn;
                        npoly->SACindex = cpoly->SACindex;
                        npoly->SCCindex = cpoly->SCCindex;
                        break;
                        }
                     else
                        duplicate = 0;
                     npoly = npoly->next;
                     }
                 if(duplicate == 0)
                    {
                    if(PolyRoot == NULL)
                       {
                       PolyRoot = cpoly;
                       PolyRoot->next = NULL;
                       }
                    else
                       {
                       cpoly->next = PolyRoot;
                       PolyRoot = cpoly;
                       }
                    }
                  else
                     {
                     free(cpoly->x);
                     free(cpoly->y);
                     free(cpoly->z);
                     free(cpoly);
                     }
                  } /*** end if vtxcnt > 0 ****/

               free(PolyFromFile.x);
               free(PolyFromFile.y);
               free(PolyFromFile.z);

               } /** end while values read **/



            if(DrawByConfig[12] > 0)
               {
               ptsin = fopen(MPdatain,"rb");
               if(ptsin != NULL)
                  {
                  if(NGA_TYPE == 0)
                     {
                     fseek(ptsin,ModelPolyTable[compositeindex].fileptr,SEEK_SET);
                     singles = ModelPolyTable[compositeindex].numinside;
                     multiples = ModelPolyTable[compositeindex].numother;
                     }
                  else
                     {
                     singles = multiples = 0;
                     }
      
                  valuesread = 0;
      
/*** the below while loop reads all polygon objects into global pointer list PolyRoot **/
                  totalpoly = singles + multiples;
                  multiples = 0;
                  while(valuesread < totalpoly)
                     {
                     if(valuesread >= singles)
                        {
                        fseek(ptsin,ModelPolyTable[compositeindex].others[multiples].fileptr,SEEK_SET);
                        ++multiples;
                        }
                     vtxcnt = ReadPolyFromFile(ptsin,digits);
                     ++valuesread;
                     OKtoUse = 0;
                     if((DrawByStratum[PolyFromFile.stratum] > 0) &&
                        (DrawByDomain[PolyFromFile.domain] > 0))
                        OKtoUse = 1;
                     if((vtxcnt > 0) && (OKtoUse > 0))
                        {
                        cpoly = (struct ThePolys *) (malloc(SzPoly));
                        if(cpoly == NULL)
                           {
                           printf("ReadProfileData:Out of allocation memory\n");
                           exit(-1);
                           }
                        cpoly->numverts = vtxcnt;
                        cpoly->config = PolyFromFile.config;
                        cpoly->stratum = PolyFromFile.stratum;
                        cpoly->domain = PolyFromFile.domain;
                        cpoly->idn = PolyFromFile.idn;
                        cpoly->next = NULL;
                        cpoly->Xtra = NULL;
                        cpoly->SACindex = PolyFromFile.SACindex;
                        cpoly->SCCindex = PolyFromFile.SCCindex;
      
                        cpoly->x = (double *) (malloc(SzD * vtxcnt));
                        cpoly->y = (double *) (malloc(SzD * vtxcnt));
                        cpoly->z = (double *) (malloc(SzD * vtxcnt));
      
                        if(cpoly->z == NULL)
                           {
                           printf("ReadProfileData:Out of allocation memory\n");
                           exit(-1);
                           }
                        for(i=0; i<vtxcnt; i++)
                           {
                           cpoly->x[i] = PolyFromFile.x[i];
                           cpoly->y[i] = PolyFromFile.y[i];
                           cpoly->z[i] = PolyFromFile.z[i];
                           }
                        duplicate = 0;
                        npoly = PolyRoot;
                        while(npoly != NULL)
                           {
                           if(npoly->numverts == cpoly->numverts)
                              {
                              for(j=0; j<cpoly->numverts; j++)
                                 {
                                 for(i=0; i<npoly->numverts; i++)
                                    {
                                    if((cpoly->x[j] == npoly->x[i]) && (cpoly->y[j] == npoly->y[i]) &&
                                            (cpoly->z[j] == npoly->z[i]))
                                       {
                                       ++duplicate;
                                       --i;
                                       break;
                                       }
                                    }
                                 if(i >= npoly->numverts) /** didn't find a clone of last vertex **/
                                    break;
                                 }
                              }
                           if(duplicate == cpoly->numverts)
                              {
/*** found a duplicate, so put the last one, which wil appear on screen, in the list ***/
                              npoly->config = cpoly->config;
                              npoly->stratum = cpoly->stratum;
                              npoly->domain = cpoly->domain;
                              npoly->idn = cpoly->idn;
                              npoly->SACindex = cpoly->SACindex;
                              npoly->SCCindex = cpoly->SCCindex;
                              break;
                              }
                           else
                              duplicate = 0;
                           npoly = npoly->next;
                           }
                       if(duplicate == 0)
                          {
                          if(PolyRoot == NULL)
                             {
                             PolyRoot = cpoly;
                             PolyRoot->next = NULL;
                             }
                          else
                             {
                             cpoly->next = PolyRoot;
                             PolyRoot = cpoly;
                             }
                          }
                        else
                           {
                           free(cpoly->x);
                           free(cpoly->y);
                           free(cpoly->z);
                           free(cpoly);
                           }
                        free(PolyFromFile.x);
                        free(PolyFromFile.y);
                        free(PolyFromFile.z);
                        } /*** end if vtxcnt > 0 ****/
     
                     } /** end while model library polys left to read **/
                  fclose(ptsin);
                  }
               }
           



            if((NumberOfGrids > 0)&& (DrawByConfig[9] > 0))
               {
               listlength = (MaxXindex + 1) * (MaxYindex + 1);
               if(compositeindex > listlength)
                  compositeindex = listlength;
               for(i=0; i< MaxGridsPerRegion; i++)
                  {
                  MG[i].numX = 0;
                  MG[i].numY = 0;
                  }

               if((NGT[compositeindex].FileNumber != NULL) && (GridFileInUse != NGT[compositeindex].FileNumber[0]))
                  ptsin = OpenGridFile(compositeindex,0);
               else
                  ptsin = NULL;
               if(ptsin != NULL)
                  {
                  if(NGT[compositeindex].NumGrids > 0)
                     {
                     kk2 = NGT[compositeindex].NumGrids;
                     for(i=0; i<kk2; i++)
                        {
                        if(GridFileInUse != NGT[compositeindex].FileNumber[i])
                           {
                           if(ptsin != NULL)
                              CloseGridFile(ptsin);
                           ptsin = OpenGridFile(compositeindex,i);
                           }
                        ReadGridFromFile(0,ptsin, digits,compositeindex,NumberOfGrids,&NofCols,&LoadedGridMres); 
                        ii2 = NGT[compositeindex].GridIndex[i];
                        if(SCCtable[GridHeader[ii2].Sindex].S == 5) /** a surface layer grid **/
                           {
                           /**if(NGT[compositeindex].fileptr[i] >= 0)
                              {***/
                              /**jj = ReadGridFromFile(ii2,ptsin, digits,compositeindex,NumberOfGrids,&NofCols,&LoadedGridMres); ***/
                              for(kk=0; kk<MaxGridsPerRegion; kk++)
                                 {
                                 if((MG[kk].numX > 0) && (MG[kk].numY > 0) && (MG[kk].actualindex == ii2))
                                    {
                                    iX = 0;
                                    for(grows = 0; grows < (MG[kk].numX - 1); grows++)
                                       {
                                       Xgrid[0] = MG[kk].SouthWestX + ((double) iX * MG[kk].Xspace);
                                       Xgrid[1] = Xgrid[0];
                                       Xgrid[2] = Xgrid[0] + MG[kk].Xspace;
                                       Xgrid[3] = Xgrid[2];
                                       mingridx = Xgrid[0] - (MG[kk].Xspace / 2.0);
                                       maxgridx = mingridx + (2 * MG[kk].Xspace);
                                       iY = 0;
                                       for(gcols = 0; gcols < (MG[kk].numY - 1); gcols++)
                                          {
                                          Ygrid[0] = MG[kk].SouthWestY + ((double) iY * MG[kk].Yspace);
                                          Ygrid[3] = Ygrid[0];
                                          Ygrid[1] = Ygrid[0] + MG[kk].Yspace;
                                          Ygrid[2] = Ygrid[1];
                                          mingridy = Ygrid[0] - (MG[kk].Yspace / 2.0);
                                          maxgridy = mingridy + (MG[kk].Yspace * 2.0);

                                          processgridsquare = 0;
                                          if((mingridx <= x1) && (maxgridx >= x1) && (mingridy <= y1) && (maxgridy >= y1))
                                             processgridsquare = 1;
                                          else if((mingridx <= x2) && (maxgridx >= x2) && (mingridy <= y2) && (maxgridy >= y2))
                                             processgridsquare = 1;
                                          else if(LineSegmentsIntersect(x1,y1,x2,y2,mingridx,mingridy,maxgridx,mingridy,&nx,&ny) > 0)
                                             processgridsquare = 1;
                                          else if(LineSegmentsIntersect(x1,y1,x2,y2,mingridx,mingridy,mingridx,maxgridy,&nx,&ny) > 0)
                                             processgridsquare = 1;
                                          else if(LineSegmentsIntersect(x1,y1,x2,y2,maxgridx,maxgridy,mingridx,maxgridy,&nx,&ny) > 0)
                                             processgridsquare = 1;
                                          else if(LineSegmentsIntersect(x1,y1,x2,y2,maxgridx,maxgridy,maxgridx,mingridy,&nx,&ny) > 0)
                                             processgridsquare = 1;

                                          if(processgridsquare > 0)
                                             {
                                             PassTest = 1;
                                             Zgrid[0] = MG[kk].Elevs[(iX * MG[kk].numY) + iY];
                                             Zgrid[1] = MG[kk].Elevs[(iX * MG[kk].numY) + iY + 1];
                                             Zgrid[2] = MG[kk].Elevs[(iX * MG[kk].numY) + MG[kk].numY + iY + 1];
                                             Zgrid[3] = MG[kk].Elevs[(iX * MG[kk].numY) + MG[kk].numY + iY];
                                             if((OmitGridSentinels > 0) && ((IsGridSentinel(Zgrid[0]) > 0) ||
                                                   (IsGridSentinel(Zgrid[1]) > 0) || (IsGridSentinel(Zgrid[2]) > 0) ||
                                                       (IsGridSentinel(Zgrid[3]) > 0)))
                                                {
                                                PassTest = 0;
                                                }
                                             if(PassTest > 0)
                                                {
                                                cpoly = (struct ThePolys *) (malloc(SzPoly));
                                                if(cpoly == NULL)
                                                   {
                                                   printf("ReadProfileData:Out of allocation memory\n");
                                                   exit(-1);
                                                   }
                                                cpoly->numverts = 4;
                                                cpoly->config = 9;  /** 9 is a grid **/
                                                cpoly->stratum = 5; /** checked above that the grid is a surface grid **/
                                                cpoly->domain = SCCtable[GridHeader[ii2].Sindex].D;
                                                cpoly->idn = GridID;
                                                   --GridID;
                                                cpoly->next = NULL;
                                                cpoly->Xtra = NULL;
                                                cpoly->SACindex = GridHeader[ii2].Lindex;
                                                cpoly->SCCindex = GridHeader[ii2].Sindex;
   
                                                cpoly->x = (double *) (malloc(gridallocsize));
                                                cpoly->y = (double *) (malloc(gridallocsize));
                                                cpoly->z = (double *) (malloc(gridallocsize));

                                                if(cpoly->z == NULL)
                                                   {
                                                   printf("ReadProfileData:Out of allocation memory\n");
                                                   exit(-1);
                                                   }
                                                cpoly->x[0] = Xgrid[0];
                                                cpoly->y[0] = Ygrid[0];
                                                cpoly->z[0] = Zgrid[0];
      
                                                cpoly->x[1] = Xgrid[1];
                                                cpoly->y[1] = Ygrid[1];
                                                cpoly->z[1] = Zgrid[1];
   
                                                cpoly->x[2] = Xgrid[2];
                                                cpoly->y[2] = Ygrid[2];
                                                cpoly->z[2] = Zgrid[2];

                                                cpoly->x[3] = Xgrid[3];
                                                cpoly->y[3] = Ygrid[3];
                                                cpoly->z[3] = Zgrid[3];

                                               if(PolyRoot == NULL)
                                                  {
                                                  PolyRoot = cpoly;
                                                  PolyRoot->next = NULL;
                                                  }
                                               else
                                                  {
                                                  cpoly->next = PolyRoot;
                                                     PolyRoot = cpoly;
                                                  }
                                               }
                                            }
                                          ++iY;
                                          }
                                       ++iX;
                                       }
                                    }
                                 }

                              /***}***/
                           }
                        }
                     }
                  CloseGridFile(ptsin);
                  } /** end found the ptsin file **/
               } /** end NumberofGrids > 0 ***/

            if((DrawByConfig[3] > 0) || (DrawByConfig[6] > 0))   /** are working with models **/
               {
               ptsin = fopen(pointsin,"rb");
               if(ptsin != NULL)
                  {

                  k = PointTable[compositeindex].numinside + PointTable[compositeindex].numother;
                  if(k > 0)
                     {
                     fseek(ptsin,PointTable[compositeindex].fileptr,SEEK_SET);
                     ii = i = 0;
                     while(i < k)
                        {
                        if(i >= PointTable[compositeindex].numinside)
                           {
                           fseek(ptsin,PointTable[compositeindex].others[ii].fileptr,SEEK_SET);
                           ++ii;
                           }
                        vtxcnt = ReadPointFromFile(ptsin, digits);
                        ++i;
                        if((PointFromFile.numverts == 0) && (DrawByConfig[PointFromFile.config] > 0) &&
                            (DrawByStratum[PointFromFile.stratum] > 0) && (DrawByDomain[PointFromFile.domain] > 0))
                           {
                           OKtoUse = 1;
                           nstamp = StampRoot;
                           while(nstamp != NULL)
                              {
                              if(nstamp->refnumber == PointFromFile.Sindex)
                                 {
                                 if((nstamp->x == PointFromFile.x[0]) &&
                                     (nstamp->y == PointFromFile.y[0]) &&
                                     (nstamp->z == PointFromFile.z[0]))
                                    {
                                    OKtoUse = 0;
                                    break;
                                    }
                                 }
                              nstamp = nstamp->next;
                              }
                           if(OKtoUse > 0)
                              {
                              cstamp = (struct StampModel *) (malloc(SzStamp));
                              if(cstamp == NULL)
                                 {
                                 printf("ReadProfileData:Out of allocation memory\n");
                                 exit(-1);
                                 }
                              cstamp->refnumber = PointFromFile.Sindex;
                              cstamp->idn = PointFromFile.idn;
                              cstamp->Lindex = PointFromFile.Lindex;
                              cstamp->x = PointFromFile.x[0];
                              cstamp->y = PointFromFile.y[0];
                              cstamp->z = PointFromFile.z[0];
                              cstamp->height = PointFromFile.h[0];
                              cstamp->radius = PointFromFile.rad;
                              cstamp->next = StampRoot;
                              StampRoot = cstamp;
                              }
                           }
                        else if((PointFromFile.numverts > 1) && (DrawByConfig[PointFromFile.config] > 0) &&
                            (DrawByStratum[PointFromFile.stratum] > 0) && (DrawByDomain[PointFromFile.domain] > 0))
                           {
                           OKtoUse = 1;
                           nstatic = ModelRoot;
                           while(nstatic != NULL)
                              {
                              if((nstatic->refnumber == PointFromFile.Sindex) &&
                                   (nstatic->numverts == PointFromFile.numverts))
                                 {
                                 for(j=0; j<PointFromFile.numverts; j++)
                                    {
                                    if((nstatic->x[j] != PointFromFile.x[j]) ||
                                     (nstatic->y[j] != PointFromFile.y[j]) ||
                                     (nstatic->z[j] != PointFromFile.z[j]))
                                       {
                                       break;
                                       }
                                    }
                                 if(j >= PointFromFile.numverts)
                                    {
                                    OKtoUse = 0;
                                    break;
                                    }
                                 }
                              nstatic = nstatic->next;
                              }
                           if(OKtoUse > 0)
                              {
                              cstatic = (struct StaticModel *) (malloc(SzStatic));
                              if(cstatic == NULL)
                                 {
                                 printf("ReadProfileData:Out of allocation memory\n");
                                 exit(-1);
                                 }
                              cstatic->refnumber = PointFromFile.Sindex;
                              cstatic->Lindex = PointFromFile.Lindex;
                              cstatic->numverts = PointFromFile.numverts;
                              cstatic->x = (double *) malloc(SzD * PointFromFile.numverts);
                              cstatic->y = (double *) malloc(SzD * PointFromFile.numverts);
                              cstatic->z = (double *) malloc(SzD * PointFromFile.numverts);
                              cstatic->h = (double *) malloc(SzD * PointFromFile.numverts);
                              if(cstatic->h == NULL)
                                 {
                                 printf("ReadProfileData:Out of allocation memory\n");
                                 exit(-1);
                                 }
                              for(j=0; j<PointFromFile.numverts; j++)
                                 {
                                 cstatic->x[j] = PointFromFile.x[j];
                                 cstatic->y[j] = PointFromFile.y[j];
                                 cstatic->z[j] = PointFromFile.z[j];
                                 cstatic->h[j] = PointFromFile.h[j];
                                 }
                              cstatic->next = ModelRoot;
                              ModelRoot = cstatic;
                              }
                           }
                        }  /*** end while ( i < k) ***/
                     }
                  fclose(ptsin);
                  }
               }  /** end working with stamp models ***/

            if((DrawByConfig[10] > 0) || (DrawByConfig[11] > 0))
               {
               ptsin = fopen(pointsin,"rb");
               if(ptsin != NULL)
                  {
                  k = PointTable[compositeindex].numinside + PointTable[compositeindex].numother;
                  if(k > 0)
                     {
                     fseek(ptsin,PointTable[compositeindex].fileptr,SEEK_SET);
                     ii = i = 0;
                     while(i < k)
                        {
                        if(i >= PointTable[compositeindex].numinside)
                           {
                           fseek(ptsin,PointTable[compositeindex].others[ii].fileptr,SEEK_SET);
                           ++ii;
                           }
                        vtxcnt = ReadPointFromFile(ptsin, digits);
                        ++i;
                        if((PointFromFile.numverts == -2) && (DrawByConfig[PointFromFile.config] > 0) &&
                            (DrawByStratum[PointFromFile.stratum] > 0) && (DrawByDomain[PointFromFile.domain] > 0))
                           {
                           OKtoUse = 1;
                           nstamp = StampRoot;
                           while(nstamp != NULL)
                              {
                              if(nstamp->refnumber == PointFromFile.Sindex)
                                 {
                                 if((nstamp->x == PointFromFile.x[0]) &&
                                     (nstamp->y == PointFromFile.y[0]) &&
                                     (nstamp->z == PointFromFile.z[0]))
                                    {
                                    OKtoUse = 0;
                                    break;
                                    }
                                 }
                              nstamp = nstamp->next;
                              }
                           if(OKtoUse > 0)
                              {
                              cstamp = (struct StampModel *) (malloc(SzStamp));
                              if(cstamp == NULL)
                                 {
                                 printf("ReadProfileData:Out of allocation memory\n");
                                 exit(-1);
                                 }
                              cstamp->refnumber = PointFromFile.Sindex;
                              cstamp->Lindex = PointFromFile.Lindex;
                              cstamp->idn = PointFromFile.idn;
                              cstamp->x = PointFromFile.x[0];
                              cstamp->y = PointFromFile.y[0];
                              cstamp->z = PointFromFile.z[0];
                              cstamp->height = PointFromFile.h[0];
                              cstamp->radius = PointFromFile.rad;
                              cstamp->next = StampRoot;
                              StampRoot = cstamp;
                              }
                           }
                        else if((PointFromFile.numverts < -2) && (DrawByConfig[PointFromFile.config] > 0) &&
                            (DrawByStratum[PointFromFile.stratum] > 0) && (DrawByDomain[PointFromFile.domain] > 0))
                           {
                           OKtoUse = 1;
                           nstatic = ModelRoot;
                           while(nstatic != NULL)
                              {
                              if((nstatic->refnumber == PointFromFile.Sindex) &&
                                   (nstatic->numverts == PointFromFile.numverts))
                                 {
                                 for(j=0; j<vtxcnt; j++)
                                    {
                                    if((nstatic->x[j] != PointFromFile.x[j]) ||
                                     (nstatic->y[j] != PointFromFile.y[j]) ||
                                     (nstatic->z[j] != PointFromFile.z[j]))
                                       {
                                       break;
                                       }
                                    }
                                 if(j >= PointFromFile.numverts)
                                    {
                                    OKtoUse = 0;
                                    break;
                                    }
                                 }
                              nstatic = nstatic->next;
                              }
                           if(OKtoUse > 0)
                              {
                              cstatic = (struct StaticModel *) (malloc(SzStatic));
                              if(cstatic == NULL)
                                 {
                                 printf("ReadProfileData:Out of allocation memory\n");
                                 exit(-1);
                                 }
                              cstatic->refnumber = PointFromFile.Sindex;
                              cstatic->Lindex = PointFromFile.Lindex;
                              cstatic->numverts = vtxcnt;
                              cstatic->x = (double *) malloc(SzD * vtxcnt);
                              cstatic->y = (double *) malloc(SzD * vtxcnt);
                              cstatic->z = (double *) malloc(SzD * vtxcnt);
                              cstatic->h = (double *) malloc(SzD * vtxcnt);
                              if(cstatic->h == NULL)
                                 {
                                 printf("ReadProfileData:Out of allocation memory\n");
                                 exit(-1);
                                 }
                              for(j=0; j<vtxcnt; j++)
                                 {
                                 cstatic->x[j] = PointFromFile.x[j];
                                 cstatic->y[j] = PointFromFile.y[j];
                                 cstatic->z[j] = PointFromFile.z[j];
                                 cstatic->h[j] = PointFromFile.h[j];
                                 }
                              cstatic->next = ModelRoot;
                              ModelRoot = cstatic;
                              }
                           }
                        } /** end while (i < k) ***/
                     }
                  fclose(ptsin);
                  }
               } 
  
            } /** end if processregion == 1 ***/
         } /** end for index2 **/
      } /** end for index1 ***/
   if(HadToOpenFile > 0)
      {
      fclose(fin);
      fin = NULL;
      HadToOpenFile = 0;
      }
}



struct ProfileList * AddToDrawProfile(double x1,double y1,double x2,double y2,
    double * minElev,double *maxElev)
{
int SzPL;
int i;
int j;
struct ProfileList *cpl, *npl, *ppl;
struct ProfileList *minpl, *maxpl, *temppl;
struct ProfileList *rootpl;
struct ProfileList * DProot;
int FoundStart;
int FoundEnd;
int StartWasSet;
int EndWasSet;
int InitMins;
unsigned char drawcolor;
double nx, ny;
double tdist, ptdist;
double maxdist;
struct StaticModel *cm;
struct StampModel *cs;
/***struct Bridges *cb, *nb, *pb;***/
double stampradius;

   InitMins = 0;
   FoundStart = FoundEnd = 0;
   SzPL = sizeof(struct ProfileList);
   DProot = NULL;


   cm = ModelRoot;
   while(cm != NULL)
      {
      StartWasSet = EndWasSet = 0;

      drawcolor = SCCtable[cm->refnumber].D;
      


      if(FoundStart == 0)
         {
         if(PointInsidePoly(x1,y1,cm->x,cm->y,cm->numverts))
            {
            StartWasSet = 1;
            FoundStart = 1; 

            minpl = maxpl = NULL;
            rootpl = NULL;
            for(i=0; i<cm->numverts; i++)
               {
               j = (i + 1) % cm->numverts;
               if(LineSegmentsIntersect(x1,y1,x2,y2,
                     cm->x[i], cm->y[i], cm->x[j], cm->y[j] ,&nx, &ny) > 0)
                  {
                  tdist = TwoDecimalDistance(x1,y1,nx,ny);
                  temppl = (struct ProfileList *) (malloc(SzPL));
                  if(temppl == NULL)
                     {
                     printf("AddToDrawProfile: Out of allocation memory\n");
                     exit(-1);
                     }
                  temppl->stratum = SCCtable[cm->refnumber].S;
                  temppl->ptype =  drawcolor;
                  temppl->LLindex = cm->Lindex;
                  temppl->elev = cm->z[0];
                  temppl->dist = tdist;
                  temppl->next = NULL;
                  if(rootpl == NULL)
                     {
                     rootpl = temppl;
                     }
                  else
                     {
                     minpl = maxpl = rootpl;
                     while(temppl->dist > maxpl->dist)
                        {
                        minpl = maxpl;
                        maxpl = maxpl->next;
                        if(maxpl == NULL)
                           break;
                        }
                     if(maxpl == rootpl)
                        {
                        temppl->next = rootpl;
                        rootpl = temppl;
                        }
                     else
                        {
                        minpl->next = temppl;
                        temppl->next = maxpl;
                        }
                     }
                  }
               }
            if(rootpl == NULL) /** whole line must be inside model **/
               {
               EndWasSet = 1;
               FoundEnd = 1;
               temppl = (struct ProfileList *) (malloc(SzPL));
               if(temppl == NULL)
                  {
                  printf("AddToDrawProfile: Out of allocation memory\n");
                  exit(-1);
                  }
               temppl->stratum = SCCtable[cm->refnumber].S;
               temppl->ptype =  drawcolor;
               temppl->LLindex = cm->Lindex;
               temppl->elev = cm->z[0] + cm->h[0];
               temppl->dist = 0.0;
               temppl->next = NULL;

               rootpl = temppl;

               temppl = (struct ProfileList *) (malloc(SzPL));
               if(temppl == NULL)
                  {
                  printf("AddToDrawProfile: Out of allocation memory\n");
                  exit(-1);
                  }
               temppl->stratum = SCCtable[cm->refnumber].S;
               temppl->ptype =  1000;
               temppl->LLindex = cm->Lindex;
               temppl->elev = cm->z[0] + cm->h[0];
               temppl->dist = TwoDecimalDistance(x1,y1,x2,y2);
               temppl->next = NULL;
               rootpl->next = temppl;

               temppl = (struct ProfileList *) (malloc(SzPL));
               if(temppl == NULL)
                  {
                  printf("AddToDrawProfile: Out of allocation memory\n");
                  exit(-1);
                  }
               temppl->stratum = SCCtable[cm->refnumber].S;
               temppl->ptype =  drawcolor;
               temppl->LLindex = cm->Lindex;
               temppl->elev = cm->z[0];
               temppl->dist = 0.0;
               temppl->next = NULL;
               rootpl->next->next = temppl;

               temppl = (struct ProfileList *) (malloc(SzPL));
               if(temppl == NULL)
                  {
                  printf("AddToDrawProfile: Out of allocation memory\n");
                  exit(-1);
                  }
               temppl->stratum = SCCtable[cm->refnumber].S;
               temppl->ptype =  1000;
               temppl->LLindex = cm->Lindex;
               temppl->elev = cm->z[0];
               temppl->dist = TwoDecimalDistance(x1,y1,x2,y2);
               temppl->next = NULL;
               rootpl->next->next->next = temppl;

               if(DProot == NULL)
                  DProot = rootpl;
               else
                  {
                  ppl = DProot;
                  while(ppl->next != NULL)
                     ppl = ppl->next;
                  ppl->next = rootpl;
                  }
               }
            else
               {
               temppl = (struct ProfileList *) (malloc(SzPL));
               if(temppl == NULL)
                  {
                  printf("AddToDrawProfile: Out of allocation memory\n");
                  exit(-1);
                  }
               temppl->stratum = SCCtable[cm->refnumber].S;
               temppl->ptype =  drawcolor;
               temppl->LLindex = cm->Lindex;
               temppl->elev = cm->z[0] + cm->h[0];
               temppl->dist = 0.0;
               temppl->next = rootpl;
               npl = rootpl->next;

               rootpl->elev += cm->h[0];

               rootpl = temppl;

               temppl = (struct ProfileList *) (malloc(SzPL));
               if(temppl == NULL)
                  {
                  printf("AddToDrawProfile: Out of allocation memory\n");
                  exit(-1);
                  }
               temppl->stratum = SCCtable[cm->refnumber].S;
               temppl->ptype =  drawcolor;
               temppl->LLindex = cm->Lindex;
               temppl->elev = cm->z[0];
               temppl->dist = rootpl->next->dist;
               rootpl->next->next = temppl;

               temppl = (struct ProfileList *) (malloc(SzPL));
               if(temppl == NULL)
                  {
                  printf("AddToDrawProfile: Out of allocation memory\n");
                  exit(-1);
                  }
               temppl->stratum = SCCtable[cm->refnumber].S;
               temppl->ptype =  1000;
               temppl->LLindex = cm->Lindex;
               temppl->elev = cm->z[0];
               temppl->dist = 0.0;
               rootpl->next->next->next = temppl;
               temppl->next = NULL;

               if(DProot == NULL)
                  DProot = rootpl;
               else
                  {
                  ppl = DProot;
                  while(ppl->next != NULL)
                     ppl = ppl->next;
                  ppl->next = rootpl;
                  }

               cpl = rootpl = npl;
               while(cpl != NULL)
                  {
                  npl = cpl->next;
                  if(npl == NULL)
                     {
                     break;
                     }

                  minpl = (struct ProfileList *) (malloc(SzPL));
                  if(minpl == NULL)
                     {
                     printf("AddToDrawProfile: Out of allocation memory\n");
                     exit(-1);
                     }
                  minpl->dist = cpl->dist;
                  minpl->elev = cpl->elev + cm->h[0];
                  minpl->stratum = cpl->stratum;
                  minpl->ptype =  drawcolor;
                  minpl->LLindex = cpl->LLindex;
                  cpl->next = minpl;

                  maxpl = (struct ProfileList *) (malloc(SzPL));
                  if(maxpl == NULL)
                     {
                     printf("AddToDrawProfile: Out of allocation memory\n");
                     exit(-1);
                     }
                  maxpl->dist = npl->dist;
                  maxpl->elev = npl->elev + cm->h[0];
                  maxpl->stratum = npl->stratum;
                  maxpl->ptype =  drawcolor;
                  maxpl->LLindex = npl->LLindex;
                  maxpl->next = npl;
                  minpl->next = maxpl;

                  temppl = (struct ProfileList *) (malloc(SzPL));
                  if(temppl == NULL)
                     {
                     printf("AddToDrawProfile: Out of allocation memory\n");
                     exit(-1);
                     }
                  temppl->dist = cpl->dist;
                  temppl->elev = cpl->elev;
                  temppl->stratum = cpl->stratum;
                  temppl->ptype = 1000;
                  temppl->LLindex = cpl->LLindex;
                  temppl->next = npl->next;
                  npl->next = temppl;
   
                  cpl = temppl->next;
                  }
               if(cpl != NULL)
                  {
/** if exited above before end of list, have to make sure don't create a circular list **/
                  ppl = rootpl;
                  while(ppl != NULL)
                     {
                     if(ppl->next == cpl)
                        {
                        ppl->next = NULL;
                        break;
                        }
                     ppl = ppl->next;
                     }
                  }
               if((rootpl != NULL) && (rootpl->next != NULL))
                  {
                  if(DProot == NULL)
                     DProot = rootpl;
                  else
                     {
                     ppl = DProot;
                     while(ppl->next != NULL)
                        ppl = ppl->next;
                     ppl->next = rootpl;
                     }
                  }
               if(cpl != NULL) /** must have exited while loop from break statement **/
                  { 
               EndWasSet = 1;
               FoundEnd = 1;
                  temppl = (struct ProfileList *) (malloc(SzPL));
                  if(temppl == NULL)
                     {
                     printf("AddToDrawProfile: Out of allocation memory\n");
                     exit(-1);
                     }
                  temppl->stratum = SCCtable[cm->refnumber].S;
                  temppl->ptype =  drawcolor;
                  temppl->LLindex = cm->Lindex;
                  temppl->elev = cm->z[0];
                  temppl->dist = TwoDecimalDistance(x1,y1,x2,y2);
                  temppl->next = cpl;

                  rootpl = temppl;

                  temppl = (struct ProfileList *) (malloc(SzPL));
                  if(temppl == NULL)
                     {
                     printf("AddToDrawProfile: Out of allocation memory\n");
                     exit(-1);
                     }
                  temppl->stratum = SCCtable[cm->refnumber].S;
                  temppl->ptype =  drawcolor;
                  temppl->LLindex = cm->Lindex;
                  temppl->elev = cm->z[0] + cm->h[0];
                  temppl->dist = cpl->dist;
                  cpl->next = temppl;

                  temppl = (struct ProfileList *) (malloc(SzPL));
                  if(temppl == NULL)
                     {
                     printf("AddToDrawProfile: Out of allocation memory\n");
                     exit(-1);
                     }
                  temppl->stratum = SCCtable[cm->refnumber].S;
                  temppl->ptype =  1000;
                  temppl->LLindex = cm->Lindex;
                  temppl->elev = cm->z[0] + cm->h[0];
                  temppl->dist = rootpl->dist;
                  rootpl->next->next->next = temppl;
                  temppl->next = NULL;

                  if(DProot == NULL)
                     DProot = rootpl;
                  else
                     {
                     ppl = DProot;
                     while(ppl->next != NULL)
                        ppl = ppl->next;
                     ppl->next = rootpl;
                     }
                  }
               }
            }
         }

      if(FoundEnd == 0)
         {
         if(PointInsidePoly(x2,y2,cm->x,cm->y,cm->numverts))
            {
            EndWasSet = 1;
            FoundEnd = 1;

            minpl = maxpl = NULL;
            rootpl = NULL;
            for(i=0; i<cm->numverts; i++)
               {
               j = (i + 1) % cm->numverts;
               if(LineSegmentsIntersect(x1,y1,x2,y2,
                     cm->x[i], cm->y[i], cm->x[j], cm->y[j] ,&nx, &ny) > 0)
                  {
                  tdist = TwoDecimalDistance(x1,y1,nx,ny);
                  temppl = (struct ProfileList *) (malloc(SzPL));
                  if(temppl == NULL)
                     {
                     printf("AddToDrawProfile: Out of allocation memory\n");
                     exit(-1);
                     }
                  temppl->stratum = SCCtable[cm->refnumber].S;
                  temppl->ptype =  drawcolor;
                  temppl->LLindex = cm->Lindex;
                  temppl->elev = cm->z[0];
                  temppl->dist = tdist;
                  temppl->next = NULL;
                  if(rootpl == NULL)
                     {
                     rootpl = temppl;
                     }
                  else
                     {
                     minpl = maxpl = rootpl;
                     while(temppl->dist > maxpl->dist)
                        {
                        minpl = maxpl;
                        maxpl = maxpl->next;
                        if(maxpl == NULL)
                           break;
                        }
                     if(maxpl == rootpl)
                        {
                        temppl->next = rootpl;
                        rootpl = temppl;
                        }
                     else
                        {
                        minpl->next = temppl;
                        temppl->next = maxpl;
                        }
                     }
                  }
               }
            if(rootpl != NULL)
               {
               cpl = rootpl;
               while(cpl != NULL)
                  {
                  npl = cpl->next;
                  if(npl == NULL)
                     {
                     break;
                     }

                  minpl = (struct ProfileList *) (malloc(SzPL));
                  if(minpl == NULL)
                     {
                     printf("AddToDrawProfile: Out of allocation memory\n");
                     exit(-1);
                     }
                  minpl->dist = cpl->dist;
                  minpl->elev = cpl->elev + cm->h[0];
                  minpl->stratum = cpl->stratum;
                  minpl->ptype =  drawcolor;
                  minpl->LLindex = cpl->LLindex;
                  cpl->next = minpl;

                  maxpl = (struct ProfileList *) (malloc(SzPL));
                  if(maxpl == NULL)
                     {
                     printf("AddToDrawProfile: Out of allocation memory\n");
                     exit(-1);
                     }
                  maxpl->dist = npl->dist;
                  maxpl->elev = npl->elev + cm->h[0];
                  maxpl->stratum = npl->stratum;
                  maxpl->ptype =  drawcolor;
                  maxpl->LLindex = npl->LLindex;
                  maxpl->next = npl;
                  minpl->next = maxpl;

                  temppl = (struct ProfileList *) (malloc(SzPL));
                  if(temppl == NULL)
                     {
                     printf("AddToDrawProfile: Out of allocation memory\n");
                     exit(-1);
                     }
                  temppl->dist = cpl->dist;
                  temppl->elev = cpl->elev;
                  temppl->stratum = cpl->stratum;
                  temppl->ptype = 1000;
                  temppl->LLindex = cpl->LLindex;
                  temppl->next = npl->next;
                  npl->next = temppl;
  
                  cpl = temppl->next;
                  }
               if(cpl != NULL)
                  {
                  ppl = rootpl;
                  while(ppl != NULL)
                     {
                     if(ppl->next == cpl)
                        {
                        ppl->next = NULL;
                        break;
                        }
                     ppl = ppl->next;
                     }
                  }
               if((rootpl != NULL) && (rootpl->next != NULL))
                  {
                  if(DProot == NULL)
                     DProot = rootpl;
                  else
                     {
                     ppl = DProot;
                     while(ppl->next != NULL)
                        ppl = ppl->next;
                     ppl->next = rootpl;
                     }
                  }
               if(cpl != NULL) /** must have exited while loop from break statement **/
                  { 
                  temppl = (struct ProfileList *) (malloc(SzPL));
                  if(temppl == NULL)
                     {
                     printf("AddToDrawProfile: Out of allocation memory\n");
                     exit(-1);
                     }
                  temppl->stratum = SCCtable[cm->refnumber].S;
                  temppl->ptype =  drawcolor;
                  temppl->LLindex = cm->Lindex;
                  temppl->elev = cm->z[0];
                  temppl->dist = TwoDecimalDistance(x1,y1,x2,y2);
                  temppl->next = cpl;

                  rootpl = temppl;

                  temppl = (struct ProfileList *) (malloc(SzPL));
                  if(temppl == NULL)
                     {
                     printf("AddToDrawProfile: Out of allocation memory\n");
                     exit(-1);
                     }
                  temppl->stratum = SCCtable[cm->refnumber].S;
                  temppl->ptype =  drawcolor;
                  temppl->LLindex = cm->Lindex;
                  temppl->elev = cm->z[0] + cm->h[0];
                  temppl->dist = cpl->dist;
                  cpl->next = temppl;

                  temppl = (struct ProfileList *) (malloc(SzPL));
                  if(temppl == NULL)
                     {
                     printf("AddToDrawProfile: Out of allocation memory\n");
                     exit(-1);
                     }
                  temppl->stratum = SCCtable[cm->refnumber].S;
                  temppl->ptype =  1000;
                  temppl->LLindex = cm->Lindex;
                  temppl->elev = cm->z[0] + cm->h[0];
                  temppl->dist = rootpl->dist;
                  rootpl->next->next->next = temppl;
                  temppl->next = NULL;

                  if(DProot == NULL)
                     DProot = rootpl;
                  else
                     {
                     ppl = DProot;
                     while(ppl->next != NULL)
                        ppl = ppl->next;
                     ppl->next = rootpl;
                     }
                  }
               }

            }
         }

      if((StartWasSet == 0) && (EndWasSet == 0))
         {
         minpl = maxpl = NULL;
         rootpl = NULL;
         for(i=0; i<cm->numverts; i++)
            {
            j = (i + 1) % cm->numverts;
            if(LineSegmentsIntersect(x1,y1,x2,y2,
                  cm->x[i], cm->y[i], cm->x[j], cm->y[j] ,&nx, &ny) > 0)
               {
               tdist = TwoDecimalDistance(x1,y1,nx,ny);
               temppl = (struct ProfileList *) (malloc(SzPL));
               if(temppl == NULL)
                  {
                  printf("AddToDrawProfile: Out of allocation memory\n");
                  exit(-1);
                  }
               temppl->stratum = SCCtable[cm->refnumber].S;
               temppl->ptype =  drawcolor;
                  temppl->LLindex = cm->Lindex;
               temppl->elev = cm->z[0];
               temppl->dist = tdist;
               temppl->next = NULL;
               if(rootpl == NULL)
                  {
                  rootpl = temppl;
                  }
               else 
                  {
                  minpl = maxpl = rootpl;
                  while(temppl->dist > maxpl->dist)
                     {
                     minpl = maxpl;
                     maxpl = maxpl->next;
                     if(maxpl == NULL)
                        break;
                     }
                  if(maxpl == rootpl)
                     {
                     temppl->next = rootpl;
                     rootpl = temppl;
                     }
                  else
                     {
                     minpl->next = temppl;
                     temppl->next = maxpl;
                     }
                  }
               }
            }
         if(rootpl != NULL)
            {
            cpl = rootpl;
            while(cpl->next != NULL)
               {
               npl = cpl->next;

               minpl = (struct ProfileList *) (malloc(SzPL));
               if(minpl == NULL)
                  {
                  printf("AddToDrawProfile: Out of allocation memory\n");
                  exit(-1);
                  }
               minpl->dist = cpl->dist;
               minpl->elev = cpl->elev + cm->h[0];
               minpl->stratum = cpl->stratum;
               minpl->ptype =  drawcolor;
               minpl->LLindex = cpl->LLindex;
               cpl->next = minpl;

               maxpl = (struct ProfileList *) (malloc(SzPL));
               if(maxpl == NULL)
                  {
                  printf("AddToDrawProfile: Out of allocation memory\n");
                  exit(-1);
                  }
               maxpl->dist = npl->dist;
               maxpl->elev = npl->elev + cm->h[0];
               maxpl->stratum = npl->stratum;
               maxpl->ptype =  drawcolor;
               maxpl->LLindex = npl->LLindex;
               maxpl->next = npl;
               minpl->next = maxpl;

               temppl = (struct ProfileList *) (malloc(SzPL));
               if(temppl == NULL)
                  {
                  printf("AddToDrawProfile: Out of allocation memory\n");
                  exit(-1);
                  }
               temppl->dist = cpl->dist;
               temppl->elev = cpl->elev;
               temppl->stratum = cpl->stratum;
               temppl->ptype = 1000;
               temppl->LLindex = cpl->LLindex;
               temppl->next = npl->next;
               npl->next = temppl;

               cpl = temppl->next;
               if(cpl == NULL)
                  break;
               }
/*** now need to insert this structure somewhere, at end should be ok ***/
            if(DProot == NULL)
               DProot = rootpl;
            else
               {
               ppl = DProot;
               while(ppl->next != NULL)
                  ppl = ppl->next;
               ppl->next = rootpl;
               }

            }
         }
      cm = cm->next;

      }

   cs = StampRoot;

   maxdist = TwoDecimalDistance(x1,y1,x2,y2);
   while(cs != NULL)
      {
      drawcolor = SCCtable[cs->refnumber].D;

      stampradius = cs->radius;
      tdist = PointToLineDist2D(cs->x,cs->y,x1,y1,x2,y2);
      if(tdist < stampradius)
         {
         ptdist = TwoDecimalDistance(x1,y1,cs->x,cs->y);
         tdist = ptdist - stampradius;
         if(tdist < 0)
            tdist = 0;

         cpl = (struct ProfileList *) (malloc(SzPL));
         if(cpl == NULL)
            {
            printf("AddToDrawProfile: Out of allocation memory\n");
            exit(-1);
            }
         cpl->dist = tdist;
         cpl->elev = cs->z;
         cpl->ptype =  drawcolor;
         cpl->LLindex = cs->Lindex;
         cpl->stratum = SCCtable[cs->refnumber].S;

         cpl->next = NULL;

         temppl = (struct ProfileList *) (malloc(SzPL));
         if(temppl == NULL)
            {
            printf("AddToDrawProfile: Out of allocation memory\n");
            exit(-1);
            }
         temppl->dist = tdist;
         temppl->elev = cpl->elev + cs->height;
         temppl->ptype = drawcolor;
         temppl->next = NULL;
         temppl->LLindex = cs->Lindex;
         temppl->stratum = SCCtable[cs->refnumber].S;
         cpl->next = temppl;
         npl = temppl;

         temppl = (struct ProfileList *) (malloc(SzPL));
         if(temppl == NULL)
            {
            printf("AddToDrawProfile: Out of allocation memory\n");
            exit(-1);
            }
         temppl->dist = ptdist + stampradius;
         if(temppl->dist > maxdist)
            temppl->dist = maxdist;
         temppl->elev = npl->elev;
         temppl->ptype = drawcolor;
         temppl->LLindex = cs->Lindex;
         temppl->stratum = SCCtable[cs->refnumber].S;
         temppl->next = NULL;
         npl->next = temppl;
         npl = temppl;

         temppl = (struct ProfileList *) (malloc(SzPL));
         if(temppl == NULL)
            {
            printf("AddToDrawProfile: Out of allocation memory\n");
            exit(-1);
            }
         temppl->dist = npl->dist;
         temppl->elev = cpl->elev;
         temppl->ptype = drawcolor;
         temppl->LLindex = cs->Lindex;
         temppl->stratum = SCCtable[cs->refnumber].S;
         temppl->next = NULL;
         npl->next = temppl;
         npl = temppl;

         temppl = (struct ProfileList *) (malloc(SzPL));
         if(temppl == NULL)
            {
            printf("AddToDrawProfile: Out of allocation memory\n");
            exit(-1);
            }
         temppl->dist = cpl->dist;
         temppl->elev = cpl->elev;
         temppl->LLindex = cs->Lindex;
         temppl->stratum = SCCtable[cs->refnumber].S;
         temppl->ptype = 1000;
         temppl->next = NULL;
         npl->next = temppl;

         if(DProot == NULL)
            DProot = cpl;
         else
            {
            ppl = DProot;
            while(ppl->next != NULL)
               ppl = ppl->next;
            ppl->next = cpl;
            }
         }
      cs = cs->next;
      }

   cpl= DProot;
   while(cpl != NULL)
      {
      if(InitMins == 0)
         {
         *minElev = cpl->elev;
         *maxElev = cpl->elev;
         InitMins = 1;
         }
      else
         {
         if(cpl->elev < *minElev)
            *minElev = cpl->elev;
         else if(cpl->elev > *maxElev)
            *maxElev = cpl->elev;
         }
      cpl = cpl->next;
      }

   return(DProot);
}





void ExtractLOSprofile(void)
{
struct ProfileList *cpl, *npl, *ppl, *tpl, *lpl, *mpl;
int SzPL;
int SzSL;
double mindist;

struct SortList
   {
   struct ProfileList *pl;
   double dist;
   struct SortList * next;
   } *SortRoot, *csl, *psl, *nsl;


   SzPL = sizeof(struct ProfileList);
   SzSL = sizeof(struct SortList);
   SortRoot = NULL;
   cpl = DrawProfileRoot;
   while(cpl != NULL)
      {
      mindist = cpl->dist;
      ppl = tpl = mpl = cpl;
      while(ppl->ptype < 999)
         {
         if(cpl->dist < mindist)
            {
            mindist = cpl->dist;
            mpl = cpl;
            }
         ppl = cpl;
         cpl = cpl->next;
         }
      nsl = (struct SortList *) (malloc(SzSL));
      if(nsl == NULL)
         {
         printf("ExtractLOSprofile: Out of allocation memory\n");
         exit(-1);
         }
      nsl->pl = tpl;
      nsl->dist = mindist;
      nsl->next = NULL;
      if(SortRoot == NULL)
         SortRoot = nsl;
      else
         {
         psl = csl = SortRoot;
         while((csl != NULL) && (csl->dist < nsl->dist))
            {
            psl = csl;
            csl = csl->next;
            }
         if(csl == SortRoot)
            {
            nsl->next = SortRoot;
            SortRoot = nsl;
            }
         else
            {
            nsl->next = csl;
            psl->next = nsl;
            }
         }
      }

   ProfileRoot = NULL;
   csl = SortRoot;
   while(csl != NULL)
      {
      tpl = csl->pl;
      do
         {
         npl = (struct ProfileList *) (malloc(SzPL));
         if(npl == NULL)
            {
            printf("ExtractLOSprofile: Out of allocation memory\n");
            exit(-1);
            }
         npl->dist = tpl->dist;
         npl->elev = tpl->elev;
         npl->ptype =  tpl->ptype;
         npl->LLindex = tpl->LLindex;
         npl->next = NULL;
         if(ProfileRoot == NULL)
            {
            ProfileRoot = npl;
            lpl = ProfileRoot;
            }
         else
            {
            lpl->next = npl;
            lpl = npl;
            }
         ppl = tpl;
         tpl = tpl->next;
         } while(ppl->ptype < 999);
      psl = csl;
      csl = csl->next;
      free(psl);
      }
}







struct ProfileList * AssembleDrawProfilePoints(double x1,double y1,double x2,double y2,
   double *minElev,double *maxElev,int SingleList)
{
int SzPL;
double TminElev, TmaxElev;
int i,j;
struct ProfileList *cpl, *ppl, *lastInsert;
struct ProfileList *AddedList;
int intersections;
int FoundStart, FoundEnd;
int StartWasSet, EndWasSet;
int PossibleStart;
int NeverFoundStart, NeverFoundEnd;
int FoundOverlap;
double xi[5], yi[5], zi[5], di[5];
int InitMins;
int edgeindex;
double maxdist;
double LA, LB, LC;
double nz1, nz2;
double tdist1;
double tdist2;
/****unsigned char drawcolor; ****/
struct ThePolys *cpoly;


   InitMins = 0;
   FoundStart = FoundEnd = 0;
   SzPL = sizeof(struct ProfileList);
   DrawProfileRoot = NULL;
   lastInsert = NULL;

   LineEquation(x1,y1,x2,y2,&LA,&LB,&LC);
   NeverFoundStart = NeverFoundEnd = 0;
   maxdist = TwoDecimalDistance(x1,y1,x2,y2);
   FoundStart = FoundEnd = 0;

   cpoly = PolyRoot;
   while(cpoly != NULL)
      {
      StartWasSet = EndWasSet = FoundOverlap = 0;

      if(FoundStart == 0)
         {
         PossibleStart = 0;
         edgeindex = -1;
         if(PointIsVertex(x1,y1,cpoly->x,cpoly->y,cpoly->z,cpoly->numverts,&nz1))
            PossibleStart = 1;
         else if(PointOnEdge(x1,y1,cpoly->x,cpoly->y,cpoly->z,cpoly->numverts,&nz1,&edgeindex))
            PossibleStart = 2;
         else if(PointIsInside(x1,y1,cpoly->x,cpoly->y,cpoly->z,cpoly->numverts,cpoly->config,&nz1))
            PossibleStart = 3;
         if(PossibleStart > 0)
            {

            if(PointIsVertex(x2,y2,cpoly->x,cpoly->y,cpoly->z,cpoly->numverts,&nz2))
/** then have found start and end in a single poly and are now done **/
               {
               if(cpoly->stratum == 5) 
                  {
                  ++NeverFoundStart;
                  ++NeverFoundEnd;
                  StartWasSet = EndWasSet = 1;
                  /***FoundStart = FoundEnd = 1; ****/
                  }
               cpl = RecordInterval(0.0, nz1, maxdist, nz2,
                             &InitMins, minElev, maxElev, SzPL, cpoly->domain,cpoly->SACindex,cpoly->stratum);
               cpl->next->next = DrawProfileRoot;
               DrawProfileRoot = cpl;

               break; /** from the while cpoly since have found everything **/
               }
            else if(PointOnEdge(x2,y2,cpoly->x,cpoly->y,cpoly->z,cpoly->numverts,&nz2,&i))
/** then have found start and end in a single poly and are now done **/
               {
               if(cpoly->stratum == 5)
                  {
                  ++NeverFoundStart;
                  ++NeverFoundEnd;
                  StartWasSet = EndWasSet = 1;
                  /***FoundStart = FoundEnd = 1; ****/
                  }
               cpl = RecordInterval(0.0, nz1, maxdist, nz2,
                             &InitMins, minElev, maxElev, SzPL, cpoly->domain,cpoly->SACindex,cpoly->stratum);
               cpl->next->next = DrawProfileRoot;
               DrawProfileRoot = cpl;

               break; /** from the while cpoly since have found everything **/
               }
            else if(PointIsInside(x2,y2,cpoly->x,cpoly->y,cpoly->z,cpoly->numverts,cpoly->config,&nz2))
/** then have found start and end in a single poly and are now done **/
               {
               if(cpoly->stratum == 5)
                  {
                  ++NeverFoundStart;
                  ++NeverFoundEnd;
                  StartWasSet = EndWasSet = 1;
                  /***FoundStart = FoundEnd = 1;***/
                  }
               cpl = RecordInterval(0.0, nz1, maxdist, nz2,
                             &InitMins, minElev, maxElev, SzPL, cpoly->domain,cpoly->SACindex,cpoly->stratum);
               cpl->next->next = DrawProfileRoot;
               DrawProfileRoot = cpl;

               break; /** from the while cpoly since have found everything **/
               }
            else if(LineExitsPoly(x1,y1,x2,y2,
                    cpoly->x,cpoly->y,cpoly->z,cpoly->numverts,PossibleStart,x1,y1,edgeindex,&tdist1,&nz2))
               {
               if(cpoly->stratum == 5)
                  {
                  ++NeverFoundStart;
                  StartWasSet = 1;
                  /**FoundStart = 1;***/
                  }
               cpl = RecordInterval(0.0, nz1, tdist1, nz2,
                             &InitMins, minElev, maxElev, SzPL, cpoly->domain,cpoly->SACindex,cpoly->stratum);
               cpl->next->next = DrawProfileRoot;
               DrawProfileRoot = cpl;
               }
            } /** end if PossibleStart **/
         }  /** end looking for interaction with start point **/

      if((FoundEnd == 0) && (StartWasSet == 0))
         {
         PossibleStart = 0;
         edgeindex = -1;
         if(PointIsVertex(x2,y2,cpoly->x,cpoly->y,cpoly->z,cpoly->numverts,&nz1))
            PossibleStart = 1;
         else if(PointOnEdge(x2,y2,cpoly->x,cpoly->y,cpoly->z,cpoly->numverts,&nz1,&edgeindex))
            PossibleStart = 2;
         else if(PointIsInside(x2,y2,cpoly->x,cpoly->y,cpoly->z,cpoly->numverts,cpoly->config,&nz1))
            PossibleStart = 3;
/** note that don't have to check all possibilities for the start node here since should have run through
    these above (if applicable) ****/
         if(PossibleStart > 0)
            {
            if(LineExitsPoly(x1,y1,x2,y2,
                    cpoly->x,cpoly->y,cpoly->z,cpoly->numverts,PossibleStart,x2,y2,edgeindex,&tdist1,&nz2))
               {
               if(cpoly->stratum == 5)
                  {
                  ++NeverFoundEnd;
                  EndWasSet = 1;
         /***         FoundEnd = 1; ***/
                  }
               cpl = RecordInterval(tdist1, nz2, maxdist, nz1,
                             &InitMins, minElev, maxElev, SzPL, cpoly->domain,cpoly->SACindex,cpoly->stratum);
               if(DrawProfileRoot == NULL)
                  DrawProfileRoot = cpl;
               else if(lastInsert != NULL)
                  lastInsert->next = cpl;
               else
                  {
                  lastInsert = DrawProfileRoot;
                  while(lastInsert->next != NULL)
                     lastInsert = lastInsert->next;
                  lastInsert->next = cpl;
                  }
               lastInsert = cpl->next;
               }
            } /** end if PossibleStart **/
         }  /** end looking for interaction with end point **/

      if((EndWasSet == 0) && (StartWasSet == 0))
         {
/** first, see if a poly vertex is exactly on the observer-target line; if so, check adjacent vertex ***/
         PossibleStart = 0;
         for(i=0; i<cpoly->numverts; i++)
            {
            if(PointOnLineSegment(cpoly->x[i], cpoly->y[i], x1,y1,x2,y2,0.0001) > 0)
               {
               PossibleStart = 1;
               j = (i + 1) % cpoly->numverts;
/** if only one vertex is on the observer-target line, do nothing ***/
               if(PointOnLineSegment(cpoly->x[j], cpoly->y[j], x1,y1,x2,y2,0.0001) > 0)
                  {
                  tdist1 = TwoDecimalDistance(x1,y1,cpoly->x[i],cpoly->y[i]);
                  nz1 = cpoly->z[i];
                  tdist2 = TwoDecimalDistance(x1,y1,cpoly->x[j],cpoly->y[j]);
                  nz2 = cpoly->z[j];
                  if(tdist1 < tdist2)
                     {
                     cpl = RecordInterval(tdist1, nz1, tdist2, nz2,
                             &InitMins, minElev, maxElev, SzPL, cpoly->domain,cpoly->SACindex,cpoly->stratum);
                     }
                  else
                     {
                     cpl = RecordInterval(tdist2, nz2, tdist1, nz1,
                             &InitMins, minElev, maxElev, SzPL, cpoly->domain,cpoly->SACindex,cpoly->stratum);
                     }
                  if(DrawProfileRoot == NULL)
                     DrawProfileRoot = cpl;
                  else if(lastInsert != NULL)
                     lastInsert->next = cpl;
                  else
                     {
                     lastInsert = DrawProfileRoot;
                     while(lastInsert->next != NULL)
                        lastInsert = lastInsert->next;
                     lastInsert->next = cpl;
                     }
                  lastInsert = cpl->next;
                  }
               }
            }
         if(PossibleStart == 0)
/** see if there are actual line intersections ****/
            {
            intersections = 0;
            for(i=0; i<cpoly->numverts; i++)
               {
               j = (i + 1) % cpoly->numverts;
               if(LineSegmentsIntersect(x1,y1,x2,y2, cpoly->x[i], cpoly->y[i],
                              cpoly->x[j], cpoly->y[j] ,&xi[intersections], &yi[intersections]) > 0)
                  {
                  di[intersections] = TwoDecimalDistance(x1,y1,xi[intersections],yi[intersections]);
                  zi[intersections] = InterpLinearElev(cpoly->x[i], cpoly->y[i], cpoly->z[i],
                               cpoly->x[j], cpoly->y[j], cpoly->z[j],xi[intersections],yi[intersections]);
                  ++intersections;
                  if(intersections > 1)
                     break;
                  }
               }
            if(intersections == 2)
               {
               if(di[0] < di[1])
                  {
                  cpl = RecordInterval(di[0], zi[0], di[1], zi[1],
                             &InitMins, minElev, maxElev, SzPL, cpoly->domain,cpoly->SACindex,cpoly->stratum);
                  }
               else
                  {
                  cpl = RecordInterval(di[1], zi[1], di[0], zi[0],
                             &InitMins, minElev, maxElev, SzPL, cpoly->domain,cpoly->SACindex,cpoly->stratum);
                  }
               if(DrawProfileRoot == NULL)
                  DrawProfileRoot = cpl;
               else if(lastInsert != NULL)
                  lastInsert->next = cpl;
               else
                  {
                  lastInsert = DrawProfileRoot;
                  while(lastInsert->next != NULL)
                     lastInsert = lastInsert->next;
                  lastInsert->next = cpl;
                  }
               lastInsert = cpl->next;
               }
            }
         } /** end looking for interaction with observer-target line segment **/


      cpoly = cpoly->next;
      }

   ppl = DrawProfileRoot;
   if(ppl == NULL)
      {
      return(NULL);
      }
   else
      {
      while(ppl->next != NULL)
         {
         ppl = ppl->next;
         }
      }
   TminElev = *minElev;
   TmaxElev = *maxElev;
   AddedList = AddToDrawProfile(x1,y1,x2,y2,&TminElev,&TmaxElev);
   ppl->next = AddedList;
   if(TminElev < *minElev)
      *minElev = TminElev;
   if(TmaxElev > *maxElev)
      *maxElev = TmaxElev;

   if(SingleList > 0) 
      {
      ProfileRoot = NULL;
      ExtractLOSprofile();
      }
   return(AddedList);
}




struct ToBeLoaded * IdentifyLoadRegions(double x1,double y1,double x2,double y2)
{
double minx, maxx,miny,maxy;
double nx, ny;
int index1, index2, Sx,Sy, Ex,Ey;
int processregion;
int SzTBL;
struct ToBeLoaded *ct, *pt, *nt, *TBLroot;

   if(x1 < x2)
      {
      Sx = (int) (x1 / RegionSize);
      Ex = (int) (x2 / RegionSize);
      }
   else
      {
      Sx = (int) (x2 / RegionSize);
      Ex = (int) (x1 / RegionSize);
      }
   if(y1 < y2)
      {
      Sy = (int) (y1 / RegionSize);
      Ey = (int) (y2 / RegionSize);
      }
   else
      {
      Sy = (int) (y2 / RegionSize);
      Ey = (int) (y1 / RegionSize);
      }

   SzTBL = sizeof(struct ToBeLoaded);
   TBLroot = NULL;

   for(index1 = Sx; index1 <= Ex; index1++)
      {
      for(index2 = Sy; index2 <= Ey; index2++)
         {
         minx = (double) (index1 * RegionSize);
         maxx = (double) (minx + RegionSize);
         miny = (double) (index2 * RegionSize);
         maxy = (double) (miny + RegionSize);
         processregion = 0;
         if((index1 == Sx) && (index2 == Sy))
            processregion = 1;
         else if((index1 == Ex) && (index2 == Ey))
            processregion = 1;
         else
            {
            if(LineSegmentsIntersect(x1,y1,x2,y2,minx,miny,maxx,miny,&nx,&ny) > 0)
               processregion = 1;
            else if(LineSegmentsIntersect(x1,y1,x2,y2,minx,miny,minx,maxy,&nx,&ny) > 0)
               processregion = 1;
            else if(LineSegmentsIntersect(x1,y1,x2,y2,maxx,maxy,minx,maxy,&nx,&ny) > 0)
               processregion = 1;
            else if(LineSegmentsIntersect(x1,y1,x2,y2,maxx,maxy,maxx,miny,&nx,&ny) > 0)
               processregion = 1;
            }
         if(processregion > 0)
            {
            nt = (struct ToBeLoaded *) (malloc(SzTBL));
            if(nt == NULL)
               {
               printf("IdentifyLoadRegions: out of allocation memory\n"); exit(-1);
               }
            nt->index1 = index1;
            nt->index2 = index2;
            nt ->isum = index1 + index2;
            nt->next = NULL;
            if(TBLroot == NULL)
               TBLroot = nt;
            else
               {
               ct = pt = TBLroot;
               while((ct != NULL) && (ct->isum < nt->isum))
                  {
                  pt = ct;
                  ct = ct->next;
                  }
               if(ct == NULL)
                  {
                  pt->next = nt;
                  nt->next = NULL;
                  }
               else if(ct == TBLroot)
                  {
                  nt->next = TBLroot;
                  TBLroot = nt;
                  }
               else
                  {
                  pt->next = nt;
                  nt->next = ct;
                  }
               }
            }
         }
      }
   return(TBLroot);
}



struct ToBeLoaded * LoadRegionIfNecessary(struct ToBeLoaded *Loaded, int index1, int index2,
   double x1,double y1,double x2,double y2)
{
int answer, sum;
struct ToBeLoaded *ct, *pt, *nt;
int SzTBL;
   sum = index1 + index2;
   pt = ct = Loaded;
   SzTBL = sizeof(struct ToBeLoaded);
   while(ct != NULL)
      {
      if(ct->isum > sum)
         {
         answer = 0;
         break;
         }
      else if(ct->isum == sum)
         {
         if((ct->index1 == index1) && (ct->index2 == index2))
            {
            answer = 1;
            break;
            }
         }
      pt = ct;
      ct = ct->next;
      }
   if(ct == NULL)
      answer = 0;
   if(answer == 0) /** add this one to the loaded list **/
      {
      nt = (struct ToBeLoaded * ) (malloc(SzTBL));
      if(nt == NULL)
         {
         printf("IsRegionLoaded: out of allocation memory\n"); exit(-1);
         }
      nt->index1 = index1;
      nt->index2 = index2;
      nt->isum = sum;
      nt->next = NULL;
      if(Loaded == NULL)
         Loaded = nt;
      else if(ct == NULL)
         {
         pt->next = nt;
         nt->next = NULL;
         }
      else if(ct == Loaded)
         {
         nt->next = Loaded;
         Loaded = nt;
         }
      else
         {
         nt->next = pt->next;
         pt->next = nt;
         }
      ReadProfileData(x1,y1,x2,y2);
      }
   return(Loaded);
}






void GetLOSendPoint(double xo,double yo,double *xe,double *ye,
    double radius, double azimuth)
{
double angle;

   if(azimuth <= 90.0)
      {
      angle = 90.0 - azimuth;
      angle = (angle * PI) / 180.0;
      *xe = xo + (radius * cos(angle));
      *ye = yo + (radius * sin(angle));
      }
   else if(azimuth <= 180.0)
      {
      angle = azimuth - 90.0;
      angle = (angle * PI) / 180.0;
      *xe = xo + (radius * cos(angle));
      *ye = yo - (radius * sin(angle));
      }
   else if(azimuth <= 270.0)
      {
      angle = 270.0 - azimuth;
      angle = (angle * PI) / 180.0;
      *xe = xo - (radius * cos(angle));
      *ye = yo - (radius * sin(angle));
      }
   else
      {
      angle = azimuth - 270.0;
      angle = (angle * PI) / 180.0;
      *xe = xo - (radius * cos(angle));
      *ye = yo + (radius * sin(angle));
      }
}





struct ProfileList * ExtractProfileClass(struct ProfileList *Olist,
   int target, int alttgt, double *mindist)
{
struct ProfileList *Sroot, *cp, *np, *lp, *fp;
int SzPL;

   SzPL = sizeof(struct ProfileList);
   Sroot = NULL;
   cp = Olist;
   while(cp != NULL)
      {
      if((cp->stratum == target) || (cp->stratum == alttgt))
         {
         if(cp->dist < *mindist)
            *mindist = cp->dist;
         np = (struct ProfileList *) (malloc(SzPL));
         if(np == NULL)
            {
            printf("ExtractProfileClass: Out of allocation memory\n"); exit(-1);
            }
         np->dist = cp->dist;
         np->elev = cp->elev;
         np->ptype = cp->ptype;
         np->LLindex = cp->LLindex;
         np->stratum = cp->stratum;
         np->next = NULL;
         fp = np;
         if(Sroot == NULL)
            {
            Sroot = np;
            lp = np;
            }
         else
            {
            np->next = lp->next;
            lp->next = np;
            lp = np;
            }
         do
            {
            cp = cp->next;
            if(cp == NULL)
               break;
            if(cp->dist < *mindist)
               *mindist = cp->dist;
            if((cp->ptype > 999) && (cp->dist == fp->dist) && (cp->elev == fp->elev))
               {
               lp->ptype = cp->ptype;
               }
            else
               {
               np = (struct ProfileList *) (malloc(SzPL));
               if(np == NULL)
                  {
                  printf("ExtractProfileClass: Out of allocation memory\n"); exit(-1);
                  }
               np->dist = cp->dist;
               np->elev = cp->elev;
               np->ptype = cp->ptype;
               np->LLindex = cp->LLindex;
               np->stratum = cp->stratum;
               np->next = lp->next;
               lp->next = np;
               lp = np;
               }
            } while(cp->ptype < 999);
         }
      else
         {
         while((cp != NULL) && (cp->ptype < 999))
            cp = cp->next;
         }
      if(cp != NULL)
         cp = cp->next;
      }
   return(Sroot);
}




void FindAzimuthInteriorPoint(double xb,double yb,double xe,double ye,
   double tdist,double dist,double *px,double *py)
{
double xdiff, ydiff;
double percentage;

   if(tdist == 0)
      percentage = 1.0;
   else
      percentage = dist / tdist;
   xdiff = xe - xb;
   ydiff = ye - yb;
   *px = xb + (xdiff * percentage);
   *py = yb + (ydiff * percentage);
}



double InterpolateInteriorPointElevation(double d1,double e1,double d2,double e2,double dtgt)
{
double distdiff1, distdiff2;
double percentage;
double ediff;
double answer;
   distdiff1 = d2 - d1;
   distdiff2 = d2 - dtgt;
   if(distdiff2 == 0)
      answer = e2;
   else if(distdiff1 == 0)
      answer = e1;
   else
      {
      ediff = e2 - e1;
      percentage = distdiff2 / distdiff1;
      answer = e2 - (ediff * percentage);
      }
   return(answer);
}






int DrawLOSresult(double basex,double basey, double BaseH, double EndX,double EndY,double radius,
    double azimuth,int minx,int miny,int maxx,int maxy,double *effradius)
{
struct ProfileList *cp, *pp, *np, *TopRoot;
struct LOSlineList
   {
   double slope;
   double dist;
   double elev;
   unsigned char surfacepoint;
   unsigned char visible;
   struct LOSlineList * next;
   } *LOSlineRoot, *cl, *pl, *nl;
double LastTgtHeight;
double TgtHeight, ObsHeight;
double x1,y1,x2,y2,px,py;
double di,ei;
double LOSline;
double endx, endy;
double nLOSline;
double d1,e1,d2,e2;
double tdist,minimumdist;
double mindist, maxdist, mindistE, maxdistE;
double  h, hn;
double pointincrement;
int onblock, topblock;
int SzLL, iradius;
int i,j,k;
extern double OBS_HEIGHT, TGT_HEIGHT;
int blocklength = 0;
unsigned char *BlockZones;



   /*** this call should gather up the surface polys; ->domain == 5 ***/
   minimumdist = radius;
   ProfileRoot = ExtractProfileClass(DrawProfileRoot,5,3,&minimumdist);
   /** below should pull out the above surface (applique) structures **/
   minimumdist = radius;
   TopRoot = ExtractProfileClass(DrawProfileRoot,1,1,&minimumdist);

   *effradius = 0.0;
   cp = ProfileRoot;
   if(cp == NULL)
      {
      }
   np = cp->next;
   if(np == NULL)
      {
      }
   if((np->next == NULL) && (TopRoot == NULL))
      {
      *effradius = np->dist;
      }

   minx -= (int)RegionSize;
   miny -= (int)RegionSize;
   maxx += (int)RegionSize;
   maxy += (int)RegionSize;
   ObsHeight = OBS_HEIGHT;
   SzLL = sizeof(struct LOSlineList);
   LOSlineRoot = NULL;

   h = BaseH + ObsHeight;
   LOSlineRoot = (struct LOSlineList *) (malloc(SzLL));
   if(LOSlineRoot == NULL)
      {
      printf("DrawLOSresult: Out of allocation memory\n"); exit(-1);
      }
   LOSlineRoot->slope = 0;
   LOSlineRoot->dist = cp->dist;
   LOSlineRoot->elev = cp->elev;
   if(cp->stratum == 5)
      LOSlineRoot->surfacepoint = 1;
   else
      LOSlineRoot->surfacepoint = 0;
   LOSlineRoot->next = NULL;

   while(np != NULL)
      {
      if(np->dist == 0)
         LOSline = 0;
      else
         LOSline = (np->elev - h) / np->dist;
      cl = (struct LOSlineList *) malloc(SzLL);
      if(cl == NULL)
         {
         printf("DrawLOSresult: Out of allocation memory\n"); exit(-1);
         }
      cl->dist = np->dist;
      cl->elev = np->elev;
      cl->slope = LOSline;
      if(np->stratum == 5)
        cl->surfacepoint = 1;
      else
        cl->surfacepoint = 0;
      pl = nl = LOSlineRoot;
      while((pl != NULL) && (pl->dist < cl->dist))
         {
         nl = pl;
         pl = pl->next;
         }
      if(pl == NULL)
         {
         cl->next = NULL;
         nl->next = cl;
         }

      else if(pl->dist == cl->dist)
         {
         if(cl->elev == pl->elev)
            {
            free(cl);
            }
         else if(cl->elev < pl->elev)
            {
            cl->next = pl;
            if(pl == LOSlineRoot)
               LOSlineRoot = cl;
            else
               nl->next = cl;
            }
         else
            {
            cl->next = pl->next;
            pl->next = cl;
            }
         }
      else if(pl == LOSlineRoot)
         {
         cl->next = LOSlineRoot;
         LOSlineRoot = cl;
         }
      else
         {
         cl->next = pl;
         nl->next = cl;
         }
      cp = np;
      np = np->next;
      }


/** now, finally, lets check the LOS results **/

   cl = pl = LOSlineRoot;
   while(cl->next != NULL)
      cl = cl->next;
   if(cl->dist < radius)
      {
      FindAzimuthInteriorPoint(basex,basey,EndX,EndY,radius,cl->dist,&px,&py);
      radius = cl->dist;
      endx = px;
      endy = py;
      }
   else
      {
      endx = EndX;
      endy = EndY;
      }

   iradius = (int) radius;
   BlockZones = (unsigned char *) (malloc(iradius + 10));
   for(i=0; i<=(iradius + 5); i++)
      BlockZones[i] = 0;

   cl = pl = LOSlineRoot;
   h = e1 = cl->elev + ObsHeight;
   d1 = 0;
   while((cl != NULL) && (cl->dist == 0))
      {
      pl = cl;
      cl = cl->next;
      }
   if(cl != NULL)
      {
      LOSline = cl->slope;
      e2 = cl->elev;
      d2 = cl->dist;
      onblock = 0;
      TgtHeight = cl->elev + TGT_HEIGHT;
      x2 = y2 = 0;
      }
   while(cl != NULL)
      {
      if((LOSline < cl->slope) && (onblock == 0)) 
         {
         LOSline = cl->slope;
         d2 = cl->dist;
         e2 = cl->elev;
         }
      LastTgtHeight = TgtHeight;
      TgtHeight = cl->elev + TGT_HEIGHT;
      nLOSline = (TgtHeight - h) / cl->dist;
      cl->visible = 1;
      if(nLOSline < LOSline) /*** have a blockage **/
         {
         cl->visible = 0;
         if(onblock > 0) /** not first blocked point **/
            {
            x1 = x2;
            y1 = y2;
            tdist = pl->dist;
            FindAzimuthInteriorPoint(basex,basey,endx,endy,radius,cl->dist,&x2,&y2);
            MAPdrawline(0,x1,y1,x2,y2,2,DRAW_NOW);
            }
         else
            {
            if(TGT_HEIGHT == 0)
               {
               tdist = pl->dist;
               FindAzimuthInteriorPoint(basex,basey,endx,endy,radius,pl->dist,&x1,&y1);
               }
            else if(InfiniteLinesIntersect(d1,e1,d2,e2,pl->dist,LastTgtHeight,cl->dist,TgtHeight, &x1,&y1))
               {
               tdist = x1;
               FindAzimuthInteriorPoint(basex,basey,endx,endy,radius,tdist,&x1,&y1);
               }
            else
               {
               tdist = pl->dist;
               FindAzimuthInteriorPoint(basex,basey,endx,endy,radius,pl->dist,&x1,&y1);
               }
            FindAzimuthInteriorPoint(basex,basey,endx,endy,radius,cl->dist,&x2,&y2);
            MAPdrawline(0,x1,y1,x2,y2,2,DRAW_NOW);
            }
         ++onblock;
         j = (int) (tdist);
         k = (int) (cl->dist);
         if(j > iradius) j = iradius;
         if(k > iradius) k = iradius;
         for(i=j; i<=k; i++)
            BlockZones[i] = 1;
         }
      else if(onblock > 0) /** transition to now visible **/
         {
         onblock = 0;
         x1 = x2;
         y1 = y2;
         if(InfiniteLinesIntersect(d1,e1,d2,e2,pl->dist,LastTgtHeight,cl->dist,TgtHeight, &x2,&y2))
            {
            tdist = x2;
            FindAzimuthInteriorPoint(basex,basey,endx,endy,radius,tdist,&x2,&y2);
            MAPdrawline(0,x1,y1,x2,y2,2,DRAW_NOW);
            }
         j = (int) (pl->dist);
         k = (int) (tdist);
         if(j > iradius) j = iradius;
         if(k > iradius) k = iradius;
         for(i=j; i<=k; i++)
            BlockZones[i] = 1;
         }
      pl = cl;
      cl = cl->next;
      }

   if(TopRoot != NULL)
      {
      onblock = 0;
      cl = pl = LOSlineRoot;
      mindist = maxdist = cl->dist;
      mindistE = maxdistE = cl->elev;
      pointincrement = 1.0;
      for(tdist = minimumdist; tdist <= radius; tdist += pointincrement)
         {
         if((tdist >= mindist) && (tdist <= maxdist))
            {
            hn = InterpolateInteriorPointElevation(mindist,mindistE,maxdist,maxdistE,tdist);
            }
         else
            {
            while((cl != NULL) && (cl->dist < tdist))
               {
               pl = cl;
               cl = cl->next;
               }
            if((cl == NULL) || (pl->dist > tdist) || (cl->dist < tdist))
               {
               printf("Ordered distance exception\n");
               printf("dist: %lf radius %lf\n",tdist,radius);
               if(cl == NULL)
                  printf("cl is NULL\n");
               else
                  printf("cl dist %.2lf elev %.2lf, pl dist %.2lf elev %.2lf\n",cl->dist, cl->elev,
               pl->dist,pl->elev);
               cl = LOSlineRoot;
               while(cl != NULL)
                  {
                  printf("cl dist %lf elev %.2lf\n",cl->dist,cl->elev);
                  cl = cl->next;
                  }
               exit(-1);
               }
            mindist = pl->dist;
            mindistE = pl->elev;
            maxdist = cl->dist;
            maxdistE = cl->elev;
            hn = InterpolateInteriorPointElevation(mindist,mindistE,maxdist,maxdistE,tdist);
            }
         hn += TGT_HEIGHT;
         pp = TopRoot;
         cp = pp->next;
         topblock = 0;
         while(cp != NULL)
            {
            if(LineSegmentsIntersect(0.0,h,tdist,hn,pp->dist,pp->elev,
                                  cp->dist,cp->elev,&di,&ei) > 0)
                  {
               if(onblock == 0)
                  {
                  if((di >= minimumdist) && (di < tdist))
                     d1 = di;
                  else
                     d1 = tdist;
                  }
               else
                  {
                  d2 = tdist;
                  }
               ++onblock;
               topblock = 1;
               break;
               }
            pp = cp;
            cp = cp->next;
            if(pp->ptype > 999) /** last edge in a model **/
               {
               if(cp != NULL)
                  {
                  pp = cp;
                  cp = cp->next;
                  }
               }
            }
         if((onblock > 0) && (topblock == 0))
            {
            if(onblock == 1)
               d2 = d1;
            FindAzimuthInteriorPoint(basex,basey,endx,endy,radius,d1,&x1,&y1);
            FindAzimuthInteriorPoint(basex,basey,endx,endy,radius,d2,&x2,&y2);
            MAPdrawline(0,x1,y1,x2,y2,2,DRAW_NOW);
            onblock = 0;
            j = (int) (d1);
            k = (int) (d2);
            if(j > iradius) j = iradius;
            if(k > iradius) k = iradius;
            for(i=j; i<=k; i++)
               BlockZones[i] = 1;/***/
            }
         }
      if(onblock > 0)
         {
         if(onblock == 1)
            d2 = d1;
         FindAzimuthInteriorPoint(basex,basey,endx,endy,radius,d1,&x1,&y1);
         FindAzimuthInteriorPoint(basex,basey,endx,endy,radius,d2,&x2,&y2);
         MAPdrawline(0,x1,y1,x2,y2,2,DRAW_NOW);
         onblock = 0;
         j = (int) (d1);
         k = (int) (d2);
         if(j > iradius) j = iradius;
         if(k > iradius) k = iradius;
         for(i=j; i<=k; i++)
            BlockZones[i] = 1;/***/
         }
      cp = TopRoot;
      while(cp != NULL)
         {
         pp = cp;
         cp = cp->next;
         free(pp);
         }
      }

   cl = LOSlineRoot;
   while(cl != NULL)
      {
      pl = cl;
      cl = cl->next;
      free(pl);
      }
   blocklength = 0;
   for(i=0; i<= iradius; i++)
      {
      if(BlockZones[i] > 0)
         ++blocklength;
      }
   free(BlockZones);
   *effradius = (double) iradius;
   return(blocklength);
}




void CalcLOSfan(double xo,double yo,double xt,double yt)
{
double Quad;
double xdiff, ydiff;
double baseangle;
double baseElevation;
double azimuth, startazimuth, stopazimuth;
double HalfAngle;
double xe,ye;
double radius;
double MinElev, MaxElev;
double Angle;
extern double FAN_ANGLE;
extern int FAN_QUALITY;
int Sx,Ex,Sy,Ey;
double increment;
double xincr,yincr;
long int blockedlength, totallength;
int azimuthscomplete;
int TempOmitGridSentinels;
struct ProfileList *tp;
struct ToBeLoaded *HaveLoaded, *NeedLoad, *cTBL, *nTBL;
double pcblocked;
double maxlen;

   AlwaysUseEuclidean = 1;
   TempOmitGridSentinels = OmitGridSentinels;
   OmitGridSentinels = 0;

   if(xt > xo)  /** quad 1 or 2 **/
      {
      xdiff = xt - xo;
      if(yt > yo)  /** quadrant 1, octant 1 or 2 **/
         {
         ydiff = yt - yo;
         Quad = 1;
         }
      else
         {
         ydiff = yo - yt;
         Quad = 2;
         }
      }
   else
      {
      xdiff = xo - xt;
      if(yt > yo) /** quadrant 4, octant 7 or 8 **/
         {
         ydiff = yt - yo;
         Quad = 4;
         }
      else
         {
         ydiff = yo - yt;
         Quad = 3;
         }
      }

   Angle = FAN_ANGLE;
   if(Angle > 359.9)
      Angle = 359.9;

   radius = (xdiff * xdiff) + (ydiff * ydiff);
   radius = sqrt(radius);
   baseangle = (atan(ydiff / xdiff) * 180.0) / PI;

   Sx = (int) (xo - radius);
   Ex = (int) (xo + radius);
   Sy = (int) (yo - radius);
   Ey = (int) (yo + radius);

   ReleasePolyAllocations();
   FreeModelAllocations();

   if(Quad == 1)
      azimuth =  90.0 - baseangle;
   else if(Quad == 2)
      azimuth = 90.0 + baseangle;
   else if(Quad == 3)
      azimuth = 270.0 - baseangle;
   else
      azimuth = 270.0 + baseangle;
   HalfAngle = Angle / 2.0;
   startazimuth = azimuth - HalfAngle;
   if(startazimuth < 0)
      startazimuth = 360.0 + startazimuth;
   stopazimuth = azimuth + HalfAngle;
   if(stopazimuth > 360.0)
      stopazimuth = stopazimuth - 360.0;
   stopazimuth += 0.05;
   increment = 1.0;
   if(FAN_QUALITY <= 5)
      {
      increment = ((double) FAN_QUALITY) * 0.2;
      }
   else
      increment = (double) (2 * (FAN_QUALITY - 5));
   HaveLoaded = NULL;
   blockedlength = totallength = 0;
   azimuthscomplete = 0;
   GetPointElevation(xo,yo,&baseElevation);

   if(startazimuth > stopazimuth) /** have to cycle through 360 degrees **/
      {
      for(azimuth = startazimuth; azimuth < 360.9; azimuth += increment)
         {
         GetLOSendPoint(xo,yo,&xe,&ye,radius,azimuth);
         if(xe > xo) xincr = 0.01;
         else xincr = -0.01;
         if(ye > yo) yincr = 0.01;
         else yincr = -0.01;
         NeedLoad = NULL;
         NeedLoad = IdentifyLoadRegions(xo,yo,xe,ye);
         cTBL = NeedLoad;
         while(cTBL != NULL)
            {
            HaveLoaded = LoadRegionIfNecessary(HaveLoaded, cTBL->index1, cTBL->index2,xo,yo,xe,ye);
            nTBL = cTBL;
            cTBL = cTBL->next;
            free(nTBL);
            }
         tp = AssembleDrawProfilePoints(xo,yo,xe+xincr,ye+yincr,&MinElev,&MaxElev,0);
         blockedlength += DrawLOSresult(xo,yo,baseElevation,xe,ye,radius,azimuth,Sx,Sy,Ex,Ey,&maxlen);
         totallength += (int) (maxlen);
         FreeProfilePoints(DrawProfileRoot);
         DrawProfileRoot = NULL;
         FreeProfilePoints(ProfileRoot);
         ProfileRoot = NULL;
         ++azimuthscomplete;
         if((azimuthscomplete % 2) == 0)
            {
            cTBL = HaveLoaded;
            while(cTBL != NULL)
               {
               nTBL = cTBL;
               cTBL = cTBL->next;
               free(nTBL);
               }
            HaveLoaded = NULL;
            }
         }
      for(azimuth= 0.0; azimuth < stopazimuth; azimuth += increment)
         {
         GetLOSendPoint(xo,yo,&xe,&ye,radius,azimuth);
         if(xe > xo) xincr = 0.01;
         else xincr = -0.01;
         if(ye > yo) yincr = 0.01;
         else yincr = -0.01;
         NeedLoad = NULL;
         NeedLoad = IdentifyLoadRegions(xo,yo,xe,ye);
         cTBL = NeedLoad;
         while(cTBL != NULL)
            {
            HaveLoaded = LoadRegionIfNecessary(HaveLoaded, cTBL->index1, cTBL->index2,xo,yo,xe,ye);
            nTBL = cTBL;
            cTBL = cTBL->next;
            free(nTBL);
            }
         tp = AssembleDrawProfilePoints(xo,yo,xe+xincr,ye+yincr,&MinElev,&MaxElev,0);
         blockedlength += DrawLOSresult(xo,yo,baseElevation,xe,ye,radius,azimuth,Sx,Sy,Ex,Ey,&maxlen);
         totallength += (int) (maxlen);
         FreeProfilePoints(DrawProfileRoot);
         DrawProfileRoot = NULL;
         FreeProfilePoints(ProfileRoot);
         ProfileRoot = NULL;
         ++azimuthscomplete;
         if((azimuthscomplete % 2) == 0)
            {
            cTBL = HaveLoaded;
            while(cTBL != NULL)
               {
               nTBL = cTBL;
               cTBL = cTBL->next;
               free(nTBL);
               }
            HaveLoaded = NULL;
            }
         }
      }
   else
      {
      for(azimuth=startazimuth; azimuth < stopazimuth; azimuth += increment)
         {
         GetLOSendPoint(xo,yo,&xe,&ye,radius,azimuth);
         if(xe > xo) xincr = 0.01;
         else xincr = -0.01;
         if(ye > yo) yincr = 0.01;
         else yincr = -0.01;
         NeedLoad = NULL;
         NeedLoad = IdentifyLoadRegions(xo,yo,xe,ye);
         cTBL = NeedLoad;
         while(cTBL != NULL)
            {
            HaveLoaded = LoadRegionIfNecessary(HaveLoaded, cTBL->index1, cTBL->index2,xo,yo,xe,ye);
            nTBL = cTBL;
            cTBL = cTBL->next;
            free(nTBL);
            }
         tp = AssembleDrawProfilePoints(xo,yo,xe+xincr,ye+yincr,&MinElev,&MaxElev,0);
         blockedlength += DrawLOSresult(xo,yo,baseElevation,xe,ye,radius,azimuth,Sx,Sy,Ex,Ey,&maxlen);
         totallength += (int) (maxlen);
         FreeProfilePoints(DrawProfileRoot);
         DrawProfileRoot = NULL;
         FreeProfilePoints(ProfileRoot);
         ProfileRoot = NULL;
         ++azimuthscomplete;
         if((azimuthscomplete % 2) == 0)
            {
            cTBL = HaveLoaded;
            while(cTBL != NULL)
               {
               nTBL = cTBL;
               cTBL = cTBL->next;
               free(nTBL);
               }
            HaveLoaded = NULL;
            }
         }
      }

   cTBL = HaveLoaded;
   while(cTBL != NULL)
      {
      nTBL = cTBL;
      cTBL = cTBL->next;
      free(nTBL);
      }
   ReleasePolyAllocations();
   FreeModelAllocations();

   if(blockedlength >= totallength)
      pcblocked = 0.0;
   else
      {
      pcblocked = ((double) blockedlength) / ((double) totallength);
      pcblocked = 100.0 - (pcblocked * 100);
      }
   sprintf(MessageLine,"%.2lf percent of this fan is visible\n",pcblocked);
   make_los_message(MessageLine,0,"LOS Fan Result",5);


   AlwaysUseEuclidean = 0;
   OmitGridSentinels = TempOmitGridSentinels;
}






void CreateDrawProfile(double Inx1,double Iny1,double Inx2,double Iny2,
   double *minElev,double *maxElev)
{
struct ProfileList *cp;
double x1,y1,x2,y2,DistPad;
int TempOmitGridSentinels;
extern int LOS;

   TempOmitGridSentinels = OmitGridSentinels;
   if(LOS > 0)
      OmitGridSentinels = 0;

   x1 = Inx1;
   x2 = Inx2;
   y1 = Iny1;
   y2 = Iny2;

   DrawProfileRoot = NULL;

   if(x1 < MinSurfXcoord)
      {
      if(x2 <= MinSurfXcoord)
         {
         OmitGridSentinels = TempOmitGridSentinels;
         DrawProfileRoot = NULL;
         ProfileRoot = NULL;
         return;
         }
      else
         {
         x1 = MinSurfXcoord;
         y1 = FindXatYonSegment(x1,Iny1,Inx1,Iny2,Inx2); /** reverse arg order since finding y, not finding x ... ***/
         }
      }
   if(x1 > MaxSurfXcoord)
      {
      if(x2 >= MaxSurfXcoord)
         {
         OmitGridSentinels = TempOmitGridSentinels;
         DrawProfileRoot = NULL;
         ProfileRoot = NULL;
         return;
         }
      else
         {
         x1 = MaxSurfXcoord;
         y1 = FindXatYonSegment(x1,Iny1,Inx1,Iny2,Inx2); /** reverse arg order since finding y, not finding x ... ***/
         }
      }
   if(y1 < MinSurfYcoord)
      {
      if(y2 <= MinSurfYcoord)
         {
         OmitGridSentinels = TempOmitGridSentinels;
         DrawProfileRoot = NULL;
         ProfileRoot = NULL;
         return;
         }
      else
         {
         y1 = MinSurfYcoord;
         x1 = FindXatYonSegment(y1,Inx1,Iny1,Inx2,Iny2);
         }
      }
   if(y1 > MaxSurfYcoord)
      {
      if(y2 >= MaxSurfYcoord)
         {
         OmitGridSentinels = TempOmitGridSentinels;
         DrawProfileRoot = NULL;
         ProfileRoot = NULL;
         return;
         }
      else
         {
         y1 = MaxSurfYcoord;
         x1 = FindXatYonSegment(y1,Inx1,Iny1,Inx2,Iny2);
         }
      }
   if(x2 < MinSurfXcoord)
      {
      x2 = MinSurfXcoord;
      y2 = FindXatYonSegment(x2,Iny1,Inx1,Iny2,Inx2); /** reverse arg order since finding y, not finding x ... ***/
      }
   if(x2 > MaxSurfXcoord)
      {
      x2 = MaxSurfXcoord;
      y2 = FindXatYonSegment(x2,Iny1,Inx1,Iny2,Inx2); /** reverse arg order since finding y, not finding x ... ***/
      }
   if(y2 < MinSurfYcoord)
      {
      y2 = MinSurfYcoord;
      x2 = FindXatYonSegment(y2,Inx1,Iny1,Inx2,Iny2);
      }
   if(y2 > MaxSurfYcoord)
      {
      y2 = MaxSurfYcoord;
      x2 = FindXatYonSegment(y2,Inx1,Iny1,Inx2,Iny2);
      }


   ReleasePolyAllocations();
   FreeModelAllocations();
   ReadProfileData(x1,y1,x2,y2);
   cp = AssembleDrawProfilePoints(x1,y1,x2,y2,minElev,maxElev,1);
   cp = DrawProfileRoot;

   DistPad = 0.0;
   if((x1 != Inx1) || (y1 != Iny1))
      DistPad = Distance(x1,y1,Inx1,Iny1);
   while(cp != NULL)
      {
      if((cp->ptype > 22) && (cp->ptype < 26))
         cp->ptype = 26;
      else if(cp->ptype == 82)
         cp->ptype = 28;

      cp->dist += DistPad;

      cp = cp->next;
      }
   OmitGridSentinels = TempOmitGridSentinels;
   ReleasePolyAllocations();
   FreeModelAllocations();
}



void FreePolygonList(struct ThePolys *root, struct ListOfEdges * edgeroot, struct ListOfEdges *Vedgeroot)
{
struct ThePolys *tpc, *tpp;
struct NeighborPolys *nc, *np;
struct ListOfEdges *ec, *ep;
struct IncidentList *ic, *ip;


   tpc = root;
   while(tpc != NULL)
      {
      tpp = tpc;
      tpc = tpc->next;
      if(tpp->Xtra != NULL)
         {
         nc = tpp->Xtra->N;
         while(nc != NULL)
            {
            np = nc;
            nc = nc->next;
            free(np);
            }
         }
      free(tpp->x);
      free(tpp->y);
      free(tpp->z);
      free(tpp);
      }
   ec = edgeroot;
   while(ec != NULL)
      {
if(VTEARdebud_3)
++EdgeCount;
      ep = ec;
      ic = ep->Iedge;
      while(ic != NULL)
         {
if(VTEARdebud_3)
++AdjEdgeCount;
         ip = ic;
         ic = ic->next;
         ip->next = NULL;
         free(ip);
         }
      ep->Iedge = NULL;
      ec = ec->next;
      free(ep);
      }
   ec = Vedgeroot;
   while(ec != NULL)
      {
if(VTEARdebud_3)
++VertEdgeCount;
      ep = ec;
      ic = ep->Iedge;
      while(ic != NULL)
         {
         ip = ic;
         ic = ic->next;
         ip->next = NULL;
         free(ip);
         }
      ep->Iedge = NULL;
      ec = ec->next;
      free(ep);
      }
}



void FreeArealList(struct RawAreal *root, struct ListOfEdges * edgeroot, int cindex)
{
struct RawAreal *rac, *rap;
struct ListOfEdges *ec, *ep;
struct IncidentList *ic, *ip;
struct LargeAreals *ARlc, *ARlp;
   rac = root;
   while(rac != NULL)
      {
      rap = rac;
      rac = rac->next;
      if(rap->ismulti == 0)
         {
         free(rap->x);
         free(rap->y);
         free(rap->z);
         if(rap->areastr != NULL)
            free(rap->areastr);
         if(rap->hgtstr != NULL)
            free(rap->hgtstr);
         if(rap->zv2str != NULL)
            free(rap->zv2str);
         if(rap->lenstr != NULL)
            free(rap->lenstr);
         if(rap->namstr != NULL)
            free(rap->namstr);
         free(rap);
         }
      else if((rap->ismulti > 0) && (rap->numverts < LARGEAREALVERTEXLIMIT))
         {
         free(rap->x);
         free(rap->y);
         free(rap->z);
         if(rap->areastr != NULL)
            free(rap->areastr);
         if(rap->hgtstr != NULL)
            free(rap->hgtstr);
         if(rap->zv2str != NULL)
            free(rap->zv2str);
         if(rap->lenstr != NULL)
            free(rap->lenstr);
         if(rap->namstr != NULL)
            free(rap->namstr);
         free(rap);
         }

      else if((rap->numverts >= LARGEAREALVERTEXLIMIT) && (rap->ismulti <= cindex))
         {
         ARlp = ARlc = ARlargeRoot;
         while(ARlc != NULL)
            {
            if(ARlc->ra == rap)
               {
               free(rap->x);
               free(rap->y);
               free(rap->z);
               if(rap->areastr != NULL)
                  free(rap->areastr);
               if(rap->hgtstr != NULL)
                  free(rap->hgtstr);
               if(rap->zv2str != NULL)
                  free(rap->zv2str);
               if(rap->lenstr != NULL)
                  free(rap->lenstr);
               if(rap->namstr != NULL)
                  free(rap->namstr);
               if(rap->RB_Tree_Edgelist != NULL)
                  RBTreeDestroy(rap->RB_Tree_Edgelist);

               free(rap);
               ARlc->ra = NULL;

               if(ARlc == ARlargeRoot)
                  {

                  ARlargeRoot = ARlargeRoot->next;
                  free(ARlc);
                  }
               else 
                  {
                  ARlp->next = ARlc->next;
                  free(ARlc);
                  }
               break;
               }
            ARlp = ARlc;
            ARlc = ARlc->next;
            }

         }
      }
      
   ec = edgeroot;
   while(ec != NULL)
      {
      ep = ec;
      ic = ep->Iedge;
      while(ic != NULL)
         {
         ip = ic;
         ic = ic->next;
         free(ip);
         }
      ec = ec->next;
      free(ep);
      }
}


void FreeLinearsList(struct RawLinear *root)
{
struct RawLinear *rlc, *rln;
   rlc = root;
   while(rlc != NULL)
      {
      rln = rlc;
      rlc = rlc->next;
      free(rln->x);
      free(rln->y);
      free(rln->z);
      if(rln->areastr != NULL)
         free(rln->areastr);
      if(rln->hgtstr != NULL)
         free(rln->hgtstr);
      if(rln->zv2str != NULL)
         free(rln->zv2str);
      if(rln->lenstr != NULL)
         free(rln->lenstr);
      if(rln->namstr != NULL)
         free(rln->namstr);
      free(rln);
      }
}


void FreePointList(struct RawPoint *root)
{
struct RawPoint *rpc, *rpn;
   rpc = root;
   while(rpc != NULL)
      {
      rpn = rpc;
      rpc = rpc->next;
      free(rpn->h);
      free(rpn->x);
      free(rpn->y);
      free(rpn->z);
      if(rpn->areastr != NULL)
         free(rpn->areastr);
      if(rpn->hgtstr != NULL)
         free(rpn->hgtstr);
      if(rpn->zv2str != NULL)
         free(rpn->zv2str);
      if(rpn->lenstr != NULL)
         free(rpn->lenstr);
      if(rpn->namstr != NULL)
         free(rpn->namstr);
      free(rpn);
      }
}


void FreeBridgeList(struct RawBridge *root)
{
struct RawBridge *rbc, *rbp;
   rbc = root;
   while(rbc != NULL)
      {
      rbp = rbc;
      rbc = rbc->next;
      free(rbp->x);
      free(rbp->y);
      free(rbp->z);
      free(rbp->h);
      free(rbp);
      }
}


int DuplicateVerticesExist(int vtxcnt, double *x, double *y, double *z)
{
int answer;
int i,j;
int iOK, jOK;

   answer = 0;
   if(vtxcnt > 1)
      {
      iOK = IsSentinelZvalue(z[0],UseNUNANPO);
      for(i=1; i<vtxcnt; i++)
         {
         j = i - 1;
         jOK = iOK;
         iOK = IsSentinelZvalue(z[i],UseNUNANPO);

         if((iOK == 0) && (jOK == 0))
            {
            if((x[i] == x[j]) && (y[i] == y[j]) && (z[i] == z[j]))
               {
               ++answer;
               }
            }
         else
            {
            if((x[i] == x[j]) && (y[i] == y[j]))
               {
               ++answer;
               }
            }
         }
      }
   return(answer);
}




struct ThePolys * CheckPolygonDuplication(struct PolyAsRead newpoly, struct ThePolys **polylist, int Sz, int *answer,
                                             struct DoublePolySkipList *Skip, int indexlimit, struct ThePolys **ElDupo)
{
struct ThePolys *tpc, *tpp, *tpn;
int i,j,k,kc,counter;
int *UsedIndex;
int matches;
int reinsert = 0;
int skipinterval = 100;

   if((*polylist == NULL) || (newpoly.numverts < 1))
      *answer = 0;
   else
      {
      UsedIndex = (int *) (malloc(SzI * newpoly.numverts));
      k = 0;
      while((k < indexlimit) && (Skip[k].entry != NULL) && (Skip[k].val < newpoly.minxvtx))
        ++k;
      if(k > 0)
         {
         --k;
         kc = counter = k * skipinterval;
         tpp = Skip[k].entry;
         tpc = tpp->next;
         }
      else
         {
         tpp = tpc = *polylist;
         counter = 1;
         kc = 0;
         }
      while(tpc != NULL)
         {
         if(tpc->minxvtx > newpoly.minxvtx)
            break;
         if((newpoly.minxvtx == tpc->minxvtx) && (newpoly.numverts == tpc->numverts))
            {
            matches = 0;
            for(i=0; i<newpoly.numverts; i++)
               UsedIndex[i] = 0;
            for(i=0; i<newpoly.numverts; i++)
               {
               for(j=0; j<tpc->numverts; j++)
                  {
                  if((newpoly.x[i] == tpc->x[j]) && (newpoly.y[i] == tpc->y[j]) &&
                         (newpoly.z[i] == tpc->z[j]) && (UsedIndex[j] == 0))
                     {
                     ++matches;
                     UsedIndex[j] = 1;
                     break;
                     }
                  }
               if(matches <= i)
                  break;
               }
            if(matches == newpoly.numverts)
               break;
            }
         if((counter % skipinterval) == 0)
            {
            if(counter > kc)
               {
               k = (counter / skipinterval) - 1;
               if(k < indexlimit)
                  {
                  Skip[k].val = tpp->minxvtx;
                  Skip[k].entry = tpc;
                  }
               }
            }
         ++counter;
         tpp = tpc;
         tpc = tpc->next;
         }
      if((tpc == NULL) || (tpc->minxvtx > newpoly.minxvtx))
         *answer = 0; /** 0 says no duplication at all **/
      else
         {
         *ElDupo = tpc; /* a pointer to the dup **/
         *answer = 1; /** 1 implies geometric duplication **/
         if((newpoly.SACindex == tpc->SACindex) && (newpoly.SCCindex == tpc->SCCindex))
            *answer = 4; /** 4 implies a complete duplication of attributes too **/
         }
      free(UsedIndex);
      }
   if(*answer > 1)
      tpn = NULL;
   else
      {
      tpn = (struct ThePolys *) (malloc(Sz));
      if(tpn == NULL)
         {
         printf("allocation memory has been exhausted during polygon processing\n");
         printf("program cannot continue\n");
         exit(-1);
         }
      if(*polylist == NULL)
         {
         tpn->next = NULL;
         *polylist = tpn;
         }
      else if(tpc == *polylist)
         {
         tpn->next = tpc;
         *polylist = tpn;
         }
      else if(tpc == NULL)
         {
         tpn->next = NULL;
         tpp->next = tpn;
         }
      else
         {
         if((tpp->minxvtx <= newpoly.minxvtx) && (newpoly.minxvtx <= tpc->minxvtx))
            {
            tpn->next = tpc;
            tpp->next = tpn;
            }
         else
            {
            tpp = tpc = *polylist;
            counter = 1;
            while(tpc != NULL)
               {
               if((reinsert == 0) && (tpc->minxvtx >= newpoly.minxvtx))
                  {
                  reinsert = 1;
                  if(tpc == *polylist)
                     {
                     tpn->next = *polylist;
                     *polylist = tpn;
                     }
                  else
                     {
                     tpn->next = tpc;
                     tpp->next = tpn;
                     }
                  }
               if((counter % skipinterval) == 0)
                  {
                  k = (counter / skipinterval) - 1;
                  if(k < indexlimit)
                     {
                     Skip[k].val = tpp->minxvtx;
                     Skip[k].entry = tpc;
                     }
                  }
               ++counter;
               if(tpp->next == tpn)
                  tpp = tpn;
               else
                  tpp = tpc;
               tpc = tpc->next;
               }
            }
         }
      }

   return(tpn);
}


int NotSameString(int a, int b)
{
int answer;
char id1[1000];
char id2[1000];
extern int GetLongAttrVal(int type,int uniqueid,int *Ival,double *Dval,char *Cval);

   if(NGA_TYPE==0)
      {
      return 1;
      }

   if(a==b)
      {
      return 0;
      }

   answer = 1;


   GetAppropIDnumber(a, &id1[0]);
   GetAppropIDnumber(b, &id2[0]);
   if(strcmp(id1,id2) == 0)
      {
      answer = 0;

      if((ATTRTYPE_ANY_TDS() > 0) || (ATTRTYPE_ANY_GGDM() > 0))
         {
         if((strcmp(id1,"No Information") == 0) && (strcmp(id2,"No Information") == 0))
            return(1);
         }

      sprintf(id2,"No %s found",GetFrontPart());

      if(!strcmp(id1,id2))
         {
         return(1);
         }

      sprintf(id2," Blank %s found ",GetFrontPart());

      if(!strcmp(id1,id2))
         {
         return(1);
         }

      /* should be impossible */
      sprintf(id2,"%s Unavailable--See Console\n",GetFrontPart());

      if(!strcmp(id1,id2))
         {
         return(1);
         }

      if((id1[0] == ' ') && (id1[1] == '\0'))
         return(1);

      }
    
  return(answer);

}


int Area_LongAttrsMatch(struct ArealAsRead newareal, struct RawAreal * a1)
{
int answer = 0;
   if((a1->areastr != NULL) && (strcmp(newareal.areastr,a1->areastr) != 0))
      return(answer);
   if((a1->hgtstr != NULL) && (strcmp(newareal.hgtstr,a1->hgtstr) != 0))
      return(answer);
   if((a1->zv2str != NULL) && (strcmp(newareal.zv2str,a1->zv2str) != 0))
      return(answer);
   if((a1->lenstr != NULL) && (strcmp(newareal.lenstr,a1->lenstr) != 0))
      return(answer);
   if((a1->namstr != NULL) && (strcmp(newareal.namstr,a1->namstr) != 0))
      return(answer);
   if(newareal.areaattr != a1->areaattr)
      return(answer);
   if(newareal.hgtattr != a1->hgtattr)
      return(answer);
   if(newareal.zv2attr != a1->zv2attr)
      return(answer);
   if(newareal.lenattr != a1->lenattr)
      return(answer);
   if(newareal.namattr != a1->namattr)
      return(answer);
  
   answer = 1;
   return(answer);

}





/*****
answer	meaning
0	no duplication
1	geometric dup, no id dup
2	id dup only
3	geometric dup and id dup
4	complete dup (geom and attribution), no id dup
5	complete dup (geom and attribution) and id dup as well
******/
struct RawAreal * CheckArealDuplication(struct ArealAsRead newareal, struct RawAreal *areallist, int *answer,
					int CheckOnlyOne, int OKtoWriteError, double myID)
{
struct RawAreal *tpc, /***  *IDdup, ***/ *answer_tpc;
int i,j,s,local_answer,FoundOne;
int *UsedIndex;
int matches,part1, part2, part3, checkinstance;


   tpc = areallist;
   answer_tpc = tpc;
   local_answer = 0;

   matches = 0;

   if((areallist == NULL) || (newareal.numverts < 1))
      *answer = 0;
      
   else 
      {
      UsedIndex = (int *) (malloc(SzI * newareal.numverts));
      *answer = 0;
      while(tpc != NULL)
         {
         FoundOne = 0;
         local_answer = 0;
         s = NotSameString(newareal.idn,tpc->idn);
         if((newareal.numverts == tpc->numverts) && (newareal.minxvtx == tpc->minxvtx) && (newareal.area == tpc->area) &&
                 (s > 0) && (newareal.ishole == tpc->ishole))
            {
            matches = 0;
            for(i=0; i<newareal.numverts; i++)
               UsedIndex[i] = 0;
            for(i=0; i<newareal.numverts; i++)
               {
               if((UsedIndex[i] == 0) && (newareal.x[i] == tpc->x[i]) && (newareal.y[i] == tpc->y[i]) &&
                         (newareal.z[i] == tpc->z[i]))
                  {
                  ++matches;
                  UsedIndex[i] = 1;
                  }
               else
                  {
                  for(j=0; j<tpc->numverts; j++)
                     {
                     if((newareal.x[i] == tpc->x[j]) && (newareal.y[i] == tpc->y[j]) &&
                            (newareal.z[i] == tpc->z[j]) && (UsedIndex[j] == 0))
                        {
                        ++matches;
                        UsedIndex[j] = 1;
                        break;
                        }
                     }
                  }
               if(matches <= i)
                  {
                  break;
                  }
               }
            if(matches == newareal.numverts)
               {
               FoundOne = 1;
               }
            }
         else if(s == 0)
            {
           if((newareal.numverts == tpc->numverts) && (newareal.minxvtx == tpc->minxvtx) && (newareal.area == tpc->area) &&
                    (newareal.ishole == tpc->ishole))
               {
               matches = 0;
               for(i=0; i<newareal.numverts; i++)
                  UsedIndex[i] = 0;
               for(i=0; i<newareal.numverts; i++)
                  {
                  if((UsedIndex[i] == 0) && (newareal.x[i] == tpc->x[i]) && (newareal.y[i] == tpc->y[i]) &&
                            (newareal.z[i] == tpc->z[i]))
                     {
                     ++matches;
                     UsedIndex[i] = 1;
                     }
                  else
                     {
                     for(j=0; j<tpc->numverts; j++)
                        {
                        if((newareal.x[i] == tpc->x[j]) && (newareal.y[i] == tpc->y[j]) &&
                               (newareal.z[i] == tpc->z[j]) && (UsedIndex[j] == 0))
                           {
                           ++matches;
                           UsedIndex[j] = 1;
                           break;
                           }
                        }
                     }
                  if(matches <= i)
                     break;
                  }
               if(matches == newareal.numverts)
                  {
                  FoundOne = 1;
                  }
               }
            }
         if(FoundOne == 0)
            local_answer = 0; /** 0 says no duplication at all **/
         else
            {
            if(s > 0)
               {
               if((newareal.Lindex == tpc->Lindex) && (Area_LongAttrsMatch(newareal,tpc) > 0))
                  {
                  local_answer = 4; /** 4 implies a complete duplication of attributes but not ID **/
                  if((newareal.ishole > 0) && (tpc->ishole > 0))
                     {
                     DHn = (struct DuplicateHoles *) (malloc(SzDH));
                     if(DHn == NULL)
                        {
                        printf("all available memory has been consumed - duplicate inner ring allocation failed\n");
                        exit(-1);
                        }
                     DHn->thisidn = newareal.idn;
                     DHn->dupidn = tpc->idn;
                     DHn->next = DHroot;
                     DHroot = DHn;
                     }
                  }
               else if((newareal.ishole > 0) || (tpc->ishole > 0))
                  local_answer = 0;
               else
                  local_answer = 1;  /** 1 implies geometric duplication but not ID ***/
               }
            else /*** s == 0, so have ID duplication as well ***/
               {
               if(matches == newareal.numverts)
                  {
                  if((newareal.Lindex == tpc->Lindex) && (Area_LongAttrsMatch(newareal,tpc) > 0))
                     {
                     local_answer = 5; /** 2 implies a complete duplication of attributes and ID **/
                     if((newareal.ishole > 0) && (tpc->ishole > 0))
                        {
                        DHn = (struct DuplicateHoles *) (malloc(SzDH));
                        if(DHn == NULL)
                           {
                           printf("all available memory has been consumed - duplicate inner ring allocation failed\n");
                           exit(-1);
                           }
                        DHn->thisidn = newareal.idn;
                        DHn->dupidn = tpc->idn;
                        DHn->next = DHroot;
                        DHroot = DHn;
                        }
                     }
                  else if((newareal.ishole > 0) || (tpc->ishole > 0))
                     local_answer = 0;
                  else
                     local_answer = 3;  /** 1 implies geometric duplication and ID **/
   
                  }
               else if((newareal.ishole > 0) || (tpc->ishole > 0))
                  local_answer = 0;
               else
                  local_answer = 2;
               }

            if(OKtoWriteError > 0)
               {
               for(checkinstance = 0; checkinstance < TtlActiveChecks; checkinstance++)
                  {
                  if((local_answer == 1) &&
                     (CombinedCheckApplies(newareal.idn,checkinstance,G_DUPS,newareal.Lindex,newareal.Sindex,
                                       newareal.config,newareal.stratum,newareal.domain,
                                       &part1,&part2,&part3))  && (part1 > 0) &&
                    (CombinedCheckApplies(tpc->idn,checkinstance,G_DUPS,tpc->Lindex,tpc->Sindex,
                     SCCtable[tpc->Sindex].C, SCCtable[tpc->Sindex].S, SCCtable[tpc->Sindex].D,
                                      &part1,&part2,&part3)) && (part2 > 0))
                    {
                 /** found a geometric duplicate area feature object ***/
                    FwriteTwoObjects(G_DUPS,Make_Correct(G_DUPS,checkinstance),
                                  newareal.idn,G_AREAL,newareal.Lindex,myID,newareal.Sindex,-1.0, -1.0,
                                  2, newareal.x, newareal.y,newareal.z,
                                  tpc->idn,G_AREAL,tpc->Lindex,tpc->localID,tpc->Sindex,-1.0,-1.0,2,
                                  tpc->x, tpc->y,tpc->z);
                    }
                 if((local_answer == 4) &&
                     (CombinedCheckApplies(newareal.idn,checkinstance,C_DUPS,newareal.Lindex,newareal.Sindex,
                                        newareal.config,newareal.stratum,newareal.domain,
                                        &part1,&part2,&part3))   && (part1 > 0) &&
                        (CombinedCheckApplies(tpc->idn,checkinstance,C_DUPS,tpc->Lindex,tpc->Sindex,
                         SCCtable[tpc->Sindex].C, SCCtable[tpc->Sindex].S, SCCtable[tpc->Sindex].D,
                                             &part1,&part2,&part3)) && (part1 > 0))
                    {
                                 /** found a complete duplicate area feature object ***/

                    FwriteTwoObjects(C_DUPS,Make_Correct(C_DUPS,checkinstance),
                                    newareal.idn,G_AREAL,newareal.Lindex,myID,newareal.Sindex,-1.0, -1.0,
                                    2, newareal.x, newareal.y,newareal.z,
                                    tpc->idn,G_AREAL,tpc->Lindex,tpc->localID,tpc->Sindex,-1.0,-1.0,2,
                                    tpc->x, tpc->y,tpc->z);
                    }
                 if(NGA_TYPE > 0)
                    {
                    if((local_answer == 2) && (tpc->ishole <= 0) && (newareal.ishole <= 0) &&
                       (CombinedCheckApplies(newareal.idn,checkinstance,SAMEID,newareal.Lindex,newareal.Sindex,
                                       newareal.config,newareal.stratum,newareal.domain,
                                       &part1,&part2,&part3))  && (part1 > 0) &&
                       (CombinedCheckApplies(tpc->idn,checkinstance,SAMEID,tpc->Lindex,tpc->Sindex,
                        SCCtable[tpc->Sindex].C, SCCtable[tpc->Sindex].S, SCCtable[tpc->Sindex].D,
                                            &part1,&part2,&part3)) && (part2 > 0))
                       {
                                 /** found a SAMEID - duplicate area feature object ***/
                       FwriteTwoObjects(SAMEID,Make_Correct(SAMEID,checkinstance),
                                   newareal.idn,G_AREAL,newareal.Lindex,myID,newareal.Sindex,-1.0, -1.0,
                                   2, newareal.x, newareal.y,newareal.z,
                                   tpc->idn,G_AREAL,tpc->Lindex,tpc->localID,tpc->Sindex,-1.0,-1.0,2,
                                   tpc->x, tpc->y,tpc->z);
                       }

                    if((local_answer == 3) &&
                       (CombinedCheckApplies(newareal.idn,checkinstance,SAMEID_GDUP,newareal.Lindex,newareal.Sindex,
                                       newareal.config,newareal.stratum,newareal.domain,
                                       &part1,&part2,&part3))  && (part1 > 0) &&
                       (CombinedCheckApplies(tpc->idn,checkinstance,SAMEID_GDUP,tpc->Lindex,tpc->Sindex,
                        SCCtable[tpc->Sindex].C, SCCtable[tpc->Sindex].S, SCCtable[tpc->Sindex].D,
                                            &part1,&part2,&part3)) && (part2 > 0))
                       {
                                 /** found a SAMEID - geometric duplicate area feature object ***/
                       FwriteTwoObjects(SAMEID_GDUP,Make_Correct(SAMEID_GDUP,checkinstance),
                                   newareal.idn,G_AREAL,newareal.Lindex,myID,newareal.Sindex,-1.0, -1.0,
                                   2, newareal.x, newareal.y,newareal.z,
                                   tpc->idn,G_AREAL,tpc->Lindex,tpc->localID,tpc->Sindex,-1.0,-1.0,2,
                                   tpc->x, tpc->y,tpc->z);
                       }

                    if((local_answer == 5) &&
                       (CombinedCheckApplies(newareal.idn,checkinstance,SAMEID_CDUP,newareal.Lindex,newareal.Sindex,
                                       newareal.config,newareal.stratum,newareal.domain,
                                       &part1,&part2,&part3))   && (part1 > 0) &&
                       (CombinedCheckApplies(tpc->idn,checkinstance,SAMEID_CDUP,tpc->Lindex,tpc->Sindex,
                        SCCtable[tpc->Sindex].C, SCCtable[tpc->Sindex].S, SCCtable[tpc->Sindex].D,
                                            &part1,&part2,&part3)) && (part1 > 0))
                       {
                                 /** found a SAMEID - complete duplicate area feature object ***/
                       FwriteTwoObjects(SAMEID_CDUP,Make_Correct(SAMEID_CDUP,checkinstance),
                                   newareal.idn,G_AREAL,newareal.Lindex,myID,newareal.Sindex,-1.0, -1.0,
                                   2, newareal.x, newareal.y,newareal.z,
                                   tpc->idn,G_AREAL,tpc->Lindex,tpc->localID,tpc->Sindex,-1.0,-1.0,2,
                                   tpc->x, tpc->y,tpc->z);
                       }
                    }
                  }
               }

            }

         if(local_answer > *answer)
            {
            *answer = local_answer;
            answer_tpc = tpc;
            }

         if(CheckOnlyOne == 0)
            tpc = tpc->next;
         else
            {
            tpc = NULL;
            break;
            }
         }
      free(UsedIndex);
      }

   return(answer_tpc);
}



int Line_LongAttrsMatch(struct LinearAsRead newlinear, struct RawLinear * a1)
{
int answer = 0;

   if((a1->areastr != NULL) && (strcmp(newlinear.areastr,a1->areastr) != 0))
      return(answer);
   if((a1->areastr != NULL) && (strcmp(newlinear.hgtstr,a1->hgtstr) != 0))
      return(answer);
   if((a1->zv2str != NULL) && (strcmp(newlinear.zv2str,a1->zv2str) != 0))
      return(answer);
   if((a1->lenstr != NULL) && (strcmp(newlinear.lenstr,a1->lenstr) != 0))
      return(answer);
   if((a1->namstr != NULL) && (strcmp(newlinear.namstr,a1->namstr) != 0))
      return(answer);
   if(newlinear.areaattr != a1->areaattr)
      return(answer);
   if(newlinear.hgtattr != a1->hgtattr)
      return(answer);
   if(newlinear.zv2attr != a1->zv2attr)
      return(answer);
   if(newlinear.lenattr != a1->lenattr)
      return(answer);
   if(newlinear.namattr != a1->namattr)
      return(answer);

   answer = 1;
   return(answer);

}





/*****
answer  meaning
0       no duplication
1       geometric dup, no id dup
2       id dup only
3       geometric dup and id dup
4       complete dup (geom and attribution), no id dup
5       complete dup (geom and attribution) and id dup as well
******/
struct RawLinear * CheckLinearDuplication(struct LinearAsRead newlinear,struct RawLinear *linearslist, int * answer)
{
struct RawLinear *rlc, *retval;
int i,j, s;
struct RawLinear *IDdup, *GeomDup, *Complete;


   IDdup = GeomDup = Complete = NULL;
   rlc = linearslist;
   while(rlc != NULL)
      {
      s = NotSameString(newlinear.idn,rlc->idn);
      if(s == 0)
         IDdup = rlc;
      if(newlinear.numnodes == rlc->numnodes) /*** could be geom or cdup ***/
         {
         if((newlinear.x[0] == rlc->x[rlc->numnodes - 1]) && (newlinear.y[0] == rlc->y[rlc->numnodes - 1]) && (newlinear.z[0] == rlc->z[rlc->numnodes - 1]))
            {
            i = 0;
            for(j=rlc->numnodes - 1; j >= 0; j--)
               {
               if((newlinear.x[i] != rlc->x[j]) || (newlinear.y[i] != rlc->y[j]) || (newlinear.z[i] != rlc->z[j]))
                  break;
               ++i;
               }
            if(j < 0)
               {
               GeomDup = rlc;
               if((newlinear.Lindex == rlc->Lindex) && (Line_LongAttrsMatch(newlinear, rlc) > 0))
                  {
                  Complete = rlc;
                  rlc->badform = 2;
                  }
               }
            }
         if((newlinear.x[0] == rlc->x[0]) && (newlinear.y[0] == rlc->y[0]) && (newlinear.z[0] == rlc->z[0]))
            {
            for(j=0; j < rlc->numnodes; j++)
               {
               if((newlinear.x[j] != rlc->x[j]) || (newlinear.y[j] != rlc->y[j]) || (newlinear.z[j] != rlc->z[j]))
                  break;
               }
            if(j >= rlc->numnodes)
               {
               GeomDup = rlc;
               if((newlinear.Lindex == rlc->Lindex) && (Line_LongAttrsMatch(newlinear, rlc) > 0))
                  {
                  Complete = rlc;
                  rlc->badform = 2;
                  }
               }
            }
         }
      if(Complete != NULL) 
         break;
      rlc = rlc->next;
      }

   *answer = 0;
   retval = NULL;
   if(Complete != NULL)
      {
      if((IDdup != NULL) && (IDdup == Complete))
         *answer = 5;
      else
         *answer = 4;
      retval = Complete;
      }
   else if(IDdup != NULL)
      {
      if((GeomDup != NULL) && (GeomDup == IDdup))
         *answer = 3;
      else
         *answer = 2;
      retval = IDdup;
      }
   else if(GeomDup != NULL)
      {
      *answer = 1;
      retval = GeomDup;
      }
   return(retval);
}


int Point_LongAttrsMatch(struct PointAsRead newpoint, struct RawPoint * a1)
{
int answer = 0;

   if((a1->areastr != NULL) && (strcmp(newpoint.areastr,a1->areastr) != 0))
      return(answer);
   if((a1->hgtstr != NULL) && (strcmp(newpoint.hgtstr,a1->hgtstr) != 0))
      return(answer);
   if((a1->zv2str != NULL) && (strcmp(newpoint.zv2str,a1->zv2str) != 0))
      return(answer);
   if((a1->lenstr != NULL) && (strcmp(newpoint.lenstr,a1->lenstr) != 0))
      return(answer);
   if((a1->namstr != NULL) && (strcmp(newpoint.namstr,a1->namstr) != 0))
      return(answer);
   if(newpoint.areaattr != a1->areaattr)
      return(answer);
   if(newpoint.hgtattr != a1->hgtattr)
      return(answer);
   if(newpoint.zv2attr != a1->zv2attr)
      return(answer);
   if(newpoint.lenattr != a1->lenattr)
      return(answer);
   if(newpoint.namattr != a1->namattr)
      return(answer);

   answer = 1;
   return(answer);

}



/*****
answer	meaning
0	no duplication
1	geometric dup, no id dup
2	id dup only
3	geometric dup and id dup
4	complete dup (geom and attribution), no id dup
5	complete dup (geom and attribution) and id dup as well
******/
struct RawPoint * CheckPointDuplication(struct PointAsRead newpt, struct RawPoint *ptlist, int * answer)
{
struct RawPoint *tpc, *IDdup;
int i,j,s;
int *UsedIndex;
int matches;
int newvtxcnt, oldvtxcnt;


   tpc = ptlist;

   if(ptlist == NULL)
      *answer = 0;
   else
      {
      if(newpt.numverts < 1)
         {
         if(newpt.numverts > -4)
            newvtxcnt = 1;
         else
            newvtxcnt = 0 - newpt.numverts;
         }
      else
         newvtxcnt = newpt.numverts;
      UsedIndex = (int *) (malloc(SzI * newvtxcnt));
      while(tpc != NULL)
         {
         s = NotSameString(newpt.idn,tpc->idn);
         if(s == 0)
            IDdup = tpc;
         else
            IDdup = NULL;
         if((newpt.numverts == tpc->numverts) && (s > 0))
            {
            if(tpc->numverts < 1)
               {
               if(tpc->numverts > -4)
                  oldvtxcnt = 1;
               else
                  oldvtxcnt = 0 - tpc->numverts;
               }
            else
               oldvtxcnt = tpc->numverts;
            matches = 0;
            for(i=0; i<newvtxcnt; i++)
               UsedIndex[i] = 0;
            for(i=0; i<newvtxcnt; i++)
               {
               for(j=0; j<oldvtxcnt; j++)
                  {
                  if((newpt.x[i] == tpc->x[j]) && (newpt.y[i] == tpc->y[j]) &&
                         (newpt.z[i] == tpc->z[j]) && (newpt.h[i] == tpc->h[j]) &&
                          (UsedIndex[j] == 0))
                     {
                     ++matches;
                     UsedIndex[j] = 1;
                     break;
                     }
                  }
               if(matches <= i)
                  break;
               }
            if(matches == newvtxcnt)
               break;
            }
         else if(s == 0)
            {
            if(newpt.numverts == tpc->numverts)
               {
               if(tpc->numverts < 1)
                  {
                  if(tpc->numverts > -4)
                     oldvtxcnt = 1;
                  else
                     oldvtxcnt = 0 - tpc->numverts;
                  }
               else
                  oldvtxcnt = tpc->numverts;
               matches = 0;
               for(i=0; i<newvtxcnt; i++)
                  UsedIndex[i] = 0;
               for(i=0; i<newvtxcnt; i++)
                  {
                  for(j=0; j<oldvtxcnt; j++)
                     {
                     if((newpt.x[i] == tpc->x[j]) && (newpt.y[i] == tpc->y[j]) &&
                            (newpt.z[i] == tpc->z[j]) && (newpt.h[i] == tpc->h[j]) &&
                             (UsedIndex[j] == 0))
                        {
                        ++matches;
                        UsedIndex[j] = 1;
                        break;
                        }
                     }
                  if(matches <= i)
                     break;
                  }
               if(matches == newvtxcnt)
                  break;
               }
            else
               break;
            }
         tpc = tpc->next;
         }


      if((s == 0) && (IDdup != NULL))
         tpc = IDdup;


      if(tpc == NULL)
         {
         if(s == 0)  /** have ID duplication ***/
            {
            *answer = 2; /** 2 says only have ID duplication, no coordinate dups **/
            }
         else
            {
            *answer = 0; /** 0 says no duplication at all **/
            }
         }
      else
         {
         if(s > 0)
            {
            if((newpt.numverts == 0) || (newpt.numverts == -2))
               {
               if(newpt.rad == tpc->rad)
                  {
                  *answer = 1; /** 1 implies geometric duplication, no ID duplication **/
                  if((newpt.Lindex == tpc->Lindex) && (Point_LongAttrsMatch(newpt, tpc) > 0))
                     *answer = 4; /** 4 implies a complete duplication of attributes too, but no ID duplication **/
                  }
               else
                  *answer = 0; /** 0 says not any kind of duplicate ***/
               }
            else
               {
               *answer = 1; /** 1 implies geometric duplication, but NO ID duplication **/
               if((newpt.Lindex == tpc->Lindex) && (Point_LongAttrsMatch(newpt, tpc) > 0))
                  *answer = 4; /** 4 implies a complete duplication of attributes too, but NO ID duplication **/
               }
            }
         else /* s == 0 so have a ID duplication situation ***/
            {
            if((newpt.numverts == 0) || (newpt.numverts == -2))
               {
               if(newpt.rad == tpc->rad)
                  {
                  *answer = 3; /** 3 implies geometric duplication with ID duplication **/
                  if((newpt.Lindex == tpc->Lindex) && (Point_LongAttrsMatch(newpt, tpc) > 0))
                     *answer = 5; /** 5 implies a complete duplication of attributes too (with ID duplication) **/
                  }
               else
                  *answer = 2; /** 2 says only have ID duplication, no coordinate dups **/
               }
            else if(matches == newvtxcnt)
               {
               *answer = 3; /** 3 implies geometric duplication with ID duplication **/
               if((newpt.Lindex == tpc->Lindex) && (Point_LongAttrsMatch(newpt, tpc) > 0))
                  *answer = 5; /** 5 implies a complete duplication of attributes too (with ID duplication) **/
               }
            else
               *answer = 2; /** 2 says only have ID duplication, no coordinate dups **/
            }
         }
      free(UsedIndex);
      }
   return(tpc);
}






struct RawBridge * CheckBridgeDuplication(struct BridgeAsRead newbridge, struct RawBridge *bridgelist, int * answer)
{
struct RawBridge *tpc;
int i,j;
int *UsedIndex;
int matches;


   tpc = bridgelist;

   if((bridgelist == NULL) || (newbridge.numverts < 1))
      *answer = 0;
   else
      {
      UsedIndex = (int *) (malloc(SzI * newbridge.numverts));
      tpc = bridgelist;
      while(tpc != NULL)
         {
         if(newbridge.numverts == tpc->numverts)
            {
            matches = 0;
            for(i=0; i<newbridge.numverts; i++)
               UsedIndex[i] = 0;
            for(i=0; i<newbridge.numverts; i++)
               {
               for(j=0; j<tpc->numverts; j++)
                  {
                  if((newbridge.x[i] == tpc->x[j]) && (newbridge.y[i] == tpc->y[j]) &&
                         (newbridge.z[i] == tpc->z[j]) && (UsedIndex[j] == 0))
                     {
                     ++matches;
                     UsedIndex[j] = 1;
                     break;
                     }
                  }
               if(matches <= i)
                  break;
               }
            if(matches == newbridge.numverts)
               break;
            }
         tpc = tpc->next;
         }
      if(tpc == NULL)
         *answer = 0; /** 0 says no duplication at all **/
      else
         {
         *answer = 1; /** 1 implies geometric duplication **/
         if((newbridge.Lindex == tpc->Lindex) && (newbridge.Sindex == tpc->Sindex))
            *answer = 4; /** 2 implies a complete duplication of attributes too **/
         }
      free(UsedIndex);
      }
   return(tpc);
}





int CombinedCheckApplies(int IDlookupkey, int Instance, int TgtCheckType, int LongListIndx, int ShortListIndx,
                         int config, int stratum, int domain, int *p1, int *p2, int *p3)
{
  int answer,checknum, startindex, stopindex;
 
  answer = 0;
  *p1 = 0;
  *p2 = 0;
  *p3 = 0;


  if(Instance < 0)
    {
      startindex = 0;
      stopindex = TtlActiveChecks;
    }
  else
    {
      startindex = Instance;
      stopindex = Instance + 1;
    }



  for(checknum = startindex; checknum < stopindex; checknum++)
    {
      if(
	 (ActiveChecks[checknum].active == 1) && 
	 ((TgtCheckType < 0) || (ActiveChecks[checknum].number == TgtCheckType))
	 )
	{
	  
	  *p1 = 0;
	  *p2 = 0;
	  *p3 = 0;
	  answer = 0;
	  
	  if(ActiveChecks[checknum].participants >= 1)
            {
	      if((ActiveChecks[checknum].Config1[config] == 1) &&
		 (ActiveChecks[checknum].Domain1[domain] == 1) &&
		 (ActiveChecks[checknum].Stratum1[stratum] == 1))
		{
		  *p1 = 1;
		  answer = 1;
		}
	      
	      if(ActiveChecks[checknum].primaryEDCSstuff != NULL)
		{
		  if(ActiveChecks[checknum].primaryEDCSstuff[LongListIndx] == 1) /** add as primary for this check **/
		    {
		      if(ActiveChecks[checknum].Config1[config] == 2)
			{
			  printf("1:fatal problem with classification geometry combination (primary)\n");
			  exit(-1);
			}
		      *p1 = 1;
		      answer = 1;
		    }
		}

	      if(ActiveChecks[checknum].primaryFIDstuff != NULL)
		{
		  if(ActiveChecks[checknum].primaryFIDstuff[IDlookupkey] == 1) /** add as primary for this check **/
		    {
		      if(ActiveChecks[checknum].Config1[config] == 2)
			{
			  printf("2:fatal problem with classification geometry combination (primary)\n");
			  exit(-1);
			}
		      *p1 = 1;
		      answer = 1;
		    }
		}
	      
	      
	      if(ActiveChecks[checknum].primaryEDCSstuff != NULL)
		{
		  if(ActiveChecks[checknum].primaryEDCSstuff[LongListIndx] == 2) /** exclude as primary for this check **/
		    {
		      if(ActiveChecks[checknum].Config1[config] == 2)
			{
			  printf("3:fatal problem with classification geometry combination (primary)\n");
			  exit(-1);
			}
		      *p1 = 0;
		    }
		}

	      if(ActiveChecks[checknum].primaryFIDstuff != NULL)
		{
		  if(ActiveChecks[checknum].primaryFIDstuff[IDlookupkey] == 2) /** exclude as primary for this check **/
		    {
		      if(ActiveChecks[checknum].Config1[config] == 2)
			{
			  printf("4:fatal problem with classification geometry combination (primary)\n");
			  exit(-1);
			}
		      *p1 = 0;
		    }
		}

            }  /*** end >=1 participant check ***/
	  


	  if(ActiveChecks[checknum].participants >= 2)
            {
	      if((ActiveChecks[checknum].Config2[config] == 1) &&
		 (ActiveChecks[checknum].Domain2[domain] == 1) &&
		 (ActiveChecks[checknum].Stratum2[stratum] == 1))
		{
		  *p2 = 1;
		  answer = 1;
		}
	      
	      if(ActiveChecks[checknum].secondaryEDCSstuff != NULL)
		{
		  if(ActiveChecks[checknum].secondaryEDCSstuff[LongListIndx] == 1) /** add as secondary for this check **/
		    {
		      if(ActiveChecks[checknum].Config2[config] == 2)
			{
			  printf("fatal problem with classification geometry combination (secondary)\n");
			  exit(-1);
			}
		      *p2 = 1;
		      answer = 1;
		    }
		}

	      if(ActiveChecks[checknum].secondaryFIDstuff != NULL)
		{
		  if(ActiveChecks[checknum].secondaryFIDstuff[IDlookupkey] == 1) /** add as secondary for this check **/
		    {
		      if(ActiveChecks[checknum].Config2[config] == 2)
			{
			  printf("fatal problem with classification geometry combination (secondary)\n");
			  exit(-1);
			}
		      *p2 = 1;
		      answer = 1;
		    }
		}
	      


	      if(ActiveChecks[checknum].secondaryEDCSstuff != NULL)
		{
		  if(ActiveChecks[checknum].secondaryEDCSstuff[LongListIndx] == 2) /** exclude as secondary for this check **/
		    {
		      if(ActiveChecks[checknum].Config2[config] == 2)
			{
			  printf("fatal problem with classification geometry combination (secondary)\n");
			  exit(-1);
			}
		      *p2 = 0;
		    }
		}

	      if(ActiveChecks[checknum].secondaryFIDstuff != NULL)
		{
		  if(ActiveChecks[checknum].secondaryFIDstuff[IDlookupkey] == 2) /** exclude as secondary for this check **/
		    {
		      if(ActiveChecks[checknum].Config2[config] == 2)
			{
			  printf("fatal problem with classification geometry combination (secondary)\n");
			  exit(-1);
			}
		      *p2 = 0;
		    }
		}


            }  /*** end >=2 participant check ***/

	  
	  
	  if(ActiveChecks[checknum].participants >= 3)
            {
	      if((ActiveChecks[checknum].Config3[config] == 1) &&
		 (ActiveChecks[checknum].Domain3[domain] == 1) &&
		 (ActiveChecks[checknum].Stratum3[stratum] == 1))
		{
		  *p3 = 1;
		  answer = 1;
		}
	      
	      if(ActiveChecks[checknum].tertiaryEDCSstuff != NULL)
		{
		  if(ActiveChecks[checknum].tertiaryEDCSstuff[LongListIndx] == 1) /** add as tertiary for this check **/
		    {
		      if(ActiveChecks[checknum].Config3[config] == 2)
			{
			  printf("fatal problem with classification geometry combination (tertiary)\n");
			  exit(-1);
			}
		      *p3 = 1;
		      answer = 1;
		    }
		}

	      if(ActiveChecks[checknum].tertiaryFIDstuff != NULL)
		{
		  if(ActiveChecks[checknum].tertiaryFIDstuff[IDlookupkey] == 1) /** add as tertiary for this check **/
		    {
		      if(ActiveChecks[checknum].Config3[config] == 2)
			{
			  printf("fatal problem with classification geometry combination (tertiary)\n");
			  exit(-1);
			}
		      *p3 = 1;
		      answer = 1;
		    }
		}


	      
	      if(ActiveChecks[checknum].tertiaryEDCSstuff != NULL)
		{
		  if(ActiveChecks[checknum].tertiaryEDCSstuff[LongListIndx] == 2) /** exclude as tertiary for this check **/
		    {
		      if(ActiveChecks[checknum].Config3[config] == 2)
			{
			  printf("fatal problem with classification geometry combination (tertiary)\n");
			  exit(-1);
			}
		      *p3 = 0;
		    }
		}

	      if(ActiveChecks[checknum].tertiaryFIDstuff != NULL)
		{
		  if(ActiveChecks[checknum].tertiaryFIDstuff[IDlookupkey] == 2) /** exclude as tertiary for this check **/
		    {
		      if(ActiveChecks[checknum].Config3[config] == 2)
			{
			  printf("fatal problem with classification geometry combination (tertiary)\n");
			  exit(-1);
			}
		      *p3 = 0;
		    }
		}

            }  /*** end >=3 participant check ***/
	  



	} /*** end checknum is active and == TgtCheckType ****/
      if((Instance < 0) && (TgtCheckType < 0) && (answer > 0))
	break;
    } /*** end for checknum ... ***/
  
  return(answer);
}








int EdgeSliverCheckOK(struct ListOfEdges *newedge, struct ListOfEdges *edgeroot, int edgenumb)
{
struct ListOfEdges *lpec;
int answer = 1;
int edgesfound = 0;

   lpec = edgeroot;
   while((lpec != NULL) && (edgesfound < edgenumb))
      {
      if(lpec->owner == newedge->owner)
         {
         if((lpec->x1 == newedge->x1) && (lpec->y1 == newedge->y1) &&
            (lpec->x2 == newedge->x2) && (lpec->y2 == newedge->y2))
            {
            answer = 0;
            break;
            }
         else if((lpec->x1 == newedge->x2) && (lpec->y1 == newedge->y2) &&
            (lpec->x2 == newedge->x1) && (lpec->y2 == newedge->y1))
            {
            answer = 0;
            break;
            }
         ++edgesfound;
         }
      lpec = lpec->next;
      }
   return(answer);
}




int PointOnPolyEdge(double px, double py, struct ListOfEdges *e)
{
int answer;
double temp;
   
   answer = 0;

   if((e->minx <= px) && (px <= e->maxx) && (e->miny <= py) && (py <= e->maxy))
      {
      if((px == e->x1) && (py == e->y1))
         {
         answer = 2;
         }
      else if((px == e->x2) && (py == e->y2))
         {
         answer = 3;
         }
      else if((e->rise == 0) || (e->run == 0))
         {
         answer = 1;
         }
      else
         {
         temp = (e->slope * px) + e->Bval - py;
         if((temp > -0.00001) && (temp < 0.00001))
              answer = 1;
         }
      }
   return(answer);
}


int ReMatchWithVerticals(struct ListOfEdges *e1, struct ListOfEdges *Ve, int matchtype)
{
int answer = 0;
int OnLine[4];
int i;

double tempZ;
double zdiff1, zdiff2, matchlen;
struct ListOfEdges *e2;

   matchlen = 0.0;
   e2 = Ve;
   while(e2 != NULL)
      {
      OnLine[0] = PointOnPolyEdge(e1->x1,e1->y1,e2);
      OnLine[1] = PointOnPolyEdge(e1->x2,e1->y2,e2);
      OnLine[2] = PointOnPolyEdge(e2->x1,e2->y1,e1);
      OnLine[3] = PointOnPolyEdge(e2->x2,e2->y2,e1);
   
      i = 0;
      if(OnLine[0] > 0)
         ++i;
      if(OnLine[1] > 0)
         ++i;
      if(OnLine[2] > 0)
         ++i;
      if(OnLine[3] > 0)
         ++i;
   
      if((matchtype >= 12) && (matchtype <= 13) && (i == 2))
         {
         answer = 1;
         }
      else if(i <= 1)
         {
         answer = 0;
         }
      else if(i == 4) 
         {
         answer = 1;
         if(OnLine[0] == 2) /** (e1->x1,e1->y1) == (e2->x1,e2->y1) **/
            zdiff1 = fabs(e1->z1 - e2->z1);
         else
            zdiff1 = fabs(e1->z1 - e2->z2);
         if(OnLine[1] == 2) /** then (e1->x2,e1->y2) == (e2->x1,e2->y1) **/
            zdiff2 = fabs(e1->z2 - e2->z1);
         else
            zdiff2 = fabs(e1->z2 - e2->z2);
         if((zdiff1 < 0.00001) && (zdiff2 < 0.00001))
            matchlen += e1->length;
         }
      else if(i == 3)
         {
         if(OnLine[0] == 0) /** then either 3 or 4 should be a T **/
            {
            if(OnLine[1] == 2) /** so that (e1->x2 == e2->x1) && (e1->y2 == e2->y1)**/
               {
               answer = 2; /** indicates pt (e2->x2,e2->y2) is a 'T' **/
               zdiff1 = fabs(e1->z2 - e2->z1);
               tempZ = InterpLinearElev(e1->x1,e1->y1,e1->z1,e1->x2,e1->y2,e1->z2,e2->x2,e2->y2);
               zdiff2 = fabs(tempZ - e2->z2);
               }
            else if(OnLine[1] == 3) /** so that (e1->x2 == e2->x2) && (e1->y2 == e2->y2)**/
               {
               answer = 3; /** indicates pt (e2->x1,e2->y1) is a 'T' **/
               zdiff1 = fabs(e1->z2 - e2->z2);
               tempZ = InterpLinearElev(e1->x1,e1->y1,e1->z1,e1->x2,e1->y2,e1->z2,e2->x1,e2->y1);
               zdiff2 = fabs(tempZ - e2->z1);
               }
            if((zdiff1 < 0.00001) && (zdiff2 < 0.00001))
               matchlen += e2->length;
            }
         else if(OnLine[1] == 0) /** again, either 3 or 4 should be a T **/
            {
            if(OnLine[0] == 2) /** so that (e1->x1 == e2->x1) && (e1->y1 == e2->y1) **/
               {
               answer = 2; /** indicates pt (e2->x2,e2->y2) is a 'T' **/
               zdiff1 = fabs(e1->z1 - e2->z1);
               tempZ = InterpLinearElev(e1->x1,e1->y1,e1->z1,e1->x2,e1->y2,e1->z2,e2->x2,e2->y2);
               zdiff2 = fabs(tempZ - e2->z2);
               }
            else if(OnLine[0] == 3) /** so that (e1->x1 == e2->x2) && (e1->y1 == e2->y2) **/
               {
               answer = 3; /** indicates pt (e2->x1,e2->y1) is a 'T' **/
               zdiff1 = fabs(e1->z1 - e2->z2);
               tempZ = InterpLinearElev(e1->x1,e1->y1,e1->z1,e1->x2,e1->y2,e1->z2,e2->x1,e2->y1);
               zdiff2 = fabs(tempZ - e2->z1);
               }
            if((zdiff1 < 0.00001) && (zdiff2 < 0.00001))
               matchlen += e2->length;
            }
         else if(OnLine[2] == 0) /** then either 1 or 2 should be a T **/
            {
            if(OnLine[3] == 3) /** so that (e2->x2 == e1->x2) && (e2->y2 == e1->y2) **/
               {
               answer = 4; /** indicates pt (e1->x1,e1->y1) is a 'T' **/
               zdiff1 = fabs(e1->z2 - e2->z2);
               tempZ = InterpLinearElev(e2->x1,e2->y1,e2->z1,e2->x2,e2->y2,e2->z2,e1->x1,e1->y1);
               zdiff2 = fabs(tempZ - e1->z1);
               }
            else if(OnLine[3] == 2) /** so that (e2->x2 == e1->x1) && (e2->y2 == e1->y1) **/
               {
               answer = 5; /** indicates pt (e1->x2,e1->y2) is a 'T' **/
               zdiff1 = fabs(e1->z1 - e2->z2);
               tempZ = InterpLinearElev(e2->x1,e2->y1,e2->z1,e2->x2,e2->y2,e2->z2,e1->x2,e1->y2);
               zdiff2 = fabs(tempZ - e1->z2);
               }
            if((zdiff1 < 0.00001) && (zdiff2 < 0.00001))
               matchlen += e1->length;
            }
         else if(OnLine[3] == 0) /** again, either 1 or 2 should be a T **/
            {
            if(OnLine[2] == 3) /** so that (e2->x1 == e1->x2) && (e2->y1 == e1->y2) **/
               {
               answer = 4; /** indicates pt (e1->x1,e1->y1) is a 'T' **/
               zdiff1 = fabs(e1->z2 - e2->z1);
               tempZ = InterpLinearElev(e2->x1,e2->y1,e2->z1,e2->x2,e2->y2,e2->z2,e1->x1,e1->y1);
               zdiff2 = fabs(tempZ - e1->z1);
               }
            else if(OnLine[2] == 2) /** so that (e2->x1 == e1->x1) && (e2->y1 == e1->y1) **/
               {
               answer = 5; /** indicates pt (e1->x2,e1->y2) is a 'T' **/
               zdiff1 = fabs(e1->z1 - e2->z1);
               tempZ = InterpLinearElev(e2->x1,e2->y1,e2->z1,e2->x2,e2->y2,e2->z2,e1->x2,e1->y2);
               zdiff2 = fabs(tempZ - e1->z2);
               }
            if((zdiff1 < 0.00001) && (zdiff2 < 0.00001))
               matchlen += e1->length;
            }
         }
      else if(i == 2) 
         {
         if(OnLine[0] == 1) /** then pt (e1->x1,e1->y1) could be a 'T' ***/
            {
            tempZ = InterpLinearElev(e2->x1,e2->y1,e2->z1,e2->x2,e2->y2,e2->z2,e1->x1,e1->y1);
            zdiff1 = fabs(e1->z1 - tempZ);
            if(zdiff1 < 0.00001)
               {
               if(OnLine[1] == 1) /** then pt (e1->x2,e1->y2) is a 'T' ***/
                  {
                  answer = 6;
                  tempZ = InterpLinearElev(e2->x1,e2->y1,e2->z1,e2->x2,e2->y2,e2->z2,e1->x2,e1->y2);
                  zdiff2 = fabs(e1->z2 - tempZ);
                  if(zdiff2 < 0.00001)
                     matchlen += e1->length;
                  }
               else if(OnLine[2] == 1) /** then pt (e2->x1,e2->y1) could be a 'T' ***/
                  {
                  if(OnLine[0] == 2) /** so that (e1->x1 == e2->x1) && (e1->y1 == e2->y1) ***/
                     answer = 0;
                  else
                     {
                     answer = 7;
                     tempZ = InterpLinearElev(e1->x1,e1->y1,e1->z1,e1->x2,e1->y2,e1->z2,e2->x1,e2->y1);
                     zdiff2 = fabs(e2->z1 - tempZ);
                     if(zdiff2 < 0.00001)
                        matchlen += Distance(e1->x1,e1->y1,e2->x1,e2->y1);
                     }
                  }
               else if(OnLine[3] == 1) /** then pt (e2->x2,e2->y2) could be a 'T' ***/
                  {
                  if(OnLine[0] == 3) /** so that (e1->x1 == e2->x2) && (e1->y1 == e2->y2))**/
                     answer = 0;
                  else
                     {
                     answer = 8;
                     tempZ = InterpLinearElev(e1->x1,e1->y1,e1->z1,e1->x2,e1->y2,e1->z2,e2->x2,e2->y2);
                     zdiff2 = fabs(e2->z2 - tempZ);
                     if(zdiff2 < 0.00001)
                        matchlen += Distance(e1->x1,e1->y1,e2->x2,e2->y2);
                     }
                  }
               }
            }
         else if(OnLine[1] == 1)  /** then pt (e1->x2,e1->y2) could be a 'T' ***/
            {
            tempZ = InterpLinearElev(e2->x1,e2->y1,e2->z1,e2->x2,e2->y2,e2->z2,e1->x2,e1->y2);
            zdiff1 = fabs(e1->z2 - tempZ);
            if(zdiff1 < 0.00001)
               {
               if(OnLine[2] == 1) /** then pt (e2->x1,e2->y1) could be a 'T' ***/
                  {
                  if(OnLine[1] == 2) /** so that (e1->x2 == e2->x1) && (e1->y2 == e2->y1)) **/
                     answer = 0;
                  else
                     {
                     answer = 9;
                     tempZ = InterpLinearElev(e1->x1,e1->y1,e1->z1,e1->x2,e1->y2,e1->z2,e2->x1,e2->y1);
                     zdiff2 = fabs(e2->z1 - tempZ);
                     if(zdiff2 < 0.00001)
                        matchlen += Distance(e1->x2,e1->y2,e2->x1,e2->y1);
                     }
                  }
               else if(OnLine[3] == 1) /** then pt (e2->x2,e2->y2) could be a 'T' ***/
                  {
                  if(OnLine[1] == 3) /** so that (e1->x2 == e2->x2) && (e1->y2 == e2->y2)) **/
                     answer = 0;
                  else
                     {
                     answer = 10;
                     tempZ = InterpLinearElev(e1->x1,e1->y1,e1->z1,e1->x2,e1->y2,e1->z2,e2->x2,e2->y2);
                     zdiff2 = fabs(e2->z2 - tempZ);
                     if(zdiff2 < 0.00001)
                        matchlen += Distance(e1->x2,e1->y2,e2->x2,e2->y2);
                     }
                  }
               }
            }
         else if(OnLine[2] == 1) /** then pt (e2->x1,e2->y1) is a 'T' ***/
            {
            if(OnLine[3] == 1) /** then pt (e2->x2,e2->y2) is a 'T' ***/
               {
               answer = 11;
               tempZ = InterpLinearElev(e1->x1,e1->y1,e1->z1,e1->x2,e1->y2,e1->z2,e2->x1,e2->y1);
               zdiff1 = fabs(e2->z1 - tempZ);
               tempZ = InterpLinearElev(e1->x1,e1->y1,e1->z1,e1->x2,e1->y2,e1->z2,e2->x2,e2->y2);
               zdiff1 = fabs(e2->z2 - tempZ);
               if((zdiff1 < 0.00001) && (zdiff2 < 0.00001))
                  matchlen += e2->length;
               }
            }
         }
      e2 = e2->next;
      }
   if(matchtype < 12)
      {
      tempZ = fabs(e1->length - matchlen);
      if(tempZ < 0.00001)
         answer = 1;
      else
         answer = 0;
      }

   return(answer);
}






int MatchPolyEdge2D(struct ListOfEdges *e1, struct ListOfEdges *e2,double *matchlen,
                double *zdiff1, double *xz1, double *yz1,
                double *zdiff2, double *xz2, double *yz2)
{
int answer = 0;
int OnLine[4];
int i;

double tempZ;

   for(i=0; i<4; i++)
      OnLine[i] = 0;

   OnLine[0] = PointOnPolyEdge(e1->x1,e1->y1,e2);
   OnLine[1] = PointOnPolyEdge(e1->x2,e1->y2,e2);
   OnLine[2] = PointOnPolyEdge(e2->x1,e2->y1,e1);
   OnLine[3] = PointOnPolyEdge(e2->x2,e2->y2,e1);

   i = 0;
   if(OnLine[0] > 0)
      ++i;
   if(OnLine[1] > 0)
      ++i;
   if(OnLine[2] > 0)
      ++i;
   if(OnLine[3] > 0)
      ++i;

   if(i < 1) 
      {
      answer = 0;
      }
   else if (i == 1) /** a classic 'T' - only a vertex of one edge touches other edge **/
      {
      *matchlen = 0;
      if(OnLine[0] == 1) /** then vertex e1->x1,e1->y1 touches interior of edge e2 **/
         {
         *matchlen = 0;
         tempZ = InterpLinearElev(e2->x1,e2->y1,e2->z1,e2->x2,e2->y2,e2->z2,e1->x1,e1->y1);
         *zdiff1 = *zdiff2 = fabs(e1->z1 - tempZ);
         *xz1 = *xz2 = e1->x1;
         *yz1 = *yz2 = e1->y1;
         }
      else if(OnLine[1] == 1) /** then vertex e1->x2,e1->y2 touches interior of edge e2 **/
         {
         *matchlen = 0;
         tempZ = InterpLinearElev(e2->x1,e2->y1,e2->z1,e2->x2,e2->y2,e2->z2,e1->x2,e1->y2);
         *zdiff1 = *zdiff2 = fabs(e1->z2 - tempZ);
         *xz1 = *xz2 = e1->x2;
         *yz1 = *yz2 = e1->y2;
         }
      else if(OnLine[2] == 1) /** then vertex e2->x1,e2->y1 touches interior of edge e1 **/
         {
         *matchlen = 0;
         tempZ = InterpLinearElev(e1->x1,e1->y1,e1->z1,e1->x2,e1->y2,e1->z2,e2->x1,e2->y1);
         *zdiff1 = *zdiff2 = fabs(e2->z1 - tempZ);
         *xz1 = *xz2 = e2->x1;
         *yz1 = *yz2 = e2->y1;
         }
      else if(OnLine[3] == 1) /** then vertex e2->x2,e2->y2 touches interior of edge e1 **/
         {
         *matchlen = 0;
         tempZ = InterpLinearElev(e1->x1,e1->y1,e1->z1,e1->x2,e1->y2,e1->z2,e2->x2,e2->y2);
         *zdiff1 = *zdiff2 = fabs(e2->z2 - tempZ);
         *xz1 = *xz2 = e2->x2;
         *yz1 = *yz2 = e2->y2;
         }
      if(*zdiff1 < 0.001)
         {
         *zdiff1 = *zdiff2 = 0.0;
         answer = 0;
         }
      else
         answer = 12;
      }
   else if(i == 4)
      {
      answer = 1;
      *matchlen = e1->length;
      *xz1 = e1->x1;
      *yz1 = e1->y1;
      *xz2 = e1->x2;
      *yz2 = e1->y2;
      if(OnLine[0] == 2) /** (e1->x1,e1->y1) == (e2->x1,e2->y1) **/
         *zdiff1 = fabs(e1->z1 - e2->z1);
      else
         *zdiff1 = fabs(e1->z1 - e2->z2);
      if(OnLine[1] == 2) /** then (e1->x2,e1->y2) == (e2->x1,e2->y1) **/
         *zdiff2 = fabs(e1->z2 - e2->z1);
      else
         *zdiff2 = fabs(e1->z2 - e2->z2);
      }
   else if(i == 3) 
      {
      if(OnLine[0] == 0) /** then either 3 or 4 should be a T **/
         {
         *matchlen = e2->length;
         if(OnLine[1] == 2) /** so that (e1->x2 == e2->x1) && (e1->y2 == e2->y1)**/
            {
            *xz1 = e1->x2;
            *yz1 = e1->y2;
            *xz2 = e2->x2;
            *yz2 = e2->y2;
            answer = 2; /** indicates pt (e2->x2,e2->y2) is a 'T' **/
            *zdiff1 = fabs(e1->z2 - e2->z1);
            tempZ = InterpLinearElev(e1->x1,e1->y1,e1->z1,e1->x2,e1->y2,e1->z2,e2->x2,e2->y2);
            *zdiff2 = fabs(tempZ - e2->z2);
            }
         else if(OnLine[1] == 3) /** so that (e1->x2 == e2->x2) && (e1->y2 == e2->y2)**/
            {
            *xz1 = e1->x2;
            *yz1 = e1->y2;
            *xz2 = e2->x1;
            *yz2 = e2->y1;
            answer = 3; /** indicates pt (e2->x1,e2->y1) is a 'T' **/
            *zdiff1 = fabs(e1->z2 - e2->z2);
            tempZ = InterpLinearElev(e1->x1,e1->y1,e1->z1,e1->x2,e1->y2,e1->z2,e2->x1,e2->y1);
            *zdiff2 = fabs(tempZ - e2->z1);
            }
         }
      else if(OnLine[1] == 0) /** again, either 3 or 4 should be a T **/
         {
         *matchlen = e2->length;
         if(OnLine[0] == 2) /** so that (e1->x1 == e2->x1) && (e1->y1 == e2->y1) **/
            {
            *xz1 = e1->x1;
            *yz1 = e1->y1;
            *xz2 = e2->x2;
            *yz2 = e2->y2;
            answer = 2; /** indicates pt (e2->x2,e2->y2) is a 'T' **/
            *zdiff1 = fabs(e1->z1 - e2->z1);
            tempZ = InterpLinearElev(e1->x1,e1->y1,e1->z1,e1->x2,e1->y2,e1->z2,e2->x2,e2->y2);
            *zdiff2 = fabs(tempZ - e2->z2);
            }
         else if(OnLine[0] == 3) /** so that (e1->x1 == e2->x2) && (e1->y1 == e2->y2) **/
            {
            *xz1 = e1->x1;
            *yz1 = e1->y1;
            *xz2 = e2->x1;
            *yz2 = e2->y1;
            answer = 3; /** indicates pt (e2->x1,e2->y1) is a 'T' **/
            *zdiff1 = fabs(e1->z1 - e2->z2);
            tempZ = InterpLinearElev(e1->x1,e1->y1,e1->z1,e1->x2,e1->y2,e1->z2,e2->x1,e2->y1);
            *zdiff2 = fabs(tempZ - e2->z1);
            }
         }
      else if(OnLine[2] == 0) /** then either 1 or 2 should be a T **/
         {
         *matchlen = e1->length;
         if(OnLine[3] == 3) /** so that (e2->x2 == e1->x2) && (e2->y2 == e1->y2) **/
            {
            *xz1 = e1->x2;
            *yz1 = e1->y2;
            *xz2 = e1->x1;
            *yz2 = e1->y1;
            answer = 4; /** indicates pt (e1->x1,e1->y1) is a 'T' **/
            *zdiff1 = fabs(e1->z2 - e2->z2);
            tempZ = InterpLinearElev(e2->x1,e2->y1,e2->z1,e2->x2,e2->y2,e2->z2,e1->x1,e1->y1);
            *zdiff2 = fabs(tempZ - e1->z1);
            }
         else if(OnLine[3] == 2) /** so that (e2->x2 == e1->x1) && (e2->y2 == e1->y1) **/
            {
            *xz1 = e1->x1;
            *yz1 = e1->y1;
            *xz2 = e1->x2;
            *yz2 = e1->y2;
            answer = 5; /** indicates pt (e1->x2,e1->y2) is a 'T' **/
            *zdiff1 = fabs(e1->z1 - e2->z2);
            tempZ = InterpLinearElev(e2->x1,e2->y1,e2->z1,e2->x2,e2->y2,e2->z2,e1->x2,e1->y2);
            *zdiff2 = fabs(tempZ - e1->z2);
            }
         }
      else if(OnLine[3] == 0) /** again, either 1 or 2 should be a T **/
         {
         *matchlen = e1->length;
         if(OnLine[2] == 3) /** so that (e2->x1 == e1->x2) && (e2->y1 == e1->y2) **/
            {
            *xz1 = e1->x2;
            *yz1 = e1->y2;
            *xz2 = e1->x1;
            *yz2 = e1->y1;
            answer = 4; /** indicates pt (e1->x1,e1->y1) is a 'T' **/
            *zdiff1 = fabs(e1->z2 - e2->z1);
            tempZ = InterpLinearElev(e2->x1,e2->y1,e2->z1,e2->x2,e2->y2,e2->z2,e1->x1,e1->y1);
            *zdiff2 = fabs(tempZ - e1->z1);
            }
         else if(OnLine[2] == 2) /** so that (e2->x1 == e1->x1) && (e2->y1 == e1->y1) **/
            {
            *xz1 = e1->x1;
            *yz1 = e1->y1;
            *xz2 = e1->x2;
            *yz2 = e1->y2;
            answer = 5; /** indicates pt (e1->x2,e1->y2) is a 'T' **/
            *zdiff1 = fabs(e1->z1 - e2->z1);
            tempZ = InterpLinearElev(e2->x1,e2->y1,e2->z1,e2->x2,e2->y2,e2->z2,e1->x2,e1->y2);
            *zdiff2 = fabs(tempZ - e1->z2);
            }
         }
      }
   else if(i == 2) 
      {
      if(OnLine[0] == 1) /** then pt (e1->x1,e1->y1) could be a 'T' ***/
         {
         tempZ = InterpLinearElev(e2->x1,e2->y1,e2->z1,e2->x2,e2->y2,e2->z2,e1->x1,e1->y1);
         *zdiff1 = fabs(e1->z1 - tempZ);
         *xz1 = e1->x1;
         *yz1 = e1->y1;
         if(OnLine[1] == 1) /** then pt (e1->x2,e1->y2) is a 'T' ***/
            {
            answer = 6;
            *matchlen = e1->length;
            tempZ = InterpLinearElev(e2->x1,e2->y1,e2->z1,e2->x2,e2->y2,e2->z2,e1->x2,e1->y2);
            *zdiff2 = fabs(e1->z2 - tempZ);
            *xz2 = e1->x2;
            *yz2 = e1->y2;
            }
         else if(OnLine[2] == 1) /** then pt (e2->x1,e2->y1) could be a 'T' ***/
            {
            if(OnLine[0] == 2) /** so that (e1->x1 == e2->x1) && (e1->y1 == e2->y1) ***/
               answer = 0;
            else
               {
               answer = 7;
               *matchlen = Distance(e1->x1,e1->y1,e2->x1,e2->y1);
               if(*matchlen > e1->length)
                  *matchlen = e1->length;
               if(*matchlen > e2->length)
                  *matchlen = e2->length;
               tempZ = InterpLinearElev(e1->x1,e1->y1,e1->z1,e1->x2,e1->y2,e1->z2,e2->x1,e2->y1);
               *zdiff2 = fabs(e2->z1 - tempZ);
               *xz2 = e2->x1;
               *yz2 = e2->y1;
               }
            }
         else if(OnLine[3] == 1) /** then pt (e2->x2,e2->y2) could be a 'T' ***/
            {
            if(OnLine[0] == 3) /** so that (e1->x1 == e2->x2) && (e1->y1 == e2->y2))**/
               answer = 0;
            else
               {
               answer = 8;
               *matchlen = Distance(e1->x1,e1->y1,e2->x2,e2->y2);
               if(*matchlen > e1->length)
                  *matchlen = e1->length;
               if(*matchlen > e2->length)
                  *matchlen = e2->length;
               tempZ = InterpLinearElev(e1->x1,e1->y1,e1->z1,e1->x2,e1->y2,e1->z2,e2->x2,e2->y2);
               *zdiff2 = fabs(e2->z2 - tempZ);
               *xz2 = e2->x2;
               *yz2 = e2->y2;
               }
            }
         }
      else if(OnLine[1] == 1)  /** then pt (e1->x2,e1->y2) could be a 'T' ***/
         {
         tempZ = InterpLinearElev(e2->x1,e2->y1,e2->z1,e2->x2,e2->y2,e2->z2,e1->x2,e1->y2);
         *zdiff1 = fabs(e1->z2 - tempZ);
         *xz1 = e1->x2;
         *yz1 = e1->y2;
         if(OnLine[2] == 1) /** then pt (e2->x1,e2->y1) could be a 'T' ***/
            {
            if(OnLine[1] == 2) /** so that (e1->x2 == e2->x1) && (e1->y2 == e2->y1)) **/
               answer = 0;
            else
               {
               answer = 9;
               *matchlen = Distance(e1->x2,e1->y2,e2->x1,e2->y1);
               if(*matchlen > e1->length)
                  *matchlen = e1->length;
               if(*matchlen > e2->length)
                  *matchlen = e2->length;
               tempZ = InterpLinearElev(e1->x1,e1->y1,e1->z1,e1->x2,e1->y2,e1->z2,e2->x1,e2->y1);
               *zdiff2 = fabs(e2->z1 - tempZ);
               *xz2 = e2->x1;
               *yz2 = e2->y1;
               }
            }
         else if(OnLine[3] == 1) /** then pt (e2->x2,e2->y2) could be a 'T' ***/
            {
            if(OnLine[1] == 3) /** so that (e1->x2 == e2->x2) && (e1->y2 == e2->y2)) **/
               answer = 0;
            else
               {
               answer = 10;
               *matchlen = Distance(e1->x2,e1->y2,e2->x2,e2->y2);
               if(*matchlen > e1->length)
                  *matchlen = e1->length;
               if(*matchlen > e2->length)
                  *matchlen = e2->length;
               tempZ = InterpLinearElev(e1->x1,e1->y1,e1->z1,e1->x2,e1->y2,e1->z2,e2->x2,e2->y2);
               *zdiff2 = fabs(e2->z2 - tempZ);
               *xz2 = e2->x2;
               *yz2 = e2->y2;
               }
            }
         }
      else if(OnLine[2] == 1) /** then pt (e2->x1,e2->y1) is a 'T' ***/
         {
         if(OnLine[3] == 1) /** then pt (e2->x2,e2->y2) is a 'T' ***/
            {
            *xz1 = e2->x1;
            *yz1 = e2->y1;
            *xz2 = e2->x2;
            *yz2 = e2->y2;
            answer = 11;
            *matchlen = e2->length;
            tempZ = InterpLinearElev(e1->x1,e1->y1,e1->z1,e1->x2,e1->y2,e1->z2,e2->x1,e2->y1);
            *zdiff1 = fabs(e2->z1 - tempZ);
            tempZ = InterpLinearElev(e1->x1,e1->y1,e1->z1,e1->x2,e1->y2,e1->z2,e2->x2,e2->y2);
            *zdiff2 = fabs(e2->z2 - tempZ);
            }
         }
      else if(OnLine[0] == 2) /** vertex e1->x1,e1->y1 is same as vertex e2->x1,e2->y1  **/
         {
         *matchlen = 0;
         *zdiff1 = *zdiff2 = fabs(e1->z1 - e2->z1);
         *xz1 = *xz2 = e1->x1;
         *yz1 = *yz2 = e1->y1;
         if(*zdiff1 < 0.001)
            {
            *zdiff1 = *zdiff2 = 0.0;
            answer = 0;
            }
         else
            answer = 13;
         }
      else if(OnLine[0] == 3) /** vertex e1->x1,e1->y1 is same as vertex e2->x2,e2->y2  **/
         {
         *matchlen = 0;
         *zdiff1 = *zdiff2 = fabs(e1->z1 - e2->z2);
         *xz1 = *xz2 = e1->x1;
         *yz1 = *yz2 = e1->y1;
         if(*zdiff1 < 0.001)
            {
            *zdiff1 = *zdiff2 = 0.0;
            answer = 0;
            }
         else
            answer = 13;
         }
      else if(OnLine[1] == 2) /** vertex e1->x2,e1->y2 is same as vertex e2->x1,e2->y1  **/
         {
         *matchlen = 0;
         *zdiff1 = *zdiff2 = fabs(e1->z2 - e2->z1);
         *xz1 = *xz2 = e1->x2;
         *yz1 = *yz2 = e1->y2;
         if(*zdiff1 < 0.001)
            {
            *zdiff1 = *zdiff2 = 0.0;
            answer = 0;
            }
         else
            answer = 13;
         }
      else if(OnLine[1] == 3) /** vertex e1->x2,e1->y2 is same as vertex e2->x2,e2->y2  **/
         {
         *matchlen = 0;
         *zdiff1 = *zdiff2 = fabs(e1->z2 - e2->z2);
         *xz1 = *xz2 = e1->x2;
         *yz1 = *yz2 = e1->y2;
         if(*zdiff1 < 0.001)
            {
            *zdiff1 = *zdiff2 = 0.0;
            answer = 0;
            }
         else
            answer = 13;
         }
      }
   if(answer > 1)
      {
      if(*zdiff1 < 0.001)
         *zdiff1 = 0.0;
      if(*zdiff2 < 0.001)
         *zdiff2 = 0.0;
      }

   return(answer);
}



void CheckEdgeTopology(struct ListOfEdges *edgeroot, struct ListOfEdges *Vedgeroot, int flag)
{
  struct ListOfEdges *ec, *en;
  int matchtype;
  int checkinstance;
  int part1, part2,part3;
  double matchlength;
  double deltaZ1, deltaZ2;
  double dzx1, dzy1,dzx2,dzy2;
  struct ThePolys *tp1, *tp2; 
  struct RawAreal *ra1, *ra2;
  struct IncidentList *IE1, *IE2;
  int ShortIndex1, ShortIndex2;
  int LongIndex1, LongIndex2;
  int SzIL = sizeof(struct IncidentList);
  unsigned char CO1, ST1, DO1, CO2, ST2, DO2;
  int IDlookup1, IDlookup2;
  
  
  ec = edgeroot;
  while(ec != NULL)
    {
      if(flag == 1)
	{
	  tp1 = (struct ThePolys *) ec->owner; 
	  ShortIndex1 = tp1->SCCindex;
	  LongIndex1 = tp1->SACindex;
	  CO1 = tp1->config;
	  ST1 = tp1->stratum;
	  DO1 = tp1->domain;
          IDlookup1 = tp1->idn;
	}
      else if(flag == 2)
	{
	  ra1 = (struct RawAreal *) ec->owner; 
	  ShortIndex1 = ra1->Sindex;
	  LongIndex1 = ra1->Lindex;
	  CO1 = SCCtable[ShortIndex1].C;
	  ST1 = SCCtable[ShortIndex1].S;
	  DO1 = SCCtable[ShortIndex1].D;
          IDlookup1 = ra1->idn;
	}
      en = ec->next;
      while(en != NULL)
         {
         if(flag == 1)
            {
            tp2 = (struct ThePolys *) en->owner;
            ShortIndex2 = tp2->SCCindex;
            LongIndex2 = tp2->SACindex;
            CO2 = tp2->config;
            ST2 = tp2->stratum;
            DO2 = tp2->domain;
            IDlookup2 = tp2->idn;
            }
         else if(flag == 2)
            {
            ra2 = (struct RawAreal *) en->owner;
            ShortIndex2 = ra2->Sindex;
            LongIndex2 = ra2->Lindex;
            CO2 = SCCtable[ShortIndex2].C;
            ST2 = SCCtable[ShortIndex2].S;
            DO2 = SCCtable[ShortIndex2].D;
            IDlookup2 = ra2->idn;
            }
         if(ec->owner != en->owner)
            {
            matchtype = MatchPolyEdge2D(ec,en,&matchlength,&deltaZ1, &dzx1, &dzy1,
                                              &deltaZ2, &dzx2, &dzy2);

            for(checkinstance = 0; checkinstance < TtlActiveChecks; checkinstance++)
               {
               if(matchtype > 0)
                  {
                  if((deltaZ1 > 0) || (deltaZ2 > 0))
                     {
                     if((Vedgeroot != NULL) && (ReMatchWithVerticals(ec,Vedgeroot,matchtype) > 0) &&
                            (ReMatchWithVerticals(en,Vedgeroot,matchtype) > 0))
                        {
                        deltaZ1 = 0.0;
                        deltaZ2 = 0.0;
                        matchtype = 0;
                        }
                     }
                  }
               if((matchtype > 0) && (matchtype < 12))
                  {
                  if((deltaZ1 > 0) || (deltaZ2 > 0))
                     {
                     if((CombinedCheckApplies(IDlookup1,checkinstance,VTEAR,LongIndex1,ShortIndex1,CO1,ST1,DO1,&part1,&part2,&part3) <  1) ||
                           (part1 == 0))
                        {
                        deltaZ1 = 0.0;
                        deltaZ2 = 0.0;
                        }
                     if((CombinedCheckApplies(IDlookup1,checkinstance,HTEAR,LongIndex1,ShortIndex1,CO1,ST1,DO1,&part1,&part2,&part3) > 0) &&
                             (part1 > 0))
                        {
                        ec->Tcover += matchlength;
                        en->Tcover += matchlength;
                        }
                     if((CombinedCheckApplies(IDlookup1,checkinstance,OVERC,LongIndex1,ShortIndex1,CO1,ST1,DO1,&part1,&part2,&part3) > 0) &&
                             (part1 > 0))
                        {
                        ec->Ocover += matchlength;
                        en->Ocover += matchlength;
                        }
                     /**}**/
                     }
                  else
                     {
                     if((CombinedCheckApplies(IDlookup1,checkinstance,HTEAR,LongIndex1,ShortIndex1,CO1,ST1,DO1,&part1,&part2,&part3) > 0) &&
                             (part1 > 0))
                        {
                        ec->Tcover += matchlength;
                        en->Tcover += matchlength;
                        }
                     if((CombinedCheckApplies(IDlookup1,checkinstance,OVERC,LongIndex1,ShortIndex1,CO1,ST1,DO1,&part1,&part2,&part3) > 0)&&
                             (part1 > 0))
                        {
                        ec->Ocover += matchlength;
                        en->Ocover += matchlength;
                        }
                     }

                  IE1 = (struct IncidentList *) (malloc(SzIL));
                  IE2 = (struct IncidentList *) (malloc(SzIL));
                  if((IE1 == NULL) || (IE2 == NULL))
                     {
                     printf("available allocation memory exhausted during topology analysis\n");
                     printf("execution cannot continue in this circumstance\n");
                     exit(-1);
                     }
                  IE1->AdjacentEdge = (long int) en;
                  IE1->primary = 1;
                  IE1->DeltaZ = deltaZ1;
                  IE1->DeltaZX = dzx1;
                  IE1->DeltaZY = dzy1;
                  IE1->next = IE2;
                  IE2->AdjacentEdge = (long int) en;
                  IE2->primary = 1;
                  IE2->DeltaZ = deltaZ2;
                  IE2->DeltaZX = dzx2;
                  IE2->DeltaZY = dzy2;
                  IE2->next = ec->Iedge;
                  ec->Iedge = IE1;

                  IE1 = (struct IncidentList *) (malloc(SzIL));
                  IE2 = (struct IncidentList *) (malloc(SzIL));
                  if((IE1 == NULL) || (IE2 == NULL))
                     {
                     printf("available allocation memory exhausted during topology analysis\n");
                     printf("execution cannot continue in this circumstance\n");
                     exit(-1);
                     }
                  IE1->AdjacentEdge = (long int) ec;
                  IE1->primary = 0;
                  IE1->DeltaZ = deltaZ1;
                  IE1->DeltaZX = dzx1;
                  IE1->DeltaZY = dzy1;
                  IE1->next = IE2;
                  IE2->AdjacentEdge = (long int) ec;
                  IE2->primary = 0;
                  IE2->DeltaZ = deltaZ2;
                  IE2->DeltaZX = dzx2;
                  IE2->DeltaZY = dzy2;
                  IE2->next = en->Iedge;
                  en->Iedge = IE1;
   
                  if(deltaZ1 > 0.0) 
                     {
                     ec->matchX1 = en->x1;
                     ec->matchX2 = en->x2;
                     ec->matchY1 = en->y1;
                     ec->matchY2 = en->y2;
                     ec->matchZ1 = en->z1;
                     ec->matchZ2 = en->z2;
                     ec->DeltaZ1 = deltaZ1;
                     ec->DeltaZX1 = dzx1;
                     ec->DeltaZY1 = dzy1;
                     if(flag == 1)
                        {
                        ec->IncidentIDN = tp2->idn;
                        ec->IncidentNumb = tp2->SCCindex;
                        }
                     else if(flag == 2)
                        {
                        ec->IncidentIDN = ra2->idn;
                        ec->IncidentNumb = ra2->Sindex;
                        }
                     }
                  else
                     ec->DeltaZ1 = 0.0;
                  if(deltaZ2 > 0.0) 
                     {
                     ec->matchX1 = en->x1;
                     ec->matchX2 = en->x2;
                     ec->matchY1 = en->y1;
                     ec->matchY2 = en->y2;
                     ec->matchZ1 = en->z1;
                     ec->matchZ2 = en->z2;
                     ec->DeltaZ2 = deltaZ2;
                     ec->DeltaZX2 = dzx2;
                     ec->DeltaZY2 = dzy2;
                     if(flag == 1)
                        {
                        ec->IncidentIDN = tp2->idn;
                        ec->IncidentNumb = tp2->SCCindex;
                        }
                     else if(flag == 2)
                        {
                        ec->IncidentIDN = ra2->idn;
                        ec->IncidentNumb = ra2->Sindex;
                        }
                     }
                  else
                     ec->DeltaZ2 = 0.0;

                  if(deltaZ1 > 0.0) 
                     {
                     en->matchX1 = ec->x1;
                     en->matchX2 = ec->x2;
                     en->matchY1 = ec->y1;
                     en->matchY2 = ec->y2;
                     en->matchZ1 = ec->z1;
                     en->matchZ2 = ec->z2;
                     en->DeltaZ1 = deltaZ1;
                     en->DeltaZX1 = dzx1;
                     en->DeltaZY1 = dzy1;
                     if(flag == 1)
                        {
                        en->IncidentIDN = tp1->idn;
                        en->IncidentNumb = tp1->SCCindex;
                        }
                     else if(flag == 2)
                        {
                        en->IncidentIDN = ra1->idn;
                        en->IncidentNumb = ra1->Sindex;
                        }
                     }
                  else
                     en->DeltaZ1 = 0.0;
                  if(deltaZ2 > 0.0) 
                     {
                     en->matchX1 = ec->x1;
                     en->matchX2 = ec->x2;
                     en->matchY1 = ec->y1;
                     en->matchY2 = ec->y2;
                     en->matchZ1 = ec->z1;
                     en->matchZ2 = ec->z2;
                     en->DeltaZ2 = deltaZ2;
                     en->DeltaZX2 = dzx2;
                     en->DeltaZY2 = dzy2;
                     if(flag == 1)
                        {
                        en->IncidentIDN = tp1->idn;
                        en->IncidentNumb = tp1->SCCindex;
                        }
                     else if(flag == 2)
                        {
                        en->IncidentIDN = ra1->idn;
                        en->IncidentNumb = ra1->Sindex;
                        }
                     }
                  else
                     en->DeltaZ2 = 0.0;

                  if((CombinedCheckApplies(IDlookup1,checkinstance,TVERT,LongIndex1,ShortIndex1,CO1,ST1,DO1,&part1,&part2,&part3) > 0)  &&
                       (CombinedCheckApplies(IDlookup2,checkinstance,TVERT,LongIndex2,ShortIndex2,CO2,ST2,DO2,&part1,&part2,&part3) > 0))
                     {

                     switch(matchtype)
                        {
                        case 2: /** only vertex en->2 is a T **/
                           if(en->isT < 2)
                              en->isT += 2;
                           if(flag == 1)
                              {
                              en->IncidentIDN = tp1->idn;
                              en->IncidentNumb = tp1->SCCindex;
                              }
                           else if(flag == 2)
                              {
                              en->IncidentIDN = ra1->idn; 
                              en->IncidentNumb = ra1->Sindex;
                              }
                           break;
                        case 3: /** only vertex en->1 is a T **/
                           if((en->isT == 0) || (en->isT == 2))
                              en->isT += 1;
                           if(flag == 1)
                              {
                              en->IncidentIDN = tp1->idn;
                              en->IncidentNumb = tp1->SCCindex;
                              }
                           else if(flag == 2)
                              {
                              en->IncidentIDN = ra1->idn; 
                              en->IncidentNumb = ra1->Sindex;
                              }
                           break;
                        case 4: /** only vertex ec->1 is a T **/
                           if((ec->isT == 0) || (ec->isT == 2))
                              ec->isT += 1;
                           if(flag == 1)
                              {
                              ec->IncidentIDN = tp2->idn;
                              ec->IncidentNumb = tp2->SCCindex;
                              }
                           else if(flag == 2)
                              {
                              ec->IncidentIDN = ra2->idn; 
                              ec->IncidentNumb = ra2->Sindex;
                              }
                           break;
                        case 5: /** only vertex ec->2 is a T **/
                           if(ec->isT < 2)
                              ec->isT += 2;
                           if(flag == 1)
                              {
                              ec->IncidentIDN = tp2->idn;
                              ec->IncidentNumb = tp2->SCCindex;
                              }
                           else if(flag == 2)
                              {
                              ec->IncidentIDN = ra2->idn; 
                              ec->IncidentNumb = ra2->Sindex;
                              }
                           break;
                        case 6: /** both ec->1 and ec->2 are T's **/
                           ec->isT = 3;
                           if(flag == 1)
                              {
                              ec->IncidentIDN = tp2->idn;
                              ec->IncidentNumb = tp2->SCCindex;
                              }
                           else if(flag == 2)
                              {
                              ec->IncidentIDN = ra2->idn;
                              ec->IncidentNumb = ra2->Sindex;
                              }
                           break;
                        case 7: /** ec->1 and en->1 are T's **/
                           if((ec->isT == 0) || (ec->isT == 2))
                              ec->isT += 1;
                           if((en->isT == 0) || (en->isT == 2))
                              en->isT += 1;
                           if(flag == 1)
                              {
                              ec->IncidentIDN = tp2->idn;
                              en->IncidentIDN = tp1->idn;
                              ec->IncidentNumb = tp2->SCCindex;
                              en->IncidentNumb = tp1->SCCindex;
                              }
                           else if(flag == 2)
                              {
                              ec->IncidentIDN = ra2->idn;
                              en->IncidentIDN = ra1->idn;
                              ec->IncidentNumb = ra2->Sindex;
                              en->IncidentNumb = ra1->Sindex;
                              }
                           break;
                        case 8: /** ec->1 and en->2 are T's **/
                           if((ec->isT == 0) || (ec->isT == 2))
                              ec->isT += 1;
                           if(en->isT < 2)
                              en->isT += 2;
                           if(flag == 1)
                              {
                              ec->IncidentIDN = tp2->idn;
                              en->IncidentIDN = tp1->idn;
                              ec->IncidentNumb = tp2->SCCindex;
                              en->IncidentNumb = tp1->SCCindex;
                              }
                           else if(flag == 2)
                              {
                              ec->IncidentIDN = ra2->idn;
                              en->IncidentIDN = ra1->idn;
                              ec->IncidentNumb = ra2->Sindex;
                              en->IncidentNumb = ra1->Sindex;
                              }
                           break;
                        case 9: /** ec->2 and en->1 are T's **/
                           if(ec->isT < 2)
                              ec->isT += 2;
                           if((en->isT == 0) || (en->isT == 2))
                              en->isT += 1;
                           if(flag == 1)
                              {
                              ec->IncidentIDN = tp2->idn;
                              en->IncidentIDN = tp1->idn;
                              ec->IncidentNumb = tp2->SCCindex;
                              en->IncidentNumb = tp1->SCCindex;
                              }
                           else if(flag == 2)
                              {
                              ec->IncidentIDN = ra2->idn;
                              en->IncidentIDN = ra1->idn;
                              ec->IncidentNumb = ra2->Sindex;
                              en->IncidentNumb = ra1->Sindex;
                              }
                           break;
                        case 10: /** ec->2 and en->2 are T's **/
                           if(ec->isT < 2)
                              ec->isT += 2;
                           if(en->isT < 2)
                              en->isT += 2;
                           if(flag == 1)
                              {
                              ec->IncidentIDN = tp2->idn;
                              en->IncidentIDN = tp1->idn;
                              ec->IncidentNumb = tp2->SCCindex;
                              en->IncidentNumb = tp1->SCCindex;
                              }
                           else if(flag == 2)
                              {
                              ec->IncidentIDN = ra2->idn;
                              en->IncidentIDN = ra1->idn;
                              ec->IncidentNumb = ra2->Sindex;
                              en->IncidentNumb = ra1->Sindex;
                              }
                           break;
                        case 11: /** both en->1 and en->2 are T's **/
                           en->isT = 3;
                           if(flag == 1)
                              {
                              en->IncidentIDN = tp1->idn;
                              en->IncidentNumb = tp1->SCCindex;
                              }
                           else if(flag == 2)
                              {
                              en->IncidentIDN = ra1->idn;
                              en->IncidentNumb = ra1->Sindex;
                              }
                           break;
                        }
                     }
                  }
               else if((matchtype == 12) || (matchtype == 13))
                  {
                  if((CombinedCheckApplies(IDlookup1,checkinstance,VTEAR,LongIndex1,ShortIndex1,CO1,ST1,DO1,&part1,&part2,&part3) < 1)  ||
                        (part1 < 0))
                     {
                     deltaZ1 = 0.0;
                     deltaZ2 = 0.0;
                     }
                  IE1 = (struct IncidentList *) (malloc(SzIL));
                  IE2 = (struct IncidentList *) (malloc(SzIL));
                  if((IE1 == NULL) || (IE2 == NULL))
                     {
                     printf("available allocation memory exhausted during topology analysis\n");
                     printf("execution cannot continue in this circumstance\n");
                     exit(-1);
                     }
                  IE1->AdjacentEdge = (long int) en;
                  if(matchtype == 12)
                     IE1->primary = 3;
                  else
                     IE1->primary = 5;
                  IE1->DeltaZ = deltaZ1;
                  IE1->DeltaZX = dzx1;
                  IE1->DeltaZY = dzy1;
                  IE1->next = IE2;
                  IE2->AdjacentEdge = (long int) en;
                  if(matchtype == 12)
                     IE2->primary = 3;
                  else
                     IE2->primary = 5;
                  IE2->DeltaZ = deltaZ2;
                  IE2->DeltaZX = dzx2;
                  IE2->DeltaZY = dzy2;
                  IE2->next = ec->Iedge;
                  ec->Iedge = IE1;
   
                  IE1 = (struct IncidentList *) (malloc(SzIL));
                  IE2 = (struct IncidentList *) (malloc(SzIL));
                  if((IE1 == NULL) || (IE2 == NULL))
                     {
                     printf("available allocation memory exhausted during topology analysis\n");
                     printf("execution cannot continue in this circumstance\n");
                     exit(-1);
                     }
                  IE1->AdjacentEdge = (long int) ec;
                  if(matchtype == 12)
                     IE1->primary = 2;
                  else
                     IE1->primary = 4;
                  IE1->DeltaZ = deltaZ1;
                  IE1->DeltaZX = dzx1;
                  IE1->DeltaZY = dzy1;
                  IE1->next = IE2;
                  IE2->AdjacentEdge = (long int) ec;
                  if(matchtype == 12)
                     IE2->primary = 2;
                  else
                     IE2->primary = 4;
                  IE2->DeltaZ = deltaZ2;
                  IE2->DeltaZX = dzx2;
                  IE2->DeltaZY = dzy2;
                  IE2->next = en->Iedge;
                  en->Iedge = IE1;
   
                  if(deltaZ1 > 0.0)
                     {
                     ec->matchX1 = en->x1;
                     ec->matchX2 = en->x2;
                     ec->matchY1 = en->y1;
                     ec->matchY2 = en->y2;
                     ec->matchZ1 = en->z1;
                     ec->matchZ2 = en->z2;
                     ec->DeltaZ1 = deltaZ1;
                     ec->DeltaZX1 = dzx1;
                     ec->DeltaZY1 = dzy1;
                     if(flag == 1)
                        {
                        ec->IncidentIDN = tp2->idn;
                        ec->IncidentNumb = tp2->SCCindex;
                        }
                     else if(flag == 2)
                        {
                        ec->IncidentIDN = ra2->idn;
                        ec->IncidentNumb = ra2->Sindex;
                        }
                     }
                  else
                     ec->DeltaZ1 = 0.0;
                  if(deltaZ2 > 0.0)
                     {
                     ec->matchX1 = en->x1;
                     ec->matchX2 = en->x2;
                     ec->matchY1 = en->y1;
                     ec->matchY2 = en->y2;
                     ec->matchZ1 = en->z1;
                     ec->matchZ2 = en->z2;
                     ec->DeltaZ2 = deltaZ2;
                     ec->DeltaZX2 = dzx2;
                     ec->DeltaZY2 = dzy2;
                     if(flag == 1)
                        {
                        ec->IncidentIDN = tp2->idn;
                        ec->IncidentNumb = tp2->SCCindex;
                        }
                     else if(flag == 2)
                        {
                        ec->IncidentIDN = ra2->idn;
                        ec->IncidentNumb = ra2->Sindex;
                        }
                     }
                  else
                     ec->DeltaZ2 = 0.0;

                  if(deltaZ1 > 0.0)
                     {
                     en->matchX1 = ec->x1;
                     en->matchX2 = ec->x2;
                     en->matchY1 = ec->y1;
                     en->matchY2 = ec->y2;
                     en->matchZ1 = ec->z1;
                     en->matchZ2 = ec->z2;
                     en->DeltaZ1 = deltaZ1;
                     en->DeltaZX1 = dzx1;
                     en->DeltaZY1 = dzy1;
                     if(flag == 1)
                        {
                        en->IncidentIDN = tp1->idn;
                        en->IncidentNumb = tp1->SCCindex;
                        }
                     else if(flag == 2)
                        {
                        en->IncidentIDN = ra1->idn;
                        en->IncidentNumb = ra1->Sindex;
                        }
                     }
                  else
                     en->DeltaZ1 = 0.0;
                  if(deltaZ2 > 0.0)
                     {
                     en->matchX1 = ec->x1;
                     en->matchX2 = ec->x2;
                     en->matchY1 = ec->y1;
                     en->matchY2 = ec->y2;
                     en->matchZ1 = ec->z1;
                     en->matchZ2 = ec->z2;
                     en->DeltaZ2 = deltaZ2;
                     en->DeltaZX2 = dzx2;
                     en->DeltaZY2 = dzy2;
                     if(flag == 1)
                        {
                        en->IncidentIDN = tp1->idn;
                        en->IncidentNumb = tp1->SCCindex;
                        }
                     else if(flag == 2)
                        {
                        en->IncidentIDN = ra1->idn;
                        en->IncidentNumb = ra1->Sindex;
                        }
                     }
                  else
                     en->DeltaZ2 = 0.0;
                  } /** end if((matchtype == 12) || (matchtype == 13)) ***/
               if((CombinedCheckApplies(IDlookup1,checkinstance,TVERT,LongIndex1,ShortIndex1,CO1,ST1,DO1,&part1,&part2,&part3) > 0)  &&
                    (part1 > 0) &&
                   (CombinedCheckApplies(IDlookup2,checkinstance,TVERT,LongIndex2,ShortIndex2,CO2,ST2,DO2,&part1,&part2,&part3) > 0) &&
                      (part1 > 0))
                  {

                  if((matchtype == 3) || (matchtype == 7) || (matchtype == 9) || (matchtype == 11))
                     {
/** first, en vertex 1 is some kind of a T **/
                     if((en->clipped != 1) && (en->clipped != 3))
                        {
                        if(flag == 1)
			  {
                           FwritePointAndObject(TVERT,Make_Correct(TVERT,checkinstance),en->x1,en->y1,en->z1, tp2->idn, 
                           tp1->SCCindex, G_POLYGON, tp1->SACindex, tp1->localID, tp1->idn,10.0, 0.0,tp1->x, tp1->y, tp1->z,tp1->numverts);
                           }
                        else
                           {
                           FwritePointAndObject(TVERT,Make_Correct(TVERT,checkinstance),en->x1,en->y1,en->z1, ra2->idn,
                           ra1->Sindex, G_AREAL, ra1->Lindex, ra1->localID, ra1->idn,10.0, 0.0,ra1->x, ra1->y, ra1->z,2);
                           }
                        }
                     }
                  if((matchtype == 2) || (matchtype == 8) || (matchtype == 10) || (matchtype == 11))
                     {
                     if((en->clipped != 2) && (en->clipped != 3))
                        {
                        if(flag == 1)
                           {
                           FwritePointAndObject(TVERT,Make_Correct(TVERT,checkinstance),en->x2,en->y2,en->z2, tp2->idn, 
                           tp1->SCCindex, G_POLYGON, tp1->SACindex, tp1->localID, tp1->idn,10.0, 0.0,tp1->x, tp1->y, tp1->z,tp1->numverts);
                           }
                        else
                           {
                           FwritePointAndObject(TVERT,Make_Correct(TVERT,checkinstance),en->x2,en->y2,en->z2, ra2->idn,
                           ra1->Sindex, G_AREAL, ra1->Lindex, ra1->localID, ra1->idn,10.0, 0.0,ra1->x, ra1->y, ra1->z,2);
                           }
                        }
                     }
                  if((matchtype == 4) || (matchtype == 6) || (matchtype == 7) || (matchtype == 8))
                     {
                     if((ec->clipped != 1) && (ec->clipped != 3))
                        {
                        if(flag == 1)
                           {
                           FwritePointAndObject(TVERT,Make_Correct(TVERT,checkinstance),ec->x1,ec->y1,ec->z1, tp1->idn,
                           tp2->SCCindex, G_POLYGON, tp2->SACindex, tp2->localID, tp2->idn,10.0, 0.0,tp2->x, tp2->y, tp2->z,tp2->numverts);
                           }
                        else
                           {
                           FwritePointAndObject(TVERT,Make_Correct(TVERT,checkinstance),ec->x1,ec->y1,ec->z1, ra1->idn,
                           ra2->Sindex, G_AREAL, ra2->Lindex, ra2->localID, ra2->idn,10.0, 0.0,ra2->x, ra2->y, ra2->z,2);
                           }
                        }
                     }
                  if((matchtype == 5) || (matchtype == 6) || (matchtype == 9) || (matchtype == 10))
                     {
                     if((ec->clipped != 2) && (ec->clipped != 3))
                        {
                        if(flag == 1)
                           {
                           FwritePointAndObject(TVERT,Make_Correct(TVERT,checkinstance),ec->x2,ec->y2,ec->z2, tp1->idn,
                           tp2->SCCindex, G_POLYGON, tp2->SACindex, tp2->localID, tp2->idn,10.0, 0.0,tp2->x, tp2->y, tp2->z,tp2->numverts);
                           }
                        else
                           {
                           FwritePointAndObject(TVERT,Make_Correct(TVERT,checkinstance),ec->x2,ec->y2,ec->z2, ra1->idn,
                           ra2->Sindex, G_AREAL, ra2->Lindex, ra2->localID, ra2->idn,10.0, 0.0,ra2->x, ra2->y, ra2->z,2);
                           }
                        }
                     }
                  }
               }
            }
         if(en->minx > ec->maxx)
            break; 
         en = en->next;
         }
      ec = ec->next;
      }
}





int MatchLinearSegment2D(double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4,
                         double *matchlen, double tolerance)
{
int answer = 0;
int OnLine[4];
int i;
double ptldist;


   for(i=0; i<4; i++)
      OnLine[i] = 0;

   ptldist = PointToLineDist2D(x1,y1,x3,y3,x4,y4);
   if(ptldist <= tolerance)
      OnLine[0] = 1;

   ptldist = PointToLineDist2D(x2,y2,x3,y3,x4,y4);
   if(ptldist <= tolerance)
      OnLine[1] = 1;

   ptldist = PointToLineDist2D(x3,y3,x1,y1,x2,y2);
   if(ptldist <= tolerance)
      OnLine[2] = 1;

   ptldist = PointToLineDist2D(x4,y4,x1,y1,x2,y2);
   if(ptldist <= tolerance)
      OnLine[3] = 1;

   i = 0;
   if(OnLine[0] > 0)
      ++i;
   if(OnLine[1] > 0)
      ++i;
   if(OnLine[2] > 0)
      ++i;
   if(OnLine[3] > 0)
      ++i;

   if(i < 1)
      {
      answer = 0;
      *matchlen = 0.0;
      }
   else if (i == 1) /** a classic 'T' - only a vertex of one edge touches other edge **/
      {
      answer = 0;
      *matchlen = 0.0;
      }
   else if(i == 4) /** two edges match exactly (share same two vertices) ****/
      {
      answer = 1;
      *matchlen = Distance(x1,y1,x2,y2);
      }
   else if(i == 3)  /** one endpt shared **/
      {
      if(OnLine[0] == 0) /** then either 3 or 4 should be a T **/
         {
         *matchlen = Distance(x3,y3,x4,y4);
         answer = 1;
         }
      else if(OnLine[1] == 0) /** again, either 3 or 4 should be a T **/
         {
         *matchlen = Distance(x3,y3,x4,y4);
         answer = 1;
         }
      else if(OnLine[2] == 0) /** then either 1 or 2 should be a T **/
         {
         *matchlen = Distance(x1,y1,x2,y2);
         answer = 1;
         }
      else if(OnLine[3] == 0) /** again, either 1 or 2 should be a T **/
         {
         *matchlen = Distance(x1,y1,x2,y2);
         answer = 1;
         }
      }
   else if(i == 2)  
      {
      if(OnLine[0] == 1) /** then pt (x1,y1) could be a 'T' ***/
         {
         if(OnLine[1] == 1) /** then pt (x2,y2) is a 'T' ***/
            {
            answer = 1;
            *matchlen = Distance(x1,y1,x2,y2);
            }
         else if(OnLine[2] == 1) /** then pt (x3,y3) could be a 'T' ***/
            {
               answer = 1;
               *matchlen = Distance(x1,y1,x3,y3);
            }
         else if(OnLine[3] == 1) /** then pt (x4,y4) could be a 'T' ***/
            {
               answer = 1;
               *matchlen = Distance(x1,y1,x4,y4);
            }
         }
      else if(OnLine[1] == 1)  /** then pt (x2,y2) could be a 'T' ***/
         {
         if(OnLine[2] == 1) /** then pt (x3,y3) could be a 'T' ***/
            {
               answer = 1;
               *matchlen = Distance(x2,y2,x3,y3);
            }
         else if(OnLine[3] == 1) /** then pt (x4,y4) could be a 'T' ***/
            {
               answer = 1;
               *matchlen = Distance(x2,y2,x4,y4);
            }
         }
      else if(OnLine[2] == 1) /** then pt (x3,y3) is a 'T' ***/
         {
         if(OnLine[3] == 1) /** then pt (x4,y4) is a 'T' ***/
            {
            answer = 1;
            *matchlen = Distance(x3,y3,x4,y4);
            }
         }
      }


   return(answer);
}


int RemoveByContainmentOrCoincidence(double px, double py, struct RawLinear *Lroot, int checkinstance, int check, 
    double minx,double miny,double maxx,double maxy, double tolerance,
    struct RawAreal *Aroot, struct RawPoint *Proot)
{
struct RawLinear *rlc;
struct RawAreal *rac, *raHole;
struct RawPoint *rpc;
int i,j, unusedint;
int part1, part2, part3, answer;
double ptfdist, unuseddbl;

   answer = 1;
   rpc = Proot;
   while(rpc != NULL)
      {
      if(CombinedCheckApplies(rpc->idn,checkinstance,check,rpc->Lindex,rpc->Sindex,
               SCCtable[rpc->Sindex].C,SCCtable[rpc->Sindex].S,SCCtable[rpc->Sindex].D,&part1,&part2,&part3) > 0)
         {
         if(part3 > 0)
            {
            ptfdist = Distance(px,py,rpc->x[0],rpc->y[0]);
            if(ptfdist < tolerance)
               return(0);
            }
         }
      rpc = rpc->next;
      }

   rlc = Lroot;
   while(rlc != NULL)
      {
      if(CombinedCheckApplies(rlc->idn,checkinstance,check,rlc->Lindex,rlc->Sindex,
               SCCtable[rlc->Sindex].C,SCCtable[rlc->Sindex].S,SCCtable[rlc->Sindex].D,&part1,&part2,&part3) > 0)
         {
         if(part3 > 0)
            {
            for(j=1; j<rlc->numnodes; j++)
               {
               i = j - 1;
               ptfdist = PointToLineDist2D(px,py,rlc->x[i], rlc->y[i], rlc->x[j], rlc->y[j]);
               if(ptfdist < tolerance)
                  return(0);
               }
            }
         }
      rlc = rlc->next;
      }
   rac = Aroot;
   while(rac != NULL)
      {
      if((rac->ishole <= 0) &&
         (CombinedCheckApplies(rac->idn,checkinstance,check,rac->Lindex,rac->Sindex,
               SCCtable[rac->Sindex].C,SCCtable[rac->Sindex].S,SCCtable[rac->Sindex].D,&part1,&part2,&part3) > 0))
         {
         if(part3 > 0)
            {
            if(rac->RB_Tree_Edgelist == NULL)
               {
               if(PointIsVertex(px, py, rac->x,rac->y,rac->x,rac->numverts,&unuseddbl))
                  {
                  return(0);
                  }
               else if(PointOnEdge(px, py, rac->x,rac->y,rac->x,rac->numverts,&unuseddbl,&unusedint))
                  {
                  return(0);
                  }
               else if(PointIsInside(px, py, rac->x,rac->y,rac->x,rac->numverts,C_AREA,&unuseddbl))
                  {
                  raHole = Aroot;
                  while(raHole != NULL)
                     {
                     if((raHole->ishole > 0) && (raHole->featureid == rac->featureid))
                        {
                        if(PointIsInside(px,py,raHole->x,raHole->y,raHole->x,raHole->numverts,C_AREA,&unuseddbl))
                           {
                           break;
                           }
                        }
                     raHole = raHole->next;
                     }
                  if(raHole == NULL)
                     return(0);
                  }
               }
            else
               {
               if(PointIsLargeArealVertex(px, py, rac,&unuseddbl) > 0)
                  {
                  return(0);
                  }
               else if(PointOnLargeArealEdge(px, py, rac,&unuseddbl, &unusedint) > 0)
                  {
                  return(0);
                  }
               else if(PointInsideLargeAreal(px, py, rac,&unusedint) > 0)
                  {
                  raHole = Aroot;
                  while(raHole != NULL)
                     {
                     if((raHole->ishole > 0) && (raHole->idn == rac->idn))
                        {
                        if(PointIsInside(px,py,raHole->x,raHole->y,raHole->x,raHole->numverts,C_AREA,&unuseddbl))
                           {
                           break;
                           }
                        }
                     raHole = raHole->next;
                     }
                  if(raHole == NULL)
                     return(0);
                  }
               }
            }
         }
      rac = rac->next;
      }
   return(answer);
}







int GetLENandWIDvalues(int Lindex, int idn, FILE * fileptr, int LENcode, int WIDcode, double *LENvalue, double *WIDvalue)
{
int ATTR_CODE;
int ECC,numchar;
char longtitle[500];
char tc;
int seeitgeom, numattr;
int i, j, attr_type;
int uom, uomscale,SEDRIStype,datatype;
int Idtvalue, IdtVal2, IntervalType;
double Fdtvalue,FdtVal2,fx;
extern int NOTYPE, C_TYPE, I_TYPE, D_TYPE;
extern int LONG_ATTR_CHECK_LEN;
extern int GetLongAttrVal(int type,int uniqueid,int *Ival,double *Dval,char *Cval);

   *LENvalue = *WIDvalue = -101010;


   if(ATTRTYPE_NFDD() > 0)
      attr_type = NOTYPE;
   attr_type = GetLongAttrVal(LONG_ATTR_CHECK_LEN,idn,&i,&fx,&MessageLine[0]);
   if(attr_type == D_TYPE)
      *LENvalue = fx;
   else if(attr_type == C_TYPE)
      {
      MessageLine[49] = '\0';
      sscanf(MessageLine,"%lf",&fx);
      *LENvalue = fx;
      }
   else if(attr_type == I_TYPE)
      *LENvalue = (double) i;

   fseek(fileptr,CrsWlk[Lindex].FullFilePosn,SEEK_SET);

   SEEIT_fread_int(&ECC,fileptr);
   if(feof(fileptr) == 0)
      {
      SEEIT_fread_int(&seeitgeom,fileptr);
      SEEIT_fread_int(&numattr,fileptr);
      if(numattr > 0)
         {
         for(i=0; i<numattr; i++)
            {
            SEEIT_fread_int(&ATTR_CODE,fileptr);
            if(ATTR_CODE < 0)
               {
               SEEIT_fread_int(&numchar,fileptr);
               if(numchar < 499)
                  fread(&longtitle[0],1,numchar,fileptr);
               longtitle[numchar] = '\0';
               }
            else
               {
               SEEIT_fread_int(&uom,fileptr);
               SEEIT_fread_int(&uomscale,fileptr);
               SEEIT_fread_int(&SEDRIStype,fileptr);
               SEEIT_fread_int(&datatype,fileptr);
               switch(datatype)
                  {
                  case 0: /** regular integer **/
                     SEEIT_fread_int(&Idtvalue,fileptr);
                     break;
                  case 1: /** a double **/
                     SEEIT_fread_double(&Fdtvalue,fileptr);
                     if(ATTR_CODE == LENcode)
                        *LENvalue = Fdtvalue;
                     else if(ATTR_CODE == WIDcode)
                        *WIDvalue = Fdtvalue;
                     break;
                  case 2: /** a string **/
                     SEEIT_fread_int(&numchar,fileptr);
                     for(j=0; j<numchar; j++)
                        {
                        fread(&tc,1,1,fileptr);
                        }
                     break;
                  case 3: /** enum as int **/
                     SEEIT_fread_int(&Idtvalue,fileptr);
strcpy(MessageLine,GetEELabel(ATTR_CODE,Idtvalue));
                     break;
                  case 4: /** metadata as int **/
                     SEEIT_fread_int(&Idtvalue,fileptr);
                     break;
                  case 5: /** a float interval for SEDRIS only **/
                     SEEIT_fread_double(&Fdtvalue,fileptr);
                     SEEIT_fread_double(&FdtVal2,fileptr);
                     SEEIT_fread_int(&IntervalType,fileptr);
                     break;
                  case 6: /** int interval - for SEDRIS, not NGA ***/
                    SEEIT_fread_int(&Idtvalue,fileptr);
                    SEEIT_fread_int(&IdtVal2,fileptr);
                    SEEIT_fread_int(&IntervalType,fileptr);
                    break;
                  case 7:
                 /* this case is not possible at this time */
                    SEEIT_fread_int(&Idtvalue,fileptr);
                    SEEIT_fread_int(&IdtVal2,fileptr);
                    SEEIT_fread_int(&IntervalType,fileptr);
                    break;
                  }
               }
            }
         }
      }

   if((*LENvalue <= 0) || (*WIDvalue <= 0))
      return(-1);
   else
      return(1);

}




struct PointRelatedCollection
	{
   int keyval;
   int Cnumber;
   int numverts1;
   int IDN1;
   int IDN2;
   double x1[3];
   double y1[3];
   double z1[3];
   double magnitude;
   double minx1, maxx1, miny1, maxy1;
   unsigned int Sindex1;
   unsigned int Sindex2;
   struct ThePolys *pp;
   struct RawAreal *aa;
   struct RawLinear *ll;
   struct RawPoint *pt1, *pt2;
   struct PointRelatedCollection * next;
   } ;
int SzPRC = sizeof(struct PointRelatedCollection);



void PerformPointRelatedChecks(FILE *ptsin, char * prompt, int cindex, struct RawPoint *root,double minx,double miny,double maxx,double maxy, double multiplier,
                struct RawLinear *Lroot, struct ThePolys * Proot, struct RawAreal * Aroot, struct RawAreal * NeighborAreals, int Lcode, int Wcode)
{
FILE *attrfileptr;
struct RawLinear *rlc, *rln, *rlp, *rlsave;
struct RawPoint *rpc, *npc;
struct ThePolys *rpoly, *polyobj;
struct RawAreal *rac, *rap, *ran, *arealobj, *raHole;
struct RB_Edgelist * LastEdge;
int i, ii2, j, jj, sj, sjj, k, kk, kindex, LookForFeature, FSindex, FLindex;
int li, ui, lj, uj, index1, index2, thisindex, keepit, checkit, thiskey;
int A_NeighborsLoaded, L_NeighborsLoaded, P_NeighborsLoaded;
int timesthroughloop, FoundCondition, LastI;
double xi, yi;
unsigned char clipflag;
int checkinstance;
int obj1form, obj2form,vtxcnt1,vtxcnt2;
int unusedint;
double unuseddbl;
double temptolerance, tolerancepad, tol2;
double ptldist,ptpdist,mindist,ptldistbase;
double X[4], Y[4], Z[4];
double X2[4], Y2[4], Z2[4];
double LENvalue, WIDvalue;
int part1, part2, part3;
int isclose, inside, outside, InHole;
int Config1, Strat1, Domain1;
int Config2, Strat2, Domain2;
int Config3, Strat3, Domain3;
int abortNow = 0;
char Tstring[500];
struct PointRelatedCollection *ERroot, *ERc, *ERn;


   attrfileptr = NULL;
   if((Lcode >= 0) && (Wcode >= 0) && (ErrorLookup[CALC_AREA].anyactive > 0))
      {
      sprintf(MessageLine,"%scodesfull.bin",indirectory);
      attrfileptr = fopen(MessageLine,"rb");
      if(attrfileptr == NULL)
         {
         printf("could not find required file %s\n",MessageLine);
         exit(-1);
         }
      }
   else
      attrfileptr = NULL;


   TgtAroot = NULL;
   TgtLroot = NULL;
   TgtProot = NULL;

   A_NeighborsLoaded = L_NeighborsLoaded = P_NeighborsLoaded = 0;

   ERroot = NULL;
   rpc = root;
   while(rpc != NULL)
      {
      Config1 = SCCtable[rpc->Sindex].C;
      Strat1 = SCCtable[rpc->Sindex].S;
      Domain1 = SCCtable[rpc->Sindex].D;


      for(checkinstance = 0; checkinstance < TtlActiveChecks; checkinstance++)
         {

         if((NGA_TYPE == 1) && (rpc->numverts == -1))
            {
            if((CombinedCheckApplies(rpc->idn,checkinstance,PORTRAYF,rpc->Lindex,rpc->Sindex,Config1,Strat1,Domain1,
                                             &part1,&part2,&part3) > 0) && (part1 > 0))
               {
               for(ii2 = 0; ii2 < NumberPF; ii2++)
                  {
                  if(rpc->Lindex == PF_Lindex[ii2])
                     {
                     if((PF_Iindex[ii2] < 0) || (rpc->idn == PF_Iindex[ii2]))
                        {
                        FwriteObject(PORTRAYF, Make_Correct(PORTRAYF,checkinstance), rpc->Lindex,
                           rpc->Sindex,G_POINT,rpc->localID,rpc->idn,10.0, -1.0,rpc->x,rpc->y,rpc->z,1, 1);
                        break;
                        }
                     }
                  }
               }

            if((CombinedCheckApplies(rpc->idn,checkinstance,TPORTRAYF,rpc->Lindex,rpc->Sindex,Config1,Strat1,Domain1,
                                             &part1,&part2,&part3) > 0) && (part1 > 0))
               {
               for(ii2 = 0; ii2 < NumberPF; ii2++)
                  {
                  if(rpc->Lindex == PF_Lindex[ii2])
                     {
                     if((PF_Iindex[ii2] < 0) || (rpc->idn == PF_Iindex[ii2]))
                        {
                        FwriteObject(TPORTRAYF, Make_Correct(TPORTRAYF,checkinstance), rpc->Lindex,
                           rpc->Sindex,G_POINT,rpc->localID,rpc->idn,10.0, -1.0,rpc->x,rpc->y,rpc->z,1, 1);
                        break;
                        }
                     }
                  }
               }

            if((Lcode >= 0) && (Wcode >= 0) &&
                 (CombinedCheckApplies(rpc->idn,checkinstance,CALC_AREA,rpc->Lindex,rpc->Sindex,Config1,Strat1,Domain1,
                                             &part1,&part2,&part3) > 0) && (part1 > 0))
               {
               i = GetLENandWIDvalues(rpc->Lindex, rpc->idn, attrfileptr, Lcode, Wcode, &LENvalue, &WIDvalue);
               if(i > 0)
                  {
                  unuseddbl = LENvalue * WIDvalue;

                  if(SensitivityCheck(GT, CALC_AREA, checkinstance, unuseddbl) > 0)
                     {
                     FwriteObjectAndMagnitude(CALC_AREA, Make_Correct(CALC_AREA,checkinstance),rpc->idn,rpc->Sindex,G_POINT,
                         rpc->Lindex,rpc->localID, -1.0, -1.0, unuseddbl,rpc->x, rpc->y, rpc->z,1, 1);
                     }

                  }
               } /*** end CALC_AREA check ***/


            if((CombinedCheckApplies(rpc->idn,checkinstance,ATTR_PAIR,rpc->Lindex,rpc->Sindex,Config1,Strat1,Domain1,
                                             &part1,&part2,&part3) > 0) && (part1 > 0))
               {
               if(CrsWlk[rpc->Lindex].AttrErr >= 0)
                  {
                  if(AttrErr[CrsWlk[rpc->Lindex].AttrErr].description[0] == '0') /*** then this is a ATTR_PAIR error **/
                     {
                     FwriteObjectAndMessage(ATTR_PAIR,Make_Correct(ATTR_PAIR,checkinstance),
                          rpc->idn, G_POINT,rpc->Lindex,rpc->localID, rpc->Sindex,-1.0,-1.0,
                          rpc->x, rpc->y, rpc->z,1,&AttrErr[CrsWlk[rpc->Lindex].AttrErr].description[1]);
                     }
                  if(CrsWlk[rpc->Lindex].MAE != NULL)
                     {
                     MAEc = CrsWlk[rpc->Lindex].MAE;
                     while(MAEc != NULL)
                        {
                        if(AttrErr[MAEc->index].description[0] == '0') /*** then this is a ATTR_PAIR error **/
                           {
                           FwriteObjectAndMessage(ATTR_PAIR,Make_Correct(ATTR_PAIR,checkinstance),
                                rpc->idn, G_POINT,rpc->Lindex,rpc->localID, rpc->Sindex,-1.0,-1.0,
                                rpc->x, rpc->y, rpc->z,1,&AttrErr[MAEc->index].description[1]);
                           }
                        MAEc = MAEc->next;
                        }
                     }
                  }
               }


            if((CombinedCheckApplies(rpc->idn,checkinstance,RPTD_ATTR,rpc->Lindex,rpc->Sindex,Config1,Strat1,Domain1,
                                             &part1,&part2,&part3) > 0) && (part1 > 0))
               {
               if(CrsWlk[rpc->Lindex].AttrErr >= 0)
                  {
                  keepit = 0;
                  if(ActiveChecks[checkinstance].clonenumber >= 0)
                     {
                     if(CloneErrorLookup[ActiveChecks[checkinstance].clonenumber].Annotation != NULL)
                        {
                        strcpy(Tstring,CloneErrorLookup[ActiveChecks[checkinstance].clonenumber].Annotation);
                        keepit = 1;
                        }
                     }
                  else
                     {
                     if(ErrorLookup[ActiveChecks[checkinstance].number].Annotation != NULL)
                        {
                        strcpy(Tstring,ErrorLookup[ActiveChecks[checkinstance].number].Annotation);
                        keepit = 1;
                        }
                     }
                  if(keepit > 0)
                     {
                     if(strstr(AttrErr[CrsWlk[rpc->Lindex].AttrErr].description, Tstring) != NULL)
                        {
                        FwriteObjectAndMessage(RPTD_ATTR,Make_Correct(RPTD_ATTR,checkinstance),
                             rpc->idn, G_POINT,rpc->Lindex,rpc->localID, rpc->Sindex,-1.0,-1.0,
                             rpc->x, rpc->y, rpc->z,1,&AttrErr[CrsWlk[rpc->Lindex].AttrErr].description[1]);
                        }
                     if(CrsWlk[rpc->Lindex].MAE != NULL)
                        {
                        MAEc = CrsWlk[rpc->Lindex].MAE;
                        while(MAEc != NULL)
                           {
                           if(strstr(AttrErr[MAEc->index].description, Tstring) != NULL) 
                              {
                              FwriteObjectAndMessage(RPTD_ATTR,Make_Correct(RPTD_ATTR,checkinstance),
                                   rpc->idn, G_POINT,rpc->Lindex,rpc->localID, rpc->Sindex,-1.0,-1.0,
                                   rpc->x, rpc->y, rpc->z,1,&AttrErr[MAEc->index].description[1]);
                              }
                           MAEc = MAEc->next;
                           }
                        }
                     }
                  }
               }


            if((CombinedCheckApplies(rpc->idn,checkinstance,ATTR_UNEXP,rpc->Lindex,rpc->Sindex,Config1,Strat1,Domain1,
                                             &part1,&part2,&part3) > 0) && (part1 > 0))
               {
               if(CrsWlk[rpc->Lindex].AttrErr >= 0)
                  {
                  if(AttrErr[CrsWlk[rpc->Lindex].AttrErr].description[0] == '1') /*** then this is a ATTR_UNEXP error **/
                     {
                     FwriteObjectAndMessage(ATTR_UNEXP,Make_Correct(ATTR_UNEXP,checkinstance),
                          rpc->idn, G_POINT,rpc->Lindex,rpc->localID, rpc->Sindex,-1.0,-1.0,
                          rpc->x, rpc->y, rpc->z,1,&AttrErr[CrsWlk[rpc->Lindex].AttrErr].description[1]);
                     }
                  if(CrsWlk[rpc->Lindex].MAE != NULL)
                     {
                     MAEc = CrsWlk[rpc->Lindex].MAE;
                     while(MAEc != NULL)
                        {
                        if(AttrErr[MAEc->index].description[0] == '1') /*** then this is a ATTR_UNEXP error **/
                           {
                           FwriteObjectAndMessage(ATTR_UNEXP,Make_Correct(ATTR_UNEXP,checkinstance),
                                rpc->idn, G_POINT,rpc->Lindex,rpc->localID, rpc->Sindex,-1.0,-1.0,
                                rpc->x, rpc->y, rpc->z,1,&AttrErr[MAEc->index].description[1]);
                           }
                        MAEc = MAEc->next;
                        }
                     }
                  }
               }


            if((CombinedCheckApplies(rpc->idn,checkinstance,ATTR_VVT,rpc->Lindex,rpc->Sindex,Config1,Strat1,Domain1,
                                             &part1,&part2,&part3) > 0) && (part1 > 0))
               {
               if(CrsWlk[rpc->Lindex].AttrErr >= 0)
                  {
                  if(AttrErr[CrsWlk[rpc->Lindex].AttrErr].description[0] == 'y') /*** then this is a ATTR_VVT error **/
                     {
                     FwriteObjectAndMessage(ATTR_VVT,Make_Correct(ATTR_VVT,checkinstance),
                          rpc->idn, G_POINT,rpc->Lindex,rpc->localID, rpc->Sindex,-1.0,-1.0,
                          rpc->x, rpc->y, rpc->z,1,&AttrErr[CrsWlk[rpc->Lindex].AttrErr].description[1]);
                     }
                  if(CrsWlk[rpc->Lindex].MAE != NULL)
                     {
                     MAEc = CrsWlk[rpc->Lindex].MAE;
                     while(MAEc != NULL)
                        {
                        if(AttrErr[MAEc->index].description[0] == 'y') /*** then this is a ATTR_VVT error **/
                           {
                           FwriteObjectAndMessage(ATTR_VVT,Make_Correct(ATTR_VVT,checkinstance),
                                rpc->idn, G_POINT,rpc->Lindex,rpc->localID, rpc->Sindex,-1.0,-1.0,
                                rpc->x, rpc->y, rpc->z,1,&AttrErr[MAEc->index].description[1]);
                           }
                        MAEc = MAEc->next;
                        }
                     }
                  if(AttrErr[CrsWlk[rpc->Lindex].AttrErr].description[0] == 'x') /*** then this is a ATTR_VVT error **/
                     {
                     FwriteObjectAndMessage(ATTR_VVT,Make_Correct(ATTR_VVT,checkinstance),
                          rpc->idn, G_POINT,rpc->Lindex,rpc->localID, rpc->Sindex,-1.0,-1.0,
                          rpc->x, rpc->y, rpc->z,1,&AttrErr[CrsWlk[rpc->Lindex].AttrErr].description[1]);
                     }
                  if(CrsWlk[rpc->Lindex].MAE != NULL)
                     {
                     MAEc = CrsWlk[rpc->Lindex].MAE;
                     while(MAEc != NULL)
                        {
                        if(AttrErr[MAEc->index].description[0] == 'x') /*** then this is a ATTR_VVT error **/
                           {
                           FwriteObjectAndMessage(ATTR_VVT,Make_Correct(ATTR_VVT,checkinstance),
                                rpc->idn, G_POINT,rpc->Lindex,rpc->localID, rpc->Sindex,-1.0,-1.0,
                                rpc->x, rpc->y, rpc->z,1,&AttrErr[MAEc->index].description[1]);
                           }
                        MAEc = MAEc->next;
                        }
                     }
                  }
               }

            if((CombinedCheckApplies(rpc->idn,checkinstance,ATTR_RNULL,rpc->Lindex,rpc->Sindex,Config1,Strat1,Domain1,
                                             &part1,&part2,&part3) > 0) && (part1 > 0))
               {
               if(CrsWlk[rpc->Lindex].AttrErr >= 0)
                  {
                  if(AttrErr[CrsWlk[rpc->Lindex].AttrErr].description[0] == '2') /*** then this is a ATTR_RNULL error **/
                     {
                     FwriteObjectAndMessage(ATTR_RNULL,Make_Correct(ATTR_RNULL,checkinstance),
                          rpc->idn, G_POINT,rpc->Lindex,rpc->localID, rpc->Sindex,-1.0,-1.0,
                          rpc->x, rpc->y, rpc->z,1,&AttrErr[CrsWlk[rpc->Lindex].AttrErr].description[1]);
                     }
                  if(CrsWlk[rpc->Lindex].MAE != NULL)
                     {
                     MAEc = CrsWlk[rpc->Lindex].MAE;
                     while(MAEc != NULL)
                        {
                        if(AttrErr[MAEc->index].description[0] == '2') /*** then this is a ATTR_RNULL error **/
                           {
                           FwriteObjectAndMessage(ATTR_RNULL,Make_Correct(ATTR_RNULL,checkinstance),
                                rpc->idn, G_POINT,rpc->Lindex,rpc->localID, rpc->Sindex,-1.0,-1.0,
                                rpc->x, rpc->y, rpc->z,1,&AttrErr[MAEc->index].description[1]);
                           }
                        MAEc = MAEc->next;
                        }
                     }
                  }
               }



            if((CombinedCheckApplies(rpc->idn,checkinstance,ATTR_MISSING,rpc->Lindex,rpc->Sindex,Config1,Strat1,Domain1,
                                             &part1,&part2,&part3) > 0) && (part1 > 0))
               {
               if(CrsWlk[rpc->Lindex].AttrErr >= 0)
                  {
                  if(AttrErr[CrsWlk[rpc->Lindex].AttrErr].description[0] == 'z') /*** then this is a ATTR_MISSING error **/
                     {
                     FwriteObjectAndMessage(ATTR_MISSING,Make_Correct(ATTR_MISSING,checkinstance),
                          rpc->idn, G_POINT,rpc->Lindex,rpc->localID, rpc->Sindex,-1.0,-1.0,
                          rpc->x, rpc->y, rpc->z,1,&AttrErr[CrsWlk[rpc->Lindex].AttrErr].description[1]);
                     }
                  if(CrsWlk[rpc->Lindex].MAE != NULL)
                     {
                     MAEc = CrsWlk[rpc->Lindex].MAE;
                     while(MAEc != NULL)
                        {
                        if(AttrErr[MAEc->index].description[0] == 'z') /*** then this is a ATTR_MISSING error **/
                           {
                           FwriteObjectAndMessage(ATTR_MISSING,Make_Correct(ATTR_MISSING,checkinstance),
                                rpc->idn, G_POINT,rpc->Lindex,rpc->localID, rpc->Sindex,-1.0,-1.0,
                                rpc->x, rpc->y, rpc->z,1,&AttrErr[MAEc->index].description[1]);
                           }
                        MAEc = MAEc->next;
                        }
                     }
                  }
               }


            if((CombinedCheckApplies(rpc->idn,checkinstance,ATTR_DT,rpc->Lindex,rpc->Sindex,Config1,Strat1,Domain1,
                                             &part1,&part2,&part3) > 0) && (part1 > 0))
               {
               if(CrsWlk[rpc->Lindex].AttrErr >= 0)
                  {
                  if(AttrErr[CrsWlk[rpc->Lindex].AttrErr].description[0] == '2') /*** then this is a ATTR_DT error **/
                     {
                     FwriteObjectAndMessage(ATTR_DT,Make_Correct(ATTR_DT,checkinstance),
                          rpc->idn, G_POINT,rpc->Lindex,rpc->localID, rpc->Sindex,-1.0,-1.0,
                          rpc->x, rpc->y, rpc->z,1,&AttrErr[CrsWlk[rpc->Lindex].AttrErr].description[1]);
                     }
                  if(CrsWlk[rpc->Lindex].MAE != NULL)
                     {
                     MAEc = CrsWlk[rpc->Lindex].MAE;
                     while(MAEc != NULL)
                        {
                        if(AttrErr[MAEc->index].description[0] == '2') /*** then this is a ATTR_DT error **/
                           {
                           FwriteObjectAndMessage(ATTR_DT,Make_Correct(ATTR_DT,checkinstance),
                                rpc->idn, G_POINT,rpc->Lindex,rpc->localID, rpc->Sindex,-1.0,-1.0,
                                rpc->x, rpc->y, rpc->z,1,&AttrErr[MAEc->index].description[1]);
                           }
                        MAEc = MAEc->next;
                        }
                     }
                  }
               }

            if((CombinedCheckApplies(rpc->idn,checkinstance,ATTR_RNG,rpc->Lindex,rpc->Sindex,Config1,Strat1,Domain1,
                                             &part1,&part2,&part3) > 0) && (part1 > 0))
               {
               if(CrsWlk[rpc->Lindex].AttrErr >= 0)
                  {
                  if(AttrErr[CrsWlk[rpc->Lindex].AttrErr].description[0] == '3') /*** then this is a ATTR_RNG error **/
                     {
                     FwriteObjectAndMessage(ATTR_RNG,Make_Correct(ATTR_RNG,checkinstance),
                          rpc->idn, G_POINT,rpc->Lindex,rpc->localID, rpc->Sindex,-1.0,-1.0,
                          rpc->x, rpc->y, rpc->z,1,&AttrErr[CrsWlk[rpc->Lindex].AttrErr].description[1]);
                     }
                  if(CrsWlk[rpc->Lindex].MAE != NULL)
                     {
                     MAEc = CrsWlk[rpc->Lindex].MAE;
                     while(MAEc != NULL)
                        {
                        if(AttrErr[MAEc->index].description[0] == '3') /*** then this is a ATTR_RNG error **/
                           {
                           FwriteObjectAndMessage(ATTR_RNG,Make_Correct(ATTR_RNG,checkinstance),
                                rpc->idn, G_POINT,rpc->Lindex,rpc->localID, rpc->Sindex,-1.0,-1.0,
                                rpc->x, rpc->y, rpc->z,1,&AttrErr[MAEc->index].description[1]);
                           }
                        MAEc = MAEc->next;
                        }
                     }
                  }
               }

            if((CombinedCheckApplies(rpc->idn,checkinstance,ATTR_PICK,rpc->Lindex,rpc->Sindex,Config1,Strat1,Domain1,
                                             &part1,&part2,&part3) > 0) && (part1 > 0))
               {
               if(CrsWlk[rpc->Lindex].AttrErr >= 0)
                  {
                  if(AttrErr[CrsWlk[rpc->Lindex].AttrErr].description[0] == '4') /*** then this is a ATTR_PICK error **/
                     {
                     FwriteObjectAndMessage(ATTR_PICK,Make_Correct(ATTR_PICK,checkinstance),
                          rpc->idn, G_POINT,rpc->Lindex,rpc->localID, rpc->Sindex,-1.0,-1.0,
                          rpc->x, rpc->y, rpc->z,1,&AttrErr[CrsWlk[rpc->Lindex].AttrErr].description[1]);
                     }
                  if(CrsWlk[rpc->Lindex].MAE != NULL)
                     {
                     MAEc = CrsWlk[rpc->Lindex].MAE;
                     while(MAEc != NULL)
                        {
                        if(AttrErr[MAEc->index].description[0] == '4') /*** then this is a ATTR_PICK error **/
                           {
                           FwriteObjectAndMessage(ATTR_PICK,Make_Correct(ATTR_PICK,checkinstance),
                                rpc->idn, G_POINT,rpc->Lindex,rpc->localID, rpc->Sindex,-1.0,-1.0,
                                rpc->x, rpc->y, rpc->z,1,&AttrErr[MAEc->index].description[1]);
                           }
                        MAEc = MAEc->next;
                        }
                     }
                  }
               }

            if((CombinedCheckApplies(rpc->idn,checkinstance,ATTR_META,rpc->Lindex,rpc->Sindex,Config1,Strat1,Domain1,
                                             &part1,&part2,&part3) > 0) && (part1 > 0))
               {
               if(CrsWlk[rpc->Lindex].AttrErr >= 0)
                  {
                  if(AttrErr[CrsWlk[rpc->Lindex].AttrErr].description[0] == ' ') /*** then this is a ATTR_META error **/
                     {
                     FwriteObjectAndMessage(ATTR_META,Make_Correct(ATTR_META,checkinstance),
                          rpc->idn, G_POINT,rpc->Lindex,rpc->localID, rpc->Sindex,-1.0,-1.0,
                          rpc->x, rpc->y, rpc->z,1,&AttrErr[CrsWlk[rpc->Lindex].AttrErr].description[1]);
                     }
                  if(CrsWlk[rpc->Lindex].MAE != NULL)
                     {
                     MAEc = CrsWlk[rpc->Lindex].MAE;
                     while(MAEc != NULL)
                        {
                        if(AttrErr[MAEc->index].description[0] == ' ') /*** then this is a ATTR_META error **/
                           {
                           FwriteObjectAndMessage(ATTR_META,Make_Correct(ATTR_META,checkinstance),
                                rpc->idn, G_POINT,rpc->Lindex,rpc->localID, rpc->Sindex,-1.0,-1.0,
                                rpc->x, rpc->y, rpc->z,1,&AttrErr[MAEc->index].description[1]);
                           }
                        MAEc = MAEc->next;
                        }
                     }
                  }
               }
            }

            if((rpc->numverts == -1) &&
                   (CombinedCheckApplies(rpc->idn,checkinstance,HIGHLIGHTED,rpc->Lindex,rpc->Sindex,Config1,Strat1,Domain1,
                                             &part1,&part2,&part3) > 0) && (part1 > 0))
               {
               k = AssignDrawingColor(rpc->idn, (unsigned char)Domain1, rpc->Lindex);
               if(k == HighLightColor)
                  {
                  ERc = (struct PointRelatedCollection *) (malloc(SzPRC));
                  if(ERc == NULL)
                     {
                     printf("allocation memory exhausted during point feature condition analysis\n");
                     printf("processing cannot continue\n");
                     exit(-1);
                     }
                  ERc->keyval = HIGHLIGHTED;
                  ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                  ERc->Sindex1 = rpc->Sindex;
                  ERc->IDN1 = rpc->idn;
                  ERc->pt1 = rpc;
                  ERc->x1[0] = rpc->x[0];
                  ERc->y1[0] = rpc->y[0];
                  ERc->z1[0] = rpc->z[0];
                  ERc->next = NULL;
                  if(ERroot == NULL)
                     {
                     ERroot = ERc;
                     }
                  else
                    {
                      ERn = ERroot;
                      while(ERn != NULL)
                        {
                        if((ERn->Cnumber  == ERc->Cnumber)  && (ERn->keyval  == ERc->keyval) && (ERn->pt1 == ERc->pt1))
                           {
                           break;
                           }
                        ERn = ERn->next;
                        }
                     if(ERn == NULL)
                        {
                        ERc->next = ERroot;
                        ERroot = ERc;
                        }
                     else
                        {
                        free(ERc);
                        }
                     }
                  }
               }



         if((rpc->numverts == -1) && /*** rpc is a pure point ***/
              (CombinedCheckApplies(rpc->idn,checkinstance,VVTERR1WAY,rpc->Lindex,rpc->Sindex,Config1,Strat1,Domain1,&part1,&part2,&part3) > 0) &&
               (part1 > 0))
            {
            ERc = (struct PointRelatedCollection *) (malloc(SzPRC));
            if(ERc == NULL)
               {
               printf("allocation memory exhausted during point feature condition analysis\n");
               printf("processing cannot continue\n");
               exit(-1);
               }
            ERc->keyval = VVTERR1WAY;
            ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
            ERc->Sindex1 = rpc->Sindex;
            ERc->IDN1 = rpc->idn;
            ERc->pt1 = rpc;
            ERc->next = NULL;
            if(ERroot == NULL)
               {
               ERroot = ERc;
               }
            else
              {
                ERn = ERroot;
                while(ERn != NULL)
                  {
                  if((ERn->Cnumber  == ERc->Cnumber)  && (ERn->keyval  == ERc->keyval) && (ERn->pt1 == ERc->pt1))
                     {
                     break;
                     }
                  ERn = ERn->next;
                  }
               if(ERn == NULL)
                  {
                  ERc->next = ERroot;
                  ERroot = ERc;
                  }
               else
                  {
                  free(ERc);
                  }
               }
            } /*** end VVTERR1WAY check ***/



         if((rpc->numverts == -1) && /*** rpc is a pure point ***/
              (CombinedCheckApplies(rpc->idn,checkinstance,VVTERR2WAY,rpc->Lindex,rpc->Sindex,Config1,Strat1,Domain1,&part1,&part2,&part3) > 0) &&
               (part1 > 0) && (part2 > 0))
            {
            ERc = (struct PointRelatedCollection *) (malloc(SzPRC));
            if(ERc == NULL)
               {
               printf("allocation memory exhausted during point feature condition analysis\n");
               printf("processing cannot continue\n");
               exit(-1);
               }
            ERc->keyval = VVTERR2WAY;
            ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
            ERc->Sindex1 = rpc->Sindex;
            ERc->IDN1 = rpc->idn;
            ERc->pt1 = rpc;
            ERc->next = NULL;
            if(ERroot == NULL)
               {
               ERroot = ERc;
               }
            else
              {
                ERn = ERroot;
                while(ERn != NULL)
                  {
                  if((ERn->Cnumber  == ERc->Cnumber)  && (ERn->keyval  == ERc->keyval) && (ERn->pt1 == ERc->pt1))
                     {
                     break;
                     }
                  ERn = ERn->next;
                  }
               if(ERn == NULL)
                  {
                  ERc->next = ERroot;
                  ERroot = ERc;
                  }
               else
                  {
                  free(ERc);
                  }
               }
            } /*** end VVTERR2WAY check ***/


         if((rpc->numverts == -1) && /*** rpc is a pure point ***/
              (CombinedCheckApplies(rpc->idn,checkinstance,VVTERR3WAY,rpc->Lindex,rpc->Sindex,Config1,Strat1,Domain1,&part1,&part2,&part3) > 0) &&
               (part1 > 0) && (part2 > 0) && (part3 > 0))
            {
            ERc = (struct PointRelatedCollection *) (malloc(SzPRC));
            if(ERc == NULL) 
               {
               printf("allocation memory exhausted during point feature condition analysis\n");
               printf("processing cannot continue\n");
               exit(-1);
               }
            ERc->keyval = VVTERR3WAY;
            ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
            ERc->Sindex1 = rpc->Sindex;
            ERc->IDN1 = rpc->idn;
            ERc->pt1 = rpc;
            ERc->next = NULL;
            if(ERroot == NULL) 
               {
               ERroot = ERc;
               }
            else
              {
                ERn = ERroot;
                while(ERn != NULL) 
                  {
                  if((ERn->Cnumber  == ERc->Cnumber)  && (ERn->keyval  == ERc->keyval) && (ERn->pt1 == ERc->pt1))
                     {        
                     break;   
                     }        
                  ERn = ERn->next;
                  }
               if(ERn == NULL) 
                  {
                  ERc->next = ERroot;
                  ERroot = ERc;
                  }        
               else
                  {        
                  free(ERc);
                  }
               }
            } /*** end VVTERR3WAY check ***/



         if((rpc->numverts == -1) &&
            (CombinedCheckApplies(rpc->idn,checkinstance,LLNONODEINT,rpc->Lindex,rpc->Sindex,Config1,Strat1,Domain1,&part1,&part2,&part3) > 0))
            {
            if(part1 > 0)
               {
               temptolerance = FindRelevantSensitivity(LLNONODEINT,checkinstance,&unuseddbl);
               rlc = Lroot;
               while(rlc != NULL)
                  {
                  if(CombinedCheckApplies(rlc->idn,checkinstance,LLNONODEINT,rlc->Lindex,rlc->Sindex,
                        SCCtable[rlc->Sindex].C,SCCtable[rlc->Sindex].S,SCCtable[rlc->Sindex].D,&part1,&part2,&part3) > 0)
                     {
                     if(part2 > 0)
                        {
                        for(j=1; j<rlc->numnodes; j++)
                           {
                           jj = j - 1;
                           X2[0] = rlc->x[jj];
                           Y2[0] = rlc->y[jj];
                           Z2[0] = rlc->z[jj];
                           X2[1] = rlc->x[j];
                           Y2[1] = rlc->y[j];
                           Z2[1] = rlc->z[j];
                           if(ClipLineToRegion(minx,miny,maxx,maxy,&X2[0],&Y2[0],&Z2[0],&X2[1],&Y2[1],&Z2[1],&clipflag,multiplier) > 0)
                              {
                              keepit = 0;
                              ptldist = PointToLineDist2D(rpc->x[0],rpc->y[0],rlc->x[jj],rlc->y[jj],rlc->x[j],rlc->y[j]);
                              if(ptldist <= temptolerance)
                                 {
                                 keepit = 1;
                                 if(EqualWithinTolerance(rpc->x[0],rpc->y[0],rlc->x[jj],rlc->y[jj],temptolerance) > 0)
                                    {
                                    keepit = 0;
                                    }
                                 else if(EqualWithinTolerance(rpc->x[0],rpc->y[0],rlc->x[j],rlc->y[j],temptolerance) > 0)
                                    {
                                    keepit = 0;
                                    }
                                 }
                              if(keepit > 0)
                                 {
                                 keepit = RemoveByContainmentOrCoincidence(rpc->x[0],rpc->y[0], Lroot, checkinstance,
                                              LLNONODEINT, minx, miny, maxx, maxy, temptolerance,
                                              Aroot, root);
                                 }
                              if(keepit > 0)
                                 {
                                 ERc = (struct PointRelatedCollection *) (malloc(SzPRC));
                                 if(ERc == NULL)
                                    {
                                    printf("allocation memory exhausted during linear feature condition analysis\n");
                                    printf("processing cannot continue\n");
                                    exit(-1);
                                    }
                                 ERc->x1[0] = rpc->x[0];
                                 ERc->y1[0] = rpc->y[0];
                                 ERc->z1[0] = rpc->z[0];
                                 ERc->x1[1] = rlc->x[jj];
                                 ERc->y1[1] = rlc->y[jj];
                                 ERc->z1[1] = rlc->z[jj];
                                 ERc->x1[2] = rlc->x[j];
                                 ERc->y1[2] = rlc->y[j];
                                 ERc->z1[2] = rlc->z[j];
                                 ERc->magnitude = 0.0;
                                 ERc->keyval = LLNONODEINT;
                                 ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                                 ERc->IDN1 = rpc->idn;
                                 ERc->Sindex1 = rpc->Sindex;
                                 ERc->ll = rlc;
                                 ERc->pt1 = rpc;
                                 ERc->pt2 = NULL;
                                 ERc->aa = NULL;
                                 ERc->next = NULL;
                                 if(ERroot == NULL)
                                    {
                                    ERroot = ERc;
                                    }
                                 else
                                    {
                                    ERn = ERroot;
                                    while(ERn != NULL)
                                       {
                                       if((ERn->Cnumber == ERc->Cnumber) && (ERn->keyval == ERc->keyval) &&
                                            (ERn->x1[0] == ERc->x1[0]) && (ERn->y1[0] == ERc->y1[0]) &&
                                            ((ERn->pt1 == ERc->pt1) && (ERn->ll == ERc->ll))) 
                                          break;

                                       ERn = ERn->next;
                                       }
                                    if(ERn == NULL)
                                       {
                                       ERc->next = ERroot;
                                       ERroot = ERc;
                                       }
                                    else
                                      free(ERc);
                                   }
                                 }
                              }
                           }
                        }
                     }
                  rlc = rlc->next;
                  }

               npc = rpc->next;
               while(npc != NULL)
                  {
                  if((npc->numverts == -1) &&
                   (CombinedCheckApplies(npc->idn,checkinstance,LLNONODEINT,npc->Lindex,npc->Sindex,
                           SCCtable[npc->Sindex].C,SCCtable[npc->Sindex].S,SCCtable[npc->Sindex].D,&part1,&part2,&part3) > 0))
                     {
                     if(part2 > 0)
                        {
                        ptldist = Distance3D(rpc->x[0],rpc->y[0],rpc->z[0], npc->x[0],npc->y[0],npc->z[0]);
                        if(ptldist <= temptolerance)
                           {
                           keepit = 1;
                           if(EqualWithinTolerance(rpc->x[0],rpc->y[0],npc->x[0],npc->y[0],temptolerance) > 0)
                              {
                              keepit = 0;
                              }

                           if(keepit > 0)
                              {
                              keepit = RemoveByContainmentOrCoincidence(rpc->x[0], rpc->y[0], Lroot, checkinstance,
                                           LLNONODEINT, minx, miny, maxx, maxy, temptolerance,
                                           Aroot, root);
                              }

                           if(keepit > 0)
                              {

                              ERc = (struct PointRelatedCollection *) (malloc(SzPRC));
                              if(ERc == NULL)
                                 {
                                 printf("allocation memory exhausted during linear feature condition analysis\n");
                                 printf("processing cannot continue\n");
                                 exit(-1);
                                 }
                              ERc->x1[0] = rpc->x[0];
                              ERc->y1[0] = rpc->y[0];
                              ERc->z1[0] = rpc->z[0];
                              ERc->x1[1] = npc->x[0];
                              ERc->y1[1] = npc->x[0];
                              ERc->z1[1] = npc->x[0];
                              ERc->magnitude = 0.0;
                              ERc->keyval = LLNONODEINT;
                              ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                              ERc->IDN1 = rpc->idn;
                              ERc->Sindex1 = rpc->Sindex;
                              ERc->ll = NULL;
                              ERc->aa = NULL;
                              ERc->pt1 = rpc;
                              ERc->pt2 = npc;
                              ERc->next = NULL;
                              if(ERroot == NULL)
                                 {
                                 ERroot = ERc;
                                 }
                              else
                                 {
                                 ERn = ERroot;
                                 while(ERn != NULL)
                                    {
                                      if((ERn->Cnumber == ERc->Cnumber) && (ERn->keyval == ERc->keyval) &&
                                         (ERn->x1[0] == ERc->x1[0]) && (ERn->y1[0] == ERc->y1[0]) &&
                                         (((ERn->pt1 == ERc->pt1) && (ERn->pt2 == ERc->pt2)) || 
                                           ((ERn->pt2 == ERc->pt1) && (ERn->pt1 == ERc->pt2))))
                                       break;

                                    ERn = ERn->next;
                                    }
                                 if(ERn == NULL)
                                    {
                                    ERc->next = ERroot;
                                    ERroot = ERc;
                                    }
                                 else
                                   free(ERc);
                                }
                              }
                           }
                        }
                     }
                  npc = npc->next;
                  }

               rac = Aroot;
               while(rac != NULL)
                  {
                  if(CombinedCheckApplies(rac->idn,checkinstance,LLNONODEINT,rac->Lindex,rac->Sindex,
                             SCCtable[rac->Sindex].C,SCCtable[rac->Sindex].S,SCCtable[rac->Sindex].D,&part1,&part2,&part3) > 0)
                     {
                     if(part2 > 0)
                        {
                        if(rac->RB_Tree_Edgelist == NULL)
                           {
                           for(j=0; j<rac->numverts; j++)
                              {
                              if(j == 0)
                                 jj = rac->numverts - 1;
                              else
                                 jj = j - 1;
                              X2[0] = rac->x[jj];
                              Y2[0] = rac->y[jj];
                              Z2[0] = rac->z[jj];
                              X2[1] = rac->x[j];
                              Y2[1] = rac->y[j];
                              Z2[1] = rac->z[j];
                              if(ClipLineToRegion(minx,miny,maxx,maxy,&X2[0],&Y2[0],&Z2[0],&X2[1],&Y2[1],&Z2[1],&clipflag,multiplier) > 0)
                                 {
                                 ptldist = PointToLineDist2D(rpc->x[0],rpc->y[0],rac->x[jj],rac->y[jj],rac->x[j],rac->y[j]);
                                 if(ptldist <= temptolerance)
                                    {
                                    keepit = 1;
                                    if(EqualWithinTolerance(rpc->x[0],rpc->y[0],rac->x[jj],rac->y[jj],temptolerance) > 0)
                                       {
                                       keepit = 0;
                                       }
                                    else if(EqualWithinTolerance(rpc->x[0],rpc->y[0],rac->x[j],rac->y[j],temptolerance) > 0)
                                       {
                                       keepit = 0;
                                       }

                                    
                                    if(keepit > 0)
                                       {
                                       keepit = RemoveByContainmentOrCoincidence(rpc->x[0], rpc->y[0], Lroot, checkinstance,
                                              LLNONODEINT, minx, miny, maxx, maxy, temptolerance,
                                              Aroot, root);
                                       }
                                    if(keepit > 0)
                                       {

                                       ERc = (struct PointRelatedCollection *) (malloc(SzPRC));
                                       if(ERc == NULL)
                                          {
                                          printf("allocation memory exhausted during linear feature condition analysis\n");
                                          printf("processing cannot continue\n");
                                          exit(-1);
                                          }
                                       ERc->x1[0] = rpc->x[0];
                                       ERc->y1[0] = rpc->y[0];
                                       ERc->z1[0] = rpc->z[0];
                                       if(jj == rac->numverts - 1)
                                          {
                                          ERc->x1[2] = rac->x[0];
                                          ERc->y1[2] = rac->y[0];
                                          ERc->z1[2] = rac->z[0];
                                          ERc->x1[1] = rac->x[rac->numverts - 1];
                                          ERc->y1[1] = rac->y[rac->numverts - 1];
                                          ERc->z1[1] = rac->z[rac->numverts - 1];
                                          }
                                       else
                                          {
                                          ERc->x1[2] = rac->x[jj];
                                          ERc->y1[2] = rac->y[jj];
                                          ERc->z1[2] = rac->z[jj];
                                          ERc->x1[1] = rac->x[j];
                                          ERc->y1[1] = rac->y[j];
                                          ERc->z1[1] = rac->z[j];
                                          }

                                       ERc->magnitude = 0.0;
                                       ERc->keyval = LLNONODEINT;
                                       ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                                       ERc->IDN1 = rpc->idn;
                                       ERc->Sindex1 = rpc->Sindex;
                                       ERc->ll = NULL;
                                       ERc->pt1 = rpc;
                                       ERc->pt2 = NULL;
                                       ERc->aa = rac;
                                       ERc->next = NULL;
                                       if(ERroot == NULL)
                                          {
                                          ERroot = ERc;
                                          }
                                       else
                                          {
                                          ERn = ERroot;
                                          while(ERn != NULL)
                                             {
                                               if((ERn->Cnumber == ERc->Cnumber) && (ERn->keyval == ERc->keyval) &&
                                                  (ERn->x1[0] == ERc->x1[0]) && (ERn->y1[0] == ERc->y1[0]) &&
                                                      (ERn->pt1 == ERc->pt1) && (ERn->aa == ERc->aa))
                                                break;

                                             ERn = ERn->next;
                                             }
                                          if(ERn == NULL)
                                             {
                                             ERc->next = ERroot;
                                             ERroot = ERc;
                                             }
                                          else
                                            free(ERc);
                                         }
                                       }
                                    }
                                 }
                              }
                           }
                        else 
                           {
                           LastEdge = NULL;
                           LastI = -1;
                           j = GetNextArealIndex(rac, LastI, 1, &LastEdge, cindex, &unusedint);
                           LastI = j;
                           while(j >= 0)
                              {
                              if(j == 0)
                                 jj = rac->numverts - 1;
                              else
                                 jj = j - 1;
                              ptldist = PointToLineDist2D(rpc->x[0],rpc->y[0],rac->x[jj],rac->y[jj],rac->x[j],rac->y[j]);
                              if(ptldist <= temptolerance)
                                 {
                                 keepit = 1;
                                 if(EqualWithinTolerance(rpc->x[0],rpc->y[0],rac->x[jj],rac->y[jj],temptolerance) > 0)
                                    {
                                    keepit = 0;
                                    }
                                 else if(EqualWithinTolerance(rpc->x[0],rpc->y[0],rac->x[j],rac->y[j],temptolerance) > 0)
                                    {
                                    keepit = 0;
                                    }

                                 if(keepit > 0)
                                    {
                                    keepit = RemoveByContainmentOrCoincidence(rpc->x[0], rpc->y[0], Lroot, checkinstance,
                                           LLNONODEINT, minx, miny, maxx, maxy, temptolerance,
                                           Aroot, root);
                                    }

                                 if(keepit > 0)
                                    {
                                    ERc = (struct PointRelatedCollection *) (malloc(SzPRC));
                                    if(ERc == NULL)
                                       {
                                       printf("allocation memory exhausted during linear feature condition analysis\n");
                                       printf("processing cannot continue\n");
                                       exit(-1);
                                       }
                                    ERc->x1[0] = rpc->x[0];
                                    ERc->y1[0] = rpc->y[0];
                                    ERc->z1[0] = rpc->z[0];
                                    if(jj == rac->numverts - 1)
                                       {
                                       ERc->x1[2] = rac->x[0];
                                       ERc->y1[2] = rac->y[0];
                                       ERc->z1[2] = rac->z[0];
                                       ERc->x1[1] = rac->x[rac->numverts - 1];
                                       ERc->y1[1] = rac->y[rac->numverts - 1];
                                       ERc->z1[1] = rac->z[rac->numverts - 1];
                                       }
                                    else
                                       {
                                       ERc->x1[2] = rac->x[jj];
                                       ERc->y1[2] = rac->y[jj];
                                       ERc->z1[2] = rac->z[jj];
                                       ERc->x1[1] = rac->x[j];
                                       ERc->y1[1] = rac->y[j];
                                       ERc->z1[1] = rac->z[j];
                                       }
                                    ERc->magnitude = 0.0;
                                    ERc->keyval = LLNONODEINT;
                                    ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                                    ERc->IDN1 = rpc->idn;
                                    ERc->Sindex1 = rpc->Sindex;
                                    ERc->pt1 = rpc;
                                    ERc->ll = NULL;
                                    ERc->pt2 = NULL;
                                    ERc->aa = rac;
                                    ERc->next = NULL;
                                    if(ERroot == NULL)
                                       {
                                       ERroot = ERc;
                                       }
                                    else
                                       {
                                       ERn = ERroot;
                                       while(ERn != NULL)
                                          {
                                            if((ERn->Cnumber == ERc->Cnumber) && (ERn->keyval == ERc->keyval) &&
                                               (ERn->x1[0] == ERc->x1[0]) && (ERn->y1[0] == ERc->y1[0]) &&
                                               (ERn->pt1 == ERc->pt1) && (ERn->aa == ERc->aa))
                                             break;

                                          ERn = ERn->next;
                                          }
                                       if(ERn == NULL)
                                          {
                                          ERc->next = ERroot;
                                          ERroot = ERc;
                                          }
                                       else
                                         free(ERc);
                                      }
                                    } /*** end need to record a condition ***/
                                 } /*** end line segments do intersect ***/

                              j = GetNextArealIndex(rac, LastI, 1, &LastEdge, cindex, &unusedint);
                              LastI = j;
                              } /*** end have another large area segment to get ***/
                           }
                        }
                     }
                  rac = rac->next;
                  }


               } /*** end if check applies to rpc as part1 ***/
            }




         if((rpc->numverts == -1) && /*** rpc is a pure point ***/
             (CombinedCheckApplies(rpc->idn,checkinstance,PTPTPROX,rpc->Lindex,rpc->Sindex,Config1,Strat1,Domain1,&part1,&part2,&part3) > 0) &&
                     (part1 > 0))
            {
            npc = root;
            while(npc != NULL)
               {
               Config2 = SCCtable[npc->Sindex].C;
               Strat2 = SCCtable[npc->Sindex].S;
               Domain2 = SCCtable[npc->Sindex].D;
               if((npc != rpc) && (npc->numverts == -1) && /** npc is a pure point ***/
                   (CombinedCheckApplies(npc->idn,checkinstance,PTPTPROX,npc->Lindex,npc->Sindex,Config2,Strat2,Domain2,&part1,&part2,&part3) > 0) &&
                    (part2 > 0))
                  {
                  ptldist = Distance(rpc->x[0],rpc->y[0],npc->x[0],npc->y[0]);
                  if(SensitivityCheck(LTEQ, PTPTPROX, checkinstance, ptldist) > 0)
               /***if(ptldist <= ErrorLookup[PTPTPROX].sensitivity)***/
                     {
                     ERc = (struct PointRelatedCollection *) (malloc(SzPRC));
                     if(ERc == NULL)
                        {
                        printf("allocation memory exhausted during point feature condition analysis\n");
                        printf("processing cannot continue\n");
                        exit(-1);
                        }
                     ERc->x1[0] = rpc->x[0];
                     ERc->y1[0] = rpc->y[0];
                     ERc->z1[0] = rpc->z[0];
                     ERc->x1[1] = npc->x[0];
                     ERc->y1[1] = npc->y[0];
                     ERc->z1[1] = npc->z[0];
                     ERc->magnitude = ptldist;
                     ERc->keyval = PTPTPROX;
                     ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                     ERc->Sindex1 = rpc->Sindex;
                     ERc->IDN1 = rpc->idn;
                     ERc->Sindex2 = npc->Sindex;
                     ERc->IDN2 = npc->idn;
                     ERc->pt1 = rpc;
                     ERc->pt2 = npc;
                     ERc->next = NULL;
                     if(ERroot == NULL)
                        {
                        ERroot = ERc;
                        }
                     else
		       {
			 ERn = ERroot;
			 while(ERn != NULL)
                           {
			     if((ERn->Cnumber == ERc->Cnumber) && (ERn->keyval == ERc->keyval))  
                                {
                                if((ERn->x1[0] == ERc->x1[0]) && (ERn->y1[0] == ERc->y1[0]) && (ERn->Sindex1 == ERc->Sindex1))
			          {
				  if((ERn->x1[1] == ERc->x1[1]) && (ERn->y1[1] == ERc->y1[1]))
				     break;
                                  }
                               else if((ERn->x1[1] == ERc->x1[0]) && (ERn->y1[1] == ERc->y1[0]) && (ERn->Sindex2 == ERc->Sindex1))
                                  {
                                  if((ERn->x1[0] == ERc->x1[1]) && (ERn->y1[0] == ERc->y1[1]))
                                     break;
                                  }
			       }
			     ERn = ERn->next;
                           }
                        if(ERn == NULL)
                           {
                           ERc->next = ERroot;
                           ERroot = ERc;
                           }
                        else
		           {
			   free(ERc);
			   }
                        }
                     }  
                  }
               npc = npc->next;
               } /*** end while npc for this load module ***/

            temptolerance = FindRelevantSensitivity(PTPTPROX,checkinstance,&unuseddbl);
            ptldist = Distance(rpc->x[0], rpc->y[0], rpc->x[0]+temptolerance, rpc->y[0]);
            xi = (temptolerance * temptolerance) / ptldist;
            ptldist = Distance(rpc->x[0], rpc->y[0], rpc->x[0], rpc->y[0]+temptolerance);
            yi = (temptolerance * temptolerance) / ptldist;

            li = (int) ((rpc->x[0] - xi) / RegionSize);
            ui = (int) ((rpc->x[0] + xi) / RegionSize);
            lj = (int) ((rpc->y[0] - yi) / RegionSize);
            uj = (int) ((rpc->y[0] + yi) / RegionSize);

            if(li < 0)   li = 0;
            if(lj < 0)   lj = 0;
            if(ui > MaxXindex)     ui = MaxXindex;
            if(uj > MaxYindex)     uj = MaxYindex;

            LookForFeature = 0;

            for(index1 = li; index1 <= ui; index1++)
               {
               LookForFeature = 0;
               for(index2 = lj; index2 <= uj; index2++)
                  {
                  thisindex = (index1 * (MaxYindex + 1)) + index2;
                  LookForFeature = 0;
                  FLindex = -1;
                  if(thisindex != cindex)
                     {
                     for(k=0; k<LindexTable[thisindex].inside; k++)
                        {
                        LookForFeature = 0;
                        FLindex =  LindexTable[thisindex].indices[k];
                        /***if((CrsWlk[FLindex].geomtype == C_LINE) || (CrsWlk[FLindex].geomtype == C_AREA))***/
                        if(CrsWlk[FLindex].geomtype == C_POFE)
                           {
                           FSindex = CrsWlk[FLindex].LtoSmapping;
                           if(ActiveChecks[checkinstance].number == PTPTPROX)
                              {
                              if(ActiveChecks[checkinstance].secondaryEDCSstuff != NULL)
                                 {
                                 if(ActiveChecks[checkinstance].secondaryEDCSstuff[FLindex] == 1)
                                    {
                                    LookForFeature = 1;
                                    break;
                                    }
                                 else if((ActiveChecks[checkinstance].Config2[SCCtable[FSindex].C] == 1) &&
                                        (ActiveChecks[checkinstance].Stratum2[SCCtable[FSindex].S] == 1) &&
                                        (ActiveChecks[checkinstance].Domain2[SCCtable[FSindex].D] == 1) &&
                                        (ActiveChecks[checkinstance].secondaryEDCSstuff[FLindex] != 2))
                                    {
                                    LookForFeature = 1;
                                    break;
                                    }
                                 }
                              else if((ActiveChecks[checkinstance].Config2[SCCtable[FSindex].C] == 1) &&
                                     (ActiveChecks[checkinstance].Stratum2[SCCtable[FSindex].S] == 1) &&
                                     (ActiveChecks[checkinstance].Domain2[SCCtable[FSindex].D] == 1))
                                 {
                                 LookForFeature = 1;
                                 break;
                                 }
                              }
                           } /*** end CrsWlk says this Lindex is a point ***/
                        if(LookForFeature > 0)
                           break;
                        } /*** end for k ***/
                     } /** end thisindex != cindex ***/
                  if(LookForFeature > 0)
                     break;
                  } /*** end for index2 ***/
               if(LookForFeature > 0)
                  break;
               } /*** end for index1 ***/

            if((LookForFeature > 0) && (FLindex >= 0))
               {
               if((P_NeighborsLoaded == 0) && (CrsWlk[FLindex].geomtype == C_POFE))
                  {
                  P_NeighborsLoaded = 1;
                  FindApplicableNeighborFeatures(cindex, ptsin, minx, maxx, miny, maxy, 0, 0 , 1, 0);
                  }

               npc = TgtProot;
               while(npc != NULL)
                  {
                  Config2 = SCCtable[npc->Sindex].C;
                  Strat2 = SCCtable[npc->Sindex].S;
                  Domain2 = SCCtable[npc->Sindex].D;
                  if((npc != rpc) && (npc->numverts == -1) && /** npc is a pure point ***/
                   (CombinedCheckApplies(npc->idn,checkinstance,PTPTPROX,npc->Lindex,npc->Sindex,Config2,Strat2,Domain2,&part1,&part2,&part3) > 0) &&
                       (part2 > 0))
                     {
                     ptldist = Distance(rpc->x[0],rpc->y[0],npc->x[0],npc->y[0]);
                     if(SensitivityCheck(LTEQ, PTPTPROX, checkinstance, ptldist) > 0)
                        {
                        ERc = (struct PointRelatedCollection *) (malloc(SzPRC));
                        if(ERc == NULL)
                           {
                           printf("allocation memory exhausted during point feature condition analysis\n");
                           printf("processing cannot continue\n");
                           exit(-1);
                           }
                        ERc->x1[0] = rpc->x[0];
                        ERc->y1[0] = rpc->y[0];
                        ERc->z1[0] = rpc->z[0];
                        ERc->x1[1] = npc->x[0];
                        ERc->y1[1] = npc->y[0];
                        ERc->z1[1] = npc->z[0];
                        ERc->magnitude = ptldist;
                        ERc->keyval = PTPTPROX;
                        ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                        ERc->Sindex1 = rpc->Sindex;
                        ERc->IDN1 = rpc->idn;
                        ERc->Sindex2 = npc->Sindex;
                        ERc->IDN2 = npc->idn;
                        ERc->pt1 = rpc;
                        ERc->pt2 = npc;
                        ERc->next = NULL;
                        if(ERroot == NULL)
                           {
                           ERroot = ERc;
                           }
                        else
                          {
                            ERn = ERroot;
                            while(ERn != NULL)
                              {
                                if((ERn->Cnumber == ERc->Cnumber) && (ERn->keyval == ERc->keyval))   
                                   {
                                   if((ERn->x1[0] == ERc->x1[0]) && (ERn->y1[0] == ERc->y1[0]) && (ERn->Sindex1 == ERc->Sindex1))
                                     {
                                     if((ERn->x1[1] == ERc->x1[1]) && (ERn->y1[1] == ERc->y1[1]))
                                        break;
                                     }
                                  else if((ERn->x1[1] == ERc->x1[0]) && (ERn->y1[1] == ERc->y1[0]) && (ERn->Sindex2 == ERc->Sindex1))
                                     {
                                     if((ERn->x1[0] == ERc->x1[1]) && (ERn->y1[0] == ERc->y1[1]))
                                        break;
                                     }
                                  }
                                ERn = ERn->next;
                              }
                           if(ERn == NULL)
                              {
                              ERc->next = ERroot;
                              ERroot = ERc;
                              }
                           else
                              {
                              free(ERc);
                              }
                           }
                        }
                     }
                  npc = npc->next;
                  } /**** end while npc for other load modules ***/
               } /*** end if LookForFeature > 0  ***/
            } /*** end PTPTPROX ***/




         if(rpc->numverts == -1) /** is a pure point **/
            {

            if((CombinedCheckApplies(rpc->idn,checkinstance,POVERSHTA,rpc->Lindex,rpc->Sindex,Config1,Strat1,Domain1,&part1,&part2,&part3) > 0) &&
                            (part1 > 0))
               {
               inside = 0;
               arealobj = NULL;
               rac = Aroot;  /** now look at point inside area feature **/
               j = 0; 
               while(rac != NULL)
                  {
                  Config2 = SCCtable[rac->Sindex].C;
                  Strat2 = SCCtable[rac->Sindex].S;
                  Domain2 = SCCtable[rac->Sindex].D;
                  inside = 0;
                  if((CombinedCheckApplies(rac->idn,checkinstance,POVERSHTA,rac->Lindex,rac->Sindex,Config2,Strat2,Domain2,&part1,&part2,&part3) > 0)
                          && (part2 > 0))
                     {
                     if(rac->ishole <= 0)
                        {
                        if(rac->RB_Tree_Edgelist == NULL)
                           ptldist = PointToSmallArealDist2D(rpc->x[j], rpc->y[j],rac,&kindex,&unuseddbl);
                        else
                           ptldist = PointToLargeArealDist2D(rpc->x[j], rpc->y[j],rac,&kindex,&unuseddbl);
                        if((ptldist > 0.0) && (SensitivityCheck(LTEQ, POVERSHTA, checkinstance, ptldist) > 0))
                           {
                           if(PointIsInside(rpc->x[0],rpc->y[0],rac->x,rac->y,rac->x,rac->numverts,(unsigned char) Config1,&unuseddbl))
                              {
                              raHole = Aroot;
                              while(raHole != NULL)
                                 {
                                 if((raHole->ishole > 0) && (raHole->idn == rac->idn))
                                    {
                                    if(PointIsInside(rpc->x[0],rpc->y[0],raHole->x,raHole->y,raHole->x,raHole->numverts,(unsigned char) Config1,&unuseddbl))
                                       {
                                       break;
                                       }
                                    }
                                 raHole = raHole->next;
                                 }
                              if(raHole == NULL)
                                 ++inside;
                              }
                           }
                        }
                     }
                  if(inside > 0)
                     {
                     arealobj = rac;
                     break;
                     }
                  rac = rac->next;
                  }

               if(arealobj != NULL)  /** found the point to be inside a region (poly or areal) **/
                  {
                  ERc = (struct PointRelatedCollection *) (malloc(SzPRC));

                  if(ERc == NULL)
                     {
                     printf("allocation memory exhausted during point feature condition analysis\n");
                     printf("processing cannot continue\n");
                     exit(-1);
                     }
                  ERc->x1[0] = rpc->x[0];
                  ERc->y1[0] = rpc->y[0];
                  ERc->z1[0] = rpc->z[0];
                  ERc->pt1 = rpc;
                  ERc->numverts1 = 1;
                  ERc->magnitude = ptldist;
                  ERc->keyval = POVERSHTA;
                  ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                  ERc->Sindex1 = rpc->Sindex;
                  ERc->IDN1 = rpc->idn;
                  ERc->Sindex2 = arealobj->Sindex;
                  ERc->IDN2 = arealobj->idn;
                  ERc->ll = NULL;
                  ERc->pp = NULL;
                  ERc->aa = arealobj;
                  ERc->next = NULL;
                  if(ERroot == NULL)
                     {
                     kk = (kindex + arealobj->numverts - 1) % arealobj->numverts;
                     k = (kindex + 1) % arealobj->numverts;
                     mindist = PointToLineDist2D(rpc->x[0], rpc->y[0], arealobj->x[kk],arealobj->y[kk],arealobj->x[kindex],arealobj->y[kindex]);
                     ptldist = PointToLineDist2D(rpc->x[0], rpc->y[0], arealobj->x[k],arealobj->y[k],arealobj->x[kindex],arealobj->y[kindex]);
                     if(mindist < ptldist)
                        k = kk;
                     ERc->x1[1] = arealobj->x[k];
                     ERc->y1[1] = arealobj->y[k];
                     ERc->z1[1] = arealobj->z[k];
                     ERc->x1[2] = arealobj->x[kindex];
                     ERc->y1[2] = arealobj->y[kindex];
                     ERc->z1[2] = arealobj->z[kindex];
                     ERroot = ERc;
                     }
                  else
                     {
                     ERn = ERroot;
                     while(ERn != NULL)
                        {
                        if(
                           (ERn->Cnumber  == ERc->Cnumber)  &&
                           (ERn->keyval  == ERc->keyval)  &&
                           (ERn->pt1     == ERc->pt1)     &&
                           (ERn->aa      == ERc->aa)      &&
                           (ERn->Sindex1 == ERc->Sindex1)
                           )
                           {
                           break;
                           }
                        ERn = ERn->next;
                        }
                     if(ERn == NULL)
                        {
                        kk = (kindex + arealobj->numverts - 1) % arealobj->numverts;
                        k = (kindex + 1) % arealobj->numverts;
                        mindist = PointToLineDist2D(rpc->x[0], rpc->y[0], arealobj->x[kk],arealobj->y[kk],arealobj->x[kindex],arealobj->y[kindex]);
                        ptldist = PointToLineDist2D(rpc->x[0], rpc->y[0], arealobj->x[k],arealobj->y[k],arealobj->x[kindex],arealobj->y[kindex]);
                        if(mindist < ptldist)
                           k = kk;
                        ERc->x1[1] = arealobj->x[k];
                        ERc->y1[1] = arealobj->y[k];
                        ERc->z1[1] = arealobj->z[k];
                        ERc->x1[2] = arealobj->x[kindex];
                        ERc->y1[2] = arealobj->y[kindex];
                        ERc->z1[2] = arealobj->z[kindex];
                        ERc->next = ERroot;
                        ERroot = ERc;
                        }
                     else
                        {
                        free(ERc);
                        }
                     }
                  } /** end inside > 0 ***/
               }  /** end POVERSHTA check **/



            if((CombinedCheckApplies(rpc->idn,checkinstance,PUNDERSHTA,rpc->Lindex,rpc->Sindex,Config1,Strat1,Domain1,&part1,&part2,&part3) > 0) &&
                            (part1 > 0))
               {
               outside = 0;
               arealobj = NULL;
               
               timesthroughloop = 10;
               temptolerance = FindRelevantSensitivity(PUNDERSHTA,checkinstance,&unuseddbl);
               unuseddbl = maxx - rpc->x[0];
               if(unuseddbl <= temptolerance)
                  timesthroughloop = 0;
               else
                  {
                  unuseddbl = rpc->x[0] - minx;
                  if(unuseddbl <= temptolerance)
                     timesthroughloop = 0;
                  else
                     {
                     unuseddbl = rpc->y[0] - miny;
                     if(unuseddbl <= temptolerance)
                        timesthroughloop = 0;
                     else
                        {
                        unuseddbl = maxy - rpc->y[0];
                        if(unuseddbl <= temptolerance)
                           timesthroughloop = 0;
                        }
                     }
                  }
               rac = Aroot;  /** now look at 'is the point outside of the areal?' **/
               while(rac != NULL)
                  {
                  Config2 = SCCtable[rac->Sindex].C;
                  Strat2 = SCCtable[rac->Sindex].S;
                  Domain2 = SCCtable[rac->Sindex].D;
                  outside = 0;
                  if((CombinedCheckApplies(rac->idn,checkinstance,PUNDERSHTA,rac->Lindex,rac->Sindex,Config2,Strat2,Domain2,&part1,&part2,&part3) > 0)
                          && (part2 > 0))
                     {
                     if(rac->ishole <= 0)
                        {
                        if(rac->RB_Tree_Edgelist == NULL)
                           ptldist = PointToSmallArealDist2D(rpc->x[0], rpc->y[0],rac,&kindex,&unuseddbl);
                        else
                           ptldist = PointToLargeArealDist2D(rpc->x[0], rpc->y[0],rac,&kindex,&unuseddbl);
                        if((ptldist > 0.0) && (SensitivityCheck(LTEQ, PUNDERSHTA, checkinstance, ptldist) > 0))
                           {
                           if(PointIsInside(rpc->x[0],rpc->y[0],rac->x,rac->y,rac->x,rac->numverts,(unsigned char) Config1,&unuseddbl))
                              {
                              raHole = Aroot;
                              while(raHole != NULL)
                                 {
                                 if((raHole->ishole > 0) && (raHole->idn == rac->idn))
                                    {
                                    if(PointIsInside(rpc->x[0],rpc->y[0],raHole->x,raHole->y,raHole->x,raHole->numverts,(unsigned char) Config1,&unuseddbl))
                                       {
                                       break;
                                       }
                                    }
                                 raHole = raHole->next;
                                 }
                              if(raHole != NULL)
                                 ++outside;
                              }
                           else
                              ++outside;
                           }
                        }
                     }
                  if(outside > 0)
                     {
                     arealobj = rac;
                     break;
                     }
                  rac = rac->next;
                  if(rac == NULL)
                     {
                     if(timesthroughloop == 0)
                        {
                        timesthroughloop += 1;
                        rac = NeighborAreals;
                        }
                     }
                  }

               if(arealobj != NULL)  /** found the point to be outside a region (poly or areal) **/
                  {
                  ERc = (struct PointRelatedCollection *) (malloc(SzPRC));

                  if(ERc == NULL)
                     {
                     printf("allocation memory exhausted during point feature condition analysis\n");
                     printf("processing cannot continue\n");
                     exit(-1);
                     }
                  ERc->x1[0] = rpc->x[0];
                  ERc->y1[0] = rpc->y[0];
                  ERc->z1[0] = rpc->z[0];
                  ERc->pt1 = rpc;
                  ERc->numverts1 = 1;
                  ERc->magnitude = ptldist;
                  ERc->keyval = PUNDERSHTA;
                  ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                  ERc->Sindex1 = rpc->Sindex;
                  ERc->IDN1 = rpc->idn;
                  ERc->Sindex2 = arealobj->Sindex;
                  ERc->IDN2 = arealobj->idn;
                  ERc->ll = NULL;
                  ERc->pp = NULL;
                  ERc->aa = arealobj;
                  ERc->next = NULL;
                  if(ERroot == NULL)
                     {
                     kk = (kindex + arealobj->numverts - 1) % arealobj->numverts;
                     k = (kindex + 1) % arealobj->numverts;
                     mindist = PointToLineDist2D(rpc->x[0], rpc->y[0], arealobj->x[kk],arealobj->y[kk],arealobj->x[kindex],arealobj->y[kindex]);
                     ptldist = PointToLineDist2D(rpc->x[0], rpc->y[0], arealobj->x[k],arealobj->y[k],arealobj->x[kindex],arealobj->y[kindex]);
                     if(mindist < ptldist)
                        k = kk;
                     ERc->x1[1] = arealobj->x[k];
                     ERc->y1[1] = arealobj->y[k];
                     ERc->z1[1] = arealobj->z[k];
                     ERc->x1[2] = arealobj->x[kindex];
                     ERc->y1[2] = arealobj->y[kindex];
                     ERc->z1[2] = arealobj->z[kindex];
                     ERroot = ERc;
                     }
                  else
                     {
                     ERn = ERroot;
                     while(ERn != NULL)
                        {
                        if(
                           (ERn->Cnumber  == ERc->Cnumber)  &&
                           (ERn->keyval  == ERc->keyval)  &&
                           (ERn->pt1     == ERc->pt1)     &&
                           (ERn->aa      == ERc->aa)      &&
                           (ERn->Sindex1 == ERc->Sindex1)
                           )
                           {
                           break;
                           }
                        ERn = ERn->next;
                        }
                     if(ERn == NULL)
                        {
                        kk = (kindex + arealobj->numverts - 1) % arealobj->numverts;
                        k = (kindex + 1) % arealobj->numverts;
                        mindist = PointToLineDist2D(rpc->x[0], rpc->y[0], arealobj->x[kk],arealobj->y[kk],arealobj->x[kindex],arealobj->y[kindex]);
                        ptldist = PointToLineDist2D(rpc->x[0], rpc->y[0], arealobj->x[k],arealobj->y[k],arealobj->x[kindex],arealobj->y[kindex]);
                        if(mindist < ptldist)
                           k = kk;
                        ERc->x1[1] = arealobj->x[k];
                        ERc->y1[1] = arealobj->y[k];
                        ERc->z1[1] = arealobj->z[k];
                        ERc->x1[2] = arealobj->x[kindex];
                        ERc->y1[2] = arealobj->y[kindex];
                        ERc->z1[2] = arealobj->z[kindex];
                        ERc->next = ERroot;
                        ERroot = ERc;
                        }
                     else
                        {
                        free(ERc);
                        }
                     }
                  } /** end outside > 0 ***/
               }  /** end PUNDERSHTA check **/




            if((CombinedCheckApplies(rpc->idn,checkinstance,ELEVGT,rpc->Lindex,rpc->Sindex,Config1,Strat1,Domain1,&part1,&part2,&part3) > 0) &&
                     (part1 > 0))
               {
               if((tempis2D(rpc->z[0]) == 0) && (SensitivityCheck(GT, ELEVGT, checkinstance, rpc->z[0]) > 0))
                  {
                  ERc = (struct PointRelatedCollection *) (malloc(SzPRC));
                  if(ERc == NULL)
                     {
                     printf("allocation memory exhausted during point feature condition analysis\n");
                     printf("processing cannot continue\n");
                     exit(-1);
                     }
                  ERc->x1[0] = rpc->x[0];
                  ERc->y1[0] = rpc->y[0];
                  ERc->z1[0] = rpc->z[0];
                  ERc->magnitude = rpc->z[0];
                  ERc->keyval = ELEVGT;
                  ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                  ERc->Sindex1 = rpc->Sindex;
                  ERc->IDN1 = rpc->idn;
                  ERc->pt1 = rpc;
                  ERc->next = NULL;
                  if(ERroot == NULL)
                     {
                     ERroot = ERc;
                     }
                  else
                    {
                    ERn = ERroot;
                    while(ERn != NULL)
                       {
   /** below, note that == magnitudes implies == z values ***/
                       if((ERn->Cnumber == ERc->Cnumber)  && (ERn->keyval == ERc->keyval) && (ERn->magnitude == ERc->magnitude))
                          {
                          if((ERn->x1[0] == ERc->x1[0]) && (ERn->y1[0] == ERc->y1[0]) && 
                                        (ERn->Sindex1 == ERc->Sindex1))
                             {
                             break;
                             }
                          }
                       ERn = ERn->next;
                       }
                     if(ERn == NULL)
                        {
                        ERc->next = ERroot;
                        ERroot = ERc;
                        }
                     else
                        {
                        free(ERc);
                        }
                     }
                  } /*** end if SensitivityCheck ***/
   
               }
   
   
            if((CombinedCheckApplies(rpc->idn,checkinstance,ELEVLT,rpc->Lindex,rpc->Sindex,Config1,Strat1,Domain1,&part1,&part2,&part3) > 0) &&
                        (part1 > 0))
               {
               if((tempis2D(rpc->z[0]) == 0) && (SensitivityCheck(LT, ELEVLT, checkinstance, rpc->z[0]) > 0))
                  {
                  ERc = (struct PointRelatedCollection *) (malloc(SzPRC));
                  if(ERc == NULL) 
                     {
                     printf("allocation memory exhausted during point feature condition analysis\n");
                     printf("processing cannot continue\n");
                     exit(-1);
                     }
                  ERc->x1[0] = rpc->x[0];
                  ERc->y1[0] = rpc->y[0];
                  ERc->z1[0] = rpc->z[0];
                  ERc->magnitude = rpc->z[0];
                  ERc->keyval = ELEVLT;
                  ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                  ERc->Sindex1 = rpc->Sindex;
                  ERc->IDN1 = rpc->idn;
                  ERc->pt1 = rpc;
                  ERc->next = NULL; 
                  if(ERroot == NULL) 
                     {     
                     ERroot = ERc;
                     }     
                  else  
                    {     
                    ERn = ERroot;
                    while(ERn != NULL) 
                       {
                       if((ERn->Cnumber == ERc->Cnumber)  && (ERn->keyval == ERc->keyval) && (ERn->magnitude == ERc->magnitude))
                          {
                          if((ERn->x1[0] == ERc->x1[0]) && (ERn->y1[0] == ERc->y1[0]) &&
                                        (ERn->Sindex1 == ERc->Sindex1))
                             {
                             break;
                             }    
                          }
                       ERn = ERn->next;
                       }    
                     if(ERn == NULL)
                        {
                        ERc->next = ERroot;
                        ERroot = ERc;
                        }
                     else
                        {
                        free(ERc);
                        }
                     }
                  } /*** end if SensitivityCheck ***/
   
               }
   
   
            if((CombinedCheckApplies(rpc->idn,checkinstance,ELEVEQ,rpc->Lindex,rpc->Sindex,Config1,Strat1,Domain1,&part1,&part2,&part3) > 0) &&
                        (part1 > 0))
               {
               if((tempis2D(rpc->z[0]) == 0) && (SensitivityCheck(CLOSEDINT, ELEVEQ, checkinstance, rpc->z[0]) > 0))
                  {
                  ERc = (struct PointRelatedCollection *) (malloc(SzPRC));
                  if(ERc == NULL) 
                     {
                     printf("allocation memory exhausted during point feature condition analysis\n");
                     printf("processing cannot continue\n");
                     exit(-1);
                     }
                  ERc->x1[0] = rpc->x[0];
                  ERc->y1[0] = rpc->y[0];
                  ERc->z1[0] = rpc->z[0];
                  ERc->magnitude = rpc->z[0];
                  ERc->keyval = ELEVEQ;
                  ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                  ERc->Sindex1 = rpc->Sindex;
                  ERc->IDN1 = rpc->idn;
                  ERc->pt1 = rpc;
                  ERc->next = NULL; 
                  if(ERroot == NULL) 
                     {     
                     ERroot = ERc;
                     }     
                  else  
                    {     
                    ERn = ERroot;
                    while(ERn != NULL) 
                       {
   /** below, note that == magnitudes implies == z values ***/
                       if((ERn->Cnumber == ERc->Cnumber)  && (ERn->keyval == ERc->keyval) && (ERn->magnitude == ERc->magnitude))
                          {
                          if((ERn->x1[0] == ERc->x1[0]) && (ERn->y1[0] == ERc->y1[0]) &&
                                        (ERn->Sindex1 == ERc->Sindex1))
                             {
                             break;
                             }    
                          }
                       ERn = ERn->next;
                       }    
                     if(ERn == NULL)
                        {
                        ERc->next = ERroot;
                        ERroot = ERc;
                        }
                     else
                        {
                        free(ERc);
                        }
                     }
                  } /*** end if SensitivityCheck ***/

               }


            if((CombinedCheckApplies(rpc->idn,checkinstance,ELEVEQOPEN,rpc->Lindex,rpc->Sindex,Config1,Strat1,Domain1,&part1,&part2,&part3) > 0) &&
                        (part1 > 0))
               {
               if((tempis2D(rpc->z[0]) == 0) && (SensitivityCheck(OPENINT, ELEVEQOPEN, checkinstance, rpc->z[0]) > 0))
                  {
                  ERc = (struct PointRelatedCollection *) (malloc(SzPRC));
                  if(ERc == NULL)
                     {
                     printf("allocation memory exhausted during point feature condition analysis\n");
                     printf("processing cannot continue\n");
                     exit(-1);
                     }
                  ERc->x1[0] = rpc->x[0];
                  ERc->y1[0] = rpc->y[0];
                  ERc->z1[0] = rpc->z[0];
                  ERc->magnitude = rpc->z[0];
                  ERc->keyval = ELEVEQOPEN;
                  ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                  ERc->Sindex1 = rpc->Sindex;
                  ERc->IDN1 = rpc->idn;
                  ERc->pt1 = rpc;
                  ERc->next = NULL;
                  if(ERroot == NULL)
                     {
                     ERroot = ERc;
                     }
                  else
                    {
                    ERn = ERroot;
                    while(ERn != NULL)
                       {
   /** below, note that == magnitudes implies == z values ***/
                       if((ERn->Cnumber == ERc->Cnumber)  && (ERn->keyval == ERc->keyval) && (ERn->magnitude == ERc->magnitude))
                          {
                          if((ERn->x1[0] == ERc->x1[0]) && (ERn->y1[0] == ERc->y1[0]) &&
                                        (ERn->Sindex1 == ERc->Sindex1))
                             {
                             break;
                             }
                          }
                       ERn = ERn->next;
                       }
                     if(ERn == NULL)
                        {
                        ERc->next = ERroot;
                        ERroot = ERc;
                        }
                     else
                        {
                        free(ERc);
                        }
                     }
                  } /*** end if SensitivityCheck ***/

               }





            if((CombinedCheckApplies(rpc->idn,checkinstance,PTINREGION,rpc->Lindex,rpc->Sindex,Config1,Strat1,Domain1,&part1,&part2,&part3) > 0) &&
                            (part1 > 0))
               {
               polyobj = NULL;
               arealobj = NULL;

               rpoly = Proot; /** first, check for point inside polygon **/
               inside = 0;
               while((rpoly != NULL) && (inside < 1))
                  {
                  if((CombinedCheckApplies(rpoly->idn,checkinstance,PTINREGION, rpoly->SACindex, rpoly->SCCindex,rpoly->config,rpoly->stratum,
                                    rpoly->domain,&part1,&part2,&part3) > 0) && (part2 > 0))
                     {
                     if(PointIsVertex(rpc->x[0],rpc->y[0],rpoly->x,rpoly->y,rpoly->x,rpoly->numverts,&unuseddbl))
                        ++inside;
                     else if(PointOnEdge(rpc->x[0],rpc->y[0],rpoly->x,rpoly->y,rpoly->x,rpoly->numverts,&unuseddbl,&unusedint))
                        ++inside;
                     else if(PointIsInside(rpc->x[0],rpc->y[0],rpoly->x,rpoly->y,rpoly->x,rpoly->numverts,(unsigned char) Config1,&unuseddbl))
                        ++inside;
                     }
                  if(inside > 0)
                     {
                     polyobj = rpoly;
                     break;
                     }
                  rpoly = rpoly->next;
                  }
               inside = 0;
               rac = Aroot;  /** now look at point inside area feature **/
               while((rac != NULL) && (inside < 1))
                  {
                  Config2 = SCCtable[rac->Sindex].C;
                  Strat2 = SCCtable[rac->Sindex].S;
                  Domain2 = SCCtable[rac->Sindex].D;
                  if((CombinedCheckApplies(rac->idn,checkinstance,PTINREGION,rac->Lindex,rac->Sindex,Config2,Strat2,Domain2,&part1,&part2,&part3) > 0)
                          && (part2 > 0))
                     {
                     InHole = 0;
                     if(rac->ishole <= 0)
                        {
                        if(PointIsVertex(rpc->x[0],rpc->y[0],rac->x,rac->y,rac->x,rac->numverts,&unuseddbl))
                           ++inside;
                        else if(PointOnEdge(rpc->x[0],rpc->y[0],rac->x,rac->y,rac->x,rac->numverts,&unuseddbl,&unusedint))
                           ++inside;
                        else if(PointIsInside(rpc->x[0],rpc->y[0],rac->x,rac->y,rac->x,rac->numverts,(unsigned char) Config1,&unuseddbl))
                           {
                           raHole = Aroot;
                           while(raHole != NULL)
                              {
                              if((raHole->ishole > 0) && (raHole->idn == rac->idn))
                                 {
                                 if(PointIsInside(rpc->x[0],rpc->y[0],raHole->x,raHole->y,raHole->x,raHole->numverts,(unsigned char) Config1,&unuseddbl))
                                    {
                                    if((PointIsVertex(rpc->x[0],rpc->y[0],raHole->x,raHole->y,raHole->x,raHole->numverts,&unuseddbl) == 0) &&
                                      (PointOnEdge(rpc->x[0],rpc->y[0],raHole->x,raHole->y,raHole->x,raHole->numverts,&unuseddbl,&unusedint) == 0))
                                       {
                                       InHole = 1;
                                       break;
                                       }
                                    }
                                 }
                              raHole = raHole->next;
                              }
                           if(raHole == NULL)
                              ++inside;
                           }
                        }
                     if((inside == 0) && (InHole == 0))
                        {
                        if(rac->RB_Tree_Edgelist == NULL)
                           ptldist = PointToSmallArealDist2D(rpc->x[0], rpc->y[0],rac,&unusedint,&unuseddbl);
                        else
                           ptldist = PointToLargeArealDist2D(rpc->x[0], rpc->y[0],rac,&unusedint,&unuseddbl);
                        if((ptldist >= 0) && 
                              (SensitivityCheck(LTEQ, PTINREGION, checkinstance, ptldist) > 0))
                           {
                           inside = 1;
                           arealobj = rac;
                           break;
                           }
                        }
                     } /*** end combined check applies ***/
                  if(inside > 0)
                     {
                     arealobj = rac;
                     break;
                     }
                  rac = rac->next;
                  }
               if((polyobj != NULL) || (arealobj != NULL))  /** found the point to be inside a region (poly or areal) **/
                  {
                  if(arealobj != NULL)
                     {
                     arealobj = FindEdgeClosestToPoint(rpc->x[0],rpc->y[0],Aroot,NeighborAreals,arealobj,&i);
                     }
                  ERc = (struct PointRelatedCollection *) (malloc(SzPRC));
   
                  if(ERc == NULL)
                     {
                     printf("allocation memory exhausted during point feature condition analysis\n");
                     printf("processing cannot continue\n");
                     exit(-1);
                     }
                  ERc->x1[0] = rpc->x[0];
                  ERc->y1[0] = rpc->y[0];
                  ERc->z1[0] = rpc->z[0];
                  if(arealobj != NULL)
                     {
                     if(i < 0)
                        {
                        ERc->x1[1] = arealobj->x[0];
                        ERc->y1[1] = arealobj->y[0];
                        ERc->z1[1] = arealobj->z[0];
                        ERc->x1[2] = arealobj->x[arealobj->numverts-1];
                        ERc->y1[2] = arealobj->y[arealobj->numverts-1];
                        ERc->z1[2] = arealobj->z[arealobj->numverts-1];
                        }
                     else
                        {
                        ERc->x1[1] = arealobj->x[i];
                        ERc->y1[1] = arealobj->y[i];
                        ERc->z1[1] = arealobj->z[i];
                        ERc->x1[2] = arealobj->x[i-1];
                        ERc->y1[2] = arealobj->y[i-1];
                        ERc->z1[2] = arealobj->z[i-1];
                        }
                     }
                  ERc->pt1 = rpc;
                  ERc->numverts1 = 1;
                  ERc->magnitude = 0.0;
                  ERc->keyval = PTINREGION;
                  ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                  ERc->Sindex1 = rpc->Sindex;
                  ERc->IDN1 = rpc->idn;
                  ERc->ll = NULL;
                  ERc->pp = polyobj;
                  ERc->aa = arealobj;
                  ERc->next = NULL;
                  if(ERroot == NULL)
                     {
                     ERroot = ERc;
                     }
                  else
                     {
                     ERn = ERroot;
                     while(ERn != NULL)
                        {
                        if(
			   (ERn->Cnumber  == ERc->Cnumber)  &&
			   (ERn->keyval  == ERc->keyval)  && 
			   (ERn->x1[0]   == ERc->x1[0])   &&
			   (ERn->y1[0]   == ERc->y1[0])   && 
			   (ERn->Sindex1 == ERc->Sindex1)
			   )
                           {
                           break;
                           }
                        ERn = ERn->next;
                        }
                     if(ERn == NULL)
                        {
                        ERc->next = ERroot;
                        ERroot = ERc;
                        }
                     else
			{
                        free(ERc);
			}
                     }
                  } /** end inside > 0 ***/
               }  /** end PTINREGION check **/



            if((CombinedCheckApplies(rpc->idn,checkinstance,PTINPROPER,rpc->Lindex,rpc->Sindex,Config1,Strat1,Domain1,&part1,&part2,&part3) > 0) &&
                            (part1 > 0))
               {
               arealobj = NULL;
               inside = 0;
               rac = Aroot;  /** now look at point inside area feature **/
               while((rac != NULL) && (inside < 1))
                  {
                  Config2 = SCCtable[rac->Sindex].C;
                  Strat2 = SCCtable[rac->Sindex].S;
                  Domain2 = SCCtable[rac->Sindex].D;
                  if((CombinedCheckApplies(rac->idn,checkinstance,PTINPROPER,rac->Lindex,rac->Sindex,Config2,Strat2,Domain2,&part1,&part2,&part3) > 0)
                          && (part2 > 0))
                     {
                     if(rac->ishole <= 0)
                        {
                        if(rac->RB_Tree_Edgelist == NULL)
                           ptldist = PointToSmallArealDist2D(rpc->x[0], rpc->y[0],rac,&unusedint,&unuseddbl);
                        else
                           ptldist = PointToLargeArealDist2D(rpc->x[0], rpc->y[0],rac,&unusedint,&unuseddbl);
                        if((ptldist < 0) || (SensitivityCheck(GT, PTINPROPER, checkinstance, ptldist) > 0))
                           {
                           if(rac->RB_Tree_Edgelist == NULL)
                              {
                              if(PointIsInside(rpc->x[0],rpc->y[0],rac->x,rac->y,rac->x,rac->numverts,(unsigned char) Config1,&unuseddbl) > 0)
                                 inside = 1;
                              }
                           else
                              {
                              if(PointInsideLargeAreal(rpc->x[0],rpc->y[0],rac,&unusedint) > 0)
                                 inside = 1;
                              }
                           if(inside > 0)
                              {
                              raHole = Aroot;
                              while(raHole != NULL)
                                 {
                                 if((raHole->ishole > 0) && (raHole->idn == rac->idn))
                                    {
                                    if(raHole->RB_Tree_Edgelist == NULL)
                                       ptldist = PointToSmallArealDist2D(rpc->x[0], rpc->y[0],raHole,&unusedint,&unuseddbl);
                                    else
                                       ptldist = PointToLargeArealDist2D(rpc->x[0], rpc->y[0],raHole,&unusedint,&unuseddbl);
                                    if((ptldist < 0) || 
                                           ((ptldist >= 0) && (SensitivityCheck(LT, PTINPROPER, checkinstance, ptldist) > 0)))
                                       {
                                       inside = 0;
                                       break;
                                       }
                                    else
                                       {
                                       if(raHole->RB_Tree_Edgelist == NULL)
                                          {
                                          if(PointIsInside(rpc->x[0],rpc->y[0],
                                              raHole->x,raHole->y,raHole->x,raHole->numverts,(unsigned char) Config1,&unuseddbl) > 0)
                                             {
                                             inside = 0;
                                             break;
                                             }
                                          }
                                       else
                                          {
                                          if(PointInsideLargeAreal(rpc->x[0],rpc->y[0],raHole,&unusedint) > 0)
                                             {
                                             inside = 0;
                                             break;
                                             }
                                          }
                                       }
                                    }
                                 raHole = raHole->next;
                                 }
                              }
                           }
                        }
                     if(inside > 0)
                        {
                        arealobj = rac;
                        break;
                        }
                     }
                  rac = rac->next;
                  }
               if(arealobj != NULL)  /** found the point to be inside a areal **/
                  {
                  arealobj = FindEdgeClosestToPoint(rpc->x[0],rpc->y[0],Aroot,NeighborAreals,arealobj,&i);
                  ERc = (struct PointRelatedCollection *) (malloc(SzPRC));

                  if(ERc == NULL)
                     {
                     printf("allocation memory exhausted during point feature condition analysis\n");
                     printf("processing cannot continue\n");
                     exit(-1);
                     }
                  ERc->x1[0] = rpc->x[0];
                  ERc->y1[0] = rpc->y[0];
                  ERc->z1[0] = rpc->z[0];
                  if(arealobj != NULL)
                     {
                     if(i < 0)
                        {
                        ERc->x1[1] = arealobj->x[0];
                        ERc->y1[1] = arealobj->y[0];
                        ERc->z1[1] = arealobj->z[0];
                        ERc->x1[2] = arealobj->x[arealobj->numverts-1];
                        ERc->y1[2] = arealobj->y[arealobj->numverts-1];
                        ERc->z1[2] = arealobj->z[arealobj->numverts-1];
                        }
                     else
                        {
                        ERc->x1[1] = arealobj->x[i];
                        ERc->y1[1] = arealobj->y[i];
                        ERc->z1[1] = arealobj->z[i];
                        ERc->x1[2] = arealobj->x[i-1];
                        ERc->y1[2] = arealobj->y[i-1];
                        ERc->z1[2] = arealobj->z[i-1];
                        }
                     }
                  ERc->pt1 = rpc;
                  ERc->numverts1 = 1;
                  ERc->magnitude = 0.0;
                  ERc->keyval = PTINPROPER;
                  ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                  ERc->Sindex1 = rpc->Sindex;
                  ERc->IDN1 = rpc->idn;
                  ERc->ll = NULL;
                  ERc->pp = polyobj;
                  ERc->aa = arealobj;
                  ERc->next = NULL;
                  if(ERroot == NULL)
                     {
                     ERroot = ERc;
                     }
                  else
                     {
                     ERn = ERroot;
                     while(ERn != NULL)
                        {
                        if(
                           (ERn->Cnumber  == ERc->Cnumber)  &&
                           (ERn->keyval  == ERc->keyval)  &&
                           (ERn->x1[0]   == ERc->x1[0])   &&
                           (ERn->y1[0]   == ERc->y1[0])   &&
                           (ERn->Sindex1 == ERc->Sindex1)
                           )
                           {
                           break;
                           }
                        ERn = ERn->next;
                        }
                     if(ERn == NULL)
                        {
                        ERc->next = ERroot;
                        ERroot = ERc;
                        }
                     else
                        {
                        free(ERc);
                        }
                     }
                  } /** end inside > 0 ***/
               }  /** end PTINPROPER check **/




            if((CombinedCheckApplies(rpc->idn,checkinstance,PTOSIDEREGION,rpc->Lindex,rpc->Sindex,Config1,Strat1,Domain1,&part1,&part2,&part3) > 0) &&
                     (part1 > 0))
               {
               checkit = 1;
               thiskey = PTOSIDEREGION;
               }
            else if((CombinedCheckApplies(rpc->idn,checkinstance,OVERUNDER,rpc->Lindex,rpc->Sindex,Config1,Strat1,Domain1,&part1,&part2,&part3) > 0) &&
                     (part1 > 0))
               {
               checkit = 1;
               thiskey = OVERUNDER;
               }
            else
               checkit = 0;
            if(checkit > 0)
               {
               rpoly = Proot; /** first, check for point inside polygon **/
               inside = 0;
               while((rpoly != NULL) && (inside < 1))
                  {
                  if((CombinedCheckApplies(rpoly->idn,checkinstance,thiskey, rpoly->SACindex, rpoly->SCCindex,rpoly->config,rpoly->stratum,
                                       rpoly->domain,&part1,&part2,&part3) > 0) && (part2 > 0))
                     {
                     if(PointIsVertex(rpc->x[0],rpc->y[0],rpoly->x,rpoly->y,rpoly->x,rpoly->numverts,&unuseddbl))
                        ++inside;
                     else if(PointOnEdge(rpc->x[0],rpc->y[0],rpoly->x,rpoly->y,rpoly->x,rpoly->numverts,&unuseddbl,&unusedint))
                        ++inside;
                     else if(PointIsInside(rpc->x[0],rpc->y[0],rpoly->x,rpoly->y,rpoly->x,rpoly->numverts,(unsigned char) Config1,&unuseddbl))
                        ++inside;
                        }
                  rpoly = rpoly->next;
                  }
               rac = Aroot;  /** now look at point inside area feature **/
               while((rac != NULL) && (inside < 1))
                  {
                  Config2 = SCCtable[rac->Sindex].C;
                  Strat2 = SCCtable[rac->Sindex].S;
                  Domain2 = SCCtable[rac->Sindex].D;
                  if((CombinedCheckApplies(rac->idn,checkinstance,thiskey,rac->Lindex,rac->Sindex,Config2,Strat2,Domain2,&part1,&part2,&part3) > 0)
                          && (part2 > 0))
                     {
                     if(rac->ishole <= 0)
                        {
                        if(PointIsVertex(rpc->x[0],rpc->y[0],rac->x,rac->y,rac->x,rac->numverts,&unuseddbl))
                           ++inside;
                        else if(PointOnEdge(rpc->x[0],rpc->y[0],rac->x,rac->y,rac->x,rac->numverts,&unuseddbl,&unusedint))
                           ++inside;
                        else if(PointIsInside(rpc->x[0],rpc->y[0],rac->x,rac->y,rac->x,rac->numverts,(unsigned char) Config1,&unuseddbl))
                           {
                           raHole = Aroot;
                           while(raHole != NULL)
                              {
                              if((raHole->ishole > 0) && (raHole->idn == rac->idn))
                                 {
                                 if(PointOnEdge(rpc->x[0],rpc->y[0],raHole->x,raHole->y,raHole->x,raHole->numverts,&unuseddbl,&unusedint))
                                    {
                                    raHole = NULL;
                                    break;
                                    }
                                 if(PointIsInside(rpc->x[0],rpc->y[0],raHole->x,raHole->y,raHole->x,raHole->numverts,(unsigned char) Config1,&unuseddbl))
                                    break;
                                 }
                              raHole = raHole->next;
                              }
                           if(raHole == NULL)
                              ++inside;
                           }
                        }
                     }
                  rac = rac->next;
                  }
               if(inside == 0)  /** could not find eligible poly or area feature containing the point **/
                  {
                  ERc = (struct PointRelatedCollection *) (malloc(SzPRC));
                  if(ERc == NULL)
                     {
                     printf("allocation memory exhausted during point feature condition analysis\n");
                     printf("processing cannot continue\n");
                     exit(-1);
                     }
                  ERc->x1[0] = rpc->x[0];
                  ERc->y1[0] = rpc->y[0];
                  ERc->z1[0] = rpc->z[0];
                  ERc->pt1 = rpc;
                  ERc->magnitude = 0.0;
                  ERc->keyval = thiskey;
                  ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                  ERc->Sindex1 = rpc->Sindex;
                  ERc->IDN1 = rpc->idn;
                  ERc->next = NULL;
                  if(ERroot == NULL)
                     {
                     ERroot = ERc;
                     }
                  else
                     {
                     ERn = ERroot;
                     while(ERn != NULL)
                        {
                        if(
			   (ERn->Cnumber  == ERc->Cnumber) &&
			   (ERn->keyval  == ERc->keyval) && 
			   (ERn->x1[0]   == ERc->x1[0])  &&
			   (ERn->y1[0]   == ERc->y1[0])  && 
			   (ERn->Sindex1 == ERc->Sindex1)
			   )
                           {
                           break;
                           }
                        ERn = ERn->next;
                        }
                     if(ERn == NULL)
                        {
                        ERc->next = ERroot;
                        ERroot = ERc;
                        }
                     else
		        {
                        free(ERc);
			}
                     }
                  } /** end inside i == 0 ***/
               }  /** end PTOSIDEREGION  and / or OVERUNDER check **/



            if(CombinedCheckApplies(rpc->idn,checkinstance,PSHOOTL,rpc->Lindex,rpc->Sindex,Config1,Strat1,Domain1,&part1,&part2,&part3) > 0)
               {
               if(part1 > 0)
                  {
                  tol2 = FindRelevantSensitivity(PSHOOTL,checkinstance,&temptolerance);
                  mindist = temptolerance * 10.0;
                  rlc = Lroot;
                  while(rlc != NULL)
                     {
                     Config2 = SCCtable[rlc->Sindex].C;
                     Strat2 = SCCtable[rlc->Sindex].S;
                     Domain2 = SCCtable[rlc->Sindex].D;
                     if(CombinedCheckApplies(rlc->idn,checkinstance,PSHOOTL,rlc->Lindex,rlc->Sindex,Config2,Strat2,Domain2,&part1,&part2,&part3) > 0)
                        {
                        if(part2 > 0)
                           {
                           for(j=1; j<rlc->numnodes; j++)
                              {
                              jj = j - 1;
                              ptldist = PointToLineDist2D(rpc->x[0], rpc->y[0], rlc->x[jj], rlc->y[jj], rlc->x[j], rlc->y[j]);
                              if(ptldist < mindist)
                                 {
                                 mindist = ptldist;
                                 sj = j;
                                 sjj = jj;
                                 rlsave = rlc;
                                 }

                              } /*** end for(j=1; j<rlc->numnodes; j++) ***/
                           }
                        }
                     if(mindist < tol2)
                        break;
                     rlc = rlc->next;
                     } /**** end while rlc not null ****/

                  LookForFeature = 0;
                  if(mindist >= tol2)
                     {
                     ptldist = Distance(rpc->x[0], rpc->y[0], rpc->x[0]+temptolerance, rpc->y[0]);
                     xi = (temptolerance * temptolerance) / ptldist;
                     ptldist = Distance(rpc->x[0], rpc->y[0], rpc->x[0], rpc->y[0]+temptolerance);
                     yi = (temptolerance * temptolerance) / ptldist;
   
                     li = (int) ((rpc->x[0] - xi) / RegionSize);
                     ui = (int) ((rpc->x[0] + xi) / RegionSize);
                     lj = (int) ((rpc->y[0] - yi) / RegionSize);
                     uj = (int) ((rpc->y[0] + yi) / RegionSize);
   
                     if(li < 0)   li = 0;
                     if(lj < 0)   lj = 0;
                     if(ui > MaxXindex)     ui = MaxXindex;
                     if(uj > MaxYindex)     uj = MaxYindex;

                     for(index1 = li; index1 <= ui; index1++)
                        {
                        LookForFeature = 0;
                        for(index2 = lj; index2 <= uj; index2++)
                           {
                           LookForFeature = 0;
                           thisindex = (index1 * (MaxYindex + 1)) + index2;
                           if(thisindex != cindex)
                              {
                              for(k=0; k<LindexTable[thisindex].inside; k++)
                                 {
                                 LookForFeature = 0;
                                 FLindex =  LindexTable[thisindex].indices[k];
                                 if(CrsWlk[FLindex].geomtype == C_LINE)
                                    {
                                    FSindex = CrsWlk[FLindex].LtoSmapping;
                                    if(ActiveChecks[checkinstance].number == PSHOOTL)
                                       {
                                       if(ActiveChecks[checkinstance].secondaryEDCSstuff != NULL)
                                          {
                                          if(ActiveChecks[checkinstance].secondaryEDCSstuff[FLindex] == 1)
                                             {
                                             LookForFeature = 1;
                                             break;
                                             }
                                          else if((ActiveChecks[checkinstance].Config2[SCCtable[FSindex].C] == 1) &&
                                                 (ActiveChecks[checkinstance].Stratum2[SCCtable[FSindex].S] == 1) &&
                                                 (ActiveChecks[checkinstance].Domain2[SCCtable[FSindex].D] == 1) &&
                                                 (ActiveChecks[checkinstance].secondaryEDCSstuff[FLindex] != 2))
                                             {
                                             LookForFeature = 1;
                                             break;
                                             }
                                          }
                                       else if((ActiveChecks[checkinstance].Config2[SCCtable[FSindex].C] == 1) &&
                                              (ActiveChecks[checkinstance].Stratum2[SCCtable[FSindex].S] == 1) &&
                                              (ActiveChecks[checkinstance].Domain2[SCCtable[FSindex].D] == 1))
                                          {
                                          LookForFeature = 1;
                                          break;
                                          }
                                       }
                                    } /*** end CrsWlk says this Lindex is a point ***/
                                 if(LookForFeature > 0)
                                    break;
                                 } /*** end for k ***/
                              } /** end thisindex != cindex ***/
                           if(LookForFeature > 0)
                              break;
                           } /*** end for index2 ***/
                        if(LookForFeature > 0)
                           break;
                        } /*** end for index1 ***/
                     } /*** end mindist is above lower bound ***/
   
                  if(LookForFeature > 0)
                     {
                     if((L_NeighborsLoaded == 0) && (CrsWlk[FLindex].geomtype == C_LINE))
                        {
                        L_NeighborsLoaded = 1;
                        FindApplicableNeighborFeatures(cindex, ptsin, minx, maxx, miny, maxy, 0, 1 , 0, 0);
                        }

                     rlc = TgtLroot;
                     while(rlc != NULL)
                        {
                        Config2 = SCCtable[rlc->Sindex].C;
                        Strat2 = SCCtable[rlc->Sindex].S;
                        Domain2 = SCCtable[rlc->Sindex].D;
                        if(CombinedCheckApplies(rlc->idn,checkinstance,PSHOOTL,rlc->Lindex,rlc->Sindex,Config2,Strat2,Domain2,&part1,&part2,&part3) > 0)
                           {
                           if(part2 > 0)
                              {
                              for(j=1; j<rlc->numnodes; j++)
                                 {
                                 jj = j - 1;
                                 ptldist = PointToLineDist2D(rpc->x[0], rpc->y[0], rlc->x[jj], rlc->y[jj], rlc->x[j], rlc->y[j]);
                                 if(ptldist < mindist)
                                    {
                                    mindist = ptldist;
                                    sj = j;
                                    sjj = jj;
                                    rlsave = rlc;
                                    }
                                 } /*** end for(j=1; j<rlc->numnodes; j++) ***/
                              }
                           }
                        if(mindist < tol2)
                           break;
                        rlc = rlc->next;
                        } /**** end while rlc not null ****/
                     } /*** end look for a neighbor region feature ***/
                  if((mindist >= tol2) && (mindist <= temptolerance))
                     {
                     ERc = (struct PointRelatedCollection *) (malloc(SzPRC));
                     if(ERc == NULL)
                        {
                        printf("allocation memory exhausted during point feature condition analysis\n");
                        printf("processing cannot continue\n");
                        exit(-1);
                        }
                        ERc->x1[0] = rpc->x[0];
                     ERc->y1[0] = rpc->y[0];
                     ERc->z1[0] = rpc->z[0];
                     ERc->pt1 = rpc;
                     ERc->ll = rlsave;
                     ERc->magnitude = mindist;
                     ERc->keyval = PSHOOTL;
                     ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                     ERc->Sindex1 = rpc->Sindex;
                     ERc->IDN1 = rpc->idn;
                     ERc->Sindex2 = rlsave->Sindex;
                     ERc->IDN2 = rlsave->idn;
                     ERc->next = NULL;
                     ERc->x1[1] = rlsave->x[sjj];
                     ERc->y1[1] = rlsave->y[sjj];
                     ERc->z1[1] = rlsave->z[sjj];
                     ERc->x1[2] = rlsave->x[sj];
                     ERc->y1[2] = rlsave->y[sj];
                     ERc->z1[2] = rlsave->z[sj];
                     if(ERroot == NULL)
                        {
                        ERroot = ERc;
                        }
                     else
                        {
                        ERn = ERroot;
                        while(ERn != NULL)
                          {
                            if(
                               (ERn->Cnumber    == ERc->Cnumber) &&
                               (ERn->keyval    == ERc->keyval) &&
                               (ERn->x1[0]     == ERc->x1[0])  &&
                               (ERn->y1[0]     == ERc->y1[0])  &&
                               (ERn->Sindex1   == ERc->Sindex1)
                               )
                              {
                                if((ERn->x1[1] == ERc->x1[1]) && (ERn->y1[1] == ERc->y1[1]) &&
                                   (ERn->x1[2] == ERc->x1[2]) && (ERn->y1[2] == ERc->y1[2]))
                                  break;
                                if((ERn->x1[2] == ERc->x1[1]) && (ERn->y1[2] == ERc->y1[1]) &&
                                   (ERn->x1[1] == ERc->x1[2]) && (ERn->y1[1] == ERc->y1[2]))
                                  break;
                              }
                            ERn = ERn->next;
                          }
                        if(ERn == NULL)
                           {
                           ERc->next = ERroot;
                           ERroot = ERc;
                           }
                        else
                           {
                           free(ERc);
                           }
                        }
                     } /**** end if mindist is in the error range****/

                  } /**** end if part1 > 0 *****/
               } /** end of check PSHOOTL **/



            if(CombinedCheckApplies(rpc->idn,checkinstance,PLPROX,rpc->Lindex,rpc->Sindex,Config1,Strat1,Domain1,&part1,&part2,&part3) > 0)
               {
               if(part1 > 0)
                  {
                  rlc = Lroot;
                  temptolerance = FindRelevantSensitivity(PLPROX,checkinstance,&unuseddbl);
                  while(rlc != NULL)
                     {
                     Config2 = SCCtable[rlc->Sindex].C;
                     Strat2 = SCCtable[rlc->Sindex].S;
                     Domain2 = SCCtable[rlc->Sindex].D;
                     if(CombinedCheckApplies(rlc->idn,checkinstance,PLPROX,rlc->Lindex,rlc->Sindex,Config2,Strat2,Domain2,&part1,&part2,&part3) > 0)
                        {
                        if(part2 > 0)
                           {
                           FoundCondition = 0;
                           mindist = temptolerance * 10;
                           for(j=1; j<rlc->numnodes; j++)
                              {
                              jj = j - 1;
                              ptldist = PointToLineDist2D(rpc->x[0], rpc->y[0], rlc->x[jj], rlc->y[jj], rlc->x[j], rlc->y[j]);
                              if(ptldist < mindist)
                                 {
                                 mindist = ptldist;
                                 sj = j;
                                 sjj = jj;
                                 }
                              } /*** end for(j=1; j<rlc->numnodes; j++) ***/
                           if(SensitivityCheck(LTEQ, PLPROX, checkinstance, mindist) > 0)
                              {
                              FoundCondition = 1;
                              rln = Lroot;
                              while(rln != NULL)
                                 {
                                 if((rln != rlc) && (CombinedCheckApplies(rln->idn,checkinstance,PLPROX,
                                                      rln->Lindex,rln->Sindex,
                                                      SCCtable[rln->Sindex].C,SCCtable[rln->Sindex].S,SCCtable[rln->Sindex].D,
                                                      &part1,&part2,&part3) > 0) &&
                                            (part3 > 0))
                                    {
                                    for(k=1; k<rln->numnodes; k++)
                                       {
                                       kk = k - 1;
                                       unuseddbl = PointToLineDist2D(rpc->x[0], rpc->y[0], rln->x[kk], rln->y[kk], rln->x[k], rln->y[k]);
                                       if(SensitivityCheck(LTEQ, PLPROX, checkinstance, unuseddbl) > 0)
                                          {
                                          FoundCondition = 0;
                                          break;
                                          }
                                       }
                                    }
                                 if(FoundCondition == 0)
                                    break;
                                 rln = rln->next;
                                 }
                              }
                           if(FoundCondition > 0)
                              {
                              FoundCondition = 0;
                              ERc = (struct PointRelatedCollection *) (malloc(SzPRC));
                              if(ERc == NULL)
                                 {
                                 printf("allocation memory exhausted during point feature condition analysis\n");
                                 printf("processing cannot continue\n");
                                 exit(-1);
                                 }
                                 ERc->x1[0] = rpc->x[0];
                              ERc->y1[0] = rpc->y[0];
                              ERc->z1[0] = rpc->z[0];
                              ERc->pt1 = rpc;
                              ERc->ll = rlc;
                              ERc->magnitude = mindist;
                              ERc->keyval = PLPROX;
                              ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                              ERc->Sindex1 = rpc->Sindex;
                              ERc->IDN1 = rpc->idn;
                              ERc->Sindex2 = rlc->Sindex;
                              ERc->IDN2 = rlc->idn;
                              ERc->next = NULL;
                              ERc->x1[1] = rlc->x[sjj];
                              ERc->y1[1] = rlc->y[sjj];
                              ERc->z1[1] = rlc->z[sjj];
                              ERc->x1[2] = rlc->x[sj];
                              ERc->y1[2] = rlc->y[sj];
                              ERc->z1[2] = rlc->z[sj];
                              if(ERroot == NULL)
                                 {
                                 ERroot = ERc;
                                 }
                              else
                                 {
                                 ERn = ERroot;
                                 while(ERn != NULL)
                                   {
                                     if((ERn->Cnumber    == ERc->Cnumber) && (ERn->keyval    == ERc->keyval) && (ERn->x1[0]     == ERc->x1[0])  &&
                                        (ERn->y1[0]     == ERc->y1[0])  && (ERn->Sindex1   == ERc->Sindex1))
                                       {
                                         if((ERn->x1[1] == ERc->x1[1]) && (ERn->y1[1] == ERc->y1[1]) &&
                                            (ERn->x1[2] == ERc->x1[2]) && (ERn->y1[2] == ERc->y1[2]))
                                           break;
                                         if((ERn->x1[2] == ERc->x1[1]) && (ERn->y1[2] == ERc->y1[1]) &&
                                            (ERn->x1[1] == ERc->x1[2]) && (ERn->y1[1] == ERc->y1[2]))
                                           break;
                                       }
                                     ERn = ERn->next;
                                   }
                                 if(ERn == NULL)
                                    {
                                    ERc->next = ERroot;
                                    ERroot = ERc;
                                    }
                                 else
                                    {
                                    free(ERc);
                                    }
                                 }
                              } /**** end if(SensitivityCheck(LTEQ, PLPROX, checkinstance, ptldist) > 0)****/
                           }
                        }
                     rlc = rlc->next;
                     } /**** end while rlc not null ****/

                  temptolerance = FindRelevantSensitivity(PLPROX,checkinstance,&unuseddbl);
                  ptldist = Distance(rpc->x[0], rpc->y[0], rpc->x[0]+temptolerance, rpc->y[0]);
                  xi = (temptolerance * temptolerance) / ptldist;
                  ptldist = Distance(rpc->x[0], rpc->y[0], rpc->x[0], rpc->y[0]+temptolerance);
                  yi = (temptolerance * temptolerance) / ptldist;

                  li = (int) ((rpc->x[0] - xi) / RegionSize);
                  ui = (int) ((rpc->x[0] + xi) / RegionSize);
                  lj = (int) ((rpc->y[0] - yi) / RegionSize);
                  uj = (int) ((rpc->y[0] + yi) / RegionSize);

                  if(li < 0)   li = 0;
                  if(lj < 0)   lj = 0;
                  if(ui > MaxXindex)     ui = MaxXindex;
                  if(uj > MaxYindex)     uj = MaxYindex;

                  LookForFeature = 0;

                  for(index1 = li; index1 <= ui; index1++)
                     {
                     LookForFeature = 0;
                     for(index2 = lj; index2 <= uj; index2++)
                        {
                        LookForFeature = 0;
                        thisindex = (index1 * (MaxYindex + 1)) + index2;
                        if(thisindex != cindex)
                           {
                           for(k=0; k<LindexTable[thisindex].inside; k++)
                              {
                              LookForFeature = 0;
                              FLindex =  LindexTable[thisindex].indices[k];
                              if(CrsWlk[FLindex].geomtype == C_LINE)
                                 {
                                 FSindex = CrsWlk[FLindex].LtoSmapping;
                                 if(ActiveChecks[checkinstance].number == PLPROX)
                                    {
                                    if(ActiveChecks[checkinstance].secondaryEDCSstuff != NULL)
                                       {
                                       if(ActiveChecks[checkinstance].secondaryEDCSstuff[FLindex] == 1)
                                          {
                                          LookForFeature = 1;
                                          break;
                                          }
                                       else if((ActiveChecks[checkinstance].Config2[SCCtable[FSindex].C] == 1) &&
                                              (ActiveChecks[checkinstance].Stratum2[SCCtable[FSindex].S] == 1) &&
                                              (ActiveChecks[checkinstance].Domain2[SCCtable[FSindex].D] == 1) &&
                                              (ActiveChecks[checkinstance].secondaryEDCSstuff[FLindex] != 2))
                                          {
                                          LookForFeature = 1;
                                          break;
                                          }
                                       }
                                    else if((ActiveChecks[checkinstance].Config2[SCCtable[FSindex].C] == 1) &&
                                           (ActiveChecks[checkinstance].Stratum2[SCCtable[FSindex].S] == 1) &&
                                           (ActiveChecks[checkinstance].Domain2[SCCtable[FSindex].D] == 1))
                                       {
                                       LookForFeature = 1;
                                       break;
                                       }
                                    }
                                 } /*** end CrsWlk says this Lindex is a point ***/
                              if(LookForFeature > 0)
                                 break;
                              } /*** end for k ***/
                           } /** end thisindex != cindex ***/
                        if(LookForFeature > 0)
                           break;
                        } /*** end for index2 ***/
                     if(LookForFeature > 0)
                        break;
                     } /*** end for index1 ***/

                  if(LookForFeature > 0)
                     {
                     if((L_NeighborsLoaded == 0) && (CrsWlk[FLindex].geomtype == C_LINE))
                        {
                        L_NeighborsLoaded = 1;
                        FindApplicableNeighborFeatures(cindex, ptsin, minx, maxx, miny, maxy, 0, 1 , 0, 0);
                        }

                     rlc = TgtLroot;
                     while(rlc != NULL)
                        {
                        Config2 = SCCtable[rlc->Sindex].C;
                        Strat2 = SCCtable[rlc->Sindex].S;
                        Domain2 = SCCtable[rlc->Sindex].D;
                        if(CombinedCheckApplies(rlc->idn,checkinstance,PLPROX,rlc->Lindex,rlc->Sindex,Config2,Strat2,Domain2,&part1,&part2,&part3) > 0)
                           {
                           if(part2 > 0)
                              {
                              mindist = temptolerance * 10;
                              for(j=1; j<rlc->numnodes; j++)
                                 {
                                 jj = j - 1;
                                 ptldist = PointToLineDist2D(rpc->x[0], rpc->y[0], rlc->x[jj], rlc->y[jj], rlc->x[j], rlc->y[j]);
                                 if(ptldist < mindist)
                                    {
                                    mindist = ptldist;
                                    sj = j;
                                    sjj = jj;
                                    }
                                 } /*** end for(j=1; j<rlc->numnodes; j++) ***/
                              if(SensitivityCheck(LTEQ, PLPROX, checkinstance, mindist) > 0)
                                 {
                                 ERc = (struct PointRelatedCollection *) (malloc(SzPRC));
                                 if(ERc == NULL)
                                    {
                                    printf("allocation memory exhausted during point feature condition analysis\n");
                                    printf("processing cannot continue\n");
                                    exit(-1);
                                    }
                                 ERc->x1[0] = rpc->x[0];
                                 ERc->y1[0] = rpc->y[0];
                                 ERc->z1[0] = rpc->z[0];
                                 ERc->pt1 = rpc;
                                 ERc->ll = rlc;
                                 ERc->magnitude = mindist;
                                 ERc->keyval = PLPROX;
                                 ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                                 ERc->Sindex1 = rpc->Sindex;
                                 ERc->IDN1 = rpc->idn;
                                 ERc->Sindex2 = rlc->Sindex;
                                 ERc->IDN2 = rlc->idn;
                                 ERc->next = NULL;
                                 if(ERroot == NULL)
                                    {
                                    ERc->x1[1] = rlc->x[sjj];
                                    ERc->y1[1] = rlc->y[sjj];
                                    ERc->z1[1] = rlc->z[sjj];
                                    ERc->x1[2] = rlc->x[sj];
                                    ERc->y1[2] = rlc->y[sj];
                                    ERc->z1[2] = rlc->z[sj];
                                    ERroot = ERc;
                                    }
                                 else
                                    {
                                    ERn = ERroot;
                                    while(ERn != NULL)
                                       {
                                       if((ERn->Cnumber == ERc->Cnumber) && (ERn->keyval == ERc->keyval) && (ERn->x1[0] == ERc->x1[0])  &&
                                           (ERn->y1[0] == ERc->y1[0]) && (ERn->Sindex1 == ERc->Sindex1))
                                          {
                                          if((ERn->x1[1] == ERc->x1[1]) && (ERn->y1[1] == ERc->y1[1]) &&
                                               (ERn->x1[2] == ERc->x1[2]) && (ERn->y1[2] == ERc->y1[2]))
                                             break;
                                          if((ERn->x1[2] == ERc->x1[1]) && (ERn->y1[2] == ERc->y1[1]) &&
                                               (ERn->x1[1] == ERc->x1[2]) && (ERn->y1[1] == ERc->y1[2]))
                                             break;
                                          }
                                        ERn = ERn->next;
                                       }
                                    if(ERn == NULL)
                                       {
                                       ERc->x1[1] = rlc->x[sjj];
                                       ERc->y1[1] = rlc->y[sjj];
                                       ERc->z1[1] = rlc->z[sjj];
                                       ERc->x1[2] = rlc->x[sj];
                                       ERc->y1[2] = rlc->y[sj];
                                       ERc->z1[2] = rlc->z[sj];
                                       ERc->next = ERroot;
                                       ERroot = ERc;
                                       }
                                    else
                                       {
                                       free(ERc);
                                       }
                                    }
                                 } /**** end if(SensitivityCheck(LTEQ, PLPROX, checkinstance, ptldist) > 0)****/
                              }
                           }
                        rlc = rlc->next;
                        } /**** end while rlc not null ****/
                     } /*** end look for a neighbor region feature ***/

                  } /**** end if part1 > 0 *****/
               } /** end of check PLPROX **/






            if(CombinedCheckApplies(rpc->idn,checkinstance,PLPROXEX,rpc->Lindex,rpc->Sindex,Config1,Strat1,Domain1,&part1,&part2,&part3) > 0)
               {
               if(part1 > 0)
                  {
                  rlc = Lroot;
                  while(rlc != NULL)
                     {
                     Config2 = SCCtable[rlc->Sindex].C;
                     Strat2 = SCCtable[rlc->Sindex].S;
                     Domain2 = SCCtable[rlc->Sindex].D;
                     if(CombinedCheckApplies(rlc->idn,checkinstance,PLPROXEX,rlc->Lindex,rlc->Sindex,Config2,Strat2,Domain2,&part1,&part2,&part3) > 0)
                        {
                        if(part2 > 0)
                           {
                           ptpdist = Distance(rpc->x[0],rpc->y[0],rlc->x[0],rlc->y[0]);
                           if(SensitivityCheck(GT, PLPROXEX, checkinstance, ptpdist) > 0)
                              {
                              ptpdist =  Distance(rpc->x[0],rpc->y[0],rlc->x[rlc->numnodes-1],rlc->y[rlc->numnodes-1]);
                              if(SensitivityCheck(LTEQ, PLPROXEX, checkinstance, ptpdist) > 0)
                                 {
                                 part2 = -1;
                                 }
                              }
                           else
                              part2 = -1; 
                           }
                        if(part2 > 0)
                           {
                           for(j=1; j<rlc->numnodes; j++)
                              {
                              jj = j - 1;
                              ptldist = PointToLineDist2D(rpc->x[0], rpc->y[0], rlc->x[jj], rlc->y[jj], rlc->x[j], rlc->y[j]);
                              if(SensitivityCheck(LTEQ, PLPROXEX, checkinstance, ptldist) > 0)
                                 {
                                 ERc = (struct PointRelatedCollection *) (malloc(SzPRC));
                                 if(ERc == NULL)
                                    {
                                    printf("allocation memory exhausted during point feature condition analysis\n");
                                    printf("processing cannot continue\n");
                                    exit(-1);
                                    }
                                    ERc->x1[0] = rpc->x[0];
                                 ERc->y1[0] = rpc->y[0];
                                 ERc->z1[0] = rpc->z[0];
                                 ERc->pt1 = rpc;
                                 ERc->ll = rlc;
                                 ERc->magnitude = ptldist;
                                 ERc->keyval = PLPROXEX;
                                 ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                                 ERc->Sindex1 = rpc->Sindex;
                                 ERc->IDN1 = rpc->idn;
                                 ERc->Sindex2 = rlc->Sindex;
                                 ERc->IDN2 = rlc->idn;
                                 ERc->next = NULL;
                                 ERc->x1[1] = rlc->x[jj];
                                 ERc->y1[1] = rlc->y[jj];
                                 ERc->z1[1] = rlc->z[jj];
                                 ERc->x1[2] = rlc->x[j];
                                 ERc->y1[2] = rlc->y[j];
                                 ERc->z1[2] = rlc->z[j];
                                if(ERroot == NULL)
                                    {
                                    ERroot = ERc;
                                    }
                                 else
                                    {
                                    ERn = ERroot;
                                    while(ERn != NULL)
                                      {
                                        if(
                                           (ERn->Cnumber    == ERc->Cnumber) &&
                                           (ERn->keyval    == ERc->keyval) &&
                                           (ERn->x1[0]     == ERc->x1[0])  &&
                                           (ERn->y1[0]     == ERc->y1[0])  &&
                                           (ERn->Sindex1   == ERc->Sindex1)
                                           )
                                          {
                                            if((ERn->x1[1] == ERc->x1[1]) && (ERn->y1[1] == ERc->y1[1]) &&
                                               (ERn->x1[2] == ERc->x1[2]) && (ERn->y1[2] == ERc->y1[2]))
                                              break;
                                            if((ERn->x1[2] == ERc->x1[1]) && (ERn->y1[2] == ERc->y1[1]) &&
                                               (ERn->x1[1] == ERc->x1[2]) && (ERn->y1[1] == ERc->y1[2]))
                                              break;
                                          }
                                        ERn = ERn->next;
                                      }
                                    if(ERn == NULL)
                                       {
                                       /****ERc->x1[1] = rlc->x[jj];
                                       ERc->y1[1] = rlc->y[jj];
                                       ERc->z1[1] = rlc->z[jj];
                                       ERc->x1[2] = rlc->x[j];
                                       ERc->y1[2] = rlc->y[j];
                                       ERc->z1[2] = rlc->z[j];***/
                                       ERc->next = ERroot;
                                       ERroot = ERc;
                                       }
                                    else
                                       {
                                       free(ERc);
                                       }
                                    }
                                 break;  /*** break from the for loop so only write one segment to represent whole line ***/
                                 } /**** end if(SensitivityCheck(LTEQ, PLPROXEX, checkinstance, ptldist) > 0)****/
                              } /*** end for(j=1; j<rlc->numnodes; j++) ***/
                           }
                        }
                     rlc = rlc->next;
                     } /**** end while rlc not null ****/

                  temptolerance = FindRelevantSensitivity(PLPROXEX,checkinstance,&unuseddbl);
                  ptldist = Distance(rpc->x[0], rpc->y[0], rpc->x[0]+temptolerance, rpc->y[0]);
                  xi = (temptolerance * temptolerance) / ptldist;
                  ptldist = Distance(rpc->x[0], rpc->y[0], rpc->x[0], rpc->y[0]+temptolerance);
                  yi = (temptolerance * temptolerance) / ptldist;

                  li = (int) ((rpc->x[0] - xi) / RegionSize);
                  ui = (int) ((rpc->x[0] + xi) / RegionSize);
                  lj = (int) ((rpc->y[0] - yi) / RegionSize);
                  uj = (int) ((rpc->y[0] + yi) / RegionSize);
                  if(li < 0)   li = 0;
                  if(lj < 0)   lj = 0;
                  if(ui > MaxXindex)     ui = MaxXindex;    
                  if(uj > MaxYindex)     uj = MaxYindex;   

                  LookForFeature = 0;

                  for(index1 = li; index1 <= ui; index1++)
                     {
                     LookForFeature = 0;
                     for(index2 = lj; index2 <= uj; index2++) 
                        {
                        LookForFeature = 0;
                        thisindex = (index1 * (MaxYindex + 1)) + index2;
                        if(thisindex != cindex)
                           {
                           for(k=0; k<LindexTable[thisindex].inside; k++)
                              {
                              LookForFeature = 0;
                              FLindex =  LindexTable[thisindex].indices[k];
                              if(CrsWlk[FLindex].geomtype == C_LINE)
                                 {
                                 FSindex = CrsWlk[FLindex].LtoSmapping;
                                 if(ActiveChecks[checkinstance].number == PLPROXEX)
                                    {
                                    if(ActiveChecks[checkinstance].secondaryEDCSstuff != NULL)
                                       {
                                       if(ActiveChecks[checkinstance].secondaryEDCSstuff[FLindex] == 1)
                                          {
                                          LookForFeature = 1;
                                          break;
                                          }
                                       else if((ActiveChecks[checkinstance].Config2[SCCtable[FSindex].C] == 1) &&
                                              (ActiveChecks[checkinstance].Stratum2[SCCtable[FSindex].S] == 1) &&
                                              (ActiveChecks[checkinstance].Domain2[SCCtable[FSindex].D] == 1) &&
                                              (ActiveChecks[checkinstance].secondaryEDCSstuff[FLindex] != 2))
                                          {
                                          LookForFeature = 1;
                                          break;
                                          }
                                       }
                                    else if((ActiveChecks[checkinstance].Config2[SCCtable[FSindex].C] == 1) &&
                                           (ActiveChecks[checkinstance].Stratum2[SCCtable[FSindex].S] == 1) &&
                                           (ActiveChecks[checkinstance].Domain2[SCCtable[FSindex].D] == 1))
                                       {
                                       LookForFeature = 1;
                                       break;
                                       }
                                    }
                                 } /*** end CrsWlk says this Lindex is a point ***/
                              if(LookForFeature > 0)
                                 break; 
                              } /*** end for k ***/
                           } /** end thisindex != cindex ***/
                        if(LookForFeature > 0) 
                           break;
                        } /*** end for index2 ***/
                     if(LookForFeature > 0)
                        break;
                     } /*** end for index1 ***/

                  if(LookForFeature > 0)
                     {
                     if((L_NeighborsLoaded == 0) && (CrsWlk[FLindex].geomtype == C_LINE))
                        {
                        L_NeighborsLoaded = 1;
                        FindApplicableNeighborFeatures(cindex, ptsin, minx, maxx, miny, maxy, 0, 1 , 0, 0);
                        }

                     rlc = TgtLroot;
                     while(rlc != NULL)
                        {
                        Config2 = SCCtable[rlc->Sindex].C;
                        Strat2 = SCCtable[rlc->Sindex].S;
                        Domain2 = SCCtable[rlc->Sindex].D;
                        if(CombinedCheckApplies(rlc->idn,checkinstance,PLPROXEX,rlc->Lindex,rlc->Sindex,Config2,Strat2,Domain2,&part1,&part2,&part3) > 0)
                           {
                           if(part2 > 0)
                              {
                              ptpdist = Distance(rpc->x[0],rpc->y[0],rlc->x[0],rlc->y[0]);
                              if(SensitivityCheck(GT, PLPROXEX, checkinstance, ptpdist) > 0)
                                 {
                                 ptpdist =  Distance(rpc->x[0],rpc->y[0],rlc->x[rlc->numnodes-1],rlc->y[rlc->numnodes-1]);
                                 if(SensitivityCheck(LTEQ, PLPROXEX, checkinstance, ptpdist) > 0)
                                    {
                                    part2 = -1;
                                    }
                                 }
                              else
                                 part2 = -1;
                              }
                           if(part2 > 0)
                              {
                              for(j=1; j<rlc->numnodes; j++)
                                 {
                                 jj = j - 1;
                                 ptldist = PointToLineDist2D(rpc->x[0], rpc->y[0], rlc->x[jj], rlc->y[jj], rlc->x[j], rlc->y[j]);
                                 if(SensitivityCheck(LTEQ, PLPROXEX, checkinstance, ptldist) > 0)
                                    {
                                    ERc = (struct PointRelatedCollection *) (malloc(SzPRC));
                                    if(ERc == NULL)
                                       {
                                       printf("allocation memory exhausted during point feature condition analysis\n");
                                       printf("processing cannot continue\n");
                                       exit(-1);
                                       }
                                    ERc->x1[0] = rpc->x[0];
                                    ERc->y1[0] = rpc->y[0];
                                    ERc->z1[0] = rpc->z[0];
                                    ERc->pt1 = rpc;
                                    ERc->ll = rlc;
                                    ERc->magnitude = ptldist;
                                    ERc->keyval = PLPROXEX;
                                    ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                                    ERc->Sindex1 = rpc->Sindex;
                                    ERc->IDN1 = rpc->idn;
                                    ERc->Sindex2 = rlc->Sindex;
                                    ERc->IDN2 = rlc->idn;
                                    ERc->next = NULL;
                                    if(ERroot == NULL)
                                       {
                                       ERc->x1[1] = rlc->x[jj];
                                       ERc->y1[1] = rlc->y[jj];
                                       ERc->z1[1] = rlc->z[jj];
                                       ERc->x1[2] = rlc->x[j];
                                       ERc->y1[2] = rlc->y[j];
                                       ERc->z1[2] = rlc->z[j];
                                       ERroot = ERc;
                                       }
                                    else 
                                       {
                                       ERn = ERroot;
                                       while(ERn != NULL)
                                          {
                                          if((ERn->Cnumber == ERc->Cnumber) && (ERn->keyval == ERc->keyval) && (ERn->x1[0] == ERc->x1[0])  &&
                                              (ERn->y1[0] == ERc->y1[0]) && (ERn->Sindex1 == ERc->Sindex1))
                                             {
                                             if((ERn->x1[1] == ERc->x1[1]) && (ERn->y1[1] == ERc->y1[1]) &&
                                                  (ERn->x1[2] == ERc->x1[2]) && (ERn->y1[2] == ERc->y1[2]))
                                                break;
                                             if((ERn->x1[2] == ERc->x1[1]) && (ERn->y1[2] == ERc->y1[1]) &&
                                                  (ERn->x1[1] == ERc->x1[2]) && (ERn->y1[1] == ERc->y1[2]))
                                                break;
                                             }
                                           ERn = ERn->next;
                                          }
                                       if(ERn == NULL)
                                          {
                                          ERc->x1[1] = rlc->x[jj];
                                          ERc->y1[1] = rlc->y[jj];
                                          ERc->z1[1] = rlc->z[jj];
                                          ERc->x1[2] = rlc->x[j];
                                          ERc->y1[2] = rlc->y[j];
                                          ERc->z1[2] = rlc->z[j];
                                          ERc->next = ERroot;
                                          ERroot = ERc;
                                          }
                                       else
                                          {
                                          free(ERc);
                                          }
                                       }
                                    break;  /*** break from the for loop so only write one segment to represent whole line ***/
                                    } /**** end if(SensitivityCheck(LTEQ, PLPROXEX, checkinstance, ptldist) > 0)****/
                                 } /*** end for(j=1; j<rlc->numnodes; j++) ***/
                              }
                           }
                        rlc = rlc->next;
                        } /**** end while rlc not null ****/
                     } /*** end look for a neighbor region feature ***/

                  } /**** end if part1 > 0 *****/ 
               } /** end of check PLPROXEX **/



            if(CombinedCheckApplies(rpc->idn,checkinstance,PLPFAIL,rpc->Lindex,rpc->Sindex,Config1,Strat1,Domain1,&part1,&part2,&part3) > 0)
               {
               if(part1 > 0)
                  {
                  isclose = 0;
                  rlc = Lroot;
                  while(rlc != NULL)
                     {
                     Config2 = SCCtable[rlc->Sindex].C;
                     Strat2  = SCCtable[rlc->Sindex].S;
                     Domain2 = SCCtable[rlc->Sindex].D;
                     if(CombinedCheckApplies(rlc->idn,checkinstance,PLPFAIL,rlc->Lindex,rlc->Sindex,Config2,Strat2,Domain2,&part1,&part2,&part3) > 0)
                        {
                        if(part2 > 0)
                           {
                           /**isclose = 0;**/
                           for(j=1; j<rlc->numnodes; j++)
                              {
                              jj = j - 1;
                              ptldist = PointToLineDist2D(rpc->x[0], rpc->y[0], rlc->x[jj], rlc->y[jj], rlc->x[j], rlc->y[j]);
                              if(SensitivityCheck(LTEQ, PLPFAIL, checkinstance, ptldist) > 0)
                                 {
                                 isclose = 1;
                                 break;
                                 }
                              }
                           }
                        }
                     if(isclose > 0)
                        break;
                     rlc = rlc->next;
                     }

                  if(isclose == 0) /*** see if a point feature will satisfy the requirement ***/
                     {
                     npc = root; 
                     while(npc != NULL)
                        {
                        if((npc != rpc) && (npc->numverts == -1))
                           {
                           Config2 = SCCtable[npc->Sindex].C;
                           Strat2  = SCCtable[npc->Sindex].S;
                           Domain2 = SCCtable[npc->Sindex].D;
                           if(CombinedCheckApplies(npc->idn,checkinstance,PLPFAIL,npc->Lindex,npc->Sindex,
                                                    Config2,Strat2,Domain2,&part1,&part2,&part3) > 0)
                              {
                              if(part2 > 0)
                                 {
                                 ptldist = Distance(rpc->x[0], rpc->y[0], npc->x[0], npc->y[0]);
                                 if(SensitivityCheck(LTEQ, PLPFAIL, checkinstance, ptldist) > 0)    
                                    {
                                    isclose = 1;
                                    }
                                 }
                              }
                           }
                        if(isclose > 0)
                           break;
                        npc = npc->next;
                        }
                     }
                  if(isclose == 0)
                     {
                     rac = Aroot;
                     while((rac != NULL) && (isclose == 0))
                        {
                        Config2 = SCCtable[rac->Sindex].C;
                        Strat2 = SCCtable[rac->Sindex].S;
                        Domain2 = SCCtable[rac->Sindex].D;
                           if((CombinedCheckApplies(rac->idn,checkinstance,PLPFAIL,rac->Lindex,rac->Sindex,Config2,Strat2,Domain2,&part1,&part2,&part3) > 0)
                             && (part2 > 0))
                           {
                           if(rac->ishole <= 0)
                              {
                              if(PointIsVertex(rpc->x[0],rpc->y[0],rac->x,rac->y,rac->x,rac->numverts,&unuseddbl))
                                 {
                                 ptldist = 0.0;
                                 ++isclose;
                                 }
                              else if(PointOnEdge(rpc->x[0],rpc->y[0],rac->x,rac->y,rac->x,rac->numverts,&unuseddbl,&unusedint))
                                 {
                                 ptldist = 0.0;
                                 ++isclose;
                                 }
                              else if(PointIsInside(rpc->x[0],rpc->y[0],rac->x,rac->y,rac->x,rac->numverts,(unsigned char) Config1,&unuseddbl))
                                 {
                                 raHole = Aroot;
                                 while(raHole != NULL)
                                    {
                                    if((raHole->ishole > 0) && (raHole->idn == rac->idn))
                                       {
                                       if(PointIsInside(rpc->x[0],rpc->y[0],raHole->x,raHole->y,raHole->x,raHole->numverts,(unsigned char) Config1,&unuseddbl))
                                          {
                                          break;
                                          }
                                       }
                                    raHole = raHole->next;
                                    }
                                 if(raHole == NULL)
                                    {
                                    ptldist = 0.0;
                                    ++isclose;
                                    }
                                 }
                              }
                           if((isclose == 0) && (rac->ishole <= 0))
                              {
                              ptldist = PointToArealDist2D(rpc->x[0], rpc->y[0], rac);
                              if(SensitivityCheck(LTEQ, PLPFAIL, checkinstance, ptldist) > 0)
                                 {
                                 isclose = 1;
                                 break;
                                 }
                              }
                           }
                        rac = rac->next;
                        }
                     if(isclose == 0)
                        {
                        temptolerance = FindRelevantSensitivity(PLPFAIL,checkinstance,&unuseddbl);
                        ptldist = Distance(rpc->x[0], rpc->y[0], rpc->x[0]+temptolerance, rpc->y[0]);
                        xi = (temptolerance * temptolerance) / ptldist;
                        ptldist = Distance(rpc->x[0], rpc->y[0], rpc->x[0], rpc->y[0]+temptolerance);
                        yi = (temptolerance * temptolerance) / ptldist;

                        li = (int) ((rpc->x[0] - xi) / RegionSize);
                        ui = (int) ((rpc->x[0] + xi) / RegionSize);
                        lj = (int) ((rpc->y[0] - yi) / RegionSize);
                        uj = (int) ((rpc->y[0] + yi) / RegionSize);

                        if(li < 0)   li = 0;
                        if(lj < 0)   lj = 0;
                        if(ui > MaxXindex)     ui = MaxXindex;
                        if(uj > MaxYindex)     uj = MaxYindex;

                        LookForFeature = 0;

                        for(index1 = li; index1 <= ui; index1++)
                           {
                           LookForFeature = 0;
                           for(index2 = lj; index2 <= uj; index2++)
                              {
                              LookForFeature = 0;
                              thisindex = (index1 * (MaxYindex + 1)) + index2;
                              if(thisindex != cindex)
                                 {
                                 for(k=0; k<LindexTable[thisindex].inside; k++)
                                    {
                                    LookForFeature = 0;
                                    FLindex =  LindexTable[thisindex].indices[k];
                                    if((CrsWlk[FLindex].geomtype == C_LINE) || (CrsWlk[FLindex].geomtype == C_AREA) ||
                                           (CrsWlk[FLindex].geomtype == C_POFE))
                                       {
                                       FSindex = CrsWlk[FLindex].LtoSmapping;
                                       if(ActiveChecks[checkinstance].number == PLPFAIL)
                                          {
                                          if(ActiveChecks[checkinstance].secondaryEDCSstuff != NULL)
                                             {
                                             if(ActiveChecks[checkinstance].secondaryEDCSstuff[FLindex] == 1)
                                                {
                                                LookForFeature = 1;
                                                }
                                             else if((ActiveChecks[checkinstance].Config2[SCCtable[FSindex].C] == 1) &&
                                                    (ActiveChecks[checkinstance].Stratum2[SCCtable[FSindex].S] == 1) &&
                                                    (ActiveChecks[checkinstance].Domain2[SCCtable[FSindex].D] == 1) &&
                                                    (ActiveChecks[checkinstance].secondaryEDCSstuff[FLindex] != 2))
                                                {
                                                LookForFeature = 1;
                                                }
                                             }
                                          else if((ActiveChecks[checkinstance].Config2[SCCtable[FSindex].C] == 1) &&
                                                 (ActiveChecks[checkinstance].Stratum2[SCCtable[FSindex].S] == 1) &&
                                                 (ActiveChecks[checkinstance].Domain2[SCCtable[FSindex].D] == 1))
                                             {
                                             LookForFeature = 1;
                                             }
                                          }
                                       }
                                    
                                    if(LookForFeature > 0)
                                       {
                                       if((A_NeighborsLoaded == 0) && (CrsWlk[FLindex].geomtype == C_AREA))
                                          {
                                          A_NeighborsLoaded = 1;
                                          FindApplicableNeighborFeatures(cindex, ptsin, minx, maxx, miny, maxy, 1, 0 , 0, 0);
                                          }

                                       rac = TgtAroot;
                                       while((rac != NULL) && (isclose == 0))
                                          {
                                          Config2 = SCCtable[rac->Sindex].C;
                                          Strat2 = SCCtable[rac->Sindex].S;
                                          Domain2 = SCCtable[rac->Sindex].D;
                                          if((CombinedCheckApplies(rac->idn,checkinstance,PLPFAIL,
                                                                   rac->Lindex,rac->Sindex,Config2,Strat2,Domain2,&part1,&part2,&part3) > 0) &&
                                               (part2 > 0))
                                             {
                                             if(rac->ishole <= 0)
                                                {
                                                if(PointIsVertex(rpc->x[0],rpc->y[0],rac->x,rac->y,rac->x,rac->numverts,&unuseddbl))
                                                   {
                                                   ptldist = 0.0;
                                                   ++isclose;
                                                   }
                                                else if(PointOnEdge(rpc->x[0],rpc->y[0],rac->x,rac->y,rac->x,rac->numverts,&unuseddbl,&unusedint))
                                                   { 
                                                   ptldist = 0.0;
                                                   ++isclose;
                                                   }
                                                else if(PointIsInside(rpc->x[0],rpc->y[0],rac->x,rac->y,rac->x,rac->numverts,(unsigned char) Config1,&unuseddbl))
                                                   { 
                                                   raHole = Aroot;
                                                   while(raHole != NULL)
                                                      {
                                                      if((raHole->ishole > 0) && (raHole->idn == rac->idn))
                                                         {
                                                         if(PointIsInside(rpc->x[0],rpc->y[0],raHole->x,raHole->y,raHole->x,raHole->numverts,(unsigned char) Config1,&unuseddbl))
                                                            {
                                                            break;
                                                            }
                                                         }
                                                      raHole = raHole->next;
                                                      }
                                                   if(raHole == NULL)
                                                      {
                                                      ptldist = 0.0;
                                                      ++isclose;
                                                      }
                                                   }
                                                }
                                             if((isclose == 0) && (rac->ishole <= 0))
                                                {
                                                ptldist = PointToArealDist2D(rpc->x[0], rpc->y[0], rac);
                                                if(SensitivityCheck(LTEQ, PLPFAIL, checkinstance, ptldist) > 0)
                                                   {
                                                   isclose = 1;
                                                   break; /** this breaks from the for loop **/
                                                   }
                                                }
                                             }
                                          rac = rac->next;
                                          }
                                       if((isclose == 0) && (CrsWlk[FLindex].geomtype == C_LINE))
                                          {
                                          if(L_NeighborsLoaded == 0)
                                             {
                                             L_NeighborsLoaded = 1;
                                             FindApplicableNeighborFeatures(cindex, ptsin, minx, maxx, miny, maxy, 0, 1 , 0, 0);
                                             }

                                          rlc = TgtLroot;
                                          while(rlc != NULL)
                                             {
                                             Config2 = SCCtable[rlc->Sindex].C;
                                             Strat2  = SCCtable[rlc->Sindex].S;
                                             Domain2 = SCCtable[rlc->Sindex].D;
                                             if(CombinedCheckApplies(rlc->idn,checkinstance,PLPFAIL,rlc->Lindex,rlc->Sindex,
                                                    Config2,Strat2,Domain2,&part1,&part2,&part3) > 0)
                                                {
                                                if(part2 > 0)
                                                   {
                                                   /**isclose = 0;**/
                                                   for(j=1; j<rlc->numnodes; j++)
                                                      {
                                                      jj = j - 1;
                                                      ptldist = PointToLineDist2D(rpc->x[0], rpc->y[0],
                                                                          rlc->x[jj], rlc->y[jj], rlc->x[j], rlc->y[j]);
                                                      if(SensitivityCheck(LTEQ, PLPFAIL, checkinstance, ptldist) > 0)
                                                      /***if(ptldist <= ErrorLookup[PLPFAIL].sensitivity) ***/
                                                         {
                                                         isclose = 1;
                                                         break; /** this breaks from the for loop **/
                                                         }
                                                      }
                                                   }
                                                }
                                             if(isclose > 0)
                                                break;
                                             rlc = rlc->next;
                                             }
                                          }

                                       if((isclose == 0) && (CrsWlk[FLindex].geomtype == C_POFE))
                                          {
                                          if(P_NeighborsLoaded == 0)
                                             {
                                             P_NeighborsLoaded = 1;
                                             FindApplicableNeighborFeatures(cindex, ptsin, minx, maxx, miny, maxy, 0, 0 , 1, 0);
                                             }

                                          npc = TgtProot;
                                          while(npc != NULL)
                                             {
                                             Config2 = SCCtable[npc->Sindex].C;
                                             Strat2  = SCCtable[npc->Sindex].S;
                                             Domain2 = SCCtable[npc->Sindex].D;
                                             if(CombinedCheckApplies(npc->idn,checkinstance,PLPFAIL,npc->Lindex,npc->Sindex,
                                                    Config2,Strat2,Domain2,&part1,&part2,&part3) > 0)
                                                {
                                                if(part2 > 0)
                                                   {
                                                   if(npc->numverts == -1)
                                                      {
                                                      ptldist = Distance3D(rpc->x[0], rpc->y[0], rpc->z[0], npc->x[0], npc->y[0], npc->z[0]);
                                                      if(SensitivityCheck(LTEQ, PLPFAIL, checkinstance, ptldist) > 0)
                                                         {
                                                         isclose = 1;
                                                         }
                                                      }
                                                   }
                                                }
                                             if(isclose > 0)
                                                break;
                                             npc = npc->next;
                                             }
                                          }

                                       }
                                    if(isclose > 0)
                                       break;
                                    }  /**** end for k ***/
                                 } /*** end if not looking at cindex ****/
                              if(isclose > 0)
                                 break;
                              } /*** end for index2 ***/
                           if(isclose > 0)
                              break;
                           } /*** end for index1 ***/
                        }  /**** end if(isclose == 0) so try applicable area features in neighbor regions *****/
                     }  /**** end if(isclose == 0) so try area features in this region  *****/

                  if(isclose == 0)
                     {
                     ERc = (struct PointRelatedCollection *) (malloc(SzPRC));
                     if(ERc == NULL)
                        {
                        printf("allocation memory exhausted during point feature condition analysis\n");
                        printf("processing cannot continue\n");
                        exit(-1);
                        }
                     ERc->x1[0] = rpc->x[0];
                     ERc->y1[0] = rpc->y[0];
                     ERc->z1[0] = rpc->z[0];
                     ERc->pt1 = rpc;
                     ERc->magnitude = ptldist;
                     ERc->keyval = PLPFAIL;
                     ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);

                     ERc->Sindex1 = rpc->Sindex;
                     ERc->IDN1 = rpc->idn;
                     ERc->next = NULL;
                     if(ERroot == NULL)
                        {
                        ERroot = ERc;
                        }
                     else
		       {
			 ERn = ERroot;
			 while(ERn != NULL)
                           {
			     if(
				(ERn->Cnumber  == ERc->Cnumber)  &&
				(ERn->keyval  == ERc->keyval)  && 
				(ERn->x1[0]   == ERc->x1[0])   &&
				(ERn->y1[0]   == ERc->y1[0])   && 
				(ERn->Sindex1 == ERc->Sindex1)
				)
			       {
				 break;
			       }
			     ERn = ERn->next;
                           }
			 if(ERn == NULL)
                           {
			     ERc->next = ERroot;
			     ERroot = ERc;
                           }
			 else
			   {
			     free(ERc);
			   }
                        }
                     } /** end isclose == 0, so did not find a closeby line segment **/
                  } /** end, part 1 applies to this point **/
               }  /** end of check PLPFAIL **/




            if(CombinedCheckApplies(rpc->idn,checkinstance,PNOCOV2LEA,rpc->Lindex,rpc->Sindex,Config1,Strat1,Domain1,&part1,&part2,&part3) > 0)
               {
               if(part1 > 0)
                  {
                  kk = 0;
                  temptolerance = FindRelevantSensitivity(PNOCOV2LEA,checkinstance,&unuseddbl);
                  
                  rlc = Lroot;
                  while((rlc != NULL) && (kk < 2))
                     {
                     Config2 = SCCtable[rlc->Sindex].C;
                     Strat2 = SCCtable[rlc->Sindex].S;
                     Domain2 = SCCtable[rlc->Sindex].D;
                     if(CombinedCheckApplies(rlc->idn,checkinstance,PNOCOV2LEA,rlc->Lindex,rlc->Sindex,Config2,Strat2,Domain2,&part1,&part2,&part3) > 0)
                        {
                        if(part2 > 0)
                           {
                           if(tempis2D(rpc->z[0]) || (tempis2D(rlc->z[0])))
                              {
                              ptldist = Distance(rpc->x[0], rpc->y[0],rlc->x[0], rlc->y[0]);
                              if(ptldist > temptolerance)
                                 ptldist = Distance(rpc->x[0], rpc->y[0],rlc->x[rlc->numnodes-1], rlc->y[rlc->numnodes-1]);
                              }
                           else
                              {
                              ptldist = Distance3D(rpc->x[0], rpc->y[0], rpc->z[0],rlc->x[0], rlc->y[0], rlc->z[0]);
                              if(ptldist > temptolerance)
                                 ptldist = Distance3D(rpc->x[0], rpc->y[0],rpc->z[0],
                                     rlc->x[rlc->numnodes-1], rlc->y[rlc->numnodes-1], rlc->z[rlc->numnodes-1]);
                              }
                           if(ptldist <= temptolerance)
                              {
                              ++kk;
                              if(kk >= 2)
                                 break;   
                              }
                           }
                        }

                     rlc = rlc->next;
                     }
                  if(kk < 2)
                     {
                     rac = Aroot;
                     while((rac != NULL) && (kk < 2))
                        {
                        Config2 = SCCtable[rac->Sindex].C;
                        Strat2 = SCCtable[rac->Sindex].S;
                        Domain2 = SCCtable[rac->Sindex].D;
                        if(CombinedCheckApplies(rac->idn,checkinstance,PNOCOV2LEA,rac->Lindex,rac->Sindex,Config2,Strat2,Domain2,&part1,&part2,&part3) > 0)
                           {
                           if(part2 > 0)
                              {
                              j = rac->numverts - 1;
                              for(i=0; i< rac->numverts; i++)
                                 {
                                 if((tempis2D(rpc->z[0])) || (tempis2D(rac->z[i])) || (tempis2D(rac->z[j])))
                                    {
                                    ptldist = PointToLineDist2D(rpc->x[0], rpc->y[0], rac->x[i], rac->y[i], rac->x[j], rac->y[j]);
                                    }
                                 else
                                    {
                                    ptldist = PointToLineDist(rpc->x[0], rpc->y[0], rpc->z[0],
                                                 rac->x[i], rac->y[i], rac->z[i], rac->x[j], rac->y[j], rac->z[j]);
                                    }
                                 if(ptldist <= temptolerance)
                                    {
                                    ++kk;
                                    break;
                                    }

                                 j = i;
                                 }
                              }
                           }
                        if(kk >= 2)
                           break;
   
                        rac = rac->next;
                        }
                     }





                  if(kk < 2) /** did not find a matching linear end node or area edges ***/
                     {
                     ERc = (struct PointRelatedCollection *) (malloc(SzPRC));
                     if(ERc == NULL)
                        {
                        printf("allocation memory exhausted during point feature condition analysis\n");
                        printf("processing cannot continue\n");
                        exit(-1);
                        }
                     ERc->x1[0] = rpc->x[0];
                     ERc->y1[0] = rpc->y[0];
                     ERc->z1[0] = rpc->z[0];
                     ERc->pt1 = rpc;
                     ERc->magnitude = 0.0;
                     ERc->keyval = PNOCOV2LEA;
                     ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                     ERc->Sindex1 = rpc->Sindex;
                     ERc->IDN1 = rpc->idn;
                     ERc->next = NULL;
                     if(ERroot == NULL)
                        {
                        ERroot = ERc;
                        }
                     else
                        {
                        ERn = ERroot;
                        while(ERn != NULL)
                          {
                            if(
                               (ERn->Cnumber    == ERc->Cnumber) &&
                               (ERn->keyval    == ERc->keyval) &&
                               (ERn->x1[0]     == ERc->x1[0])  &&
                               (ERn->y1[0]     == ERc->y1[0])  &&
                               (ERn->Sindex1   == ERc->Sindex1) &&
                               (ERn->IDN1      == ERc->IDN1)
                               )
                              {
                                  break;
                              }
                            ERn = ERn->next;
                          }
                        if(ERn == NULL)
                           {
                           ERc->next = ERroot;
                           ERroot = ERc;
                           }
                        else
                           {
                           free(ERc);
                           }
                        }
                     } /**** end if kk < 2 ****/
                  }
               } /** end of check PNOCOV2LEA **/




            if(CombinedCheckApplies(rpc->idn,checkinstance,PNOCOVERLE,rpc->Lindex,rpc->Sindex,Config1,Strat1,Domain1,&part1,&part2,&part3) > 0)
               {
               keepit = 0;
               if(part1 > 0)
                  {
                  mindist = FindRelevantSensitivity(PNOCOVERLE,checkinstance,&unuseddbl);
                  mindist *= 10;
                  rlc = Lroot;
                  while(rlc != NULL)
                     {
                     Config2 = SCCtable[rlc->Sindex].C;
                     Strat2 = SCCtable[rlc->Sindex].S;
                     Domain2 = SCCtable[rlc->Sindex].D;
                     if(CombinedCheckApplies(rlc->idn,checkinstance,PNOCOVERLE,rlc->Lindex,rlc->Sindex,Config2,Strat2,Domain2,&part1,&part2,&part3) > 0)
                        {
                        if(part2 > 0)
                           {
                           ptldist = Distance3D(rpc->x[0], rpc->y[0], rpc->z[0],rlc->x[0], rlc->y[0], rlc->z[0]);
                           if(SensitivityCheck(LTEQ, PNOCOVERLE, checkinstance, ptldist) > 0)
                              break;
                           
                           ptldist = Distance3D(rpc->x[0], rpc->y[0],rpc->z[0], 
                                     rlc->x[rlc->numnodes-1], rlc->y[rlc->numnodes-1], rlc->z[rlc->numnodes-1]);
                           if(SensitivityCheck(LTEQ, PNOCOVERLE, checkinstance, ptldist) > 0)
                              break;
                              
                           }
                        }

                     rlc = rlc->next;
                     }
                  if(rlc == NULL) /** did not find a matching linear end node ***/
                     {
                     keepit = 1;
                     rac = Aroot;
                     while(rac != NULL)
                        {
                        if(CombinedCheckApplies(rac->idn,checkinstance,PNOCOVERLE,rac->Lindex,rac->Sindex,
                                 SCCtable[rac->Sindex].C,SCCtable[rac->Sindex].S,SCCtable[rac->Sindex].D,&part1,&part2,&part3) > 0)
                           {
                           if(part2 > 0)
                              {
                              if(rac->RB_Tree_Edgelist == NULL)
                                 ptpdist = PointToSmallArealDist2D(rpc->x[0], rpc->y[0],rac,&unusedint,&unuseddbl);
                              else
                                 ptpdist = PointToLargeArealDist2D(rpc->x[0], rpc->y[0],rac,&unusedint,&unuseddbl);

                              if((ptpdist > -1.0) && (SensitivityCheck(LTEQ, PNOCOVERLE, checkinstance, ptpdist) > 0))
                                 {

                                 keepit = 0;
                                 break;
                                 }
                              }
                           }
                        rac = rac->next;
                        }
                     }
                  if(keepit > 0) /** did not find matching line end node or any area perimeter vertex or segment ***/
                     {
                     ERc = (struct PointRelatedCollection *) (malloc(SzPRC));
                     if(ERc == NULL)
                        {
                        printf("allocation memory exhausted during point feature condition analysis\n");
                        printf("processing cannot continue\n");
                        exit(-1);
                        }
                     ERc->x1[0] = rpc->x[0];
                     ERc->y1[0] = rpc->y[0];
                     ERc->z1[0] = rpc->z[0];
                     ERc->pt1 = rpc;
                     ERc->magnitude = 0.0;
                     ERc->keyval = PNOCOVERLE;
                     ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                     ERc->Sindex1 = rpc->Sindex;
                     ERc->IDN1 = rpc->idn;
                     ERc->next = NULL;
                     if(ERroot == NULL)
                        {
                        ERroot = ERc;
                        }
                     else
                        {
                        ERn = ERroot;
                        while(ERn != NULL)
                          {
                            if(
                               (ERn->Cnumber    == ERc->Cnumber) &&
                               (ERn->keyval    == ERc->keyval) &&
                               (ERn->x1[0]     == ERc->x1[0])  &&
                               (ERn->y1[0]     == ERc->y1[0])  &&
                               (ERn->Sindex1   == ERc->Sindex1) &&
                               (ERn->IDN1      == ERc->IDN1)
                               )
                              {
                                  break;
                              }
                            ERn = ERn->next;
                          }
                        if(ERn == NULL)
                           {
                           ERc->next = ERroot;
                           ERroot = ERc;
                           }
                        else
                           {
                           free(ERc);
                           }
                        }
                     } /**** end if rlc != NULL ****/
                  }
               } /** end of check PNOCOVERLE **/


            if(CombinedCheckApplies(rpc->idn,checkinstance,PNOCOVERLV,rpc->Lindex,rpc->Sindex,Config1,Strat1,Domain1,&part1,&part2,&part3) > 0)
               {
               if(part1 > 0)
                  {
                  mindist = FindRelevantSensitivity(PNOCOVERLV,checkinstance,&unuseddbl);
                  mindist *= 10;
                  rlc = Lroot;
                  while(rlc != NULL)
                     {
                     Config2 = SCCtable[rlc->Sindex].C;
                     Strat2 = SCCtable[rlc->Sindex].S;
                     Domain2 = SCCtable[rlc->Sindex].D;
                     jj = 0;
                     if(CombinedCheckApplies(rlc->idn,checkinstance,PNOCOVERLV,rlc->Lindex,rlc->Sindex,Config2,Strat2,Domain2,&part1,&part2,&part3) > 0)
                        {
                        if(part2 > 0)
                           {
                           for(j=0; j<rlc->numnodes; j++)
                              {
                              ptldist = Distance3D(rpc->x[0], rpc->y[0], rpc->z[0],rlc->x[j], rlc->y[j], rlc->z[j]);
                              if(SensitivityCheck(LTEQ, PNOCOVERLV, checkinstance, ptldist) > 0)
                                 {
                                 jj = 1;
                                 break;
                                 }
                              }
                           }
                        }

                     if(jj > 0)
                        break;

                     rlc = rlc->next;
                     }
                  if(rlc == NULL)
                     {
                     ERc = (struct PointRelatedCollection *) (malloc(SzPRC));
                     if(ERc == NULL)
                        {
                        printf("allocation memory exhausted during point feature condition analysis\n");
                        printf("processing cannot continue\n");
                        exit(-1);
                        }
                     ERc->x1[0] = rpc->x[0];
                     ERc->y1[0] = rpc->y[0];
                     ERc->z1[0] = rpc->z[0];
                     ERc->pt1 = rpc;
                     ERc->magnitude = 0.0;
                     ERc->keyval = PNOCOVERLV;
                     ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                     ERc->Sindex1 = rpc->Sindex;
                     ERc->IDN1 = rpc->idn;
                     ERc->next = NULL;
                     if(ERroot == NULL)
                        {
                        ERroot = ERc;
                        }
                     else
                        {
                        ERn = ERroot;
                        while(ERn != NULL)
                          {
                            if(
                               (ERn->Cnumber    == ERc->Cnumber) &&
                               (ERn->keyval    == ERc->keyval) &&
                               (ERn->x1[0]     == ERc->x1[0])  &&
                               (ERn->y1[0]     == ERc->y1[0])  &&
                               (ERn->Sindex1   == ERc->Sindex1) &&
                               (ERn->IDN1      == ERc->IDN1)
                               )
                              {
                                  break;
                              }
                            ERn = ERn->next;
                          }
                        if(ERn == NULL)
                           {
                           ERc->next = ERroot;
                           ERroot = ERc;
                           }
                        else
                           {
                           free(ERc);
                           }
                        }
                     } /**** end if rlc != NULL ****/
                  }
               } /** end of check PNOCOVERLV **/

         if((rpc->numverts == -1) && /*** rpc is a pure point ***/
             (OSIDE_LatLon_Count < OSIDE_LL_Limit) &&
             (CombinedCheckApplies(rpc->idn,checkinstance,OSIDE_LAT,rpc->Lindex,rpc->Sindex,
                         Config1,Strat1,Domain1,&part1,&part2,&part3) > 0) &&
                     (part1 > 0))
            {
            temptolerance = FindRelevantSensitivity(OSIDE_LAT, checkinstance, &tolerancepad);

            temptolerance = YCoordToProjectCoord(temptolerance);
            tolerancepad = YCoordToProjectCoord(tolerancepad);

            if(tolerancepad < temptolerance)
               {
               unuseddbl = tolerancepad;
               temptolerance = tolerancepad;
               tolerancepad = unuseddbl;
               }
            temptolerance -= ActiveChecks[checkinstance].sensitivity3;
            tolerancepad += ActiveChecks[checkinstance].sensitivity3;


            if((rpc->y[0] < temptolerance) || (rpc->y[0] > tolerancepad))
                {
                OSIDE_LatLon_Count += 1;
                ERc = (struct PointRelatedCollection *) (malloc(SzPRC));
                if(ERc == NULL)
                   {
                   printf("allocation memory exhausted during point feature condition analysis\n");
                   printf("processing cannot continue\n");
                   exit(-1);
                   }
                ERc->x1[0] = rpc->x[0];
                ERc->y1[0] = rpc->y[0];
                ERc->z1[0] = rpc->z[0];
                ERc->pt1 = rpc;
                if(rpc->y[0] > tolerancepad)
                   ERc->magnitude = rpc->y[0] - tolerancepad;
                else
                   ERc->magnitude = temptolerance - rpc->y[0];

                ERc->keyval = OSIDE_LAT;
                ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                ERc->Sindex1 = rpc->Sindex;
                ERc->IDN1 = rpc->idn;
                ERc->next = NULL;
                if(ERroot == NULL)
                   {
                   ERroot = ERc;
                   }
                else
                   {
                   ERn = ERroot;
                   while(ERn != NULL)
                     {
                     if((ERn->Cnumber == ERc->Cnumber) && (ERn->keyval == ERc->keyval) &&
                          (ERn->x1[0] == ERc->x1[0])  && (ERn->y1[0] == ERc->y1[0])  &&
                          (ERn->Sindex1 == ERc->Sindex1) && (ERn->IDN1 == ERc->IDN1))
                        {
                        break;
                        }
                     ERn = ERn->next;
                     }
                   if(ERn == NULL)
                      {
                      ERc->next = ERroot;
                      ERroot = ERc;
                      }
                   else
                      {
                      free(ERc);
                      }
                   }
                }
            } /*** end OSIDE_LAT ***/



         if((rpc->numverts == -1) && /*** rpc is a pure point ***/
             (OSIDE_LatLon_Count < OSIDE_LL_Limit) &&

             (CombinedCheckApplies(rpc->idn,checkinstance,OSIDE_LON,rpc->Lindex,rpc->Sindex,
                         Config1,Strat1,Domain1,&part1,&part2,&part3) > 0) &&
                     (part1 > 0))
            {
            temptolerance = FindRelevantSensitivity(OSIDE_LON, checkinstance, &tolerancepad);

            temptolerance = XCoordToProjectCoord(temptolerance);
            tolerancepad = XCoordToProjectCoord(tolerancepad);

            if(tolerancepad < temptolerance)
               {
               unuseddbl = tolerancepad;
               temptolerance = tolerancepad;
               tolerancepad = unuseddbl;
               }
            temptolerance -= ActiveChecks[checkinstance].sensitivity3;
            tolerancepad += ActiveChecks[checkinstance].sensitivity3;

            if((rpc->x[0] < temptolerance) || (rpc->x[0] > tolerancepad))
                {
                OSIDE_LatLon_Count += 1;
                ERc = (struct PointRelatedCollection *) (malloc(SzPRC));
                if(ERc == NULL)
                   {
                   printf("allocation memory exhausted during point feature condition analysis\n");
                   printf("processing cannot continue\n");
                   exit(-1);
                   }
                ERc->x1[0] = rpc->x[0];
                ERc->y1[0] = rpc->y[0];
                ERc->z1[0] = rpc->z[0];
                ERc->pt1 = rpc;
                if(rpc->x[0] > tolerancepad)
                   ERc->magnitude = rpc->x[0] - tolerancepad;
                else
                   ERc->magnitude = temptolerance - rpc->x[0];
                ERc->keyval = OSIDE_LON;
                ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                ERc->Sindex1 = rpc->Sindex;
                ERc->IDN1 = rpc->idn;
                ERc->next = NULL;
                if(ERroot == NULL)
                   {
                   ERroot = ERc;
                   }
                else
                   {
                   ERn = ERroot;
                   while(ERn != NULL)
                     {
                     if((ERn->Cnumber == ERc->Cnumber) && (ERn->keyval == ERc->keyval) &&
                          (ERn->x1[0] == ERc->x1[0])  && (ERn->y1[0] == ERc->y1[0])  &&
                          (ERn->Sindex1 == ERc->Sindex1) && (ERn->IDN1 == ERc->IDN1))
                        {
                        break;
                        }
                     ERn = ERn->next;
                     }
                   if(ERn == NULL)
                      {
                      ERc->next = ERroot;
                      ERroot = ERc;
                      }
                   else
                      {
                      free(ERc);
                      }
                   }
                }
            } /*** end OSIDE_LON ***/


         if((rpc->numverts == -1) && /*** rpc is a pure point ***/
             (CombinedCheckApplies(rpc->idn,checkinstance,FEATOUTSIDE,rpc->Lindex,rpc->Sindex,
                         Config1,Strat1,Domain1,&part1,&part2,&part3) > 0) &&
                     (part1 > 0))
            {
            FoundCondition = 0;
            tolerancepad = FindRelevantSensitivity(FEATOUTSIDE,checkinstance,&unuseddbl);
            if(rpc->x[0] > LAEmaxx)
                {
                ptldist = Distance(rpc->x[0],rpc->y[0],LAEmaxx,rpc->y[0]);
                if(ptldist > tolerancepad)
                   FoundCondition = 1;
                }
            if((FoundCondition  == 0) && (rpc->x[0] < LAEminx))
                {
                ptldist = Distance(rpc->x[0],rpc->y[0],LAEminx,rpc->y[0]);
                if(ptldist > tolerancepad)
                   FoundCondition = 1;
                }
            if((FoundCondition  == 0) && (rpc->y[0] > LAEmaxy))
                {
                ptldist = Distance(rpc->x[0],rpc->y[0],rpc->x[0],LAEmaxy);
                if(ptldist > tolerancepad)
                   FoundCondition = 1;
                }
            if((FoundCondition  == 0) && (rpc->y[0] < LAEminy))
                {
                ptldist = Distance(rpc->x[0],rpc->y[0],rpc->x[0],LAEminy);
                if(ptldist > tolerancepad)
                   FoundCondition = 1;
                }

             if(FoundCondition > 0)
                {
                ERc = (struct PointRelatedCollection *) (malloc(SzPRC));
                if(ERc == NULL)
                   {
                   printf("allocation memory exhausted during point feature condition analysis\n");
                   printf("processing cannot continue\n");
                   exit(-1);
                   }
                ERc->x1[0] = rpc->x[0];
                ERc->y1[0] = rpc->y[0];
                ERc->z1[0] = rpc->z[0];
                ERc->pt1 = rpc;
                ERc->magnitude = ptldist;
                ERc->keyval = FEATOUTSIDE;
                ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                ERc->Sindex1 = rpc->Sindex;
                ERc->IDN1 = rpc->idn;
                ERc->next = NULL;
                if(ERroot == NULL)
                   {
                   ERroot = ERc;
                   }
                else
                   {
                   ERn = ERroot;
                   while(ERn != NULL)
                     {
                     if((ERn->Cnumber == ERc->Cnumber) && (ERn->keyval == ERc->keyval) &&
                          (ERn->x1[0] == ERc->x1[0])  && (ERn->y1[0] == ERc->y1[0])  &&
                          (ERn->Sindex1 == ERc->Sindex1) && (ERn->IDN1 == ERc->IDN1))
                        {
                        break;
                        }
                     ERn = ERn->next;
                     }
                   if(ERn == NULL)
                      {
                      ERc->next = ERroot;
                      ERroot = ERc;
                      }
                   else
                      {
                      free(ERc);
                      }
                   }
                }
            }



         if((rpc->numverts == -1) && /*** rpc is a pure point ***/
             (CombinedCheckApplies(rpc->idn,checkinstance,BNDRYUNDERSHT,rpc->Lindex,rpc->Sindex,
                         Config1,Strat1,Domain1,&part1,&part2,&part3) > 0) &&
                     (part1 > 0))
            {
            FoundCondition = 0;
            tolerancepad = FindRelevantSensitivity(BNDRYUNDERSHT,checkinstance,&temptolerance);
            if(rpc->x[0] < LAEmaxx)
                {
                ptldist = Distance(rpc->x[0],rpc->y[0],LAEmaxx,rpc->y[0]);
                if((ptldist > tolerancepad) && (ptldist < temptolerance))
                   FoundCondition = 1;
                }
            if((FoundCondition  == 0) && (rpc->x[0] > LAEminx))
                {
                ptldist = Distance(rpc->x[0],rpc->y[0],LAEminx,rpc->y[0]);
                if((ptldist > tolerancepad) && (ptldist < temptolerance))
                   FoundCondition = 1;
                }
            if((FoundCondition  == 0) && (rpc->y[0] < LAEmaxy))
                {
                ptldist = Distance(rpc->x[0],rpc->y[0],rpc->x[0],LAEmaxy);
                if((ptldist > tolerancepad) && (ptldist < temptolerance))
                   FoundCondition = 1;
                }
            if((FoundCondition  == 0) && (rpc->y[0] > LAEminy))
                {
                ptldist = Distance(rpc->x[0],rpc->y[0],rpc->x[0],LAEminy);
                if((ptldist > tolerancepad) && (ptldist < temptolerance))
                   FoundCondition = 1;
                }

             if(FoundCondition > 0)
                {
                ERc = (struct PointRelatedCollection *) (malloc(SzPRC));
                if(ERc == NULL)
                   {
                   printf("allocation memory exhausted during point feature condition analysis\n");
                   printf("processing cannot continue\n");
                   exit(-1);
                   }
                ERc->x1[0] = rpc->x[0];
                ERc->y1[0] = rpc->y[0];
                ERc->z1[0] = rpc->z[0];
                ERc->pt1 = rpc;
                ERc->magnitude = ptldist;
                ERc->keyval = BNDRYUNDERSHT;
                ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                ERc->Sindex1 = rpc->Sindex;
                ERc->IDN1 = rpc->idn;
                ERc->next = NULL;
                if(ERroot == NULL)
                   {
                   ERroot = ERc;
                   }
                else
                   {
                   ERn = ERroot;
                   while(ERn != NULL)
                     {
                     if((ERn->Cnumber == ERc->Cnumber) && (ERn->keyval == ERc->keyval) &&
                          (ERn->x1[0] == ERc->x1[0])  && (ERn->y1[0] == ERc->y1[0])  &&
                          (ERn->Sindex1 == ERc->Sindex1) && (ERn->IDN1 == ERc->IDN1))
                        {
                        break;
                        }
                     ERn = ERn->next;
                     }
                   if(ERn == NULL)
                      {
                      ERc->next = ERroot;
                      ERroot = ERc;
                      }
                   else
                      {
                      free(ERc);
                      }
                   }
                }
            }






         if((rpc->numverts == -1) && /*** rpc is a pure point ***/
             (CombinedCheckApplies(rpc->idn,checkinstance,CONNECTFAIL,rpc->Lindex,rpc->Sindex,Config1,Strat1,Domain1,&part1,&part2,&part3) > 0) &&
                     (part1 > 0))
            {
mindist = 100000.0;
            isclose = 0;
            npc = root;
            while(npc != NULL)
               {
               Config2 = SCCtable[npc->Sindex].C;
               Strat2 = SCCtable[npc->Sindex].S;
               Domain2 = SCCtable[npc->Sindex].D;
               if((npc != rpc) && (npc->numverts == -1) && /** npc is a pure point ***/
                   (CombinedCheckApplies(npc->idn,checkinstance,CONNECTFAIL,npc->Lindex,npc->Sindex,Config2,Strat2,Domain2,&part1,&part2,&part3) > 0) &&
                    (part2 > 0))
                  {     
                  ptldist = Distance(rpc->x[0],rpc->y[0],npc->x[0],npc->y[0]);
                  if(SensitivityCheck(LTEQ, CONNECTFAIL, checkinstance, ptldist) > 0)
                     {
                     isclose = 1;
                     break;
                     }
                  }
               npc = npc->next;
               } /*** end while looking at neighbot points ***/

            if(isclose == 0)
               {
               rlc = Lroot;
               while(rlc != NULL)
                  {
                  Config2 = SCCtable[rlc->Sindex].C;
                  Strat2 = SCCtable[rlc->Sindex].S;
                  Domain2 = SCCtable[rlc->Sindex].D;
                  if(CombinedCheckApplies(rlc->idn,checkinstance,CONNECTFAIL,rlc->Lindex,rlc->Sindex,Config2,Strat2,Domain2,&part1,&part2,&part3) > 0)
                     {
                     if(part2 > 0)
                        {
                        for(j=1; j<rlc->numnodes; j++)
                           {
                           jj = j - 1;
                           ptldist = PointToLineDist2D(rpc->x[0], rpc->y[0], rlc->x[jj], rlc->y[jj], rlc->x[j], rlc->y[j]);
                           if(SensitivityCheck(LTEQ, CONNECTFAIL, checkinstance, ptldist) > 0)
                              {
                              isclose = 1;
                              break;  /*** break from the for loop ***/
                              } /**** end if(SensitivityCheck****/
                           } /*** end for(j=1; j<rlc->numnodes; j++) ***/
                        }
                     }
                  if(isclose > 0)
                     break;
                  rlc = rlc->next;
                  }
               }

            if(isclose == 0)
               {
               rac = Aroot;
               while((rac != NULL) && (isclose == 0))
                  {
                  Config2 = SCCtable[rac->Sindex].C;
                  Strat2 = SCCtable[rac->Sindex].S;
                  Domain2 = SCCtable[rac->Sindex].D;
                  if((CombinedCheckApplies(rac->idn,checkinstance,CONNECTFAIL,rac->Lindex,rac->Sindex,Config2,Strat2,Domain2,&part1,&part2,&part3) > 0)
                       && (part2 > 0))
                     {
                     ptldist = PointToArealDist2D(rpc->x[0], rpc->y[0], rac);
                     if((SensitivityCheck(LTEQ, CONNECTFAIL, checkinstance, ptldist) > 0) ||
                                (PointInsideArealWithHoles(rpc->x[0], rpc->y[0], Aroot, rac) > 0))
                        {
                        isclose = 1;
                        break;
                        }
                     }
                  if(isclose > 0)
                     break;
                  rac = rac->next;
                  }
               }

            if(isclose == 0)
               {
               ERc = (struct PointRelatedCollection *) (malloc(SzPRC));
               if(ERc == NULL)
                  {
                  printf("allocation memory exhausted during point feature condition analysis\n");
                  printf("processing cannot continue\n");
                  exit(-1);
                  }
               ERc->x1[0] = rpc->x[0];
               ERc->y1[0] = rpc->y[0];
               ERc->z1[0] = rpc->z[0];
               ERc->magnitude = 0;
               ERc->keyval = CONNECTFAIL;
               ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
               ERc->Sindex1 = rpc->Sindex;
               ERc->IDN1 = rpc->idn;
               ERc->pt1 = rpc;
               ERc->pt2 = NULL;
               ERc->next = NULL;
               if(ERroot == NULL)
                  {
                  ERroot = ERc;
                  }
               else
                 {
                   ERn = ERroot;
                   while(ERn != NULL)
                     {
                       if((ERn->Cnumber  == ERc->Cnumber)  && (ERn->keyval  == ERc->keyval))
                          {
                          if((ERn->x1[0]   == ERc->x1[0])   && (ERn->y1[0]   == ERc->y1[0])   &&
                                     (ERn->Sindex1 == ERc->Sindex1))
                            {
                               break;
                            }
                         }
                       ERn = ERn->next;
                     }
                  if(ERn == NULL)
                     {
                     ERc->next = ERroot;
                     ERroot = ERc;
                     }
                  else
                     {
                     free(ERc);
                     }
                  }
               }
            } /** end CONNECTFAIL check for primary point feature ***/


          if((rpc->numverts == -1) &&
           (CombinedCheckApplies(rpc->idn,checkinstance,LLAINT,rpc->Lindex,rpc->Sindex,Config1,Strat1,Domain1,&part1,&part2,&part3) > 0) &&
                      (part1 > 0))
             {
             if((rpc->x[0] >= minx) && (rpc->x[0] <= maxx) && (rpc->y[0] >= miny) && (rpc->y[0] <= maxy))
                {
                tolerancepad = FindRelevantSensitivity(LLAINT,checkinstance,&unuseddbl); 
                rln = Lroot;
                keepit = 0;
                while(rln != NULL)
                   {
                   if((CombinedCheckApplies(rln->idn,checkinstance,LLAINT,rln->Lindex,rln->Sindex,
                          SCCtable[rln->Sindex].C,SCCtable[rln->Sindex].S,SCCtable[rln->Sindex].D,&part1,&part2,&part3) > 0) &&
                                       (part2 > 0))
                      {
                      for(k=1; k<rln->numnodes; k++)
                         {
                         kk = k - 1;
                         ptldist = PointToLineDist2D(rpc->x[0], rpc->y[0], rln->x[kk], rln->y[kk], rln->x[k], rln->y[k]);
                         if(ptldist <= tolerancepad)
                            {
                            keepit = 1;
                            break;
                            }
                         }
                      }
                   if(keepit > 0)
                      break;
                   rln = rln->next;
                   } /** end while rln ***/

                if(rln != NULL) /** then found an applicable end node to end node connection at point (rpc->x[0], rpc->y[0] ***/
                   {
                   rac = Aroot;
                   while(rac != NULL)
                      {
                      if((CombinedCheckApplies(rac->idn,checkinstance,LLAINT,rac->Lindex,rac->Sindex,
                            SCCtable[rac->Sindex].C,SCCtable[rac->Sindex].S,SCCtable[rac->Sindex].D,&part1,&part2,&part3) > 0) &&
                                       (part3 > 0))
                         {
                         if(rac->RB_Tree_Edgelist == NULL)
                            ptpdist = PointToSmallArealDist2D(rpc->x[0], rpc->y[0],rac,&unusedint,&unuseddbl);
                         else
                            ptpdist = PointToLargeArealDist2D(rpc->x[0], rpc->y[0],rac,&unusedint,&unuseddbl);

                         if((ptpdist >= 0.0) && (ptpdist < tolerancepad)) /** seems we have found the condition ***/
                            {
                            ERc = (struct PointRelatedCollection *) (malloc(SzPRC));
                            if(ERc == NULL)
                               {
                               printf("allocation memory exhausted during linear feature condition analysis\n");
                               printf("processing cannot continue\n");
                               exit(-1);
                               }
                            ERc->x1[0] = rpc->x[0];
                            ERc->y1[0] = rpc->y[0];
                            ERc->z1[0] = rpc->z[0];

                            ERc->x1[1] = rln->x[k];
                            ERc->y1[1] = rln->y[k];
                            ERc->z1[1] = rln->z[k];
                            ERc->x1[2] = rln->x[kk];
                            ERc->y1[2] = rln->y[kk];
                            ERc->z1[2] = rln->z[kk];
                            
                            ERc->keyval = LLAINT;
                            ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                            ERc->pt1 = rpc;
                            ERc->ll = rln;
                            ERc->Sindex1 = rpc->Sindex;
                            ERc->next = NULL;
                            if(ERroot == NULL)
                               {
                               ERroot = ERc;
                               }
                            else
                               {
                               ERn = ERroot;
                               while(ERn != NULL)
                                  {
                                  if((ERn->Cnumber == ERc->Cnumber) && (ERn->keyval == ERc->keyval) &&
                                     (ERn->pt1 == ERc->pt1) && (ERn->Sindex1 == ERc->Sindex1) &&
                                     (ERn->x1[0] == ERc->x1[0]) && (ERn->y1[0] == ERc->y1[0]) && (ERn->z1[0] == ERc->z1[0]))
                                     {
                                     break;
                                     }
                                  ERn = ERn->next;
                                  }
                               if(ERn == NULL)
                                  {
                                  ERc->next = ERroot;
                                  ERroot = ERc;
                                  }
                               else
                                  free(ERc);
                               }
                            break; /** from the while rac loop ***/
                            } /*** end found the condition ***/
                         } /*** end check applies to this area feature ***/
                      rac = rac->next;
                      } /** end while rac != NULL ***/
                   } /*** end found the right type of end node match ***/
                }  /** end rpc is in the current load module ***/
             } /*** end LLAINT check applies ***/




            if(CombinedCheckApplies(rpc->idn,checkinstance,PLLPROXFAIL,rpc->Lindex,rpc->Sindex,Config1,Strat1,Domain1,&part1,&part2,&part3) > 0)
               {
               if(part1 > 0)
                  {
                  isclose = 0;
                  timesthroughloop = 0;
                  while((isclose == 0) && (timesthroughloop < 2))
                     {
                     timesthroughloop += 1;
                     if(timesthroughloop == 1)
                        rlc = Lroot;
                     else 
                        {
                        temptolerance = FindRelevantSensitivity(PLLPROXFAIL,checkinstance,&unuseddbl);
                        ptldist = Distance(rpc->x[0], rpc->y[0], rpc->x[0]+temptolerance, rpc->y[0]);
                        xi = (temptolerance * temptolerance) / ptldist;
                        ptldist = Distance(rpc->x[0], rpc->y[0], rpc->x[0], rpc->y[0]+temptolerance);
                        yi = (temptolerance * temptolerance) / ptldist;
      
                        li = (int) ((rpc->x[0] - xi) / RegionSize);
                        ui = (int) ((rpc->x[0] + xi) / RegionSize);
                        lj = (int) ((rpc->y[0] - yi) / RegionSize);
                        uj = (int) ((rpc->y[0] + yi) / RegionSize);
      
                        if(li < 0)   li = 0;
                        if(lj < 0)   lj = 0;
                        if(ui > MaxXindex)     ui = MaxXindex;
                        if(uj > MaxYindex)     uj = MaxYindex;

                        LookForFeature = 0;
      
                        for(index1 = li; index1 <= ui; index1++)
                           {
                           LookForFeature = 0;
                           for(index2 = lj; index2 <= uj; index2++)
                              {
                              LookForFeature = 0;
                              thisindex = (index1 * (MaxYindex + 1)) + index2;
                              if(thisindex != cindex)
                                 {
                                 for(k=0; k<LindexTable[thisindex].inside; k++)
                                    {
                                    LookForFeature = 0;
                                    FLindex =  LindexTable[thisindex].indices[k];
                                    if(CrsWlk[FLindex].geomtype == C_LINE)
                                       {
                                       FSindex = CrsWlk[FLindex].LtoSmapping;
                                       if(ActiveChecks[checkinstance].number == PLLPROXFAIL)
                                          {
                                          if(ActiveChecks[checkinstance].secondaryEDCSstuff != NULL)
                                             {
                                             if(ActiveChecks[checkinstance].secondaryEDCSstuff[FLindex] == 1)
                                                {
                                                LookForFeature = 1;
                                                break;
                                                }
                                             else if((ActiveChecks[checkinstance].Config2[SCCtable[FSindex].C] == 1) &&
                                                    (ActiveChecks[checkinstance].Stratum2[SCCtable[FSindex].S] == 1) &&
                                                    (ActiveChecks[checkinstance].Domain2[SCCtable[FSindex].D] == 1) &&
                                                    (ActiveChecks[checkinstance].secondaryEDCSstuff[FLindex] != 2))
                                                {
                                                LookForFeature = 1;
                                                break;
                                                }
                                             }
                                          else if((ActiveChecks[checkinstance].Config2[SCCtable[FSindex].C] == 1) &&
                                                 (ActiveChecks[checkinstance].Stratum2[SCCtable[FSindex].S] == 1) &&
                                                 (ActiveChecks[checkinstance].Domain2[SCCtable[FSindex].D] == 1))
                                             {
                                             LookForFeature = 1;
                                             break;
                                             }
                                          }
                                       } /*** end CrsWlk says this Lindex is a point ***/
                                    if(LookForFeature > 0)
                                       break;
                                    } /*** end for k ***/
                                 } /** end thisindex != cindex ***/
                              if(LookForFeature > 0)
                                 break;
                              } /*** end for index2 ***/
                           if(LookForFeature > 0)
                              break;
                           } /*** end for index1 ***/

                        if(LookForFeature > 0)
                           {
                           if((L_NeighborsLoaded == 0) && (CrsWlk[FLindex].geomtype == C_LINE))
                              {
                              L_NeighborsLoaded = 1;
                              FindApplicableNeighborFeatures(cindex, ptsin, minx, maxx, miny, maxy, 0, 1 , 0, 1);
                              }
      
                           rlc = TgtLroot;
                           }
                        else
                           {
                           rlc = NULL;
                           }
                        } /*** end else time through loop > 1 ****/
                     while(rlc != NULL)
                        {
                        Config2 = SCCtable[rlc->Sindex].C;
                        Strat2  = SCCtable[rlc->Sindex].S;
                        Domain2 = SCCtable[rlc->Sindex].D;
                        if(CombinedCheckApplies(rlc->idn,checkinstance,PLLPROXFAIL,rlc->Lindex,rlc->Sindex,Config2,Strat2,Domain2,&part1,&part2,&part3) > 0)
                           {
                           if(part2 > 0)
                              {
                              if(timesthroughloop == 1)
                                 rln = Lroot;
                              else
                                 rln = TgtLroot;
                              while(rln != NULL)
                                 {
                                 if(rln != rlc)
                                    {
                                    Config3 = SCCtable[rln->Sindex].C;
                                    Strat3  = SCCtable[rln->Sindex].S;
                                    Domain3 = SCCtable[rln->Sindex].D;
                                    if(CombinedCheckApplies(rln->idn,checkinstance,PLLPROXFAIL,rln->Lindex,rln->Sindex,Config3,Strat3,Domain3,&part1,&part2,&part3) > 0)
                                       {
                                       if(part3 > 0)
                                          {
                                          for(j=1; j<rlc->numnodes; j++)
                                             {
                                             jj = j - 1;
                                             ptldistbase = PointToLineDist2D(rpc->x[0], rpc->y[0],
                                                            rlc->x[jj], rlc->y[jj], rlc->x[j], rlc->y[j]);
                                             if(SensitivityCheck(LTEQ, PLLPROXFAIL, checkinstance, ptldistbase) > 0)
                                                {
                                                for(k=1; k<rln->numnodes; k++)
                                                   {
                                                   kk = k - 1;
                                                   ptldist = PointToLineDist2D(rpc->x[0], rpc->y[0],
                                                                   rln->x[kk], rln->y[kk], rln->x[k], rln->y[k]);
                                                   if(SensitivityCheck(LTEQ, PLLPROXFAIL, checkinstance, ptldist) > 0)
                                                      {
                                                      if(LineSegmentsIntersect(rlc->x[jj],rlc->y[jj],rlc->x[j],rlc->y[j],
                                                                    rln->x[kk],rln->y[kk],rln->x[k],rln->y[k],&xi, &yi) > 0)
                                                         {
                                                         ptldist = Distance(rpc->x[0],rpc->y[0],xi,yi);
                                                         if(SensitivityCheck(LTEQ, PLLPROXFAIL, checkinstance, ptldist) > 0)
                                                            {
                                                            isclose = 1;
                                                            break;
                                                            }
                                                         }
                                                      else
                                                         {
                                                         ptldist = PointToLineDist2DwithFlag(rpc->x[0], rpc->y[0],
                                                                   rln->x[kk], rln->y[kk], rln->x[k], rln->y[k],&unuseddbl);
                                                         xi = PTL_Dist_Xi;
                                                         yi = PTL_Dist_Yi;
                                                         ptldist = PointToLineDist2DwithFlag(rpc->x[0], rpc->y[0],
                                                                   rlc->x[jj], rlc->y[jj], rlc->x[j], rlc->y[j],&unuseddbl);
                                                         ptldist = Distance(xi,yi,PTL_Dist_Xi,PTL_Dist_Yi);
                                                         if(SensitivityCheck(LTEQ, PLLPROXFAIL, checkinstance, ptldist) > 0)
                                                            {
                                                            isclose = 1;
                                                            break;
                                                            }
                                                         }
                                                      }
                                                   }
                                                } /** end for k ***/
                                             if(isclose > 0)
                                                break;
                                             } /** end for j ***/
                                          } /** end part3 OK **/
                                       } /*** end check applies to 2d line ***/
                                    } /** end rln != rlc ***/
                                 if(isclose > 0)
                                    break;
                                 rln = rln->next;
                                 } /** end while rln ***/
                              if(isclose == 0) /** did not find a line line int - go for line area feature int **/
                                 {
                                 if(timesthroughloop == 1)
                                    rac = Aroot;
                                 else
                                    {
                                    temptolerance = FindRelevantSensitivity(PLLPROXFAIL,checkinstance,&unuseddbl);
                                    ptldist = Distance(rpc->x[0], rpc->y[0], rpc->x[0]+temptolerance, rpc->y[0]);
                                    xi = (temptolerance * temptolerance) / ptldist;
                                    ptldist = Distance(rpc->x[0], rpc->y[0], rpc->x[0], rpc->y[0]+temptolerance);
                                    yi = (temptolerance * temptolerance) / ptldist;

                                    li = (int) ((rpc->x[0] - xi) / RegionSize);
                                    ui = (int) ((rpc->x[0] + xi) / RegionSize);
                                    lj = (int) ((rpc->y[0] - yi) / RegionSize);
                                    uj = (int) ((rpc->y[0] + yi) / RegionSize);

                                    if(li < 0)   li = 0;
                                    if(lj < 0)   lj = 0;
                                    if(ui > MaxXindex)     ui = MaxXindex;
                                    if(uj > MaxYindex)     uj = MaxYindex;

                                    LookForFeature = 0;

                                    for(index1 = li; index1 <= ui; index1++)
                                       {
                                       LookForFeature = 0;
                                       for(index2 = lj; index2 <= uj; index2++)
                                          {
                                          LookForFeature = 0;
                                          thisindex = (index1 * (MaxYindex + 1)) + index2;
                                          if(thisindex != cindex)
                                             {
                                             for(k=0; k<LindexTable[thisindex].inside; k++)
                                                {
                                                LookForFeature = 0;
                                                FLindex =  LindexTable[thisindex].indices[k];
                                                if(CrsWlk[FLindex].geomtype == C_AREA)
                                                   {
                                                   FSindex = CrsWlk[FLindex].LtoSmapping;
                                                   if(ActiveChecks[checkinstance].number == PLLPROXFAIL)
                                                      {
                                                      if(ActiveChecks[checkinstance].secondaryEDCSstuff != NULL)
                                                         {
                                                         if(ActiveChecks[checkinstance].secondaryEDCSstuff[FLindex] == 1)
                                                            {
                                                            LookForFeature = 1;
                                                            break;
                                                            }
                                                         else if((ActiveChecks[checkinstance].Config2[SCCtable[FSindex].C] == 1) &&
                                                                (ActiveChecks[checkinstance].Stratum2[SCCtable[FSindex].S] == 1) &&
                                                                (ActiveChecks[checkinstance].Domain2[SCCtable[FSindex].D] == 1) &&
                                                                (ActiveChecks[checkinstance].secondaryEDCSstuff[FLindex] != 2))
                                                            {
                                                            LookForFeature = 1;
                                                            break;
                                                            }
                                                         }
                                                      else if((ActiveChecks[checkinstance].Config2[SCCtable[FSindex].C] == 1) &&
                                                             (ActiveChecks[checkinstance].Stratum2[SCCtable[FSindex].S] == 1) &&
                                                             (ActiveChecks[checkinstance].Domain2[SCCtable[FSindex].D] == 1))
                                                         {
                                                         LookForFeature = 1;
                                                         break;
                                                         }
                                                      }
                                                   } /*** end CrsWlk says this Lindex is a point ***/ 
                                                if(LookForFeature > 0)
                                                   break;
                                                } /*** end for k ***/
                                             } /** end thisindex != cindex ***/
                                          if(LookForFeature > 0) 
                                             break;
                                          } /*** end for index2 ***/
                                       if(LookForFeature > 0)
                                          break;
                                       } /*** end for index1 ***/
         
                                    if(LookForFeature > 0) 
                                       {
                                       if((A_NeighborsLoaded == 0) && (CrsWlk[FLindex].geomtype == C_AREA))
                                          {
                                          A_NeighborsLoaded = 1;
                                          FindApplicableNeighborFeatures(cindex, ptsin, minx, maxx, miny, maxy, 1, 0 , 0, 1);
                                          }
         
                                       rac = TgtAroot; 
                                       }
                                    else
                                       rac = NULL;
                                    } /*** end else time through loop > 1 ****/

                                 while((rac != NULL) && (isclose == 0))
                                    {
                                    Config3 = SCCtable[rac->Sindex].C;
                                    Strat3 = SCCtable[rac->Sindex].S;
                                    Domain3 = SCCtable[rac->Sindex].D;
                                    if((CombinedCheckApplies(rac->idn,checkinstance,PLLPROXFAIL,rac->Lindex,rac->Sindex,Config3,Strat3,Domain3,&part1,&part2,&part3) > 0)
                                      && (part3 > 0))
                                       {
                                       if(PointInsideArealWithHoles(rpc->x[0], rpc->y[0], Aroot, rac) > 0)
                                          {
                                          for(j=1; j<rlc->numnodes; j++)
                                             {
                                             jj = j - 1;
                                             ptldist = PointToLineDist2D(rpc->x[0], rpc->y[0], rlc->x[jj], rlc->y[jj], rlc->x[j], rlc->y[j]);
                                             if(SensitivityCheck(LTEQ, PLLPROXFAIL, checkinstance, ptldist) > 0)
                                                {
                                                isclose = 1;
                                                break;
                                                }
                                             } /** end for j ***/
                                          } /*** end point si inside this area feature ***/
                                       if(isclose == 0)
                                          {
                                          ptldist = PointToArealDist2D(rpc->x[0], rpc->y[0], rac);
                                          if(SensitivityCheck(LTEQ, PLLPROXFAIL, checkinstance, ptldist) > 0)
                                             {
                                             for(j=1; j<rlc->numnodes; j++)
                                                {
                                                jj = j - 1;
                                                ptldist = PointToLineDist2D(rpc->x[0], rpc->y[0], rlc->x[jj], rlc->y[jj], rlc->x[j], rlc->y[j]);
                                                if(SensitivityCheck(LTEQ, PLLPROXFAIL, checkinstance, ptldist) > 0)
                                                   {
                                                   isclose = 1;
                                                   break;
                                                   }
                                                } /** end for j ***/
                                             }  /** end sensitivity chack for pt dist to area feature **/
                                          } /*** end try second approach, pt outside but close to area feature ***/
                                       } /***end if OK and part 3 ***/
                                    if(isclose == 1)
                                       break;
                                    rac = rac->next;
                                    } /** end while rac ***/
                                 } /*** end isclose == 0 so try line area feature matchup ***/
                              } /** end if part 2 OK ***/
                           } /*** end if check applies to first line ***/
                        if(isclose > 0)
                           break;
                        rlc = rlc->next;
                        } /*** end while rlc ***/
                     if(isclose == 0)
                        {
                        if(timesthroughloop == 1)
                           rac = Aroot;
                        else
                           {
                           temptolerance = FindRelevantSensitivity(PLLPROXFAIL,checkinstance,&unuseddbl);
                           ptldist = Distance(rpc->x[0], rpc->y[0], rpc->x[0]+temptolerance, rpc->y[0]);
                           xi = (temptolerance * temptolerance) / ptldist;
                           ptldist = Distance(rpc->x[0], rpc->y[0], rpc->x[0], rpc->y[0]+temptolerance);
                           yi = (temptolerance * temptolerance) / ptldist;

                           li = (int) ((rpc->x[0] - xi) / RegionSize);
                           ui = (int) ((rpc->x[0] + xi) / RegionSize);
                           lj = (int) ((rpc->y[0] - yi) / RegionSize);
                           uj = (int) ((rpc->y[0] + yi) / RegionSize);

                           if(li < 0)   li = 0;
                           if(lj < 0)   lj = 0;
                           if(ui > MaxXindex)     ui = MaxXindex;
                           if(uj > MaxYindex)     uj = MaxYindex;

                           LookForFeature = 0;

                           for(index1 = li; index1 <= ui; index1++)
                              {
                              LookForFeature = 0;
                              for(index2 = lj; index2 <= uj; index2++)
                                 {
                                 LookForFeature = 0;
                                 thisindex = (index1 * (MaxYindex + 1)) + index2;
                                 if(thisindex != cindex)
                                    {
                                    for(k=0; k<LindexTable[thisindex].inside; k++)
                                       {
                                       LookForFeature = 0;
                                       FLindex =  LindexTable[thisindex].indices[k];
                                       if(CrsWlk[FLindex].geomtype == C_AREA)
                                          {
                                          FSindex = CrsWlk[FLindex].LtoSmapping;
                                          if(ActiveChecks[checkinstance].number == PLLPROXFAIL)
                                             {
                                             if(ActiveChecks[checkinstance].secondaryEDCSstuff != NULL)
                                                {
                                                if(ActiveChecks[checkinstance].secondaryEDCSstuff[FLindex] == 1)
                                                   {
                                                   LookForFeature = 1;
                                                   break;
                                                   }
                                                else if((ActiveChecks[checkinstance].Config2[SCCtable[FSindex].C] == 1) &&
                                                       (ActiveChecks[checkinstance].Stratum2[SCCtable[FSindex].S] == 1) &&
                                                       (ActiveChecks[checkinstance].Domain2[SCCtable[FSindex].D] == 1) &&
                                                       (ActiveChecks[checkinstance].secondaryEDCSstuff[FLindex] != 2))
                                                   {
                                                   LookForFeature = 1;
                                                   break;
                                                   }
                                                }
                                             else if((ActiveChecks[checkinstance].Config2[SCCtable[FSindex].C] == 1) &&
                                                    (ActiveChecks[checkinstance].Stratum2[SCCtable[FSindex].S] == 1) &&
                                                    (ActiveChecks[checkinstance].Domain2[SCCtable[FSindex].D] == 1))
                                                {
                                                LookForFeature = 1;
                                                break;
                                                }
                                             }
                                          } /*** end CrsWlk says this Lindex is a point ***/ 
                                       if(LookForFeature > 0)
                                          break;
                                       } /*** end for k ***/
                                    } /** end thisindex != cindex ***/
                                 if(LookForFeature > 0) 
                                    break;
                                 } /*** end for index2 ***/
                              if(LookForFeature > 0)
                                 break;
                              } /*** end for index1 ***/
   
                           if(LookForFeature > 0) 
                              {
                              if((A_NeighborsLoaded == 0) && (CrsWlk[FLindex].geomtype == C_AREA))
                                 {
                                 A_NeighborsLoaded = 1;
                                 FindApplicableNeighborFeatures(cindex, ptsin, minx, maxx, miny, maxy, 1, 0 , 0, 1);
                                 }

                              rac = TgtAroot; 
                              }
                           else
                              rac = NULL;
                           } /*** end else time through loop > 1 ****/

                        while((rac != NULL) && (isclose == 0))
                           {
                           Config2 = SCCtable[rac->Sindex].C;
                           Strat2 = SCCtable[rac->Sindex].S;
                           Domain2 = SCCtable[rac->Sindex].D;
                           if((CombinedCheckApplies(rac->idn,checkinstance,PLLPROXFAIL,rac->Lindex,rac->Sindex,Config2,Strat2,Domain2,&part1,&part2,&part3) > 0)
                             && (part2 > 0))
                              {
                              ptldist = PointToArealDist2D(rpc->x[0], rpc->y[0], rac);
                              if((SensitivityCheck(LTEQ, PLLPROXFAIL, checkinstance, ptldist) > 0) ||
                                   (PointInsideArealWithHoles(rpc->x[0], rpc->y[0], Aroot, rac) > 0))
                                 {
                                 if(timesthroughloop == 1)
                                    rln = Lroot;
                                 else
                                    rln = TgtLroot;
                                 while(rln != NULL)
                                    {
                                    Config3 = SCCtable[rln->Sindex].C;
                                    Strat3  = SCCtable[rln->Sindex].S;
                                    Domain3 = SCCtable[rln->Sindex].D;
                                    if(CombinedCheckApplies(rln->idn,checkinstance,PLLPROXFAIL,rln->Lindex,rln->Sindex,Config3,Strat3,Domain3,&part1,&part2,&part3) > 0)
                                       {
                                       if(part3 > 0)
                                          {
                                          for(k=1; k<rln->numnodes; k++)
                                             {
                                             kk = k - 1;
                                             ptldist = PointToLineDist2D(rpc->x[0], rpc->y[0], rln->x[kk], rln->y[kk], rln->x[k], rln->y[k]);
                                             if(SensitivityCheck(LTEQ, PLLPROXFAIL, checkinstance, ptldist) > 0)
                                                {
                                                isclose = 1;
                                                break;
                                                }
                                             } /** end for k ***/
                                          } /** end part3 OK **/
                                       } /*** end check applies to 2d line ***/
                                    if(isclose > 0)
                                       break;
                                    rln = rln->next;
                                    } /** end while rln ***/

                                 if(isclose == 0) /** did not find an area line int - go for area area int **/
                                    {
                                    if(timesthroughloop == 1)
                                       ran = Aroot;
                                    else
                                       ran = TgtAroot;
                                    while((ran != NULL) && (isclose == 0))
                                       {
                                       if(ran != rac)
                                          {
                                          Config3 = SCCtable[ran->Sindex].C;
                                          Strat3 = SCCtable[ran->Sindex].S;
                                          Domain3 = SCCtable[ran->Sindex].D;
                                          if((CombinedCheckApplies(ran->idn,checkinstance,PLLPROXFAIL,ran->Lindex,ran->Sindex,Config3,Strat3,Domain3,&part1,&part2,&part3) > 0)
                                            && (part3 > 0))
                                             {
                                              ptldist = PointToArealDist2D(rpc->x[0], rpc->y[0], ran);
                                              if((SensitivityCheck(LTEQ, PLLPROXFAIL, checkinstance, ptldist) > 0)  ||
                                                  (PointInsideArealWithHoles(rpc->x[0], rpc->y[0], Aroot, ran) > 0))
                                                {
                                                isclose = 1; 
                                                break;
                                                }
                                             } /** part 3 OK ***/
                                          } /** end ran != rac ***/
                                       ran = ran->next;
                                       } /** end while ran ***/
                                    }
                                 } /*** end pt is close enough to area ***/
                              } /*** end part 2 OK for rac ***/
     
                           rac = rac->next;
                           } /** end while rac ***/
                        } /*** end isclose == 0 ***/
                     } /*** end while isclose and timesthroughloop ****/

                  if(isclose == 0)
                     {
                     ERc = (struct PointRelatedCollection *) (malloc(SzPRC));
                     if(ERc == NULL)
                        {
                        printf("allocation memory exhausted during point feature condition analysis\n");
                        printf("processing cannot continue\n");
                        exit(-1);
                        }
                     ERc->x1[0] = rpc->x[0];
                     ERc->y1[0] = rpc->y[0];
                     ERc->z1[0] = rpc->z[0];
                     ERc->pt1 = rpc;
                     ERc->magnitude = ptldist;
                     ERc->keyval = PLLPROXFAIL;
                     ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);

                     ERc->Sindex1 = rpc->Sindex;
                     ERc->IDN1 = rpc->idn;
                     ERc->next = NULL;
                     if(ERroot == NULL)
                        {
                        ERroot = ERc;
                        }
                     else
                       {
                         ERn = ERroot;
                         while(ERn != NULL)
                           {
                             if((ERn->Cnumber == ERc->Cnumber) && (ERn->keyval == ERc->keyval) && (ERn->x1[0] == ERc->x1[0]) &&
                                (ERn->y1[0] == ERc->y1[0]) && (ERn->Sindex1 == ERc->Sindex1))
                               {
                                 break;
                               }
                             ERn = ERn->next;
                           }
                         if(ERn == NULL)
                           {
                             ERc->next = ERroot;
                             ERroot = ERc;
                           }
                         else
                           {
                             free(ERc);
                           }
                        }
                     } /** end isclose == 0 **/
                  } /** end, part 1 applies to this point **/
               }  /** end of check PLLPROXFAIL **/

            } /** end numverts == -1, so have a pure point objects **/

         } /*** end for(checkinstance = 0; checkinstance < TtlActiveChecks; checkinstance++) ***/

      if(abortNow > 0)
         break;

      rpc = rpc->next;
      }

   if(attrfileptr != NULL)
      fclose(attrfileptr);



   ERc = ERroot;
   while(ERc != NULL)
      {
      switch(ERc->keyval)
         {
         case LLAINT:
            FwritePointAndObject(ERc->keyval,ERc->Cnumber,ERc->x1[0],ERc->y1[0],ERc->z1[0], -1,
                       ERc->Sindex1, G_POINT, ERc->pt1->Lindex,ERc->pt1->localID,
                          ERc->pt1->idn,10.0, 0.0,&ERc->x1[0], &ERc->y1[0], &ERc->z1[0], 1);
            break;

         case PUNDERSHTA:
         case POVERSHTA:
            FwriteMagnitudeAndTwoObjects(ERc->keyval, ERc->Cnumber,ERc->magnitude,
                   ERc->Sindex1,G_POINT,ERc->pt1->Lindex,
                   ERc->pt1->localID,ERc->IDN1, ERc->pt1->rad,-1.0,&ERc->x1[0],&ERc->y1[0],&ERc->z1[0],1,
                   ERc->Sindex2,G_AREAL,ERc->aa->Lindex,
                   ERc->aa->localID,ERc->IDN2, -1.0 ,-1.0,&ERc->x1[1],&ERc->y1[1],&ERc->z1[1],2);
            break;

         case LLNONODEINT:
            if(ERc->ll != NULL)
               {
               FwritePointAndTwoObjects(ERc->keyval,ERc->Cnumber,ERc->x1[0],ERc->y1[0],ERc->z1[0],
                               ERc->pt1->Sindex,G_POINT,ERc->pt1->Lindex,ERc->pt1->localID,
                               ERc->pt1->idn,-1.0,-1.0,&ERc->x1[0],&ERc->y1[0],&ERc->z1[0],1,
                               ERc->ll->Sindex,G_LINE,ERc->ll->Lindex,ERc->ll->localID,
                               ERc->ll->idn,-1.0,-1.0,&ERc->x1[1],&ERc->y1[1],&ERc->z1[1],2);
               }
            else if(ERc->pt2 != NULL)
               {
               FwritePointAndTwoObjects(ERc->keyval,ERc->Cnumber,ERc->x1[0],ERc->y1[0],ERc->z1[0],
                               ERc->pt1->Sindex,G_POINT,ERc->pt1->Lindex,ERc->pt1->localID,
                               ERc->pt1->idn,-1.0,-1.0,&ERc->x1[0],&ERc->y1[0],&ERc->z1[0],1,
                               ERc->pt2->Sindex,G_POINT,ERc->pt2->Lindex,ERc->pt2->localID,
                               ERc->pt2->idn,-1.0,-1.0,&ERc->pt2->x[0],&ERc->pt2->y[0],&ERc->pt2->z[0],1);
               }
            else if(ERc->aa != NULL)
               {
               FwritePointAndTwoObjects(ERc->keyval,ERc->Cnumber,ERc->x1[0],ERc->y1[0],ERc->z1[0],
                               ERc->pt1->Sindex,G_POINT,ERc->pt1->Lindex,ERc->pt1->localID,
                               ERc->pt1->idn,-1.0,-1.0,&ERc->x1[0],&ERc->y1[0],&ERc->z1[0],1,
                               ERc->aa->Sindex,G_AREAL,ERc->aa->Lindex,ERc->aa->localID,
                               ERc->aa->idn,-1.0,-1.0,&ERc->x1[1],&ERc->y1[1],&ERc->z1[1],2);
               }
            break;

         case PLPROX:
         case PSHOOTL:
         case PLPROXEX:
            FwritePointEdgeAndMagnitude(ERc->keyval,ERc->Cnumber,ERc->magnitude, ERc->IDN1, G_POINT,
                      ERc->pt1->Lindex,ERc->pt1->localID,
                      ERc->Sindex1,ERc->x1[0],ERc->y1[0],ERc->z1[0],
                      ERc->Sindex2, ERc->IDN2, G_LINE, ERc->ll->Lindex, ERc->ll->localID,
                      ERc->x1[1],ERc->y1[1],ERc->z1[1],ERc->x1[2],ERc->y1[2],ERc->z1[2],ERc->x1,ERc->y1, ERc->z1);
            break;
         case PTINPROPER:
            if(ERc->aa != NULL) /** point was found  inside an area feature **/
               {
               FwriteTwoObjects(ERc->keyval,ERc->Cnumber,
                             ERc->IDN1,G_POINT,ERc->pt1->Lindex,ERc->pt1->localID,ERc->Sindex1,-1.0,-1.0,1,ERc->x1,                              ERc->y1,ERc->z1,
                             ERc->aa->idn,G_AREAL,ERc->aa->Lindex,ERc->aa->localID,ERc->aa->Sindex,-1.0,-1.0,2,&ERc->x1[1],                              &ERc->y1[1],&ERc->z1[1]);
               }
            break;
         case PTINREGION:
            if(ERc->aa != NULL) /** point was found  inside an area feature **/
               {
               FwriteTwoObjects(ERc->keyval,ERc->Cnumber, 
                             ERc->IDN1,G_POINT,ERc->pt1->Lindex,ERc->pt1->localID,ERc->Sindex1,-1.0,-1.0,1,ERc->x1,
                             ERc->y1,ERc->z1,
                             ERc->aa->idn,G_AREAL,ERc->aa->Lindex,ERc->aa->localID,ERc->aa->Sindex,-1.0,-1.0,2,&ERc->x1[1],
                             &ERc->y1[1],&ERc->z1[1]);
               }
            if(ERc->pp != NULL) /** point was found  inside a poly **/
               {
               FwriteTwoObjects(ERc->keyval, ERc->Cnumber,
                             ERc->IDN1,G_POINT,ERc->pt1->Lindex,ERc->pt1->localID,ERc->Sindex1,-1.0,-1.0,ERc->numverts1,ERc->x1,
                             ERc->y1,ERc->z1,
                             ERc->pp->idn,G_POLYGON,ERc->pp->SACindex,ERc->pp->localID,ERc->pp->SCCindex,-1.0,-1.0,ERc->pp->numverts,ERc->pp->x,
                             ERc->pp->y,ERc->pp->z);
               }
            break;

         case PLPFAIL:
         case PLLPROXFAIL:
         case PNOCOVERLE:
         case PNOCOVERLV:
         case CONNECTFAIL:
            FwriteObject(ERc->keyval, ERc->Cnumber, ERc->pt1->Lindex,
                       ERc->Sindex1,G_POINT,ERc->pt1->localID,ERc->IDN1,10.0, -1.0,ERc->x1,ERc->y1,ERc->z1,1, 1);
            break;

         case ELEVLT:
         case ELEVGT:
         case ELEVEQ:
         case ELEVEQOPEN:
         case FEATOUTSIDE:
            FwriteDynamicInfo(ERc->keyval,ERc->Cnumber,0,1,1,NULL,
              ERc->magnitude, -1.0, -1.0, -1.0,
              ERc->Sindex1,G_POINT,ERc->pt1->Lindex,ERc->pt1->localID,ERc->pt1->idn,-1.0,-1.0,
              ERc->x1, ERc->y1, ERc->z1, 1,
              ERc->Sindex1,G_POINT,ERc->pt1->Lindex,ERc->pt1->localID,ERc->pt1->idn,-1.0,-1.0,
              ERc->x1, ERc->y1, ERc->z1, 1);
            break;

         case OSIDE_LAT:
         case OSIDE_LON:
         case BNDRYUNDERSHT:
            FwriteObjectAndMagnitude(ERc->keyval, ERc->Cnumber,ERc->IDN1,ERc->Sindex1,G_POINT,
                               ERc->pt1->Lindex,ERc->pt1->localID,
                             -1.0, -1.0, ERc->magnitude,ERc->x1,ERc->y1,ERc->z1,1, 1);
            break;

         case VVTERR1WAY:
         case VVTERR2WAY:
         case VVTERR3WAY:
            FwriteObjectAndMessage(ERc->keyval,ERc->Cnumber,
              ERc->pt1->idn, G_POINT,ERc->pt1->Lindex,ERc->pt1->localID, ERc->Sindex1,-1.0,-1.0,
              ERc->pt1->x, ERc->pt1->y, ERc->pt1->z,1,"feature meeting specification");
            break;

         case OVERUNDER:
         case PTOSIDEREGION:
         case PNOCOV2LEA:
         case HIGHLIGHTED:
            X[0] = ERc->x1[0];
            Y[0] = ERc->y1[0];
            Z[0] = ERc->z1[0];
            FwriteObject(ERc->keyval, ERc->Cnumber, ERc->pt1->Lindex, ERc->Sindex1,
                  G_POINT, ERc->pt1->localID, ERc->IDN1, 10.0, -1.0,X,Y,Z,1, 1);

            break;
         case PTPTPROX:
            X[0] = ERc->x1[0];
            Y[0] = ERc->y1[0];
            Z[0] = ERc->z1[0];
            X2[0] = ERc->x1[1];
            Y2[0] = ERc->y1[1];
            Z2[0] = ERc->z1[1];
            X[2] = 0.0;
            if((ERc->pt1->numverts == 0) || (ERc->pt1->numverts == -2)) /** a stamp model  or spherical col vol**/
               {
               vtxcnt1 = 1;
               obj1form = G_CIRCLE;
               }
            else if(ERc->pt1->numverts == -1) /** a dimensionless point feature **/
               {
               vtxcnt1 = 1;
               obj1form = G_POINT;
               }
            else if(ERc->pt1->numverts == -4)  /** a parallelpiped collision vol **/
               {
               vtxcnt1 = 4;
               obj1form = G_POLYGON;
               for(i=0; i<4; i++)
                  {
                  X[i] = ERc->pt1->x[i];
                  Y[i] = ERc->pt1->y[i];
                  Z[i] = ERc->pt2->z[i];
                  }
               }

            if((ERc->pt2->numverts == 0) || (ERc->pt2->numverts == -2)) /** a stamp model  or spherical col vol**/
               {
               vtxcnt2 = 1;
               obj2form = G_CIRCLE;
               }
            else if(ERc->pt2->numverts == -1) /** a dimensionless point feature **/
               {
               vtxcnt2 = 1;
               obj2form = G_POINT;
               }
            else if(ERc->pt2->numverts == -4)  /** a parallelpiped collisioon vol **/
               {
               vtxcnt2 = 4;
               obj2form = G_POLYGON;
               for(i=0; i<4; i++)
                  {
                  X2[i] = ERc->pt2->x[i];
                  Y2[i] = ERc->pt2->y[i];
                  Z2[i] = ERc->pt2->z[i];
                  }
               }


            FwriteMagnitudeAndTwoObjects(ERc->keyval, ERc->Cnumber,ERc->magnitude,
                   ERc->Sindex1,(char) obj1form,ERc->pt1->Lindex,
                   ERc->pt1->localID,ERc->IDN1, ERc->pt1->rad,-1.0,&X[0],&Y[0],&Z[0],vtxcnt1,
                   ERc->Sindex2,(char) obj2form,ERc->pt2->Lindex,
                   ERc->pt2->localID,ERc->IDN2, ERc->pt2->rad,-1.0,&X2[0],&Y2[0],&Z2[0],vtxcnt2);
            break;


         default:
             printf("unrecognized key condition flag received during point feature analysis\n");
            break;
         }
      ERn = ERc;
      ERc = ERc->next;
      free(ERn);
      }


   rac = TgtAroot;
   while(rac != NULL)
      {
      rap = rac;
      rac = rac->next; 
      free(rap->x);
      free(rap->y);
      free(rap->z);
      free(rap);
      }
   rlc = TgtLroot;
   while(rlc != NULL)
      {
      rlp = rlc;
      rlc = rlc->next;
      free(rlp->x);
      free(rlp->y);
      free(rlp->z);
      free(rlp);
      }
   rpc = TgtProot;
   while(rpc != NULL)
      {
      npc = rpc;
      rpc = rpc->next;
      free(npc->x);
      free(npc->y);
      free(npc->z);
      free(npc->h);
      free(npc);
      }
   TgtAroot = NULL;
   TgtLroot = NULL;
   TgtProot = NULL;


   return;

} /** end PerformPointRelatedChecks ***/




char fixbuffer[100000];

int PolygonsIntersect(int numverts1, double *x1, double *y1, double *z1,
					  int numverts2, double *x2, double *y2, double *z2)
{
int i,j;
double xi, yi;  /* intersection points */
double xi2, yi2;


	for (i=0; i<numverts1-1; i++)
		{
		for (j=0; j<numverts2-1; j++)
			{
			if (LineSegmentsIntersect(x1[i],y1[i],x1[i+1],y1[i+1], x2[j],y2[j],x2[j+1],y2[j+1], &xi, &yi) || 
				LineSegmentsOverlap(x1[i],y1[i],x1[i+1],y1[i+1], 
                                      x2[j],y2[j],x2[j+1],y2[j+1], &xi, &yi, &xi2, &yi2, 0.01))
				return 1; /* There is an intersection between the two polys */
			}
		if (LineSegmentsIntersect(x1[i],y1[i],x1[i+1],y1[i+1], 
                                      x2[0],y2[0],x2[numverts2-1],y2[numverts2-1], &xi, &yi) ||
			LineSegmentsOverlap(x1[i],y1[i],x1[i+1],y1[i+1], 
                                      x2[0],y2[0],x2[numverts2-1],y2[numverts2-1], &xi, &yi, &xi2, &yi2, 0.01))
				return 1; /* There is an intersection between the two polys */
		}

	for (j=0; j<numverts2-1; j++)
		{
		if (LineSegmentsIntersect(x1[0],y1[0],x1[numverts1-1],y1[numverts1-1], x2[j],y2[j],x2[j+1],y2[j+1], &xi, &yi) ||
			LineSegmentsOverlap(x1[0],y1[0],x1[numverts1-1],y1[numverts1-1], 
                                      x2[j],y2[j],x2[j+1],y2[j+1], &xi, &yi, &xi2, &yi2, 0.01))
			return 1; /* There is an intersection between the two polys */
		}

	if (LineSegmentsIntersect(x1[0],y1[0],x1[numverts1-1],y1[numverts1-1],x2[0],y2[0],x2[numverts2-1],y2[numverts2-1], &xi, &yi) ||
		LineSegmentsOverlap(x1[0],y1[0],x1[numverts1-1],y1[numverts1-1],
                                      x2[0],y2[0],x2[numverts2-1],y2[numverts2-1], &xi, &yi, &xi2, &yi2, 0.01))
			return 1; /* There is an intersection between the two polys */


	if (PointInsidePoly(x1[0], y1[0], x2, y2, numverts2) ||
		PointInsidePoly(x2[0], y2[0], x1, y1, numverts1) )
		return 1;

	return 0; /* no intersection */
}


struct PolygonCollection
{
   int keyval;
   int Cnumber;
   double magnitude;
   double radius;  /* currently unused */
   int IDN1;
   int IDN2;
   int Sindex1;
   int Sindex2;
   int numverts1;
   int numverts2;
   double pointX, pointY;
   double *x1, *y1, *z1;
   double *x2, *y2, *z2;
   double minx1, maxx1, miny1, maxy1;
   double minx2, maxx2, miny2, maxy2;
   struct ThePolys *pp,*pp2;
   struct RawAreal *aa;
   struct PolygonCollection * next;
   };
int SzPC = sizeof(struct PolygonCollection);




void InsertPolygonPairIfNotADuplicate(struct PolygonCollection **ERroot, struct PolygonCollection *newrec)
{
  struct PolygonCollection *poly;
  int point_dupe;
  int i;
  
  if (!(*ERroot))
    {
      *ERroot = newrec;
      return;
    }
  

  poly = *ERroot;
  while (poly)
    {
      if (
	  (poly->keyval    == newrec->keyval)    &&
	  (poly->Cnumber    == newrec->Cnumber)    &&
	  (poly->numverts1 == newrec->numverts1) && 
	  (poly->numverts2 == newrec->numverts2)
	  )
	{
	  point_dupe = 1;
	  for (i=0; (i<poly->numverts1) && point_dupe; i++)
	    if ( (poly->x1[i] != newrec->x1[i]) || (poly->y1[i] != newrec->y1[i]))
	      point_dupe = 0;
	  
	  for (i=0; (i<poly->numverts2) && point_dupe; i++)
	    if ( (poly->x2[i] != newrec->x2[i]) || (poly->y2[i] != newrec->y2[i]))
	      point_dupe = 0;
	  
	  if (point_dupe==1)
	    {
	      return;
	    }
	}
      
      
      if (
	  (poly->keyval    == newrec->keyval)    &&
	  (poly->Cnumber    == newrec->Cnumber)    &&
	  (poly->numverts1 == newrec->numverts2) && 
	  (poly->numverts2 == newrec->numverts1)
	  )
	{
	  point_dupe = 1;
	  for (i=0; (i<poly->numverts1) && point_dupe; i++)
	    if ( (poly->x1[i] != newrec->x2[i]) || (poly->y1[i] != newrec->y2[i]))
	      point_dupe = 0;
	  
	  for (i=0; (i<poly->numverts2) && point_dupe; i++)
	    if ( (poly->x2[i] != newrec->x1[i]) || (poly->y2[i] != newrec->y1[i]))
	      point_dupe = 0;
	  
	  if (point_dupe==1) 
	    {
	      return;
	    }
	}
      
      poly = poly->next;
    }
  
  newrec->next = *ERroot;
  *ERroot = newrec;

}




int decide_to_checkfor_poly_intersect(int part1, int part1a, int part2, int part2a)
{
  return ((part1 && part2a) || (part1a && part2)) ; 
}


void PerformPolyChecks(struct ThePolys * Proot, struct RawAreal * Aroot, struct RawPoint * PointRoot)
{
struct RawAreal *rac;
struct ThePolys *rpc, *npc;
int i,j;
double unuseddbl;
double xi, yi;
int unusedint;
int checkinstance;
int part1, part2, part3;
int part1a, part2a, part3a;
int inside,intersect;
int Config1, Strat1, Domain1;
struct PolygonCollection  *ERroot, *ERc, *ERn;
struct RawPoint *ppc, *point;
int qq;


#define COPYVERTEXREFERENCES(rec, which, x, y, z, n) \
	if (which == 1) { \
	  rec->x1 = x; rec->y1 = y; rec->z1 = z; \
	  rec->numverts1 = n; \
	  rec->minx1 = rec->maxx1 = x[0]; rec->miny1 = rec->maxy1 = y[0]; \
	  for (qq=1; qq<n; qq++) { \
		if (x[qq] < rec->minx1) rec->minx1 = x[qq]; \
		if (x[qq] > rec->maxx1) rec->maxx1 = x[qq]; \
		if (x[qq] < rec->minx1) rec->minx1 = x[qq]; \
		if (x[qq] > rec->maxx1) rec->maxx1 = x[qq]; \
	  } \
	} else { \
  	  rec->x2 = x; rec->y2 = y; rec->z2 = z; \
	  rec->numverts2 = n; \
	  rec->minx2 = rec->maxx2 = x[0]; rec->miny2 = rec->maxy2 = y[0]; \
	  for (qq=1; qq<n; qq++) { \
		if (x[qq] < rec->minx2) rec->minx2 = x[qq]; \
		if (x[qq] > rec->maxx2) rec->maxx2 = x[qq]; \
		if (x[qq] < rec->minx2) rec->minx2 = x[qq]; \
		if (x[qq] > rec->maxx2) rec->maxx2 = x[qq]; \
	  } \
	}


#define INIT_NULLS(rec) \
	{ \
	rec->numverts1 = rec->numverts2 = 0; \
	rec->x1 = rec->y1 = rec->z1 = rec->x2 = rec->y2 = rec->z2 = (double *) NULL; \
	}



   ERroot = NULL;
   rpc = Proot;

   while(rpc != NULL) /* looping through the raw polygons */
     {
      for(checkinstance = 0; checkinstance < TtlActiveChecks; checkinstance++)
           {

	   if((Aroot != NULL) && 
          (CombinedCheckApplies(rpc->idn,checkinstance,POLYINTAREA,rpc->SACindex,rpc->SCCindex,rpc->config,rpc->stratum,
                     rpc->domain,&part1,&part2,&part3) > 0) &&
	      (part1 > 0))
	     {
	       rac = Aroot;
	       while(rac != NULL) 
		 {
		   Config1 = SCCtable[rac->Sindex].C;
		   Strat1 = SCCtable[rac->Sindex].S;
		   Domain1 = SCCtable[rac->Sindex].D;
		   if((CombinedCheckApplies(rac->idn,checkinstance,POLYINTAREA,
                           rac->Lindex,rac->Sindex,Config1,Strat1,Domain1,&part1,&part2,&part3) > 0) &&
		      (part2 > 0))
		     {
                       intersect = 0;
		       for(i=1; i<rpc->numverts; i++)
			 {
                         for(j = 1; j < rac->numverts; j++)
                            {
                            if(LineSegmentsIntersect(rpc->x[i-1],rpc->y[i-1],rpc->x[i],rpc->y[i],
                                                     rac->x[j-1],rac->y[j-1],rac->x[j],rac->y[j], &xi, &yi))
                               {
                               intersect = 1;
                               break;
                               }
                            }
                         if(intersect > 0)
                            break;
                         if(LineSegmentsIntersect(rpc->x[i-1],rpc->y[i-1],rpc->x[i],rpc->y[i],
                                                  rac->x[rac->numverts-1],rac->y[rac->numverts-1],rac->x[0],rac->y[0], &xi, &yi))
                            {
                            intersect = 1;
                            break;
                            }
                         } /** end for i .... **/
                      if(intersect == 0)
                         {
                         for(j = 1; j < rac->numverts; j++)
                            {
                            if(LineSegmentsIntersect(rpc->x[rpc->numverts-1],rpc->y[rpc->numverts-1],rpc->x[0],rpc->y[0],
                                                     rac->x[j-1],rac->y[j-1],rac->x[j],rac->y[j], &xi, &yi))
                               {
                               intersect = 1;
                               break;
                               }
                            }
                         if((intersect == 0) && 
                            (LineSegmentsIntersect(rpc->x[rpc->numverts-1],rpc->y[rpc->numverts-1],rpc->x[0],rpc->y[0],
                                                  rac->x[rac->numverts-1],rac->y[rac->numverts-1],rac->x[0],rac->y[0], &xi, &yi)))
                            {
                            intersect = 1;
                            }
                         }

		       
		       if(intersect > 0 )  
			 {
			   ERc = (struct PolygonCollection *) (malloc(SzPC));
			   if(ERc == NULL)
			     {
			       printf("allocation memory exhausted during linear feature condition analysis\n");
			       printf("processing cannot continue\n");
			       exit(-1);
			     }
			   INIT_NULLS(ERc);
			   ERc->magnitude = 0.0;
			   ERc->keyval = POLYINTAREA;
                           ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                           ERc->pointX = xi;
                           ERc->pointY = yi;
			   ERc->pp = rpc;
			   ERc->aa = rac;
			   ERc->next = NULL;
			   COPYVERTEXREFERENCES(ERc, 1, rpc->x, rpc->y, rpc->z, rpc->numverts);
			   COPYVERTEXREFERENCES(ERc, 2, rac->x, rac->y, rac->z, rac->numverts);
			   if(ERroot == NULL)
			     {
			       ERroot = ERc;
			     }
			   else
			     {	
			       ERn = ERroot;
			       while(ERn != NULL)
				 {
				   if(
				      (ERn->Cnumber == ERc->Cnumber) &&
				      (ERn->keyval == ERc->keyval) && 
				      (ERn->pp     == ERc->pp)     && 
				      (ERn->aa     == ERc->aa)
				      )
				     break;
				   ERn = ERn->next;
				 }
			       if(ERn == NULL)
				 {
				   ERc->next = ERroot;
				   ERroot = ERc;
				 }
			       else
				 free(ERc);
			     }
			   
			 }
		       
		     }
                 rac = rac->next;
		 }
	     }

      part1 = 0;
      if((Aroot != NULL) && 
          (CombinedCheckApplies(rpc->idn,checkinstance,POLYINAREA,rpc->SACindex,rpc->SCCindex,rpc->config,
                            rpc->stratum, rpc->domain,&part1,&part2,&part3) > 0) &&
                                    (part1 > 0))
         {
         rac = Aroot;
         while(rac != NULL)
            {
            part2 = 0;
            Config1 = SCCtable[rac->Sindex].C;
            Strat1 = SCCtable[rac->Sindex].S;
            Domain1 = SCCtable[rac->Sindex].D;
            if((CombinedCheckApplies(rac->idn,checkinstance,POLYINAREA,rac->Lindex,rac->Sindex,Config1,Strat1,Domain1,&part1,&part2,&part3) > 0) &&
                                      (part2 > 0))
               {
               inside = 0;
               for(i=0; i<rpc->numverts; i++)
                  {
                  if(PointIsVertex(rpc->x[i],rpc->y[i],rac->x,rac->y,rac->x,rac->numverts,&unuseddbl))
                     ++inside;
                  else if(PointOnEdge(rpc->x[i],rpc->y[i],rac->x,rac->y,rac->x,rac->numverts,&unuseddbl,&unusedint))
                     ++inside;
                  else if(PointIsInside(rpc->x[i],rpc->y[i],rac->x,rac->y,rac->x,rac->numverts,(unsigned char) Config1,&unuseddbl))
                     ++inside;
                  else
                     break;
                  }
               if(inside == rpc->numverts)  /** then this poly is inside rac area feature ***/
                  {
                  ERc = (struct PolygonCollection *) (malloc(SzPC));
                  if(ERc == NULL)
                     {
                     printf("allocation memory exhausted during linear feature condition analysis\n");
                     printf("processing cannot continue\n");
                     exit(-1);
                     }
				  INIT_NULLS(ERc);
                  ERc->magnitude = 0.0;
                  ERc->keyval = POLYINAREA;
                  ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                  ERc->pp = (struct ThePolys *) rpc;
                  ERc->aa = (struct RawAreal *) rac;
                  ERc->next = NULL;
                  if(ERroot == NULL)
                     {
                     ERroot = ERc;
                     }
                  else
                     {
                     ERn = ERroot;
                     while(ERn != NULL)
		       {
			 if(
			    (ERn->Cnumber == ERc->Cnumber) &&
			    (ERn->keyval == ERc->keyval) && 
			    (ERn->pp     == ERc->pp)     && 
			    (ERn->aa     == ERc->aa)
			    )
                           break;
			 ERn = ERn->next;
		       }
                     if(ERn == NULL)
		       {
			 ERc->next = ERroot;
			 ERroot = ERc;
		       }
                     else
		       {
			 free(ERc);
		       }
                     }

                  break; /** no need to look for other 'containing' areals since found at least 1 **/
                  }
               }
            rac = rac->next;
            }
         }

      part1 = 0;
      if((CombinedCheckApplies(rpc->idn,checkinstance,POLYOSIDEAREA,rpc->SACindex,rpc->SCCindex,rpc->config,
                   rpc->stratum, rpc->domain,&part1,&part2,&part3) > 0) &&
                                    (part1 > 0))
         {
         rac = Aroot;
         inside = 0;
         while((rac != NULL) && (inside == 0))
            {
            part2 = 0;
            Config1 = SCCtable[rac->Sindex].C;
            Strat1 = SCCtable[rac->Sindex].S;
            Domain1 = SCCtable[rac->Sindex].D;
            if((CombinedCheckApplies(rac->idn,checkinstance,POLYOSIDEAREA,rac->Lindex,rac->Sindex,Config1,Strat1,Domain1,&part1,&part2,&part3) > 0) &&
                                      (part2 > 0))
               {
               for(i=0; i<rpc->numverts; i++)
                  {
                  if(PointIsVertex(rpc->x[i],rpc->y[i],rac->x,rac->y,rac->x,rac->numverts,&unuseddbl))
                     {
                     ++inside;
                     break;
                     }
                  else if(PointOnEdge(rpc->x[i],rpc->y[i],rac->x,rac->y,rac->x,rac->numverts,&unuseddbl,&unusedint))
                     {
                     ++inside;
                     break;
                     }
                  else if(PointIsInside(rpc->x[i],rpc->y[i],rac->x,rac->y,rac->x,rac->numverts,(unsigned char) Config1,&unuseddbl))
                     {
                     ++inside;
                     break;
                     }
                  }
                }
             rac = rac->next;
             }
 
		 if(inside == 0 )
            {
            ERc = (struct PolygonCollection *) (malloc(SzPC));
            if(ERc == NULL)
               {
               printf("allocation memory exhausted during linear feature condition analysis\n");
               printf("processing cannot continue\n");
               exit(-1);
               }
			INIT_NULLS(ERc);
            ERc->magnitude = 0.0;
            ERc->keyval = POLYOSIDEAREA;
            ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
            ERc->pp = (struct ThePolys *) rpc;
            ERc->aa = NULL;
            ERc->next = NULL;
            if(ERroot == NULL)
               {
               ERroot = ERc;
               }
            else
               {
               ERn = ERroot;
               while(ERn != NULL)
		 {
		   if(
		      (ERn->Cnumber == ERc->Cnumber) &&
		      (ERn->keyval == ERc->keyval) && 
		      (ERn->pp     == ERc->pp)     && 
		      (ERn->aa     == ERc->aa)
		      )
                     break;
		   ERn = ERn->next;
		 }
               if(ERn == NULL)
		 {
		   ERc->next = ERroot;
		   ERroot = ERc;
		 }
               else
		 {
                  free(ERc);
		 }
               }

            }
         }

	   
  	  if(CombinedCheckApplies(rpc->idn,checkinstance,POLYINTPOLY,rpc->SACindex,rpc->SCCindex, rpc->config,
               rpc->stratum, rpc->domain, &part1,&part2,&part3) > 0)
		{
			npc = Proot;
			while (npc)
				{
				if((npc != rpc) &&
                                    (CombinedCheckApplies(npc->idn,checkinstance,POLYINTPOLY,
                                         npc->SACindex,npc->SCCindex, npc->config, npc->stratum, npc->domain, &part1a,&part2a,&part3a) > 0))
				if ( decide_to_checkfor_poly_intersect(part1, part1a, part2, part2a) )
					{
					if (PolygonsIntersect(rpc->numverts, rpc->x, rpc->y, rpc->z, npc->numverts, npc->x, npc->y, npc->z))
						{
						ERc = (struct PolygonCollection *) (malloc(SzPC));
					    if(ERc == NULL)
							{	
							printf("allocation memory exhausted during linear feature condition analysis\n");
							printf("processing cannot continue\n");
							exit(-1);
							}
						INIT_NULLS(ERc);
						COPYVERTEXREFERENCES(ERc, 1, rpc->x, rpc->y, rpc->z, rpc->numverts);
						COPYVERTEXREFERENCES(ERc, 2, npc->x, npc->y, npc->z, npc->numverts);
						ERc->magnitude = 0.0;
						ERc->keyval = POLYINTPOLY;
                                                ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
						ERc->pp = (struct ThePolys *) rpc;
                                                ERc->pp2 = (struct ThePolys *) npc;
						ERc->aa = NULL;
						ERc->next = NULL;
                                                ERc->IDN1 = rpc->idn;
                                                ERc->IDN2 = npc->idn;
						ERc->Sindex1 = rpc->SCCindex;
						ERc->Sindex2 = npc->SCCindex;
						InsertPolygonPairIfNotADuplicate(&ERroot, ERc);
						}
					}
				npc = npc->next;
				}

			ppc = PointRoot;
			while (ppc)
				{
	            Config1 = SCCtable[ppc->Sindex].C;
		        Strat1  = SCCtable[ppc->Sindex].S;
			    Domain1 = SCCtable[ppc->Sindex].D;
				if (CombinedCheckApplies(ppc->idn,checkinstance,POLYINTPOLY,
                                             ppc->Lindex,ppc->Sindex, Config1,Strat1,Domain1,&part1a,&part2a,&part3a))
				if ( decide_to_checkfor_poly_intersect(part1, part1a, part2, part2a) )
					{
					if (PolygonsIntersect(rpc->numverts, rpc->x, rpc->y, rpc->z, ppc->numverts, ppc->x, ppc->y, ppc->z))
						{
						ERc = (struct PolygonCollection *) (malloc(SzPC));
					    if(ERc == NULL)
							{
							printf("allocation memory exhausted during linear feature condition analysis\n");
							printf("processing cannot continue\n");
							exit(-1);
							}
						INIT_NULLS(ERc);
						COPYVERTEXREFERENCES(ERc, 1, rpc->x, rpc->y, rpc->z, rpc->numverts);
						COPYVERTEXREFERENCES(ERc, 2, ppc->x, ppc->y, ppc->z, ppc->numverts);
						ERc->magnitude = 0.0;
						ERc->keyval = POLYINTPOLY;
                                                ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
						ERc->pp = (struct ThePolys *) rpc;
                                                ERc->pp2 = (struct ThePolys *) ppc;
						ERc->aa = NULL;
						ERc->next = NULL;
                                                ERc->IDN1 = rpc->idn;
                                                ERc->IDN2 = ppc->idn;
						ERc->Sindex1 = rpc->SCCindex;
						ERc->Sindex2 = ppc->Sindex;
						InsertPolygonPairIfNotADuplicate(&ERroot, ERc);
						}				
					}
				ppc = ppc->next;
				}
		}
         } /*** end for(checkinstance = 0; checkinstance < TtlActiveChecks; checkinstance++) ***/

      rpc = rpc->next;
      }



   point = PointRoot;
   while (point)
     {
       for(checkinstance = 0; checkinstance < TtlActiveChecks; checkinstance++)
	 {
	   Config1 = SCCtable[point->Sindex].C;
	   Strat1  = SCCtable[point->Sindex].S;
	   Domain1 = SCCtable[point->Sindex].D;
	   if(CombinedCheckApplies(point->idn,checkinstance,POLYINTPOLY,point->Lindex,point->Sindex,
				   Config1,Strat1,Domain1,&part1,&part2,&part3) > 0)
	     {
	       ppc = point->next;
	       while (ppc)
		 {
		   Config1 = SCCtable[ppc->Sindex].C;
		   Strat1  = SCCtable[ppc->Sindex].S;
		   Domain1 = SCCtable[ppc->Sindex].D;
		   if(CombinedCheckApplies(ppc->idn,checkinstance,POLYINTPOLY,
					   ppc->Lindex,ppc->Sindex, Config1,Strat1,Domain1,&part1a,&part2a,&part3a) > 0)
		     if ( decide_to_checkfor_poly_intersect(part1, part1a, part2, part2a) )
		       {
			 if ( PolygonsIntersect(point->numverts, point->x, point->y, point->z, ppc->numverts, ppc->x, ppc->y, ppc->z) )
			   {
			     ERc = (struct PolygonCollection *) (malloc(SzPC));
			     if(ERc == NULL)
			       {	
				 printf("allocation memory exhausted during linear feature condition analysis\n");
				 printf("processing cannot continue\n");
				 exit(-1);
			       }
			     INIT_NULLS(ERc);
			     COPYVERTEXREFERENCES(ERc, 1, point->x, point->y, point->z, point->numverts);
			     COPYVERTEXREFERENCES(ERc, 2, ppc->x, ppc->y, ppc->z, ppc->numverts);
			     ERc->magnitude = 0.0;
			     ERc->keyval = POLYINTPOLY;
			     ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
			     ERc->pp = (struct ThePolys *) ppc;
			     ERc->pp2 = (struct ThePolys *) point;
			     ERc->aa = NULL;
			     ERc->next = NULL;
			     ERc->Sindex1 = point->Sindex;
			     ERc->Sindex2 = ppc->Sindex;
			     ERc->IDN1 = point->idn;
			     ERc->IDN2 = ppc->idn;
			     InsertPolygonPairIfNotADuplicate(&ERroot, ERc);
			   }				
		       }
		   ppc = ppc->next;
		 }
	     }
	 } /*** end for(checkinstance = 0; checkinstance < TtlActiveChecks; checkinstance++) *****/
       point = point->next;	
     }


   ERc = ERroot;
   while(ERc != NULL)
      {
	switch(ERc->keyval)
	  {
	  case POLYINAREA:
            FwriteTwoObjects(ERc->keyval, ERc->Cnumber, 
                             ERc->pp->idn,G_POLYGON,ERc->pp->SACindex,ERc->pp->localID,ERc->pp->SCCindex,-1.0,-1.0,ERc->pp->numverts,ERc->pp->x,
                             ERc->pp->y,ERc->pp->z,
                             ERc->aa->idn,G_AREAL,ERc->aa->Lindex,ERc->aa->localID,ERc->aa->Sindex,-1.0,-1.0,2,ERc->aa->x,
                             ERc->aa->y,ERc->aa->z);
            break;
	  case POLYOSIDEAREA:
            FwriteObject(ERc->keyval, ERc->Cnumber, ERc->pp->SACindex, ERc->pp->SCCindex, G_POLYGON, ERc->pp->localID,
			 ERc->pp->idn, 10.0, -1.0,ERc->pp->x,ERc->pp->y,ERc->pp->z,ERc->pp->numverts, 1);
            break;
	  case POLYINTPOLY:
            FwriteTwoObjects(ERc->keyval, ERc->Cnumber,
                             ERc->pp->idn,G_POLYGON,ERc->pp->SACindex,ERc->pp->localID,ERc->pp->SCCindex,-1.0,-1.0,ERc->pp->numverts,ERc->pp->x,
                             ERc->pp->y,ERc->pp->z,
                             ERc->pp2->idn,G_POLYGON,ERc->pp2->SACindex,ERc->pp2->localID,ERc->pp2->SCCindex,-1.0,-1.0,ERc->pp2->numverts,ERc->pp2->x,
                             ERc->pp2->y,ERc->pp2->z);

	    break;

	  case POLYINTAREA:  
            FwritePointAndTwoObjects(ERc->keyval, ERc->Cnumber,  ERc->pointX, ERc->pointY, 0.0,
                             ERc->pp->SCCindex,G_POLYGON,ERc->pp->SACindex,ERc->pp->localID,ERc->pp->idn,-1.0,-1.0,ERc->pp->x,
                             ERc->pp->y,ERc->pp->z,ERc->pp->numverts,
                             ERc->aa->Sindex,G_AREAL,ERc->aa->Lindex,ERc->aa->localID,ERc->aa->idn,-1.0,-1.0,ERc->aa->x,
                             ERc->aa->y,ERc->aa->z,2);
	    break;

	  default:
            printf("unrecognized key condition flag received during linear feature analysis\n");
            break;
	  }
	ERn = ERc;
	ERc = ERc->next;
	free(ERn);
      }


   return;
}





void PerformOtherPolyChecks(struct ThePolys * Proot, struct RawAreal * Aroot, struct RawPoint * PointRoot,
                         struct RawLinear *Lroot, int * LODbandCount)
{
struct ThePolys *rpc, *npc;
struct RawLinear *rlc;
struct RawPoint *rpt;
int i,j,k,minLODindex,foundobject;
double xint, yint;
int checkinstance;
double zdiff,answer;
double X[4], Y[4], Z[4];
double PA,PB,PC,PD;
int part1, part2, part3;

struct collection
   {
   int keyval;
   int Cnumber;
   double *x;
   double *y;
   double *z;
   double magnitude;
   int IDN;
   unsigned int Sindex;
   int vertexindex1, vertexindex2;
   struct RawAreal *aa;
   struct RawBridge *bb;
   struct RawPoint *pp;
   struct ListOfEdges *le;
   struct RawLinear *ll;
   struct ThePolys *poly;
   struct collection * next;
   } *ERroot, *ERc, *ERn;
int SzC = sizeof(struct collection);


   minLODindex = 0;

   if(Proot != NULL)
      {
      minLODindex = -1;
      if((ErrorLookup[LODELEVDIF].anyactive > 0) && (LODbandCount != NULL))
         {
         for(i=0; i<NumLODbands; i++)
            {
            if(LODbandCount[i] > 0)
               {
               if(minLODindex < 0)
                  minLODindex = i;
               else if(LODbandCount[i] < LODbandCount[minLODindex])
                  minLODindex = i;
               }
            }
         }
      }

   ++minLODindex;

   ERroot = NULL;
      
   rpc = Proot;

   while(rpc != NULL) /* looping through the raw polygons */
      {
 
      checkinstance = -1;
      if((ErrorLookup[LODELEVDIF].anyactive > 0) &&
         (CombinedCheckApplies(rpc->idn,checkinstance,LODELEVDIF,rpc->SACindex,rpc->SCCindex,rpc->config,rpc->stratum, rpc->domain,
                   &part1,&part2,&part3) > 0) &&
              (part1 > 0) && (CrsWlk[rpc->SACindex].LODband == minLODindex))
         {
         npc = Proot;
         while(npc != NULL)
            {
            for(checkinstance = 0; checkinstance < TtlActiveChecks; checkinstance++)
               {
               if((CombinedCheckApplies(npc->idn,checkinstance,LODELEVDIF,npc->SACindex,npc->SCCindex,
                      npc->config,npc->stratum, npc->domain,&part1,&part2,&part3) > 0) &&
                       (part1 > 0) && (CrsWlk[npc->SACindex].LODband != minLODindex))
                  {
                  for(i=0; i<rpc->numverts; i++)
                     {
                     zdiff = 0;
                     if((rpc->x[i] >= npc->minxvtx) && (rpc->x[i] <= npc->maxxvtx) &&
                           (rpc->y[i] >= npc->minyvtx) && (rpc->y[i] <= npc->maxyvtx))
                        {
                        if((npc->numverts == 3) && (PointInsideTriangle(rpc->x[i],rpc->y[i], npc->x[0], npc->y[0],
                                         npc->x[1], npc->y[1], npc->x[2], npc->y[2]) > 0))
                           {
                           PlaneEquation(&PA,&PB,&PC,&PD,npc->x,npc->y,npc->z,npc->numverts);
                           if((NEGSMIDGE < PC) && (PC < SMIDGE))
                              answer = npc->z[0];
                           else
                              SolveForZ(PA,PB,PC,PD,rpc->x[i],rpc->y[i],&answer);
                           zdiff = answer - rpc->z[i];
                           if(zdiff < 0)
                              zdiff = 0 - zdiff;
                           }
                        else if((npc->numverts > 3) && (PointInsidePoly(rpc->x[i],rpc->y[i], npc->x, npc->y, npc->numverts) > 0))
                           {
                           PlaneEquation(&PA,&PB,&PC,&PD,npc->x,npc->y,npc->z,npc->numverts);
                           if((NEGSMIDGE < PC) && (PC < SMIDGE))
                              answer = npc->z[0];
                           else
                              SolveForZ(PA,PB,PC,PD,rpc->x[i],rpc->y[i],&answer);
                           zdiff = answer - rpc->z[i];
                           if(zdiff < 0)
                              zdiff = 0 - zdiff;
                           }
                        }
                     if(SensitivityCheck(GTEQ, LODELEVDIF, checkinstance, zdiff) > 0)
                        {
                         FwriteMagnitudeAndTwoObjects(LODELEVDIF,Make_Correct(LODELEVDIF,checkinstance),zdiff,
                               rpc->SCCindex,G_POLYGON,rpc->SACindex,
                               rpc->localID,rpc->idn,-1.0,-1.0,&rpc->x[i],&rpc->y[i],&rpc->z[i],1,
                               npc->SCCindex,G_POLYGON,npc->SACindex,
                               npc->localID,npc->idn,-1.0,-1.0,npc->x,npc->y,npc->z,npc->numverts);
                        }
                     }
                  }
               } /**** end for(checkinstance = 0; checkinstance < TtlActiveChecks; checkinstance++) *****/
            npc = npc->next;
            }
         }

      for(checkinstance = 0; checkinstance < TtlActiveChecks; checkinstance++)
         {
         if((CombinedCheckApplies(rpc->idn,checkinstance,OBJECTWITHOUT,rpc->SACindex,rpc->SCCindex,
                rpc->config,rpc->stratum, rpc->domain,&part1,&part2,&part3) > 0) &&
              (part1 > 0))
            {
            foundobject = 0;
            rlc = Lroot;
            while(rlc != NULL)
               {
               if((CombinedCheckApplies(rlc->idn,checkinstance,OBJECTWITHOUT,
                         rlc->Lindex,rlc->Sindex,SCCtable[rlc->Sindex].C,SCCtable[rlc->Sindex].S,SCCtable[rlc->Sindex].D,
                   &part1,&part2,&part3) > 0) && (part2 > 0))
                  {
                  for(j=0; j<rlc->numnodes; j++)
                     {
                     if((rpc->numverts == 3) && (PointInsideTriangle(rlc->x[j],rlc->y[j], rpc->x[0], rpc->y[0],
                                         rpc->x[1], rpc->y[1], rpc->x[2], rpc->y[2]) > 0))
                        {
                        foundobject = 1;
                        break;
                        }
                     else if((rpc->numverts > 3) && (PointInsidePoly(rlc->x[j],rlc->y[j], rpc->x, rpc->y, rpc->numverts) > 0))
                        {
                        foundobject = 1;
                        break;
                        }
                     }
                  if((rlc->numnodes > 1) && (foundobject == 0))
                     {
                     for(j=1; j<rlc->numnodes; j++)
                        {
                        for(i=0; i<rpc->numverts; i++)
                           {
                           k = (i + 1) % rpc->numverts;
                           if(LineSegmentsIntersect(rlc->x[j-1],rlc->y[j-1],rlc->x[j],rlc->y[j],rpc->x[i],rpc->y[i],rpc->x[k],rpc->y[k],
                                    &xint, &yint) > 0)
                              {
                              foundobject = 1;
                              break;
                              }
                           }
                        if(foundobject > 0)
                           break;
                        }
                     }
                  }
               if(foundobject > 0)
                  break;
               rlc = rlc->next;
               }
            if(foundobject == 0) /** see if any point objects satisfy criteria **/
               {
               rpt = PointRoot;
               while(rpt != NULL)
                  {
                  if((rpt->numverts < 1) && (rpt->numverts > -3) &&
                      (CombinedCheckApplies(rpt->idn,checkinstance,OBJECTWITHOUT,
                             rpt->Lindex,rpt->Sindex,SCCtable[rpt->Sindex].C,SCCtable[rpt->Sindex].S,SCCtable[rpt->Sindex].D,
                      &part1,&part2,&part3) > 0) && (part2 > 0))
                     {
                     if((rpc->numverts == 3) && (PointInsideTriangle(rpt->x[0],rpt->y[0], rpc->x[0], rpc->y[0],
                                         rpc->x[1], rpc->y[1], rpc->x[2], rpc->y[2]) > 0))
                        {
                        foundobject = 1;
                        break;
                        }
                     else if((rpc->numverts > 3) && (PointInsidePoly(rpt->x[0],rpt->y[0], rpc->x, rpc->y, rpc->numverts) > 0))
                        {
                        foundobject = 1;
                        break;
                        }
                     }
                  if(foundobject > 0)
                     break;
                  rpt = rpt->next;
                  }
               }
            if(foundobject == 0) /** couldn't find specified point or line object in this polygon **/
               {
               FwriteObject(OBJECTWITHOUT,Make_Correct(OBJECTWITHOUT,checkinstance),
                                   rpc->SACindex, rpc->SCCindex, G_POLYGON,rpc->localID,/** need poly localID here **/rpc->idn,-1.0, -1.0,rpc->x,
                                   rpc->y,rpc->z,rpc->numverts, 1);
               }
            } /*** end OBJECTWITHOUT check for polys **/


         if((rpc->insertOK == 1) &&
           (CombinedCheckApplies(rpc->idn,checkinstance,ELEVADJCHANGE,rpc->SACindex,rpc->SCCindex,
                   rpc->config,rpc->stratum, rpc->domain,&part1,&part2,&part3) > 0) &&
                 (part1 > 0))
            {
            for(i=0; i < rpc->numverts; i++)
               {
               j = (i + 1) % rpc->numverts;
               if(rpc->z[i] > rpc->z[j])
                  zdiff = rpc->z[i] - rpc->z[j];
               else
                  zdiff = rpc->z[j] - rpc->z[i];
               if(SensitivityCheck(GTEQ, ELEVADJCHANGE, checkinstance, zdiff) > 0)
               /***if(zdiff >= ErrorLookup[ELEVADJCHANGE].sensitivity)***/
                  {
                  ERc = (struct collection *) (malloc(SzC));
                  if(ERc == NULL)
                     {
                     printf("allocation memory exhausted during polygon condition analysis\n");
                     printf("processing cannot continue\n");
                     exit(-1);
                     }
                  ERc->magnitude = zdiff;
                  ERc->keyval = ELEVADJCHANGE;
                  ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                  ERc->Sindex = rpc->SCCindex;
                  ERc->poly = rpc;
                  ERc->next = NULL;
                  ERc->x = (double *) (malloc(SzD * 2));
                  ERc->y = (double *) (malloc(SzD * 2));
                  ERc->z = (double *) (malloc(SzD * 2));
                  if((ERc->x == NULL) || (ERc->y == NULL) || (ERc->z == NULL))
                     {
                     printf("allocation memory exhausted during polygon condition analysis\n");
                     printf("processing cannot continue\n");
                     exit(-1);
                     }
                  ERc->x[0] = rpc->x[i];
                  ERc->y[0] = rpc->y[i];
                  ERc->z[0] = rpc->z[i];
                  ERc->x[1] = rpc->x[j];
                  ERc->y[1] = rpc->y[j];
                  ERc->z[1] = rpc->z[j];

                  if(ERroot == NULL)
                     {
                     ERroot = ERc;
                     }
                  else
                     {
                     ERn = ERroot;
                     while(ERn != NULL)
                        {
			  if(
			     (ERn->Cnumber    == ERc->Cnumber)    &&
			     (ERn->keyval    == ERc->keyval)    && 
			     (ERn->magnitude == ERc->magnitude) && 
			     (ERn->x[1]      == ERc->x[1])      &&
			     (ERn->y[1]      == ERc->y[1])      && 
			     (ERn->x[0]      == ERc->x[0])      && 
			     (ERn->y[0]      == ERc->y[0])      &&
			     (ERn->Sindex    == ERc->Sindex)
			     )
                           break;
                        ERn = ERn->next;
                        }
                     if(ERn == NULL)
                        {
                        ERc->next = ERroot;
                        ERroot = ERc;
                        }
                     else
                        {
                        free(ERc->x);
                        free(ERc->y);
                        free(ERc->z);
                        free(ERc);
                        }
                     }
                  }
               }
            }
         } /**** for(checkinstance = 0; checkinstance < TtlActiveChecks; checkinstance++) ****/

      rpc = rpc->next;
      }  /*** end while rpc != NULL ****/


   ERc = ERroot;
   while(ERc != NULL)
      {
      switch(ERc->keyval)
         {
         case ELEVADJCHANGE:
            X[0] = ERc->x[0];
            Y[0] = ERc->y[0];
            Z[0] = ERc->z[0];
            X[1] = ERc->x[1];
            Y[1] = ERc->y[1];
            Z[1] = ERc->z[1];
            FwriteObjectAndMagnitude(ERc->keyval, ERc->Cnumber,
                        ERc->poly->idn, ERc->Sindex,G_POLYGON,ERc->poly->SACindex,ERc->poly->localID,-1.0,-1.0,ERc->magnitude,X,Y,Z,2, 1);
            break;

         default:
            printf("unrecognized key condition flag received during linear feature analysis\n");
            break;
         }
      ERn = ERc;
      ERc = ERc->next;
      free(ERn->x);
      free(ERn->y);
      free(ERn->z);
      free(ERn);
      }

   return;
} /*** end PerformOtherPolyChecks ***/




int DrawSubnetFeatures(char * fname, int TgtCheck, int TgtCnumber, int TgtIndexStart, int TgtIndexStop)
{
int threshold = 2;
int i, j, TgtIndex;
int NetTypeCount, LIindex;
int index, cnumber, count, checkdefinenumber;
int definenumber;
int answer;
int AbortDraw;
int Afiledecimal, Lfiledecimal;
long int Afileposn, Lfileposn, Pfileposn;
int Afileopen, Lfileopen;
int vtxcnt,igeom;
int ttlnets;
int FCODE;
int NumFCODE, NumFeatures;
long int seekposn;
long int ftellposn;
double FeatureFileInfo;
double mix, miy, max,may;
double dbltemp;
FILE *filein;
FILE *lfilein, *afilein, *pfilein;
char Afname[300];
char Lfname[300];
char suffix[100];
char title[1000];
char geom;
struct LookupInfo
   {
   int cnumber;
   int index;
   long seekposn;
   } *LI;


   if(NetRouteType > 0)
      {
      RoutePlanningAttempts += 1;
      return(DrawSubnetPathAndFeatures(fname, TgtCheck, TgtCnumber, TgtIndexStart, TgtIndexStop));
      }

   NetTypeCount = -1;
   answer = -1;
   Afiledecimal = Lfiledecimal = -1;
   Afileopen = Lfileopen = -1;
   lfilein = afilein = pfilein = NULL;
   filein = fopen(fname,"rb");
   if(filein != NULL)
      {
      SEEIT_fread_int(&NetTypeCount,filein);
      if(NetTypeCount > 0)
         {
         for(i=0; i<NetTypeCount; i++)
            {
            SEEIT_fread_int(&checkdefinenumber,filein);
            SEEIT_fread_int(&cnumber,filein);
            SEEIT_fread_int(&count,filein);
            fread(&title[0],1000,1,filein);

            }
         SEEIT_fread_int(&ttlnets,filein);
         ftellposn = ftell(filein);

         if(ttlnets >= threshold)
            {
            LI = (struct LookupInfo *) (malloc(sizeof(struct LookupInfo) * (ttlnets + 2)));
            LIindex = 0;
            for(i=0; i<ttlnets; i++)
               {
               SEEIT_fread_int(&checkdefinenumber,filein);
               SEEIT_fread_int(&cnumber,filein);
               SEEIT_fread_int(&index,filein);
               SEEIT_fread_long(&seekposn,filein);
               if((checkdefinenumber == TgtCheck) && (cnumber == TgtCnumber))
                  {
                  LI[LIindex].cnumber = cnumber;
                  LI[LIindex].index = index;
                  LI[LIindex].seekposn = seekposn;
                  ++LIindex;
                  }
               }
            }

         for(TgtIndex = TgtIndexStart; TgtIndex <= TgtIndexStop; TgtIndex++)
            {
            if(ttlnets < threshold)
               {
               for(i=0; i<ttlnets; i++)
                  {
                  SEEIT_fread_int(&checkdefinenumber,filein);
                  SEEIT_fread_int(&cnumber,filein);
                  SEEIT_fread_int(&index,filein);
                  SEEIT_fread_long(&seekposn,filein);
                  if((checkdefinenumber == TgtCheck) && (cnumber == TgtCnumber) && (index == TgtIndex))
                  break;
                  }
               }
            else
               {
               for(i=0; i<LIindex; i++)
                  {
                  if((LI[i].cnumber == TgtCnumber) && (LI[i].index == TgtIndex)) 
                     {
                     seekposn = LI[i].seekposn;
                     break;
                     }
                  }
               if(i >= LIindex)
                  i = ttlnets + 2;
               }
            if(i >= ttlnets)
               answer = -1;
            else
               {
               fseek(filein,seekposn,SEEK_SET);
               SEEIT_fread_int(&definenumber,filein);
               SEEIT_fread_int(&cnumber,filein);
               SEEIT_fread_int(&index,filein);
               if((definenumber == TgtCheck) && (cnumber == TgtCnumber) && (index == TgtIndex))
                  {
                  answer = 1;
                  SEEIT_fread_int(&NumFCODE,filein);
                  SEEIT_fread_int(&FCODE,filein);
                  SEEIT_fread_double(&mix,filein);
                  SEEIT_fread_double(&miy,filein);
                  SEEIT_fread_double(&max,filein);
                  SEEIT_fread_double(&may,filein);
                  SEEIT_fread_int(&NumFeatures,filein);
                  for(j=0; j<NumFeatures; j++)
                     {
                     AbortDraw = AbortZoom();
                     if(AbortDraw == 1)
                        {
                        if(afilein != NULL)
                           fclose(afilein);
                        if(lfilein != NULL)
                           fclose(lfilein);
                        if(pfilein != NULL)
                           fclose(pfilein);
                        fclose(filein);
                        if(ttlnets >= threshold)
                           free(LI);
                        return(-1);
                        }
                     fread(&geom,1,1,filein);
                     igeom = (int) geom;
                     SEEIT_fread_double(&FeatureFileInfo,filein);

                     if(igeom == G_AREAL)
                        {
                        Afileposn = (long int) FeatureFileInfo;
                        dbltemp = FeatureFileInfo - ((double) Afileposn);
                        dbltemp = dbltemp * 10;
                        dbltemp += 0.1;
                        Afiledecimal = (int) dbltemp;
                        if(Afiledecimal != Afileopen)
                           {
                           if(afilein != NULL)
                              {
                              fclose(afilein);
                              }
                           strcpy(Afname,arealsin);
                           if(Afiledecimal > 1)
                              {
                              sprintf(suffix,"%d",Afiledecimal-1);
                              strcat(Afname,suffix);
                              }
                           afilein = fopen(Afname,"rb");
                           if(afilein == NULL)
                              {
                              printf("areals in string is: %s\n",arealsin);
                              printf("9 area feature data input file %s could not be opened for read\n",Afname);
                              exit(-1);
                              }
                           Afileopen = Afiledecimal;
                           }

                        fseek(afilein,Afileposn,SEEK_SET);
                        vtxcnt = ReadArealFromFile(afilein, SignificantDecimals);
                        MAPdrawpoly(ArealFromFile.numverts,ArealFromFile.x,ArealFromFile.y,
                                      1,0,1,1,DRAW_NOW);
                        }

                     else if(igeom == G_LINE)
                        {
                        Lfileposn = (long int) FeatureFileInfo;
                        dbltemp = FeatureFileInfo - ((double) Lfileposn);
                        dbltemp = dbltemp * 10;
                        dbltemp += 0.1;
                        Lfiledecimal = (int) dbltemp;
                        if(Lfiledecimal != Lfileopen)
                           {
                           if(lfilein != NULL)
                              {
                              fclose(lfilein);
                              }
                           strcpy(Lfname,linearsin);
                           if(Lfiledecimal > 1)
                              {
                              sprintf(suffix,"%d",Lfiledecimal-1);
                              strcat(Lfname,suffix);
                              }
                           lfilein = fopen(Lfname,"rb");
                           if(lfilein == NULL)
                              {
                              printf("9 line feature data input file %s could not be opened for read\n",Lfname);
                              exit(-1);
                              }
                           Lfileopen = Lfiledecimal;
                           }

                        fseek(lfilein,Lfileposn,SEEK_SET);
                        vtxcnt = ReadLinearFromFile(lfilein, SignificantDecimals);
                        MAPdrawfullline(LinearFromFile.x,LinearFromFile.y,LinearFromFile.numnodes,1,DRAW_NOW);
                        }
                     else if(igeom == G_POINT)
                        {
                        if(pfilein == NULL)
                           pfilein = fopen(pointsin,"rb");
                        Pfileposn = (long int) FeatureFileInfo;
                        fseek(pfilein,Pfileposn,SEEK_SET);
                        vtxcnt = ReadPointFromFile(pfilein, SignificantDecimals);
                        MAPdrawX(PointFromFile.x[0],PointFromFile.y[0],1,DRAW_NOW); //PointFromFile.Lindex);
                        }
                     }
                  if(ttlnets < threshold)
                     fseek(filein,ftellposn,SEEK_SET); /*** restore file ptr to indes location **/
                  }
               else
                  {
                  answer = -1;
                  break;
                  }
               }
            }
         }

      if(afilein != NULL)
         fclose(afilein);
      if(lfilein != NULL)
         fclose(lfilein);
      fclose(filein);
      if(ttlnets >= threshold)
         free(LI);
      }

   return(answer);
}


/** see function void SummarizeRoutePlanningResults(void) in moregeomchecks.c for printing of planning summary to console **/
int DrawSubnetPathAndFeatures(char * fname, int TgtCheck, int TgtCnumber, int TgtIndexStart, int TgtIndexStop)
{
extern struct POIList  * POIRoot;
struct POIList *POIc;
extern int API_DRAW;
extern void MySetLineThickness(int thickness);
int IllustrateNetworkSolution = 0; /** if > 0 draw network links as they are expanded during path-planning search **/
int NetworkLinkDrawDelay = 0; /**100000; use in conjunction with IllustrateNetworkSolution to slow down solution (use a big number) **/
int listlength;
int threshold = 2;
int i, ii, j, index1,index2,cindex,cindex2,TgtIndex;
int NetTypeCount, LIindex;
int index, cnumber, count, checkdefinenumber;
int definenumber, AddNode;
int answer;
int AbortDraw, AbortRouting;
int TickerCount = 0;
int Afiledecimal, Lfiledecimal;
long int Afileposn, Lfileposn, Pfileposn;
int Afileopen, Lfileopen;
int vtxcnt,igeom;
int ttlnets;
int FCODE;
int NumFCODE, NumFeatures;
int RouteCnumber, RouteIndex;
int ShowNetworkInBackground = 0; /** for path-planning - if > 0 show the entire network and then draw solution path in bold on top  **/
long int seekposn;
long int ftellposn;
double FeatureFileInfo;
double mix, miy, max,may;
double dbltemp;
double Sx, Sy, Gx, Gy;
double RealSx, RealSy, RealGx, RealGy;
double Sdist, Gdist, MinH;
FILE *filein;
FILE *lfilein, *afilein, *pfilein;
char Afname[300];
char Lfname[300];
char suffix[100];
char title[1000];
char geom;
struct LookupInfo
   {
   int cnumber;
   int index;
   long seekposn;
   } *LI;
struct NetNode
   {
   double x;
   double y;
   double z;
   struct ConnectList *joins;
   struct NetNode *next;
   } *Nn, *Nc, *Np, *StartPtr, *GoalPtr;
struct ConnectList
   {
   struct NetNode *node;
   struct ConnectList *next;
   } *Cc, *Cp, *Cn;
struct TheNodes
   {
   struct NetNode *thisnode;
   //struct NetNode *comesfrom;
   double f,g,h;
   struct TheNodes *comesfrom;
   struct TheNodes *next;
   } *Open, *Closed, *TNc, *TNp, *TNn, *TNc2, *Expanding;
struct NodeIndex
   {
   struct NetNode *n;
   struct TheNodes *Closed;
   struct NodeIndex *next;
   }  *Buckets;
int SzNN = sizeof(struct NetNode);
int SzCL = sizeof(struct ConnectList);
int SzTN = sizeof(struct TheNodes);
   if(POIRoot == NULL)
      {
      RouteProblem1 += 1;
      return(-1);
      }
   if(TgtIndexStart != TgtIndexStop)
     {
     printf("only one network can be selected - try again with only one network\n");
     return(-1);
     }

   ShowNetworkInBackground = 0;
   if(NetRouteType == 1)
      ShowNetworkInBackground = 1;
   POIc = POIRoot;
   index1 = index2 = 0;
   while(POIc != NULL)
      {
      if(strstr(POIc->annotation,"Goal Instance") != NULL)
         {
         i = 14;
         j = 0;
         while((POIc->annotation[i] >= '0') && (POIc->annotation[i] <= '9'))
            {
            j = (j * 10) + (int) (POIc->annotation[i] - 48);
            ++i;
            }
         cindex = j - 1;
         if(cindex == TgtCnumber)
            {
            if(strncmp(&POIc->annotation[i]," Network ",9) == 0)
               {
               i += 9;
               j = 0;
               while((POIc->annotation[i] >= '0') && (POIc->annotation[i] <= '9'))
                  {
                  j = (j * 10) + (int) (POIc->annotation[i] - 48);
                  ++i;
                  }
               cindex2 = j;
               if((cindex == TgtCnumber) && (cindex2 == TgtIndexStart))
                  {
                  RouteCnumber = cindex;
                  RouteIndex = cindex2;
                  index1 += 1;
                  Gx = POIc->x;
                  Gy = POIc->y;
                  }
               }
            }
         }

      if(strstr(POIc->annotation,"Start Instance") != NULL)
         {
         i = 15;
         j = 0;
         while((POIc->annotation[i] >= '0') && (POIc->annotation[i] <= '9'))
            {
            j = (j * 10) + (int) (POIc->annotation[i] - 48);
            ++i;
            }
         cindex = j - 1;
         if(cindex == TgtCnumber)
            {
            if(strncmp(&POIc->annotation[i]," Network ",9) == 0)
               {
               i += 9;
               j = 0;
               while((POIc->annotation[i] >= '0') && (POIc->annotation[i] <= '9'))
                  {
                  j = (j * 10) + (int) (POIc->annotation[i] - 48);
                  ++i;
                  }
               cindex2 = j;
               if((cindex == TgtCnumber) && (cindex2 == TgtIndexStart))
                  {
                  RouteCnumber = cindex;
                  RouteIndex = cindex2;
                  index2 += 1;
                  Sx = POIc->x;
                  Sy = POIc->y;
                  }
               }
            }
         }

      if((index1 > 0) && (index2 > 0))
         break;
      POIc = POIc->next;
      }

   if((POIc == NULL) || (index1 != 1) || (index2 != 1))
      {
      RouteProblem2 += 1;
      return(-1);
      }

   Open = Closed = NULL;
   listlength = (MaxXindex + 1) * (MaxYindex + 1);
   Buckets = (struct NodeIndex *) (malloc(sizeof(struct NodeIndex) * listlength));
   if(Buckets == NULL)
      {
      printf("allocation memory exhausted during network indexing initialization for route planning\n");
      exit(-1);
      }
   for(i=0; i<listlength; i++)
      {
      Buckets[i].n = NULL;
      Buckets[i].Closed = NULL;
      Buckets[i].next = NULL;
      }


   NetTypeCount = -1;
   answer = -1;
   Afiledecimal = Lfiledecimal = -1;
   Afileopen = Lfileopen = -1;
   lfilein = afilein = pfilein = NULL;
   filein = fopen(fname,"rb");
   if(filein != NULL)
      {
      SEEIT_fread_int(&NetTypeCount,filein);
      if(NetTypeCount > 0)
         {
         for(i=0; i<NetTypeCount; i++)
            {
            SEEIT_fread_int(&checkdefinenumber,filein);
            SEEIT_fread_int(&cnumber,filein);
            SEEIT_fread_int(&count,filein);
            fread(&title[0],1000,1,filein);

            }
         SEEIT_fread_int(&ttlnets,filein);
         ftellposn = ftell(filein);

         if(ttlnets >= threshold)
            {
            LI = (struct LookupInfo *) (malloc(sizeof(struct LookupInfo) * (ttlnets + 2)));
   if(LI == NULL)
      {
      printf("allocation memory exhausted during network route planning (2)\n");
      exit(-1);
      }
            LIindex = 0;
            for(i=0; i<ttlnets; i++)
               {
               SEEIT_fread_int(&checkdefinenumber,filein);
               SEEIT_fread_int(&cnumber,filein);
               SEEIT_fread_int(&index,filein);
               SEEIT_fread_long(&seekposn,filein);
               if((checkdefinenumber == TgtCheck) && (cnumber == TgtCnumber))
                  {
                  LI[LIindex].cnumber = cnumber;
                  LI[LIindex].index = index;
                  LI[LIindex].seekposn = seekposn;
                  ++LIindex;
                  }
               }
            }
         for(TgtIndex = TgtIndexStart; TgtIndex <= TgtIndexStop; TgtIndex++)
            {
            if(ttlnets < threshold)
               {
               for(i=0; i<ttlnets; i++)
                  {
                  SEEIT_fread_int(&checkdefinenumber,filein);
                  SEEIT_fread_int(&cnumber,filein);
                  SEEIT_fread_int(&index,filein);
                  SEEIT_fread_long(&seekposn,filein);
                  if((checkdefinenumber == TgtCheck) && (cnumber == TgtCnumber) && (index == TgtIndex))
                  break;
                  }
               }
            else
               {
               for(i=0; i<LIindex; i++)
                  {
                  if((LI[i].cnumber == TgtCnumber) && (LI[i].index == TgtIndex))
                     {
                     seekposn = LI[i].seekposn;
                     break;
                     }
                  }
               if(i >= LIindex)
                  i = ttlnets + 2;
               }
            if(i >= ttlnets)
               answer = -1;
            else
               {
               fseek(filein,seekposn,SEEK_SET);
               SEEIT_fread_int(&definenumber,filein);
               SEEIT_fread_int(&cnumber,filein);
               SEEIT_fread_int(&index,filein);
               if((definenumber == TgtCheck) && (cnumber == TgtCnumber) && (index == TgtIndex))
                  {
                  answer = 1;
                  SEEIT_fread_int(&NumFCODE,filein);
                  SEEIT_fread_int(&FCODE,filein);
                  SEEIT_fread_double(&mix,filein);
                  SEEIT_fread_double(&miy,filein);
                  SEEIT_fread_double(&max,filein);
                  SEEIT_fread_double(&may,filein);
                  SEEIT_fread_int(&NumFeatures,filein);
                  Sdist = -1;
                  Gdist = -1;
                  for(j=0; j<NumFeatures; j++)
                     {
                     AbortDraw = AbortZoom();
                     if(AbortDraw == 1)
                        {
                        if(afilein != NULL)
                           fclose(afilein);
                        if(lfilein != NULL)
                           fclose(lfilein);
                        if(pfilein != NULL)
                           fclose(pfilein);
                        fclose(filein);
                        if(ttlnets >= threshold)
                           free(LI);
                        return(-1);
                        }
                     fread(&geom,1,1,filein);
                     igeom = (int) geom;
                     SEEIT_fread_double(&FeatureFileInfo,filein);

                     if(igeom == G_AREAL)
                        {
                        Afileposn = (long int) FeatureFileInfo;
                        dbltemp = FeatureFileInfo - ((double) Afileposn);
                        dbltemp = dbltemp * 10;
                        dbltemp += 0.1;
                        Afiledecimal = (int) dbltemp;
                        if(Afiledecimal != Afileopen)
                           {
                           if(afilein != NULL)
                              {
                              fclose(afilein);
                              }
                           strcpy(Afname,arealsin);
                           if(Afiledecimal > 1)
                              {
                              sprintf(suffix,"%d",Afiledecimal-1);
                              strcat(Afname,suffix);
                              }
                           afilein = fopen(Afname,"rb");
                           if(afilein == NULL)
                              {
                              printf("areals in string is: %s\n",arealsin);
                              printf("9 area feature data input file %s could not be opened for read\n",Afname);
                              exit(-1);
                              }
                           Afileopen = Afiledecimal;
                           }

                        fseek(afilein,Afileposn,SEEK_SET);
                        vtxcnt = ReadArealFromFile(afilein, SignificantDecimals);
                        if(ShowNetworkInBackground > 0)
                           MAPdrawpoly(ArealFromFile.numverts,ArealFromFile.x,ArealFromFile.y,
                                      1,0,1,1,DRAW_NOW);
                        ii = ArealFromFile.numverts - 1;
                        for(i = 0; i<ArealFromFile.numverts; i++)
                           {
                           index1 = (int) (ArealFromFile.x[i] / RegionSize);
                           index2 = (int) (ArealFromFile.y[i] / RegionSize);

                           cindex = (index1 * (MaxYindex + 1)) + index2;   //data will go into Buckets[cindex]

                           Nc = Buckets[cindex].n;
                           while(Nc != NULL)
                              {
                              if((Nc->x == ArealFromFile.x[i]) && (Nc->y == ArealFromFile.y[i]))  //found it
                                 {
                                 break;
                                 }
                              Nc = Nc->next;
                              }
                           if(Nc == NULL)
                              {
                              Nc = (struct NetNode *) (malloc(SzNN));
   if(Nc == NULL)
      {
      printf("allocation memory exhausted during network route planning (3)\n");
      exit(-1);
      }
                              Nc->x = ArealFromFile.x[i];
                              Nc->y = ArealFromFile.y[i];
                              Nc->z = ArealFromFile.z[i];
                              Nc->joins = NULL;
                              Nc->next = Buckets[cindex].n;
                              Buckets[cindex].n = Nc;
                              }
                           dbltemp = SquaredDistance_GAITcoords(Sx,Sy,ArealFromFile.x[i],ArealFromFile.y[i]);
                           if((Sdist < 0) || (dbltemp < Sdist))
                              {
                              RealSx = ArealFromFile.x[i];
                              RealSy = ArealFromFile.y[i];
                              Sdist = dbltemp;
                              StartPtr = Nc;
                              }
                           dbltemp = SquaredDistance_GAITcoords(Gx,Gy,ArealFromFile.x[i],ArealFromFile.y[i]);
                           if((Gdist < 0) || (dbltemp < Gdist))
                              {
                              RealGx = ArealFromFile.x[i];
                              RealGy = ArealFromFile.y[i];
                              Gdist = dbltemp;
                              GoalPtr = Nc;
                              }

                           index1 = (int) (ArealFromFile.x[ii] / RegionSize);
                           index2 = (int) (ArealFromFile.y[ii] / RegionSize);

                           cindex2 = (index1 * (MaxYindex + 1)) + index2;
                           Nn = Buckets[cindex2].n;
                           while(Nn != NULL)
                              {
                              if((Nn->x == ArealFromFile.x[ii]) && (Nn->y == ArealFromFile.y[ii]))  //found it
                                 {
                                 break;
                                 }
                              Nn = Nn->next;
                              }
                           if(Nn == NULL)
                              {
                              Nn = (struct NetNode *) (malloc(SzNN));
   if(Nn == NULL)
      {
      printf("allocation memory exhausted during network route planning (4)\n");
      exit(-1);
      }
                              Nn->x = ArealFromFile.x[ii];
                              Nn->y = ArealFromFile.y[ii];
                              Nn->z = ArealFromFile.z[ii];
                              Nn->joins = NULL;
                              Nn->next = Buckets[cindex2].n;
                              Buckets[cindex2].n = Nn;
                              }
                           dbltemp = SquaredDistance_GAITcoords(Sx,Sy,ArealFromFile.x[ii],ArealFromFile.y[ii]);
                           if((Sdist < 0) || (dbltemp < Sdist))
                              {
                              RealSx = ArealFromFile.x[ii];
                              RealSy = ArealFromFile.y[ii];
                              Sdist = dbltemp;
                              StartPtr = Nn;
                              }
                           dbltemp = SquaredDistance_GAITcoords(Gx,Gy,ArealFromFile.x[ii],ArealFromFile.y[ii]);
                           if((Gdist < 0) || (dbltemp < Gdist))
                              {
                              RealGx = ArealFromFile.x[ii];
                              RealGy = ArealFromFile.y[ii];
                              Gdist = dbltemp;
                              GoalPtr = Nn;
                              }
                           Cc = Nc->joins;
                           while(Cc != NULL)
                              {
                              if(Cc->node == Nn)
                                 break;
                              Cc = Cc->next;
                              }
                           if(Cc == NULL)
                              {
                              Cn = (struct ConnectList *) (malloc(SzCL));
   if(Cn == NULL)
      {
      printf("allocation memory exhausted during network route planning (5)\n");
      exit(-1);
      }
                              Cn->node = Nn;
                              Cn->next = Nc->joins;
                              Nc->joins = Cn;
                              }

                           Cc = Nn->joins;
                           while(Cc != NULL)
                              {
                              if(Cc->node == Nc)
                                 break;
                              Cc = Cc->next;
                              }
                           if(Cc == NULL)
                              {
                              Cn = (struct ConnectList *) (malloc(SzCL));
   if(Cn == NULL)
      {
      printf("allocation memory exhausted during network route planning (6)\n");
      exit(-1);
      }
                              Cn->node = Nc;
                              Cn->next = Nn->joins;
                              Nn->joins = Cn;
                              }
                           ii = i;
                           }
                        }

                     else if(igeom == G_LINE)
                        {
                        Lfileposn = (long int) FeatureFileInfo;
                        dbltemp = FeatureFileInfo - ((double) Lfileposn);
                        dbltemp = dbltemp * 10;
                        dbltemp += 0.1;
                        Lfiledecimal = (int) dbltemp;
                        if(Lfiledecimal != Lfileopen)
                           {
                           if(lfilein != NULL)
                              {
                              fclose(lfilein);
                              }
                           strcpy(Lfname,linearsin);
                           if(Lfiledecimal > 1)
                              {
                              sprintf(suffix,"%d",Lfiledecimal-1);
                              strcat(Lfname,suffix);
                              }
                           lfilein = fopen(Lfname,"rb");
                           if(lfilein == NULL)
                              {
                              printf("9 line feature data input file %s could not be opened for read\n",Lfname);
                              exit(-1);
                              }
                           Lfileopen = Lfiledecimal;
                           }

                        fseek(lfilein,Lfileposn,SEEK_SET);
                        vtxcnt = ReadLinearFromFile(lfilein, SignificantDecimals);
                        if(ShowNetworkInBackground > 0)
                           MAPdrawfullline(LinearFromFile.x,LinearFromFile.y,LinearFromFile.numnodes,1,DRAW_NOW);

                        for(i = 1; i<LinearFromFile.numnodes; i++)
                           {
                           ii = i - 1;
                           index1 = (int) (LinearFromFile.x[i] / RegionSize);
                           index2 = (int) (LinearFromFile.y[i] / RegionSize);
               
                           cindex = (index1 * (MaxYindex + 1)) + index2;

                           Nc = Buckets[cindex].n;
                           while(Nc != NULL)
                              {
                              if((Nc->x == LinearFromFile.x[i]) && (Nc->y == LinearFromFile.y[i]))  //found it
                                 {
                                 break;
                                 }
                              Nc = Nc->next;
                              }
                           if(Nc == NULL)
                              {
                              Nc = (struct NetNode *) (malloc(SzNN));
   if(Nc == NULL)
      {
      printf("allocation memory exhausted during network route planning (7)\n");
      exit(-1);
      }
                              Nc->x = LinearFromFile.x[i];
                              Nc->y = LinearFromFile.y[i];
                              Nc->z = LinearFromFile.z[i];
                              Nc->joins = NULL;
                              Nc->next = Buckets[cindex].n;
                              Buckets[cindex].n = Nc;
                              }
                           dbltemp = SquaredDistance_GAITcoords(Sx,Sy,LinearFromFile.x[i],LinearFromFile.y[i]);
                           if((Sdist < 0) || (dbltemp < Sdist))
                              {
                              RealSx = LinearFromFile.x[i];
                              RealSy = LinearFromFile.y[i];
                              Sdist = dbltemp;
                              StartPtr = Nc;
                              }
                           dbltemp = SquaredDistance_GAITcoords(Gx,Gy,LinearFromFile.x[i],LinearFromFile.y[i]);
                           if((Gdist < 0) || (dbltemp < Gdist))
                              {
                              RealGx = LinearFromFile.x[i];
                              RealGy = LinearFromFile.y[i];
                              Gdist = dbltemp;
                              GoalPtr = Nc;
                              }

                           index1 = (int) (LinearFromFile.x[ii] / RegionSize);
                           index2 = (int) (LinearFromFile.y[ii] / RegionSize);

                           cindex2 = (index1 * (MaxYindex + 1)) + index2;

                           Nn = Buckets[cindex2].n;
                           while(Nn != NULL)
                              {
                              if((Nn->x == LinearFromFile.x[ii]) && (Nn->y == LinearFromFile.y[ii]))  //found it
                                 {
                                 break;
                                 }
                              Nn = Nn->next;
                              }
                           if(Nn == NULL)
                              {
                              Nn = (struct NetNode *) (malloc(SzNN));
   if(Nn == NULL)
      {
      printf("allocation memory exhausted during network route planning (8)\n");
      exit(-1);
      }
                              Nn->x = LinearFromFile.x[ii];
                              Nn->y = LinearFromFile.y[ii];
                              Nn->z = LinearFromFile.z[ii];
                              Nn->joins = NULL;
                              Nn->next = Buckets[cindex2].n;
                              Buckets[cindex2].n = Nn;
                              }
                           dbltemp = SquaredDistance_GAITcoords(Sx,Sy,LinearFromFile.x[ii],LinearFromFile.y[ii]);
                           if((Sdist < 0) || (dbltemp < Sdist))
                              {
                              RealSx = LinearFromFile.x[ii];
                              RealSy = LinearFromFile.y[ii];
                              Sdist = dbltemp;
                              StartPtr = Nn;
                              }
                           dbltemp = SquaredDistance_GAITcoords(Gx,Gy,LinearFromFile.x[ii],LinearFromFile.y[ii]);
                           if((Gdist < 0) || (dbltemp < Gdist))
                              {
                              RealGx = LinearFromFile.x[ii];
                              RealGy = LinearFromFile.y[ii];
                              Gdist = dbltemp;
                              GoalPtr = Nn;
                              }
                           Cc = Nc->joins;
                           while(Cc != NULL)
                              {
                              if(Cc->node == Nn)
                                 break;
                              Cc = Cc->next;
                              }
                           if(Cc == NULL)
                              {
                              Cn = (struct ConnectList *) (malloc(SzCL));
   if(Cn == NULL)
      {
      printf("allocation memory exhausted during network route planning (9)\n");
      exit(-1);
      }
                              Cn->node = Nn;
                              Cn->next = Nc->joins;
                              Nc->joins = Cn;
                              }
               
                           Cc = Nn->joins;
                           while(Cc != NULL)
                              {
                              if(Cc->node == Nc)
                                 break;
                              Cc = Cc->next;
                              }
                           if(Cc == NULL)
                              {
                              Cn = (struct ConnectList *) (malloc(SzCL));
   if(Cn == NULL)
      {
      printf("allocation memory exhausted during network route planning (10)\n");
      exit(-1);
      }
                              Cn->node = Nc;
                              Cn->next = Nn->joins;
                              Nn->joins = Cn;
                              }
                           }
                        }
                     else if(igeom == G_POINT)
                        {
                        if(pfilein == NULL)
                           pfilein = fopen(pointsin,"rb");
                        Pfileposn = (long int) FeatureFileInfo;
                        fseek(pfilein,Pfileposn,SEEK_SET);
                        vtxcnt = ReadPointFromFile(pfilein, SignificantDecimals);
                        if(ShowNetworkInBackground > 0)
                           MAPdrawX(PointFromFile.x[0],PointFromFile.y[0],1,DRAW_NOW);
                        }
                     }
                  if(ttlnets < threshold)
                     fseek(filein,ftellposn,SEEK_SET); 
                  }
               else
                  {
                  answer = -1;
                  break;
                  }
               }
            }
         }

      if(afilein != NULL)
         fclose(afilein);
      if(lfilein != NULL)
         fclose(lfilein);
      fclose(filein);
      if(ttlnets >= threshold)
         free(LI);
      }
   Sdist = Distance(Sx,Sy,RealSx,RealSy);
   Gdist = Distance(Gx,Gy,RealGx,RealGy);
   if((Gdist > 100) || (Sdist > 100))
      {
      RouteProblem3 += 1;
      for(i=0; i<listlength; i++)
         {
         TNc = Buckets[i].Closed;
         while(TNc != NULL)
            {
            TNp = TNc;
            TNc = TNc->next;
            free(TNp);
            }

         Nc = Buckets[i].n;
         while(Nc != NULL)
            {
            Np = Nc;
            Cc = Np->joins;
            while(Cc != NULL)
               {
               Cp = Cc;
               Cc = Cc->next;
               free(Cp);
               }
            Nc = Nc->next;
            free(Np);
            }
         }
      free(Buckets);
      answer = -1;
      return(answer);
      }
   printf("preparing to plan least-distance route across Network %d Instantiation %d between:\n",TgtIndexStart,TgtCnumber+1);
   printf("Start %s and ",Coordinate2DtoString(RealSx,RealSy));
   printf("Goal %s\n",Coordinate2DtoString(RealGx,RealGy));
   printf("(POI specified points were Start: %s and ",Coordinate2DtoString(Sx,Sy));
   printf("Goal: %s)\n",Coordinate2DtoString(Gx,Gy));
   TNn = (struct TheNodes *) (malloc(SzTN));
   if(TNn == NULL)
      {
      printf("allocation memory exhausted during network route planning (11)\n");
      exit(-1);
      }
   TNn->thisnode = StartPtr;
   TNn->comesfrom = NULL;
   TNn->h = Distance(StartPtr->x,StartPtr->y,GoalPtr->x,GoalPtr->y);
   MinH = TNn->h;
   TNn->g = 0;
   TNn->f = TNn->g + TNn->h;
   TNn->next = NULL;

   index1 = (int) (StartPtr->x / RegionSize);
   index2 = (int) (StartPtr->y / RegionSize);
   cindex2 = (index1 * (MaxYindex + 1)) + index2;
   Buckets[cindex2].Closed = TNn;
   Buckets[cindex2].Closed->next = NULL;

   Expanding = TNn;
   Cc = Expanding->thisnode->joins;
   while(Cc != NULL) 
      {
      Nc = Cc->node;
      if(Nc != Expanding->thisnode)
         {
         TNc = (struct TheNodes *) (malloc(SzTN));
   if(TNc == NULL)
      {
      printf("allocation memory exhausted during network route planning (12)\n");
      exit(-1);
      }
         TNc->thisnode = Nc;
         TNc->comesfrom = Expanding;
         TNc->h = Distance(TNc->thisnode->x,TNc->thisnode->y,GoalPtr->x,GoalPtr->y);
         TNc->g = Expanding->g + Distance(TNc->comesfrom->thisnode->x,TNc->comesfrom->thisnode->y,Nc->x,Nc->y);
         TNc->f = TNc->g + TNc->h;
         TNc->next = NULL;
         if(Open == NULL)
            {
            Open = TNc;
            TNc->next = NULL;
            }
         else
            {
            TNp = TNc2 = Open;
            while(TNc2->f < TNc->f)
               {
               TNp = TNc2;
               TNc2 = TNc2->next;
               if(TNc2 == NULL)
                  break;
               }
            if(TNc2 == Open)
               {
               TNc->next = Open;
               Open = TNc;
               }
            else
               {
               TNc->next = TNp->next;
               TNp->next = TNc;
               }
            }
         }
      Cc = Cc->next;
      }

   while(Open != NULL)
      {
      Expanding = Open;
      Open = Open->next;
      if(Expanding->h < MinH)
         MinH = Expanding->h;
      if(Expanding->thisnode == GoalPtr)
         {
         printf("Identified route from %s to ",Coordinate2DtoString(StartPtr->x,StartPtr->y));
         printf("%s - total distance is %.2lf meters\n", Coordinate2DtoString(GoalPtr->x,GoalPtr->y),Expanding->g);
         sprintf(title,"Route length is %.2lf meters",Expanding->g);
         AbortRouting = route_time_update(2,title);
         TNc = Expanding;
         TNp = TNc->comesfrom;
         API_DRAW = 1;
         MySetLineThickness(5);
         while(TNp != NULL)
            {
            MAPdrawline(-1,TNp->thisnode->x, TNp->thisnode->y, TNc->thisnode->x, TNc->thisnode->y,2,DRAW_NOW);
            TNc = TNp;
            TNp = TNp->comesfrom;
            }
         API_DRAW = 0;
         MySetLineThickness(0);
         break;
         }
      else
         {
   index1 = (int) (Expanding->thisnode->x / RegionSize);
   index2 = (int) (Expanding->thisnode->y / RegionSize);
   cindex2 = (index1 * (MaxYindex + 1)) + index2;
   TNc = Buckets[cindex2].Closed;
   while(TNc != NULL)
      {
      if(TNc->thisnode == Expanding->thisnode)
         break;
      TNc = TNc->next;
      }
   if(TNc == NULL)
      {
      Expanding->next = Buckets[cindex2].Closed;
      Buckets[cindex2].Closed = Expanding;
      Cc = Expanding->thisnode->joins;
      while(Cc != NULL)
         {
         Nc = Cc->node;
         if(Nc != Expanding->thisnode)
            {
            TNc = (struct TheNodes *) (malloc(SzTN));
   if(TNc == NULL)
      {
      printf("allocation memory exhausted during network route planning (13)\n");
      exit(-1);
      }
            TNc->thisnode = Nc;
            TNc->comesfrom = Expanding;
            TNc->h = Distance(TNc->thisnode->x,TNc->thisnode->y,GoalPtr->x,GoalPtr->y);
            TNc->g = Expanding->g + Distance(TNc->thisnode->x,TNc->thisnode->y,Expanding->thisnode->x,Expanding->thisnode->y);
            if(IllustrateNetworkSolution > 0)
               {
               MAPdrawline(-1,TNc->thisnode->x, TNc->thisnode->y, Expanding->thisnode->x,Expanding->thisnode->y ,2,DRAW_NOW);
               for(ii=0; ii< NetworkLinkDrawDelay; ii++)
                 ;
               }
            TNc->f = TNc->g + TNc->h;
            TNc->next = NULL;

            ++TickerCount;
            if(TickerCount >= 0)
               {
               TickerCount = 0;

               sprintf(title,"%.2lf meters",MinH);
               AbortRouting = route_time_update(1,title);
               if(AbortRouting > 0)
                  {
                  TNc = Open;
                  while(TNc != NULL)
                     {
                     TNp = TNc;
                     TNc = TNc->next;
                     free(TNp);
                     }
                  for(i=0; i<listlength; i++)
                     {
                     TNc = Buckets[i].Closed;
                     while(TNc != NULL)
                        {
                        TNp = TNc;
                        TNc = TNc->next;
                        free(TNp);
                        }

                     Nc = Buckets[i].n;
                     while(Nc != NULL)
                        {
                        Np = Nc;
                        Cc = Np->joins;
                        while(Cc != NULL)
                           {
                           Cp = Cc;
                           Cc = Cc->next;
                           free(Cp);
                           }
                        Nc = Nc->next;
                        free(Np);
                        }
                     }
                  free(Buckets);
                  answer = -1;
                  return(answer);
                  }
               }
            AddNode = 1;
            index1 = (int) (TNc->thisnode->x / RegionSize);
            index2 = (int) (TNc->thisnode->y / RegionSize);
            cindex2 = (index1 * (MaxYindex + 1)) + index2;
            TNp = TNc2 = Buckets[cindex2].Closed;
            while(TNc2 != NULL)
               {
               if(TNc->thisnode == TNc2->thisnode)  /** node is already on the Closed list **/
                  {
                  if(TNc->g < TNc2->g)  // then want to keep new version and discard the old one
                     {
                     if(TNc2 == Buckets[cindex2].Closed)
                        Buckets[cindex2].Closed = Buckets[cindex2].Closed->next;
                     else
                        TNp->next = TNc2->next;
                     free(TNc2);
                     }
                  else  // want to discard the new version
                     {
                     AddNode = 0;
                     free(TNc);
                     }
                  break;
                  }
               TNp = TNc2;
               TNc2 = TNc2->next;
               }

            TNp = TNc2 = Open;
            while(TNc2 != NULL)
               {
               if(TNc->thisnode == TNc2->thisnode)  // node is already on the Open list
                  {
                  if(TNc->g < TNc2->g)  // then want to keep new version and discard the old one
                     {
                     if(TNc2 == Open)
                        Open = Open->next;
                     else
                        TNp->next = TNc2->next;
                     free(TNc2);
                     }
                  else  // want to discard the new version
                     {
                     AddNode = 0;
                     free(TNc);
                     }
                  break;
                  }
               TNp = TNc2;
               TNc2 = TNc2->next;
               }

            if(AddNode > 0)
               {
               if(Open == NULL)
                  {
                  Open = TNc;
                  TNc->next = NULL;
                  }
               else
                  {
                  TNp = TNc2 = Open;

                  while(TNc2->f < TNc->f)
                     {
                     TNp = TNc2;
                     TNc2 = TNc2->next;
                     if(TNc2 == NULL)
                        break;
                     }
                  if(TNc2 == Open)
                     {
                     TNc->next = Open;
                     Open = TNc;
                     }
                  else
                     {
                     TNc->next = TNp->next;
                     TNp->next = TNc;
                     }
                  }
               }
            }
         Cc = Cc->next;
         }
      }

         }
      }

   if(Open == NULL)
      {
      RouteProblem4 += 1;
      }

   TNc = Open;
   while(TNc != NULL)
      {
      TNp = TNc;
      TNc = TNc->next;
      free(TNp);
      }
   for(i=0; i<listlength; i++)
      {
      TNc = Buckets[i].Closed;
      while(TNc != NULL)
         {
         TNp = TNc;
         TNc = TNc->next;
         free(TNp);
         }

      Nc = Buckets[i].n;
      while(Nc != NULL)
         {
         Np = Nc;
         Cc = Np->joins;
         while(Cc != NULL)
            {
            Cp = Cc;
            Cc = Cc->next;
            free(Cp);
            }
         Nc = Nc->next;
         free(Np);
         }
      }
   free(Buckets);

   return(answer);
}


int ReadNetworkFileHeader(char * fname)
{
int i;
int NetTypeCount;
int checkdefinenumber;
int cnumber, count;
char title[1000];
int ttlnets;
FILE *filein;



   NetTypeCount = -1;

   filein = fopen(fname,"rb");
   if(filein != NULL)
      {
      SEEIT_fread_int(&NetTypeCount,filein);
      if(NetTypeCount > 0)
         {
         for(i=0; i<NetTypeCount; i++)
            {
            SEEIT_fread_int(&checkdefinenumber,filein);
            SEEIT_fread_int(&cnumber,filein);
            SEEIT_fread_int(&count,filein);
            fread(&title[0],1000,1,filein);
            }
         SEEIT_fread_int(&ttlnets,filein);
            
         }

      fclose(filein);
      }

   return(NetTypeCount);
}




int GetSubnetExtents(char * fname, int TgtCheck, int TgtCnumber, int TgtIndex, double *MinX, double *MinY, double *MaxX, double *MaxY)
{
int i;
int NetTypeCount;
int index, cnumber, count, definenumber;
int answer;
char title[1000];
int ttlnets;
double mix, miy, max,may;
int FCODE;
int NumFCODE, NumFeatures;
long int seekposn;
FILE *filein;


   NetTypeCount = -1;
   answer = -1;
   filein = fopen(fname,"rb");
   if(filein != NULL)
      {
      SEEIT_fread_int(&NetTypeCount,filein);
      if(NetTypeCount > 0)
         {
         for(i=0; i<NetTypeCount; i++)
            {
            SEEIT_fread_int(&definenumber,filein);
            SEEIT_fread_int(&cnumber,filein);
            SEEIT_fread_int(&count,filein);
            fread(&title[0],1000,1,filein);

            }
         SEEIT_fread_int(&ttlnets,filein);

         for(i=0; i<ttlnets; i++)
            {
            SEEIT_fread_int(&definenumber,filein);
            SEEIT_fread_int(&cnumber,filein);
            SEEIT_fread_int(&index,filein);
            SEEIT_fread_long(&seekposn,filein);
            if((definenumber == TgtCheck) && (cnumber == TgtCnumber) && (index == TgtIndex))
               break;
            }
         if(i >= ttlnets)
            answer = -1;
         else
            {
            fseek(filein,seekposn,SEEK_SET);
            SEEIT_fread_int(&definenumber,filein);
            SEEIT_fread_int(&cnumber,filein);
            SEEIT_fread_int(&index,filein);
            if((definenumber == TgtCheck) && (cnumber == TgtCnumber) && (index == TgtIndex))
               {
               answer = 1;
               SEEIT_fread_int(&NumFCODE,filein);
               SEEIT_fread_int(&FCODE,filein);
               SEEIT_fread_double(&mix,filein);
               SEEIT_fread_double(&miy,filein);
               SEEIT_fread_double(&max,filein);
               SEEIT_fread_double(&may,filein);
               SEEIT_fread_int(&NumFeatures,filein);
               *MinX = mix;
               *MinY = miy;
               *MaxX = max;
               *MaxY = may;
               }
            else
               {
               answer = -1;
               }
            }
         }

      fclose(filein);
      }

   return(answer);
}


void FreeNetworkNames(void)
{
int i;
   if(NetworkNames != NULL)
      {
      for(i=0; i<NetworkNameSize; i++)
         {
         if(NetworkNames[i] != NULL)
            free(NetworkNames[i]);
         }
   
      free(NetworkNames);
      }

   NetworkNameSize = 0;
   NetworkNames = NULL;
}



void GetSubnetName(char * fname, int TgtCheck, int TgtCnumber)
{
int i,ArraySize;
int NetTypeCount;
int index, cnumber, count, definenumber;
char title[1000];
int ttlnets;
double mix, miy, max,may;
int FCODE;
int NumFCODE, NumFeatures;
long int seekposn;
FILE *filein;
long int *sp;


   NetTypeCount = -1;
   strcpy(title,"Caption Not Available");
   filein = fopen(fname,"rb");
   ArraySize = -1;
   sp = NULL;
   if(filein != NULL)
      {
      SEEIT_fread_int(&NetTypeCount,filein);
      if(NetTypeCount > 0)
         {
         for(i=0; i<NetTypeCount; i++)
            {
            SEEIT_fread_int(&definenumber,filein);
            SEEIT_fread_int(&cnumber,filein);
            SEEIT_fread_int(&count,filein);
            if((definenumber == TgtCheck) && (cnumber == TgtCnumber))
               ArraySize = count;
            fread(&title[0],1000,1,filein);

            }
         SEEIT_fread_int(&ttlnets,filein);

         NetworkNames = (char **) (malloc(sizeof(char *) * ArraySize));
         NetworkNameSize = ArraySize;
         sp = (long int *) (malloc(sizeof(long int) * ArraySize));
         if(sp == NULL)
            {
            printf("all available meemory has been consumed during network analysis - exiting now!\n");
            exit(-1);
            }
         for(i=0; i<ArraySize; i++)
            {
            NetworkNames[i] = (char *) (malloc(200));
            sp[i] = -1;
            }

         for(i=0; i<ttlnets; i++)
            {
            SEEIT_fread_int(&definenumber,filein);
            SEEIT_fread_int(&cnumber,filein);
            SEEIT_fread_int(&index,filein);
            SEEIT_fread_long(&seekposn,filein);
            if((definenumber == TgtCheck) && (cnumber == TgtCnumber) /***&& (index == TgtIndex)**/ )
               {
               if((index > ArraySize) || (index < 1))
                  {
                  printf("fatal index misalignment in network name processing - exiting now!\n");
                  printf("index value %d index limit %d\n",index,ArraySize);
                  exit(-1);
                  }
               --index;
               if(sp[index] < 0)
                  sp[index] = seekposn;
               else
                  printf("indexing misalignment in network name processing\n");
               }
            }
         for(i=0; i<ArraySize; i++)
            {
            fseek(filein,sp[i],SEEK_SET);
            SEEIT_fread_int(&definenumber,filein);
            SEEIT_fread_int(&cnumber,filein);
            SEEIT_fread_int(&index,filein);
            if((definenumber == TgtCheck) && (cnumber == TgtCnumber) /**&& (index == TgtIndex)**/ )
               {
               SEEIT_fread_int(&NumFCODE,filein);
               SEEIT_fread_int(&FCODE,filein);
               SEEIT_fread_double(&mix,filein);
               SEEIT_fread_double(&miy,filein);
               SEEIT_fread_double(&max,filein);
               SEEIT_fread_double(&may,filein);
               SEEIT_fread_int(&NumFeatures,filein);
               if(NGA_TYPE == 1)
                  {
                  if(NumFCODE == 1)
                     {
                     if(NumFeatures == 1)
                        sprintf(title,"1 feature, %s (%s) feature type",GetECCCode(FCODE),GetECCLabel(FCODE));
                     else if(NumFeatures == 2)
                        sprintf(title,"2 features, both %s (%s) feature types",GetECCCode(FCODE),GetECCLabel(FCODE));
                     else
                        sprintf(title,"%d features, all %s (%s) features",NumFeatures,GetECCCode(FCODE),GetECCLabel(FCODE));
                     }
                  else
                     {
                     if(NumFCODE > 20)
                        sprintf(title,"%d features, includes %s (%s) and more than 20 other feature types",NumFeatures, 
                                            GetECCCode(FCODE),GetECCLabel(FCODE));
                     else if(NumFCODE == 2)
                        sprintf(title,"%d features, includes %s (%s) and 1 other feature type",NumFeatures, 
                                            GetECCCode(FCODE),GetECCLabel(FCODE));
                     else
                        sprintf(title,"%d features, includes %s (%s) and %d other feature types",NumFeatures, 
                                         GetECCCode(FCODE),GetECCLabel(FCODE), NumFCODE-1);
                     }
                  }
               else
                  {
                  if(NumFCODE == 1)
                     {
                     if(NumFeatures == 1)
                        sprintf(title,"1 feature, %s feature type",GetECCLabel(FCODE));
                     else if(NumFeatures == 2)
                        sprintf(title,"2 features, both %s feature types",GetECCLabel(FCODE));
                     else
                        sprintf(title,"%d features, all %s features",NumFeatures,GetECCLabel(FCODE));
                     }
                  else
                     {
                     if(NumFCODE > 20)
                        sprintf(title,"%d features, includes %s and more than 20 other feature types",NumFeatures,
                                            GetECCLabel(FCODE));
                     else if(NumFCODE == 2)
                        sprintf(title,"%d features, includes %s and 1 other feature type",NumFeatures,
                                            GetECCLabel(FCODE));
                     else
                        sprintf(title,"%d features, includes %s and %d other feature types",NumFeatures,
                                         GetECCLabel(FCODE), NumFCODE-1);
                     }
                  }
               }
            else
               {
               strcpy(title,"Caption Not Available");
               }
            title[198] = '\0';
            if((i >= 0) && (i < NetworkNameSize))
               strcpy(NetworkNames[i],title);
            else
               {
                  printf("fatal index misalignment in network name processing - exiting now!\n");
                  printf("index value %d index limit %d\n",i,NetworkNameSize);
                  exit(-1);
               }
            }
         if(sp != NULL)
            free(sp);
         }

      fclose(filein);
      }


   return;
}



/*************************************************************************************************************
int FindLengthLimitedPath(double fromx, double fromy, double fromz, double tgtx, double tgty, double tgtz,
                           double limit, double distsofar, int checkinstance)
{
struct CoordList *C;
struct NetworkNode *N;
struct CloseVertex *V;
int index1, index2, cindex;
double newdist;
double distcalc;
int answer;

   index1 = (int) (fromx / RegionSize);
   index2 = (int) (fromy / RegionSize);

   cindex = (index1 * (MaxYindex + 1)) + index2;

   answer = 0;

   if(BucketsOfNets[cindex].next == NULL)
      return(0);
   N = BucketsOfNets[cindex].next;
   while(N != NULL)
      {
      C = N->CL;
      while(C != NULL)
         {
         if(C->checkinstance == checkinstance)
            {
            if((C->x == fromx) && (C->y == fromy))
               {
               distcalc = 0;
               }
            else
               {
               distcalc =  Distance(C->x,C->y,fromx, fromy);
               }
            if(distcalc <= ActiveChecks[checkinstance].sensitivity)
               {
               V = C->sibling;
               while(V != NULL)
                  {
                  if((V->x == tgtx) && (V->y == tgty))
                     return(1);
                  else
                     {
                     newdist = V->distance + distsofar;
                     if(newdist < limit)
                        {
// add to (and then restore) distance value for cycle prevention - don't want to traverse the same link more than once 
                        V->distance += limit;
                        answer = FindLengthLimitedPath(V->x,V->y,V->z,tgtx,tgty,tgtz,limit,newdist,checkinstance);
                        V->distance -= limit;
                        }
                     }
                  if(answer < 1)
                     V = V->next;
                  else
                     return(answer);
                  }
               if(answer < 1)
                  {
                  V = C->neighbor;
                  while(V != NULL)
                     {
                     if((V->x == tgtx) && (V->y == tgty))
                        return(1);
                     else
                        {
                        newdist = V->distance + distsofar;
                        if(newdist < limit)
                           {
// add to (and then restore) distance value for cycle prevention - don't want to traverse the same link more than once 
                           V->distance += limit;
                           answer = FindLengthLimitedPath(V->x,V->y,V->z,tgtx,tgty,tgtz,limit,newdist,checkinstance);
                           V->distance -= limit;
                           }
                        }
                     if(answer < 1)
                        V = V->next;
                     else
                        return(answer);
                     }
                  }
               }
            }
         if(answer < 1)
            C = C->next;
         else
            return(answer);
         }
      if(answer < 1)
         N = N->next;
      else
         return(answer);
      }
   return(answer);
}
******************************************************************************************************/






void FreeAndWriteNetStructs(void)
{
int listlength;
int i,j,jj, Sindex;
int cloneindex;
int k,kk,kdefine;
int CountOfNets;
int NetTypeCount;
int NetCounter, SampleIndex;
int S_Count[25];
int S_Codes[25];
int nextfreeslot;
char nettypetitle[1000];
char portiondone[100];
long int indexstartposn;
FILE *networkout;

struct LookupInfo
   {
   int definenumber;
   int cnumber;
   int ordinal;
   int netnumber;
   long int fp;
   } * fparray;
struct NetTypeData
   {
   int checkinstance;
   int make_correct_index;
   int count;
   } * IndivdNTcounts;
struct diffnets
   {
   int number;
   int count;
   int numfcodes;
   int samplefcode;
   double mix, max, miy, may;
   struct LIDlist *features;
   struct diffnets * next;
   } *NetRootUnsorted, *NetRoot, *nc, *np, *nn, *nc2;
int Szdiff = sizeof(struct diffnets);

   NetRoot = NULL;
   NetRootUnsorted = NULL;
   CountOfNets = 0;
   NetTypeCount = 0;

   listlength = (MaxXindex + 1) * (MaxYindex + 1);


   sprintf(portiondone,"Network analysis: \n0.0%% complete\n");
   periodic_checking_redraw(0,"Network Analysis Progress",portiondone);

   for(i=0; i<listlength; i++)
      {
      sprintf(portiondone,"Network analysis:\n %.1lf%% complete\n",50.0 * ((double) i) / ((double) listlength));
      periodic_checking_redraw(0,"Network Analysis Progress",portiondone);
      if(BucketsOfNets[i].next != NULL)
         {
         NNc = BucketsOfNets[i].next;

         while(NNc != NULL)
            {
            if(NNc->lid != NULL)
               {
               if(NetRootUnsorted == NULL)
                  {
                  nc = (struct diffnets *) (malloc(Szdiff));
                  if(nc == NULL)
                     {
                     printf("memory has been exhausted during final network analysis\n");
                     exit(-1);
                     }
                  nc->number = NNc->netnumb;
                  nc->features = NNc->lid;
                  nc->count = 0;
                  nc->mix = nc->max = nc->miy = nc->may = 0;
                  CountOfNets += 1;
                  NetTypeCount += 1;
                  nc->next = NULL;
                  NetRootUnsorted = nc;
                  }
               else
                  {
                  nc = NetRootUnsorted;
                  while(nc != NULL)
                     {
                     if(nc->number == NNc->netnumb)
                        {
                        if(nc->features == NULL)
                           nc->features = NNc->lid;
                        else
                           {
                           LIDc = nc->features;
                           while(LIDc->next != NULL)
                              LIDc = LIDc->next;
                           LIDc->next = NNc->lid;
                           }
                        break;
                        }
                     nc = nc->next;
                     }

                  sprintf(portiondone,"Network analysis:\n %.1lf%% complete\n",50.0 * ((double) i) / ((double) listlength));
                  periodic_checking_redraw(0,"Network Analysis Progress",portiondone);

                  if(nc == NULL)
                     {
                     nn = (struct diffnets *) (malloc(Szdiff));
                     if(nn == NULL)
                        {
                        printf("memory has been exhausted during final network analysis\n");
                        exit(-1);
                        }
                     nn->number = NNc->netnumb;
                     nn->features = NNc->lid;
                     nn->count = 0;
                     nn->mix = nn->max = nn->miy = nn->may = 0;
                     CountOfNets += 1;
                     nc = np = NetRootUnsorted;
                     while(nn->features->checkinstance > nc->features->checkinstance)
                        {
                        np = nc;
                        nc = nc->next;
                        if(nc == NULL)
                           break;
                        }
                     if(nc == NetRootUnsorted)
                        {
                        nn->next = NetRootUnsorted;
                        NetRootUnsorted = nn;
                        if(nn->features->checkinstance != nc->features->checkinstance)
                           NetTypeCount += 1;
                        }
                     else
                        {
                        nn->next = nc;
                        np->next = nn;
                        if(nc == NULL)
                           NetTypeCount += 1;
                        else if(nn->features->checkinstance != nc->features->checkinstance)
                           NetTypeCount += 1;
                        }
                     }
                  }
                }
             NNc = NNc->next;
             }
          }
       }



   sprintf(portiondone,"Network analysis:\n %.1lf%% complete\n",50.0 * ((double) i) / ((double) listlength));
   periodic_checking_redraw(0,"Network Analysis Progress",portiondone);
   if(NetRootUnsorted != NULL)
      {
/** if intersection based, may have some features recorded more than once, so scrub them off now, before count features ***/
      if(INTERSECTION_BASED > 0)
         {
         nc = NetRootUnsorted;
         while(nc != NULL)
            {
            LIDp = LIDc = nc->features;
            while(LIDc != NULL)
               {
               LIDp = LIDc;
               LIDn = LIDc->next;
               while(LIDn != NULL)
                  {
                  if((LIDc->idn == LIDn->idn) && (LIDc->localid == LIDn->localid))
                     {
                     LIDp->next = LIDn->next;
                     free(LIDn);
                     LIDn = LIDp->next;
                     }
                  else
                     {
                     LIDp = LIDn;
                     LIDn = LIDn->next;
                     }
                  }
               LIDc = LIDc->next;
               }
            nc = nc->next;
            }
         }
      nc = NetRootUnsorted;
      while(nc != NULL)
         {
         k = 0;
         LIDc = nc->features;
         while(LIDc != NULL)
            {
            if((k == 0) || (LIDc->mix < nc->mix))  nc->mix = LIDc->mix;
            if((k == 0) || (LIDc->max > nc->max))  nc->max = LIDc->max;
            if((k == 0) || (LIDc->miy < nc->miy))  nc->miy = LIDc->miy;
            if((k == 0) || (LIDc->may > nc->may))  nc->may = LIDc->may;
            nc->count += 1;
            LIDc = LIDc->next;
            ++k;
            }
         nc = nc->next;
         }

/*** now want to sort the nets  ***/

      nc = NetRootUnsorted;
      while(nc != NULL)
         {
         NetRootUnsorted = nc->next;
         if(NetRoot == NULL)
            {
            NetRoot = nc;
            nc->next = NULL;
            }
         else
            {
            np = nc2 = NetRoot;
            while(nc->features->checkinstance > nc2->features->checkinstance)
               {
               np = nc2;
               nc2 = nc2->next;
               if(nc2 == NULL)
                  break;
               }
   
            if((nc2 != NULL) && (nc->features->checkinstance == nc2->features->checkinstance))
               {
               while(nc->features->checkinstance == nc2->features->checkinstance)
                  {
                  if(nc2->count > nc->count)
                     break;
                  np = nc2;
                  nc2 = nc2->next;
                  if(nc2 == NULL)
                     break;      
                  }
               }
   
            if(nc2 == NetRoot)
               {
               nc->next = NetRoot;
               NetRoot = nc;
               }
            else
               {
               nc->next = nc2;
               np->next = nc;
               }
            }
         nc = NetRootUnsorted;
         }
      } 



if(NetTypeCount > 0)
   {
   nc = NetRoot;
   while(nc != NULL)
      {
      if((NetFeatureMin == 101) || (nc->count <= NetFeatureMin))
         {
         if((nc->mix <= (MinXcoord + 0.1)) || (nc->miy <= (MinYcoord + 0.1)) ||
               (nc->max >= (MaxXcoord - 0.1)) || (nc->may >= (MaxYcoord - 0.1)))
            {
         /*** then discard this network as small net touching the boundary ***/
            nc->count = -1;

            }
         }
      nc = nc->next;
      }
   }

   if(NetTypeCount > 0)
      {
      IndivdNTcounts = (struct NetTypeData *) (malloc(sizeof(struct NetTypeData) * NetTypeCount));
      if(IndivdNTcounts == NULL)
         {
         printf("all available memory has been consumed during network analysis - exiting now\n");
         exit(-1);
         }
      }
   else
      IndivdNTcounts = NULL;

   for(k=0; k<NetTypeCount; k++)
      {
      IndivdNTcounts[k].checkinstance = -1;

      IndivdNTcounts[k].count = 0;
      }
   nextfreeslot = 0;

   nc = NetRoot;
   while(nc != NULL)
      {
      for(jj=0; jj<nextfreeslot; jj++)
         {
         if(IndivdNTcounts[jj].checkinstance == nc->features->checkinstance)
            {
            if(nc->count > 0)
               IndivdNTcounts[jj].count += 1;
            break;
            }
         }
      if(jj >= nextfreeslot)
         {
         if(nextfreeslot >= NetTypeCount)
            {
            printf("serious array index misalignment during network analysis - exiting now!\n");
            exit(-1);
            }
         IndivdNTcounts[nextfreeslot].checkinstance = nc->features->checkinstance;
         IndivdNTcounts[nextfreeslot].make_correct_index = (Make_Correct(ActiveChecks[nc->features->checkinstance].number,
                                                                         nc->features->checkinstance));
         if(nc->count > 0)
            IndivdNTcounts[nextfreeslot].count = 1;
         else
            IndivdNTcounts[nextfreeslot].count = 0;
         nextfreeslot += 1;
         }
      for(k=0; k<25; k++)
         {
         S_Codes[k] = -10;
         S_Count[k] = 0;
         }

      LIDc = nc->features;
      while(LIDc != NULL)
         {
         Sindex = CrsWlk[LIDc->Lindex].LtoSmapping;
         for(j=0; j<25; j++)
            {
            if((S_Codes[j] == SCCtable[Sindex].ECC) || (S_Codes[j] < -5))
               {
               S_Codes[j] = SCCtable[Sindex].ECC;
               S_Count[j] += 1;
               break;
               }
            }
         LIDc = LIDc->next;
         }
      NetCounter = -1;
      SampleIndex = 0;
      for(j=0; j<25; j++)
         {
         if(S_Codes[j] < -5)
            break;
         if(S_Count[j] > NetCounter)
            {
            SampleIndex = j;
            NetCounter = S_Count[j];
            }
         }
      nc->numfcodes = j;
      nc->samplefcode = S_Codes[SampleIndex];

      nc = nc->next;
      }

   fparray = (struct LookupInfo *) (malloc(sizeof(struct LookupInfo) * CountOfNets));
   if(fparray == NULL)
      {
      printf("memory has been exhausted during network analysis - must terminate now\n");
      exit(-1);
      }
   for(k=0; k<CountOfNets; k++)
      {
      fparray[k].definenumber = 0;
      fparray[k].cnumber = 0;
      fparray[k].ordinal = k;
      fparray[k].netnumber = -1;
      fparray[k].fp = 0;
      }

   networkout = fopen(networksfound,"wb+");
   if(NetTypeCount > 0)
      {
      SEEIT_fwrite_int(&NetTypeCount,networkout);
      for(jj=0; jj<NetTypeCount; jj++)
         {
         SEEIT_fwrite_int(&ActiveChecks[IndivdNTcounts[jj].checkinstance].number,networkout); /** check define number  ***/
         SEEIT_fwrite_int(&IndivdNTcounts[jj].make_correct_index,networkout);
         SEEIT_fwrite_int(&IndivdNTcounts[jj].count,networkout);
         for(k=0; k<1000; k++)
            nettypetitle[k] = '\0';
         
         if(IndivdNTcounts[jj].make_correct_index == 0)
            {
            if(ErrorLookup[ActiveChecks[IndivdNTcounts[jj].checkinstance].number].Annotation == NULL)
               strcpy(nettypetitle,"No Annotation Entered");
            else
               strcpy(nettypetitle,ErrorLookup[ActiveChecks[IndivdNTcounts[jj].checkinstance].number].Annotation);
            }
         else
            {
            cloneindex = GetCloneIndex(IndivdNTcounts[jj].make_correct_index,ActiveChecks[IndivdNTcounts[jj].checkinstance].number);
            if(CloneErrorLookup[cloneindex].Annotation == NULL)
               strcpy(nettypetitle,"No Annotation Entered");
            else
               strcpy(nettypetitle,CloneErrorLookup[cloneindex].Annotation);
            }
         fwrite(&nettypetitle[0],1000,1,networkout);
         }

      SEEIT_fwrite_int(&CountOfNets,networkout);

      indexstartposn = ftell(networkout);

      for(k=0; k<CountOfNets; k++)
         {
         SEEIT_fwrite_int(&fparray[k].definenumber,networkout);
         SEEIT_fwrite_int(&fparray[k].cnumber,networkout);
         SEEIT_fwrite_int(&fparray[k].ordinal,networkout);
         SEEIT_fwrite_long(&fparray[k].fp,networkout);
         }

      nc = NetRoot;
      nextfreeslot = 0;
      NetCounter = -1;
      jj = -1;
      k = 0;
      while(nc != NULL)
         {
      if(nc-> count > 0)
         {
         if(nc->features->checkinstance != jj)
            {
            nextfreeslot = 0;
            while(IndivdNTcounts[nextfreeslot].checkinstance != nc->features->checkinstance)
               ++nextfreeslot;
            jj = IndivdNTcounts[nextfreeslot].checkinstance;
            kk = Make_Correct(ActiveChecks[IndivdNTcounts[nextfreeslot].checkinstance].number,IndivdNTcounts[nextfreeslot].checkinstance);
            kdefine = ActiveChecks[IndivdNTcounts[nextfreeslot].checkinstance].number;
            NetCounter = 1;
            }
         if(k >= CountOfNets)
            {
            printf("Count of Nets index mis-alignment - fatal error exiting now\n");
            exit(-1);
            }
         fparray[k].definenumber = kdefine;
         fparray[k].cnumber = kk;
         fparray[k].ordinal = NetCounter;
         fparray[k].netnumber = nc->number;
         fparray[k].fp = ftell(networkout);

         SEEIT_fwrite_int(&kdefine,networkout);
         SEEIT_fwrite_int(&kk,networkout);
         SEEIT_fwrite_int(&NetCounter,networkout);
         SEEIT_fwrite_int(&nc->numfcodes,networkout);
         SEEIT_fwrite_int(&nc->samplefcode,networkout);
         SEEIT_fwrite_double(&nc->mix,networkout);
         SEEIT_fwrite_double(&nc->miy,networkout);
         SEEIT_fwrite_double(&nc->max,networkout);
         SEEIT_fwrite_double(&nc->may,networkout);
         SEEIT_fwrite_int(&nc->count,networkout);
         LIDc = nc->features;
         while(LIDc != NULL)
            {
            fwrite(&LIDc->geom,1,1,networkout);
            SEEIT_fwrite_double(&LIDc->localid,networkout);
            LIDc = LIDc->next;
            }
         NetCounter += 1;
         ++k;
         }

         nc = nc->next;
         }

      fseek(networkout,indexstartposn,SEEK_SET);
      for(k=0; k<CountOfNets; k++)
         {
         SEEIT_fwrite_int(&fparray[k].definenumber,networkout);
         SEEIT_fwrite_int(&fparray[k].cnumber,networkout);
         SEEIT_fwrite_int(&fparray[k].ordinal,networkout);
         SEEIT_fwrite_long(&fparray[k].fp,networkout);
         }
      }
   else
      {
      NetTypeCount = 0;
      SEEIT_fwrite_int(&NetTypeCount,networkout);
      }


   fclose(networkout);



/*******
printf("Distinct networks assembled: %d different types %d\n",CountOfNets, NetTypeCount);
for(k=0; k<NetTypeCount; k++)
   {
   printf("net type %d (%d) includes %d nets ",k,IndivdNTcounts[k].checkinstance, IndivdNTcounts[k].count);
   if(IndivdNTcounts[k].make_correct_index == 0)
      printf("%s\n",ErrorLookup[EXTRA_NET].Annotation);
   else
      printf("%s\n",CloneErrorLookup[IndivdNTcounts[k].make_correct_index-1].Annotation);
   }
*************/

   nc = NetRoot;
   while(nc != NULL)
      {
      np = nc;

      LIDc = nc->features;
      while(LIDc != NULL)
         {
         LIDp = LIDc;
         LIDc = LIDc->next;
         free(LIDp);
         }

      nc = nc->next;
      free(np);
      }

   for(i=0; i<listlength; i++)
      {
      if(BucketsOfNets[i].next != NULL)
         {
         NNc = BucketsOfNets[i].next;
         while(NNc != NULL)
            {
            NNn = NNc;
            NNc = NNc->next;
            CLc = NNn->CL;
            while(CLc != NULL)
               {
               CLn = CLc;
               CLc = CLc->next;
               free(CLn);
               }
            free(NNn);
            }
         }
      BucketsOfNets[i].netnumb = -1;
      BucketsOfNets[i].CL = NULL;
      BucketsOfNets[i].next = NULL;
      }


   if(fparray != NULL)
      free(fparray);
   if(IndivdNTcounts != NULL)
      free(IndivdNTcounts);
   NewNetNumber = 0;
}






void AddEdgesToNetwork(struct RawLinear *Lroot, struct RawAreal *Aroot, struct RawPoint *Proot, int compositeindex, int checkinstance,
                        double MIX, double MIY, double MAX, double MAY)
{
int cindex;
int i,j,jj,maxindex, checkapplies,i_previous,i_next;
int part1, part2, part3;
int index1, index2;
int nettouse,listlength;
int InCREATENET;
struct RawLinear *rlc;
struct RawAreal *rac;
struct RawPoint *rpc;
int *foundnets;
int *BucketIndices;
int SzNN = sizeof(struct NetworkNode);
int SzCL = sizeof(struct CoordList);
int SzLID = sizeof(struct LIDlist);
double mix, miy, max, may;
double NodeToNodeDist;
   listlength = (MaxXindex + 1) * (MaxYindex + 1);
   maxindex = 100;
   BucketIndices = (int *) (malloc(SzI * maxindex));
   foundnets = (int *) (malloc(SzI * maxindex));
   if(foundnets == NULL) 
      {
      printf("all memory has been allocated - exiting now!\n");
      exit(-1);
      }

   InCREATENET = 0;
   rpc = Proot;
   while(rpc != NULL)
      {
      checkapplies = -1;
      InCREATENET = 0;
      if(rpc->numverts == -1) /*** only looking at pure points, NGA-style ***/
         {
         checkapplies = CombinedCheckApplies(rpc->idn,checkinstance,EXTRA_NET,rpc->Lindex,rpc->Sindex,
                                          SCCtable[rpc->Sindex].C, SCCtable[rpc->Sindex].S, SCCtable[rpc->Sindex].D,
                                          &part1, &part2, &part3);
         if(checkapplies <= 0)
            checkapplies = CombinedCheckApplies(rpc->idn,checkinstance,INTRA_NET,rpc->Lindex,rpc->Sindex,
                                          SCCtable[rpc->Sindex].C, SCCtable[rpc->Sindex].S, SCCtable[rpc->Sindex].D,
                                          &part1, &part2, &part3);

         if(checkapplies <= 0)
            {
            checkapplies = CombinedCheckApplies(rpc->idn,checkinstance,CREATENET,rpc->Lindex,rpc->Sindex,
                                          SCCtable[rpc->Sindex].C, SCCtable[rpc->Sindex].S, SCCtable[rpc->Sindex].D,
                                          &part1, &part2, &part3);
            if(checkapplies > 0)
               InCREATENET = 1;
            }
         }

      if(checkapplies > 0)
         {
         LIDc = (struct LIDlist *) (malloc(SzLID));
         if(LIDc == NULL)
            {
            printf("all memory has been consumed while adding feature identifcations to assembled networks\n");
            printf("terminating now\n");
            exit(-1);
            }


         foundnets[0] = -1;
         nettouse = -1;

         for(i=0; i<1; i++)
            {
            index1 = (int) (rpc->x[i] / RegionSize);
            index2 = (int) (rpc->y[i] / RegionSize);

            cindex = (index1 * (MaxYindex + 1)) + index2;
            BucketIndices[i] = cindex;

            if(BucketsOfNets[cindex].next == NULL) /*** start off the net stucture in this bucket **/
               {
               NewNetNumber += 1;
               nettouse = NewNetNumber;
               foundnets[i] = nettouse;

               NNc = (struct NetworkNode *) (malloc(SzNN));
               if(NNc == NULL)
                  {
                  printf("all memory has been allocated - exiting now!\n");
                  exit(-1);
                  }
               NNc->next = NULL;
               NNc->lid = NULL;
               NNc->netnumb = nettouse;
               NNc->CL = NULL;
               BucketsOfNets[cindex].next = NNc;

               CLc = (struct CoordList *) (malloc(SzCL));
               if(CLc == NULL)
                  {
                  printf("all memory has been allocated - exiting now!\n");
                  exit(-1);
                  }
               CLc->x = rpc->x[i];
               CLc->y = rpc->y[i];
               CLc->z = rpc->z[i];
                
               CLc->lid = LIDc;
               CLc->checkinstance = checkinstance;
               CLc->next = NNc->CL;
               NNc->CL = CLc;
               }
            else
               {
               NNc = BucketsOfNets[cindex].next;
               while(NNc != NULL)
                  {
                  CLc = NNc->CL;
                  while(CLc != NULL)
                     {
                     if(CLc->checkinstance == checkinstance)
                        NodeToNodeDist = Distance(CLc->x,CLc->y,rpc->x[i],rpc->y[i]);
                     else
                        NodeToNodeDist = ActiveChecks[checkinstance].sensitivity * 100 + 100;

                     if(NodeToNodeDist <= ActiveChecks[checkinstance].sensitivity)
                        {
                        if(foundnets[i] >= 0)  /** already put this node into a network somewhere - join nets ***/
                           {
                           for(jj=0; jj<listlength; jj++)
                              {
                              NNt = BucketsOfNets[jj].next;
                              while(NNt != NULL)
                                 {
                                 if(NNt->netnumb == foundnets[i])
                                    {
                                    NNt->netnumb = NNc->netnumb;
                                    }
                                 NNt = NNt->next;
                                 }
                              }
                           }
                        foundnets[i] = NNc->netnumb;
                        if(nettouse < 0)
                           nettouse = NNc->netnumb;


                        break;
                        }
                     CLc = CLc->next;
                     }
                  NNc = NNc->next;
                  }
               }
            }
         if(nettouse < 0) /*** add nodes with a new net number of NewNetNumber + 1 ***/
            {
            NewNetNumber += 1;
            nettouse = NewNetNumber;
            }
         for(i=0; i<1; i++)
            {
            if(foundnets[i] < 0) /** means there is no connection to this node ***/
               {
               foundnets[i] = nettouse;
               cindex = BucketIndices[i];

               BucketIndices[i] = cindex;
               NNc = BucketsOfNets[cindex].next;
               while(NNc != NULL)
                  {
                  if(NNc->netnumb == nettouse)
                     break;
                  NNc = NNc->next;
                  }
               if(NNc == NULL) /*** have to add a new network ***/
                  {
                  NNc = (struct NetworkNode *) (malloc(SzNN));
                  if(NNc == NULL)
                     {
                     printf("all memory has been allocated - exiting now!\n");
                     exit(-1);
                     }
                  NNc->next = BucketsOfNets[cindex].next;
                  NNc->netnumb = nettouse;
                  NNc->lid = NULL;
                  NNc->CL = NULL;
                  BucketsOfNets[cindex].next = NNc;
                  }

               CLc = (struct CoordList *) (malloc(SzCL));
               if(CLc == NULL)
                  {
                  printf("all memory has been allocated - exiting now!\n");
                  exit(-1);
                  }
               CLc->x = rpc->x[i];
               CLc->y = rpc->y[i];
               CLc->z = rpc->z[i];
               CLc->lid = LIDc;
               CLc->checkinstance = checkinstance;
               CLc->next = NNc->CL;
               NNc->CL = CLc;
               }
            }

         /*** set feature extents and see if we have to merge nets by reassigning net numbers ****/
         mix = max = rpc->x[0];
         miy = may = rpc->y[0];
         for(i=0; i<1; i++)
            {
            if(rpc->x[i] > max)  max = rpc->x[i];
            if(rpc->x[i] < mix)  mix = rpc->x[i];
            if(rpc->y[i] > may)  may = rpc->y[i];
            if(rpc->y[i] < miy)  miy = rpc->y[i];

            if(foundnets[i] != nettouse)
               {
               for(j=0; j<listlength; j++)
                  {
                  NNc = BucketsOfNets[j].next;
                  while(NNc != NULL)
                     {
                     if(NNc->netnumb == foundnets[i])
                        {
                        NNc->netnumb = nettouse;
                        }
                     NNc = NNc->next;
                     }
                  }
               }
            }
         NNc = BucketsOfNets[BucketIndices[0]].next;
         while(NNc != NULL)
            {
            if(NNc->netnumb == nettouse)
               {
               LIDc->localid = rpc->localID;
               LIDc->Lindex = rpc->Lindex;
               LIDc->idn = rpc->idn;
               LIDc->checkinstance = checkinstance;
               LIDc->geom = (char) (G_POINT);

               LIDc->mix = mix;
               LIDc->max = max;
               LIDc->miy = miy;
               LIDc->may = may;

               LIDc->next = NNc->lid;
               NNc->lid = LIDc;
               break;
               }
            NNc = NNc->next;
            }
         if(NNc == NULL)
            {
            printf("fatal error in assigning feaure id to network - terminating now\n");
            exit(-1);
            }
         }
      rpc = rpc->next;
      }


   rlc = Lroot;
   while(rlc != NULL)
      {
      InCREATENET = 0;

      if(rlc->firstencounter == 1)
         {
         checkapplies = CombinedCheckApplies(rlc->idn,checkinstance,EXTRA_NET,rlc->Lindex,rlc->Sindex,
                                          SCCtable[rlc->Sindex].C, SCCtable[rlc->Sindex].S, SCCtable[rlc->Sindex].D,
                                          &part1, &part2, &part3);
         if(checkapplies <= 0)
            checkapplies = CombinedCheckApplies(rlc->idn,checkinstance,INTRA_NET,rlc->Lindex,rlc->Sindex,
                                          SCCtable[rlc->Sindex].C, SCCtable[rlc->Sindex].S, SCCtable[rlc->Sindex].D,
                                          &part1, &part2, &part3);

         if(checkapplies <= 0)
            {
            checkapplies = CombinedCheckApplies(rlc->idn,checkinstance,CREATENET,rlc->Lindex,rlc->Sindex,
                                          SCCtable[rlc->Sindex].C, SCCtable[rlc->Sindex].S, SCCtable[rlc->Sindex].D,
                                          &part1, &part2, &part3);
            if(checkapplies > 0)
               InCREATENET = 1;
            }
         }
      else
         {
         checkapplies = -1;
         }

      if(checkapplies > 0)
         {
         LIDc = (struct LIDlist *) (malloc(SzLID));
         if(LIDc == NULL)
            {
            printf("all memory has been consumed while adding feature identifcations to assembled networks\n");
            printf("terminating now\n");
            exit(-1);
            }
               LIDc->localid = rlc->localID;
               LIDc->Lindex = rlc->Lindex;
               LIDc->idn = rlc->idn;
               LIDc->checkinstance = checkinstance;
               LIDc->geom = (char) (G_LINE);

         if(rlc->numnodes > maxindex)
            {
            BucketIndices = (int *) (realloc(BucketIndices,SzI * rlc->numnodes));
            foundnets = (int *) (realloc(foundnets,SzI * rlc->numnodes));
            maxindex = rlc->numnodes;
            if(foundnets == NULL)
               {
               printf("all memory has been allocated - exiting now!\n");
               exit(-1);
               }
            }
         for(i=0; i<rlc->numnodes; i++)
            {
            foundnets[i] = -1;
            }
         nettouse = -1;

         for(i=0; i<rlc->numnodes; i++)
            {
            j = i + 1;

            foundnets[i] = -1;
            index1 = (int) (rlc->x[i] / RegionSize);
            index2 = (int) (rlc->y[i] / RegionSize);

            cindex = (index1 * (MaxYindex + 1)) + index2;
            BucketIndices[i] = cindex;

            if(BucketsOfNets[cindex].next == NULL) /*** start off the net stucture in this bucket **/
               {
               NewNetNumber += 1;
               nettouse = NewNetNumber;
               foundnets[i] = nettouse;

               NNc = (struct NetworkNode *) (malloc(SzNN));
               if(NNc == NULL)
                  {
                  printf("all memory has been allocated - exiting now!\n");
                  exit(-1);
                  }
               NNc->next = NULL;
               NNc->lid = NULL;
               NNc->netnumb = nettouse;
               NNc->CL = NULL;
               BucketsOfNets[cindex].next = NNc;

               CLc = (struct CoordList *) (malloc(SzCL));
               if(CLc == NULL)
                  {
                  printf("all memory has been allocated - exiting now!\n");
                  exit(-1);
                  }
               CLc->x = rlc->x[i];
               CLc->y = rlc->y[i];
               CLc->z = rlc->z[i];
               CLc->lid = LIDc;
               CLc->checkinstance = checkinstance;
               CLc->next = NNc->CL;
               NNc->CL = CLc;
               }
            else
               {
               NNc = BucketsOfNets[cindex].next;
               while(NNc != NULL)
                  {
                  CLc = NNc->CL;
/**** see if the rlc vertex at index i matches with a previously stored index from another feature in the network ***/
                  while(CLc != NULL)
                     {
                     if(CLc->checkinstance == checkinstance)
                        NodeToNodeDist = Distance(CLc->x,CLc->y,rlc->x[i],rlc->y[i]);
                     else
                        NodeToNodeDist = ActiveChecks[checkinstance].sensitivity + 100;

                     if(NodeToNodeDist <= ActiveChecks[checkinstance].sensitivity)
                        {
                        if(foundnets[i] >= 0)  /** already put this node into a network somewhere - join nets ***/
                           {
                           for(jj=0; jj<listlength; jj++)
                              {
                              NNt = BucketsOfNets[jj].next;
                              while(NNt != NULL)
                                 {
                                 if(NNt->netnumb == foundnets[i])
                                    {
                                    NNt->netnumb = NNc->netnumb;
                                    }
                                 NNt = NNt->next;
                                 }
                              }
                           }
                        foundnets[i] = NNc->netnumb;
                        if(nettouse < 0)
                           nettouse = NNc->netnumb;
      
                        break;
                        }
                     CLc = CLc->next;
                     }
                  NNc = NNc->next;
                  }
               }
            }
         if(nettouse < 0) /*** add nodes with a new net number of NewNetNumber + 1 ***/
            {
            NewNetNumber += 1;
            nettouse = NewNetNumber;
            }
         for(i=0; i<rlc->numnodes; i++)
            {
            j = i + 1;

            if(foundnets[i] < 0) /** means there is no connection to this node ***/
               {
               foundnets[i] = nettouse;
               cindex = BucketIndices[i];

            BucketIndices[i] = cindex;
               NNc = BucketsOfNets[cindex].next;
               while(NNc != NULL)
                  {
                  if(NNc->netnumb == nettouse)
                     break;
                  NNc = NNc->next;
                  }
               if(NNc == NULL)
                  {
                  NNc = (struct NetworkNode *) (malloc(SzNN));
                  if(NNc == NULL)
                     {
                     printf("all memory has been allocated - exiting now!\n");
                     exit(-1);
                     }
                  NNc->next = BucketsOfNets[cindex].next;
                  NNc->netnumb = nettouse;
                  NNc->lid = NULL;
                  NNc->CL = NULL;
                  BucketsOfNets[cindex].next = NNc;
                  }

               CLc = (struct CoordList *) (malloc(SzCL));
               if(CLc == NULL)
                  {
                  printf("all memory has been allocated - exiting now!\n");
                  exit(-1);
                  }
               CLc->x = rlc->x[i];
               CLc->y = rlc->y[i];
               CLc->z = rlc->z[i];
               CLc->lid = LIDc;
               CLc->checkinstance = checkinstance;
               CLc->next = NNc->CL;
               NNc->CL = CLc;
               }
            }

         mix = max = rlc->x[0];
         miy = may = rlc->y[0];
         for(i=0; i<rlc->numnodes; i++)
            {
            if(rlc->x[i] > max)  max = rlc->x[i];
            if(rlc->x[i] < mix)  mix = rlc->x[i];
            if(rlc->y[i] > may)  may = rlc->y[i];
            if(rlc->y[i] < miy)  miy = rlc->y[i];

            if(foundnets[i] != nettouse) /** means this node exists in another network - need to change it ***/
               {
               for(j=0; j<listlength; j++)
                  {
                  NNc = BucketsOfNets[j].next;
                  while(NNc != NULL) 
                     {
                     if(NNc->netnumb == foundnets[i])
                        {
                        NNc->netnumb = nettouse;
                        }
                     NNc = NNc->next;
                     }
                  }
               }
            }
         NNc = BucketsOfNets[BucketIndices[0]].next;
         while(NNc != NULL)
            {
            if(NNc->netnumb == nettouse)
               {
               LIDc->mix = mix;
               LIDc->max = max;
               LIDc->miy = miy;
               LIDc->may = may;
               LIDc->next = NNc->lid;
               NNc->lid = LIDc;
               break;
               }
            NNc = NNc->next;
            }
         if(NNc == NULL)
            {
            printf("fatal error in assigning feaure id to network - terminating now\n");
            exit(-1);
            }
         }
      rlc = rlc->next;
      }

   rac = Aroot;
   while(rac != NULL)
      {
      InCREATENET = 0;
      if((rac->firstindex == compositeindex) || (rac->firstindex < -90))
         {
         checkapplies = CombinedCheckApplies(rac->idn,checkinstance,EXTRA_NET,rac->Lindex,rac->Sindex,
                                          SCCtable[rac->Sindex].C, SCCtable[rac->Sindex].S, SCCtable[rac->Sindex].D,
                                          &part1, &part2, &part3);
         if(checkapplies <= 0)
            checkapplies = CombinedCheckApplies(rac->idn,checkinstance,INTRA_NET,rac->Lindex,rac->Sindex,
                                          SCCtable[rac->Sindex].C, SCCtable[rac->Sindex].S, SCCtable[rac->Sindex].D,
                                          &part1, &part2, &part3);

         if(checkapplies <= 0)
            {
            checkapplies = CombinedCheckApplies(rac->idn,checkinstance,CREATENET,rac->Lindex,rac->Sindex,
                                          SCCtable[rac->Sindex].C, SCCtable[rac->Sindex].S, SCCtable[rac->Sindex].D,
                                          &part1, &part2, &part3);
            if(checkapplies > 0)
               InCREATENET = 1;
            }
         }
      else
         {
         checkapplies = -1;
         }

      if(checkapplies > 0) 
         {
         if(rac->numverts > maxindex)
            {
            BucketIndices = (int *) (realloc(BucketIndices,SzI * rac->numverts));
            foundnets = (int *) (realloc(foundnets,SzI * rac->numverts));
            maxindex = rac->numverts;
            if(foundnets == NULL)
               {
               printf("all memory has been allocated - exiting now!\n");
               exit(-1);
               }
            }
         LIDc = (struct LIDlist *) (malloc(SzLID));
         if(LIDc == NULL)
            {
            printf("all memory has been consumed while adding feature identifcations to assembled networks\n");
            printf("terminating now\n");
            exit(-1);
            }

         for(i=0; i<rac->numverts; i++)
            {
            foundnets[i] = -1;
            }


         nettouse = -1;
         for(i=0; i<rac->numverts; i++)
            {
            i_next = i + 1;
            if(i_next >= rac->numverts)
               i_next = 0;
   
            if(i == 0)
               i_previous = rac->numverts - 1;
            else
               i_previous = i - 1;

            foundnets[i] = -1;
            index1 = (int) (rac->x[i] / RegionSize);
            index2 = (int) (rac->y[i] / RegionSize);

            cindex = (index1 * (MaxYindex + 1)) + index2;
            BucketIndices[i] = cindex;

            if(BucketsOfNets[cindex].next == NULL) /*** then need to start off the net stucture in this bucket **/
               {
               NewNetNumber += 1;
               nettouse = NewNetNumber;
               foundnets[i] = nettouse;

               NNc = (struct NetworkNode *) (malloc(SzNN));
               if(NNc == NULL)
                  {
                  printf("all memory has been allocated - exiting now!\n");
                  exit(-1);
                  }
               NNc->next = NULL;
               NNc->netnumb = nettouse;
               NNc->lid = NULL;
               NNc->CL = NULL;
               BucketsOfNets[cindex].next = NNc;

               CLc = (struct CoordList *) (malloc(SzCL));
               if(CLc == NULL)
                  {
                  printf("all memory has been allocated - exiting now!\n");
                  exit(-1);
                  }
               CLc->x = rac->x[i];
               CLc->y = rac->y[i];
               CLc->z = rac->z[i];
               /**CLc->potential = NULL;**/
               CLc->lid = LIDc;
               CLc->checkinstance = checkinstance;
               CLc->next = NNc->CL;
               NNc->CL = CLc;
               }
            else
               {
               NNc = BucketsOfNets[cindex].next;
               while(NNc != NULL)
                  {
                  CLc = NNc->CL;
/**** see if the rac vertex at index i matches with a previously stored index from another feature in the network ***/
                  while(CLc != NULL)
                     {
                     if(CLc->checkinstance == checkinstance)
                        NodeToNodeDist = Distance(CLc->x,CLc->y,rac->x[i],rac->y[i]);
                     else
                        NodeToNodeDist = ActiveChecks[checkinstance].sensitivity * 100 + 100;
                     if(NodeToNodeDist <= ActiveChecks[checkinstance].sensitivity)
                        {
                        if(foundnets[i] >= 0)  /** already put this node into a network somewhere - join nets ***/
                           {
                           for(jj=0; jj<listlength; jj++)
                              {
                              NNt = BucketsOfNets[jj].next;
                              while(NNt != NULL)
                                 {
                                 if(NNt->netnumb == foundnets[i])
                                    {
                                    NNt->netnumb = NNc->netnumb;
                                    }
                                 NNt = NNt->next;
                                 }
                              }
                           }
                        foundnets[i] = NNc->netnumb;
                        if(nettouse < 0)
                           nettouse = NNc->netnumb;
                        break;
                        }
                     CLc = CLc->next;
                     }
                  NNc = NNc->next;
                  }
               }
            }

         if(nettouse < 0) /*** add nodes with a new net number of NewNetNumber + 1 ***/
            {
            NewNetNumber += 1;
            nettouse = NewNetNumber;
            }

         for(i=0; i<rac->numverts; i++)
            {
            i_next = i + 1;
            if(i_next >= rac->numverts)
               i_next = 0;

            if(i == 0)
               i_previous = rac->numverts - 1;
            else
               i_previous = i - 1;


            if(foundnets[i] < 0) /** means there is no connection to this node ***/
               {
               foundnets[i] = nettouse;
               cindex = BucketIndices[i];

               NNc = BucketsOfNets[cindex].next;
               while(NNc != NULL)
                  {
                  if(NNc->netnumb == nettouse)
                     break;
                  NNc = NNc->next;
                  }
               if(NNc == NULL) /*** have to add a new network ***/
                  {
                  NNc = (struct NetworkNode *) (malloc(SzNN));
                  if(NNc == NULL)
                     {
                     printf("all memory has been allocated - exiting now!\n");
                     exit(-1);
                     }
                  NNc->next = BucketsOfNets[cindex].next;
                  NNc->lid = NULL;
                  NNc->netnumb = nettouse;
                  NNc->CL = NULL;
                  BucketsOfNets[cindex].next = NNc;
                  }

               CLc = (struct CoordList *) (malloc(SzCL));
               if(CLc == NULL)
                  {
                  printf("all memory has been allocated - exiting now!\n");
                  exit(-1);
                  }
               CLc->x = rac->x[i];
               CLc->y = rac->y[i];
               CLc->z = rac->z[i];
               CLc->lid = LIDc;
               CLc->checkinstance = checkinstance;
               CLc->next = NNc->CL;
               NNc->CL = CLc;
               }
            }

         mix = max = rac->x[0];
         miy = may = rac->y[0];
         for(i=0; i<rac->numverts; i++)
            {
            if(rac->x[i] > max)  max = rac->x[i];
            if(rac->x[i] < mix)  mix = rac->x[i];
            if(rac->y[i] > may)  may = rac->y[i];
            if(rac->y[i] < miy)  miy = rac->y[i];

            if(foundnets[i] != nettouse) /** means this node exists in another network - need to change it ***/
               {
               for(j=0; j<listlength; j++)
                  {
                  NNc = BucketsOfNets[j].next;
                  while(NNc != NULL)
                     {
                     if(NNc->netnumb == foundnets[i])
                        {
                        NNc->netnumb = nettouse;
                        }
                     NNc = NNc->next;
                     }
                  }
               }
            }
         NNc = BucketsOfNets[BucketIndices[0]].next;
         while(NNc != NULL)
            {
            if(NNc->netnumb == nettouse)
               {
               LIDc->localid = rac->localID;
               LIDc->Lindex = rac->Lindex;
               LIDc->idn = rac->idn;
               LIDc->checkinstance = checkinstance;
               LIDc->geom = (char) (G_AREAL);

               LIDc->mix = mix;
               LIDc->max = max;
               LIDc->miy = miy;
               LIDc->may = may;

               LIDc->next = NNc->lid;
               NNc->lid = LIDc;
               break;
               }
            NNc = NNc->next;
            }
         if(NNc == NULL)
            {
            printf("fatal error in assigning feaure id to network - terminating now\n");
            exit(-1);
            }

         }

      rac = rac->next;
      }
   i = compositeindex;


   free(BucketIndices);
   free(foundnets);
}





struct RawBridge * AddObjectToBridgeList(int SzRB, int BridgeIndex, int LongIndex, int ShortIndex, int numverts,
           int SEDRISid, double *x, double *y, double *z, double *h, double localID)
{
struct RawBridge * RB;
int i;

   RB = (struct RawBridge *) (malloc(SzRB));
   if(RB == NULL)
      {
      printf("allocation memory exhausted during bridge feature read\n");
      printf("processing cannot continue\n");
      exit(-1);
      }
   RB->Bindex = BridgeIndex;
   RB->numverts = numverts;
   RB->Lindex = LongIndex;
   RB->Sindex = ShortIndex;
   RB->idn = SEDRISid;
   RB->localID = localID;
   RB->next = NULL;
   RB->x = (double *) malloc(SzD * numverts);
   RB->y = (double *) malloc(SzD * numverts);
   RB->z = (double *) malloc(SzD * numverts);
   RB->h = (double *) malloc(SzD * numverts);
   if((RB->h == NULL) || (RB->y == NULL) || (RB->z == NULL))
      {
      printf("allocation memory exhausted during bridge data read\n");
      printf("processing cannot continue\n");
      exit(-1);
      }
   for(i = 0; i<numverts; i++)
      {
      RB->x[i] = x[i];
      RB->y[i] = y[i];
      RB->z[i] = z[i];
      RB->h[i] = h[i];
      }
   RB->numverts = numverts;
   return(RB);
}




void MakeActiveChecks(int FreeMemoryOnly)
{
  int i,j;
  int SzAC = sizeof(struct CombinedChecks);

  if((TtlCombinedChecks < (CONDITION_DEFINITIONS + CLONE_DEFINITIONS)) ||
     (FreeMemoryOnly > 0))
    {
      if(TtlCombinedChecks > 0)
	{
	  for(i=0; i<TtlCombinedChecks; i++)
            {
	      if(ActiveChecks[i].primaryEDCSstuff != NULL)
		free(ActiveChecks[i].primaryEDCSstuff);
	      if(ActiveChecks[i].secondaryEDCSstuff != NULL)
		free(ActiveChecks[i].secondaryEDCSstuff);
	      if(ActiveChecks[i].tertiaryEDCSstuff != NULL)
		free(ActiveChecks[i].tertiaryEDCSstuff);

	      if(ActiveChecks[i].primaryFIDstuff != NULL)
		free(ActiveChecks[i].primaryFIDstuff);
	      if(ActiveChecks[i].secondaryFIDstuff != NULL)
		free(ActiveChecks[i].secondaryFIDstuff);
	      if(ActiveChecks[i].tertiaryFIDstuff != NULL)
		free(ActiveChecks[i].tertiaryFIDstuff);
            }
	  free(ActiveChecks);
	  TtlCombinedChecks = 0;
	  TtlActiveChecks = 0;
	}
      if(FreeMemoryOnly == 0)
	{
	  TtlCombinedChecks = CONDITION_DEFINITIONS + CLONE_DEFINITIONS;
	  ActiveChecks = (struct CombinedChecks *) (malloc(SzAC * TtlCombinedChecks));
	  if(ActiveChecks == NULL)
            {
	      printf("available memory has been exhausted during analysis preparation\n");
	      printf("terminating\n");
	      exit(-1);
            }
	  for(i=0; i<TtlCombinedChecks; i++)
            {
	      ActiveChecks[i].primaryEDCSstuff   = NULL;
	      ActiveChecks[i].secondaryEDCSstuff = NULL;
	      ActiveChecks[i].tertiaryEDCSstuff  = NULL;

	      ActiveChecks[i].primaryFIDstuff    = NULL;
	      ActiveChecks[i].secondaryFIDstuff  = NULL;
	      ActiveChecks[i].tertiaryFIDstuff   = NULL;
            }
	}
    }

  
  if(FreeMemoryOnly == 0)
    {
      for(i=0; i<TtlCombinedChecks; i++)
        ActiveChecks[i].active = 0;
      
      TtlActiveChecks = 0;
      
      for(i=1; i<=CONDITION_DEFINITIONS; i++)
	{
          ErrorLookup[i].anyactive = 0;
          if(ErrorLookup[i].active == 1)
	     ErrorLookup[i].anyactive = ErrorLookup[i].active;
          else if(ErrorLookup[i].active == -1)
             ErrorLookup[i].anyactive = 1;
          else if(ErrorLookup[i].active != 0)
{
printf("encountered ErrorLookup active flag of %d for inspection %d\n",ErrorLookup[i].active,i);
ErrorLookup[i].anyactive = 0;
}

             
	  if((ErrorLookup[i].active > 0) || (ErrorLookup[i].active == -1))  /** user has check turned on ***/
            {
	      ActiveChecks[TtlActiveChecks].sensitivity = ActiveChecks[TtlActiveChecks].sensitivity2 = 0.0;
	      ActiveChecks[TtlActiveChecks].active = 1;
	      ActiveChecks[TtlActiveChecks].number = i;
	      ActiveChecks[TtlActiveChecks].clonenumber = -1;
	      ActiveChecks[TtlActiveChecks].numthresholds = ErrorLookup[i].numthresholds;
	      if(ActiveChecks[TtlActiveChecks].numthresholds > 0)
		ActiveChecks[TtlActiveChecks].sensitivity = ErrorLookup[i].sensitivity;
	      if(ActiveChecks[TtlActiveChecks].numthresholds > 1)
		ActiveChecks[TtlActiveChecks].sensitivity2 = ErrorLookup[i].sensitivity2;


              ActiveChecks[TtlActiveChecks].sensitivity3 = ErrorLookup[i].sensitivity3;
              ActiveChecks[TtlActiveChecks].sensitivity4 = ErrorLookup[i].sensitivity4;
              ActiveChecks[TtlActiveChecks].sensitivity5 = ErrorLookup[i].sensitivity5;
              ActiveChecks[TtlActiveChecks].sensitivity6 = ErrorLookup[i].sensitivity6;

              ActiveChecks[TtlActiveChecks].use_sen1 = ErrorLookup[i].use_sen1;
              ActiveChecks[TtlActiveChecks].use_sen2 = ErrorLookup[i].use_sen2;
              ActiveChecks[TtlActiveChecks].use_sen3 = ErrorLookup[i].use_sen3;
              ActiveChecks[TtlActiveChecks].use_sen4 = ErrorLookup[i].use_sen4;
              ActiveChecks[TtlActiveChecks].use_sen5 = ErrorLookup[i].use_sen5;
              ActiveChecks[TtlActiveChecks].use_sen6 = ErrorLookup[i].use_sen6;
              ActiveChecks[TtlActiveChecks].UseBorderConds = ErrorLookup[i].UseBorderConds;

	      ActiveChecks[TtlActiveChecks].participants = ErrorLookup[i].participants;
	      for(j=0; j<NUM_C; j++)
		{
		  ActiveChecks[TtlActiveChecks].Config1[j] = ErrorLookup[i].Config1[j];
		  ActiveChecks[TtlActiveChecks].Config2[j] = ErrorLookup[i].Config2[j];
		  ActiveChecks[TtlActiveChecks].Config3[j] = ErrorLookup[i].Config3[j];
		}
	      for(j=0; j<NUM_S; j++)
		{
		  ActiveChecks[TtlActiveChecks].Stratum1[j] = ErrorLookup[i].Stratum1[j];
		  ActiveChecks[TtlActiveChecks].Stratum2[j] = ErrorLookup[i].Stratum2[j];
		  ActiveChecks[TtlActiveChecks].Stratum3[j] = ErrorLookup[i].Stratum3[j];
		}
	      for(j=0; j<NUM_D; j++)
		{
		  ActiveChecks[TtlActiveChecks].Domain1[j] = ErrorLookup[i].Domain1[j];
		  ActiveChecks[TtlActiveChecks].Domain2[j] = ErrorLookup[i].Domain2[j];
		  ActiveChecks[TtlActiveChecks].Domain3[j] = ErrorLookup[i].Domain3[j];
		}


	      if(ErrorLookup[i].primaryEDCSstuff != NULL)
		{
		  ActiveChecks[TtlActiveChecks].primaryEDCSstuff = ErrorLookup[i].primaryEDCSstuff;
		  ErrorLookup[i].primaryEDCSstuff = NULL;
		}
	      
	      if(ErrorLookup[i].secondaryEDCSstuff != NULL)
		{
		  ActiveChecks[TtlActiveChecks].secondaryEDCSstuff = ErrorLookup[i].secondaryEDCSstuff;
		  ErrorLookup[i].secondaryEDCSstuff = NULL;
		}
	      
	      if(ErrorLookup[i].tertiaryEDCSstuff != NULL)
		{
		  ActiveChecks[TtlActiveChecks].tertiaryEDCSstuff = ErrorLookup[i].tertiaryEDCSstuff;
		  ErrorLookup[i].tertiaryEDCSstuff = NULL;
		}


	      if(ErrorLookup[i].primaryFIDstuff != NULL)
		{
		  ActiveChecks[TtlActiveChecks].primaryFIDstuff = ErrorLookup[i].primaryFIDstuff;
		  ErrorLookup[i].primaryFIDstuff = NULL;
		}
	      
	      if(ErrorLookup[i].secondaryFIDstuff != NULL)
		{
		  ActiveChecks[TtlActiveChecks].secondaryFIDstuff = ErrorLookup[i].secondaryFIDstuff;
		  ErrorLookup[i].secondaryFIDstuff = NULL;
		}
	      
	      if(ErrorLookup[i].tertiaryFIDstuff != NULL)
		{
		  ActiveChecks[TtlActiveChecks].tertiaryFIDstuff = ErrorLookup[i].tertiaryFIDstuff;
		  ErrorLookup[i].tertiaryFIDstuff = NULL;
		}


	      TtlActiveChecks += 1;
            }
	}
      for(i=0; i<CLONE_DEFINITIONS; i++)
	{
	  if((CloneErrorLookup[i].active > 0) || (CloneErrorLookup[i].active == -1))  /** user has check turned on ***/
            {
	      ActiveChecks[TtlActiveChecks].active = 1;
	      ErrorLookup[CloneErrorLookup[i].CloneNumber].anyactive += 1;
	      ActiveChecks[TtlActiveChecks].number = CloneErrorLookup[i].CloneNumber;
	      ActiveChecks[TtlActiveChecks].clonenumber = i;
	      ActiveChecks[TtlActiveChecks].numthresholds = ErrorLookup[CloneErrorLookup[i].CloneNumber].numthresholds;
	      if(ErrorLookup[CloneErrorLookup[i].CloneNumber].numthresholds > 0)
		ActiveChecks[TtlActiveChecks].sensitivity = CloneErrorLookup[i].sensitivity;
	      if(ErrorLookup[CloneErrorLookup[i].CloneNumber].numthresholds > 1)
		ActiveChecks[TtlActiveChecks].sensitivity2 = CloneErrorLookup[i].sensitivity2;

              ActiveChecks[TtlActiveChecks].sensitivity3 = CloneErrorLookup[i].sensitivity3;
              ActiveChecks[TtlActiveChecks].sensitivity4 = CloneErrorLookup[i].sensitivity4;
              ActiveChecks[TtlActiveChecks].sensitivity5 = CloneErrorLookup[i].sensitivity5;
              ActiveChecks[TtlActiveChecks].sensitivity6 = CloneErrorLookup[i].sensitivity6;

              ActiveChecks[TtlActiveChecks].use_sen1 = CloneErrorLookup[i].use_sen1;
              ActiveChecks[TtlActiveChecks].use_sen2 = CloneErrorLookup[i].use_sen2;
              ActiveChecks[TtlActiveChecks].use_sen3 = CloneErrorLookup[i].use_sen3;
              ActiveChecks[TtlActiveChecks].use_sen4 = CloneErrorLookup[i].use_sen4;
              ActiveChecks[TtlActiveChecks].use_sen5 = CloneErrorLookup[i].use_sen5;
              ActiveChecks[TtlActiveChecks].use_sen6 = CloneErrorLookup[i].use_sen6;

              ActiveChecks[TtlActiveChecks].UseBorderConds = CloneErrorLookup[i].UseBorderConds;

	      ActiveChecks[TtlActiveChecks].participants = ErrorLookup[CloneErrorLookup[i].CloneNumber].participants;
	      for(j=0; j<NUM_C; j++)
		{
		  ActiveChecks[TtlActiveChecks].Config1[j] = CloneErrorLookup[i].Config1[j];
		  ActiveChecks[TtlActiveChecks].Config2[j] = CloneErrorLookup[i].Config2[j];
		  ActiveChecks[TtlActiveChecks].Config3[j] = CloneErrorLookup[i].Config3[j];
		}
	      for(j=0; j<NUM_S; j++)
		{
		  ActiveChecks[TtlActiveChecks].Stratum1[j] = CloneErrorLookup[i].Stratum1[j];
		  ActiveChecks[TtlActiveChecks].Stratum2[j] = CloneErrorLookup[i].Stratum2[j];
		  ActiveChecks[TtlActiveChecks].Stratum3[j] = CloneErrorLookup[i].Stratum3[j];
		}
	      for(j=0; j<NUM_D; j++)
		{
		  ActiveChecks[TtlActiveChecks].Domain1[j] = CloneErrorLookup[i].Domain1[j];
		  ActiveChecks[TtlActiveChecks].Domain2[j] = CloneErrorLookup[i].Domain2[j];
		  ActiveChecks[TtlActiveChecks].Domain3[j] = CloneErrorLookup[i].Domain3[j];
		}
	      
	      if(CloneErrorLookup[i].primaryEDCSstuff != NULL)
		{
		  ActiveChecks[TtlActiveChecks].primaryEDCSstuff = CloneErrorLookup[i].primaryEDCSstuff;
		  CloneErrorLookup[i].primaryEDCSstuff = NULL;
		}
	      
	      if(CloneErrorLookup[i].secondaryEDCSstuff != NULL)
		{
		  ActiveChecks[TtlActiveChecks].secondaryEDCSstuff = CloneErrorLookup[i].secondaryEDCSstuff;
		  CloneErrorLookup[i].secondaryEDCSstuff = NULL;
		}
	      
	      if(CloneErrorLookup[i].tertiaryEDCSstuff != NULL)
		{
		  ActiveChecks[TtlActiveChecks].tertiaryEDCSstuff = CloneErrorLookup[i].tertiaryEDCSstuff;
		  CloneErrorLookup[i].tertiaryEDCSstuff = NULL;
		}
	      

	      if(CloneErrorLookup[i].primaryFIDstuff != NULL)
		{
		  ActiveChecks[TtlActiveChecks].primaryFIDstuff = CloneErrorLookup[i].primaryFIDstuff;
		  CloneErrorLookup[i].primaryFIDstuff = NULL;
		}
	      
	      if(CloneErrorLookup[i].secondaryFIDstuff != NULL)
		{
		  ActiveChecks[TtlActiveChecks].secondaryFIDstuff = CloneErrorLookup[i].secondaryFIDstuff;
		  CloneErrorLookup[i].secondaryFIDstuff = NULL;
		}
	      
	      if(CloneErrorLookup[i].tertiaryFIDstuff != NULL)
		{
		  ActiveChecks[TtlActiveChecks].tertiaryFIDstuff = CloneErrorLookup[i].tertiaryFIDstuff;
		  CloneErrorLookup[i].tertiaryFIDstuff = NULL;
		}
	      

	      TtlActiveChecks += 1;
            }
	}
    }


  return;
}







void ClampLinears(struct RawLinear *root, double multiplier, int cindex, int NofGrids)
{
struct RawLinear *rlc;
int gi1, iX, iY;
int grows, gcols;
double Xgrid[4], Ygrid[4], Zgrid[4];
int retval;
double answer;
double t,t1,u,u1;
int index;
int LoadedGridMres;
double off1, off2;
FILE *gridfilein;


   gridfilein = OpenGridFile(cindex,0);

   grows = ReadGridFromFile(0,gridfilein, multiplier,cindex,NofGrids,&gcols,&LoadedGridMres);

   off1 = SMIDGE;
   off2 = 2.0 * SMIDGE;
   rlc = root;
   while(rlc != NULL)
      {
      for(index = 0; index < rlc->numnodes; index++)
         {
         rlc->z[index] = (double) MY2DSENTINEL;
         retval = 0;
         for(gi1=0; gi1<MaxGridsPerRegion; gi1++)
            {
            if((MG[gi1].numX > 0) && (MG[gi1].numY > 0))
               {
               iX = 0;
               for(grows = 0; grows < MG[gi1].numX -1; grows++)
                  {
                  Xgrid[0] = MG[gi1].SouthWestX - off1 + ((double) iX * MG[gi1].Xspace);
                  Xgrid[1] = Xgrid[0] + MG[gi1].Xspace + off2;
                  if((Xgrid[0] <= rlc->x[index]) && (Xgrid[1] >= rlc->x[index]))
                     {
                     iY = 0;
                     for(gcols = 0; gcols < MG[gi1].numY - 1; gcols++)
                        {
                        Ygrid[0] = MG[gi1].SouthWestY - off1 + ((double) iY * MG[gi1].Yspace);
                        Ygrid[1] = Ygrid[0] + MG[gi1].Yspace + off2;

                        if((Ygrid[0] <= rlc->y[index]) && (Ygrid[1] >= rlc->y[index]))
                           {
                           Zgrid[0] = MG[gi1].Elevs[(iX * MG[gi1].numY) + iY];
                           Zgrid[3] = MG[gi1].Elevs[(iX * MG[gi1].numY) + iY + 1];
                           Zgrid[2] = MG[gi1].Elevs[(iX * MG[gi1].numY) + MG[gi1].numY + iY + 1];
                           Zgrid[1] = MG[gi1].Elevs[(iX * MG[gi1].numY) + MG[gi1].numY + iY];

                           t = (rlc->x[index] - Xgrid[0]) / (Xgrid[1] - Xgrid[0]);
                           t1 = 1.0 - t;
                           u = (rlc->y[index] - Ygrid[0]) / (Ygrid[1] - Ygrid[0]);
                           u1 = 1.0 - u;

                           answer = t1 * u1 * Zgrid[0];
                           answer += t * u1 * Zgrid[1];
                           answer += t * u * Zgrid[2];
                           answer += t1 * u * Zgrid[3];

                           rlc->z[index] = answer;

                           retval = 1;
                           break;  /*** break from for cols loop ***/
                           }
                        ++iY;
                        } /*** end for(gcols *****/
                     } /*** end if((Xgrid[0] <= pntx) && (Xgrid[2] >= pntx)) ***/
                  if(retval > 0)
                     break;  /*** break from for grows loop ***/
                  ++iX;
                  }  /*** end for(grows = 0; grows < MG[gi1].numX -1; grows++) ****/
               } /*** end if((MG[gi1].numX > 0) && (MG[gi1].numY > 0)) ****/
            if(retval > 0)
               break;   /*** break from for gi1 loop ***/
            } /*** end for gi1 ***/
         } /** end for index ***/

      rlc = rlc->next;
      } /** end while rlc != NULL) ****/

   CloseGridFile(gridfilein);


   rlc = root;
   while(rlc != NULL)
      {
      for(index = 0; index < rlc->numnodes; index++)
         {
         if((rlc->z[index] > 1.307005) && (rlc->z[index] < 1.307007))
            {
            if(GetPointElevation(rlc->x[index],rlc->y[index],&answer) > 0)
               {
               rlc->z[index] = answer;
               }
            }
         }
      rlc = rlc->next;
      }
}



int EitherPointInBox(double x1, double y1, double x2, double y2, double bx1, double by1, double bx2, double by2)
{
int answer;
   answer = 0;
   if((x1 >= bx1) && (x1 <= bx2) && (y1 >= by1) && (y1 <= by2))
      answer = 1;
   else if((x2 >= bx1) && (x2 <= bx2) && (y2 >= by1) && (y2 <= by2))
      answer = 1;
   return(answer);
}

      

int AddToPointAndIDlist(double x, double y, int id)
{
int answer;
double tx, ty;
   pic = PIroot;
   while(pic != NULL)
      {
      if(pic->ID == id)
         {
         if((pic->x == x) && (pic->y == y))
            break;
         else
            {
            tx = pic->x - x;
            ty = pic->y - y;
            if((-0.001 < tx) && (tx < 0.001) && (-0.001 < ty) && (ty < 0.001))
               break;
            }
         }
      pic = pic->next;
      }
   if(pic == NULL)
      {
      answer = 1;
      pic = (struct PointAndID *) (malloc(sizeof(struct PointAndID)));
      if(pic == NULL)
         {
         printf("all memory available for allocation has been exhausted");
         printf("terminating execution\n");
         exit(-1);
         }
      pic->x = x;
      pic->y = y;
      pic->ID = id;
      pic->next = PIroot;
      PIroot = pic;
      }
   else
      {
      answer = 0;
      }
   return(answer);
}


void FreePointAndIDlist(void)
{
struct PointAndID *t;
   pic = PIroot;
   while(pic != NULL)
      {
      t = pic;
      pic = pic->next;
      free(t);
      }
   PIroot = NULL;
}








int SL_CalculateGeodeticCoordArea(double minx,double miny, double *returnarea, double *returnperimeter, int startindex, int stopindex)
{
int i,numlegs;
int stopi;
double Xold, Yold;
double temp, xbase, ybase;
double tx1, ty1, tx2, ty2;
double avglatitude;
double area, perimlength, leglenth;
double TX[3], TY[3];


   i = startindex + 3;
   if(stopindex == 0)
      stopi = ArealFromFile.numverts - 1;
   else
      stopi = stopindex - 1;
   numlegs = 0;
   if(i == stopindex)
      {
      perimlength = 0;
      for(i=startindex; i<stopindex; i++)
         {
         TX[i-startindex] = ArealFromFile.x[i];
         TY[i-startindex] = ArealFromFile.y[i];

         if(i > startindex)
            {
            leglenth = Distance(ArealFromFile.x[i-1],ArealFromFile.y[i-1],
               ArealFromFile.x[i],ArealFromFile.y[i]);
            perimlength += leglenth;
            ++numlegs;
            }
         else
            {
            perimlength = Distance(ArealFromFile.x[i],ArealFromFile.y[i],
                 ArealFromFile.x[stopi],ArealFromFile.y[stopi]);
            }
         }

      area = TriangleXYsurfaceArea(TX,TY);

      *returnarea = area;
      *returnperimeter = perimlength;
         return(1);

      }
   tx1 = MinNativeX;
   ty1 = MinNativeY;
   tx2 = minx / 100000.0 + Xtranslation;
   ty2 = miny / 100000.0 + Ytranslation;

   avglatitude = (ty2 - ty1) / 2.0 + ty1;

   avglatitude = (avglatitude * PI) / 180.0;

   temp = WGS84degreeLength * cos(avglatitude);
   xbase = (tx2 - tx1) * temp;
   if(xbase < 0)
      xbase = 0 - xbase;


   ybase = WGS84degreeLength * (ty2 - ty1);
   if(ybase < 0)
      ybase = 0 - ybase;


   for(i=0; i<ArealFromFile.numverts; i++)
      {
      tx2 = ArealFromFile.x[i] / 100000.0 + Xtranslation;
      ty2 = ArealFromFile.y[i] / 100000.0 + Ytranslation;

      avglatitude = (ty2 - ty1) / 2.0 + ty1;

      avglatitude = (avglatitude * PI) / 180.0;

      temp = WGS84degreeLength * cos(avglatitude);
      temp = (tx2 - tx1) * temp;

      ArealForAreaCalculation.x[i] = temp - xbase;

      temp = WGS84degreeLength * (ty2 - ty1);

      ArealForAreaCalculation.y[i] = temp - ybase;

      }


   area = 0.0;
   if(stopindex == 0)
      {
      Xold = ArealForAreaCalculation.x[ArealFromFile.numverts - 1];
      Yold = ArealForAreaCalculation.y[ArealFromFile.numverts - 1];
      }
   else
      {
      Xold = ArealForAreaCalculation.x[stopi];
      Yold = ArealForAreaCalculation.y[stopi];
      }

   if(startindex < stopindex)
      {
      for(i=startindex; i<stopindex; i++)
         {
         if(i > startindex)
            {
            leglenth = Distance(ArealForAreaCalculation.x[i-1],ArealForAreaCalculation.y[i-1],
               ArealForAreaCalculation.x[i],ArealForAreaCalculation.y[i]);
            perimlength += leglenth;
            ++numlegs;
            }
         else
            {
            perimlength = Distance(ArealForAreaCalculation.x[i],ArealForAreaCalculation.y[i],
                 ArealForAreaCalculation.x[stopi],ArealForAreaCalculation.y[stopi]);
            }
         area += (Xold - ArealForAreaCalculation.x[i]) * (Yold + ArealForAreaCalculation.y[i] - miny);
         Xold = ArealForAreaCalculation.x[i];
         Yold = ArealForAreaCalculation.y[i];
         }
      }
   else
      {
      i = startindex;
      while(i != stopindex)
         {
         if(i > startindex)
            {
            leglenth = Distance(ArealForAreaCalculation.x[i-1],ArealForAreaCalculation.y[i-1],
               ArealForAreaCalculation.x[i],ArealForAreaCalculation.y[i]);
            perimlength += leglenth;
            ++numlegs;
            }
         else
            {
            perimlength = Distance(ArealForAreaCalculation.x[i],ArealForAreaCalculation.y[i],
                 ArealForAreaCalculation.x[stopi],ArealForAreaCalculation.y[stopi]);
            }

         area += (Xold - ArealForAreaCalculation.x[i]) * (Yold + ArealForAreaCalculation.y[i] - miny);
         Xold = ArealForAreaCalculation.x[i];
         Yold = ArealForAreaCalculation.y[i];

         ++i;
         if(i == stopindex)
            break;
         else if(i == ArealFromFile.numverts)
            i = 0;
         }
      }


   if(area < 0)
      area = 0.0 - area;
   area = 0.5 * area;

   *returnarea = area;
   *returnperimeter = perimlength;
         return(1);
}



double IncludedSlivers(double localid)
{
int i,j, i1;
int part1, part2, part3;
int checknum;
int OnReset, DoTheReset;
int NeighborsChecked;
int teststart, testend;
int wrapstop;
double d;
double Xvicinity, Yvicinity, Zvicinity;
double ratio1, ratio2;
double miny,minx;
double perim1, perim2, area1, area2;
double xint,yint, angle;
double answer = 10000.0;


   ratio1 = ratio2 = answer = 10000.0;

   if(ArealFromFile.numverts <= 3)
      return(answer);

   for(checknum = 0; checknum < TtlActiveChecks; checknum++)
      {
      if(CombinedCheckApplies(ArealFromFile.idn,checknum,INCLSLIVER,ArealFromFile.Lindex,ArealFromFile.Sindex,
                                                 ArealFromFile.config,ArealFromFile.stratum,ArealFromFile.domain,
                                                 &part1,&part2,&part3) && (part1 > 0))
         {

         for(i=0; i<ArealFromFile.numverts; i++)
            {
            if(i == 0)
               {
               j = ArealFromFile.numverts - 1;
               miny = ArealFromFile.y[i];
               }
            else
               {
               j = i - 1;
               if(ArealFromFile.y[i] < miny)
                  miny = ArealFromFile.y[i];
               }
            SliverGuide[i].adjacentdist = 0.0;
            angle = 100.0;
            while((SliverGuide[i].adjacentdist < 0.000001) || (angle < 5.0))
               {
               SliverGuide[i].adjacentdist = Distance(ArealFromFile.x[i],ArealFromFile.y[i], ArealFromFile.x[j],ArealFromFile.y[j]);
               SliverGuide[i].closest = (SliverGuide[i].adjacentdist * 0.9); /***/
               SliverGuide[i].index = j;
               SliverGuide[i].reset = 0;
               --j;
               if(j < 0)
                  j = ArealFromFile.numverts - 1;
               if(j == 1)
                  break;
               }

            j = i + 1;
            if(j == ArealFromFile.numverts)
               j = 0;
            d = 0.0;
            angle = 100.0;
            while((d < 0.000001) || (angle < 5.0))
               {
               SliverGuide[i].forwardindex = j;
               d = Distance(ArealFromFile.x[i],ArealFromFile.y[i], ArealFromFile.x[j],ArealFromFile.y[j]);
               if(d < SliverGuide[i].adjacentdist)
                  {
                  SliverGuide[i].adjacentdist = d;
                  SliverGuide[i].closest = (SliverGuide[i].adjacentdist * 0.9); /***/
                  SliverGuide[i].index = j;
                  }
               ++j;
               if(j == ArealFromFile.numverts)
                  j = 0;
               if(j == i)
                  break;
               }

            }


         for(i=0; i<ArealFromFile.numverts; i++)
            {
            if(i == 0)
               wrapstop = ArealFromFile.numverts - 1;
            else
               wrapstop = i - 1;
            OnReset = 0;
            NeighborsChecked = SliverGuide[i].forwardindex + 5;
            teststart = SliverGuide[i].forwardindex + 2;
            DoTheReset = 1;
            for(j = SliverGuide[i].forwardindex + 1; j < ArealFromFile.numverts; j++) 
               {
               if(j > NeighborsChecked)
                  break;
               if(j == wrapstop)
                  break;
               d = PointToLineDist2D(ArealFromFile.x[i],ArealFromFile.y[i],
                         ArealFromFile.x[j],ArealFromFile.y[j], ArealFromFile.x[j-1],ArealFromFile.y[j-1]);
               if(d < SliverGuide[i].closest)
                  {
                  if(j >= teststart)
                    {
                    testend = j - 1;
                    for(i1 = teststart-1; i1 <= testend; i1++)
                       {
                       if(LineSegmentsIntersect(ArealFromFile.x[i],ArealFromFile.y[i], ArealFromFile.x[j],ArealFromFile.y[j],
                               ArealFromFile.x[i1-1],ArealFromFile.y[i1-1], ArealFromFile.x[i1],ArealFromFile.y[i1],&xint,&yint) > 0)
                          {
                          DoTheReset = 0;
                          break;
                          }
                       }
                    }
                  if(DoTheReset > 0)
                     {
                     SliverGuide[i].closest = d;
                     SliverGuide[i].index = j;
                     SliverGuide[i].reset = 1;
                     OnReset = 1;
                     }
                  else
                     break;
                  }
               else if(OnReset > 0)
                  break;
               }
            }

         for(i=0; i<ArealFromFile.numverts; i++)
            {
            if(SliverGuide[i].reset > 0) /** then found a vertex closer than one of the adjacent vertices ***/
               {
               minx = ArealFromFile.x[i];
               miny = ArealFromFile.y[i];

               j = i;
               while(j != SliverGuide[i].index)
                  {
                  if(ArealFromFile.x[j] < minx)
                     minx = ArealFromFile.x[j];
                  if(ArealFromFile.y[j] <miny)
                     miny = ArealFromFile.y[j];

                  ++j;
                  if(j == ArealFromFile.numverts)
                     j = 0;
                  }
/** add one to j here as the stop index for calcuate area treats it as numverts so stops at < j ***/
               j = SliverGuide[i].index + 1;
               if(j == ArealFromFile.numverts)
                  j = 0;

               if(SL_CalculateGeodeticCoordArea(minx,miny, &area1, &perim1, i, j) == 0)
                  {
                  perim1 = 0;
                  answer = 100000.0;
                  }

               if(perim1 > 0)
                  {
                  /**ratio1 = area1 / (perim1 * perim1);**/
                  ratio1 = area1 /perim1;
   
                  if(ratio1 < answer)
                     {
                     answer = ratio1;
                     if(j > i)
                        {
                        i1 = i + (j - i - 1) / 2;
                        }
                     else
                        {
                        /**i1 = SliverGuide[i].index + (ArealFromFile.numverts - j); **/
                        i1 = j + ArealFromFile.numverts - i - 1;
                        i1 = i1 / 2;
                        i1 = (i + i1) % ArealFromFile.numverts;
                        }
                     }
                  }
/*** now go from closest vertex back to i to check that area ratio ***/
               minx = ArealFromFile.x[i];
               miny = ArealFromFile.y[i];
               j = SliverGuide[i].index;
               while(j != i)
                  {
                  if(j == ArealFromFile.numverts)
                    j = 0;
                  else
                    ++j;
                  if(ArealFromFile.x[j] < minx)
                     minx = ArealFromFile.x[j];
                  if(ArealFromFile.y[j] <miny)
                     miny = ArealFromFile.y[j];
                  }

               j = i+1;
               if(j == ArealFromFile.numverts)
                  j = 0;
               if(SL_CalculateGeodeticCoordArea(minx,miny, &area2, &perim2, SliverGuide[i].index,j) == 0)
                  {
                  perim2 = 0;
                  answer = 100000.0;
                  }
               if(perim2 > 0)
                  {
                  ratio2 = area2 / perim2;

                  if(ratio2 < answer)
                     {
                     answer = ratio2;
                     if(j > SliverGuide[i].index)
                        {
                        i1 = SliverGuide[i].index + (j - SliverGuide[i].index) / 2;
                        }
                     else
                        {
                        i1 = j + ArealFromFile.numverts - SliverGuide[i].index;
                        i1 = i1 / 2;
                        i1 = (SliverGuide[i].index + i1) % ArealFromFile.numverts;
                        }
                     }
                  }

               if(SensitivityCheck(LT, INCLSLIVER, checknum, answer) > 0)
                  { 
                  Xvicinity = ArealFromFile.x[i1];
                  Yvicinity = ArealFromFile.y[i1];
                  Zvicinity = ArealFromFile.z[i1];

                  if(i1 == (ArealFromFile.numverts - 1))
                     i1 -= 1;

                  FwritePointObjectAndMagnitude(INCLSLIVER,Make_Correct(INCLSLIVER,checknum), answer,
                         ArealFromFile.idn,
                         G_AREAL,ArealFromFile.Lindex,localid,ArealFromFile.Sindex,Xvicinity,Yvicinity,Zvicinity,
                         ArealFromFile.Sindex,ArealFromFile.idn, G_AREAL,ArealFromFile.Lindex,localid,
                         2, &ArealFromFile.x[i1], &ArealFromFile.y[i1], &ArealFromFile.z[i1]);
                  }

               answer = 10000.0;
               }
            }
         }
      }

   return(answer);
}




rb_red_blk_tree * CreateTreeOfArealEdge(double * Xverts, double * Yverts, int NumVerts, int * LastIndex)
{
int i, j, k, xindex1, xindex2, yindex1, yindex2;
int ii, jj;
int cindex,MaxCindex;
double minx, maxx, miny, maxy, xint, yint;
int MYI;
int inbox;
struct RB_Edgelist * RBE, *RBE2;
int SzRBE = sizeof(struct RB_Edgelist);

   MYI = MaxYindex + 1;
   RB_tree = RBTreeCreate(IntComp,IntDest,EdgeInfoDest,IntPrint,InfoPrint);

   MaxCindex = -1;
   
   for(k=1; k<=NumVerts; k++)
      {
      if(k == NumVerts)
         {
         i = 0;
         j = NumVerts - 1;
         }
      else
         {
         i = k;
         j = k - 1;
         }
         
      xindex1 = (int) (Xverts[j] / RegionSize);
      yindex1 = (int) (Yverts[j] / RegionSize);
      xindex2 = (int) (Xverts[i] / RegionSize);
      yindex2 = (int) (Yverts[i] / RegionSize);
      if(xindex2 < xindex1)
         {
         jj = xindex1;
         xindex1 = xindex2;
         xindex2 = jj;
         }
      if(yindex2 < yindex1)
         {
         jj = yindex1;
         yindex1 = yindex2;
         yindex2 = jj;
         }
      if((xindex1 == xindex2) && (yindex1 == yindex2)) /** edge is in only one region ***/
         {
         RBE = (struct RB_Edgelist *) (malloc(SzRBE));
         if(RBE == NULL)
            {
            printf("available memory has been exhausted during large area feature edge list indexing\n");
            printf("processing must terminate\n");
            exit(-1);
            }
         cindex = (xindex1 * MYI) + yindex1;
         if(cindex > MaxCindex)
            {
            MaxCindex = cindex;
            }
         RBE->index = i;
         RBE->next = NULL;
         RB_newKey = cindex;
         if(( RB_newNode = RBExactQuery(RB_tree,&RB_newKey)))
            {
            RBE2 = (struct RB_Edgelist *) RB_newNode->info;
            RBE->next = RBE2->next;
            RBE2->next = RBE;
            }
         else
            {
            RB_newInt = (int *) (malloc(SzI));
            if(RB_newInt == NULL)
               {
               printf("memory has been exhausted during RB-Tree alloction for Area Edge analysis\n");
               exit(-1);
               }
            *RB_newInt = cindex;
            RBTreeInsert(RB_tree,RB_newInt, RBE);
            }
         }
      else /*** a multi-region edge ***/
         {
         for(ii = xindex1; ii <= xindex2; ii++)
            {
            minx = ii * RegionSize;
            maxx = minx + RegionSize;
            for(jj = yindex1; jj <= yindex2; jj++)
               {
               miny = jj * RegionSize;
               maxy = miny + RegionSize;
               inbox = 0;
/*** added the first if and else (just testing vertex, without line intersections) after problems with land
 * cover fail (COVERFAIL) inspection - will influence other checks as well since potentially added more edges to
 * individual buckets for large areals ***/
               if((Xverts[j] >= minx) && (Xverts[j] <= maxx) && (Yverts[j] >= miny) && (Yverts[j] <= maxy))
                  inbox = 1;
               else if((Xverts[i] >= minx) && (Xverts[i] <= maxx) && (Yverts[i] >= miny) && (Yverts[i] <= maxy))
                  inbox = 1;
               else
                  {
                  if(LineSegmentsIntersect(Xverts[j],Yverts[j], Xverts[i],Yverts[i],minx,miny,minx,maxy, &xint, &yint) > 0)
                     inbox = 1;
                  else
                     {
                     if(LineSegmentsIntersect(Xverts[j],Yverts[j], Xverts[i],Yverts[i],minx,miny,maxx,miny, &xint, &yint) > 0)
                        inbox = 1;
                     else
                        {
                        if(LineSegmentsIntersect(Xverts[j],Yverts[j], Xverts[i],Yverts[i],maxx,maxy,minx,maxy, &xint, &yint) > 0)
                           inbox = 1;
                        else if(LineSegmentsIntersect(Xverts[j],Yverts[j], Xverts[i],Yverts[i],maxx,maxy,maxx,miny, &xint, &yint) > 0)
                           {
                           inbox = 1;
                           }
                        }
                     }
                  }
               if(inbox > 0)
                  {
                  RBE = (struct RB_Edgelist *) (malloc(SzRBE));
                  if(RBE == NULL)
                     {
                     printf("available memory has been exhausted during large area feature edge list indexing\n");
                     printf("processing must terminate\n");
                     exit(-1);
                     }
                  cindex = (ii * MYI) + jj;
                  if(cindex > MaxCindex)
                     {
                     MaxCindex = cindex;
                     }
                  RBE->index = i;
                  RBE->next = NULL;
                  RB_newKey = cindex;
                  if(( RB_newNode = RBExactQuery(RB_tree,&RB_newKey)))
                     {
                     RBE2 = (struct RB_Edgelist *) RB_newNode->info;
                     RBE->next = RBE2->next;
                     RBE2->next = RBE;
                     }
                  else
                     {
                     RB_newInt = (int *) (malloc(SzI));
                     if(RB_newInt == NULL)
                        {
                        printf("memory has been exhausted during RB-Tree alloction for Area Edge analysis\n");
                        exit(-1);
                        }
                     *RB_newInt = cindex;
                     RBTreeInsert(RB_tree,RB_newInt, RBE);
                     }
                  }
               }
            }
         }
      }

   * LastIndex = MaxCindex /** + MYI **/;  /* causes Colombia and others (baghdad, etc) to blow up in time and mem */

   return(RB_tree);
}





void CheckArealForSelfIntersection(struct RawAreal *A, double *xi, double *yi, int checkinstance)
{
int i,j,ci1, ci2,checkit;
int ii,jj,prejj, kk, kkk;
int kkend, kkstart,testindex;
double xint, yint, zint;
int cindex1, cindex2;
int MYI;
int LastI, UsedTree;
struct RB_Edgelist * LastEdge1;
/***struct RB_Edgelist * LastEdge2; ***/

   MYI = MaxYindex + 1;

   if(A->RB_Tree_Edgelist == NULL)
      {
/** skip over duplicate vertices ***/
      kkend = A->numverts-1;
      while((kkend > 0) &&
             (A->x[kkend-1] == A->x[kkend]) && (A->y[kkend-1] == A->y[kkend]))
         {
         --kkend;
         }

      while((kkend > 0) && (A->x[kkend] == A->x[0]) && (A->y[kkend] == A->y[0]))
         {
         --kkend;
         }
      prejj = kkend;
      for(jj=0; jj<= kkend; jj++)
         {
         if(jj > 0)
            prejj = jj - 1;
         kkstart = jj + 1;
/**** here, skip over duplicate nodes to avoid bogus intersection notification ***/
         while((kkstart<= kkend) &&
                (A->x[kkstart] == A->x[jj]) && (A->y[kkstart] == A->y[jj]))
            {
            ++kkstart;
            }
         for(kk=kkstart; kk< kkend; kk++)
            {
            if(kk == kkstart)
               {
               if((A->x[kk] != A->x[jj]) ||
                       (A->y[kk] != A->y[jj]))
                  {
                  if(PointOnLineSegment(A->x[kk],A->y[kk],
                       A->x[prejj],A->y[prejj],
                        A->x[jj],A->y[jj], 0.000001) > 0)
                     {
                     kkk = jj + 1;
                     if(kkk == kk)  /*** found the point to be on immediately preceeding line segment ***/
                        {
                        kkk = prejj;
                        if(StrictlyBetween(A->x[kk],A->y[kk],A->x[kkk],A->y[kkk],A->x[jj],A->y[jj]) > 0)
                           {
                           kkk = AddToPointAndIDlist(A->x[kk],A->y[kk],A->idn);
                           }
                        else
                           {
                           kkk = -1;
                           }
                        }
                     else
                        kkk = AddToPointAndIDlist(A->x[kk],A->y[kk],A->idn);
                     if(kkk > 0)
                        {
                        if(kk == 0)
                           {
                           FwritePointAndObject(LOOPS,Make_Correct(LOOPS,checkinstance),
                              A->x[kk],A->y[kk],A->z[kk],A->idn,
                              A->Sindex,G_AREAL,A->Lindex,A->localID,A->idn,10.0,0.0,
                              &A->x[0], &A->y[0],&A->z[0],2);
                           }
                        else
                           {
                           FwritePointAndObject(LOOPS,Make_Correct(LOOPS,checkinstance),
                              A->x[kk],A->y[kk],A->z[kk],A->idn,
                              A->Sindex,G_AREAL,A->Lindex,A->localID,A->idn,10.0,0.0,
                              &A->x[kk-1], &A->y[kk-1],&A->z[kk-1],2);
                           }
                        }
                     }
                  }
               }   /*** end kk == kkstart ***/
            else 
               {
               if(LineSegmentsIntersect(A->x[kk-1],A->y[kk-1],
                                        A->x[kk],A->y[kk],
                                     A->x[prejj],A->y[prejj],
                                        A->x[jj],A->y[jj],&xint, &yint) > 0)
                  {
                  kkk = AddToPointAndIDlist(xint,yint,A->idn);
                  if(kkk > 0)
                     {
                     zint = InterpLinearElev(A->x[kk-1],A->y[kk-1],A->z[kk-1],
                                   A->x[kk],A->y[kk],A->z[kk],xint,yint);
                     FwritePointAndObject(LOOPS,Make_Correct(LOOPS,checkinstance),
                        xint,yint,zint,A->idn,
                        A->Sindex,G_AREAL,A->Lindex,A->localID,A->idn,10.0,0.0,
                                                     &A->x[kk-1], &A->y[kk-1],&A->z[kk-1],2);
                     }
                  }
               }  /*** end else ***/
            }
         } /*** end for jj ***/
      }
   else if(A->RB_Tree_Edgelist != NULL) /** a large vertex count area feature ***/
      {
      LastEdge1 = NULL;
      LastI = -1;

      kkend = A->numverts - 1;
      while((kkend > 0) && (A->x[kkend] == A->x[0]) && (A->y[kkend] == A->y[0]))
         {
         --kkend;
         }

      for(j=0; j<= kkend; j++)
         {
         if(j > 0)
            jj = j - 1;
         else
            jj = kkend;

         ci1 = (int) (A->x[j] / RegionSize);
         ci2 = (int) (A->y[j] / RegionSize);

         cindex1 = (ci1 * MYI) + ci2;

         ci1 = (int) (A->x[jj] / RegionSize);
         ci2 = (int) (A->y[jj] / RegionSize);

         cindex2 = (ci1 * MYI) + ci2;

         if(cindex2 < cindex1)
            {
            ci1 = cindex2;
            cindex2 = cindex1;
            cindex1 = ci1;
            }

         LastEdge1 = NULL;
         LastI = -1;
         for(ci1=cindex1; ci1<=cindex2; ci1++)
            {
            i = GetNextArealIndex(A, LastI, 1, &LastEdge1, ci1, &UsedTree);
            LastI = i;

            while(i >= 0)
               {
               if(i == 0)
                  ii = kkend;
               else
                  ii = i - 1;

               checkit = 1;
               testindex = j+1;
               if(testindex >= kkend)
                  testindex = 0;
               if((A->x[j] == A->x[testindex]) && (A->y[j] == A->y[testindex]))
                  {
                  checkit = 0;
                  while(testindex != ii)
                     {
                     if((A->x[j] == A->x[testindex]) && (A->y[j] == A->y[testindex]))
                        {
                        testindex += 1;
                        if(testindex >= kkend)
                           testindex = 0;
                        }
                     else
                        {
                        checkit = 1; /** then some vertex between i and j does not duplicate i ****/
                        break;
                        }
                     }
                  }
               if(checkit > 0)
                  {
                  testindex = jj - 1;
                  if(testindex < 0)
                     testindex = kkend;
                  if((A->x[jj] == A->x[testindex]) && (A->y[jj] == A->y[testindex]))
                     {
                     checkit = 0;
                     while(testindex != i)
                        {
                        if((A->x[jj] == A->x[testindex]) && (A->y[jj] == A->y[testindex]))
                           {
                           testindex -= 1;
                           if(testindex < 0)
                              testindex = kkend;
                           }
                        else
                           {
                           checkit = 1; /** then some vertex between i and j does not duplicate i ****/
                           break;
                           }
                        }
                     }
                  }
               if((checkit > 0) && (i <= kkend) && (i != j) && (i != jj) && (ii != j) && (ii != jj))
                  {
                  if(LineSegmentsIntersect(A->x[ii], A->y[ii], A->x[i], A->y[i],
                                   A->x[jj],A->y[jj],A->x[j],A->y[j], &xint, &yint) > 0)
                     {
                     kkk = AddToPointAndIDlist(xint,yint,A->idn);
                     if(kkk > 0)
                        {
                        zint = InterpLinearElev(A->x[i],A->y[i],A->z[i],
                                      A->x[ii],A->y[ii],A->z[ii],xint,yint);
                        if(i == 0)
                           {
                           FwritePointAndObject(LOOPS,Make_Correct(LOOPS,checkinstance),
                               xint,yint,zint,A->idn,
                               A->Sindex,G_AREAL,A->Lindex,A->localID,A->idn,10.0,0.0,
                                                     &A->x[i], &A->y[i],&A->z[i],2);
                           }
                        else
                           {
                           FwritePointAndObject(LOOPS,Make_Correct(LOOPS,checkinstance),
                               xint,yint,zint,A->idn,
                               A->Sindex,G_AREAL,A->Lindex,A->localID,A->idn,10.0,0.0,
                                                     &A->x[ii], &A->y[ii],&A->z[ii],2);
                           }
                        }
                     }
                  }

               i = GetNextArealIndex(A, LastI, 1, &LastEdge1, ci1, &UsedTree);
               LastI = i;
               }  /** end while i >= 0 ***/
            LastEdge1 = NULL;
            LastI = -1;
            } /*** end for(ci1=cindex1; ci1<=cindex2; ci1++) ***/
         } /*** end for(j=0; j<A->numverts; j++) ***/
      }  /** end else if(A->RB_Tree_Edgelist != NULL) ***/
}





void AddLC_EdgeToLC_Tree(struct ListOfArealEdges *L, int SzRBE, int MYI)
{
int xindex1, xindex2, yindex1, yindex2;
struct RB_LC_Edgelist *RBE, *RBE2;
int cindex;


   xindex1 = (int) (L->x1 / RegionSize);
   yindex1 = (int) (L->y1 / RegionSize);
   xindex2 = (int) (L->x2 / RegionSize);
   yindex2 = (int) (L->y2 / RegionSize);

   if((xindex1 == xindex2) && (yindex1 == yindex2)) /*** edge is entirely in one lm **/
      {
      RBE = (struct RB_LC_Edgelist *) (malloc(SzRBE));
      if(RBE == NULL)
         {
         printf("available memory has been exhausted during land cover area feature edge list indexing\n");
         printf("processing must terminate\n");
         exit(-1);
         }
      cindex = (xindex1 * MYI) + yindex1;
      RBE->edge = L;
      RBE->usedit = 0;
      RBE->next = NULL;
      RB_newKey = cindex;
      if(( RB_newNode = RBExactQuery(RB_LC_tree,&RB_newKey)))
         {
         RBE2 = (struct RB_LC_Edgelist *) RB_newNode->info;
         RBE->next = RBE2->next;
         RBE2->next = RBE;
         }
      else
         {
         RB_newInt = (int *) (malloc(SzI));
         if(RB_newInt == NULL)
            {
            printf("memory has been exhausted during RB-Tree alloction for Area Edge analysis\n");
            exit(-1);
            }
         *RB_newInt = cindex;
         RBTreeInsert(RB_LC_tree,RB_newInt, RBE);
         }
      }

   else
      {
      RBE = (struct RB_LC_Edgelist *) (malloc(SzRBE));
      if(RBE == NULL)
         {
         printf("available memory has been exhausted during large area feature edge list indexing\n");
         printf("processing must terminate\n");
         exit(-1);
         }
      cindex = (xindex1 * MYI) + yindex1;
      RBE->edge = L;
      RBE->usedit = 0;
      RBE->next = NULL;
      RB_newKey = cindex;
      if(( RB_newNode = RBExactQuery(RB_LC_tree,&RB_newKey)))
         {
         RBE2 = (struct RB_LC_Edgelist *) RB_newNode->info;
         RBE->next = RBE2->next;
         RBE2->next = RBE;
         }
      else
         {
         RB_newInt = (int *) (malloc(SzI));
         if(RB_newInt == NULL)
            {
            printf("memory has been exhausted during RB-Tree alloction for Area Edge analysis\n");
            exit(-1);
            }
         *RB_newInt = cindex;
         RBTreeInsert(RB_LC_tree,RB_newInt, RBE);
         }

      RBE = (struct RB_LC_Edgelist *) (malloc(SzRBE));
      if(RBE == NULL)
         {
         printf("available memory has been exhausted during large area feature edge list indexing\n");
         printf("processing must terminate\n");
         exit(-1);
         }
      cindex = (xindex2 * MYI) + yindex2;
      RBE->edge = L;
      RBE->usedit = 0;
      RBE->next = NULL;
      RB_newKey = cindex;
      if(( RB_newNode = RBExactQuery(RB_LC_tree,&RB_newKey)))
         {
         RBE2 = (struct RB_LC_Edgelist *) RB_newNode->info;
         RBE->next = RBE2->next;
         RBE2->next = RBE;
         }
      else
         {
         RB_newInt = (int *) (malloc(SzI));
         if(RB_newInt == NULL)
            {
            printf("memory has been exhausted during RB-Tree alloction for Area Edge analysis\n");
            exit(-1);
            }
         *RB_newInt = cindex;
         RBTreeInsert(RB_LC_tree,RB_newInt, RBE);
         }
      }
}




void WriteLandCoverHoles(void)
{
double MinLAEx, MinLAEy;
double ex1,ey1, ex2, ey2;
double X[2], Y[2];
double xdiff1, ydiff1, xdiff2, ydiff2;
double LengthTest, LengthFilter;
int madeconnection;
double holenumber = 1.0;
int CN;
struct ListOfArealEdges *LAEpp;
struct ListOfArealEdges *LAE_rt;
int MYI,xindex1, xindex2, yindex1, yindex2, cindex, cindex2;
int SzRBE = sizeof(struct RB_LC_Edgelist);
struct RB_LC_Edgelist *RBE, *RBE3; 
int whichend;
double *HX;
double *HY;
double *HZ;
struct HL
   {
   double x;
   double y;
   double z;
   struct HL * next;
   } *HLroot, *HLc, *HLn, *HLp;
int SzHL = sizeof(struct HL);
int i,numedges;


   LengthFilter = 0.0001;
   HLroot = NULL;
   numedges = 0;
   LAE_rt = NULL;

   if(LAEroot != NULL)
      {
      MYI =  MaxYindex + 1;
      RB_LC_tree = RBTreeCreate(IntComp,IntDest,LC_EdgeInfoDest,IntPrint,InfoPrint);

      LAEp = LAEc = LAEroot;
      if(LAEc->x1 < LAEc->x2)
         {
         MinLAEx = LAEc->x1;
         MinLAEy = LAEc->y1;
         }
      else if((LAEc->x1 == LAEc->x2) && (LAEc->y1 < LAEc->y2))
         {
         MinLAEx = LAEc->x1;
         MinLAEy = LAEc->y1;
         }
      else
         {
         MinLAEx = LAEc->x2;
         MinLAEy = LAEc->y2;
         }
      LAEpp = LAEp;
      LAEn = LAEc;
      CN = LAEc->cnumb;

      while(LAEc != NULL)
         {
         AddLC_EdgeToLC_Tree(LAEc, SzRBE, MYI);

         if(LAEc->x1 < MinLAEx)
            {
            MinLAEx = LAEc->x1;
            MinLAEy = LAEc->y1;
            CN = LAEc->cnumb;
            LAEpp = LAEp;
            LAEn = LAEc;
            }
         else if((LAEc->x1 == MinLAEx) && (LAEc->y1 < MinLAEy))
            {
            MinLAEx = LAEc->x1;
            MinLAEy = LAEc->y1;
            CN = LAEc->cnumb;
            LAEpp = LAEp;
            LAEn = LAEc;
            }

         if(LAEc->x2 < MinLAEx)
            {
            MinLAEx = LAEc->x2;
            MinLAEy = LAEc->y2;
            CN = LAEc->cnumb;
            LAEpp = LAEp;
            LAEn = LAEc;
            }
         else if((LAEc->x2 == MinLAEx) && (LAEc->y2 < MinLAEy))
            {
            MinLAEx = LAEc->x2;
            MinLAEy = LAEc->y2;
            CN = LAEc->cnumb;
            LAEpp = LAEp;
            LAEn = LAEc;
            }

         LAEp = LAEc;
         LAEc = LAEc->next;
         }

      ex1 = LAEn->x1;
      ex2 = LAEn->x2;
      ey1 = LAEn->y1;
      ey2 = LAEn->y2;

      if(LAEn != LAEroot)
         {
         LAEpp->next = LAEn->next;
         LAEn->next = LAEroot;
         LAEroot = LAEn;
         }
      while(LAEroot != NULL)
         {
         if(LAEroot->cnumb != -999909)
            {
            ex1 = LAEroot->x1;
            ey1 = LAEroot->y1;
            ex2 = LAEroot->x2;
            ey2 = LAEroot->y2;
            CN = LAEroot->cnumb;
            LAEroot->cnumb = -999909;

            xindex1 = (int) (ex1 / RegionSize);
            yindex1 = (int) (ey1 / RegionSize);
            cindex = (xindex1 * MYI) + yindex1;
            RB_newKey = cindex;
            if(( RB_newNode = RBExactQuery(RB_LC_tree,&RB_newKey)))
               {
               RBE = (struct RB_LC_Edgelist *) RB_newNode->info;
               while(RBE != NULL)
                  {
                  if(RBE->edge == LAEroot)
                     {
                     RBE->usedit = 1;
                     break;
                     }
                  RBE = RBE->next;
                  }
               }
            xindex2 = (int) (ex2 / RegionSize);
            yindex2 = (int) (ey2 / RegionSize);
            cindex2 = (xindex2 * MYI) + yindex2;
            if(cindex != cindex2)
               {
               RB_newKey = cindex2;
               if(( RB_newNode = RBExactQuery(RB_LC_tree,&RB_newKey)))
                  {
                  RBE = (struct RB_LC_Edgelist *) RB_newNode->info;
                  while(RBE != NULL)
                     {
                     if(RBE->edge == LAEroot)
                        {
                        RBE->usedit = 1;
                        break;
                        }
                     RBE = RBE->next;
                     }
                  }
               }

            LAEc = LAEroot;
            X[0] = LAEc->x1;
            Y[0] = LAEc->y1;
            X[1] = LAEc->x2;
            Y[1] = LAEc->y2;
            LengthTest = (X[0] - X[1]) * (X[0] - X[1]);
            LengthTest += (Y[0] - Y[1]) * (Y[0] - Y[1]);
            if(LengthTest > LengthFilter)
               {
               HLc = (struct HL *) (malloc(SzHL));
               HLc->x = LAEc->x1;
               HLc->y = LAEc->y1;
               HLc->z = LAEc->z1;

               HLn = (struct HL *) (malloc(SzHL));
               HLn->x = LAEc->x2;
               HLn->y = LAEc->y2;
               HLn->z = LAEc->z2;
               HLn->next = NULL;
               HLc->next = HLn;
               HLroot = HLc;
               HLp = HLn;
               numedges = 2;
               LAE_rt = LAEc;
               }
            whichend = 1;
            do
               {
               madeconnection = 0;

               xindex1 = (int) (ex1 / RegionSize);
               yindex1 = (int) (ey1 / RegionSize);
               cindex = (xindex1 * MYI) + yindex1;

               RB_newKey = cindex;
               if(( RB_newNode = RBExactQuery(RB_LC_tree,&RB_newKey)))
                  {
                  RBE = (struct RB_LC_Edgelist *) RB_newNode->info;
                  while(RBE != NULL)
                     {
                     if(RBE->usedit == 0)
                        {
                        LAEc = (struct ListOfArealEdges *) RBE->edge;
                        if(LAEc->cnumb == CN)
                           {
                           if(ex1 > LAEc->x1)   xdiff1 = ex1 - LAEc->x1;
                           else                 xdiff1 = LAEc->x1 - ex1;

                           if(ey1 > LAEc->y1)   ydiff1 = ey1 - LAEc->y1;
                           else                 ydiff1 = LAEc->y1 - ey1;

                           if(ex1 > LAEc->x2)   xdiff2 = ex1 - LAEc->x2;
                           else                 xdiff2 = LAEc->x2 - ex1;

                           if(ey1 > LAEc->y2)   ydiff2 = ey1 - LAEc->y2;
                           else                 ydiff2 = LAEc->y2 - ey1;

                           if((xdiff1 < 0.001) && (ydiff1 < 0.001))
                              {
                              RBE->usedit = 1;
                              LAEc->cnumb = -999909;
                              X[0] = LAEc->x1;
                              Y[0] = LAEc->y1;
                              X[1] = LAEc->x2;
                              Y[1] = LAEc->y2;
                              LengthTest = (X[0] - X[1]) * (X[0] - X[1]);
                              LengthTest += (Y[0] - Y[1]) * (Y[0] - Y[1]);
                              if(LengthTest > LengthFilter)
                                 {
                                 HLc = (struct HL *) (malloc(SzHL));
                                 HLc->x = LAEc->x2;
                                 HLc->y = LAEc->y2;
                                 HLc->z = LAEc->z2;
                                 if(HLroot == NULL)
                                    {
                                    HLn = (struct HL *) (malloc(SzHL));
                                    HLn->x = LAEc->x2;
                                    HLn->y = LAEc->y2;
                                    HLn->z = LAEc->z2;
                                    HLn->next = NULL;
                                    HLc->next = HLn;
                                    HLroot = HLc;
                                    HLp = HLn;
                                    numedges = 1; /*** this should be 2 at init, but it is ++ just below ***/
                                    }
                                 else
                                    {
                                    if((ex1 == HLroot->x) && (ey1 == HLroot->y))
                                       {
                                       HLc->next = HLroot;
                                       HLroot = HLc;
                                       }
                                    else
                                       {
                                       HLp->next = HLc;
                                       HLc->next = NULL;
                                       HLp = HLc;
                                       }
                                    }
                                 LAE_rt = LAEc;
                                 ++numedges;
                                 }
                              ex1 = LAEc->x2;
                              ey1 = LAEc->y2;
                              madeconnection = 1;
                              xindex2 = (int) (LAEc->x2 / RegionSize);
                              yindex2 = (int) (LAEc->y2 / RegionSize);
                              cindex2 = (xindex2 * MYI) + yindex2;
                              if(cindex != cindex2)
                                 {
                                 RB_newKey = cindex2;
                                 if(( RB_newNode = RBExactQuery(RB_LC_tree,&RB_newKey)))
                                    {
                                    RBE3 = (struct RB_LC_Edgelist *) RB_newNode->info;
                                    while(RBE3 != NULL)
                                       {
                                       if(RBE3->edge == LAEc)
                                          {
                                          RBE3->usedit = 1;
                                          break;
                                          }
                                       RBE3 = RBE3->next;
                                       }
                                    }
                                 }

                              break;
                              }
                           else if((xdiff2 < 0.001) && (ydiff2 < 0.001))
                              {
                              RBE->usedit = 1;
                              LAEc->cnumb = -999909;
                              X[0] = LAEc->x1;
                              Y[0] = LAEc->y1;
                              X[1] = LAEc->x2;
                              Y[1] = LAEc->y2;
                              LengthTest = (X[0] - X[1]) * (X[0] - X[1]);
                              LengthTest += (Y[0] - Y[1]) * (Y[0] - Y[1]);
                              if(LengthTest > LengthFilter)
                                 {
                                 HLc = (struct HL *) (malloc(SzHL));
                                 HLc->x = LAEc->x1;
                                 HLc->y = LAEc->y1;
                                 HLc->z = LAEc->z1;
                                 if(HLroot == NULL)
                                    {
                                    HLn = (struct HL *) (malloc(SzHL));
                                    HLn->x = LAEc->x2;
                                    HLn->y = LAEc->y2;
                                    HLn->z = LAEc->z2;
                                    HLn->next = NULL;
                                    HLc->next = HLn;
                                    HLroot = HLc;
                                    HLp = HLn;
                                    numedges = 1; /*** this should be 2 at init, but it is ++ just below ***/
                                    }
                                 else
                                    {
                                    if((ex1 == HLroot->x) && (ey1 == HLroot->y))
                                       {
                                       HLc->next = HLroot;
                                       HLroot = HLc;
                                       }
                                    else
                                       {
                                       HLp->next = HLc;
                                       HLc->next = NULL;
                                       HLp = HLc;
                                       }
                                    }
                                 LAE_rt = LAEc;
                                 ++numedges;
                                 }
                              madeconnection = 1;
                              ex1 = LAEc->x1;
                              ey1 = LAEc->y1;
                              xindex2 = (int) (LAEc->x1 / RegionSize);
                              yindex2 = (int) (LAEc->y1 / RegionSize);
                              cindex2 = (xindex2 * MYI) + yindex2;
                              if(cindex != cindex2)
                                 {
                                 RB_newKey = cindex2;
                                 if(( RB_newNode = RBExactQuery(RB_LC_tree,&RB_newKey)))
                                    {
                                    RBE3 = (struct RB_LC_Edgelist *) RB_newNode->info;
                                    while(RBE3 != NULL)
                                       {
                                       if(RBE3->edge == LAEc)
                                          {
                                          RBE3->usedit = 1;
                                          break;
                                          }
                                       RBE3 = RBE3->next;
                                       }
                                    }
                                 }

                              break;
                              }
                           } /*** end have same condition number (cnumb) ***/
                        } /*** end have not yet used this reference ***/
                     RBE = RBE->next;
                     } /*** end while RBE != NULL ***/
                 } /** end exact query match ***/
/**************************** do the below if want tomatch both endpoints as going around 
 * need to modify to write the edge out as it is connected ****
               xindex2 = (int) (ex2 / RegionSize);
               yindex2 = (int) (ey2 / RegionSize);
               cindex = (xindex2 * MYI) + yindex2;

               RB_newKey = cindex;
               if((0) && ( RB_newNode = RBExactQuery(RB_LC_tree,&RB_newKey)))
                  {
                  RBE = (struct RB_LC_Edgelist *) RB_newNode->info;
                  while(RBE != NULL)
                     {
                     if(RBE->usedit == 0)
                        {
                        LAEc = (struct ListOfArealEdges *) RBE->edge;
                        if(LAEc->cnumb == CN)
                           {
                           if((LAEc->x1 == ex2) && (LAEc->y1 == ey2))
                              {
                              RBE->usedit = 1;
printf("   2a connecting (%lf %lf) to (%lf %lf)\n",LAEc->x2,LAEc->y2,ex2,ey2);
                              ex2 = LAEc->x2;
                              ey2 = LAEc->y2;
                              LAEc->cnumb = -999909;
                              LAEc->next = Hroot;
                              Hroot = LAEc;
                              madeconnection = 1;
                              break;
                              }
                           else if((LAEc->x2 == ex2) && (LAEc->y2 == ey2))
                              {
                              RBE->usedit = 1;
printf("   2b connecting (%lf %lf) to (%lf %lf)\n",LAEc->x1,LAEc->y1,ex2,ey2);
                              ex2 = LAEc->x1;
                              ey2 = LAEc->y1;
                              LAEc->cnumb = -999909;
                              LAEc->next = Hroot;
                              Hroot = LAEc;
                              madeconnection = 1;
                              break;
                              }
                           } 
                        } 
                     RBE = RBE->next;
                     } 
                 } 
*****************************/
          
/**** do this to get through loop one more time ***/
               if((madeconnection == 0) && (whichend == 1))
                  {
                  madeconnection = 1;
                  whichend = 2;
                  ex1 = ex2;
                  ey1 = ey2;
                  }
               } while(madeconnection > 0);
            holenumber += 1.0;

            HX = (double *) malloc(SzD * (numedges + 3));
            HY = (double *) malloc(SzD * (numedges + 3));
            HZ = (double *) malloc(SzD * (numedges + 3));
            i = 0;
            HLc = HLroot;
            while(HLc != NULL)
               {
               HX[i] = HLc->x;
               HY[i] = HLc->y;
               HZ[i] = HLc->z;
               ++i;
               HLp = HLc;
               HLc = HLc->next;
               free(HLp);
               }
            HLroot = NULL;
            if(LAE_rt != NULL)
               {
               FwriteObjectAndMagnitude(COVERFAIL,CN,
                                      LAE_rt->idn,LAE_rt->Sindex,G_LINE,LAE_rt->Lindex,LAE_rt->UID,-1.0, -1.0, holenumber,
                                          HX,HY,HZ,numedges, 1);
               }
            free(HX);
            free(HY);
            free(HZ);
            LAE_rt = NULL;

            LAEpp = LAEroot;
            LAEroot = LAEroot->next;
            free(LAEpp);
            } /**** end if have a valid cnumb ***/
         else
            {
            LAEpp = LAEroot;
            LAEroot = LAEroot->next;
            free(LAEpp);
            }
         } /** end while LAEroot != NULL ***/

      LAEc = LAEroot;
      while(LAEc != NULL)
         {
         LAEp = LAEc;
         LAEc = LAEc->next;
         free(LAEp);
         }
      RBTreeDestroy(RB_LC_tree);
      }
}



int GetUUIDindex(char * idstring)
{
int i,j;
int c;
int answer = -1;

j = 0;

   i = 0;
   while(i < ID_O_count)
      {
      c = strcmp(&idstring[j],ID_O[i].IDstr);
      if(c == 0)
         {
         answer = i;
         break;
         }
      else if(c < 0)
         break;

      ++i;
      }
   return(answer);
}




int GetApplicableLengthWidthCodes(int *lengthcode, int *widthcode)
{
int answer = -1;

   if(NGA_TYPE == 1)
      {
      if(ATTRTYPE_D4() > 0) /*** GIFD D4 model ***/
         {
         *lengthcode = GetAttrIndex("LEG");
         *widthcode = GetAttrIndex("WGP");
         answer = 1;
         }
      else if(ATTRTYPE_FACC() > 0) /*** FACC+ model ***/
         {
         *lengthcode = GetAttrIndex("LEG");
         *widthcode = GetAttrIndex("WGP");
         answer = 1;
         }
      else if((ATTRTYPE_VMAP() > 0) || (ATTRTYPE_UFD1() > 0) ||
                (ATTRTYPE_UFD2() > 0) || (ATTRTYPE_UFD3() > 0))
 /*** VMAP model ***/ /*** UFD2 **/ /*** UFD1 **/ /*** UFD3 **/
         {
         *lengthcode = GetAttrIndex("LEN");
         *widthcode = GetAttrIndex("WID");
         answer = 1;
         }
      else if((ATTRTYPE_MGCP3() > 0) || (ATTRTYPE_MGCP4() > 0))
         {
         *lengthcode = GetAttrIndex("LEN");
         *widthcode = GetAttrIndex("WID");
         answer = 1;
         }
      else if((ATTRTYPE_ANY_TDS() > 0) || (ATTRTYPE_ANY_GGDM() > 0))
 /*** TDS v5***/ /*** TDS v4***/ /** GGDM **/
         {
         *lengthcode = GetAttrIndex("LZN");
         *widthcode = GetAttrIndex("WID");
         answer = 1;
         }
      else if(ATTRTYPE_SAC() > 0)
         {
         *lengthcode = GetAttrIndex("LEN");
         *widthcode = GetAttrIndex("WGP");
         answer = 1;
         }
      else /**** just in case  ***/
         {
         *lengthcode = -1;
         *widthcode = -1;
         answer = -1;
         }
      }
   return(answer);
}






void CheckRegion(int Lindex1,int Uindex1, int Lindex2, int Uindex2)
{
FILE *arin;
FILE *linin;
FILE *ptsin;
FILE *brdgin;
FILE *gridfilein;
FILE *MPin;
FILE *IDProb;
FILE *CstatsOut;
FILE *SrcFiles;
FILE *portrayfails;
/***FILE *tempout;***/
/**** FILE *AttrErrFile; ****/
int index1, index2;
int index1base, index1top, index2base, index2top;
double index1Min,index1Max,index2Min,index2Max;
double minx, maxx,miny,maxy;
double filedecimal, temp, temp2, tempID;
double AvgElevError, StdDev, RMSE, LE90, LE90factor;
double MaxDiff, MD_X, MD_Y, MaxDiffdiscard, MD_Xdiscard,MD_Ydiscard;
long int NZpoints, NZpointsdiscard;
int i, j, k, kk, kkk, kkstart, kkend, ii,jj, jjj, HadToOpenFile, vtxcnt;
int ii2,jj2, kk2, kk3, ii5, ii6, ii7, DoNotSkipThisLM,EDMindex,WBMindex;
int TempOK, OKtoUse,OKtoCheck;
int sliverdone;
int edgesin,neighborhit;
int CheckThemAll;
int ZB060code = -1;
int Config, Stratum, Domain;
int gridLODSchecked;
int valuesread = 0;
int FirstCheck;
int PseudoNodesAdded;
int dv;
int UseDupThreshold;
int compositeindex;
int neighborcompositeindex;
int NorthNeighborCount, SouthNeighborCount, EastNeighborCount, WestNeighborCount;
int Grows, Gcols;
int checkinstance;
int CheckMultiParts = 0;
int CheckNGA_Attributes = 0;
int FormNetworks = 0;
int CheckCOVERFAIL = 0;
int CheckDEMSTATS = 0;
int CheckFEATOUTSIDE = 0;
int CheckAOVERLAPA = 0;
int CheckBNDRYUNDERSHT = 0;
int CheckLBNDUSHT = 0;
int CheckMASKMONO = 0;
int LoadAttrBndryMatchSet = 0;
int LENcode = -1;
int WIDcode = -1;
/**int PrimeCount, SecCount;***/
/**int findex = 0;**/
double multiplier = 1.0;
double width, height, sliverratio;
double IncludedSliverRatio;
double surfacearea3D;
double vertpolysurfarea;
double pcCoverage;
double LLdm1;
double segmentlength;
double avgx1,avgy1,avgx2,avgy2;
double NumberToCheck;
double MinElev, MaxElev;
double edgeX[4], edgeY[4], edgeZ[4];
double xint, yint,zint;
struct RawAreal *ARroot, *ARc, *ARn, *ARadj, *ARdup, *ARtoUse;
struct RawAreal *NRAroot, *NRAc;
struct RawLinear *RLroot, *RLc, *RLdup;
struct RawLinear *NRLroot, *NRLc;
struct RawPoint *RProot, *RPc, *RPdup;
struct RawBridge *RBroot, *RBc, *RBdup;
struct ThePolys *TProot, *TPc, *TPn, *TPc2, *TPadj, *TPdup;
struct ThePolys *MProot;
struct LargeAreals *ARlc, *ARlp;

double PA, PB, PC, PD;
double PA2, PB2, PC2, PD2;
double LA,LB,LC, LB2;
double angle,dbljunk,tempsensitivity,AreaSizeCutoff;
double vx1,vy1,vz1,vx2,vy2,vz2;
double clipx1,clipy1,clipz1,clipx2,clipy2,clipz2;
double rlx,rly,rux,ruy;
double regionscomplete = 0.0;
int skiplimit;
char portiondone[100];
char MsgEnding[45];
unsigned char clipflag;
int abortNow,InsertOK,IsDup;

int SpecialCase;
double origx1,origy1,origx2,origy2,testx1,testy1,testx2,testy2;
struct reflist *BBrefc, *BBrefp;
struct LongList * PolyLongListRoot = NULL;
struct LongSkipList *LongPolySkipList;
struct LongList * Areal1LongListRoot = NULL;
struct LongList * Areal2LongListRoot = NULL;
struct LongList * Areal3LongListRoot = NULL;
struct LongList * Areal4LongListRoot = NULL;
struct LongSkipList *LongAreal1SkipList;
struct LongSkipList *LongAreal2SkipList;
struct LongSkipList *LongAreal3SkipList;
struct LongSkipList *LongAreal4SkipList;
struct LongList * LinearLongListRoot = NULL;
struct LongSkipList *LongLinearSkipList;
struct LongList * ModelPolyLongListRoot = NULL;
struct LongSkipList *LongModelPolySkipList;
/****/
struct LongList * NeighborLinearLongListRoot = NULL;
struct LongSkipList *NeighborLongLinearSkipList;
struct LongList * NeighborArealLongListRoot = NULL;
struct LongSkipList *NeighborLongArealSkipList;
/****/
struct LongList * PointLongListRoot = NULL;
struct LongSkipList *LongPointSkipList;
struct LongList * BridgeLongListRoot = NULL;
struct LongSkipList *LongBridgeSkipList;
struct ListOfEdges *PolyEdgeRoot, *lpec;
struct ListOfEdges *VertArealEdgeRoot, *VertPolyEdgeRoot;
struct ListOfEdges *ModelPolyEdgeRoot, *VertModelPolyEdgeRoot;
struct ListOfEdges *ArealEdgeRoot, *laec;
struct ListOfEdges *AdjEdge;
struct DoublePolySkipList *DblPolySkipList;
struct DoubleEdgeSkipList *DblPolyEdgeSkipList;
struct DoubleEdgeSkipList *DblArealEdgeSkipList;
struct DoubleEdgeSkipList *DblModelPolyEdgeSkipList;
struct DoublePolySkipList *DblModelPolySkipList;
struct TearErrorSortList *tr1, *tr2;
struct IncidentList *IE1;
int SzRA = sizeof(struct RawAreal);
int SzRL = sizeof(struct RawLinear);
int SzRP = sizeof(struct RawPoint);
int SzTESL = sizeof(struct TearErrorSortList);
int SzRB = sizeof(struct RawBridge);
int SzTP = sizeof(struct ThePolys);
int SzLE = sizeof(struct ListOfEdges);
int SzLA = sizeof(struct LargeAreals);
int SzPC = sizeof(struct PairsChecked);
int SzPW = sizeof(struct pairedwith);
int CheckByConfig[NUM_C];
int CheckByDomain[NUM_D];
int CheckByStratum[NUM_S];
int part1, part2, part3;
int NeighborsExist[4];
double NumObjects[NUM_C];
double NumLineSegments = 0.0;
/**long int temp_long; **/
int MinValsWereInit;
int SkipEntry = 0;
int Skip1Entry = 0;
int Skip2Entry = 0;
int Skip3Entry = 0;
int Skip4Entry = 0;
int SkipNEntry = 0;
int *PolyLODbandCount = NULL;
double XG, YG;
char afilein[500];
char suffix[5];
char tempstring[1000];
char tempstring2[500];
char CoordStr[100];
/******************************* don't need - only use to develop compare cond reports ******
char * CondSummary;
****************/
int Afilenumber;
int Lfilenumber;
int ReUseLargeAreal;
long int fo;
int TempConfig, TempStrat, TempDomain;
int CheckLLNOINT = 0;
int CheckLNOCOVERLA = 0;
int CheckCONFLATE = 0;
int CheckCONF_STATS = 0;
int CheckLSPANFAIL = 0;
int CheckLFNOINT = 0;
int CheckOBJECTWITHOUT = 0;
int CheckOBJ_WO_TWO = 0;
int CheckAREAKINK = 0;
int CheckAWITHOUTA = 0;
int CheckFSFAIL = 0;
int CheckCOINCIDEFAIL = 0;
int CheckISOLATEDA = 0;
int CheckNETISOA = 0;
int CheckANETISOA = 0;
int CheckCONNECTFAIL = 0;
int CheckFACESIZE = 0;
int CheckPSHAREFAIL = 0;
int CheckNOCOINCIDE = 0;
int CheckNOENDCON = 0;
int CheckISOLINE = 0;
int CheckBOTHENDCON = 0;
int CheckPERIMLEN = 0;
int CheckSEGLEN = 0;
int CheckLENOCOVERL = 0;
int CheckNOLCOVLE = 0;
int CheckLENOCOVERP = 0;
int CheckLLNONODEINT = 0;
int CheckShoots = 0;
int CheckSMALLAREA = 0;
int CheckSMLCUTOUT = 0;
int OnBoundaryExclude = 0;
long int ReportTime;
extern int LLFidTableCount;
extern int *LLFidTable;
extern int RoundInt(double inval);





/************************* all this moved to function LODelevDiffCheck to provide user error messages if
                           the attribution check is turned on, but can't be completed due missing files *****/

/*************************
   if((ErrorLookup[ATTRERR].active == 1) && (AttributionAnalysisComplete == 0))
      {
      ConstructFileNames(indirectory, 0);
      CheckAssignedSAC();
      ReleaseFileNames(0);
      AttributionAnalysisComplete = 1;
      AttrErrFile = fopen(attrgigs,"rb");
      if(AttrErrFile != NULL)
         {
         SEEIT_fread_int(&i,AttrErrFile);
         NumAttrErr = i;
         printf("number of recorded attribution discrepancies: %d\n",NumAttrErr);
         if(i > 0)
            {
            AttrErr = (struct AttributionErrors *) (malloc(sizeof(struct AttributionErrors) * i));
            if(AttrErr == NULL)
               {
               printf("allocation memory exhausted during attempt to read attribution errors text descriptions\n");
               exit(-1);
               }
            for(j=0; j<i; j++)
               {
               SEEIT_fread_int(&k,AttrErrFile);
               AttrErr[j].description = (char *) (malloc(k + 5));
               fread(&AttrErr[j].description[0],1,k,AttrErrFile);
               AttrErr[j].description[k] = '\0';
               printf("(%d) %s\n",j+1,AttrErr[j].description);
               }
            SEEIT_fread_int(&j,AttrErrFile);
            SEEIT_fread_int(&k,AttrErrFile);
            while(feof(AttrErrFile) == 0)
               {
               if(AttrErr[k].description[0] != '*')
                  {
                  CrsWlk[j].AttrErr = k;
                  }
               SEEIT_fread_int(&j,AttrErrFile);
               SEEIT_fread_int(&k,AttrErrFile);
               }
            }
         else
            AttrErr = NULL;
         fclose(AttrErrFile);
         }
      else
         {
         printf("severe problem with attribute error analysis, file %s not found\n",attrgigs);
         exit(-1);
         }
      }
********************************/


   CV_Master = NULL; 


   MakeActiveChecks(0);

   NUMBEROFCONDITIONS = 0;

   BucketsOfTransNets = NULL;


   AreaSizeCutoff = RegionSize * RegionSize * 4.0;

   BillBoardChecks = NULL;
   BillBoardChecks2 = NULL;

   portrayfails = NULL;
   PF_Lindex = NULL;
   PF_Iindex = NULL;
   NumberPF = -1;

   /***UseRGridStruct = 1;***/

   abortNow = 0;

   Areal1Shared = NULL;
   Areal2Shared = NULL;
   DHroot = NULL;
   CTCroot = NULL;
   AreaPairRoot = (struct PairsCheckedEntry *) (malloc(sizeof(struct PairsCheckedEntry) * TtlActiveChecks));
   LinePairRoot = (struct PairsCheckedEntry *) (malloc(sizeof(struct PairsCheckedEntry) * TtlActiveChecks));

   LatRoot = NULL;
   LonRoot = NULL;

   if(ATTRTYPE_TREX() == 1)
      ZB060code = GetCodeIndex(TREX_EDGE_POINT_CODE);

   for(i=0; i<TtlActiveChecks; i++)
      {
      AreaPairRoot[i].entry = NULL;
      LinePairRoot[i].entry = NULL;
      }
   SqDistTolerance = 0.0000001;
   DistTolerance = SqDistTolerance * SqDistTolerance;


if(VTEARdebud_3)
InsertCount = VertEdgeCount = EdgeCount = AdjEdgeCount = 0;

   NumberToCheck = (double) ((Uindex1 - Lindex1 + 1) * (Uindex2 - Lindex2 + 1));
   if(NumberToCheck < 3001)
      skiplimit = 150;
   else
      skiplimit = (int) (ceil(NumberToCheck / 20.0));

   LongPolySkipList = (struct LongSkipList *) (malloc(SzSkip * skiplimit));
   LongAreal1SkipList = (struct LongSkipList *) (malloc(SzSkip * skiplimit));
   LongAreal2SkipList = (struct LongSkipList *) (malloc(SzSkip * skiplimit));
   LongAreal3SkipList = (struct LongSkipList *) (malloc(SzSkip * skiplimit));
   LongAreal4SkipList = (struct LongSkipList *) (malloc(SzSkip * skiplimit));
   LongLinearSkipList = (struct LongSkipList *) (malloc(SzSkip * skiplimit));
   LongModelPolySkipList = (struct LongSkipList *) (malloc(SzSkip * skiplimit));
   /**/NeighborLongLinearSkipList = (struct LongSkipList *) (malloc(SzSkip * skiplimit));/***/
       NeighborLongArealSkipList = (struct LongSkipList *) (malloc(SzSkip * skiplimit));
   LongPointSkipList = (struct LongSkipList *) (malloc(SzSkip * skiplimit));
   LongBridgeSkipList = (struct LongSkipList *) (malloc(SzSkip * skiplimit));
   DblPolySkipList = (struct DoublePolySkipList *) (malloc(sizeof(struct DoublePolySkipList) * skiplimit));
   DblPolyEdgeSkipList = (struct DoubleEdgeSkipList *) (malloc(sizeof(struct DoubleEdgeSkipList) * skiplimit));
   DblArealEdgeSkipList = (struct DoubleEdgeSkipList *) (malloc(sizeof(struct DoubleEdgeSkipList) * skiplimit));
   DblModelPolySkipList = (struct DoublePolySkipList *) (malloc(sizeof(struct DoublePolySkipList) * skiplimit));
   DblModelPolyEdgeSkipList = (struct DoubleEdgeSkipList *) (malloc(sizeof(struct DoubleEdgeSkipList) * skiplimit));

   ArealFiles = (struct InputFiles *) (malloc(sizeof(struct InputFiles) * MaxInputFileNumber));
   LinearFiles = (struct InputFiles *) (malloc(sizeof(struct InputFiles) * MaxInputFileNumber));
   for(i=0; i<MaxInputFileNumber; i++)
      {
      ArealFiles[i].fp = NULL;
      ArealFiles[i].isopen = 0;
      LinearFiles[i].fp = NULL;
      LinearFiles[i].isopen = 0;
      }

   multiplier = SignificantDecimals;

   for(i=0; i<skiplimit; i++)
      {
      LongPolySkipList[i].val = -1;
      LongPolySkipList[i].entry = NULL;

      LongAreal1SkipList[i].val = -1;
      LongAreal1SkipList[i].entry = NULL;
      LongAreal2SkipList[i].val = -1;
      LongAreal2SkipList[i].entry = NULL;
      LongAreal3SkipList[i].val = -1;
      LongAreal3SkipList[i].entry = NULL;
      LongAreal4SkipList[i].val = -1;
      LongAreal4SkipList[i].entry = NULL;

      LongLinearSkipList[i].val = -1;
      LongLinearSkipList[i].entry = NULL;
      LongModelPolySkipList[i].val = -1;
      LongModelPolySkipList[i].entry = NULL;
      /***/NeighborLongLinearSkipList[i].val = -1;
      NeighborLongLinearSkipList[i].entry = NULL;/***/
      NeighborLongArealSkipList[i].val = -1;
      NeighborLongArealSkipList[i].entry = NULL;
      LongPointSkipList[i].val = -1;
      LongPointSkipList[i].entry = NULL;
      LongBridgeSkipList[i].val = -1;
      LongBridgeSkipList[i].entry = NULL;
      DblPolySkipList[i].val = -1.0;
      DblPolySkipList[i].entry = NULL;
      DblPolyEdgeSkipList[i].val = -1.0;
      DblPolyEdgeSkipList[i].entry = NULL;
      DblArealEdgeSkipList[i].val = -1.0;
      DblArealEdgeSkipList[i].entry = NULL;
      DblModelPolySkipList[i].val = -1.0;
      DblModelPolySkipList[i].entry = NULL;
      DblModelPolyEdgeSkipList[i].val = -1.0;
      DblModelPolyEdgeSkipList[i].entry = NULL;
      }
   TProot = NULL;
   ARroot = NULL;
   ARlargeRoot = NULL;
   RLroot = NULL;
   NRLroot = NULL;
   NRAroot = NULL;
   RProot = NULL;
   RBroot = NULL;
   MProot = NULL;
   PolyEdgeRoot = NULL;
   VertPolyEdgeRoot = NULL;
   VertArealEdgeRoot = NULL;
   ArealEdgeRoot = NULL;
   ModelPolyEdgeRoot = NULL;
   VertModelPolyEdgeRoot = NULL;
   PolyLODbandCount = NULL;

   unsortout = fopen(unsortlog, "wb");

   if(unsortout == NULL)
      {
      printf("unable to open required output files in the directory %s\n",outdirectory);
      printf("program cannot continue\n");
      printf("please check write permissions and directory status, then restart\n");
      exit(-1);
      }
   write_endian(unsortout);


   HadToOpenFile = 0;
   if(fin == NULL)
      {
      fin = fopen(infile,"rb");
      if(fin == NULL)
         {
         printf("Could not open %s for processing \n",infile);
         printf("   2: No processing can occur without this basic input file\n");
         exit(-1);
         }
      else
         HadToOpenFile = 1;
      }
   arin = fopen(arealsin,"rb");
   Afilenumber = 0;
   ArealFiles[0].fp = arin;
   ArealFiles[0].isopen = 1;


   linin = fopen(linearsin,"rb");
   Lfilenumber = 0;
   LinearFiles[0].fp = linin;
   LinearFiles[0].isopen = 1;

   ptsin = fopen(pointsin,"rb");

   brdgin = fopen(bridgesin,"rb");

   MPin = fopen(MPdatain,"rb");

   BillBoardPtsWritten = 0;
   billbout = NULL;
   billbout2 = NULL;

   abortNow = 0;

   if(ArealFromFile.MaxVerts == 0)
      {
      ArealFromFile.MaxVerts = 5000;
      
      ArealFromFile.x = (double *) (malloc(ArealFromFile.MaxVerts * SzD));
      ArealFromFile.y = (double *) (malloc(ArealFromFile.MaxVerts * SzD));
      ArealFromFile.z = (double *) (malloc(ArealFromFile.MaxVerts * SzD));
      }
   ArealForAreaCalculation.x = (double *) (malloc(ArealFromFile.MaxVerts * SzD));
   ArealForAreaCalculation.y = (double *) (malloc(ArealFromFile.MaxVerts * SzD));
   ArealForAreaCalculation.z = (double *) (malloc(ArealFromFile.MaxVerts * SzD));

   ArealForAreaCalculation.numverts = ArealFromFile.MaxVerts;

   NeedIntersectingArealCalc = 1;
   Areal1ForIntersections = (int *) (malloc(ArealFromFile.MaxVerts * SzI));
   Areal2ForIntersections = (int *) (malloc(ArealFromFile.MaxVerts * SzI));
   Areal1Shared = (int *) (malloc(SzI* ArealFromFile.MaxVerts));
   Areal2Shared = (int *) (malloc(SzI* ArealFromFile.MaxVerts));

   NeedSliverGuide = 1;
   SliverGuide = (struct guide *) (malloc(sizeof(struct guide) * ArealFromFile.MaxVerts));
   if(SliverGuide == NULL)
      {
      printf("memory exhausted during included slivers analysis\n");
      printf("request for %d bytes of memory failed\n",(int) sizeof(struct guide) * ArealFromFile.MaxVerts);
      printf("execution must terminate\n");
      exit(-1);
      }


   if(LinearFromFile.MaxNodes == 0)
      {
      LinearFromFile.MaxNodes = 1000;
      LinearFromFile.x = (double *) (malloc(LinearFromFile.MaxNodes * SzD));
      LinearFromFile.y = (double *) (malloc(LinearFromFile.MaxNodes * SzD));
      LinearFromFile.z = (double *) (malloc(LinearFromFile.MaxNodes * SzD));
      }

   GridFileInUse = -1;


   for(i=0; i<NUM_C; i++)
      {
      CheckByConfig[i] = 0;
      NumObjects[i] = 0.0;
      }


   for(i=0; i<NUM_D; i++)
      {
      CheckByDomain[i] = 0;
      }
   for(i=0; i<NUM_S; i++)
      {
      CheckByStratum[i] = 0;
      }


/**** set these values based on individual items marked to participate in checks ***/
   LoadAttrBndryMatchSet = 0;
   ACBMroot = NULL;

   ShadowElevations = NULL; /*** used as vertex elevations for DEM and Feature checks ***/
   NumShadowElevations = 0;
   CheckThemAll = 0;
   for(j=0; j<=TtlActiveChecks; j++)
      {
      if(ActiveChecks[j].active == 1)
         {
         if((ActiveChecks[j].Config1[C_GRID] == 1) || (ActiveChecks[j].Config2[C_GRID] == 1) ||
               (ActiveChecks[j].Config3[C_GRID] == 1))
            ++CheckThemAll;

         if((ActiveChecks[j].Config1[C_AREA] == 1) || (ActiveChecks[j].Config2[C_AREA] == 1) ||
               (ActiveChecks[j].Config3[C_AREA] == 1))
            ++CheckThemAll;

         if((ActiveChecks[j].Config1[C_LINE] == 1) || (ActiveChecks[j].Config2[C_LINE] == 1) ||
               (ActiveChecks[j].Config3[C_LINE] == 1))
            ++CheckThemAll;
         if((ActiveChecks[j].Config1[C_POFE] == 1) || (ActiveChecks[j].Config2[C_POFE] == 1) ||
               (ActiveChecks[j].Config3[C_POFE] == 1))
            ++CheckThemAll;
         if(LoadAttrBndryMatchSet == 0)
            {
            if((ActiveChecks[j].number == LGEOM_UNM_LAT) ||(ActiveChecks[j].number == LGEOM_UNM_LON) ||
                   (ActiveChecks[j].number == AGEOM_UNM_LAT) || (ActiveChecks[j].number == AGEOM_UNM_LON) ||
                     (ActiveChecks[j].number == AUNM_ATTR_A) || (ActiveChecks[j].number == LUNM_ATTR_A))
               {
               LoadAttrBndryMatchSet = 1;
               ReadAttrBoundaryMatchSpecification();
               }
            }
         
         if(ActiveChecks[j].number == CLAMP_SDC)
            NumShadowElevations = 50000;

         if((CheckLLNOINT == 0) && (ActiveChecks[j].number == LLNOINT))
            CheckLLNOINT = 1;

         if((CheckLNOCOVERLA == 0) && (ActiveChecks[j].number == LNOCOVERLA))
            CheckLNOCOVERLA = 1;

         if((CheckCONFLATE == 0) && (ActiveChecks[j].number == CONFLATE))
            CheckCONFLATE = 1;

         if((ATTRTYPE_MGCP4() > 0) &&
                   (portrayfails == NULL) && (NumberPF < 0) && (ActiveChecks[j].number == PORTRAYF))
            {
            if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
              {
              sprintf(tempstring,"%sinternal_data\\PortrayFailures.bin",indirectory);
              }
            else
              {
              sprintf(tempstring,"%sinternal_data/PortrayFailures.bin",indirectory);
              }
            portrayfails = fopen(tempstring,"rb");
            NumberPF = 0;
            SEEIT_fread_int(&part1,portrayfails);
            SEEIT_fread_int(&part2,portrayfails);
            if(part1 >= 0)
               {
               while(part1 >= 0)
                  {
                  ++NumberPF;
                  SEEIT_fread_int(&part1,portrayfails);
                  SEEIT_fread_int(&part2,portrayfails);
                  }
               }
            if(NumberPF > 0)
               {
               PF_Lindex = (int *) (malloc(SzI * (NumberPF + 1)));
               PF_Iindex = (int *) (malloc(SzI * (NumberPF + 1)));
               ii2 = 0;
               rewind(portrayfails);
               SEEIT_fread_int(&part1,portrayfails);
               SEEIT_fread_int(&part2,portrayfails);
               if(part1 >= 0)
                  {
                  while((part1 >= 0) && (feof(portrayfails) == 0))
                     {
                     PF_Lindex[ii2] = part1;
                     PF_Iindex[ii2] = part2;
                     ++ii2;
                     SEEIT_fread_int(&part1,portrayfails);
                     SEEIT_fread_int(&part2,portrayfails);
                     }
                  NumberPF = ii2;
                  }
               }
            if(portrayfails != NULL)
               fclose(portrayfails);
            }


         if((ATTRTYPE_TDS6() > 0) &&
                   (portrayfails == NULL) && (NumberPF < 0) && (ActiveChecks[j].number == TPORTRAYF))
            {
            if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
              {
              sprintf(tempstring,"%sinternal_data\\PortrayFailures.bin",indirectory);
              }
            else
              {
              sprintf(tempstring,"%sinternal_data/PortrayFailures.bin",indirectory);
              }
            portrayfails = fopen(tempstring,"rb");
            NumberPF = 0;
            SEEIT_fread_int(&part1,portrayfails);
            SEEIT_fread_int(&part2,portrayfails);
            if(part1 >= 0)
               {
               while(part1 >= 0)
                  {
                  ++NumberPF;
                  SEEIT_fread_int(&part1,portrayfails);
                  SEEIT_fread_int(&part2,portrayfails);
                  }
               }
            if(NumberPF > 0)
               {
               PF_Lindex = (int *) (malloc(SzI * (NumberPF + 1)));
               PF_Iindex = (int *) (malloc(SzI * (NumberPF + 1)));
               ii2 = 0;
               rewind(portrayfails);
               SEEIT_fread_int(&part1,portrayfails);
               SEEIT_fread_int(&part2,portrayfails);
               if(part1 >= 0)
                  {
                  while((part1 >= 0) && (feof(portrayfails) == 0))
                     {
                     PF_Lindex[ii2] = part1;
                     PF_Iindex[ii2] = part2;
                     ++ii2;
                     SEEIT_fread_int(&part1,portrayfails);
                     SEEIT_fread_int(&part2,portrayfails);
                     }
                  NumberPF = ii2;
                  }
               }
            if(portrayfails != NULL)
               fclose(portrayfails);
            }


         if((ATTRTYPE_TDS6() > 0) && (CheckCONF_STATS == 0) && (ActiveChecks[j].number == CONF_STATS))
            CheckCONF_STATS = 1;

         if((CheckLSPANFAIL == 0) && (ActiveChecks[j].number == LSPANFAIL))
            CheckLSPANFAIL = 1;

         if((CheckLFNOINT == 0) && (ActiveChecks[j].number == LFNOINT))
            CheckLFNOINT = 1;

         if((FormNetworks == 0) && (ActiveChecks[j].number == EXTRA_NET))
            FormNetworks = 1;
         if((FormNetworks == 0) && (ActiveChecks[j].number == INTRA_NET))
            FormNetworks = 1;
         if((FormNetworks == 0) && (ActiveChecks[j].number == CREATENET))
            FormNetworks = 1;

         if((CheckCOVERFAIL == 0) && (ActiveChecks[j].number == COVERFAIL))
            CheckCOVERFAIL = 1;

         if((CheckDEMSTATS == 0) && (ActiveChecks[j].number == KERNELSTATS))
            CheckDEMSTATS = 1;
         if((CheckDEMSTATS == 0) && (ActiveChecks[j].number == BILINSTATS))
            CheckDEMSTATS = 2;

         if((CheckBNDRYUNDERSHT == 0) && (ActiveChecks[j].number == BNDRYUNDERSHT))
            CheckBNDRYUNDERSHT = 1;

         if((CheckLBNDUSHT == 0) && (ActiveChecks[j].number == LBNDUSHT))
            CheckLBNDUSHT = 1;

         if((CheckAOVERLAPA == 0) && (ActiveChecks[j].number == AOVERLAPA))
            CheckAOVERLAPA = 1;

         if((CheckFEATOUTSIDE == 0) && (ActiveChecks[j].number == FEATOUTSIDE))
            CheckFEATOUTSIDE = 1;

         if((CheckOBJECTWITHOUT == 0) && (ActiveChecks[j].number == OBJECTWITHOUT))
            CheckOBJECTWITHOUT = 1;

         if((CheckOBJ_WO_TWO == 0) && (ActiveChecks[j].number == OBJ_WO_TWO))
            CheckOBJ_WO_TWO = 1;

         if((CheckAWITHOUTA == 0) && (ActiveChecks[j].number == AWITHOUTA))
            CheckAWITHOUTA = 1;

         if((CheckFSFAIL == 0) && (ActiveChecks[j].number == FSFAIL))
            CheckFSFAIL = 1;

         if((CheckCOINCIDEFAIL == 0) && (ActiveChecks[j].number == COINCIDEFAIL))
            CheckCOINCIDEFAIL = 1;

         if((CheckISOLATEDA == 0) && (ActiveChecks[j].number == ISOLATEDA))
            CheckISOLATEDA = 1;

         if((CheckNETISOA == 0) && (ActiveChecks[j].number == NETISOA))
            CheckNETISOA = 1;

         if((CheckANETISOA == 0) && (ActiveChecks[j].number == ANETISOA))
            CheckANETISOA = 1;

         if((BucketsOfTransNets == NULL) && (ActiveChecks[j].number == NETISOFEAT))
            InitializeBucketsOfTransNets();

         if((CheckPSHAREFAIL == 0) && (ActiveChecks[j].number == PSHAREFAIL))
            CheckPSHAREFAIL = 1;

         if((CheckNOCOINCIDE == 0) && (ActiveChecks[j].number == NOCOINCIDE))
            CheckNOCOINCIDE = 1;

         if((CheckCONNECTFAIL == 0) && (ActiveChecks[j].number == CONNECTFAIL))
            CheckCONNECTFAIL = 1;

         if((CheckNOENDCON == 0) && (ActiveChecks[j].number == NOENDCON))
            CheckNOENDCON = 1;

         if((CheckISOLINE == 0) && (ActiveChecks[j].number == ISOLINE))
            CheckISOLINE = 1;

         if((CheckBOTHENDCON == 0) && (ActiveChecks[j].number == BOTHENDCON))
            CheckBOTHENDCON = 1;

         if((CheckPERIMLEN == 0) && (ActiveChecks[j].number == PERIMLEN))
            CheckPERIMLEN = 1;

         if((CheckSMALLAREA == 0) && (ActiveChecks[j].number == SMALLAREA))
            CheckSMALLAREA = 1;
         if((CheckSMLCUTOUT == 0) && (ActiveChecks[j].number == SMLCUTOUT))
            CheckSMLCUTOUT = 1;

         if((CheckAREAKINK == 0) && (ActiveChecks[j].number == AREAKINK))
            CheckAREAKINK = 1;

         if((CheckSEGLEN == 0) && (ActiveChecks[j].number == SEGLEN))
            CheckSEGLEN = 1;

         if((CheckLENOCOVERL == 0) && (ActiveChecks[j].number == LENOCOVERL))
            CheckLENOCOVERL = 1;

         if((CheckNOLCOVLE == 0) && (ActiveChecks[j].number == NOLCOVLE))
            CheckNOLCOVLE = 1;

         if((CheckLENOCOVERP == 0) && (ActiveChecks[j].number == LENOCOVERP))
            CheckLENOCOVERP = 1;

         if((CheckLLNONODEINT == 0) && (ActiveChecks[j].number == LLNONODEINT))
            CheckLLNONODEINT = 1;

         if((NumberOfGrids > 0) && (GridHeader != NULL) && (CheckMASKMONO == 0) && (ActiveChecks[j].number == MASKMONO))
            CheckMASKMONO = 1;

         if((CheckShoots == 0) && ((ActiveChecks[j].number == LUNDERSHTL) ||
                                   (ActiveChecks[j].number == LOVERSHTL) ||
                                   (ActiveChecks[j].number == LUSHTL_DF) ||
                                   (ActiveChecks[j].number == LOSHTL_DF)))
            {
            CheckShoots = 1;
            }

         if((OnBoundaryExclude == 0)  && (ActiveChecks[j].UseBorderConds == 0))
            {
            OnBoundaryExclude = 1;
            }

         if(CheckMultiParts == 0)
            {
            if(ActiveChecks[j].number == MULTIPARTL)
               CheckMultiParts = 1;
            else if(ActiveChecks[j].number == MULTIPARTA)
               CheckMultiParts = 1;
            else if(ActiveChecks[j].number == MULTIPARTP)
               CheckMultiParts = 1;
            }

         if((NGA_TYPE == 1) && (CheckNGA_Attributes == 0))
            {
            if(ActiveChecks[j].number == ATTR_PAIR)
               CheckNGA_Attributes = 1;
            else if(ActiveChecks[j].number == RPTD_ATTR)
               CheckNGA_Attributes = 1;
            else if(ActiveChecks[j].number == ATTR_UNEXP)
               CheckNGA_Attributes = 1;
            else if(ActiveChecks[j].number == ATTR_VVT)
               CheckNGA_Attributes = 1;
            else if(ActiveChecks[j].number == ATTR_RNULL)
               CheckNGA_Attributes = 1;
            else if(ActiveChecks[j].number == ATTR_MISSING)
               CheckNGA_Attributes = 1;
            else if(ActiveChecks[j].number == ATTR_DT)
               CheckNGA_Attributes = 1;
            else if(ActiveChecks[j].number == ATTR_RNG)
               CheckNGA_Attributes = 1;
            else if(ActiveChecks[j].number == ATTR_PICK)
               CheckNGA_Attributes = 1;
            else if(ActiveChecks[j].number == ATTR_META)
               CheckNGA_Attributes = 1;
            }

         if(ActiveChecks[j].participants >= 1)
            {
	      if(ActiveChecks[j].primaryEDCSstuff != NULL)
		{
		  for(k=0; k<SACfull; k++)
		    {
		      if(ActiveChecks[j].primaryEDCSstuff[k] == 1)
			{
			  if(CrsWlk[k].LtoSmapping >= 0)
			    {
			      i = CrsWlk[k].LtoSmapping;
			      if(ActiveChecks[j].Config1[SCCtable[i].C] != 2)
				{
				  CheckByConfig[SCCtable[i].C] = 1;
				  CheckByStratum[SCCtable[i].S] = 1;
				  CheckByDomain[SCCtable[i].D] = 1;
				}
			    }
			}
		    }
		}

	      if(ActiveChecks[j].primaryFIDstuff != NULL)
		{
		  for(k=0; k<LLFidTableCount; k++)
		    {
		      if(ActiveChecks[j].primaryFIDstuff[k] == 1)
			{
			  if(CrsWlk[LLFidTable[k]].LtoSmapping >= 0)
			    {
			      i = CrsWlk[LLFidTable[k]].LtoSmapping;
			      if(ActiveChecks[j].Config1[SCCtable[i].C] != 2)
				{
				  CheckByConfig[SCCtable[i].C] = 1;
				  CheckByStratum[SCCtable[i].S] = 1;
				  CheckByDomain[SCCtable[i].D] = 1;
				}
			    }
			}
		    }
		}
            }
	 




         if(ActiveChecks[j].participants >= 2)
	   {
	     if(ActiveChecks[j].secondaryEDCSstuff != NULL)
               {
		 for(k=0; k<SACfull; k++)
		   {
		     if(ActiveChecks[j].secondaryEDCSstuff[k] == 1)
		       {
			 i = CrsWlk[k].LtoSmapping;
			 if((i >= 0) && (ActiveChecks[j].Config2[SCCtable[i].C] != 2))
			   {
			     CheckByConfig[SCCtable[i].C] = 1;
			     CheckByStratum[SCCtable[i].S] = 1;
			     CheckByDomain[SCCtable[i].D] = 1;
			   }
		       }
		   }
               }

	     if(ActiveChecks[j].secondaryFIDstuff != NULL)
	       {
		 for(k=0; k<LLFidTableCount; k++)
		   {
		     if(ActiveChecks[j].secondaryFIDstuff[k] == 1)
		       {
			 if(CrsWlk[LLFidTable[k]].LtoSmapping >= 0)
			   {
			     i = CrsWlk[LLFidTable[k]].LtoSmapping;
			     if(ActiveChecks[j].Config2[SCCtable[i].C] != 2)
			       {
				 CheckByConfig[SCCtable[i].C] = 1;
				 CheckByStratum[SCCtable[i].S] = 1;
				 CheckByDomain[SCCtable[i].D] = 1;
			       }
			   }
		       }
		   }
	       }
	   }


         if(ActiveChecks[j].participants > 2)
	   {
           if(ActiveChecks[j].number == AOVERLAPA)
              {
/** i have overloaded use of the sensitivity6 field to save time and space for this check and the
    potential need to call function RemoveCheckedAreaPair - this should only be necessary a very
    few times and don't want to make this an expensive solution ****/
              if(ActiveChecks[j].numthresholds > 5)  /** problem - can't overload sensitivity6 any more ***/
                 {
                 printf("\n\n\nneed to rethink overload of sensitivity6 field for AOVERLAPA\n\n\n");
                 exit(-1);
                 }
              ActiveChecks[j].sensitivity6 = 0;  /** this is flag to skip the call - reset below as needed ***/
              }
	     if(ActiveChecks[j].tertiaryEDCSstuff != NULL)
               {
		 for(k=0; k<SACfull; k++)
		   {
		     if(ActiveChecks[j].tertiaryEDCSstuff[k] == 1)
		       {
                       if(ActiveChecks[j].number == AOVERLAPA)
                          ActiveChecks[j].sensitivity6 = 1; /** some tertiary turned on, so RemoveCheckedAreaPair may be necessary ***/
			 i = CrsWlk[k].LtoSmapping;
			 if((i >= 0) && (ActiveChecks[j].Config3[SCCtable[i].C] != 2))
			   {
			     CheckByConfig[SCCtable[i].C] = 1;
			     CheckByStratum[SCCtable[i].S] = 1;
			     CheckByDomain[SCCtable[i].D] = 1;
			   }
		       }
		   }
               }

	     if(ActiveChecks[j].tertiaryFIDstuff != NULL)
	       {
		 for(k=0; k<LLFidTableCount; k++)
		   {
		     if(ActiveChecks[j].tertiaryFIDstuff[k] == 1)
		       {
			 if(CrsWlk[LLFidTable[k]].LtoSmapping >= 0)
			   {
			     i = CrsWlk[LLFidTable[k]].LtoSmapping;
			     if(ActiveChecks[j].Config3[SCCtable[i].C] != 2)
			       {
				 CheckByConfig[SCCtable[i].C] = 1;
				 CheckByStratum[SCCtable[i].S] = 1;
				 CheckByDomain[SCCtable[i].D] = 1;
			       }
			   }
		       }
		   }
	       }
	   }
         }
      }

   if(NumShadowElevations > 0)
      {
      ShadowElevations = (double *) (malloc(SzD * NumShadowElevations));
      for(i=0; i<NumShadowElevations; i++)
         ShadowElevations[i] = -59999.90909;
      }

   if((CheckPERIMLEN > 0) || (CheckSEGLEN > 0) || (CheckSMALLAREA > 0) ||   (CheckAREAKINK > 0) ||
         (CheckLENOCOVERL > 0) || (CheckLENOCOVERP > 0) || (CheckNOLCOVLE > 0) ||
         (CheckOBJECTWITHOUT > 0) || (CheckOBJ_WO_TWO > 0) || (CheckShoots > 0) || (CheckSMLCUTOUT > 0) || (CheckLLNONODEINT > 0))
      {
      for(i=0; i<NUM_C; i++)
         {
         CheckByConfig[i] = 1;
         }
      }
   

   for(i=0; i<NUM_C; i++)
      {
      if(CheckByConfig[i] == 0)
         {
         for(j=0; j<=TtlActiveChecks; j++)
            {
            if(ActiveChecks[j].active == 1)
               {
		if(ActiveChecks[j].Config1[i] == 1)
                  {
                  CheckByConfig[i] = 1;
                  break;
                  }
               else if(ActiveChecks[j].Config2[i] == 1)
                  {
                  CheckByConfig[i] = 1;
                  break;
                  }
               else if(ActiveChecks[j].Config3[i] == 1)
                  {
                  CheckByConfig[i] = 1;
                  break;
                  }
               }
            }
         }
      }

   if(OnBoundaryExclude > 0)
      CheckByConfig[C_POFE] = CheckByConfig[C_LINE] = CheckByConfig[C_AREA] = 1;


   for(i=0; i<NUM_D; i++)
      {
      if(OnBoundaryExclude > 0)
         CheckByDomain[i] = 1;

      if(CheckByDomain[i] == 0)
         {
         for(j=0; j<=TtlActiveChecks; j++)
            {
            if(ActiveChecks[j].active == 1)
               {
               if(ActiveChecks[j].Domain1[i] == 1)
                  {
                  CheckByDomain[i] = 1;
                  break;
                  }
               else if(ActiveChecks[j].Domain2[i] == 1)
                  {
                  CheckByDomain[i] = 1;
                  break;
                  }
               else if(ActiveChecks[j].Domain3[i] == 1)
                  {
                  CheckByDomain[i] = 1;
                  break;
                  }
               }
            }
         }
      }
   for(i=0; i<NUM_S; i++)
      {
      if(OnBoundaryExclude > 0)
         CheckByStratum[i] = 1;

      if(CheckByStratum[i] == 0)
         {
         for(j=0; j<=TtlActiveChecks; j++)
            {
            if(ActiveChecks[j].active == 1)
               {
               if(ActiveChecks[j].Stratum1[i] == 1)
                  {
                  CheckByStratum[i] = 1;
                  break;
                  }
               else if(ActiveChecks[j].Stratum2[i] == 1)
                  {
                  CheckByStratum[i] = 1;
                  break;
                  }
               else if(ActiveChecks[j].Stratum3[i] == 1)
                  {
                  CheckByStratum[i] = 1;
                  break;
                  }
               }
            }
         }
      }


   if((CheckLLNOINT > 0) || (CheckLFNOINT > 0) || (CheckOBJECTWITHOUT > 0) || (CheckAWITHOUTA > 0) || (CheckLNOCOVERLA) ||
         (CheckPSHAREFAIL > 0) || (CheckNOENDCON > 0) || (CheckPERIMLEN > 0) || (CheckSMLCUTOUT > 0) ||
         (CheckBOTHENDCON > 0) || (CheckOBJ_WO_TWO > 0) || (CheckISOLINE > 0) ||
         (CheckSMALLAREA > 0) || (CheckFACESIZE > 0) || (CheckLSPANFAIL > 0) || (CheckCONFLATE > 0) ||
        (CheckISOLATEDA > 0) || (CheckNOCOINCIDE > 0) || (CheckCOINCIDEFAIL > 0) || (CheckFSFAIL > 0) || (CheckCONNECTFAIL > 0))
      {
      Check_RB_Tree = RBTreeCreate(DblComp,IntDest,InfoDest,IntPrint,InfoPrint);
      }

   if((CheckNETISOA > 0) || (CheckANETISOA > 0))
      {
      Trans_RB_Tree = RBTreeCreate(DblComp,IntDest,TransInfoDest,IntPrint,InfoPrint);
      }

   if((ATTRTYPE_TDS6() > 0) && (CheckCONF_STATS > 0))
      {
      Stats_RB_Tree = RBTreeCreate(TTF_StdStrComp,ConStatsStrDest,ConStatsInfoDest,IntPrint,InfoPrint);
      InitConflateStatsCapture();
      }

   if((CheckMASKMONO > 0) && (NumberOfGrids > 0) && (GridHeader != NULL))
      {
      for(j=0; j<=TtlActiveChecks; j++)
         {
         if((ActiveChecks[j].active == 1) && (ActiveChecks[j].number == MASKMONO))
            {
            for(ii = 0; ii < SACfull; ii++)
               {
               if(ActiveChecks[j].primaryEDCSstuff[ii] == 1)
                  {
                  for(i=0; i < NumberOfGrids; i++)
                     {
                     if(GridHeader[i].Lindex == ii)
                        {
                        FlowFlags.Lindex = GridHeader[i].Lindex;
                        FlowFlags.NumX = GridHeader[i].Xpts;
                        FlowFlags.NumY = GridHeader[i].Ypts;
                        FlowFlags.Xspacing = GridHeader[i].Xspacing;
                        FlowFlags.Yspacing = GridHeader[i].Yspacing;
                        FlowFlags.Cindex = j;
                        FlowFlags.GridHeadIndex = i;
                        jj = FlowFlags.NumX * FlowFlags.NumY;
                        if(FlowFlags.PointFlow != NULL)
                           free(FlowFlags.PointFlow);
                        FlowFlags.PointFlow = (char *) (malloc(jj));
                        if(FlowFlags.PointFlow != NULL)
                           {
                           for(kk = 0; kk < jj; kk++)
                              FlowFlags.PointFlow[kk] = 0;
                           }
                        else
                           {
                           printf("\n\ninsufficient memory to perform DEM / Drain Monotonicity inspection\n");
                           exit(-1);
                           }
                        break;
                        }
                     }
                  }
               }
            }
         }
      }


           ReadMultiPartObjects();  /*** have to do this to get the checked objects count straight ***/

           if((NGA_TYPE > 0) && (ErrorLookup[ANY_SAMEID].anyactive > 0)) /** need to set up the duplicate UUID array ***/
              {
              IDProb = fopen(IDproblems,"rt");
              if(IDProb == NULL)
                 {
                 ID_O_count = 0;
                 ID_O = NULL;
                 }
              else
                 {
                 fgets(tempstring,400,IDProb);
                 sscanf(tempstring,"%d",&ID_O_count);
                 if(ID_O_count > 0)
                    {
                    ID_O = (struct OverlapID *) (malloc(sizeof(struct OverlapID) * (ID_O_count + 1)));
                    if(ID_O == NULL)
                       {
                       printf("Allocation memory exhausted during unique identifier inspection preparation\n");
                       printf("            inspection for unique identifiers will not be performed\n");
                       }
                    else
                       {
                       i = 0;
                       fgets(tempstring,400,IDProb);
                       while(feof(IDProb) == 0)
                          {
                          j = 0;
                          
                          while(tempstring[j] > ' ')  /* should skip over the first word, 'String'   ***/
                             ++j;
                          ++j;
                          while(tempstring[j] > ' ')  /* should skip over the second word, 'Length'   ***/
                             ++j;
                          ++j;  /*** should now be on the first character of the string length   ***/
                          k = 0;
                          while((tempstring[j] >= '0') && (tempstring[j] <= '9'))
                             {
                             k = k * 10 + (tempstring[j] - 48);
                             ++j;
                             }
                          /** should now be on the blank space between the # of characters and the word 'characters:' ***/
                          ++j;
                          while(tempstring[j] > ' ')  /* should skip over the word, 'characters:'   ***/
                             ++j;
                         /** should now be on the blank space between the word 'characters:' and the start of the ID string***/
                          ++j; /*** now of the first character of the ID string ***/
                          tempstring[j+k] = '\0';
                          
                          ID_O[i].IDstr = (char * ) (malloc(k+2));

                          strcpy(ID_O[i].IDstr,&tempstring[j]);
                          ID_O[i].inst = NULL;
                          ++i;
                          fgets(tempstring,400,IDProb);
                          }
                       }
                    }
                 else
                    ID_O = NULL;
                 fclose(IDProb);
                 }
              }


	   if(CheckNGA_Attributes > 0)
	      {
	      ReadRecordedAttributionErrorIndices();
	      }

	   if((CheckByConfig[7] == 0) || (CheckByConfig[9] == 0))
	      {
	      if((ErrorLookup[LJOINSLOPEDC].anyactive > 0) && (CLAMPFEATURES > 0))
		{
		++CheckByConfig[7];
		++CheckByConfig[9];
		++CheckByStratum[5];
		++CheckByDomain[11];
		}
	      else if((ErrorLookup[SLOPEDIRCH].anyactive > 0) && (CLAMPFEATURES > 0))
		{
		++CheckByConfig[7];
		++CheckByConfig[9];
		++CheckByStratum[5];
		++CheckByDomain[11];
		}
	      }

	   TearRoot = NULL;


	   index1Min = (double) Lindex1 * RegionSize;
	   index1Max = (double) Uindex1 * RegionSize + RegionSize;
	   index2Min = (double) Lindex2 * RegionSize;
	   index2Max = (double) Uindex2 * RegionSize + RegionSize;

	   gridfilein = NULL;


	   if(RemoveDupsBeforeCheck > 0)
	      UseDupThreshold = 4;
	   else
	      UseDupThreshold = 6;


           LAEroot = NULL;
           KnownRoot = NULL;
           TtlCoverFailures = 0;

           if(ErrorLookup[CALC_AREA].anyactive > 0)
              {
              OKtoCheck = GetApplicableLengthWidthCodes(&LENcode, &WIDcode);
              }
           else LENcode = WIDcode = -1;

           if((CheckCOVERFAIL > 0) || (CheckFEATOUTSIDE > 0) || 
                     (CheckBNDRYUNDERSHT > 0) || (CheckLBNDUSHT > 0))
              {
		
		LAEminx = RoundToNearestWholeDegree(1,MinXcoord);
		LAEmaxx = RoundToNearestWholeDegree(1,MaxXcoord);
		LAEminy = RoundToNearestWholeDegree(2,MinYcoord);
		LAEmaxy = RoundToNearestWholeDegree(2,MaxYcoord);

                CF_LAEminx = LAEminx;
                CF_LAEmaxx = LAEmaxx;
                CF_LAEminy = LAEminy;
                CF_LAEmaxy = LAEmaxy;

		if(LAEminx==LAEmaxx)
		  {
			if(RoundInt(RoundToNearestWholeDegree(1,MinXcoord)/100000.0 + Xtranslation)>=0)
			{
		      LAEminx = ( (int)MinNativeX - Xtranslation)*100000.0;
		      LAEmaxx = (((int)MinNativeX + 1.0)- Xtranslation)*100000.0;
			}
			else
			{
		      LAEmaxx = ( (int)MinNativeX - Xtranslation)*100000.0;
		      LAEminx = (((int)MinNativeX - 1.0)- Xtranslation)*100000.0;
			}
		  }
		if(LAEminy==LAEmaxy)
		  {
			if(RoundInt(RoundToNearestWholeDegree(2,MinYcoord)/100000.0 + Ytranslation)>=0)
			{
		      LAEminy = ( (int)MinNativeY - Ytranslation)*100000.0;
		      LAEmaxy = (((int)MinNativeY + 1.0)- Ytranslation)*100000.0;
			}
			else
			{
		      LAEmaxy = ( (int)MinNativeY - Ytranslation)*100000.0;
		      LAEminy = (((int)MinNativeY - 1.0)- Ytranslation)*100000.0;
			}
		  }					
              }

    

	   sprintf(portiondone,"0%% complete\n");
	   periodic_checking_redraw(1,"Inspection Progress",portiondone);

           CTD = (struct ConditionList *) (malloc(sizeof(struct ConditionList)));
           if(CTD == NULL)
             return;
           CstatsOut = NULL;
           if(CheckCONF_STATS > 0)
              {
              CSc = CSroot;
              while(CSc != NULL)
                 {
                 if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
                    {
                    sprintf(tempstring2,"%spoints_of_interest_files\\InformativeAttrFile_%d.txt",indirectory,CSc->fileindex);
                    }
                 else
                    {
                    sprintf(tempstring2,"%spoints_of_interest_files/InformativeAttrFile_%d.txt",indirectory,CSc->fileindex);
                    }
                 CstatsOut = fopen(tempstring2,"wt");
                 fprintf(CstatsOut,"1\n");
                 fclose(CstatsOut);
                 CstatsOut = NULL;
                 CSc = CSc->next;
                 }
              }

	   for(index1 = Lindex1; index1 <= Uindex1; index1++)
	      {
              if(NUMBEROFCONDITIONS >= CONDITION_LIMIT)
                 {
                 sprintf(portiondone,"%.1lf%% complete\n",regionscomplete / NumberToCheck);
                 abortNow = 1;
                 STOP_FLAG = 1;
                 }

	      minx = (double) index1 * RegionSize;
	      maxx = minx + RegionSize;

	      for(index2 = Lindex2; index2 <= Uindex2; index2++)
		 {
                 if(NUMBEROFCONDITIONS >= CONDITION_LIMIT)
                    {
                    sprintf(portiondone,"%.1lf%% complete\n",regionscomplete / NumberToCheck);
                    abortNow  = 1;
                    STOP_FLAG = 1;
                    }

		 compositeindex = (index1 * (MaxYindex + 1)) + index2;
                 if(CheckThemAll == 0)
                    {
                    DoNotSkipThisLM = 0;
                    for(ii2=0; ii2 < LindexTable[compositeindex].inside; ii2++)
                       {
                       for(jj2  =0; jj2 < TtlActiveChecks; jj2++)
                          {
                          if(((ActiveChecks[jj2].primaryEDCSstuff != NULL) &&
                                     (ActiveChecks[jj2].primaryEDCSstuff[LindexTable[compositeindex].indices[ii2]] == 1)) ||
                             ((ActiveChecks[jj2].secondaryEDCSstuff != NULL) &&
                                      (ActiveChecks[jj2].secondaryEDCSstuff[LindexTable[compositeindex].indices[ii2]] == 1)) ||
                                ((ActiveChecks[jj2].tertiaryEDCSstuff != NULL) &&
                                       (ActiveChecks[jj2].tertiaryEDCSstuff[LindexTable[compositeindex].indices[ii2]] == 1)))
                             {
                             DoNotSkipThisLM = 1;
                             break;
                             }
                          if(ActiveChecks[jj2].primaryFIDstuff != NULL)
                            {
                              for(kk3=0; kk3<LLFidTableCount; kk3++)
                                {
                                  if(ActiveChecks[jj2].primaryFIDstuff[kk3] == 1)
                                    {
                                      if(CrsWlk[LLFidTable[kk3]].LtoSmapping >= 0)
                                        {
                                          kk2 = CrsWlk[LLFidTable[kk3]].LtoSmapping;
                                          if(ActiveChecks[jj2].Config1[SCCtable[kk2].C] != 2)
                                            {
                                            DoNotSkipThisLM = 1;
                                            break;
                                            }
                                        }
                                    }
                                }
                            }
                          }
                       if(DoNotSkipThisLM > 0)
                          break;
                       }
                    if(DoNotSkipThisLM == 0)
                       {
                       regionscomplete += 100.0;/** adding 100 instead of 1 to avoid mult by 100 to get percent complete **/
                       continue;
                       }
                    }
                 kk = index1 - 1;
                 if(kk < 0)
                    WestNeighborCount = -1;
                 else
                    WestNeighborCount = 0;
                 kkk = 1;
                 while(kkk < 25)
                    {
                    kk = index1 - kkk;
                    if(kk >= 0)
                       {
                       k = (kk * (MaxYindex + 1)) + index2;
                       WestNeighborCount += ArealTable[k].numother + ArealTable[k].numinside + LinearTable[k].numother + LinearTable[k].numinside +
                          PointTable[k].numother + PointTable[k].numinside;
                       }
                    else
                       break;
                    ++kkk;
                    }
                 //EastNeighborCount = -1;
                 kk = index1 + 1;
                 if(kk > MaxXindex)
                    EastNeighborCount = -1;
                 else
                    EastNeighborCount = 0;
                 kkk = 1;
                 while(kkk < 25)
                    {
                    kk = index1 + kkk;
                    if(kk <= MaxXindex)
                       {
                       k = (kk * (MaxYindex + 1)) + index2;
                       EastNeighborCount += ArealTable[k].numother + ArealTable[k].numinside + LinearTable[k].numother + LinearTable[k].numinside +
                          PointTable[k].numother + PointTable[k].numinside;
                       }
                    else
                       break;
                    ++kkk;
                    }
                 kk = index2 + 1;
                 if(kk > MaxYindex)
                    NorthNeighborCount = -1;
                 else
                    NorthNeighborCount = 0;
                 kkk = 1;
                 while(kkk < 25)
                    {
                    kk = index2 + kkk;
                    if(kk <= MaxYindex)
                       {
                       k = (index1 * (MaxYindex + 1)) + kk;
                       NorthNeighborCount += ArealTable[k].numother + ArealTable[k].numinside + LinearTable[k].numother + LinearTable[k].numinside +
                          PointTable[k].numother + PointTable[k].numinside;
                       }
                    else
                       break;
                    ++kkk;
                    }
                 kk = index2 - 1;
                 if(kk < 0)
                    SouthNeighborCount = -1;
                 else
                    SouthNeighborCount = 0;
                 kkk = 1;
                 while(kkk < 25)
                    {
                    kk = index2 - kkk;
                    if(kk >= 0)
                       {
                       k = (index1 * (MaxYindex + 1)) + kk;
                       SouthNeighborCount += ArealTable[k].numother + ArealTable[k].numinside + LinearTable[k].numother + LinearTable[k].numinside +
                          PointTable[k].numother + PointTable[k].numinside;
                       }
                    else
                       break;
                    ++kkk;
                    }

		 
		 miny = (double) index2 * RegionSize;
		 maxy = miny + RegionSize;

                 if(LAEroot != NULL)
                    {
                    PruneLandCoverErrorList(minx,maxx,miny,maxy);
                    }


	/*** any grid related checks ?? ****/
		 gridLODSchecked = 0;
		 Gcols = Grows = 0;
                 GridNowLoaded = -100;
		 if((CheckByConfig[9] > 0) && (NumberOfGrids > 0) && (abortNow == 0))
		    {
		    if((NGT[compositeindex].NumGrids > 0) && (GridFileInUse != NGT[compositeindex].FileNumber[0]))
		       {
		       if(gridfilein != NULL)
			  CloseGridFile(gridfilein);
		       gridfilein = OpenGridFile(compositeindex,0);
		       }
		    if(gridfilein != NULL)
		       {
                                for(jjj=0; jjj<MaxGridsPerRegion; jjj++)
                                   {
                                   MG[jjj].numX = 0;
                                   MG[jjj].numY = 0;
                                   }

		       for(i=0; i<NGT[compositeindex].NumGrids; i++)
			  {
                          if(GridFileInUse != NGT[compositeindex].FileNumber[i])
                             {
                             if(gridfilein != NULL)
                                CloseGridFile(gridfilein);
                             gridfilein = OpenGridFile(compositeindex,i);
                             }
			  ii2 = NGT[compositeindex].GridIndex[i];
			  jj = 1;
			  if((SCCtable[GridHeader[ii2].Sindex].S == 5) && (jj > 0)) /** an active (by LOD) surface grid **/
			     {
                             if(NGT[compositeindex].NumRows[i] > 0)
                                {
                                if(NGT[compositeindex].fileptr[i] >= 0)
				   {
				   Grows = ReadGridFromFile(ii2,gridfilein, multiplier,compositeindex,NumberOfGrids,&Gcols,&LoadedGridMres);
				   GridNowLoaded = compositeindex;
				   LoadedGridRows = Grows;
				   LoadedGridCols = Gcols;

				   for(kk=0; kk<MaxGridsPerRegion; kk++)
				      {
                                      temp = 0;
				      if(/**/(MG[kk].actualindex == ii2) &&/**/ (MG[kk].numX > 0) && (MG[kk].numY > 0))
					 {
                                         for(Grows = 0; Grows < MG[kk].numX; Grows++)
					    {
					    XG = MG[kk].SouthWestX + ((double) Grows * MG[kk].Xspace);
					    if((XG >= minx) && (XG <= maxx))
					       {
                                               for(Gcols = 0; Gcols < MG[kk].numY; Gcols++)
						  {
						  YG = MG[kk].SouthWestY + ((double) Gcols * MG[kk].Yspace);
						  if((YG>= miny) && (YG <= maxy))
						     {
						     temp += 1.0;
						     }
						  }
					       }
					    }
                                         NumObjects[9] += temp;
					 }
				      }
				   }
				for(checkinstance = 0; checkinstance < TtlActiveChecks; checkinstance++)
				   {
				   if((i < NumberOfGrids) &&
				     (CombinedCheckApplies(GridHeader[ii2].idn,checkinstance,GSPIKE,GridHeader[ii2].Lindex,
							   GridHeader[ii2].Sindex,C_GRID /** config must be grid **/,
					   SCCtable[GridHeader[ii2].Sindex].S,SCCtable[GridHeader[ii2].Sindex].D, 
							   &part1,&part2,&part3)) && (part1 > 0)) 
				      {
				      CheckGridForSpikes(GridHeader[ii2].idn,GridHeader[ii2].Sindex,GridHeader[ii2].Lindex,
                                                         Grows, Gcols,
							 checkinstance,ii2,minx,miny,maxx,maxy);
				      }

                                   if((i < NumberOfGrids) &&
                                     (CombinedCheckApplies(GridHeader[ii2].idn,checkinstance,RAISEDPC,GridHeader[ii2].Lindex,
                                                           GridHeader[ii2].Sindex,C_GRID /** config must be grid **/,
                                           SCCtable[GridHeader[ii2].Sindex].S,SCCtable[GridHeader[ii2].Sindex].D,
                                                           &part1,&part2,&part3)) && (part2 > 0))
                                      {
                                      for(EDMindex=0; EDMindex<NGT[compositeindex].NumGrids; EDMindex++)
                                         {
                                         ii5 = NGT[compositeindex].GridIndex[EDMindex];
                                         if((CombinedCheckApplies(GridHeader[ii5].idn,checkinstance,RAISEDPC,GridHeader[ii5].Lindex,
                                                           GridHeader[ii5].Sindex,C_GRID /** config must be grid **/,
                                           SCCtable[GridHeader[ii5].Sindex].S,SCCtable[GridHeader[ii5].Sindex].D,
                                                           &part1,&part2,&part3)) && (part1 > 0))
                                            break;
                                         }
                                      if(EDMindex < NGT[compositeindex].NumGrids)
                                         {
                                         CheckShorelineForRaisedPC(GridHeader[ii2].idn,GridHeader[ii2].Sindex,GridHeader[ii2].Lindex,
                                                         Grows, Gcols,
                                                         checkinstance,ii2,EDMindex,minx,miny,maxx,maxy);
                                         }
                                      }



				   if((i < NumberOfGrids) &&
				     (CombinedCheckApplies(GridHeader[ii2].idn,checkinstance,ELEVGT,GridHeader[ii2].Lindex,
							   GridHeader[ii2].Sindex,C_GRID /** config must be grid **/,
					   SCCtable[GridHeader[ii2].Sindex].S,SCCtable[GridHeader[ii2].Sindex].D,
							   &part1,&part2,&part3)) && (part1 > 0))
				      {
				      CheckGridForElevationValues(GT,GridHeader[ii2].idn,GridHeader[ii2].Sindex,GridHeader[ii2].Lindex,Grows, Gcols,
								  checkinstance,ii2,minx,miny,maxx,maxy);
				      }


				   if((i < NumberOfGrids) &&
				     (CombinedCheckApplies(GridHeader[ii2].idn,checkinstance,ELEVLT,GridHeader[ii2].Lindex,
							   GridHeader[ii2].Sindex,C_GRID /** config must be grid **/,
					   SCCtable[GridHeader[ii2].Sindex].S,SCCtable[GridHeader[ii2].Sindex].D, 
							   &part1,&part2,&part3)) && (part1 > 0))
				      {
				      CheckGridForElevationValues(LT,GridHeader[ii2].idn,GridHeader[ii2].Sindex,GridHeader[ii2].Lindex,Grows, 
								  Gcols,checkinstance,ii2,minx,miny,maxx,maxy);
				      }


				   if((i < NumberOfGrids) &&
				     (CombinedCheckApplies(GridHeader[ii2].idn,checkinstance,ELEVEQ,GridHeader[ii2].Lindex,
							   GridHeader[ii2].Sindex,C_GRID /** config must be grid **/,
					   SCCtable[GridHeader[ii2].Sindex].S,SCCtable[GridHeader[ii2].Sindex].D, 
							   &part1,&part2,&part3)) && (part1 > 0))
				      {
				      CheckGridForElevationValues(CLOSEDINT,GridHeader[ii2].idn,GridHeader[ii2].Sindex,GridHeader[ii2].Lindex, Grows,
								  Gcols,checkinstance,ii2,minx,miny,maxx,maxy);
				      }
                                   if((i < NumberOfGrids) &&
                                     (CombinedCheckApplies(GridHeader[ii2].idn,checkinstance,ELEVEQOPEN,GridHeader[ii2].Lindex,
                                                           GridHeader[ii2].Sindex,C_GRID /** config must be grid **/,
                                           SCCtable[GridHeader[ii2].Sindex].S,SCCtable[GridHeader[ii2].Sindex].D,
                                                           &part1,&part2,&part3)) && (part1 > 0))
                                      {
                                      CheckGridForElevationValues(OPENINT,GridHeader[ii2].idn,GridHeader[ii2].Sindex,GridHeader[ii2].Lindex, Grows,
                                                                  Gcols,checkinstance,ii2,minx,miny,maxx,maxy);
                                      }
                                   if((i < NumberOfGrids) &&
                                     (CombinedCheckApplies(GridHeader[ii2].idn,checkinstance,WATERMMU,GridHeader[ii2].Lindex,
                                                           GridHeader[ii2].Sindex,C_GRID /** config must be grid **/,
                                           SCCtable[GridHeader[ii2].Sindex].S,SCCtable[GridHeader[ii2].Sindex].D,
                                                           &part1,&part2,&part3)) && (part1 > 0))
                                      {
                                      CheckGridForElevationValues(CLOSEDINT,GridHeader[ii2].idn,GridHeader[ii2].Sindex,GridHeader[ii2].Lindex, Grows,
                                                                  Gcols,checkinstance,ii2,minx,miny,maxx,maxy);
                                      }

                                   if(i == (NGT[compositeindex].NumGrids - 1))
                                      {
                                      TempOK = CheckMaskAndGridsForZeroElev(compositeindex, checkinstance,minx,miny,maxx,maxy);

                                      TempOK = CheckMaskAndGridsForConstantElev(compositeindex, checkinstance,minx,miny,maxx,maxy);

                                      TempOK = CheckMaskAndGridsForMonotonicity(compositeindex, checkinstance,minx,miny,maxx,maxy);

                                      TempOK = CheckMaskAndGridsForShorelineContainment(compositeindex, checkinstance,minx,miny,maxx,maxy);

                                      TempOK = CheckMaskAndGridsForStepSize(compositeindex, checkinstance,minx,miny,maxx,maxy);

                                      TempOK = CheckRiverBreaklineAngle(compositeindex, checkinstance,minx,miny,maxx,maxy);

                                      TempOK = CheckMaskAndGridsForEditedElev(MASKEDIT_1,
                                                      compositeindex, checkinstance,minx,miny,maxx,maxy);

                                      TempOK = CheckMaskAndGridsForEditedElev(MASKEDIT_0,
                                                      compositeindex, checkinstance,minx,miny,maxx,maxy);
                                      }
				   if((NumLODbands > 0) && 
                                      (i == (NGT[compositeindex].NumGrids - 1))    )
				      {
                                      if(gridLODSchecked == 0)
                                         {
				         TempOK = Check2GridsForElevDifferences(compositeindex, checkinstance,minx,miny,maxx,maxy);

                                         TempOK = CheckMatchingGridsForElevDifferences(compositeindex, checkinstance,minx,miny,maxx,maxy);

                                         TempOK = CheckTwoMasksForAgreement(compositeindex, checkinstance,minx,miny,maxx,maxy);

                                         for(ii7=0; ii7<NGT[compositeindex].NumGrids; ii7++)
                                            {
                                            ii6 = NGT[compositeindex].GridIndex[ii7];
                                            if((CombinedCheckApplies(GridHeader[ii6].idn,checkinstance,AVGSPIKE,
                                               GridHeader[ii6].Lindex,
                                               GridHeader[ii6].Sindex,C_GRID,
                                           SCCtable[GridHeader[ii6].Sindex].S,SCCtable[GridHeader[ii6].Sindex].D,
                                                           &part1,&part2,&part3)) && (part1 > 0))
                                               {
                                               WBMindex = -1;
                                               for(WBMindex=0; WBMindex<NGT[compositeindex].NumGrids; WBMindex++)
                                                  {
                                                  ii5 = NGT[compositeindex].GridIndex[WBMindex];
                                                  if((CombinedCheckApplies(GridHeader[ii5].idn,checkinstance,AVGSPIKE,
                                                    GridHeader[ii5].Lindex, GridHeader[ii5].Sindex,C_GRID,
                                                    SCCtable[GridHeader[ii5].Sindex].S,SCCtable[GridHeader[ii5].Sindex].D,
                                                                    &part1,&part2,&part3)) && (part2 > 0))
                                                     break;
                                                  }
                                               if(WBMindex >= NGT[compositeindex].NumGrids)
                                                  WBMindex = -1;
                                               CheckGridForAverageSpikes(GridHeader[ii6].idn,GridHeader[ii6].Sindex,
                                                         GridHeader[ii6].Lindex,
                                                         Grows, Gcols,
                                                         checkinstance,WBMindex,ii6,minx,miny,maxx,maxy);
                                               }
                                            }

                                         for(ii7=0; ii7<NGT[compositeindex].NumGrids; ii7++)
                                            {
                                            ii6 = NGT[compositeindex].GridIndex[ii7];
                                            if((CombinedCheckApplies(GridHeader[ii6].idn,checkinstance,GSHELF,
                                               GridHeader[ii6].Lindex, GridHeader[ii6].Sindex,C_GRID,
                                                  SCCtable[GridHeader[ii6].Sindex].S,SCCtable[GridHeader[ii6].Sindex].D,
                                                           &part1,&part2,&part3)) && (part1 > 0))
                                               {
                                               WBMindex = -1;
                                               for(WBMindex=0; WBMindex<NGT[compositeindex].NumGrids; WBMindex++)
                                                  {
                                                  ii5 = NGT[compositeindex].GridIndex[WBMindex];
                                                  if((CombinedCheckApplies(GridHeader[ii5].idn,checkinstance,GSHELF,
                                                    GridHeader[ii5].Lindex, GridHeader[ii5].Sindex,C_GRID,
                                                    SCCtable[GridHeader[ii5].Sindex].S,SCCtable[GridHeader[ii5].Sindex].D,
                                                                    &part1,&part2,&part3)) && (part2 > 0))
                                                     break;
                                                  }
                                               if(WBMindex >= NGT[compositeindex].NumGrids)
                                                  WBMindex = -1;

                                               CheckGridFor_PUE_Shelf(GridHeader[ii6].idn,GridHeader[ii6].Sindex,
                                                         GridHeader[ii6].Lindex,
                                                         Grows, Gcols,
                                                         checkinstance,WBMindex,ii6,minx,miny,maxx,maxy);
                                               }
                                            }

                                         }
				      }

				   }
	
				}
			     }
			  }
		       CloseGridFile(gridfilein);
		       gridfilein = NULL;
		       }
		    }


	/**** get the polygon objects ****/
		 PolyLODbandCount = NULL;
		 if((NGA_TYPE == 0) && (CheckByConfig[C_POLY] > 0)) /** yes, we are checking polygons **/
		    {
		    if(NumLODbands > 0)
		       {
		       PolyLODbandCount = (int *) (malloc(SzI * (NumLODbands + 1)));
		       for(i = 0; i<=NumLODbands; i++)
			  PolyLODbandCount[i] = 0;
		       }
		    else
		       PolyLODbandCount = NULL;

		    for(i=0; i<4; i++)
		       NeighborsExist[i] = 0;

		    MinValsWereInit = 0;
		    filedecimal = 0.1;
		    for(i=0; i<PolyTable[compositeindex].numother; i++)
		       {
		       InsertOK = InsertIntoLongList(PolyTable[compositeindex].others[i].fileptr,0,skiplimit,
					  &PolyLongListRoot,LongPolySkipList,&SkipEntry);
		       fseek(fin,PolyTable[compositeindex].others[i].fileptr,SEEK_SET);
		       vtxcnt = ReadPolyFromFile(fin,multiplier);

		       OKtoUse = 1;
		       if(NumLODbands > 0)
			  {
			  jj = CrsWlk[PolyFromFile.SACindex].LODband;
			  if((jj > 0) && (LODindex[jj-1].active < 1))
			     OKtoUse = 0;
			  }


		       if((OKtoUse > 0) && (CheckByStratum[PolyFromFile.stratum] > 0) && (CheckByDomain[PolyFromFile.domain] > 0))
			  {
			  if(InsertOK)
			     {
			     NumObjects[C_POLY] += 1.0;
			     }
			  TPc = CheckPolygonDuplication(PolyFromFile, &TProot,SzTP,&IsDup, DblPolySkipList, skiplimit, &TPdup);
			  sliverdone = 0;
			  if(IsDup < UseDupThreshold) /**** HERE HERE 3 to 2 ****/
			     {
			     if(InsertOK)
				{

				sliverdone = CalculateSliverRating(PolyFromFile.x,PolyFromFile.y,PolyFromFile.z,
				       PolyFromFile.numverts,&width,&height,&sliverratio);

				if((NumLODbands > 0) && (PolyLODbandCount != NULL))
				   {
				   jj = CrsWlk[PolyFromFile.SACindex].LODband;
				   if((jj > 0) && (LODindex[jj-1].active > 0))
				      {
				      if(jj <= NumLODbands)
					 PolyLODbandCount[jj-1] += 1;
				      else
					 {
					 printf("bounds exception with PolyLODbandCount array\n");
					 printf("NumLODbands %d index value %d\n", NumLODbands,jj);
					 exit(-1);
					 }
				      }
				   }
				else if(NumLODbands > 0)
				   {
				   printf("exception - assigning values to NULL PolyLODbandCount array\n");
				   exit(-1);
				   }

				} 

			     if(TPc == NULL)
				{
				printf("1: allocation memory exhausted during polygon list assembly operation\n");
				printf("processing cannot continue\n");
				exit(-1);
				}
			     TPc->SACindex = PolyFromFile.SACindex;
			     TPc->SCCindex = PolyFromFile.SCCindex;
			     TPc->idn = PolyFromFile.idn;
			     TPc->numverts = vtxcnt;
			     TPc->config = PolyFromFile.config;
			     TPc->stratum = PolyFromFile.stratum;
			     TPc->domain = PolyFromFile.domain;
			     TPc->insertOK = (unsigned char) InsertOK;
			     tempID = TPc->localID = PolyTable[compositeindex].others[i].fileptr + filedecimal;
			     TPc->Xtra = NULL;
			     /***TPc->next = NULL; ***/
			     TPc->minxvtx = PolyFromFile.minxvtx;
			     TPc->minyvtx = PolyFromFile.minyvtx;
			     TPc->maxxvtx = PolyFromFile.maxxvtx;
			     TPc->maxyvtx = PolyFromFile.maxyvtx;
			     jj = PlaneEquation(&PA,&PB,&PC,&PD,PolyFromFile.x,
					PolyFromFile.y,PolyFromFile.z,PolyFromFile.numverts);
			     if(jj == 1) /** then plane equation was a success **/
				{
				TPc->slope = PolygonAngle(PA,PB,PC);
				if(TPc->slope == HalfPI)
				   vertpolysurfarea = SurfaceAreaByTriangles(PolyFromFile.numverts, PolyFromFile.x,
						      PolyFromFile.y,PolyFromFile.z);
				else
				   vertpolysurfarea = 1.0;
				}
			     else
				TPc->slope = 2;
	  
			     TPc->x = (double *) malloc(SzD * vtxcnt);
			     TPc->y = (double *) malloc(SzD * vtxcnt);
			     TPc->z = (double *) malloc(SzD * vtxcnt);
			     if((TPc->x == NULL) || (TPc->y == NULL) || (TPc->z == NULL))
				{
				printf("2: allocation memory exhausted during polygon list assembly operation\n");
				printf("processing cannot continue (found %d polygon vertices)\n",vtxcnt);
				exit(-1);
				}
			     for(jj = 0; jj<vtxcnt; jj++)
				{
				TPc->x[jj] = PolyFromFile.x[jj];
				TPc->y[jj] = PolyFromFile.y[jj];
				TPc->z[jj] = PolyFromFile.z[jj];
				if(jj == 0)
				   {
				   MaxElev = MinElev = PolyFromFile.z[0];
				   }
				else if(PolyFromFile.z[jj] > MaxElev)
				   MaxElev = PolyFromFile.z[jj];
				else if(PolyFromFile.z[jj] < MinElev)
				   MinElev = PolyFromFile.z[jj];
				}

			     for(checkinstance = 0; checkinstance < TtlActiveChecks; checkinstance++)
				{



				if((CombinedCheckApplies(PolyFromFile.idn,checkinstance,ELEVGT,PolyFromFile.SACindex,PolyFromFile.SCCindex,PolyFromFile.config,PolyFromFile.stratum,
					    PolyFromFile.domain,&part1,&part2,&part3)) && (part1 > 0))
				   {
				   if(SensitivityCheck(GT, ELEVGT, checkinstance, MaxElev) > 0)
				      {
                                      FwriteDynamicInfo(ELEVGT,Make_Correct(ELEVGT,checkinstance),0,1,1,NULL,
                                        MinElev, -1.0, -1.0, -1.0,
                                        PolyFromFile.SCCindex,G_POLYGON,PolyFromFile.SACindex,TPc->localID,PolyFromFile.idn,-1.0,-1.0,
                                        PolyFromFile.x, PolyFromFile.y,PolyFromFile.z, 1,
/** the arguments below have no impact since only writing 1 object ****/
                                        PolyFromFile.SCCindex,G_POLYGON,PolyFromFile.SACindex,TPc->localID,PolyFromFile.idn,-1.0,-1.0,                                     
                                        PolyFromFile.x, PolyFromFile.y,PolyFromFile.z, 1);
				      }
				   }
				if((CombinedCheckApplies(PolyFromFile.idn,checkinstance,ELEVLT,PolyFromFile.SACindex,PolyFromFile.SCCindex,
					       PolyFromFile.config,PolyFromFile.stratum,
					       PolyFromFile.domain,&part1,&part2,&part3)) && (part1 > 0))
				   {
				   if(SensitivityCheck(LT, ELEVLT, checkinstance, MinElev) > 0)
				      {
                                      FwriteDynamicInfo(ELEVLT,Make_Correct(ELEVLT,checkinstance),0,1,1,NULL,
                                        MinElev, -1.0, -1.0, -1.0,
                                        PolyFromFile.SCCindex,G_POLYGON,PolyFromFile.SACindex,TPc->localID,PolyFromFile.idn,-1.0,-1.0,
                                        PolyFromFile.x, PolyFromFile.y,PolyFromFile.z, 1,
/** the arguments below have no impact since only writing 1 object ****/
                                        PolyFromFile.SCCindex,G_POLYGON,PolyFromFile.SACindex,TPc->localID,PolyFromFile.idn,-1.0,-1.0,                                     
                                        PolyFromFile.x, PolyFromFile.y,PolyFromFile.z, 1);
				      }
				   }
				if((CombinedCheckApplies(PolyFromFile.idn,checkinstance,ELEVEQ,PolyFromFile.SACindex,PolyFromFile.SCCindex,
					       PolyFromFile.config,PolyFromFile.stratum,
					       PolyFromFile.domain,&part1,&part2,&part3)) && (part1 > 0))
				   {
				   if((SensitivityCheck(CLOSEDINT, ELEVEQ, checkinstance, MinElev) > 0) &&
				      (SensitivityCheck(CLOSEDINT, ELEVEQ, checkinstance, MaxElev) > 0))
				      {
                                      FwriteDynamicInfo(ELEVEQ,Make_Correct(ELEVEQ,checkinstance),0,1,1,NULL,
                                        MinElev, -1.0, -1.0, -1.0,
                                        PolyFromFile.SCCindex,G_POLYGON,PolyFromFile.SACindex,TPc->localID,PolyFromFile.idn,-1.0,-1.0,
                                        PolyFromFile.x, PolyFromFile.y,PolyFromFile.z, 1,
                                        PolyFromFile.SCCindex,G_POLYGON,PolyFromFile.SACindex,TPc->localID,PolyFromFile.idn,-1.0,-1.0,                                     
                                        PolyFromFile.x, PolyFromFile.y,PolyFromFile.z, 1);
				      }
				   }

                                if((CombinedCheckApplies(PolyFromFile.idn,checkinstance,ELEVEQOPEN,PolyFromFile.SACindex,PolyFromFile.SCCindex,
                                               PolyFromFile.config,PolyFromFile.stratum,
                                               PolyFromFile.domain,&part1,&part2,&part3)) && (part1 > 0))
                                   {
                                   if((SensitivityCheck(OPENINT, ELEVEQOPEN, checkinstance, MinElev) > 0) &&
                                      (SensitivityCheck(OPENINT, ELEVEQOPEN, checkinstance, MaxElev) > 0))
                                      {
                                      FwriteDynamicInfo(ELEVEQOPEN,Make_Correct(ELEVEQOPEN,checkinstance),0,1,1,NULL,
                                        MinElev, -1.0, -1.0, -1.0,
                                        PolyFromFile.SCCindex,G_POLYGON,PolyFromFile.SACindex,TPc->localID,PolyFromFile.idn,-1.0,-1.0,
                                        PolyFromFile.x, PolyFromFile.y,PolyFromFile.z, 1,
                                        PolyFromFile.SCCindex,G_POLYGON,PolyFromFile.SACindex,TPc->localID,PolyFromFile.idn,-1.0,-1.0,
                                        PolyFromFile.x, PolyFromFile.y,PolyFromFile.z, 1);
                                      }
                                   }
				}

			     checkinstance = -1; /** so that any applicable check will return a yes answer ***/
			     if((CombinedCheckApplies(PolyFromFile.idn,checkinstance,VTEAR,PolyFromFile.SACindex,PolyFromFile.SCCindex,PolyFromFile.config,PolyFromFile.stratum,
					    PolyFromFile.domain,&part1,&part2,&part3)) ||
				(CombinedCheckApplies(PolyFromFile.idn,checkinstance,HTEAR,PolyFromFile.SACindex,PolyFromFile.SCCindex,PolyFromFile.config,PolyFromFile.stratum,
					    PolyFromFile.domain,&part1,&part2,&part3)) ||
				(CombinedCheckApplies(PolyFromFile.idn,checkinstance,OVERC,PolyFromFile.SACindex,PolyFromFile.SCCindex,PolyFromFile.config,PolyFromFile.stratum,
					    PolyFromFile.domain,&part1,&part2,&part3)) ||
				(CombinedCheckApplies(PolyFromFile.idn,checkinstance,TVERT,PolyFromFile.SACindex,PolyFromFile.SCCindex,PolyFromFile.config,PolyFromFile.stratum,
					    PolyFromFile.domain,&part1,&part2,&part3)) ||
				(CombinedCheckApplies(PolyFromFile.idn,checkinstance,LSPINT,PolyFromFile.SACindex,PolyFromFile.SCCindex,PolyFromFile.config,PolyFromFile.stratum,
					    PolyFromFile.domain,&part1,&part2,&part3)) ||
				(CombinedCheckApplies(PolyFromFile.idn,checkinstance,LSPIEXP,PolyFromFile.SACindex,PolyFromFile.SCCindex,PolyFromFile.config,PolyFromFile.stratum,
					    PolyFromFile.domain,&part1,&part2,&part3)) ||
				((PolyFromFile.stratum == 5) && (ErrorLookup[SLOPEDIRCH].anyactive > 0)) ||
				((PolyFromFile.stratum == 5) && (ErrorLookup[LJOINSLOPEDC].anyactive > 0)))
				{
				edgesin = 0;
				for(jj=0; jj<vtxcnt; jj++)
				   {
				   ii = (jj + 1) % vtxcnt;
				   vx1 = PolyFromFile.x[jj]; 
				   vy1 = PolyFromFile.y[jj];
				   vz1 = PolyFromFile.z[jj];
				   vx2 = PolyFromFile.x[ii];
				   vy2 = PolyFromFile.y[ii];
				   vz2 = PolyFromFile.z[ii];
				   neighborhit = ClipLineToRegion(minx,miny,maxx,maxy,&vx1,&vy1,&vz1,&vx2,&vy2,&vz2, &clipflag, multiplier);

				   if(neighborhit > 0)
				      {
				      if(neighborhit & 2)
					 NeighborsExist[0] += 1;
				      if(neighborhit & 4)
					 NeighborsExist[1] += 1;
				      if(neighborhit & 8)
					 NeighborsExist[2] += 1;
				      if(neighborhit & 16)
					 NeighborsExist[3] += 1;
				      lpec = (struct ListOfEdges *) (malloc(SzLE));
				      if(lpec == NULL)
					 {
					 printf("allocation memory exhausted during polygon edge list assembly operation\n");
					 printf("processing cannot continue\n");
					 exit(-1);
					 }
				      lpec->x1 = PolyFromFile.x[jj];
				      lpec->y1 = PolyFromFile.y[jj];
				      lpec->z1 = PolyFromFile.z[jj];
				      lpec->x2 = PolyFromFile.x[ii];
				      lpec->y2 = PolyFromFile.y[ii];

				      lpec->z2 = PolyFromFile.z[ii];
				      if(lpec->x1 < lpec->x2)
					 {
					 lpec->minx = lpec->x1;
					 lpec->maxx = lpec->x2;
					 }
				      else
					 {
					 lpec->minx = lpec->x2;
					 lpec->maxx = lpec->x1;
					 }
				      if(lpec->y1 < lpec->y2)
					 {
					 lpec->miny = lpec->y1;
					 lpec->maxy = lpec->y2;
					 }
				      else
					 {
					 lpec->miny = lpec->y2;
					 lpec->maxy = lpec->y1;
					 }
				      lpec->rise = lpec->y2 - lpec->y1;
				      lpec->run = lpec->x2 - lpec->x1;
				      if(lpec->x1 != lpec->x2)
					 {
					 lpec->slope = lpec->rise / lpec->run;
					 lpec->Bval = lpec->y1 - (lpec->slope * lpec->x1);
					 }
				      else
					 {
					 lpec->slope = 0;
					 lpec->Bval = 0;
					 }
	   
				      if(MinValsWereInit == 0)
					 {
					 rlx = lpec->minx;
					 rux = lpec->maxx;
					 rly = lpec->miny;
					 ruy = lpec->maxy;
					 MinValsWereInit = 1;
					 }
				      else
					 {
					 if(lpec->minx < rlx)
					    rlx = lpec->minx;
					 if(lpec->maxx > rux)
					    rux = lpec->maxx;
					 if(lpec->miny < rly)
					    rly = lpec->miny;
					 if(lpec->maxy > ruy)
					    ruy = lpec->maxy;
					 }

				      lpec->owner = (long int) TPc; /** ptr to poly this edges belongs to **/
				      lpec->ownernumb = jj; /** original edges from which it may have been clipped **/
				      lpec->clipped = clipflag; /** ==1:vtx 1 was replaced, ==2:vtx 2 was replaced, ==3: both vtx replaced **/
				      lpec->isT = 0;
				      lpec->length = Distance(vx1,vy1,vx2,vy2);
				      lpec->Tcover = 0.0;
				      lpec->Ocover = 0.0;
				      lpec->Iedge = NULL;
				      lpec->DeltaZ1 = lpec->DeltaZ2 = 0.0;
				      ii = 0;
				      if((sliverdone == 0) || (InsertOK == 0) || (sliverratio < 0.001))
					 ii = EdgeSliverCheckOK(lpec, PolyEdgeRoot, edgesin);
				      else
					 ii = 1;

				      if((ii > 0) && (lpec->length > 0))
					 {
					 if(TPc->slope != HalfPI)
					    {
					    ++edgesin;
					    lpec->next = NULL;
					    InsertIntoEdgeList(lpec, &PolyEdgeRoot, DblPolyEdgeSkipList, skiplimit);
					    }
					 else
					    {
					    ++edgesin;
					    if(vertpolysurfarea > 0)
					       {
					       lpec->next = VertPolyEdgeRoot;
					       VertPolyEdgeRoot = lpec;
					       }
					    else
					       free(lpec);
					    }
					 }
				      else
					 free(lpec);
				      }
				   }
				} /** end inserting into edge list **/
			     } /** end if not a duplicate **/
			  else
			     {
			     tempID = PolyTable[compositeindex].others[i].fileptr + filedecimal;
			     }



			  for(checkinstance = 0; checkinstance < TtlActiveChecks; checkinstance++)
			    {
			      if(
				 (IsDup == 1)   && 
				 (InsertOK > 0) && 
				 (CombinedCheckApplies(PolyFromFile.idn,checkinstance,G_DUPS,PolyFromFile.SACindex,PolyFromFile.SCCindex,
						       PolyFromFile.config,PolyFromFile.stratum,PolyFromFile.domain,
						       &part1,&part2,&part3))  && (part1 > 0) &&
				      (CombinedCheckApplies(TPdup->idn,checkinstance,G_DUPS,TPdup->SACindex,TPdup->SCCindex,
				       SCCtable[TPdup->SCCindex].C, SCCtable[TPdup->SCCindex].S, SCCtable[TPdup->SCCindex].D,
							   &part1,&part2,&part3) > 0) && (part2 > 0)

				 )
				{
				  FwriteTwoObjects(G_DUPS,Make_Correct(G_DUPS,checkinstance),
						   PolyFromFile.idn,G_POLYGON,PolyFromFile.SACindex,tempID,PolyFromFile.SCCindex,-1.0,-1.0,
						   PolyFromFile.numverts,PolyFromFile.x,PolyFromFile.y,PolyFromFile.z,
						   TPdup->idn,G_POLYGON,TPdup->SACindex,TPdup->localID,TPdup->SCCindex,-1.0,-1.0,
						   TPdup->numverts,TPdup->x, TPdup->y,TPdup->z);
				}
			      

			      if(
				 (IsDup == 4)   && 
				 (InsertOK > 0) &&
				 (CombinedCheckApplies(PolyFromFile.idn,checkinstance,C_DUPS,PolyFromFile.SACindex,PolyFromFile.SCCindex,
						       PolyFromFile.config,PolyFromFile.stratum,PolyFromFile.domain,
						       &part1,&part2,&part3))  && (part1 > 0) &&
				      (CombinedCheckApplies(TPdup->idn,checkinstance,C_DUPS,TPdup->SACindex,TPdup->SCCindex,
				       SCCtable[TPdup->SCCindex].C, SCCtable[TPdup->SCCindex].S, SCCtable[TPdup->SCCindex].D,
							   &part1,&part2,&part3)) && (part1 > 0)
				 )
				{
				  FwriteTwoObjects(C_DUPS,Make_Correct(C_DUPS,checkinstance),
						   PolyFromFile.idn,G_POLYGON,PolyFromFile.SACindex,tempID,PolyFromFile.SCCindex,-1.0,-1.0,
						   PolyFromFile.numverts,PolyFromFile.x,PolyFromFile.y,PolyFromFile.z,
						   TPdup->idn,G_POLYGON,TPdup->SACindex,TPdup->localID,TPdup->SCCindex,-1.0,-1.0,
						   TPdup->numverts,TPdup->x, TPdup->y,TPdup->z);
				}
			      
			      



			      if((IsDup < UseDupThreshold) && (InsertOK))
				{
				  if(sliverdone == 0)
				    {
				      sliverdone = CalculateSliverRating(PolyFromFile.x,PolyFromFile.y,PolyFromFile.z,
									 PolyFromFile.numverts,&width,&height,&sliverratio); 
				    }
				  if((CombinedCheckApplies(PolyFromFile.idn,checkinstance,V_DUPS,PolyFromFile.SACindex,PolyFromFile.SCCindex,
							  PolyFromFile.config,PolyFromFile.stratum,PolyFromFile.domain,
							  &part1,&part2,&part3)) && (part1 > 0))
				    {
				      dv = DuplicateVerticesExist(PolyFromFile.numverts,
								     PolyFromFile.x,PolyFromFile.y,PolyFromFile.z);
				      if(SensitivityCheck(GT, V_DUPS, checkinstance, (double) dv) > 0)
					{
					  /*** found a poly with duplicate vertices **/
					for(jj=1; jj<PolyFromFile.numverts; jj++)
					  {
					  if((PolyFromFile.x[jj-1] == PolyFromFile.x[jj]) &&
					      (PolyFromFile.y[jj-1] == PolyFromFile.y[jj]) &&
					      (PolyFromFile.z[jj-1] == PolyFromFile.z[jj]))
					     {
                                             FwriteObject(V_DUPS,Make_Correct(V_DUPS,checkinstance),PolyFromFile.SACindex,
                                                           PolyFromFile.SCCindex,G_POLYGON,TPc->localID,PolyFromFile.idn, -1.0, -1.0,
                                                            &PolyFromFile.x[jj],&PolyFromFile.y[jj],&PolyFromFile.z[jj],1, 1);
					     }
					  }
					}
				    }






				  if((CombinedCheckApplies(PolyFromFile.idn,checkinstance,SLIVER,PolyFromFile.SACindex,PolyFromFile.SCCindex,
							  PolyFromFile.config,PolyFromFile.stratum,PolyFromFile.domain,
							  &part1,&part2,&part3)) && (part1 > 0))
				    {
				      if(
					 (sliverdone > 0) && 
					 (SensitivityCheck(LTEQ, SLIVER, checkinstance, sliverratio) > 0)
					 )
					{
					  FwriteObjectAndMagnitude(SLIVER,Make_Correct(SLIVER,checkinstance),
								   PolyFromFile.idn, 
								   PolyFromFile.SCCindex, G_POLYGON, PolyFromFile.SACindex,
								   TPc->localID,-1.0,-1.0, sliverratio,
								   PolyFromFile.x, PolyFromFile.y,PolyFromFile.z,
								   PolyFromFile.numverts, 1);
					}
				    }


				  if((CombinedCheckApplies(PolyFromFile.idn,checkinstance,NARROW,PolyFromFile.SACindex,PolyFromFile.SCCindex,
							  PolyFromFile.config,PolyFromFile.stratum,PolyFromFile.domain,
							  &part1,&part2,&part3)) && (part1 > 0))
				    {
				      if(
					 (sliverdone > 0) &&
					 (SensitivityCheck(LT, NARROW, checkinstance, width) > 0)
					 )
					{
					  FwriteObjectAndMagnitude(NARROW,Make_Correct(NARROW,checkinstance),
								   PolyFromFile.idn, PolyFromFile.SCCindex,
								   G_POLYGON, PolyFromFile.SACindex,
								   TPc->localID,-1.0,-1.0, width,
								   PolyFromFile.x, PolyFromFile.y,PolyFromFile.z,
								   PolyFromFile.numverts, 1);
					}
				   }



				  if((CombinedCheckApplies(PolyFromFile.idn,checkinstance,SMALLOBJ,PolyFromFile.SACindex,PolyFromFile.SCCindex,
							  PolyFromFile.config,PolyFromFile.stratum,PolyFromFile.domain,
							  &part1,&part2,&part3)) && (part1 > 0))
				    {
				      surfacearea3D = SurfaceAreaByTriangles(PolyFromFile.numverts, PolyFromFile.x,
									     PolyFromFile.y,PolyFromFile.z);

				      if(SensitivityCheck(LT, SMALLOBJ, checkinstance, surfacearea3D) > 0)
					{
					  FwriteObjectAndMagnitude(SMALLOBJ,Make_Correct(SMALLOBJ,checkinstance),
								   PolyFromFile.idn, 
								   PolyFromFile.SCCindex,G_POLYGON, PolyFromFile.SACindex,
								   TPc->localID,-1.0,-1.0,
								   surfacearea3D,PolyFromFile.x, PolyFromFile.y,PolyFromFile.z,
								   PolyFromFile.numverts, 1);
					}
				    }


                                   if(CombinedCheckApplies(PolyFromFile.idn,checkinstance,PERIMLEN,PolyFromFile.SACindex,PolyFromFile.SCCindex,
                                                              PolyFromFile.config,PolyFromFile.stratum,PolyFromFile.domain,
                                                              &part1,&part2,&part3))
                                        {
                                          if((part1 > 0) && (PolyFromFile.numverts > 1))
                                             {
                                             segmentlength = 0;
                                             for(jj=1; jj<PolyFromFile.numverts; jj++)
                                                {
                                                segmentlength += Distance3D(PolyFromFile.x[jj-1],PolyFromFile.y[jj-1],PolyFromFile.z[jj-1],
                                                                           PolyFromFile.x[jj],PolyFromFile.y[jj],PolyFromFile.z[jj]);
                                                }
                                             segmentlength += Distance3D(PolyFromFile.x[jj-1],PolyFromFile.y[jj-1],PolyFromFile.z[jj-1],
                                                                           PolyFromFile.x[0],PolyFromFile.y[0],PolyFromFile.z[0]);
                                             if(SensitivityCheck(LTEQ, PERIMLEN, checkinstance, segmentlength) > 0)
                                                {
                                                FwriteObjectAndMagnitude(PERIMLEN,Make_Correct(PERIMLEN,checkinstance),
                                                                  PolyFromFile.idn,
                                                                  PolyFromFile.SCCindex,G_POLYGON,PolyFromFile.SACindex,TPc->localID,
                                                                  -1.0,-1.0,segmentlength,
                                                                  PolyFromFile.x, PolyFromFile.y,PolyFromFile.z,PolyFromFile.numverts, 1);
                                                }

                                             }
                                        }



                                      if(CombinedCheckApplies(PolyFromFile.idn,checkinstance,SEGLEN,PolyFromFile.SACindex,PolyFromFile.SCCindex,
                                                              PolyFromFile.config,PolyFromFile.stratum,PolyFromFile.domain,
                                                              &part1,&part2,&part3))
                                        {
                                          if((part1 > 0) && (PolyFromFile.numverts > 1))
                                             {
                                             for(jj=0; jj<PolyFromFile.numverts; jj++)
                                                {
                                                if(jj == 0)
                                                   jj2 = PolyFromFile.numverts-1;
                                                else
                                                   jj2 = jj - 1;
                                                if((PolyFromFile.x[jj] != PolyFromFile.x[jj2]) || (PolyFromFile.y[jj] != PolyFromFile.y[jj2]) ||
                                                    (PolyFromFile.z[jj] != PolyFromFile.z[jj2]))
                                                   {
                                                   if(EitherPointInBox(PolyFromFile.x[jj2],PolyFromFile.y[jj2],PolyFromFile.x[jj],PolyFromFile.y[jj],
                                                                index1Min,index2Min,index1Max,index2Max) > 0)
                                                      {
                                                      segmentlength = Distance3D(PolyFromFile.x[jj2],PolyFromFile.y[jj2],PolyFromFile.z[jj2],
                                                                           PolyFromFile.x[jj],PolyFromFile.y[jj],PolyFromFile.z[jj]);
                                                      if(SensitivityCheck(LTEQ, SEGLEN, checkinstance, segmentlength) > 0)
                                                         {
                                                         edgeX[0] = PolyFromFile.x[jj2];
                                                         edgeY[0] = PolyFromFile.y[jj2];
                                                         edgeZ[0] = PolyFromFile.z[jj2];
                                                         edgeX[1] = PolyFromFile.x[jj];
                                                         edgeY[1] = PolyFromFile.y[jj];
                                                         edgeZ[1] = PolyFromFile.z[jj];
                                                         FwriteObjectAndMagnitude(SEGLEN,Make_Correct(SEGLEN,checkinstance),
                                                                     PolyFromFile.idn,
                                                                     PolyFromFile.SCCindex,G_POLYGON,PolyFromFile.SACindex,TPc->localID,
                                                                     -1.0,-1.0,segmentlength,
                                                                     &edgeX[0], &edgeY[0],&edgeZ[0],2, 1);
                                                         }
                                                      }
                                                   }
                                                }
                                             }
                                        }




				  
				  if((CombinedCheckApplies(PolyFromFile.idn,checkinstance,ATTRERR,PolyFromFile.SACindex,PolyFromFile.SCCindex,
							  PolyFromFile.config,PolyFromFile.stratum,PolyFromFile.domain,
							  &part1,&part2,&part3)) && (part1 > 0))
				    {
				      if(CrsWlk[PolyFromFile.SACindex].AttrErr >= 0)
					{
					  FwriteObjectAndMessage(ATTRERR,Make_Correct(ATTRERR,checkinstance),
								 PolyFromFile.idn, G_POLYGON,PolyFromFile.SACindex,TPc->localID,
								 PolyFromFile.SCCindex,-1.0,-1.0,PolyFromFile.x,
								 PolyFromFile.y,PolyFromFile.z,PolyFromFile.numverts,
								 AttrErr[CrsWlk[PolyFromFile.SACindex].AttrErr].description);
					}
				    }



				  
				  if(			     
				     (CombinedCheckApplies(PolyFromFile.idn,checkinstance,HSLOPE,PolyFromFile.SACindex,PolyFromFile.SCCindex,
							   PolyFromFile.config,PolyFromFile.stratum,PolyFromFile.domain,
							   &part1,&part2,&part3)) 
				     ||
				     (CombinedCheckApplies(PolyFromFile.idn,checkinstance,VERTSLOPE,PolyFromFile.SACindex,PolyFromFile.SCCindex,
							   PolyFromFile.config,PolyFromFile.stratum,PolyFromFile.domain,
							   &part1,&part2,&part3))
				     )
				    {
				      if(TPc->slope < 1.75) /** then plane equation was a success **/
					{
					  angle = TPc->slope;
					  if((angle >= HalfPI) &&
					     (CombinedCheckApplies(PolyFromFile.idn,checkinstance,VERTSLOPE,PolyFromFile.SACindex,
								   PolyFromFile.SCCindex,PolyFromFile.config,
								   PolyFromFile.stratum,PolyFromFile.domain,
								   &part1,&part2,&part3)) && (part1 > 0))
					    {
					      FwriteObject(VERTSLOPE,Make_Correct(VERTSLOPE,checkinstance),
							   PolyFromFile.SACindex,
							   PolyFromFile.SCCindex, G_POLYGON,TPc->localID /** need poly localID here **/,PolyFromFile.idn,-1.0, -1.0,
							   PolyFromFile.x, PolyFromFile.y,PolyFromFile.z,
							   PolyFromFile.numverts, 1);
					 }

					  
					  angle = RadiansToDegrees(angle);
					  if(
					     (CombinedCheckApplies(PolyFromFile.idn,checkinstance,HSLOPE,PolyFromFile.SACindex,
								   PolyFromFile.SCCindex,PolyFromFile.config,
								   PolyFromFile.stratum,PolyFromFile.domain,
								   &part1,&part2,&part3)) && (part1 > 0) &&
					     (SensitivityCheck(GTEQ, HSLOPE, checkinstance, angle) > 0)
					     )
					    {
					      FwriteObjectAndMagnitude(HSLOPE,Make_Correct(HSLOPE,checkinstance),
								       PolyFromFile.idn, 
								       PolyFromFile.SCCindex,G_POLYGON, PolyFromFile.SACindex,
								       TPc->localID,-1.0,-1.0,
								       angle,PolyFromFile.x, PolyFromFile.y,PolyFromFile.z,
								       PolyFromFile.numverts, 1);
					    }
					}
				    }
				}
			     }
			  }
		       free(PolyFromFile.x);
		       free(PolyFromFile.y);
		       free(PolyFromFile.z);
		       }

		    fseek(fin,PolyTable[compositeindex].fileptr,SEEK_SET);
		    filedecimal = 0.1;
		    valuesread = 0;
		    while(valuesread < PolyTable[compositeindex].numinside)
		       {
		       if(feof(fin) != 0)
			  break;
		       fo = ftell(fin);
		       vtxcnt = ReadPolyFromFile(fin,multiplier);

		       OKtoUse = 1;
		       if(NumLODbands > 0)
			  {
			  jj = CrsWlk[PolyFromFile.SACindex].LODband;
			  if((jj > 0) && (LODindex[jj-1].active < 1))
			     OKtoUse = 0;
			  }

		       if((OKtoUse > 0) && (CheckByStratum[PolyFromFile.stratum] > 0) && (CheckByDomain[PolyFromFile.domain] > 0))
			  {
			  NumObjects[C_POLY] += 1.0;
			  TPc = CheckPolygonDuplication(PolyFromFile, &TProot,SzTP,&IsDup, DblPolySkipList, skiplimit, &TPdup);
			  sliverdone = 0;
			  if(IsDup < UseDupThreshold) 
			     {
			     if((NumLODbands > 0) && (PolyLODbandCount != NULL))
				{
				jj = CrsWlk[PolyFromFile.SACindex].LODband;
				if((jj > 0) && (LODindex[jj-1].active > 0))
				   {
				   if(jj <= NumLODbands)
				      PolyLODbandCount[jj-1] += 1;
				   else
				      {
				      printf("array bounds exception with PolyLODbandCount array\n");
				      exit(-1);
				      }
				   }
				}
			     else if(NumLODbands > 0)
				{
				printf("exception - assigning values to NULL PolyLODbandCount array\n");
				exit(-1);
				}

			     sliverdone = CalculateSliverRating(PolyFromFile.x,PolyFromFile.y,PolyFromFile.z,
				       PolyFromFile.numverts,&width,&height,&sliverratio); 

			     if(TPc == NULL)
				{
				printf("allocation memory exhausted during polygon list creation operation\n");
				printf("processing cannot continue\n");
				exit(-1);
				}
			     TPc->SACindex = PolyFromFile.SACindex;
			     TPc->SCCindex = PolyFromFile.SCCindex;
			     TPc->idn = PolyFromFile.idn;
			     TPc->numverts = vtxcnt;
			     TPc->config = PolyFromFile.config;
			     TPc->stratum = PolyFromFile.stratum;
			     TPc->domain = PolyFromFile.domain;
			     TPc->insertOK = (unsigned char) 1; /** single region poly can't be dup this way **/
			     tempID = TPc->localID = fo + filedecimal;
			     TPc->minxvtx = PolyFromFile.minxvtx;
			     TPc->minyvtx = PolyFromFile.minyvtx;
			     TPc->maxxvtx = PolyFromFile.maxxvtx;
			     TPc->maxyvtx = PolyFromFile.maxyvtx;
			     jj = PlaneEquation(&PA,&PB,&PC,&PD,PolyFromFile.x,
					PolyFromFile.y,PolyFromFile.z,PolyFromFile.numverts);
			     if(jj == 1) /** then plane equation was a success **/
				{
				TPc->slope = PolygonAngle(PA,PB,PC);
				if(TPc->slope == HalfPI)
				   vertpolysurfarea = SurfaceAreaByTriangles(PolyFromFile.numverts, PolyFromFile.x,
						      PolyFromFile.y,PolyFromFile.z);
				else
				   vertpolysurfarea = 1.0;
				}
			     else
				TPc->slope = 2.0;
			     TPc->Xtra = NULL;
	   
			     TPc->x = (double *) malloc(SzD * vtxcnt);
			     TPc->y = (double *) malloc(SzD * vtxcnt);
			     TPc->z = (double *) malloc(SzD * vtxcnt);
			     if((TPc->x == NULL) || (TPc->y == NULL) || (TPc->z == NULL))
				{
				printf("allocation memory exhausted during polygon list creation operation\n");
				printf("processing cannot continue (polygon has %d vertices)\n",vtxcnt);
				exit(-1);
				}
			     for(jj = 0; jj<vtxcnt; jj++)
				{
				TPc->x[jj] = PolyFromFile.x[jj];
				TPc->y[jj] = PolyFromFile.y[jj];
				TPc->z[jj] = PolyFromFile.z[jj];
				if(jj == 0)
				   {
				   MaxElev = MinElev = PolyFromFile.z[0];
				   }
				else if(PolyFromFile.z[jj] > MaxElev)
				   MaxElev = PolyFromFile.z[jj];
				else if(PolyFromFile.z[jj] < MinElev)
				   MinElev = PolyFromFile.z[jj];
				}

			     for(checkinstance = 0; checkinstance < TtlActiveChecks; checkinstance++)
				{
				if(CombinedCheckApplies(PolyFromFile.idn,checkinstance,ELEVGT,PolyFromFile.SACindex,PolyFromFile.SCCindex,PolyFromFile.config,PolyFromFile.stratum,
					    PolyFromFile.domain,&part1,&part2,&part3))
				   {
				   if((part1 > 0) && (SensitivityCheck(GT, ELEVGT, checkinstance, MaxElev) > 0))
				      {
                                      FwriteDynamicInfo(ELEVGT,Make_Correct(ELEVGT,checkinstance),0,1,1,NULL,
                                        MinElev, -1.0, -1.0, -1.0,
                                        PolyFromFile.SCCindex,G_POLYGON,PolyFromFile.SACindex,TPc->localID,PolyFromFile.idn,-1.0,-1.0,
                                        PolyFromFile.x, PolyFromFile.y,PolyFromFile.z, 1,
                                        PolyFromFile.SCCindex,G_POLYGON,PolyFromFile.SACindex,TPc->localID,PolyFromFile.idn,-1.0,-1.0,
                                        PolyFromFile.x, PolyFromFile.y,PolyFromFile.z, 1);
				      }
				   }
				if(CombinedCheckApplies(PolyFromFile.idn,checkinstance,ELEVLT,PolyFromFile.SACindex,PolyFromFile.SCCindex,PolyFromFile.config,PolyFromFile.stratum,
					    PolyFromFile.domain,&part1,&part2,&part3))
				   {
				   if((part1 > 0) && (SensitivityCheck(LT, ELEVLT, checkinstance, MinElev) > 0))
				      {
                                      FwriteDynamicInfo(ELEVLT,Make_Correct(ELEVLT,checkinstance),0,1,1,NULL,
                                        MinElev, -1.0, -1.0, -1.0,
                                        PolyFromFile.SCCindex,G_POLYGON,PolyFromFile.SACindex,TPc->localID,PolyFromFile.idn,-1.0,-1.0,
                                        PolyFromFile.x, PolyFromFile.y,PolyFromFile.z, 1,
                                        PolyFromFile.SCCindex,G_POLYGON,PolyFromFile.SACindex,TPc->localID,PolyFromFile.idn,-1.0,-1.0,
                                        PolyFromFile.x, PolyFromFile.y,PolyFromFile.z, 1);
				      }
				   }
				if(CombinedCheckApplies(PolyFromFile.idn,checkinstance,ELEVEQ,PolyFromFile.SACindex,PolyFromFile.SCCindex,PolyFromFile.config,PolyFromFile.stratum,
					    PolyFromFile.domain,&part1,&part2,&part3))
				   {
				   if((part1 > 0) && (SensitivityCheck(CLOSEDINT, ELEVEQ, checkinstance, MinElev) > 0) &&
				      (SensitivityCheck(CLOSEDINT, ELEVEQ, checkinstance, MaxElev) > 0))
				      {
                                      FwriteDynamicInfo(ELEVEQ,Make_Correct(ELEVEQ,checkinstance),0,1,1,NULL,
                                        MinElev, -1.0, -1.0, -1.0,
                                        PolyFromFile.SCCindex,G_POLYGON,PolyFromFile.SACindex,TPc->localID,PolyFromFile.idn,-1.0,-1.0,
                                        PolyFromFile.x, PolyFromFile.y,PolyFromFile.z, 1,
                                        PolyFromFile.SCCindex,G_POLYGON,PolyFromFile.SACindex,TPc->localID,PolyFromFile.idn,-1.0,-1.0,
                                        PolyFromFile.x, PolyFromFile.y,PolyFromFile.z, 1);
				      }
				   }

                                if(CombinedCheckApplies(PolyFromFile.idn,checkinstance,ELEVEQOPEN,PolyFromFile.SACindex,PolyFromFile.SCCindex,PolyFromFile.config,PolyFromFile.stratum,
                                            PolyFromFile.domain,&part1,&part2,&part3))
                                   {
                                   if((part1 > 0) && (SensitivityCheck(OPENINT, ELEVEQOPEN, checkinstance, MinElev) > 0) &&
                                      (SensitivityCheck(OPENINT, ELEVEQOPEN, checkinstance, MaxElev) > 0))
                                      {
                                      FwriteDynamicInfo(ELEVEQOPEN,Make_Correct(ELEVEQOPEN,checkinstance),0,1,1,NULL,
                                        MinElev, -1.0, -1.0, -1.0,
                                        PolyFromFile.SCCindex,G_POLYGON,PolyFromFile.SACindex,TPc->localID,PolyFromFile.idn,-1.0,-1.0,
                                        PolyFromFile.x, PolyFromFile.y,PolyFromFile.z, 1,
                                        PolyFromFile.SCCindex,G_POLYGON,PolyFromFile.SACindex,TPc->localID,PolyFromFile.idn,-1.0,-1.0,
                                        PolyFromFile.x, PolyFromFile.y,PolyFromFile.z, 1);
                                      }
                                   }

				}


			     checkinstance = -1;
			     if((CombinedCheckApplies(PolyFromFile.idn,checkinstance,VTEAR,PolyFromFile.SACindex,PolyFromFile.SCCindex,PolyFromFile.config,PolyFromFile.stratum,
				  PolyFromFile.domain,&part1,&part2,&part3)) ||
				(CombinedCheckApplies(PolyFromFile.idn,checkinstance,HTEAR,PolyFromFile.SACindex,PolyFromFile.SCCindex,PolyFromFile.config,PolyFromFile.stratum,
				  PolyFromFile.domain,&part1,&part2,&part3)) ||
				(CombinedCheckApplies(PolyFromFile.idn,checkinstance,OVERC,PolyFromFile.SACindex,PolyFromFile.SCCindex,PolyFromFile.config,PolyFromFile.stratum,
				  PolyFromFile.domain,&part1,&part2,&part3)) ||
				(CombinedCheckApplies(PolyFromFile.idn,checkinstance,TVERT,PolyFromFile.SACindex,PolyFromFile.SCCindex,PolyFromFile.config,PolyFromFile.stratum,
				  PolyFromFile.domain,&part1,&part2,&part3)) ||
				(CombinedCheckApplies(PolyFromFile.idn,checkinstance,LSPINT,PolyFromFile.SACindex,PolyFromFile.SCCindex,PolyFromFile.config,PolyFromFile.stratum,
					    PolyFromFile.domain,&part1,&part2,&part3)) ||
				(CombinedCheckApplies(PolyFromFile.idn,checkinstance,LSPIEXP,PolyFromFile.SACindex,PolyFromFile.SCCindex,PolyFromFile.config,PolyFromFile.stratum,
					    PolyFromFile.domain,&part1,&part2,&part3)) ||
				((PolyFromFile.stratum == S_SURF) && (ErrorLookup[SLOPEDIRCH].anyactive > 0)) ||
				((PolyFromFile.stratum == S_SURF) && (ErrorLookup[LJOINSLOPEDC].anyactive > 0)))
				{
				edgesin = 0;
				for(jj=0; jj<vtxcnt; jj++)
				   {
				   ii = (jj + 1) % vtxcnt;
				   lpec = (struct ListOfEdges *) (malloc(SzLE));
				   if(lpec == NULL)
				      {
				      printf("allocation memory exhausted during polygon edge assemble operation\n");
				      printf("processing cannot continue (%d verticex poly involved)\n",vtxcnt);
				      exit(-1);
				      }
				   lpec->x1 = PolyFromFile.x[jj];
				   lpec->y1 = PolyFromFile.y[jj];
				   lpec->z1 = PolyFromFile.z[jj];
				   lpec->x2 = PolyFromFile.x[ii];
				   lpec->y2 = PolyFromFile.y[ii];
				   lpec->z2 = PolyFromFile.z[ii];

				   if(lpec->x1 < lpec->x2)
				      {
				      lpec->minx = lpec->x1;
				      lpec->maxx = lpec->x2;
				      }
				   else
				      {
				      lpec->minx = lpec->x2;
				      lpec->maxx = lpec->x1;
				      }
				   if(lpec->y1 < lpec->y2)
				      {
				      lpec->miny = lpec->y1;
				      lpec->maxy = lpec->y2;
				      }
				   else
				      {
				      lpec->miny = lpec->y2;
				      lpec->maxy = lpec->y1;
				      }
				   lpec->rise = lpec->y2 - lpec->y1;
				   lpec->run = lpec->x2 - lpec->x1;
				   if(lpec->run != 0)
				      {
				      lpec->slope = lpec->rise / lpec->run;
				      lpec->Bval = lpec->y1 - (lpec->slope * lpec->x1);
				      }
				   else
				      {
				      lpec->slope = 0;
				      lpec->Bval = 0;
				      }
	   
				   if(MinValsWereInit == 0)
				      {
				      rlx = lpec->minx;
				      rux = lpec->maxx;
				      rly = lpec->miny;
				      ruy = lpec->maxy;
				      MinValsWereInit = 1;
				      }
				   else
				      {
				      if(lpec->minx < rlx)
					 rlx = lpec->minx;
				      if(lpec->maxx > rux)
					 rux = lpec->maxx;
				      if(lpec->miny < rly)
					 rly = lpec->miny;
				      if(lpec->maxy > ruy)
					 ruy = lpec->maxy;
				      }

				   lpec->owner = (long int) TPc; /** ptr to poly this edges belongs to **/
				   lpec->ownernumb = jj; /** edge number in the owning poly **/
				   lpec->clipped = 0; /** edge did not need clipping, so no vtx replaced **/
				   lpec->isT = 0;
				   lpec->length = Distance(lpec->x1,lpec->y1,lpec->x2,lpec->y2);
				   lpec->Tcover = 0.0;
				   lpec->Ocover = 0.0;
				   lpec->Iedge = NULL;
				   lpec->DeltaZ1 = lpec->DeltaZ2 = 0.0;

				   ii = 0;
				   if((sliverdone == 0) || (sliverratio < 0.001))
				      ii = EdgeSliverCheckOK(lpec, PolyEdgeRoot, edgesin);
				   else
				      ii = 1;
				   if((ii > 0)&& (lpec->length > 0))
				      {
				      if(TPc->slope != HalfPI)
					 {
					 ++edgesin;
					 lpec->next = NULL;
					 InsertIntoEdgeList(lpec, &PolyEdgeRoot, DblPolyEdgeSkipList, skiplimit);
					 }
				      else
					 {
					 ++edgesin;
					 if(vertpolysurfarea > 0)
					    {
					    lpec->next = VertPolyEdgeRoot;
					    VertPolyEdgeRoot = lpec;
					    }
					 else
					    free(lpec);
					 }
				      }
				   else
				      free(lpec);
				   }
				} /** end inserting into edge list **/
			     } /** end if not a duplicate **/
			  else
			     {
			     tempID = fo + filedecimal;
			     }
			     
			  for(checkinstance = 0; checkinstance < TtlActiveChecks; checkinstance++)
			     {
			       if(
				  (IsDup == 1) &&
				  (CombinedCheckApplies(PolyFromFile.idn,checkinstance,G_DUPS,PolyFromFile.SACindex,PolyFromFile.SCCindex,
							PolyFromFile.config,
							PolyFromFile.stratum,PolyFromFile.domain,&part1,&part2,&part3))  &&
					   (part1 > 0) &&
				      (CombinedCheckApplies(TPdup->idn,checkinstance,G_DUPS,TPdup->SACindex,TPdup->SCCindex,
				       SCCtable[TPdup->SCCindex].C, SCCtable[TPdup->SCCindex].S, SCCtable[TPdup->SCCindex].D,
							   &part1,&part2,&part3)) && (part2 > 0)
				  )
				 {
				   FwriteTwoObjects(G_DUPS,Make_Correct(G_DUPS,checkinstance), 
						    PolyFromFile.idn,G_POLYGON,PolyFromFile.SACindex,tempID,PolyFromFile.SCCindex,-1.0,-1.0,
						    PolyFromFile.numverts,
						    PolyFromFile.x,PolyFromFile.y,PolyFromFile.z,
						    TPdup->idn,G_POLYGON,TPdup->SACindex,TPdup->localID,TPdup->SCCindex,-1.0,-1.0,TPdup->numverts,
						    TPdup->x, TPdup->y,TPdup->z);
				 }
			       

			     if(
				(IsDup == 4) &&
				(CombinedCheckApplies(PolyFromFile.idn,checkinstance,C_DUPS,PolyFromFile.SACindex,
						      PolyFromFile.SCCindex,PolyFromFile.config,
						      PolyFromFile.stratum,PolyFromFile.domain,&part1,&part2,&part3))  &&
					   (part1 > 0) &&
				      (CombinedCheckApplies(TPdup->idn,checkinstance,C_DUPS,TPdup->SACindex,TPdup->SCCindex,
				       SCCtable[TPdup->SCCindex].C, SCCtable[TPdup->SCCindex].S, SCCtable[TPdup->SCCindex].D,
							   &part1,&part2,&part3)) && (part1 > 0)
				)
			       {
				 FwriteTwoObjects(C_DUPS,Make_Correct(C_DUPS,checkinstance), 
						  PolyFromFile.idn,G_POLYGON,PolyFromFile.SACindex,tempID,PolyFromFile.SCCindex,-1.0,-1.0,
						  PolyFromFile.numverts,PolyFromFile.x,
						  PolyFromFile.y,PolyFromFile.z,
						  TPdup->idn,G_POLYGON,TPdup->SACindex,TPdup->localID,TPdup->SCCindex,-1.0,-1.0,
						  TPdup->numverts,TPdup->x, TPdup->y,TPdup->z);
			       }

			     if(IsDup < UseDupThreshold)
			       {
				 if(sliverdone == 0)
				   {
				     sliverdone = CalculateSliverRating(PolyFromFile.x,PolyFromFile.y,PolyFromFile.z,
									PolyFromFile.numverts,&width,&height,&sliverratio);
				   }


				if((CombinedCheckApplies(PolyFromFile.idn,checkinstance,V_DUPS,PolyFromFile.SACindex,PolyFromFile.SCCindex,
							PolyFromFile.config,PolyFromFile.stratum,PolyFromFile.domain,
							&part1,&part2,&part3)) && (part1 > 0))
				   {
				   dv = DuplicateVerticesExist(PolyFromFile.numverts,
								  PolyFromFile.x,PolyFromFile.y,PolyFromFile.z);
				   if(SensitivityCheck(GT, V_DUPS, checkinstance, (double) dv) > 0)
				     {
				       for(jj=1; jj<PolyFromFile.numverts; jj++)
					 {
					 if((PolyFromFile.x[jj-1] == PolyFromFile.x[jj]) &&
					     (PolyFromFile.y[jj-1] == PolyFromFile.y[jj]) &&
					     (PolyFromFile.z[jj-1] == PolyFromFile.z[jj]))
					    {
                                            FwriteObject(V_DUPS,Make_Correct(V_DUPS,checkinstance),PolyFromFile.SACindex,
                                                           PolyFromFile.SCCindex,G_POLYGON,TPc->localID,PolyFromFile.idn, -1.0, -1.0,
                                                            &PolyFromFile.x[jj],&PolyFromFile.y[jj],&PolyFromFile.z[jj],1, 1);
					    }
					 }
				     }
				   }



				if((CombinedCheckApplies(PolyFromFile.idn,checkinstance,SLIVER,PolyFromFile.SACindex,PolyFromFile.SCCindex,
							PolyFromFile.config,
							PolyFromFile.stratum,PolyFromFile.domain,&part1,&part2,&part3)) && (part1 > 0))
				  {
				    if(
				       (sliverdone > 0) && 
				       (SensitivityCheck(LT, SLIVER, checkinstance, sliverratio) > 0)
				       )
				      {
					FwriteObjectAndMagnitude(SLIVER,Make_Correct(SLIVER,checkinstance),
								 PolyFromFile.idn,PolyFromFile.SCCindex,
								 G_POLYGON, PolyFromFile.SACindex,TPc->localID,-1.0,-1.0,sliverratio,
								 PolyFromFile.x, PolyFromFile.y,PolyFromFile.z,
								 PolyFromFile.numverts, 1);
				      }
				  }
				


				if((CombinedCheckApplies(PolyFromFile.idn,checkinstance,NARROW,PolyFromFile.SACindex,PolyFromFile.SCCindex,
							PolyFromFile.config,PolyFromFile.stratum,PolyFromFile.domain,
							&part1,&part2,&part3)) && (part1 > 0))
				  {
				    if(
				       (sliverdone > 0) && 
				       (SensitivityCheck(LT, NARROW, checkinstance, width) > 0)
				       )
				      {
					FwriteObjectAndMagnitude(NARROW,Make_Correct(NARROW,checkinstance),
								 PolyFromFile.idn, PolyFromFile.SCCindex,
								 G_POLYGON, PolyFromFile.SACindex,TPc->localID,-1.0,-1.0,width,
								 PolyFromFile.x, PolyFromFile.y,PolyFromFile.z,
								 PolyFromFile.numverts, 1);
				      }
				  }




				if((CombinedCheckApplies(PolyFromFile.idn,checkinstance,SMALLOBJ,PolyFromFile.SACindex,PolyFromFile.SCCindex,
							PolyFromFile.config,PolyFromFile.stratum,PolyFromFile.domain,
							&part1,&part2,&part3)) && (part1 > 0))
				  {
				    surfacearea3D = SurfaceAreaByTriangles(PolyFromFile.numverts, PolyFromFile.x,
									   PolyFromFile.y,PolyFromFile.z);
				    if(SensitivityCheck(LT, SMALLOBJ, checkinstance, surfacearea3D) > 0)
				      {
					FwriteObjectAndMagnitude(SMALLOBJ,Make_Correct(SMALLOBJ,checkinstance),
								 PolyFromFile.idn, PolyFromFile.SCCindex,
								 G_POLYGON, PolyFromFile.SACindex,TPc->localID,-1.0,-1.0,surfacearea3D,
								 PolyFromFile.x, PolyFromFile.y,PolyFromFile.z,
								 PolyFromFile.numverts, 1);
				      }
				   }


                                 if(CombinedCheckApplies(PolyFromFile.idn,checkinstance,PERIMLEN,PolyFromFile.SACindex,PolyFromFile.SCCindex,
                                                              PolyFromFile.config,PolyFromFile.stratum,PolyFromFile.domain,
                                                              &part1,&part2,&part3))
                                        {
                                          if((part1 > 0) && (PolyFromFile.numverts > 1))
                                             {
                                             segmentlength = 0;
                                             for(jj=1; jj<PolyFromFile.numverts; jj++)
                                                {
                                                segmentlength += Distance3D(PolyFromFile.x[jj-1],PolyFromFile.y[jj-1],PolyFromFile.z[jj-1],
                                                                           PolyFromFile.x[jj],PolyFromFile.y[jj],PolyFromFile.z[jj]);
                                                }
                                             segmentlength += Distance3D(PolyFromFile.x[jj-1],PolyFromFile.y[jj-1],PolyFromFile.z[jj-1],
                                                                           PolyFromFile.x[0],PolyFromFile.y[0],PolyFromFile.z[0]);
                                             if(SensitivityCheck(LTEQ, PERIMLEN, checkinstance, segmentlength) > 0)
                                                {
                                                FwriteObjectAndMagnitude(PERIMLEN,Make_Correct(PERIMLEN,checkinstance),
                                                                  PolyFromFile.idn,
                                                                  PolyFromFile.SCCindex,G_POLYGON,PolyFromFile.SACindex,TPc->localID,
                                                                  -1.0,-1.0,segmentlength,
                                                                  PolyFromFile.x, PolyFromFile.y,PolyFromFile.z,PolyFromFile.numverts, 1);
                                                }

                                             }
                                        }

                                 if(CombinedCheckApplies(PolyFromFile.idn,checkinstance,SEGLEN,PolyFromFile.SACindex,PolyFromFile.SCCindex,
                                                              PolyFromFile.config,PolyFromFile.stratum,PolyFromFile.domain,
                                                              &part1,&part2,&part3))
                                        {
                                          if((part1 > 0) && (PolyFromFile.numverts > 1))
                                             {
                                             for(jj=0; jj<PolyFromFile.numverts; jj++)
                                                {
                                                if(jj == 0)
                                                   jj2 = PolyFromFile.numverts-1;
                                                else
                                                   jj2 = jj - 1;
                                                if((PolyFromFile.x[jj] != PolyFromFile.x[jj2]) || (PolyFromFile.y[jj] != PolyFromFile.y[jj2]) ||
                                                    (PolyFromFile.z[jj] != PolyFromFile.z[jj2]))
                                                   {
                                                      segmentlength = Distance3D(PolyFromFile.x[jj2],PolyFromFile.y[jj2],PolyFromFile.z[jj2],
                                                                           PolyFromFile.x[jj],PolyFromFile.y[jj],PolyFromFile.z[jj]);
                                                      if(SensitivityCheck(LTEQ, SEGLEN, checkinstance, segmentlength) > 0)
                                                         {
                                                         edgeX[0] = PolyFromFile.x[jj2];
                                                         edgeY[0] = PolyFromFile.y[jj2];
                                                         edgeZ[0] = PolyFromFile.z[jj2];
                                                         edgeX[1] = PolyFromFile.x[jj];
                                                         edgeY[1] = PolyFromFile.y[jj];
                                                         edgeZ[1] = PolyFromFile.z[jj];
                                                         FwriteObjectAndMagnitude(SEGLEN,Make_Correct(SEGLEN,checkinstance),
                                                                     PolyFromFile.idn,
                                                                     PolyFromFile.SCCindex,G_POLYGON,PolyFromFile.SACindex,TPc->localID,
                                                                     -1.0,-1.0,segmentlength,
                                                                     &edgeX[0], &edgeY[0],&edgeZ[0],2, 1);
                                                      }
                                                   }
                                                }
                                             }
                                        }



				if((CombinedCheckApplies(PolyFromFile.idn,checkinstance,ATTRERR,PolyFromFile.SACindex,PolyFromFile.SCCindex,
							PolyFromFile.config,PolyFromFile.stratum,PolyFromFile.domain,
							&part1,&part2,&part3)) && (part1 > 0))
				  {
				    if(CrsWlk[PolyFromFile.SACindex].AttrErr >= 0)
				      {
					FwriteObjectAndMessage(ATTRERR,Make_Correct(ATTRERR,checkinstance),
							       PolyFromFile.idn, G_POLYGON,PolyFromFile.SACindex,TPc->localID,
							       PolyFromFile.SCCindex,-1.0,-1.0,PolyFromFile.x,
							       PolyFromFile.y,PolyFromFile.z,PolyFromFile.numverts,
							       AttrErr[CrsWlk[PolyFromFile.SACindex].AttrErr].description);
				      }
				   }





				if(
				   (CombinedCheckApplies(PolyFromFile.idn,checkinstance,HSLOPE,PolyFromFile.SACindex,PolyFromFile.SCCindex,
							 PolyFromFile.config, PolyFromFile.stratum,PolyFromFile.domain,
							 &part1,&part2,&part3)) 
				   ||
				   (CombinedCheckApplies(PolyFromFile.idn,checkinstance,VERTSLOPE,PolyFromFile.SACindex,PolyFromFile.SCCindex,
							 PolyFromFile.config,PolyFromFile.stratum,PolyFromFile.domain,
							 &part1,&part2,&part3))
				   )
				   {
				     if(TPc->slope < 1.75) /** then plane equation was a success **/
				       {
					 angle = TPc->slope;
					 if((angle >= HalfPI) &&
					    (CombinedCheckApplies(PolyFromFile.idn,checkinstance,VERTSLOPE,PolyFromFile.SACindex,
								  PolyFromFile.SCCindex,PolyFromFile.config,
								  PolyFromFile.stratum,PolyFromFile.domain,
								  &part1,&part2,&part3)) && (part1 > 0))
					   {
					     FwriteObject(VERTSLOPE,Make_Correct(VERTSLOPE,checkinstance),
							  PolyFromFile.SACindex,
							  PolyFromFile.SCCindex, G_POLYGON,TPc->localID /** need poly localID here **/,PolyFromFile.idn,-1.0,-1.0,
							  PolyFromFile.x,PolyFromFile.y,PolyFromFile.z,PolyFromFile.numverts, 1);
					   }
					 

					 angle = RadiansToDegrees(angle);
					 if(
					    (CombinedCheckApplies(PolyFromFile.idn,checkinstance,HSLOPE,PolyFromFile.SACindex,
								  PolyFromFile.SCCindex,PolyFromFile.config,
								  PolyFromFile.stratum,PolyFromFile.domain,
								  &part1,&part2,&part3)) 
					    && (part1 > 0) &&
					    (SensitivityCheck(GTEQ, HSLOPE, checkinstance, angle) > 0)
					    )
					   {
					     FwriteObjectAndMagnitude(HSLOPE,Make_Correct(HSLOPE,checkinstance),
								      PolyFromFile.idn, 
								      PolyFromFile.SCCindex,G_POLYGON, PolyFromFile.SACindex,
								      TPc->localID,-1.0,-1.0,
								      angle,PolyFromFile.x, PolyFromFile.y,PolyFromFile.z,
								      PolyFromFile.numverts, 1);
					   }
				       }
				   }
				}
			     } /*** end for(checkinstance = 0; checkinstance < TtlActiveChecks; checkinstance++) ***/
			  }
		       ++valuesread;
		       free(PolyFromFile.x);
		       free(PolyFromFile.y);
		       free(PolyFromFile.z);
		       }
	/*** now have all the polygons in this region - what to do with them ?? ***/



		    CheckEdgeTopology(PolyEdgeRoot,VertPolyEdgeRoot,1);
		    lpec = PolyEdgeRoot;





		    while(lpec != NULL)
		      {
			for(checkinstance = 0; checkinstance < TtlActiveChecks; checkinstance++)
			  {

			    TPn = (struct ThePolys *) lpec->owner;
			    LA = lpec->length - lpec->Tcover;
			 

			    if(
			       (lpec->Tcover < lpec->length) && /*** undercovered edge **/
			       (CombinedCheckApplies(TPn->idn,checkinstance,HTEAR,TPn->SACindex,TPn->SCCindex,
						     TPn->config,TPn->stratum,TPn->domain,
						     &part1,&part2,&part3) > 0)   && (part1 > 0)
			       )
			      {


				neighborhit = 0;
				if((lpec->x1 == MinSurfXcoord) && (lpec->x2 == MinSurfXcoord))
				  ++neighborhit;
				else if((lpec->x1 == MaxSurfXcoord) && (lpec->x2 == MaxSurfXcoord))
				  ++neighborhit;
				if((lpec->y1 == MinSurfYcoord) && (lpec->y2 == MinSurfYcoord))
				  ++neighborhit;
				else if((lpec->y1 == MaxSurfYcoord) && (lpec->y2 == MaxSurfYcoord))
				  ++neighborhit;
				if(neighborhit == 0) 
				{
				if(NeighborsExist[0] == 0)
				   {
				   if((PointOnLineSegment(lpec->x1,lpec->y1,rlx,rly,rux,rly,0.01) > 0) && 
				    (PointOnLineSegment(lpec->x2,lpec->y2,rlx,rly,rux,rly,0.01) > 0))
				   ++neighborhit;
				   }
				if(NeighborsExist[1] == 0)
				   {
				   if((PointOnLineSegment(lpec->x1,lpec->y1,rlx,rly,rlx,ruy,0.01) > 0) &&            
				    (PointOnLineSegment(lpec->x2,lpec->y2,rlx,rly,rlx,ruy,0.01) > 0))
				   ++neighborhit;
				   }
				if(NeighborsExist[2] == 0)
				   {
				   if((PointOnLineSegment(lpec->x1,lpec->y1,rlx,ruy,rux,ruy,0.01) > 0) &&            
				       (PointOnLineSegment(lpec->x2,lpec->y2,rlx,ruy,rux,ruy,0.01) > 0))
				   ++neighborhit;
				   }
				if(NeighborsExist[3] == 0)
				   {
				   if((PointOnLineSegment(lpec->x1,lpec->y1,rux,rly,rux,ruy,0.01) > 0) &&            
					  (PointOnLineSegment(lpec->x2,lpec->y2,rux,rly,rux,ruy,0.01) > 0))
				   ++neighborhit;
				   }


				   LineEquation(lpec->x1,lpec->y1,lpec->x2,lpec->y2,&LA,&LB,&LC);
	   
				   if(lpec->clipped == 0)
				      {
					origx1 = lpec->x1;
					origx2 = lpec->x2;
					origy1 = lpec->y1;
					origy2 = lpec->y2;

					avgx1 = ((lpec->x1 - lpec->x2) / 2) + lpec->x2;
					avgy1 = ((lpec->y1 - lpec->y2) / 2) + lpec->y2;
				      }
				   else
				     {
				       clipx1 = lpec->x1;
				       clipy1 = lpec->y1;
				       clipz1 = lpec->z1;
				       clipx2 = lpec->x2;
				       clipy2 = lpec->y2;
				       clipz2 = lpec->z2;
				       ClipLineToRegion(minx,miny,maxx,maxy,
							&clipx1,&clipy1,&clipz1,
							&clipx2,&clipy2,&clipz2, &clipflag, multiplier);
				       
				       origx1 = clipx1;
				       origx2 = clipx2;
				       origy1 = clipy1;
				       origy2 = clipy2;
				       
				       avgx1 = ((clipx1 - clipx2) / 2) + clipx2;
				       avgy1 = ((clipy1 - clipy2) / 2) + clipy2;
				      }


				   if(
				      (neighborhit == 0) || 
				      InSmidge(origx1,origx2) ||
				      InSmidge(origy1,origy2) 
				      )
				      {


				   tempsensitivity = FindRelevantSensitivity(HTEAR,checkinstance,&dbljunk);
				   avgx2 = avgx1 + (2 * tempsensitivity);


				   if(LA == 0)
				      avgy2 = avgy1;
				   else
				      {
				      LB2 = LB / LA;
				      avgy2 = (LB2 * avgx2) + avgy1  -LB2 * avgx1;
				      }

				   LLdm1 = tempsensitivity / Distance(avgx1,avgy1,avgx2,avgy2);
				   vx1 = avgx1 + LLdm1 * (avgx2 - avgx1);
				   vy1 = avgy1 + LLdm1 * (avgy2 - avgy1);
				   FirstCheck = 0;




				   if(
				      InSmidge(origx1,origx2) ||
				      InSmidge(origy1,origy2) 
				      )
				     {
				       SpecialCase = 1;
				       FirstCheck = 10;
				       if(InSmidge(origx1,origx2))
					  {
					    testx1 = origx1 + 2 * tempsensitivity;
					    testx2 = origx1 - 2 * tempsensitivity;
					    testy1 = (origy1+origy2)/2.0;				    
					    testy2 = testy1;
					  }
				       else
					 {
					    testy1 = origy1 + 2 * tempsensitivity;
					    testy2 = origy1 - 2 * tempsensitivity;
					    testx1 = (origx1+origx2)/2.0;				    
					    testx2 = testx1;
					 }
				       
				       
				       TPc2 = TProot;
				       while(TPc2 != NULL)
					 {
					   if((TPc2 != TPn) && (CombinedCheckApplies(TPc2->idn,checkinstance,HTEAR,TPc2->SACindex,TPc2->SCCindex,
								   TPc2->config,TPc2->stratum,TPc2->domain,
								   &part1,&part2,&part3) > 0) && (part1 > 0))
					     {
					       if(TPc2->numverts == 3)
						 {
						   if (PointInsideTriangle(testx1,testy1, TPc2->x[0], TPc2->y[0],
									   TPc2->x[1], TPc2->y[1], TPc2->x[2], TPc2->y[2]) > 0)
						     {
						       SpecialCase = -1;  /* we did the special case, but didnt find a hole */
						       break;
						     }

						   if (PointInsideTriangle(testx2,testy2, TPc2->x[0], TPc2->y[0],
									   TPc2->x[1], TPc2->y[1], TPc2->x[2], TPc2->y[2]) > 0)
						     {
						       SpecialCase = -1;  /* we did the special case, but didnt find a hole */
						       break;
						     }
						 }
					       else
						 {
						   if(PointInsidePoly(testx1,testy1, TPc2->x, TPc2->y, TPc2->numverts) > 0)
						     {
						       SpecialCase = -1;  /* we did the special case, but didnt find a hole */
						       break;
						     }
						   
						   if(PointInsidePoly(testx2,testy2, TPc2->x, TPc2->y, TPc2->numverts) > 0)
						     {
						       SpecialCase = -1;  /* we did the special case, but didnt find a hole */
						       break;
						     }
						 }
					     }
					   TPc2 = TPc2->next;
					 }
				     }


				   else
				     {   
				       SpecialCase = 0;
				       testx1 = vx1;
				       testy1 = vy1;
				       TPc2 = TProot;
				       while(TPc2 != NULL)
					 {
					   if((CombinedCheckApplies(TPc2->idn,checkinstance,HTEAR,TPc2->SACindex,TPc2->SCCindex,
								   TPc2->config,TPc2->stratum,TPc2->domain,
								   &part1,&part2,&part3) > 0) && (part1 > 0))
					     {
					       if((TPc2->numverts == 3) &&
						  (PointInsideTriangle(vx1,vy1, TPc2->x[0], TPc2->y[0],
								       TPc2->x[1], TPc2->y[1], TPc2->x[2], TPc2->y[2]) > 0))
						 {
						   ++FirstCheck;
						   break;
						 }
					       else if(PointInsidePoly(vx1,vy1, TPc2->x, TPc2->y, TPc2->numverts) > 0)
						 {
						   ++FirstCheck;
						   break;
						 }
					     }
					   TPc2 = TPc2->next;
					 }



					   avgx2 = avgx1 - 2 * tempsensitivity;   
					   if(LA == 0)
					     avgy2 = avgy1;
					   else
					     {
					       LB2 = LB / LA;
					       avgy2 = (LB2 * avgx2) + avgy1  -LB2 * avgx1;
					     }
					   vx1 = avgx1 + LLdm1 * (avgx2 - avgx1);
					   vy1 = avgy1 + LLdm1 * (avgy2 - avgy1);
					   testx2 = vx1;
					   testy2 = vy1;
					if(FirstCheck == 1)
					   {
					   
					   TPc2 = TProot;
					   while(TPc2 != NULL)
					     {
					       if((CombinedCheckApplies(TPc2->idn,checkinstance,HTEAR,TPc2->SACindex,TPc2->SCCindex,
								       TPc2->config,TPc2->stratum,TPc2->domain,
								       &part1,&part2,&part3) > 0) && (part1 > 0))
						 {
						   if((TPc2->numverts == 3) &&
						      (PointInsideTriangle(vx1,vy1, TPc2->x[0], TPc2->y[0],
									   TPc2->x[1], TPc2->y[1], TPc2->x[2], TPc2->y[2]) > 0))
						     {
						       ++FirstCheck;
						       break;
						     }
						   else if(PointInsidePoly(vx1,vy1, TPc2->x, TPc2->y, TPc2->numverts) > 0)
						     {
						       ++FirstCheck;
						       break;
						     }
						 }
					       TPc2 = TPc2->next;
					     }
					 }
				     }

				   
				   if((FirstCheck < 2) || (SpecialCase==1))
				      {
				       OnlyUsePolysForElevLookup = 1;
				      if((GetPointElevation(testx1,testy1,&vx1) == 0) ||
					  (GetPointElevation(testx2,testy2,&vx1) == 0))
					 {
				      edgeX[0] = lpec->x1;
				      edgeY[0] = lpec->y1;
				      edgeZ[0] = lpec->z1;
				      edgeX[1] = lpec->x2; 
				      edgeY[1] = lpec->y2;
				      edgeZ[1] = lpec->z2;
				      FwriteObjectAndMagnitude(HTEAR,Make_Correct(HTEAR,checkinstance),
					     TPn->idn, TPn->SCCindex,G_POLYGON,TPn->SACindex,TPn->localID,-1.0,-1.0,
					     999999,edgeX, edgeY,edgeZ,2, 1);
					 }
				       OnlyUsePolysForElevLookup = 0;
				      }
				   }
				}
			     }



			    if((lpec->Tcover < lpec->length) && /*** undercovered edge **/
			       (CombinedCheckApplies(TPn->idn,checkinstance,OVERC,TPn->SACindex,TPn->SCCindex,TPn->config,TPn->stratum,
						     TPn->domain,&part1,&part2,&part3) > 0) && (part1 > 0))
			      {
			     pcCoverage = 1.0 - (lpec->Tcover / lpec->length);
			     pcCoverage = pcCoverage * 100.0;
			     neighborhit = 0;
			     if((lpec->x1 == MinSurfXcoord) && (lpec->x2 == MinSurfXcoord))
				++neighborhit;
			     else if((lpec->x1 == MaxSurfXcoord) && (lpec->x2 == MaxSurfXcoord))
				++neighborhit;
			     if((lpec->y1 == MinSurfYcoord) && (lpec->y2 == MinSurfYcoord))
				++neighborhit;
			     else if((lpec->y1 == MaxSurfYcoord) && (lpec->y2 == MaxSurfYcoord))
				++neighborhit;
			     if((neighborhit == 0) && /****(pcCoverage > ErrorLookup[OVERC].sensitivity))****/
				    (SensitivityCheck(GT, OVERC, checkinstance, pcCoverage) > 0))
				{
				if(NeighborsExist[0] == 0)
				   {
				   if((PointOnLineSegment(lpec->x1,lpec->y1,rlx,rly,rux,rly,0.01) > 0) &&
				    (PointOnLineSegment(lpec->x2,lpec->y2,rlx,rly,rux,rly,0.01) > 0))
				   ++neighborhit;
				   }
				if(NeighborsExist[1] == 0)
				   {
				   if((PointOnLineSegment(lpec->x1,lpec->y1,rlx,rly,rlx,ruy,0.01) > 0) &&
				    (PointOnLineSegment(lpec->x2,lpec->y2,rlx,rly,rlx,ruy,0.01) > 0))
				   ++neighborhit;
				   }
				if(NeighborsExist[2] == 0)
				   {
				   if((PointOnLineSegment(lpec->x1,lpec->y1,rlx,ruy,rux,ruy,0.01) > 0) &&
				       (PointOnLineSegment(lpec->x2,lpec->y2,rlx,ruy,rux,ruy,0.01) > 0))
				   ++neighborhit;
				   }
				if(NeighborsExist[3] == 0)
				   {
				   if((PointOnLineSegment(lpec->x1,lpec->y1,rux,rly,rux,ruy,0.01) > 0) &&
				       (PointOnLineSegment(lpec->x2,lpec->y2,rux,rly,rux,ruy,0.01) > 0))
				   ++neighborhit;
				   }
				if(neighborhit == 0)
				   {
				   FirstCheck = 1;

				   LineEquation(lpec->x1,lpec->y1,lpec->x2,lpec->y2,&LA,&LB,&LC);
	   
				   if(lpec->clipped == 0)
				      {
				      avgx1 = ((lpec->x1 - lpec->x2) / 2) + lpec->x2;
				      avgy1 = ((lpec->y1 - lpec->y2) / 2) + lpec->y2;
				      }
				   else
				      {
				      clipx1 = lpec->x1;
				      clipy1 = lpec->y1;
				      clipz1 = lpec->z1;
				      clipx2 = lpec->x2;
				      clipy2 = lpec->y2;
				      clipz2 = lpec->z2;
				      ClipLineToRegion(minx,miny,maxx,maxy,&clipx1,&clipy1,&clipz1,&clipx2,&clipy2,&clipz2, &clipflag, multiplier);
				      avgx1 = ((clipx1 - clipx2) / 2) + clipx2;
				      avgy1 = ((clipy1 - clipy2) / 2) + clipy2;
				      }

				   tempsensitivity = FindRelevantSensitivity(OVERC,checkinstance,&dbljunk);
				   avgx2 = avgx1 + 2 * tempsensitivity; 
				   if(LA == 0)
				      avgy2 = avgy1;
				   else
				      {
				      LB2 = LB / LA;
				      avgy2 = (LB2 * avgx2) + avgy1  -LB2 * avgx1;
				      }
				   LLdm1 = tempsensitivity / Distance(avgx1,avgy1,avgx2,avgy2);
				   vx1 = avgx1 + LLdm1 * (avgx2 - avgx1);
				   vy1 = avgy1 + LLdm1 * (avgy2 - avgy1);
				   FirstCheck = 0;
				   if((TPn->minxvtx <= vx1) && (TPn->maxxvtx >= vx1) &&
				       (TPn->minyvtx <= vy1) && (TPn->maxyvtx >= vy1))
				      {
				      if((TPn->numverts == 3) &&
					       (PointInsideTriangle(vx1,vy1, TPn->x[0], TPn->y[0],
						    TPn->x[1], TPn->y[1], TPn->x[2], TPn->y[2]) > 0))
					 {
					 ++FirstCheck;
					 }
				      else if(PointInsidePoly(vx1,vy1, TPn->x, TPn->y, TPn->numverts) > 0)
					 {
					 ++FirstCheck;
					 }
				      }
				   if(FirstCheck == 0)
				      {
				      avgx2 = avgx1 - 2 * tempsensitivity; 
				      if(LA == 0)
					 avgy2 = avgy1;
				      else
					 {
					 LB2 = LB / LA;
					 avgy2 = (LB2 * avgx2) + avgy1  -LB2 * avgx1;
					 }
				      vx1 = avgx1 + LLdm1 * (avgx2 - avgx1);
				      vy1 = avgy1 + LLdm1 * (avgy2 - avgy1);
				      if((TPn->numverts == 3) &&
					       (PointInsideTriangle(vx1,vy1, TPn->x[0], TPn->y[0],
						    TPn->x[1], TPn->y[1], TPn->x[2], TPn->y[2]) > 0))
					 {
					 ++FirstCheck;
					 }
				      else if(PointInsidePoly(vx1,vy1, TPn->x, TPn->y, TPn->numverts) > 0)
					 {
					 ++FirstCheck;
					 }
				      }
				   if(FirstCheck > 0)
				      {
					TPc2 = TProot;
					while(TPc2 != NULL)
					  {
					    if((TPc2 != TPn) &&
					       (TPc2->minxvtx <= vx1) && (TPc2->maxxvtx >= vx1) &&
					       (TPc2->minyvtx <= vy1) && (TPc2->maxyvtx >= vy1) &&
					       (CombinedCheckApplies(TPc2->idn,checkinstance,OVERC,TPc2->SACindex,TPc2->SCCindex,TPc2->config,TPc2->stratum,
						     TPc2->domain,&part1,&part2,&part3) > 0) &&
					   (part1 > 0))
					    {
					    if((TPc2->numverts == 3) &&
						     (PointInsideTriangle(vx1,vy1, TPc2->x[0], TPc2->y[0],
							  TPc2->x[1], TPc2->y[1], TPc2->x[2], TPc2->y[2]) > 0))
					       {
					       ++FirstCheck;
					       break;
					       }
					    else if(PointInsidePoly(vx1,vy1, TPc2->x, TPc2->y, TPc2->numverts) > 0)
					       {
					       ++FirstCheck;
					       break;
					       }
					    }
					 TPc2 = TPc2->next;
					 }
				      }
				   if(FirstCheck > 1)
				      {
				      PlaneEquation(&PA2,&PB2,&PC2,&PD2,TPn->x,TPn->y,TPn->z,TPn->numverts);
				      if(PC2 == 0)
					 vz1 = lpec->z1;
				      else
					 {
					 SolveForZ(PA2,PB2,PC2,PD2,vx1,vy1,&vz1);
					 }
				      PlaneEquation(&PA2,&PB2,&PC2,&PD2,TPc2->x,TPc2->y,TPc2->z,TPc2->numverts);
				      if(PC2 == 0)
					 vz2 = TPc2->z[0];
				      else
					 {
					 SolveForZ(PA2,PB2,PC2,PD2,vx1,vy1,&vz2);
					 }
				      if(vz1 > vz2)
					 vz2 = vz1 - vz2;
				      else
					 vz2 = vz2 - vz1;

				      tempsensitivity = FindRelevantSensitivity(HTEAR,checkinstance,&dbljunk);
				      if(vz2 > dbljunk)
					 {
					 edgeX[0] = lpec->x1;
					 edgeY[0] = lpec->y1;
					 edgeZ[0] = lpec->z1;
					 edgeX[1] = lpec->x2;
					 edgeY[1] = lpec->y2;
					 edgeZ[1] = lpec->z2;
					 FwriteObjectAndMagnitude(OVERC,Make_Correct(OVERC,checkinstance),
					     TPn->idn, TPn->SCCindex,G_POLYGON,TPn->SACindex,TPn->localID,-1.0,-1.0,
					     vz2,edgeX, edgeY,edgeZ,2, 1);
					 }
				      }
				   }
				}
			      }

			  


			    if((CombinedCheckApplies(TPn->idn,checkinstance,VTEAR,TPn->SACindex,TPn->SCCindex,TPn->config,TPn->stratum,
						    TPn->domain,&part1,&part2,&part3) > 0) && (part1 > 0))
			      {
				
				/* already checked to see that lpec->owner is applicable poly */
				
				IE1 = lpec->Iedge;
				while(IE1 != NULL)
				  {
				    
				    if((IE1->primary == 1)  && /** to avoid a doubl-count ***/
				       (SensitivityCheck(GT, VTEAR, checkinstance, IE1->DeltaZ) > 0))
				      {
					AdjEdge = (struct ListOfEdges *) IE1->AdjacentEdge;
					TPadj = (struct ThePolys *) AdjEdge->owner;
					
					
					
					if((CombinedCheckApplies(TPadj->idn,checkinstance,VTEAR,TPadj->SACindex,TPadj->SCCindex,
								TPadj->config,TPadj->stratum,TPadj->domain,
								&part1,&part2,&part3) > 0) && (part2 > 0))
					  {
					    
					    
					    if((lpec->x1 == IE1->DeltaZX) && (lpec->y1 == IE1->DeltaZY))
					      {
						tr1 = (struct TearErrorSortList *) (malloc(SzTESL));
						if(tr1 == NULL)
						  {
						    printf("available memory has been exhausted during topology analysis\n");
						    printf("execution cannot continue!\n");
						    exit(-1);
						  }
						tr1->x1[0] = lpec->x1;
						tr1->y1[0] = lpec->y1;
						tr1->z1[0] = lpec->z1;
						tr1->x1[1] = lpec->x2;
						tr1->y1[1] = lpec->y2;
						tr1->z1[1] = lpec->z2;
						
						tr1->x2[0] = AdjEdge->x1;
						tr1->y2[0] = AdjEdge->y1;
						tr1->z2[0] = AdjEdge->z1;
						tr1->x2[1] = AdjEdge->x2;
						tr1->y2[1] = AdjEdge->y2;
						tr1->z2[1] = AdjEdge->z2;
						
						tr1->keyval = VTEAR;
						tr1->Cnumber = checkinstance;
						tr1->magnitude = IE1->DeltaZ;
						tr1->index1 = TPn->SCCindex;
						tr1->index2 = TPadj->SCCindex;
						tr1->Lindex1 = TPn->SACindex;
						tr1->Lindex2 = TPadj->SACindex;
						tr1->gform1 = tr1->gform2 = G_POLYGON;
						tr1->radius1 = tr1->radius2 = -1.0;
						tr1->height1 = tr1->height2 = -1.0;
						tr1->numverts1 = tr1->numverts2 = 2;
						tr1->localID1 = TPn->localID;
						tr1->localID2 = TPadj->localID;
						tr1->IDN1 = TPn->idn;
						tr1->IDN2 = TPadj->idn;
						tr1->next = NULL;
						
						if(InsertIntoTearErrList(tr1) <= 0)
						  free(tr1);
					      }
					    
					    else if((lpec->x2 == IE1->DeltaZX) && (lpec->y2 == IE1->DeltaZY))
					      {
						tr1 = (struct TearErrorSortList *) (malloc(SzTESL));
						if(tr1 == NULL)
						  {
						    printf("available memory has been exhausted during topology analysis\n");
						    printf("execution cannot continue!\n");
						    exit(-1);
						  }
						tr1->x1[0] = lpec->x2;
						tr1->y1[0] = lpec->y2;
						tr1->z1[0] = lpec->z2;
						tr1->x1[1] = lpec->x1;
						tr1->y1[1] = lpec->y1;
						tr1->z1[1] = lpec->z1;
						
						tr1->x2[0] = AdjEdge->x1;
						tr1->y2[0] = AdjEdge->y1;
						tr1->z2[0] = AdjEdge->z1;
						tr1->x2[1] = AdjEdge->x2;
						tr1->y2[1] = AdjEdge->y2;
						tr1->z2[1] = AdjEdge->z2;
					   
						tr1->keyval = VTEAR;
						tr1->Cnumber = checkinstance;
						tr1->magnitude = IE1->DeltaZ;
						tr1->index1 = TPn->SCCindex;
						tr1->index2 = TPadj->SCCindex;
						tr1->gform1 = tr1->gform2 = G_POLYGON;
						tr1->radius1 = tr1->radius2 = -1.0;
						tr1->height1 = tr1->height2 = -1.0;
						tr1->numverts1 = tr1->numverts2 = 2;
						tr1->Lindex1 = TPn->SACindex;
						tr1->Lindex2 = TPadj->SACindex;
						tr1->localID1 = TPn->localID;
						tr1->localID2 = TPadj->localID;
						tr1->IDN1 = TPn->idn;
						tr1->IDN2 = TPadj->idn;
						tr1->next = NULL;
						
						if(InsertIntoTearErrList(tr1) <= 0)
						  free(tr1);
					      }
					    
					    else if((AdjEdge->x1 == IE1->DeltaZX) && (AdjEdge->y1 == IE1->DeltaZY))
					      {
						tr1 = (struct TearErrorSortList *) (malloc(SzTESL));
						if(tr1 == NULL)
						  {
						    printf("available memory has been exhausted during topology analysis\n");
						    printf("execution cannot continue!\n");
						    exit(-1);
						  }
						tr1->x2[0] = lpec->x1;
						tr1->y2[0] = lpec->y1;
						tr1->z2[0] = lpec->z1;
						tr1->x2[1] = lpec->x2;
						tr1->y2[1] = lpec->y2;
						tr1->z2[1] = lpec->z2;
						
						tr1->x1[0] = AdjEdge->x1;
						tr1->y1[0] = AdjEdge->y1;
						tr1->z1[0] = AdjEdge->z1;
						tr1->x1[1] = AdjEdge->x2;
						tr1->y1[1] = AdjEdge->y2;
						tr1->z1[1] = AdjEdge->z2;
						
						tr1->keyval = VTEAR;
						tr1->Cnumber = checkinstance;
						tr1->magnitude = IE1->DeltaZ;
						tr1->index2 = TPn->SCCindex;
						tr1->index1 = TPadj->SCCindex;
						tr1->gform1 = tr1->gform2 = G_POLYGON;
						tr1->radius1 = tr1->radius2 = -1.0;
						tr1->height1 = tr1->height2 = -1.0;
						tr1->numverts1 = tr1->numverts2 = 2;
						tr1->Lindex1 = TPn->SACindex;
						tr1->Lindex2 = TPadj->SACindex;
						tr1->localID2 = TPn->localID;
						tr1->localID1 = TPadj->localID;
						tr1->IDN2 = TPn->idn;
						tr1->IDN1 = TPadj->idn;
						tr1->next = NULL;
						
						if(InsertIntoTearErrList(tr1) <= 0)
						  free(tr1);
					      }
					    else if((AdjEdge->x2 == IE1->DeltaZX) && (AdjEdge->y2 == IE1->DeltaZY))
					      {
						tr1 = (struct TearErrorSortList *) (malloc(SzTESL));
						if(tr1 == NULL)
						  {
						    printf("available memory has been exhausted during topology analysis\n");
						    printf("execution cannot continue!\n");
						    exit(-1);
						  }
						tr1->x2[0] = lpec->x1;
						tr1->y2[0] = lpec->y1;
						tr1->z2[0] = lpec->z1;
						tr1->x2[1] = lpec->x2;
						tr1->y2[1] = lpec->y2;
						tr1->z2[1] = lpec->z2;
						
						tr1->x1[0] = AdjEdge->x2;
						tr1->y1[0] = AdjEdge->y2;
						tr1->z1[0] = AdjEdge->z2;
						tr1->x1[1] = AdjEdge->x1;
						tr1->y1[1] = AdjEdge->y1;
						tr1->z1[1] = AdjEdge->z1;
						
						tr1->keyval = VTEAR;
						tr1->Cnumber = checkinstance;
						tr1->magnitude = IE1->DeltaZ;
						tr1->index2 = TPn->SCCindex;
						tr1->index1 = TPadj->SCCindex;
						tr1->gform1 = tr1->gform2 = G_POLYGON;
						tr1->radius1 = tr1->radius2 = -1.0;
						tr1->height1 = tr1->height2 = -1.0;
						tr1->numverts1 = tr1->numverts2 = 2;
						tr1->Lindex1 = TPn->SACindex;
						tr1->Lindex2 = TPadj->SACindex;
						tr1->localID2 = TPn->localID;
						tr1->localID1 = TPadj->localID;
						tr1->IDN2 = TPn->idn;
						tr1->IDN1 = TPadj->idn;
						tr1->next = NULL;
						
						if(InsertIntoTearErrList(tr1) <= 0)
						  free(tr1);
					      }
					  }
				      }
				  


				    
				    else if((IE1->primary == 3) &&
					    (SensitivityCheck(GT, VTEAR, checkinstance, IE1->DeltaZ) > 0))
				      {
					AdjEdge = (struct ListOfEdges *) IE1->AdjacentEdge;
					TPadj = (struct ThePolys *) AdjEdge->owner;

					
					if((CombinedCheckApplies(TPadj->idn,checkinstance,VTEAR,TPadj->SACindex,TPadj->SCCindex,
								TPadj->config,TPadj->stratum,TPadj->domain,
								&part1,&part2,&part3) > 0) && (part2 > 0))
					  {				    
					    
					    if((lpec->x1 == IE1->DeltaZX) && (lpec->y1 == IE1->DeltaZY))
					      {
						tr1 = (struct TearErrorSortList *) (malloc(SzTESL));
						if(tr1 == NULL)
						  {
						    printf("available memory has been exhausted during topology analysis\n");
						    printf("execution cannot continue!\n");
						    exit(-1);
						  }
						tr1->x1[0] = tr1->x1[1] = lpec->x1;
						tr1->y1[0] = tr1->y1[1] = lpec->y1;
						tr1->z1[0] = tr1->z1[1] = lpec->z1;
						
						tr1->x2[0] = AdjEdge->x2;
						tr1->y2[0] = AdjEdge->y2;
						tr1->z2[0] = AdjEdge->z2;
						tr1->x2[1] = AdjEdge->x1;
						tr1->y2[1] = AdjEdge->y1;
						tr1->z2[1] = AdjEdge->z1;
						
						tr1->keyval = VTEAR;
						tr1->Cnumber = checkinstance;
						tr1->magnitude = IE1->DeltaZ;
						tr1->index1 = TPn->SCCindex;
						tr1->index2 = TPadj->SCCindex;
						tr1->gform1 = tr1->gform2 = G_POLYGON;
						tr1->radius1 = tr1->radius2 = -1.0;
						tr1->height1 = tr1->height2 = -1.0;
						tr1->numverts1 = 1;
						tr1->numverts2 = 2;
						tr1->Lindex1 = TPn->SACindex;
						tr1->Lindex2 = TPadj->SACindex;
						tr1->localID1 = TPn->localID;
						tr1->localID2 = TPadj->localID;
						tr1->IDN1 = TPn->idn;
						tr1->IDN2 = TPadj->idn;
						tr1->next = NULL;
						
						if(InsertIntoTearErrList(tr1) <= 0)
						  free(tr1);
					      }
					    else if((lpec->x2 == IE1->DeltaZX) && (lpec->y2 == IE1->DeltaZY))
					      {
						tr1 = (struct TearErrorSortList *) (malloc(SzTESL));
						if(tr1 == NULL)
						  {
						    printf("available memory has been exhausted during topology analysis\n");
						    printf("execution cannot continue!\n");
						    exit(-1);
						  }
						tr1->x1[0] = tr1->x1[1] = lpec->x2;
						tr1->y1[0] = tr1->y1[1] = lpec->y2;
						tr1->z1[0] = tr1->z1[1] = lpec->z2;
						
						tr1->x2[0] = AdjEdge->x2;
						tr1->y2[0] = AdjEdge->y2;
						tr1->z2[0] = AdjEdge->z2;
						tr1->x2[1] = AdjEdge->x1;
						tr1->y2[1] = AdjEdge->y1;
						tr1->z2[1] = AdjEdge->z1;
						
						tr1->keyval = VTEAR;
						tr1->Cnumber = checkinstance;
						tr1->magnitude = IE1->DeltaZ;
						tr1->index1 = TPn->SCCindex;
						tr1->index2 = TPadj->SCCindex;
						tr1->gform1 = tr1->gform2 = G_POLYGON;
						tr1->radius1 = tr1->radius2 = -1.0;
						tr1->height1 = tr1->height2 = -1.0;
						tr1->numverts1 = 1;
						tr1->numverts2 = 2;
						tr1->localID1 = TPn->localID;
						tr1->localID2 = TPadj->localID;
						tr1->Lindex1 = TPn->SACindex;
						tr1->Lindex2 = TPadj->SACindex;
						tr1->IDN1 = TPn->idn;
						tr1->IDN2 = TPadj->idn;
						tr1->next = NULL;
						
						if(InsertIntoTearErrList(tr1) <= 0)
						  free(tr1);
					      }
					  }
				      }



				    else if((IE1->primary == 5) &&
					    (SensitivityCheck(GT, VTEAR, checkinstance, IE1->DeltaZ) > 0))
				      {
					AdjEdge = (struct ListOfEdges *) IE1->AdjacentEdge;
					TPadj = (struct ThePolys *) AdjEdge->owner;
					
					
					if((CombinedCheckApplies(TPadj->idn,checkinstance,VTEAR,TPadj->SACindex,TPadj->SCCindex,
								TPadj->config,TPadj->stratum,TPadj->domain,
								&part1,&part2,&part3) > 0) && (part2 > 0))
					  {
					    edgeX[0] = 0;
					    edgeX[1] = 0;
					    if((lpec->x1 == IE1->DeltaZX) && (lpec->y1 == IE1->DeltaZY))
					      {
						edgeX[0] = 1;
					      }
					    else if((lpec->x2 == IE1->DeltaZX) && (lpec->y2 == IE1->DeltaZY))
					      {
						edgeX[0] = 2;
					      }
					    if((AdjEdge->x1 == IE1->DeltaZX) && (AdjEdge->y1 == IE1->DeltaZY))
					      {
						edgeX[1] = 1;
					      }
					    else if((AdjEdge->x2 == IE1->DeltaZX) && (AdjEdge->y2 == IE1->DeltaZY))
					      {
						edgeX[1] = 2;
					      }
					    if((edgeX[0] > 0) && (edgeX[1] > 0))
					      {
						tr1 = (struct TearErrorSortList *) (malloc(SzTESL));
						if(tr1 == NULL)
						  {
						    printf("available memory has been exhausted during topology analysis\n");
						    printf("execution cannot continue!\n");
						    exit(-1);
						  }
						if(edgeX[0] < 2)
						  {
						    tr1->x1[0] = tr1->x1[1] = lpec->x1;
						    tr1->y1[0] = tr1->y1[1] = lpec->y1;
						    tr1->z1[0] = tr1->z1[1] = lpec->z1;
						  }
						else
						  {
						    tr1->x1[0] = tr1->x1[1] = lpec->x2;
						    tr1->y1[0] = tr1->y1[1] = lpec->y2;
						    tr1->z1[0] = tr1->z1[1] = lpec->z2;
						  }
						if(edgeX[1] < 2)
						  {
						    tr1->x2[0] = tr1->x2[1] = AdjEdge->x1;
						    tr1->y2[0] = tr1->y2[1] = AdjEdge->y1;
						    tr1->z2[0] = tr1->z2[1] = AdjEdge->z1;
						  }
						else
						  {
						    tr1->x2[0] = tr1->x2[1] = AdjEdge->x2;
						    tr1->y2[0] = tr1->y2[1] = AdjEdge->y2;
						    tr1->z2[0] = tr1->z2[1] = AdjEdge->z2;
						  }
						
						tr1->keyval = VTEAR;
						tr1->Cnumber = checkinstance;
						tr1->magnitude = IE1->DeltaZ;
						tr1->index1 = TPn->SCCindex;
						tr1->index2 = TPadj->SCCindex;
						tr1->gform1 = tr1->gform2 = G_POLYGON;
						tr1->radius1 = tr1->radius2 = -1.0;
						tr1->height1 = tr1->height2 = -1.0;
						tr1->numverts1 = 1;
						tr1->numverts2 = 1;
						tr1->Lindex1 = TPn->SACindex;
						tr1->Lindex2 = TPadj->SACindex;
						tr1->localID1 = TPn->localID;
						tr1->localID2 = TPadj->localID;
						tr1->IDN1 = TPn->idn;
						tr1->IDN2 = TPadj->idn;
						tr1->next = NULL;
						
						if(InsertIntoTearErrList(tr1) <= 0)
						  free(tr1);
					      }
					  }   
				      }

				IE1 = IE1->next;
				}
			     }
			  } /** end for(checkinstance = 0; checkinstance < TtlActiveChecks; checkinstance++) ***/

		       lpec = lpec->next;
		       }
		    } /** end if doing something with polygon objects ***/






	/***** gather up the area feature objects  ***/
		 PIroot = NULL;
		 NeedAreaCalculation =  1;

		 if((arin != NULL) && (abortNow == 0) && ((CheckByConfig[1] > 0) || (CheckByConfig[15] > 0)))
		    {
		    for(i=0; i<4; i++)
		       NeighborsExist[i] = 0;

                    DHroot = NULL;
		    for(i=0; i<ArealTable[compositeindex].numother; i++)
		       {
		       fo = (long int) ArealTable[compositeindex].others[i].fileptr;
		       if(ArealTable[compositeindex].others[i].filenumber == 0)
			  {
			  InsertOK = InsertIntoLongList(fo,ArealTable[compositeindex].others[i].filenumber,
					  skiplimit, &Areal1LongListRoot,LongAreal1SkipList,&Skip1Entry);
			  filedecimal = 0.1;
			  }
		       else if(ArealTable[compositeindex].others[i].filenumber == 1)
			  {
			  InsertOK = InsertIntoLongList(fo,ArealTable[compositeindex].others[i].filenumber,
					  skiplimit, &Areal2LongListRoot,LongAreal2SkipList,&Skip2Entry);
			  filedecimal = 0.2;
			  }
		       else if(ArealTable[compositeindex].others[i].filenumber == 2)
			  {
			  InsertOK = InsertIntoLongList(fo,ArealTable[compositeindex].others[i].filenumber,
					  skiplimit, &Areal3LongListRoot,LongAreal3SkipList,&Skip3Entry);
			  filedecimal = 0.3;
			  }
		       else if(ArealTable[compositeindex].others[i].filenumber == 3)
			  {
			  InsertOK = InsertIntoLongList(fo,ArealTable[compositeindex].others[i].filenumber,
					  skiplimit, &Areal4LongListRoot,LongAreal4SkipList,&Skip4Entry);
			  filedecimal = 0.4;
			  }


		       ReUseLargeAreal = 0;
		       ARtoUse = NULL;
		       if(InsertOK < 1)
			  {
			  ARlc = ARlargeRoot;
			  while(ARlc != NULL)
			    {
			    if((ARlc->fp == fo) && (ARlc->fnumber == ArealTable[compositeindex].others[i].filenumber))
			       {
			       ReUseLargeAreal = 1;
			       ARtoUse = ARlc->ra;
			       if(ARtoUse != NULL)
				  {
				  ARtoUse->localID = (double) fo + filedecimal;
				  }
			       break;
			       }
			    ARlc = ARlc->next;
			    }
			  }

		       if(ReUseLargeAreal == 0)
			  {
			  if(ArealTable[compositeindex].others[i].filenumber != Afilenumber)
			     {
			     Afilenumber = ArealTable[compositeindex].others[i].filenumber;
			     filedecimal = ((double) (Afilenumber + 1)) / 10.0;
			     if(ArealFiles[Afilenumber].isopen == 0)
				{
				sprintf(suffix,"%d",Afilenumber);
				strcpy(afilein,arealsin);
				if(Afilenumber > 0)
				    strcat(afilein,suffix);
				arin = fopen(afilein,"rb");
				if(arin == NULL)
				   {
				   printf("3 area feature data input file %s could not be opened for read\n",afilein);
				   exit(-1);
				   }
				ArealFiles[Afilenumber].fp = arin;
				ArealFiles[Afilenumber].isopen = 1;
				}
			     else
				{
				arin = ArealFiles[Afilenumber].fp;
				}
			     }
			  
			  fseek(arin,ArealTable[compositeindex].others[i].fileptr,SEEK_SET);
			  j = ReadArealFromFile(arin, multiplier);

			  OKtoUse = 1;
			  if((NGA_TYPE == 0) && (NumLODbands > 0))
			     {
			     jj = CrsWlk[ArealFromFile.Lindex].LODband;
			     if((jj > 0) && (LODindex[jj-1].active < 1))
				OKtoUse = 0;
			     }
			  }
		       else if((ReUseLargeAreal > 0) && (ARtoUse != NULL))
			  {

			  TempConfig = (unsigned char) SCCtable[ARtoUse->Sindex].C;
			  TempStrat = (unsigned char) SCCtable[ARtoUse->Sindex].S;
			  TempDomain = (unsigned char) SCCtable[ARtoUse->Sindex].D;
			  OKtoUse = 1;
			  if((NGA_TYPE == 0) && (NumLODbands > 0))
			     {
			     jj = CrsWlk[ARtoUse->Lindex].LODband;
			     if((jj > 0) && (LODindex[jj-1].active < 1))
				OKtoUse = 0;
			     }
			  if(OKtoUse > 0)
			     {
			     jj = 0;
			     if(ARroot == NULL)
				{
				ARroot = ARtoUse;
				ARroot->next = NULL;
				jj = 1;
				}
			     else
				{
				ARn = ARroot;
				while(ARn != NULL)
				   {
				   if(ARn == ARtoUse)
				      break;
				   ARn = ARn->next;
				   }
				if(ARn == NULL)
				   {
				   ARtoUse->next = ARroot;
				   ARroot = ARtoUse;
				   jj = 1;
				   }
				}
			     if(jj > 0)
				{
				if((CombinedCheckApplies(ARtoUse->idn,checkinstance,VTEAR,ARtoUse->Lindex,ARtoUse->Sindex,TempConfig,
				    TempStrat,TempDomain,&part1,&part2,&part3)) ||
				(CombinedCheckApplies(ARtoUse->idn,checkinstance,HTEAR,ARtoUse->Lindex,ARtoUse->Sindex,TempConfig,
				    TempStrat,TempDomain,&part1,&part2,&part3)) ||
				(CombinedCheckApplies(ARtoUse->idn,checkinstance,OVERC,ARtoUse->Lindex,ARtoUse->Sindex,TempConfig,
				    TempStrat,TempDomain,&part1,&part2,&part3)) ||
				(CombinedCheckApplies(ARtoUse->idn,checkinstance,TVERT,ARtoUse->Lindex,ARtoUse->Sindex,TempConfig,
				    TempStrat,TempDomain,&part1,&part2,&part3)))
				   {
				   edgesin = 0;
				   for(jj=0; jj<vtxcnt; jj++)
				      {
				      ii = (jj + 1) % vtxcnt;
				      vx1 = ARtoUse->x[jj];
				      vy1 = ARtoUse->y[jj];
				      vz1 = ARtoUse->z[jj];
				      vx2 = ARtoUse->x[ii];
				      vy2 = ARtoUse->y[ii];
				      vz2 = ARtoUse->z[ii];
				      if((vx1 != vx2) || (vy1 != vy2))
					 neighborhit = ClipLineToRegion(minx,miny,maxx,maxy,&vx1,&vy1,&vz1,&vx2,&vy2,&vz2, &clipflag, multiplier);
				      if(neighborhit > 0)
					 {
					 if(neighborhit & 2)
					    NeighborsExist[0] += 1;
					 if(neighborhit & 4)
					    NeighborsExist[1] += 1;
					 if(neighborhit & 8)
					    NeighborsExist[2] += 1;
					 if(neighborhit & 16)
					    NeighborsExist[3] += 1;

					 laec = (struct ListOfEdges *) (malloc(SzLE));
					 if(laec == NULL)                                 {
					    printf("allocation memory exhausted during area feature edge assembly operation\n");
					    printf("processing cannot continue (%d vertex area feature involved)\n",vtxcnt);
					    exit(-1);
					    }
					 laec->x1 = ARtoUse->x[jj];
					 laec->y1 = ARtoUse->y[jj];
					 laec->z1 = ARtoUse->z[jj];
					 laec->x2 = ARtoUse->x[ii];
					 laec->y2 = ARtoUse->y[ii];
					 laec->z2 = ARtoUse->z[ii];

					 if(laec->x1 < laec->x2)
					    {
					    laec->minx = laec->x1;
					    laec->maxx = laec->x2;
					    }
					 else
					    {
					    laec->minx = laec->x2;
					    laec->maxx = laec->x1;
					    }
					 if(laec->y1 < laec->y2)
					    {
					    laec->miny = laec->y1;
					    laec->maxy = laec->y2;
					    }
					 else
					    {
					    laec->miny = laec->y2;
					    laec->maxy = laec->y1;
					    }

					 if(i == 0)
					    {
					    rlx = laec->minx;
					    rux = laec->maxx;
					    rly = laec->miny;
					    ruy = laec->maxy;
					    }
					 else
					    {
					    if(laec->minx < rlx)
					       rlx = laec->minx;
					    if(laec->maxx > rux)
					       rux = laec->maxx;
					    if(laec->miny < rly)
					       rly = laec->miny;
					    if(laec->maxy > ruy)
					       ruy = laec->maxy;
					    }

					 laec->owner = (long int) ARtoUse; /** ptr to area feature this edges belongs to **/
					 laec->ownernumb = jj; /** original edges from which it may have been clipped **/
					 laec->clipped = clipflag;
					 laec->isT = 0;
					 laec->length = Distance(vx1,vy1,vx2,vy2);
					 laec->Tcover = 0.0;
					 laec->Ocover = 0.0;
					 laec->Iedge = NULL;
					 laec->DeltaZ1 = laec->DeltaZ2  = 0.0;
					 ii = 0;
					 if((sliverdone == 0) || (InsertOK == 0) || (sliverratio < 0.001))
					    ii = EdgeSliverCheckOK(laec, ArealEdgeRoot, edgesin);
					 else
					    ii = 1;
	   
					 if((ii > 0) && (laec->length > 0.0001))
					    {
					    ++edgesin;
					    laec->next = NULL;
					    InsertIntoEdgeList(laec, &ArealEdgeRoot, DblArealEdgeSkipList, skiplimit);
					    }
					 else
					    free(laec);
					 }
				      }
				   } /** end insert into edge list **/

				}
			     }
			  }
		       if((OKtoUse > 0) && (ReUseLargeAreal == 0))
			  {
			  if((InsertOK) || (ArealFromFile.numverts < LARGEAREALVERTEXLIMIT))
			     {
                             tempID = (double) fo + filedecimal;
			     ARdup = CheckArealDuplication(ArealFromFile,ARroot,&IsDup,0,InsertOK,tempID);
                             if((InsertOK) && (IsDup >= UseDupThreshold) && (ArealFromFile.ishole <= 0))
                                {
                                if((CombinedCheckApplies(ArealFromFile.idn,-1,-1,ArealFromFile.Lindex,ArealFromFile.Sindex,
                                                           ArealFromFile.config,ArealFromFile.stratum,ArealFromFile.domain,
                                                           &part1,&part2,&part3)) && ((part1 > 0) || (part2 > 0) || (part3 > 0)))
                                   {
                                   NumObjects[1] += 1.0;
                                   mpoc = MultiAreaRoot;
                                   while(mpoc != NULL)
                                      {
                                      if(mpoc->featureid == ArealFromFile.idn)
                                         {
                                         mpoc->counted += 1;
                                         break;
                                         }
                                      mpoc = mpoc->next;
                                      }
                                   }
                                }

			     }
			  else
			     {
			     IsDup = UseDupThreshold + 1;
			     ARdup = NULL;
			     }
			  if(IsDup >= UseDupThreshold)
			     {
			     tempID = (double) fo + filedecimal;
			     }
			  sliverdone = 0;
			  if((IsDup < UseDupThreshold) || (InsertOK == 0) || ((IsDup >= UseDupThreshold) && (InsertOK == 1)))
			     {
			     if(InsertOK)
				{
				if(NGA_TYPE == 1)
				   {
				   sliverdone = 1;

				   IncludedSliverRatio = IncludedSlivers((double)fo + filedecimal);

				   if(ArealFromFile.perimlength > 5)
				      {
				      sliverratio = ArealFromFile.area / ArealFromFile.perimlength;  /**(ArealFromFile.perimlength * ArealFromFile.perimlength); **/
				      }
				   else
				      {
				      sliverratio = 10000.0;
				      }
				   }
				else
				   {
				   sliverdone = CalculateSliverRating(ArealFromFile.x,ArealFromFile.y,ArealFromFile.z,
				       ArealFromFile.numverts,&width,&height,&sliverratio);
				   }
				}

			     if(ReUseLargeAreal >= 0) /*** || (ARtoUse == NULL)) ***/
				{
				if(IsDup < UseDupThreshold)
				{
				ARc = (struct RawAreal *) (malloc(SzRA));
				if(ARc == NULL)
				   {
				   printf("allocation memory exhausted during area feature read\n");
				   printf("processing cannot continue\n");
				   exit(-1);
				   }
				ARc->numverts = ArealFromFile.numverts;
				ARc->Lindex = ArealFromFile.Lindex;
				ARc->Sindex = ArealFromFile.Sindex;
				ARc->idn = ArealFromFile.idn;
				ARc->ishole = ArealFromFile.ishole;
				ARc->RB_Tree_Edgelist = NULL;
				ARc->area = ArealFromFile.area;
                                ARc->perimlength = ArealFromFile.perimlength;
                                ARc->areaattr = ArealFromFile.areaattr;
                                ARc->hgtattr = ArealFromFile.hgtattr;
                                ARc->zv2attr = ArealFromFile.zv2attr;
                                ARc->lenattr = ArealFromFile.lenattr;
                                ARc->namattr = ArealFromFile.namattr;
                                if(ArealFromFile.areastr[0] == '\0')
                                   ARc->areastr = NULL;
                                else
                                   {
                                   ARc->areastr = (char *) (malloc(strlen(ArealFromFile.areastr) + 2));
                                   if(ARc->areastr != NULL)
                                      strcpy(ARc->areastr,ArealFromFile.areastr);
                                   }
                                if(ArealFromFile.hgtstr[0] == '\0')
                                   ARc->hgtstr = NULL;
                                else
                                   {
                                   ARc->hgtstr = (char *) (malloc(strlen(ArealFromFile.hgtstr) + 2));
                                   if(ARc->hgtstr != NULL)
                                      strcpy(ARc->hgtstr,ArealFromFile.hgtstr);
                                   }
                                if(ArealFromFile.zv2str[0] == '\0')
                                   ARc->zv2str = NULL;
                                else
                                   {
                                   ARc->zv2str = (char *) (malloc(strlen(ArealFromFile.zv2str) + 2));
                                   if(ARc->zv2str != NULL)
                                      strcpy(ARc->zv2str,ArealFromFile.zv2str);
                                   }
                                if(ArealFromFile.lenstr[0] == '\0')
                                   ARc->lenstr = NULL;
                                else
                                   {
                                   ARc->lenstr = (char *) (malloc(strlen(ArealFromFile.lenstr) + 2));
                                   if(ARc->lenstr != NULL)
                                      strcpy(ARc->lenstr,ArealFromFile.lenstr);
                                   }
                                if(ArealFromFile.namstr[0] == '\0')
                                   ARc->namstr = NULL;
                                else
                                   {
                                   ARc->namstr = (char *) (malloc(strlen(ArealFromFile.namstr) + 2));
                                   if(ARc->namstr != NULL)
                                      strcpy(ARc->namstr,ArealFromFile.namstr);
                                   }

				if(InsertOK)
				   {
				   ARc->firstindex = compositeindex;

				   if(ARc->ishole <= 0)
                                      {
                                      if((CombinedCheckApplies(ArealFromFile.idn,-1,-1,ArealFromFile.Lindex,ArealFromFile.Sindex,
                                                           ArealFromFile.config,ArealFromFile.stratum,ArealFromFile.domain,
                                                           &part1,&part2,&part3)) && ((part1 > 0) || (part2 > 0) || (part3 > 0)))
                                         {
                                         NumObjects[1] += 1.0;
                                         mpoc = MultiAreaRoot;
                                         while(mpoc != NULL)
                                            {
                                            if(mpoc->featureid == ArealFromFile.idn)
                                               {
                                               mpoc->counted += 1;
                                               break;
                                               }
                                            mpoc = mpoc->next;
                                            }
                                         }
                                      }

				   }
				else
				   ARc->firstindex = -1;

				ARc->ismulti = 1;
				tempID = ARc->localID = (double) fo + filedecimal;
				ARc->featureid = ArealFromFile.featureid;
				ARc->minxvtx = ArealFromFile.minxvtx;
				ARc->next = NULL;
				ARc->x = (double *) malloc(SzD * ArealFromFile.numverts);
				ARc->y = (double *) malloc(SzD * ArealFromFile.numverts);
				ARc->z = (double *) malloc(SzD * ArealFromFile.numverts);
                                ARc->coversLM = 0;
				if((ARc->x == NULL) || (ARc->y == NULL) || (ARc->z == NULL))
				   {
				   printf("allocation memory exhausted during area feature read\n");
				   printf("processing cannot continue\n");
				   exit(-1);
				   }
				
				MinElev = MaxElev = ArealFromFile.z[0];

				for(jj = 0; jj<ArealFromFile.numverts; jj++)
				   {
				   ARc->x[jj] = ArealFromFile.x[jj];
				   ARc->y[jj] = ArealFromFile.y[jj];
				   ARc->z[jj] = ArealFromFile.z[jj];
				   if(ArealFromFile.z[jj] < MinElev)
				      MinElev = ArealFromFile.z[jj];
				   if(ArealFromFile.z[jj] > MaxElev)
				      MaxElev = ArealFromFile.z[jj];
				   }
				vtxcnt = ARc->numverts = ArealFromFile.numverts;

				}
				else vtxcnt = 0;

                                if((InsertOK) &&(ARc->numverts >= LARGEAREALVERTEXLIMIT))
                                  {
                                   ARlc = (struct LargeAreals *) (malloc(SzLA));
                                   if(ARlc == NULL)
                                      {
                                      printf("available memory has been exhausted during large area feature procesing\n");
                                      exit(-1);
                                      }
                                   if(IsDup < UseDupThreshold)
                                      {
                                      ARlc->ra = ARc;
                                      }
                                   else
                                      ARlc->ra = NULL;
                                   ARlc->fnumber = ArealTable[compositeindex].others[i].filenumber;
                                   ARlc->fp = fo;

                                   ARlc->next = ARlargeRoot;
                                   ARlargeRoot = ARlc;
                                  }

				if((InsertOK) && (IsDup < UseDupThreshold) && (ARc->numverts >= LARGEAREALVERTEXLIMIT))
				  {
				      
				   if(IsDup < UseDupThreshold)
				      {
				      ARc->RB_Tree_Edgelist = CreateTreeOfArealEdge(ARc->x, ARc->y, ARc->numverts, &jj);
                                      if((ARc->ishole == 1) && (jj == 0))
				         ARc->ismulti = jj + 1;
                                      else
                                         {
/***** was doing this to ensure things freed up after check last LM in a localized inspection - this isn't best
   way to achieve that since will fould up point inside large area caculation which limits its look at edge
   intersections based on max extent of area feature ***
                                         jjj = (Uindex1 * (MaxYindex + 1)) + Uindex2;
                                         if(jjj < jj)
                                            jj = jjj;
*********************/
if(jj < 1)
jj = 1; /*** if allow ismulti to be zero, have a crash problem since try to free it twice since is and is not seen as a
              multi-region area feature ****/
                                         ARc->ismulti = jj;
                                         }
				      }
				   else
				      {
				      ARc->RB_Tree_Edgelist = NULL;
				      ARc->ismulti = (MaxXindex * MaxYindex) + (2 * MaxYindex);
				      }
				   }
				}
	else if((IsDup < UseDupThreshold) && (ARtoUse == NULL))
	{
	printf("ELSE CLAUSE CONDITION FAILURE\n");
	exit(-1);
	}
			     if(IsDup < UseDupThreshold)
				{
				if(ARroot == NULL)
				   {
				   ARroot = ARc;
				      ARroot->next = NULL;
				   }
				else
				   {
				   ARn = ARroot;
				   while(ARn != NULL)
				      {
				      if(ARn == ARc)
					 break;
				      ARn = ARn->next;
				      }
				   if(ARn == NULL)
				      {
				      ARc->next = ARroot;
				      ARroot = ARc;
				      }
				   else
				      {
				      if(ARtoUse == NULL)
					 {
					 free(ARc->x);
					 free(ARc->y);
					 free(ARc->z);
					 free(ARc);
					 }
				      continue;
				      }
				   }
				}

			     checkinstance = -1;

			     if((NGA_TYPE == 0) &&
                             (CheckByStratum[ArealFromFile.stratum] > 0) && (CheckByDomain[ArealFromFile.domain] > 0) &&
			     ((CombinedCheckApplies(ArealFromFile.idn,checkinstance,VTEAR,ArealFromFile.Lindex,ArealFromFile.Sindex,ArealFromFile.config,
				    ArealFromFile.stratum,ArealFromFile.domain,&part1,&part2,&part3)) ||
			     (CombinedCheckApplies(ArealFromFile.idn,checkinstance,HTEAR,ArealFromFile.Lindex,ArealFromFile.Sindex,ArealFromFile.config,
				    ArealFromFile.stratum,ArealFromFile.domain,&part1,&part2,&part3)) ||
			     (CombinedCheckApplies(ArealFromFile.idn,checkinstance,OVERC,ArealFromFile.Lindex,ArealFromFile.Sindex,ArealFromFile.config,
				    ArealFromFile.stratum,ArealFromFile.domain,&part1,&part2,&part3)) ||
			     (CombinedCheckApplies(ArealFromFile.idn,checkinstance,TVERT,ArealFromFile.Lindex,ArealFromFile.Sindex,ArealFromFile.config,
				    ArealFromFile.stratum,ArealFromFile.domain,&part1,&part2,&part3))))
				{
				edgesin = 0;
				for(jj=0; jj<vtxcnt; jj++)
				   {
				   ii = (jj + 1) % vtxcnt;
				   vx1 = ARc->x[jj];
				   vy1 = ARc->y[jj];
				   vz1 = ARc->z[jj];
				   vx2 = ARc->x[ii];
				   vy2 = ARc->y[ii];
				   vz2 = ARc->z[ii];
				   if((vx1 != vx2) || (vy1 != vy2))
				      neighborhit = ClipLineToRegion(minx,miny,maxx,maxy,&vx1,&vy1,&vz1,&vx2,&vy2,&vz2, &clipflag, multiplier);
				   if(neighborhit > 0)
				      {
				      if(neighborhit & 2)
					 NeighborsExist[0] += 1;
				      if(neighborhit & 4)
					 NeighborsExist[1] += 1;
				      if(neighborhit & 8)
					 NeighborsExist[2] += 1;
				      if(neighborhit & 16)
					 NeighborsExist[3] += 1;

				      laec = (struct ListOfEdges *) (malloc(SzLE));
				      if(laec == NULL)
					 {
					 printf("allocation memory exhausted during area feature edge assembly operation\n");
					 printf("processing cannot continue (%d vertex area feature involved)\n",vtxcnt);
					 exit(-1);
					 }
				      laec->x1 = ARc->x[jj];
				      laec->y1 = ARc->y[jj];
				      laec->z1 = ARc->z[jj];
				      laec->x2 = ARc->x[ii];
				      laec->y2 = ARc->y[ii];
				      laec->z2 = ARc->z[ii];

				      if(laec->x1 < laec->x2)
					 {
					 laec->minx = laec->x1;
					 laec->maxx = laec->x2;
					 }
				      else
					 {
					 laec->minx = laec->x2;
					 laec->maxx = laec->x1;
					 }
				      if(laec->y1 < laec->y2)
					 {
					 laec->miny = laec->y1;
					 laec->maxy = laec->y2;
					 }
				      else
					 {
					 laec->miny = laec->y2;
					 laec->maxy = laec->y1;
					 }

				      if(i == 0)
					 {
					 rlx = laec->minx;
					 rux = laec->maxx;
					 rly = laec->miny;
					 ruy = laec->maxy;
					 }
				      else
					 {
					 if(laec->minx < rlx)
					    rlx = laec->minx;
					 if(laec->maxx > rux)
					    rux = laec->maxx;
					 if(laec->miny < rly)
					    rly = laec->miny;
					 if(laec->maxy > ruy)
					    ruy = laec->maxy;
					 }

				      laec->owner = (long int) ARc; /** ptr to area feature this edges belongs to **/
				      laec->ownernumb = jj; /** original edges from which it may have been clipped **/
				      laec->clipped = clipflag;
				      laec->isT = 0;
				      laec->length = Distance(vx1,vy1,vx2,vy2);
				      laec->Tcover = 0.0;
				      laec->Ocover = 0.0;
				      laec->Iedge = NULL;
				      laec->DeltaZ1 = laec->DeltaZ2  = 0.0;
				      ii = 0;
				      if((sliverdone == 0) || (InsertOK == 0) || (sliverratio < 0.001))
					 ii = EdgeSliverCheckOK(laec, ArealEdgeRoot, edgesin);
				      else
					 ii = 1;
	   
				      if((ii > 0) && (laec->length > 0.0001))
					 {
					 ++edgesin;
					 laec->next = NULL;
					 InsertIntoEdgeList(laec, &ArealEdgeRoot, DblArealEdgeSkipList, skiplimit);
					 }
				      else
					 free(laec);
				      }
				   }
				} /** end insert into edge list **/
			     } /** end is not a duplicate **/

			  if((CheckByStratum[ArealFromFile.stratum] > 0) &&
				(CheckByDomain[ArealFromFile.domain] > 0))
			  {
			  for(checkinstance = 0; checkinstance < TtlActiveChecks; checkinstance++)
			     {

/*** below, found some type of ID duplication in this LM, so go ahead and write the error ***/
                             part1 = 0;
                             if(ID_O_count > 0)
                                {
                                if((InsertOK > 0) && (ArealFromFile.ishole <= 0) &&
                                      ((IsDup == 2) || (IsDup == 3) || (IsDup == 5)) && (ArealFromFile.idn != ARdup->idn) &&
                                      (CombinedCheckApplies(ArealFromFile.idn,checkinstance,ANY_SAMEID,ArealFromFile.Lindex,ArealFromFile.Sindex,
                                                      ArealFromFile.config,ArealFromFile.stratum,ArealFromFile.domain,
                                                      &part1,&part2,&part3))  && (part1 > 0) &&
                                      (CombinedCheckApplies(ARdup->idn,checkinstance,ANY_SAMEID,ARdup->Lindex,ARdup->Sindex,
                                       SCCtable[ARdup->Sindex].C, SCCtable[ARdup->Sindex].S, SCCtable[ARdup->Sindex].D,
                                                           &part1,&part2,&part3)) && (part2 > 0))
                                   {
                                    FwriteTwoObjects(ANY_SAMEID,Make_Correct(ANY_SAMEID,checkinstance),
                                                  ArealFromFile.idn,G_AREAL,ArealFromFile.Lindex,tempID,ArealFromFile.Sindex,-1.0, -1.0,
                                                  2, ArealFromFile.x, ArealFromFile.y,ArealFromFile.z,
                                                  ARdup->idn,G_AREAL,ARdup->Lindex,ARdup->localID,ARdup->Sindex,-1.0,-1.0,2,
                                                  ARdup->x, ARdup->y,ARdup->z);
                                   }
                                else if((InsertOK > 0) && (IsDup != 4) && (ArealFromFile.ishole <= 0) &&
                                       (CombinedCheckApplies(ArealFromFile.idn,checkinstance,ANY_SAMEID,ArealFromFile.Lindex,ArealFromFile.Sindex,
                                                      ArealFromFile.config,ArealFromFile.stratum,ArealFromFile.domain,
                                                      &part1,&part2,&part3)) &&
                                        ((part1 > 0) || (part2 > 0)))
                                   {
                                   GetAppropIDnumber(ArealFromFile.idn, &tempstring[0]);
                                   jj = GetUUIDindex(tempstring);
                                   if(jj >= 0)
                                      {
                                      olidp = ID_O[jj].inst;
                                      while(olidp != NULL)
                                         {
                                         if((olidp->idn != ArealFromFile.idn) && (olidp->checknumb == checkinstance))
                                            {
                                            if((part1 > 0) && (olidp->part > 1))
                                               {
                                               FwriteTwoObjects(ANY_SAMEID,Make_Correct(ANY_SAMEID,checkinstance),
                                                     ArealFromFile.idn,G_AREAL,ArealFromFile.Lindex,tempID,ArealFromFile.Sindex,-1.0, -1.0,
                                                     2, ArealFromFile.x, ArealFromFile.y,ArealFromFile.z,
                                                     olidp->idn,olidp->gform,olidp->Lindex,olidp->lid,olidp->Sindex,-1.0,-1.0,olidp->numvert,
                                                     olidp->x, olidp->y,olidp->z);
                                               break;
                                               }
                                            else if((part2 > 0) && ((olidp->part == 1) || (olidp->part == 3)))
                                               {
                                               FwriteTwoObjects(ANY_SAMEID,Make_Correct(ANY_SAMEID,checkinstance),
                                                     ArealFromFile.idn,G_AREAL,ArealFromFile.Lindex,tempID,ArealFromFile.Sindex,-1.0, -1.0,
                                                     2, ArealFromFile.x, ArealFromFile.y,ArealFromFile.z,
                                                     olidp->idn,olidp->gform,olidp->Lindex,olidp->lid,olidp->Sindex,-1.0,-1.0,olidp->numvert,
                                                     olidp->x, olidp->y,olidp->z);
                                                  break;
                                               }
                                            }
                                         olidp = olidp->next;
                                         }
                                      if(olidp == NULL)
                                         {
                                         olidc = (struct OverlapIDinstance *) (malloc(sizeof(struct OverlapIDinstance)));
                                         if(olidc == NULL)
                                            {
                                            printf("memory exhausted during unique identifier processing - results will be incomplete\n");
                                            }
                                         else
                                            {
                                            olidc->checknumb = checkinstance;
                                            olidc->idn = ArealFromFile.idn;
                                            olidc->lid = tempID;
                                            olidc->Lindex = ArealFromFile.Lindex;
                                            olidc->Sindex = ArealFromFile.Sindex;
                                            olidc->gform = G_AREAL;
                                            if((part1 > 0) && (part2 > 0))
                                               olidc->part = 3;
                                            else if(part1 > 0)
                                               olidc->part = 1;
                                            else
                                               olidc->part = 2;
                                            olidc->numvert = 2;
                                            olidc->x[0] = ArealFromFile.x[0];
                                            olidc->y[0] = ArealFromFile.y[0];
                                            olidc->z[0] = ArealFromFile.z[0];
                                            olidc->x[1] = ArealFromFile.x[1];
                                            olidc->y[1] = ArealFromFile.y[1];
                                            olidc->z[1] = ArealFromFile.z[1];
                                            olidc->next = ID_O[jj].inst;
                                            ID_O[jj].inst = olidc;
                                            }
                                         }
                                      }
                                   }
                                }


			     if((IsDup < UseDupThreshold) && (InsertOK))
			       {
				 if((NGA_TYPE != 1) &&
                                   (CombinedCheckApplies(ArealFromFile.idn,checkinstance,SLIVER,ArealFromFile.Lindex,ArealFromFile.Sindex,
							 ArealFromFile.config,ArealFromFile.stratum,ArealFromFile.domain,
							 &part1,&part2,&part3)))
				   {
				     if((part1 > 0) &&
					(sliverdone > 0) && 
					(SensitivityCheck(LT, SLIVER, checkinstance, sliverratio) > 0)
					)
				       {
					 FwriteObjectAndMagnitude(SLIVER,Make_Correct(SLIVER,checkinstance),
								  ARc->idn, 
								  ARc->Sindex,G_AREAL,ARc->Lindex,ARc->localID,-1.0,-1.0,
								  sliverratio,ARc->x, ARc->y,
								  ARc->z,2, 1);
				       }
				   }

				 if((ArealFromFile.ishole <= 0) && (CombinedCheckApplies(ArealFromFile.idn,checkinstance,BIGAREA,ArealFromFile.Lindex,ArealFromFile.Sindex,
						      ArealFromFile.config,ArealFromFile.stratum,ArealFromFile.domain,
						      &part1,&part2,&part3)))
				    {
				    if((part1 > 0) &&
					(SensitivityCheck(GT, BIGAREA, checkinstance, ArealFromFile.area) > 0))
				       {
				       FwriteObjectAndMagnitude(BIGAREA,Make_Correct(BIGAREA,checkinstance),
							ArealFromFile.idn,
							ArealFromFile.Sindex,G_AREAL,ARc->Lindex,ARc->localID,-1.0,-1.0,ArealFromFile.area,
							&ArealFromFile.x[0], &ArealFromFile.y[0],&ArealFromFile.z[0],2, 1);
				       }
				    }


				if(ChkAreaClosure > 0) 
				   {
                                   kkend = ArealFromFile.numverts;
				   if((CombinedCheckApplies(ArealFromFile.idn,checkinstance,ZUNCLOSED,ArealFromFile.Lindex,ArealFromFile.Sindex,
							ArealFromFile.config,ArealFromFile.stratum,ArealFromFile.domain,
							&part1,&part2,&part3)) && (part1 > 0))
				      {
                                      if((IsSentinelZvalue(ArealFromFile.z[0],UseNUNANPO) == 0) && (IsSentinelZvalue(ArealFromFile.z[kkend],UseNUNANPO) == 0))
                                         {
				         if(ArealFromFile.z[0] != ArealFromFile.z[kkend])
					    {
					    if(ArealFromFile.z[0] > ArealFromFile.z[kkend])
					       temp = ArealFromFile.z[0] - ArealFromFile.z[kkend];
					    else
					       temp = ArealFromFile.z[kkend] - ArealFromFile.z[0];
		
					    if(SensitivityCheck(GT, ZUNCLOSED, checkinstance, temp) > 0)
					       {
                                               FwritePointObjectAndMagnitude(ZUNCLOSED,Make_Correct(ZUNCLOSED,checkinstance),temp,
                                                           ArealFromFile.idn,G_AREAL,ARc->Lindex,ARc->localID,ArealFromFile.Sindex,
                                                           ArealFromFile.x[kkend], ArealFromFile.y[kkend],
                                                           ArealFromFile.z[kkend],
                                                           ArealFromFile.Sindex,ArealFromFile.idn,G_AREAL,ARc->Lindex,ARc->localID,1,
                                                           &ArealFromFile.x[0], &ArealFromFile.y[0], &ArealFromFile.z[0]);
                                               }
					    }
					 }
				      }
				   if((CombinedCheckApplies(ArealFromFile.idn,checkinstance,AREAUNCLOSED,ArealFromFile.Lindex,ArealFromFile.Sindex,
							ArealFromFile.config,ArealFromFile.stratum,ArealFromFile.domain,
							&part1,&part2,&part3)) && (part1 > 0))
				      {
				      temp = Distance(ArealFromFile.x[0],ArealFromFile.y[0],
						ArealFromFile.x[kkend],ArealFromFile.y[kkend]);
                                      if(ArealFromFile.z[0] != ArealFromFile.z[kkend])
                                         {
                                         temp2 = ArealFromFile.z[0] - ArealFromFile.z[kkend];
                                         temp2 = temp2 * temp2;
                                         temp = temp * temp + temp2;
                                         temp = sqrt(temp);
                                         }
                                   
				      if(SensitivityCheck(GT, AREAUNCLOSED, checkinstance, temp) > 0)
					 {
                                         FwritePointObjectAndMagnitude(AREAUNCLOSED,Make_Correct(AREAUNCLOSED,checkinstance),temp,
                                                        ArealFromFile.idn,G_AREAL,ARc->Lindex,ARc->localID,ArealFromFile.Sindex,
                                                        ArealFromFile.x[kkend], ArealFromFile.y[kkend],
                                                        ArealFromFile.z[kkend],
                                                        ArealFromFile.Sindex,ArealFromFile.idn,G_AREAL,ARc->Lindex,ARc->localID,1,
                                                        &ArealFromFile.x[0], &ArealFromFile.y[0], &ArealFromFile.z[0]);
					 }
				      }
				   }


				if((ArealFromFile.numverts > 1) &&
                                     (CombinedCheckApplies(ArealFromFile.idn,checkinstance,V_DUPS,ArealFromFile.Lindex,ArealFromFile.Sindex,
							ArealFromFile.config,ArealFromFile.stratum,ArealFromFile.domain,
							&part1,&part2,&part3)) && (part1 > 0))
				  {
				    dv = DuplicateVerticesExist(ARc->numverts,
								   ARc->x,ARc->y,ARc->z);
				    if(SensitivityCheck(GT, V_DUPS, checkinstance, (double) dv) > 0)
				      {
				       for(jj=1; jj<ArealFromFile.numverts; jj++)
					 {
					 if((ArealFromFile.x[jj-1] == ArealFromFile.x[jj]) &&
					     (ArealFromFile.y[jj-1] == ArealFromFile.y[jj]) &&
					     (ArealFromFile.z[jj-1] == ArealFromFile.z[jj]))
					    {
                                            FwriteObject(V_DUPS,Make_Correct(V_DUPS,checkinstance),ArealFromFile.Lindex,
                                                           ArealFromFile.Sindex,G_AREAL,ARc->localID,ArealFromFile.idn, -1.0, -1.0,
                                                            &ArealFromFile.x[jj],&ArealFromFile.y[jj],&ArealFromFile.z[jj],1, 1);
					    }
					 }
				      }
                                   if((ArealFromFile.x[0] == ArealFromFile.x[ArealFromFile.numverts-1]) &&
                                             (ArealFromFile.y[0] == ArealFromFile.y[ArealFromFile.numverts-1]) &&
                                             (ArealFromFile.z[0] == ArealFromFile.z[ArealFromFile.numverts-1]))
                                      {
                                      if(SensitivityCheck(GT, V_DUPS, checkinstance, 1.0) > 0)
                                         {
                                         FwriteObject(V_DUPS,Make_Correct(V_DUPS,checkinstance),ArealFromFile.Lindex,
                                                        ArealFromFile.Sindex,G_AREAL,ARc->localID,ArealFromFile.idn, -1.0, -1.0,
                                                         &ArealFromFile.x[ArealFromFile.numverts-1],&ArealFromFile.y[ArealFromFile.numverts-1],&ArealFromFile.z[ArealFromFile.numverts-1],1, 1);
                                         }
                                      }
				  }


				if((CombinedCheckApplies(ArealFromFile.idn,checkinstance,NARROW,ArealFromFile.Lindex,ArealFromFile.Sindex,
							ArealFromFile.config,ArealFromFile.stratum,ArealFromFile.domain,
							&part1,&part2,&part3)) && (part1 > 0))
				  {
				    if(
				       (sliverdone > 0) &&
				       (SensitivityCheck(LT, NARROW, checkinstance, width) > 0)
				       )
				      {
					FwriteObjectAndMagnitude(NARROW, Make_Correct(NARROW,checkinstance),
								 ARc->idn, 
								 ARc->Sindex,G_AREAL,ARc->Lindex,ARc->localID,-1.0,-1.0,
								 width,ARc->x, ARc->y,ARc->z,
								 2, 1);
				      }
				  }



				if((CombinedCheckApplies(ArealFromFile.idn,checkinstance,SMALLOBJ,ArealFromFile.Lindex,ArealFromFile.Sindex,
							ArealFromFile.config,ArealFromFile.stratum,ArealFromFile.domain,
							&part1,&part2,&part3)) && (part1 > 0))
				  {
				    surfacearea3D = SurfaceAreaByTriangles(ARc->numverts, ARc->x,
									   ARc->y,ARc->z);

				    if(SensitivityCheck(LT, SMALLOBJ, checkinstance, surfacearea3D) > 0)
				      {
					FwriteObjectAndMagnitude(SMALLOBJ,Make_Correct(SMALLOBJ,checkinstance),
								 ARc->idn, 
								 ARc->Sindex,G_AREAL,ARc->Lindex,ARc->localID,-1.0,-1.0,
								 surfacearea3D,ARc->x, ARc->y,
								 ARc->z,2, 1);
				      }
				   }


				if((CombinedCheckApplies(ArealFromFile.idn,checkinstance,ATTRERR,ArealFromFile.Lindex,ArealFromFile.Sindex,
							ArealFromFile.config, ArealFromFile.stratum,ArealFromFile.domain,
							&part1,&part2,&part3)) && (part1 > 0))
				  {
				    if(CrsWlk[ARc->Lindex].AttrErr >= 0)
				      {
					FwriteObjectAndMessage(ATTRERR,Make_Correct(ATTRERR,checkinstance),
							       ARc->idn, G_AREAL,ARc->Lindex,ARc->localID,
							       ARc->Sindex,-1.0,-1.0,ARc->x,
							       ARc->y,ARc->z,2,
							       AttrErr[CrsWlk[ARc->Lindex].AttrErr].description);
				      }
				  }


                                       if(CombinedCheckApplies(ArealFromFile.idn,checkinstance,LONGFEAT,ArealFromFile.Lindex,ArealFromFile.Sindex,
                                                              ArealFromFile.config,ArealFromFile.stratum,ArealFromFile.domain,
                                                              &part1,&part2,&part3))
                                        {
                                          if((part1 > 0) && (ARc->numverts > 1))
                                             {
                                             segmentlength = 0;
                                             for(jj=1; jj<ARc->numverts; jj++)
                                                {
                                                   segmentlength += Distance3D(ARc->x[jj-1],ARc->y[jj-1],ARc->z[jj-1],
                                                                           ARc->x[jj],ARc->y[jj],ARc->z[jj]);
                                                }
                                             segmentlength += Distance3D(ARc->x[ARc->numverts-1],ARc->y[ARc->numverts-1],ARc->z[ARc->numverts-1],
                                                                           ARc->x[0],ARc->y[0],ARc->z[0]);
                                             if(SensitivityCheck(GT, LONGFEAT, checkinstance, segmentlength) > 0)
                                                {
                                                FwriteObjectAndMagnitude(LONGFEAT,Make_Correct(LONGFEAT,checkinstance),
                                                                  ARc->idn,
                                                                  ARc->Sindex,G_AREAL,ARc->Lindex,ARc->localID,-1.0,-1.0,segmentlength,
                                                                  ARc->x, ARc->y,ARc->z,2, 1);
                                                }

                                             }
                                        }


                                      if((ArealFromFile.ishole <= 0) &&
                                           (CombinedCheckApplies(ArealFromFile.idn,checkinstance,MULTIPARTA,ArealFromFile.Lindex,ArealFromFile.Sindex,
                                                              ArealFromFile.config,ArealFromFile.stratum,ArealFromFile.domain,
                                                              &part1,&part2,&part3) > 0) && (part1 > 0))
                                        {
                                        mpoc = MultiAreaRoot;
                                        kkk = 0;
                                        while(mpoc != NULL)
                                           {
                                           if((mpoc->featureid == ArealFromFile.idn) && (mpoc->used == 0))
                                              ++kkk;
                                           mpoc = mpoc->next;
                                           }
                                        if(SensitivityCheck(GT, MULTIPARTA, checkinstance, (double) kkk) > 0)
                                           {
                                           mpoc = MultiAreaRoot;
                                           while(mpoc != NULL)
                                              {
                                              if(mpoc->featureid == ArealFromFile.idn)
                                                 {
                                                 mpoc->used = 1;
                                                 FwriteObjectAndMagnitude(MULTIPARTA,Make_Correct(MULTIPARTA,checkinstance),
                                                                     ArealFromFile.idn,
                                                                     ArealFromFile.Sindex,G_AREAL,ARc->Lindex,ARc->localID,-1.0,-1.0,(double) kkk,
                                                                     mpoc->x, mpoc->y, mpoc->z, mpoc->numverts, 1);
                                                 }
                                              mpoc = mpoc->next;
                                              }
                                           }
                                        }




				      if(CombinedCheckApplies(ArealFromFile.idn,checkinstance,LOOPS,ArealFromFile.Lindex,ArealFromFile.Sindex,
							      ArealFromFile.config,ArealFromFile.stratum,ArealFromFile.domain,
							      &part1,&part2,&part3))
					{
					if((part1 > 0) && (ArealFromFile.numverts > 2)) /*** &&(ArealFromFile.numverts <maxverts)) ***/
					   {
					   CheckArealForSelfIntersection(ARc,&xint, &yint,checkinstance);
					   } 
					}
			       } /** end (IsDup < UseDupThreshold) && (InsertOK) **/
			     } /**** for(checkinstance = 0; checkinstance < TtlActiveChecks; checkinstance++) ****/
			   } /*** end if (CheckByStratum[ArealFromFile.stratum] > 0) &&
				(CheckByDomain[ArealFromFile.domain] > 0) *** new addition here ***/
			  }

		       FreePointAndIDlist();
		       if(abortNow > 0)
			  break;
		       }

                    if(CheckAOVERLAPA > 0)
                       {
                       ARc = ARroot;
                       while(ARc != NULL)
                          {
                          ARc->coversLM = 0;
                          if(ARc->area > AreaSizeCutoff)
                             {
                             jj2 = AnyEdgesInThisLoadModule(ARc,compositeindex);
                             if(jj2 == 0)
                                {
                                ARc->coversLM = 1;
                                }
                             }
                          ARc = ARc->next;
                          }
                       }


		    filedecimal = ((double) (Afilenumber + 1)) / 10.0;
		    k = ArealTable[compositeindex].numinside;
		    if((k > 0) && (abortNow == 0))
		       {

		       if(ArealTable[compositeindex].filenumber != Afilenumber)
			  {
			  Afilenumber = ArealTable[compositeindex].filenumber;
			  filedecimal = ((double) (Afilenumber + 1)) / 10.0;
			  if(ArealFiles[Afilenumber].isopen == 0)
			     {
			     sprintf(suffix,"%d",Afilenumber);
			     strcpy(afilein,arealsin);
			     if(Afilenumber > 0)
				 strcat(afilein,suffix);
			     arin = fopen(afilein,"rb");
			     if(arin == NULL)
				{
				printf("3 area feature data input file %s could not be opened for read\n",afilein);
				exit(-1);
				}
			     ArealFiles[Afilenumber].fp = arin;
			     ArealFiles[Afilenumber].isopen = 1;
			     }
			  else
			     {
			     arin = ArealFiles[Afilenumber].fp;
			     }

			  }

		       fseek(arin,ArealTable[compositeindex].fileptr,SEEK_SET);
		       i = 0;
		       while(i < k)
			  {
                          fo = ftell(arin);
			  j = ReadArealFromFile(arin, multiplier);
			  ++i;


			     OKtoUse = 1;
			     if((NGA_TYPE == 0) && (NumLODbands > 0))
				{
				jj = CrsWlk[ArealFromFile.Lindex].LODband;
				if((jj > 0) && (LODindex[jj-1].active < 1))
				   OKtoUse = 0;
				}

			  if((OKtoUse > 0) && (CheckByStratum[ArealFromFile.stratum] > 0) &&
				   (CheckByDomain[ArealFromFile.domain] > 0))
			     {
                             tempID = fo + filedecimal;
			     ARdup = CheckArealDuplication(ArealFromFile,ARroot,&IsDup,0,OKtoUse,tempID);
                                if(ArealFromFile.ishole <= 0)
                                   {
                                   if((CombinedCheckApplies(ArealFromFile.idn,-1,-1,ArealFromFile.Lindex,ArealFromFile.Sindex,
                                                           ArealFromFile.config,ArealFromFile.stratum,ArealFromFile.domain,
                                                           &part1,&part2,&part3)) && ((part1 > 0) || (part2 > 0) || (part3 > 0)))
                                      {
                                      NumObjects[1] += 1.0;
                                      mpoc = MultiAreaRoot;
                                      while(mpoc != NULL)
                                         {
                                         if(mpoc->featureid == ArealFromFile.idn)
                                            {
                                            mpoc->counted += 1;
                                            break;
                                            }
                                         mpoc = mpoc->next;
                                         }
                                      }
                                   }
			     if(IsDup < UseDupThreshold)
				{
				if(NGA_TYPE == 1)
				   {
				   sliverdone = 1;

				   IncludedSliverRatio = IncludedSlivers((double)fo + filedecimal);
				   if(ArealFromFile.perimlength > 5)
				      {
				      sliverratio = ArealFromFile.area / ArealFromFile.perimlength; /**(ArealFromFile.perimlength * ArealFromFile.perimlength); **/
				      }
				   else
				      {
				      sliverratio = 10000.0;
				      }

				   }
				else
				   {
				   sliverdone = CalculateSliverRating(ArealFromFile.x,ArealFromFile.y,ArealFromFile.z,
				       ArealFromFile.numverts,&width,&height,&sliverratio);
				   }
				ARc = (struct RawAreal *) (malloc(SzRA));
				if(ARc == NULL)
				   {
				   printf("allocation memory exhausted during area feature read\n");
				   printf("processing cannot continue\n");
				   exit(-1);
				   }
				ARc->numverts = ArealFromFile.numverts;
				ARc->Lindex = ArealFromFile.Lindex;
				ARc->Sindex = ArealFromFile.Sindex;
				ARc->idn = ArealFromFile.idn;
                                ARc->areaattr = ArealFromFile.areaattr;
                                ARc->hgtattr = ArealFromFile.hgtattr;
                                ARc->zv2attr = ArealFromFile.zv2attr;
                                ARc->lenattr = ArealFromFile.lenattr;
                                ARc->namattr = ArealFromFile.namattr;
                                ARc->coversLM = 0;
                                if(ArealFromFile.areastr[0] == '\0')
                                   ARc->areastr = NULL;
                                else
                                   {
                                   ARc->areastr = (char *) (malloc(strlen(ArealFromFile.areastr) + 2));
                                   if(ARc->areastr != NULL)
                                      strcpy(ARc->areastr,ArealFromFile.areastr);
                                   }
                                if(ArealFromFile.hgtstr[0] == '\0')
                                   ARc->hgtstr = NULL;
                                else
                                   {
                                   ARc->hgtstr = (char *) (malloc(strlen(ArealFromFile.hgtstr) + 2));
                                   if(ARc->hgtstr != NULL)
                                      strcpy(ARc->hgtstr,ArealFromFile.hgtstr);
                                   }
                                if(ArealFromFile.zv2str[0] == '\0')
                                   ARc->zv2str = NULL;
                                else
                                   {
                                   ARc->zv2str = (char *) (malloc(strlen(ArealFromFile.zv2str) + 2));
                                   if(ARc->zv2str != NULL)
                                      strcpy(ARc->zv2str,ArealFromFile.zv2str);
                                   }
                                if(ArealFromFile.lenstr[0] == '\0')
                                   ARc->lenstr = NULL;
                                else
                                   {
                                   ARc->lenstr = (char *) (malloc(strlen(ArealFromFile.lenstr) + 2));
                                   if(ARc->lenstr != NULL)
                                      strcpy(ARc->lenstr,ArealFromFile.lenstr);
                                   }
                                if(ArealFromFile.namstr[0] == '\0')
                                   ARc->namstr = NULL;
                                else
                                   {
                                   ARc->namstr = (char *) (malloc(strlen(ArealFromFile.namstr) + 2));
                                   if(ARc->namstr != NULL)
                                      strcpy(ARc->namstr,ArealFromFile.namstr);
                                   }
				ARc->ishole = ArealFromFile.ishole;
				ARc->firstindex = compositeindex;
				ARc->ismulti = 0;
				ARc->RB_Tree_Edgelist = NULL;
				ARc->area = ArealFromFile.area;
ARc->perimlength = ArealFromFile.perimlength;
				tempID = ARc->localID = fo + filedecimal;
				ARc->featureid = ArealFromFile.featureid;
				ARc->minxvtx = ArealFromFile.minxvtx;
				ARc->next = NULL;
				ARc->x = (double *) malloc(SzD * ArealFromFile.numverts);
				ARc->y = (double *) malloc(SzD * ArealFromFile.numverts);
				ARc->z = (double *) malloc(SzD * ArealFromFile.numverts);
				if((ARc->x == NULL) || (ARc->y == NULL) || (ARc->z == NULL))
				   {
				   printf("allocation memory exhausted during area feature read\n");
				   printf("processing cannot continue\n");
				   exit(-1);
				   }
				MinElev = MaxElev = ArealFromFile.z[0];
				for(jj = 0; jj<ArealFromFile.numverts; jj++)
				   {
				   ARc->x[jj] = ArealFromFile.x[jj];
				   ARc->y[jj] = ArealFromFile.y[jj];
				   ARc->z[jj] = ArealFromFile.z[jj];
				   if(ArealFromFile.z[jj] < MinElev)
				      MinElev = ArealFromFile.z[jj];
				   if(ArealFromFile.z[jj] > MaxElev)
				      MaxElev = ArealFromFile.z[jj];
				   }

				vtxcnt = ARc->numverts = ArealFromFile.numverts;
				ARc->next = ARroot;
				ARroot = ARc;

				checkinstance = -1;
                                if((NGA_TYPE == 0) &&
                                ((CombinedCheckApplies(ArealFromFile.idn,checkinstance,VTEAR,ArealFromFile.Lindex,ArealFromFile.Sindex,ArealFromFile.config,
                                        ArealFromFile.stratum,ArealFromFile.domain,&part1,&part2,&part3)) ||
                                (CombinedCheckApplies(ArealFromFile.idn,checkinstance,HTEAR,ArealFromFile.Lindex,ArealFromFile.Sindex,ArealFromFile.config,
                                        ArealFromFile.stratum,ArealFromFile.domain,&part1,&part2,&part3)) ||
                                (CombinedCheckApplies(ArealFromFile.idn,checkinstance,OVERC,ArealFromFile.Lindex,ArealFromFile.Sindex,ArealFromFile.config,
                                        ArealFromFile.stratum,ArealFromFile.domain,&part1,&part2,&part3)) ||
                                (CombinedCheckApplies(ArealFromFile.idn,checkinstance,TVERT,ArealFromFile.Lindex,ArealFromFile.Sindex,ArealFromFile.config,
                                        ArealFromFile.stratum,ArealFromFile.domain,&part1,&part2,&part3))))
				   {
				   edgesin = 0;
				   for(jj=0; jj<ArealFromFile.numverts; jj++)
				      {
				      ii = (jj + 1) % vtxcnt;
				      laec = (struct ListOfEdges *) (malloc(SzLE));
				      if(laec == NULL)
					 {
					 printf("allocation memory exhausted during area feature edge assemble operation\n");
					 printf("processing cannot continue (%d vertex areal)\n",vtxcnt);
					 exit(-1);
					 }
				      laec->x1 = ArealFromFile.x[jj];
				      laec->y1 = ArealFromFile.y[jj];
				      laec->z1 = ArealFromFile.z[jj];
				      laec->x2 = ArealFromFile.x[ii];
				      laec->y2 = ArealFromFile.y[ii];
				      laec->z2 = ArealFromFile.z[ii];

				      if(laec->x1 < laec->x2)
					 {
					 laec->minx = laec->x1;
					 laec->maxx = laec->x2;
					 }
				      else
					 {
					 laec->minx = laec->x2;
					 laec->maxx = laec->x1;
					 }
				      if(laec->y1 < laec->y2)
					 {
					 laec->miny = laec->y1;
					 laec->maxy = laec->y2;
					 }
				      else
					 {
					 laec->miny = laec->y2;
					 laec->maxy = laec->y1;
					 }

				      if((i == 0) && (ArealTable[compositeindex].numother == 0))
					 {
					 rlx = laec->minx;
					 rux = laec->maxx;
					 rly = laec->miny;
					 ruy = laec->maxy;
					 }
				      else
					 {
					 if(laec->minx < rlx)
					    rlx = laec->minx;
					 if(laec->maxx > rux)
					    rux = laec->maxx;
					 if(laec->miny < rly)
					    rly = laec->miny;
					 if(laec->maxy > ruy)
					    ruy = laec->maxy;
					 }

				      laec->owner = (long int) ARc; /** ptr to area feature this edges belongs to **/
				      laec->ownernumb = jj; /** original edges from which it may have been clipped **/
				      laec->clipped = clipflag;
				      laec->isT = 0;
				      laec->length = Distance(laec->x1,laec->y1,laec->x2,laec->y2);
				      laec->Tcover = 0.0;
				      laec->Ocover = 0.0;
				      laec->Iedge = NULL;
				      laec->DeltaZ1 = laec->DeltaZ2  = 0.0;
				      ii = 0;
				      if((sliverdone == 0) || (sliverratio < 0.001))
					 ii = EdgeSliverCheckOK(laec, ArealEdgeRoot, edgesin);
				      else
					 ii = 1;

				      if((ii > 0) && (laec->length > 0.0001))
					 {
					 ++edgesin;
					 laec->next = NULL;
					 InsertIntoEdgeList(laec, &ArealEdgeRoot, DblArealEdgeSkipList, skiplimit);
					 }
				      else
					 free(laec);
				      }
				   } /** end insertion into edge list **/
				} /** end not a duplicate **/
			     else
				{
				tempID = fo + filedecimal;
				}

			     for(checkinstance = 0; checkinstance < TtlActiveChecks; checkinstance++)
				{
                                if(ID_O_count > 0)
                                   {
                                   part1 = 0;
                                   if((ArealFromFile.ishole <= 0) &&
                                      ((IsDup == 2) || (IsDup == 3) || (IsDup == 5)) && (ArealFromFile.idn != ARdup->idn) &&
                                      (CombinedCheckApplies(ArealFromFile.idn,checkinstance,ANY_SAMEID,ArealFromFile.Lindex,ArealFromFile.Sindex,
                                                      ArealFromFile.config,ArealFromFile.stratum,ArealFromFile.domain,
                                                      &part1,&part2,&part3))  && (part1 > 0) &&
                                      (CombinedCheckApplies(ARdup->idn,checkinstance,ANY_SAMEID,ARdup->Lindex,ARdup->Sindex,
                                       SCCtable[ARdup->Sindex].C, SCCtable[ARdup->Sindex].S, SCCtable[ARdup->Sindex].D,
                                                           &part1,&part2,&part3)) && (part2 > 0))
                                      {
                                       FwriteTwoObjects(ANY_SAMEID,Make_Correct(ANY_SAMEID,checkinstance),
                                                  ArealFromFile.idn,G_AREAL,ArealFromFile.Lindex,tempID,ArealFromFile.Sindex,-1.0, -1.0,
                                                  2, ArealFromFile.x, ArealFromFile.y,ArealFromFile.z,
                                                  ARdup->idn,G_AREAL,ARdup->Lindex,ARdup->localID,ARdup->Sindex,-1.0,-1.0,2,
                                                  ARdup->x, ARdup->y,ARdup->z);
                                      }
                                   else if((IsDup != 4) && (ArealFromFile.ishole <= 0) &&
                                       (CombinedCheckApplies(ArealFromFile.idn,checkinstance,ANY_SAMEID,ArealFromFile.Lindex,ArealFromFile.Sindex,
                                                      ArealFromFile.config,ArealFromFile.stratum,ArealFromFile.domain,
                                                      &part1,&part2,&part3)) &&
                                           ((part1 > 0) || (part2 > 0)))
                                      {
                                      GetAppropIDnumber(ArealFromFile.idn, &tempstring[0]);
                                      jj = GetUUIDindex(tempstring);
                                      if(jj >= 0)
                                         {
                                         olidp = ID_O[jj].inst;
                                         while(olidp != NULL)
                                            {
                                            if((olidp->idn != ArealFromFile.idn) && (olidp->checknumb == checkinstance))
                                               {
                                               if((part1 > 0) && (olidp->part > 1))
                                                  {
                                                  FwriteTwoObjects(ANY_SAMEID,Make_Correct(ANY_SAMEID,checkinstance),
                                                        ArealFromFile.idn,G_AREAL,ArealFromFile.Lindex,tempID,ArealFromFile.Sindex,-1.0, -1.0,
                                                        2, ArealFromFile.x, ArealFromFile.y,ArealFromFile.z,
                                                        olidp->idn,olidp->gform,olidp->Lindex,olidp->lid,olidp->Sindex,-1.0,-1.0,olidp->numvert,
                                                        olidp->x, olidp->y,olidp->z);
                                                  break;
                                                  }
                                               else if((part2 > 0) && ((olidp->part == 1) || (olidp->part == 3)))
                                                  {
                                                  FwriteTwoObjects(ANY_SAMEID,Make_Correct(ANY_SAMEID,checkinstance),
                                                        ArealFromFile.idn,G_AREAL,ArealFromFile.Lindex,tempID,ArealFromFile.Sindex,-1.0, -1.0,
                                                        2, ArealFromFile.x, ArealFromFile.y,ArealFromFile.z,
                                                        olidp->idn,olidp->gform,olidp->Lindex,olidp->lid,olidp->Sindex,-1.0,-1.0,2,
                                                        olidp->x, olidp->y,olidp->z);
                                                  break;
                                                  }
                                               }
                                            olidp = olidp->next;
                                            }
                                         if(olidp == NULL)
                                            {
                                            olidc = (struct OverlapIDinstance *) (malloc(sizeof(struct OverlapIDinstance)));
                                            if(olidc == NULL)
                                               {
                                               printf("memory exhausted during unique identifier processing - results will be incomplete\n");
                                               }
                                            else
                                               {
                                               olidc->checknumb = checkinstance;
                                               olidc->idn = ArealFromFile.idn;
                                               olidc->lid = tempID;
                                               olidc->Lindex = ArealFromFile.Lindex;
                                               olidc->Sindex = ArealFromFile.Sindex;
                                               olidc->gform = G_AREAL;
                                               if((part1 > 0) && (part2 > 0))
                                                  olidc->part = 3;
                                               else if(part1 > 0)
                                                  olidc->part = 1;
                                               else
                                                  olidc->part = 2;
                                               olidc->numvert = 2;
                                               olidc->x[0] = ArealFromFile.x[0];
                                               olidc->y[0] = ArealFromFile.y[0];
                                               olidc->z[0] = ArealFromFile.z[0];
                                               olidc->x[1] = ArealFromFile.x[1];
                                               olidc->y[1] = ArealFromFile.y[1];
                                               olidc->z[1] = ArealFromFile.z[1];
                                               olidc->next = ID_O[jj].inst;
                                               ID_O[jj].inst = olidc;
                                               }
                                            }
                                         }
                                      }
                                   }


				if(IsDup < UseDupThreshold)
				  {
				    if((NGA_TYPE != 1) &&
                                     (CombinedCheckApplies(ArealFromFile.idn,checkinstance,SLIVER,ArealFromFile.Lindex,ArealFromFile.Sindex,
							    ArealFromFile.config,ArealFromFile.stratum,ArealFromFile.domain,
							    &part1,&part2,&part3)))
				      {
					if((part1 > 0) &&
					   (sliverdone > 0) && 
					   (SensitivityCheck(LT, SLIVER, checkinstance, sliverratio) > 0)
					   )
					  {
					    FwriteObjectAndMagnitude(SLIVER,Make_Correct(SLIVER,checkinstance),
								     ArealFromFile.idn, 
								     ArealFromFile.Sindex,G_AREAL,ARc->Lindex,ARc->localID,-1.0,-1.0,sliverratio,
								     ArealFromFile.x, ArealFromFile.y,ArealFromFile.z,
								     2, 1);
					  }
				      }

				    if((ArealFromFile.ishole <= 0) && (CombinedCheckApplies(ArealFromFile.idn,checkinstance,BIGAREA,ArealFromFile.Lindex,ArealFromFile.Sindex,
							    ArealFromFile.config,ArealFromFile.stratum,ArealFromFile.domain,
							    &part1,&part2,&part3)))
				       {
				       if((part1 > 0) &&
					   (SensitivityCheck(GT, BIGAREA, checkinstance, ArealFromFile.area) > 0))
					  {
					  FwriteObjectAndMagnitude(BIGAREA,Make_Correct(BIGAREA,checkinstance),
							   ArealFromFile.idn,
							   ArealFromFile.Sindex,G_AREAL,ARc->Lindex,ARc->localID,-1.0,-1.0,ArealFromFile.area,
							   &ArealFromFile.x[0], &ArealFromFile.y[0],&ArealFromFile.z[0],2, 1);
					  }
				       }



				   if(ChkAreaClosure > 0)
				      {
                                      kkend = ArealFromFile.numverts;
				      if((CombinedCheckApplies(ArealFromFile.idn,checkinstance,ZUNCLOSED,ArealFromFile.Lindex,ArealFromFile.Sindex,
							   ArealFromFile.config,ArealFromFile.stratum,ArealFromFile.domain,
							   &part1,&part2,&part3)) && (part1 > 0))
					 {
                                         if((IsSentinelZvalue(ArealFromFile.z[0],UseNUNANPO) == 0) && (IsSentinelZvalue(ArealFromFile.z[kkend],UseNUNANPO) == 0))
                                            {
                                            if(ArealFromFile.z[0] != ArealFromFile.z[kkend])
					       {
					       if(ArealFromFile.z[0] > ArealFromFile.z[kkend])
					          temp = ArealFromFile.z[0] - ArealFromFile.z[kkend];
					       else
					          temp = ArealFromFile.z[kkend] - ArealFromFile.z[0];
	   
					       if(SensitivityCheck(GT, ZUNCLOSED, checkinstance, temp) > 0)
					          {
                                                  FwritePointObjectAndMagnitude(ZUNCLOSED,Make_Correct(ZUNCLOSED,checkinstance),temp,
                                                           ArealFromFile.idn,G_AREAL,ARc->Lindex,ARc->localID,ArealFromFile.Sindex,
                                                           ArealFromFile.x[kkend], ArealFromFile.y[kkend],
                                                           ArealFromFile.z[kkend],
                                                           ArealFromFile.Sindex,ArealFromFile.idn,G_AREAL,ARc->Lindex,ARc->localID,1,
                                                           &ArealFromFile.x[0], &ArealFromFile.y[0], &ArealFromFile.z[0]);
                                                  }
					       }
					    }
					 }
				      if((CombinedCheckApplies(ArealFromFile.idn,checkinstance,AREAUNCLOSED,ArealFromFile.Lindex,ArealFromFile.Sindex,
							   ArealFromFile.config,ArealFromFile.stratum,ArealFromFile.domain,
							   &part1,&part2,&part3)) && (part1 > 0))
					 {  
                                         temp = Distance(ArealFromFile.x[0],ArealFromFile.y[0],
                                                ArealFromFile.x[kkend],ArealFromFile.y[kkend]);
                                         if(ArealFromFile.z[0] != ArealFromFile.z[kkend])
                                            {
                                            temp2 = ArealFromFile.z[0] - ArealFromFile.z[kkend];
                                            temp2 = temp2 * temp2;
                                            temp = temp * temp + temp2;
                                            temp = sqrt(temp);
                                            }
					 if(SensitivityCheck(GT, AREAUNCLOSED, checkinstance, temp) > 0)
					    {          
                                            FwritePointObjectAndMagnitude(AREAUNCLOSED,Make_Correct(AREAUNCLOSED,checkinstance),temp,
                                                           ArealFromFile.idn,G_AREAL,ARc->Lindex,ARc->localID,ArealFromFile.Sindex,
                                                           ArealFromFile.x[kkend], ArealFromFile.y[kkend],
                                                           ArealFromFile.z[kkend],
                                                           ArealFromFile.Sindex,ArealFromFile.idn,G_AREAL,ARc->Lindex,ARc->localID,1,
                                                           &ArealFromFile.x[0], &ArealFromFile.y[0], &ArealFromFile.z[0]);
					    }
					 }
				      }



				    if((ArealFromFile.numverts > 1) &&
                                     (CombinedCheckApplies(ArealFromFile.idn,checkinstance,V_DUPS,ArealFromFile.Lindex,ArealFromFile.Sindex,
							    ArealFromFile.config,ArealFromFile.stratum,ArealFromFile.domain,
							    &part1,&part2,&part3)) && (part1 > 0))
				      {
					dv = DuplicateVerticesExist(ArealFromFile.numverts,
								       ArealFromFile.x,ArealFromFile.y,
								       ArealFromFile.z);
					if(SensitivityCheck(GT, V_DUPS, checkinstance, (double) dv) > 0)
					  {
					  for(jj=1; jj<ArealFromFile.numverts; jj++)
					    {
					    if((ArealFromFile.x[jj-1] == ArealFromFile.x[jj]) &&
						(ArealFromFile.y[jj-1] == ArealFromFile.y[jj]) &&
						(ArealFromFile.z[jj-1] == ArealFromFile.z[jj]))
					       {
                                               FwriteObject(V_DUPS,Make_Correct(V_DUPS,checkinstance),ArealFromFile.Lindex,
                                                           ArealFromFile.Sindex,G_AREAL,ARc->localID,ArealFromFile.idn, -1.0, -1.0,
                                                            &ArealFromFile.x[jj],&ArealFromFile.y[jj],&ArealFromFile.z[jj],1, 1);
					       }
					    }
					  }
                                      if((ArealFromFile.x[0] == ArealFromFile.x[ArealFromFile.numverts-1]) &&
                                                (ArealFromFile.y[0] == ArealFromFile.y[ArealFromFile.numverts-1]) &&
                                                (ArealFromFile.z[0] == ArealFromFile.z[ArealFromFile.numverts-1]))
                                         {
                                         if(SensitivityCheck(GT, V_DUPS, checkinstance, 1.0) > 0)
                                            {
                                            FwriteObject(V_DUPS,Make_Correct(V_DUPS,checkinstance),ArealFromFile.Lindex,
                                                           ArealFromFile.Sindex,G_AREAL,ARc->localID,ArealFromFile.idn, -1.0, -1.0,
                                                            &ArealFromFile.x[ArealFromFile.numverts-1],&ArealFromFile.y[ArealFromFile.numverts-1],&ArealFromFile.z[ArealFromFile.numverts-1],1, 1);
                                            }
                                         }
				      }


				    if((CombinedCheckApplies(ArealFromFile.idn,checkinstance,NARROW,ArealFromFile.Lindex,ArealFromFile.Sindex,
							    ArealFromFile.config,ArealFromFile.stratum,ArealFromFile.domain,
							    &part1,&part2,&part3)) && (part1 > 0))
				      {
					if((sliverdone > 0) && /****(width < ErrorLookup[NARROW].sensitivity))****/
					   (SensitivityCheck(LT, NARROW, checkinstance, width) > 0))
					  {
					    FwriteObjectAndMagnitude(NARROW,Make_Correct(NARROW,checkinstance),
								     ArealFromFile.idn, 
								     ArealFromFile.Sindex,G_AREAL,ARc->Lindex,ARc->localID,-1.0,-1.0,
								     width,ArealFromFile.x, ArealFromFile.y,
								     ArealFromFile.z,2, 1);
					  }
				      }


				    if((CombinedCheckApplies(ArealFromFile.idn,checkinstance,SMALLOBJ,ArealFromFile.Lindex,
							    ArealFromFile.Sindex,ArealFromFile.config,
							    ArealFromFile.stratum,ArealFromFile.domain,
							    &part1,&part2,&part3)) && (part1 > 0))
				      {
					surfacearea3D = SurfaceAreaByTriangles(ArealFromFile.numverts, ArealFromFile.x,
									       ArealFromFile.y,ArealFromFile.z);
				
					if(SensitivityCheck(LT, SMALLOBJ, checkinstance, surfacearea3D) > 0)
					  /****if(surfacearea3D < ErrorLookup[SMALLOBJ].sensitivity) ****/
					  {
					    FwriteObjectAndMagnitude(SMALLOBJ,Make_Correct(SMALLOBJ,checkinstance),
								     ArealFromFile.idn, 
								     ArealFromFile.Sindex,G_AREAL,ARc->Lindex,ARc->localID,-1.0,-1.0,
								     surfacearea3D,ArealFromFile.x, ArealFromFile.y,
								     ArealFromFile.z,2, 1);
					  }
				      }



				    if((CombinedCheckApplies(ArealFromFile.idn,checkinstance,ATTRERR,ArealFromFile.Lindex,
							    ArealFromFile.Sindex,ArealFromFile.config,
							    ArealFromFile.stratum,ArealFromFile.domain,
							    &part1,&part2,&part3)) && (part1 > 0))
				      {
					if(CrsWlk[ArealFromFile.Lindex].AttrErr >= 0)
					  {
					    FwriteObjectAndMessage(ATTRERR,Make_Correct(ATTRERR,checkinstance),
								   ArealFromFile.idn, G_AREAL,ARc->Lindex,ARc->localID,
								   ArealFromFile.Sindex,-1.0,-1.0,ArealFromFile.x,
								   ArealFromFile.y,ArealFromFile.z,2,
								   AttrErr[CrsWlk[ArealFromFile.Lindex].AttrErr].description);
					  }
				      }




				      if((ArealFromFile.ishole <= 0) && 
                                            (CombinedCheckApplies(ArealFromFile.idn,checkinstance,MULTIPARTA,ArealFromFile.Lindex,ArealFromFile.Sindex,
							      ArealFromFile.config,ArealFromFile.stratum,ArealFromFile.domain,
							      &part1,&part2,&part3) > 0) && (part1 > 0))
					{
					mpoc = MultiAreaRoot;
					kkk = 0;
					while(mpoc != NULL)
					   {
					   if((mpoc->featureid == ArealFromFile.idn) && (mpoc->used == 0))
					      ++kkk;
					   mpoc = mpoc->next;
					   }
					if(SensitivityCheck(GT, MULTIPARTA, checkinstance, (double) kkk) > 0)
					   {
					   mpoc = MultiAreaRoot;
					   while(mpoc != NULL)
					      {
					      if(mpoc->featureid == ArealFromFile.idn)
						 {
						 mpoc->used = 1;
						 FwriteObjectAndMagnitude(MULTIPARTA,Make_Correct(MULTIPARTA,checkinstance),
								     ArealFromFile.idn,
								     ArealFromFile.Sindex,G_AREAL,ARc->Lindex,ARc->localID,-1.0,-1.0,(double) kkk,
								     mpoc->x, mpoc->y, mpoc->z, mpoc->numverts, 1); /**mpoc->numverts); **/
						 }
					      mpoc = mpoc->next;
					      }
					   }
					}




				      if(CombinedCheckApplies(ArealFromFile.idn,checkinstance,LOOPS,ArealFromFile.Lindex,ArealFromFile.Sindex,
							      ArealFromFile.config,ArealFromFile.stratum,ArealFromFile.domain,
							      &part1,&part2,&part3))
					{
					if((part1 > 0) && (ArealFromFile.numverts > 2)) /*** &&(ArealFromFile.numverts <maxverts)) ***/
					   {
					   CheckArealForSelfIntersection(ARc,&xint, &yint,checkinstance);
					   }
					}



                                      if(CombinedCheckApplies(ArealFromFile.idn,checkinstance,LONGFEAT,ArealFromFile.Lindex,ArealFromFile.Sindex,
                                                              ArealFromFile.config,ArealFromFile.stratum,ArealFromFile.domain,
                                                              &part1,&part2,&part3))
                                        {
                                          if((part1 > 0) && (ArealFromFile.numverts > 1))
                                             {
                                             segmentlength = 0;
                                             for(jj=1; jj<ArealFromFile.numverts; jj++)
                                                {
                                                segmentlength += Distance3D(ArealFromFile.x[jj-1],ArealFromFile.y[jj-1],ArealFromFile.z[jj-1],
                                                                           ArealFromFile.x[jj],ArealFromFile.y[jj],ArealFromFile.z[jj]);

                                                }
                                             segmentlength += Distance3D(ArealFromFile.x[jj-1],ArealFromFile.y[jj-1],ArealFromFile.z[jj-1],
                                                                        ArealFromFile.x[jj],ArealFromFile.y[jj],ArealFromFile.z[jj]);
                                             if(SensitivityCheck(GT, LONGFEAT, checkinstance, segmentlength) > 0)
                                                {
                                                FwriteObjectAndMagnitude(LONGFEAT,Make_Correct(LONGFEAT,checkinstance),
                                                                  ArealFromFile.idn,
                                                                  ArealFromFile.Sindex,G_AREAL,ARc->Lindex,ARc->localID,-1.0,-1.0,segmentlength,
                                                                  ArealFromFile.x, ArealFromFile.y,ArealFromFile.z,2, 1);
                                                }

                                             }
                                        }

				  }
				}  /**** for(checkinstance = 0; checkinstance < TtlActiveChecks; checkinstance++) ***/
			     }
			  FreePointAndIDlist();
			  if(abortNow > 0)
			     break;
			  }
		       }

	/** now have all the areals in this region ****/
                    if(NGA_TYPE == 0)
                    {
		    if(abortNow == 0)
		       {
		       CheckEdgeTopology(ArealEdgeRoot, VertArealEdgeRoot,2);
		       }
		    laec = ArealEdgeRoot;
		    while((abortNow == 0) && (laec != NULL))
		       {
		       ARn = (struct RawAreal *) laec->owner;
		       Config = SCCtable[ARn->Sindex].C;
		       Stratum = SCCtable[ARn->Sindex].S;
		       Domain = SCCtable[ARn->Sindex].D;
		       for(checkinstance = 0; checkinstance < TtlActiveChecks; checkinstance++)
			  {

			  if((laec->Tcover < laec->length) && /*** undercovered edge **/
			    (CombinedCheckApplies(ARn->idn,checkinstance,HTEAR,ARn->Lindex,ARn->Sindex,Config,Stratum,Domain,&part1,&part2,&part3) > 0) &&
				(part1 > 0))
			     {
			     pcCoverage = 1.0 - (laec->Tcover / laec->length);
			     pcCoverage = pcCoverage * 100.0;
			     if(SensitivityCheck(GT, HTEAR, checkinstance, pcCoverage) > 0)
				{
				neighborhit = 0;
				if(NeighborsExist[0] == 0)
				   {
				   if((PointOnLineSegment(laec->x1,laec->y1,rlx,rly,rux,rly,0.01) > 0) &&
				    (PointOnLineSegment(laec->x2,laec->y2,rlx,rly,rux,rly,0.01) > 0))
				   ++neighborhit;
				   }
				if(NeighborsExist[1] == 0)
				   {
				   if((PointOnLineSegment(laec->x1,laec->y1,rlx,rly,rlx,ruy,0.01) > 0) &&
				    (PointOnLineSegment(laec->x2,laec->y2,rlx,rly,rlx,ruy,0.01) > 0))
				   ++neighborhit;
				   }
				if(NeighborsExist[2] == 0)
				   {
				   if((PointOnLineSegment(laec->x1,laec->y1,rlx,ruy,rux,ruy,0.01) > 0) &&
				       (PointOnLineSegment(laec->x2,laec->y2,rlx,ruy,rux,ruy,0.01) > 0))
				   ++neighborhit;
				   }
				if(NeighborsExist[3] == 0)
				   {
				   if((PointOnLineSegment(laec->x1,laec->y1,rux,rly,rux,ruy,0.01) > 0) &&
					  (PointOnLineSegment(laec->x2,laec->y2,rux,rly,rux,ruy,0.01) > 0))
				   ++neighborhit;
				   }
				if(neighborhit == 0)
				   {
				   edgeX[0] = laec->x1;
				   edgeY[0] = laec->y1;
				   edgeZ[0] = laec->z1;
				   edgeX[1] = laec->x2;
				   edgeY[1] = laec->y2;
				   edgeZ[1] = laec->z2;
				   FwriteObjectAndMagnitude(HTEAR,Make_Correct(HTEAR,checkinstance),
					     ARn->idn, ARn->Sindex,G_AREAL,ARn->Lindex,ARn->localID,-1.0,-1.0,
					     pcCoverage,edgeX, edgeY,edgeZ,2, 1);
				   }
				}
			     }
			  else if((laec->Ocover > laec->length) &&  /** over-covered edge **/
				 (CombinedCheckApplies(ARn->idn,checkinstance,OVERC,ARn->Lindex,ARn->Sindex,Config,Stratum,Domain,&part1,&part2,&part3) > 0) &&
				(part1 > 0))
			     {
			     edgeX[0] = laec->x1;
			     edgeY[0] = laec->y1;
			     edgeZ[0] = laec->z1;
			     edgeX[1] = laec->x2;
			     edgeY[1] = laec->y2;
			     edgeZ[1] = laec->z2;
			     FwriteObjectAndMagnitude(OVERC,Make_Correct(OVERC,checkinstance),
				   ARn->idn, ARn->Sindex,G_AREAL,ARn->Lindex,ARn->localID,-1.0,-1.0,
				   laec->Ocover/laec->length*100.0,edgeX, edgeY,edgeZ,2, 1);
			     }
			  if((CombinedCheckApplies(ARn->idn,checkinstance,VTEAR,ARn->Lindex,ARn->Sindex,Config,Stratum,Domain,&part1,&part2,&part3) > 0) && (part1 > 0))
			     {
			     IE1 = laec->Iedge;
			     while(IE1 != NULL)
				{
				if((IE1->primary == 1)  && /** to avoid a doubl-count ***/
				    (SensitivityCheck(GT, VTEAR, checkinstance, IE1->DeltaZ) > 0))
				   {
				   AdjEdge = (struct ListOfEdges *) IE1->AdjacentEdge;
				   ARadj = (struct RawAreal *) AdjEdge->owner;
				   if((laec->x1 == IE1->DeltaZX) && (laec->y1 == IE1->DeltaZY))
				      {
				      edgeX[0] = laec->x1;
				      edgeY[0] = laec->y1;
				      edgeZ[0] = laec->z1;
				      edgeX[1] = laec->x2;
				      edgeY[1] = laec->y2;
				      edgeZ[1] = laec->z2;

				      edgeX[2] = AdjEdge->x1;
				      edgeY[2] = AdjEdge->y1;
				      edgeZ[2] = AdjEdge->z1;
				      edgeX[3] = AdjEdge->x2;
				      edgeY[3] = AdjEdge->y2;
				      edgeZ[3] = AdjEdge->z2;
				      FwriteMagnitudeAndTwoObjects(VTEAR,Make_Correct(VTEAR,checkinstance),laec->DeltaZ1,
					  ARn->Sindex,G_AREAL,ARn->Lindex,
					  ARn->localID,ARn->idn,-1.0, -1.0,edgeX, edgeY,edgeZ,2,
					  ARadj->Sindex,G_AREAL,ARadj->Lindex,
					  ARadj->localID,ARadj->idn, -1.0,-1.0,&edgeX[2], &edgeY[2],&edgeZ[2],2);
				      }
				   else if((laec->x2 == IE1->DeltaZX) && (laec->y2 == IE1->DeltaZY))
				      {
				      edgeX[0] = laec->x2;
				      edgeY[0] = laec->y2;
				      edgeZ[0] = laec->z2;
				      edgeX[1] = laec->x1;
				      edgeY[1] = laec->y1;
				      edgeZ[1] = laec->z1;

				      edgeX[2] = AdjEdge->x1;
				      edgeY[2] = AdjEdge->y1;
				      edgeZ[2] = AdjEdge->z1;
				      edgeX[3] = AdjEdge->x2;
				      edgeY[3] = AdjEdge->y2;
				      edgeZ[3] = AdjEdge->z2;
				      FwriteMagnitudeAndTwoObjects(VTEAR,Make_Correct(VTEAR,checkinstance),laec->DeltaZ1,
					  ARn->Sindex,G_AREAL,ARn->Lindex,
					  ARn->localID,ARn->idn,-1.0, -1.0,edgeX, edgeY,edgeZ,2,
					  ARadj->Sindex,G_AREAL,ARadj->Lindex,
					  ARadj->localID,ARadj->idn, -1.0,-1.0,&edgeX[2], &edgeY[2],&edgeZ[2],2);
				      }
				   else if((AdjEdge->x1 == IE1->DeltaZX) && (AdjEdge->y1 == IE1->DeltaZY))
				      {
				      edgeX[0] = AdjEdge->x1;
				      edgeY[0] = AdjEdge->y1;
				      edgeZ[0] = AdjEdge->z1;
				      edgeX[1] = AdjEdge->x2;
				      edgeY[1] = AdjEdge->y2;
				      edgeZ[1] = AdjEdge->z2;

				      edgeX[2] = laec->x1;
				      edgeY[2] = laec->y1;
				      edgeZ[2] = laec->z1;
				      edgeX[3] = laec->x2;
				      edgeY[3] = laec->y2;
				      edgeZ[3] = laec->z2;
				      FwriteMagnitudeAndTwoObjects(VTEAR,Make_Correct(VTEAR,checkinstance),laec->DeltaZ1,
					  ARadj->Sindex,G_AREAL,ARadj->Lindex,
					  ARadj->localID,ARadj->idn,-1.0, -1.0,edgeX, edgeY,edgeZ,2,
					  ARn->Sindex,G_AREAL,ARn->Lindex,
					  ARn->localID,ARn->idn, -1.0,-1.0,&edgeX[2], &edgeY[2],&edgeZ[2],2);
				      }
				   else if((AdjEdge->x2 == IE1->DeltaZX) && (AdjEdge->y2 == IE1->DeltaZY))
				      {
				      edgeX[0] = AdjEdge->x2;
				      edgeY[0] = AdjEdge->y2;
				      edgeZ[0] = AdjEdge->z2;
				      edgeX[1] = AdjEdge->x1;
				      edgeY[1] = AdjEdge->y1;
				      edgeZ[1] = AdjEdge->z1;

				      edgeX[2] = laec->x1;
				      edgeY[2] = laec->y1;
				      edgeZ[2] = laec->z1;
				      edgeX[3] = laec->x2;
				      edgeY[3] = laec->y2;
				      edgeZ[3] = laec->z2;
				      FwriteMagnitudeAndTwoObjects(VTEAR,Make_Correct(VTEAR,checkinstance),laec->DeltaZ1,
					  ARadj->Sindex,G_AREAL,ARadj->Lindex,
					  ARadj->localID,ARadj->idn,-1.0, -1.0,edgeX, edgeY,edgeZ,2,
					  ARn->Sindex,G_AREAL,ARn->Lindex,
					  ARn->localID,ARn->idn, -1.0,-1.0,&edgeX[2], &edgeY[2],&edgeZ[2],2);
				      }
				   }
				else if((IE1->primary == 3) &&  /** to avoid a doubl-count for classsic 'T' case ***/
				   (SensitivityCheck(GT, VTEAR, checkinstance, IE1->DeltaZ) > 0))
				   {
				   AdjEdge = (struct ListOfEdges *) IE1->AdjacentEdge;
				   ARadj = (struct RawAreal *) AdjEdge->owner;
				   if((laec->x1 == IE1->DeltaZX) && (laec->y1 == IE1->DeltaZY))
				      {
				      edgeX[0] = laec->x1;
				      edgeY[0] = laec->y1;
				      edgeZ[0] = laec->z1;

				      edgeX[2] = AdjEdge->x1;
				      edgeY[2] = AdjEdge->y1;
				      edgeZ[2] = AdjEdge->z1;
				      edgeX[3] = AdjEdge->x2;
				      edgeY[3] = AdjEdge->y2;
				      edgeZ[3] = AdjEdge->z2;
				      FwriteMagnitudeAndTwoObjects(VTEAR,Make_Correct(VTEAR,checkinstance),IE1->DeltaZ,
					  ARn->Sindex,G_AREAL,ARn->Lindex,
					  ARn->localID,ARn->idn,-1.0, -1.0,edgeX, edgeY,edgeZ,1,
					  ARadj->Sindex,G_AREAL,ARadj->Lindex,
					  ARadj->localID,ARadj->idn,-1.0, -1.0,&edgeX[2], &edgeY[2],&edgeZ[2],2);
				      }
				   else if((laec->x2 == IE1->DeltaZX) && (laec->y2 == IE1->DeltaZY))
				      {
				      edgeX[0] = laec->x2;
				      edgeY[0] = laec->y2;
				      edgeZ[0] = laec->z2;
	   
				      edgeX[2] = AdjEdge->x1;
				      edgeY[2] = AdjEdge->y1;
				      edgeZ[2] = AdjEdge->z1;
				      edgeX[3] = AdjEdge->x2;
				      edgeY[3] = AdjEdge->y2;
				      edgeZ[3] = AdjEdge->z2;
				      FwriteMagnitudeAndTwoObjects(VTEAR,Make_Correct(VTEAR,checkinstance),IE1->DeltaZ,
					  ARn->Sindex,G_AREAL,ARn->Lindex,
					  ARn->localID,ARn->idn,-1.0, -1.0,edgeX, edgeY,edgeZ,1,
					  ARadj->Sindex,G_AREAL,ARadj->Lindex,
					  ARadj->localID,ARadj->idn,-1.0, -1.0,&edgeX[2], &edgeY[2],&edgeZ[2],2);
				      }
				   }
				else if((IE1->primary == 5) &&  /** to avoid a doubl-count for incident at shared vertex case ***/
				    (SensitivityCheck(GT, VTEAR, checkinstance, IE1->DeltaZ) > 0))
				   {
				   AdjEdge = (struct ListOfEdges *) IE1->AdjacentEdge;
				   ARadj = (struct RawAreal *) AdjEdge->owner;
				   if((laec->x1 == IE1->DeltaZX) && (laec->y1 == IE1->DeltaZY))
				      {
				      edgeX[0] = laec->x1;
				      edgeY[0] = laec->y1;
				      edgeZ[0] = laec->z1;
				      }
				   else
				      {
				      edgeX[0] = laec->x2;
				      edgeY[0] = laec->y2;
				      edgeZ[0] = laec->z2;
				      }
				   if((AdjEdge->x1 == IE1->DeltaZX) && (AdjEdge->y1 == IE1->DeltaZY))
				      {
				      edgeX[2] = AdjEdge->x1;
				      edgeY[2] = AdjEdge->y1;
				      edgeZ[2] = AdjEdge->z1;
				      }
				   else
				      {
				      edgeX[2] = AdjEdge->x2;
				      edgeY[2] = AdjEdge->y2;
				      edgeZ[2] = AdjEdge->z2;
				      }

				   FwriteMagnitudeAndTwoObjects(VTEAR,Make_Correct(VTEAR,checkinstance),IE1->DeltaZ,
				       ARn->Sindex,G_AREAL,ARn->Lindex,
				       ARn->localID,ARn->idn,-1.0, -1.0,edgeX, edgeY,edgeZ,1,
				       ARadj->Sindex,G_AREAL,ARadj->Lindex,
				       ARadj->localID,ARadj->idn,-1.0, -1.0,&edgeX[2], &edgeY[2],&edgeZ[2],1);
				   }

				IE1 = IE1->next;
				}
			     }
			  } /*** for(checkinstance = 0; checkinstance < TtlActiveChecks; checkinstance++) ***/
		       laec = laec->next;
		       if(abortNow > 0)
			  break;
		       }
                    } /*** end if NGA_TYPE == 0 ***/



		    FreeLongList(&NeighborArealLongListRoot);
		    NeighborArealLongListRoot = NULL;
		    for(i=0; i<skiplimit; i++)
		       {
		       NeighborLongArealSkipList[i].val = -1;
		       NeighborLongArealSkipList[i].entry = NULL;
		       }

		    if(index1 == 0)
		       index1base = 0;
		    else
		       index1base = index1 - 1;
		    if(index1 == MaxXindex)
		       index1top = index1;
		    else
		       index1top = index1 + 1;
		    if(index2 == 0)
		       index2base = 0;
		    else
		       index2base = index2 - 1;
		    if(index2 == MaxYindex)
		       index2top = index2;
		    else
		       index2top = index2 + 1;

		    filedecimal = ((double) (Lfilenumber + 1)) / 10.0;

		    for(i=index1base; i<=index1top; i++)
		       {
		       for(j=index2base; j<=index2top; j++)
			  {
			  if((i != index1) || (j != index2))
			     {
			     neighborcompositeindex = (i * (MaxYindex + 1)) + j;
			     for(ii=0; ii<ArealTable[neighborcompositeindex].numother; ii++)
				{

				fo = fileoffset * ArealTable[neighborcompositeindex].others[ii].filenumber +
					       ArealTable[neighborcompositeindex].others[ii].fileptr;
				for(jj2 = 0; jj2 < ArealTable[compositeindex].numother; jj2++)
				    {
				    if((ArealTable[compositeindex].others[jj2].filenumber == ArealTable[neighborcompositeindex].others[ii].filenumber) &&
					 (ArealTable[compositeindex].others[jj2].fileptr == ArealTable[neighborcompositeindex].others[ii].fileptr))

				       break;
				    }
				if(jj2 >= ArealTable[compositeindex].numother)
				   InsertOK =  InsertIntoLongList(fo,ArealTable[neighborcompositeindex].others[ii].filenumber,skiplimit,
					  &NeighborArealLongListRoot,NeighborLongArealSkipList,&SkipNEntry);
				else
				   InsertOK = 0;
				if(InsertOK > 0)
				   {
				   ARlc = ARlargeRoot;
				   while(ARlc != NULL)
				     {
				     if((ARlc->fp == fo) && (ARlc->fnumber == ArealTable[neighborcompositeindex].others[ii].filenumber))
					{
					if(ARlc->ra != NULL)
					   {
					   ARlc->ra->next = NRAroot;
					   NRAroot = ARlc->ra;
					   }
					InsertOK = 0;
					break;
					}
				     ARlc = ARlc->next;
				     }
				   }
				if(InsertOK > 0)
				   {
				   if(ArealTable[neighborcompositeindex].others[ii].filenumber != Afilenumber)
				      {
				      Afilenumber = ArealTable[neighborcompositeindex].others[ii].filenumber;
				      filedecimal = ((double) (Afilenumber + 1)) / 10.0;
				      if(ArealFiles[Afilenumber].isopen == 0)
					 {
					 sprintf(suffix,"%d",Afilenumber);
					 strcpy(afilein,arealsin);
					 if(Afilenumber > 0)
					     strcat(afilein,suffix);
					 arin = fopen(afilein,"rb");
					 if(arin == NULL)
					    {
					    printf("3 area feature data input file %s could not be opened for read\n",afilein);
					    exit(-1);
					    }
					 ArealFiles[Afilenumber].fp = arin;
					 ArealFiles[Afilenumber].isopen = 1;
					 }
				      else
					 {
					 arin = ArealFiles[Afilenumber].fp;
					 }
				      }

				   fseek(arin,ArealTable[neighborcompositeindex].others[ii].fileptr,SEEK_SET);
				   vtxcnt = ReadArealFromFile(arin, multiplier);

				   OKtoUse = 1;
				   if((NGA_TYPE == 0) && (NumLODbands > 0))
				      {
				      jj = CrsWlk[ArealFromFile.Lindex].LODband;
				      if((jj > 0) && (LODindex[jj-1].active < 1))
					 OKtoUse = 0;
				      }
				   }
				if((InsertOK > 0) && (OKtoUse > 0) && (vtxcnt > 0))
				   {
				   if((CheckByStratum[ArealFromFile.stratum] > 0) &&
					 (CheckByDomain[ArealFromFile.domain] > 0))
				      {
				      NRAc = (struct RawAreal *) (malloc(SzRA));
				      if(NRAc == NULL)
					 {
					 printf("allocation memory exhausted during area feature read\n");
					 printf("processing cannot continue\n");
					 exit(-1);
					 }
				      NRAc->next = NULL;
				      NRAc->numverts = ArealFromFile.numverts;
				      NRAc->Lindex = ArealFromFile.Lindex;
				      NRAc->Sindex = ArealFromFile.Sindex;
				      NRAc->idn = ArealFromFile.idn;
                                      NRAc->areaattr = ArealFromFile.areaattr;
                                      NRAc->coversLM = 0;
                                      NRAc->hgtattr = ArealFromFile.hgtattr;
                                      NRAc->zv2attr = ArealFromFile.zv2attr;
                                      NRAc->lenattr = ArealFromFile.lenattr;
                                      NRAc->namattr = ArealFromFile.namattr;
                                      if(ArealFromFile.areastr[0] == '\0')
                                         NRAc->areastr = NULL;
                                      else
                                         {
                                         NRAc->areastr = (char *) (malloc(strlen(ArealFromFile.areastr) + 2));
                                         if(NRAc->areastr != NULL)
                                            strcpy(NRAc->areastr,ArealFromFile.areastr);
                                         }
                                      if(ArealFromFile.hgtstr[0] == '\0')
                                         NRAc->hgtstr = NULL;
                                      else
                                         {
                                         NRAc->hgtstr = (char *) (malloc(strlen(ArealFromFile.hgtstr) + 2));
                                         if(NRAc->hgtstr != NULL)
                                            strcpy(NRAc->hgtstr,ArealFromFile.hgtstr);
                                         }
                                      if(ArealFromFile.zv2str[0] == '\0')
                                         NRAc->zv2str = NULL;
                                      else
                                         {
                                         NRAc->zv2str = (char *) (malloc(strlen(ArealFromFile.zv2str) + 2));
                                         if(NRAc->zv2str != NULL)
                                            strcpy(NRAc->zv2str,ArealFromFile.zv2str);
                                         }
                                      if(ArealFromFile.lenstr[0] == '\0')
                                         NRAc->lenstr = NULL;
                                      else
                                         {
                                         NRAc->lenstr = (char *) (malloc(strlen(ArealFromFile.lenstr) + 2));
                                         if(NRAc->lenstr != NULL)
                                            strcpy(NRAc->lenstr,ArealFromFile.lenstr);
                                         }
                                      if(ArealFromFile.namstr[0] == '\0')
                                         NRAc->namstr = NULL;
                                      else
                                         {
                                         NRAc->namstr = (char *) (malloc(strlen(ArealFromFile.namstr) + 2));
                                         if(NRAc->namstr != NULL)
                                            strcpy(NRAc->namstr,ArealFromFile.namstr);
                                         }
				      NRAc->ishole = ArealFromFile.ishole;
				      NRAc->firstindex = compositeindex;
				      NRAc->ismulti = 0;
				      NRAc->RB_Tree_Edgelist = NULL;
				      NRAc->area = ArealFromFile.area;
NRAc->perimlength = ArealFromFile.perimlength;
				      NRAc->localID = (double)ArealTable[neighborcompositeindex].others[ii].fileptr + filedecimal;
				      NRAc->featureid = ArealFromFile.featureid;
				      NRAc->minxvtx = ArealFromFile.minxvtx;
				      NRAc->next = NULL;
				      NRAc->x = (double *) malloc(SzD * ArealFromFile.numverts);
				      NRAc->y = (double *) malloc(SzD * ArealFromFile.numverts);
				      NRAc->z = (double *) malloc(SzD * ArealFromFile.numverts);
				      if((NRAc->x == NULL) || (NRAc->y == NULL) || (NRAc->z == NULL))
					 {
					 printf("allocation memory exhausted during area feature read\n");
					 printf("processing cannot continue\n");
					 exit(-1);
					 }
				      MinElev = MaxElev = ArealFromFile.z[0];
				      for(jj = 0; jj<ArealFromFile.numverts; jj++)
					 {
					 NRAc->x[jj] = ArealFromFile.x[jj];
					 NRAc->y[jj] = ArealFromFile.y[jj];
					 NRAc->z[jj] = ArealFromFile.z[jj];
					 if(ArealFromFile.z[jj] < MinElev)
					    MinElev = ArealFromFile.z[jj];
					 if(ArealFromFile.z[jj] > MaxElev)
					    MaxElev = ArealFromFile.z[jj];
					 }
	      
				      vtxcnt = NRAc->numverts = ArealFromFile.numverts;
				      NRAc->next = NRAroot;
				      NRAroot = NRAc;
				      }
				   }
				}
			     k = ArealTable[neighborcompositeindex].numinside;
			     if(k > 0)
				{
				if(ArealTable[neighborcompositeindex].filenumber != Afilenumber)
				   {
				   Afilenumber = ArealTable[neighborcompositeindex].filenumber;
				   filedecimal = ((double) (Afilenumber + 1)) / 10.0;
				   if(ArealFiles[Afilenumber].isopen == 0)
				      {
				      sprintf(suffix,"%d",Afilenumber);
				      strcpy(afilein,arealsin);
				      if(Afilenumber > 0)
					  strcat(afilein,suffix);
				      arin = fopen(afilein,"rb");
				      if(arin == NULL)
					 {
					 printf("3 area feature data input file %s could not be opened for read\n",afilein);
					 exit(-1);
					 }
				      ArealFiles[Afilenumber].fp = arin;
				      ArealFiles[Afilenumber].isopen = 1;
				      }
				   else
				      {
				      arin = ArealFiles[Afilenumber].fp;
				      }
				   }
				fseek(arin,ArealTable[neighborcompositeindex].fileptr,SEEK_SET);
				ii = 0;
				while(ii < k)
				   {
				   fo = ftell(arin);
				   vtxcnt =  ReadArealFromFile(arin, multiplier);
				   ++ii;

				   OKtoUse = 1;
				   if((NGA_TYPE == 0) && (NumLODbands > 0))
				      {
				      jj = CrsWlk[ArealFromFile.Lindex].LODband;
				      if((jj > 0) && (LODindex[jj-1].active < 1))
					 OKtoUse = 0;
				      }

				   if((OKtoUse > 0) && (vtxcnt > 0))
				      {
				      if((CheckByStratum[ArealFromFile.stratum] > 0) &&
					    (CheckByDomain[ArealFromFile.domain] > 0))
					 {
					 NRAc = (struct RawAreal *) (malloc(SzRA));
					 if(NRAc == NULL)
					    {
					    printf("allocation memory exhausted during area feature read\n");
					    printf("processing cannot continue\n");
					    exit(-1);
					    }
					 NRAc->next = NULL;
					 NRAc->numverts = ArealFromFile.numverts;
					 NRAc->Lindex = ArealFromFile.Lindex;
					 NRAc->Sindex = ArealFromFile.Sindex;
					 NRAc->idn = ArealFromFile.idn;
                                         NRAc->coversLM = 0;
                                         NRAc->areaattr = ArealFromFile.areaattr;
                                         NRAc->hgtattr = ArealFromFile.hgtattr;
                                         NRAc->zv2attr = ArealFromFile.zv2attr;
                                         NRAc->lenattr = ArealFromFile.lenattr;
                                         NRAc->namattr = ArealFromFile.namattr;
                                         if(ArealFromFile.areastr[0] == '\0')
                                            NRAc->areastr = NULL;
                                         else
                                            {
                                            NRAc->areastr = (char *) (malloc(strlen(ArealFromFile.areastr)+ 2));
                                            if(NRAc->areastr != NULL)
                                               strcpy(NRAc->areastr,ArealFromFile.areastr);
                                            }
                                         if(ArealFromFile.hgtstr[0] == '\0')
                                            NRAc->hgtstr = NULL;
                                         else
                                            {
                                            NRAc->hgtstr = (char *) (malloc(strlen(ArealFromFile.hgtstr)+ 2));
                                            if(NRAc->hgtstr != NULL)
                                               strcpy(NRAc->hgtstr,ArealFromFile.hgtstr);
                                            }
                                         if(ArealFromFile.zv2str[0] == '\0')
                                            NRAc->zv2str = NULL;
                                         else
                                            {
                                            NRAc->zv2str = (char *) (malloc(strlen(ArealFromFile.zv2str)+ 2));
                                            if(NRAc->zv2str != NULL)
                                               strcpy(NRAc->zv2str,ArealFromFile.zv2str);
                                            }
                                         if(ArealFromFile.lenstr[0] == '\0')
                                            NRAc->lenstr = NULL;
                                         else
                                            {
                                            NRAc->lenstr = (char *) (malloc(strlen(ArealFromFile.lenstr)+ 2));
                                            if(NRAc->lenstr != NULL)
                                               strcpy(NRAc->lenstr,ArealFromFile.lenstr);
                                            }
                                         if(ArealFromFile.namstr[0] == '\0')
                                            NRAc->namstr = NULL;
                                         else
                                            {
                                            NRAc->namstr = (char *) (malloc(strlen(ArealFromFile.namstr)+ 2));
                                            if(NRAc->namstr != NULL)
                                               strcpy(NRAc->namstr,ArealFromFile.namstr);
                                            }
					 NRAc->ishole = ArealFromFile.ishole;
					 NRAc->firstindex = compositeindex;
					 NRAc->ismulti = 0;
					 NRAc->RB_Tree_Edgelist = NULL;
					 NRAc->area = ArealFromFile.area;
NRAc->perimlength = ArealFromFile.perimlength;
					 NRAc->localID = (double) fo + filedecimal;
					 NRAc->featureid = ArealFromFile.featureid;
					 NRAc->minxvtx = ArealFromFile.minxvtx;
					 NRAc->next = NULL;
					 NRAc->x = (double *) malloc(SzD * ArealFromFile.numverts);
					 NRAc->y = (double *) malloc(SzD * ArealFromFile.numverts);
					 NRAc->z = (double *) malloc(SzD * ArealFromFile.numverts);
					 if((NRAc->x == NULL) || (NRAc->y == NULL) || (NRAc->z == NULL))
					    {
					    printf("allocation memory exhausted during area feature read\n");
					    printf("processing cannot continue\n");
					    exit(-1);
					    }
					 MinElev = MaxElev = ArealFromFile.z[0];
					 for(jj = 0; jj<ArealFromFile.numverts; jj++)
					    {
					    NRAc->x[jj] = ArealFromFile.x[jj];
					    NRAc->y[jj] = ArealFromFile.y[jj];
					    NRAc->z[jj] = ArealFromFile.z[jj];
					    if(ArealFromFile.z[jj] < MinElev)
					       MinElev = ArealFromFile.z[jj];
					    if(ArealFromFile.z[jj] > MaxElev)
					       MaxElev = ArealFromFile.z[jj];
					    }
	   
					 vtxcnt = NRAc->numverts = ArealFromFile.numverts;
					 NRAc->next = NRAroot;
					 NRAroot = NRAc;
					 }
				      }
				   }
				}
			     }
			  }
		       }

                    DHc = DHroot;
                    while(DHc != NULL)
                       {
                       ARc = ARroot;
                       while(ARc != NULL)
                          {
                          if((ARc->ishole <= 0) && (ARc->idn == DHc->dupidn))
                             break;
                          else if((ARc->ishole <= 0) && (ARc->idn == DHc->thisidn))
                             {
                             i = DHc->dupidn;
                             DHc->dupidn = DHc->thisidn;
                             DHc->thisidn = i;
                             break;
                             }
                          ARc = ARc->next;
                          }
                       DHc = DHc->next;
                       }

                    ARc = ARroot;
                    while(ARc != NULL)
                       {
                       if(ARc->ishole > 0)
                          {
                          DHc = DHroot;
                          while(DHc != NULL)
                             {
                             if(ARc->idn == DHc->dupidn)
                                break;
                             DHc = DHc->next;
                             }
                          if(DHc == NULL)
                             {
                             ARn = ARroot;
                             while(ARn != NULL)
                                {
                                if((ARn->ishole < 0) && (ARn->idn == ARc->idn))  /** then the parent of ARc is in the list to be processed - keep ARc ***/
                                   break;
                                ARn = ARn->next;
                                }
                             if(ARn == NULL)
                                {
                                DHc = DHroot;
                                while(DHc != NULL)
                                   {
                                   if(DHc->thisidn == ARc->idn)
                                      {
                                      ARc->idn = DHc->dupidn;
                                      break;
                                      }
                                   DHc = DHc->next;
                                   }
                                }
                             }
                          }
                       ARc = ARc->next;
                       }

                    DHc = DHroot;
                    while(DHc != NULL)
                       {
                       DHp = DHc;
                       DHc = DHc->next;
                       free(DHp);
                       }
                    DHroot = NULL;

		    } /*** done with the area feature objects ***/



	/*** checks for linear objects **/

		 if((linin != NULL) && (abortNow == 0) && ((CheckByConfig[2] > 0) || (CheckByConfig[4] > 0) || (CheckByConfig[14] > 0)))
		    {
		    FreeLongList(&NeighborLinearLongListRoot);
		    NeighborLinearLongListRoot = NULL;
		    for(i=0; i<skiplimit; i++)
		       {
		       NeighborLongLinearSkipList[i].val = -1;
		       NeighborLongLinearSkipList[i].entry = NULL;
		       }

		    if(index1 == 0)
		       index1base = 0;
		    else
		       index1base = index1 - 1;
		    if(index1 == MaxXindex)
		       index1top = index1;
		    else
		       index1top = index1 + 1;
		    if(index2 == 0)
		       index2base = 0;
		    else
		       index2base = index2 - 1;
		    if(index2 == MaxYindex)
		       index2top = index2;
		    else
		       index2top = index2 + 1;

		    filedecimal = ((double) (Lfilenumber + 1)) / 10.0;

		    for(i=index1base; i<=index1top; i++)
		       {
		       for(j=index2base; j<=index2top; j++)
			  {
			  if((i != index1) || (j != index2))
			     {
			     neighborcompositeindex = (i * (MaxYindex + 1)) + j;
			     for(ii=0; ii<LinearTable[neighborcompositeindex].numother; ii++)
				{

				fo = fileoffset * LinearTable[neighborcompositeindex].others[ii].filenumber +
					       LinearTable[neighborcompositeindex].others[ii].fileptr;
				for(jj2 = 0; jj2 < LinearTable[compositeindex].numother; jj2++)
				    {
				    if((LinearTable[compositeindex].others[jj2].filenumber == LinearTable[neighborcompositeindex].others[ii].filenumber) &&
					 (LinearTable[compositeindex].others[jj2].fileptr == LinearTable[neighborcompositeindex].others[ii].fileptr))
				      
				       break;
				    }
				if(jj2 >= LinearTable[compositeindex].numother)
				   InsertOK =  InsertIntoLongList(fo,LinearTable[neighborcompositeindex].others[ii].filenumber,skiplimit,
					  &NeighborLinearLongListRoot,NeighborLongLinearSkipList,&SkipNEntry); 
				else
				   InsertOK = 0;
				if(InsertOK > 0)
				   {
				   if(LinearTable[neighborcompositeindex].others[ii].filenumber != Lfilenumber)
				      {
				      Lfilenumber = LinearTable[neighborcompositeindex].others[ii].filenumber;
				      filedecimal = ((double) (Lfilenumber + 1)) / 10.0;
				      if(LinearFiles[Lfilenumber].isopen == 0)
					 {
					 sprintf(suffix,"%d",Lfilenumber);
					 strcpy(afilein,linearsin);
					 if(Lfilenumber > 0)
					     strcat(afilein,suffix);
					 linin = fopen(afilein,"rb");
					 if(linin == NULL)
					    {
					    printf("3 area feature data input file %s could not be opened for read\n",afilein);
					    exit(-1);

					    }
					 LinearFiles[Lfilenumber].fp = linin;
					 LinearFiles[Lfilenumber].isopen = 1;
					 }
				      else
					 {
					 linin = LinearFiles[Lfilenumber].fp;
					 }
				      }

				   fseek(linin,LinearTable[neighborcompositeindex].others[ii].fileptr,SEEK_SET);
				   vtxcnt = ReadLinearFromFile(linin, multiplier);
	   
				   OKtoUse = 1;
				   if((NGA_TYPE == 0) && (NumLODbands > 0))
				      {
				      jj = CrsWlk[LinearFromFile.Lindex].LODband;
				      if((jj > 0) && (LODindex[jj-1].active < 1))
					 OKtoUse = 0;
				      }
				   }
				if((InsertOK > 0) && (OKtoUse > 0) && (vtxcnt > 0))
				   {
				   if((CheckByStratum[LinearFromFile.stratum] > 0) &&
					 (CheckByDomain[LinearFromFile.domain] > 0))
				      {
				      NRLc = (struct RawLinear *) (malloc(SzRL));
				      if(NRLc == NULL)
					 {
					 printf("allocation memory exhausted during linear data read\n");
					 printf("processing cannot continue\n");
					 exit(-1);
					 }
NRLc->lenstr = NULL;

				      NRLc->length = LinearFromFile.length;
				      NRLc->badform = LinearFromFile.badform;
				      NRLc->featureid = LinearFromFile.featureid;
				      NRLc->numnodes = LinearFromFile.numnodes;
				      NRLc->Lindex = LinearFromFile.Lindex;
				      NRLc->Sindex = LinearFromFile.Sindex;
				      NRLc->localID = (double) LinearTable[neighborcompositeindex].others[ii].fileptr + filedecimal;
				      NRLc->IsMulti = 1;
				      NRLc->firstencounter = 0;
				      NRLc->idn = LinearFromFile.idn;
                                      NRLc->areaattr = LinearFromFile.areaattr;
                                      NRLc->hgtattr = LinearFromFile.hgtattr;
                                      NRLc->zv2attr = LinearFromFile.zv2attr;
                                      NRLc->lenattr = LinearFromFile.lenattr;
                                      NRLc->namattr = LinearFromFile.namattr;
                                      if(LinearFromFile.areastr[0] == '\0')
                                         NRLc->areastr = NULL;
                                      else
                                         {
                                         NRLc->areastr = (char *) (malloc(strlen(LinearFromFile.areastr) + 2));
                                         if(NRLc->areastr != NULL)
                                            strcpy(NRLc->areastr,LinearFromFile.areastr);
                                         }
                                      if(LinearFromFile.hgtstr[0] == '\0')
                                         NRLc->hgtstr = NULL;
                                      else
                                         {
                                         NRLc->hgtstr = (char *) (malloc(strlen(LinearFromFile.hgtstr) + 2));
                                         if(NRLc->hgtstr != NULL)
                                            strcpy(NRLc->hgtstr,LinearFromFile.hgtstr);
                                         }
                                      if(LinearFromFile.zv2str[0] == '\0')
                                         NRLc->zv2str = NULL;
                                      else
                                         {
                                         NRLc->zv2str = (char *) (malloc(strlen(LinearFromFile.zv2str) + 2));
                                         if(NRLc->zv2str != NULL)
                                            strcpy(NRLc->zv2str,LinearFromFile.zv2str);
                                         }
                                      if(LinearFromFile.lenstr[0] == '\0')
                                         NRLc->lenstr = NULL;
                                      else
                                         {
                                         NRLc->lenstr = (char *) (malloc(strlen(LinearFromFile.lenstr) + 2));
                                         if(NRLc->lenstr != NULL)
                                            strcpy(NRLc->lenstr,LinearFromFile.lenstr);
                                         }
                                      if(LinearFromFile.namstr[0] == '\0')
                                         NRLc->namstr = NULL;
                                      else
                                         {
                                         NRLc->namstr = (char *) (malloc(strlen(LinearFromFile.namstr) + 2));
                                         if(NRLc->namstr != NULL)
                                            strcpy(NRLc->namstr,LinearFromFile.namstr);
                                         }
				      NRLc->next = NULL;
				      NRLc->x = (double *) malloc(SzD * LinearFromFile.numnodes);
				      NRLc->y = (double *) malloc(SzD * LinearFromFile.numnodes);
				      NRLc->z = (double *) malloc(SzD * LinearFromFile.numnodes);
				      if((NRLc->x == NULL) || (NRLc->y == NULL) || (NRLc->z == NULL))
					 {
					 printf("allocation memory exhausted during linear data read\n");
					 printf("processing cannot continue\n");
					 exit(-1);
					 }
				      for(jj = 0; jj<LinearFromFile.numnodes; jj++)
					 {
					 NRLc->x[jj] = LinearFromFile.x[jj];
					 NRLc->y[jj] = LinearFromFile.y[jj];
					 NRLc->z[jj] = LinearFromFile.z[jj];
					 }
				      NRLc->next = NRLroot;
				      NRLroot = NRLc;
				      }
				   }
				}
			     k = LinearTable[neighborcompositeindex].numinside;
			     if(k > 0)
				{
				if(LinearTable[neighborcompositeindex].filenumber != Lfilenumber)
				   {
				   Lfilenumber = LinearTable[neighborcompositeindex].filenumber;
				   filedecimal = ((double) (Lfilenumber + 1)) / 10.0;
				   if(LinearFiles[Lfilenumber].isopen == 0)
				      {
				      sprintf(suffix,"%d",Lfilenumber);
				      strcpy(afilein,linearsin);
				      if(Lfilenumber > 0)
					  strcat(afilein,suffix);
				      linin = fopen(afilein,"rb");
				      if(linin == NULL)
					 {
					 printf("3 area feature data input file %s could not be opened for read\n",afilein);
					 exit(-1);
					 }
				      LinearFiles[Lfilenumber].fp = linin;
				      LinearFiles[Lfilenumber].isopen = 1;
				      }
				   else
				      {
				      filedecimal = ((double) (Lfilenumber + 1)) / 10.0;
				      linin = LinearFiles[Lfilenumber].fp;
				      }

				   }
				fseek(linin,LinearTable[neighborcompositeindex].fileptr,SEEK_SET);
				ii = 0;
				while(ii < k)
				   {
				  fo = ftell(linin);
				  vtxcnt =  ReadLinearFromFile(linin, multiplier);
				   ++ii;

				   OKtoUse = 1;
				   if((NGA_TYPE == 0) && (NumLODbands > 0))
				      {
				      jj = CrsWlk[LinearFromFile.Lindex].LODband;
				      if((jj > 0) && (LODindex[jj-1].active < 1))
					 OKtoUse = 0;
				      }

				   if((OKtoUse > 0) && (vtxcnt > 0))
				      {
				      if((CheckByStratum[LinearFromFile.stratum] > 0) &&
					    (CheckByDomain[LinearFromFile.domain] > 0))
					 {
					 NRLc = (struct RawLinear *) (malloc(SzRL));
					 if(NRLc == NULL)
					    {
					    printf("allocation memory exhausted during linear data read\n");
					    printf("processing cannot continue\n");
					    exit(-1);
					    }
NRLc->lenstr = NULL;

					 NRLc->length = LinearFromFile.length;
					 NRLc->badform = LinearFromFile.badform;
					 NRLc->featureid = LinearFromFile.featureid;
					 NRLc->numnodes = LinearFromFile.numnodes;
					 NRLc->Lindex = LinearFromFile.Lindex;
					 NRLc->Sindex = LinearFromFile.Sindex;
					 NRLc->localID = (double) fo + filedecimal;
					 NRLc->IsMulti = 0;
					 NRLc->firstencounter = 0;
					 NRLc->idn = LinearFromFile.idn;
                                         NRLc->areaattr = LinearFromFile.areaattr;
                                         NRLc->hgtattr = LinearFromFile.hgtattr;
                                         NRLc->zv2attr = LinearFromFile.zv2attr;
                                         NRLc->lenattr = LinearFromFile.lenattr;
                                         NRLc->namattr = LinearFromFile.namattr;
                                         if(LinearFromFile.areastr[0] == '\0')
                                            NRLc->areastr = NULL;
                                         else
                                            {
                                            NRLc->areastr = (char *) (malloc(strlen(LinearFromFile.areastr) + 2));
                                            if(NRLc->areastr != NULL)
                                               strcpy(NRLc->areastr,LinearFromFile.areastr);
                                            }
                                         if(LinearFromFile.hgtstr[0] == '\0')
                                            NRLc->hgtstr = NULL;
                                         else
                                            {
                                            NRLc->hgtstr = (char *) (malloc(strlen(LinearFromFile.hgtstr) + 2));
                                            if(NRLc->hgtstr != NULL)
                                               strcpy(NRLc->hgtstr,LinearFromFile.hgtstr);
                                            }
                                         if(LinearFromFile.zv2str[0] == '\0')
                                            NRLc->zv2str = NULL;
                                         else
                                            {
                                            NRLc->zv2str = (char *) (malloc(strlen(LinearFromFile.zv2str) + 2));
                                            if(NRLc->zv2str != NULL)
                                               strcpy(NRLc->zv2str,LinearFromFile.zv2str);
                                            }
                                         if(LinearFromFile.lenstr[0] == '\0')
                                            NRLc->lenstr = NULL;
                                         else
                                            {
                                            NRLc->lenstr = (char *) (malloc(strlen(LinearFromFile.lenstr) + 2));
                                            if(NRLc->lenstr != NULL)
                                               strcpy(NRLc->lenstr,LinearFromFile.lenstr);
                                            }
                                         if(LinearFromFile.namstr[0] == '\0')
                                            NRLc->namstr = NULL;
                                         else
                                            {
                                            NRLc->namstr = (char *) (malloc(strlen(LinearFromFile.namstr) + 2));
                                            if(NRLc->namstr != NULL)
                                               strcpy(NRLc->namstr,LinearFromFile.namstr);
                                            }
					 /**NRLc->width = LinearFromFile.width;
					 NRLc->height = LinearFromFile.height;**/
					 NRLc->next = NULL;
					 NRLc->x = (double *) malloc(SzD * LinearFromFile.numnodes);
					 NRLc->y = (double *) malloc(SzD * LinearFromFile.numnodes);
					 NRLc->z = (double *) malloc(SzD * LinearFromFile.numnodes);
					 if((NRLc->x == NULL) || (NRLc->y == NULL) || (NRLc->z == NULL))
					    {
					    printf("allocation memory exhausted during linear data read\n");
					    printf("processing cannot continue\n");
					    exit(-1);
					    }
					 for(jj = 0; jj<LinearFromFile.numnodes; jj++)
					    {
					    NRLc->x[jj] = LinearFromFile.x[jj];
					    NRLc->y[jj] = LinearFromFile.y[jj];
					    NRLc->z[jj] = LinearFromFile.z[jj];
					    }
					 NRLc->next = NRLroot;
					 NRLroot = NRLc;
					 }
				      }
				   }
				}
			     }
			  }
		       }
		    

		    filedecimal = ((double) (Lfilenumber + 1)) / 10.0;
		    for(i=0; i<LinearTable[compositeindex].numother; i++)
		       {
		       fo = fileoffset * LinearTable[compositeindex].others[i].filenumber + LinearTable[compositeindex].others[i].fileptr;
		       InsertOK = InsertIntoLongList(fo,LinearTable[compositeindex].others[i].filenumber,skiplimit,
					  &LinearLongListRoot,LongLinearSkipList,&SkipEntry); 
		       if(LinearTable[compositeindex].others[i].filenumber != Lfilenumber)
			  {
			  Lfilenumber = LinearTable[compositeindex].others[i].filenumber;
			  filedecimal = ((double) (Lfilenumber + 1)) / 10.0;
			  if(LinearFiles[Lfilenumber].isopen == 0)
			      {
			      sprintf(suffix,"%d",Lfilenumber);
			      strcpy(afilein,linearsin);
			      if(Lfilenumber > 0)
				  strcat(afilein,suffix);
			      linin = fopen(afilein,"rb");
			      if(linin == NULL)
				 {
				 printf("3 area feature data input file %s could not be opened for read\n",afilein);
				 exit(-1);
				 }
			      LinearFiles[Lfilenumber].fp = linin;
			      LinearFiles[Lfilenumber].isopen = 1;
			      }
			   else
			      {
			      linin = LinearFiles[Lfilenumber].fp;
			      }

			  }
		       fseek(linin,LinearTable[compositeindex].others[i].fileptr,SEEK_SET);
		       j = ReadLinearFromFile(linin, multiplier);

		       OKtoUse = 1;
		       if((NGA_TYPE == 0) && (NumLODbands > 0))
			  {
			  jj = CrsWlk[LinearFromFile.Lindex].LODband;
			  if((jj > 0) && (LODindex[jj-1].active < 1))
			     OKtoUse = 0;
			  }

		       if((OKtoUse > 0) && (j > 0))
			  {

			  if((ErrorLookup[L_UNM_A].anyactive > 0) || ((CheckByStratum[LinearFromFile.stratum] > 0) &&
				   (CheckByDomain[LinearFromFile.domain] > 0)))
			     {
			     if(InsertOK)
				{
                                if((CombinedCheckApplies(LinearFromFile.idn,-1,-1,LinearFromFile.Lindex,LinearFromFile.Sindex,
                                                           LinearFromFile.config,LinearFromFile.stratum,LinearFromFile.domain,
                                                           &part1,&part2,&part3)) && ((part1 > 0) || (part2 > 0) || (part3 > 0)))
                                   {
				   NumObjects[LinearFromFile.config] += 1.0;
                                   mpoc = MultiLineRoot;
                                   while(mpoc != NULL)
                                      {
                                      if(mpoc->featureid == LinearFromFile.idn)
                                         {
                                         mpoc->counted += 1;
                                         break;
                                         }
                                      mpoc = mpoc->next;
                                      }

				   if(LinearFromFile.numnodes > 0)
				      NumLineSegments += (double) (LinearFromFile.numnodes - 1);
                                   }
				}
			     RLdup = CheckLinearDuplication(LinearFromFile,RLroot,&IsDup);
			     if(IsDup < UseDupThreshold)
				{
				RLc = (struct RawLinear *) (malloc(SzRL));
				if(RLc == NULL)
				   {
				   printf("allocation memory exhausted during linear data read\n");
				   printf("processing cannot continue\n");
				   exit(-1);
				   }
RLc->lenstr = NULL;

				RLc->length = LinearFromFile.length;
				RLc->badform = LinearFromFile.badform;
				RLc->featureid = LinearFromFile.featureid;
				RLc->numnodes = LinearFromFile.numnodes;
				RLc->Lindex = LinearFromFile.Lindex;
				RLc->Sindex = LinearFromFile.Sindex;
				tempID = RLc->localID = (double) LinearTable[compositeindex].others[i].fileptr + filedecimal;
				RLc->IsMulti = 1;
				if(InsertOK > 0)
				   RLc->firstencounter = 1;
				else
				   RLc->firstencounter = 0;
				RLc->idn = LinearFromFile.idn;
                                RLc->areaattr = LinearFromFile.areaattr;
                                RLc->hgtattr = LinearFromFile.hgtattr;
                                RLc->zv2attr = LinearFromFile.zv2attr;
                                RLc->lenattr = LinearFromFile.lenattr;
                                RLc->namattr = LinearFromFile.namattr;
                                if(LinearFromFile.areastr[0] == '\0')
                                   RLc->areastr = NULL;
                                else
                                   {
                                   RLc->areastr = (char *) (malloc(strlen(LinearFromFile.areastr) + 2));
                                   if(RLc->areastr != NULL)
                                      strcpy(RLc->areastr,LinearFromFile.areastr);
                                   }
                                if(LinearFromFile.hgtstr[0] == '\0')
                                   RLc->hgtstr = NULL;
                                else
                                   {
                                   RLc->hgtstr = (char *) (malloc(strlen(LinearFromFile.hgtstr) + 2));
                                   if(RLc->hgtstr != NULL)
                                      strcpy(RLc->hgtstr,LinearFromFile.hgtstr);
                                   }
                                if(LinearFromFile.zv2str[0] == '\0')
                                   RLc->zv2str = NULL;
                                else
                                   {
                                   RLc->zv2str = (char *) (malloc(strlen(LinearFromFile.zv2str) + 2));
                                   if(RLc->zv2str != NULL)
                                      strcpy(RLc->zv2str,LinearFromFile.zv2str);
                                   }
                                if(LinearFromFile.lenstr[0] == '\0')
                                   RLc->lenstr = NULL;
                                else
                                   {
                                   RLc->lenstr = (char *) (malloc(strlen(LinearFromFile.lenstr) + 2));
                                   if(RLc->lenstr != NULL)
                                      strcpy(RLc->lenstr,LinearFromFile.lenstr);
                                   }
                                if(LinearFromFile.namstr[0] == '\0')
                                   RLc->namstr = NULL;
                                else
                                   {
                                   RLc->namstr = (char *) (malloc(strlen(LinearFromFile.namstr) + 2));
                                   if(RLc->namstr != NULL)
                                      strcpy(RLc->namstr,LinearFromFile.namstr);
                                   }
				/**RLc->width = LinearFromFile.width;
				RLc->height = LinearFromFile.height;**/
				RLc->next = NULL;
				RLc->x = (double *) malloc(SzD * LinearFromFile.numnodes);
				RLc->y = (double *) malloc(SzD * LinearFromFile.numnodes);
				RLc->z = (double *) malloc(SzD * LinearFromFile.numnodes);
				if((RLc->x == NULL) || (RLc->y == NULL) || (RLc->z == NULL))
				   {
				   printf("allocation memory exhausted during linear data read\n");
				   printf("processing cannot continue\n");
				   exit(-1);
				   }
				for(jj = 0; jj<LinearFromFile.numnodes; jj++)
				   {
				   RLc->x[jj] = LinearFromFile.x[jj];
				   RLc->y[jj] = LinearFromFile.y[jj];
				   RLc->z[jj] = LinearFromFile.z[jj];
				   }
				RLc->next = RLroot;
				RLroot = RLc;
				}
			     else
				{
				tempID = (double) LinearTable[compositeindex].others[i].fileptr + filedecimal;
				}
			     for(checkinstance = 0; checkinstance < TtlActiveChecks; checkinstance++)
				{
                                if(ID_O_count > 0)
                                   {
                                   part1 = 0;
                                   if((InsertOK > 0) && 
                                    ((IsDup == 2) || (IsDup == 3) || (IsDup == 5)) && (LinearFromFile.idn != RLdup->idn) &&
                                    (CombinedCheckApplies(LinearFromFile.idn,checkinstance,ANY_SAMEID,LinearFromFile.Lindex,LinearFromFile.Sindex,
                                                      LinearFromFile.config,LinearFromFile.stratum,LinearFromFile.domain,
                                                      &part1,&part2,&part3))  && (part1 > 0) &&
                                            (CombinedCheckApplies(RLdup->idn,checkinstance,ANY_SAMEID,RLdup->Lindex,RLdup->Sindex,
                                             SCCtable[RLdup->Sindex].C, SCCtable[RLdup->Sindex].S, SCCtable[RLdup->Sindex].D,
                                                           &part1,&part2,&part3)) && (part2 > 0))
                                      {
                                      FwriteTwoObjects(ANY_SAMEID,Make_Correct(ANY_SAMEID,checkinstance),
                                                    LinearFromFile.idn,G_LINE,LinearFromFile.Lindex,tempID,LinearFromFile.Sindex,-1.0,-1.0,2,
                                                    LinearFromFile.x, LinearFromFile.y,LinearFromFile.z,
                                                    RLdup->idn,G_LINE,RLdup->Lindex,RLdup->localID,RLdup->Sindex,-1.0,-1.0,2,
                                                    RLdup->x, RLdup->y,RLdup->z);
                                      }
                                   else if((InsertOK > 0) && (IsDup != 4) &&
                                          (CombinedCheckApplies(LinearFromFile.idn,checkinstance,ANY_SAMEID,
                                                      LinearFromFile.Lindex,LinearFromFile.Sindex,
                                                      LinearFromFile.config,LinearFromFile.stratum,LinearFromFile.domain,
                                                      &part1,&part2,&part3)) &&
                                           ((part1 > 0) || (part2 > 0)))
                                      {
                                      GetAppropIDnumber(LinearFromFile.idn, &tempstring[0]);
                                      jj = GetUUIDindex(tempstring);
                                      if(jj >= 0)
                                         {
                                         olidp = ID_O[jj].inst;
                                         while(olidp != NULL)
                                            {
                                            if((LinearFromFile.idn != olidp->idn) && (olidp->checknumb == checkinstance))
                                               {
                                               if((part1 > 0) && (olidp->part > 1))
                                                  {
                                                  FwriteTwoObjects(ANY_SAMEID,Make_Correct(ANY_SAMEID,checkinstance),
                                                        LinearFromFile.idn,G_LINE,LinearFromFile.Lindex,tempID,LinearFromFile.Sindex,-1.0, -1.0,2,
                                                        LinearFromFile.x, LinearFromFile.y,LinearFromFile.z,
                                                        olidp->idn,olidp->gform,olidp->Lindex,olidp->lid,olidp->Sindex,-1.0,-1.0,olidp->numvert,
                                                        olidp->x, olidp->y,olidp->z);
                                                  break;
                                                  }
                                               else if((part2 > 0) && ((olidp->part == 1) || (olidp->part == 3)))
                                                  {
                                                  FwriteTwoObjects(ANY_SAMEID,Make_Correct(ANY_SAMEID,checkinstance),
                                                        LinearFromFile.idn,G_LINE,LinearFromFile.Lindex,tempID,LinearFromFile.Sindex,-1.0,-1.0,2,
                                                        LinearFromFile.x, LinearFromFile.y,LinearFromFile.z,
                                                        olidp->idn,olidp->gform,olidp->Lindex,olidp->lid,olidp->Sindex,-1.0,-1.0,olidp->numvert,
                                                        olidp->x, olidp->y,olidp->z);
                                                  break;
                                                  }
                                               }
                                            olidp = olidp->next;
                                            }
                                         if(olidp == NULL)
                                            {
                                            olidc = (struct OverlapIDinstance *) (malloc(sizeof(struct OverlapIDinstance)));
                                            if(olidc == NULL)
                                               {
                                               printf("memory exhausted during unique identifier processing - results will be incomplete\n");
                                               }
                                            else
                                               {
                                               olidc->checknumb = checkinstance;
                                               olidc->idn = LinearFromFile.idn;
                                               olidc->lid = tempID;
                                               olidc->Lindex = LinearFromFile.Lindex;
                                               olidc->Sindex = LinearFromFile.Sindex;
                                               olidc->gform = G_LINE;
                                               if((part1 > 0) && (part2 > 0))
                                                  olidc->part = 3;
                                               else if(part1 > 0)
                                                  olidc->part = 1;
                                               else
                                                  olidc->part = 2;
                                               olidc->numvert = 2;
                                               olidc->x[0] = LinearFromFile.x[0];
                                               olidc->y[0] = LinearFromFile.y[0];
                                               olidc->z[0] = LinearFromFile.z[0];
                                               olidc->x[1] = LinearFromFile.x[1];
                                               olidc->y[1] = LinearFromFile.y[1];
                                               olidc->z[1] = LinearFromFile.z[1];
                                               olidc->next = ID_O[jj].inst;
                                               ID_O[jj].inst = olidc;
                                               }
                                            }
                                         }
                                      }
                                   }


				  if(
				     (IsDup == 1)   && 
				     (InsertOK > 0) &&
				     (CombinedCheckApplies(LinearFromFile.idn,checkinstance,G_DUPS,LinearFromFile.Lindex,LinearFromFile.Sindex,
							   LinearFromFile.config,LinearFromFile.stratum,LinearFromFile.domain,
							   &part1,&part2,&part3)) && (part1 > 0) &&
				      (CombinedCheckApplies(RLdup->idn,checkinstance,G_DUPS,RLdup->Lindex,RLdup->Sindex,
				       SCCtable[RLdup->Sindex].C, SCCtable[RLdup->Sindex].S, SCCtable[RLdup->Sindex].D,
							   &part1,&part2,&part3)) && (part2 > 0)
				     )
				    {
				      FwriteTwoObjects(G_DUPS,Make_Correct(G_DUPS,checkinstance), 
						       LinearFromFile.idn,G_LINE,LinearFromFile.Lindex,tempID,LinearFromFile.Sindex,-1.0,-1.0,
						       LinearFromFile.numnodes,LinearFromFile.x,
						       LinearFromFile.y,LinearFromFile.z,
						       RLdup->idn,G_LINE,RLdup->Lindex,RLdup->localID,RLdup->Sindex,-1.0,-1.0,RLdup->numnodes,
						       RLdup->x, RLdup->y,RLdup->z);
				    }



				  if(
				     (IsDup == 4)   && 
				     (InsertOK > 0) &&
				     (CombinedCheckApplies(LinearFromFile.idn,checkinstance,C_DUPS,LinearFromFile.Lindex,LinearFromFile.Sindex,
							   LinearFromFile.config,LinearFromFile.stratum,LinearFromFile.domain,
							   &part1,&part2,&part3)) && (part1 > 0) &&
				      (CombinedCheckApplies(RLdup->idn,checkinstance,C_DUPS,RLdup->Lindex,RLdup->Sindex,
				       SCCtable[RLdup->Sindex].C, SCCtable[RLdup->Sindex].S, SCCtable[RLdup->Sindex].D,
							   &part1,&part2,&part3)) && (part1 > 0)
				     )
				    {
				      FwriteTwoObjects(C_DUPS, Make_Correct(C_DUPS,checkinstance),
						       LinearFromFile.idn,G_LINE,LinearFromFile.Lindex,tempID,LinearFromFile.Sindex,-1.0,-1.0,
						       LinearFromFile.numnodes,LinearFromFile.x,
						       LinearFromFile.y,LinearFromFile.z,
						       RLdup->idn,G_LINE,RLdup->Lindex,RLdup->localID,RLdup->Sindex,-1.0,-1.0,RLdup->numnodes,
						       RLdup->x, RLdup->y,RLdup->z);
				    }


				  if(NGA_TYPE == 1)
				     {
				     if((IsDup == 2) && (InsertOK > 0) &&
					(CombinedCheckApplies(LinearFromFile.idn,checkinstance,SAMEID,LinearFromFile.Lindex,LinearFromFile.Sindex,
							   LinearFromFile.config,LinearFromFile.stratum,LinearFromFile.domain,
							   &part1,&part2,&part3)) && (part1 > 0) &&
					 (CombinedCheckApplies(RLdup->idn,checkinstance,SAMEID,RLdup->Lindex,RLdup->Sindex,
					  SCCtable[RLdup->Sindex].C, SCCtable[RLdup->Sindex].S, SCCtable[RLdup->Sindex].D,
							   &part1,&part2,&part3)) && (part2 > 0))
					{
                                        mpoc = MultiLineRoot;
                                        while(mpoc != NULL)
                                           {
                                           if(mpoc->featureid == LinearFromFile.idn) 
                                              break;
                                           mpoc = mpoc->next;
                                           }
                                        if(mpoc == NULL)
                                           {
					   FwriteTwoObjects(SAMEID,Make_Correct(SAMEID,checkinstance),
						       LinearFromFile.idn,G_LINE,LinearFromFile.Lindex,tempID,LinearFromFile.Sindex,-1.0,-1.0,
						       LinearFromFile.numnodes,LinearFromFile.x, LinearFromFile.y,LinearFromFile.z,
						       RLdup->idn,G_LINE,RLdup->Lindex,RLdup->localID,RLdup->Sindex,-1.0,-1.0,RLdup->numnodes,
						       RLdup->x, RLdup->y,RLdup->z);
                                           }
					}

				     if((IsDup == 3) && (InsertOK > 0) &&
					(CombinedCheckApplies(LinearFromFile.idn,checkinstance,SAMEID_GDUP,LinearFromFile.Lindex,LinearFromFile.Sindex,
							   LinearFromFile.config,LinearFromFile.stratum,LinearFromFile.domain,
							   &part1,&part2,&part3)) && (part1 > 0) &&
					 (CombinedCheckApplies(RLdup->idn,checkinstance,SAMEID_GDUP,RLdup->Lindex,RLdup->Sindex,
					  SCCtable[RLdup->Sindex].C, SCCtable[RLdup->Sindex].S, SCCtable[RLdup->Sindex].D,
							   &part1,&part2,&part3)) && (part2 > 0))
					{
					FwriteTwoObjects(SAMEID_GDUP,Make_Correct(SAMEID_GDUP,checkinstance),
						       LinearFromFile.idn,G_LINE,LinearFromFile.Lindex,tempID,LinearFromFile.Sindex,-1.0,-1.0,
						       LinearFromFile.numnodes,LinearFromFile.x, LinearFromFile.y,LinearFromFile.z,
						       RLdup->idn,G_LINE,RLdup->Lindex,RLdup->localID,RLdup->Sindex,-1.0,-1.0,RLdup->numnodes,
						       RLdup->x, RLdup->y,RLdup->z);
					}

				     if((IsDup == 5) && (InsertOK > 0) &&
					(CombinedCheckApplies(LinearFromFile.idn,checkinstance,SAMEID_CDUP,LinearFromFile.Lindex,LinearFromFile.Sindex,
							   LinearFromFile.config,LinearFromFile.stratum,LinearFromFile.domain,
							   &part1,&part2,&part3)) && (part1 > 0) &&
					 (CombinedCheckApplies(RLdup->idn,checkinstance,SAMEID_CDUP,RLdup->Lindex,RLdup->Sindex,
					  SCCtable[RLdup->Sindex].C, SCCtable[RLdup->Sindex].S, SCCtable[RLdup->Sindex].D,
							   &part1,&part2,&part3)) && (part1 > 0))
					{
					FwriteTwoObjects(SAMEID_CDUP, Make_Correct(SAMEID_CDUP,checkinstance),
						       LinearFromFile.idn,G_LINE,LinearFromFile.Lindex,tempID,LinearFromFile.Sindex,-1.0,-1.0,
						       LinearFromFile.numnodes,LinearFromFile.x, LinearFromFile.y,LinearFromFile.z,
						       RLdup->idn,G_LINE,RLdup->Lindex,RLdup->localID,RLdup->Sindex,-1.0,-1.0,RLdup->numnodes,
						       RLdup->x, RLdup->y,RLdup->z);
/**********/
					}
				     }


				  if((IsDup < UseDupThreshold) && (InsertOK))
				    {
				      if((CombinedCheckApplies(LinearFromFile.idn,checkinstance,V_DUPS,LinearFromFile.Lindex,LinearFromFile.Sindex,
							      LinearFromFile.config,LinearFromFile.stratum,LinearFromFile.domain,
							      &part1,&part2,&part3)) && (part1 > 0))
					{
					 dv = DuplicateVerticesExist(LinearFromFile.numnodes,
									 LinearFromFile.x,LinearFromFile.y,
									 LinearFromFile.z);

					  if(SensitivityCheck(GT, V_DUPS, checkinstance, (double) dv) > 0)
					    {
					      /*** found a linear with duplicate vertices **/
					       for(jj=1; jj<LinearFromFile.numnodes; jj++)
						 {
						 if((LinearFromFile.x[jj-1] == LinearFromFile.x[jj]) &&
						     (LinearFromFile.y[jj-1] == LinearFromFile.y[jj]) &&
						     (LinearFromFile.z[jj-1] == LinearFromFile.z[jj]))
						    {
                                                    FwriteObject(V_DUPS,Make_Correct(V_DUPS,checkinstance),RLc->Lindex,
                                                           LinearFromFile.Sindex,G_LINE,RLc->localID,LinearFromFile.idn, -1.0, -1.0,
                                                            &LinearFromFile.x[jj],&LinearFromFile.y[jj],&LinearFromFile.z[jj],1, 1);
						    }
						 }
					    }
					}



				      if((CombinedCheckApplies(LinearFromFile.idn,checkinstance,ATTRERR,LinearFromFile.Lindex,LinearFromFile.Sindex,
							      LinearFromFile.config,LinearFromFile.stratum,LinearFromFile.domain,
							      &part1,&part2,&part3)) && (part1 > 0))
					{
					  if(CrsWlk[LinearFromFile.Lindex].AttrErr >= 0)
					    {
					      FwriteObjectAndMessage(ATTRERR,Make_Correct(ATTRERR,checkinstance), 
								     LinearFromFile.idn, G_LINE,RLc->Lindex,RLc->localID,
								     LinearFromFile.Sindex,-1.0,-1.0,LinearFromFile.x,
								     LinearFromFile.y,LinearFromFile.z,LinearFromFile.numnodes,
								     AttrErr[CrsWlk[LinearFromFile.Lindex].AttrErr].description);
					    }
					}



				      if(CombinedCheckApplies(LinearFromFile.idn,checkinstance,LOOPS,LinearFromFile.Lindex,LinearFromFile.Sindex,
							      LinearFromFile.config,LinearFromFile.stratum,LinearFromFile.domain,
							      &part1,&part2,&part3))
					{
					if((part1 > 0) && (LinearFromFile.numnodes > 2)) /*** &&(LinearFromFile.numnodes <maxverts)) ***/
					   {
					   kkend = LinearFromFile.numnodes-1;
					   while((kkend > 0) &&
						  (LinearFromFile.x[kkend-1] == LinearFromFile.x[kkend]) &&
						    (LinearFromFile.y[kkend-1] == LinearFromFile.y[kkend]))
					      {
					      --kkend;
					      }

					   for(jj=1; jj<= kkend; jj++)
					      {
					      kkstart = jj + 1;
					      while((kkstart<= kkend) &&
						     (LinearFromFile.x[kkstart] == LinearFromFile.x[jj]) &&
							(LinearFromFile.y[kkstart] == LinearFromFile.y[jj]))
						 {
						 ++kkstart;
						 }

					      for(kk=kkstart; kk<= kkend; kk++)
						 {
						 OKtoCheck = 1;
						 if((jj == 1) && (kk == kkend) && (LinearFromFile.x[0] == LinearFromFile.x[kk]) &&
						      (LinearFromFile.y[0] == LinearFromFile.y[kk]))
						    {
						    OKtoCheck = 0;
						    }
                                                 else if((LinearFromFile.x[0] == LinearFromFile.x[kk]) &&
                                                      (LinearFromFile.y[0] == LinearFromFile.y[kk]))
                                                    {
                                                    OKtoCheck = 0;
                                                    }
                                                 else if(/***/(kk != kkend) &&/***/ (LinearFromFile.x[kkend] == LinearFromFile.x[kk]) &&
                                                      (LinearFromFile.y[kkend] == LinearFromFile.y[kk]))
                                                    {
                                                    OKtoCheck = 0;
                                                    }

						 if(OKtoCheck > 0)
						    {
						    if(kk == kkstart)
						       {
						       if((LinearFromFile.x[kk] != LinearFromFile.x[jj]) ||
							    (LinearFromFile.y[kk] != LinearFromFile.y[jj]))
							  {
							  if(PointOnLineSegment(LinearFromFile.x[kk],LinearFromFile.y[kk],
							       LinearFromFile.x[jj-1],LinearFromFile.y[jj-1],
								 LinearFromFile.x[jj],LinearFromFile.y[jj],0.000001) > 0)
							     {
                                                             kkk = jj + 1;
                                                             if(kkk == kk)  /*** found the point to be on immediately preceeding line segment ***/
                                                                {
                                                                kkk = jj -1;
                                                                if(StrictlyBetween(LinearFromFile.x[kk],LinearFromFile.y[kk],
                                                                       LinearFromFile.x[kkk],LinearFromFile.y[kkk],LinearFromFile.x[jj],LinearFromFile.y[jj]) > 0)
                                                                   {
                                                                   kkk = AddToPointAndIDlist(LinearFromFile.x[kk],LinearFromFile.y[kk],LinearFromFile.idn);
                                                                   }
                                                                else
                                                                   {
                                                                   kkk = -1;

                                                                   }
                                                                }
                                                             else
							        kkk = AddToPointAndIDlist(LinearFromFile.x[kk],LinearFromFile.y[kk],LinearFromFile.idn);
							     if(kkk > 0)
								{
                                                                if((IsSentinelZvalue(LinearFromFile.z[kk],1) == 0) &&
                                                                    (IsSentinelZvalue(LinearFromFile.z[jj],1) == 0) &&
                                                                       (IsSentinelZvalue(LinearFromFile.z[jj-1],1) == 0))
                                                                   {
                                                                   zint = InterpLinearElev(LinearFromFile.x[jj-1],LinearFromFile.y[jj-1],
                                                                        LinearFromFile.z[jj-1],
                                                                        LinearFromFile.x[jj],LinearFromFile.y[jj],LinearFromFile.z[jj],
                                                                         LinearFromFile.x[kk],LinearFromFile.y[kk]);
                                                                   if(zint > LinearFromFile.z[kk])
                                                                      PD2 = zint - LinearFromFile.z[kk];
                                                                   else
                                                                      PD2 = LinearFromFile.z[kk] - zint;
                                                                   }
                                                                else
                                                                   PD2 = 0;
                                                                if(PD2 < 0.1)
                                                                   {
								   FwritePointAndObject(LOOPS,Make_Correct(LOOPS,checkinstance),
								      LinearFromFile.x[kk],LinearFromFile.y[kk],LinearFromFile.z[kk],LinearFromFile.idn,
								      LinearFromFile.Sindex,G_LINE,LinearFromFile.Lindex,RLc->localID,
								      LinearFromFile.idn,10.0,0.0,
								      &LinearFromFile.x[kk], &LinearFromFile.y[kk],&LinearFromFile.z[kk],2);
                                                                   }
								}
							     }
							  }
						       }
						    else 
						       {
						       if(LineSegmentsIntersect(LinearFromFile.x[kk-1],LinearFromFile.y[kk-1],
									     LinearFromFile.x[kk],LinearFromFile.y[kk],
									  LinearFromFile.x[jj-1],LinearFromFile.y[jj-1],
									     LinearFromFile.x[jj],LinearFromFile.y[jj], &xint, &yint) > 0)
							  {
                                                          if((NearlyEqual(xint,LinearFromFile.x[kkend]) == 0) || 
                                                                 (NearlyEqual(yint,LinearFromFile.y[kkend]) == 0))
                                                             {
                                                             if((NearlyEqual(xint,LinearFromFile.x[0]) == 0) ||
                                                                 (NearlyEqual(yint,LinearFromFile.y[0]) == 0))
                                                             /**if((xint != LinearFromFile.x[0]) || (yint != LinearFromFile.y[0]))**/
                                                                {
							        kkk = AddToPointAndIDlist(xint,yint,LinearFromFile.idn);
							        if(kkk > 0)
							           {
	      
							           zint = InterpLinearElev(LinearFromFile.x[kk-1],LinearFromFile.y[kk-1],LinearFromFile.z[kk-1],
								        LinearFromFile.x[kk],LinearFromFile.y[kk],LinearFromFile.z[kk],xint,yint);
                                                                   if((IsSentinelZvalue(LinearFromFile.z[jj],1) == 0) &&
                                                                       (IsSentinelZvalue(LinearFromFile.z[jj-1],1) == 0))
                                                                     {
                                                                     PD2 = InterpLinearElev(LinearFromFile.x[jj-1],LinearFromFile.y[jj-1],
                                                                         LinearFromFile.z[jj-1],
                                                                        LinearFromFile.x[jj],LinearFromFile.y[jj],LinearFromFile.z[jj],xint,yint);
                                                                   
                                                                      if(zint > PD2)
                                                                         PD2 = zint - PD2;
                                                                      else
                                                                         PD2 = PD2 - zint;
                                                                      }
                                                                   else
                                                                      PD2 = 0;
                                                                   if(PD2 < 0.1)
                                                                      {
							              FwritePointAndObject(LOOPS,Make_Correct(LOOPS,checkinstance),
								         xint,yint,zint,LinearFromFile.idn,
								         LinearFromFile.Sindex,G_LINE,LinearFromFile.Lindex,RLc->localID,
								             LinearFromFile.idn,10.0,0.0,
								         &LinearFromFile.x[kk-1], &LinearFromFile.y[kk-1],
                                                                          &LinearFromFile.z[kk-1],2);
                                                                      }
                                                                   }
                                                                }
							     }
							  }
						       }
						    }
						 }
					      } /*** end for jj ***/
					   }
					}

				      if(CombinedCheckApplies(LinearFromFile.idn,checkinstance,MULTIPARTL,LinearFromFile.Lindex,LinearFromFile.Sindex,
							      LinearFromFile.config,LinearFromFile.stratum,LinearFromFile.domain,
							      &part1,&part2,&part3) && (part1 > 0))
					{
					mpoc = MultiLineRoot;
					kkk = 0;
					while(mpoc != NULL)
					   {
					   if((mpoc->featureid == LinearFromFile.idn) && (mpoc->used == 0))
					      ++kkk;
					   mpoc = mpoc->next;
					   }
					if(SensitivityCheck(GT, MULTIPARTL, checkinstance, (double) kkk) > 0)
					   {
					   mpoc = MultiLineRoot;
					   while(mpoc != NULL)
					      {
					      if(mpoc->featureid == LinearFromFile.idn)
						 {
						 mpoc->used = 1;
                                                 FwriteObjectAndMagnitude(MULTIPARTL,Make_Correct(MULTIPARTL,checkinstance),
                                                                     LinearFromFile.idn,
                                                                     LinearFromFile.Sindex,G_LINE,RLc->Lindex,RLc->localID,-1.0,-1.0,(double) kkk,
                                                                     mpoc->x, mpoc->y, mpoc->z, mpoc->numverts, 1);
						 }
					      mpoc = mpoc->next;
					      }
					   }
					
					}


				      if(CombinedCheckApplies(LinearFromFile.idn,checkinstance,ENDPTINT,LinearFromFile.Lindex,LinearFromFile.Sindex,
							      LinearFromFile.config,LinearFromFile.stratum,LinearFromFile.domain,
							      &part1,&part2,&part3))
					{
					if((part1 > 0) && (LinearFromFile.numnodes > 2)) /***** &&(LinearFromFile.numnodes <maxverts)) ***/
					   {
					   jj = LinearFromFile.numnodes - 1;
					   if((LinearFromFile.x[0] == LinearFromFile.x[jj]) && (LinearFromFile.y[0] == LinearFromFile.y[jj]) &&
						       (LinearFromFile.z[0] == LinearFromFile.z[jj]))
					      {
					      FwritePointAndObject(ENDPTINT,Make_Correct(ENDPTINT,checkinstance),
						 LinearFromFile.x[0],LinearFromFile.y[0],LinearFromFile.z[0],LinearFromFile.idn,
						 LinearFromFile.Sindex,G_LINE,LinearFromFile.Lindex,RLc->localID,
								    LinearFromFile.idn,10.0,0.0,
						 &LinearFromFile.x[0], &LinearFromFile.y[0],&LinearFromFile.z[0],2);
					      }
					   }
					}




                                      if(CombinedCheckApplies(LinearFromFile.idn,checkinstance,LONGFEAT,LinearFromFile.Lindex,LinearFromFile.Sindex,
                                                              LinearFromFile.config,LinearFromFile.stratum,LinearFromFile.domain,
                                                              &part1,&part2,&part3))
                                        {
                                          if((part1 > 0) && (LinearFromFile.numnodes > 1))
                                             {
                                             segmentlength = 0;
                                             for(jj=1; jj<LinearFromFile.numnodes; jj++)
                                                {
                                                segmentlength += Distance3D(LinearFromFile.x[jj-1],LinearFromFile.y[jj-1],LinearFromFile.z[jj-1],
                                                                           LinearFromFile.x[jj],LinearFromFile.y[jj],LinearFromFile.z[jj]);
                                                }
                                             if(SensitivityCheck(GT, LONGFEAT, checkinstance, segmentlength) > 0)
                                                {
                                                FwriteObjectAndMagnitude(LONGFEAT,Make_Correct(LONGFEAT,checkinstance),
                                                                  LinearFromFile.idn,
                                                                  LinearFromFile.Sindex,G_LINE,RLc->Lindex,RLc->localID,-1.0,-1.0,segmentlength,
                                                                  LinearFromFile.x, LinearFromFile.y,LinearFromFile.z,LinearFromFile.numnodes, 1);
                                                }

                                             }
                                        }



                                      if(CombinedCheckApplies(LinearFromFile.idn,checkinstance,SHORTFEAT,LinearFromFile.Lindex,LinearFromFile.Sindex,
                                                              LinearFromFile.config,LinearFromFile.stratum,LinearFromFile.domain,
                                                              &part1,&part2,&part3))
                                        {
                                          if((part1 > 0) && (LinearFromFile.numnodes > 1) &&
                                               (SensitivityCheck(LT, SHORTFEAT, checkinstance, LinearFromFile.length) > 0))
                                             {
                                             OKtoUse = 1;
                                             kkk = 0;
                                             while((OKtoUse == 1) && (kkk < LinearFromFile.numnodes))
                                                {
                                                OKtoUse = PointOnQuarterDegreeBoundary(LinearFromFile.x[kkk],LinearFromFile.y[kkk],
                                                                                        ActiveChecks[checkinstance].sensitivity2);
                                                if(OKtoUse == 1)
                                                   OKtoUse = 0;
                                                else
                                                   OKtoUse = 1;
                                                kkk += LinearFromFile.numnodes - 1;
                                                }

                                             if(OKtoUse > 0)
                                                {
                                                FwriteObjectAndMagnitude(SHORTFEAT,Make_Correct(SHORTFEAT,checkinstance),
                                                               LinearFromFile.idn,
                                                               LinearFromFile.Sindex,G_LINE,RLc->Lindex,
                                                               RLc->localID,-1.0,-1.0,LinearFromFile.length,
                                                               LinearFromFile.x, LinearFromFile.y,LinearFromFile.z,LinearFromFile.numnodes, 1);
                                                }

                                             }
                                        }  /*** end SHORTFEAT check ***/

				    }
				}   /**** for(checkinstance = 0; checkinstance < TtlActiveChecks; checkinstance++) ***/
			     }
			  }
		       FreePointAndIDlist();
		       if(abortNow > 0)
			  break;
		       }


		    filedecimal = ((double) (Lfilenumber + 1)) / 10.0;
		    k = LinearTable[compositeindex].numinside;

		    if(k > 0)
		       {
		       if(LinearTable[compositeindex].filenumber != Lfilenumber)
			  {
			  Lfilenumber = LinearTable[compositeindex].filenumber;
			  filedecimal = ((double) (Lfilenumber + 1)) / 10.0;
			  if(LinearFiles[Lfilenumber].isopen == 0)
			      {
			      sprintf(suffix,"%d",Lfilenumber);
			      strcpy(afilein,linearsin);
			      if(Lfilenumber > 0)
				  strcat(afilein,suffix);
			      linin = fopen(afilein,"rb");
			      if(linin == NULL)
				 {
				 printf("3 area feature data input file %s could not be opened for read\n",afilein);
				 exit(-1);
				 }
			      LinearFiles[Lfilenumber].fp = linin;
			      LinearFiles[Lfilenumber].isopen = 1;
			      }
			   else
			      {
			      linin = LinearFiles[Lfilenumber].fp;
			      }

			  }
		       fseek(linin,LinearTable[compositeindex].fileptr,SEEK_SET);
		       i = 0;
		       while(i < k)
			  {
			  fo = ftell(linin);
			  j = ReadLinearFromFile(linin, multiplier);
			  ++i;

			  OKtoUse = 1;
			  if((NGA_TYPE == 0) && (NumLODbands > 0))
			     {
			     jj = CrsWlk[LinearFromFile.Lindex].LODband;
			     if((jj > 0) && (LODindex[jj-1].active < 1))
				OKtoUse = 0;
			     }

			  if((OKtoUse > 0) && (j > 0))
			     {

			     if((CheckByStratum[LinearFromFile.stratum] > 0) &&
				   (CheckByDomain[LinearFromFile.domain] > 0))
				{
                                if((CombinedCheckApplies(LinearFromFile.idn,-1,-1,LinearFromFile.Lindex,LinearFromFile.Sindex,
                                                           LinearFromFile.config,LinearFromFile.stratum,LinearFromFile.domain,
                                                           &part1,&part2,&part3)) && ((part1 > 0) || (part2 > 0) || (part3 > 0)))
                                   {
				   NumObjects[LinearFromFile.config] += 1.0;
                                   mpoc = MultiLineRoot;
                                   while(mpoc != NULL)
                                      {
                                      if(mpoc->featureid == LinearFromFile.idn)
                                         {
                                         mpoc->counted += 1; 
                                         break;
                                         }
                                      mpoc = mpoc->next;
                                      }

				   if(LinearFromFile.numnodes > 0)
				      NumLineSegments += (double) (LinearFromFile.numnodes - 1);
                                   }
			      
				RLdup = CheckLinearDuplication(LinearFromFile,RLroot,&IsDup);
				if(IsDup < UseDupThreshold)
				   {
				   RLc = (struct RawLinear *) (malloc(SzRL));
				   if(RLc == NULL)
				      {
				      printf("allocation memory exhausted during linear data read\n");
				      printf("processing cannot continue\n");
				      exit(-1);
				      }
RLc->lenstr = NULL;

				   RLc->length = LinearFromFile.length;
				   RLc->badform = LinearFromFile.badform;
				   RLc->featureid = LinearFromFile.featureid;
				   RLc->numnodes = LinearFromFile.numnodes;
				   RLc->Lindex = LinearFromFile.Lindex;
				   RLc->Sindex = LinearFromFile.Sindex;
				   RLc->IsMulti = 0;
				   tempID = RLc->localID = fo + filedecimal;
				   RLc->firstencounter = 1;
				   RLc->idn = LinearFromFile.idn;
                                   RLc->areaattr = LinearFromFile.areaattr;
                                   RLc->hgtattr = LinearFromFile.hgtattr;
                                   RLc->zv2attr = LinearFromFile.zv2attr;
                                   RLc->lenattr = LinearFromFile.lenattr;
                                   RLc->namattr = LinearFromFile.namattr;
                                   if(LinearFromFile.areastr[0] == '\0')
                                      RLc->areastr = NULL;
                                   else
                                      {
                                      RLc->areastr = (char *) (malloc(strlen(LinearFromFile.areastr) + 2));
                                      if(RLc->areastr != NULL)
                                         strcpy(RLc->areastr,LinearFromFile.areastr);
                                      }
                                   if(LinearFromFile.hgtstr[0] == '\0')
                                      RLc->hgtstr = NULL;
                                   else
                                      {
                                      RLc->hgtstr = (char *) (malloc(strlen(LinearFromFile.hgtstr) + 2));
                                      if(RLc->hgtstr != NULL)
                                         strcpy(RLc->hgtstr,LinearFromFile.hgtstr);
                                      }
                                   if(LinearFromFile.zv2str[0] == '\0')
                                      RLc->zv2str = NULL;
                                   else
                                      {
                                      RLc->zv2str = (char *) (malloc(strlen(LinearFromFile.zv2str) + 2));
                                      if(RLc->zv2str != NULL)
                                         strcpy(RLc->zv2str,LinearFromFile.zv2str);
                                      }
                                   if(LinearFromFile.lenstr[0] == '\0')
                                      RLc->lenstr = NULL;
                                   else
                                      {
                                      RLc->lenstr = (char *) (malloc(strlen(LinearFromFile.lenstr) + 2));
                                      if(RLc->lenstr != NULL)
                                         strcpy(RLc->lenstr,LinearFromFile.lenstr);
                                      }
                                   if(LinearFromFile.namstr[0] == '\0')
                                      RLc->namstr = NULL;
                                   else
                                      {
                                      RLc->namstr = (char *) (malloc(strlen(LinearFromFile.namstr) + 2));
                                      if(RLc->namstr != NULL)
                                         strcpy(RLc->namstr,LinearFromFile.namstr);
                                      }
				   /**RLc->width = LinearFromFile.width;
				   RLc->height = LinearFromFile.height;**/
				   RLc->next = NULL;
				   RLc->x = (double *) malloc(SzD * LinearFromFile.numnodes);
				   RLc->y = (double *) malloc(SzD * LinearFromFile.numnodes);
				   RLc->z = (double *) malloc(SzD * LinearFromFile.numnodes);
				   if((RLc->x == NULL) || (RLc->y == NULL) || (RLc->z == NULL))
				      {
				      printf("allocation memory exhausted during linear data read\n");
				      printf("processing cannot continue\n");
				      exit(-1);
				      }
				   for(jj = 0; jj<LinearFromFile.numnodes; jj++)
				      {
				      RLc->x[jj] = LinearFromFile.x[jj];
				      RLc->y[jj] = LinearFromFile.y[jj];
				      RLc->z[jj] = LinearFromFile.z[jj];
				      }
				   RLc->next = RLroot;
				   RLroot = RLc;
				   }
				else
				   {
				   tempID = fo + filedecimal;
				   }
				for(checkinstance = 0; checkinstance < TtlActiveChecks; checkinstance++)
				   {
                                   if(ID_O_count > 0)
                                      {
                                      part1 = 0;
                                      if( ((IsDup == 2) || (IsDup == 3) || (IsDup == 5)) && (LinearFromFile.idn != RLdup->idn) &&
                                            (CombinedCheckApplies(LinearFromFile.idn,checkinstance,ANY_SAMEID,LinearFromFile.Lindex,LinearFromFile.Sindex,
                                                      LinearFromFile.config,LinearFromFile.stratum,LinearFromFile.domain,
                                                      &part1,&part2,&part3))  && (part1 > 0) &&
                                            (CombinedCheckApplies(RLdup->idn,checkinstance,ANY_SAMEID,RLdup->Lindex,RLdup->Sindex,
                                             SCCtable[RLdup->Sindex].C, SCCtable[RLdup->Sindex].S, SCCtable[RLdup->Sindex].D,
                                                           &part1,&part2,&part3)) && (part2 > 0))
                                         {
                                         FwriteTwoObjects(ANY_SAMEID,Make_Correct(ANY_SAMEID,checkinstance),
                                                    LinearFromFile.idn,G_LINE,LinearFromFile.Lindex,tempID,LinearFromFile.Sindex,-1.0,-1.0,2,
                                                    LinearFromFile.x, LinearFromFile.y,LinearFromFile.z,
                                                    RLdup->idn,G_LINE,RLdup->Lindex,RLdup->localID,RLdup->Sindex,-1.0,-1.0,2,
                                                    RLdup->x, RLdup->y,RLdup->z);
/*****/
                                         }
/***************/
                                      else if((IsDup != 4) &&
                                    (CombinedCheckApplies(LinearFromFile.idn,checkinstance,ANY_SAMEID,LinearFromFile.Lindex,LinearFromFile.Sindex,
                                                      LinearFromFile.config,LinearFromFile.stratum,LinearFromFile.domain,
                                                      &part1,&part2,&part3)) &&
                                              ((part1 > 0) || (part2 > 0)))
                                         {
                                         GetAppropIDnumber(LinearFromFile.idn, &tempstring[0]);
                                         jj = GetUUIDindex(tempstring);
                                         if(jj >= 0)
                                            {
                                            olidp = ID_O[jj].inst;
                                            while(olidp != NULL)
                                               {
                                               if((LinearFromFile.idn != olidp->idn) && (olidp->checknumb == checkinstance))
                                                  {
                                                  if((part1 > 0) && (olidp->part > 1))
                                                     {
                                                     FwriteTwoObjects(ANY_SAMEID,Make_Correct(ANY_SAMEID,checkinstance),
                                                        LinearFromFile.idn,G_LINE,LinearFromFile.Lindex,tempID,LinearFromFile.Sindex,-1.0,-1.0,2,
                                                           LinearFromFile.x, LinearFromFile.y,LinearFromFile.z,
                                                           olidp->idn,olidp->gform,olidp->Lindex,olidp->lid,olidp->Sindex,-1.0,-1.0,olidp->numvert,
                                                           olidp->x, olidp->y,olidp->z);
                                                     break;
                                                     }
                                                  else if((part2 > 0) && ((olidp->part == 1) || (olidp->part == 3)))
                                                     {
                                                     FwriteTwoObjects(ANY_SAMEID,Make_Correct(ANY_SAMEID,checkinstance),
                                                        LinearFromFile.idn,G_LINE,LinearFromFile.Lindex,tempID,LinearFromFile.Sindex,-1.0,-1.0,2,
                                                           LinearFromFile.x, LinearFromFile.y,LinearFromFile.z,
                                                           olidp->idn,olidp->gform,olidp->Lindex,olidp->lid,olidp->Sindex,-1.0,-1.0,olidp->numvert,
                                                           olidp->x, olidp->y,olidp->z);
                                                     break;
                                                     }
                                                  }
                                               olidp = olidp->next;
                                               }
                                            if(olidp == NULL)
                                               {
                                               olidc = (struct OverlapIDinstance *) (malloc(sizeof(struct OverlapIDinstance)));
                                               if(olidc == NULL)
                                                  {
                                                  printf("memory exhausted during unique identifier processing - results will be incomplete\n");
                                                  }
                                               else
                                                  {
                                                  olidc->checknumb = checkinstance;
                                                  olidc->idn = LinearFromFile.idn;
                                                  olidc->lid = tempID;
                                                  olidc->Lindex = LinearFromFile.Lindex;
                                                  olidc->Sindex = LinearFromFile.Sindex;
                                                  olidc->gform = G_LINE;
                                                  if((part1 > 0) && (part2 > 0))
                                                     olidc->part = 3;
                                                  else if(part1 > 0)
                                                     olidc->part = 1;
                                                  else
                                                     olidc->part = 2;
                                                  olidc->numvert = 2;
                                                  olidc->x[0] = LinearFromFile.x[0];
                                                  olidc->y[0] = LinearFromFile.y[0];
                                                  olidc->z[0] = LinearFromFile.z[0];
                                                  olidc->x[1] = LinearFromFile.x[1];
                                                  olidc->y[1] = LinearFromFile.y[1];
                                                  olidc->z[1] = LinearFromFile.z[1];
                                                  olidc->next = ID_O[jj].inst;
                                                  ID_O[jj].inst = olidc;
                                                  }
                                               }
                                            }
                                         }
                                      }
/*****************/

				   if(
				      (IsDup == 1) &&
				      (CombinedCheckApplies(LinearFromFile.idn,checkinstance,G_DUPS,LinearFromFile.Lindex,LinearFromFile.Sindex,
							    LinearFromFile.config,LinearFromFile.stratum,LinearFromFile.domain,
							    &part1,&part2,&part3)) && (part1 > 0) &&
				      (CombinedCheckApplies(RLdup->idn,checkinstance,G_DUPS,RLdup->Lindex,RLdup->Sindex,
				       SCCtable[RLdup->Sindex].C, SCCtable[RLdup->Sindex].S, SCCtable[RLdup->Sindex].D,
							   &part1,&part2,&part3)) && (part2 > 0)
				      )
				     {
				       FwriteTwoObjects(G_DUPS,Make_Correct(G_DUPS,checkinstance),
							LinearFromFile.idn,G_LINE,LinearFromFile.Lindex,tempID,LinearFromFile.Sindex,-1.0,-1.0,
							LinearFromFile.numnodes,LinearFromFile.x,
							LinearFromFile.y,LinearFromFile.z,
							RLdup->idn,G_LINE,RLdup->Lindex,RLdup->localID,RLdup->Sindex,-1.0,-1.0,RLdup->numnodes,
							RLdup->x, RLdup->y,RLdup->z);
				     }


				   if(
				      (IsDup == 4) &&
				      (CombinedCheckApplies(LinearFromFile.idn,checkinstance,C_DUPS,LinearFromFile.Lindex,LinearFromFile.Sindex,
							    LinearFromFile.config,LinearFromFile.stratum,LinearFromFile.domain,
							    &part1,&part2,&part3)) && (part1 > 0) &&
				      (CombinedCheckApplies(RLdup->idn,checkinstance,C_DUPS,RLdup->Lindex,RLdup->Sindex,
				       SCCtable[RLdup->Sindex].C, SCCtable[RLdup->Sindex].S, SCCtable[RLdup->Sindex].D,
							   &part1,&part2,&part3)) && (part1 > 0)
				      )
				     {
				       FwriteTwoObjects(C_DUPS,Make_Correct(C_DUPS,checkinstance), 
							LinearFromFile.idn,G_LINE,LinearFromFile.Lindex,tempID,LinearFromFile.Sindex,-1.0,-1.0,
							LinearFromFile.numnodes,LinearFromFile.x,
							LinearFromFile.y,LinearFromFile.z,
							RLdup->idn,G_LINE,RLdup->Lindex,RLdup->localID,RLdup->Sindex,-1.0,-1.0,RLdup->numnodes,
							RLdup->x, RLdup->y,RLdup->z);
				     }


				  if(NGA_TYPE == 1)
				     {
				     if((IsDup == 2) && 
					(CombinedCheckApplies(LinearFromFile.idn,checkinstance,SAMEID,LinearFromFile.Lindex,LinearFromFile.Sindex,
							   LinearFromFile.config,LinearFromFile.stratum,LinearFromFile.domain,
							   &part1,&part2,&part3)) && (part1 > 0) &&
					 (CombinedCheckApplies(RLdup->idn,checkinstance,SAMEID,RLdup->Lindex,RLdup->Sindex,
					  SCCtable[RLdup->Sindex].C, SCCtable[RLdup->Sindex].S, SCCtable[RLdup->Sindex].D,
							   &part1,&part2,&part3)) && (part2 > 0))
					{
                                       mpoc = MultiLineRoot;
                                        while(mpoc != NULL)
                                           {
                                           if(mpoc->featureid == LinearFromFile.idn)
                                              break;
                                           mpoc = mpoc->next;
                                           }
                                        if(mpoc == NULL)
                                           {
					   FwriteTwoObjects(SAMEID,Make_Correct(SAMEID,checkinstance),
						       LinearFromFile.idn,G_LINE,LinearFromFile.Lindex,tempID,LinearFromFile.Sindex,-1.0,-1.0,
						       LinearFromFile.numnodes,LinearFromFile.x, LinearFromFile.y,LinearFromFile.z,
						       RLdup->idn,G_LINE,RLdup->Lindex,RLdup->localID,RLdup->Sindex,-1.0,-1.0,RLdup->numnodes,
						       RLdup->x, RLdup->y,RLdup->z);
                                           }
					}

				     if((IsDup == 3) && 
					(CombinedCheckApplies(LinearFromFile.idn,checkinstance,SAMEID_GDUP,LinearFromFile.Lindex,LinearFromFile.Sindex,
							   LinearFromFile.config,LinearFromFile.stratum,LinearFromFile.domain,
							   &part1,&part2,&part3)) && (part1 > 0) &&
					 (CombinedCheckApplies(RLdup->idn,checkinstance,SAMEID_GDUP,RLdup->Lindex,RLdup->Sindex,
					  SCCtable[RLdup->Sindex].C, SCCtable[RLdup->Sindex].S, SCCtable[RLdup->Sindex].D,
							   &part1,&part2,&part3)) && (part2 > 0))
					{
					FwriteTwoObjects(SAMEID_GDUP,Make_Correct(SAMEID_GDUP,checkinstance),
						       LinearFromFile.idn,G_LINE,LinearFromFile.Lindex,tempID,LinearFromFile.Sindex,-1.0,-1.0,
						       LinearFromFile.numnodes,LinearFromFile.x, LinearFromFile.y,LinearFromFile.z,
						       RLdup->idn,G_LINE,RLdup->Lindex,RLdup->localID,RLdup->Sindex,-1.0,-1.0,RLdup->numnodes,
						       RLdup->x, RLdup->y,RLdup->z);
					}

				     if((IsDup == 5) && 
					(CombinedCheckApplies(LinearFromFile.idn,checkinstance,SAMEID_CDUP,LinearFromFile.Lindex,LinearFromFile.Sindex,
							   LinearFromFile.config,LinearFromFile.stratum,LinearFromFile.domain,
							   &part1,&part2,&part3)) && (part1 > 0) &&
					 (CombinedCheckApplies(RLdup->idn,checkinstance,SAMEID_CDUP,RLdup->Lindex,RLdup->Sindex,
					  SCCtable[RLdup->Sindex].C, SCCtable[RLdup->Sindex].S, SCCtable[RLdup->Sindex].D,
							   &part1,&part2,&part3)) && (part1 > 0))
					{
                                        FwriteTwoObjects(SAMEID_CDUP, Make_Correct(SAMEID_CDUP,checkinstance),
                                                       LinearFromFile.idn,G_LINE,LinearFromFile.Lindex,tempID,LinearFromFile.Sindex,-1.0,-1.0,
                                                       LinearFromFile.numnodes,LinearFromFile.x, LinearFromFile.y,LinearFromFile.z,
                                                       RLdup->idn,G_LINE,RLdup->Lindex,RLdup->localID,RLdup->Sindex,-1.0,-1.0,RLdup->numnodes,
                                                       RLdup->x, RLdup->y,RLdup->z);
					}
				     }

				   
				   if(IsDup < UseDupThreshold)
				     {
				       if((CombinedCheckApplies(LinearFromFile.idn,checkinstance,V_DUPS,LinearFromFile.Lindex,
							       LinearFromFile.Sindex,
							       LinearFromFile.config,LinearFromFile.stratum,
							       LinearFromFile.domain,&part1,&part2,&part3)) && (part1 > 0))
					 {
					   dv = DuplicateVerticesExist(LinearFromFile.numnodes,LinearFromFile.x,
									  LinearFromFile.y,LinearFromFile.z);
					   if(SensitivityCheck(GT, V_DUPS, checkinstance, (double) dv) > 0)
					     {
					       /*** found a linear with duplicate vertices **/
					       for(jj=1; jj<LinearFromFile.numnodes; jj++)
						 {
						 if((LinearFromFile.x[jj-1] == LinearFromFile.x[jj]) &&
						     (LinearFromFile.y[jj-1] == LinearFromFile.y[jj]) &&
						     (LinearFromFile.z[jj-1] == LinearFromFile.z[jj]))
						    {
                                                    FwriteObject(V_DUPS,Make_Correct(V_DUPS,checkinstance),RLc->Lindex,
                                                           LinearFromFile.Sindex,G_LINE,RLc->localID,LinearFromFile.idn, -1.0, -1.0,
                                                            &LinearFromFile.x[jj],&LinearFromFile.y[jj],&LinearFromFile.z[jj],1, 1);
						    }
						 }
					     }
					 }




				       if((CombinedCheckApplies(LinearFromFile.idn,checkinstance,ATTRERR,LinearFromFile.Lindex,
							       LinearFromFile.Sindex,LinearFromFile.config,
							       LinearFromFile.stratum,LinearFromFile.domain,
							       &part1,&part2,&part3)) && (part1 > 0))
					 {
					   if(CrsWlk[LinearFromFile.Lindex].AttrErr >= 0)
					     {
					       FwriteObjectAndMessage(ATTRERR,Make_Correct(ATTRERR,checkinstance),
								      LinearFromFile.idn, G_LINE,RLc->Lindex,RLc->localID,
								      LinearFromFile.Sindex,-1.0,-1.0,LinearFromFile.x,
								      LinearFromFile.y,LinearFromFile.z,LinearFromFile.numnodes,
								      AttrErr[CrsWlk[LinearFromFile.Lindex].AttrErr].description);
					    }
					 }


				      if(CombinedCheckApplies(LinearFromFile.idn,checkinstance,LOOPS,LinearFromFile.Lindex,LinearFromFile.Sindex,
							      LinearFromFile.config,LinearFromFile.stratum,LinearFromFile.domain,
							      &part1,&part2,&part3))
					{
					if((part1 > 0) && (LinearFromFile.numnodes > 2)) /**** &&(LinearFromFile.numnodes <maxverts)) ***/
					   {
					   kkend = LinearFromFile.numnodes-1;
					   while((kkend > 0) && 
						  (LinearFromFile.x[kkend-1] == LinearFromFile.x[kkend]) &&
						    (LinearFromFile.y[kkend-1] == LinearFromFile.y[kkend]))
					      {
					      --kkend;
					      }

					   for(jj=1; jj<= kkend; jj++)
					      {
					      kkstart = jj + 1;
					      while((kkstart<= kkend) &&
						     (LinearFromFile.x[kkstart] == LinearFromFile.x[jj]) &&
							(LinearFromFile.y[kkstart] == LinearFromFile.y[jj]))
						 {
						 ++kkstart;
						 }
					      for(kk=kkstart; kk<= kkend; kk++)
						 {
						 OKtoCheck = 1;
						 if((jj == 1) && (kk == kkend) && (LinearFromFile.x[0] == LinearFromFile.x[kk]) &&
						      (LinearFromFile.y[0] == LinearFromFile.y[kk]))
						    {
						    OKtoCheck = 0;
						    }
                                                 else if((LinearFromFile.x[0] == LinearFromFile.x[kk]) &&
                                                      (LinearFromFile.y[0] == LinearFromFile.y[kk]))
                                                    {
                                                    OKtoCheck = 0;
                                                    }
                                                 else if((LinearFromFile.x[kkend] == LinearFromFile.x[kk]) &&
                                                      (LinearFromFile.y[kkend] == LinearFromFile.y[kk]))
                                                    {
                                                    OKtoCheck = 0;
                                                    }

						 if(OKtoCheck > 0)
						    {
						    /***if(kk == (jj+1))***/
						    if(kk == kkstart)
						       {
						       if((LinearFromFile.x[kk] != LinearFromFile.x[jj]) ||
							    (LinearFromFile.y[kk] != LinearFromFile.y[jj]))
							  {
							  if(PointOnLineSegment(LinearFromFile.x[kk],LinearFromFile.y[kk],
							       LinearFromFile.x[jj-1],LinearFromFile.y[jj-1],
								 LinearFromFile.x[jj],LinearFromFile.y[jj],0.000001) > 0)
							     {
							     kkk = AddToPointAndIDlist(LinearFromFile.x[kk],LinearFromFile.y[kk],LinearFromFile.idn);
							     if(kkk > 0)
								{
                                                                if((IsSentinelZvalue(LinearFromFile.z[kk],1) == 0) &&
                                                                    (IsSentinelZvalue(LinearFromFile.z[jj],1) == 0) &&
                                                                       (IsSentinelZvalue(LinearFromFile.z[jj-1],1) == 0))
                                                                   {
                                                                   zint = InterpLinearElev(LinearFromFile.x[jj-1],LinearFromFile.y[jj-1],LinearFromFile.z[jj-1],
                                                                          LinearFromFile.x[jj],LinearFromFile.y[jj],LinearFromFile.z[jj],
                                                                         LinearFromFile.x[kk],LinearFromFile.y[kk]);
                                                                   if(zint > LinearFromFile.z[kk])
                                                                      PD2 = zint - LinearFromFile.z[kk];
                                                                   else
                                                                      PD2 = LinearFromFile.z[kk] - zint;
                                                                   }
                                                                else
                                                                   PD2 = 0;
                                                                if(PD2 < 0.1)
                                                                   {
								   FwritePointAndObject(LOOPS,Make_Correct(LOOPS,checkinstance),
								      LinearFromFile.x[kk],LinearFromFile.y[kk],LinearFromFile.z[kk],LinearFromFile.idn,
								      LinearFromFile.Sindex,G_LINE,LinearFromFile.Lindex,RLc->localID,
								      LinearFromFile.idn,10.0,0.0,
								      &LinearFromFile.x[kk], &LinearFromFile.y[kk],&LinearFromFile.z[0],2);
                                                                   }
								}
							     }
							  }
						       }
						    else
						       {
						       if(LineSegmentsIntersect(LinearFromFile.x[kk-1],LinearFromFile.y[kk-1],
									     LinearFromFile.x[kk],LinearFromFile.y[kk],
									  LinearFromFile.x[jj-1],LinearFromFile.y[jj-1],
									     LinearFromFile.x[jj],LinearFromFile.y[jj], &xint, &yint) > 0)
							  {
                                                          if((xint != LinearFromFile.x[kkend]) || (yint != LinearFromFile.y[kkend]))
                                                             {
                                                             if((xint != LinearFromFile.x[0]) || (yint != LinearFromFile.y[0]))
                                                                {
							        kkk = AddToPointAndIDlist(xint,yint,LinearFromFile.idn);
							        if(kkk > 0)
							           {
							           zint = InterpLinearElev(LinearFromFile.x[kk-1],LinearFromFile.y[kk-1],LinearFromFile.z[kk-1],
								        LinearFromFile.x[kk],LinearFromFile.y[kk],LinearFromFile.z[kk],xint,yint);

                                                                   if((IsSentinelZvalue(LinearFromFile.z[jj],1) == 0) &&
                                                                       (IsSentinelZvalue(LinearFromFile.z[jj-1],1) == 0))
                                                                      {
                                                                      PD2 = InterpLinearElev(LinearFromFile.x[jj-1],LinearFromFile.y[jj-1],
                                                                         LinearFromFile.z[jj-1],
                                                                         LinearFromFile.x[jj],LinearFromFile.y[jj],LinearFromFile.z[jj],xint,yint);
                                                                      if(zint > PD2)
                                                                         PD2 = zint - PD2;
                                                                      else
                                                                         PD2 = PD2 - zint;
                                                                      }
                                                                   else
                                                                      PD2 = 0;
                                                                   if(PD2 < 0.1)
                                                                      {
							              FwritePointAndObject(LOOPS,Make_Correct(LOOPS,checkinstance),
								         xint,yint,zint,LinearFromFile.idn,
								         LinearFromFile.Sindex,G_LINE,LinearFromFile.Lindex,RLc->localID,
								         LinearFromFile.idn,10.0,0.0,
								         &LinearFromFile.x[kk-1], &LinearFromFile.y[kk-1],&LinearFromFile.z[kk-1],2);
                                                                      }
                                                                   }
                                                                }
							     }
							  }
						       }
						    }

						 }  /*** end for kk ***/
					      } /*** end for jj ***/
					   } 
					}

				      if(CombinedCheckApplies(LinearFromFile.idn,checkinstance,MULTIPARTL,LinearFromFile.Lindex,LinearFromFile.Sindex,
							      LinearFromFile.config,LinearFromFile.stratum,LinearFromFile.domain,
							      &part1,&part2,&part3) && (part1 > 0))
					{
					mpoc = MultiLineRoot;
					kkk = 0;
					while(mpoc != NULL)
					   {
					   if((mpoc->featureid == LinearFromFile.idn) && (mpoc->used == 0))
					      ++kkk;
					   mpoc = mpoc->next;
					   }
					if(SensitivityCheck(GT, MULTIPARTL, checkinstance, (double) kkk) > 0)
					   {
					   mpoc = MultiLineRoot;
					   while(mpoc != NULL)
					      {
					      if(mpoc->featureid == LinearFromFile.idn)
						 {
						 mpoc->used = 1;
						 FwriteObjectAndMagnitude(MULTIPARTL,Make_Correct(MULTIPARTL,checkinstance),
								     LinearFromFile.idn,
								     LinearFromFile.Sindex,G_LINE,RLc->Lindex,RLc->localID,-1.0,-1.0,(double) kkk,
								     mpoc->x, mpoc->y, mpoc->z, mpoc->numverts, 1);
						 }
					      mpoc = mpoc->next;
					      }
					   }
					}


				      if(CombinedCheckApplies(LinearFromFile.idn,checkinstance,ENDPTINT,LinearFromFile.Lindex,LinearFromFile.Sindex,
							      LinearFromFile.config,LinearFromFile.stratum,LinearFromFile.domain,
							      &part1,&part2,&part3))
					{
					if((part1 > 0) && (LinearFromFile.numnodes > 2)) /*** &&(LinearFromFile.numnodes <maxverts)) ***/
					   {
					   jj = LinearFromFile.numnodes - 1;
					   if((LinearFromFile.x[0] == LinearFromFile.x[jj]) && (LinearFromFile.y[0] == LinearFromFile.y[jj]) &&
						       (LinearFromFile.z[0] == LinearFromFile.z[jj]))
					      {
					      FwritePointAndObject(ENDPTINT,Make_Correct(ENDPTINT,checkinstance),
						 LinearFromFile.x[0],LinearFromFile.y[0],LinearFromFile.z[0],LinearFromFile.idn,
						 LinearFromFile.Sindex,G_LINE,LinearFromFile.Lindex,RLc->localID,
								    LinearFromFile.idn,10.0,0.0,
						 &LinearFromFile.x[0], &LinearFromFile.y[0],&LinearFromFile.z[0],2);
					      }
					   }
					}



                                      if(CombinedCheckApplies(LinearFromFile.idn,checkinstance,LONGFEAT,LinearFromFile.Lindex,LinearFromFile.Sindex,
                                                              LinearFromFile.config,LinearFromFile.stratum,LinearFromFile.domain,
                                                              &part1,&part2,&part3))
                                        {
                                          if((part1 > 0) && (LinearFromFile.numnodes > 1))
                                             {
                                             segmentlength = 0;
                                             for(jj=1; jj<LinearFromFile.numnodes; jj++)
                                                {
                                                segmentlength += Distance3D(LinearFromFile.x[jj-1],LinearFromFile.y[jj-1],LinearFromFile.z[jj-1],
                                                                           LinearFromFile.x[jj],LinearFromFile.y[jj],LinearFromFile.z[jj]);
                                                }
                                             if(SensitivityCheck(GT, LONGFEAT, checkinstance, segmentlength) > 0)
                                                {
                                                FwriteObjectAndMagnitude(LONGFEAT,Make_Correct(LONGFEAT,checkinstance),
                                                                  LinearFromFile.idn,
                                                                  LinearFromFile.Sindex,G_LINE,RLc->Lindex,RLc->localID,-1.0,-1.0,segmentlength,
                                                                  LinearFromFile.x, LinearFromFile.y,LinearFromFile.z,LinearFromFile.numnodes, 1);
                                                }

                                             }
                                        }



                                      if(CombinedCheckApplies(LinearFromFile.idn,checkinstance,SHORTFEAT,LinearFromFile.Lindex,LinearFromFile.Sindex,
                                                              LinearFromFile.config,LinearFromFile.stratum,LinearFromFile.domain,
                                                              &part1,&part2,&part3))
                                        {
                                          if((part1 > 0) && (LinearFromFile.numnodes > 1) && 
                                                 (SensitivityCheck(LT, SHORTFEAT, checkinstance, LinearFromFile.length) > 0))
                                             {
                                             OKtoUse = 1;
                                             kkk = 0;
                                             while((OKtoUse == 1) && (kkk < LinearFromFile.numnodes))
                                                {
                                                OKtoUse = PointOnQuarterDegreeBoundary(LinearFromFile.x[kkk],LinearFromFile.y[kkk],
                                                               ActiveChecks[checkinstance].sensitivity2);
                                                if(OKtoUse == 1)
                                                   OKtoUse = 0;
                                                else
                                                   OKtoUse = 1;
                                                kkk += LinearFromFile.numnodes - 1;
                                                }

                                             if(OKtoUse > 0)
                                                {
                                                FwriteObjectAndMagnitude(SHORTFEAT,Make_Correct(SHORTFEAT,checkinstance),
                                                               LinearFromFile.idn,
                                                               LinearFromFile.Sindex,G_LINE,RLc->Lindex,RLc->localID,-1.0,-1.0,LinearFromFile.length,
                                                               LinearFromFile.x, LinearFromFile.y,LinearFromFile.z,LinearFromFile.numnodes, 1);
                                                }

                                             }
                                        }  /*** end SHORTFEAT check ***/


				      }
				   }  /*** for(checkinstance = 0; checkinstance < TtlActiveChecks; checkinstance++) ***/
				}
			     }
			  FreePointAndIDlist();
			  if(abortNow > 0)
			     break;
			  }
		       }
		    }  /** finished with all linear objects **/

		 if((abortNow == 0) && (NGA_TYPE == 1) && (CLAMPFEATURES > 0))
		    {
		       if(gridfilein != NULL)
			  CloseGridFile(gridfilein);
		       ClampLinears(RLroot,multiplier,compositeindex,NumberOfGrids);
		    }


	/*** checks for point objects **/
		 if((ptsin != NULL) && (abortNow == 0) && ((CheckByConfig[3] > 0) || (CheckByConfig[5] > 0) || (CheckByConfig[6] > 0) || 
		    (CheckByConfig[10] > 0) || (CheckByConfig[11] > 0) || (CheckByConfig[13] > 0)))
		    {
		    FreeLongList(&PointLongListRoot);

		    for(i=0; i<PointTable[compositeindex].numother; i++)
		       {

		       filedecimal = 0.1;

		       fseek(ptsin,PointTable[compositeindex].others[i].fileptr,SEEK_SET);
		       vtxcnt = ReadPointFromFile(ptsin, multiplier);
		       InsertOK = InsertIntoLongList(PointTable[compositeindex].others[i].fileptr,0,skiplimit,
					  &PointLongListRoot,LongPointSkipList,&SkipEntry);

		       OKtoUse = 1;

		       if((NGA_TYPE == 0) && (NumLODbands > 0))
			  {
			  jj = CrsWlk[PointFromFile.Lindex].LODband;
			  if((jj > 0) && (LODindex[jj-1].active < 1))
			     OKtoUse = 0;
			  }

		       if((OKtoUse > 0) && (CheckByStratum[PointFromFile.stratum] > 0) &&
				(CheckByDomain[PointFromFile.domain] > 0))
			  {
			  if(InsertOK)
                             {
			     NumObjects[PointFromFile.config] += 1.0;
                             mpoc = MultiPointRoot;
                             while(mpoc != NULL)
                                {
                                if(mpoc->featureid == PointFromFile.idn)
                                   {
                                   mpoc->counted += 1; 
                                   break;
                                   }
                                mpoc = mpoc->next;
                                }
                             }

			  RPdup = CheckPointDuplication(PointFromFile,RProot,&IsDup);
			  if(IsDup >= UseDupThreshold)
			     {
			     tempID = (double) PointTable[compositeindex].others[i].fileptr + filedecimal;
			     }
			  
			  for(checkinstance = 0; checkinstance < TtlActiveChecks; checkinstance++)
			     {

			       /* tim modified the &&(checkinstance==0) was added for speed */
			       if((IsDup < UseDupThreshold) && (checkinstance==0))
				{
				if(( PointFromFile.numverts < 1) && (PointFromFile.numverts > -3))
				   vtxcnt = 1;
				else if(PointFromFile.numverts < -2)
				   vtxcnt = 0 - PointFromFile.numverts;
				else
				   vtxcnt = PointFromFile.numverts;
				RPc = (struct RawPoint *) (malloc(SzRP));
				if(RPc == NULL)
				   {
				   printf("allocation memory exhausted during point data read\n");
				   printf("processing cannot continue\n");
				   exit(-1);
				   }
				RPc->numverts = PointFromFile.numverts;

RPc->featureid = PointFromFile.idn;

				RPc->Lindex = PointFromFile.Lindex;
				RPc->Sindex = PointFromFile.Sindex;
				RPc->idn = PointFromFile.idn;
                                RPc->areaattr = PointFromFile.areaattr;
                                RPc->hgtattr = PointFromFile.hgtattr;
                                RPc->zv2attr = PointFromFile.zv2attr;
                                RPc->lenattr = PointFromFile.lenattr;
                                RPc->namattr = PointFromFile.namattr;
                                if(PointFromFile.areastr[0] == '\0')
                                   RPc->areastr = NULL;
                                else
                                   {
                                   RPc->areastr = (char *) (malloc(strlen(PointFromFile.areastr) + 2));
                                   if(RPc->areastr != NULL)
                                      strcpy(RPc->areastr,PointFromFile.areastr);
                                   }
                                if(PointFromFile.hgtstr[0] == '\0')
                                   RPc->hgtstr = NULL;
                                else
                                   {
                                   RPc->hgtstr = (char *) (malloc(strlen(PointFromFile.hgtstr) + 2));
                                   if(RPc->hgtstr != NULL)
                                      strcpy(RPc->hgtstr,PointFromFile.hgtstr);
                                   }
                                if(PointFromFile.zv2str[0] == '\0')
                                   RPc->zv2str = NULL;
                                else
                                   {
                                   RPc->zv2str = (char *) (malloc(strlen(PointFromFile.zv2str)+ 2));
                                   if(RPc->zv2str != NULL)
                                      strcpy(RPc->zv2str,PointFromFile.zv2str);
                                   }
                                if(PointFromFile.lenstr[0] == '\0')
                                   RPc->lenstr = NULL;
                                else
                                   {
                                   RPc->lenstr = (char *) (malloc(strlen(PointFromFile.lenstr)+ 2));
                                   if(RPc->lenstr != NULL)
                                      strcpy(RPc->lenstr,PointFromFile.lenstr);
                                   }
                                if(PointFromFile.namstr[0] == '\0')
                                   RPc->namstr = NULL;
                                else
                                   {
                                   RPc->namstr = (char *) (malloc(strlen(PointFromFile.namstr)+ 2));
                                   if(RPc->namstr != NULL)
                                      strcpy(RPc->namstr,PointFromFile.namstr);
                                   }
				RPc->rad = PointFromFile.rad;
				tempID = RPc->localID = (double) PointTable[compositeindex].others[i].fileptr + filedecimal;
				RPc->next = NULL;
				RPc->h = (double *) malloc(SzD * vtxcnt);
				RPc->x = (double *) malloc(SzD * vtxcnt);
				RPc->y = (double *) malloc(SzD * vtxcnt);
				RPc->z = (double *) malloc(SzD * vtxcnt);
				if((RPc->h == NULL) || (RPc->x == NULL) || (RPc->y == NULL) || (RPc->z == NULL))
				   {
				   printf("allocation memory exhausted during point data read\n");
				   printf("processing cannot continue\n");
				   exit(-1);
				   }
				for(jj = 0; jj<vtxcnt; jj++)
				   {
				   RPc->h[jj] = PointFromFile.h[jj];
				   RPc->x[jj] = PointFromFile.x[jj];
				   RPc->y[jj] = PointFromFile.y[jj];
				   RPc->z[jj] = PointFromFile.z[jj];
				   }
				RPc->next = RProot;
				RProot = RPc;
				}

		     if((IsDup < UseDupThreshold) && (InsertOK > 0) && (PointFromFile.numverts == -1) &&
			      (CombinedCheckApplies(PointFromFile.idn,checkinstance,MULTIPARTP,PointFromFile.Lindex,PointFromFile.Sindex,
						     PointFromFile.config,PointFromFile.stratum,PointFromFile.domain,
						     &part1,&part2,&part3) && (part1 > 0)))
			       {
			       mpoc = MultiPointRoot;
			       kkk = 0; 
			       while(mpoc != NULL)
				  {
				  if((mpoc->featureid == PointFromFile.idn) && (mpoc->used == 0))
				     ++kkk;
				  mpoc = mpoc->next;
				  }
			       if(SensitivityCheck(GT, MULTIPARTP, checkinstance, (double) kkk) > 0)
				  {
				  mpoc = MultiPointRoot;
				  while(mpoc != NULL)
				     {
				     if(mpoc->featureid == PointFromFile.idn)
					{
					mpoc->used = 1;
					FwriteObjectAndMagnitude(MULTIPARTP,Make_Correct(MULTIPARTP,checkinstance),
							    PointFromFile.idn,
							    PointFromFile.Sindex,G_POINT,RPc->Lindex,RPc->localID,-1.0,-1.0,(double) kkk,
							    &mpoc->x[0], &mpoc->y[0], &mpoc->z[0], 1, 1);
					}
				     mpoc = mpoc->next;
				     }
				  }
			       }



                             if(ID_O_count > 0)
                                {
                                part1 = 0;
                                if((NGA_TYPE > 0) && (InsertOK > 0) && 
                                         ((IsDup == 2) || (IsDup == 3) || (IsDup == 5)) && (PointFromFile.idn != RPdup->idn) &&
                                         (CombinedCheckApplies(PointFromFile.idn,checkinstance,ANY_SAMEID,PointFromFile.Lindex,PointFromFile.Sindex,
                                                      PointFromFile.config,PointFromFile.stratum,PointFromFile.domain,
                                                      &part1,&part2,&part3))  && (part1 > 0) &&
                                         (CombinedCheckApplies(RPdup->idn,checkinstance,ANY_SAMEID,RPdup->Lindex,RPdup->Sindex,
                                          SCCtable[RPdup->Sindex].C, SCCtable[RPdup->Sindex].S, SCCtable[RPdup->Sindex].D,
                                                           &part1,&part2,&part3)) && (part2 > 0))
                                   {
                                   if(PointFromFile.numverts == -1) 
                                      {
                                      FwriteTwoObjects(ANY_SAMEID,Make_Correct(ANY_SAMEID,checkinstance),
                                                        PointFromFile.idn,G_POINT,PointFromFile.Lindex,tempID,PointFromFile.Sindex,-1.0,-1.0,
                                                        1,PointFromFile.x, PointFromFile.y,PointFromFile.z,
                                                        RPdup->idn,G_POINT,RPdup->Lindex,RPdup->localID,RPdup->Sindex,-1.0,-1.0,1,
                                                        RPdup->x, RPdup->y,RPdup->z);
                                      }
                                   }
                                else if((NGA_TYPE > 0) && (InsertOK > 0) && (IsDup != 4) &&
                                       (CombinedCheckApplies(PointFromFile.idn,checkinstance,ANY_SAMEID,PointFromFile.Lindex,PointFromFile.Sindex,
                                                      PointFromFile.config,PointFromFile.stratum,PointFromFile.domain,
                                                      &part1,&part2,&part3)) &&
                                        ((part1 > 0) || (part2 > 0)))
                                   {
                                   GetAppropIDnumber(PointFromFile.idn, &tempstring[0]);
                                   jj = GetUUIDindex(tempstring);
                                   if(jj >= 0)
                                      {
                                      olidp = ID_O[jj].inst;
                                      while(olidp != NULL)
                                         {
                                         if((PointFromFile.idn != olidp->idn) && (olidp->checknumb == checkinstance))
                                            {
                                            if((part1 > 0) && (olidp->part > 1))
                                               {
                                               if(PointFromFile.numverts == -1) 
                                                  {
                                                  FwriteTwoObjects(ANY_SAMEID,Make_Correct(ANY_SAMEID,checkinstance),
                                                        PointFromFile.idn,G_POINT,PointFromFile.Lindex,tempID,PointFromFile.Sindex,-1.0,-1.0,
                                                        1,PointFromFile.x, PointFromFile.y,PointFromFile.z,
                                                        olidp->idn,olidp->gform,olidp->Lindex,olidp->lid,olidp->Sindex,-1.0,-1.0,olidp->numvert,
                                                        olidp->x, olidp->y,olidp->z);
                                                  }
                                               break;
                                               }
                                            else if((part2 > 0) && ((olidp->part == 1) || (olidp->part == 3)))
                                               {
                                               if(PointFromFile.numverts == -1) 
                                                  {
                                                  FwriteTwoObjects(ANY_SAMEID,Make_Correct(ANY_SAMEID,checkinstance),
                                                           PointFromFile.idn,G_POINT,PointFromFile.Lindex,tempID,PointFromFile.Sindex,-1.0,-1.0,
                                                           1,PointFromFile.x, PointFromFile.y,PointFromFile.z,
                                                           olidp->idn,olidp->gform,olidp->Lindex,olidp->lid,olidp->Sindex,-1.0,-1.0,olidp->numvert,
                                                           olidp->x, olidp->y,olidp->z);
                                                  }
                                               break;
                                               }
                                            }
                                         olidp = olidp->next;
                                         }
                                      if(olidp == NULL)
                                         {
                                         olidc = (struct OverlapIDinstance *) (malloc(sizeof(struct OverlapIDinstance)));
                                         if(olidc == NULL)
                                            {
                                            printf("memory exhausted during unique identifier processing - results will be incomplete\n");
                                            }
                                         else
                                            {
                                            olidc->checknumb = checkinstance;
                                            olidc->idn = PointFromFile.idn;
                                            olidc->lid = tempID;
                                            olidc->Lindex = PointFromFile.Lindex;
                                            olidc->Sindex = PointFromFile.Sindex;
                                            olidc->gform = G_POINT;
                                            if((part1 > 0) && (part2 > 0))
                                               olidc->part = 3;
                                            else if(part1 > 0)
                                               olidc->part = 1;
                                            else
                                               olidc->part = 2;
                                            olidc->numvert = 1;
                                            olidc->x[0] = PointFromFile.x[0];
                                            olidc->y[0] = PointFromFile.y[0];
                                            olidc->z[0] = PointFromFile.z[0];
                                            olidc->x[1] = PointFromFile.x[0];
                                            olidc->y[1] = PointFromFile.y[0];
                                            olidc->z[1] = PointFromFile.z[0];
                                            olidc->next = ID_O[jj].inst;
                                            ID_O[jj].inst = olidc;
                                            }
                                         }
                                      }
                                   }
                                }

/*****/


			       if(
				  (IsDup == 1)   && 
				  (InsertOK > 0) &&
				  (CombinedCheckApplies(PointFromFile.idn,checkinstance,G_DUPS,PointFromFile.Lindex,PointFromFile.Sindex,
							PointFromFile.config,PointFromFile.stratum,PointFromFile.domain,
							&part1,&part2,&part3))  && (part1 > 0) &&
				      (CombinedCheckApplies(RPdup->idn,checkinstance,G_DUPS,RPdup->Lindex,RPdup->Sindex,
				       SCCtable[RPdup->Sindex].C, SCCtable[RPdup->Sindex].S, SCCtable[RPdup->Sindex].D,
							   &part1,&part2,&part3)) && (part2 > 0) 
				  )
				 {
				   
				   if(PointFromFile.numverts == -1) /** dimensionless point feature **/
				     {
				       FwriteTwoObjects(G_DUPS,Make_Correct(G_DUPS,checkinstance), 
							PointFromFile.idn,G_POINT,PointFromFile.Lindex,tempID,PointFromFile.Sindex,PointFromFile.rad,
							PointFromFile.h[0],
							vtxcnt,PointFromFile.x, PointFromFile.y,PointFromFile.z,
							RPdup->idn,G_POINT,RPdup->Lindex,RPdup->localID,RPdup->Sindex,RPdup->rad,RPdup->h[0],vtxcnt,
							RPdup->x, RPdup->y,RPdup->z);
				     }
				   
				   else if(PointFromFile.numverts == 0) /** a stamp model **/
				     {
				       FwriteTwoObjects(G_DUPS,Make_Correct(G_DUPS,checkinstance),
							PointFromFile.idn,G_CYLINDER,PointFromFile.Lindex,tempID,PointFromFile.Sindex,PointFromFile.rad,
							PointFromFile.h[0],
							vtxcnt,PointFromFile.x, PointFromFile.y,PointFromFile.z,
							RPdup->idn,G_CYLINDER,RPdup->Lindex,RPdup->localID,RPdup->Sindex,RPdup->rad,RPdup->h[0],vtxcnt,
							RPdup->x, RPdup->y,RPdup->z);
				     }


				   else if(PointFromFile.numverts == -2) /*** spherical collision volume **/
				     {
				       FwriteTwoObjects(G_DUPS,Make_Correct(G_DUPS,checkinstance),
							PointFromFile.idn,G_CIRCLE,PointFromFile.Lindex,tempID,PointFromFile.Sindex,PointFromFile.rad,
							PointFromFile.h[0],
							vtxcnt,PointFromFile.x,PointFromFile.y,PointFromFile.z,
							RPdup->idn,G_CIRCLE,RPdup->Lindex,RPdup->localID,RPdup->Sindex,RPdup->rad,RPdup->h[0],vtxcnt,
							RPdup->x, RPdup->y,RPdup->z);
				     }

				   else if(PointFromFile.numverts <= -3) /** a parallelpiped collision volume **/
				     {
				       FwriteTwoObjects(G_DUPS,Make_Correct(G_DUPS,checkinstance),
							PointFromFile.idn,G_PIPED,PointFromFile.Lindex,tempID,PointFromFile.Sindex,PointFromFile.rad,
							PointFromFile.h[0],
							vtxcnt,PointFromFile.x, PointFromFile.y,PointFromFile.z,
							RPdup->idn,G_PIPED,RPdup->Lindex,RPdup->localID,RPdup->Sindex,RPdup->rad,RPdup->h[0],vtxcnt,
							RPdup->x, RPdup->y,RPdup->z);
				     }
				   
				   
				   else /** numverts must be >1 for a footprint model ***/
				     {
				       FwriteTwoObjects(G_DUPS,Make_Correct(G_DUPS,checkinstance),
							PointFromFile.idn,G_POLYGON,PointFromFile.Lindex,tempID,PointFromFile.Sindex,PointFromFile.rad,
							PointFromFile.h[0],
							vtxcnt,PointFromFile.x, PointFromFile.y,PointFromFile.z,
							RPdup->idn,G_POLYGON,RPdup->Lindex,RPdup->localID,RPdup->Sindex,RPdup->rad,RPdup->h[0],vtxcnt,
							RPdup->x, RPdup->y,RPdup->z);
				     }
				 }




			     if(
				(IsDup == 4)   && 
				(InsertOK > 0) &&
				(CombinedCheckApplies(PointFromFile.idn,checkinstance,C_DUPS,PointFromFile.Lindex,PointFromFile.Sindex,
						      PointFromFile.config,PointFromFile.stratum,PointFromFile.domain,
						      &part1,&part2,&part3))  && (part1 > 0) &&
				      (CombinedCheckApplies(RPdup->idn,checkinstance,C_DUPS,RPdup->Lindex,RPdup->Sindex,
				       SCCtable[RPdup->Sindex].C, SCCtable[RPdup->Sindex].S, SCCtable[RPdup->Sindex].D,
							   &part1,&part2,&part3)) && (part1 > 0)
				)
			       {
				 if(PointFromFile.numverts == -1) /** dimensionless point feature **/
				   {
				     FwriteTwoObjects(C_DUPS,Make_Correct(C_DUPS,checkinstance),
						      PointFromFile.idn,G_POINT,PointFromFile.Lindex,tempID,PointFromFile.Sindex,PointFromFile.rad,
						      PointFromFile.h[0],
						      vtxcnt,PointFromFile.x, PointFromFile.y,PointFromFile.z,
						      RPdup->idn,G_POINT,RPdup->Lindex,RPdup->localID,RPdup->Sindex,RPdup->rad,RPdup->h[0],vtxcnt,
						      RPdup->x, RPdup->y,RPdup->z);
				   }

				 else if(PointFromFile.numverts == 0) /** a stamp model **/
				   {
				     FwriteTwoObjects(C_DUPS,Make_Correct(C_DUPS,checkinstance),
						      PointFromFile.idn,G_CYLINDER,PointFromFile.Lindex,tempID,PointFromFile.Sindex,PointFromFile.rad,
						      PointFromFile.h[0],
						      vtxcnt,PointFromFile.x, PointFromFile.y,PointFromFile.z,
						      RPdup->idn,G_CYLINDER,RPdup->Lindex,RPdup->localID,RPdup->Sindex,RPdup->rad,RPdup->h[0],vtxcnt,
						      RPdup->x, RPdup->y,RPdup->z);
				   }



				 else if(PointFromFile.numverts == -2) /*** spherical collision volume **/
				   {
				     FwriteTwoObjects(C_DUPS,Make_Correct(C_DUPS,checkinstance),
						      PointFromFile.idn,G_CIRCLE,PointFromFile.Lindex,tempID,PointFromFile.Sindex,PointFromFile.rad,
						      PointFromFile.h[0],
						      vtxcnt,PointFromFile.x,PointFromFile.y,PointFromFile.z,
						      RPdup->idn,G_CIRCLE,RPdup->Lindex,RPdup->localID,RPdup->Sindex,RPdup->rad,RPdup->h[0],vtxcnt,
						      RPdup->x, RPdup->y,RPdup->z);
				   }
				 

				 else if(PointFromFile.numverts <= -3) /** a parallelpiped collision volume **/
				   {
				     FwriteTwoObjects(C_DUPS,Make_Correct(C_DUPS,checkinstance),
						      PointFromFile.idn,G_PIPED,PointFromFile.Lindex,tempID,PointFromFile.Sindex,PointFromFile.rad,
						      PointFromFile.h[0],
						      vtxcnt,PointFromFile.x, PointFromFile.y,PointFromFile.z,
						      RPdup->idn,G_PIPED,RPdup->Lindex,RPdup->localID,RPdup->Sindex,RPdup->rad,RPdup->h[0],vtxcnt,
						      RPdup->x, RPdup->y,RPdup->z);
				   }


				 else /** numverts must be >1 for a footprint model ***/
				   {
				     FwriteTwoObjects(C_DUPS,Make_Correct(C_DUPS,checkinstance),
						      PointFromFile.idn,G_POLYGON,PointFromFile.Lindex,tempID,PointFromFile.Sindex,PointFromFile.rad,
						      PointFromFile.h[0],
						      vtxcnt,PointFromFile.x, PointFromFile.y,PointFromFile.z,
						      RPdup->idn,G_POLYGON,RPdup->Lindex,RPdup->localID,RPdup->Sindex,RPdup->rad,RPdup->h[0],vtxcnt,
						      RPdup->x, RPdup->y,RPdup->z);
				   }
			       }


			       if(NGA_TYPE == 1)
				  {
				  if((IsDup == 2) && (InsertOK > 0) &&
				     (CombinedCheckApplies(PointFromFile.idn,checkinstance,SAMEID,PointFromFile.Lindex,PointFromFile.Sindex,
							PointFromFile.config,PointFromFile.stratum,PointFromFile.domain,
							&part1,&part2,&part3))  && (part1 > 0) &&
				      (CombinedCheckApplies(RPdup->idn,checkinstance,SAMEID,RPdup->Lindex,RPdup->Sindex,
				       SCCtable[RPdup->Sindex].C, SCCtable[RPdup->Sindex].S, SCCtable[RPdup->Sindex].D,
							   &part1,&part2,&part3)) && (part2 > 0))
				     {
				     if(PointFromFile.numverts == -1) /** dimensionless point feature **/
					{
					FwriteTwoObjects(SAMEID,Make_Correct(SAMEID,checkinstance),
							PointFromFile.idn,G_POINT,PointFromFile.Lindex,tempID,PointFromFile.Sindex,PointFromFile.rad,
							PointFromFile.h[0], vtxcnt,PointFromFile.x, PointFromFile.y,PointFromFile.z,
							RPdup->idn,G_POINT,RPdup->Lindex,RPdup->localID,RPdup->Sindex,RPdup->rad,RPdup->h[0],vtxcnt,
							RPdup->x, RPdup->y,RPdup->z);
					}
				     }

				  if((IsDup == 3) && (InsertOK > 0) &&
				     (CombinedCheckApplies(PointFromFile.idn,checkinstance,SAMEID_GDUP,PointFromFile.Lindex,PointFromFile.Sindex,
							PointFromFile.config,PointFromFile.stratum,PointFromFile.domain,
							&part1,&part2,&part3))  && (part1 > 0) &&
				      (CombinedCheckApplies(RPdup->idn,checkinstance,SAMEID_GDUP,RPdup->Lindex,RPdup->Sindex,
				       SCCtable[RPdup->Sindex].C, SCCtable[RPdup->Sindex].S, SCCtable[RPdup->Sindex].D,
							   &part1,&part2,&part3)) && (part2 > 0))
				     {
				     if(PointFromFile.numverts == -1) /** dimensionless point feature **/
					{
					FwriteTwoObjects(SAMEID_GDUP,Make_Correct(SAMEID_GDUP,checkinstance),
							PointFromFile.idn,G_POINT,PointFromFile.Lindex,tempID,PointFromFile.Sindex,PointFromFile.rad,
							PointFromFile.h[0], vtxcnt,PointFromFile.x, PointFromFile.y,PointFromFile.z,
							RPdup->idn,G_POINT,RPdup->Lindex,RPdup->localID,RPdup->Sindex,RPdup->rad,RPdup->h[0],vtxcnt,
							RPdup->x, RPdup->y,RPdup->z);
					}
				     }

				  if((IsDup == 5) && (InsertOK > 0) &&
				   (CombinedCheckApplies(PointFromFile.idn,checkinstance,SAMEID_CDUP,PointFromFile.Lindex,PointFromFile.Sindex,
						      PointFromFile.config,PointFromFile.stratum,PointFromFile.domain,
						      &part1,&part2,&part3))  && (part1 > 0) &&
				      (CombinedCheckApplies(RPdup->idn,checkinstance,SAMEID_CDUP,RPdup->Lindex,RPdup->Sindex,
				       SCCtable[RPdup->Sindex].C, SCCtable[RPdup->Sindex].S, SCCtable[RPdup->Sindex].D,
							   &part1,&part2,&part3)) && (part1 > 0))
				     {
				     if(PointFromFile.numverts == -1) /** dimensionless point feature **/
					{
					FwriteTwoObjects(SAMEID_CDUP,Make_Correct(SAMEID_CDUP,checkinstance),
						      PointFromFile.idn,G_POINT,PointFromFile.Lindex,tempID,PointFromFile.Sindex,PointFromFile.rad,
						      PointFromFile.h[0], vtxcnt,PointFromFile.x, PointFromFile.y,PointFromFile.z,
						      RPdup->idn,G_POINT,RPdup->Lindex,RPdup->localID,RPdup->Sindex,RPdup->rad,RPdup->h[0],vtxcnt,
						      RPdup->x, RPdup->y,RPdup->z);
					}
				     }
				  }

			     
			     if((IsDup < UseDupThreshold) && (InsertOK))
			       {
				 if((CombinedCheckApplies(PointFromFile.idn,checkinstance,ATTRERR,PointFromFile.Lindex,PointFromFile.Sindex,
							 PointFromFile.config,PointFromFile.stratum,PointFromFile.domain,
							 &part1,&part2,&part3)) && (part1 > 0))
				   {
				     if(CrsWlk[PointFromFile.Lindex].AttrErr >= 0)
				       {

					 if(PointFromFile.numverts == -1) /** dimensionless point feature **/
					   {
					     FwriteObjectAndMessage(ATTRERR,Make_Correct(ATTRERR,checkinstance),
								    PointFromFile.idn, G_POINT,RPc->Lindex,RPc->localID,
								    PointFromFile.Sindex,PointFromFile.rad,PointFromFile.h[0],
								    PointFromFile.x,
								    PointFromFile.y,PointFromFile.z,vtxcnt,
								    AttrErr[CrsWlk[PointFromFile.Lindex].AttrErr].description);
					   }
					 
					 else if(PointFromFile.numverts == 0) /** a stamp model **/
					   {
					     FwriteObjectAndMessage(ATTRERR,Make_Correct(ATTRERR,checkinstance),
								    PointFromFile.idn, G_CYLINDER,RPc->Lindex,RPc->localID,
								    PointFromFile.Sindex,PointFromFile.rad,PointFromFile.h[0],
								    PointFromFile.x,
								    PointFromFile.y,PointFromFile.z,vtxcnt,
								    AttrErr[CrsWlk[PointFromFile.Lindex].AttrErr].description);
					   }
					 
					 
					 else if(PointFromFile.numverts == -2) /*** spherical collision volume **/
					   {
					     FwriteObjectAndMessage(ATTRERR,Make_Correct(ATTRERR,checkinstance),
								    PointFromFile.idn, G_CIRCLE,RPc->Lindex,RPc->localID,
								    PointFromFile.Sindex,PointFromFile.rad,PointFromFile.h[0],
								    PointFromFile.x,
								    PointFromFile.y,PointFromFile.z,vtxcnt,
								    AttrErr[CrsWlk[PointFromFile.Lindex].AttrErr].description);
					   }
					 
					 
					 else if(PointFromFile.numverts <= -3) /** a parallelpiped collision volume **/
					   {
					     FwriteObjectAndMessage(ATTRERR,Make_Correct(ATTRERR,checkinstance),
								    PointFromFile.idn, G_PIPED,RPc->Lindex,RPc->localID,
								    PointFromFile.Sindex,PointFromFile.rad,PointFromFile.h[0],
								    PointFromFile.x,
								    PointFromFile.y,PointFromFile.z,vtxcnt,
								    AttrErr[CrsWlk[PointFromFile.Lindex].AttrErr].description);
					   }
					 
					 else /** numverts must be >1 for a footprint model ***/
					   {
					     FwriteObjectAndMessage(ATTRERR,Make_Correct(ATTRERR,checkinstance),
								    PointFromFile.idn, G_POLYGON,RPc->Lindex,RPc->localID,
								    PointFromFile.Sindex,PointFromFile.rad,PointFromFile.h[0],
								    PointFromFile.x,
								    PointFromFile.y,PointFromFile.z,vtxcnt,
								    AttrErr[CrsWlk[PointFromFile.Lindex].AttrErr].description);
					   }
				       }
				   }
			       }
			     }  /*** for(checkinstance = 0; checkinstance < TtlActiveChecks; checkinstance++) ****/
			  }
		       ++i;
		       if(abortNow > 0)
			  break;
		       }
		    k = PointTable[compositeindex].numinside;
		    if(k > 0)
		       {
		       filedecimal = 0.1;

		       fseek(ptsin,PointTable[compositeindex].fileptr,SEEK_SET);
		       i = 0;
		       while(i < k)
			  {
			  fo = ftell(ptsin);
			  vtxcnt = ReadPointFromFile(ptsin, multiplier);


			  OKtoUse = 1;
			  if((NGA_TYPE == 0) && (NumLODbands > 0))
			     {
			     jj = CrsWlk[PointFromFile.Lindex].LODband;
			     if((jj > 0) && (LODindex[jj-1].active < 1))
				OKtoUse = 0;
			     }


			  if((OKtoUse > 0) && (CheckByStratum[PointFromFile.stratum] > 0) &&
			     (CheckByDomain[PointFromFile.domain] > 0))
			     {
                             if((CombinedCheckApplies(PointFromFile.idn,-1,-1,PointFromFile.Lindex,PointFromFile.Sindex,
                                                           PointFromFile.config,PointFromFile.stratum,PointFromFile.domain,
                                                           &part1,&part2,&part3)) && ((part1 > 0) || (part2 > 0) || (part3 > 0)))
                                {
			        NumObjects[PointFromFile.config] += 1.0;
                                mpoc = MultiPointRoot;
                                while(mpoc != NULL)
                                   {
                                   if(mpoc->featureid == PointFromFile.idn)
                                      {
                                      mpoc->counted += 1;
                                      break;
                                      }
                                   mpoc = mpoc->next;
                                   }
                                }

                             if((ATTRTYPE_TREX() == 1) && (SCCtable[PointFromFile.Sindex].ECC == ZB060code))
                                IsDup = 0;
                             else
			        RPdup = CheckPointDuplication(PointFromFile,RProot,&IsDup);
			     if(IsDup >= UseDupThreshold)
				{
				tempID = fo + filedecimal;
				}
			     for(checkinstance = 0; checkinstance < TtlActiveChecks; checkinstance++)
				{

				  if((IsDup < UseDupThreshold) && (checkinstance==0))  /* the &&(checkinstance==0) was added for speed */
				   {
				   if((PointFromFile.numverts < 1) && (PointFromFile.numverts > -3))
				      vtxcnt = 1;
				   else if(PointFromFile.numverts < -2)
				      vtxcnt = 0 - PointFromFile.numverts;
				   else
				      vtxcnt = PointFromFile.numverts;
				   RPc = (struct RawPoint *) (malloc(SzRP));
				   if(RPc == NULL)
				      {
				      printf("allocation memory exhausted during point data read\n");
				      printf("processing cannot continue\n");
				      exit(-1);
				      }
				/***strcpy(&RPc->pname[0],&PointFromFile.pname[0]);***/
				   RPc->numverts = PointFromFile.numverts;
				   RPc->Lindex = PointFromFile.Lindex;
				   RPc->Sindex = PointFromFile.Sindex;
				   RPc->idn = PointFromFile.idn;
                                   RPc->areaattr = PointFromFile.areaattr;
                                   RPc->hgtattr = PointFromFile.hgtattr;
                                   RPc->zv2attr = PointFromFile.zv2attr;
                                   RPc->lenattr = PointFromFile.lenattr;
                                   RPc->namattr = PointFromFile.namattr;
                                   if(PointFromFile.areastr[0] == '\0')
                                      RPc->areastr = NULL;
                                   else
                                      {
                                      RPc->areastr = (char *) (malloc(strlen(PointFromFile.areastr) + 2));
                                      if(RPc->areastr != NULL)
                                         strcpy(RPc->areastr,PointFromFile.areastr);
                                      }
                                   if(PointFromFile.hgtstr[0] == '\0')
                                      RPc->hgtstr = NULL;
                                   else
                                      {
                                      RPc->hgtstr = (char *) (malloc(strlen(PointFromFile.hgtstr) + 2));
                                      if(RPc->hgtstr != NULL)
                                         strcpy(RPc->hgtstr,PointFromFile.hgtstr);
                                      }
                                   if(PointFromFile.zv2str[0] == '\0')
                                      RPc->zv2str = NULL;
                                   else
                                      {
                                      RPc->zv2str = (char *) (malloc(strlen(PointFromFile.zv2str) + 2));
                                      if(RPc->zv2str != NULL)
                                         strcpy(RPc->zv2str,PointFromFile.zv2str);
                                      }
                                   if(PointFromFile.lenstr[0] == '\0')
                                      RPc->lenstr = NULL;
                                   else
                                      {
                                      RPc->lenstr = (char *) (malloc(strlen(PointFromFile.lenstr) + 2));
                                      if(RPc->lenstr != NULL)
                                         strcpy(RPc->lenstr,PointFromFile.lenstr);
                                      }
                                   if(PointFromFile.namstr[0] == '\0')
                                      RPc->namstr = NULL;
                                   else
                                      {
                                      RPc->namstr = (char *) (malloc(strlen(PointFromFile.namstr) + 2));
                                      if(RPc->namstr != NULL)
                                         strcpy(RPc->namstr,PointFromFile.namstr);
                                      }
				   RPc->rad = PointFromFile.rad;
				   tempID = RPc->localID = fo + filedecimal;
RPc->featureid = PointFromFile.idn;
				   RPc->next = NULL;
				   RPc->h = (double *) malloc(SzD * vtxcnt);
				   RPc->x = (double *) malloc(SzD * vtxcnt);
				   RPc->y = (double *) malloc(SzD * vtxcnt);
				   RPc->z = (double *) malloc(SzD * vtxcnt);
				   if((RPc->h == NULL) || (RPc->x == NULL) || (RPc->y == NULL) || (RPc->z == NULL))
				      {
				      printf("allocation memory exhausted during point data read\n");
				      printf("processing cannot continue\n");
				      exit(-1);
				      }
				   for(jj = 0; jj<vtxcnt; jj++)
				      {
				      RPc->h[jj] = PointFromFile.h[jj];
				      RPc->x[jj] = PointFromFile.x[jj];
				      RPc->y[jj] = PointFromFile.y[jj];
				      RPc->z[jj] = PointFromFile.z[jj];
				      }
				   RPc->next = RProot;
				   RProot = RPc;
				   }


			     if((IsDup < UseDupThreshold) && (PointFromFile.numverts == -1) &&
			      (CombinedCheckApplies(PointFromFile.idn,checkinstance,MULTIPARTP,PointFromFile.Lindex,PointFromFile.Sindex,
						     PointFromFile.config,PointFromFile.stratum,PointFromFile.domain,
						     &part1,&part2,&part3) && (part1 > 0)))
			       {
			       mpoc = MultiPointRoot;
			       kkk = 0; 
			       while(mpoc != NULL) 
				  {        
				  if((mpoc->featureid == PointFromFile.idn) && (mpoc->used == 0))
				     ++kkk;
				  mpoc = mpoc->next;
				  }        
			       if(SensitivityCheck(GT, MULTIPARTP, checkinstance, (double) kkk) > 0)
				  {
				  mpoc = MultiPointRoot;
				  while(mpoc != NULL) 
				     {        
				     if(mpoc->featureid == PointFromFile.idn)
					{
					mpoc->used = 1;
					FwriteObjectAndMagnitude(MULTIPARTP,Make_Correct(MULTIPARTP,checkinstance),
							    PointFromFile.idn,
							    PointFromFile.Sindex,G_POINT,RPc->Lindex,RPc->localID,-1.0,-1.0,(double) kkk,
							    &mpoc->x[0], &mpoc->y[0], &mpoc->z[0], 1, 1);
					}
				     mpoc = mpoc->next;
				     }
				  }
			       }


                             if(ID_O_count > 0)
                                {
                                part1 = 0;
                                if((NGA_TYPE > 0) && 
                                   ((IsDup == 2) || (IsDup == 3) || (IsDup == 5)) && (PointFromFile.idn != RPdup->idn) &&
                                     (CombinedCheckApplies(PointFromFile.idn,checkinstance,ANY_SAMEID,PointFromFile.Lindex,PointFromFile.Sindex,
                                                      PointFromFile.config,PointFromFile.stratum,PointFromFile.domain,
                                                      &part1,&part2,&part3))  && (part1 > 0) &&
                                         (CombinedCheckApplies(RPdup->idn,checkinstance,ANY_SAMEID,RPdup->Lindex,RPdup->Sindex,
                                          SCCtable[RPdup->Sindex].C, SCCtable[RPdup->Sindex].S, SCCtable[RPdup->Sindex].D,
                                                           &part1,&part2,&part3)) && (part2 > 0))
                                   {
                                   if(PointFromFile.numverts == -1) 
                                      {
                                      FwriteTwoObjects(ANY_SAMEID,Make_Correct(ANY_SAMEID,checkinstance),
                                                        PointFromFile.idn,G_POINT,PointFromFile.Lindex,tempID,PointFromFile.Sindex,-1.0,-1.0,
                                                        1,PointFromFile.x, PointFromFile.y,PointFromFile.z,
                                                        RPdup->idn,G_POINT,RPdup->Lindex,RPdup->localID,RPdup->Sindex,-1.0,-1.0,1,
                                                        RPdup->x, RPdup->y,RPdup->z);
/***/
                                      }
                                   }
                                else if((NGA_TYPE > 0) && (IsDup != 4) &&
                                       (CombinedCheckApplies(PointFromFile.idn,checkinstance,ANY_SAMEID,PointFromFile.Lindex,PointFromFile.Sindex,
                                                      PointFromFile.config,PointFromFile.stratum,PointFromFile.domain,
                                                      &part1,&part2,&part3)) &&
                                        ((part1 > 0) || (part2 > 0)))
                                   {
                                   GetAppropIDnumber(PointFromFile.idn, &tempstring[0]);
                                   jj = GetUUIDindex(tempstring);
                                   if(jj >= 0)
                                      {
                                      olidp = ID_O[jj].inst;
                                      while(olidp != NULL)
                                         {
                                         if(/***/(olidp->idn != PointFromFile.idn) && /***/ (olidp->checknumb == checkinstance))
                                            {
                                            if((part1 > 0) && (olidp->part > 1))
                                               {
                                               if(PointFromFile.numverts == -1) 
                                                  {
                                                  FwriteTwoObjects(ANY_SAMEID,Make_Correct(ANY_SAMEID,checkinstance),
                                                        PointFromFile.idn,G_POINT,PointFromFile.Lindex,tempID,PointFromFile.Sindex,-1.0,-1.0,
                                                        1,PointFromFile.x, PointFromFile.y,PointFromFile.z,
                                                        olidp->idn,olidp->gform,olidp->Lindex,olidp->lid,olidp->Sindex,-1.0,-1.0,olidp->numvert,
                                                        olidp->x, olidp->y,olidp->z);
                                                  }
                                               break;
                                               }
                                            else if((part2 > 0) && ((olidp->part == 1) || (olidp->part == 3)))
                                               {
                                               if(PointFromFile.numverts == -1) 
                                                  {
                                                  FwriteTwoObjects(ANY_SAMEID,Make_Correct(ANY_SAMEID,checkinstance),
                                                           PointFromFile.idn,G_POINT,PointFromFile.Lindex,tempID,PointFromFile.Sindex,-1.0,-1.0,
                                                           1,PointFromFile.x, PointFromFile.y,PointFromFile.z,
                                                           olidp->idn,olidp->gform,olidp->Lindex,olidp->lid,olidp->Sindex,-1.0,-1.0,olidp->numvert,
                                                           olidp->x, olidp->y,olidp->z);
                                                  }
                                               break;
                                               }
                                            }
                                         olidp = olidp->next;
                                         }
                                      if(olidp == NULL)
                                         {
                                         olidc = (struct OverlapIDinstance *) (malloc(sizeof(struct OverlapIDinstance)));
                                         if(olidc == NULL)
                                            {
                                            printf("memory exhausted during unique identifier processing - results will be incomplete\n");
                                            }
                                         else
                                            {
                                            olidc->checknumb = checkinstance;
                                            olidc->idn = PointFromFile.idn;
                                            olidc->lid = tempID;
                                            olidc->Lindex = PointFromFile.Lindex;
                                            olidc->Sindex = PointFromFile.Sindex;
                                            olidc->gform = G_POINT;
                                            if((part1 > 0) && (part2 > 0))
                                               olidc->part = 3;
                                            else if(part1 > 0)
                                               olidc->part = 1;
                                            else
                                               olidc->part = 2;
                                            olidc->numvert = 1;
                                            olidc->x[0] = PointFromFile.x[0];
                                            olidc->y[0] = PointFromFile.y[0];
                                            olidc->z[0] = PointFromFile.z[0];
                                            olidc->x[1] = PointFromFile.x[0];
                                            olidc->y[1] = PointFromFile.y[0];
                                            olidc->z[1] = PointFromFile.z[0];
                                            olidc->next = ID_O[jj].inst;
                                            ID_O[jj].inst = olidc;
                                               }
                                         }
   /**********/
                                      }
                                   }
                                }



				  if(
				     (IsDup == 1)   &&
				     (CombinedCheckApplies(PointFromFile.idn,checkinstance,G_DUPS,PointFromFile.Lindex,PointFromFile.Sindex,
							   PointFromFile.config,PointFromFile.stratum,PointFromFile.domain,
							   &part1,&part2,&part3))  && (part1 > 0) &&
				      (CombinedCheckApplies(RPdup->idn,checkinstance,G_DUPS,RPdup->Lindex,RPdup->Sindex,
				       SCCtable[RPdup->Sindex].C, SCCtable[RPdup->Sindex].S, SCCtable[RPdup->Sindex].D,
							   &part1,&part2,&part3) && (part2 > 0))
				     )
				    {
				      if(PointFromFile.numverts == -1) /** dimensionless point feature **/
					{
					  FwriteTwoObjects(G_DUPS,Make_Correct(G_DUPS,checkinstance),
							   PointFromFile.idn,G_POINT,PointFromFile.Lindex,tempID,PointFromFile.Sindex,PointFromFile.rad,PointFromFile.h[0],
							   vtxcnt,PointFromFile.x, PointFromFile.y,PointFromFile.z,
							   RPdup->idn,G_POINT,RPdup->Lindex,RPdup->localID,RPdup->Sindex,RPdup->rad,RPdup->h[0],vtxcnt,RPdup->x, RPdup->y,RPdup->z);
					}
				      else if(PointFromFile.numverts == 0) /** a stamp model **/
					{
					  FwriteTwoObjects(G_DUPS,Make_Correct(G_DUPS,checkinstance),
							   PointFromFile.idn,G_CYLINDER,PointFromFile.Lindex,tempID,PointFromFile.Sindex,PointFromFile.rad,PointFromFile.h[0],
							   vtxcnt,PointFromFile.x, PointFromFile.y,PointFromFile.z,
							   RPdup->idn,G_CYLINDER,RPdup->Lindex,RPdup->localID,RPdup->Sindex,RPdup->rad,RPdup->h[0],vtxcnt,RPdup->x, RPdup->y,RPdup->z);
					}
				      else if(PointFromFile.numverts == -2) /*** spherical collision volume **/
					{
					  FwriteTwoObjects(G_DUPS,Make_Correct(G_DUPS,checkinstance),
							   PointFromFile.idn,G_CIRCLE,PointFromFile.Lindex,tempID,PointFromFile.Sindex,PointFromFile.rad,PointFromFile.h[0],
							   vtxcnt,PointFromFile.x,PointFromFile.y,PointFromFile.z,
							   RPdup->idn,G_CIRCLE,RPdup->Lindex,RPdup->localID,RPdup->Sindex,RPdup->rad,RPdup->h[0],vtxcnt,RPdup->x, RPdup->y,RPdup->z);
					}
				      else if(PointFromFile.numverts <= -3) /** a parallelpiped collision volume **/
					{
					  FwriteTwoObjects(G_DUPS,Make_Correct(G_DUPS,checkinstance),
							   PointFromFile.idn,G_PIPED,PointFromFile.Lindex,tempID,PointFromFile.Sindex,PointFromFile.rad,PointFromFile.h[0],
							   vtxcnt,PointFromFile.x, PointFromFile.y,PointFromFile.z,
							   RPdup->idn,G_PIPED,RPdup->Lindex,RPdup->localID,RPdup->Sindex,RPdup->rad,RPdup->h[0],vtxcnt,RPdup->x, RPdup->y,RPdup->z);
					}
				      else /** numverts must be >1 for a footprint model ***/
					{
					  FwriteTwoObjects(G_DUPS,Make_Correct(G_DUPS,checkinstance),
							   PointFromFile.idn,G_POLYGON,PointFromFile.Lindex,tempID,PointFromFile.Sindex,PointFromFile.rad,PointFromFile.h[0],
							   vtxcnt,PointFromFile.x, PointFromFile.y,PointFromFile.z,
							   RPdup->idn,G_POLYGON,RPdup->Lindex,RPdup->localID,RPdup->Sindex,RPdup->rad,RPdup->h[0],vtxcnt,RPdup->x, RPdup->y,RPdup->z);
					}
				    }
				  if((IsDup == 4) &&
				     (CombinedCheckApplies(PointFromFile.idn,checkinstance,C_DUPS,PointFromFile.Lindex,PointFromFile.Sindex,PointFromFile.config,
							   PointFromFile.stratum,PointFromFile.domain,&part1,&part2,&part3)) && (part1 > 0) &&
				      (CombinedCheckApplies(RPdup->idn,checkinstance,C_DUPS,RPdup->Lindex,RPdup->Sindex,
				       SCCtable[RPdup->Sindex].C, SCCtable[RPdup->Sindex].S, SCCtable[RPdup->Sindex].D,
							   &part1,&part2,&part3) && (part1 > 0))
				       )
				    {
				      if(PointFromFile.numverts == -1) /** dimensionless point feature **/
					{
					  FwriteTwoObjects(C_DUPS,Make_Correct(C_DUPS,checkinstance),
							   PointFromFile.idn,G_POINT,PointFromFile.Lindex,tempID,PointFromFile.Sindex,PointFromFile.rad,PointFromFile.h[0],
							   vtxcnt,PointFromFile.x, PointFromFile.y,PointFromFile.z,
							   RPdup->idn,G_POINT,RPdup->Lindex,RPdup->localID,RPdup->Sindex,RPdup->rad,RPdup->h[0],vtxcnt,RPdup->x, RPdup->y,RPdup->z);
					}
				      else if(PointFromFile.numverts == 0) /** a stamp model **/
					{
					  FwriteTwoObjects(C_DUPS,Make_Correct(C_DUPS,checkinstance),
							   PointFromFile.idn,G_CYLINDER,PointFromFile.Lindex,tempID,PointFromFile.Sindex,PointFromFile.rad,PointFromFile.h[0],
							   vtxcnt,PointFromFile.x, PointFromFile.y,PointFromFile.z,
							   RPdup->idn,G_CYLINDER,RPdup->Lindex,RPdup->localID,RPdup->Sindex,RPdup->rad,RPdup->h[0],vtxcnt,RPdup->x, RPdup->y,RPdup->z);
					}
				      else if(PointFromFile.numverts == -2) /*** spherical collision volume **/
					{
					  FwriteTwoObjects(C_DUPS, Make_Correct(C_DUPS,checkinstance),
							   PointFromFile.idn,G_CIRCLE,PointFromFile.Lindex,tempID,PointFromFile.Sindex,PointFromFile.rad,PointFromFile.h[0],
							   vtxcnt,PointFromFile.x,PointFromFile.y,PointFromFile.z,
							   RPdup->idn,G_CIRCLE,RPdup->Lindex,RPdup->localID,RPdup->Sindex,RPdup->rad,RPdup->h[0],vtxcnt,RPdup->x, RPdup->y,RPdup->z);
					}
				      else if(PointFromFile.numverts <= -3) /** a parallelpiped collision volume **/
					{
					  FwriteTwoObjects(C_DUPS, Make_Correct(C_DUPS,checkinstance),
							   PointFromFile.idn,G_PIPED,PointFromFile.Lindex,tempID,PointFromFile.Sindex,PointFromFile.rad,PointFromFile.h[0],
							   vtxcnt,PointFromFile.x, PointFromFile.y,PointFromFile.z,
							   RPdup->idn,G_PIPED,RPdup->Lindex,RPdup->localID,RPdup->Sindex,RPdup->rad,RPdup->h[0],vtxcnt,RPdup->x, RPdup->y,RPdup->z);
					}
				      else /** numverts must be >1 for a footprint model ***/
					{
					  FwriteTwoObjects(C_DUPS, Make_Correct(C_DUPS,checkinstance),
							   PointFromFile.idn,G_POLYGON,PointFromFile.Lindex,tempID,PointFromFile.Sindex,PointFromFile.rad,PointFromFile.h[0],
							   vtxcnt,PointFromFile.x, PointFromFile.y,PointFromFile.z,
							   RPdup->idn,G_POLYGON,RPdup->Lindex,RPdup->localID,RPdup->Sindex,RPdup->rad,RPdup->h[0],vtxcnt,RPdup->x, RPdup->y,RPdup->z);
					}
				    }

			       if(NGA_TYPE == 1)
				  {
				  if((IsDup == 2) && 
				     (CombinedCheckApplies(PointFromFile.idn,checkinstance,SAMEID,PointFromFile.Lindex,PointFromFile.Sindex,
							PointFromFile.config,PointFromFile.stratum,PointFromFile.domain,
							&part1,&part2,&part3))  && (part1 > 0) &&
				      (CombinedCheckApplies(RPdup->idn,checkinstance,SAMEID,RPdup->Lindex,RPdup->Sindex,
				       SCCtable[RPdup->Sindex].C, SCCtable[RPdup->Sindex].S, SCCtable[RPdup->Sindex].D,
							   &part1,&part2,&part3)) && (part2 > 0))
				     {
				     if(PointFromFile.numverts == -1) /** dimensionless point feature **/
					{
					FwriteTwoObjects(SAMEID,Make_Correct(SAMEID,checkinstance),
							PointFromFile.idn,G_POINT,PointFromFile.Lindex,tempID,PointFromFile.Sindex,PointFromFile.rad,
							PointFromFile.h[0], vtxcnt,PointFromFile.x, PointFromFile.y,PointFromFile.z,
							RPdup->idn,G_POINT,RPdup->Lindex,RPdup->localID,RPdup->Sindex,RPdup->rad,RPdup->h[0],vtxcnt,
							RPdup->x, RPdup->y,RPdup->z);
					}
				     }

				  if((IsDup == 3) &&
				     (CombinedCheckApplies(PointFromFile.idn,checkinstance,SAMEID_GDUP,PointFromFile.Lindex,PointFromFile.Sindex,
							PointFromFile.config,PointFromFile.stratum,PointFromFile.domain,
							&part1,&part2,&part3))  && (part1 > 0) &&
				      (CombinedCheckApplies(RPdup->idn,checkinstance,SAMEID_GDUP,RPdup->Lindex,RPdup->Sindex,
				       SCCtable[RPdup->Sindex].C, SCCtable[RPdup->Sindex].S, SCCtable[RPdup->Sindex].D,
							   &part1,&part2,&part3)) && (part2 > 0))
				     {
				     if(PointFromFile.numverts == -1) /** dimensionless point feature **/
					{
					FwriteTwoObjects(SAMEID_GDUP,Make_Correct(SAMEID_GDUP,checkinstance),
							PointFromFile.idn,G_POINT,PointFromFile.Lindex,tempID,PointFromFile.Sindex,PointFromFile.rad,
							PointFromFile.h[0], vtxcnt,PointFromFile.x, PointFromFile.y,PointFromFile.z,
							RPdup->idn,G_POINT,RPdup->Lindex,RPdup->localID,RPdup->Sindex,RPdup->rad,RPdup->h[0],vtxcnt,
							RPdup->x, RPdup->y,RPdup->z);
					}
				     }

				  if((IsDup == 5) &&
				   (CombinedCheckApplies(PointFromFile.idn,checkinstance,SAMEID_CDUP,PointFromFile.Lindex,PointFromFile.Sindex,
						      PointFromFile.config,PointFromFile.stratum,PointFromFile.domain,
						      &part1,&part2,&part3))  && (part1 > 0) &&
				      (CombinedCheckApplies(RPdup->idn,checkinstance,SAMEID_CDUP,RPdup->Lindex,RPdup->Sindex,
				       SCCtable[RPdup->Sindex].C, SCCtable[RPdup->Sindex].S, SCCtable[RPdup->Sindex].D,
							   &part1,&part2,&part3)) && (part1 > 0))
				     {
				     if(PointFromFile.numverts == -1) /** dimensionless point feature **/
					{
					FwriteTwoObjects(SAMEID_CDUP,Make_Correct(SAMEID_CDUP,checkinstance),
						      PointFromFile.idn,G_POINT,PointFromFile.Lindex,tempID,PointFromFile.Sindex,PointFromFile.rad,
						      PointFromFile.h[0], vtxcnt,PointFromFile.x, PointFromFile.y,PointFromFile.z,
						      RPdup->idn,G_POINT,RPdup->Lindex,RPdup->localID,RPdup->Sindex,RPdup->rad,RPdup->h[0],vtxcnt,
						      RPdup->x, RPdup->y,RPdup->z);
					}
				     }
				  }

				  if(IsDup < UseDupThreshold) 
				    {
				      if((CombinedCheckApplies(PointFromFile.idn,checkinstance,ATTRERR,PointFromFile.Lindex,PointFromFile.Sindex,PointFromFile.config,
							      PointFromFile.stratum,PointFromFile.domain,&part1,&part2,&part3)) && (part1 > 0))
					{
					  if(CrsWlk[PointFromFile.Lindex].AttrErr >= 0)
					    {
					      if(PointFromFile.numverts == -1) /** dimensionless point feature **/
						{
						  FwriteObjectAndMessage(ATTRERR, Make_Correct(ATTRERR,checkinstance),
									 PointFromFile.idn, G_POINT,RPc->Lindex,RPc->localID,
									 PointFromFile.Sindex,PointFromFile.rad,PointFromFile.h[0],PointFromFile.x,
									 PointFromFile.y,PointFromFile.z,vtxcnt,
									 AttrErr[CrsWlk[PointFromFile.Lindex].AttrErr].description);
						}
					      else if(PointFromFile.numverts == 0) /** a stamp model **/
						{
						  FwriteObjectAndMessage(ATTRERR, Make_Correct(ATTRERR,checkinstance),
									 PointFromFile.idn, G_CYLINDER,RPc->Lindex,RPc->localID,
									 PointFromFile.Sindex,PointFromFile.rad,PointFromFile.h[0],PointFromFile.x,
									 PointFromFile.y,PointFromFile.z,vtxcnt,
									 AttrErr[CrsWlk[PointFromFile.Lindex].AttrErr].description);
						}
					      else if(PointFromFile.numverts == -2) /*** spherical collision volume **/
						{
						  FwriteObjectAndMessage(ATTRERR, Make_Correct(ATTRERR,checkinstance),
									 PointFromFile.idn, G_CIRCLE,RPc->Lindex,RPc->localID,
									 PointFromFile.Sindex,PointFromFile.rad,PointFromFile.h[0],PointFromFile.x,
									 PointFromFile.y,PointFromFile.z,vtxcnt,
									 AttrErr[CrsWlk[PointFromFile.Lindex].AttrErr].description);
						}
					      else if(PointFromFile.numverts <= -3) /** a parallelpiped collision volume **/
						{
						  FwriteObjectAndMessage(ATTRERR, Make_Correct(ATTRERR,checkinstance),
									 PointFromFile.idn, G_PIPED,RPc->Lindex,RPc->localID,
									 PointFromFile.Sindex,PointFromFile.rad,PointFromFile.h[0],PointFromFile.x,
									 PointFromFile.y,PointFromFile.z,vtxcnt,
									 AttrErr[CrsWlk[PointFromFile.Lindex].AttrErr].description);
						}
					      else /** numverts must be >1 for a footprint model ***/
						{
						  FwriteObjectAndMessage(ATTRERR, Make_Correct(ATTRERR,checkinstance),
									 PointFromFile.idn, G_POLYGON,RPc->Lindex,RPc->localID,
									 PointFromFile.Sindex,PointFromFile.rad,PointFromFile.h[0],PointFromFile.x,
									 PointFromFile.y,PointFromFile.z,vtxcnt,
									 AttrErr[CrsWlk[PointFromFile.Lindex].AttrErr].description);
						}
					    }
					}
				    }
				}  /**** for(checkinstance = 0; checkinstance < TtlActiveChecks; checkinstance++) ****/
			     }
			  ++i;
			  if(abortNow > 0)
			     break;
			  }
		       }
		    
		    } /*** finished with all the point checks ***/


	/******* bridge checks begin here ****/
		 if((NGA_TYPE == 0) && (abortNow ==0) && (brdgin != NULL) && (CheckByConfig[3] > 0))
		    {
		    for(i=0; i<BridgeTable[compositeindex].numother; i++)
		       {
		       InsertOK = InsertIntoLongList(BridgeTable[compositeindex].others[i].fileptr,0,skiplimit,
					  &BridgeLongListRoot,LongBridgeSkipList,&SkipEntry);
		       fseek(brdgin,BridgeTable[compositeindex].others[i].fileptr,SEEK_SET);
		       j = ReadBridgeFromFile(brdgin, multiplier);

		       filedecimal = (double) BridgeTable[compositeindex].others[i].fileptr + 0.1;

		       OKtoUse = 1;
		       if(NumLODbands > 0)
			  {
			  jj = CrsWlk[BridgeFromFile.Lindex].LODband;
			  if((jj > 0) && (LODindex[jj-1].active < 1))
			     OKtoUse = 0;
			  }

		       if((OKtoUse > 0) && (CheckByStratum[BridgeFromFile.stratum] > 0) &&
				(CheckByDomain[BridgeFromFile.domain] > 0))
			  {
			  if(InsertOK)
			     NumObjects[BridgeFromFile.config] += 1.0;
			  RBdup = CheckBridgeDuplication(BridgeFromFile,RBroot, &IsDup);
			  if(IsDup < UseDupThreshold)
			     {
			     RBc = AddObjectToBridgeList(SzRB, BridgeFromFile.Bindex, BridgeFromFile.Lindex, BridgeFromFile.Sindex,
						     BridgeFromFile.numverts, BridgeFromFile.idn, BridgeFromFile.x,
						     BridgeFromFile.y, BridgeFromFile.z, BridgeFromFile.h,filedecimal);

			     RBc->next = RBroot;
			     RBroot = RBc;
			     }
			  for(checkinstance = 0; checkinstance < TtlActiveChecks; checkinstance++)
			     {
			     if((IsDup == 1) && (InsertOK > 0) &&
				 (CombinedCheckApplies(BridgeFromFile.idn,checkinstance,G_DUPS,BridgeFromFile.Lindex,BridgeFromFile.Sindex,BridgeFromFile.config,
					 BridgeFromFile.stratum,BridgeFromFile.domain,&part1,&part2,&part3)) && (part1 > 0) &&
				      (CombinedCheckApplies(RBdup->idn,checkinstance,G_DUPS,RBdup->Lindex,RBdup->Sindex,
				       SCCtable[RBdup->Sindex].C, SCCtable[RBdup->Sindex].S, SCCtable[RBdup->Sindex].D,
							   &part1,&part2,&part3) && (part2 > 0))
				  )
				{
				FwriteTwoObjects(G_DUPS, Make_Correct(G_DUPS,checkinstance),
				      BridgeFromFile.idn,G_POLYGON,BridgeFromFile.Lindex,
				      filedecimal,BridgeFromFile.Sindex,-1.0,-1.0,BridgeFromFile.numverts,BridgeFromFile.x,
				      BridgeFromFile.y,BridgeFromFile.z,
				      RBdup->idn,G_POLYGON,RBdup->Lindex,RBdup->localID,RBdup->Sindex,-1.0,-1.0,RBdup->numverts,RBdup->x, RBdup->y,RBdup->z);
				}
			     if((IsDup == 4) && (InsertOK > 0) &&
				 (CombinedCheckApplies(BridgeFromFile.idn,checkinstance,C_DUPS,BridgeFromFile.Lindex,BridgeFromFile.Sindex,BridgeFromFile.config,
				      BridgeFromFile.stratum,BridgeFromFile.domain,&part1,&part2,&part3))  && (part1 > 0)  &&
				      (CombinedCheckApplies(RBdup->idn,checkinstance,C_DUPS,RBdup->Lindex,RBdup->Sindex,
				       SCCtable[RBdup->Sindex].C, SCCtable[RBdup->Sindex].S, SCCtable[RBdup->Sindex].D,
							   &part1,&part2,&part3) && (part1 > 0))
				  )
				{
				FwriteTwoObjects(C_DUPS, Make_Correct(C_DUPS,checkinstance),
				      BridgeFromFile.idn,G_POLYGON,BridgeFromFile.Lindex,
				      filedecimal,BridgeFromFile.Sindex,-1.0,-1.0,BridgeFromFile.numverts,BridgeFromFile.x,
				      BridgeFromFile.y,BridgeFromFile.z,
				      RBdup->idn,G_POLYGON,RBdup->Lindex,RBdup->localID,RBdup->Sindex,-1.0,-1.0,RBdup->numverts,RBdup->x, RBdup->y,RBdup->z);
				}
			     if((IsDup < UseDupThreshold) && (InsertOK))
				{
				if((CombinedCheckApplies(BridgeFromFile.idn,checkinstance,ATTRERR,BridgeFromFile.Lindex,BridgeFromFile.Sindex,BridgeFromFile.config,
				      BridgeFromFile.stratum,BridgeFromFile.domain,&part1,&part2,&part3)) && (part1 > 0))
				   {
				   if(CrsWlk[BridgeFromFile.Lindex].AttrErr >= 0)
				      {
				      FwriteObjectAndMessage(ATTRERR, Make_Correct(ATTRERR,checkinstance),
					   BridgeFromFile.idn, G_POLYGON,BridgeFromFile.Lindex,filedecimal,
					   BridgeFromFile.Sindex,-1.0,-1.0,BridgeFromFile.x,
					   BridgeFromFile.y,BridgeFromFile.z,BridgeFromFile.numverts,
					   AttrErr[CrsWlk[BridgeFromFile.Lindex].AttrErr].description);
				      }
				   }
				}
			     } /**** for(checkinstance = 0; checkinstance < TtlActiveChecks; checkinstance++) ****/
			  }
		       free(BridgeFromFile.x);
		       free(BridgeFromFile.y);
		       free(BridgeFromFile.z);
		       free(BridgeFromFile.h);
		       }

		    k = BridgeTable[compositeindex].numinside;
		    if(k > 0)
		       {
		       fseek(brdgin,BridgeTable[compositeindex].fileptr,SEEK_SET);
		       i = 0;
		       while(i < k)
			  {
			  fo = ftell(brdgin);

			  filedecimal = (double) fo + 0.1;

			  j = ReadBridgeFromFile(brdgin, multiplier);
			  ++i;

			  OKtoUse = 1;
			  if(NumLODbands > 0)
			     {
			     jj = CrsWlk[BridgeFromFile.Lindex].LODband;
			     if((jj > 0) && (LODindex[jj-1].active < 1))
				OKtoUse = 0;
			     }

			  if((OKtoUse > 0) && (CheckByStratum[BridgeFromFile.stratum] > 0) &&
				   (CheckByDomain[BridgeFromFile.domain] > 0))
			     {
			     NumObjects[BridgeFromFile.config] += 1.0;
			     RBdup = CheckBridgeDuplication(BridgeFromFile,RBroot, &IsDup);
			     if(IsDup < UseDupThreshold)
				{
				RBc = AddObjectToBridgeList(SzRB, BridgeFromFile.Bindex, BridgeFromFile.Lindex, BridgeFromFile.Sindex,
						     BridgeFromFile.numverts, BridgeFromFile.idn, BridgeFromFile.x,
						     BridgeFromFile.y, BridgeFromFile.z, BridgeFromFile.h,filedecimal);
				RBc->next = RBroot;
				RBroot = RBc;
				}
			     for(checkinstance = 0; checkinstance < TtlActiveChecks; checkinstance++)
				{
				if((IsDup == 1) && (InsertOK > 0) &&
				    (CombinedCheckApplies(BridgeFromFile.idn,checkinstance,G_DUPS,BridgeFromFile.Lindex,BridgeFromFile.Sindex,BridgeFromFile.config,
				      BridgeFromFile.stratum,BridgeFromFile.domain,&part1,&part2,&part3)) && (part1 > 0) &&
				      (CombinedCheckApplies(RBdup->idn,checkinstance,G_DUPS,RBdup->Lindex,RBdup->Sindex,
				       SCCtable[RBdup->Sindex].C, SCCtable[RBdup->Sindex].S, SCCtable[RBdup->Sindex].D,
							   &part1,&part2,&part3) && (part2 > 0))
				  )
				   {
				   FwriteTwoObjects(G_DUPS, Make_Correct(G_DUPS,checkinstance),
					   BridgeFromFile.idn,G_POLYGON,BridgeFromFile.Lindex,
					   filedecimal,BridgeFromFile.Sindex,-1.0,-1.0,BridgeFromFile.numverts,BridgeFromFile.x,
					   BridgeFromFile.y,BridgeFromFile.z,
					   RBdup->idn,G_POLYGON,RBdup->Lindex,RBdup->localID,RBdup->Sindex,-1.0,-1.0,RBdup->numverts,RBdup->x, RBdup->y,RBdup->z);
				   }
				if((IsDup == 4) && (InsertOK > 0) &&
				    (CombinedCheckApplies(BridgeFromFile.idn,checkinstance,C_DUPS,BridgeFromFile.Lindex,BridgeFromFile.Sindex,BridgeFromFile.config,
				      BridgeFromFile.stratum,BridgeFromFile.domain,&part1,&part2,&part3))  && (part1 > 0)  &&
				      (CombinedCheckApplies(RBdup->idn,checkinstance,C_DUPS,RBdup->Lindex,RBdup->Sindex,
				       SCCtable[RBdup->Sindex].C, SCCtable[RBdup->Sindex].S, SCCtable[RBdup->Sindex].D,
							   &part1,&part2,&part3) && (part1 > 0))
				  )
				   {
				   FwriteTwoObjects(C_DUPS, Make_Correct(C_DUPS,checkinstance),
					   BridgeFromFile.idn,G_POLYGON,BridgeFromFile.Lindex,
					   filedecimal,BridgeFromFile.Sindex,-1.0,-1.0,BridgeFromFile.numverts,BridgeFromFile.x,
					   BridgeFromFile.y,BridgeFromFile.z,
					   RBdup->idn,G_POLYGON,RBdup->Lindex,RBdup->localID,RBdup->Sindex,-1.0,-1.0,RBdup->numverts,RBdup->x, RBdup->y,RBdup->z);
				   }
				if((IsDup < UseDupThreshold) && (InsertOK))
				   {
				   if((CombinedCheckApplies(BridgeFromFile.idn,checkinstance,ATTRERR,BridgeFromFile.Lindex,BridgeFromFile.Sindex,BridgeFromFile.config,
					 BridgeFromFile.stratum,BridgeFromFile.domain,&part1,&part2,&part3)) && (part1 > 0))
				      {
				      if(CrsWlk[BridgeFromFile.Lindex].AttrErr >= 0)
					 {
					 FwriteObjectAndMessage(ATTRERR, Make_Correct(ATTRERR,checkinstance),
					      BridgeFromFile.idn, G_POLYGON,BridgeFromFile.Lindex,filedecimal,
					      BridgeFromFile.Sindex,-1.0,-1.0,BridgeFromFile.x,
					      BridgeFromFile.y,BridgeFromFile.z,BridgeFromFile.numverts,
					      AttrErr[CrsWlk[BridgeFromFile.Lindex].AttrErr].description);
					 }
				      }
				   }
				} /*** for(checkinstance = 0; checkinstance < TtlActiveChecks; checkinstance++) ***/
			     }

			  free(BridgeFromFile.x);
			  free(BridgeFromFile.y);
			  free(BridgeFromFile.z);
			  free(BridgeFromFile.h);
			  }
		       }
		    } /*** done with the bridge objects ***/



	/**** get the model polygon objects ****/
		 if((NGA_TYPE == 0) && (abortNow == 0) && (CheckByConfig[12] > 0)) /** yes, we are checking model polygons **/
		    {
		    for(i=0; i<4; i++)
		       NeighborsExist[i] = 0;

		    filedecimal = 0.1;
		    for(i=0; i<ModelPolyTable[compositeindex].numother; i++)
		       {
		       InsertOK = InsertIntoLongList(ModelPolyTable[compositeindex].others[i].fileptr,0,skiplimit,
					  &ModelPolyLongListRoot,LongModelPolySkipList,&SkipEntry);
		       fseek(MPin,ModelPolyTable[compositeindex].others[i].fileptr,SEEK_SET);
		       vtxcnt = ReadPolyFromFile(MPin,multiplier);

		       OKtoUse = 1;
		       if(NumLODbands > 0)
			  {
			  jj = CrsWlk[PolyFromFile.SACindex].LODband;
			  if((jj > 0) && (LODindex[jj-1].active < 1))
			     OKtoUse = 0;
			  }

		       if((OKtoUse > 0) && (CheckByStratum[PolyFromFile.stratum] > 0) && (CheckByDomain[PolyFromFile.domain] > 0))
			  {
			  if(InsertOK)
			     NumObjects[12] += 1.0;
			  TPc = CheckPolygonDuplication(PolyFromFile, &MProot,SzTP,&IsDup, DblModelPolySkipList, skiplimit, &TPdup);
			  sliverdone = 0;
			  if(IsDup < UseDupThreshold)
			     {
			     if(InsertOK)
				{
				sliverdone = CalculateSliverRating(PolyFromFile.x,PolyFromFile.y,PolyFromFile.z,
				       PolyFromFile.numverts,&width,&height,&sliverratio);
				}

			     if(TPc == NULL)
				{
				printf("allocation memory exhausted during model polygon list assembly operation\n");
				printf("processing cannot continue\n");
				exit(-1);
				}
			     TPc->SACindex = PolyFromFile.SACindex;
			     TPc->SCCindex = PolyFromFile.SCCindex;
			     TPc->idn = PolyFromFile.idn;
			     TPc->numverts = vtxcnt;
			     TPc->config = PolyFromFile.config;
			     TPc->stratum = PolyFromFile.stratum;
			     TPc->domain = PolyFromFile.domain;
			     TPc->Xtra = NULL;
			     tempID = TPc->localID = ModelPolyTable[compositeindex].others[i].fileptr + filedecimal;
			     TPc->insertOK = (unsigned char) InsertOK;
			     /***TPc->next = NULL; ***/
			     TPc->minxvtx = PolyFromFile.minxvtx;
			     TPc->minyvtx = PolyFromFile.minyvtx;
			     TPc->maxxvtx = PolyFromFile.maxxvtx;
			     TPc->maxyvtx = PolyFromFile.maxyvtx;
			     jj = PlaneEquation(&PA,&PB,&PC,&PD,PolyFromFile.x,
					PolyFromFile.y,PolyFromFile.z,PolyFromFile.numverts);
			     if(jj == 1)
				{
				TPc->slope = PolygonAngle(PA,PB,PC);
				if(TPc->slope == HalfPI)
				   vertpolysurfarea = SurfaceAreaByTriangles(PolyFromFile.numverts, PolyFromFile.x,
						      PolyFromFile.y,PolyFromFile.z);
				else
				   vertpolysurfarea = 1.0;
				}
			     else
				TPc->slope = 2;
	 
			     TPc->x = (double *) malloc(SzD * vtxcnt);
			     TPc->y = (double *) malloc(SzD * vtxcnt);
			     TPc->z = (double *) malloc(SzD * vtxcnt);
			     if((TPc->x == NULL) || (TPc->y == NULL) || (TPc->z == NULL))
				{
				printf("3: allocation memory exhausted during polygon list assembly operation\n");
				printf("processing cannot continue (found %d polygon vertices)\n",vtxcnt);
				exit(-1);
				}
			     for(jj = 0; jj<vtxcnt; jj++)
				{
				TPc->x[jj] = PolyFromFile.x[jj];
				TPc->y[jj] = PolyFromFile.y[jj];
				TPc->z[jj] = PolyFromFile.z[jj];
				if(jj == 0)
				   {
				   MaxElev = MinElev = PolyFromFile.z[0];
				   }
				else if(PolyFromFile.z[jj] > MaxElev)
				   MaxElev = PolyFromFile.z[jj];
				else if(PolyFromFile.z[jj] < MinElev)
				   MinElev = PolyFromFile.z[jj];
				}

			     for(checkinstance = 0; checkinstance < TtlActiveChecks; checkinstance++)
				{
				if(CombinedCheckApplies(PolyFromFile.idn,checkinstance,ELEVGT,PolyFromFile.SACindex,PolyFromFile.SCCindex,PolyFromFile.config,PolyFromFile.stratum,
					    PolyFromFile.domain,&part1,&part2,&part3))
				   {
				   if((part1 > 0) && (SensitivityCheck(GT, ELEVGT, checkinstance, MaxElev) > 0))
				/***if(MaxElev > ErrorLookup[ELEVGT].sensitivity)****/
				      {
                                      FwriteDynamicInfo(ELEVGT,Make_Correct(ELEVGT,checkinstance),0,1,1,NULL,
                                        MinElev, -1.0, -1.0, -1.0,
                                        PolyFromFile.SCCindex,G_POLYGON,PolyFromFile.SACindex,TPc->localID,PolyFromFile.idn,-1.0,-1.0,
                                        PolyFromFile.x, PolyFromFile.y,PolyFromFile.z, 1,
                                        PolyFromFile.SCCindex,G_POLYGON,PolyFromFile.SACindex,TPc->localID,PolyFromFile.idn,-1.0,-1.0,
                                        PolyFromFile.x, PolyFromFile.y,PolyFromFile.z, 1);
				      }
				   }
				if(CombinedCheckApplies(PolyFromFile.idn,checkinstance,ELEVLT,PolyFromFile.SACindex,PolyFromFile.SCCindex,PolyFromFile.config,PolyFromFile.stratum,
					    PolyFromFile.domain,&part1,&part2,&part3))
				   {
				   if((part1 > 0) && (SensitivityCheck(LT, ELEVLT, checkinstance, MinElev) > 0))
				      {
                                      FwriteDynamicInfo(ELEVLT,Make_Correct(ELEVLT,checkinstance),0,1,1,NULL,
                                        MinElev, -1.0, -1.0, -1.0,
                                        PolyFromFile.SCCindex,G_POLYGON,PolyFromFile.SACindex,TPc->localID,PolyFromFile.idn,-1.0,-1.0,
                                        PolyFromFile.x, PolyFromFile.y,PolyFromFile.z, 1,
                                        PolyFromFile.SCCindex,G_POLYGON,PolyFromFile.SACindex,TPc->localID,PolyFromFile.idn,-1.0,-1.0,
                                        PolyFromFile.x, PolyFromFile.y,PolyFromFile.z, 1);
				      }
				   }
				if(CombinedCheckApplies(PolyFromFile.idn,checkinstance,ELEVEQ,PolyFromFile.SACindex,PolyFromFile.SCCindex,PolyFromFile.config,PolyFromFile.stratum,
					    PolyFromFile.domain,&part1,&part2,&part3))
				   {
				   if((part1 > 0) && (SensitivityCheck(CLOSEDINT, ELEVEQ, checkinstance, MinElev) > 0) &&
				      (SensitivityCheck(CLOSEDINT, ELEVEQ, checkinstance, MaxElev) > 0))
				      {
                                      FwriteDynamicInfo(ELEVEQ,Make_Correct(ELEVEQ,checkinstance),0,1,1,NULL,
                                        MinElev, -1.0, -1.0, -1.0,
                                        PolyFromFile.SCCindex,G_POLYGON,PolyFromFile.SACindex,TPc->localID,PolyFromFile.idn,-1.0,-1.0,
                                        PolyFromFile.x, PolyFromFile.y,PolyFromFile.z, 1,
                                        PolyFromFile.SCCindex,G_POLYGON,PolyFromFile.SACindex,TPc->localID,PolyFromFile.idn,-1.0,-1.0,
                                        PolyFromFile.x, PolyFromFile.y,PolyFromFile.z, 1);
				      }
				   }

                                if(CombinedCheckApplies(PolyFromFile.idn,checkinstance,ELEVEQOPEN,PolyFromFile.SACindex,PolyFromFile.SCCindex,PolyFromFile.config,PolyFromFile.stratum,
                                            PolyFromFile.domain,&part1,&part2,&part3))
                                   {
                                   if((part1 > 0) && (SensitivityCheck(OPENINT, ELEVEQOPEN, checkinstance, MinElev) > 0) &&
                                      (SensitivityCheck(OPENINT, ELEVEQOPEN, checkinstance, MaxElev) > 0))
                                      {
                                      FwriteDynamicInfo(ELEVEQOPEN,Make_Correct(ELEVEQOPEN,checkinstance),0,1,1,NULL,
                                        MinElev, -1.0, -1.0, -1.0,
                                        PolyFromFile.SCCindex,G_POLYGON,PolyFromFile.SACindex,TPc->localID,PolyFromFile.idn,-1.0,-1.0,
                                        PolyFromFile.x, PolyFromFile.y,PolyFromFile.z, 1,
                                        PolyFromFile.SCCindex,G_POLYGON,PolyFromFile.SACindex,TPc->localID,PolyFromFile.idn,-1.0,-1.0,
                                        PolyFromFile.x, PolyFromFile.y,PolyFromFile.z, 1);
                                      }
                                   }
				}  /*** for(checkinstance = 0; checkinstance < TtlActiveChecks; checkinstance++) ***/

			     checkinstance = -1;

			     if((CombinedCheckApplies(PolyFromFile.idn,checkinstance,VTEAR,PolyFromFile.SACindex,PolyFromFile.SCCindex,PolyFromFile.config,PolyFromFile.stratum,
					    PolyFromFile.domain,&part1,&part2,&part3)) ||
				(CombinedCheckApplies(PolyFromFile.idn,checkinstance,HTEAR,PolyFromFile.SACindex,PolyFromFile.SCCindex,PolyFromFile.config,PolyFromFile.stratum,
					    PolyFromFile.domain,&part1,&part2,&part3)) ||
				(CombinedCheckApplies(PolyFromFile.idn,checkinstance,OVERC,PolyFromFile.SACindex,PolyFromFile.SCCindex,PolyFromFile.config,PolyFromFile.stratum,
					    PolyFromFile.domain,&part1,&part2,&part3)) ||
				(CombinedCheckApplies(PolyFromFile.idn,checkinstance,TVERT,PolyFromFile.SACindex,PolyFromFile.SCCindex,PolyFromFile.config,PolyFromFile.stratum,
					    PolyFromFile.domain,&part1,&part2,&part3)) ||
				(CombinedCheckApplies(PolyFromFile.idn,checkinstance,LMINT,PolyFromFile.SACindex,PolyFromFile.SCCindex,PolyFromFile.config,PolyFromFile.stratum,
					    PolyFromFile.domain,&part1,&part2,&part3)) ||
				(CombinedCheckApplies(PolyFromFile.idn,checkinstance,LSPINT,PolyFromFile.SACindex,PolyFromFile.SCCindex,PolyFromFile.config,PolyFromFile.stratum,
					    PolyFromFile.domain,&part1,&part2,&part3)) ||
				(CombinedCheckApplies(PolyFromFile.idn,checkinstance,LSPIEXP,PolyFromFile.SACindex,PolyFromFile.SCCindex,PolyFromFile.config,PolyFromFile.stratum,
					    PolyFromFile.domain,&part1,&part2,&part3)) ||
				((PolyFromFile.stratum == 5) && (ErrorLookup[SLOPEDIRCH].anyactive > 0)) ||
				((PolyFromFile.stratum == 5) && (ErrorLookup[LJOINSLOPEDC].anyactive > 0)))
				{
				edgesin = 0;
				for(jj=0; jj<vtxcnt; jj++)
				   {
				   ii = (jj + 1) % vtxcnt;
				   vx1 = PolyFromFile.x[jj];
				   vy1 = PolyFromFile.y[jj];
				   vz1 = PolyFromFile.z[jj];
				   vx2 = PolyFromFile.x[ii];
				   vy2 = PolyFromFile.y[ii];
				   vz2 = PolyFromFile.z[ii];
				   neighborhit = ClipLineToRegion(minx,miny,maxx,maxy,&vx1,&vy1,&vz1,&vx2,&vy2,&vz2, &clipflag, multiplier);

				   if(neighborhit > 0)
				      {
				      if(neighborhit & 2)
					 NeighborsExist[0] += 1;
				      if(neighborhit & 4)
					 NeighborsExist[1] += 1;
				      if(neighborhit & 8)
					 NeighborsExist[2] += 1;
				      if(neighborhit & 16)
					 NeighborsExist[3] += 1;
				      lpec = (struct ListOfEdges *) (malloc(SzLE));
				      if(lpec == NULL)
					 {
					 printf("allocation memory exhausted during polygon edge list assembly operation\n");
					 printf("processing cannot continue\n");
					 exit(-1);
					 }
				      lpec->x1 = PolyFromFile.x[jj];
				      lpec->y1 = PolyFromFile.y[jj];
				      lpec->z1 = PolyFromFile.z[jj];
				      lpec->x2 = PolyFromFile.x[ii];
				      lpec->y2 = PolyFromFile.y[ii];

				      lpec->z2 = PolyFromFile.z[ii];
				      if(lpec->x1 < lpec->x2)
					 {
					 lpec->minx = lpec->x1;
					 lpec->maxx = lpec->x2;
					 }
				      else
					 {
					 lpec->minx = lpec->x2;
					 lpec->maxx = lpec->x1;
					 }
				      if(lpec->y1 < lpec->y2)
					 {
					 lpec->miny = lpec->y1;
					 lpec->maxy = lpec->y2;
					 }
				      else
					 {
					 lpec->miny = lpec->y2;
					 lpec->maxy = lpec->y1;
					 }
				      lpec->rise = lpec->y2 - lpec->y1;
				      lpec->run = lpec->x2 - lpec->x1;
				      if(lpec->x1 != lpec->x2)
					 {
					 lpec->slope = lpec->rise / lpec->run;
					 lpec->Bval = lpec->y1 - (lpec->slope * lpec->x1);
					 }
				      else
					 {
					 lpec->slope = 0;
					 lpec->Bval = 0;
					 }
	  
				      if(i == 0)
					 {
					 rlx = lpec->minx;
					 rux = lpec->maxx;
					 rly = lpec->miny;
					 ruy = lpec->maxy;
					 }
				      else
					 {
					 if(lpec->minx < rlx)
					    rlx = lpec->minx;
					 if(lpec->maxx > rux)
					    rux = lpec->maxx;
					 if(lpec->miny < rly)
					    rly = lpec->miny;
					 if(lpec->maxy > ruy)
					    ruy = lpec->maxy;
					 }

				      lpec->owner = (long int) TPc; /** ptr to poly this edges belongs to **/
				      lpec->ownernumb = jj; /** original edges from which it may have been clipped **/
				      lpec->clipped = clipflag;
				      lpec->isT = 0;
				   /**lpec->length = Distance(lpec->x1,lpec->y1,lpec->x2,lpec->y2);**/
				      lpec->length = Distance(vx1,vy1,vx2,vy2);
				      lpec->Tcover = 0.0;
				      lpec->Ocover = 0.0;
				      lpec->Iedge = NULL;
				      lpec->DeltaZ1 = lpec->DeltaZ2 = 0.0;
				      ii = 0;
				      if((sliverdone == 0) || (InsertOK == 0) || (sliverratio < 0.001))
					 ii = EdgeSliverCheckOK(lpec, ModelPolyEdgeRoot, edgesin);
				      else
					 ii = 1;

				      if((ii > 0) && (lpec->length > 0))
					 {
					 if(TPc->slope != HalfPI)
					    {
					    ++edgesin;
					    lpec->next = NULL;
					    InsertIntoEdgeList(lpec, &ModelPolyEdgeRoot, DblPolyEdgeSkipList, skiplimit);
					    }
					 else
					    {
					    ++edgesin;
					    if(vertpolysurfarea > 0)
					       {
					       lpec->next = VertModelPolyEdgeRoot;
					       VertModelPolyEdgeRoot = lpec;
					       }
					    else
					       free(lpec);
					    }
					 }
				      else
					 free(lpec);
				      }
				   }
				} /** end inserting into edge list **/
			     } /** end if not a duplicate **/
			  else
			     {
			     tempID = ModelPolyTable[compositeindex].others[i].fileptr + filedecimal;
			     }

			  for(checkinstance = 0; checkinstance < TtlActiveChecks; checkinstance++)
			     {
			     if(
				(IsDup == 1)   &&
				(InsertOK > 0) &&
				(CombinedCheckApplies(PolyFromFile.idn,checkinstance,G_DUPS,PolyFromFile.SACindex,PolyFromFile.SCCindex,
						      PolyFromFile.config,PolyFromFile.stratum,PolyFromFile.domain,
						      &part1,&part2,&part3))  && (part1 > 0)  &&
				      (CombinedCheckApplies(TPdup->idn,checkinstance,G_DUPS,TPdup->SACindex,TPdup->SCCindex,
				       SCCtable[TPdup->SCCindex].C, SCCtable[TPdup->SCCindex].S, SCCtable[TPdup->SCCindex].D,
							   &part1,&part2,&part3) && (part2 > 0))
				  
				)
			       {
				 FwriteTwoObjects(G_DUPS, Make_Correct(G_DUPS,checkinstance), 
						  PolyFromFile.idn,G_POLYGON,PolyFromFile.SACindex,tempID,PolyFromFile.SCCindex,-1.0,-1.0,
						  PolyFromFile.numverts,PolyFromFile.x,
						  PolyFromFile.y,PolyFromFile.z,
						  TPdup->idn,G_POLYGON,TPdup->SACindex,TPdup->localID,TPdup->SCCindex,-1.0,-1.0,TPdup->numverts,
						  TPdup->x, TPdup->y,TPdup->z);
			       }


			     if(
				(IsDup == 4)   &&
				(InsertOK > 0) &&
				(CombinedCheckApplies(PolyFromFile.idn,checkinstance,C_DUPS,PolyFromFile.SACindex,PolyFromFile.SCCindex,
						      PolyFromFile.config,PolyFromFile.stratum,PolyFromFile.domain,
						      &part1,&part2,&part3))  && (part1 > 0)  &&
				      (CombinedCheckApplies(TPdup->idn,checkinstance,C_DUPS,TPdup->SACindex,TPdup->SCCindex,
				       SCCtable[TPdup->SCCindex].C, SCCtable[TPdup->SCCindex].S, SCCtable[TPdup->SCCindex].D,
							   &part1,&part2,&part3) && (part1 > 0))
				)
			       {
				 FwriteTwoObjects(C_DUPS, Make_Correct(C_DUPS,checkinstance),  
						  PolyFromFile.idn,G_POLYGON,PolyFromFile.SACindex,tempID,PolyFromFile.SCCindex,-1.0,-1.0,
						  PolyFromFile.numverts,PolyFromFile.x,
						  PolyFromFile.y,PolyFromFile.z,
						  TPdup->idn,G_POLYGON,TPdup->SACindex,TPdup->localID,TPdup->SCCindex,-1.0,-1.0,TPdup->numverts,
						  TPdup->x, TPdup->y,TPdup->z);
			       }


			     if((IsDup < UseDupThreshold) && (InsertOK))
			       {
				 if(sliverdone == 0)
				   {
				     sliverdone = CalculateSliverRating(PolyFromFile.x,PolyFromFile.y,PolyFromFile.z,
									PolyFromFile.numverts,&width,&height,&sliverratio);
				   }
				 
				 if((CombinedCheckApplies(PolyFromFile.idn,checkinstance,V_DUPS,PolyFromFile.SACindex,PolyFromFile.SCCindex,
							 PolyFromFile.config,PolyFromFile.stratum,PolyFromFile.domain,
							 &part1,&part2,&part3)) && (part1 > 0))
				   {
				     dv = DuplicateVerticesExist(PolyFromFile.numverts,
								    PolyFromFile.x,PolyFromFile.y,PolyFromFile.z);
				     if(SensitivityCheck(GT, V_DUPS, checkinstance, (double) dv) > 0)
				       {
				       for(jj=1; jj<PolyFromFile.numverts; jj++)
					 {
					 if((PolyFromFile.x[jj-1] == PolyFromFile.x[jj]) &&
					     (PolyFromFile.y[jj-1] == PolyFromFile.y[jj]) &&
					     (PolyFromFile.z[jj-1] == PolyFromFile.z[jj]))
					    {
                                            FwriteObject(V_DUPS,Make_Correct(V_DUPS,checkinstance),PolyFromFile.SACindex,
                                                           PolyFromFile.SCCindex,G_POLYGON,TPc->localID,PolyFromFile.idn, -1.0, -1.0,
                                                            &PolyFromFile.x[jj],&PolyFromFile.y[jj],&PolyFromFile.z[jj],1, 1);
					    }
					 }

				       }
				   }



				 if(CombinedCheckApplies(PolyFromFile.idn,checkinstance,SLIVER,PolyFromFile.SACindex,PolyFromFile.SCCindex,
							 PolyFromFile.config,PolyFromFile.stratum,PolyFromFile.domain,
							 &part1,&part2,&part3))
				   {
				     if((part1 > 0) &&
					(sliverdone > 0) &&
					(SensitivityCheck(LT, SLIVER, checkinstance, sliverratio) > 0)
					)
				       {
					 FwriteObjectAndMagnitude(SLIVER, Make_Correct(SLIVER,checkinstance), 
								  PolyFromFile.idn, PolyFromFile.SCCindex,
								  G_POLYGON,PolyFromFile.SACindex,TPc->localID,-1.0,-1.0,
								  sliverratio,PolyFromFile.x, PolyFromFile.y,PolyFromFile.z,
								  PolyFromFile.numverts, 1);
				       }
				   }


				 if(CombinedCheckApplies(PolyFromFile.idn,checkinstance,NARROW,PolyFromFile.SACindex,PolyFromFile.SCCindex,
							 PolyFromFile.config,PolyFromFile.stratum,PolyFromFile.domain,
							 &part1,&part2,&part3))
				   {
				     if((part1 > 0) &&
					(sliverdone > 0) &&
					(SensitivityCheck(LT, NARROW, checkinstance, width) > 0)
					)
				       {
					 FwriteObjectAndMagnitude(NARROW, Make_Correct(NARROW,checkinstance), 
								  PolyFromFile.idn, PolyFromFile.SCCindex,
								  G_POLYGON,PolyFromFile.SACindex,TPc->localID,-1.0,-1.0,
								  width,PolyFromFile.x, PolyFromFile.y,PolyFromFile.z,
								  PolyFromFile.numverts, 1);
				       }
				   }





				 if((CombinedCheckApplies(PolyFromFile.idn,checkinstance,SMALLOBJ,PolyFromFile.SACindex,PolyFromFile.SCCindex,
							 PolyFromFile.config,PolyFromFile.stratum,PolyFromFile.domain,
							 &part1,&part2,&part3)) && (part1 > 0))
				   {
				     surfacearea3D = SurfaceAreaByTriangles(PolyFromFile.numverts, PolyFromFile.x,
									    PolyFromFile.y,PolyFromFile.z);

				     if(SensitivityCheck(LT, SMALLOBJ, checkinstance, surfacearea3D) > 0)
				       {
					 FwriteObjectAndMagnitude(SMALLOBJ, Make_Correct(SMALLOBJ,checkinstance), 
								  PolyFromFile.idn, PolyFromFile.SCCindex,
								  G_POLYGON,PolyFromFile.SACindex,TPc->localID,-1.0,-1.0,
								  surfacearea3D,PolyFromFile.x, PolyFromFile.y,PolyFromFile.z,
								  PolyFromFile.numverts, 1);
				       }
				   }



				 if((CombinedCheckApplies(PolyFromFile.idn,checkinstance,ATTRERR,PolyFromFile.SACindex,PolyFromFile.SCCindex,
							 PolyFromFile.config,PolyFromFile.stratum,PolyFromFile.domain,
							 &part1,&part2,&part3)) && (part1 > 0))
				   {
				     if(CrsWlk[PolyFromFile.SACindex].AttrErr >= 0)
				       {
					 FwriteObjectAndMessage(ATTRERR, Make_Correct(ATTRERR,checkinstance), 
								PolyFromFile.idn, G_POLYGON,PolyFromFile.SACindex,TPc->localID,
								PolyFromFile.SCCindex,-1.0,-1.0,PolyFromFile.x,
								PolyFromFile.y,PolyFromFile.z,PolyFromFile.numverts,
								AttrErr[CrsWlk[PolyFromFile.SACindex].AttrErr].description);
				       }
				   }




				 if(
				    (CombinedCheckApplies(PolyFromFile.idn,checkinstance,HSLOPE,PolyFromFile.SACindex,PolyFromFile.SCCindex,
							  PolyFromFile.config,PolyFromFile.stratum,PolyFromFile.domain,
							  &part1,&part2,&part3)) 
				    ||
				    (CombinedCheckApplies(PolyFromFile.idn,checkinstance,VERTSLOPE,PolyFromFile.SACindex,PolyFromFile.SCCindex,
							  PolyFromFile.config,PolyFromFile.stratum,PolyFromFile.domain,
							  &part1,&part2,&part3))
				    )
				   {
				     if(TPc->slope < 1.75)
				       {
					 angle = TPc->slope;

					 if(
					    (angle >= HalfPI) &&
					    (CombinedCheckApplies(PolyFromFile.idn,checkinstance,VERTSLOPE,PolyFromFile.SACindex,
								  PolyFromFile.SCCindex,PolyFromFile.config,
								  PolyFromFile.stratum,PolyFromFile.domain,
								  &part1,&part2,&part3)) && (part1 > 0)
					    )
					   {
					     FwriteObject(VERTSLOPE, Make_Correct(VERTSLOPE,checkinstance), 
							  PolyFromFile.SACindex,
							  PolyFromFile.SCCindex, G_POLYGON,TPc->localID /** need poly localID here **/,PolyFromFile.idn,-1.0,-1.0,
							  PolyFromFile.x,PolyFromFile.y,PolyFromFile.z,PolyFromFile.numverts, 1);
					   }
					 

					 angle = RadiansToDegrees(angle);
					 if(
					    (CombinedCheckApplies(PolyFromFile.idn,checkinstance,HSLOPE,PolyFromFile.SACindex,
								  PolyFromFile.SCCindex,PolyFromFile.config,
								  PolyFromFile.stratum,PolyFromFile.domain,
								  &part1,&part2,&part3))  && (part1 > 0)
					    &&
					    (SensitivityCheck(GT, HSLOPE, checkinstance, angle) > 0)
					    )
					   {
					     FwriteObjectAndMagnitude(HSLOPE, Make_Correct(HSLOPE,checkinstance), 
								      PolyFromFile.idn, 
								      PolyFromFile.SCCindex,G_POLYGON,PolyFromFile.SACindex,TPc->localID,-1.0,-1.0,
								      angle,PolyFromFile.x, PolyFromFile.y,PolyFromFile.z,
								      PolyFromFile.numverts, 1);
					   }
				       }
				   }
				}   /*** end if((IsDup < 2) && (InsertOK)) ***/
			     }  /*** for(checkinstance = 0; checkinstance < TtlActiveChecks; checkinstance++) ***/

			  }
		       free(PolyFromFile.x);
		       free(PolyFromFile.y);
		       free(PolyFromFile.z);
		       }

		    fseek(MPin,ModelPolyTable[compositeindex].fileptr,SEEK_SET);
		    valuesread = 0;
		    filedecimal = 0.1;
	/*** the below while loop reads all polygon objects ***/
		    while(valuesread < ModelPolyTable[compositeindex].numinside)
		       {
		       if(feof(MPin) != 0)
			  break;
		       fo = ftell(MPin);
		       vtxcnt = ReadPolyFromFile(MPin,multiplier);

		       OKtoUse = 1;
		       if(NumLODbands > 0)
			  {
			  jj = CrsWlk[PolyFromFile.SACindex].LODband;
			  if((jj > 0) && (LODindex[jj-1].active < 1))
			     OKtoUse = 0;
			  }

		       if((OKtoUse > 0) && (CheckByStratum[PolyFromFile.stratum] > 0) && (CheckByDomain[PolyFromFile.domain] > 0))
			  {
			  NumObjects[12] += 1.0;
			  TPc = CheckPolygonDuplication(PolyFromFile, &MProot,SzTP,&IsDup, DblModelPolySkipList, skiplimit, &TPdup);
			  sliverdone = 0;
			  if(IsDup < UseDupThreshold)
			     {
			     sliverdone = CalculateSliverRating(PolyFromFile.x,PolyFromFile.y,PolyFromFile.z,
				       PolyFromFile.numverts,&width,&height,&sliverratio);

			     if(TPc == NULL)
				{
				printf("allocation memory exhausted during polygon list creation operation\n");
				printf("processing cannot continue\n");
				exit(-1);
				}
			     TPc->SACindex = PolyFromFile.SACindex;
			     TPc->SCCindex = PolyFromFile.SCCindex;
			     TPc->idn = PolyFromFile.idn;
			     TPc->numverts = vtxcnt;
			     TPc->config = PolyFromFile.config;
			     TPc->stratum = PolyFromFile.stratum;
			     TPc->domain = PolyFromFile.domain;
			     TPc->insertOK = (unsigned char) 1; /** single region poly can't be a dup like this **/
			     tempID = TPc->localID = fo + filedecimal;
			     TPc->minxvtx = PolyFromFile.minxvtx;
			     TPc->minyvtx = PolyFromFile.minyvtx;
			     TPc->maxxvtx = PolyFromFile.maxxvtx;
			     TPc->maxyvtx = PolyFromFile.maxyvtx;
			     jj = PlaneEquation(&PA,&PB,&PC,&PD,PolyFromFile.x,
					PolyFromFile.y,PolyFromFile.z,PolyFromFile.numverts);
			     if(jj == 1) /** then plane equation was a success **/
				{
				TPc->slope = PolygonAngle(PA,PB,PC);
				if(TPc->slope == HalfPI)
				   vertpolysurfarea = SurfaceAreaByTriangles(PolyFromFile.numverts, PolyFromFile.x,
						      PolyFromFile.y,PolyFromFile.z);
				else
				   vertpolysurfarea = 1.0;
				}
			     else
				TPc->slope = 2.0;
			     TPc->Xtra = NULL;
	  
			     TPc->x = (double *) malloc(SzD * vtxcnt);
			     TPc->y = (double *) malloc(SzD * vtxcnt);
			     TPc->z = (double *) malloc(SzD * vtxcnt);
			     if((TPc->x == NULL) || (TPc->y == NULL) || (TPc->z == NULL))
				{
				printf("allocation memory exhausted during model polygon list creation operation\n");
				printf("processing cannot continue (polygon has %d vertices)\n",vtxcnt);
				exit(-1);
				}
			     for(jj = 0; jj<vtxcnt; jj++)
				{
				TPc->x[jj] = PolyFromFile.x[jj];
				TPc->y[jj] = PolyFromFile.y[jj];
				TPc->z[jj] = PolyFromFile.z[jj];
				if(jj == 0)
				   {
				   MaxElev = MinElev = PolyFromFile.z[0];
				   }
				else if(PolyFromFile.z[jj] > MaxElev)
				   MaxElev = PolyFromFile.z[jj];
				else if(PolyFromFile.z[jj] < MinElev)
				   MinElev = PolyFromFile.z[jj];
				}


			     for(checkinstance = 0; checkinstance < TtlActiveChecks; checkinstance++)
				{
				if((CombinedCheckApplies(PolyFromFile.idn,checkinstance,ELEVGT,PolyFromFile.SACindex,PolyFromFile.SCCindex,PolyFromFile.config,PolyFromFile.stratum,
					    PolyFromFile.domain,&part1,&part2,&part3)) && (part1 > 0))
				   {
				   if(SensitivityCheck(GT, ELEVGT, checkinstance, MaxElev) > 0)
				      {
                                      FwriteDynamicInfo(ELEVGT,Make_Correct(ELEVGT,checkinstance),0,1,1,NULL,
                                        MinElev, -1.0, -1.0, -1.0,
                                        PolyFromFile.SCCindex,G_POLYGON,PolyFromFile.SACindex,TPc->localID,PolyFromFile.idn,-1.0,-1.0,
                                        PolyFromFile.x, PolyFromFile.y,PolyFromFile.z, 1,
                                        PolyFromFile.SCCindex,G_POLYGON,PolyFromFile.SACindex,TPc->localID,PolyFromFile.idn,-1.0,-1.0,
                                        PolyFromFile.x, PolyFromFile.y,PolyFromFile.z, 1);
				      }
				   }
				if((CombinedCheckApplies(PolyFromFile.idn,checkinstance,ELEVLT,PolyFromFile.SACindex,PolyFromFile.SCCindex,PolyFromFile.config,PolyFromFile.stratum,
					    PolyFromFile.domain,&part1,&part2,&part3)) && (part1 > 0))
				   {
				   if(SensitivityCheck(LT, ELEVLT, checkinstance, MinElev) > 0)
				      {
                                      FwriteDynamicInfo(ELEVLT,Make_Correct(ELEVLT,checkinstance),0,1,1,NULL,
                                        MinElev, -1.0, -1.0, -1.0,
                                        PolyFromFile.SCCindex,G_POLYGON,PolyFromFile.SACindex,TPc->localID,PolyFromFile.idn,-1.0,-1.0,
                                        PolyFromFile.x, PolyFromFile.y,PolyFromFile.z, 1,
                                        PolyFromFile.SCCindex,G_POLYGON,PolyFromFile.SACindex,TPc->localID,PolyFromFile.idn,-1.0,-1.0,
                                        PolyFromFile.x, PolyFromFile.y,PolyFromFile.z, 1);
				      }
				   }
				if((CombinedCheckApplies(PolyFromFile.idn,checkinstance,ELEVEQ,PolyFromFile.SACindex,PolyFromFile.SCCindex,PolyFromFile.config,PolyFromFile.stratum,
					    PolyFromFile.domain,&part1,&part2,&part3)) && (part1 > 0))
				   {
				   if((SensitivityCheck(CLOSEDINT, ELEVEQ, checkinstance, MinElev) > 0) &&
				      (SensitivityCheck(CLOSEDINT, ELEVEQ, checkinstance, MaxElev) > 0))
				      {
                                      FwriteDynamicInfo(ELEVEQ,Make_Correct(ELEVEQ,checkinstance),0,1,1,NULL,
                                        MinElev, -1.0, -1.0, -1.0,
                                        PolyFromFile.SCCindex,G_POLYGON,PolyFromFile.SACindex,TPc->localID,PolyFromFile.idn,-1.0,-1.0,
                                        PolyFromFile.x, PolyFromFile.y,PolyFromFile.z, 1,
                                        PolyFromFile.SCCindex,G_POLYGON,PolyFromFile.SACindex,TPc->localID,PolyFromFile.idn,-1.0,-1.0,
                                        PolyFromFile.x, PolyFromFile.y,PolyFromFile.z, 1);
				      }
				   }
                                if((CombinedCheckApplies(PolyFromFile.idn,checkinstance,ELEVEQOPEN,PolyFromFile.SACindex,PolyFromFile.SCCindex,PolyFromFile.config,PolyFromFile.stratum,
                                            PolyFromFile.domain,&part1,&part2,&part3)) && (part1 > 0))
                                    {
                                    if((SensitivityCheck(OPENINT, ELEVEQOPEN, checkinstance, MinElev) > 0) &&
                                      (SensitivityCheck(OPENINT, ELEVEQOPEN, checkinstance, MaxElev) > 0))
                                      {
                                      FwriteDynamicInfo(ELEVEQOPEN,Make_Correct(ELEVEQOPEN,checkinstance),0,1,1,NULL,
                                        MinElev, -1.0, -1.0, -1.0,
                                        PolyFromFile.SCCindex,G_POLYGON,PolyFromFile.SACindex,TPc->localID,PolyFromFile.idn,-1.0,-1.0,
                                        PolyFromFile.x, PolyFromFile.y,PolyFromFile.z, 1,
                                        PolyFromFile.SCCindex,G_POLYGON,PolyFromFile.SACindex,TPc->localID,PolyFromFile.idn,-1.0,-1.0,
                                        PolyFromFile.x, PolyFromFile.y,PolyFromFile.z, 1);
                                      }
                                    }

				}  /*** for(checkinstance = 0; checkinstance < TtlActiveChecks; checkinstance++) ***/

			     checkinstance = -1;

			     if((CombinedCheckApplies(PolyFromFile.idn,checkinstance,VTEAR,PolyFromFile.SACindex,PolyFromFile.SCCindex,PolyFromFile.config,PolyFromFile.stratum,
				  PolyFromFile.domain,&part1,&part2,&part3)) ||
				(CombinedCheckApplies(PolyFromFile.idn,checkinstance,HTEAR,PolyFromFile.SACindex,PolyFromFile.SCCindex,PolyFromFile.config,PolyFromFile.stratum,
				  PolyFromFile.domain,&part1,&part2,&part3)) ||
				(CombinedCheckApplies(PolyFromFile.idn,checkinstance,OVERC,PolyFromFile.SACindex,PolyFromFile.SCCindex,PolyFromFile.config,PolyFromFile.stratum,
				  PolyFromFile.domain,&part1,&part2,&part3)) ||
				(CombinedCheckApplies(PolyFromFile.idn,checkinstance,TVERT,PolyFromFile.SACindex,PolyFromFile.SCCindex,PolyFromFile.config,PolyFromFile.stratum,
				  PolyFromFile.domain,&part1,&part2,&part3)) ||
				(CombinedCheckApplies(PolyFromFile.idn,checkinstance,LMINT,PolyFromFile.SACindex,PolyFromFile.SCCindex,PolyFromFile.config,PolyFromFile.stratum,
					    PolyFromFile.domain,&part1,&part2,&part3)) ||
				(CombinedCheckApplies(PolyFromFile.idn,checkinstance,LSPINT,PolyFromFile.SACindex,PolyFromFile.SCCindex,PolyFromFile.config,PolyFromFile.stratum,
					    PolyFromFile.domain,&part1,&part2,&part3)) ||
				(CombinedCheckApplies(PolyFromFile.idn,checkinstance,LSPIEXP,PolyFromFile.SACindex,PolyFromFile.SCCindex,PolyFromFile.config,PolyFromFile.stratum,
					    PolyFromFile.domain,&part1,&part2,&part3)) ||
				((PolyFromFile.stratum == 5) && (ErrorLookup[SLOPEDIRCH].anyactive > 0)) ||
				((PolyFromFile.stratum == 5) && (ErrorLookup[LJOINSLOPEDC].anyactive > 0)))
				{
				edgesin = 0;
				for(jj=0; jj<vtxcnt; jj++)
				   {
				   ii = (jj + 1) % vtxcnt;
				   lpec = (struct ListOfEdges *) (malloc(SzLE));
				   if(lpec == NULL)
				      {
				      printf("allocation memory exhausted during polygon edge assemble operation\n");
				      printf("processing cannot continue (%d verticex poly involved)\n",vtxcnt);
				      exit(-1);
				      }
				   lpec->x1 = PolyFromFile.x[jj];
				   lpec->y1 = PolyFromFile.y[jj];
				   lpec->z1 = PolyFromFile.z[jj];
				   lpec->x2 = PolyFromFile.x[ii];
				   lpec->y2 = PolyFromFile.y[ii];
				   lpec->z2 = PolyFromFile.z[ii];

				   if(lpec->x1 < lpec->x2)
				      {
				      lpec->minx = lpec->x1;
				      lpec->maxx = lpec->x2;
				      }
				   else
				      {
				      lpec->minx = lpec->x2;
				      lpec->maxx = lpec->x1;
				      }
				   if(lpec->y1 < lpec->y2)
				      {
				      lpec->miny = lpec->y1;
				      lpec->maxy = lpec->y2;
				      }
				   else
				      {
				      lpec->miny = lpec->y2;
				      lpec->maxy = lpec->y1;
				      }
				   lpec->rise = lpec->y2 - lpec->y1;
				   lpec->run = lpec->x2 - lpec->x1;
				   if(lpec->run != 0)
				      {
				      lpec->slope = lpec->rise / lpec->run;
				      lpec->Bval = lpec->y1 - (lpec->slope * lpec->x1);
				      }
				   else
				      {
				      lpec->slope = 0;
				      lpec->Bval = 0;
				      }
	  
				   if((i == 0) && (ModelPolyTable[compositeindex].numother == 0))
				      {
				      rlx = lpec->minx;
				      rux = lpec->maxx;
				      rly = lpec->miny;
				      ruy = lpec->maxy;
				      }
				   else
				      {
				      if(lpec->minx < rlx)
					 rlx = lpec->minx;
				      if(lpec->maxx > rux)
					 rux = lpec->maxx;
				      if(lpec->miny < rly)
					 rly = lpec->miny;
				      if(lpec->maxy > ruy)
					 ruy = lpec->maxy;
				      }

				   lpec->owner = (long int) TPc; /** ptr to poly this edges belongs to **/
				   lpec->ownernumb = jj; /** edge number in the owning poly **/
				   lpec->clipped = 0; /** edge did not need clipping, so no vtx replaced **/
				   lpec->isT = 0;
				   lpec->length = Distance(lpec->x1,lpec->y1,lpec->x2,lpec->y2);
				   lpec->Tcover = 0.0;
				   lpec->Ocover = 0.0;
				   lpec->Iedge = NULL;
				   lpec->DeltaZ1 = lpec->DeltaZ2 = 0.0;
				   ii = 0;
				   if((sliverdone == 0) || (sliverratio < 0.001))
				      ii = EdgeSliverCheckOK(lpec, ModelPolyEdgeRoot, edgesin);
				   else
				      ii = 1;
				   if((ii > 0)&& (lpec->length > 0))
				      {
				      if(TPc->slope != HalfPI)
					 {
					 ++edgesin;
					 lpec->next = NULL;
					 InsertIntoEdgeList(lpec, &ModelPolyEdgeRoot, DblPolyEdgeSkipList, skiplimit);
					 }
				      else
					 {
					 ++edgesin;
					 if(vertpolysurfarea > 0)
					    {
					    lpec->next = VertModelPolyEdgeRoot;
					    VertModelPolyEdgeRoot = lpec;
					    }
					 else
					    free(lpec);
					 }
				      }
				   else
				      free(lpec);
				   }
				} /** end inserting into edge list **/
			     } /** end if not a complete duplicate **/
			  else
			     {
			     tempID = fo + filedecimal;
			     }

			  for(checkinstance = 0; checkinstance < TtlActiveChecks; checkinstance++)
			     {
			     if(
				(IsDup == 1) &&
				(CombinedCheckApplies(PolyFromFile.idn,checkinstance,G_DUPS,PolyFromFile.SACindex,PolyFromFile.SCCindex,
						      PolyFromFile.config,PolyFromFile.stratum,PolyFromFile.domain,
						      &part1,&part2,&part3)) && (part1 > 0)    &&
				      (CombinedCheckApplies(TPdup->idn,checkinstance,G_DUPS,TPdup->SACindex,TPdup->SCCindex,
				       SCCtable[TPdup->SCCindex].C, SCCtable[TPdup->SCCindex].S, SCCtable[TPdup->SCCindex].D,
							   &part1,&part2,&part3)) && (part2 > 0)
				)
			       {
				 FwriteTwoObjects(G_DUPS, Make_Correct(G_DUPS,checkinstance), 
						  PolyFromFile.idn,G_POLYGON,PolyFromFile.SACindex,tempID,PolyFromFile.SCCindex,-1.0,-1.0,
						  PolyFromFile.numverts,PolyFromFile.x,
						  PolyFromFile.y,PolyFromFile.z,
						  TPdup->idn,G_POLYGON,TPdup->SACindex,TPdup->localID,TPdup->SCCindex,-1.0,-1.0,TPdup->numverts,
						  TPdup->x, TPdup->y,TPdup->z);
				}




			     if(
				(IsDup == 4) &&
				(CombinedCheckApplies(PolyFromFile.idn,checkinstance,C_DUPS,PolyFromFile.SACindex,PolyFromFile.SCCindex,
						      PolyFromFile.config,PolyFromFile.stratum,PolyFromFile.domain,
						      &part1,&part2,&part3)) && (part1 > 0)   &&
				      (CombinedCheckApplies(TPdup->idn,checkinstance,C_DUPS,TPdup->SACindex,TPdup->SCCindex,
				       SCCtable[TPdup->SCCindex].C, SCCtable[TPdup->SCCindex].S, SCCtable[TPdup->SCCindex].D,
							   &part1,&part2,&part3)) && (part1 > 0)
				)
			       {
				 FwriteTwoObjects(C_DUPS, Make_Correct(C_DUPS,checkinstance),  
						  PolyFromFile.idn,G_POLYGON,PolyFromFile.SACindex,tempID,PolyFromFile.SCCindex,-1.0,-1.0,
						  PolyFromFile.numverts,PolyFromFile.x,
						  PolyFromFile.y,PolyFromFile.z,
						  TPdup->idn,G_POLYGON,TPdup->SACindex,TPdup->localID,TPdup->SCCindex,-1.0,-1.0,TPdup->numverts,
						  TPdup->x, TPdup->y,TPdup->z);
			       }


			     
			     if(IsDup < UseDupThreshold)
			       {
				 if(sliverdone == 0)
				   {
				     sliverdone = CalculateSliverRating(PolyFromFile.x,PolyFromFile.y,PolyFromFile.z,
									PolyFromFile.numverts,&width,&height,&sliverratio);
				   }
				 
				 if((CombinedCheckApplies(PolyFromFile.idn,checkinstance,V_DUPS,PolyFromFile.SACindex,PolyFromFile.SCCindex,
							 PolyFromFile.config,PolyFromFile.stratum,PolyFromFile.domain,
							 &part1,&part2,&part3)) && (part1 > 0))
				   {
				     dv = DuplicateVerticesExist(PolyFromFile.numverts,
								    PolyFromFile.x,PolyFromFile.y,PolyFromFile.z);
				     if(SensitivityCheck(GT, V_DUPS, checkinstance, (double) dv) > 0)
				       {
				       for(jj=1; jj<PolyFromFile.numverts; jj++)
					 {
					 if((PolyFromFile.x[jj-1] == PolyFromFile.x[jj]) &&
					     (PolyFromFile.y[jj-1] == PolyFromFile.y[jj]) &&
					     (PolyFromFile.z[jj-1] == PolyFromFile.z[jj]))
					    {
                                            FwriteObject(V_DUPS,Make_Correct(V_DUPS,checkinstance),PolyFromFile.SACindex,
                                                           PolyFromFile.SCCindex,G_POLYGON,TPc->localID,PolyFromFile.idn, -1.0, -1.0,
                                                            &PolyFromFile.x[jj],&PolyFromFile.y[jj],&PolyFromFile.z[jj],1, 1);
					    }
					 }
				       }
				   }




				 if(CombinedCheckApplies(PolyFromFile.idn,checkinstance,SLIVER,PolyFromFile.SACindex,PolyFromFile.SCCindex,
							 PolyFromFile.config,PolyFromFile.stratum,PolyFromFile.domain,
							 &part1,&part2,&part3))
				   {
				     if((part1 > 0) &&
					(sliverdone > 0) &&
					(SensitivityCheck(LT, SLIVER, checkinstance, sliverratio) > 0)
					)
				       {
					 FwriteObjectAndMagnitude(SLIVER, Make_Correct(SLIVER,checkinstance), 
								  PolyFromFile.idn, PolyFromFile.SCCindex,
								  G_POLYGON,PolyFromFile.SACindex,TPc->localID,-1.0,-1.0,sliverratio,
								  PolyFromFile.x, PolyFromFile.y,PolyFromFile.z,
								  PolyFromFile.numverts, 1);
				       }
				   }


				if(CombinedCheckApplies(PolyFromFile.idn,checkinstance,NARROW,PolyFromFile.SACindex,PolyFromFile.SCCindex,
							PolyFromFile.config,PolyFromFile.stratum,PolyFromFile.domain,
							&part1,&part2,&part3))
				   {
				   if((part1 > 0) &&
				      (sliverdone > 0) &&
				      (SensitivityCheck(LT, NARROW, checkinstance, width) > 0)
				      )
				     {
				       FwriteObjectAndMagnitude(NARROW,Make_Correct(NARROW,checkinstance), 
								PolyFromFile.idn, PolyFromFile.SCCindex,
								G_POLYGON,PolyFromFile.SACindex,TPc->localID,-1.0,-1.0,
								width,PolyFromFile.x, PolyFromFile.y,PolyFromFile.z,
								PolyFromFile.numverts, 1);
				     }
				   }



				if((CombinedCheckApplies(PolyFromFile.idn,checkinstance,SMALLOBJ,PolyFromFile.SACindex,PolyFromFile.SCCindex,
							PolyFromFile.config,PolyFromFile.stratum,PolyFromFile.domain,
							&part1,&part2,&part3)) && (part1 > 0))
				  {
				    surfacearea3D = SurfaceAreaByTriangles(PolyFromFile.numverts, PolyFromFile.x,
									   PolyFromFile.y,PolyFromFile.z);

				    if(SensitivityCheck(LT, SMALLOBJ, checkinstance, surfacearea3D) > 0)
				      {
					FwriteObjectAndMagnitude(SMALLOBJ,Make_Correct(SMALLOBJ,checkinstance), 
								 PolyFromFile.idn, PolyFromFile.SCCindex,
								 G_POLYGON,PolyFromFile.SACindex,TPc->localID,-1.0,-1.0,
								 surfacearea3D,PolyFromFile.x, PolyFromFile.y,PolyFromFile.z,
								 PolyFromFile.numverts, 1);
				      }
				  } 
				


				if((CombinedCheckApplies(PolyFromFile.idn,checkinstance,ATTRERR,PolyFromFile.SACindex,PolyFromFile.SCCindex,
							PolyFromFile.config,PolyFromFile.stratum,PolyFromFile.domain,
							&part1,&part2,&part3)) && (part1 > 0))
				  {
				    if(CrsWlk[PolyFromFile.SACindex].AttrErr >= 0)
				      {
					FwriteObjectAndMessage(ATTRERR,Make_Correct(ATTRERR,checkinstance), 
							       PolyFromFile.idn, G_POLYGON,PolyFromFile.SACindex,TPc->localID,
							       PolyFromFile.SCCindex,-1.0,-1.0,PolyFromFile.x,
							       PolyFromFile.y,PolyFromFile.z,PolyFromFile.numverts,
							       AttrErr[CrsWlk[PolyFromFile.SACindex].AttrErr].description);
				      }
				  }


				if(
				   (CombinedCheckApplies(PolyFromFile.idn,checkinstance,HSLOPE,PolyFromFile.SACindex,PolyFromFile.SCCindex,
							 PolyFromFile.config,PolyFromFile.stratum,PolyFromFile.domain,
							 &part1,&part2,&part3)) 
				   ||
				   (CombinedCheckApplies(PolyFromFile.idn,checkinstance,VERTSLOPE,PolyFromFile.SACindex,PolyFromFile.SCCindex,
							 PolyFromFile.config,PolyFromFile.stratum,PolyFromFile.domain,
							 &part1,&part2,&part3))
				   )
				  {
				    if(TPc->slope < 1.75)
				      {
					angle = TPc->slope;
					if((angle >= HalfPI) &&
					   (CombinedCheckApplies(PolyFromFile.idn,checkinstance,VERTSLOPE,PolyFromFile.SACindex,
								 PolyFromFile.SCCindex,PolyFromFile.config,
								 PolyFromFile.stratum,PolyFromFile.domain,
								 &part1,&part2,&part3)) && (part1 > 0))
					  {
					    FwriteObject(VERTSLOPE, Make_Correct(VERTSLOPE,checkinstance), 
							 PolyFromFile.SACindex,
							 PolyFromFile.SCCindex, G_POLYGON,TPc->localID /** need poly localID here **/,PolyFromFile.idn,-1.0,-1.0,
							 PolyFromFile.x,PolyFromFile.y,PolyFromFile.z,PolyFromFile.numverts, 1);
					  }



					angle = RadiansToDegrees(angle);
					if(
					   (CombinedCheckApplies(PolyFromFile.idn,checkinstance,HSLOPE,PolyFromFile.SACindex,
								 PolyFromFile.SCCindex,PolyFromFile.config,
								 PolyFromFile.stratum,PolyFromFile.domain,
								 &part1,&part2,&part3))  
					   && (part1 > 0) &&
					   (SensitivityCheck(GT, HSLOPE, checkinstance, angle) > 0)
					   )
					  {
					    FwriteObjectAndMagnitude(HSLOPE, Make_Correct(HSLOPE,checkinstance),
								     PolyFromFile.idn, 
								     PolyFromFile.SCCindex,G_POLYGON,PolyFromFile.SACindex,TPc->localID,-1.0,-1.0,
								     angle,PolyFromFile.x, PolyFromFile.y,PolyFromFile.z,
								     PolyFromFile.numverts, 1);
					  }
				      }
				  }
			       }
			     }  /*** end for(checkinstance = 0; checkinstance < TtlActiveChecks; checkinstance++) ***/
			  }
		       ++valuesread;
		       free(PolyFromFile.x);
		       free(PolyFromFile.y);
		       free(PolyFromFile.z);
		       }


		    CheckEdgeTopology(ModelPolyEdgeRoot,VertModelPolyEdgeRoot,1);
		    lpec = ModelPolyEdgeRoot;
		    while(lpec != NULL)
		       {
		       TPn = (struct ThePolys *) lpec->owner;
		       for(checkinstance = 0; checkinstance < TtlActiveChecks; checkinstance++)
			  {
			  if((lpec->Tcover < lpec->length) && /*** undercovered edge **/
			    (CombinedCheckApplies(TPn->idn,checkinstance,HTEAR,TPn->SACindex,TPn->SCCindex,TPn->config,
				    TPn->stratum,TPn->domain,&part1,&part2,&part3) > 0) && (part1 > 0))
			     {
			     pcCoverage = 1.0 - (lpec->Tcover / lpec->length);
			     pcCoverage = pcCoverage * 100.0;
			     if(SensitivityCheck(GT, HTEAR, checkinstance, pcCoverage) > 0)
				{
				neighborhit = 0;
				if(NeighborsExist[0] == 0)
				   {
				   if((PointOnLineSegment(lpec->x1,lpec->y1,rlx,rly,rux,rly,0.01) > 0) &&
				    (PointOnLineSegment(lpec->x2,lpec->y2,rlx,rly,rux,rly,0.01) > 0))
				   ++neighborhit;
				   }
				if(NeighborsExist[1] == 0)
				   {
				   if((PointOnLineSegment(lpec->x1,lpec->y1,rlx,rly,rlx,ruy,0.01) > 0) &&
				    (PointOnLineSegment(lpec->x2,lpec->y2,rlx,rly,rlx,ruy,0.01) > 0))
				   ++neighborhit;
				   }
				if(NeighborsExist[2] == 0)
				   {
				   if((PointOnLineSegment(lpec->x1,lpec->y1,rlx,ruy,rux,ruy,0.01) > 0) &&
				       (PointOnLineSegment(lpec->x2,lpec->y2,rlx,ruy,rux,ruy,0.01) > 0))
				   ++neighborhit;
				   }
				if(NeighborsExist[3] == 0)
				   {
				   if((PointOnLineSegment(lpec->x1,lpec->y1,rux,rly,rux,ruy,0.01) > 0) &&
					  (PointOnLineSegment(lpec->x2,lpec->y2,rux,rly,rux,ruy,0.01) > 0))
				   ++neighborhit;
				   }
				if(neighborhit == 0)
				   {
				   edgeX[0] = lpec->x1;
				   edgeY[0] = lpec->y1;
				   edgeZ[0] = lpec->z1;
				   edgeX[1] = lpec->x2;
				   edgeY[1] = lpec->y2;
				   edgeZ[1] = lpec->z2;
				   FwriteObjectAndMagnitude(HTEAR,Make_Correct(HTEAR,checkinstance),
					     TPn->idn, TPn->SCCindex,G_POLYGON,TPn->SACindex,TPn->localID,-1.0,-1.0,
					     pcCoverage,edgeX, edgeY,edgeZ,2, 1);
				   }
				}
			     }
			  else if((lpec->Ocover > lpec->length) &&  /** over-covered edge **/
				 (CombinedCheckApplies(TPn->idn,checkinstance,OVERC,TPn->SACindex,TPn->SCCindex,TPn->config,
				       TPn->stratum,TPn->domain,&part1,&part2,&part3) > 0) && (part1 > 0))
			     {
			     edgeX[0] = lpec->x1;
			     edgeY[0] = lpec->y1;
			     edgeZ[0] = lpec->z1;
			     edgeX[1] = lpec->x2;
			     edgeY[1] = lpec->y2;
			     edgeZ[1] = lpec->z2;
			     FwriteObjectAndMagnitude(OVERC, Make_Correct(OVERC,checkinstance),
				   TPn->idn, TPn->SCCindex,G_POLYGON,TPn->SACindex,TPn->localID,-1.0,-1.0,
				   lpec->Ocover/lpec->length*100.0,edgeX, edgeY,edgeZ,2, 1);
			     }

			  if((CombinedCheckApplies(TPn->idn,checkinstance,VTEAR,TPn->SACindex,TPn->SCCindex,TPn->config,
				       TPn->stratum,TPn->domain,&part1,&part2,&part3) > 0) && (part1 > 0))
			     {
			     IE1 = lpec->Iedge;
			     while(IE1 != NULL)
				{
				if((IE1->primary == 1) &&
				      (SensitivityCheck(GT, VTEAR, checkinstance, IE1->DeltaZ) > 0))
				   {
				   AdjEdge = (struct ListOfEdges *) IE1->AdjacentEdge;
				   TPadj = (struct ThePolys *) AdjEdge->owner;
				   if((lpec->x1 == IE1->DeltaZX) && (lpec->y1 == IE1->DeltaZY))
				      {
				      edgeX[0] = lpec->x1;
				      edgeY[0] = lpec->y1;
				      edgeZ[0] = lpec->z1;
				      edgeX[1] = lpec->x2;
				      edgeY[1] = lpec->y2;
				      edgeZ[1] = lpec->z2;
	   
				      edgeX[2] = AdjEdge->x1;
				      edgeY[2] = AdjEdge->y1;
				      edgeZ[2] = AdjEdge->z1;
				      edgeX[3] = AdjEdge->x2;
				      edgeY[3] = AdjEdge->y2;
				      edgeZ[3] = AdjEdge->z2;
				      FwriteMagnitudeAndTwoObjects(VTEAR, Make_Correct(VTEAR,checkinstance),IE1->DeltaZ,
					  TPn->SCCindex,G_POLYGON,TPn->SACindex,
					  TPn->localID,TPn->idn,-1.0, -1.0,edgeX, edgeY,edgeZ,2,
					  TPadj->SCCindex,G_POLYGON,TPadj->SACindex,
					  TPadj->localID,TPadj->idn,-1.0, -1.0,&edgeX[2], &edgeY[2],&edgeZ[2],2);
				      }
				   else if((lpec->x2 == IE1->DeltaZX) && (lpec->y2 == IE1->DeltaZY))
				      {
				      edgeX[0] = lpec->x2;
				      edgeY[0] = lpec->y2;
				      edgeZ[0] = lpec->z2;
				      edgeX[1] = lpec->x1;
				      edgeY[1] = lpec->y1;
				      edgeZ[1] = lpec->z1;

				      edgeX[2] = AdjEdge->x1;
				      edgeY[2] = AdjEdge->y1;
				      edgeZ[2] = AdjEdge->z1;
				      edgeX[3] = AdjEdge->x2;
				      edgeY[3] = AdjEdge->y2;
				      edgeZ[3] = AdjEdge->z2;
				      FwriteMagnitudeAndTwoObjects(VTEAR, Make_Correct(VTEAR,checkinstance),IE1->DeltaZ,
					  TPn->SCCindex,G_POLYGON,TPn->SACindex,
					  TPn->localID,TPn->idn,-1.0, -1.0,edgeX, edgeY,edgeZ,2,
					  TPadj->SCCindex,G_POLYGON,TPadj->SACindex,
					  TPadj->localID,TPadj->idn,-1.0, -1.0,&edgeX[2], &edgeY[2],&edgeZ[2],2);
				      }
				   else if((AdjEdge->x1 == IE1->DeltaZX) && (AdjEdge->y1 == IE1->DeltaZY))
				      {
				      edgeX[0] = AdjEdge->x1;
				      edgeY[0] = AdjEdge->y1;
				      edgeZ[0] = AdjEdge->z1;
				      edgeX[1] = AdjEdge->x2;
				      edgeY[1] = AdjEdge->y2;
				      edgeZ[1] = AdjEdge->z2;

				      edgeX[2] = lpec->x1;
				      edgeY[2] = lpec->y1;
				      edgeZ[2] = lpec->z1;
				      edgeX[3] = lpec->x2;
				      edgeY[3] = lpec->y2;
				      edgeZ[3] = lpec->z2;
				      FwriteMagnitudeAndTwoObjects(VTEAR, Make_Correct(VTEAR,checkinstance),IE1->DeltaZ,
					  TPadj->SCCindex,G_POLYGON,TPadj->SACindex,
					   TPadj->localID,TPadj->idn,-1.0, -1.0,edgeX, edgeY,edgeZ,2,
					  TPn->SCCindex,G_POLYGON,TPn->SACindex,
					   TPn->localID,TPn->idn,-1.0, -1.0,&edgeX[2], &edgeY[2],&edgeZ[2],2);
				      }
				   else if((AdjEdge->x2 == IE1->DeltaZX) && (AdjEdge->y2 == IE1->DeltaZY))
				      {                           edgeX[0] = AdjEdge->x2;
				      edgeY[0] = AdjEdge->y2;
				      edgeZ[0] = AdjEdge->z2;
				      edgeX[1] = AdjEdge->x1;
				      edgeY[1] = AdjEdge->y1;
				      edgeZ[1] = AdjEdge->z1;
	   
				      edgeX[2] = lpec->x1;
				      edgeY[2] = lpec->y1;
				      edgeZ[2] = lpec->z1;
				      edgeX[3] = lpec->x2;
				      edgeY[3] = lpec->y2;
				      edgeZ[3] = lpec->z2;
				      FwriteMagnitudeAndTwoObjects(VTEAR, Make_Correct(VTEAR,checkinstance),IE1->DeltaZ,
					  TPadj->SCCindex,G_POLYGON,TPadj->SACindex,
					   TPadj->localID,TPadj->idn,-1.0, -1.0,edgeX, edgeY,edgeZ,2,
					  TPn->SCCindex,G_POLYGON,TPn->SACindex,
					   TPn->localID,TPn->idn,-1.0, -1.0,&edgeX[2], &edgeY[2],&edgeZ[2],2);
				      }
				   }
				else if((IE1->primary == 3) &&
				      (SensitivityCheck(GT, VTEAR, checkinstance, IE1->DeltaZ) > 0))
				   {
				   AdjEdge = (struct ListOfEdges *) IE1->AdjacentEdge;
				   TPadj = (struct ThePolys *) AdjEdge->owner;
				   if((lpec->x1 == IE1->DeltaZX) && (lpec->y1 == IE1->DeltaZY))
				      {
				      edgeX[0] = lpec->x1;
				      edgeY[0] = lpec->y1;
				      edgeZ[0] = lpec->z1;
	   
				      edgeX[2] = AdjEdge->x1;
				      edgeY[2] = AdjEdge->y1;
				      edgeZ[2] = AdjEdge->z1;
				      edgeX[3] = AdjEdge->x2;
				      edgeY[3] = AdjEdge->y2;
				      edgeZ[3] = AdjEdge->z2;
				      FwriteMagnitudeAndTwoObjects(VTEAR, Make_Correct(VTEAR,checkinstance),IE1->DeltaZ,
					  TPn->SCCindex,G_POLYGON,TPn->SACindex,
					  TPn->localID,TPn->idn,-1.0, -1.0,edgeX, edgeY,edgeZ,1,
					  TPadj->SCCindex,G_POLYGON,TPadj->SACindex,
					  TPadj->localID,TPadj->idn,-1.0, -1.0,&edgeX[2], &edgeY[2],&edgeZ[2],2);
				      }
				   else if((lpec->x2 == IE1->DeltaZX) && (lpec->y2 == IE1->DeltaZY))
				      {
				      edgeX[0] = lpec->x2;
				      edgeY[0] = lpec->y2;
				      edgeZ[0] = lpec->z2;
	   
				      edgeX[2] = AdjEdge->x1;
				      edgeY[2] = AdjEdge->y1;
				      edgeZ[2] = AdjEdge->z1;
				      edgeX[3] = AdjEdge->x2;
				      edgeY[3] = AdjEdge->y2;
				      edgeZ[3] = AdjEdge->z2;
				      FwriteMagnitudeAndTwoObjects(VTEAR, Make_Correct(VTEAR,checkinstance),IE1->DeltaZ,
					  TPn->SCCindex,G_POLYGON,TPn->SACindex,
					  TPn->localID,TPn->idn,-1.0, -1.0,edgeX, edgeY,edgeZ,1,
					  TPadj->SCCindex,G_POLYGON,TPadj->SACindex,
					  TPadj->localID,TPadj->idn,-1.0, -1.0,&edgeX[2], &edgeY[2],&edgeZ[2],2);
				      }
				   }
				else if((IE1->primary == 5) &&
				      (SensitivityCheck(GT, VTEAR, checkinstance, IE1->DeltaZ) > 0))
				   {
				   AdjEdge = (struct ListOfEdges *) IE1->AdjacentEdge;
				   TPadj = (struct ThePolys *) AdjEdge->owner;
				   if((lpec->x1 == IE1->DeltaZX) && (lpec->y1 == IE1->DeltaZY))
				      {
				      edgeX[0] = lpec->x1;
				      edgeY[0] = lpec->y1;
				      edgeZ[0] = lpec->z1;
				      }
				   else
				      {
				      edgeX[0] = lpec->x2;
				      edgeY[0] = lpec->y2;
				      edgeZ[0] = lpec->z2;
				      }
				   if((AdjEdge->x1 == IE1->DeltaZX) && (AdjEdge->y1 == IE1->DeltaZY))
				      {
				      edgeX[2] = AdjEdge->x1;
				      edgeY[2] = AdjEdge->y1;
				      edgeZ[2] = AdjEdge->z1;
				      }
				   else
				      {
				      edgeX[2] = AdjEdge->x2;
				      edgeY[2] = AdjEdge->y2;
				      edgeZ[2] = AdjEdge->z2;
				      }

				   FwriteMagnitudeAndTwoObjects(VTEAR, Make_Correct(VTEAR,checkinstance),IE1->DeltaZ,
				       TPn->SCCindex,G_POLYGON,TPn->SACindex,
				       TPn->localID,TPn->idn,-1.0, -1.0,edgeX, edgeY,edgeZ,1,
				       TPadj->SCCindex,G_POLYGON,TPadj->SACindex,
				       TPadj->localID,TPadj->idn,-1.0, -1.0,&edgeX[2], &edgeY[2],&edgeZ[2],1);
				   }
				IE1 = IE1->next;
				}
			     }
			  } /*** end for(checkinstance = 0; checkinstance < TtlActiveChecks; checkinstance++) ***/

		       lpec = lpec->next;
		       }
		    } /** end if doing something with model polygon objects ***/





		 if((NGA_TYPE == 0) && (abortNow == 0) && (MProot != NULL))
		    {
		    if(TProot == NULL)
		       {
		       TProot = MProot;
		       PolyEdgeRoot = ModelPolyEdgeRoot;
		       VertPolyEdgeRoot = VertModelPolyEdgeRoot;
		       }
		    else
		       {
		       TPc = TProot;
		       while(TPc->next != NULL)
			  TPc = TPc->next;
		       TPc->next = MProot;
		       if(PolyEdgeRoot == NULL)
			  PolyEdgeRoot = ModelPolyEdgeRoot;
		       else
			  {
			  lpec = PolyEdgeRoot;
			  while(lpec->next != NULL)
			     lpec = lpec->next;
			  lpec->next = ModelPolyEdgeRoot;
			  }
		       lpec = VertPolyEdgeRoot;
		       if(VertPolyEdgeRoot == NULL)
			  VertPolyEdgeRoot =  VertModelPolyEdgeRoot;
		       else
			  {
			  lpec = VertPolyEdgeRoot;
			  while(lpec->next != NULL)
			     lpec = lpec->next;
			  lpec->next = VertModelPolyEdgeRoot;
			  }
		       }
		    }
		 

		 if(abortNow == 0)
		    {
                    PerformDEMandFeatureChecks(portiondone,compositeindex,RLroot,minx,miny,maxx,maxy, multiplier,
                        NorthNeighborCount, SouthNeighborCount, EastNeighborCount, WestNeighborCount,
                        ARroot,RBroot,RProot,PolyEdgeRoot,VertPolyEdgeRoot,NRLroot,TProot);

		    PerformAttrEdgeMatchChecks(portiondone,compositeindex,RLroot,minx,miny,maxx,maxy, multiplier,
                        NorthNeighborCount, SouthNeighborCount, EastNeighborCount, WestNeighborCount,
			ARroot,RBroot,RProot,PolyEdgeRoot,VertPolyEdgeRoot,NRLroot,TProot);

                    PerformEdgeMatchChecks(portiondone,compositeindex,RLroot,minx,miny,maxx,maxy, multiplier,
                         NorthNeighborCount, SouthNeighborCount, EastNeighborCount, WestNeighborCount,
                         ARroot,RBroot,RProot,PolyEdgeRoot,VertPolyEdgeRoot,NRLroot,TProot);

                    PerformRangeLimitedEdgeMatchChecks(portiondone,compositeindex,RLroot,minx,miny,maxx,maxy, multiplier,
                        NorthNeighborCount, SouthNeighborCount, EastNeighborCount, WestNeighborCount,
                        ARroot,RBroot,RProot,PolyEdgeRoot,VertPolyEdgeRoot,NRLroot,TProot);

		    PerformLinearRelatedChecks(portiondone,compositeindex,RLroot,minx,miny,maxx,maxy, multiplier,
                        NorthNeighborCount, SouthNeighborCount, EastNeighborCount, WestNeighborCount,
			ARroot,RBroot,RProot,PolyEdgeRoot,VertPolyEdgeRoot,NRLroot,NRAroot,TProot, SzPC, SzPW, index1);

		    PerformLinearOverUnderChecks(portiondone,compositeindex,RLroot,minx,miny,maxx,maxy, multiplier,
                        NorthNeighborCount, SouthNeighborCount, EastNeighborCount, WestNeighborCount,
			ARroot,NRAroot,RBroot,RProot,PolyEdgeRoot,VertPolyEdgeRoot,NRLroot,TProot);

                    PerformMoreLinearRelatedChecks(portiondone,compositeindex,RLroot,minx,miny,maxx,maxy, multiplier,
                        NorthNeighborCount, SouthNeighborCount, EastNeighborCount, WestNeighborCount,
                        ARroot,RBroot,RProot,PolyEdgeRoot,VertPolyEdgeRoot,NRLroot,NRAroot,TProot, SzPC, SzPW, index1);

                    PerformAllGeomChecks(portiondone,compositeindex,RLroot,minx,miny,maxx,maxy, multiplier,
                        ARroot,RBroot,RProot,PolyEdgeRoot,VertPolyEdgeRoot,NRLroot,TProot, SzPC, SzPW, index1);
		    PerformPointRelatedChecks(ptsin,portiondone,compositeindex,RProot,minx,miny,maxx,maxy, multiplier,RLroot,TProot,ARroot,NRAroot,LENcode, WIDcode);

		    PerformPolyChecks(TProot,ARroot,RProot);

		    PerformOtherPolyChecks(TProot,ARroot,RProot,RLroot,PolyLODbandCount);
                    if((CheckCOVERFAIL > 0) && (TtlCoverFailures < MAXCOVERFAILURES))
                       {
                       EdgeAddRoot = LAEroot;
                       LAEroot = NULL;
                       }
		    PerformArealRelatedChecks(portiondone,compositeindex,ARroot,minx,miny,maxx,maxy, multiplier,
                        NorthNeighborCount, SouthNeighborCount, EastNeighborCount, WestNeighborCount,
			RLroot,RBroot,RProot,PolyEdgeRoot,NRAroot,index1, SzPC, SzPW);

                    if((CheckNETISOA > 0) || (CheckANETISOA > 0))
                       {
                       PerformTransitiveChecks(portiondone,compositeindex,ARroot,minx,miny,maxx,maxy, multiplier,
                        NorthNeighborCount, SouthNeighborCount, EastNeighborCount, WestNeighborCount,
                        RLroot,RBroot,RProot,PolyEdgeRoot,NRAroot,index1, SzPC, SzPW);
                       }

                    if((CheckCONFLATE > 0) || (CheckCONF_STATS > 0))
                       {
                       PerformConflationAnalyses(portiondone,compositeindex,RLroot,minx,miny,maxx,maxy, multiplier,
                        NorthNeighborCount, SouthNeighborCount, EastNeighborCount, WestNeighborCount,
                        ARroot,RBroot,RProot,PolyEdgeRoot,VertPolyEdgeRoot,NRLroot,TProot, SzPC, SzPW, index1);

                       if(CheckCONF_STATS > 0)
                          {
                          temp = minx + ((maxx - minx) / 2.0);
                          temp2 = miny + ((maxy - miny) / 2.0);
                          sprintf(CoordStr,"%.7lf %.7lf",temp/100000.0 + Xtranslation,
                                                     temp2/100000.0 + Ytranslation);
                          CSc = CSroot;
                          while(CSc != NULL)
                             {
                             if(CSc->TC != NULL)
                                {
                                TCc = CSc->TC;
                                if(TCc != NULL)
                                   {
                                   if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
                                      {
                                      sprintf(tempstring,"%spoints_of_interest_files\\InformativeAttrFile_%d.txt",                                                 indirectory,CSc->fileindex);
                                      }
                                   else
                                      {
                                      sprintf(tempstring,"%spoints_of_interest_files/InformativeAttrFile_%d.txt",                                                  indirectory,CSc->fileindex);
                                      }
                                   CstatsOut = fopen(tempstring,"at");

                                   tempstring2[0] = '\0';
                                   
                                   temp = temp2 = 0.0;
                                   while(TCc != NULL)
                                      {
                                      temp += TCc->good;
                                      temp2 += TCc->bad;
                                      sprintf(MessageLine,"(%s,%s,%s) ",
                                           GetECCCode(TCc->ECC),GetEACCode(TCc->EAC),ParseGAITgeometry((unsigned char) TCc->geom,2));
                                      if((strlen(MessageLine) + strlen(tempstring2)) < 490)
                                         strcat(tempstring2,MessageLine);

                                      TCp = TCc;
                                      TCc = TCc->next;
                                      free(TCp);
                                      }
                                   CSc->TC = NULL;
                                   temp = temp / (temp + temp2);
                                   temp = temp * 100.0;
                                   part3 = CSc->marktype;
                                   if(temp >= 75.0)
                                      part3 += 2;
                                   else if(temp >= 50.0)
                                      part3 += 1;
                                   else if(temp >= 25.0)
                                      part3 += 3;

                                   fprintf(CstatsOut,"%d %s %s\n",part3,CoordStr,tempstring2);
                                      
                                   fclose(CstatsOut);
                                   CstatsOut = NULL;
                                   }
                                }
                             CSc = CSc->next;
                             }
                          }
                       }

/***/PrintAndFreeCTC(compositeindex); /***/

                    if((CheckCOVERFAIL > 0) && (TtlCoverFailures < MAXCOVERFAILURES))
                       {
                       if((EdgeAddRoot != NULL) && (LAEroot == NULL))
                          LAEroot = EdgeAddRoot;
                       else if(LAEroot != NULL)
                          {
                          LAEadded2 = LAEroot;
                          LAEroot = EdgeAddRoot;
                          LAEadded = LAEadded2;
                          while(LAEadded != NULL)
                             {
                             MatchAreaEdge(LAEadded->x1,LAEadded->y1,LAEadded->z1,LAEadded->x2,LAEadded->y2,LAEadded->z2,
                                        LAEadded->UID, LAEadded->cnumb,LAEadded->idn,LAEadded->Sindex,LAEadded->Lindex);
                             LAEadded2 = LAEadded;
                             LAEadded = LAEadded->next;
                             free(LAEadded2);
                             }
                          TtlCoverFailures = 0;
                          LAEadded = LAEroot;
                          while(LAEadded != NULL)
                             {
                             ++TtlCoverFailures;
                             LAEadded = LAEadded->next;
                             }
                          LAEadded = KnownRoot;
                          while(LAEadded != NULL)
                             {
                             ++TtlCoverFailures;
                             LAEadded = LAEadded->next;
                             }
                          }
                       }

                    PseudoNodesAdded = 0;
                    if(FormNetworks > 0)
                       {
                       ARc = ARroot;
                       while(ARc != NULL)
                          {
                          ARc->coversLM = ARc->numverts;
                          ARc = ARc->next;
                          }
                       RLc = RLroot;
                       while(RLc != NULL)
                          {
                          RLc->NumIntersections = RLc->numnodes;
                          RLc = RLc->next;
                          }
                       for(i = 0; i < TtlActiveChecks; i++)
                          {
                          if((INTERSECTION_BASED > 0) && (ActiveChecks[i].number == CREATENET) && 
                                (PseudoNodesAdded == 0))
                             {
                             AddPseudoNodesAtIntersections(&RLroot, &ARroot, RProot,
                                         compositeindex, i, minx,miny,maxx,maxy);
                             PseudoNodesAdded = 1;
                             }
                          if((ActiveChecks[i].number == CREATENET) ||
                                  (ActiveChecks[i].number == EXTRA_NET) || (ActiveChecks[i].number == INTRA_NET))
                             {
                             AddPseudoNodeFromOuterToInnerRings(ARroot, compositeindex);
                             AddEdgesToNetwork(RLroot, ARroot, RProot, compositeindex, i, minx,miny,maxx,maxy);
                             RemoveInnerRingPseudoNode(ARroot, compositeindex);
                             }
                          }
                       }

                    if(BucketsOfTransNets != NULL)
                       {
                       if(FormNetworks <= 0)
                          {
                          ARc = ARroot;
                          while(ARc != NULL)
                             {
                             ARc->coversLM = ARc->numverts;
                             ARc = ARc->next;
                             }
                          RLc = RLroot;
                          while(RLc != NULL)
                             {
                             RLc->NumIntersections = RLc->numnodes;
                             RLc = RLc->next;
                             }
                          }
                       ii = 0;
                       for(i = 0; i < TtlActiveChecks; i++)
                          {
                          if(ActiveChecks[i].number == NETISOFEAT)
                             {
                             if(PseudoNodesAdded == 0)
                                {
                                if(ActiveChecks[i].sensitivity2 > 0)
                                   AddPseudoNodesAtIntersections(&RLroot, &ARroot, RProot,
                                         compositeindex, i, minx,miny,maxx,maxy);
                                PseudoNodesAdded = 1;
                                }

                             ++ii;
                             AddPseudoNodeFromOuterToInnerRings(ARroot, compositeindex);
                             AddEdgesToTransNetwork(RLroot, ARroot, RProot,compositeindex, i,
                                   NorthNeighborCount, SouthNeighborCount, EastNeighborCount, WestNeighborCount,
                                     minx,miny,maxx,maxy,PseudoNodesAdded);
                             RemoveInnerRingPseudoNode(ARroot, compositeindex);
                             }
                          }
if(ii > 0)
{
CheckForBndryRemoval(compositeindex, RLroot, ARroot, RProot,
                                   NorthNeighborCount, SouthNeighborCount, EastNeighborCount, WestNeighborCount);
}
                       }
                    if(PseudoNodesAdded > 0)
                       {
                          ARc = ARroot;
                          while(ARc != NULL)
                             {
                             if(ARc->coversLM >= LARGEAREALVERTEXLIMIT)
                                ARc->numverts = ARc->coversLM;
                             ARc = ARc->next;
                             }

                       }
		    }


		 FreePolygonList(TProot, PolyEdgeRoot, VertPolyEdgeRoot);
		 TProot = NULL;
		 PolyEdgeRoot = NULL;
		 VertPolyEdgeRoot = NULL;
		 MProot = NULL;
		 ModelPolyEdgeRoot = NULL;
		 VertModelPolyEdgeRoot = NULL;
                 if((index1 >= Uindex1) && (index2 >= Uindex2))
                    FreeArealList(ARroot, ArealEdgeRoot, 0);
                 else
                    FreeArealList(ARroot, ArealEdgeRoot, compositeindex);
		 ARroot = NULL;
		 ArealEdgeRoot = NULL;
                 if((index1 >= Uindex1) && (index2 >= Uindex2))
                    FreeArealList(NRAroot,NULL, 0);
                 else
                    FreeArealList(NRAroot,NULL, compositeindex);
		 NRAroot = NULL;


		 for(ii=0; ii<skiplimit; ii++)
		    {
		    DblPolySkipList[ii].val = -1.0;
		    DblPolySkipList[ii].entry = NULL;
		    DblPolyEdgeSkipList[ii].val = -1.0;
		    DblPolyEdgeSkipList[ii].entry = NULL;
		    DblArealEdgeSkipList[ii].val = -1.0;
		    DblArealEdgeSkipList[ii].entry = NULL;
		    DblModelPolySkipList[ii].val = -1.0;
		    DblModelPolySkipList[ii].entry = NULL;
		    DblModelPolyEdgeSkipList[ii].val = -1.0;
		    DblModelPolyEdgeSkipList[ii].entry = NULL;
		    }
		 FreeLinearsList(RLroot);
		 RLroot = NULL;
		 FreeLinearsList(NRLroot);
		 NRLroot = NULL;
		 FreePointList(RProot);
		 RProot = NULL;
		 FreeBridgeList(RBroot);
		 RBroot = NULL;

		 regionscomplete += 100.0; /** adding 100 instead of 1 to avoid multiplication by 100 to get percent complete **/
                 if(abortNow == 0)
                    {
                    sprintf(portiondone,"%.1lf%% complete\n",regionscomplete / NumberToCheck);
                    abortNow = periodic_checking_redraw(1,"Inspection Progress",portiondone);
		    if(abortNow > 0)
		       {
		       index1Max = (double) index1 * RegionSize + RegionSize;
		       index2Max = (double) index2 * RegionSize + RegionSize;
		       break;
		       }
                    }
		 } /** end for index2 **/
              if((FeatsInNet > 0) || (FeatsAddedToNet > 0))
                 {
                 if(FeatsAddedToNet > 0)
                    FeatsInNet += FeatsAddedToNet;
                 else /** must mean we went a whole LM colum w/o adding anything to any net ***/
                    {
                    if(BucketsOfTransNets != NULL)
                       {
                       FreeAndWriteTransNetStructs();
                       FeatsInNet = 0;
                       }
                    ii2 = (MaxXindex + 1) * (MaxYindex + 1);
                    for(ii=0; ii < ii2; ii++)
                       {
                       BucketsOfTransNets[ii].netnumb = 0;
                       BucketsOfTransNets[ii].CL = NULL;
                       BucketsOfTransNets[ii].next = NULL;
                       }
                    }
                 FeatsAddedToNet = 0;
                 }

	      if(abortNow > 0)
		 {
		 index1Max = (double) index1 * RegionSize + RegionSize;
		 index2Max = (double) index2 * RegionSize + RegionSize;
		 break;
		 }
              if(CheckNOENDCON > 0)
                 {
                 //PruneAndWriteRBCheckTree(compositeindex,NOENDCON,Check_RB_Tree,Check_RB_Tree->root->left);
                 ii = index1 % 2;
                 if(ii == 0)
                    PruneAndWriteRBCheckTree(index1,NOENDCON,Check_RB_Tree,Check_RB_Tree->root->left);
                 }
              if(CheckISOLINE > 0)
                 {
                 ii = index1 % 2;
                 if(ii == 0)
                    PruneAndWriteRBCheckTree(index1,ISOLINE,Check_RB_Tree,Check_RB_Tree->root->left);
                 }
              if(CheckBOTHENDCON > 0)
                 {
                 ii = index1 % 2;
                 if(ii == 0)
                    PruneAndWriteRBCheckTree(index1,BOTHENDCON,Check_RB_Tree,Check_RB_Tree->root->left);
                 }
              for(ii=0; ii<TtlActiveChecks; ii++)
                 {
                 PruneCheckedAreaPairs(index1, ii);
                 PruneCheckedLinePairs(index1, ii);
                 }
	      } /** end for index1 **/

           if(CheckDEMSTATS > 0)
             {
             ii2 = jj2 = kk2 = -99;
             NZpoints = 0;
             if(CheckDEMSTATS == 1)
                {
                AvgElevError = GenerateKernelStats(1, Lindex1, Uindex1, Lindex2, Uindex2, 0.0, &RMSE, &NZpoints, 
                    &MaxDiff, &MD_X, &MD_Y, &ii2, &jj2, &kk2);
                StdDev = GenerateKernelStats(2, Lindex1, Uindex1, Lindex2, Uindex2, AvgElevError, &RMSE,
                         &NZpointsdiscard, &MaxDiffdiscard, &MD_Xdiscard, &MD_Ydiscard, &ii2, &jj2, &kk2);
                }
             if(NZpoints > 0)
                {
                temp = fabs(AvgElevError) / StdDev;
                if(temp > 1.4)
                   LE90factor = 1.28;
                else
                   {
                   LE90factor = 1.6435 - (0.999556 * temp);
                   temp = temp * temp;
                   LE90factor = LE90factor + (0.923237 * temp);
                   temp = temp * temp;
                   LE90factor = LE90factor - (0.282533 * temp);
                   }
                LE90 = fabs(AvgElevError) + (LE90factor * StdDev);
                sprintf(tempstring2,"%sKernelStatistics.txt",outsumdirectory);
                CstatsOut = fopen(tempstring2,"wt");
                fprintf(CstatsOut,"Statistics produced using the 5x5 Kernel Weighted Average Method\n");
                fprintf(CstatsOut,"Source File: %s\n",LODindex[CrsWlk[ii2].LODband-1].filename);
                fprintf(CstatsOut,"Reference File: %s\n",LODindex[CrsWlk[jj2].LODband-1].filename);
                if(kk2 >= 0)
                   fprintf(CstatsOut,"Mask File: %s\n",LODindex[CrsWlk[kk2].LODband-1].filename);
                else
                   fprintf(CstatsOut,"(Mask option not used)\n");
                fprintf(CstatsOut,"\n");
                fprintf(CstatsOut,"Maximum elevation difference %lf at %s from %ld differences\n",
                                MaxDiff,Coordinate2DtoString(MD_X,MD_Y),NZpoints);
                fprintf(CstatsOut,"Mean Elevation Error %lf\nRMSE %lf\nStandard Deviation %lf\nLE90 %lf\n",
                                    AvgElevError,RMSE,StdDev,LE90);
                fclose(CstatsOut);
                CstatsOut = NULL;
                }
              else if((CheckDEMSTATS == 1) && (NZpoints == 0))
                printf("No Kernel-based report generated - insufficient number of different elevation points\n");
             ii2 = jj2 = kk2 = -99;
             NZpoints = 0;
             if(CheckDEMSTATS == 2)
                {
                AvgElevError = GenerateNearestNeighborStats(1, Lindex1, Uindex1, Lindex2, Uindex2, 0.0,
                         &RMSE, &NZpoints, &MaxDiff, &MD_X, &MD_Y, &ii2, &jj2, &kk2);
                StdDev = GenerateNearestNeighborStats(2, Lindex1, Uindex1, Lindex2, Uindex2, AvgElevError,
                          &RMSE, &NZpointsdiscard, &MaxDiffdiscard, &MD_Xdiscard, &MD_Ydiscard, &ii2, &jj2, &kk2);
                }
             if(NZpoints > 0)
                {
                temp = fabs(AvgElevError) / StdDev;
                if(temp > 1.4)
                   LE90factor = 1.28;
                else
                   {
                   LE90factor = 1.6435 - (0.999556 * temp);
                   temp = temp * temp;
                   LE90factor = LE90factor + (0.923237 * temp);
                   temp = temp * temp;
                   LE90factor = LE90factor - (0.282533 * temp);
                   }
                LE90 = fabs(AvgElevError) + (LE90factor * StdDev);
                sprintf(tempstring2,"%sNearNeighborStatistics.txt",outsumdirectory);
                CstatsOut = fopen(tempstring2,"wt");
                fprintf(CstatsOut,"Statistics produced using the 2x2 Bilinear Interpolation Method\n");
                fprintf(CstatsOut,"Source File: %s\n",LODindex[CrsWlk[ii2].LODband-1].filename);
                fprintf(CstatsOut,"Reference File: %s\n",LODindex[CrsWlk[jj2].LODband-1].filename);
                if(kk2 >= 0)
                   fprintf(CstatsOut,"Mask File: %s\n",LODindex[CrsWlk[kk2].LODband-1].filename);
                else
                   fprintf(CstatsOut,"(Mask option not used)\n");
                fprintf(CstatsOut,"\n");
                fprintf(CstatsOut,"Maximum elevation difference %lf at %s from %ld differences\n",
                              MaxDiff,Coordinate2DtoString(MD_X,MD_Y),NZpoints);
                fprintf(CstatsOut,"Mean Elevation Error %lf\nRMSE %lf\nStandard Deviation %lf\nLE90 %lf\n",
                                  AvgElevError,RMSE,StdDev,LE90);
                fclose(CstatsOut);
                CstatsOut = NULL;
                }
              else if((CheckDEMSTATS == 2) && (NZpoints == 0))
                printf("No Bilinear report generated - insufficient number of different elevation points\n");
              }


           if((NumberPF >= 0) && (PF_Lindex != NULL) && (PF_Iindex != NULL))
              {
              NumberPF = -1;
              free(PF_Lindex);
              free(PF_Iindex);
              PF_Lindex = NULL;
              PF_Iindex = NULL;
              }

           if(billbout != NULL)
              {
              fclose(billbout);

              if(BillBoardPtsWritten > 0)
                 {
                 BBrefc = BillBoardChecks;
                 while(BBrefc != NULL)
                    {
                    billbout = fopen(billboardlog,"rb");
                    switch(ActiveChecks[BBrefc->index].number)
                       {
                       case MASKEDIT_0:
                       case MASKEDIT_1:
                       case MASKCONSTANT:
                       case MASKZERO:
                       case MASKCONF2:
                       case MASKCONFLICT:

                          MakeBillBoardFromPoints_DynamicInfo(billbout,BBrefc->index,1);
                          break;

                       case RAISEDPC:
                       case FLOWSTEP:
                       case BREAKLINE:
                       case WATERMMU:
                       case AVGSPIKE:
                       case GSHELF:
                       case ELEVGT:
                       case ELEVLT:
                       case ELEVEQ:
                       case ELEVEQOPEN:
                          MakeBillBoardFromPoints_DynamicInfo(billbout,BBrefc->index,1);
                          break;

                       default:
                          printf("unexpected check type in call to MakeBillBoardFromPoints\n");
                          exit(-1);
                          break;
                       }
                    fclose(billbout);

                    BillBoardPtsWritten = 0;
                    BBrefp = BBrefc;
                    BBrefc = BBrefc->next;
                    free(BBrefp);
                    }
                 }
              }


           if(CheckCONF_STATS > 0)
              {
              if(CstatsOut != NULL)
                 fclose(CstatsOut);
              CstatsOut = NULL;
              }


           if((ShadowElevations != NULL) && (NumShadowElevations > 0))
              {
              free(ShadowElevations);
              NumShadowElevations = 0;
              }


           ARUc = LatRoot;
           while(ARUc != NULL)
              {
              ARUp = ARUc;
              
              FwriteObjectAndMagnitude(ARNGE_UNM_LAT,ARUc->Cnumber,ARUc->idn,ARUc->Sindex,G_AREAL,ARUc->Lindex,
                                        ARUc->parentid, /*** parentid holds localID***/
                                        -1.0,-1.0,Distance(ARUc->x[0],ARUc->y[0],ARUc->x[1],ARUc->y[1]),
                                        &ARUc->x[0],&ARUc->y[0],&ARUc->z[0],2, 1);
              ARUc = ARUc->next;
              free(ARUp);
              }
           LatRoot = NULL;   

           ARUc = LonRoot;
           while(ARUc != NULL)
              {
              ARUp = ARUc;

              FwriteObjectAndMagnitude(ARNGE_UNM_LON,ARUc->Cnumber,ARUc->idn,ARUc->Sindex,G_AREAL,ARUc->Lindex,
                                        ARUc->parentid, /*** parentid holds localID***/
                                        -1.0,-1.0,Distance(ARUc->x[0],ARUc->y[0],ARUc->x[1],ARUc->y[1]),
                                        &ARUc->x[0],&ARUc->y[0],&ARUc->z[0],2, 1);
              ARUc = ARUc->next;
              free(ARUp);
              }
           LonRoot = NULL;
PrintAndFreeCTC(-1);

   if(ACBMroot != NULL)
      {
      ACBMc = ACBMroot;
      while(ACBMc != NULL)
         {
         ACBMp = ACBMc;
         ACBMc = ACBMc->next;
         free(ACBMp);
         }
      ACBMroot = NULL;
      }

   for(ii=0; ii<TtlActiveChecks; ii++)
      {
      FreeCheckedAreaPairs(ii);
      FreeCheckedLinePairs(ii);
      }

   free(AreaPairRoot);
   free(LinePairRoot);


   if((CheckMASKMONO > 0) && (FlowFlags.PointFlow != NULL))
      {
      DeconflictActualFlows();

      PropagateFlowDirection();
      free(FlowFlags.PointFlow);
      FlowFlags.PointFlow = NULL;
      FlowFlags.NumX = 0;
      FlowFlags.NumY = 0;
      FlowFlags.Lindex = -99;
      FlowFlags.Xspacing = 0.0;
      FlowFlags.Yspacing = 0.0;
      }


   if((LAEroot != NULL) || (KnownRoot != NULL))
      {
      if(LAEroot == NULL)
         LAEroot = KnownRoot;
      else
         {
         LAEn = LAEroot;
         while(LAEn->next != NULL)
            LAEn = LAEn->next;

         LAEn->next = KnownRoot;
         }
      WriteLandCoverHoles();
      LAEroot = KnownRoot = NULL;
      }

   mpoc = MultiAreaRoot;
   while(mpoc != NULL)
      {
      if(mpoc->counted > 1)
         {
         NumObjects[1] -= (double) (mpoc->counted);
         NumObjects[1] += 1.0;
         }
      mpoc = mpoc->next;
      }

   mpoc = MultiPointRoot;
   while(mpoc != NULL)
      {
      if(mpoc->counted > 1)
         {
         NumObjects[5] -= (double) (mpoc->counted);
         NumObjects[5] += 1.0;
         }
      mpoc = mpoc->next;
      }
   mpoc = MultiLineRoot;
   while(mpoc != NULL)
      {
      if(mpoc->counted > 1)
         {
         NumObjects[4] -= (double) (mpoc->counted);
         NumObjects[4] += 1.0;
         }
      mpoc = mpoc->next;
      }

   FreeMultiPartObjects();  /*** always load and check to get the count of objects inspected correct ***/

   if((NGA_TYPE == 1) && (CheckNGA_Attributes > 0))
      {
      FreeAttrErrStruct();
      }


   DHc = DHroot;
   while(DHc != NULL)
      {
      DHp = DHc;
      DHc = DHc->next;
      free(DHp);
      }
   DHroot = NULL;



   tr1 = TearRoot;
   while(tr1 != NULL)
      {
      FwriteMagnitudeAndTwoObjects(tr1->keyval,tr1->Cnumber,tr1->magnitude,
           tr1->index1,tr1->gform1,tr1->Lindex1,
           tr1->localID1,tr1->IDN1,tr1->radius1,tr1->height1,tr1->x1,tr1->y1,tr1->z1,tr1->numverts1,
           tr1->index2,tr1->gform2,tr1->Lindex2,
           tr1->localID2,tr1->IDN2,tr1->radius2,tr1->height2,tr1->x2,tr1->y2,tr1->z2,tr1->numverts2);

      tr2 = tr1;
      tr1 = tr1->next;
      free(tr2);
      }
   TearRoot = NULL;


   if((CheckLLNOINT > 0) || (CheckLFNOINT > 0) || (CheckOBJECTWITHOUT > 0) || (CheckAWITHOUTA > 0) || (CheckLNOCOVERLA) ||
          (CheckPSHAREFAIL > 0) || (CheckNOENDCON > 0) || (CheckPERIMLEN > 0) || (CheckSMLCUTOUT > 0) ||
          (CheckBOTHENDCON > 0) || (CheckOBJ_WO_TWO > 0) || (CheckISOLINE > 0) ||
          (CheckSMALLAREA > 0) || (CheckFACESIZE > 0) || (CheckLSPANFAIL > 0) || (CheckCONFLATE > 0) ||
        (CheckISOLATEDA > 0) || (CheckNOCOINCIDE > 0) || (CheckCOINCIDEFAIL > 0) || (CheckFSFAIL > 0) || (CheckCONNECTFAIL > 0))
      {
      FwriteTreeInorder(Check_RB_Tree,Check_RB_Tree->root->left);

      RBTreeDestroy(Check_RB_Tree);   /*** free up the rb tree memory ****/
      }

   if((CheckNETISOA > 0) || (CheckANETISOA > 0))
      {
      PropagateTransitiveCounters(Trans_RB_Tree,Trans_RB_Tree->root->left);

      FwriteTransTreeInorder(Trans_RB_Tree,Trans_RB_Tree->root->left);

      RBTreeDestroy(Trans_RB_Tree);   /*** free up the rb tree memory ****/
      }

   if(CheckCONF_STATS > 0)
      {
      sprintf(tempstring2,"%sInformativeAttributes.csv",outsumdirectory);
      CstatsOut = fopen(tempstring2,"wt");
      fprintf(CstatsOut,"File Name,FCODE,Feature Name,Attribute Code,Attribute Name,Informative Values,Sentinel Values\n");
      SrcFiles = fopen(ConflateSourceFiles,"rt");
      FwriteStatsTreeInorder(Stats_RB_Tree, Stats_RB_Tree->root->left, CstatsOut, SrcFiles);
      fclose(CstatsOut);
      CstatsOut = NULL;
      fclose(SrcFiles);
      RBTreeDestroy(Stats_RB_Tree);
      FreeConflateStatsCapture(1);
      }


   if(NGA_TYPE > 0)
      {
      if(index1Max > MaxXcoord)
         index1Max = MaxXcoord;
      if(index2Max > MaxYcoord)
         index2Max = MaxYcoord;
      ReportTime = time(NULL);

      sprintf(tempstring2,"%s.hdr",binsmrylog);
      if((USE_DOS==0)||(SLASHTYPE==NONDOS_TYPE))
        {
          sprintf(tempstring,"cp \"%s\" \"%s\"",tempstring2,binsmrylog);
        }
      else
        {
          sprintf(tempstring,"copy \"%s\" \"%s\"",tempstring2,binsmrylog);
        }

      system(tempstring);

      binsmryout = fopen(binsmrylog,"ab");

      sprintf(tempstring,"%s\n    (Classification: %s) by GAIT %s",indirectory, SetThisClassLevel(1,0),VersionStr);
      kk = strlen(tempstring);
      SEEIT_fwrite_int(&kk,binsmryout);
      fwrite(&tempstring[0],kk,1,binsmryout);

      strcpy(tempstring,Coordinate2DtoString(index1Min,index2Min));
      kk = strlen(tempstring);
      SEEIT_fwrite_int(&kk,binsmryout);
      fwrite(&tempstring[0],kk,1,binsmryout);
      strcpy(tempstring,Coordinate2DtoString(index1Max,index2Max));
      kk = strlen(tempstring);
      SEEIT_fwrite_int(&kk,binsmryout);
      fwrite(&tempstring[0],kk,1,binsmryout);
      SEEIT_fwrite_long(&ReportTime,binsmryout);
      strcpy(tempstring,GetDataContent(1));
      kk = strlen(tempstring);
      SEEIT_fwrite_int(&kk,binsmryout);
      fwrite(&tempstring[0],kk,1,binsmryout); /** number of point features ***/
      strcpy(tempstring,GetDataContent(2));
      kk = strlen(tempstring);
      SEEIT_fwrite_int(&kk,binsmryout);
      fwrite(&tempstring[0],kk,1,binsmryout); /** number of line features ***/
      strcpy(tempstring,GetDataContent(3));
      kk = strlen(tempstring);
      SEEIT_fwrite_int(&kk,binsmryout);
      fwrite(&tempstring[0],kk,1,binsmryout); /** number of area features ***/
      strcpy(tempstring,GetVariousPeices(4));
      kk = strlen(tempstring);
      SEEIT_fwrite_int(&kk,binsmryout);
      fwrite(&tempstring[0],kk,1,binsmryout); /** number of elevation posts ***/

      SEEIT_fwrite_double(&NumObjects[1],binsmryout);/***/ /*** area features inspected ***/
      SEEIT_fwrite_double(&NumObjects[4],binsmryout);/***/ /*** line features inspected ***/
      SEEIT_fwrite_double(&NumObjects[5],binsmryout);/***/ /*** point features inspected ***/
      SEEIT_fwrite_double(&NumObjects[9],binsmryout);/***/ /*** grid features inspected ***/
      }

   if(Areal1Shared != NULL)
      {
      free(Areal1Shared);
      Areal1Shared = NULL;
      }
   if(Areal2Shared != NULL)
      {
      free(Areal2Shared);
      Areal2Shared = NULL;
      }

   if(ArealFromFile.MaxVerts > 0)
      {
      if(Areal1ForIntersections != NULL)
         free(Areal1ForIntersections);
      if(Areal2ForIntersections != NULL)
         free(Areal2ForIntersections);

      NeedIntersectingArealCalc = 0; 
      free(SliverGuide);
      NeedSliverGuide = 0;
      }
   if(ArealForAreaCalculation.numverts > 0)
      {
      free(ArealForAreaCalculation.x);
      free(ArealForAreaCalculation.y);
      free(ArealForAreaCalculation.z);
      ArealForAreaCalculation.numverts = 0;
      }
   NeedAreaCalculation = 0;
   ARlc = ARlargeRoot;
   while(ARlc != NULL)
      {
      ARc = ARlc->ra;
      if(ARc != NULL)
         {
         if(ARc->x != NULL)
         free(ARc->x);
         if(ARc->y != NULL)
         free(ARc->y);
         if(ARc->z != NULL)
         free(ARc->z);
         if(ARc->areastr != NULL)
            free(ARc->areastr);
         if(ARc->hgtstr != NULL)
            free(ARc->hgtstr);
         if(ARc->zv2str != NULL)
            free(ARc->zv2str);
         if(ARc->lenstr != NULL)
            free(ARc->lenstr);
         if(ARc->namstr != NULL)
            free(ARc->namstr);

         if(ARc->RB_Tree_Edgelist != NULL)
            RBTreeDestroy(ARc->RB_Tree_Edgelist);
         free(ARc);
         }
         
      ARlp = ARlc;
      ARlc = ARlc->next;
      free(ARlp);
      }
   ARlargeRoot = NULL;


   if(ID_O_count > 0)
      {
      for(i=0; i<ID_O_count; i++)
         {
         if(ID_O[i].inst != NULL)
            {
            olidc = ID_O[i].inst;
            while(olidc != NULL)
               {
               olidp = olidc;
               olidc = olidc->next;
               free(olidp);
               }
            }
         free(ID_O[i].IDstr);
         }
      free(ID_O);
      ID_O_count = 0;
      ID_O = NULL;
      }



   if(PolyLODbandCount != NULL)
      free(PolyLODbandCount);
   PolyLODbandCount = NULL;
   FreeLongList(&PolyLongListRoot);
   FreeLongList(&Areal1LongListRoot);
   FreeLongList(&Areal2LongListRoot);
   FreeLongList(&Areal3LongListRoot);
   FreeLongList(&Areal4LongListRoot);
   FreeLongList(&LinearLongListRoot);
   /***/FreeLongList(&NeighborLinearLongListRoot);/***/
   FreeLongList(&NeighborArealLongListRoot);
   FreeLongList(&PointLongListRoot);
   FreeLongList(&BridgeLongListRoot);
   FreeLongList(&ModelPolyLongListRoot);
   free(LongPolySkipList);
   free(LongAreal1SkipList);
   free(LongAreal2SkipList);
   free(LongAreal3SkipList);
   free(LongAreal4SkipList);
   free(LongLinearSkipList);
   /***/free(NeighborLongLinearSkipList);/***/
   free(NeighborLongArealSkipList);
   free(LongPointSkipList);
   free(LongBridgeSkipList);
   free(LongModelPolySkipList);
   free(DblPolySkipList);
   free(DblPolyEdgeSkipList);
   free(DblArealEdgeSkipList);
   free(DblModelPolySkipList);
   free(DblModelPolyEdgeSkipList);
   if(HadToOpenFile)
      {
      fclose(fin);
      fin = NULL;
      HadToOpenFile = 0;
      }
   for(i=0; i<MaxInputFileNumber; i++)
      {
      if(ArealFiles[i].isopen ==1)
         {
         arin = ArealFiles[i].fp;
         fclose(arin);
         }
      if(LinearFiles[i].isopen ==1)
         {
         linin = LinearFiles[i].fp;
         fclose(linin);
         }
      ArealFiles[i].fp = NULL;
      ArealFiles[i].isopen = 0;
      LinearFiles[i].fp = NULL;
      LinearFiles[i].isopen = 0;
      }

   free(ArealFiles);
   free(LinearFiles);
   fclose(ptsin);
   fclose(brdgin);
   fclose(MPin);
           if(BucketsOfTransNets != NULL)
              {
              FreeAndWriteTransNetStructs();
              free(BucketsOfTransNets);
              BucketsOfTransNets = NULL;
              }

   if(FormNetworks > 0)
     {
     FreeAndWriteNetStructs();


     }

   if(CTD != NULL)
      free(CTD);
   CTD = NULL;



   ReRackAllConditions(1,0,0,0);

   if(NGA_TYPE == 1)
      strcpy(MessageLine,"Features Considered By Geometry\n");
   else
      strcpy(MessageLine,"Data Considered By Geometry\n");
   j = 0;
   for(i=0; i<NUM_C; i++)
      {
      if((NGA_TYPE == 0) && (i == 5) && (NumLineSegments > 0))
         {
         if(NumLineSegments < 10)
            sprintf(portiondone,"      (%.0lf ttl line segments)\n",NumLineSegments);
         else if(NumLineSegments < 100)
            sprintf(portiondone,"     (%.0lf ttl line segments)\n",NumLineSegments);
         else if(NumLineSegments < 1000)
            sprintf(portiondone,"    (%.0lf ttl line segments)\n",NumLineSegments);
         else if(NumLineSegments < 10000)
            sprintf(portiondone,"   (%.0lf ttl line segments)\n",NumLineSegments);
         else if(NumLineSegments < 100000)
            sprintf(portiondone,"  (%.0lf ttl line segments)\n",NumLineSegments);
         else if(NumLineSegments < 1000000)
            sprintf(portiondone," (%.0lf ttl line segments)\n",NumLineSegments);
         else if(NumLineSegments < 10000000)
            sprintf(portiondone,"(%.0lf ttl line segments)\n",NumLineSegments);
         else
            sprintf(portiondone,"(%.0lf ttl line segments)\n",NumLineSegments);
         strcat(MessageLine,portiondone);
         }
      if(NumObjects[i] > 0)
         {
         ++j; 
         clipflag = (unsigned char) i;
         if(i == 9)
            sprintf(MsgEnding,"%s points",ParseGAITgeometry(clipflag, 2));
         else
            sprintf(MsgEnding,"%s",ParseGAITgeometry(clipflag, 2));

         if(NumObjects[i] < 10)
            sprintf(portiondone,"       %.0lf  %s\n",NumObjects[i], MsgEnding);
         else if(NumObjects[i] < 100)
            sprintf(portiondone,"      %.0lf  %s\n",NumObjects[i], MsgEnding);
         else if(NumObjects[i] < 1000)
            sprintf(portiondone,"     %.0lf  %s\n",NumObjects[i], MsgEnding);
         else if(NumObjects[i] < 10000)
            sprintf(portiondone,"    %.0lf  %s\n",NumObjects[i], MsgEnding);
         else if(NumObjects[i] < 100000)
            sprintf(portiondone,"   %.0lf  %s\n",NumObjects[i], MsgEnding);
         else if(NumObjects[i] < 1000000)
            sprintf(portiondone,"  %.0lf  %s\n",NumObjects[i], MsgEnding);
         else if(NumObjects[i] < 10000000)
            sprintf(portiondone," %.0lf  %s\n",NumObjects[i], MsgEnding);
         else
            sprintf(portiondone,"%.0lf  %s\n",NumObjects[i], MsgEnding);
         strcat(MessageLine,portiondone);
         }
      }
   if(abortNow > 0)
      {
      strcat(MessageLine,"\nPremature Inspection Termination\n");
      }
   else if(j == 0)
      {
      if(NGA_TYPE == 0)
         strcpy(MessageLine,"No Data Was Inspected\n");
      else
         strcpy(MessageLine,"No Features or Posts Were Inspected\n");
      }
   if(NGA_TYPE == 0)
      periodic_checking_redraw(1,"Data Inspection Summary",MessageLine);
   else
      periodic_checking_redraw(1,"Data Inspection Summary",MessageLine);


   if(NGA_TYPE > 0)
      {
      if(binsmryout != NULL)
         {
         fclose(binsmryout);
         binsmryout = NULL;
         }
      }

   if(unsortout != NULL)
      fclose(unsortout);
   unsortout = NULL;



   MakeActiveChecks(1);

   return;
}

