/************
GAIT (Geospatial Analysis Integrity Tool) is a geospatial data validation tool developed by the Institute for Defense Analyses (IDA) for the National Geospatial-Intelligence Agency (NGA).  

This source code was used to generate GAIT 26 executable software in accordance with Amendment 6 to Task Order DH-8-3815 under Contract HQ0034-14-D-0001.

IDA is furnishing this item "as is". IDA was not tasked or funded to generate developer documentation or to provide support for this source code. IDA does not provide any warranty of the item whatsoever, whether express, implied, or statutory, including, but not limited to, any warranty of fitness for a particular purpose or any warranty that the contents of the item will be error-free. In no event shall NGA or IDA be held liable for damages arising, directly or indirectly, from the use of this source code. 

This material may be reproduced by the U.S. Government pursuant to its unlimited use rights under DFARS 252.227-7014 [Feb 2014].

The Institute for Defense Analyses (IDA) is a Federally Funded Research and Development Center that provides scientific and technical expertise on issues important to national security to the Office of the Secretary of Defense, Joint Staff, Unified Commands, and Defense Agencies. 

© 2017 Institute for Defense Analyses
  4850 Mark Center Drive
  Alexandria, Virginia 22311-1882
  703.845-2000
  www.ida.org
************/
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <time.h>

#include "share.h"
#include "rb.h"


#define MDstring1 "GIFD_D4_metadata"
#define MDstring2 "Schema_Metadata"
#define TDS4_MultiAttr 41 /*** how many value set attrs are actually defined in TDS4 ***/
#define TDS6_MultiAttr 50 /*** how many value set attrs are actually defined in TDS6 ***/
#define GGDM_22_MultiAttr 80 /*** how many value set attrs are actually defined in GGDM (max of the capstone and GRLS) ***/
#define GGDM_21_MultiAttr 73 /*** how many value set attrs are actually defined in GGDM ***/
#define GGDM_3_MultiAttr 83
#define TDS_MultiAttr 84 /*** at least as large as the greatest of the TDS and GGDM above - use for array decl **/
#define MaxPortrayRules 350

int UseNUNANPO = 1;
extern int DoMetadataChecking;
extern int DoAttrChecking;
extern int SLASHTYPE;
extern int ATTRIBUTION_TYPE;
extern int * gifd_attr_enum_start;
extern int * gifd_attr_enum_count;
extern char **gifd_enum_codes;
extern char **gifd_enum_names;
extern char **gifd_class_codes;
extern char **gifd_class_names;
extern char **gifd_attr_codes;
extern char **gifd_attr_names;
extern int GIFD_CLASS_NUM;
extern int GIFD_ATTR_NUM;
extern int FORMATBUTTON;

extern char * SetThisClassLevel(int returnearly, int useextract);
extern char *GetDomainFile();
extern char *GetComboFile();
extern char *GetPVfile();
extern char *GetTDS_NotExtracted_File();
extern char * GetMGCP_ReqFCODESFile();
extern char * GetVVDomainsFile();
extern char * GetVVFile();
extern char * GetVV3_File();
extern char * GetVV3DomainsFile();
extern char * GetFrontPart(void);
extern char * GetFrontPart2(void);
extern char * GetIDName();
extern int SetNUNANPO();
extern int PointInsidePoly(double px,double py,double * x,double * y,int numb);
extern int LineSegmentsIntersect(double xl,double yl,double xk,double yk,double xm,double ym,double xn,double yn,double * xi,double * yi);
extern double GetGridValue(FILE *gridfile,long int gridstart,int gridtypeflag,int xindex,int yindex,int xnum, int ynum); /** in interface.c ***/
extern int IsHgt(char possiblecode[]);
extern int IsZv2(char possiblecode[]);
extern int IsArea(char possiblecode[]);
extern int IsLen(char possiblecode[]);
extern int IsNam(char possiblecode[]);
extern int IsGFID(char possiblecode[]);
extern int GetLongAttrVal(int type,int uniqueid,int *Ival,double *Dval,char *Cval);
extern int GetLongAttrType(int code, int silent);
extern char * ParseGAITgeometry(unsigned char geom, int CaseFlag);
extern char * GetTRExSubName2(char * dirname,int TargetTDF);
extern int NOTYPE, C_TYPE, I_TYPE, D_TYPE;
extern int LONG_ATTR_AREA, LONG_ATTR_HGT, LONG_ATTR_ZV2, LONG_ATTR_ID, LONG_ATTR_LEN, LONG_ATTR_NAM;
extern int BIN_ATTR_TYPE;
extern int ATTRINSTYPE;
extern FILE * badtrex;


#define AvgPolysPerIndex 250
#define PI 3.141592653589793
#define ScrnMaxCol 790
#define ScrnMaxRow 990
#define ImageMaxSize 1000
#define Num_MGCP_Meta 16
#define Num_MGCP4_Meta 7
#define Num_SAC_Meta 10 //9 13 
#define Num_LTDS_Meta 31
#define Num_UTDS_Meta 31

int NumMeta = 32;



unsigned char SpecialDomainColors[30] = 
{
  130, 131, 132, 133, 134, 135, 136, 137, 138, 139,
  140, 141, 142, 144, 144, 145, 146, 147, 148, 149,
  150, 151, 152, 155, 155, 155, 156, 157, 158, 159
};




#define InitColor 200  /* white */

#define ShadedReliefRequired 1

#define SkipLimit 25
#define InitSkipList 100


#define compLT(a,b) ( strcmp(a,b) < 0)
#define compEQ(a,b) ( strcmp(a,b) == 0)


#define NIL  &sentinel        /* all leafs are sentinels */


#define SortAttrByNGA 1


int PrintSchemaCodes = 1;
int ConserveMemory  = 1;
double NoiseThreshold, MaxDifference;
int MinICESATqualified = 30;
double GCPdifLimit = 20; /** changed from 50 per Jason email 25 July 2016 ***/

int TDSmeta;
int TDSm1, TDSm2, TDSm3, TDSm4, TDSm5, TDSm6, TDS_EQC, TDS_HGT, TDS_ARA;
int Global_FID_Index = -999;
char EQCvalue[10];

extern char *GetEECode(int attr_code, int enum_num);
extern int GetCodeIndex(char *ecc);
extern int GetNum(char *ecc);
extern int GetAttrIndex(char *ecc);
extern int GetNum2(char *ecc);
extern char * FindCONFLATEsourceFile(int localid, int * entry);
extern int DO_LINES; 
extern char indirectory[];
extern char outdirectory[];
extern char outsumdirectory[];
extern char outattrdirectory[];

extern int file_endianness;
extern int machine_endianness;
extern int NumCountryCodes;
extern char *CountryCodes[];

extern int gcpindex2_0,gcpindex2_1,gcpindex2_2,gcpindex2_3;
extern int gcpindex1_0,gcpindex1_1,gcpindex1_2,gcpindex1_3;
extern int trexfinishedindex0,trexfinishedindex1,trexfinishedindex2,trexfinishedindex3;
extern int trexwatermaskindex0,trexwatermaskindex1,trexwatermaskindex2,trexwatermaskindex3;


int LandMarksSet = 1;
double MinXcoord = 1000000000.0;
double MaxXcoord = 0.0;
double MinYcoord = 1000000000.0;
double MaxYcoord = 0.0;
double LRegionSize;
double NumberOfLoadModules = 0;
extern double Xtranslation;
extern double Ytranslation;
int PixPerLM,PixPerRow,PixPerCol;
int NumberAListEntries;
int GenerateAttrCheckTemplate = 0;
int MaxLineVerts, MinLineVerts;
int MaxAreaVerts, MinAreaVerts, NumAreaHoles;
int GCPread = 0;
int ICESATread = 0;
double PointsPerPixel;
int  NumRows, NumCols;
unsigned int ttlgridpoints;
int TotalArealObjects;
int TtlHGTattr,TtlARAattr,TtlZV2attr;
int TtlNAMattr,TtlLENattr;
int TTF_MaximumEACcount = MaximumEACcount;
int TDS_SAX_RY2_index = -1;
int TDS_ZSAX_RX3_index = -1;
int TDS_ZSAX_RX0_index = -1;
int TDS_SAX_RY1_index = -1;
int TDS_SAX_RX7_index = -1;
int TDS_SAX_RX6_index = -1;
int TDS_SAX_RX1_index = -1;
int TDS_SAX_RX2_index = -1;
int TDS_SAX_RX5_index = -1;
int TDS_ZSAX_RX4_index = -1;

int TDS_URI_index = -1;
int TDS_MDE_index = -1;
int TDS_SAX_RS4_index = -1;
int TDS_SAX_RS3_index = -1;
int TDS_RIDL_index = -1;
int TDS_RIDH_index = -1;
int TDS_SSE_index = -1;
int TDS_IKO_index = -1;
int TDS_PSE_index = -1;
int TDS_VOI_index = -1;
int TDS_BEN_index = -1;
int GGDM_HSE_index = -1;
int GGDM_SAX_RS6_index = -1;
int GGDM_BRR_index = -1;
int GGDM_MLR_index = -1;
int GGDM_ZI103_MVD_index = -1;
int GGDM_ZI001_VSD_index = -1;
int GGDM_PRVR_index = -1;
int GGDM_SCVN_index = -1;
int GGDM_BC040_MLR_index = -1;
int GGDM_BC040_COL_index = -1;
int GGDM_COL_index = -1;
int GGDM_DIA_index = -1;
int GGDM_CNCP_index = -1;
int GGDM_FUFI_index = -1;
int GGDM_FURL_index = -1;
int GGDM_ZI039S_UFI_index = -1;
int GGDM_ZI031S_URI_index = -1;

struct RawPoly
   {
   int Lindex;
   int Sindex;
   int idn;
   int TblIdn;
   int numverts;
   double * x;
   double * y;
   double * z;
   struct RawPoly * next;
   } ;
struct singles
   {
   struct RawPoly * root;
   } * SingleRegionPolys;
struct PtrList
   {
   int filenumber;
   long fileptr;
   long count; 
   struct PtrList * next;
   } * SingleRegionPolyRoot, *srpr1, *srpr2;
struct ObjPtrList
   {
   int filenumber;
   long fileptr;
   struct ObjPtrList * next;
   };
struct ObjectLookup
   {
   int numpoly;
   long fileptr;
   int numother;
   struct PtrList *others;
   } * LocalPolyTable;
struct SCClookup
   {
   int inside;
   struct SCClookup * next;
   } * SCCroot,  * FIDroot;

struct RowPixels
   {
   unsigned char color;
   };
struct ColPixels
   {
   struct RowPixels *Row;
   } *PBM, *PBM2;
struct EnumList
   {
   int val;
   struct EnumList * next;
   };
struct EnumSpec
   {
   char tag[5];
   char datatype[15];
   char units[40];
   char used;
   char denied;
   struct EnumList * vals;
   struct EnumSpec * next;
   };
struct SACspec
   {
   char tag[5];
   char datatype[15];
   char units[40];
   char used;
   char denied;
   double minval;
   double maxval;
   struct SACspec * next;
   };
struct SACallowed
   {
   char SCCtag[6];
   char geometry[15];
   struct EnumSpec *enums;
   struct SACspec *sacvals;
   struct SACallowed * next;
   };
struct Classifications
   {
   int ECC;
   int C,S,D;
   double occurrences;
   } *ClassData;
struct NameArray
   {
   int code;
   char name[ModelNameMaxLength];
   double occurrences;
   int areaholes;
   double configcount[NUM_C];
   int crossindex;
   } *NArray;
struct NameList
   {
   int ECC;
   char name[ModelNameMaxLength];
   double occurrences;
   int areaholes;
   int references;
   double configcount[NUM_C];
   struct EnumList * LastIndex;
   struct EnumList * indices;
   struct NameList *next;
   } *NListRoot, *NListLast;

struct LocalAttrValList
{
  int thisindex;  /** this will be an array, will hold array index during format here **/
  int ClassCode;  /** related classifcation code to this EAC - Value ***/
  double occurrences; /** number of times this value for this EAC for this ModelNames entry **/
  double uniqueoccurrences;  /** if this entry is unique, will have sum of all similar entries, if not is zero **/
  double value; /** this holds all values, int or dbl, and serves as #characters in string, if approp **/
  double value2; /** if have an interval as the value, this holds the interval end, value holds interval start **/
  int intervaltype; /** if is an interval, could be open, closed, half-open, half-closed **/
  int type; /** type of attr value, 0-int, 1-double, 2-string, 3-enum, 4-metadata enum **/
            /** 5-float interval, 6 integer interval, 7 unsigned int interval ***/
  int uom; /** code for unit of measure **/
  int scale; /** code for scale factor applied ti unit of measure **/
  double Unique; /**is this one unique (could be coming from multiple LongList refs to same attr and value **/
  double UniqueCounts; /** may need to sum up other occurrences of this attr and value **/
  char * label; /** if attr is string type, this is value, NULL otherwise **/
  char * sortlabel;  /** for RBtree sorting, make a string of ECC and value, concat value onto ECC ***/
  int refcount; /** number of references **/
  struct reflist * references; /** SEE-IT regions that include objects with this attribute and value **/
  int LLindexcount; /** number of long list references to this value **/
  struct reflist * LongListIndices; /** long list indices that ref this attr and value ***/
  int UniqueLLindexcount; /** how many entries in next array / linked list ?  **/
  struct reflist * UniqueLLindices; /** here, a linked list of LLindices for all entries similar to this (if this is unique **/
  struct LocalAttrValList * next;
} *VListRoot, *VListLast;


struct LocalAttrList
{
  int thisindex;  /** this will be an array, will hold array index during format here **/
  double occurrences; /** number of times this attribute occurs w/ ModelNames entry in the database ***/
  int code;        /** EAC ***/
  int stringdigits; /** some strings have only digits as characters - set to 1 if true so can sort numerical, not lexicographic **/
  int count;  /** count of values assigned to this attribute for this ModelNames entry, also is **/
             /** dimension of the AttrValList attached to this AttrList Entry **/
  int refcount; /** number of references **/
  struct reflist * references; /** SEE-IT regions that include objects with this attribute **/
  struct LocalAttrValList * values;
  struct LocalAttrList * next;
};
struct MonsterP
   {
   long int fileposn;
   int outfilenumber;
   int Lindex;
   int idn;
   char * LM;
   struct MonsterP * next;
   } *MonsterRoot, *Mc, *Mn, *Mp;
struct LongAttrValList
{
int FID_Index;
double v;
struct LongAttrValList *next;
} *LAVc, *LAVn, *LAVp;
struct elist
{
   char *evalue;
   char *value2;
   int dt;
   struct elist *next;
} *VVTec, *VVTep, *VVTen, *VVTetest;
struct VVTdomains
{
   char *name;
   struct elist *values;
   struct VVTdomains * next;
} *VVTdomainRoot, *VVTdomc, *VVTdomp;
struct MGCP_VVT_depend
{
   int attr;
   struct VVTdomains *d;
   int req;
   int isok;
   struct MGCP_VVT_depend * next;
} *VVTdc, *VVTdp, *VVTdn;
struct MGCP_VVT_attr
{
   int attr;
   int inequality;
   double SetValue;
   char * presentvalue;
   struct LongAttrValList *lav;
   struct VVTdomains *dom;
   struct MGCP_VVT_depend *dep;
   struct MGCP_VVT_attr * next;
} *VVTac, *VVTap, *VVTan;
struct MGCP_VVT
{
   char FCODE[10];
   char * shapename;
   int code;
   int geom;
   struct MGCP_VVT_attr *a;
   struct MGCP_VVT_attr *o;
   struct MGCP_VVT *next;
} *MGCP_VVT_root, *MGCP_Vc, *MGCP_Vp, *MGCP_Vn;

struct EnumValList
{
   char *value;
   char *label;
   struct EnumValList * next;
} *EVLroot, *evlc, *evlp, *evln;
struct VVT_3Way
{
   char FCODE[10];
   char * shapename;
   int code;
   int geom;
   int Attr1;
   int Attr2;
   int DependentAttr;
   char *presentvalue1;
   char *presentvalue2;
   char *depvalue;
   struct EnumValList *v1;
   struct EnumValList *v2;
   struct EnumValList *v3;
   struct VVT_3Way * next;
} *TWay_Root, *Twayc, *Twayn, *Twayp;
struct VVTDomains
{
   char *Dname;
   struct EnumValList *ev;
   struct VVTDomains * next;
} *DMroot, *DMc, *DMp, *DMn;
struct IntervalVVT
{
int EAClower;
int EACupper;
int EACclosure;
char closure[50];
int values_found;
double lower;
double upper;
} Int_VVT[28];


struct ValueSetAttrs
   {
   int ac1, ac2, ac3, ac4;
   int fcode;
   char exclude[16];
   char geom;
   char  *vc1, *vc2, *vc3, *vc4;
   } ValueSets[TDS_MultiAttr];

struct SAC_Converts
{
   int acode1;
   int acode2;
   int foundboth;
   double val1;
   double val2;
   double convert1to2;
} SAC_CONV[15];


int  * LongListInstances;
int * LongToShortMap; 
char * LongListBadUID;
int * LongListBadUIDcount; 
int * LL_to_Layer_Map;

struct LL_ID
   {
   int count;
   int * IDentries;
   } * LLtoIDmap;

struct LongListToFeatureIDmap
   {
   int counter;
   struct EnumList *fidlist;
   } *LLtoFeatureID;


struct crsref
  {
  int count;
  double occurrences;
  int numunique;
  int unique;
  int AIndex;
  int VIndex;
  struct crsref * next;
  } *NameAttrCross, *NAC1, *NAC2, *NAC3, *LastNAC;


struct AttrsForOTH
   {
   int acode;
   struct AttrsForOTH * next;
   } *AFOc, *AFOn;
struct ImproperOTH
   {
   char *OTHvalue;
   struct AttrsForOTH * attrs;
   } BadOTH;
struct GlobalGridInfo
   {
   int Lindex;
   int Sindex;
   int Xpts;
   int Ypts;
   int BPGV;
   int FileNumber;
   long int fileptr;
   double BaseX;
   double BaseY;
   double Xspacing;
   double Yspacing;
   } *GridHeader;
  
struct LocalAttrList *AListRoot;

struct AListEntryPoints
   {
   struct LocalAttrList * Entry[8];
   } *LALentries;

struct NGA_ALEP
   {
   int thisindex;  /** this will be an array, will hold array index during format here **/
   double occurrences; /** number of times this attribute occurs w/ ModelNames entry in the database ***/
   int code;        /** EAC ***/
   int stringdigits; /** some strings have only digits as characters - set to 1 if true so can sort numerical, not lexicographic **/
   int count;  /** count of values assigned to this attribute for this ModelNames entry, also is **/
             /** dimension of the AttrValList attached to this AttrList Entry **/
   int refcount; /** number of references **/
   struct reflist * references; /** SEE-IT regions that include objects with this attribute **/
   rb_red_blk_tree * RB_Entry;
   };
struct NGA_AListEntryPoints
   {
   struct NGA_ALEP *SortTree[5];
   } *NGA_LALentries;
struct NListEntryPoints
   {
   rb_red_blk_tree * RB_Entry;
   }  * NALentries;
struct RB_IDkey
   {
   char * idstr;
   int counter;
   } *RB_ID1, *RB_ID2;
rb_red_blk_tree * IDstr_RB_Tree;
rb_red_blk_tree * Summary_AE_Tree;
rb_red_blk_tree * GIFD_AE_Tree;
rb_red_blk_tree * Regular_AE_Tree;
extern rb_red_blk_node * RB_newNode;




struct errorlist
   {
   char * msgline;
   int count;
   int idnumber;
   int long_attr_fid;
   struct EnumList *LindexList;
   struct errorlist * next;
   } *Eroot, *E1, *E2, *Eparent, *GIFD_Eroot, *GIFD_Mroot, *GIFD_MTroot, *Summary_AEroot;
struct indexlist
   {
   int index;
   int msgid;
   struct indexlist * next;
   } *Iroot;
struct LODranges
   {
   int length;
   char *range;
   int numindices;
   struct EnumList * indices;
   struct LODranges * next;
   } *LODroot;
struct sccdataarray
   {
   unsigned char C, S, D;
   } * SCCdataArray;

struct ArealHoles
   {
   int featureid;
   int sedrisid;
   long int fileposn;
   struct ArealHoles * next;
   } *CutOutRoot, *COc, *COn, *COp;
struct NGApicklist
{
   char *value;
   char *code;
   struct NGApicklist * next;
} *pc, *pn, *pp;
struct PickTop
{
   char domain[40];
   struct NGApicklist * picks;
   struct PickTop *next;
} *PickRoot, *PRc, *PRn, *PRp;

struct NGAattribute
{
   char *name;
   int code;
   int codeindex;
   char *codeDomain;
   double minval;
   double maxval;
   int MaxValPresent;
   int MinValPresent;
   int maxstrlen;
   int datatype;
   int DT_as_read;
   int NGAdatatype;
   int varchar;
   int IsLong;
   char OptReq;
   char present;
   char MinOpen;
   char MaxOpen;
   char *strval;
   double floatval;
   int intval;
   struct NGApicklist *picks;
   struct NGAattribute * next;
} *Ap, *Ac, *Ameta, *Tmeta, *Atemp;
struct NGAclass
{
   char *name;
   int geom;
   char present;
   int code;
   int codeindex;
   struct NGAattribute *attr;
   struct NGAclass *next;
} *NGAclassRoot, *NGAmetaRoot, *ngac, *ngap, *ngan, *ngameta, *ngaNoRecord;


struct MultiPO
{
   int featureid;
   int ECC;
   int used;
   int parts;
   struct MultiPO *next;
} *AreaMProot, *PointMProot, *LineMProot, *MPoc, *MPon;


struct AttrOptReqList
{
   int code;
   double ttl;
   char O_R;
   struct AttrOptReqList *next;
} * AORc, *AORp;
struct FCodeOptReqList
{
   int geom;
   int code;
   double ttl;
   struct AttrOptReqList * atl;
   struct FCodeOptReqList * next;
} *FORroot, *FORc, *FORp;
struct DateValueToLindex
{
   struct EnumList * Lindex;
   char * date;
   int count;
   struct DateValueToLindex *next;
} *UPD_DATE_root,*SRC_DATE_root, *date_c, *date_n, *date_p;

struct PortrayRules
{
   char *rule;
   char RuleID[10];
   char *Rname;
   int success;
   int applied;
   struct PortrayRules *next;
} *PRc1, *PRc2;
struct RuleAttrs
{
   char *code;
   int EAC;
   int apply_fail;
   int apply_success;
   char * value;
   struct RuleAttrs *next;
};
struct PortrayalValues
{
   struct RuleAttrs * attrs;
   struct PortrayRules * rules;
};
struct PortValFeatures
{
   struct PortrayalValues *curve;
   struct PortrayalValues *point;
   struct PortrayalValues *surface;
} PVF[MaxPortrayRules];
struct PortraySummary
{
   int ECC;
   int Pcount;
   int Ccount;
   int Scount;
   struct PortraySummary * next;
} *PSroot, *PSn, *PSc, *PSp;




extern int SzD;
extern int SzI;
extern int SzUC;
extern int SzL;
extern int SzShort;


int SzEr = sizeof(struct errorlist);
int SzAH = sizeof(struct ArealHoles);
int SzPS = sizeof(struct PortraySummary);
long SinglePolys = 0;
long MultiPolys = 0;
int *CrossWalk = NULL;
long int pointverts, arealverts, lineverts;
int AttrErrMsgID = 0;
int NowFormatting = 0;

char * Linfile;
char * arealfile;
char * linearfile;
char * gridfile;
char * pointfile;
char * bridgefile;
char * Lmetadata;
char * headerout;

char * polyfile;
char * tablefile;
char * arealtablefile;
char * arealholefile;
char * arealdata;
char * lineartablefile;
char * lineardata;
char * gridtablefile;
char * griddata;
char * gridheader;
char * pointtablefile;
char * pointdata;
char * bridgetablefile;
char * bridgedata;
char * modelPfile;
char * modelPdata;
char * modelPtablefile;
char * SACvaluesfile;
char * LODrangefile;
char * allowedSAC = NULL;
char * SACgigs;
char * binSACgigs;
char * TTFattrgigs;
char * geomgigs;
char * fid_details;
char * missingattrgigs;
char * fillervaluegigs;
char * dtgigs;
char * vvtgigs;
char * valuegigs;
char * pickgigs;
char * IDformat;
char * metadatagigs;
char * CCgigs;
char * imageout;
char * LayerImage;
char * TTF_IDdatafile;
char * TTF_IDheaderfile;
char * TTF_IDproblems;
char * scclookup;
char * fidlookup;
char * eaclookup;
char * LLfrequency;
char * scclist;
char * summarydatafile;
char * portrayalfile;

extern char * scctablefile;

/*** function prototypes *******/
extern int ATTRTYPE_GGDM3();
int PortrayAndEval(char * rule,struct RuleAttrs *R,int LLindex);
int PortrayOrEval(char * rule,struct RuleAttrs *R,int LLindex);


FILE *IDDfp;
FILE *IDHfp;
FILE *IDD2fp;
FILE *IDH2fp;
FILE *BUID;




void RB_ID_InfoDest(void * a)
{
struct RB_IDkey * k;

   k = (struct RB_IDkey *) a;
   if(k->idstr != NULL)
      free(k->idstr);
   free(k);

   return;
}


void Retrieve_Regular_AE_TreeInorder(rb_red_blk_tree* tree, rb_red_blk_node* x)
{
struct errorlist * er;

   if (x != tree->nil)
      {
      Retrieve_Regular_AE_TreeInorder(tree,x->left);

      er = (struct errorlist *) (x->info);
      er->next = NULL;

      if(Eroot == NULL)
         Eroot = er;
      else
         Eparent->next = er;

      Eparent = er;

      Retrieve_Regular_AE_TreeInorder(tree,x->right);
      }


}



void Retrieve_GIFD_AE_TreeInorder(rb_red_blk_tree* tree, rb_red_blk_node* x)
{
struct errorlist * er;

   if (x != tree->nil)
      {
      Retrieve_GIFD_AE_TreeInorder(tree,x->left);

      er = (struct errorlist *) (x->info);
      er->next = NULL;

      if(GIFD_Eroot == NULL)
         GIFD_Eroot = er;
      else
         Eparent->next = er;

      Eparent = er;

      Retrieve_GIFD_AE_TreeInorder(tree,x->right);
      }


}



void Retrieve_Summary_AE_TreeInorder(rb_red_blk_tree* tree, rb_red_blk_node* x)
{
struct errorlist * er;

   if (x != tree->nil)
      {
      Retrieve_Summary_AE_TreeInorder(tree,x->left);

      er = (struct errorlist *) (x->info);
      er->next = NULL;

      if(Summary_AEroot == NULL)
         Summary_AEroot = er;
      else
         Eparent->next = er;

      Eparent = er;

      Retrieve_Summary_AE_TreeInorder(tree,x->right);
      }


}

void Fwrite_IDstr_TreeInorder(rb_red_blk_tree* tree, rb_red_blk_node* x)
{
struct RB_IDkey *k;

   if (x != tree->nil)
      {
      Fwrite_IDstr_TreeInorder(tree,x->left);

      k = (struct RB_IDkey *) (x->info);

      if(k->counter > 1)
         {
         fprintf(BUID,"String Length %d characters: %s\n",(int) strlen(k->idstr),k->idstr);
         }

      Fwrite_IDstr_TreeInorder(tree,x->right);
      }
}

int  DigitStrCmp(char * str1, char * str2)
{
static char modstr1[50];
static char modstr2[50];
int sl1,sl2,i,us1,us2;
   if((str1[0] == '"') || (str2[0] == '"'))
      return(strcmp(str1,str2));

   if((str1[0] == '(') || (str2[0] == '('))
      return(strcmp(str1,str2));

   if((str1[0] < '0') || (str1[0] > '9'))
      {
      if(str1[0] != '-') 
         return(strcmp(str1,str2));
      else if((str1[1] < '0') || (str1[1] > '9'))
         return(strcmp(str1,str2));
      }
   if((str2[0] < '0') || (str2[0] > '9'))
      {
      if(str2[0] != '-')
         return(strcmp(str2,str2));
      else if((str2[1] < '0') || (str2[1] > '9'))
         return(strcmp(str2,str2));
      }

   sl1 = strlen(str1) + 1;
   sl2 = strlen(str2) + 1;
   if((sl1 > 30) || (sl2 > 30))
      return(strcmp(str1,str2));
   else
      {
      for(us1=0; us1<sl1; us1++)
         {
         if(str1[us1] == '_')
            break;
         }
      for(us2 = 0; us2<sl2; us2++)
         {
         if(str2[us2] == '_')
            break;
         }
      if(us1 == us2)
         return(strcmp(str1,str2));

      for(i=0; i<50; i++)
         modstr1[i] = modstr2[i] = '.';
      modstr1[49] = modstr2[49] = '\0';
us1 += 6;
us2 += 6;
strcpy(&modstr1[50 - us1],str1);
strcpy(&modstr2[50 - us2],str2);
      return(strcmp(modstr1, modstr2));
      }
}


int TTF_StrComp(const void * a, const void * b)
{  
char *Sa, *Sb;
int i;
   Sa = (char *) a;
   Sb = (char *) b;

   i = DigitStrCmp(Sa,Sb);

   if(i > 0)
      return(1);
   else if(i < 0)
      return(-1);
   else
      return(0);
} 


int TTF_StdStrComp(const void * a, const void * b)
{
char *Sa, *Sb;
int i;
   Sa = (char *) a;
   Sb = (char *) b;

   i = strcmp(Sa,Sb);

   if(i > 0)
      return(1);
   else if(i < 0)
      return(-1);
   else
      return(0);
}



void TTF_IntPrint(const void * a)
{
   printf("%d", * (int *) a);
}

void TTF_InfoPrint(void * a)
{
   return;
}

void TTF_InfoDest(void * a)
{
   return;
/**** here, want to free memory, but not in this usage ****
 *
 * example follows where tree->info points to objects of type ConditionCollection:
struct ConditionCollection *C;

   C = (struct ConditionCollection *) a;
   free(C->x);
   free(C->y);
   free(C->z);
   free(C);

   return;
**********/
}

void TTF_IDstr_StrDest(void * a)
{
   free((char *) a); 
   return;
}

void TTF_StrDestroy(void * a)
{
   free((char *) a);
   return;
}


void TTF_StrDest(void * a)
{
/***printf("not destroying %s*\n",(char *) a); ***/
   /**free((char *) a); **/
   return;
}

void TTF_IntDest(void * a)
{
   /**free((int *) a); **/
   return;
}

void TTF_DblDest(void * a)
{
   /**free((double *) a);  **/
   return;
}

void Summary_AEStrDest(void * a)
{
   free((char *) a);
   return;
}



void Summary_AEInfoDest(void * a)
{
struct ConflateStats *cs;
   cs = (struct ConflateStats *) a;
   free(cs);

   return;
}




void TTF_Assert(int assertion, char* error) {
  if(!assertion) {
    printf("Assertion Failed: %s\n",error);
    exit(-1);
  }
}

void * TTF_SafeMalloc(size_t size) {
  void * result;

  if ( (result = malloc(size)) ) { /* assignment intentional */
    return(result);
  } else {
    printf("memory overflow: malloc failed in TTF_SafeMalloc.");
    printf("  Exiting Program.\n");
    exit(-1);
    return(0);
  }
}



rb_red_blk_tree* TTF_RBTreeCreate( int (*CompFunc) (const void*,const void*),
                              void (*DestFunc) (void*),
                              void (*InfoDestFunc) (void*),
                              void (*PrintFunc) (const void*),
                              void (*PrintInfo)(void*)) {
  rb_red_blk_tree* newTree;
  rb_red_blk_node* temp;

  newTree=(rb_red_blk_tree*) TTF_SafeMalloc(sizeof(rb_red_blk_tree));
  newTree->Compare=  CompFunc;
  newTree->DestroyKey= DestFunc;
  newTree->PrintKey= PrintFunc;
  newTree->PrintInfo= PrintInfo;
  newTree->DestroyInfo= InfoDestFunc;

  temp=newTree->nil= (rb_red_blk_node*) TTF_SafeMalloc(sizeof(rb_red_blk_node));
  temp->parent=temp->left=temp->right=temp;
  temp->red=0;
  temp->key=0;
  temp=newTree->root= (rb_red_blk_node*) TTF_SafeMalloc(sizeof(rb_red_blk_node));
  temp->parent=temp->left=temp->right=newTree->nil;
  temp->key=0;
  temp->red=0;
  return(newTree);
}

void TTF_LeftRotate(rb_red_blk_tree* tree, rb_red_blk_node* x) {
  rb_red_blk_node* y;
  rb_red_blk_node* nil=tree->nil;

  y=x->right;
  x->right=y->left;

  if (y->left != nil) y->left->parent=x;

  y->parent=x->parent;

  if( x == x->parent->left) {
    x->parent->left=y;
  } else {
    x->parent->right=y;
  }
  y->left=x;
  x->parent=y;

}

void TTF_RightRotate(rb_red_blk_tree* tree, rb_red_blk_node* y) {
  rb_red_blk_node* x;
  rb_red_blk_node* nil=tree->nil;

  x=y->left;
  y->left=x->right;

  if (nil != x->right)  x->right->parent=y;

  x->parent=y->parent;
  if( y == y->parent->left) {
    y->parent->left=x;
  } else {
    y->parent->right=x;
  }
  x->right=y;
  y->parent=x;

}


void TTF_TreeInsertHelp(rb_red_blk_tree* tree, rb_red_blk_node* z) {
  rb_red_blk_node* x;
  rb_red_blk_node* y;
  rb_red_blk_node* nil=tree->nil;

  z->left=z->right=nil;
  y=tree->root;
  x=tree->root->left;
  while( x != nil) {
    y=x;
    if (1 == tree->Compare(x->key,z->key)) { /* x.key > z.key */
      x=x->left;
    } else { /* x,key <= z.key */
      x=x->right;
    }
  }
  z->parent=y;
  if ( (y == tree->root) ||
       (1 == tree->Compare(y->key,z->key))) { /* y.key > z.key */
    y->left=z;
  } else {
    y->right=z;
  }

}


rb_red_blk_node * TTF_RBTreeInsert(rb_red_blk_tree* tree, void* key, void* info) {
  rb_red_blk_node * y;
  rb_red_blk_node * x;
  rb_red_blk_node * newNode;

  x=(rb_red_blk_node*) TTF_SafeMalloc(sizeof(rb_red_blk_node));
  x->key=key;
  x->info=info;

  TTF_TreeInsertHelp(tree,x);
  newNode=x;
  x->red=1;
  while(x->parent->red) {
    if (x->parent == x->parent->parent->left) {
      y=x->parent->parent->right;
      if (y->red) {
        x->parent->red=0;
        y->red=0;
        x->parent->parent->red=1;
        x=x->parent->parent;
      } else {
        if (x == x->parent->right) {
          x=x->parent;
          TTF_LeftRotate(tree,x);
        }
        x->parent->red=0;
        x->parent->parent->red=1;
        TTF_RightRotate(tree,x->parent->parent);
      }
    } else { /* case for x->parent == x->parent->parent->right */
      y=x->parent->parent->left;
      if (y->red) {
        x->parent->red=0;
        y->red=0;
        x->parent->parent->red=1;
        x=x->parent->parent;
      } else {
        if (x == x->parent->left) {
          x=x->parent;
          TTF_RightRotate(tree,x);
        }
        x->parent->red=0;
        x->parent->parent->red=1;
        TTF_LeftRotate(tree,x->parent->parent);
      }
    }
  }
  tree->root->left->red=0;
  return(newNode);

}


rb_red_blk_node* TTF_TreeSuccessor(rb_red_blk_tree* tree,rb_red_blk_node* x) {
  rb_red_blk_node* y;
  rb_red_blk_node* nil=tree->nil;
  rb_red_blk_node* root=tree->root;

  if (nil != (y = x->right)) {
    while(y->left != nil) {
      y=y->left;
    }
    return(y);
  } else {
    y=x->parent;
    while(x == y->right) {
      x=y;
      y=y->parent;
    }
    if (y == root) return(nil);
    return(y);
  }
}


rb_red_blk_node* TTF_TreePredecessor(rb_red_blk_tree* tree, rb_red_blk_node* x) {
  rb_red_blk_node* y;
  rb_red_blk_node* nil=tree->nil;
  rb_red_blk_node* root=tree->root;

  if (nil != (y = x->left)) {
    while(y->right != nil) {
      y=y->right;
    }
    return(y);
  } else {
    y=x->parent;
    while(x == y->left) {
      if (y == root) return(nil);
      x=y;
      y=y->parent;
    }
    return(y);
  }
}


void TTF_InorderTreePrint(rb_red_blk_tree* tree, rb_red_blk_node* x) {
  rb_red_blk_node* nil=tree->nil;
  rb_red_blk_node* root=tree->root;
  if (x != tree->nil) {
    TTF_InorderTreePrint(tree,x->left);
    printf("info=");
    tree->PrintInfo(x->info);
    printf("  key=");
    tree->PrintKey(x->key);
    printf("  l->key=");
    if( x->left == nil) printf("NULL"); else tree->PrintKey(x->left->key);
    printf("  r->key=");
    if( x->right == nil) printf("NULL"); else tree->PrintKey(x->right->key);
    printf("  p->key=");
    if( x->parent == root) printf("NULL"); else tree->PrintKey(x->parent->key);
    printf("  red=%i\n",x->red);
    TTF_InorderTreePrint(tree,x->right);
  }
}



void TTF_TreeDestHelper(rb_red_blk_tree* tree, rb_red_blk_node* x) {
  rb_red_blk_node* nil=tree->nil;
  if (x != nil) {
    TTF_TreeDestHelper(tree,x->left);
    TTF_TreeDestHelper(tree,x->right);
    tree->DestroyKey(x->key);
    tree->DestroyInfo(x->info);
    free(x);
  }
}



void TTF_RBTreeDestroy(rb_red_blk_tree* tree) {
  TTF_TreeDestHelper(tree,tree->root->left);
  free(tree->root);
  free(tree->nil);
  free(tree);
}




rb_red_blk_node* TTF_RBExactQuery(rb_red_blk_tree* tree, void* q) {
  rb_red_blk_node* x=tree->root->left;
  rb_red_blk_node* nil=tree->nil;
  int compVal;
  if (x == nil) return(0);
  compVal=tree->Compare(x->key,(int*) q);
  while(0 != compVal) {
    if (1 == compVal) {
      x=x->left;
    } else {
      x=x->right;
    }
    if ( x == nil) return(0);
    compVal=tree->Compare(x->key,(int*) q);
  }
  return(x);
}



void TTF_RBDeleteFixUp(rb_red_blk_tree* tree, rb_red_blk_node* x) {
  rb_red_blk_node* root=tree->root->left;
  rb_red_blk_node* w;

  while( (!x->red) && (root != x)) {
    if (x == x->parent->left) {
      w=x->parent->right;
      if (w->red) {
        w->red=0;
        x->parent->red=1;
        TTF_LeftRotate(tree,x->parent);
        w=x->parent->right;
      }
      if ( (!w->right->red) && (!w->left->red) ) {
        w->red=1;
        x=x->parent;
      } else {
        if (!w->right->red) {
          w->left->red=0;
          w->red=1;
          TTF_RightRotate(tree,w);
          w=x->parent->right;
        }
        w->red=x->parent->red;
        x->parent->red=0;
        w->right->red=0;
        TTF_LeftRotate(tree,x->parent);
        x=root;
      }
    } else {
      w=x->parent->left;
      if (w->red) {
        w->red=0;
        x->parent->red=1;
        TTF_RightRotate(tree,x->parent);
        w=x->parent->left;
      }
      if ( (!w->right->red) && (!w->left->red) ) {
        w->red=1;
        x=x->parent;
      } else {
        if (!w->left->red) {
          w->right->red=0;
          w->red=1;
          TTF_LeftRotate(tree,w);
          w=x->parent->left;
        }
        w->red=x->parent->red;
        x->parent->red=0;
        w->left->red=0;
        TTF_RightRotate(tree,x->parent);
        x=root;
      }
    }
  }
  x->red=0;

}



void TTF_RBDelete(rb_red_blk_tree* tree, rb_red_blk_node* z){
  rb_red_blk_node* y;
  rb_red_blk_node* x;
  rb_red_blk_node* nil=tree->nil;
  rb_red_blk_node* root=tree->root;

  y= ((z->left == nil) || (z->right == nil)) ? z : TTF_TreeSuccessor(tree,z);
  x= (y->left == nil) ? y->right : y->left;
  if (root == (x->parent = y->parent)) {
    root->left=x;
  } else {
    if (y == y->parent->left) {
      y->parent->left=x;
    } else {
      y->parent->right=x;
    }
  }
  if (y != z) {

    if (!(y->red)) TTF_RBDeleteFixUp(tree,x);

    tree->DestroyKey(z->key);
    tree->DestroyInfo(z->info);
    y->left=z->left;
    y->right=z->right;
    y->parent=z->parent;
    y->red=z->red;
    z->left->parent=z->right->parent=y;
    if (z == z->parent->left) {
      z->parent->left=y;
    } else {
      z->parent->right=y;
    }
    free(z);
  } else {
    tree->DestroyKey(y->key);
    tree->DestroyInfo(y->info);
    if (!(y->red)) TTF_RBDeleteFixUp(tree,x);
    free(y);
  }

}



int GetEEindex(int attr, char * strcode)
{
int index, start;
int limit;

   attr = attr - 1;
   start = gifd_attr_enum_start[attr];
   limit = gifd_attr_enum_count[attr];
   if(limit > 0)
      {
      index = 0;
      while(index <= limit)
         {
         if(strcmp(strcode,gifd_enum_codes[start + index]) == 0)
            break;
         ++index;
         }
      if(index > limit)
         index = -1;
      }
   else
      index = -1;

   return(index);
}


int LongAttrCounts(int entryindex, int thistype)
{
int counter = 0;
int i, kjunk, ijunk;
double djunk;
char resultmessage[2000];

   if(thistype >= 0) /** really has to be, or is not one of the special attributes  ****/
      {
      for(i=0; i<LLtoIDmap[entryindex].count; i++)
         {
         if(LLtoIDmap[entryindex].IDentries[i] >= 0)
            {
            kjunk = GetLongAttrVal(thistype,LLtoIDmap[entryindex].IDentries[i],
                                   &ijunk,&djunk,&resultmessage[0]);
            if(kjunk != NOTYPE)
               ++counter;
            }
         }
      }
   return(counter);
}


char * RemoveOuterQuotes(char * strin)
{
static char answer[1000];
int i,j;
  if(strlen(strin) > 999)
     return(strin);
  else if(strin[0] == '"')
     {
     i = 1;
     j = strlen(strin);
     
     while(strin[j] != '"')
        {
        --j;
        }
     strin[j] = '\0';
     strcpy(answer,&strin[i]);
     strin[j] = '"';
     }
   else
      strcpy(answer, strin);

   return(answer);
}

void FreeDateList(struct DateValueToLindex *Root)
{
struct EnumList *ec, *ep;
   date_c = Root;
   while(date_c != NULL)
      {
      ec = date_c->Lindex;
      while(ec != NULL)
         {
         ep = ec;
         ec = ec->next;
         free(ep);
         }
      date_p = date_c;
      date_c = date_c->next;
      if(date_p->date != NULL)
         free(date_p->date);
      free(date_p);
      }
}


char * FindGoodDateValue(char *indate)
{
static char testd[200];
int i,j;

   strcpy(testd,"2000");
   for(i=0; i<10; i++)
      {
      if(strstr(indate,testd) != NULL)
         return(testd);
      testd[3] += 1;
      }
   strcpy(testd,"2010");
   for(i=0; i<10; i++)
      {
      if(strstr(indate,testd) != NULL)
         return(testd);
      testd[3] += 1;
      }
   strcpy(testd,"1990");
   for(i=0; i<10; i++)
      {
      if(strstr(indate,testd) != NULL)
         return(testd);
      testd[3] += 1;
      }
   strcpy(testd,"1980");
   for(i=0; i<10; i++)
      {
      if(strstr(indate,testd) != NULL)
         return(testd);
      testd[3] += 1;
      }
   strcpy(testd,"1970");
   for(i=0; i<10; i++)
      {
      if(strstr(indate,testd) != NULL)
         return(testd);
      testd[3] += 1;
      }
   strcpy(testd,"1960");
   for(i=0; i<10; i++)
      {
      if(strstr(indate,testd) != NULL)
         return(testd);
      testd[3] += 1;
      }
   strcpy(testd,"1950");
   for(i=0; i<10; i++)
      {
      if(strstr(indate,testd) != NULL)
         return(testd);
      testd[3] += 1;
      }
   strcpy(testd,"1940");
   for(i=0; i<10; i++)
      {
      if(strstr(indate,testd) != NULL)
         return(testd);
      testd[3] += 1;
      }
   strcpy(testd,"2020");
   for(i=0; i<10; i++)
      {
      if(strstr(indate,testd) != NULL)
         return(testd);
      testd[3] += 1;
      }
   i = j = 0;
   while(indate[i] >= ' ')
      {
      if(indate[i] == '"')
         testd[j] = 39;
      else
         testd[j] = indate[i];
      ++j;
      ++i;
      testd[j] = '\0';
      }
   return(testd);
}
void InsertIntoDateList(struct DateValueToLindex **Root, int Lindex, char * inputdatevalue)
{
struct EnumList *ec, *en;
int i;
char datevalue[200];

   date_c = *Root;
   date_p = NULL;
   strcpy(datevalue,FindGoodDateValue(inputdatevalue));

   while(date_c != NULL)
      {
      i = strcmp(datevalue,date_c->date);
      if(i == 0)  /*** same value, add new Lindex ****/
         {
         ec = date_c->Lindex;
         while(ec != NULL)
            {
            if(ec->val == Lindex)
               break;
            else if(ec->next == NULL)
               {
               en = (struct EnumList *) (malloc(sizeof(struct EnumList)));
               en->val = Lindex;
               en->next = NULL;
               ec->next = en;
               }
            ec = ec->next;
            }
         break;
         }
      else if(i < 0)  /*** keep them in date order - this must be a new one ***/
         {
         date_n = (struct DateValueToLindex *) (malloc(sizeof(struct DateValueToLindex)));
         date_n->date = (char *) (malloc(strlen(datevalue) + 1));
         strcpy(date_n->date,datevalue);
         en = (struct EnumList *) (malloc(sizeof(struct EnumList)));
         en->val = Lindex;
         en->next = NULL;
         date_n->Lindex = en;
         if(date_c == *Root)
            {
            date_n->next = *Root;
            *Root = date_n;
            }
         else
            {
            date_n->next = date_p->next;
            date_p->next = date_n;
            }
         break;
         }
      else if(date_c->next == NULL)  /*** keep them in date order - this must be a new one ***/
         {
         date_n = (struct DateValueToLindex *) (malloc(sizeof(struct DateValueToLindex)));
         date_n->date = (char *) (malloc(strlen(datevalue) + 1));
         strcpy(date_n->date,datevalue);
         en = (struct EnumList *) (malloc(sizeof(struct EnumList)));
         en->val = Lindex;
         en->next = NULL;
         date_n->Lindex = en;
         date_c->next = date_n;
         date_n->next = NULL;
         break;
         }
      date_p = date_c;
      date_c = date_c->next;
      }
   return;
}



void ConstructFileNames(char * filepath, int allfiles)
{
int PathStrLength = strlen(filepath) + 1;
FILE *testfile;

   if(allfiles > 0)
      {
      Linfile = (char *) (malloc(PathStrLength + 100));
      sprintf(Linfile,"%spolys.bin",filepath);

      arealfile = (char *) (malloc(PathStrLength + 100));
      sprintf(arealfile,"%sareals.bin",filepath);

      linearfile = (char *) (malloc(PathStrLength + 100));
      sprintf(linearfile,"%slinears.bin",filepath);

      gridfile = (char *) (malloc(PathStrLength + 100));
      sprintf(gridfile,"%sgrid.bin",filepath);

      pointfile = (char *) (malloc(PathStrLength + 100));
      sprintf(pointfile,"%spoints.bin",filepath);

      bridgefile = (char *) (malloc(PathStrLength + 100));
      sprintf(bridgefile,"%sbridges.bin",filepath);

      Lmetadata = (char *) (malloc(PathStrLength + 100));
      sprintf(Lmetadata,"%sheader.bin",filepath);

      headerout = (char *) (malloc(PathStrLength + 100));
      sprintf(headerout,"%sheader.bin",filepath);

      polyfile = (char *) (malloc(PathStrLength + 100));
      sprintf(polyfile,"%ssingleregion.bin",filepath);

      tablefile = (char *) (malloc(PathStrLength + 100));
      sprintf(tablefile,"%spolytable.bin",filepath);

      arealtablefile = (char *) (malloc(PathStrLength + 100));
      sprintf(arealtablefile,"%sarealtable.bin",filepath);

      arealholefile = (char *) (malloc(PathStrLength + 100));
      sprintf(arealholefile,"%sarealhole.bin",filepath);

      arealdata = (char *) (malloc(PathStrLength + 100));
      sprintf(arealdata,"%sarealdata.bin",filepath);

      lineartablefile = (char *) (malloc(PathStrLength + 100));
      sprintf(lineartablefile,"%slineartable.bin",filepath);

      lineardata = (char *) (malloc(PathStrLength + 100));
      sprintf(lineardata,"%slineardata.bin",filepath);

      gridtablefile = (char *) (malloc(PathStrLength + 100));
      sprintf(gridtablefile,"%sgridtable.bin",filepath);

      griddata = (char *) (malloc(PathStrLength + 100));
      sprintf(griddata,"%sgriddata.bin",filepath);

      gridheader = (char *) (malloc(PathStrLength + 100));
      sprintf(gridheader,"%sgridheader.bin",filepath);

      pointtablefile = (char *) (malloc(PathStrLength + 100));
      sprintf(pointtablefile,"%spointtable.bin",filepath);

      pointdata = (char *) (malloc(PathStrLength + 100));
      sprintf(pointdata,"%spointdata.bin",filepath);

      bridgetablefile = (char *) (malloc(PathStrLength + 100));
      sprintf(bridgetablefile,"%sbridgetable.bin",filepath);

      bridgedata = (char *) (malloc(PathStrLength + 100));
      sprintf(bridgedata,"%sbridgedata.bin",filepath);

      modelPfile = (char *) (malloc(PathStrLength + 100));
      sprintf(modelPfile,"%smodelpolys.bin",filepath);

      modelPdata = (char *) (malloc(PathStrLength + 100));
      sprintf(modelPdata,"%smodelpolydata.bin",filepath);

      modelPtablefile = (char *) (malloc(PathStrLength + 100));
      sprintf(modelPtablefile,"%smodelpolytable.bin",filepath);

      LODrangefile = (char *) (malloc(PathStrLength + 100));
      sprintf(LODrangefile,"%sLODbands.bin",filepath);

      imageout = (char *) (malloc(PathStrLength + 100));
      sprintf(imageout,"%scell0.pgm",filepath);

      LayerImage = (char *) (malloc(PathStrLength + 100));
      if(SLASHTYPE==DOS_TYPE)
         {
         sprintf(LayerImage,"%sbitmaps\\GridLayer",filepath);
         }
      else
         {
         sprintf(LayerImage,"%sbitmaps/GridLayer",filepath);
         }

      TTF_IDdatafile = (char *) (malloc(PathStrLength + 100));
      sprintf(TTF_IDdatafile,"%sidlookup1.bin",filepath);

      TTF_IDheaderfile = (char *) (malloc(PathStrLength + 100));
      sprintf(TTF_IDheaderfile,"%sidlookup2.bin",filepath);


      TTF_IDproblems = (char *) (malloc(PathStrLength + 100));
      sprintf(TTF_IDproblems,"%sID_Overload.txt",filepath);

      scclookup = (char *) (malloc(PathStrLength + 100));
      sprintf(scclookup,"%secclookup.bin",filepath);

      fidlookup = (char *) (malloc(PathStrLength + 100));
      sprintf(fidlookup,"%sfidlookup.bin",filepath);

      eaclookup = (char *) (malloc(PathStrLength + 100));
      sprintf(eaclookup,"%seaclookup.bin",filepath);

      LLfrequency = (char *) (malloc(PathStrLength + 100));
      sprintf(LLfrequency,"%sLLfrequency.bin",filepath);

      scclist = (char *) (malloc(PathStrLength + 100));
      sprintf(scclist,"%secclist.bin",filepath);

      scctablefile = (char *) (malloc(PathStrLength + 100));
      sprintf(scctablefile,"%sdynamicdefs.bin",filepath);

      summarydatafile = (char *) (malloc(PathStrLength + 100));
      sprintf(summarydatafile,"%scontentsummary.txt",outsumdirectory);

      if(ATTRTYPE_MGCP4() > 0)
         {
         portrayalfile = (char *) (malloc(PathStrLength + 100));
         sprintf(portrayalfile,"%sMGCP4_PortrayalReport.csv",outsumdirectory);
         }
      else if(ATTRTYPE_TDS6() > 0)
         {
         portrayalfile = (char *) (malloc(PathStrLength + 100));
         sprintf(portrayalfile,"%sTDS6_PortrayalReport.csv",outsumdirectory);
         }
      else
         portrayalfile = NULL;
      }

   SACvaluesfile = (char *) (malloc(PathStrLength + 100));
   sprintf(SACvaluesfile,"%scodesfull.bin",filepath);

   SACgigs = (char *) (malloc(PathStrLength + 100));
   sprintf(SACgigs,"%sattrsummary.txt",outsumdirectory);

   TTFattrgigs = (char *) (malloc(PathStrLength + 100));
   sprintf(TTFattrgigs,"%sUnexpectedAttr.txt",outattrdirectory);

   geomgigs = (char *) (malloc(PathStrLength + 100));
   sprintf(geomgigs,"%sUnexpectedGeom.txt",outattrdirectory);

   fid_details = (char *) (malloc(PathStrLength + 100));
   sprintf(fid_details,"%sAttrErr_FeatureID.txt",outattrdirectory);

   missingattrgigs = (char *) (malloc(PathStrLength + 100));
   sprintf(missingattrgigs,"%sMissingAttribute.txt",outattrdirectory);

   fillervaluegigs = (char *) (malloc(PathStrLength + 100));
   sprintf(fillervaluegigs,"%sSentinelValues.txt",outsumdirectory);

   dtgigs = (char *) (malloc(PathStrLength + 100));
   sprintf(dtgigs,"%sReqAttrNullValueErr.txt",outattrdirectory);

   valuegigs = (char *) (malloc(PathStrLength + 100));
   sprintf(valuegigs,"%sValueRangeErr.txt",outattrdirectory);

   vvtgigs = (char *) (malloc(PathStrLength + 100));
   sprintf(vvtgigs,"%sDependencyErr.txt",outattrdirectory);

   pickgigs = (char *) (malloc(PathStrLength + 100));
   sprintf(pickgigs,"%sPickListErr.txt",outattrdirectory);

   IDformat = (char *) (malloc(PathStrLength + 100));
   sprintf(IDformat,"%sID_FormatErr.txt",outattrdirectory);

   metadatagigs = (char *) (malloc(PathStrLength + 100));
   sprintf(metadatagigs,"%sMetaDataErr.txt",outattrdirectory);

   CCgigs = (char *) (malloc(PathStrLength + 100));
   sprintf(CCgigs,"%sCaptureCriteriaErr.txt",outattrdirectory);

   binSACgigs = (char *) (malloc(PathStrLength + 100));
   sprintf(binSACgigs,"%sattproblems.bin",filepath);

   allowedSAC = (char *) (malloc(PathStrLength + 100));
   sprintf(allowedSAC,"%sattribution.txt",outdirectory);
   if(NGA_TYPE == 0) 
      {
      testfile = fopen(allowedSAC,"rt");
      if(testfile == NULL)
         {
         strcpy(allowedSAC,"attribution.txt");
         printf("could not find attribution analysis file 'attribution.txt' in directory %s\n",filepath);
         printf("will also look in the current working directory\n");
         }
      else
         fclose(testfile);
      }

}

void ReleaseFileNames(int allfiles)
{
   if(allfiles > 0)
      {
      free(Linfile);
      free(arealfile);
      free(linearfile);
      free(gridfile);
      free(pointfile);
      free(bridgefile);
      free(Lmetadata);

      free(headerout);
      free(polyfile);
      free(tablefile);
      free(arealtablefile);
      free(arealholefile);
      free(arealdata);
      free(lineartablefile);
      free(lineardata);
      free(gridtablefile);
      free(griddata);
      free(gridheader);
      free(pointtablefile);
      free(pointdata);
      free(bridgetablefile);
      free(bridgedata);
      free(modelPfile);
      free(modelPtablefile);
      free(modelPdata);
      free(LODrangefile);
      free(imageout);
      free(LayerImage);
      free(TTF_IDdatafile);
      free(TTF_IDheaderfile);
      free(TTF_IDproblems);
      free(scclookup);
      free(fidlookup);
      free(eaclookup);
      free(LLfrequency);
      free(scclist);
      free(summarydatafile);
      if(portrayalfile != NULL)
          {
          free(portrayalfile);
          portrayalfile = NULL;
          }
      free(scctablefile);
      scctablefile = NULL;
      }

   free(SACvaluesfile);
   free(allowedSAC);
   free(SACgigs);
   free(binSACgigs);
   free(TTFattrgigs);
   free(geomgigs);
   free(fid_details);
   free(missingattrgigs);
   free(fillervaluegigs);
   free(dtgigs);
   free(valuegigs);
   free(vvtgigs);
   free(pickgigs);
   free(IDformat);
   free(metadatagigs);
   free(CCgigs);
   binSACgigs = NULL;
   SACvaluesfile = NULL;
   SACgigs = NULL;
   allowedSAC = NULL;
   TTFattrgigs = NULL;
   geomgigs = NULL;
   fid_details = NULL;
   missingattrgigs = NULL;
   fillervaluegigs = NULL;
   dtgigs = NULL;
   valuegigs = NULL;
   vvtgigs = NULL;
   pickgigs = NULL;
   IDformat = NULL;
   metadatagigs = NULL;
   CCgigs = NULL;
   /***deniedSAC = NULL; ***/
}


int AlmostTheSameValue(double v1, double v2)
{
double d;
  if(v1 > v2)
     d = v1 - v2;
  else
     d = v2 - v1;

  if(d < 0.0000001)
     return(1);
  else
     return(0);
}



int AllDigits(char *str_in, int allow_decimal)
{
int i, sl,j,k;
int answer;

   answer = 0;

   sl = strlen(str_in);
   if(str_in[0] == '"')
      j = 1;
   else
      j = 0;
   if(str_in[sl-1] == '"')
      k = sl - 2;
   else
      k = sl - 1;

   if((j == 0) && (k == 0) && (str_in[0] >= '0') && (str_in[0] <= '9'))
      {
      answer = 1;
      }
   else
      {
      for(i=j; i<k; i++)
         {
         if((str_in[i] < '0') || (str_in[i] > '9'))
            {
            if(allow_decimal == 0)
               break;
            else if((i > j) && (allow_decimal > 0) && (str_in[i] != '.'))
               break;
            else if((i == j) && (allow_decimal > 0) && (str_in[i] != '.') && (str_in[i] != '-'))
               break;
            }
         }
      if(i >= k)
         answer = 1;
      }
   return(answer);
}





void ReverseLLFidTable(int SACfull)
{
extern int * LLFidTable;
extern int LLFidTableCount;
int i, j, index;
int *BeenSet;

   BeenSet = (int *) (malloc(SzI * SACfull));
   LLtoIDmap = (struct LL_ID *) (malloc(sizeof(struct LL_ID) * SACfull));
   if(LLtoIDmap == NULL)
      {
      printf("insufficient memory available to reverse LL to ID table - exiting now!\n");
      exit(-1);
      }
   for(i=0; i<SACfull; i++)
      {
      LLtoIDmap[i].count = 0;
      LLtoIDmap[i].IDentries = NULL;
      BeenSet[i] = -1;
      }

   for(i=0; i<LLFidTableCount; i++)
      {
      index = LLFidTable[i];  /*** index holds the Lindex for feature with GAIT ID i ***/
      if(index >= 0)
         LLtoIDmap[index].count += 1;
      }

   for(i=0; i<SACfull; i++)
      {
      LLtoIDmap[i].IDentries = (int *) (malloc(SzI * LLtoIDmap[i].count));
      if(LLtoIDmap[i].IDentries == NULL)
         {
         printf("insufficient memory available to reverse LL to ID table - terminating now!\n");
         exit(-1);
         }
      for(j=0; j<LLtoIDmap[i].count; j++)
         {
         LLtoIDmap[i].IDentries[j] = -999;
         }
      }

   for(i=0; i<LLFidTableCount; i++)
      {
      index = LLFidTable[i];
      if(index >= 0)
         {
         BeenSet[index] += 1;
         j = BeenSet[index];
         if(j < LLtoIDmap[index].count)
            LLtoIDmap[index].IDentries[j] = i;
         else
            {
            printf("bad array index mismatch during  reverse LL to ID table - terminating now!\n");
            exit(-1);
            }
         }
      }

   free(BeenSet);
}


void FreeLLtoIDmap(int SACfull)
{
int i;
   
   for(i=0; i<SACfull; i++)
      {
      if(LLtoIDmap[i].IDentries != NULL)
         free(LLtoIDmap[i].IDentries);
      }
   free(LLtoIDmap);
   LLtoIDmap = NULL;
}



void BIN_SetMGCPrequirements(void)
{
int SzAOR = sizeof(struct AttrOptReqList);
int SzFCOR = sizeof(struct FCodeOptReqList);
struct FCodeOptReqList *lastFOR;
struct AttrOptReqList *lastAOR;

   lastFOR = NULL;

   if(NGAclassRoot == NULL)
      {
      printf("NGAclassroot is NULL - can't continue with BIN_SetMGCPrequirements\n");
      exit(1);
      }
   ngac = NGAclassRoot;
   while(ngac != NULL)
      {
      FORc = (struct FCodeOptReqList *) (malloc(SzFCOR));
      if(FORc == NULL)
         {
         printf("out of available memory for allocation - exiting now!\n");
         exit(-1);
         }

      FORc->code = ngac->codeindex; /** ->codeindex = GetGIFD_class_code_index(FCODE); **/
      FORc->ttl = 0;
      FORc->atl = NULL;
      FORc->geom = ngac->geom;
      FORc->next = NULL;

      if(lastFOR == NULL)
         FORroot = FORc;
      else
         lastFOR->next = FORc;
      lastFOR = FORc;

      lastAOR = NULL;
      if(ngac->attr != NULL)
         {
         Ac = ngac->attr;
         while(Ac != NULL)
            {
            AORc = (struct AttrOptReqList *) (malloc(SzAOR));
            if(AORc == NULL)
               {
               printf("out of available memory for allocation - exiting now!\n");
               exit(-1);
               }

            AORc->code = Ac->codeindex;
            AORc->O_R = Ac->OptReq;
            AORc->ttl = 0;
            AORc->next = NULL;

            if(FORc->atl == NULL)
               FORc->atl = AORc;
            else
               lastAOR->next = AORc;

            lastAOR = AORc;

            Ac = Ac->next;
            }
         }
      ngac = ngac->next;
      }
   return;
}




void ReadMGCPrequirements()
{
FILE *cfile;
char linein[1000];
char classcode[10];
char lastcode[10];
char GEOM[10];
char lastGEOM[10];
char attrcode[100];
char O_R;
int i,j,k;
int SzAOR = sizeof(struct AttrOptReqList);
int SzFCOR = sizeof(struct FCodeOptReqList);
struct AttrOptReqList *lastAOR;
struct FCodeOptReqList *lastFOR;

   strcpy(linein,GetComboFile());
   if(BIN_ATTR_TYPE==1)
      {
      BIN_SetMGCPrequirements();
      return;
      }


   cfile = fopen(linein, "rt");

   if(cfile == NULL)
      return;

   fgets(linein,999,cfile); /** skip the header line ***/
   fgets(linein,999,cfile);
   
   strcpy(lastcode,"zxzxzxzx");
   strcpy(lastGEOM,"zxzxzxzx");
   lastAOR = NULL;
   lastFOR = NULL;
   while(feof(cfile) == 0)
      {
      if((strcmp(linein,MDstring1) != 0) && (strcmp(linein,MDstring2) != 0))
         {
         fgets(linein,999,cfile);
         continue;
         }
      i = 0;
      while(linein[i] != ',')
         ++i;
/*** should have skipped over the FCODE name ***/
      ++i;
      j=0;
      while(linein[i] != ',')
         {
         classcode[j] = linein[i];
         ++i;
         ++j;
         }
      classcode[j] = '\0';
      ++i;
      

      GEOM[0] = linein[i];  /** should be a single char for geometry **/

      GEOM[1] = '\0';
      ++i;  /** should be on a comma **/
      ++i; /** start of attr code;  **/

      j = 0;
      while(linein[i] != ',')
         {
         attrcode[j] = linein[i];
         ++j;
         ++i;
         }

      ++i;
      attrcode[j] = '\0';

      while(linein[i] != ',')
         ++i;

      ++i;  /*** skipped over attr name ***/

      O_R = linein[i];

      k = strcmp(lastcode,classcode);
      if((k != 0) || (lastGEOM[0] != GEOM[0]))
         {
         strcpy(lastcode,classcode);
         lastGEOM[0] = GEOM[0];

         FORc = (struct FCodeOptReqList *) (malloc(SzFCOR));
         if(FORc == NULL)
            {
            printf("out of available memory for allocation - exiting now!\n");
            exit(-1);
            }

         FORc->code = GetCodeIndex(classcode);
         FORc->atl = NULL;
         switch(GEOM[0])
            {
            case 'A':
               FORc->geom = 1;
               break;
            case 'P':
               FORc->geom = 5;
               break;
            case 'L':
               FORc->geom = 4;
               break;
            default:
               printf("unknown code in file %c\n",GEOM[0]);
               exit(-1);
            }
         FORc->ttl = 0;
         FORc->next = NULL;
         if(strcmp(attrcode,"None") != 0)
            {
            AORc = (struct AttrOptReqList *) (malloc(SzAOR));
            if(AORc == NULL)
               {
               printf("out of available memory for allocation - exiting now!\n");
               exit(-1);
               }

            FORc->atl = AORc;
            AORc->code = GetAttrIndex(attrcode);
            AORc->O_R = O_R;
            AORc->ttl = 0;
            AORc->next = NULL;

            if(lastFOR == NULL)
               FORroot = FORc;
            else
               lastFOR->next = FORc;
            lastAOR = AORc;
            }
         else
            {
            if(lastFOR == NULL)
               FORroot = FORc;
            else
               lastFOR->next = FORc;
            FORc->atl = NULL;
            lastAOR = NULL;
            }
         lastFOR = FORc;
         }
      else
         {
         AORc = (struct AttrOptReqList *) (malloc(SzAOR));
         if(AORc == NULL)
            {
            printf("out of available memory for allocation - exiting now!\n");
            exit(-1);
            }

         AORc-> code = GetAttrIndex(attrcode);
         AORc->O_R = O_R;
         AORc->ttl = 0;
         AORc->next = NULL;

         if(lastAOR == NULL)
            {
            printf("pointer mishap in MGCP req - opt attr read\n");
            exit(-1);
            }
         lastAOR->next = AORc;
         lastAOR = AORc;
         }
      fgets(linein,999,cfile);
      }

   fclose(cfile);
}




void PrintMGCP_OptReq_Summary(FILE *fout, int M_A_req, int M_A_pres, int O_A_pres, int O_A_req)
{
int i,j;
int MG_Present[3], MG_Required[3];
int CG_Present[3], CG_Required[3];
int OG_Present[3], OG_Required[3];
int NG_Present[3], NG_Required[3];
int MF_Present, CF_Present, MF_Required, CF_Required, OF_Required, OF_Present;
char *req_filename;
FILE *REQin;
struct Recap
   {
   int code;
   char Areq, Lreq, Preq;
   double Afound, Lfound, Pfound;
   struct Recap * next;
   } *RecapRoot, *Rc, *Rp;
int SzRecap = sizeof(struct Recap);
char Req_FCODE[7];
char ReqA, ReqP, ReqL, wchar;

   for(i=0; i<3; i++)
      {
      MG_Present[i] = MG_Required[i] = 0;
      CG_Present[i] = CG_Required[i] = 0;
      OG_Present[i] = OG_Required[i] = 0;
      NG_Present[i] = NG_Required[i] = 0;
      }

   MF_Present = CF_Present = MF_Required = CF_Required = 0;
   OF_Required = OF_Present = 0;

   RecapRoot = NULL;

   j = strlen(outattrdirectory) + 1;
   req_filename = (char *) (malloc(j + 100));

   if(req_filename == NULL)
      {
      printf("all available memory on this platform has been used - execution must terminate now\n");
      exit(-1);
      }
   strcpy(req_filename,GetMGCP_ReqFCODESFile());

   if(BIN_ATTR_TYPE == 1)
      REQin = fopen(req_filename,"rb");
   else
      REQin = fopen(req_filename,"rt");

   if(REQin == NULL)
      return;

   if(BIN_ATTR_TYPE == 1)
      {
      fread(&wchar,1,1,REQin);
      j = (int) wchar;
      fread(&Req_FCODE[0],j,1,REQin);
      Req_FCODE[j] = '\0';
      fread(&ReqP,1,1,REQin);
      fread(&ReqA,1,1,REQin);
      fread(&ReqL,1,1,REQin);
      }
   else
      fgets(req_filename,29,REQin);
   while(feof(REQin) == 0)
      {
      if(BIN_ATTR_TYPE != 1)
         {
         i = 0;
         while(req_filename[i] != ',')
            {
            Req_FCODE[i] = req_filename[i];
            ++i;
            }
         Req_FCODE[i] = '\0';
         ++i;
         ReqA = req_filename[i];
         i += 2;
         ReqP = req_filename[i];
         i += 2;
         ReqL = req_filename[i];
         }

      j = GetCodeIndex(Req_FCODE);
      Rc = (struct Recap *) (malloc(SzRecap));
      if(Rc == NULL)
         {
         printf("all available memory has been consumed during MGCP required features reporting\n");
         exit(-1);
         }
      Rc->code = j;
      Rc->Areq = ReqA;
      Rc->Lreq = ReqL;
      Rc->Preq = ReqP;
      Rc->Afound = Rc->Lfound = Rc->Pfound = 0;
      Rc->next = NULL;

      if(RecapRoot == NULL)
         {
         RecapRoot = Rc;
         }
      else
         {
         Rp->next = Rc;
         }
      Rp = Rc;
      FORc = FORroot;
      while(FORc != NULL)
         {
         if(FORc->code == Rc->code)
            {
            switch(FORc->geom)
               {
               case 1: Rc->Afound = FORc->ttl; break;
               case 4: Rc->Lfound = FORc->ttl; break;
               case 5: Rc->Pfound = FORc->ttl; break;
               default: printf("bad geometry key (%d) for code %s\n",FORc->geom,GetECCCode(FORc->code));
               }
            }
         FORc = FORc->next;
         }
      if(BIN_ATTR_TYPE == 1)
         {
         fread(&wchar,1,1,REQin);
         j = (int) wchar;
         if(j == 0)
            {
            break;
            }
         fread(&Req_FCODE[0],j,1,REQin);
         Req_FCODE[j] = '\0';
         fread(&ReqP,1,1,REQin);
         fread(&ReqA,1,1,REQin);
         fread(&ReqL,1,1,REQin);
         }
      else
         fgets(req_filename,29,REQin);
      }
   fclose(REQin);
   Rc = RecapRoot;
   while(Rc != NULL)
      {
      if((Rc->Areq == 'M') || (Rc->Lreq == 'M') || (Rc->Preq == 'M'))
         {
         MF_Required += 1;
         if((Rc->Afound > 0) || (Rc->Lfound > 0) || (Rc->Pfound > 0))
            MF_Present += 1;
         }
      else if((Rc->Areq == 'C') || (Rc->Lreq == 'C') || (Rc->Preq == 'C'))
         {
         CF_Required += 1;
         if((Rc->Afound > 0) || (Rc->Lfound > 0) || (Rc->Pfound > 0))
            CF_Present += 1;
         }
      else
         {
         OF_Required += 1;
         if((Rc->Afound > 0) || (Rc->Lfound > 0) || (Rc->Pfound > 0))
            OF_Present += 1;
         }
      switch(Rc->Areq)
         {
         case 'M':
            MG_Required[0] += 1;
            if(Rc->Afound > 0)
               MG_Present[0] += 1;
            break;
         case 'C':
            CG_Required[0] += 1;
            if(Rc->Afound > 0)
               CG_Present[0] += 1;
            break;
         case 'O':
            OG_Required[0] += 1;
            if(Rc->Afound > 0)
               OG_Present[0] += 1;
            break;
         default:
            NG_Required[0] += 1;
            if(Rc->Afound > 0)
               NG_Present[0] += 1;
            break;
         }
      switch(Rc->Lreq)
         {
         case 'M':
            MG_Required[1] += 1;
            if(Rc->Lfound > 0)
               MG_Present[1] += 1;
            break;
         case 'C':
            CG_Required[1] += 1;
            if(Rc->Lfound > 0)
               CG_Present[1] += 1;
            break;
         case 'O':
            OG_Required[1] += 1;
            if(Rc->Lfound > 0)
               OG_Present[1] += 1;
            break;
         default:
            NG_Required[1] += 1;
            if(Rc->Lfound > 0)
               NG_Present[1] += 1;
            break;
         }
      switch(Rc->Preq)
         {
         case 'M':
            MG_Required[2] += 1;
            if(Rc->Pfound > 0)
               MG_Present[2] += 1;
            break;
         case 'C':
            CG_Required[2] += 1; 
            if(Rc->Pfound > 0)
               CG_Present[2] += 1;
            break;
         case 'O':
            OG_Required[2] += 1;
            if(Rc->Pfound > 0)
               OG_Present[2] += 1;
            break;
         default:
            NG_Required[2] += 1;
            if(Rc->Pfound > 0)
               NG_Present[2] += 1;
            break;
         }
      Rc = Rc->next;
      }
   fprintf(fout,"             MGCP Feature And Attribute Requirement Summary\n\n\n");
   fprintf(fout,"                         Feature   Feature\n");
   fprintf(fout,"                          Types     Types\n");
   fprintf(fout,"                        Specified  Found In\n");
   fprintf(fout,"                        In Schema  Project \n");
   fprintf(fout,"Mandatory     Area    %8d %8d\n",MG_Required[0],MG_Present[0]);
   fprintf(fout,"Conditional   Area    %8d %8d\n",CG_Required[0],CG_Present[0]);
   fprintf(fout,"Optional      Area    %8d %8d\n",OG_Required[0],OG_Present[0]);
   fprintf(fout,"Not Specified Area    %8d %8d\n",NG_Required[0],NG_Present[0]);
   fprintf(fout,"  Total       Area    %8d %8d\n\n",MG_Required[0]+CG_Required[0]+OG_Required[0]+NG_Required[0],
                                                    MG_Present[0]+CG_Present[0]+OG_Present[0]+NG_Present[0]);
   fprintf(fout,"Mandatory     Line    %8d %8d\n",MG_Required[1],MG_Present[1]);
   fprintf(fout,"Conditional   Line    %8d %8d\n",CG_Required[1],CG_Present[1]);
   fprintf(fout,"Optional      Line    %8d %8d\n",OG_Required[1],OG_Present[1]);
   fprintf(fout,"Not Specified Line    %8d %8d\n",NG_Required[1],NG_Present[1]);
   fprintf(fout,"  Total       Line    %8d %8d\n\n",MG_Required[1]+CG_Required[1]+OG_Required[1]+NG_Required[1],
                                                    MG_Present[1]+CG_Present[1]+OG_Present[1]+NG_Present[1]);
   fprintf(fout,"Mandatory     Point   %8d %8d\n",MG_Required[2],MG_Present[2]);
   fprintf(fout,"Conditional   Point   %8d %8d\n",CG_Required[2],CG_Present[2]);
   fprintf(fout,"Optional      Point   %8d %8d\n",OG_Required[2],OG_Present[2]);
   fprintf(fout,"Not Specified Point   %8d %8d\n",NG_Required[2],NG_Present[2]);
   fprintf(fout,"  Total       Point   %8d %8d\n\n",MG_Required[2]+CG_Required[2]+OG_Required[2]+NG_Required[2],
                                                    MG_Present[2]+CG_Present[2]+OG_Present[2]+NG_Present[2]);

   fprintf(fout,"Feature Types with at least one mandatory geometry: \n    Specification %d\n    Present %d\n",MF_Required,MF_Present);
   if(MF_Required > MF_Present)
      fprintf(fout,"    Missing mandatory feature types: %d\n",MF_Required - MF_Present);
   else
      fprintf(fout,"    Missing mandatory feature types: 0\n");

   fprintf(fout,"Feature Types with no mandatory geometry and at least\n  one conditional geometry:\n    Specification %d\n    Present %d\n",CF_Required,CF_Present);
   if(CF_Required > CF_Present)
      fprintf(fout,"    Missing conditional feature types: %d\n",CF_Required - CF_Present);
   else
      fprintf(fout,"    Missing conditional feature types: 0\n");

   fprintf(fout,"Feature Types with no mandatory or conditional geometry:\n    Specification %d\n    Present %d\n",OF_Required,OF_Present);

   fprintf(fout,"\nAttribute counts for features in the project:\n");
   fprintf(fout,"    Mandatory attributes specified: %10d\n",M_A_req);
   fprintf(fout,"    Mandatory attributes present:   %10d\n",M_A_pres);
   fprintf(fout,"    Mandatory attributes missing:   %10d\n",M_A_req - M_A_pres);
   fprintf(fout,"    Optional attributes specified:  %10d\n",O_A_req);
   fprintf(fout,"    Optional attributes present:    %10d\n",O_A_pres);
   fprintf(fout,"    Optional attributes missing:    %10d\n",O_A_req - O_A_pres);


   fprintf(fout,"\n\nDetailed Information:  ");
   fprintf(fout,"\n  Mandatory, conditional and optional features and attributes\n   present in the project");
   fprintf(fout,"   (excludes metadata attributes)\n");
   fprintf(fout,"    ('*M' indicates a missing mandatory feature and geometry\n");
   fprintf(fout,"    ('*C' indicates a missing conditional feature and geometry\n");
   fprintf(fout,"    ('**' indicates a missing attribute)\n\n");

   Rc = RecapRoot;
   while(Rc != NULL)
      {
      if((Rc->Afound > 0) || (Rc->Lfound > 0) || (Rc->Pfound > 0))
         {
         if( ((Rc->Areq == 'M') && (Rc->Afound == 0)) ||
              ((Rc->Lreq == 'M') && (Rc->Lfound == 0)) ||
                ((Rc->Preq == 'M') && (Rc->Pfound == 0)))
            {
            fprintf(fout,"*M ");
            }
         else if( ((Rc->Areq == 'C') && (Rc->Afound == 0)) ||
              ((Rc->Lreq == 'C') && (Rc->Lfound == 0)) ||
                ((Rc->Preq == 'C') && (Rc->Pfound == 0)))
            {
            fprintf(fout,"*C ");
            }
         else
            fprintf(fout,"   ");
   
         fprintf(fout,"%s %s (total present: %.0lf)\n",GetECCCode(Rc->code), GetECCLabel(Rc->code), Rc->Afound + Rc->Lfound + Rc->Pfound);

         if(Rc->Afound > 0)
            {
            switch(Rc->Areq)
               {
               case 'M': 
                  fprintf(fout,"      Area  Specified: Mandatory     Number Found: %.0lf\n",Rc->Afound);
                  break;
               case 'C':
                  fprintf(fout,"      Area  Specified: Conditional   Number Found: %.0lf\n",Rc->Afound);
                  break;
               case 'O':
                  fprintf(fout,"      Area  Specified: Optional      Number Found: %.0lf\n",Rc->Afound);
                  break;
               default:
                  fprintf(fout,"      Area  Specified: None          Number Found: %.0lf\n",Rc->Afound);
                  break;
               }
            
            FORc = FORroot;
            while(FORc != NULL)
               {
               if((FORc->code == Rc->code) && (FORc->geom == 1))
                  break;
               FORc = FORc->next;
               }
            if(FORc != NULL)
               {
               fprintf(fout,"        Mandatory Attributes:\n");
               i = 0;
               AORc = FORc->atl;
               while(AORc != NULL)
                  {
                  if(AORc->O_R == 'M')
                     {
                     ++i;
                     if(AORc->ttl != FORc->ttl)
                        fprintf(fout,"**       number present: %-6u %s %s\n", (unsigned int) AORc->ttl, GetEACCode(AORc->code), GetEACLabel(AORc->code));
                     else
                        fprintf(fout,"         number present: %-6u %s %s\n", (unsigned int) AORc->ttl, GetEACCode(AORc->code), GetEACLabel(AORc->code));
                     }
                  AORc = AORc->next;
                  }
               if(i == 0)
                  fprintf(fout,"         no mandatory attributes prescribed\n");
               fprintf(fout,"        Optional Attributes:\n");
               AORc = FORc->atl;
               i = 0;
               while(AORc != NULL)
                  {
                  if(AORc->O_R != 'M')
                     {
                     ++i;
                     if(AORc->ttl == FORc->ttl)
                        fprintf(fout,"         number present: %-6u %s %s\n", (unsigned int) AORc->ttl, GetEACCode(AORc->code), GetEACLabel(AORc->code));
                     else
                        fprintf(fout,"**       number present: %-6u %s %s\n", (unsigned int) AORc->ttl, GetEACCode(AORc->code), GetEACLabel(AORc->code));
                     }
                  AORc = AORc->next;
                  }
               if(i == 0)
                  fprintf(fout,"         no optional attributes prescribed\n");
               }
            else
               fprintf(fout,"         no attributes assigned to this feature and geometry\n");
            }
         else /*** Rc->Afound is zero ***/
            {
            if(Rc->Areq == 'M')
               fprintf(fout,"*M    Area  Specified: Mandatory     Number Found: %.0lf\n",Rc->Afound);
            else if(Rc->Areq == 'C')
               fprintf(fout,"*C    Area  Specified: Conditional   Number Found: %.0lf\n",Rc->Afound);
            }


         if(Rc->Lfound > 0)
            {
            switch(Rc->Lreq)
               {
               case 'M':
                  fprintf(fout,"      Line  Specified: Mandatory     Number Found: %.0lf\n",Rc->Lfound);
                  break;
               case 'C':
                  fprintf(fout,"      Line  Specified: Conditional   Number Found: %.0lf\n",Rc->Lfound);
                  break;
               case 'O':
                  fprintf(fout,"      Line  Specified: Optional      Number Found: %.0lf\n",Rc->Lfound);
                  break;
               default:
                  fprintf(fout,"      Line  Specified: None          Number Found: %.0lf\n",Rc->Lfound);
                  break;
               }

            FORc = FORroot;
            while(FORc != NULL)
               {
               if((FORc->code == Rc->code) && (FORc->geom == 4))
                  break;
               FORc = FORc->next;
               }
            if(FORc != NULL)
               {
               fprintf(fout,"        Mandatory Attributes:\n");
               i = 0;
               AORc = FORc->atl;
               while(AORc != NULL)
                  {
                  if(AORc->O_R == 'M')
                     {
                     ++i;
                     if(AORc->ttl != FORc->ttl)
                        fprintf(fout,"**       number present: %-6u %s %s\n", (unsigned int) AORc->ttl, GetEACCode(AORc->code), GetEACLabel(AORc->code));
                     else
                        fprintf(fout,"         number present: %-6u %s %s\n", (unsigned int) AORc->ttl, GetEACCode(AORc->code), GetEACLabel(AORc->code));
                     }
                  AORc = AORc->next;
                  }
               if(i == 0)
                  fprintf(fout,"         no mandatory attributes prescribed\n");
               fprintf(fout,"        Optional Attributes:\n");
               AORc = FORc->atl;
               i = 0;
               while(AORc != NULL)
                  {
                  if(AORc->O_R != 'M')
                     {
                     ++i;
                     if(AORc->ttl == FORc->ttl)
                        fprintf(fout,"         number present: %-6u %s %s\n", (unsigned int) AORc->ttl, GetEACCode(AORc->code), GetEACLabel(AORc->code));
                     else
                        fprintf(fout,"**       number present: %-6u %s %s\n", (unsigned int) AORc->ttl, GetEACCode(AORc->code), GetEACLabel(AORc->code));
                     }
                  AORc = AORc->next;
                  }
               if(i == 0)
                  fprintf(fout,"         no optional attributes prescribed\n");
               }
            else
               fprintf(fout,"         no attributes assigned to this feature and geometry\n");
            }
         else /*** Rc->Lfound is zero ***/
            {
            if(Rc->Lreq == 'M')
               fprintf(fout,"*M    Line  Specified: Mandatory     Number Found: %.0lf\n",Rc->Lfound);
            else if(Rc->Lreq == 'C')
               fprintf(fout,"*C    Line  Specified: Conditional   Number Found: %.0lf\n",Rc->Lfound);
            }


         if(Rc->Pfound > 0)
            {
            switch(Rc->Preq)
               {
               case 'M':
                  fprintf(fout,"      Point Specified: Mandatory     Number Found: %.0lf\n",Rc->Pfound);
                  break;
               case 'C':
                  fprintf(fout,"      Point Specified: Conditional   Number Found: %.0lf\n",Rc->Pfound);
                  break;
               case 'O':
                  fprintf(fout,"      Point Specified: Optional      Number Found: %.0lf\n",Rc->Pfound);
                  break;
               default:
                  fprintf(fout,"      Point Specified: None          Number Found: %.0lf\n",Rc->Pfound);
                  break;
               }

            FORc = FORroot;
            while(FORc != NULL)
               {
               if((FORc->code == Rc->code) && (FORc->geom == 5))
                  break;
               FORc = FORc->next;
               }
            if(FORc != NULL)
               {
               fprintf(fout,"        Mandatory Attributes:\n");
               i = 0;
               AORc = FORc->atl;
               while(AORc != NULL)
                  {
                  if(AORc->O_R == 'M')
                     {
                     ++i;
                     if(AORc->ttl != FORc->ttl)
                        fprintf(fout,"**       number present: %-6u %s %s\n", (unsigned int) AORc->ttl, GetEACCode(AORc->code), GetEACLabel(AORc->code));
                     else
                        fprintf(fout,"         number present: %-6u %s %s\n", (unsigned int) AORc->ttl, GetEACCode(AORc->code), GetEACLabel(AORc->code));
                     }
                  AORc = AORc->next;
                  }
               if(i == 0)
                  fprintf(fout,"         no mandatory attributes prescribed\n");
               fprintf(fout,"        Optional Attributes:\n");
               AORc = FORc->atl;
               i = 0;
               while(AORc != NULL)
                  {
                  if(AORc->O_R != 'M')
                     {
                     ++i;
                     if(AORc->ttl == FORc->ttl)
                        fprintf(fout,"         number present: %-6u %s %s\n", (unsigned int) AORc->ttl, GetEACCode(AORc->code), GetEACLabel(AORc->code));
                     else
                        fprintf(fout,"**       number present: %-6u %s %s\n", (unsigned int) AORc->ttl, GetEACCode(AORc->code), GetEACLabel(AORc->code));
                     }
                  AORc = AORc->next;
                  }
               if(i == 0)
                  fprintf(fout,"         no optional attributes prescribed\n");
               }
            else
               fprintf(fout,"         no attributes assigned to this feature and geometry\n");
            }
         else /*** Rc->Pfound is zero ***/
            {
            if(Rc->Preq == 'M')
               fprintf(fout,"*M    Point Specified: Mandatory     Number Found: %.0lf\n",Rc->Pfound);
            else if(Rc->Preq == 'C')
               fprintf(fout,"*C    Point Specified: Conditional   Number Found: %.0lf\n",Rc->Pfound);
            }



         }

      Rc = Rc->next;
      }


   fprintf(fout,"\n\n    Mandatory Feature Types Not Present In The Project\n\n");

   Rc = RecapRoot;
   i = 0;
   while(Rc != NULL)
      {
      if((Rc->Afound == 0) && (Rc->Lfound == 0) && (Rc->Pfound == 0))
         {
         if((Rc->Areq == 'M') || (Rc->Lreq == 'M') || (Rc->Preq == 'M'))
            {
            ++i;
            fprintf(fout,"%3d. %s %s (total present: 0)\n",i,GetECCCode(Rc->code), GetECCLabel(Rc->code));
            if(Rc->Areq == 'M')
               fprintf(fout,"       area:  Mandatory\n");
            else if(Rc->Areq == 'C')
               fprintf(fout,"       area:  Conditional\n");
            else if(Rc->Areq == 'O')
               fprintf(fout,"       area:  Optional\n");
            else
               fprintf(fout,"       area:  Not Specified\n");

            if(Rc->Lreq == 'M')
               fprintf(fout,"       line:  Mandatory\n");
            else if(Rc->Lreq == 'C')
               fprintf(fout,"       line:  Conditional\n");
            else if(Rc->Lreq == 'O')
               fprintf(fout,"       line:  Optional\n");
            else
               fprintf(fout,"       line:  Not Specified\n");

            if(Rc->Preq == 'M')
               fprintf(fout,"       point: Mandatory\n");
            else if(Rc->Preq == 'C')
               fprintf(fout,"       point: Conditional\n");
            else if(Rc->Preq == 'O')
               fprintf(fout,"       point: Optional\n");
            else
               fprintf(fout,"       point: Not Specified\n");
            }
         }
      Rc = Rc->next;
      }
   if(i == 0)
      {
      fprintf(fout,"      No missing mandatory features noted\n");
      }

   fprintf(fout,"\n\n    Conditional Feature Types Not Present In The Project\n\n");
   Rc = RecapRoot;
   i = 0;
   while(Rc != NULL)
      {
      if((Rc->Afound == 0) && (Rc->Lfound == 0) && (Rc->Pfound == 0))
         {
         if((Rc->Areq != 'M') && (Rc->Lreq != 'M') && (Rc->Preq != 'M'))
            {
            if((Rc->Areq == 'C') || (Rc->Lreq == 'C') || (Rc->Preq == 'C'))
               {
               ++i;
               fprintf(fout,"%3d. %s %s (total present: 0)\n",i,GetECCCode(Rc->code), GetECCLabel(Rc->code));
               if(Rc->Areq == 'C')
                  fprintf(fout,"       area:  Conditional\n");
               else if(Rc->Areq == 'O')
                  fprintf(fout,"       area:  Optional\n");
               else
                  fprintf(fout,"       area:  Not Specified\n");

               if(Rc->Lreq == 'C')
                  fprintf(fout,"       line:  Conditional\n");
               else if(Rc->Lreq == 'O')
                  fprintf(fout,"       line:  Optional\n");
               else
                  fprintf(fout,"       line:  Not Specified\n");

               if(Rc->Preq == 'C')
                  fprintf(fout,"       point: Conditional\n");
               else if(Rc->Preq == 'O')
                  fprintf(fout,"       point: Optional\n");
               else
                  fprintf(fout,"       point: Not Specified\n");
               }
            }
         }
      Rc = Rc->next;
      }
   if(i == 0)
      {
      fprintf(fout,"      No missing conditional features noted\n");
      }


   free(req_filename);
      
   Rc = RecapRoot;
   while(Rc != NULL)
      {
      Rp = Rc;
      Rc = Rc->next;
      free(Rp);
      }
}





void PrintMGCP_OptReq_Lists(FILE *fout, int *M_A_Req, int *M_A_Pres, int *O_A_Pres, int *O_A_Req)
{
int i;
int MandPresent, OptPresent, MandRequired, OptRequired;

   MandPresent = OptPresent = MandRequired =  OptRequired = 0;
   fprintf(fout,"Mandatory and optional attributes present in the data\n");
   fprintf(fout,"('**' indicates missing mandatory attributes)\n");
   FORc = FORroot;
   while(FORc != NULL)
      {
      if(FORc->ttl > 0)
         {
         switch(FORc->geom)
            {
            case 1:
               fprintf(fout,"%s %s Area number present: %.0lf\n",GetECCCode(FORc->code), GetECCLabel(FORc->code), FORc->ttl);
               break;
            case 4:
               fprintf(fout,"%s %s Line number present: %.0lf\n",GetECCCode(FORc->code), GetECCLabel(FORc->code), FORc->ttl);
               break;
            case 5:
               fprintf(fout,"%s %s Point number present: %.0lf\n",GetECCCode(FORc->code), GetECCLabel(FORc->code), FORc->ttl);
               break;
            }
         fprintf(fout," Mandatory Attributes:\n");
         i = 0;
         AORc = FORc->atl;
         while(AORc != NULL)
            {
            if(AORc->O_R == 'M')
               {
               MandPresent += (int) AORc->ttl;
               MandRequired += (int) FORc->ttl;
               ++i;
               if(AORc->ttl != FORc->ttl)
                  fprintf(fout,"** number present: %-6u %s %s\n", (unsigned int) AORc->ttl, GetEACCode(AORc->code), GetEACLabel(AORc->code));
               else
                  fprintf(fout,"   number present: %-6u %s %s\n", (unsigned int) AORc->ttl, GetEACCode(AORc->code), GetEACLabel(AORc->code));
               }
            AORc = AORc->next;
            }
         if(i == 0)
            fprintf(fout,"   no mandatory attributes prescribed\n");
         fprintf(fout," Optional Attributes:\n");
         AORc = FORc->atl;
         i = 0;
         while(AORc != NULL)
            {
            if(AORc->O_R != 'M')
               {
               OptPresent += (int) AORc->ttl;
               OptRequired += (int) FORc->ttl;
               ++i;
               if(AORc->ttl > 0)
                  fprintf(fout,"   number present: %-6u %s %s\n", (unsigned int) AORc->ttl, GetEACCode(AORc->code), GetEACLabel(AORc->code));
               else
                  fprintf(fout,"** number present: %-6u %s %s\n", (unsigned int) AORc->ttl, GetEACCode(AORc->code), GetEACLabel(AORc->code));
               }
            AORc = AORc->next;
            }
         if(i == 0)
            fprintf(fout,"   no optional attributes prescribed\n");
         }
      FORc = FORc->next;
      }

   fprintf(fout,"\nTotal counts:\n");
   fprintf(fout,"Mandatory attributes required: %10d\n",MandRequired);
   fprintf(fout,"Mandatory attributes present:  %10d\n",MandPresent);
   fprintf(fout,"Mandatory attributes missing:  %10d\n",MandRequired - MandPresent);
   fprintf(fout,"Optional attributes required:  %10d\n",OptRequired);
   fprintf(fout,"Optional attributes present:   %10d\n",OptPresent);
   fprintf(fout,"Optional attributes missing:   %10d\n",OptRequired - OptPresent);

   *M_A_Req = MandRequired;
   *M_A_Pres = MandPresent;
   *O_A_Pres = OptPresent;
   *O_A_Req = OptRequired;
}



void FreeMGCP_OptReq_Lists(void)
{
   FORc = FORroot;
   while(FORc != NULL)
      {
      AORc = FORc->atl;
      while(AORc != NULL)
         {
         AORp = AORc;
         AORc = AORc->next;
         free(AORp);
         }
      FORp = FORc;
      FORc = FORc->next;
      free(FORp);
      }
   FORroot = NULL;
}



void NGA_InsertIntoAttributeList(int ECC,int EAC,int uom,int uomscale,int datatype,int Idtvalue, double Fdtvalue,
                               int Idtval2, double Fdtval2, int IntervalType,
                               char * instring, int LongListIndex)
{
struct LocalAttrValList *cvl;
struct reflist *refcl; 
int SzAV = sizeof(struct LocalAttrValList);
int SzRL = sizeof(struct reflist);
int SzALEP = sizeof(struct NGA_ALEP);
int insertnewvalue;
int i;
double DblIval2;
char QueryLabel[1000];
rb_red_blk_node * RB_newNode;

   insertnewvalue = 0;

   if((EAC > TTF_MaximumEACcount) || (datatype > 4))
      {
      printf("Attribute index range violation - expected maximum of %d\n",TTF_MaximumEACcount);
      printf("presented with index %d\n",EAC);
      printf("subarray maximum 4\n presented with %d\n",datatype);
      exit(-1);
      }
   if(NGA_LALentries[EAC].SortTree[datatype] == NULL)
      {
      NGA_LALentries[EAC].SortTree[datatype] = (struct NGA_ALEP *) (malloc(SzALEP));
      if(NGA_LALentries[EAC].SortTree[datatype] == NULL)
         {
         printf("allocation memory exhausted during attribute catalog operation (0)\n");
         printf("execution cannot continue\n");
         exit(-1);
         }
      NGA_LALentries[EAC].SortTree[datatype]->occurrences = 0;
      NGA_LALentries[EAC].SortTree[datatype]->code = EAC;
      NGA_LALentries[EAC].SortTree[datatype]->count = 1;
      NGA_LALentries[EAC].SortTree[datatype]->refcount = 0;
      NGA_LALentries[EAC].SortTree[datatype]->thisindex = 0;
      if(datatype == 2) /** a string type ***/
          NGA_LALentries[EAC].SortTree[datatype]->stringdigits = 1;
      else
          NGA_LALentries[EAC].SortTree[datatype]->stringdigits = 0;
      NGA_LALentries[EAC].SortTree[datatype]->references = NULL;

      cvl = (struct LocalAttrValList *) (malloc(SzAV));
      if(cvl == NULL)
         {
         printf("allocation memory exhausted during attribute catalog operation\n");
         printf("execution cannot continue\n");
         exit(-1);
         }
      cvl->type = datatype;
      cvl->ClassCode = ECC;
      cvl->occurrences = 0;
      cvl->uniqueoccurrences = 0;
      cvl->uom = uom;
      cvl->scale = uomscale;
      cvl->label = NULL;
      if(datatype == 2)  /** a string ***/
         cvl->sortlabel = (char *) malloc(Idtvalue + 10);
      else
         cvl->sortlabel = (char *) malloc(30);
      if(cvl->sortlabel == NULL)
         {
         printf("memory exhausted during RB-Tree sort label allocation\n");
         exit(-1);
         }
      cvl->refcount = 0;
      cvl->intervaltype = IntervalType;
      cvl->references = NULL;
      refcl = (struct reflist *) (malloc(SzRL));
      if(refcl == NULL)
         {
         printf("allocation memory exhausted during attribute catalog operation (reference indexing)\n");
         printf("execution cannot continue\n");
         exit(-1);
         }
      cvl->LLindexcount = 1;
      refcl->index = LongListIndex;
      refcl->next = NULL;
      cvl->LongListIndices = refcl;
      cvl->UniqueLLindexcount = 0;
      cvl->UniqueLLindices = NULL;
      cvl->next = NULL;

      switch(datatype)
         {
         case 0: /** regular integer **/
            cvl->value = (double) Idtvalue;
            sprintf(cvl->sortlabel,"%lf_%d",cvl->value,cvl->ClassCode);
            break;
         case 1: /** a double **/
            cvl->value = Fdtvalue;
            sprintf(cvl->sortlabel,"%lf_%d",cvl->value,cvl->ClassCode);
            break;
         case 2: /** a string **/
            cvl->label = (char *) (malloc(Idtvalue + 1)); /** in this case, Idtvalue is strlen of instring **/
            cvl->value = (double) Idtvalue; /** and by convention, we store the strlen in ->value **/
            if(Idtvalue == 0)
               NGA_LALentries[EAC].SortTree[datatype]->stringdigits = 0;
            else
               {
               for(i=0; i<Idtvalue; i++)
                  {
                  if((instring[i] < '0') || (instring[i] > '9'))
                     {
                     NGA_LALentries[EAC].SortTree[datatype]->stringdigits = 0;
                     break;
                     }
                  }
               }
            strcpy(cvl->label,instring);

            cvl->label[Idtvalue] = '\0';
            sprintf(cvl->sortlabel,"%s_%d",cvl->label,cvl->ClassCode);
            break;
         case 3: /** enum as int **/
         case 4: /** attribute metadata as int **/
            cvl->value = (double) Idtvalue;
            sprintf(cvl->sortlabel,"%lf_%d",cvl->value,cvl->ClassCode);
            break;
         default:
            printf("did not recognize datatype %d as possible for NGA data\n",datatype);
            exit(-1);
         }
      cvl->next = NULL;


      NGA_LALentries[EAC].SortTree[datatype]->RB_Entry = TTF_RBTreeCreate(TTF_StrComp,TTF_StrDest,TTF_InfoDest,TTF_IntPrint,TTF_InfoPrint);
      TTF_RBTreeInsert(NGA_LALentries[EAC].SortTree[datatype]->RB_Entry,cvl->sortlabel,cvl);
      }
   else
      {
      insertnewvalue = 1;
      switch(datatype)
         {
         case 0: /*** integer ***/
            DblIval2 = (double) Idtvalue;
            sprintf(QueryLabel,"%lf_%d",DblIval2,ECC);
            if((RB_newNode = TTF_RBExactQuery(NGA_LALentries[EAC].SortTree[datatype]->RB_Entry, QueryLabel)))
               insertnewvalue = 0;
            break;
         case 1: /*** double ***/
            sprintf(QueryLabel,"%lf_%d",Fdtvalue,ECC);
            if((RB_newNode = TTF_RBExactQuery(NGA_LALentries[EAC].SortTree[datatype]->RB_Entry, QueryLabel)))
               insertnewvalue = 0;
            break;
         case 2: /*** string ***/
if(strlen(instring) > 990)
{
printf("unexpected length for QueryString: %d\n",(int) strlen(instring));
exit(-1);
}
            sprintf(QueryLabel,"%d_%s",ECC,instring);
            sprintf(QueryLabel,"%s_%d",instring,ECC);
            if((RB_newNode = TTF_RBExactQuery(NGA_LALentries[EAC].SortTree[datatype]->RB_Entry, QueryLabel)))
               insertnewvalue = 0;
            break;
         case 3: /** enum ***/
            DblIval2 = (double) Idtvalue;
            sprintf(QueryLabel,"%lf_%d",DblIval2,ECC);
            if((RB_newNode = TTF_RBExactQuery(NGA_LALentries[EAC].SortTree[datatype]->RB_Entry, QueryLabel)))
               insertnewvalue = 0;
            break;
         case 4: /** metadata ***/
            DblIval2 = (double) Idtvalue;
            sprintf(QueryLabel,"%lf_%d",DblIval2,ECC);
            if((RB_newNode = TTF_RBExactQuery(NGA_LALentries[EAC].SortTree[datatype]->RB_Entry, QueryLabel)))
               insertnewvalue = 0;
            break;
         }
      if(insertnewvalue > 0) /*** have not seen this value before, so put in into tree structure ***/
         {

         NGA_LALentries[EAC].SortTree[datatype]->count += 1; 

         cvl = (struct LocalAttrValList *) (malloc(SzAV));
         if(cvl == NULL)
            {
            printf("allocation memory exhausted during attribute catalog operation\n");
            printf("execution cannot continue\n");
            exit(-1);
            }
         cvl->type = datatype;
         cvl->ClassCode = ECC;
         cvl->occurrences = 0;
         cvl->uniqueoccurrences = 0;
         cvl->uom = uom;
         cvl->scale = uomscale;
         cvl->label = NULL;
         if(datatype == 2)  /** a string ***/
            cvl->sortlabel = (char *) malloc(Idtvalue + 10);
         else
            cvl->sortlabel = (char *) malloc(strlen(QueryLabel) + 1);
         if(cvl->sortlabel == NULL)
            {
            printf("memory exhausted during RB-Tree sort label allocation\n");
            exit(-1);
            }
         strcpy(cvl->sortlabel,QueryLabel);
         cvl->refcount = 0;
         cvl->intervaltype = IntervalType;
         cvl->references = NULL;
         refcl = (struct reflist *) (malloc(SzRL));
         if(refcl == NULL)
            {
            printf("allocation memory exhausted during attribute catalog operation (reference indexing)\n");
            printf("execution cannot continue\n");
            exit(-1);
            }
         cvl->LLindexcount = 1;
         refcl->index = LongListIndex;
         refcl->next = NULL;
         cvl->LongListIndices = refcl;
         cvl->UniqueLLindexcount = 0;
         cvl->UniqueLLindices = NULL;
         switch(datatype)
            {
            case 0: /** regular integer **/
               cvl->value = (double) Idtvalue;
               break;
            case 1: /** a double **/
               cvl->value = Fdtvalue;
               break;
            case 2: /** a string **/
               cvl->label = (char *) (malloc(Idtvalue + 1)); /** in this case, Idtvalue is strlen of instring **/
               cvl->value = (double) Idtvalue; /** and by convention, we store the strlen in ->value **/
               if(Idtvalue == 0)
                  NGA_LALentries[EAC].SortTree[datatype]->stringdigits = 0;
               else
                  {/** will need to know if the string value is really numeric **/
                  for(i=0; i<Idtvalue; i++)
                     {
                     if((instring[i] < '0') || (instring[i] > '9'))
                        {
                        NGA_LALentries[EAC].SortTree[datatype]->stringdigits = 0;
                        break;
                        }
                     }
                  }
               strcpy(cvl->label,instring);
               cvl->label[Idtvalue] = '\0';
               break;
            case 3: /** enum as int **/
            case 4: /** attribute metadata as int **/
               cvl->value = (double) Idtvalue;
               break;
            }
         cvl->next = NULL;

         TTF_RBTreeInsert(NGA_LALentries[EAC].SortTree[datatype]->RB_Entry,cvl->sortlabel,cvl);
         }  /** end insert new value ***/
      else
         {
         cvl = (struct LocalAttrValList *) (RB_newNode->info); 
         cvl->LLindexcount += 1;
         refcl = (struct reflist *) (malloc(SzRL));
         if(refcl == NULL)
            {
            printf("allocation memory exhausted during attribute catalog operation (index for references)\n");
            printf("execution cannot continue\n");
            exit(-1);
            }
         refcl->index = LongListIndex;
         refcl->next = cvl->LongListIndices;
         cvl->LongListIndices = refcl;
         }
      }
}





void InsertIntoAttrIndexList(int IndVal, int idn)
{
struct indexlist * il;
int SzIr = sizeof(struct indexlist);


   if(Iroot[IndVal].msgid < 0)
      {
      Iroot[IndVal].msgid = idn;
      Iroot[IndVal].next = NULL;
      }
   else
      {
      il = (struct indexlist *) (malloc(SzIr));
      if(il == NULL)
         {
         printf("allocation memory exhausted during error message allocation\n");
         exit(-1);
         }
      il->index = IndVal;
      il->msgid = idn;
      il->next = Iroot[IndVal].next;
      Iroot[IndVal].next = il;
      }
   return;
}




void InsertIntoSummary_AttrErrorList(char *linein, int LLindex)
{
struct errorlist * er;
char * RBkey;
rb_red_blk_node * RB_newNode;


   RBkey = (char *) (malloc(strlen(linein) + 1));
   strcpy(RBkey,linein);
   if((RB_newNode = TTF_RBExactQuery(Summary_AE_Tree,RBkey)))
      {
      free(RBkey);
      E1 = (struct errorlist *) RB_newNode->info;
      if((LLindex < 0) && ((linein[0] == 'p') || (linein[0] == 'P')))
         E1->count += 1;
      else if(LLindex < 0)
         E1->count -= LLindex;
      else
         E1->count += LongListInstances[LLindex];
      }
   else
      {
      er = (struct errorlist *)(malloc(SzEr));
      if(er == NULL)
         {
         printf("memory has been exhausted during RB-Tree information alloction for Unique Identifier frequency analysis\n");
         exit(-1);
         }
      er->LindexList = NULL;
      er->long_attr_fid = -999;
      er->msgline = (char *) (malloc(strlen(linein) + 1));
      if(er->msgline == NULL)
         {
         printf("allocation memory exhausted during error message allocation\n");
         exit(-1);
         }
      strcpy(er->msgline,linein);
      if((LLindex < 0) && ((linein[0] == 'p') || (linein[0] == 'P')))
         er->count = 1;
      else if(LLindex < 0)  /*** do this as pass in neg count for long value attrs (HGT, ARA, ZV2 and equivalents)  ***/
         {
         er->count = 0 - LLindex;
         if(Global_FID_Index != -999)
            er->long_attr_fid = Global_FID_Index;
         }
      else
         er->count = LongListInstances[LLindex];
      er->next = NULL;
      er->idnumber = 1;
      TTF_RBTreeInsert(Summary_AE_Tree,RBkey,er);
      }

   return;
}




void InsertIntoSpecial_GIFD_AttrErrorList(char *linein, int LLindex)
{
struct errorlist * er;
struct EnumList *en,*ep;
int k;


   if(GIFD_Eroot == NULL)
      {
      er = (struct errorlist *) (malloc(SzEr));
      if(er == NULL)
         {
         printf("allocation memory exhausted during error message allocation\n");
         exit(-1);
         }
      er->long_attr_fid = -999;
      er->msgline = (char *) (malloc(strlen(linein) + 2));
      if(LLindex >= 0)
         {
         er->LindexList = (struct EnumList *) (malloc(sizeof(struct EnumList)));
         er->LindexList->val = LLindex;
         er->LindexList->next = NULL;
         }
      else
         er->LindexList = NULL;
      if(er->msgline == NULL)
         {
         printf("allocation memory exhausted during error message allocation\n");
         exit(-1);
         }
      strcpy(er->msgline,linein);
      er->count = 1;
      er->next = NULL;
      er->idnumber = 1;
      GIFD_Eroot = er;
      }
   else
      {
      E2 = NULL;
      E1 = GIFD_Eroot;
      while(E1 != NULL)
         {
         k = strcmp(linein, E1->msgline);
         if(k <= 0)
            break;
         E2 = E1;
         E1 = E1->next;
         }
      if(k == 0) /** same line already encountered **/
         {
         E1->count += 1;
         en = (struct EnumList *) (malloc(sizeof(struct EnumList)));
         en->val = LLindex;
         en->next = NULL;
         if(E1->LindexList == NULL)
            E1->LindexList = en;
         else
            {
            ep = E1->LindexList;
            while(ep->next != NULL)
               {
               if(ep->val == LLindex)
                  break;
               ep = ep->next;
               }
            if((ep->next == NULL) && (ep->val != LLindex))
               ep->next = en;
            else
               free(en);
            }
         }
      else
         {
         er = (struct errorlist *) (malloc(SzEr));
         if(er == NULL)
            {
            printf("allocation memory exhausted during error message allocation\n");
            exit(-1);
            }
         if(LLindex >= 0)
            {
            er->LindexList = (struct EnumList *) (malloc(SzEr));
            er->LindexList->val = LLindex;
            er->LindexList->next = NULL;
            }
         else
            er->LindexList = NULL;

         er->msgline = (char *) (malloc(strlen(linein) + 2));
         er->long_attr_fid = -999;
         er->idnumber = -1;
         if(er->msgline == NULL)
            {
            printf("allocation memory exhausted during error message allocation\n");
            exit(-1);
            }
         strcpy(er->msgline,linein);
         er->count = 1;
         er->next = NULL;
         if(E1 == GIFD_Eroot)
            {
            er->next = GIFD_Eroot;
            GIFD_Eroot = er;
            }
         else
            {
            er->next = E2->next;
            E2->next = er;
            }
         }
      }
   return;
}





void InsertIntoGIFD_AttrErrorList(char *linein, int LLindex)
{
struct errorlist * er;
struct EnumList *en,*ep;
char * RBkey;
rb_red_blk_node * RB_newNode;


   RBkey = (char *) (malloc(strlen(linein) + 1));
   strcpy(RBkey,linein);
   if((RB_newNode = TTF_RBExactQuery(GIFD_AE_Tree,RBkey)))
      {
      free(RBkey);
      E1 = (struct errorlist *) RB_newNode->info;
      if((LLindex < 0) && ((linein[0] == 'p') || (linein[0] == 'P')))
         E1->count += 1;
      else if(LLindex >= 0)
         {
         E1->count += LongListInstances[LLindex];
         en = (struct EnumList *) (malloc(sizeof(struct EnumList)));
         en->val = LLindex;
         en->next = NULL;
         if(E1->LindexList == NULL)
            E1->LindexList = en;
         else
            {
            ep = E1->LindexList;
            while(ep->next != NULL)
               {
               if(ep->val == LLindex)
                  break;
               ep = ep->next;
               }
            if((ep->next == NULL) && (ep->val != LLindex))
               ep->next = en;
            else
               free(en);
            }
         }
      else
         {
         E1->count -= LLindex; /*** this works for UID with MGCP metadata check ***/
         if(Global_FID_Index != -999)
            {
            en = (struct EnumList *) (malloc(sizeof(struct EnumList)));
            en->val = Global_FID_Index;
            en->next = NULL;
            if(E1->LindexList == NULL)
               E1->LindexList = en;
            else
               {
               ep = E1->LindexList;
               while(ep->next != NULL)
                  {
                  if(ep->val == Global_FID_Index)
                     break;
                  ep = ep->next;
                  }
               if((ep->next == NULL) && (ep->val != Global_FID_Index))
                  ep->next = en;
               else
                  free(en);
               }
            }
         }
      } /*** end, if already have this in the tree ***/
   else
      {
      er = (struct errorlist *) (malloc(SzEr));
      if(er == NULL)
         {
         printf("allocation memory exhausted during error message allocation\n");
         exit(-1);
         }
      if(LLindex >= 0)
         {
         er->LindexList = (struct EnumList *) (malloc(sizeof(struct EnumList)));
         er->LindexList->val = LLindex;
         er->LindexList->next = NULL;
         }
      else
         er->LindexList = NULL;

      er->msgline = (char *) (malloc(strlen(linein) + 1));
      er->long_attr_fid = -999;
      er->idnumber = -1;
      if(er->msgline == NULL)
         {
         printf("allocation memory exhausted during error message allocation\n");
         exit(-1);
         }
      strcpy(er->msgline,linein);
      if((LLindex < 0) && ((linein[0] == 'p') || (linein[0] == 'P')))
         er->count = 1;
      else if(LLindex >= 0)
         er->count = LongListInstances[LLindex];
      else
         {
         er->count = 0 - LLindex; /*** this works for UID with MGCP metadata check ***/
         if(Global_FID_Index != -999)
            {
            er->long_attr_fid = Global_FID_Index;
            er->LindexList = (struct EnumList *) (malloc(sizeof(struct EnumList)));
            er->LindexList->val = Global_FID_Index;
            er->LindexList->next = NULL;
            }
         }
      er->next = NULL;

      TTF_RBTreeInsert(GIFD_AE_Tree,RBkey,er);
      }

   return;
}



void InsertIntoGIFD_MetaData_Totals(char *linein, int LLindex)
{
struct errorlist * er;
int k;

   if(GIFD_MTroot == NULL)
      {
      er = (struct errorlist *) (malloc(SzEr));
      if(er == NULL)
         {
         printf("allocation memory exhausted during error message allocation\n");
         exit(-1);
         }
      er->msgline = (char *) (malloc(strlen(linein) + 5));
      er->long_attr_fid = -999;
      er->LindexList = NULL;
      if(er->msgline == NULL)
         {
         printf("allocation memory exhausted during error message allocation\n");
         exit(-1);
         }
      strcpy(er->msgline,linein);
      if(LLindex >= 0)
         er->count = LongListInstances[LLindex];
      else
         {
         er->count = 0 - LLindex;  /** do this for the MGCP UID metadata requirements ***/
         if(Global_FID_Index != -999)
            er->long_attr_fid = Global_FID_Index;
         }
      er->next = NULL;
      er->idnumber = 1;
      GIFD_MTroot = er;
      }
   else
      {
      E2 = NULL;
      E1 = GIFD_MTroot;
      while(E1 != NULL)
         {
         k = strcmp(linein, E1->msgline);
         if(k <= 0)
            break;
         E2 = E1;
         E1 = E1->next;
         }
      if(k == 0) /** same line already encountered **/
         {
         if(LLindex >= 0)
            E1->count += LongListInstances[LLindex]; 
         else
            E1->count -= LLindex; /** do this for the MGCP UID metadata requirements ***/
         }
      else
         {
         er = (struct errorlist *) (malloc(SzEr));
         if(er == NULL)
            {
            printf("allocation memory exhausted during error message allocation\n");
            exit(-1);
            }
         er->msgline = (char *) (malloc(strlen(linein) + 5));
         er->LindexList = NULL;
         er->long_attr_fid = -999;
         er->idnumber = -1;
         if(er->msgline == NULL)
            {
            printf("allocation memory exhausted during error message allocation\n");
            exit(-1);
            }
         strcpy(er->msgline,linein);
         if(LLindex >= 0)
            er->count = LongListInstances[LLindex];
         else
            {
            er->count = 0 - LLindex;  /** do this for the MGCP UID metadata requirements ***/
            if(Global_FID_Index != -999)
               er->long_attr_fid = Global_FID_Index;
            }
         er->next = NULL;
         if(E1 == GIFD_MTroot)
            {
            er->next = GIFD_MTroot;
            GIFD_MTroot = er;
            }
         else
            {
            er->next = E2->next;
            E2->next = er;
            }
         }
      }
   return;
}




int InsertIntoAttrErrorList(char *linein, int LLindex)
{
struct errorlist * er;
struct EnumList *en, *ep;
int answer;
char * RBkey;
rb_red_blk_node * RB_newNode;

   RBkey = (char *) (malloc(strlen(linein) + 1));
   strcpy(RBkey,linein);
   if((RB_newNode = TTF_RBExactQuery(Regular_AE_Tree,RBkey)))
      {
      free(RBkey);
      E1 = (struct errorlist *) RB_newNode->info;
      if(NGA_TYPE > 0)
         {
         if((LLindex < 0) && ((linein[0] == 'p') || (linein[0] == 'P')))
            E1->count += 1;
         else if(LLindex >= 0)
            {
            E1->count += LongListInstances[LLindex];
            en = (struct EnumList *) (malloc(sizeof(struct EnumList)));
            en->val = LLindex;
            en->next = NULL;
            if(E1->LindexList == NULL)
               E1->LindexList = en;
            else
               {
               ep = E1->LindexList;
               while(ep->next != NULL)
                  {
                  if(ep->val == LLindex)
                     break;
                  ep = ep->next;
                  }
               if((ep->next == NULL) && (ep->val != LLindex))
                  ep->next = en;
               else
                  free(en);
               }
            }
         else
            {
            E1->count -= LLindex; // account for MGCP UID metadata requirement
            if(Global_FID_Index != -999)
               {
               en = (struct EnumList *) (malloc(SzEr));
               en->val = Global_FID_Index;
               en->next = NULL;
               if(E1->LindexList == NULL)
                  E1->LindexList = en;
               else
                  {
                  ep = E1->LindexList;
                  while(ep->next != NULL)
                     {
                     if(ep->val == Global_FID_Index)
                        break;
                     ep = ep->next;
                     }
                  if((ep->next == NULL) && (ep->val != Global_FID_Index))
                     ep->next = en;
                  else
                     free(en);
                  }
               }
            }
         }
      else
         E1->count += 1;
      answer = E1->idnumber;
      } // end, if already have this in the tree 
   else
      {
         er = (struct errorlist *) (malloc(SzEr));
         if(er == NULL)
            {
            printf("allocation memory exhausted during error message allocation\n");
            exit(-1);
            }
         er->LindexList = NULL;
         er->long_attr_fid = -999;
         er->msgline = (char *) (malloc(strlen(linein) + 1));
         AttrErrMsgID += 1;
         er->idnumber = AttrErrMsgID;
         answer = AttrErrMsgID;
         if(er->msgline == NULL)
            {
            printf("allocation memory exhausted during error message allocation\n");
            exit(-1);
            }
         strcpy(er->msgline,linein);
         if(NGA_TYPE > 0)
            {
            if((LLindex < 0) && ((linein[0] == 'p') || (linein[0] == 'P')))
               er->count = 1;
            else if(LLindex >= 0)
               {
               er->count = LongListInstances[LLindex];
               er->LindexList = (struct EnumList *) (malloc(sizeof(struct EnumList)));
               er->LindexList->val = LLindex;
               er->LindexList->next = NULL;
               }
            else
               {
               er->count = 0 - LLindex;  // account for MGCP UID metadata requirement 
               if(Global_FID_Index != -999)
                  {
                  er->long_attr_fid = Global_FID_Index;
                  er->LindexList = (struct EnumList *) (malloc(sizeof(struct EnumList)));
                  er->LindexList->val = Global_FID_Index;
                  er->LindexList->next = NULL;
                  }
               }
            }
         else
            er->count = 1;
         er->next = NULL;

      TTF_RBTreeInsert(Regular_AE_Tree,RBkey,er);
      }

   return(answer);
}



void InsertIntoGIFD_MetaData_ErrorList(char *linein, int LLindex)
{
struct errorlist * er;
int k,s, useid;

   if(GIFD_Mroot == NULL)
      {
      er = (struct errorlist *) (malloc(SzEr));
      if(er == NULL)
         {
         printf("allocation memory exhausted during error message allocation\n");
         exit(-1);
         }
      er->LindexList = NULL;
      er->long_attr_fid = -999;
      er->msgline = (char *) (malloc(strlen(linein) + 1));
      if(er->msgline == NULL)
         {
         printf("allocation memory exhausted during error message allocation\n");
         exit(-1);
         }
      strcpy(er->msgline,linein);
      if(LLindex >= 0)
         er->count = LongListInstances[LLindex];
      else
         er->count = 0 - LLindex;  /*** for MGCP UID MetaData requirement **/
      er->next = NULL;
      er->idnumber = 1;
      GIFD_Mroot = er;
      }
   else
      {
      E2 = NULL;
      E1 = GIFD_Mroot;
      while(E1 != NULL)
         {
         k = strcmp(linein, E1->msgline);
         if(k <= 0)
            break;
         E2 = E1;
         E1 = E1->next;
         }
      if(k == 0) /** same line already encountered **/
         {
         if(LLindex >= 0)
            E1->count += LongListInstances[LLindex];
         else
            {
            E1->count -= LLindex; /*** for MGCP UID MetaData requirement **/
            if(Global_FID_Index != -999)
               E1->long_attr_fid = Global_FID_Index;
            }
         }
      else
         {
         er = (struct errorlist *) (malloc(SzEr));
         if(er == NULL)
            {
            printf("allocation memory exhausted during error message allocation\n");
            exit(-1);
            }
         er->LindexList = NULL;
         er->long_attr_fid = -999;
         er->msgline = (char *) (malloc(strlen(linein) + 1));
         er->idnumber = -1;
         if(er->msgline == NULL)
            {
            printf("allocation memory exhausted during error message allocation\n");
            exit(-1);
            }
         strcpy(er->msgline,linein);
         if(LLindex >= 0)
            er->count = LongListInstances[LLindex];
         else
            {
            er->count = 0 - LLindex;  /*** for MGCP UID MetaData requirement **/
            if(Global_FID_Index != -999)
               er->long_attr_fid = Global_FID_Index;
            }
         er->next = NULL;
         if(E1 == GIFD_Mroot)
            {
            er->next = GIFD_Mroot;
            GIFD_Mroot = er;
            }
         else
            {
            er->next = E2->next;
            E2->next = er;
            }
         }
      }

   k = 0;
   s = strlen(linein);
   while((k < s) && (linein[k] != ':'))
      ++k;
   if((linein[k] == ':') && (strncmp("Table",&linein[k+1],5) == 0))
   {
	   ++k;
	   while((k<s) && (linein[k] != ':'))
		   ++k;
   }
   ++k;
   while((k < s) && (linein[k] != ':'))
      ++k;

   if(k < s) 
      {
      InsertIntoGIFD_MetaData_Totals(&linein[k+1], LLindex);
      useid = InsertIntoAttrErrorList(&linein[k+1],LLindex);
      if(LLindex >= 0)
         InsertIntoAttrIndexList(LLindex,useid);
/*********/
      }
else 
{
printf("k is %d, s is %d\n string %s\n\n",k,s,linein);
exit(1);
}

   return;
}





void InsertIntoAttributeList(int ECC,int EAC,int uom,int uomscale,int datatype,int Idtvalue, double Fdtvalue,
                               int Idtval2, double Fdtval2, int IntervalType,
                               char * instring, int LongListIndex)
{
struct LocalAttrList *cal, *thisptr;
struct LocalAttrValList *cvl, *nvl, *bvptr, *nvptr, *tvl;
struct reflist *refcl;
int SzAV = sizeof(struct LocalAttrValList);
int SzAL = sizeof(struct LocalAttrList);
int SzRL = sizeof(struct reflist);
int doinsert, insertnewvalue, insertrootvalue;
int duplicatevalue;
int strcmpresult;
int i;
double DblIval, DblIval2;


   doinsert = insertnewvalue = insertrootvalue = 0;
   duplicatevalue = 0;

   if(EAC > TTF_MaximumEACcount)
      {
      printf("Attribute index range violation - expected maximum of %d\n",TTF_MaximumEACcount);
      printf("presented with index %d\n",EAC);
      exit(-1);
      }
   if(LALentries[EAC].Entry[datatype] == NULL)
      {
      doinsert = 1;
      thisptr = NULL;
      }
   else
      {
      cal = LALentries[EAC].Entry[datatype];
         
      duplicatevalue = insertrootvalue = 0;
      insertnewvalue = 1;
      DblIval = (double) Idtvalue;
      DblIval2 = (double) Idtval2;
      thisptr = cal;
      nvl = cvl = cal->values;
      while((cvl != NULL) && (cvl->type == datatype) && (cvl->uom < uom))
         {
         nvl = cvl;
         cvl = cvl->next;
         }
      while((cvl != NULL) && (cvl->type == datatype) && (cvl->uom == uom) &&
              (cvl->scale < uomscale))
         {
         nvl = cvl;
         cvl = cvl->next;
         }
      if((cvl != NULL) && (cvl->type == datatype) && (cvl->uom == uom) &&
              (cvl->scale == uomscale))
         {
         insertnewvalue = 0;
         }
      while((cvl != NULL) && (cvl->type == datatype) && (cvl->uom == uom) &&
              (cvl->scale == uomscale))
         {
         if((datatype == 0) || /** int value **/
            (datatype == 3) || /** enum **/
            (datatype == 4)) /** metadata **/
            {
            if(cvl->value == DblIval)
               {
               tvl = cvl;
               while(tvl->value == DblIval)
                  {
                  if(tvl->ClassCode == ECC)
                     {
                     duplicatevalue = 1;
                     break;
                     }
                  tvl = tvl->next;
                  if((tvl == NULL) || (tvl->value != DblIval))
                     {
                     insertnewvalue = 1;
                     break;
                     }
                  }
              if(duplicatevalue > 0)
                 {
                  break;
                  }
               else if(insertnewvalue > 0)
                  {
                  break; 
                  }
               }
            else if(cvl->value > DblIval) /** want to insert value here **/
               {
               insertnewvalue = 1;
               break;
               }
            }
         else if(datatype == 1) /** a double **/
            {
            if(cvl->value == Fdtvalue)
               {
               tvl = cvl;
               while(tvl->value == Fdtvalue)
                  {
                  if(tvl->ClassCode == ECC)
                     {
                     duplicatevalue = 1;
                     break;
                     }
                  tvl = tvl->next;
                  if((tvl == NULL) || (tvl->value != DblIval))
                     {
                     insertnewvalue = 1;
                     break;
                     }
                  }

               if(   duplicatevalue  > 0)
                  {
                  break;
                  }
               else if(insertnewvalue > 0)
                  {
                  break;
                  }
               }
            else if(cvl->value > Fdtvalue) /** want to insert value here **/
               {
               insertnewvalue = 1;
               break;
               }
            }
         else if(datatype == 2) /** a string **/
            {
            strcmpresult = DigitStrCmp(cvl->label, instring);
            if(strcmpresult == 0) /** same string values **/
               {
               if(cvl->ClassCode == ECC)
                  {
                  tvl = cvl;
                  while(strcmpresult == 0)
                     {
                     if(tvl->ClassCode == ECC)
                        {
                        duplicatevalue = 1;
                        break;
                        }
                     tvl = tvl->next;
                     if(tvl != NULL)
                         strcmpresult = strcmp(tvl->label,instring);
                     if((tvl == NULL) || (strcmpresult != 0))
                        {
                        insertnewvalue = 1;
                        break;
                        }
                     }
                 if(duplicatevalue > 0)
                    {
                     break;
                     }
                  else if(insertnewvalue > 0)
                     {
                     break;
                     }
                  }
               else /***if(cvl->ClassCode > ECC) ***/
                  {
                  insertnewvalue = 1;
                  break;
                  }
               }
            else if(strcmpresult > 0) /** want to insert value here **/
               {
               insertnewvalue = 1;
               break;
               }
            }
         else if(datatype == 5) /** float interval **/
            {
            if(cvl->value == Fdtvalue)
               {
               if(cvl->value2 == Fdtval2)
                  {
                  if(cvl->intervaltype == IntervalType)
                     {
                     tvl = cvl;
                     while((tvl->value == Fdtvalue) && (tvl->value2 == Fdtval2) && (tvl->intervaltype == IntervalType))
                        {
                        if(tvl->ClassCode == ECC)
                           {
                           duplicatevalue = 1;
                           break;
                           }
                        tvl = tvl->next;
                        if((tvl == NULL) || (tvl->value != Fdtvalue) || (tvl->value2 != Fdtval2) || (tvl->intervaltype != IntervalType))
                           {
                           insertnewvalue = 1;
                           break;
                           }
                        }
                     if((duplicatevalue > 0) || (insertnewvalue > 0))
                        break;
                     }
                  else if(cvl->intervaltype > IntervalType)
                     {
                     insertnewvalue = 1;
                     break;
                     }
                  }
               else if(cvl->value2 > Fdtval2) /** want to insert value here **/
                  {
                  insertnewvalue = 1;
                  break;
                  }
               }
            else if(cvl->value > Fdtvalue) /** want to insert value here **/
               {
               insertnewvalue = 1;
               break;
               }
            }
         else if((datatype == 6) || (datatype == 7)) /** int intervals **/
            {
            if(cvl->value == DblIval)
               {
               if(cvl->value2 == DblIval2)
                  {
                  if(cvl->intervaltype == IntervalType)
                     {
                     tvl = cvl;
                     while((tvl->value == Fdtvalue) && (tvl->value2 == Fdtval2) && (tvl->intervaltype == IntervalType))
                        {
                        if(tvl->ClassCode == ECC)
                           {
                           duplicatevalue = 1;
                           break;
                           }
                        tvl = tvl->next;
                        if((tvl == NULL) || (tvl->value != Fdtvalue) || (tvl->value2 != Fdtval2) || (tvl->intervaltype != IntervalType))
                           {
                           insertnewvalue = 1;
                           break;
                           }
                        }
                     if((duplicatevalue > 0) || (insertnewvalue > 0))
                        break;
                     }
                  else 
                     {
                     insertnewvalue = 1;
                     break;
                     }
                  }
               else if(cvl->value2 > DblIval2) /** want to insert value here **/
                  {
                  insertnewvalue = 1;
                  break;
                  }
               }
            else if(cvl->value > DblIval) /** want to insert value here **/
               {
               insertnewvalue = 1;
               break;
               }
            }
         if((duplicatevalue > 0) || (insertnewvalue > 0))
            break;
         nvl = cvl;
         cvl = cvl->next;
         }
      if(cvl == NULL)
         {
         insertnewvalue = 1;
         bvptr = nvl;
         nvptr = NULL;
         }
      else if((duplicatevalue == 0) && (cvl != NULL) && (cvl == cal->values))
         {
         insertrootvalue = 1;
         }
      else if(duplicatevalue == 0)
         {
         insertnewvalue = 1;
         bvptr = nvl;
         nvptr = cvl;
         }
      else
         {
         bvptr = tvl;
         }
      }


   if(doinsert > 0)
      {
      cal = (struct LocalAttrList *) (malloc(SzAL));
      if(cal == NULL)
         {
         printf("allocation memory exhausted during attribute catalog operation\n");
         printf("execution cannot continue\n");
         exit(-1);
         }

      LALentries[EAC].Entry[datatype] = cal;

      cal->occurrences = 0;
      cal->code = EAC;
      cal->count = 1;
      cal->refcount = 0;
      if(datatype == 2) /** a string type ***/
          cal->stringdigits = 1; 
      else
          cal->stringdigits = 0;
      cal->references = NULL;
      cal->next = NULL;

      cvl = (struct LocalAttrValList *) (malloc(SzAV));
      if(cvl == NULL)
         {
         printf("allocation memory exhausted during attribute catalog operation\n");
         printf("execution cannot continue\n");
         exit(-1);
         }
      cvl->type = datatype;
      cvl->ClassCode = ECC;
      cvl->occurrences = 0;
      cvl->uniqueoccurrences = 0;
      cvl->uom = uom;
      cvl->scale = uomscale;
      cvl->sortlabel = NULL;
      cvl->label = NULL;
      cvl->refcount = 0;
      cvl->intervaltype = IntervalType;
      cvl->references = NULL;
      refcl = (struct reflist *) (malloc(SzRL));
      if(refcl == NULL)
         {
         printf("allocation memory exhausted during attribute catalog operation (reference indexing)\n");
         printf("execution cannot continue\n");
         exit(-1);
         }
      cvl->LLindexcount = 1;
      refcl->index = LongListIndex;
      refcl->next = NULL;
      cvl->LongListIndices = refcl;
      cvl->UniqueLLindexcount = 0;
      cvl->UniqueLLindices = NULL;
      switch(datatype)
         {
         case 0: /** regular integer **/
            cvl->value = (double) Idtvalue;
            break;
         case 1: /** a double **/
            cvl->value = Fdtvalue;
            break;
         case 2: /** a string **/
            cvl->label = (char *) (malloc(Idtvalue + 1)); /** in this case, Idtvalue is strlen of instring **/
            cvl->value = (double) Idtvalue; /** and by convention, we store the strlen in ->value **/
            if(Idtvalue == 0)
               cal->stringdigits = 0;
            else
               {
               for(i=0; i<Idtvalue; i++)
                  {
                  if((instring[i] < '0') || (instring[i] > '9'))
                     {
                     if((instring[i] != '-') && (instring[i] != '.'))
                        {
                        cal->stringdigits = 0;
                        break;
                        }
                     }
                  }
               }
            strcpy(cvl->label,instring);
            cvl->label[Idtvalue] = '\0';
            break;
         case 3: /** enum as int **/
         case 4: /** attribute metadata as int **/
            cvl->value = (double) Idtvalue;
            break;
         case 5:  /** double interval **/
            cvl->value = Fdtvalue;
            cvl->value2 = Fdtval2;
            break;
         case 6:
         case 7:
            cvl->value = (double) Idtvalue;
            cvl->value2 = (double) Idtval2;
            break;
         }
      cvl->next = NULL;
      cal->values = cvl;
      }
   else if((insertnewvalue > 0) || (insertrootvalue > 0))
      {
      cvl = (struct LocalAttrValList *) (malloc(SzAV));
      if(cvl == NULL)
         {
         printf("allocation memory exhausted during attribute catalog operation\n");
         printf("execution cannot continue\n");
         exit(-1);
         }
      cvl->type = datatype;
      cvl->ClassCode = ECC;
      cvl->uom = uom;
      cvl->scale = uomscale;
      cvl->label = NULL;
      cvl->sortlabel = NULL;
      cvl->occurrences = 0;
      cvl->uniqueoccurrences = 0;
      cvl->refcount = 0;
      cvl->references = NULL;
      refcl = (struct reflist *) (malloc(SzRL));

      if(refcl == NULL)
         {
         printf("allocation memory exhausted during attribute catalog operation (reference indexing)\n");
         printf("execution cannot continue\n");
         exit(-1);
         }
      refcl->index = LongListIndex;
      cvl->intervaltype = IntervalType;
      cvl->LLindexcount = 1;
      refcl->next = NULL;
      cvl->LongListIndices = refcl;
      cvl->UniqueLLindexcount = 0;
      cvl->UniqueLLindices = NULL;
      switch(datatype)
         {
         case 0: /** regular integer **/
            cvl->value = (double) Idtvalue;
            break;
         case 1: /** a double **/
            cvl->value = Fdtvalue;
            break;
         case 2: /** a string **/
            cvl->label = (char *) (malloc(Idtvalue + 1)); /** in this case, Idtvalue is strlen of instring **/
            if(cvl->label == NULL)
               {
               printf("allocation memory exhausted during attribute catalog operation (label allocation)\n");
               printf("execution cannot continue\n");
               exit(-1);
               }
            cvl->value = (double) Idtvalue; /** and by convention, we store the strlen in ->value **/
            if(Idtvalue == 0)
               cal->stringdigits = 0;
            else
               {
               for(i=0; i<Idtvalue; i++)
                  {
                  if((instring[i] < '0') || (instring[i] > '9'))
                     {
                     if((instring[i] != '-') && (instring[i] != '.'))
                        {
                        cal->stringdigits = 0;
                        break;
                        }
                     }
                  }
               }
            strcpy(cvl->label,instring);
            cvl->label[Idtvalue] = '\0';
            break;
         case 3: /** enum as int **/
         case 4: /** attribute metadata as int **/
            cvl->value = (double) Idtvalue;
            break;
         case 5:  /** double interval **/
            cvl->value = Fdtvalue;
            cvl->value2 = Fdtval2;
            break;
         case 6:
         case 7:
            cvl->value = (double) Idtvalue;
            cvl->value2 = (double) Idtval2;
            break;
         }
      if(insertrootvalue)
         {
         thisptr->count += 1;
         cvl->next = thisptr->values;
         thisptr->values = cvl;
         }
      else
         {
         thisptr->count += 1;
         cvl->next = nvptr;
         bvptr->next = cvl;
         }
      }
   else if(duplicatevalue > 0)
      {
      bvptr->LLindexcount += 1;
      refcl = (struct reflist *) (malloc(SzRL));
      if(refcl == NULL)
         {
         printf("allocation memory exhausted during attribute catalog operation (index for references)\n");
         printf("execution cannot continue\n");
         exit(-1);
         }
      refcl->index = LongListIndex;
      refcl->next = bvptr->LongListIndices;
      bvptr->LongListIndices = refcl;

      }

}



int InsertIntoNameList(int inputECC, char *inputlinein, int index, int SzNL, int SzEL)
{
struct NameList *cnl;
struct EnumList *cel, *pel;
rb_red_blk_node * RB_newNode;
int i,slen;
int inserted = 0;
int ECC;
char linein[ModelNameMaxLength + 10];


   i = 0;
   slen = ModelNameMaxLength - 1;
   while(inputlinein[i] >= ' ')
      {
      linein[i] = inputlinein[i];
      ++i;
      linein[i] = '\0';
      if(i >= slen)
         break;
      }

   if(NGA_TYPE == 1)
      ECC = inputECC;
   else
      {
      if(inputECC >= 0)
         ECC = inputECC;
      else
         ECC = MaximumECCcount + 3;
      }
   if(NALentries[ECC].RB_Entry == NULL)
      {
      NALentries[ECC].RB_Entry = TTF_RBTreeCreate(TTF_StrComp,TTF_StrDest,TTF_InfoDest,TTF_IntPrint,TTF_InfoPrint);

      cnl = (struct NameList *) (malloc(SzNL));
      if(cnl == NULL)
         {
         printf("allocation memory exhausted during Data Name List processing\n");
         exit(-1);
         }
      cnl->ECC = inputECC;
      memset(cnl->name,'\0',ModelNameMaxLength);
      strcpy(cnl->name,linein);
      cnl->name[ModelNameMaxLength - 1] = '\0'; 
      cnl->references = 1;
      cnl->occurrences = 0;
      cnl->areaholes = 0;
      for(i=0; i<NUM_C; i++)
         cnl->configcount[i] = 0;
      cel = (struct EnumList *) (malloc(SzEL));
      if(cel == NULL)
         {
         printf("allocation memory exhausted during Data Name List (index references) processing\n");
         exit(-1);
         }

      cel->val = index;
      cel->next = NULL;
      cnl->indices = cel;
      cnl->LastIndex = cel;
      cnl->next = NULL;

      TTF_RBTreeInsert(NALentries[ECC].RB_Entry,cnl->name,cnl);

      inserted = 1;
      }

   else if((RB_newNode = TTF_RBExactQuery(NALentries[ECC].RB_Entry, linein)))
      {
      cnl = (struct NameList *) (RB_newNode->info);
      cnl->references += 1;
      cel = (struct EnumList *) (malloc(SzEL));
      if(cel == NULL)
         {
         printf("allocation memory exhausted during Data Name List (index references) processing\n");
         exit(-1);
         }
      cel->val = index;
      cel->next = NULL;
      pel = cnl->LastIndex;
      pel->next = cel;
      cnl->LastIndex = cel;
      inserted = 0;
      }
   else
      {
      cnl = (struct NameList *) (malloc(SzNL));
      if(cnl == NULL)
         {
         printf("allocation memory exhausted during Data Name List processing\n");
         exit(-1);
         }
      cnl->ECC = inputECC;
      memset(cnl->name,'\0',ModelNameMaxLength);
      strcpy(cnl->name,linein);
      cnl->name[ModelNameMaxLength - 1] = '\0'; 
      cnl->references = 1; 
      cnl->occurrences = 0; 
      cnl->areaholes = 0;
      for(i=0; i<NUM_C; i++)
         cnl->configcount[i] = 0; 
      cel = (struct EnumList *) (malloc(SzEL));
      if(cel == NULL)
         {
         printf("allocation memory exhausted during Data Name List (index references) processing\n");
         exit(-1);
         }

      cel->val = index;
      cel->next = NULL;
      cnl->indices = cel;
      cnl->LastIndex = cel;
      cnl->next = NULL;

      TTF_RBTreeInsert(NALentries[ECC].RB_Entry,cnl->name,cnl);

      inserted = 1;
      }

   return(inserted);
}




void InsertIntoSCCtable(int IsBigAreal, int index, int val, int fidval, int featureid)
{
struct SCClookup *csl, *psl, *nsl;
struct EnumList *elc, *elp;

int insertOK = 0;

   if(IsBigAreal == 0)
      {
      if(SCCroot[index].inside == 0)
         {
         insertOK = 1;
         psl = &SCCroot[index];
         }
      else
         {
         psl = &SCCroot[index];
         while(psl->next != NULL)
            {
            nsl = psl->next;
            if(nsl->inside >= val)
               {
               if(nsl->inside > val)
                  insertOK = 1;
               break;
               }
            psl = psl->next;
            }
         if(psl->next == NULL)
            insertOK = 1;
         }
      if(insertOK > 0)
         {
         SCCroot[index].inside += 1;
         csl = (struct SCClookup *) (malloc(sizeof(struct SCClookup)));
         csl->inside = val;
         csl->next = psl->next;
         psl->next = csl;
         }
      }

   if((fidval >= 0) && (IsBigAreal == 0))
      {
      if(FIDroot[index].inside == 0)
         {
         insertOK = 1;
         psl = &FIDroot[index];
         }
      else
         {
         psl = &FIDroot[index];
         while(psl->next != NULL)
            {
            nsl = psl->next;
            if(nsl->inside >= fidval)
               {
               if(nsl->inside > fidval)
                  insertOK = 1;
               break;
               }
            psl = psl->next;
            }
         if(psl->next == NULL)
            insertOK = 1;
         }
      if(insertOK > 0)
         {
         FIDroot[index].inside += 1;
         csl = (struct SCClookup *) (malloc(sizeof(struct SCClookup)));
         csl->inside = fidval;
         csl->next = psl->next;
         psl->next = csl;
         }
      }

   if(featureid >= 0)
      {
      if(LLtoFeatureID[val].fidlist == NULL)
         {
         elc = (struct EnumList *) (malloc(sizeof(struct EnumList)));
         if(elc == NULL)
            {
            printf("available memory has been exhausted during feature ID index operation\n");
            exit(-1);
            }
         elc->val = featureid;
         elc->next = NULL;
         LLtoFeatureID[val].counter = 1;
         LLtoFeatureID[val].fidlist = elc;
         LLtoFeatureID[val].fidlist->next = NULL;
         }
      else if(LLtoFeatureID[val].counter > 499)
         {
         LLtoFeatureID[val].counter += 1;
         }
      else
         {
         elp = LLtoFeatureID[val].fidlist;

         while(elp->next != NULL)
            {
            if(elp->val == featureid)
               break;
            elp = elp->next;
            }
         if((elp->next == NULL) && (elp->val != featureid))
            {
            elc = (struct EnumList *) (malloc(sizeof(struct EnumList)));
            if(elc == NULL)
               {
               printf("available memory has been exhausted during feature ID index operation\n");
               exit(-1);
               }
            elc->val = featureid;
            elc->next = NULL;
            elp->next = elc;
            LLtoFeatureID[val].counter += 1;
            }
         }
      }
   return;
}



void SetUpCrosswalk(void)
{
int i,j;
struct NameList *cnl;
struct EnumList *cel;

   cnl = NListRoot;
   i = 0;
   while(cnl != NULL)
      {
      cel = cnl->indices;
      while(cel != NULL)
         {
         if(NArray[cel->val].crossindex < 0)
            NArray[cel->val].crossindex = i;
         else
            {
            printf("duplication problem during cross index initialization\n");
            printf("feature code %d first index %d second index %d\n",NArray[cel->val].code,NArray[cel->val].crossindex,i);
            printf("label name %s\n",GetECCLabel(NArray[cel->val].code));
            exit(-1);
            }
         cnl->occurrences += NArray[cel->val].occurrences;
         for(j=0; j<NUM_C; j++)
            cnl->configcount[j] += NArray[cel->val].configcount[j];

         cnl->areaholes += NArray[cel->val].areaholes;

         cel = cel->next;
         }
      ++i;
      cnl = cnl->next;
      }
   return;


}



void FreeNGAattrSpec(void)
{

   if(ngaNoRecord != NULL)
      {
      free(ngaNoRecord->name);
      free(ngaNoRecord);
      ngaNoRecord = NULL;
      }

   ngac = NGAclassRoot;
   while(ngac != NULL)
      {
      Ac = ngac->attr;
      while(Ac != NULL)
         {
         if(Ac->name != NULL)
            {
            free(Ac->name);
            }
         if(Ac->codeDomain != NULL)
            {
            free(Ac->codeDomain);
            }

         Ap = Ac;
         Ac = Ac->next;
         free(Ap);
         }
      if(ngac->name != NULL)
         free(ngac->name);

      ngap = ngac;
      ngac = ngac->next;
      free(ngap);
      }

   NGAclassRoot = NULL;

   ngac = NGAmetaRoot;
   while(ngac != NULL)
      {
      Ac = ngac->attr;
      while(Ac != NULL)
         {
         if(Ac->name != NULL)
            free(Ac->name);
         if(Ac->codeDomain != NULL)
            free(Ac->codeDomain);
         if(Ac->strval != NULL)
            free(Ac->strval);

         Ap = Ac;
         Ac = Ac->next;
         free(Ap);
         }
      if(ngac->name != NULL)
         free(ngac->name);

      ngap = ngac;
      ngac = ngac->next;
      free(ngap);
      }
   NGAmetaRoot = NULL;
}


struct NGAclass * GetGIFD_meta(char * metaname)
{
static struct NGAclass *ng;

   ng = NGAmetaRoot;
   while(ng != NULL)
      {
      if(strcmp(metaname, ng->name) == 0)
         break;
      ng = ng->next;
      }
   return(ng);
}




int BIN_ParseNGApicklist(char filein[])
{
FILE *picklistfile;
int i,j,sl,numenum;
unsigned char readc;
char domain[1500];
char code[1500];
char value[1500];
int SzPT = sizeof(struct PickTop);
int SzPL = sizeof(struct NGApicklist);


   PickRoot = NULL;
   picklistfile = fopen(filein,"rb");
   if(picklistfile == NULL)
      {
      printf("could not open file %s during preparation for attribute analysis\n",filein);
      return(0);
      }
   PickRoot = NULL;

   fread(&readc,1,1,picklistfile);
   i = (int) readc;
   i = readc;
   fread(code,i,1,picklistfile);
   code[i] = '\0';
   sscanf(code,"%d",&numenum);
   while(feof(picklistfile) == 0)
      {
      fread(&readc,1,1,picklistfile);
      j = (int) readc;  /** number of characters in the domain name ***/
      j = readc;
      fread(domain,j,1,picklistfile);
      domain[j] = '\0';

      PRn = (struct PickTop *) (malloc(SzPT));
      if(PRn == NULL)
         {
         printf("used all emmory\n");
         exit(-1);
         }

      sl = strlen(domain);
      if(sl > 38)
         {
         printf("predefined array space (40) too small for coded domain name %s (length %d)\n",domain,sl);
         exit(-1);
         }
      strcpy(PRn->domain,domain);
      PRn->picks = NULL;
      PRn->next = NULL;
      if(PickRoot == NULL)
         PickRoot = PRn;
      else
         PRp->next = PRn;
      PRp = PRn;

      for(i=0; i<numenum; i++)
         {
         fread(&readc,1,1,picklistfile);
         j = (int) readc;
         j = readc;
         fread(code,j,1,picklistfile);  /** the enum code ***/
         code[j] = '\0';
         fread(&readc,1,1,picklistfile);
         if(readc != '|')
            {
            printf("123: misaligned in binary domain file read\n");
            exit(1);
            }
         j = 0;
         fread(&readc,1,1,picklistfile);
         while(readc != '|')
            {
            value[j] = readc;
            ++j;
            value[j] = '\0';
            fread(&readc,1,1,picklistfile);
            }

         pc = (struct NGApicklist *) (malloc(SzPL));
         if(pc == NULL)
            {
            printf("used all memory\n");
            exit(-1);
            }
         pc->next = NULL;
         sl = strlen(value);
         if(sl > 0)
            {
            pc->value = (char *) (malloc(sl + 2));
            if(pc->value == NULL)
               {
               printf("all allocation memory has been exhausted\n");
               exit(-1);
               }
            strcpy(pc->value,value);
            }
         else
            {
            pc->value = (char *) (malloc(2));
            if(pc->value == NULL)
               {
               printf("all allocation memory has been exhausted\n");
               exit(-1);
               }
            pc->value[0] = '\0';
            }


         sl = strlen(code);
         if(sl > 0)
            {
            pc->code = (char *) (malloc(sl + 2));
            if(pc->code == NULL)
               {
               printf("all allocation memory has been exhausted\n");
               exit(-1);
               }
            strcpy(pc->code,code);
            }
         else
            {
            pc->code = (char *) (malloc(2));
            if(pc->code == NULL)
               {
               printf("all allocation memory has been exhausted\n");
               exit(-1);
               }
            pc->code[0] = '\0';
            }

         if(PRn->picks == NULL)
            PRn->picks = pc;
         else
            pp->next = pc;

         pp = pc;
         }

      fread(&readc,1,1,picklistfile);
      i = (int) readc;
      i = readc;
      fread(code,i,1,picklistfile);
      code[i] = '\0';
      if(strcmp(code,"********") == 0)
         break;
      sscanf(code,"%d",&numenum);
      }
   fclose(picklistfile);
   return(1);
}






int ParseNGApicklist(char filein[])
{
FILE *picklistfile;
int i,j,k,sl;
char domain[1500];
char code[1500];
char value[1500];
char linein[1500];
char lastdomain[1500];
int SzPT = sizeof(struct PickTop);
int SzPL = sizeof(struct NGApicklist);
   if(BIN_ATTR_TYPE == 1)
      {
      return(BIN_ParseNGApicklist(filein));
      }
   picklistfile = fopen(filein,"rt");
   if(picklistfile == NULL)
      {
      printf("could not open file %s during preparation for attribute analysis\n",filein);
      return(0);
      }
   PickRoot = NULL;
   strcpy(lastdomain,"jdscjksnch");
   fgets(linein,1499,picklistfile);
   fgets(linein,1499,picklistfile);

   while(feof(picklistfile) == 0)
      {
      i = 0;
      while(linein[i] != ',')
         {
         domain[i] = linein[i];
         ++i;
         }
      domain[i] = '\0';
      ++i;
      while(linein[i] != ',') /** skip code type (redundant) ***/
         ++i;
      ++i;
      j = 0;
      while(linein[i] != ',')
         {
         code[j] = linein[i];
         ++i;
         ++j;
         if((j > 1495) || (i > 1495))
            {
            printf("predefined arrays (code, linein) are too small in ParseNGApicklist: i %d j %d\n%s\n",i,j,linein);
            exit(-1);
            }
         }
      code[j] = '\0';
      ++i;
      j = 0;
      while(linein[i] >= ' ')
         {
         value[j] = linein[i];
         ++j;
         ++i;
         if((j > 1495) || (i > 1495))
            {
            printf("predefined arrays (value, linein) are too small in ParseNGApicklist: i %d j %d\n%s\n",i,j,linein);
            exit(-1);
            }
         }
      value[j] = '\0';

      k = strcmp(domain,lastdomain);
      if(k != 0)
         {
         strcpy(lastdomain,domain);

         PRn = (struct PickTop *) (malloc(SzPT));
         if(PRn == NULL)
            {
            printf("used all emmory\n");
            exit(-1);
            }
         
         sl = strlen(domain);
         if(sl > 38)
            {
            printf("predefined array space (40) too small for coded domain name %s (length %d)\n",domain,sl);
            exit(-1);
            }
         strcpy(PRn->domain,domain);
         PRn->picks = NULL;
         PRn->next = NULL;
         if(PickRoot == NULL)
            PickRoot = PRn;
         else
            PRp->next = PRn;
         PRp = PRn;
         PRc = PRn;
         }
      pc = (struct NGApicklist *) (malloc(SzPL));
      if(pc == NULL)
         {
         printf("used all memory\n");
         exit(-1);
         }
      pc->next = NULL;
      sl = strlen(value);
      if(sl > 0)
         {
         pc->value = (char *) (malloc(sl + 2));
         if(pc->value == NULL)
            {
            printf("all allocation memory has been exhausted\n");
            exit(-1);
            }
         strcpy(pc->value,value);
         }
      else
         {
         pc->value = (char *) (malloc(2));
         if(pc->value == NULL)
            {
            printf("all allocation memory has been exhausted\n");
            exit(-1);
            }
         pc->value[0] = '\0';
         }


      sl = strlen(code);
      if(sl > 0)
         {
         pc->code = (char *) (malloc(sl + 2));
         if(pc->code == NULL)
            {
            printf("all allocation memory has been exhausted\n");
            exit(-1);
            }
         strcpy(pc->code,code);
         }
      else
         {
         pc->code = (char *) (malloc(2));
         if(pc->code == NULL)
            {
            printf("all allocation memory has been exhausted\n");
            exit(-1);
            }
         pc->code[0] = '\0';
         }
      
      if(PRc->picks == NULL)
         PRc->picks = pc;
      else
         pp->next = pc;
      pp = pc;

      fgets(linein,499,picklistfile);
      }
   fclose(picklistfile);
   return(1);
}


int NGAtypeToSentinal(char dt[])
{
int answer = 0;

   if(dt[0] == '\0')
      answer = 99;
   if(strcmp(dt,"String") == 0)
      answer = 1;
   else if(strcmp(dt,"Short Integer") == 0)
      answer = 2;
   else if(strcmp(dt,"Float") == 0)
      answer = 3;
   else if(strcmp(dt,"Long Integer") == 0)
      answer = 4;
   else if(strcmp(dt,"Integer") == 0)
      answer = 4;
   else if(strcmp(dt,"Date") == 0)
      answer = 5;
   else if(strcmp(dt,"Double") == 0)
      answer = 6;
   else if(strcmp(dt,"Blob") == 0)
      answer = 7;
   else if(strcmp(dt,"Boolean") == 0)
      answer = 8;


   return(answer);
}





int ParseNGAdataType(char dt[])
{
int answer = 99;
   if(dt[0] == '\0')
      answer = 99;
   if(strcmp(dt,"String") == 0)
      answer = 2;
   else if(strcmp(dt,"Short Integer") == 0)
      answer = 0;
   else if(strcmp(dt,"Float") == 0)
      answer = 1;
   else if(strcmp(dt, "Real") == 0)
      answer = 1;
   else if(strcmp(dt,"Long Integer") == 0)
      answer = 0;
   else if(strcmp(dt,"Integer") == 0)
      answer = 0;
   else if(strcmp(dt,"Date") == 0)
      answer = 6;
   else if(strcmp(dt,"Double") == 0)
      answer = 1;
   else if(strcmp(dt,"M_META") == 0)
      answer = 4;
   else if(strcmp(dt,"Blob") == 0)
      answer = 9;
   else if(strcmp(dt,"Boolean") == 0)
      answer = 10;
   else if(strcmp(dt,"Void") == 0)
      answer = 98;
   else if(strcmp(dt,"UserEnumeration") == 0)
      answer = 2;
   else if(strcmp(dt,"N/A") == 0)
      answer = 98;
  
   return(answer);
}


char * NGAdataTypeToString(int dt)
{
   switch(dt)
      {
      case 0: return("Integer");
      case 1: return("Floating Point");
      case 2: return("String");
      case 3: return("Short Integer");
      case 4: return("M_META");
      case 6: return("Date");
      case 9: return("Blob");
      }
   return("Unknown");
}


int GetGIFD_class_code_index(char *code)
{
int i;

   i = GetCodeIndex(code);
   if(i < 0)
      {
      i = GetNum(code);
      if(i < 0)
         exit(-1);
      }
   return(i);
}



int GetGIFD_attr_code_index(char *code)
{
int i;

   i = GetAttrIndex(code);
   if(i < 0)
      exit(-1);
   return(i);
}



int OnLongAttrList(char *EAC)
{

int answer = 0;
   if(IsHgt(EAC) > 0)
      answer = 1;
   else if(IsZv2(EAC) > 0)
      answer = 1;
   else if(IsArea(EAC) > 0)
      answer = 1;
   else if(IsNam(EAC) > 0)
      answer = 1;
   else if(IsLen(EAC) > 0)
      answer = 1;
   else if(IsGFID(EAC) > 0)
      answer = 1;

   return(answer);
}





char * ParseUserSchema(char *combofile, char * domainfile)
{
static char parse_result[2000];
char next_msg[2000];
FILE *schema_in;
FILE *domain_in;
char lastlinein[4000];
char linein[4000];
char dom_linein[2000];
int i,j,k,jj,kk, ii,lines_read, sendreport;
int num_digits, num_decimal, attr_index, num_char,e_start, e_end;
long int seekp;
char fname[200];
char aname[200];
char fcode[100];
char acode[100];
char minv[100];
char maxv[100];
char dname[200];
char slength[200];
char geom[100];
char opt_req[100];
char dt[200];
char endchar;
struct DomainSeek
   {
   char *dname;
   long int seekposn;
   struct DomainSeek * next;
   } *DSroot, *DSc, *DSp;
int SzDS = sizeof(struct DomainSeek);

extern void periodic_attr_redraw();


   periodic_attr_redraw();
   schema_in = fopen(combofile,"rt");
   if(schema_in == NULL)
      {
      sprintf(parse_result,"Unable to open file: %s\n",combofile);
      return(parse_result);
      }

   domain_in = fopen(domainfile,"rt");
   if(domain_in == NULL)
      {
      sprintf(parse_result,"Unable to open file: %s\n",domainfile);
      return(parse_result);
      }
   DSroot = NULL;
   dname[0] = '\0';
   fgets(dom_linein,1999,domain_in);
   seekp = ftell(domain_in);
   while(feof(domain_in) == 0)
      {
      j = 0;
      while(dom_linein[j] != ',')
         {
         if(dom_linein[j] < ' ')
            break;
         ++j;
         }
      if(dom_linein[j] == ',')
         {
         dom_linein[j] = '\0';
         if(strcmp(dname,dom_linein) != 0)
            {
            DSc = (struct DomainSeek *) (malloc(SzDS));
            DSc->dname = (char *) (malloc(strlen(dom_linein) + 2));
            strcpy(DSc->dname,dom_linein);
            DSc->seekposn = seekp;
            DSc->next = NULL;
            if(DSroot == NULL)
               DSroot = DSc;
            else
               DSp->next = DSc;
            DSp = DSc;
            }
         }
      seekp = ftell(domain_in);
      fgets(dom_linein,1999,domain_in);
      }

   fgets(linein,3999,schema_in);
   lines_read = 1;
   parse_result[0] = '\0';
   lastlinein[0] = '\0';
   while(feof(schema_in) == 0)
      {
  
      periodic_attr_redraw();
      i = j = 0;
      while(linein[i] >= ' ')
         {
         if(lines_read > 2)
            {
            if(strcmp(lastlinein,linein) > 0)
               {
               sendreport = 1;
               kk = 0;
               while(linein[kk] != ',')
                  ++kk;
               jj = 0;
               while(lastlinein[jj] != ',')
                  ++jj;
               if(jj < kk)  /**** is could be that last line is jj a substring, so strcmp gets confused ... ****/
                  {
                  if(strncmp(lastlinein,linein,jj-1) == 0)
                     {
                     sendreport = 0;
                     }
                  }
               if(sendreport > 0) /*** just check the first 3 fields: name, fcode, geometry ***/
                  {
                  ++jj;
                  while(lastlinein[jj] != ',')
                     ++jj;
                  ++jj;
                  while(lastlinein[jj] != ',')
                     ++jj;
                  ++kk;
                  while(linein[kk] != ',')
                     ++kk;
                  ++kk;
                  while(linein[kk] != ',')
                     ++kk;
                  if((kk == jj) && (strncmp(lastlinein,linein,kk-1) == 0))
                     {
                     sendreport = 0;
                     }
                  }
               if(sendreport > 0)
                   {
           strcpy(parse_result,"All entries in the attribute inspection specification file should appear in alphabetical order\n");
                  sprintf(next_msg," - line number %d is lexicographically less than the preceeding line\n",lines_read);
                  strcat(parse_result,next_msg);
                  sprintf(next_msg,"problem found in file %s\n",combofile);
                  strcat(parse_result,next_msg);
                  DSc = DSroot;
                  while(DSc != NULL)
                     {
                     DSp = DSc;
                     DSc = DSc->next;
                     free(DSp->dname);
                     free(DSp);
                     }
                  DSroot = NULL;
      
                  return(parse_result);
                  }
               }
            }
         strcpy(lastlinein,linein);
         if(linein[i] == '"')
            {
            ++i;
            while((linein[i] != '"') && (linein[i] >= ' '))
               ++i;
            if(linein[i] != '"')
               {
               strcpy(parse_result,"Double quotes can be used to enclose single fields that contain the ',' character\n");
               sprintf(next_msg," - line number %d does not appear to have a pair of '\"' characters\n",lines_read);
               strcat(parse_result,next_msg);
               sprintf(next_msg,"problem found in file %s\n",combofile);
               strcat(parse_result,next_msg);
               if(lines_read > 1)
                  {
                  DSc = DSroot;
                  while(DSc != NULL)
                     {
                     DSp = DSc;
                     DSc = DSc->next;
                     free(DSp->dname);
                     free(DSp);
                     }
                  DSroot = NULL;

                  return(parse_result);
                  }
               }
            ++i;
            }
         if(linein[i] == ',')
            ++j;
         ++i;
         }
      if(j < 10)
         {
         strcpy(parse_result,"Each line should include 11 comma-separated fields \n");
         sprintf(next_msg," - line number %d has only %d such fields\n",lines_read,j+1);
         strcat(parse_result,next_msg);
         sprintf(next_msg,"problem found in file %s\n",combofile);
         strcat(parse_result,next_msg);
         if(lines_read > 1)
            {
            DSc = DSroot;
            while(DSc != NULL)
               {
               DSp = DSc;
               DSc = DSc->next;
               free(DSp->dname);
               free(DSp);
               }
            DSroot = NULL;
            return(parse_result);
            }
         }
      if(j > 10)
         {
         strcpy(parse_result,"Each line should include 11 comma-separated fields \n");
         sprintf(next_msg," - line number %d has additional (%d total fields) fields\n",lines_read,j+1);
         strcat(parse_result,next_msg);
         sprintf(next_msg,"problem found in file %s\n",combofile);
         strcat(parse_result,next_msg);
         if(lines_read > 1)
            {
            DSc = DSroot;
            while(DSc != NULL)
               {
               DSp = DSc;
               DSc = DSc->next;
               free(DSp->dname);
               free(DSp);
               }
            DSroot = NULL;
            return(parse_result);
            }
         }

      i = num_char = 0;
      while(linein[i] >= ' ') /** ga all the way to the end of line ****/
         {
         if(linein[i] == '"')
            {
            endchar = '"';
            ++i;
            }
         else
            endchar = ',';

         num_char = 0;
         while(linein[i] != endchar)
            {
            if(linein[i] < ' ')
               break;
            if(linein[i] > ' ')
               ++num_char;
            ++i;
            }
         if(num_char == 0)
            {
            strcpy(parse_result,"No field on any line can be null or include only blank characters\n");
            sprintf(next_msg," - line number %d includes a field with only blank or a null specification\n",lines_read);
            strcat(parse_result,next_msg);
            sprintf(next_msg,"problem found in file %s\n",combofile);
            strcat(parse_result,next_msg);
            if(lines_read > 1)
               {
               DSc = DSroot;
               while(DSc != NULL)
                  {
                  DSp = DSc;
                  DSc = DSc->next;
                  free(DSp->dname);
                  free(DSp);
                  }
               DSroot = NULL;
               return(parse_result);
               }
            }
         if(linein[i] < ' ')
            break;
         if(endchar == '"')
            i += 2;
         else
            ++i;
         }


      i = j = 0;
      if(linein[i] == '"')
         {
         endchar = '"';
         ++i;
         }
      else
         endchar = ',';

      while(linein[i] != endchar)
         {
         fname[j] = linein[i];
         ++j;
         ++i;
         fname[j] = '\0';
         }

      if((strcmp(fname,MDstring1) != 0) && (strcmp(fname,MDstring2) != 0))
         {
         for(k=0; k<GIFD_CLASS_NUM; k++)
            {
            if(strcmp(fname,gifd_class_names[k]) == 0)
               break;
            }
         if(k >= GIFD_CLASS_NUM)
            {
            sprintf(parse_result,"Feature %s is not included in the specified schema\n",fname);
            sprintf(next_msg," reference to %s was encountered on line %d\n",fname,lines_read);
            strcat(parse_result,next_msg);
            sprintf(next_msg,"problem found in file %s\n",combofile);
            strcat(parse_result,next_msg);
            if(lines_read > 1)
               {
               DSc = DSroot;
               while(DSc != NULL)
                  {
                  DSp = DSc;
                  DSc = DSc->next;
                  free(DSp->dname);
                  free(DSp);
                  }
               DSroot = NULL;
               return(parse_result);
               }
            }
         }

      if(endchar == '"')
         i += 2;
      else
         ++i;


      j = 0;
      if(linein[i] == '"')
         {
         endchar = '"';
         ++i;
         }
      else
         endchar = ',';

      while(linein[i] != endchar)
         {
         fcode[j] = linein[i];
         ++j;
         ++i;
         fcode[j] = '\0';
         }

      if((strcmp(fcode,MDstring1) != 0) && (strcmp(fcode,MDstring2) != 0))
         {
         for(k=0; k<GIFD_CLASS_NUM; k++)
            {
            if(strcmp(fcode,gifd_class_codes[k]) == 0)
               break;
            }
         if(k >= GIFD_CLASS_NUM)
            {
            sprintf(parse_result,"Feature code %s is not included in the specified schema\n",fcode);
            sprintf(next_msg," reference to %s was encountered on line %d\n",fcode,lines_read);
            strcat(parse_result,next_msg);
            sprintf(next_msg,"problem found in file %s\n",combofile);
            strcat(parse_result,next_msg);
            if(lines_read > 1)
               {
               DSc = DSroot;
               while(DSc != NULL)
                  {
                  DSp = DSc;
                  DSc = DSc->next;
                  free(DSp->dname);
                  free(DSp);
                  }
               DSroot = NULL;
               return(parse_result);
               }
            }
         }

      if(endchar == '"')
         i += 2;
      else
         ++i;

      j = 0;
      if(linein[i] == '"')
         {
         endchar = '"';
         ++i;
         }
      else
         endchar = ',';

      while(linein[i] != endchar)
         {
         geom[j] = linein[i];
         ++j;
         ++i;
         geom[j] = '\0';
         }

      if(strcmp(geom,"N/A") != 0)
         {
         if(geom[1] != '\0')
            {
            sprintf(parse_result,"Only 'N/A', 'P', 'C', 'L', 'S', or 'A' are recognized geometry specifications\n");
            sprintf(next_msg," reference to geometry %s was encountered on line %d\n",geom,lines_read);
            strcat(parse_result,next_msg);
            sprintf(next_msg,"problem found in file %s\n",combofile);
            strcat(parse_result,next_msg);
            if(lines_read > 1)
               {
               DSc = DSroot;
               while(DSc != NULL)
                  {
                  DSp = DSc;
                  DSc = DSc->next;
                  free(DSp->dname);
                  free(DSp);
                  }
               DSroot = NULL;
               return(parse_result);
               }
            }
         if(ATTRTYPE_VMAP() > 0) /** VMAP ***/
            {
            if((geom[0] != 'T') && (geom[0] != 'N') && (geom[0] != 'P') && (geom[0] != 'C') && (geom[0] != 'L') && (geom[0] != 'S') && (geom[0] != 'A'))
               {
               sprintf(parse_result,"Only 'N/A', 'P', 'C', 'L', 'S', or 'A' are recognized geometry specifications\n");
               sprintf(next_msg," reference to geometry %s was encountered on line %d\n",geom,lines_read);
               strcat(parse_result,next_msg);
               sprintf(next_msg,"problem found in file %s\n",combofile);
               strcat(parse_result,next_msg);
               if(lines_read > 1)
                  {
                  DSc = DSroot;
                  while(DSc != NULL)
                     {
                     DSp = DSc;
                     DSc = DSc->next;
                     free(DSp->dname);
                     free(DSp);
                     }
                  DSroot = NULL;
                  return(parse_result);
                  }
               }
            }
         else
            {
            if((geom[0] != 'N') && (geom[0] != 'P') && (geom[0] != 'C') && (geom[0] != 'L') && (geom[0] != 'S') && (geom[0] != 'A'))
               {
               sprintf(parse_result,"Only 'N/A', 'P', 'C', 'L', 'S', or 'A' are recognized geometry specifications\n");
               sprintf(next_msg," reference to geometry %s was encountered on line %d\n",geom,lines_read);
               strcat(parse_result,next_msg);
               sprintf(next_msg,"problem found in file %s\n",combofile);
               strcat(parse_result,next_msg);
               if(lines_read > 1)
                  {
                  DSc = DSroot;
                  while(DSc != NULL)
                     {
                     DSp = DSc;
                     DSc = DSc->next;
                     free(DSp->dname);
                     free(DSp);
                     }
                  DSroot = NULL;
                  return(parse_result);
                  }
               }
            }
         }

      if(endchar == '"')
         i += 2;
      else
         ++i;


      j = 0;
      if(linein[i] == '"')
         {
         endchar = '"';
         ++i;
         }
      else
         endchar = ',';

      while(linein[i] != endchar)
         {
         acode[j] = linein[i];
         ++j;
         ++i;
         acode[j] = '\0';
         }

      if((strcmp(acode,"None") == 0) && (strstr(linein,"No Items except F_CODE") != NULL))
         {
         fgets(linein,3999,schema_in);
/**printf("%s",linein);**/
         ++lines_read;
         continue;
         }

      for(k=0; k<GIFD_ATTR_NUM; k++)
         {
         if(strcmp(acode,gifd_attr_codes[k]) == 0)
            break;
         }
      if(k >= GIFD_ATTR_NUM )
         {
         sprintf(parse_result,"Attribute code %s is not included in the specified schema\n",acode);
         sprintf(next_msg," reference to %s was encountered on line %d\n",acode,lines_read);
         strcat(parse_result,next_msg);
         sprintf(next_msg,"problem found in file %s\n",combofile);
         strcat(parse_result,next_msg);
         if(lines_read > 1)
            {
            DSc = DSroot;
            while(DSc != NULL)
               {
               DSp = DSc;
               DSc = DSc->next;
               free(DSp->dname);
               free(DSp);
               }
            DSroot = NULL;
            return(parse_result);
            }
         }


      if(endchar == '"')
         i += 2;
      else
         ++i;


      j = 0;
      if(linein[i] == '"')
         {
         endchar = '"';
         ++i;
         }
      else
         endchar = ',';

      while(linein[i] != endchar)
         {
         aname[j] = linein[i];
         ++j;
         ++i;
         aname[j] = '\0';
         }


      for(k=0; k<GIFD_ATTR_NUM; k++)
         {
         if(strcmp(aname,gifd_attr_names[k]) == 0)
            break;
         }
      if((k >= GIFD_ATTR_NUM) && (ATTRTYPE_UFD1() > 0)) /** UFD1 ***/
         {
         strcpy(next_msg,aname);
         strcat(next_msg,".");
         for(k=0; k<GIFD_ATTR_NUM; k++)
            {
            if(strcmp(next_msg,gifd_attr_names[k]) == 0)
               break;
            }
         }
      if(k >= GIFD_ATTR_NUM )
         {
         sprintf(parse_result,"Attribute %s is not included in the specified schema\n",aname);
         sprintf(next_msg," reference to %s was encountered on line %d\n",aname,lines_read);
         strcat(parse_result,next_msg);
         sprintf(next_msg,"problem found in file %s\n",combofile);
         strcat(parse_result,next_msg);
         if(lines_read > 1)
            {
            DSc = DSroot;
            while(DSc != NULL)
               {
               DSp = DSc;
               DSc = DSc->next;
               free(DSp->dname);
               free(DSp);
               }
            DSroot = NULL;
            return(parse_result);
            }
         }

      if(endchar == '"')
         i += 2;
      else
         ++i;

      j = 0;
      if(linein[i] == '"')
         {
         endchar = '"';
         ++i;
         }
      else
         endchar = ',';

      while(linein[i] != endchar)
         {
         opt_req[j] = linein[i];
         ++j;
         ++i;
         opt_req[j] = '\0';
         }

      if(opt_req[1] != '\0')
         {
         strcpy(parse_result,"Only 'O' or 'R' are recognized optional - required specifications\n");
         sprintf(next_msg," reference to specification %s was encountered on line %d\n",opt_req,lines_read);
         strcat(parse_result,next_msg);
         sprintf(next_msg,"problem found in file %s\n",combofile);
         strcat(parse_result,next_msg);
         if(lines_read > 1)
            {
            DSc = DSroot;
            while(DSc != NULL)
               {
               DSp = DSc;
               DSc = DSc->next;
               free(DSp->dname);
               free(DSp);
               }
            DSroot = NULL;
            return(parse_result);
            }
         }
      if((ATTRTYPE_ANY_MGCP() > 0) || (ATTRTYPE_ANY_UFD() > 0) || (ATTRTYPE_ANY_TDS() > 0) || (ATTRTYPE_SAC() > 0))
         {
         if((opt_req[0] != 'M') && (opt_req[0] != 'R') && (opt_req[0] != 'O'))
            {
            strcpy(parse_result,"Only 'O' or 'R' are recognized optional - required specifications\n");
            sprintf(next_msg," reference to specification %s was encountered on line %d\n",opt_req,lines_read);
            strcat(parse_result,next_msg);
            sprintf(next_msg,"problem found in file %s\n",combofile);
            strcat(parse_result,next_msg);
            if(lines_read > 1)
               {
               DSc = DSroot;
               while(DSc != NULL)
                  {
                  DSp = DSc;
                  DSc = DSc->next;
                  free(DSp->dname);
                  free(DSp);
                  }
               DSroot = NULL;
               return(parse_result);
               }
            }
         }
      else
         {
         if((opt_req[0] != 'R') && (opt_req[0] != 'O'))
            {
            strcpy(parse_result,"Only 'O' or 'R' are recognized optional - required specifications\n");
            sprintf(next_msg," reference to specification %s was encountered on line %d\n",opt_req,lines_read);
            strcat(parse_result,next_msg);
            sprintf(next_msg,"problem found in file %s\n",combofile);
            strcat(parse_result,next_msg);
            if(lines_read > 1)
               {
               DSc = DSroot;
               while(DSc != NULL)
                  {
                  DSp = DSc;
                  DSc = DSc->next;
                  free(DSp->dname);
                  free(DSp);
                  }
               DSroot = NULL;
               return(parse_result);
               }
            }
         }

      if(endchar == '"')
         i += 2;
      else
         ++i;

      j = 0;
      if(linein[i] == '"')
         {
         endchar = '"';
         ++i;
         }
      else
         endchar = ',';

      while(linein[i] != endchar)
         {
         minv[j] = linein[i];
         ++j;
         ++i;
         minv[j] = '\0';
         }

      if(strcmp(minv,"N/A") != 0)
         {
         num_digits = num_decimal = 0;
         if(minv[0] == '-')
            {
            k = 1;
            }
         else
            k = 0;
         while(minv[k] >= ' ')
            {
            if((k> 0) && (num_decimal == 0) && (minv[k] == '.') && (minv[k-1] >= '0') && (minv[k-1] <= '9'))
               num_decimal += 1;
            else if(minv[k] == '.')
               {
               strcpy(parse_result,"Only a single decimal point may be used in a minimum value specification\n");
               sprintf(next_msg,"The decimal point must be preceded by at least one number (0 thru 9)\n");
               strcat(parse_result,next_msg);
               sprintf(next_msg,"An unexpected use of a decimal point was encountered on line %d\n",lines_read);
               strcat(parse_result,next_msg);
               sprintf(next_msg,"problem found in file %s\n",combofile);
               strcat(parse_result,next_msg);
               if(lines_read > 1)
                  {
                  DSc = DSroot;
                  while(DSc != NULL)
                     {
                     DSp = DSc;
                     DSc = DSc->next;
                     free(DSp->dname);
                     free(DSp);
                     }
                  DSroot = NULL;
                  return(parse_result);
                  }
               }
            else if(minv[k] == '-')
               {
               strcpy(parse_result,"Only a single negative sign (e.g., '-') may be used in a minimum value specification\n");
               sprintf(next_msg,"The negative sign must be the first character of the specification\n");
               strcat(parse_result,next_msg);
               sprintf(next_msg,"An unexpected use of a negative sign was encountered on line %d\n",lines_read);
               strcat(parse_result,next_msg);
               sprintf(next_msg,"problem found in file %s\n",combofile);
               strcat(parse_result,next_msg);
               if(lines_read > 1)
                  {
                  DSc = DSroot;
                  while(DSc != NULL)
                     {
                     DSp = DSc;
                     DSc = DSc->next;
                     free(DSp->dname);
                     free(DSp);
                     }
                  DSroot = NULL;
                  return(parse_result);
                  }
               }
            else if((minv[k] >= '0') && (minv[k] <= '9'))
               {
               num_digits += 1;
               }
            else
               {
               strcpy(parse_result,"Only a single negative sign, a single decimal point (e.g., '-' or '.')\n");
               strcat(parse_result,"a single greater than signe (e.g., '>')\n");
               strcat(parse_result,"or the digits '0' through '9' may be used in a minimum value specification\n");
               sprintf(next_msg,"An unexpected character was encountered on line %d\n",lines_read);
               strcat(parse_result,next_msg);
               sprintf(next_msg,"problem found in file %s\n",combofile);
               strcat(parse_result,next_msg);
               if(lines_read > 1)
                  {
                  DSc = DSroot;
                  while(DSc != NULL)
                     {
                     DSp = DSc;
                     DSc = DSc->next;
                     free(DSp->dname);
                     free(DSp);
                     }
                  DSroot = NULL;
                  return(parse_result);
                  }
               }
            ++k;
            }
         if(num_digits < 1)
            {
            strcpy(parse_result,"The sentinel 'N/A' may be used as a minimum value specification.  Otherwise,\n");
            sprintf(next_msg,"at least 1 of the digits '0' through '9' must be used in the specification.\n");
            strcat(parse_result,next_msg);
            sprintf(next_msg,"An unexpected minimum value specification was encountered on line %d\n",lines_read);
            strcat(parse_result,next_msg);
            sprintf(next_msg,"problem found in file %s\n",combofile);
            strcat(parse_result,next_msg);
            if(lines_read > 1)
               {
               DSc = DSroot;
               while(DSc != NULL)
                  {
                  DSp = DSc;
                  DSc = DSc->next;
                  free(DSp->dname);
                  free(DSp);
                  }
               DSroot = NULL;
               return(parse_result);
               }
            }
         }

      if(endchar == '"')
         i += 2;
      else
         ++i;


      j = 0;
      if(linein[i] == '"')
         {
         endchar = '"';
         ++i;
         }
      else
         endchar = ',';

      while(linein[i] != endchar)
         {
         maxv[j] = linein[i];
         ++j;
         ++i;
         maxv[j] = '\0';
         }

      if(strcmp(maxv,"N/A") != 0)
         {
         num_digits = num_decimal = 0;
         if(maxv[0] == '-')
            {
            k = 1;
            }
         else
            k = 0;
         while(maxv[k] >= ' ')
            {
            if((k> 0) && (num_decimal == 0) && (maxv[k] == '.') && (maxv[k-1] >= '0') && (maxv[k-1] <= '9'))
               num_decimal += 1;
            else if(maxv[k] == '.')
               {
               strcpy(parse_result,"Only a single decimal point may be used in a maximum value specification\n");
               sprintf(next_msg,"The decimal point must be preceded by at least one number (0 thru 9)\n");
               strcat(parse_result,next_msg);
               sprintf(next_msg,"An unexpected use of a decimal point was encountered on line %d\n",lines_read);
               strcat(parse_result,next_msg);
               sprintf(next_msg,"problem found in file %s\n",combofile);
               strcat(parse_result,next_msg);
               if(lines_read > 1)
                  {
                  DSc = DSroot;
                  while(DSc != NULL)
                     {
                     DSp = DSc;
                     DSc = DSc->next;
                     free(DSp->dname);
                     free(DSp);
                     }
                  DSroot = NULL;

                  return(parse_result);
                  }
               }
            else if(maxv[k] == '-')
               {
               strcpy(parse_result,"Only a single negative sign (e.g., '-') may be used in a maximum value specification\n");
               sprintf(next_msg,"The negative sign must be the first character of the specification\n");
               strcat(parse_result,next_msg);
               sprintf(next_msg,"An unexpected use of a negative sign was encountered on line %d\n",lines_read);
               strcat(parse_result,next_msg);
               sprintf(next_msg,"problem found in file %s\n",combofile);
               strcat(parse_result,next_msg);
               if(lines_read > 1)
                  {
                  DSc = DSroot;
                  while(DSc != NULL)
                     {
                     DSp = DSc;
                     DSc = DSc->next;
                     free(DSp->dname);
                     free(DSp);
                     }
                  DSroot = NULL;

                  return(parse_result);
                  }
               }
            else if((maxv[k] >= '0') && (maxv[k] <= '9'))
               {
               num_digits += 1;
               }
            else
               {
               strcpy(parse_result,"Only a single negative sign, a single decimal point (e.g., '-' or '.')\n");
               sprintf(next_msg,"or the digits '0' through '9' may be used in a maximum value specification\n");
               strcat(parse_result,next_msg);
               sprintf(next_msg,"An unexpected character was encountered on line %d\n",lines_read);
               strcat(parse_result,next_msg);
               sprintf(next_msg,"problem found in file %s\n",combofile);
               strcat(parse_result,next_msg);
               if(lines_read > 1)
                  {
                  DSc = DSroot;
                  while(DSc != NULL)
                     {
                     DSp = DSc;
                     DSc = DSc->next;
                     free(DSp->dname);
                     free(DSp);
                     }
                  DSroot = NULL;

                  return(parse_result);
                  }
               }
            ++k;
            }
         if(num_digits < 1)
            {
            strcpy(parse_result,"The sentinel 'N/A' may be used as a maximum value specification.  Otherwise,\n");
            sprintf(next_msg,"at least 1 of the digits '0' through '9' must be used in the specification.\n");
            strcat(parse_result,next_msg);
            sprintf(next_msg,"An unexpected maximum value specification was encountered on line %d\n",lines_read);
            strcat(parse_result,next_msg);
            sprintf(next_msg,"problem found in file %s\n",combofile);
            strcat(parse_result,next_msg);
            if(lines_read > 1)
               {
               DSc = DSroot;
               while(DSc != NULL)
                  {
                  DSp = DSc;
                  DSc = DSc->next;
                  free(DSp->dname);
                  free(DSp);
                  }
               DSroot = NULL;

               return(parse_result);
               }
            }
         }


      if(endchar == '"')
         i += 2;
      else
         ++i;


      j = 0;
      if(linein[i] == '"')
         {
         endchar = '"';
         ++i;
         }
      else
         endchar = ',';

      while(linein[i] != endchar)
         {
         dname[j] = linein[i];
         ++j;
         ++i;
         dname[j] = '\0';
         }

      if(strcmp(dname,"N/A") != 0)
         {
         DSc = DSroot;
         while(strcmp(DSc->dname,dname) != 0)
            {
            DSc = DSc->next;
            if(DSc == NULL)
               break;
            }
         if((DSc != NULL) && (strcmp(DSc->dname,dname) == 0))
            fseek(domain_in,DSc->seekposn,SEEK_SET);
         else
            rewind(domain_in);
         fgets(dom_linein,1999,domain_in);
         while(feof(domain_in) == 0)
            {

            j = 0;
            while(dom_linein[j] != ',')
               {
               if(dom_linein[j] < ' ')
                  break;
               ++j;
               }
            if(dom_linein[j] == ',')
               {
               dom_linein[j] = '\0';
               if(strcmp(dname,dom_linein) == 0)
                  {
                  break;
                  }
               }
            fgets(dom_linein,1999,domain_in);
            }
         if(feof(domain_in) != 0)
            {
            sprintf(parse_result,"Unable to find value domain label %s in file %s\n",dname,domainfile);
            sprintf(next_msg,"Reference to this value domain used on line %d\n",lines_read);
            strcat(parse_result,next_msg);
            sprintf(next_msg,"problem found in file %s\n",combofile);
            strcat(parse_result,next_msg);
            if(lines_read > 1)
               {
               DSc = DSroot;
               while(DSc != NULL)
                  {
                  DSp = DSc;
                  DSc = DSc->next;
                  free(DSp->dname);
                  free(DSp);
                  }
               DSroot = NULL;

               return(parse_result);
               }
            }
         }

      if(endchar == '"')
         i += 2;
      else
         ++i;



      j = 0;
      if(linein[i] == '"')
         {
         endchar = '"';
         ++i;
         }
      else
         endchar = ',';

      while(linein[i] != endchar)
         {
         dt[j] = linein[i];
         ++j;
         ++i;
         dt[j] = '\0';
         }
      k = 0;
      if(strcmp(dt,"Integer") == 0)
         k = 1;
      else if(strcmp(dt,"Short Integer") == 0)
         k = 1;
      else if(strcmp(dt,"String") == 0)
         k = 1;
      else if(strcmp(dt,"Real") == 0)
         k = 1;
      else if(strcmp(dt,"Float") == 0)
         k = 1;
      else if(strcmp(dt, "Long Integer") == 0)
         k = 1;
      else if(strcmp(dt, "Date") == 0)
         k = 1;
      else if((ATTRTYPE_FACC() > 0) && (strcmp(dt, "N/A") == 0))
         k = 1;

      if(k == 0)
         {
         sprintf(parse_result,"An unexpected datatype specification (%s) was encountered on line %d\n",dt,lines_read);
         sprintf(next_msg,"problem found in file %s\n",combofile);
         strcat(parse_result,next_msg);
         if(lines_read > 1)
            {
            DSc = DSroot;
            while(DSc != NULL)
               {
               DSp = DSc;
               DSc = DSc->next;
               free(DSp->dname);
               free(DSp);
               }
            DSroot = NULL;

            return(parse_result);
            }
         }

      if(endchar == '"')
         i += 2;
      else
         ++i;


      j = 0;
      if(linein[i] == '"')
         {
         endchar = '"';
         ++i;
         }
      else
         endchar = ',';

      num_digits = num_char = 0;
      while(linein[i] != endchar)
         {
         if(linein[i] < ' ')
            break;  /*** line should terminate with a \n  ***/
         ++num_char;
         if((linein[i] >= '0') && (linein[i] <= '9'))
            ++num_digits;
         slength[j] = linein[i];
         ++j;
         ++i;
         slength[j] = '\0';
         }
      if((lines_read > 1) && (strcmp(slength,"N/A") != 0))
         {
         if(num_digits != num_char)
            {
            strcpy(parse_result,"The maximum string length must either be 'N/A' or a decimal numer using only digits\n");
            sprintf(next_msg,"'0' through '9', inclusive.  Length specification '%s' conflicts with this requirement.\n",slength);
            strcat(parse_result,next_msg);
            sprintf(next_msg,"This string length specification was found on line %d\n",lines_read);
            strcat(parse_result,next_msg);
            sprintf(next_msg,"in the file %s\n",combofile);
            strcat(parse_result,next_msg);
            DSc = DSroot;
            while(DSc != NULL)
               {
               DSp = DSc;
               DSc = DSc->next;
               free(DSp->dname);
               free(DSp);
               }
            DSroot = NULL;

            return(parse_result);
            }
         }


      if((lines_read == 1) && (parse_result[0] == '0'))
         {
         strcpy(parse_result,"The first line of data is expected to be a header line free of feature specifications\n");
         sprintf(next_msg,"It appears that feature specifications have been made on the first line of file %s\n",combofile);
         strcat(parse_result,next_msg);
         strcat(parse_result,"Specifications on the first line will be ignored during GAIT attribute inspections\n");
         DSc = DSroot;
         while(DSc != NULL)
            {
            DSp = DSc;
            DSc = DSc->next;
            free(DSp->dname);
            free(DSp);
            }
         DSroot = NULL;

         return(parse_result);
         }

      fgets(linein,3999,schema_in);
      ++lines_read;
      }
   fclose(schema_in);

   DSc = DSroot;
   while(DSc != NULL)
      {
      DSp = DSc;
      DSc = DSc->next;
      free(DSp->dname);
      free(DSp);
      }
   DSroot = NULL;


   rewind(domain_in);
   fgets(dom_linein,1999,domain_in);
   lines_read = 1;
   parse_result[0] = '\0';
   while(feof(domain_in) == 0)
      {
      periodic_attr_redraw();
      i = 0;
      j = 0;
      if(dom_linein[i] == '"')
         {
         endchar = '"';
         ++i;
         }
      else
         endchar = ',';

      while(dom_linein[i] != endchar)
         {
         dname[j] = dom_linein[i];
         ++j;
         ++i;
         dname[j] = '\0';
         }
      if(endchar == '"')
         i += 2;
      else
         ++i;
      k = strlen(dname);
      while((k > 0) && (dname[k] < ' '))
         --k;
      ii = 0;
      while(k > 0)
         {
         if((dname[k] >= '0') && (dname[k] <= '9'))
            {
            ++ii;
            --k;
            }
         else
            break;
         }
      if(ii != 3)
         {
         strcpy(parse_result,"Codelist domain names should end with 3 digits, 001 through 999\n");
         sprintf(next_msg,"An alternate ending was found on line %d (%d digits found)\n",lines_read,ii);
         strcat(parse_result,next_msg);
         sprintf(next_msg,"problem found in file %s\n",domainfile);
         strcat(parse_result,next_msg);
         if(lines_read > 1)
            return(parse_result);
         }
      if(dom_linein[k] != '_')
         {
         strcpy(parse_result,"Codelist domain names should end with 3 digits, 001 through 999\n");
         sprintf(next_msg,"preceded by a '_' charater - a different ending was found on line %d\n",lines_read);
         strcat(parse_result,next_msg);
         sprintf(next_msg,"problem found in file %s\n",domainfile);
         strcat(parse_result,next_msg);
         if(lines_read > 1)
            return(parse_result);
         }
      dom_linein[k] = '\0';
      if((ATTRTYPE_UFD1() == 0) && (ATTRTYPE_VMAP() == 0)) /** VMAP  and UFD1 could be AD***/
         {
         if((dom_linein[0] != 'C') || (dom_linein[1] != 'D') || (dom_linein[2] != '_'))
            {
            strcpy(parse_result,"Codelist domain names should begin with the characters 'CD_' followed by an attribute code\n");
            sprintf(next_msg,"and the an ordinal designator: an error was found on line %d\n",lines_read);
            strcat(parse_result,next_msg);
            sprintf(next_msg,"problem found in file %s\n",domainfile);
            strcat(parse_result,next_msg);
            if(lines_read > 1)
               return(parse_result);
            }
         }
      strcpy(acode,&dom_linein[3]);
      for(k=0; k<GIFD_ATTR_NUM; k++)
         {
         if(strcmp(acode,gifd_attr_codes[k]) == 0)
            break;
         }
      if((k >= GIFD_ATTR_NUM) && (ATTRTYPE_D4() > 0)) /*** GIFD D4  ***/
         {
         strcpy(next_msg,"M_");
         strcat(next_msg,acode);
         for(k=0; k<GIFD_ATTR_NUM; k++)
            {
            if(strcmp(next_msg,gifd_attr_codes[k]) == 0)
               break;
            }
         }
      if((k >= GIFD_ATTR_NUM) && (ATTRTYPE_D4() > 0)) /*** GIFD D4  ***/
         {
         strcpy(next_msg,acode);
         strcat(next_msg,"_");
         for(k=0; k<GIFD_ATTR_NUM; k++)
            {
            if(strcmp(next_msg,gifd_attr_codes[k]) == 0)
               break;
            }
         }
      if(k >= GIFD_ATTR_NUM )
         {
         sprintf(parse_result,"Attribute code %s from domain name is not included in the specified schema\n",acode);
         sprintf(next_msg,"Domain name including attribute code %s was encountered on line %d\n",acode,lines_read);
         strcat(parse_result,next_msg);
         sprintf(next_msg,"problem found in file %s\n",domainfile);
         strcat(parse_result,next_msg);
         if(lines_read > 1)
            return(parse_result);
         }
      attr_index = k;  /*** will need this to deal with the enums ***/

      if((ATTRTYPE_FACC() > 0) && 
                ((strcmp(acode,"LAF") == 0) ||(strcmp(acode,"HLT") == 0)))
         attr_index = GIFD_ATTR_NUM + 10;

      
      j = 0;
      if(dom_linein[i] == '"')
         {
         endchar = '"';
         ++i;
         }
      else
         endchar = ',';

      while(dom_linein[i] != endchar)
         {
         dt[j] = dom_linein[i];
         ++j;
         ++i;
         dt[j] = '\0';
         }
      if(endchar == '"')
         i += 2;
      else
         ++i;
/*** no real error message on data type ***/


      j = 0;
      if(dom_linein[i] == '"')
         {
         endchar = '"';
         ++i;
         }
      else
         endchar = ',';

      while(dom_linein[i] != endchar)
         {
         fcode[j] = dom_linein[i];
         ++j;
         ++i;
         fcode[j] = '\0';
         }
      if(endchar == '"')
         i += 2;
      else
         ++i;

     k = 1;
     if(((ATTRTYPE_NFDD() > 0) || (ATTRTYPE_DFDD() > 0)) && 
                      (strcmp(fcode,"-999999") == 0))
        k = 0;
     if(k > 0)
        {
        if(attr_index < GIFD_ATTR_NUM)
           {
           e_start = gifd_attr_enum_start[attr_index];
           e_end = e_start + gifd_attr_enum_count[attr_index];
           if((e_start >= 0) && (e_end >= 0))
              {
              for(k = e_start; k<= e_end; k++)
                 {
                 if(strcmp(fcode,gifd_enum_codes[k]) == 0)
                    break;
                 }
              if(k > e_end)
                 {
                 sprintf(parse_result,"Enumerated code %s designated with attribute %s is not included in the specified schema\n",fcode,acode);
                 sprintf(next_msg,"This enumerated attribute value code was encountered on line %d\n",lines_read);
                 strcat(parse_result,next_msg);
                 sprintf(next_msg,"problem found in file %s\n",domainfile);
                 strcat(parse_result,next_msg);
                 if(lines_read > 1)
                    return(parse_result);
                 }
              }
           }
        }



      j = 0;
      if(dom_linein[i] == '"')
         {
         endchar = '"';
         ++i;
         }
      else
         endchar = ',';

      while(dom_linein[i] != endchar)
         {
         if((ATTRTYPE_FACC() > 0) && (dom_linein[i] == '\t'))
            ;
         else if(dom_linein[i] < ' ')
            break;  /*** should hit the newline to signal end ***/
         aname[j] = dom_linein[i];
         ++j;
         ++i;
         aname[j] = '\0';
         }
      if(endchar == '"')
         i += 2;
      else
         ++i;


     k = 1;
     if(((ATTRTYPE_NFDD() > 0) || (ATTRTYPE_DFDD() > 0)) &&
                      (strcmp(fcode,"-999999") == 0))
        k = 0;
     if(k > 0)
        {
        if(attr_index < GIFD_ATTR_NUM)
           {
           e_start = gifd_attr_enum_start[attr_index];
           e_end = e_start + gifd_attr_enum_count[attr_index];
           if((e_start >= 0) && (e_end >= 0))
              {
              for(k = e_start; k<= e_end; k++)
                 {
                 if(strcmp(aname,gifd_enum_names[k]) == 0)
                    break;
                 }
              if(k > e_end)
                 {
                 sprintf(parse_result,"Enumerated code label %s designated with attribute %s is not included in the specified schema\n",aname,acode);
                 sprintf(next_msg,"This enumerated attribute code label was encountered on line %d\n",lines_read);
                 strcat(parse_result,next_msg);
                 sprintf(next_msg,"problem found in file %s\n",domainfile);
                 strcat(parse_result,next_msg);
                 if(lines_read > 1)
                    return(parse_result);
                 }
              }
           }
        }


      if((lines_read == 1) && (parse_result[0] == '0'))
         {
         strcpy(parse_result,"The first line of data is expected to be a header line free of feature specifications\n");
         sprintf(next_msg,"It appears that feature specifications have been made on the first line of file %s\n",domainfile);
         strcat(parse_result,next_msg);
         strcat(parse_result,"Specifications on the first line will be ignored during GAIT attribute inspections\n");
         return(parse_result);
         }

      if(lines_read == 1)
         parse_result[0] = '\0';

      fgets(dom_linein,1999,domain_in);
      if(feof(domain_in) != 0)
         break;
      ++lines_read;
      }

   fclose(domain_in);

   return(parse_result);
}






int BIN_ReadNGAclass(char *fname, int IncludeDomains)
{
FILE * classfile;
int i,j,k,IsLongAttr,numchar;
/***int unusedint; ***/
char Fname[500];
char FCODE[100];
char geom[100];
char Acode[500];
char Aname[500];
char OptReq;
char MinVal[200];
char MaxVal[200];
char domainname[500];
char dt[100];
char stringlen[200];
int decimalplaces;
int divisor,numattr;
int classifications = 0;
int MinOpen, MaxOpen;
double minval, maxval;
int SzC = sizeof(struct NGAclass);
int SzA = sizeof(struct NGAattribute);
int classindex,attrindex;
int MaxValSpecified, MinValSpecified;
int negativeNumber,idt,sentinel,sl;


   ngaNoRecord = (struct NGAclass *) (malloc(SzC));
   ngaNoRecord->name = (char *) (malloc(200));
   for(j=0; j<200; j++)
      ngaNoRecord->name[j] = '\0';

   ngaNoRecord->attr = NULL;
   ngaNoRecord->geom = -1;
   ngaNoRecord->present = 'N';
   ngaNoRecord->next = NULL;
   ngaNoRecord->codeindex = -1;

   classfile = fopen(fname,"rb");
   numchar = '\0';
   if(classfile == NULL)
      {
      printf("could not open file %s during preparation for attribute analysis\n",fname);
      return(0);
      }

   fread(&numchar,1,1,classfile);
   numattr = (int) numchar;
   while(feof(classfile) == 0)
      {
      fread(&numchar,1,1,classfile);
      j = (int) numchar;
      fread(&Fname,j,1,classfile);
      Fname[j] = '\0';
      fread(&numchar,1,1,classfile);
      j = (int) numchar;
      fread(&FCODE,j,1,classfile);
      FCODE[j] = '\0';
      fread(&numchar,1,1,classfile);
      j = (int) numchar;
      fread(&geom,j,1,classfile);
      geom[j] = '\0';
      if((strcmp(FCODE,MDstring1) == 0) || (strcmp(FCODE,MDstring2) == 0))
         classindex = -999;
      else
         {
         classindex =  GetGIFD_class_code_index(FCODE);
         ++classifications;
         if(classindex < 1)
            {
            printf("2-failed to locate index code for classification %s\n",FCODE);
            exit(-1);
            }
         }

      ngan = (struct NGAclass *) (malloc(SzC));
      j = strlen(Fname);
      ngan->name = (char *) (malloc(j + 1));
      strcpy(ngan->name,Fname);
      if((geom[0] == 'N') && (geom[1] == '/') && (geom[2] == 'A'))
         ngan->geom = -1;
      else
         {
         switch(geom[0])
            {
            case 'P':
            case 'N':      /** this is for 'Node' ****/
               ngan->geom = 5;
               break;
            case 'A':
               ngan->geom = 1;
               break;
            case 'L':
               ngan->geom = 4;
               break;
            case 'G':
               ngan->geom = 9;
               break;
            case 'T':
               ngan->geom = -1;
               break;
            case 'M':   /** using this for geometry independent metatdata requirements **/
               ngan->geom = 0;
               break;
            default:
               printf("bad geometry specification in file %s\n",fname);
               printf("expected 'N/A', 'P', 'N', 'A', 'L', 'T', or 'G'\n");
               printf("encountered value %s\n",geom);
               exit(-1);
            }
         }
      ngan->present = 'N';
      ngan->next = NULL;
      ngan->codeindex = classindex;
      ngan->attr = NULL;
      if(((strstr(Fname,MDstring1) != NULL) || (strstr(Fname,MDstring2) != NULL)) && (TDSmeta == 0))
         {
         if(NGAmetaRoot == NULL)
            NGAmetaRoot = ngan;
         else
            ngap->next = ngan;
         }
      else
         {
         if(NGAclassRoot == NULL)
            NGAclassRoot = ngan;
         else
            ngap->next = ngan;
         }
      ngap = ngan;
      for(i=0; i<numattr; i++)
         {
         fread(&numchar,1,1,classfile);
         j = (int) numchar;
         fread(&Acode,j,1,classfile);
         Acode[j] = '\0';
         fread(&numchar,1,1,classfile);
         j = (int) numchar;
         fread(&Aname,j,1,classfile);
         Aname[j] = '\0';
         fread(&OptReq,1,1,classfile);
         fread(&numchar,1,1,classfile);
         j = (int) numchar;
         fread(&MinVal,j,1,classfile);
         MinVal[j] = '\0';
         minval = 0;
         MinOpen = 0;
         decimalplaces = negativeNumber = 0;
         divisor = 10;
         MinValSpecified = 0;
         for(k=0;k<j;k++)
            {
            if(MinVal[k] == '.')
               {
               decimalplaces = 1;
               }
            else if(MinVal[k] == '-')
               {
               negativeNumber = 1;
               }
            else if(MinVal[k] == '>')
               {
               MinOpen = 1;
               }
            else if((MinVal[k] >= '0') && (MinVal[k] <= '9'))
               {
               if(decimalplaces == 0)
                  {
                  minval = minval * 10 + (int) (MinVal[k] - 48);
                  ++MinValSpecified;
                  }
               else
                  {
                  minval += ((double) (MinVal[k] - 48))/ ((double) (divisor));
                  ++MinValSpecified;
                  divisor *= 10;
                  }
               }
            }
         if(negativeNumber > 0)
            minval = 0 - minval;
         fread(&numchar,1,1,classfile);
         j = (int) numchar;
         fread(&MaxVal,j,1,classfile);
         MaxVal[j] = '\0';
         maxval = 0;
         MaxOpen = 0;
         decimalplaces = negativeNumber = 0;
         divisor = 10;
         MaxValSpecified = 0;
         for(k=0;k<j;k++)
            {
            if(MaxVal[k] == '.')
               {
               decimalplaces = 1;
               }
            else if(MaxVal[k] == '-')
               {
               negativeNumber = 1;
               }
            else if(MaxVal[k] == '<')
               {
               MaxOpen = 1;
               }
            else if((MaxVal[k] >= '0') && (MaxVal[k] <= '9'))
               {
               if(decimalplaces == 0)
                  {
                  maxval = maxval * 10 + (int) (MaxVal[k] - 48);
                  ++MaxValSpecified;
                  }
               else
                  {
                  maxval += ((double) (MaxVal[k] - 48))/ ((double) (divisor));
                  ++MaxValSpecified;
                  divisor *= 10;
                  }
               }
            }

         if(negativeNumber > 0)
            maxval = 0 - maxval;
         fread(&numchar,1,1,classfile);
         j = (int) numchar;
         fread(&domainname,j,1,classfile);
         domainname[j] = '\0';
         fread(&numchar,1,1,classfile);
         j = (int) numchar;
         fread(&dt,j,1,classfile);
         dt[j] = '\0';
         sentinel =  NGAtypeToSentinal(dt);
         idt = ParseNGAdataType(dt);
         if(idt == 99)
            {
            idt = -1;
            printf("classification name %s\n",Fname);
            printf("attribute name: %s\n",Aname);
            printf("unrecognized data type %s\n",dt);
            exit(-1);
            }

         fread(&numchar,1,1,classfile);
         j = (int) numchar;
         fread(&stringlen,j,1,classfile);
         stringlen[j] = '\0';
         sl = 0;
         negativeNumber = 0;
         k = 0;
         while(stringlen[k] != '\0')
            {
            if(stringlen[k] == '-')
               negativeNumber = 1;
            else
               sl = sl * 10 + (int) (stringlen[k] - 48);
            ++k;
            if(stringlen[k] == '.')
               break;
            }
         if(negativeNumber > 0)
            sl = 0 - sl;

         if(strcmp(Acode,"None") == 0)
            {
            IsLongAttr = 0;
            attrindex = 0;
            }
         else
            {
            attrindex =  GetGIFD_attr_code_index(Acode);

            IsLongAttr = OnLongAttrList(Acode);

            if(attrindex < 1)
               {
               printf("3-failed to locate index code for attribute %s\n",Acode);
               exit(-1);
               }
            }

         if(attrindex > 0)
            {
            Ac = (struct NGAattribute *) (malloc(SzA));
            j = strlen(Aname);
            Ac->name = (char *) (malloc(j + 1));
            strcpy(Ac->name,Aname);


            Ac->strval = NULL;
            Ac->present = 'N';

            j = strlen(domainname);
            Ac->codeDomain = (char *) (malloc(j + 1));
            strcpy(Ac->codeDomain, domainname);

            Ac->codeindex = attrindex;
            if(idt == 2) /*** a string data type  ***/
               Ac->maxval = sl;
            else
               Ac->maxval = maxval;
            Ac->minval = minval;
            if(MinOpen > 0)
               Ac->MinOpen = 1;
            else
               Ac->MinOpen = 0;
            if(MaxOpen > 0)
               Ac->MaxOpen = 1;
            else
               Ac->MaxOpen = 0;
            Ac->MinValPresent = MinValSpecified;
            Ac->MaxValPresent = MaxValSpecified;
            Ac->datatype = idt;
            Ac->NGAdatatype = sentinel;
            Ac->maxstrlen = sl;
            Ac->OptReq = OptReq;
            Ac->IsLong = IsLongAttr;
            Ac->present = 'N';
            Ac->varchar = negativeNumber;
            Ac->picks = NULL;

            if(IncludeDomains > 0)
               {
               if((Ac->codeDomain[0] != 'N') || (Ac->codeDomain[1] != '/') || (Ac->codeDomain[2] != 'A'))
                  {
                  PRc = PickRoot;
                  while(PRc != NULL)
                     {
                     if(strcmp(PRc->domain,Ac->codeDomain) == 0)
                        {
                        Ac->picks = PRc->picks;
                        pp = Ac->picks;
                        while(pp != NULL)
                           {
                           pp = pp->next;
                           }
                        break;
                        }
                     PRc = PRc->next;
                     }
                  if(PRc == NULL)
                     {
                     printf("place 2 could not find pick list for %s\n",Ac->codeDomain);
                     exit(-1);
                     }
                  }
               }
            Ac->next = NULL;
            if(ngan->attr == NULL)
               ngan->attr = Ac;
            else
               Ap->next = Ac;

            Ap = Ac;

            }
         }

      numchar = '\0';
      fread(&numchar,1,1,classfile);
      numattr = (int) numchar;
      }

   fclose(classfile);

   return(1);
}







int ReadNGAclass(char *fname, int IncludeDomains)
{
FILE *classfile;
char linein[1000];
int i,j,k,IsLongAttr;
int classifications = 0;
int linesread;
char classname[500];
char lastname[500];
char attrname[500];
char domainName[500];
char attrsort[500];
char GEOM[50];
char LastGEOM[50];
char OptReq[50];
char dt[500];
int idt,sl,sentinal;
int decimalplaces;
int divisor;
int newclassification;
double minval, maxval;
int SzC = sizeof(struct NGAclass);
int SzA = sizeof(struct NGAattribute);
int inputlength;
int MinOpen,MaxOpen;
char FACC[500], FACC_A[500], LastFACC[500];
int classindex,attrindex;
int MaxValSpecified, MinValSpecified;
int negativeNumber;
   if(BIN_ATTR_TYPE == 1)
      {
      return(BIN_ReadNGAclass(fname, IncludeDomains));
      }

   ngaNoRecord = (struct NGAclass *) (malloc(SzC));
   ngaNoRecord->name = (char *) (malloc(200));
   for(j=0; j<200; j++)
      ngaNoRecord->name[j] = '\0';

   ngaNoRecord->attr = NULL;
   ngaNoRecord->geom = -1;
   ngaNoRecord->present = 'N';
   ngaNoRecord->next = NULL;
   ngaNoRecord->codeindex = -1;

   classfile = fopen(fname,"rt");
   if(classfile == NULL)
      {
      printf("could not open file %s during preparation for attribute analysis\n",fname);
      return(0);
      }

   fgets(linein,999,classfile); /** skip header line ***/
   fgets(linein, 999, classfile); /** should be real data ***/
   linesread = 2;
   newclassification = 1;
   strcpy(lastname,"zxzxzxzxzxzxzxzxzxzxzx");
   strcpy(LastGEOM,"zxzxzxzxzxzxzxzxzxzxzx");
   strcpy(LastFACC,"zxzxzxzxzxzxzxzxzxzxzx");
   while(feof(classfile) == 0)
      {
      i = 0;

      j = k = 0;
      inputlength = strlen(linein);
      if(inputlength < 1)
         {
         fgets(linein, 999, classfile);
         ++linesread;
         continue;
         }
      while(i < inputlength)
         {
         if(linein[i] == '"')
            {
            if(j == 0)
               j = 1;
            else
               j = 0;
            }
         else if((j == 1) && (linein[i] == ','))
            linein[i] = 26;
         else if(linein[i] == ',')
            ++k;

         ++i;
         }

      if(k < 10)
         {
         j=inputlength-1;
         while(linein[j] != ',')
            {
            --j;
            if(j < 0)
              break;
            }
         ++j;
         while(k < 9)
            {
            linein[j] = ',';
            ++k;
            ++j;
            }
         linein[j] = '\0';
         linein[j+1] = '\n';
         }


      i = 0;
      j = 0;
      while(linein[i] != ',')
         {
         classname[j] = linein[i];
         ++i;
         ++j;
         }
      classname[j] = '\0';
      ++i;

      j = 0;
      while(linein[i] != ',') /*** FACC class code ***/
         {
         FACC[j] = linein[i];
         ++i;
         ++j;
         }
      FACC[j] = '\0';

      if(strcmp(lastname,classname) == 0)
         {
         if(strcmp(LastFACC,FACC) != 0)
            {
            if((strcmp(FACC,MDstring1) == 0) || (strcmp(FACC,MDstring2) == 0))
               newclassification = 0;
            else
               {
               ++classifications;
               newclassification = 1;
               strcpy(LastFACC,FACC);
               }
            }
         else
            {
            newclassification = 0;
            }
         }
      else
         {
         ++classifications;
         newclassification = 1;
         strcpy(lastname,classname);
         strcpy(LastFACC,FACC);
         }


      if((strcmp(FACC,MDstring1) == 0) || (strcmp(FACC,MDstring2) == 0))
         classindex = -999;
      else
         {
         classindex =  GetGIFD_class_code_index(FACC);
         if(classindex < 1)
            {
            printf("2-failed to locate index code for classification %s\n",FACC);
            printf("in line %s",linein);
            exit(-1);
            }
         }

      ++i;
      j = 0;
      while(linein[i] != ',') /*** PAL geometry ***/
         {
         GEOM[j] = linein[i];
         ++i;
         ++j;
         }
      GEOM[j] = '\0';

      if(strcmp(LastGEOM,GEOM) != 0)
         {
         newclassification = 1;
         strcpy(LastGEOM,GEOM);
         }

      ++i;
      j = 0;
      while(linein[i] != ',') /** FACC attr code ***/
         {
         FACC_A[j] = linein[i];
         ++i;
         ++j;
         }
      FACC_A[j] = '\0';
      if(strcmp(FACC_A,"None") == 0)
         {
         IsLongAttr = 0;
         attrindex = 0;
         }
      else
         {
         attrindex =  GetGIFD_attr_code_index(FACC_A);

         IsLongAttr = OnLongAttrList(FACC_A);
         
         if(attrindex < 1) 
            {
            printf("3-failed to locate index code for attribute %s\n",FACC_A);
            printf("in line %s",linein);
            exit(-1);
            }
         }

      ++i;

      j = 0;
      while(linein[i] != ',')
         {
         attrname[j] = linein[i];
         ++i;
         ++j;
         }
      attrname[j] = '\0';
      ++i;

      j = 0;
      while(linein[i] != ',') /*** optional or required code ***/
         {
         OptReq[j] = linein[i];
         ++i;
         ++j;
         }
      OptReq[j] = '\0';


      ++i;
      minval = 0;
      MinValSpecified = 0;
      MinOpen = 0;
      decimalplaces = 0;
      divisor = 10;
      negativeNumber = 0;
      while(linein[i] != ',')
         {
         if(linein[i] == '.')
            {
            decimalplaces = 1;
            }
         else if(linein[i] == '-')
            negativeNumber = 1;
         else if(linein[i] == '>')
            MinOpen = 1;
         else if((linein[i] >= '0') && (linein[i] <= '9'))
            {
            if(decimalplaces == 0)
               {
               minval = minval * 10 + (int) (linein[i] - 48);
               ++MinValSpecified;
               }
            else
               {
               minval += ((double) (linein[i] - 48))/ ((double) (divisor));
               ++MinValSpecified;
               divisor *= 10;
               }
            }
         ++i;
         }
      if(negativeNumber > 0)
         minval = 0 - minval;
      ++i;

      maxval = 0;
      decimalplaces = 0;
      MaxValSpecified = 0;
      MaxOpen = 0;
      negativeNumber = 0;
      while(linein[i] != ',')
         {
         if(linein[i] == '.')
            {
            decimalplaces = 1;
            }
         else if(linein[i] == '-')
            negativeNumber = 1;
         else if(linein[i] == '<')
            MaxOpen = 1;
         else if((linein[i] >= '0') && (linein[i] <= '9'))
            {
            if(decimalplaces == 0)
               {
               maxval = maxval * 10 + (double) (linein[i] - 48);
               ++MaxValSpecified;
               }
            else
               {
               maxval += ((double) (linein[i] - 48))/ ((double) (divisor));
               ++MaxValSpecified;
               divisor *= 10;
               }
            }
         ++i;
         }
      if(negativeNumber > 0)
         maxval = 0 - maxval;

      ++i;
      j = 0;
      while(linein[i] != ',')  /*** coded domain association ***/
         {
         domainName[j] = linein[i];
         ++i;
         ++j;
         }
      domainName[j] = '\0';

      ++i;
      j = 0;
      while(linein[i] != ',') /** attr format = data type ***/
         {
         dt[j] = linein[i];
         ++i;
         ++j;
         }
      dt[j] = '\0';
      sentinal =  NGAtypeToSentinal(dt);
      idt = ParseNGAdataType(dt);
      if(idt == 99)
         {
idt = -1;
/****************/
         printf("classification name %s\n",classname);
         printf("attribute name: %s\n",attrname);
         printf("attribute sort name: %s\n",attrsort);
         printf("unrecognized data type %s\n",dt);
         printf("input file line # %d\n",linesread);
         printf("input string:\n%s",linein);
         exit(-1);
/****************/
         }

      ++i;
      sl = 0;
      negativeNumber = 0;
      while(linein[i] != '\n') 
         {
         if(linein[i] == '-')
            negativeNumber = 1;
         else
            sl = sl * 10 + (int) (linein[i] - 48);
         ++i;
         }
      if(negativeNumber > 0)
         sl = 0 - sl;

      ++i;





      if(newclassification > 0)
         {
         ngan = (struct NGAclass *) (malloc(SzC));
         j = strlen(classname);

         for(k=0; k<j; k++)
            {
            if(classname[k] == 26)
               classname[k] = ',';
            }

         ngan->name = (char *) (malloc(j + 1));
         strcpy(ngan->name,classname);
         ngan->attr = NULL;
         if((GEOM[0] == 'N') && (GEOM[1] == '/') && (GEOM[2] == 'A'))
            ngan->geom = -1;
         else
            {
            switch(GEOM[0])
               {
               case 'P':
               case 'N':      /** this is for 'Node' ****/
                  ngan->geom = 5;
                  break;
               case 'A':
                  ngan->geom = 1;
                  break;
               case 'L':
                  ngan->geom = 4;
                  break;
               case 'G':
                  ngan->geom = 9;
                  break;
               case 'T':
                  ngan->geom = -1;
                  break;
               case 'M':   /** using this for geometry independent metatdata requirements **/
                  ngan->geom = 0;
                  break;
               default:
                  printf("bad geometry specification in file %s\n",fname);
                  printf("expected 'N/A', 'P', 'N', 'A', 'L', 'T', or 'G'\n");
                  printf("encountered value %s\n",GEOM);
                  exit(-1);
               }
            }
         ngan->present = 'N';
         ngan->next = NULL;
         ngan->codeindex = classindex;
         if(((strstr(classname,MDstring1) != NULL) || (strstr(classname,MDstring2) != NULL)) && (TDSmeta == 0))
            {
            if(NGAmetaRoot == NULL)
               NGAmetaRoot = ngan;
            else
               ngap->next = ngan;
            }
         else
            {
            if(NGAclassRoot == NULL)
               NGAclassRoot = ngan;
            else
               ngap->next = ngan;
            }
         ngap = ngan;
         }
      if(attrindex > 0) /*** could be == 0 if have a feature with no attributes specified ('None' flag used as attr name ***/
         {
         Ac = (struct NGAattribute *) (malloc(SzA));
         j = strlen(attrname);

         for(k=0; k<j; k++)
            {
            if(attrname[k] == 26)
               attrname[k] = ',';
            }

         Ac->name = (char *) (malloc(j + 1));
         strcpy(Ac->name,attrname);

         Ac->strval = NULL;
         Ac->present = 'N';

         j = strlen(domainName);

         for(k=0; k<j; k++)
            {
            if(domainName[k] == 26)
               domainName[k] = ',';
            }

         Ac->codeDomain = (char *) (malloc(j + 1));
         strcpy(Ac->codeDomain, domainName);
   
         Ac->codeindex = attrindex;

         if(idt == 2) /*** a string data type  ***/
            Ac->maxval = sl;
         else
            Ac->maxval = maxval;
         Ac->minval = minval;
         if(MinOpen > 0)
            Ac->MinOpen = 1;
         else
            Ac->MinOpen = 0;
         if(MaxOpen > 0)
            Ac->MaxOpen = 1;
         else
            Ac->MaxOpen = 0;
         Ac->MinValPresent = MinValSpecified;
         Ac->MaxValPresent = MaxValSpecified;
         Ac->datatype = idt;
         Ac->NGAdatatype = sentinal;
         Ac->maxstrlen = sl;
         Ac->OptReq = OptReq[0];
         Ac->IsLong = IsLongAttr;
         Ac->present = 'N';
         Ac->varchar = negativeNumber;
         Ac->picks = NULL;
         if((Ac->codeDomain[0] != 'N') || (Ac->codeDomain[1] != '/') || (Ac->codeDomain[2] != 'A'))
            {
            PRc = PickRoot;
            while(PRc != NULL)
               {
               if(strcmp(PRc->domain,Ac->codeDomain) == 0)
                  {
                  Ac->picks = PRc->picks;
                  pp = Ac->picks;
                  while(pp != NULL)
                     {
                     pp = pp->next;
                     }
                  break;
                  }
               PRc = PRc->next;
               }
            if(PRc == NULL)
               {
               printf("place 2 could not find pick list for %s\n",Ac->codeDomain);
               exit(-1);
               }
            }
         else
            {
            Ac->picks = NULL;
            }
         Ac->next = NULL;
         if(ngan->attr == NULL)
            ngan->attr = Ac;
         else
            Ap->next = Ac;

         Ap = Ac;
         } /*** end had some valid attributes ***/


      fgets(linein, 999, classfile);
      ++linesread;
      }

   fclose(classfile);

   return(1);
}





int IsNUNANPOString(char *inputstring, int datatype, int varlengthstr, int stringlength)
{
int IsAnError = 1; 
int i;
char instr[1000];
   if(inputstring[0] != '"')
      strcpy(instr,inputstring);
   else
      {
      strcpy(instr,&inputstring[1]);
      i = strlen(instr);
      while(i >= 0)
         {
         if(instr[i] == '"')
            {
            instr[i] = '\0';
            break;
            }
         --i;
         }
      }
   if((datatype == 1) && (varlengthstr > 0)) /*** variable length char string ***/
      { 
      if(instr[0] == '\0')
         IsAnError = 0;
      else if (strcmp(instr,"UNK") == 0)
         IsAnError = 0;
      else if(strcmp(instr,"N_P") == 0)
         IsAnError = 0;
      else if(strcmp(instr,"N_A") == 0)
         IsAnError = 0;
      else if(strcmp(instr,"Other") == 0)
         IsAnError = 0;
      else
         IsAnError = 1;
      }
   else if((datatype == 1) && (stringlength == 1))
      {
      if(strcmp(instr,"-") == 0)
         IsAnError = 0;
      else if (strcmp(instr,"U") == 0)
         IsAnError = 0;
      else if(strcmp(instr,"X") == 0)
         IsAnError = 0;
      else if(strcmp(instr,"Z") == 0)
         IsAnError = 0;
      else if(strcmp(instr,"O") == 0)
         IsAnError = 0;
      else
         IsAnError = 1;
      }
   else if((datatype == 1) && (stringlength == 2))
      {
      if(strcmp(instr,"--") == 0)
         IsAnError = 0;
      else if (strcmp(instr,"UK") == 0)
         IsAnError = 0;
      else if(strcmp(instr,"NP") == 0)
         IsAnError = 0;
      else if(strcmp(instr,"NA") == 0)
         IsAnError = 0;
      else if(strcmp(instr,"Ot") == 0)
         IsAnError = 0;
      else
         IsAnError = 1;
      }
   else if((datatype == 1) && ((stringlength == 3) || (stringlength == 4)))
      {
      if(strcmp(instr,"N/A") == 0)
         IsAnError = 0;
      else if (strcmp(instr,"UNK") == 0)
         IsAnError = 0;
      else if(strcmp(instr,"N_P") == 0)
         IsAnError = 0;
      else if(strcmp(instr,"N_A") == 0)
         IsAnError = 0;
      else if(strcmp(instr,"Oth") == 0)
         IsAnError = 0;
      else
         IsAnError = 1;
      }
   else if((datatype == 1) && (stringlength >= 5))
      {
      if(strcmp(instr,"N/A") == 0)
         IsAnError = 0;
      else if (strcmp(instr,"UNK") == 0)
         IsAnError = 0;
      else if(strcmp(instr,"N_P") == 0)
         IsAnError = 0;
      else if(strcmp(instr,"N_A") == 0)
         IsAnError = 0;
      else if(strcmp(instr,"Other") == 0)
         IsAnError = 0;
      else
         IsAnError = 1;
      }

   return(IsAnError);
}



int ParseRSTRN_DECLASS_XMPT(char * strval)
{
int i,j,answer;
char temp[10];

   i = 0;
   answer = 0;
   while(strval[i] >= 32)  /*** 32 is a blank, so will break off on any char < blank, including end of string \0  ***/
      {
      j = 0;
      while((strval[i] >= 32) && (strval[i] != ','))
         {
         if(strval[i] == ' ')
            {
            answer = 1;
            break;
            }
         temp[j] = strval[i];
         ++i;
         ++j;
         temp[j] = '\0';
         }
      if(j > 4)
         {
         answer = 1;
         break;
         }
      if(j == 2)
         {
         if((temp[0] != 'X') || (temp[1] < '1') || (temp[1] > '8'))
            {
            answer = 1;
            break;
            }
         }
      else if(j == 4)
         {
         if((temp[0] != '2') || (temp[1] != '5') || (temp[2] != 'X') ||
              (temp[3] < '1') || (temp[3] > '9'))
            {
            answer = 1;
            break;
            }
         }
      else
         {
         answer = 1;
         break;
         }
         
      if(answer > 0)
         break;
      ++i;
      }
   return(answer);
}


void SetUp_SAC_MetadataIndexArray(int Indices[])
{
int i;
char codestr[100];


   if(NGAmetaRoot == NULL)
      return;
   for(i=0; i<Num_SAC_Meta; i++)
      Indices[i] = -1;

   ngameta = NGAmetaRoot;
   Ameta = ngameta->attr;
   while(Ameta != NULL)
      {
      strcpy(codestr,GetEACCode(Ameta->codeindex));
      if(codestr[0] == 'A')
         {
         if(strcmp(codestr,"ALA") == 0)
            Indices[0] = Ameta->codeindex;
         else if(strcmp(codestr,"ALO") == 0)
            Indices[1] = Ameta->codeindex;
         else if(strcmp(codestr,"AEH") == 0)
            Indices[2] = Ameta->codeindex;
         else if(strcmp(codestr,"AOH") == 0)
            Indices[3] = Ameta->codeindex;
         else
            {
            printf("unrecognized metadata code entry: %s\n",codestr);
            }
         }
      else if(codestr[0] == 'R')
         {
         if(strcmp(codestr,"REMARKS") == 0)
            Indices[4] = Ameta->codeindex;
         else if(strcmp(codestr,"REL") == 0)
            Indices[5] = Ameta->codeindex;
         else
            {
            printf("unrecognized metadata code entry: %s\n",codestr);
            }
         }
      else if(codestr[0] == 'C')
         {
         if(strcmp(codestr,"CLASS") == 0)
            Indices[6] = Ameta->codeindex;
         else
            {
            printf("unrecognized metadata code entry: %s\n",codestr);
            }
         }
      else if(codestr[0] == 'W')
         {
         if(strcmp(codestr,"WAC_INNR") == 0)
            Indices[7] = Ameta->codeindex;
         else
            {
            printf("unrecognized metadata code entry: %s\n",codestr);
            }
         }
      else if(codestr[0] == 'S')
         {
         if(strcmp(codestr,"STC") == 0)
            Indices[8] = Ameta->codeindex;
         else
            {
            printf("unrecognized metadata code entry: %s\n",codestr);
            }
         }
      else if(codestr[0] == 'U')
         {
         if(strcmp(codestr,"UUID_1") == 0)
            Indices[9] = Ameta->codeindex;
         else
            {
            printf("unrecognized metadata code entry: %s\n",codestr);
            }
         }

      else
         {
         printf("unrecognized metadata code entry: %s\n",codestr);
         }

      Ameta = Ameta->next;
      }


   for(i=0; i<Num_SAC_Meta; i++)
      {
      if(Indices[i] < 0)
         {
         printf("fatal error - missing SAC metadata spec for definition %d\n",i+1);
         exit(-1);
         }
      }

}







void SetUp_MGCP_4_MetadataIndexArray(int Indices[])
{
int i;
char codestr[100];


   if(NGAmetaRoot == NULL)
      return;
   for(i=0; i<Num_MGCP4_Meta; i++)
      Indices[i] = -1;

   ngameta = NGAmetaRoot;
   Ameta = ngameta->attr;
   while(Ameta != NULL)
      {
      strcpy(codestr,GetEACCode(Ameta->codeindex));
      if(codestr[0] == 'A')
         {
         if(strcmp(codestr,"ACC") == 0)
            Indices[0] = Ameta->codeindex;
         else
            {
            printf("unrecognized metadata code entry: %s\n",codestr);
            }
         }

      else if(codestr[0] == 'C')
         {
         if(strcmp(codestr,"CCN") == 0)
            Indices[1] = Ameta->codeindex;
         else
            {
            printf("unrecognized metadata code entry: %s\n",codestr);
            }
         }

      else if(codestr[0] == 'S')
         {
         if(strcmp(codestr,"SDV") == 0)
            Indices[2] = Ameta->codeindex;
         else if(strcmp(codestr,"SDP") == 0)
            Indices[3] = Ameta->codeindex;
         else if(strcmp(codestr,"SRT") == 0)
            Indices[4] = Ameta->codeindex;
         else
            {
            printf("unrecognized metadata code entry: %s\n",codestr);
            }
         }
      else if(codestr[0] == 'T')
         {
         if(strcmp(codestr,"TXT") == 0)
            Indices[5] = Ameta->codeindex;
         else
            {
            printf("unrecognized metadata code entry: %s\n",codestr);
            }
         }
      else if(codestr[0] == 'U')
         {
         if(strcmp(codestr,"UID") == 0)
            Indices[6] = Ameta->codeindex;
         else
            {
            printf("unrecognized metadata code entry: %s\n",codestr);
            }
         }

      else
         {
         printf("unrecognized metadata code entry: %s\n",codestr);
         }

      Ameta = Ameta->next;
      }


   for(i=0; i<Num_MGCP4_Meta; i++)
      {
      if(Indices[i] < 0)
         {
         printf("fatal error - missing MGCP V4 metadata spec for definition %d\n",i+1);
         exit(-1);
         }
      }

}


int IsCountryCode(char *codetocheck)
{
int i, answer, s;
   answer = 0;
   for(i=0; i<NumCountryCodes; i++)
      {
      s = strcmp(codetocheck,CountryCodes[i]);
      if(s == 0)
         {
         answer = 1;
         break;
         }
      else if(s < 0)
         break;
      }
   return(answer);
}


int Check_TDS_StrucText(int EAC, char * strvalue)
{
int answer = 1;  /*** return 1 for correct content or N/A to EAC passed in, 0 for applies to EAC and incorrect ****/
   if((EAC == TDS_URI_index) || (EAC == TDS_MDE_index) || (EAC == TDS_SAX_RS4_index) || (EAC == TDS_SAX_RS3_index) ||
       (EAC == TDS_RIDL_index) || (EAC == TDS_RIDH_index) || (EAC == TDS_SSE_index) || (EAC == TDS_IKO_index) ||
       (EAC == TDS_PSE_index) || (EAC == TDS_VOI_index) || (EAC == TDS_BEN_index))
      {
      if(strcmp(strvalue,"No Information") == 0)
         answer = 0;
      }
   if(ATTRTYPE_GGDM3() > 0)
      {
      if((EAC == GGDM_HSE_index) || (EAC == GGDM_SAX_RS6_index) || (EAC == GGDM_BRR_index) ||
       (EAC == GGDM_MLR_index) || (EAC == GGDM_FURL_index) ||
       (EAC == GGDM_ZI103_MVD_index) || (EAC == GGDM_PRVR_index) || (EAC == GGDM_SCVN_index) ||
       (EAC == GGDM_BC040_MLR_index) || (EAC == GGDM_BC040_COL_index) ||
       (EAC == GGDM_ZI039S_UFI_index) || (EAC == GGDM_ZI031S_URI_index) ||
       (EAC == GGDM_DIA_index) || (EAC == GGDM_CNCP_index) || (EAC == GGDM_FUFI_index))
         {
         if(strcmp(strvalue,"No Information") == 0)
            answer = 0;
         }
      }

   return(answer);
}

int Check_TDS_Specials(int EAC,char * strvalue)
{
int answer = 1;  /*** return 1 for correct content / format, 0 for incorrect ****/
char code[500];
char sar_code[500];
int i,j,k;
int foundgood;
char tstval[1000];

   if((EAC == TDS_SAX_RY2_index) || (EAC == TDS_ZSAX_RX0_index) || (EAC == TDS_SAX_RY1_index) ||
          (EAC == TDS_ZSAX_RX3_index) || (EAC == TDS_SAX_RX7_index) || (EAC == TDS_ZSAX_RX4_index) ||
              (EAC == TDS_SAX_RX6_index) ||
                 (EAC == TDS_SAX_RX1_index) || (EAC == TDS_SAX_RX2_index) || (EAC == TDS_SAX_RX5_index))
      {
      if(strvalue[0] == '"')
         {
         strcpy(tstval,&strvalue[1]);
         k = strlen(tstval);
         while((k >= 0) && (tstval[k] != '"'))
            --k;
         if(k > 0)
            tstval[k] = '\0';
         }
      else
         strcpy(tstval,strvalue);
      }
   else
      return(answer);

   if(strcmp(tstval,"noInformation") == 0)
      return(answer);

   if(EAC == TDS_SAX_RY2_index)
      {
      i = 0;
      foundgood = 0;
      while(tstval[i] >= ' ')
         {
         while(tstval[i] == ' ')
            ++i;

         j = 0;
         code[0] = '\0';
         while((j < 499) && (tstval[i] > ' '))
            {
            code[j] = tstval[i];
            ++i;
            ++j;
            code[j] = '\0';
            }
         k = 0;
         if(strcmp(code,"RD") == 0)
            k = 1;
         if((k == 0) && (strcmp(code,"RD-CNWDI") == 0))
            k = 1;
         if((k == 0) && (strcmp(code,"FRD") == 0))
            k = 1;
         if((k == 0) && (strcmp(code,"DCNI") == 0))
            k = 1;
         if((k == 0) && (strcmp(code,"UCNI") == 0))
            k = 1;
         if((k == 0) && (strcmp(code,"TFNI") == 0))
            k = 1;
         if((k == 0) && (strncmp(code,"RD-SG-",6) == 0))
            {
            if((code[8] == '\0') && (code[7] >= '0') && (code[7] <= '9') &&
               (code[6] >= '1') && (code[6] <= '9'))
               k = 1;
            else if((code[7] == '\0') && (code[6] >= '1') && (code[6] <= '9'))
               k = 1;
            }
         if((k == 0) && (strncmp(code,"FRD-SG-",7) == 0))
            {
            if((code[9] == '\0') && (code[8] >= '0') && (code[8] <= '9') &&
               (code[7] >= '1') && (code[7] <= '9'))
               k = 1;
            else if((code[8] == '\0') && (code[7] >= '1') && (code[7] <= '9'))
               k = 1;
            }
         if(k > 0)
            ++foundgood;
         if(k == 0)
            {
            answer = 0;
            break;
            }
         }
      }
   else if(EAC == TDS_SAX_RX6_index)
      {
      i = 0;
      while(tstval[i] >= ' ')
         {
         if(strncmp(&tstval[i],"SAR-",4) == 0)
            {
            i += 4;
            j = 0;
            while(tstval[i] > ' ')
               {
               sar_code[j] = tstval[i];
               ++i;
               ++j;
               sar_code[j] = '\0';
               }
            k = IsCountryCode(sar_code);
            if(tstval[i] == ' ')
               ++i;
            if(k == 0)
               {
               answer = 0;
               break;
               }
            }
         else if((i > 0) && (tstval[i] >= 'A') && (tstval[i] <= 'Z') &&
                   (tstval[i+1] >= 'A') && (tstval[i+1] <= 'Z') &&
                     (tstval[i+2] >= 'A') && (tstval[i+2] <= 'Z'))
            {
            sar_code[0] = tstval[i];
            ++i;
            sar_code[1] = tstval[i];
            ++i;
            sar_code[2] = tstval[i];
            ++i;
            if(tstval[i] == ' ')
               ++i;
            sar_code[3] = '\0';
            k = IsCountryCode(sar_code);
            if(k == 0)
               {
               answer = 0;
               break;
               }
            }
         else
            {
            answer = 0;
            break;
            }
         if(answer == 0)
            break;
         }
      }
   else if(EAC == TDS_SAX_RX7_index)
      {
      i = 0;
      foundgood = 0;
      while(tstval[i] >= ' ')
         {
         while(tstval[i] == ' ')
            ++i;

         j = 0;
         code[0] = '\0';
         while((j < 499) && (tstval[i] > ' '))
            {
            code[j] = tstval[i];
            ++i;
            ++j;
            code[j] = '\0';
            }
         k = 0;
         if(strcmp(code,"HCS") == 0)
            k = 1;
         if((k == 0) && (strcmp(code,"KDK") == 0))
            k = 1;
         if((k == 0) && (strcmp(code,"SI") == 0))
            k = 1;
         if((k == 0) && (strcmp(code,"SI-G") == 0))
            k = 1;
         if((k == 0) && (strcmp(code,"TK") == 0))
            k = 1;
         if((k == 0) && (strncmp(code,"SI-G-",5) == 0))
            k = 1;
         if((k == 0) && (strncmp(code,"SI-ECI-",7) == 0))
            k = 1;

         if(k > 0)
            ++foundgood;
         if(k == 0)
            {
            answer = 0;
            break;
            }
         }
      }



  else if(EAC == TDS_ZSAX_RX3_index)
      {
      i = 0;
      foundgood = 0;
      while(tstval[i] >= ' ')
         {
         while(tstval[i] == ' ')
            ++i;

         j = 0;
         code[0] = '\0';
         while((j < 499) && (tstval[i] > ' '))
            {
            code[j] = tstval[i];
            ++i;
            ++j;
            code[j] = '\0';
            }
         k = 0;
         if(strcmp(code,"DS") == 0)
            k = 1;
         if((k == 0) && (strcmp(code,"SC") == 0))
            k = 1;
         if((k == 0) && (strcmp(code,"SINFO") == 0))
            k = 1;
         if((k == 0) && (strcmp(code,"XD") == 0))
            k = 1;
         if((k == 0) && (strcmp(code,"ND") == 0))
            k = 1;
         if((k == 0) && (strcmp(code,"SBU") == 0))
            k = 1;
         if((k == 0) && (strcmp(code,"SBU-NF") == 0))
            k = 1;
         if((k == 0) && (strcmp(code,"LES") == 0))
            k = 1;
         if((k == 0) && (strcmp(code,"LES-NF") == 0))
            k = 1;
         if((k == 0) && (strcmp(code,"SSI") == 0))
            k = 1;
         if((k == 0) && (strncmp(code,"ACCM-",5) == 0))
            k = 1;
            
         if(k > 0)
            ++foundgood;
         if(k == 0)
            {
            answer = 0;
            break;
            }
         }
      }
   else if(EAC == TDS_ZSAX_RX0_index)
      {
      i = 0;
      foundgood = 0;
      while(tstval[i] >= ' ')
         {
         while(tstval[i] == ' ')
            ++i;

         j = 0;
         code[0] = '\0';
         while((j < 499) && (tstval[i] > ' '))
            {
            code[j] = tstval[i];
            ++i;
            ++j;
            code[j] = '\0';
            }
         k = 0;
         if(strcmp(code,"RS") == 0)
            k = 1;
         if((k == 0) && (strcmp(code,"FOUO") == 0))
            k = 1;
         if((k == 0) && (strcmp(code,"OC") == 0))
            k = 1;
         if((k == 0) && (strcmp(code,"IMC") == 0))
            k = 1;
         if((k == 0) && (strcmp(code,"NF") == 0))
            k = 1;
         if((k == 0) && (strcmp(code,"PR") == 0))
            k = 1;
         if((k == 0) && (strcmp(code,"REL") == 0))
            k = 1;
         if((k == 0) && (strcmp(code,"RELIDO") == 0))
            k = 1;
         if((k == 0) && (strcmp(code,"EYES") == 0))
            k = 1;
         if((k == 0) && (strcmp(code,"DSEN") == 0))
            k = 1;
         if((k == 0) && (strcmp(code,"FISA") == 0))
            k = 1;
         if((k == 0) && (strcmp(code,"DISPLAYONLY") == 0))
            k = 1;

         if(k > 0)
            ++foundgood;
         if(k == 0)
            {
            answer = 0;
            break;
            }
         }
      }

   else if(EAC == TDS_SAX_RY1_index)
      {
      i = 0;
      foundgood = 0;
      while(tstval[i] >= ' ')
         {
         while(tstval[i] == ' ')
            ++i;

         j = 0;
         code[0] = '\0';
         while((j < 499) && (tstval[i] > ' '))
            {
            code[j] = tstval[i];
            ++i;
            ++j;
            code[j] = '\0';
            }
         k = 0;
         if(strcmp(code,"ATOMAL") == 0)
            k = 1;
         if((k == 0) && (strcmp(code,"BOHEMIA") == 0))
            k = 1;
         if((k == 0) && (strcmp(code,"BALK") == 0))
            k = 1;

         if(k > 0)
            ++foundgood;
         if(k == 0)
            {
            answer = 0;
            break;
            }
         }
      }

   else if(EAC == TDS_ZSAX_RX4_index)
      {
      i = 0;
      foundgood = 0;
      while(tstval[i] >= ' ')
         {
         while(tstval[i] == ' ')
            ++i;

         j = 0;
         code[0] = '\0';
         while((j < 499) && (tstval[i] > ' '))
            {
            code[j] = tstval[i];
            ++i;
            ++j;
            code[j] = '\0';
            }
         k = 0;
         if(strcmp(code,"UNKNOWN") == 0)
            {
            answer = 0;
            foundgood = 0;
            break;
            }
         else
            k = IsCountryCode(code);

         if(k > 0)
            ++foundgood;
         if(k == 0)
            {
            answer = 0;
            break;
            }
         }
      }
   else if(EAC == TDS_SAX_RX1_index)
      {
      i = 0;
      foundgood = 0;
      while(tstval[i] >= ' ')
         {
         while(tstval[i] == ' ')
            ++i;

         j = 0;
         code[0] = '\0';
         while((j < 499) && (tstval[i] > ' '))
            {
            code[j] = tstval[i];
            ++i;
            ++j;
            code[j] = '\0';
            }
         k = 0;
         if((strcmp(code,"ANT") == 0) || (strcmp(code,"FGI") == 0) ||
               (strcmp(code,"MCFI") == 0) || (strcmp(code,"UNCK") == 0) ||
                   (strcmp(code,"USA") == 0))
            {
            answer = 0;
            foundgood = 0;
            break;
            }
         else
            k = IsCountryCode(code);

         if(k > 0)
            ++foundgood;
         if(k == 0)
            {
            answer = 0;
            break;
            }
         }
      }
   else if(EAC == TDS_SAX_RX2_index)
      {
      i = 0;
      foundgood = 0;
      while(tstval[i] >= ' ')
         {
         while(tstval[i] == ' ')
            ++i;

         j = 0;
         code[0] = '\0';
         while((j < 499) && (tstval[i] > ' '))
            {
            code[j] = tstval[i];
            ++i;
            ++j;
            code[j] = '\0';
            }
         k = 0;
         if((strcmp(code,"ANT") == 0) || 
               (strcmp(code,"MCFI") == 0) || (strcmp(code,"UNCK") == 0) ||
                   (strcmp(code,"UNKNOWN") == 0) ||
                   (strcmp(code,"USA") == 0))
            {
            answer = 0;
            foundgood = 0;
            break;
            }
         else
            k = IsCountryCode(code);

         if(k > 0)
            ++foundgood;
         if(k == 0)
            {
            answer = 0;
            break;
            }
         }
      }
   else if(EAC == TDS_SAX_RX5_index)
      {
      i = 0;
      foundgood = 0;
      while(tstval[i] >= ' ')
         {
         while(tstval[i] == ' ')
            ++i;

         j = 0;
         code[0] = '\0';
         while((j < 499) && (tstval[i] > ' '))
            {
            code[j] = tstval[i];
            ++i;
            ++j;
            code[j] = '\0';
            }
         k = 0;
         if((strcmp(code,"ANT") == 0) || (strcmp(code,"FGI") == 0) ||
               (strcmp(code,"MCFI") == 0) || (strcmp(code,"UNCK") == 0) ||
                   (strcmp(code,"UNKNOWN") == 0))
            {
            answer = 0;
            foundgood = 0;
            break;
            }
         else
            k = IsCountryCode(code);

         if(k > 0)
            ++foundgood;
         if(k == 0)
            {
            answer = 0;
            break;
            }
         }
      }

   else /*** not an applicable attribute ****/
      {
      answer = foundgood = 1;
      }


   if((answer == 1) && (foundgood == 0))
      answer = 0;
   return(answer);
}



                                                                                                                                                


void SetUp_MGCP_MetadataIndexArray(int Indices[])
{
int i;
char codestr[100];


   if(NGAmetaRoot == NULL)
      return;
   for(i=0; i<Num_MGCP_Meta; i++)
      Indices[i] = -1;

   ngameta = NGAmetaRoot;
   Ameta = ngameta->attr;
   while(Ameta != NULL)
      {
      strcpy(codestr,GetEACCode(Ameta->codeindex));
      if(codestr[0] == 'A')
         {
         if(strcmp(codestr,"ACC") == 0)
            Indices[0] = Ameta->codeindex;
         else if(strcmp(codestr,"ACE") == 0)
            Indices[1] = Ameta->codeindex;
         else if(strcmp(codestr,"ACE_EVAL") == 0)
            Indices[2] = Ameta->codeindex;
         else if(strcmp(codestr,"ALE") == 0)
            Indices[3] = Ameta->codeindex;
         else if(strcmp(codestr,"ALE_EVAL") == 0)
            Indices[4] = Ameta->codeindex;
         else
            {
            printf("unrecognized metadata code entry: %s\n",codestr);
            }
         }

      else if(codestr[0] == 'C')
         {
         if(strcmp(codestr,"CPYRT_NOTE") == 0)
            Indices[5] = Ameta->codeindex;
         else
            {
            printf("unrecognized metadata code entry: %s\n",codestr);
            }
         }

      else if(codestr[0] == 'S')
         {
         if(strcmp(codestr,"SRC_DATE") == 0)
            Indices[6] = Ameta->codeindex;
         else if(strcmp(codestr,"SRC_INFO") == 0)
            Indices[7] = Ameta->codeindex;
         else if(strcmp(codestr,"SRC_NAME") == 0)
            Indices[8] = Ameta->codeindex;
         else
            {
            printf("unrecognized metadata code entry: %s\n",codestr);
            }
         }

      else if(codestr[0] == 'T')
         {
         if(strcmp(codestr,"TIER_NOTE") == 0)
            Indices[9] = Ameta->codeindex;
         else if(strcmp(codestr,"TXT") == 0)
            Indices[10] = Ameta->codeindex;
         else
            {
            printf("unrecognized metadata code entry: %s\n",codestr);
            }
         }

      else if(codestr[0] == 'U')
         {
         if(strcmp(codestr,"UID") == 0)
            Indices[11] = Ameta->codeindex;
         else if(strcmp(codestr,"UPD_DATE") == 0)
            Indices[12] = Ameta->codeindex;
         else if(strcmp(codestr,"UPD_INFO") == 0)
            Indices[13] = Ameta->codeindex;
         else if(strcmp(codestr,"UPD_NAME") == 0)
            Indices[14] = Ameta->codeindex;
         else
            {
            printf("unrecognized metadata code entry: %s\n",codestr);
            }
         }

      else if(codestr[0] == 'Z')
         {
         if(strcmp(codestr,"ZVAL_TYPE") == 0)
            Indices[15] = Ameta->codeindex;
         else
            {
            printf("unrecognized metadata code entry: %s\n",codestr);
            }
         }

      else
         {
         printf("unrecognized metadata code entry: %s\n",codestr);
         }

      Ameta = Ameta->next;
      }


   for(i=0; i<Num_MGCP_Meta; i++)
      {
      if(Indices[i] < 0)
         {
         printf("fatal error - missing MGCP metadata spec for definition %d\n",i+1);
         exit(-1);
         }
      }

}




void SetUp_D4_MetadataIndexArray(int Indices[])
{
int i;
char codestr[100];


   if(NGAmetaRoot == NULL)
      return;
   for(i=0; i<NumMeta; i++)
      Indices[i] = -1;

   ngameta = NGAmetaRoot;
   Ameta = ngameta->attr;
   if(Ameta == NULL)
      {
      NumMeta = 0;
      DoMetadataChecking = 0;
      }
   while(Ameta != NULL)
      {
      strcpy(codestr,GetEACCode(Ameta->codeindex));
      if(codestr[0] == 'A')
         {
         if(strcmp(codestr,"ACE") == 0)
            Indices[0] = Ameta->codeindex;
         else if(strcmp(codestr,"ACE_EVAL_METHOD_CD") == 0)
            Indices[1] = Ameta->codeindex;
         else if(strcmp(codestr,"ALE") == 0)
            Indices[2] = Ameta->codeindex;
         else if(strcmp(codestr,"ALE_EVAL_METHOD_CD") == 0)
            Indices[3] = Ameta->codeindex;
         else
            {
            printf("unrecognized metadata code entry: %s\n",codestr);
            }
         }

      else if(codestr[0] == 'C')
         {
         if(strcmp(codestr,"CREATION_DATE") == 0)
            Indices[4] = Ameta->codeindex;
         else if(strcmp(codestr,"COMMENTS") == 0)
            Indices[5] = Ameta->codeindex;
         else if(strcmp(codestr,"COMM_CPYRT_NOTICE") == 0)
            Indices[6] = Ameta->codeindex;
         else if(strcmp(codestr,"COMM_LIC_TIER_NOTICE") == 0)
            Indices[7] = Ameta->codeindex;
         else if(strcmp(codestr,"COMPLETENESS_CODE") == 0)
            Indices[8] = Ameta->codeindex;
         else
            {
            printf("unrecognized metadata code entry: %s\n",codestr);
            }
         }

      else if(codestr[0] == 'O')
         {
         if(strcmp(codestr,"OPERATOR") == 0)
            Indices[9] = Ameta->codeindex;
         else if(strcmp(codestr,"ORIG_SOURCE_DATE") == 0)
            Indices[10] = Ameta->codeindex;
         else if(strcmp(codestr,"ORIG_SOURCE_INFO") == 0)
            Indices[11] = Ameta->codeindex;
         else if(strcmp(codestr,"ORIGINATING_SOURCE") == 0)
            Indices[12] = Ameta->codeindex;
         else if(strcmp(codestr,"ORIGINATOR") == 0)
            Indices[13] = Ameta->codeindex;
         else
            {
            printf("unrecognized metadata code entry: %s\n",codestr);
            }
         }

      else if(codestr[0] == 'R')
         {
         if(strcmp(codestr,"RSTRN_DCLS_XMPT_CD") == 0)
            Indices[14] = Ameta->codeindex;
         else if(strcmp(codestr,"RSTRN_DECLASS") == 0)
            Indices[15] = Ameta->codeindex;
         else if(strcmp(codestr,"RSTRN_DSEM_CTRL_IC") == 0)
            Indices[16] = Ameta->codeindex;
         else if(strcmp(codestr,"RSTRN_DSEM_CTRL_NIC") == 0)
            Indices[17] = Ameta->codeindex;
         else if(strcmp(codestr,"RSTRN_FOREIGN_GOV") == 0)
            Indices[18] = Ameta->codeindex;
         else if(strcmp(codestr,"RSTRN_RELEASIBILITY") == 0)
            Indices[19] = Ameta->codeindex;
         else
            {
            printf("unrecognized metadata code entry: %s\n",codestr);
            }
         }

      else if(codestr[0] == 'S')
         {
         if(strcmp(codestr,"SCALE") == 0)
            Indices[20] = Ameta->codeindex;
         else if(strcmp(codestr,"SEC_CLS_AUTHORITY") == 0)
            Indices[21] = Ameta->codeindex;
         else if(strcmp(codestr,"SEC_CLS_AUTH_DESC") == 0)
            Indices[22] = Ameta->codeindex;
         else if(strcmp(codestr,"SEC_CLS_AUTH_MULT") == 0)
            Indices[23] = Ameta->codeindex;
         else if(strcmp(codestr,"SEC_CD_CNTRL") == 0)
            Indices[24] = Ameta->codeindex;
         else if(strcmp(codestr,"SEC_CLASS") == 0)
            Indices[25] = Ameta->codeindex;
         else if(strcmp(codestr,"SEC_CLASS_SYS_ID") == 0)
            Indices[26] = Ameta->codeindex;
         else if(strcmp(codestr,"SPEC_ID") == 0)
            Indices[27] = Ameta->codeindex;
         else
            {
            printf("unrecognized metadata code entry: %s\n",codestr);
            }
         }

      else if(codestr[0] == 'U')
         {
         if(strcmp(codestr,"UPDATE_SOURCE_DATE") == 0)
            Indices[28] = Ameta->codeindex;
         else if(strcmp(codestr,"UPDATE_SOURCE_INFO") == 0)
            Indices[29] = Ameta->codeindex;
         else if(strcmp(codestr,"UPDATE_SOURCE") == 0)
            Indices[30] = Ameta->codeindex;
         else
            {
            printf("unrecognized metadata code entry: %s\n",codestr);
            }
         }

      else if(codestr[0] == 'Z')
         {
         if(strcmp(codestr,"Z_VALUE_TYPE") == 0)
            Indices[31] = Ameta->codeindex;
         else
            {
            printf("unrecognized metadata code entry: %s\n",codestr);
            }
         }

      else
         {
         printf("unrecognized metadata code entry: %s\n",codestr);
         }

      Ameta = Ameta->next;
      }

   for(i=0; i<NumMeta; i++)
      {
      if(Indices[i] < 0)
         {
         printf("fatal error - missing D4 metadata spec for definition %d\n",i+1);
         exit(-1);
         }
      }

}





void  Inspect_SAC_Metadata(int ECC, int Indices[], int entrycount, char * Infname, int NumberAttr, int geomtery,  char * YearLimit)
{
char enumcodestring[500];
char messageline[500];
char ECClabel[100];
int WriteTheError;
int i;
   strcpy(ECClabel,GetECCLabel(ECC));

   for(i=0; i<Num_SAC_Meta; i++)
      {
      Ameta = NGAmetaRoot->attr;
      while(Ameta != NULL)
         {
         if(Ameta->codeindex == Indices[i])
            break;
         Ameta = Ameta->next;
         }

      if(Ameta == NULL)
         {
         printf("could not find metadata entry for spec %d\n",i+1);
         exit(-1);
         }

      if((Ameta->present == 'Y') && (Ameta->datatype != Ameta->DT_as_read))
         continue;

      if(Ameta->codeindex != Indices[9])  /*** don't want a missing attr notice for UID - is reported  with LongListBadUID errors **/
         {
         if(((Ameta->OptReq == 'M') || (Ameta->OptReq == 'R')) && (Ameta->present != 'Y')) /*** did not find this required attr ***/
            {
            sprintf(messageline,"Layer Identifier %s: Feature %s (%s): Attribute %s (%s): required metadata attribute not present\n",
                Infname,GetECCCode(ECC),ECClabel,GetEACCode(Ameta->codeindex),GetEACLabel(Ameta->codeindex));

            InsertIntoGIFD_MetaData_ErrorList(messageline,entrycount);
            }
         }

      if((Ameta->present == 'Y') && (Ameta->picks != NULL))  /** should be an enum type attr ***/
         {
         pc = Ameta->picks;

         if(Ameta->present == 'Y')
            strcpy(enumcodestring,Ameta->strval);
         else
            enumcodestring[0] = '\0';


         while(pc != NULL)
            {
            if(strcmp(enumcodestring,pc->code) == 0)
               break;
            pc = pc->next;
            }
         if(pc == NULL)
            {
            WriteTheError = 1;
            if(WriteTheError > 0)
               {
               messageline[0] = '\0';
               sprintf(messageline,"Layer Identifier %s: Feature %s (%s): Attribute %s (%s): has invalid pick list value: %s\n",
                    Infname,GetECCCode(ECC),ECClabel,GetEACCode(Ameta->codeindex),GetEACLabel(Ameta->codeindex),enumcodestring);
               if(messageline[0] == 'L')
                  InsertIntoGIFD_MetaData_ErrorList(messageline,entrycount);
               }
            }
         }


      } /** end for i ***/

return;
}



int InspectMGCPdate(int NA_OK, char * indatestr, char * YearLimit, char * MonthLimit, char * DayLimit)
{
int answer = 0;
char year[10];
char datestr[100];
int numdigits;
int j,k,offset,Iyear;
int LeapYear;

   j = strlen(indatestr);
   if(j > 50)
      return(1);

   strcpy(datestr,"                                                                                            ");

   strcpy(datestr,indatestr);


   if(datestr[0] == '"')
      offset = 1;
   else
      offset = 0;

   if(strcmp(&datestr[offset],"N/A") == 0)
      return(1);

   answer = 0;

   Iyear = 0;
   k = offset;
   numdigits = 0;
   if((datestr[k] >= '0') && (datestr[k] <= '9'))
      ++numdigits;
   if((datestr[k+1] >= '0') && (datestr[k+1] <= '9'))
      ++numdigits;
   if((datestr[k+2] >= '0') && (datestr[k+2] <= '9'))
      ++numdigits;
   if((datestr[k+3] >= '0') && (datestr[k+3] <= '9'))
      ++numdigits;

   strncpy(year,&datestr[k],4);

   year[4] = '\0';

   if(numdigits == 4)
      sscanf(year,"%d",&Iyear);

//printf("date str %s and i year %d\n",datestr,Iyear);
   LeapYear = 0;
   if((Iyear > 0) && (Iyear != 1900) && (Iyear != 2100))
      {
      j = Iyear % 4;
      if(j == 0)
         LeapYear = 1;
      }
   
   if((year[0] < '1') || (year[0] > '2'))
      answer = 1;
   else if((year[1] < '0') || (year[1] > '9'))
      answer = 1;
   else if((year[2] < '0') || (year[2] > '9'))
      answer = 1;
   else if((year[3] < '0') || (year[3] > '9'))
      answer = 1;

   if(strcmp(year,YearLimit) == 0)
      {
      if(strncmp(&datestr[5+offset],MonthLimit,2) > 0)
         answer = 1;
      else if((strncmp(&datestr[5+offset],MonthLimit,2) == 0) &&
              (strncmp(&datestr[8+offset],DayLimit,2) > 0))
         answer = 1;
      }
   if(datestr[4+offset] != '-')
      answer = 1;
   else if(datestr[7+offset] != '-')
      answer = 1;
   else if((datestr[5+offset] < '0') || (datestr[5+offset] > '1'))
      answer = 1;
   else if((datestr[5+offset] == '0') && ((datestr[6+offset] < '1') || (datestr[6+offset] > '9')))
      answer = 1;
   else if((datestr[5+offset] == '1') && ((datestr[6+offset] < '0') || (datestr[6+offset] > '2')))
      answer = 1;
   else if((datestr[8+offset] < '0') || (datestr[8+offset] > '3'))
      answer = 1;
   else if((datestr[9+offset] < '0') || (datestr[9+offset] > '9'))
      answer = 1;
   else if((datestr[8+offset] == '3') && ((datestr[9+offset] < '0') || (datestr[9+offset] > '1')))
      answer = 1;
   else if((datestr[8+offset] == '0') && (datestr[9+offset] < '1'))
      answer = 1;
   else if((datestr[10+offset] != '"') && (datestr[10+offset] != '\0'))  /** then string must continue on ***/
      {
      if(datestr[10+offset] != 'T')
         answer = 1;
      else if((datestr[11+offset] < '0') || (datestr[11+offset] > '2'))
         answer = 1;
      else if((datestr[12+offset] < '0') || (datestr[12+offset] > '9'))
         answer = 1;
      else if((datestr[11+offset] == '2') && ((datestr[9+offset] < '0') || (datestr[9+offset] > '3')))
         answer = 1;
      else if(datestr[13+offset] != ':')
         answer = 1;
      else if(datestr[16+offset] != ':')
         answer = 1;
      else if((datestr[14+offset] < '0') || (datestr[14+offset] > '5'))
         answer = 1;
      else if((datestr[15+offset] < '0') || (datestr[15+offset] > '9'))
         answer = 1;
      else if((datestr[17+offset] < '0') || (datestr[17+offset] > '5'))
         answer = 1;
      else if((datestr[18+offset] < '0') || (datestr[18+offset] > '9'))
         answer = 1;
      else if(datestr[19+offset] != 'Z')
         answer = 1;
      }
   if(answer == 0)
      {
      if(strncmp(&datestr[5+offset],"02",2) == 0)  /** February **/
         {
         if(datestr[8+offset] > '2')
            answer = 1;
         else if((LeapYear == 0) && (datestr[8+offset] == '2') && (datestr[9+offset] > '8'))
            answer = 1;
         else if((LeapYear == 1) && (datestr[8+offset] == '2') && (datestr[9+offset] > '9'))
            answer = 1;
         }
      else if((strncmp(&datestr[5+offset],"04",2) == 0) || (strncmp(&datestr[5+offset],"06",2) == 0) ||
                       (strncmp(&datestr[5+offset],"09",2) == 0) || (strncmp(&datestr[5+offset],"11",2) == 0))
         {
         if((datestr[8+offset] == '3') && (datestr[9+offset] > '0'))
            answer = 1;
         }
      }
   if((answer > 0) && (NA_OK > 0))  /*** note that "N_A" is allowed for UPD_DATE but not for SRC_DATE ***/
      {
      if((offset == 0) && (datestr[0] == 'N') && (datestr[1] == '_') && (datestr[2] == 'A') &&
                  (datestr[3] == '\0'))
         answer = 0;
      else if((datestr[1] == 'N') && (datestr[2] == '_') && (datestr[3] == 'A') && 
                 (datestr[5] == '\0')) /** [0] and [4] should == " ***/
         answer = 0;
      }

   return(answer);
}




void  Inspect_MGCP_4_Metadata(int ECC, int Indices[], int entrycount, char * Infname, int NumberAttr, int geomtery,  char * YearLimit,
                                 char * MonthLimit, char * DayLimit)
{
char enumcodestring[500];
char messageline[500];
char ECClabel[100];
int WriteTheError;
int i;
   strcpy(ECClabel,GetECCLabel(ECC));

   for(i=0; i<Num_MGCP4_Meta; i++)
      {
      Ameta = NGAmetaRoot->attr;
      while(Ameta != NULL)
         {
         if(Ameta->codeindex == Indices[i])
            break;
         Ameta = Ameta->next;
         }

      if(Ameta == NULL)
         {
         printf("could not find metadata entry for spec %d\n",i+1);
         exit(-1);
         }

      if((Ameta->present == 'Y') && (Ameta->datatype != Ameta->DT_as_read))
         continue;

      if(Ameta->codeindex != Indices[6])  /*** don't want a missing attr notice for UID **/
         {
         if(((Ameta->OptReq == 'M') || (Ameta->OptReq == 'R')) && (Ameta->present != 'Y')) /*** did not find this required attr ***/
            {
            sprintf(messageline,"Layer Identifier %s: Feature %s (%s): Attribute %s (%s): required metadata attribute not present\n",
                Infname,GetECCCode(ECC),ECClabel,GetEACCode(Ameta->codeindex),GetEACLabel(Ameta->codeindex));

            InsertIntoGIFD_MetaData_ErrorList(messageline,entrycount);
            }
         }

      if((Ameta->present == 'Y') && (Ameta->codeindex == Indices[2]))
         {
         WriteTheError = 0;
         WriteTheError = InspectMGCPdate(0, Ameta->strval, YearLimit, MonthLimit, DayLimit);
         if(WriteTheError > 0)
            {
            messageline[0] = '\0';
            if(Ameta->codeindex == Indices[2])
               sprintf(messageline,"Layer Identifier %s: Feature %s (%s): Attribute SDV (%s): has invalid date value: %s\n",Infname,
                  GetECCCode(ECC),ECClabel,GetEACLabel(Ameta->codeindex),Ameta->strval);
            if(messageline[0] == 'L')
               InsertIntoGIFD_MetaData_ErrorList(messageline,entrycount);
            WriteTheError = 0;
            }
         }
      if((Ameta->present == 'Y') && (Ameta->picks != NULL))  /** should be an enum type attr ***/
         {
         pc = Ameta->picks;

         if(Ameta->present == 'Y')
            strcpy(enumcodestring,Ameta->strval);
         else
            enumcodestring[0] = '\0';


         while(pc != NULL)
            {
            if(strcmp(enumcodestring,pc->code) == 0)
               break;
            pc = pc->next;
            }
         if(pc == NULL)
            {
            WriteTheError = 1;
            if(WriteTheError > 0)
               {
               messageline[0] = '\0';
               sprintf(messageline,"Layer Identifier %s: Feature %s (%s): Attribute %s (%s): has invalid pick list value: %s\n",
                    Infname,GetECCCode(ECC),ECClabel,GetEACCode(Ameta->codeindex),GetEACLabel(Ameta->codeindex),enumcodestring);
               if(messageline[0] == 'L')
                  InsertIntoGIFD_MetaData_ErrorList(messageline,entrycount);
               }
            }
         }


      } /** end for i ***/


return;
}



void Inspect_MGCP_Metadata(int ECC, int Indices[], int entrycount, char * Infname, int NumberAttr, int geomtery,  char * YearLimit,
                                 char * MonthLimit, char * DayLimit)
{
char enumcodestring[500];
char messageline[500];
char ECClabel[100];

int WriteTheError;
int i;


   strcpy(ECClabel,GetECCLabel(ECC));

   for(i=0; i<Num_MGCP_Meta; i++)
      {
      Ameta = NGAmetaRoot->attr;
      while(Ameta != NULL)
         {
         if(Ameta->codeindex == Indices[i])
            break;
         Ameta = Ameta->next;
         }

      if(Ameta == NULL)
         {
         printf("could not find metadata entry for spec %d\n",i+1);
         exit(-1);
         }

      if((Ameta->present == 'Y') && (Ameta->datatype != Ameta->DT_as_read))
         continue;

      if(Ameta->codeindex != Indices[11])  /*** don't want a missing attr notice for UID **/
         {
         if(((Ameta->OptReq == 'M') || (Ameta->OptReq == 'R')) && (Ameta->present != 'Y')) /*** did not find this required attr ***/
            {
            sprintf(messageline,"Layer Identifier %s: Feature %s (%s): Attribute %s (%s): required metadata attribute not present\n",
                Infname,GetECCCode(ECC),ECClabel,GetEACCode(Ameta->codeindex),GetEACLabel(Ameta->codeindex));

            InsertIntoGIFD_MetaData_ErrorList(messageline,entrycount);
            }
         }


      if((Ameta->present == 'Y') && ((Ameta->codeindex == Indices[6]) || (Ameta->codeindex == Indices[12])))
         {
         WriteTheError = 0;
         if(Ameta->codeindex == Indices[12])  /*** note that "N_A" is allowed for UPD_DATE but not for SRC_DATE ***/
            WriteTheError = InspectMGCPdate(1, Ameta->strval, YearLimit, MonthLimit, DayLimit);
         else 
            WriteTheError = InspectMGCPdate(0, Ameta->strval, YearLimit, MonthLimit, DayLimit);
         if(WriteTheError > 0)
            {
            messageline[0] = '\0';
            if(Ameta->codeindex == Indices[6])
               sprintf(messageline,"Layer Identifier %s: Feature %s (%s): Attribute SRC_DATE (%s): has invalid date value: %s\n",Infname,
                  GetECCCode(ECC),ECClabel,GetEACLabel(Ameta->codeindex),Ameta->strval);
            else if(Ameta->codeindex == Indices[12])
               sprintf(messageline,"Layer Identifier %s: Feature %s (%s): Attribute UPD_DATE (%s): has invalid date value: %s\n",Infname,
                  GetECCCode(ECC),ECClabel,GetEACLabel(Ameta->codeindex),Ameta->strval);
            if(messageline[0] == 'L')
               InsertIntoGIFD_MetaData_ErrorList(messageline,entrycount);
            WriteTheError = 0;
            }
         }
      if((Ameta->present == 'Y') && (Ameta->picks != NULL))  /** should be an enum type attr ***/
         {
         pc = Ameta->picks;

         if(Ameta->present == 'Y')
            strcpy(enumcodestring,Ameta->strval);
         else
            enumcodestring[0] = '\0';


         while(pc != NULL)
            {
            if(strcmp(enumcodestring,pc->code) == 0)
               break;
            pc = pc->next;
            }
         if(pc == NULL)
            {
            WriteTheError = IsNUNANPOString(enumcodestring,Ameta->NGAdatatype,Ameta->varchar,Ameta->maxstrlen);

            if(UseNUNANPO > 0)
               {
               if(Ameta->NGAdatatype == 2) /*** short int type ***/
                  {
                  if(strcmp(enumcodestring,"-32768") == 0)
                     WriteTheError = 0;
                  else if (strcmp(enumcodestring,"0") == 0)
                     WriteTheError = 0;
                  else if(strcmp(enumcodestring,"997") == 0)
                     WriteTheError = 0;
                  else if(strcmp(enumcodestring,"998") == 0)
                     WriteTheError = 0;
                  else if(strcmp(enumcodestring,"999") == 0)
                     WriteTheError = 0;
                  else
                     WriteTheError = 1;
                  }
               }
            if(WriteTheError > 0)
               {
               messageline[0] = '\0';
               sprintf(messageline,"Layer Identifier %s: Feature %s (%s): Attribute %s (%s): has invalid pick list value: %s\n", 
                    Infname,GetECCCode(ECC),ECClabel,GetEACCode(Ameta->codeindex),GetEACLabel(Ameta->codeindex),enumcodestring);
/**printf("%s\n",messageline); **/
               if(messageline[0] == 'L')
                  InsertIntoGIFD_MetaData_ErrorList(messageline,entrycount);
               }
            }
         }


      } /** end for i ***/

   return;
}




void InspectGIFD_D4_Metadata(int ECC, int Indices[], int entrycount, char * Infname, int NumberAttr, int geomtery, char * YearLimit)
{
char codestring[100];
char enumcodestring[500];
char messageline[500];
char ECClabel[100];
char year[5],month[3],day[3];
int WriteTheError;
int i,j,ii,slen,seemsbad, offset;
int IsRequired,NoPopulate,WriteError;
char Sec_Class_val[50];
char Sec_CD_Cntrl_val[50];
char Rstrn_Releasibility_val[50];
char Rstrn_Declass_val[50];
char DeclassYear[50];

   sscanf(YearLimit,"%d",&ii);
   ii += 40;
   sprintf(DeclassYear,"%d",ii);
   if(NGAmetaRoot == NULL)
      return;
   strcpy(ECClabel,GetECCLabel(ECC));


   for(i=0; i<NumMeta; i++)
      {
      Ameta = NGAmetaRoot->attr;
      while(Ameta != NULL)
         {
         if(Ameta->codeindex == Indices[i])
            break;
         Ameta = Ameta->next;
         }

      if(Ameta == NULL)
         {
         printf("could not find metadata entry for spec %d\n",i+1);
         }

      if(Ameta->present == 'Y')
         {
         if(Ameta->datatype == 6)   /*** a Date type ***/
            {
            if((Ameta->DT_as_read != 6) && (Ameta->DT_as_read != 2)) /*** should really be a string coming from the importer ***/
               continue;
            }
         else if(Ameta->datatype != Ameta->DT_as_read)
            continue;
         }

      switch(i)
         {
         case 0: /** attr ACE  ***/
            messageline[0] = '\0';
            if(Ameta->present != 'Y') /*** did not find this required attr ***/
               {
               sprintf(messageline,"Layer Identifier %s: Feature %s (%s): Attribute ACE (%s): required metadata attribute not present\n",
                    Infname,GetECCCode(ECC),ECClabel,GetEACLabel(Ameta->codeindex));
               }
            else
               {
               if(Ameta->datatype != 0)
                  {
                  sprintf(messageline,"Layer Identifier %s: Feature %s (%s): Attribute ACE (%s): expected INTEGER datatype, encountered %s\n",
                       Infname,GetECCCode(ECC),ECClabel,GetEACLabel(Ameta->codeindex),NGAdataTypeToString(Ameta->datatype));
                  }
               if(Ameta->strval[0] == '\0') 
                  {
                  sprintf(messageline,"Layer Identifier %s: Feature %s (%s): Attribute ACE (%s): Null values should be entered as '-32768'\n",
                       Infname,GetECCCode(ECC),ECClabel,GetEACLabel(Ameta->codeindex));
                  }
               else if((Ameta->intval < 0) && (Ameta->intval != -32768))
                  {
                  sprintf(messageline,"Layer Identifier %s: Feature %s (%s): Attribute ACE (%s): Null values should be entered as '-32768' (encountered %d)\n",
                       Infname,GetECCCode(ECC),ECClabel,GetEACLabel(Ameta->codeindex),Ameta->intval);
                  }
               }
            if(messageline[0] == 'L')
               InsertIntoGIFD_MetaData_ErrorList(messageline,entrycount);
            break;

         case 2: /** ALE **/
            messageline[0] = '\0';
            if(Ameta->present != 'Y') /*** did not find this required attr ***/
               {
               sprintf(messageline,"Layer Identifier %s: Feature %s (%s): Attribute ALE (%s): required metadata attribute not present\n",
                   Infname,GetECCCode(ECC),ECClabel,GetEACLabel(Ameta->codeindex));
               }
            else
               {
               if(Ameta->datatype != 0)
                  {
                  sprintf(messageline,"Layer Identifier %s: Feature %s (%s): Attribute ALE (%s): expected INTEGER datatype, encountered %s\n",
                       Infname,GetECCCode(ECC),ECClabel,GetEACLabel(Ameta->codeindex),NGAdataTypeToString(Ameta->datatype));
                  }
               if(Ameta->strval[0] == '\0')
                  {
                  sprintf(messageline,"Layer Identifier %s: Feature %s (%s): Attribute ALE (%s): Null values should be entered as '-32768'\n",
                       Infname,GetECCCode(ECC),ECClabel,GetEACLabel(Ameta->codeindex));
                  }
               else if((Ameta->intval < 0) && (Ameta->intval != -32768))
                  {
                  sprintf(messageline,"Layer Identifier %s: Feature %s (%s): Attribute ALE (%s): Null values should be entered as '-32768' (encountered %d)\n",
                       Infname,GetECCCode(ECC),ECClabel,GetEACLabel(Ameta->codeindex),Ameta->intval);
                  }
               }
            if(messageline[0] == 'L')
               InsertIntoGIFD_MetaData_ErrorList(messageline,entrycount);
            break;

         case 6: /*** COMM_CPYRT_NOTICE ***/
            messageline[0] = '\0';
            if(Ameta->present != 'Y') /*** did not find this required attr ***/
               {
               sprintf(messageline,"Layer Identifier %s: Feature %s (%s): Attribute COMM_CPYRT_NOTICE (%s): required metadata attribute not present\n",
                        Infname,GetECCCode(ECC),ECClabel,GetEACLabel(Ameta->codeindex));
               }
            else
               {
               if((Ameta->strval[0] == '\0') || (strcmp(Ameta->strval,"N/A") == 0) || (strcmp(Ameta->strval,"UNK") == 0) ||
                       (strcmp(Ameta->strval,"N_P") == 0) || (strcmp(Ameta->strval,"N_A") == 0) || (strcmp(Ameta->strval,"Other") == 0))
                  { 
                  sprintf(messageline,"Layer Identifier %s: Feature %s (%s): Attribute COMM_CPYRT_NOTICE (%s): required NGA copyright notice not present\n",
                        Infname,GetECCCode(ECC),ECClabel,GetEACLabel(Ameta->codeindex));
                  }
               }
            if(messageline[0] == 'L')
               InsertIntoGIFD_MetaData_ErrorList(messageline,entrycount);
            break;

         case 7: /*** COMM_LIC_TIER_NOTICE ***/
            messageline[0] = '\0';
            if(Ameta->present != 'Y') /*** did not find this required attr ***/
               { 
               sprintf(messageline,"Layer Identifier %s: Feature %s (%s): Attribute COMM_LIC_TIER_NOTICE (%s): required metadata attribute not present\n",
                       Infname,GetECCCode(ECC),ECClabel,GetEACLabel(Ameta->codeindex));
               }
            else
               {
               if((Ameta->strval[0] == '\0') || (strcmp(Ameta->strval,"UNK") == 0) ||
                       (strcmp(Ameta->strval,"N_P") == 0) || (strcmp(Ameta->strval,"N_A") == 0) || (strcmp(Ameta->strval,"Other") == 0))
                  {
                  sprintf(messageline,"Layer Identifier %s: Feature %s (%s): Attribute COMM_LIC_TIER_NOTICE (%s): value 'N/A' should be used\n",
                                   Infname,GetECCCode(ECC),ECClabel,GetEACLabel(Ameta->codeindex));
                  }
               }
            if(messageline[0] == 'L')
               InsertIntoGIFD_MetaData_ErrorList(messageline,entrycount);
            break;

         case 9: /** OPERATOR ***/
         case 13: /** ORIGINATOR ***/
            if(Ameta->present != 'Y') /*** did not find this required attr ***/
               {
               messageline[0] = '\0';
               if(i == 13)
                  sprintf(messageline,"Layer Identifier %s: Feature %s (%s): Attribute ORIGINATOR (%s): required metadata attribute not present\n",
                                   Infname,GetECCCode(ECC),ECClabel,GetEACLabel(Ameta->codeindex));
               if(messageline[0] == 'L')
                  InsertIntoGIFD_MetaData_ErrorList(messageline,entrycount);
               }
            break;
         case 1: /** ACE_EVAL_METHOD_CD ***/
         case 3: /** ALE_EVAL_METHOD_CD ***/
         case 8: /** COMPLETENESS_CODE ***/
         case 12: /*** ORIGINATING_SOURCE ***/
         case 25: /*** SEC_CLASS ***/
         case 27: /*** SPEC_ID ***/
         case 30: /** UPDATE_SOURCE **/
         case 31: /*** Z_VALUE_TYPE ***/
            if(Ameta->present != 'Y') /*** did not find this required attr ***/
               {
               messageline[0] = '\0';
               if(i == 1)
                  sprintf(messageline,"Layer Identifier %s: Feature %s (%s): Attribute ACE_EVAL_METHOD_CD (%s): required metadata attribute not present\n",
                           Infname,GetECCCode(ECC),ECClabel,GetEACLabel(Ameta->codeindex));
               else if(i == 3)
                  sprintf(messageline,"Layer Identifier %s: Feature %s (%s): Attribute ALE_EVAL_METHOD_CD (%s): required metadata attribute not present\n",
                           Infname,GetECCCode(ECC),ECClabel,GetEACLabel(Ameta->codeindex));
               else if(i == 12)
                  sprintf(messageline,"Layer Identifier %s: Feature %s (%s): Attribute ORIGINATING_SOURCE (%s): required metadata attribute not present\n",
                           Infname,GetECCCode(ECC),ECClabel,GetEACLabel(Ameta->codeindex));
               else if(i == 25)
                  sprintf(messageline,"Layer Identifier %s: Feature %s (%s): Attribute SEC_CLASS (%s): required metadata attribute not present\n",
                           Infname,GetECCCode(ECC),ECClabel,GetEACLabel(Ameta->codeindex));
               else if(i == 27)
                  sprintf(messageline,"Layer Identifier %s: Feature %s (%s): Attribute SPEC_ID (%s): required metadata attribute not present\n",
                           Infname,GetECCCode(ECC),ECClabel,GetEACLabel(Ameta->codeindex));
               else if(i == 31)
                  sprintf(messageline,"Layer Identifier %s: Feature %s (%s): Attribute Z_VALUE_TYPE (%s): required metadata attribute not present\n",
                           Infname,GetECCCode(ECC),ECClabel,GetEACLabel(Ameta->codeindex));
               if(messageline[0] == 'L')
                  InsertIntoGIFD_MetaData_ErrorList(messageline,entrycount);
               }
            else if(Ameta != NULL)
               {
               if(i == 1)
                  {
                  Ap = NGAmetaRoot->attr;
                  while(Ap != NULL)
                     {
                     if(Ap->codeindex == Indices[0]) /*** for ACE ***/
                        break; 
                     Ap = Ap->next;
                     }

                  if(Ap->present == 'Y')
                     {
                     if((Ap->intval < 0) || (Ap->strval[0] == '\0') || (strcmp(Ap->strval,"N/A") == 0) || (strcmp(Ap->strval,"N_A") == 0) ||
                            (strcmp(Ap->strval,"UNK") == 0) || (strcmp(Ap->strval, "-32768") == 0) || 
                             (strcmp(Ap->strval,"-32768.0") == 0))
                        {
                        if(strcmp(Ameta->strval,"FZD") != 0)
                           {
                           sprintf(messageline,"Layer Identifier %s: Feature %s (%s): Attribute ACE_EVAL_METHOD_CD (%s): when ACE is NULL, value must be 'FZD', found: %s\n",
                                    Infname,GetECCCode(ECC),ECClabel,GetEACLabel(Ameta->codeindex),Ameta->strval);
                           InsertIntoGIFD_MetaData_ErrorList(messageline,entrycount);
                           }
                        }
                     else if(strcmp(Ameta->strval,"FZD") == 0)
                        {
                        sprintf(messageline,"Layer Identifier %s: Feature %s (%s): Attribute ACE (%s): when ACE_EVAL_METHOD_CD is 'FZD', ACE value must be NULL (-32768), found: %s\n",
                                    Infname,GetECCCode(ECC),ECClabel,GetEACLabel(Ap->codeindex),Ap->strval);
                        InsertIntoGIFD_MetaData_ErrorList(messageline,entrycount);
                        }
                     }

                  }
               else if(i == 3)
                  {
                  Ap = NGAmetaRoot->attr;
                  while(Ap != NULL)
                     {
                     if(Ap->codeindex == Indices[2]) /*** for ALE ***/
                        break;
                     Ap = Ap->next;
                     }

                  if(Ap->present == 'Y')
                     {
                     if((Ap->intval < 0) || (Ap->strval[0] == '\0') || (strcmp(Ap->strval,"N/A") == 0) || (strcmp(Ap->strval,"N_A") == 0) ||
                            (strcmp(Ap->strval,"UNK") == 0) || (strcmp(Ap->strval, "-32768") == 0) ||
                             (strcmp(Ap->strval,"-32768.0") == 0))
                        {
                        if(strcmp(Ameta->strval,"FZD") != 0)
                           {
                           sprintf(messageline,"Layer Identifier %s: Feature %s (%s): Attribute ALE_EVAL_METHOD_CD (%s): when ALE is NULL, value must be 'FZD', found: %s\n",
                                    Infname,GetECCCode(ECC),ECClabel,enumcodestring,GetEACLabel(Ameta->codeindex));
                           InsertIntoGIFD_MetaData_ErrorList(messageline,entrycount);
                           }
                        }
                     }
                  else if(strcmp(Ameta->strval,"FZD") == 0)
                     {
                     sprintf(messageline,"Layer Identifier %s: Feature %s (%s): Attribute ALE (%s): when ALE_EVAL_METHOD_CD is 'FZD', ALE value must be NULL (-32768), found: %s\n",
                                 Infname,GetECCCode(ECC),ECClabel,GetEACLabel(Ap->codeindex),Ap->strval);
                     InsertIntoGIFD_MetaData_ErrorList(messageline,entrycount);
                     }

                  }

               pc = Ameta->picks;

               if(Ameta->present == 'Y')
                  strcpy(enumcodestring,Ameta->strval);
               else
                  enumcodestring[0] = '\0';


               while(pc != NULL)
                  {
                  if(strcmp(enumcodestring,pc->code) == 0)
                     break;
                  pc = pc->next;
                  }
               if(pc == NULL)
                  {
                  if((enumcodestring[0] == '\0') && (i == 30))
                     WriteTheError = 0;
                  else
                     WriteTheError = IsNUNANPOString(enumcodestring,Ameta->NGAdatatype,Ameta->varchar,Ameta->maxstrlen);
                  if(UseNUNANPO > 0)
                     {
                     if(Ameta->NGAdatatype == 2) /*** short int type ***/
                        {
                        if(strcmp(enumcodestring,"-32768") == 0)
                           WriteTheError = 0;
                        else if (strcmp(enumcodestring,"0") == 0)
                           WriteTheError = 0;
                        else if(strcmp(enumcodestring,"997") == 0)
                           WriteTheError = 0;
                        else if(strcmp(enumcodestring,"998") == 0)
                           WriteTheError = 0;
                        else if(strcmp(enumcodestring,"999") == 0)
                           WriteTheError = 0;
                        else
                           WriteTheError = 1;
                        }
                     }
                  if(WriteTheError > 0)
                     {
                     messageline[0] = '\0';
                     if(i == 1)
                        sprintf(messageline,"Layer Identifier %s: Feature %s (%s): Attribute ACE_EVAL_METHOD_CD (%s): has invalid pick list value: %s\n",Infname,
                           GetECCCode(ECC),ECClabel,enumcodestring,GetEACLabel(Ameta->codeindex));
                     else if(i == 3)
                        sprintf(messageline,"Layer Identifier %s: Feature %s (%s): Attribute ALE_EVAL_METHOD_CD (%s): has invalid pick list value: %s\n",Infname,
                           GetECCCode(ECC),ECClabel,enumcodestring,GetEACLabel(Ameta->codeindex));
                     else if(i == 8)
                        sprintf(messageline,"Layer Identifier %s: Feature %s (%s): Attribute COMPLETENESS_CODE (%s): has invalid pick list value: %s\n",Infname,
                           GetECCCode(ECC),ECClabel,enumcodestring,GetEACLabel(Ameta->codeindex));
                     else if(i == 12)
                        sprintf(messageline,"Layer Identifier %s: Feature %s (%s): Attribute ORIGINATING_SOURCE (%s): has invalid pick list value: %s\n",Infname,
                           GetECCCode(ECC),ECClabel,enumcodestring,GetEACLabel(Ameta->codeindex));
                     else if(i == 25)
                        sprintf(messageline,"Layer Identifier %s: Feature %s (%s): Attribute SEC_CLASS (%s): has invalid pick list value: %s\n",Infname,
                           GetECCCode(ECC),ECClabel,enumcodestring,GetEACLabel(Ameta->codeindex));
                     else if(i == 27)
                        sprintf(messageline,"Layer Identifier %s: Feature %s (%s): Attribute SPEC_ID (%s): has invalid pick list value: %s\n",Infname,
                           GetECCCode(ECC),ECClabel,enumcodestring,GetEACLabel(Ameta->codeindex));
                     else if(i == 30)
                        sprintf(messageline,"Layer Identifier %s: Feature %s (%s): Attribute UPDATE_SOURCE (%s): has invalid pick list value: %s\n",Infname,
                           GetECCCode(ECC),ECClabel,enumcodestring,GetEACLabel(Ameta->codeindex));
                     else if(i == 31)
                        sprintf(messageline,"Layer Identifier %s: Feature %s (%s): Attribute Z_VALUE_TYPE (%s): has invalid pick list value: %s\n",Infname,
                           GetECCCode(ECC),ECClabel,enumcodestring,GetEACLabel(Ameta->codeindex));
                     if(messageline[0] == 'L')
                        InsertIntoGIFD_MetaData_ErrorList(messageline,entrycount);
                     }
                  }
               }
            break;
         case 4: /** CREATION_DATE ***/
         case 10: /** ORIG_SOURCE_DATE ***/
         case 28: /*** UPDATE_SOURCE_DATE - this is an optional field ***/
            if(Ameta->present != 'Y') /*** did not find this required attr ***/
               {
               messageline[0] = '\0';
               if(i == 10)
                  sprintf(messageline,"Layer Identifier %s: Feature %s (%s): Attribute ORIG_SOURCE_DATE (%s): required metadata attribute not present\n",Infname,
                           GetECCCode(ECC),ECClabel,GetEACLabel(Ameta->codeindex));
               if(messageline[0] == 'L')
                  InsertIntoGIFD_MetaData_ErrorList(messageline,entrycount);
               }
            else if((Ameta->datatype == 0) || (Ameta->datatype == 6))  /*** a string type or a Date type ***/
               {
               if((UseNUNANPO < 1)  ||
                     (IsNUNANPOString(Ameta->strval, 1, 0, 25) > 0))
                  {
                  WriteError = 0;
                  if(Ameta->strval == NULL)
                     slen = 0;
                  else
                     slen = strlen(Ameta->strval);
                  if(slen < 8)
                     WriteError = 1;
                  else
                     {
                     if(Ameta->strval[0] == '"')
                        offset = 1;
                     else
                        offset = 0;
                     year[0] = Ameta->strval[0+offset];
                     year[1] = Ameta->strval[1+offset];
                     year[2] = Ameta->strval[2+offset];
                     year[3] = Ameta->strval[3+offset];
                     year[4] = '\0';

                     month[0] = Ameta->strval[4+offset];
                     month[1] = Ameta->strval[5+offset];
                     month[2] = '\0';

                     day[0] = Ameta->strval[6+offset];
                     day[1] = Ameta->strval[7+offset];
                     day[2] = '\0';
                     if(strcmp(year,"1940") < 0)
                        WriteError = 1;
                     else if(strcmp(year,YearLimit) > 0)   /***else if(strcmp(year,"2008") > 0) **/
                        WriteError = 1;
                     else if(strcmp(month,"00") < 0)
                        WriteError = 1;
                     else if(strcmp(month,"12") > 0)
                        WriteError = 1;
                     else if(strcmp(day,"01") < 0)
                        WriteError = 1;
                     else if(strcmp(day,"31") > 0)
                        WriteError = 1;
                     }
                  if(WriteError > 0)
                     {
                     messageline[0] = '\0';
                     if(i == 4)
                        sprintf(messageline,"Layer Identifier %s: Feature %s (%s): Attribute CREATION_DATE (%s): has invalid date value: %s\n",Infname,
                           GetECCCode(ECC),ECClabel,GetEACLabel(Ameta->codeindex),Ameta->strval);
                     else if(i == 10)
                        sprintf(messageline,"Layer Identifier %s: Feature %s (%s): Attribute ORIG_SOURCE_DATE (%s): has invalid date value: %s\n",Infname,
                           GetECCCode(ECC),ECClabel,GetEACLabel(Ameta->codeindex),Ameta->strval);
                     else if(i == 28)
                        sprintf(messageline,"Layer Identifier %s: Feature %s (%s): Attribute UPDATE_SOURCE_DATE (%s): has invalid date value: %s\n",Infname,
                           GetECCCode(ECC),ECClabel,GetEACLabel(Ameta->codeindex),Ameta->strval);
                     if(messageline[0] == 'L')
                        InsertIntoGIFD_MetaData_ErrorList(messageline,entrycount);
                     }
                  }
               }

            break;

         case 5: /** COMMENTS ***/
         case 11: /*** ORIG_SOURCE_INFO ***/
         case 24: /*** SEC_CD_CNTRL ***/
         case 26:  /*** SEC_CLASS_SYS_ID - not really free field, but no data avail from NGA ***/
         case 29: /*** UPDATE_SOURCE_INFO ***/
            break;

         case 14: /*** RSTRN_DCLS_XMPT_CD ****/
            Ap = NGAmetaRoot->attr;
            while(Ap != NULL)
               {
               if(Ap->codeindex == Indices[25]) /*** for SEC_CLASS ***/
                  break;
               Ap = Ap->next;
               }

            if(Ap == NULL)
               {
               printf("could not find metadata entry for spec SEC_CLASS for use with attribute RSTRN_DCLS_XMPT_CD\n");
               exit(-1);
               }
            IsRequired = 0;
            NoPopulate = 0;
            if(Ap->present == 'Y')
               strcpy(enumcodestring, GetEECode(Ap->codeindex, Ap->intval));
            else
               enumcodestring[0] = '\0';

            if((strcmp(enumcodestring,"TS") == 0) || (strcmp(enumcodestring,"S") == 0) ||
                 (strcmp(enumcodestring,"C") == 0))
               {
               Ac = NGAmetaRoot->attr;
               while(Ac != NULL)
                  {
                  if(Ac->codeindex == Indices[15]) /*** for RSTRN_DECLASS ***/
                     break;
                  Ac = Ac->next;
                  }
   
               if(Ac == NULL)
                  {
                  printf("could not find metadata entry for spec RSTRN_DECLASS for use with attribute RSTRN_DCLS_XMPT_CD\n");
                  exit(-1);
                  }

               if(Ac->present == 'N')
                  IsRequired = 1;
               }
            else if(strcmp(enumcodestring,"U") == 0)
               NoPopulate = 1;

            WriteError = 0;
            if(NoPopulate > 0)
               {
               if(Ameta->present == 'Y') 
                  {
                  sprintf(messageline,"Layer Identifier %s: Feature %s (%s): Attribute RSTRN_DCLS_XMPT_CD (%s): is assigned with value %s;  When SEC_CLASS reflects unclassified data, this field should be unpopulated\n",
                           Infname,GetECCCode(ECC),ECClabel,GetEACLabel(Ameta->codeindex),Ameta->strval);
                  InsertIntoGIFD_MetaData_ErrorList(messageline,entrycount);
                  }
               }
            else if(IsRequired > 0)
               {
               if(Ameta->present != 'Y')
                  {
sprintf(messageline,"Layer Identifier %s: Feature %s (%s): Attribute RSTRN_DCLS_XMPT_CD (%s): attribute is missing; When SEC_CLASS reflects TS, S, or C data and RSTRN_DECLASS is not populated, this attribute is required\n",
                           Infname,GetECCCode(ECC),ECClabel,GetEACLabel(Ameta->codeindex));
                     InsertIntoGIFD_MetaData_ErrorList(messageline,entrycount);
                  }
               else  /*** need to parse the string value ***/
                  {
                  j = ParseRSTRN_DECLASS_XMPT(Ameta->strval);
                  if(j > 0)
                     {
sprintf(messageline,"Layer Identifier %s: Feature %s (%s): Attribute RSTRN_DCLS_XMPT_CD (%s): attribute assigned improper value %s; value must not contain blanks and must be comma separated list of one or more specific codes\n",
                           Infname,GetECCCode(ECC),ECClabel,GetEACLabel(Ameta->codeindex),Ameta->strval);
                     InsertIntoGIFD_MetaData_ErrorList(messageline,entrycount);
                     }
                  }
               }

            break;


         case 15: /*** RSTRN_DECLASS ****/
            Ap = NGAmetaRoot->attr;
            while(Ap != NULL)
               {
               if(Ap->codeindex == Indices[25]) /*** for SEC_CLASS ***/
                  break;
               Ap = Ap->next;
               }

            if(Ap == NULL)
               {
               printf("could not find metadata entry for spec SEC_CLASS for use with attribute RSTRN_DECLASS\n");
               exit(-1);
               }
            IsRequired = 0;
            NoPopulate = 0;
            if(Ap->present == 'Y')
               strcpy(enumcodestring, GetEECode(Ap->codeindex, Ap->intval));
            else
               enumcodestring[0] = '\0';

            if((strcmp(enumcodestring,"TS") == 0) || (strcmp(enumcodestring,"S") == 0) ||
                 (strcmp(enumcodestring,"C") == 0))
               {
               Ac = NGAmetaRoot->attr;
               while(Ac != NULL)
                  {
                  if(Ac->codeindex == Indices[14]) /*** for RSTRN_DCLS_XMPT_CD ***/
                     break;
                  Ac = Ac->next;
                  }

               if(Ac == NULL)
                  {
                  printf("could not find metadata entry for spec RSTRN_DECLASS for use with attribute RSTRN_DCLS_XMPT_CD\n");
                  exit(-1);
                  }

                  
               if(Ac->strval != NULL)
                  {
                  if(Ac->present == 'N')
                     IsRequired = 1;
                  }
               }
            else if(strcmp(enumcodestring,"U") == 0)
               NoPopulate = 1;

            WriteError = 0;
            if(NoPopulate > 0)
               {
               if(Ameta->present == 'Y')
                  {
                  sprintf(messageline,"Layer Identifier %s: Feature %s (%s): Attribute RSTRN_DECLASS (%s): attribute is assigned with value %s;  When SEC_CLASS reflects unclassified data, this field should be unpopulated\n",
                           Infname,GetECCCode(ECC),ECClabel,GetEACLabel(Ameta->codeindex),Ameta->strval);
                  InsertIntoGIFD_MetaData_ErrorList(messageline,entrycount);

                  }
               }
            else if(IsRequired > 0)
               {
               if(Ameta->present != 'Y')
                  {
                     sprintf(messageline,"Layer Identifier %s: Feature %s (%s): Attribute RSTRN_DECLASS (%s): attribute is missing;  When SEC_CLASS reflects TS, S, or C data and RSTRN_DCLS_XMPT_CD is not populated, this attribute is required\n",
                           Infname,GetECCCode(ECC),ECClabel,GetEACLabel(Ameta->codeindex));
                     InsertIntoGIFD_MetaData_ErrorList(messageline,entrycount);
                  }
               }
            else if(Ameta->present == 'Y') /*** need to parse the string value ***/
               {
               j = 1;
               if(strcmp(Ameta->strval,"MR") == 0)
                  {
                  j = 0;
                  }
               else if((Ameta->strval[0] == '"') && (Ameta->strval[1] == 'M') && (Ameta->strval[2] == 'R') && (Ameta->strval[3] == '"'))
                  {
                  j = 0;
                  }
               else if((Ameta->strval[0] == '"') && (Ameta->strval[9] == '"') && (AllDigits(Ameta->strval,0) > 0) &&
                         (strncmp("1940",&Ameta->strval[1],4) < 0)  && (strncmp(DeclassYear,&Ameta->strval[1],4) > 0) &&
                         (strncmp("00",&Ameta->strval[5],2) < 0) && (strncmp("13",&Ameta->strval[5],2) > 0) &&
                         (strncmp("00",&Ameta->strval[7],2) < 0) && (strncmp("32",&Ameta->strval[7],2) > 0))
                  {
                  j = 0;
                  }

               else if((AllDigits(Ameta->strval,0) > 0) &&
                         (strncmp("1940",Ameta->strval,4) < 0)  && (strncmp(DeclassYear,Ameta->strval,4) > 0) &&
                         (strncmp("00",&Ameta->strval[4],2) < 0) && (strncmp("13",&Ameta->strval[4],2) > 0) &&
                         (strncmp("00",&Ameta->strval[6],2) < 0) && (strncmp("32",&Ameta->strval[6],2) > 0))
                  {
                  j = 0;
                  }
               else if((UseNUNANPO > 0)  &&
                  (IsNUNANPOString(Ameta->strval, 1, 0, 9) == 0))
                  {
                  j = 0;
                  }

               if(j > 0)
                  {
                  sprintf(messageline,"Layer Identifier %s: Feature %s (%s): Attribute RSTRN_DECLASS (%s): attribute assigned improper value %s  value must be \"MR\" (for manual review) or valid date in YYYYMMDD format\n",
                           Infname,GetECCCode(ECC),ECClabel,GetEACLabel(Ameta->codeindex),Ameta->strval);
                  InsertIntoGIFD_MetaData_ErrorList(messageline,entrycount);
                  }
               }

            break;

         case 16: /*** RSTRN_DSEM_CTRL_IC ***/
            Ap = NGAmetaRoot->attr;
            while(Ap != NULL)
               {
               if(Ap->codeindex == Indices[25]) /*** for SEC_CLASS ***/
                  break;
               Ap = Ap->next;
               }

            if(Ap == NULL)
               {
               printf("could not find metadata entry for spec SEC_CLASS for use with attribute RSTRN_DSEM_CTRL_IC\n");
               exit(-1);
               }
            if(Ap->present == 'Y')
               strcpy(Sec_Class_val, GetEECode(Ap->codeindex, Ap->intval));
            else
               Sec_Class_val[0] = '\0';

            if((UseNUNANPO > 0) && (strcmp(Sec_Class_val,"N_P") == 0))
               Sec_Class_val[0] = '\0';

            Ap = NGAmetaRoot->attr;
            while(Ap != NULL)
               {
               if(Ap->codeindex == Indices[24]) /*** for SEC_CD_CTRL ***/
                  break;
               Ap = Ap->next;
               }

            if(Ap == NULL)
               {
               printf("could not find metadata entry for spec SEC_CLASS for use with attribute RSTRN_DSEM_CTRL_IC\n");
               exit(-1);
               }
            if(Ap->present == 'Y')
               strcpy(Sec_CD_Cntrl_val, Ap->strval);
            else
               Sec_CD_Cntrl_val[0] = '\0';

            Ap = NGAmetaRoot->attr;
            while(Ap != NULL)
               {
               if(Ap->codeindex == Indices[19]) /*** for RSTRN_RELEASIBILITY ***/
                  break;
               Ap = Ap->next;
               }

            if(Ap == NULL)
               {
               printf("could not find metadata entry for spec SEC_CLASS for use with attribute RSTRN_DSEM_CTRL_IC\n");
               exit(-1);
               }
            if(Ap->present == 'Y')
               {
               strcpy(Rstrn_Releasibility_val, Ap->strval);
               }
            else
               Rstrn_Releasibility_val[0] = '\0';

            if((UseNUNANPO > 0) && (strcmp(Rstrn_Releasibility_val,"N_P") == 0))
               Rstrn_Releasibility_val[0] = '\0';

            Ap = NGAmetaRoot->attr;
            while(Ap != NULL)
               {
               if(Ap->codeindex == Indices[15]) /*** for RSTRN_DECLASS ***/
                  break;
               Ap = Ap->next;
               }

            if(Ap == NULL)
               {
               printf("could not find metadata entry for spec SEC_CLASS for use with attribute RSTRN_DSEM_CTRL_IC\n");
               exit(-1);
               }
            if(Ap->present == 'Y')
               strcpy(Rstrn_Declass_val, Ap->strval);
            else
               Rstrn_Declass_val[0] = '\0';

            if(Ameta->present == 'Y')
               strcpy(enumcodestring,Ameta->strval);
            else
               enumcodestring[0] = '\0';

            NoPopulate = 0;
            slen = strlen(enumcodestring);
            if(slen == 0)
               NoPopulate = 1;
            else if((UseNUNANPO > 0) && (strcmp(Ameta->strval,"N_P") == 0))
               NoPopulate = 1;
            
            if(NoPopulate == 0)
               {
               ii = 0;
               while(ii < slen)
                  {
                  j = 0;
                  while((enumcodestring[ii] != ',') && (ii < slen))
                     {
                     if(enumcodestring[ii] == '"')
                        ++ii;
                     else
                        {
                        codestring[j] = enumcodestring[ii];
                        ++ii;
                        ++j;
                        codestring[j] = '\0';
                        }
                     }

                  WriteTheError = 0;
                  if(strcmp(codestring,"RSEN") == 0)
                      {
                      if((strcmp(Sec_Class_val,"TS") == 0) || (strcmp(Sec_Class_val,"S") == 0))
                         {
                         if((Sec_CD_Cntrl_val[0] == '\0') || (strstr(Sec_CD_Cntrl_val,"TK") != NULL))
                            WriteTheError = 0;
                         else
                            {
                            WriteTheError = 1;
                            }
                         }
                      else
                         WriteTheError = 1;
                      if(WriteTheError > 0)
                         {
sprintf(messageline,"Layer Identifier %s: Feature %s (%s): Attribute RSTRN_DSEM_CTRL_IC (%s): value: %s assigned value can contain \"RSEN\" only when SEC_CLASS is \"TS\" or \"S\" and SEC_CD_CNTRL contains \"TK\"\n or SEC_CD_CNTRL is not populated",
                           Infname,GetECCCode(ECC),ECClabel,GetEACLabel(Ameta->codeindex),Ameta->strval);
                         InsertIntoGIFD_MetaData_ErrorList(messageline,entrycount);
                         }
                      }
                  else if(strcmp(codestring,"FOUO") == 0)
                      {
                      if(strcmp(Sec_Class_val,"U") == 0)
                         WriteTheError = 0;
                      else
                         WriteTheError = 1;
                      if(WriteTheError > 0)
                         {
sprintf(messageline,"Layer Identifier %s: Feature %s (%s): Attribute RSTRN_DSEM_CTRL_IC (%s): value: %s assigned value can contain \"FOUO\" only when SEC_CLASS is \"U\" \n",
                           Infname,GetECCCode(ECC),ECClabel,GetEACLabel(Ameta->codeindex),Ameta->strval);
                         InsertIntoGIFD_MetaData_ErrorList(messageline,entrycount);
                         }
                      }
                  else if(strcmp(codestring,"ORCON") == 0)
                      {
                      if((strcmp(Sec_Class_val,"TS") == 0) || (strcmp(Sec_Class_val,"S") == 0) || (strcmp(Sec_Class_val,"C") == 0))
                         {
                         WriteTheError = 0;
                         }
                      else
                         WriteTheError = 1;
                      if(WriteTheError > 0)
                         {
sprintf(messageline,"Layer Identifier %s: Feature %s (%s): Attribute RSTRN_DSEM_CTRL_IC (%s): value: %s assigned value can contain \"ORCON\" only when SEC_CLASS is \"TS\" or \"S\" or \"C\"\n",
                           Infname,GetECCCode(ECC),ECClabel,GetEACLabel(Ameta->codeindex),Ameta->strval);
                         InsertIntoGIFD_MetaData_ErrorList(messageline,entrycount);
                         }
                      }
                  else if(strcmp(codestring,"IMCON") == 0)
                      {
                      if(strcmp(Sec_Class_val,"S") == 0)
                         {
                         if(Rstrn_Releasibility_val[0] == '\0')
                            WriteTheError = 0;
                         else
                            {
                            WriteTheError = 1;
                            }
                         }
                      else
                         WriteTheError = 1;
                      if(WriteTheError > 0)
                         {
sprintf(messageline,"Layer Identifier %s: Feature %s (%s): Attribute RSTRN_DSEM_CTRL_IC (%s): value: %s assigned value can contain \"IMCON\" only when SEC_CLASS is \"S\" and RSTRN_RELEASIBILITY is not populated\n",
                           Infname,GetECCCode(ECC),ECClabel,GetEACLabel(Ameta->codeindex),Ameta->strval);
                         InsertIntoGIFD_MetaData_ErrorList(messageline,entrycount);
                         }
                      }
                  else if(strcmp(codestring,"SAMI") == 0)
                      {
                      if((strcmp(Sec_Class_val,"TS") == 0) || (strcmp(Sec_Class_val,"S") == 0) || (strcmp(Sec_Class_val,"C") == 0))
                         {
                         if(Rstrn_Releasibility_val[0] == '\0')
                            WriteTheError = 0;
                         else
                            {
                            WriteTheError = 1;
                            }
                         }
                      else
                         WriteTheError = 1;
                      if(WriteTheError > 0)
                         {
sprintf(messageline,"Layer Identifier %s: Feature %s (%s): Attribute RSTRN_DSEM_CTRL_IC (%s): value: %s assigned value can contain \"SAMI\" only when SEC_CLASS is \"TS\", \"S\", or \"C\" and \n RSTRN_RELEASIBILITY is not populated\n",
                           Infname,GetECCCode(ECC),ECClabel,GetEACLabel(Ameta->codeindex),Ameta->strval);
                         InsertIntoGIFD_MetaData_ErrorList(messageline,entrycount);
                         }
                      }
                  else if(strcmp(codestring,"NOFORN") == 0)
                      {
                      if((strcmp(Sec_Class_val,"TS") == 0) || (strcmp(Sec_Class_val,"S") == 0) || (strcmp(Sec_Class_val,"C") == 0))
                         {
                         if(Rstrn_Releasibility_val[0] == '\0')
                            WriteTheError = 0;
                         else
                            {
                            WriteTheError = 1;
                            }
                         }
                      else
                         WriteTheError = 1;
                      if(WriteTheError > 0)
                         {
sprintf(messageline,"Layer Identifier %s: Feature %s (%s): Attribute RSTRN_DSEM_CTRL_IC (%s): value: %s assigned value can contain \"NOFORN\" only when SEC_CLASS is \"TS\", \"S\", or \"C\" and \n RSTRN_RELEASIBILITY is not populated\n",
                           Infname,GetECCCode(ECC),ECClabel,GetEACLabel(Ameta->codeindex),Ameta->strval);
                         InsertIntoGIFD_MetaData_ErrorList(messageline,entrycount);
                         }
                      }
                  else if(strcmp(codestring,"PROPIN") == 0)
                      {
                      WriteTheError = 0;
                      }
                  else if(strcmp(codestring,"RD") == 0)
                      {
                      if((strcmp(Sec_Class_val,"TS") == 0) || (strcmp(Sec_Class_val,"S") == 0) || (strcmp(Sec_Class_val,"C") == 0))
                         {
                         if(strcmp(Rstrn_Declass_val,"MR") == 0)
                            WriteTheError = 0;
                         else
                            {
                            WriteTheError = 1;
                            }
                         }
                      else
                         WriteTheError = 1;
                      if(WriteTheError > 0)
                         {
sprintf(messageline,"Layer Identifier %s: Feature %s (%s): Attribute RSTRN_DSEM_CTRL_IC (%s): value: %s assigned value can contain \"RD\" only when SEC_CLASS is \"TS\", \"S\", or \"C\" and \n RSTRN_DECLASS is \"MR\"\n",
                           Infname,GetECCCode(ECC),ECClabel,GetEACLabel(Ameta->codeindex),Ameta->strval);
                         InsertIntoGIFD_MetaData_ErrorList(messageline,entrycount);
                         }
                      }
                  else if(strcmp(codestring,"RD-CNWDI") == 0)
                      {
                      if((strcmp(Sec_Class_val,"TS") == 0) || (strcmp(Sec_Class_val,"S") == 0))
                         {
                         if(strcmp(Rstrn_Declass_val,"MR") == 0)
                            WriteTheError = 0;
                         else
                            {
                            WriteTheError = 1;
                            }
                         }
                      else
                         WriteTheError = 1;
                      if(WriteTheError > 0)
                         {
sprintf(messageline,"Layer Identifier %s: Feature %s (%s): Attribute RSTRN_DSEM_CTRL_IC (%s): value: %s assigned value can contain \"RD-CNWDI\" only when SEC_CLASS is \"TS\" or \"S\" and \n RSTRN_DECLASS is \"MR\"\n",
                           Infname,GetECCCode(ECC),ECClabel,GetEACLabel(Ameta->codeindex),Ameta->strval);
                         InsertIntoGIFD_MetaData_ErrorList(messageline,entrycount);
                         }
                      }
                  else if(strstr(codestring,"RD-SIGMA") != NULL)
                      {
                      if((strcmp(Sec_Class_val,"TS") == 0) || (strcmp(Sec_Class_val,"S") == 0) || (strcmp(Sec_Class_val,"C") == 0))
                         {
                         if(strcmp(Rstrn_Declass_val,"MR") == 0)
                            WriteTheError = 0;
                         else
                            {
                            WriteTheError = 1;
                            }
                         }
                      else
                         WriteTheError = 1;
                      if(WriteTheError > 0)
                         {
sprintf(messageline,"Layer Identifier %s: Feature %s (%s): Attribute RSTRN_DSEM_CTRL_IC (%s): value: %s assigned value can contain \"RD-SIGMA##\" only when SEC_CLASS is \"TS\", \"S\", or \"C\" and \n RSTRN_DECLASS is \"MR\"\n",
                           Infname,GetECCCode(ECC),ECClabel,GetEACLabel(Ameta->codeindex),Ameta->strval);
                         InsertIntoGIFD_MetaData_ErrorList(messageline,entrycount);
                         }
                      }
                  else if(strcmp(codestring,"FRD") == 0)
                      {
                      if((strcmp(Sec_Class_val,"TS") == 0) || (strcmp(Sec_Class_val,"S") == 0) || (strcmp(Sec_Class_val,"C") == 0))
                         {
                         if(strcmp(Rstrn_Declass_val,"MR") == 0)
                            WriteTheError = 0;
                         else
                            {
                            WriteTheError = 1;
                            }
                         }
                      else
                         WriteTheError = 1;
                      if(WriteTheError > 0)
                         {
sprintf(messageline,"Layer Identifier %s: Feature %s (%s): Attribute RSTRN_DSEM_CTRL_IC (%s): value: %s assigned value can contain \"FRD\" only when SEC_CLASS is \"TS\", \"S\", or \"C\" and \n RSTRN_DECLASS is \"MR\"\n",
                           Infname,GetECCCode(ECC),ECClabel,GetEACLabel(Ameta->codeindex),Ameta->strval);
                         InsertIntoGIFD_MetaData_ErrorList(messageline,entrycount);
                         }
                      }
                  else if(strcmp(codestring,"FRD-CNWDI") == 0)
                      {
                      if((strcmp(Sec_Class_val,"TS") == 0) || (strcmp(Sec_Class_val,"S") == 0))
                         {
                         if(strcmp(Rstrn_Declass_val,"MR") == 0)
                            WriteTheError = 0;
                         else
                            {
                            WriteTheError = 1;
                            }
                         }
                      else
                         WriteTheError = 1;
                      if(WriteTheError > 0)
                         {
sprintf(messageline,"Layer Identifier %s: Feature %s (%s): Attribute RSTRN_DSEM_CTRL_IC (%s): value: %s assigned value can contain \"FRD-CNWDI\" only when SEC_CLASS is \"TS\" or \"S\" and \n RSTRN_DECLASS is \"MR\"\n",
                           Infname,GetECCCode(ECC),ECClabel,GetEACLabel(Ameta->codeindex),Ameta->strval);
                         InsertIntoGIFD_MetaData_ErrorList(messageline,entrycount);
                         }
                      }
                  else if(strstr(codestring,"FRD-SIGMA") != NULL)
                      {
                      if((strcmp(Sec_Class_val,"TS") == 0) || (strcmp(Sec_Class_val,"S") == 0) || (strcmp(Sec_Class_val,"C") == 0))
                         {
                         if(strcmp(Rstrn_Declass_val,"MR") == 0)
                            WriteTheError = 0;
                         else
                            {
                            WriteTheError = 1;
                            }
                         }
                      else
                         WriteTheError = 1;
                      if(WriteTheError > 0)
                         {
sprintf(messageline,"Layer Identifier %s: Feature %s (%s): Attribute RSTRN_DSEM_CTRL_IC (%s): value: %s assigned value can contain \"FRD-SIGMA##\" only when SEC_CLASS is \"TS\", \"S\", or \"C\" and \n RSTRN_DECLASS is \"MR\"\n",
                           Infname,GetECCCode(ECC),ECClabel,GetEACLabel(Ameta->codeindex),Ameta->strval);
                         InsertIntoGIFD_MetaData_ErrorList(messageline,entrycount);
                         }
                      }
                  else if(strcmp(codestring,"DOD UCNI") == 0)
                      {
                      if(strcmp(Sec_Class_val,"U") == 0)
                         WriteTheError = 0;
                      else
                         WriteTheError = 1;
                      if(WriteTheError > 0)
                         {
sprintf(messageline,"Layer Identifier %s: Feature %s (%s): Attribute RSTRN_DSEM_CTRL_IC (%s): value: %s assigned value can contain \"DOD UCNI\" only when SEC_CLASS is \"U\" \n",
                           Infname,GetECCCode(ECC),ECClabel,GetEACLabel(Ameta->codeindex),Ameta->strval);
                         InsertIntoGIFD_MetaData_ErrorList(messageline,entrycount);
                         }
                      }
                  else if(strcmp(codestring,"DOE UCNI") == 0)
                      {
                      if(strcmp(Sec_Class_val,"U") == 0)
                         WriteTheError = 0;
                      else
                         WriteTheError = 1;
                      if(WriteTheError > 0)
                         {
sprintf(messageline,"Layer Identifier %s: Feature %s (%s): Attribute RSTRN_DSEM_CTRL_IC (%s): value: %s assigned value can contain \"DOE UCNI\" only when SEC_CLASS is \"U\" \n",
                           Infname,GetECCCode(ECC),ECClabel,GetEACLabel(Ameta->codeindex),Ameta->strval);
                         InsertIntoGIFD_MetaData_ErrorList(messageline,entrycount);
                         }
                      }
                  else if(strcmp(codestring,"LAC") == 0)
                      {
                      if((strcmp(Sec_Class_val,"TS") == 0) || (strcmp(Sec_Class_val,"S") == 0) || (strcmp(Sec_Class_val,"C") == 0))
                         {
                         if(strstr(Sec_CD_Cntrl_val,"SI") != NULL)
                            WriteTheError = 0; 
                         else
                            {
                            WriteTheError = 1;
                            }
                         }
                      else
                         WriteTheError = 1;
                      if(WriteTheError > 0) 
                         {
sprintf(messageline,"Layer Identifier %s: Feature %s (%s): Attribute RSTRN_DSEM_CTRL_IC (%s): value: %s assigned value can contain \"LAC\" only when SEC_CLASS is \"TS\", \"S\", or \"C\" and SEC_CD_CNTRL contains \"SI\"\n",
                           Infname,GetECCCode(ECC),ECClabel,GetEACLabel(Ameta->codeindex),Ameta->strval);
                         InsertIntoGIFD_MetaData_ErrorList(messageline,entrycount);
                         }
                      }
                  else if(strcmp(codestring,"KILT") == 0)
                      {
                      if((strcmp(Sec_Class_val,"TS") == 0) || (strcmp(Sec_Class_val,"S") == 0) || (strcmp(Sec_Class_val,"C") == 0))
                         {
                         if(strstr(Sec_CD_Cntrl_val,"SI") != NULL)
                            WriteTheError = 0;
                         else
                            {
                            WriteTheError = 1;
                            }
                         }
                      else
                         WriteTheError = 1;
                      if(WriteTheError > 0)
                         {
sprintf(messageline,"Layer Identifier %s: Feature %s (%s): Attribute RSTRN_DSEM_CTRL_IC (%s): value: %s assigned value can contain \"KILT\" only when SEC_CLASS is \"TS\", \"S\", or \"C\" and SEC_CD_CNTRL contains \"SI\"\n",
                           Infname,GetECCCode(ECC),ECClabel,GetEACLabel(Ameta->codeindex),Ameta->strval);
                         InsertIntoGIFD_MetaData_ErrorList(messageline,entrycount);
                         }
                      }
                  else if(strcmp(codestring,"M") == 0)
                      {
                      if((strcmp(Sec_Class_val,"TS") == 0) || (strcmp(Sec_Class_val,"S") == 0))
                         {
                         if(strstr(Sec_CD_Cntrl_val,"SI") != NULL)
                            WriteTheError = 0;
                         else
                            {
                            WriteTheError = 1;
                            }
                         }
                      else
                         WriteTheError = 1;
                      if(WriteTheError > 0)
                         {
sprintf(messageline,"Layer Identifier %s: Feature %s (%s): Attribute RSTRN_DSEM_CTRL_IC (%s): value: %s assigned value can contain \"M\" only when SEC_CLASS is \"TS\" or \"S\" and SEC_CD_CNTRL contains \"SI\"\n",
                           Infname,GetECCCode(ECC),ECClabel,GetEACLabel(Ameta->codeindex),Ameta->strval);
                         InsertIntoGIFD_MetaData_ErrorList(messageline,entrycount);
                         }
                      }
                  else if(strcmp(codestring,"DSEN") == 0)
                      {
                      if(strcmp(Sec_Class_val,"U") == 0)
                         WriteTheError = 0;
                      else
                         WriteTheError = 1;
                      if(WriteTheError > 0)
                         {
sprintf(messageline,"Layer Identifier %s: Feature %s (%s): Attribute RSTRN_DSEM_CTRL_IC (%s): value: %s assigned value can contain \"DSEN\" only when SEC_CLASS is \"U\" \n",
                           Infname,GetECCCode(ECC),ECClabel,GetEACLabel(Ameta->codeindex),Ameta->strval);
                         InsertIntoGIFD_MetaData_ErrorList(messageline,entrycount);
                         }
                      }
                  else
                      {
                      WriteTheError = 1;
sprintf(messageline,"Layer Identifier %s: Feature %s (%s): Attribute RSTRN_DSEM_CTRL_IC (%s): value: %s assigned value is not an allowable value\n",
                           Infname,GetECCCode(ECC),ECClabel,GetEACLabel(Ameta->codeindex),Ameta->strval);
                         InsertIntoGIFD_MetaData_ErrorList(messageline,entrycount);
                      }


                  if(enumcodestring[ii] == ',')
                     ++ii;
                  }
               }
            break;

         case 17: /*** RSTRN_DSEM_CTRL_NIC ***/
            Ap = NGAmetaRoot->attr;
            while(Ap != NULL)
               {
               if(Ap->codeindex == Indices[25]) /*** for SEC_CLASS ***/
                  break;
               Ap = Ap->next;
               }
            if(Ap == NULL)
               {
               printf("could not find metadata entry for spec SEC_CLASS for use with attribute RSTRN_DSEM_CTRL_NIC\n");
               exit(-1);
               }
            if(Ap->present == 'Y')
               strcpy(Sec_Class_val, GetEECode(Ap->codeindex, Ap->intval));
            else
               Sec_Class_val[0] = '\0';
            if((UseNUNANPO > 0) && (strcmp(Sec_Class_val,"N_P") == 0))
               Sec_Class_val[0] = '\0';

            NoPopulate = 0;
            if(Ameta->strval == NULL)
               slen = 0;
            else
               slen = strlen(Ameta->strval);
            if(slen == 0)
               NoPopulate = 1;
            else if((UseNUNANPO > 0) && (strcmp(Ameta->strval,"N_P") == 0))
               NoPopulate = 1;

            if(NoPopulate == 0)
               { 
               ii = 0;
               while(ii < slen)
                  {
                  j = 0;
                  while((Ameta->strval[ii] != ',') && (ii < slen))
                     {
                     if(Ameta->strval[ii] == '"')
                        ++ii;
                     else
                        {
                        codestring[j] = Ameta->strval[ii];
                        ++ii;
                        ++j;
                        codestring[j] = '\0';
                        }
                     }

                  WriteTheError = 0;
                  if(strcmp(codestring,"SPECAT") == 0)
                      {
                      if((strcmp(Sec_Class_val,"TS") == 0) || (strcmp(Sec_Class_val,"S") == 0)|| (strcmp(Sec_Class_val,"C") == 0))
                         {
                         WriteTheError = 0;
                         }
                      else
                         WriteTheError = 1;
                      if(WriteTheError > 0)
                         {
sprintf(messageline,"Layer Identifier %s: Feature %s (%s): Attribute RSTRN_DSEM_CTRL_NIC (%s): value: %s assigned value can contain \"SPECAT\" only when SEC_CLASS is \"TS\", \"S\", or \"C\"\n",
                           Infname,GetECCCode(ECC),ECClabel,GetEACLabel(Ameta->codeindex),Ameta->strval);
                         InsertIntoGIFD_MetaData_ErrorList(messageline,entrycount);
                         }
                      }
                  else if(strcmp(codestring,"SIOP-ESI") == 0)
                      {
                      if(strcmp(Sec_Class_val,"TS") == 0)
                         {
                         WriteTheError = 0;
                         }
                      else
                         WriteTheError = 1;
                      if(WriteTheError > 0)
                         {
sprintf(messageline,"Layer Identifier %s: Feature %s (%s): Attribute RSTRN_DSEM_CTRL_NIC (%s): value: %s assigned value can contain \"SIOP-ESI\" only when SEC_CLASS is \"TS\"\n",
                           Infname,GetECCCode(ECC),ECClabel,GetEACLabel(Ameta->codeindex),Ameta->strval);
                         InsertIntoGIFD_MetaData_ErrorList(messageline,entrycount);
                         }
                      }
                   else if(strstr(codestring,"SAR") != NULL)
                      {
                      WriteTheError = 0;
                      }
                  else if(strcmp(codestring,"SINFO") == 0)
                      {
                      if(strcmp(Sec_Class_val,"U") == 0)
                         {
                         WriteTheError = 0;
                         }
                      else
                         WriteTheError = 1;
                      if(WriteTheError > 0)
                         {
sprintf(messageline,"Layer Identifier %s: Feature %s (%s): Attribute RSTRN_DSEM_CTRL_NIC (%s): value: %s assigned value can contain \"SINFO\" only when SEC_CLASS is \"U\"\n",
                           Infname,GetECCCode(ECC),ECClabel,GetEACLabel(Ameta->codeindex),Ameta->strval);
                         InsertIntoGIFD_MetaData_ErrorList(messageline,entrycount);
                         }
                      }
                  else if(strcmp(codestring,"LIMDIS") == 0)
                      {
                      if(strcmp(Sec_Class_val,"U") == 0) 
                         {
                         WriteTheError = 0;
                         }
                      else
                         WriteTheError = 1;
                      if(WriteTheError > 0)
                         {
sprintf(messageline,"Layer Identifier %s: Feature %s (%s): Attribute RSTRN_DSEM_CTRL_NIC (%s): value: %s assigned value can contain \"LIMDIS\" only when SEC_CLASS is \"U\"\n",
                           Infname,GetECCCode(ECC),ECClabel,GetEACLabel(Ameta->codeindex),Ameta->strval);
                         InsertIntoGIFD_MetaData_ErrorList(messageline,entrycount);
                         }
                      }
                  else if(strcmp(codestring,"SBU") == 0)
                      {
                      if(strcmp(Sec_Class_val,"U") == 0) 
                         {
                         WriteTheError = 0;
                         }
                      else
                         WriteTheError = 1;
                      if(WriteTheError > 0)
                         {
sprintf(messageline,"Layer Identifier %s: Feature %s (%s): Attribute RSTRN_DSEM_CTRL_NIC (%s): value: %s assigned value can contain \"SBU\" only when SEC_CLASS is \"U\"\n",
                           Infname,GetECCCode(ECC),ECClabel,GetEACLabel(Ameta->codeindex),Ameta->strval);
                      InsertIntoGIFD_MetaData_ErrorList(messageline,entrycount);
                         }
                      }
                  else if(strcmp(codestring,"SBU NOFORN") == 0)
                      {
                      if(strcmp(Sec_Class_val,"U") == 0)
                         {
                         WriteTheError = 0;
                         }
                      else
                         WriteTheError = 1;
                      if(WriteTheError > 0)
                         {
sprintf(messageline,"Layer Identifier %s: Feature %s (%s): Attribute RSTRN_DSEM_CTRL_NIC (%s): value: %s assigned value can contain \"SBU NOFORN\" only when SEC_CLASS is \"U\"\n",
                           Infname,GetECCCode(ECC),ECClabel,GetEACLabel(Ameta->codeindex),Ameta->strval);
                      InsertIntoGIFD_MetaData_ErrorList(messageline,entrycount);
                         }
                      }
                  else
                      {
                      WriteTheError = 1;
sprintf(messageline,"Layer Identifier %s: Feature %s (%s): Attribute RSTRN_DSEM_CTRL_NIC (%s): value: %s assigned value %s is not an allowable value\n",
                           Infname,GetECCCode(ECC),ECClabel,GetEACLabel(Ameta->codeindex),Ameta->strval,codestring);
                      InsertIntoGIFD_MetaData_ErrorList(messageline,entrycount);
                      }

                  if(Ameta->strval[ii] == ',')
                     ++ii;
                  }
               }
            break;

         case 18: /*** RSTRN_FOREIGN_GOV ***/
            Ap = NGAmetaRoot->attr;
            while(Ap != NULL)
               {
               if(Ap->codeindex == Indices[25]) /*** for SEC_CLASS ***/
                  break;
               Ap = Ap->next;
               }
            if(Ap == NULL)
               {
               printf("could not find metadata entry for spec SEC_CLASS for use with attribute RSTRN_FOREIGN_GOV\n");
               exit(-1);
               }
            if(Ap->present == 'Y')
               strcpy(Sec_Class_val, GetEECode(Ap->codeindex, Ap->intval));
            else
               Sec_Class_val[0] = '\0';

            if((UseNUNANPO > 0) && (strcmp(Sec_Class_val,"N_P") == 0))
               Sec_Class_val[0] = '\0';


            Ap = NGAmetaRoot->attr;
            while(Ap != NULL)
               {
               if(Ap->codeindex == Indices[14]) /*** for RSTRN_DCLS_XMPT_CD ***/
                  break;
               Ap = Ap->next;
               }
            if(Ap == NULL)
               {
               printf("could not find metadata entry for spec SEC_CLASS for use with attribute RSTRN_FOREIGN_GOV\n");
               exit(-1);
               }
            if(Ap->present == 'Y')
               strcpy(Rstrn_Declass_val, Ap->strval); 
            else
               Rstrn_Declass_val[0] = '\0';

            if((UseNUNANPO > 0) && (strcmp(Rstrn_Declass_val,"N_P") == 0))
               Rstrn_Declass_val[0] = '\0';


            if(Ameta->present == 'Y')
               strcpy(enumcodestring,Ameta->strval);
            else
               enumcodestring[0] = '\0';

            NoPopulate = 0;
            slen = strlen(enumcodestring);
            if(slen == 0)
               NoPopulate = 1;
            else if((UseNUNANPO > 0) && (strcmp(Ameta->strval,"N_P") == 0))
               NoPopulate = 1;

            if(NoPopulate == 0)
               {
               ii = 0;
               while(enumcodestring[ii] <= 32)
                  ++ii;
               if((enumcodestring[ii] == 'F') && (enumcodestring[ii+1] == 'G') && (enumcodestring[ii+2] == 'I'))
                  WriteTheError = 0;
               else
                  {
                  WriteTheError = 1;
sprintf(messageline,"Layer Identifier %s: Feature %s (%s): Attribute RSTRN_FOREIGN_GOV (%s): value: %s assigned value must begin with \"FGI\" \n",
                           Infname,GetECCCode(ECC),ECClabel,GetEACLabel(Ameta->codeindex),Ameta->strval);
                  InsertIntoGIFD_MetaData_ErrorList(messageline,entrycount);
                  }

               if((strcmp(Sec_Class_val,"TS") == 0) || (strcmp(Sec_Class_val,"S") == 0) || (strcmp(Sec_Class_val,"C") == 0))
                  {
                  WriteTheError = 0;
                  }
               else
                  {
                  WriteTheError = 1;
sprintf(messageline,"Layer Identifier %s: Feature %s (%s): Attribute RSTRN_FOREIGN_GOV (%s): value: %s  attribute can only be populated when SEC_CLASS is \"TS\", \"S\", or \"C\"\n",
                           Infname,GetECCCode(ECC),ECClabel,GetEACLabel(Ameta->codeindex),Ameta->strval);
                  InsertIntoGIFD_MetaData_ErrorList(messageline,entrycount);
                  }
               if(strcmp(Rstrn_Declass_val,"X5") == 0)
                  {
                  WriteTheError = 0;
                  }
               else
                  {
                  WriteTheError = 1;
sprintf(messageline,"Layer Identifier %s: Feature %s (%s): Attribute RSTRN_FOREIGN_GOV (%s): value: %s  attribute can only be populated when RSTRN_DCLS_XMPT_CD is \"X5\"\n",
                           Infname,GetECCCode(ECC),ECClabel,GetEACLabel(Ameta->codeindex),Ameta->strval);
                  InsertIntoGIFD_MetaData_ErrorList(messageline,entrycount);
                  }


               }
            break;

         case 19: /*** RSTRN_RELEASIBILITY ***/
            Ap = NGAmetaRoot->attr;
            while(Ap != NULL)
               {
               if(Ap->codeindex == Indices[25]) /*** for SEC_CLASS ***/
                  break;
               Ap = Ap->next;
               }
            if(Ap == NULL)
               {
               printf("could not find metadata entry for spec SEC_CLASS for use with attribute RSTRN_RELEASIBILITY\n");
               exit(-1);
               }
            if(Ap->present == 'Y')
               strcpy(Sec_Class_val, GetEECode(Ap->codeindex, Ap->intval));
            else
               Sec_Class_val[0] = '\0';

            if((UseNUNANPO > 0) && (strcmp(Sec_Class_val,"N_P") == 0))
               Sec_Class_val[0] = '\0';


            Ap = NGAmetaRoot->attr;
            while(Ap != NULL)
               {
               if(Ap->codeindex == Indices[16]) /*** for RSTRN_DSEM_CTRL_IC ***/
                  break;
               Ap = Ap->next;
               }
            if(Ap == NULL)
               {
               printf("could not find metadata entry for spec SEC_CLASS for use with attribute RSTRN_RELEASIBILITY\n");
               exit(-1);
               }
            if(Ap->present == 'Y')
               strcpy(Rstrn_Declass_val, Ap->strval);
            else
               Rstrn_Declass_val[0] = '\0';

            if((UseNUNANPO > 0) && (strcmp(Rstrn_Declass_val,"N_P") == 0))
               Rstrn_Declass_val[0] = '\0';


            if(Ameta->present == 'Y')
               strcpy(enumcodestring,Ameta->strval);
            else
               enumcodestring[0] = '\0';

            NoPopulate = 0;
            slen = strlen(enumcodestring);
            if(slen == 0)
               NoPopulate = 1;
            else if((UseNUNANPO > 0) && (strcmp(Ameta->strval,"N_P") == 0))
               NoPopulate = 1;

            if(NoPopulate == 0)
               {
               ii = 0;
               while(enumcodestring[ii] <= 32)
                  ++ii;
               if((enumcodestring[ii] == 'U') && (enumcodestring[ii+1] == 'S') && (enumcodestring[ii+2] == 'A'))
                  WriteTheError = 0;
               else
                  {
                  WriteTheError = 1;
sprintf(messageline,"Layer Identifier %s: Feature %s (%s): Attribute RSTRN_FOREIGN_GOV (%s): value: %s assigned value must begin with \"USA\" \n",
                           Infname,GetECCCode(ECC),ECClabel,GetEACLabel(Ameta->codeindex),Ameta->strval);
                  InsertIntoGIFD_MetaData_ErrorList(messageline,entrycount);
                  }

               if(strstr(enumcodestring,"REL TO") != NULL)
                  {
                  WriteTheError = 1;
sprintf(messageline,"Layer Identifier %s: Feature %s (%s): Attribute RSTRN_FOREIGN_GOV (%s): value: %s attribute may not contain the string \"REL TO\"\n",
                           Infname,GetECCCode(ECC),ECClabel,GetEACLabel(Ameta->codeindex),Ameta->strval);
                  InsertIntoGIFD_MetaData_ErrorList(messageline,entrycount);
                  }
               else
                  WriteTheError = 0;

               if((strcmp(Sec_Class_val,"TS") == 0) || (strcmp(Sec_Class_val,"S") == 0) || (strcmp(Sec_Class_val,"C") == 0))
                  {
                  WriteTheError = 0;
                  }
               else
                  {
                  WriteTheError = 1;
sprintf(messageline,"Layer Identifier %s: Feature %s (%s): Attribute RSTRN_FOREIGN_GOV (%s): value: %s attribute can only be populated when SEC_CLASS is \"TS\", \"S\", or \"C\"\n",
                           Infname,GetECCCode(ECC),ECClabel,GetEACLabel(Ameta->codeindex),Ameta->strval);
                  InsertIntoGIFD_MetaData_ErrorList(messageline,entrycount);
                  }
               if(strstr(Rstrn_Declass_val,"IMCON") != NULL)
                  {
                  WriteTheError = 1;
sprintf(messageline,"Layer Identifier %s: Feature %s (%s): Attribute RSTRN_FOREIGN_GOV (%s): value: %s attribute may not be populated when attribute RSTRN_DSEM_CTRL_IC contains \"IMCON\"\n",
                           Infname,GetECCCode(ECC),ECClabel,GetEACLabel(Ameta->codeindex),Ameta->strval);
                  InsertIntoGIFD_MetaData_ErrorList(messageline,entrycount);
                  }
               if(strstr(Rstrn_Declass_val,"SAMI") != NULL)
                  {
                  WriteTheError = 1;
sprintf(messageline,"Layer Identifier %s: Feature %s (%s): Attribute RSTRN_FOREIGN_GOV (%s): value: %s  attribute may not be populated when attribute RSTRN_DSEM_CTRL_IC contains \"SAMI\"\n",
                           Infname,GetECCCode(ECC),ECClabel,GetEACLabel(Ameta->codeindex),Ameta->strval);
                  InsertIntoGIFD_MetaData_ErrorList(messageline,entrycount);
                  }
               if(strstr(Rstrn_Declass_val,"NOFORN") != NULL)
                  {
                  WriteTheError = 1;
sprintf(messageline,"Layer Identifier %s: Feature %s (%s): Attribute RSTRN_FOREIGN_GOV (%s): value: %s  attribute may not be populated when attribute RSTRN_DSEM_CTRL_IC contains \"NOFORN\"\n",
                           Infname,GetECCCode(ECC),ECClabel,GetEACLabel(Ameta->codeindex),Ameta->strval);
                  InsertIntoGIFD_MetaData_ErrorList(messageline,entrycount);
                  }
               }
            break;

         case 20: /*** SCALE ***/
            if(Ameta->present != 'Y') /*** did not find this required attr ***/
               {
               sprintf(messageline,"Layer Identifier %s: Feature %s (%s): Attribute SCALE (%s): required metadata attribute not present\n",
                           Infname,GetECCCode(ECC),ECClabel,GetEACLabel(Ameta->codeindex));
               InsertIntoGIFD_MetaData_ErrorList(messageline,entrycount);
               }
            else
               {
               if((Ameta->intval < 0) && (Ameta->intval > 2147483647))
                  {
sprintf(messageline,"Layer Identifier %s: Feature %s (%s): Attribute SCALE (%s): value %d out of allowed range\n",
                           Infname,GetECCCode(ECC),ECClabel,GetEACLabel(Ameta->codeindex),Ameta->intval);
                  InsertIntoGIFD_MetaData_ErrorList(messageline,entrycount);
                  }
               }

            break;

         case 21: /*** SEC_CLS_AUTHORITY ***/
            Ap = NGAmetaRoot->attr;
            while(Ap != NULL)
               {
               if(Ap->codeindex == Indices[25]) /*** for SEC_CLASS ***/
                  break;
               Ap = Ap->next;
               }
            if(Ap == NULL)
               {
               printf("could not find metadata entry for spec SEC_CLASS for use with attribute SEC_CLS_AUTHORITY\n");
               exit(-1);
               }
    
            if(Ap->present == 'Y')
               strcpy(Sec_Class_val, GetEECode(Ap->codeindex, Ap->intval));
            else
               Sec_Class_val[0] = '\0';

            NoPopulate = 0;
            if(strcmp(Sec_Class_val,"U") == 0)
               NoPopulate = 1;

               
            if(NoPopulate == 0)
               {
               if(Ameta != NULL)
                  {
                  pc = Ameta->picks;

                  if(Ameta->present == 'Y')
                     strcpy(enumcodestring,Ameta->strval);
                  else
                     enumcodestring[0] = '\0';


                  if(Ap->present == 'Y')
                     {
                     while(pc != NULL)
                        {
                        if(strcmp(enumcodestring,pc->code) == 0)
                           break;
                        pc = pc->next;
                        }
                     if((Ameta->present == 'Y') && (pc == NULL))
                        {
                        WriteTheError = IsNUNANPOString(enumcodestring,Ameta->NGAdatatype,Ameta->varchar,Ameta->maxstrlen);
                        if(UseNUNANPO > 0)
                           {
                           if(Ameta->NGAdatatype == 2) /*** short int type ***/
                              {
                              if(strcmp(enumcodestring,"-32768") == 0)
                                 WriteTheError = 0;
                              else if (strcmp(enumcodestring,"0") == 0)
                                 WriteTheError = 0;
                              else if(strcmp(enumcodestring,"997") == 0)
                                 WriteTheError = 0;
                              else if(strcmp(enumcodestring,"998") == 0)
                                 WriteTheError = 0;
                              else if(strcmp(enumcodestring,"999") == 0)
                                 WriteTheError = 0;
                              else
                                 WriteTheError = 1;
                              }
                           }
                        if(WriteTheError > 0)
                           {
sprintf(messageline,"Layer Identifier %s: Feature %s (%s): Attribute SEC_CLS_AUTHORITY (%s): has invalid pick list value: %s\n",
                           Infname,GetECCCode(ECC),ECClabel,GetEACLabel(Ameta->codeindex),enumcodestring);
                           InsertIntoGIFD_MetaData_ErrorList(messageline,entrycount);
                           }
                        }
                     else if(Ameta->present != 'Y')
                        {
sprintf(messageline,"Layer Identifier %s: Feature %s (%s): Attribute SEC_CLS_AUTHORITY (%s): SEC_CLASS has value \"%s\" and attribute SEC_CLS_AUTHORITY (%s) is not assigned\n",
                           Infname,GetECCCode(ECC),ECClabel,GetEACLabel(Ameta->codeindex),Sec_Class_val,GetEACLabel(Ameta->codeindex));
                        InsertIntoGIFD_MetaData_ErrorList(messageline,entrycount);
                        }
                     }
                  }
               }
            else
               {
               if(Ameta->present == 'Y')
                  {
                  seemsbad = 1;
                  if(Ameta->strval[0] == '\0')
                     seemsbad = 0;
                  else if((Ameta->strval[0] == '"') && (Ameta->strval[1] == '"') && (Ameta->strval[2] == '\0'))
                     seemsbad = 0;
                  if(seemsbad > 0)
                     {
                     sprintf(messageline,"Layer Identifier %s: Feature %s (%s): Attribute SEC_CLS_AUTHORITY (%s): is to be left unpopulated when SEC_CLASS is \"U\"\n",
                           Infname,GetECCCode(ECC),ECClabel,GetEACLabel(Ameta->codeindex));
                     InsertIntoGIFD_MetaData_ErrorList(messageline,entrycount);
                     }
                  }

               }
            break;

         case 22: /*** SEC_CLS_AUTH_DESC ***/
            Ap = NGAmetaRoot->attr;
            while(Ap != NULL)
               {
               if(Ap->codeindex == Indices[21]) /*** for SEC_CLS_AUTHORITY ***/
                  break;
               Ap = Ap->next;
               }
            if(Ap == NULL)
               {
               printf("could not find metadata entry for spec SEC_CLASS for use with attribute SEC_CLS_AUTH_DESC\n");
               exit(-1);
               }
            if(Ap->present == 'Y')
               strcpy(Sec_Class_val, GetEECode(Ap->codeindex, Ap->intval));
            else
               Sec_Class_val[0] = '\0';


            NoPopulate = 0;
            if((strcmp(Sec_Class_val,"O") == 0) && (Ameta->present != 'Y')) /*** did not find this required attr ***/
                  {
                  sprintf(messageline,"Layer Identifier %s: Feature %s (%s): Attribute SEC_CLS_AUTH_DESC (%s): is required when SEC_CLS_AUTHORITY is \"O\"\n",
                           Infname,GetECCCode(ECC),ECClabel,GetEACLabel(Ameta->codeindex));
                  InsertIntoGIFD_MetaData_ErrorList(messageline,entrycount);
                  }
            break;

         case 23: /*** SEC_CLS_AUTH_MULT ***/
            Ap = NGAmetaRoot->attr;
            while(Ap != NULL)
               {
               if(Ap->codeindex == Indices[21]) /*** for SEC_CLS_AUTHORITY ***/
                  break;
               Ap = Ap->next;
               }
            if(Ap == NULL)
               {
               printf("could not find metadata entry for spec SEC_CLASS for use with attribute SEC_CLS_AUTH_MULT\n");
               exit(-1);
               }
            if(Ap->present == 'Y')
               strcpy(Sec_Class_val, GetEECode(Ap->codeindex, Ap->intval));
            else
               Sec_Class_val[0] = '\0';

            NoPopulate = 0;
            if((strcmp(Sec_Class_val,"M") == 0) && (Ameta->present != 'Y')) /*** did not find this required attr ***/
                  {
                  sprintf(messageline,"Layer Identifier %s: Feature %s (%s): Attribute SEC_CLS_AUTH_MULT (%s): is required when SEC_CLS_AUTHORITY is \"M\"\n",
                           Infname,GetECCCode(ECC),ECClabel,GetEACLabel(Ameta->codeindex));
                  InsertIntoGIFD_MetaData_ErrorList(messageline,entrycount);
                  }
            break;



         default:
            break;
            
         }  /** end switch(i) ***/
      }
}




int StrIsNumber(char *str_in, double *dbl_val)
{
int i, sl,j,k;
int answer;
int numdecimal, numminus, numdigits, onquote;
double retval;


   answer = 0;
   numdecimal = 0;
   numdigits = 0;
   numminus = 0;
   onquote = 0;

   sl = strlen(str_in);
   if(str_in[0] == '"')
      j = 1;
   else
      j = 0;
   if(str_in[sl-1] == '"')
      k = sl - 2;
   else
      k = sl - 1;

   if((j == 0) && (k == 0) && (str_in[0] >= '0') && (str_in[0] <= '9'))
      {
      numdigits = 1;
      }
   else
      {
      for(i=j; i<k; i++)
         {
         if((str_in[i] < '0') || (str_in[i] > '9'))
            {
            if((str_in[i] != '.') && (str_in[i] != '-'))
               {
               break;
               }
            else
               {
               if(str_in[i] == '.')
                  ++numdecimal;
               else if(str_in[i] == '-')
                  {
                  if((i ==0) || ((onquote == 1) && (i == 1)))
                     ++numminus;
                  else
                     numminus += 100;
                  }
               }
            }
         else
            ++numdigits;
         }
      }
   if((i >= k) && (numdigits > 0) && (numdecimal <= 1) && (numminus <= 1))
      {
      sscanf(&str_in[j],"%lf",&retval);
      *dbl_val = retval;
      answer = 1;
      }

   return(answer);
}

void FreeNotEqualEnums(void)
{
int i;


   for(i= 0; i<TDS_MultiAttr; i++)
      {
      if(ValueSets[i].vc1 != NULL)
         {
         free(ValueSets[i].vc1);
         ValueSets[i].vc1 = NULL;
         }
      if(ValueSets[i].vc2 != NULL)
         {
         free(ValueSets[i].vc2);
         ValueSets[i].vc2 = NULL;
         }
      if(ValueSets[i].vc3 != NULL)
         {
         free(ValueSets[i].vc3);
         ValueSets[i].vc3 = NULL;
         }
      if(ValueSets[i].vc4 != NULL)
         {
         free(ValueSets[i].vc4);
         ValueSets[i].vc4 = NULL;
         }
      }

}


void AddToValueSets(int ECC, char seeitgeom, int EAC, char *enumcodestring)
{
int i, limit;

   limit = 0;

   if(ATTRTYPE_TDS4() > 0)
      {
      limit = TDS4_MultiAttr;
      }
   else if(ATTRTYPE_TDS6() > 0)
      {
      limit = TDS6_MultiAttr;
      }
   else if(ATTRTYPE_GGDM21() > 0)
      {
      limit = GGDM_21_MultiAttr;
      }
   else if(ATTRTYPE_GGDM22() > 0)
      {
      limit = GGDM_22_MultiAttr;
      }
   else if(ATTRTYPE_GGDM3() > 0)
      {
      limit = GGDM_3_MultiAttr;
      }

   for(i=0; i<limit; i++)
      {
      if((ValueSets[i].ac1 == EAC) || (ValueSets[i].ac2 == EAC) || (ValueSets[i].ac3 == EAC))
         {
         if(strcmp(enumcodestring,ValueSets[i].exclude) != 0) /*** if the value for LTDS is -999999, multiple are OK ***/
            {
            ValueSets[i].fcode = ECC;
            ValueSets[i].geom = seeitgeom;
            if(ValueSets[i].ac1 == EAC)
                {
                ValueSets[i].vc1 = (char *) (malloc(strlen(enumcodestring) + 1));
                strcpy(ValueSets[i].vc1,enumcodestring);
                }
            else if(ValueSets[i].ac2 == EAC)
                {
                ValueSets[i].vc2 = (char *) (malloc(strlen(enumcodestring) + 1));
                strcpy(ValueSets[i].vc2,enumcodestring);
                }
            else if(ValueSets[i].ac3 == EAC)
                {
                ValueSets[i].vc3 = (char *) (malloc(strlen(enumcodestring) + 1));
                strcpy(ValueSets[i].vc3,enumcodestring);
                }
            else if(ValueSets[i].ac4 == EAC)
                {
                ValueSets[i].vc4 = (char *) (malloc(strlen(enumcodestring) + 1));
                strcpy(ValueSets[i].vc4,enumcodestring);
                }
             }
         break;
         }
      }
}

int TestSACconversions(int i)
{
int answer = 1;
double temp;
   if(SAC_CONV[i].foundboth > 1)
      {
      if((SAC_CONV[i].val1 >= 0) || (SAC_CONV[i].val2 >= 0))
         {
         temp = SAC_CONV[i].val1 * SAC_CONV[i].convert1to2;
         temp = SAC_CONV[i].val2 - temp;
         if((temp < -0.1) || (temp > 0.1))
            answer = 0;
         }
      }

   return(answer);
}

void AddToSACconversions(int EAC, double value)
{
int i;
   for(i=0; i<6; i++)
      {
      if(SAC_CONV[i].acode1 == EAC)
         {
         SAC_CONV[i].val1 = value;
         SAC_CONV[i].foundboth += 1;
         break;
         }
      else if(SAC_CONV[i].acode2 == EAC)
         {
         SAC_CONV[i].val2 = value;
         SAC_CONV[i].foundboth += 1;
         break;
         }
      }
}

void ResetSACconversions(void)
{
int i;
   for(i=0; i<6; i++)
      {
      SAC_CONV[i].val1 = -999.0;
      SAC_CONV[i].val2 = -999.0;
      SAC_CONV[i].foundboth = 0;
      }
}

void InitializeSAC_StructText(void)
{
extern char *GetLongCode (int attr_type);

   SAC_CONV[0].acode1 = GetAttrIndex("HGF");
   SAC_CONV[0].acode2 = GetAttrIndex("HGT");
   SAC_CONV[0].convert1to2 = 0.3048; /*** 1 foot = 0.3048 meters, 1 meter = 3.2808 feet ****/
   SAC_CONV[1].acode1 = GetAttrIndex("DTF");
   SAC_CONV[1].acode2 = GetAttrIndex("DTM");
   SAC_CONV[1].convert1to2 = 0.3048; /*** 1 foot = 0.3048 meters, 1 meter = 3.2808 feet ****/
   SAC_CONV[2].acode1 = GetAttrIndex("LEF");
   SAC_CONV[2].acode2 = GetAttrIndex(GetLongCode(LONG_ATTR_LEN)); /** was GetAttrIndex("LEN");***/
   SAC_CONV[2].convert1to2 = 0.3048; /*** 1 foot = 0.3048 meters, 1 meter = 3.2808 feet ****/
   SAC_CONV[3].acode1 = GetAttrIndex("WGF");
   SAC_CONV[3].acode2 = GetAttrIndex("WGP");
   SAC_CONV[3].convert1to2 = 0.3048; /*** 1 foot = 0.3048 meters, 1 meter = 3.2808 feet ****/
   SAC_CONV[4].acode1 = GetAttrIndex("Z5F");
   SAC_CONV[4].acode2 = GetAttrIndex("Z5M");
   SAC_CONV[4].convert1to2 = 0.3048; /*** 1 foot = 0.3048 meters, 1 meter = 3.2808 feet ****/
   SAC_CONV[5].acode1 = GetAttrIndex("Z7F");
   SAC_CONV[5].acode2 = GetAttrIndex("ZV7");
   SAC_CONV[5].convert1to2 = 0.3048; /*** 1 foot = 0.3048 meters, 1 meter = 3.2808 feet ****/

   return;
}



void InitializeNotEqualEnums(void)
{
int i;


   for(i=0; i<TDS_MultiAttr; i++)
      {
      strcpy(ValueSets[i].exclude,"No Information");
      ValueSets[i].vc1 = NULL;
      ValueSets[i].vc2 = NULL;
      ValueSets[i].vc3 = NULL;
      ValueSets[i].vc4 = NULL;
      ValueSets[i].ac1 = -999;
      ValueSets[i].ac2 = -999;
      ValueSets[i].ac3 = -999;
      ValueSets[i].ac4 = -999;
      }

   if(ATTRTYPE_TDS4() > 0) 
      {
      ValueSets[0].ac1 = GetAttrIndex("AQO");
      ValueSets[0].ac2 = GetAttrIndex("AQO2");
      ValueSets[0].ac3 = GetAttrIndex("AQO3");
      ValueSets[1].ac1 = GetAttrIndex("ASU");
      ValueSets[1].ac2 = GetAttrIndex("ASU2");
      ValueSets[1].ac3 = GetAttrIndex("ASU3");
      ValueSets[2].ac1 = GetAttrIndex("AT005_CAB");
      ValueSets[2].ac2 = GetAttrIndex("AT005_CAB2");
      ValueSets[2].ac3 = GetAttrIndex("AT005_CAB3");
      ValueSets[3].ac1 = GetAttrIndex("BMC");
      ValueSets[3].ac2 = GetAttrIndex("BMC2");
      ValueSets[3].ac3 = GetAttrIndex("BMC3");
      ValueSets[4].ac1 = GetAttrIndex("BSC");
      ValueSets[4].ac2 = GetAttrIndex("BSC2");
      ValueSets[4].ac3 = GetAttrIndex("BSC3");
      ValueSets[5].ac1 = GetAttrIndex("CAB");
      ValueSets[5].ac2 = GetAttrIndex("CAB2");
      ValueSets[5].ac3 = GetAttrIndex("CAB3");
      ValueSets[6].ac1 = GetAttrIndex("CSC");
      ValueSets[6].ac2 = GetAttrIndex("CSC2");
      ValueSets[6].ac3 = GetAttrIndex("CSC3");
      ValueSets[7].ac1 = GetAttrIndex("FFN");
      ValueSets[7].ac2 = GetAttrIndex("FFN2");
      ValueSets[7].ac3 = GetAttrIndex("FFN3");
      ValueSets[8].ac1 = GetAttrIndex("FHC");
      ValueSets[8].ac2 = GetAttrIndex("FHC2");
      ValueSets[8].ac3 = GetAttrIndex("FHC3");
      ValueSets[9].ac1 = GetAttrIndex("FRT");
      ValueSets[9].ac2 = GetAttrIndex("FRT2");
      ValueSets[9].ac3 = GetAttrIndex("FRT3");
      ValueSets[10].ac1 = GetAttrIndex("HST");
      ValueSets[10].ac2 = GetAttrIndex("HST2");
      ValueSets[10].ac3 = GetAttrIndex("HST3");
      ValueSets[11].ac1 = GetAttrIndex("MCC");
      ValueSets[11].ac2 = GetAttrIndex("MCC2");
      ValueSets[11].ac3 = GetAttrIndex("MCC3");
      ValueSets[12].ac1 = GetAttrIndex("MST");
      ValueSets[12].ac2 = GetAttrIndex("MST2");
      ValueSets[12].ac3 = GetAttrIndex("MST3");
      ValueSets[13].ac1 = GetAttrIndex("PBY");
      ValueSets[13].ac2 = GetAttrIndex("PBY2");
      ValueSets[13].ac3 = GetAttrIndex("PBY3");
      ValueSets[14].ac1 = GetAttrIndex("POS");
      ValueSets[14].ac2 = GetAttrIndex("POS2");
      ValueSets[14].ac3 = GetAttrIndex("POS3");
      ValueSets[15].ac1 = GetAttrIndex("PPO");
      ValueSets[15].ac2 = GetAttrIndex("PPO2");
      ValueSets[15].ac3 = GetAttrIndex("PPO3");
      ValueSets[16].ac1 = GetAttrIndex("PRW");
      ValueSets[16].ac2 = GetAttrIndex("PRW2");
      ValueSets[16].ac3 = GetAttrIndex("PRW3");
      ValueSets[17].ac1 = GetAttrIndex("RRC");
      ValueSets[17].ac2 = GetAttrIndex("RRC2");
      ValueSets[17].ac3 = GetAttrIndex("RRC3");
      ValueSets[18].ac1 = GetAttrIndex("RTN");
      ValueSets[18].ac2 = GetAttrIndex("RTN2");
      ValueSets[18].ac3 = GetAttrIndex("RTN3");
      ValueSets[19].ac1 = GetAttrIndex("RTN_ROI");
      ValueSets[19].ac2 = GetAttrIndex("RTN_ROI2");
      ValueSets[19].ac3 = GetAttrIndex("RTN_ROI3");
      ValueSets[20].ac1 = GetAttrIndex("SBT");
      ValueSets[20].ac2 = GetAttrIndex("SBT2");
      ValueSets[20].ac3 = GetAttrIndex("SBT3");
      ValueSets[21].ac1 = GetAttrIndex("SSR");
      ValueSets[21].ac2 = GetAttrIndex("SSR2");
      ValueSets[21].ac3 = GetAttrIndex("SSR3");
      ValueSets[22].ac1 = GetAttrIndex("STL");
      ValueSets[22].ac2 = GetAttrIndex("STL2");
      ValueSets[22].ac3 = GetAttrIndex("STL3");
      ValueSets[23].ac1 = GetAttrIndex("TRS");
      ValueSets[23].ac2 = GetAttrIndex("TRS2");
      ValueSets[23].ac3 = GetAttrIndex("TRS3");
      ValueSets[24].ac1 = GetAttrIndex("TSM");
      ValueSets[24].ac2 = GetAttrIndex("TSM2");
      ValueSets[24].ac3 = GetAttrIndex("TSM3");
      ValueSets[25].ac1 = GetAttrIndex("TTC");
      ValueSets[25].ac2 = GetAttrIndex("TTC2");
      ValueSets[25].ac3 = GetAttrIndex("TTC3");
      ValueSets[26].ac1 = GetAttrIndex("UTY");
      ValueSets[26].ac2 = GetAttrIndex("UTY2");
      ValueSets[26].ac3 = GetAttrIndex("UTY3");
      ValueSets[27].ac1 = GetAttrIndex("VCA");
      ValueSets[27].ac2 = GetAttrIndex("VCA2");
      ValueSets[27].ac3 = GetAttrIndex("VCA3");
      ValueSets[28].ac1 = GetAttrIndex("VCM");
      ValueSets[28].ac2 = GetAttrIndex("VCM2");
      ValueSets[28].ac3 = GetAttrIndex("VCM3");
      ValueSets[29].ac1 = GetAttrIndex("VCT");
      ValueSets[29].ac2 = GetAttrIndex("VCT2");
      ValueSets[29].ac3 = GetAttrIndex("VCT3");
      ValueSets[30].ac1 = GetAttrIndex("VSP");
      ValueSets[30].ac2 = GetAttrIndex("VSP2");
      ValueSets[30].ac3 = GetAttrIndex("VSP3");
      ValueSets[31].ac1 = GetAttrIndex("WEQ");
      ValueSets[31].ac2 = GetAttrIndex("WEQ2");
      ValueSets[31].ac3 = GetAttrIndex("WEQ3");
      ValueSets[32].ac1 = GetAttrIndex("ZI013_CSP");
      ValueSets[32].ac2 = GetAttrIndex("ZI013_CSP2");
      ValueSets[32].ac3 = GetAttrIndex("ZI013_CSP3");
      ValueSets[33].ac1 = GetAttrIndex("ZI013_FFP");
      ValueSets[33].ac2 = GetAttrIndex("ZI013_FFP2");
      ValueSets[33].ac3 = GetAttrIndex("ZI013_FFP3");
      ValueSets[34].ac1 = GetAttrIndex("ZI013_FMM");
      ValueSets[34].ac2 = GetAttrIndex("ZI013_FMM2");
      ValueSets[34].ac3 = GetAttrIndex("ZI013_FMM3");
      ValueSets[35].ac1 = GetAttrIndex("ZI014_PBY");
      ValueSets[35].ac2 = GetAttrIndex("ZI014_PBY2");
      ValueSets[35].ac3 = GetAttrIndex("ZI014_PBY3");
      ValueSets[36].ac1 = GetAttrIndex("ZI014_PPO");
      ValueSets[36].ac2 = GetAttrIndex("ZI014_PPO2");
      ValueSets[36].ac3 = GetAttrIndex("ZI014_PPO3");
      ValueSets[37].ac1 = GetAttrIndex("ZI014_PRW");
      ValueSets[37].ac2 = GetAttrIndex("ZI014_PRW2");
      ValueSets[37].ac3 = GetAttrIndex("ZI014_PRW3");
      ValueSets[38].ac1 = GetAttrIndex("ZI019_ASP");
      ValueSets[38].ac2 = GetAttrIndex("ZI019_ASP2");
      ValueSets[38].ac3 = GetAttrIndex("ZI019_ASP3");
      ValueSets[39].ac1 = GetAttrIndex("ZI019_ASU");
      ValueSets[39].ac2 = GetAttrIndex("ZI019_ASU2");
      ValueSets[39].ac3 = GetAttrIndex("ZI019_ASU3");
      ValueSets[40].ac1 = GetAttrIndex("ZI071_FFN");
      ValueSets[40].ac2 = GetAttrIndex("ZI071_FFN2");
      ValueSets[40].ac3 = GetAttrIndex("ZI071_FFN3");
      }
   else if(ATTRTYPE_TDS6() > 0)
      {
      ValueSets[0].ac1 = GetAttrIndex("APT");
      ValueSets[0].ac2 = GetAttrIndex("APT2");
      ValueSets[0].ac3 = GetAttrIndex("APT3");
      ValueSets[1].ac1 = GetAttrIndex("APU");
      ValueSets[1].ac2 = GetAttrIndex("APU2");
      ValueSets[1].ac3 = GetAttrIndex("APU3");
      ValueSets[2].ac1 = GetAttrIndex("AQO");
      ValueSets[2].ac2 = GetAttrIndex("AQO2");
      ValueSets[2].ac3 = GetAttrIndex("AQO3");
      ValueSets[3].ac1 = GetAttrIndex("AQP");
      ValueSets[3].ac2 = GetAttrIndex("AQP2");
      ValueSets[3].ac3 = GetAttrIndex("AQP3");
      ValueSets[4].ac1 = GetAttrIndex("ASU");
      ValueSets[4].ac2 = GetAttrIndex("ASU2");
      ValueSets[4].ac3 = GetAttrIndex("ASU3");
      ValueSets[5].ac1 = GetAttrIndex("AT005_CAB");
      ValueSets[5].ac2 = GetAttrIndex("AT005_CAB2");
      ValueSets[5].ac3 = GetAttrIndex("AT005_CAB3");
      ValueSets[6].ac1 = GetAttrIndex("BMC");
      ValueSets[6].ac2 = GetAttrIndex("BMC2");
      ValueSets[6].ac3 = GetAttrIndex("BMC3");
      ValueSets[7].ac1 = GetAttrIndex("BSC");
      ValueSets[7].ac2 = GetAttrIndex("BSC2");
      ValueSets[7].ac3 = GetAttrIndex("BSC3");
      ValueSets[8].ac1 = GetAttrIndex("CAB");
      ValueSets[8].ac2 = GetAttrIndex("CAB2");
      ValueSets[8].ac3 = GetAttrIndex("CAB3");
      ValueSets[9].ac1 = GetAttrIndex("CSC");
      ValueSets[9].ac2 = GetAttrIndex("CSC2");
      ValueSets[9].ac3 = GetAttrIndex("CSC3");
      ValueSets[10].ac1 = GetAttrIndex("CVT");
      ValueSets[10].ac2 = GetAttrIndex("CVT2");
      ValueSets[10].ac3 = GetAttrIndex("CVT3");
      ValueSets[11].ac1 = GetAttrIndex("FFN");
      ValueSets[11].ac2 = GetAttrIndex("FFN2");
      ValueSets[11].ac3 = GetAttrIndex("FFN3");
      ValueSets[12].ac1 = GetAttrIndex("FHC");
      ValueSets[12].ac2 = GetAttrIndex("FHC2");
      ValueSets[12].ac3 = GetAttrIndex("FHC3");
      ValueSets[13].ac1 = GetAttrIndex("FRT");
      ValueSets[13].ac2 = GetAttrIndex("FRT2");
      ValueSets[13].ac3 = GetAttrIndex("FRT3");
      ValueSets[14].ac1 = GetAttrIndex("HST");
      ValueSets[14].ac2 = GetAttrIndex("HST2");
      ValueSets[14].ac3 = GetAttrIndex("HST3");
      ValueSets[15].ac1 = GetAttrIndex("MCC");
      ValueSets[15].ac2 = GetAttrIndex("MCC2");
      ValueSets[15].ac3 = GetAttrIndex("MCC3");
      ValueSets[16].ac1 = GetAttrIndex("MST");
      ValueSets[16].ac2 = GetAttrIndex("MST2");
      ValueSets[16].ac3 = GetAttrIndex("MST3");
      ValueSets[17].ac1 = GetAttrIndex("PBY");
      ValueSets[17].ac2 = GetAttrIndex("PBY2");
      ValueSets[17].ac3 = GetAttrIndex("PBY3");
      ValueSets[18].ac1 = GetAttrIndex("PLT");
      ValueSets[18].ac2 = GetAttrIndex("PLT2");
      ValueSets[18].ac3 = GetAttrIndex("PLT3");
      ValueSets[19].ac1 = GetAttrIndex("POS");
      ValueSets[19].ac2 = GetAttrIndex("POS2");
      ValueSets[19].ac3 = GetAttrIndex("POS3");
      ValueSets[20].ac1 = GetAttrIndex("PPO");
      ValueSets[20].ac2 = GetAttrIndex("PPO2");
      ValueSets[20].ac3 = GetAttrIndex("PPO3");
      ValueSets[21].ac1 = GetAttrIndex("PRW");
      ValueSets[21].ac2 = GetAttrIndex("PRW2");
      ValueSets[21].ac3 = GetAttrIndex("PRW3");
      ValueSets[22].ac1 = GetAttrIndex("RIN_ROI");
      ValueSets[22].ac2 = GetAttrIndex("RIN_ROI2");
      ValueSets[22].ac3 = GetAttrIndex("RIN_ROI3");
      ValueSets[23].ac1 = GetAttrIndex("RIN_RTN");
      ValueSets[23].ac2 = GetAttrIndex("RIN_RTN2");
      ValueSets[23].ac3 = GetAttrIndex("RIN_RTN3");
      ValueSets[24].ac1 = GetAttrIndex("RRC");
      ValueSets[24].ac2 = GetAttrIndex("RRC2");
      ValueSets[24].ac3 = GetAttrIndex("RRC3");
      ValueSets[25].ac1 = GetAttrIndex("RTN");
      ValueSets[25].ac2 = GetAttrIndex("RTN2");
      ValueSets[25].ac3 = GetAttrIndex("RTN3");
      ValueSets[26].ac1 = GetAttrIndex("SBT");
      ValueSets[26].ac2 = GetAttrIndex("SBT2");
      ValueSets[26].ac3 = GetAttrIndex("SBT3");
      ValueSets[27].ac1 = GetAttrIndex("SSR");
      ValueSets[27].ac2 = GetAttrIndex("SSR2");
      ValueSets[27].ac3 = GetAttrIndex("SSR3");
      ValueSets[28].ac1 = GetAttrIndex("STL");
      ValueSets[28].ac2 = GetAttrIndex("STL2");
      ValueSets[28].ac3 = GetAttrIndex("STL3");
      ValueSets[29].ac1 = GetAttrIndex("TRS");
      ValueSets[29].ac2 = GetAttrIndex("TRS2");
      ValueSets[29].ac3 = GetAttrIndex("TRS3");
      ValueSets[30].ac1 = GetAttrIndex("TSM");
      ValueSets[30].ac2 = GetAttrIndex("TSM2");
      ValueSets[30].ac3 = GetAttrIndex("TSM3");
      ValueSets[31].ac1 = GetAttrIndex("TTC");
      ValueSets[31].ac2 = GetAttrIndex("TTC2");
      ValueSets[31].ac3 = GetAttrIndex("TTC3");
      ValueSets[32].ac1 = GetAttrIndex("UTY");
      ValueSets[32].ac2 = GetAttrIndex("UTY2");
      ValueSets[32].ac3 = GetAttrIndex("UTY3");
      ValueSets[33].ac1 = GetAttrIndex("VCA");
      ValueSets[33].ac2 = GetAttrIndex("VCA2");
      ValueSets[33].ac3 = GetAttrIndex("VCA3");
      ValueSets[34].ac1 = GetAttrIndex("VCM");
      ValueSets[34].ac2 = GetAttrIndex("VCM2");
      ValueSets[34].ac3 = GetAttrIndex("VCM3");
      ValueSets[35].ac1 = GetAttrIndex("VCT");
      ValueSets[35].ac2 = GetAttrIndex("VCT2");
      ValueSets[35].ac3 = GetAttrIndex("VCT3");
      ValueSets[36].ac1 = GetAttrIndex("VSP");
      ValueSets[36].ac2 = GetAttrIndex("VSP2");
      ValueSets[36].ac3 = GetAttrIndex("VSP3");
      ValueSets[37].ac1 = GetAttrIndex("WEQ");
      ValueSets[37].ac2 = GetAttrIndex("WEQ2");
      ValueSets[37].ac3 = GetAttrIndex("WEQ3");
      ValueSets[38].ac1 = GetAttrIndex("ZI005_FNA");
      ValueSets[38].ac2 = GetAttrIndex("ZI005_FNA2");
      ValueSets[38].ac3 = GetAttrIndex("ZI005_FNA3");
      ValueSets[39].ac1 = GetAttrIndex("ZI005_NFN");
      ValueSets[39].ac2 = GetAttrIndex("ZI005_NFN2");
      ValueSets[39].ac3 = GetAttrIndex("ZI005_NFN3");
      ValueSets[40].ac1 = GetAttrIndex("ZI013_CSP");
      ValueSets[40].ac2 = GetAttrIndex("ZI013_CSP2");
      ValueSets[40].ac3 = GetAttrIndex("ZI013_CSP3");
      ValueSets[41].ac1 = GetAttrIndex("ZI013_FFP");
      ValueSets[41].ac2 = GetAttrIndex("ZI013_FFP2");
      ValueSets[41].ac3 = GetAttrIndex("ZI013_FFP3");
      ValueSets[42].ac1 = GetAttrIndex("ZI013_FMM");
      ValueSets[42].ac2 = GetAttrIndex("ZI013_FMM2");
      ValueSets[42].ac3 = GetAttrIndex("ZI013_FMM3");
      ValueSets[43].ac1 = GetAttrIndex("ZI014_PBY");
      ValueSets[43].ac2 = GetAttrIndex("ZI014_PBY2");
      ValueSets[43].ac3 = GetAttrIndex("ZI014_PBY3");
      ValueSets[44].ac1 = GetAttrIndex("ZI014_PPO");
      ValueSets[44].ac2 = GetAttrIndex("ZI014_PPO2");
      ValueSets[44].ac3 = GetAttrIndex("ZI014_PPO3");
      ValueSets[45].ac1 = GetAttrIndex("ZI014_PRW");
      ValueSets[45].ac2 = GetAttrIndex("ZI014_PRW2");
      ValueSets[45].ac3 = GetAttrIndex("ZI014_PRW3");
      ValueSets[46].ac1 = GetAttrIndex("ZI019_ASP");
      ValueSets[46].ac2 = GetAttrIndex("ZI019_ASP2");
      ValueSets[46].ac3 = GetAttrIndex("ZI019_ASP3");
      ValueSets[47].ac1 = GetAttrIndex("ZI019_ASU");
      ValueSets[47].ac2 = GetAttrIndex("ZI019_ASU2");
      ValueSets[47].ac3 = GetAttrIndex("ZI019_ASU3");
      ValueSets[48].ac1 = GetAttrIndex("ZI020_GE4");
      ValueSets[48].ac2 = GetAttrIndex("ZI020_GE42");
      ValueSets[48].ac3 = GetAttrIndex("ZI020_GE43");
      ValueSets[48].ac4 = GetAttrIndex("ZI020_GE44");
      ValueSets[49].ac1 = GetAttrIndex("ZI071_FFN");
      ValueSets[49].ac2 = GetAttrIndex("ZI071_FFN2");
      ValueSets[49].ac3 = GetAttrIndex("ZI071_FFN3");
      }
   else if(ATTRTYPE_GGDM21() > 0) /*** GGDM v2.1****/
      {
      ValueSets[0].ac1 = GetAttrIndex("APT");
      ValueSets[0].ac2 = GetAttrIndex("APT2");
      ValueSets[0].ac3 = GetAttrIndex("APT3");
      ValueSets[1].ac1 = GetAttrIndex("AQO");
      ValueSets[1].ac2 = GetAttrIndex("AQO2");
      ValueSets[1].ac3 = GetAttrIndex("AQO3");
      ValueSets[2].ac1 = GetAttrIndex("ASU");
      ValueSets[2].ac2 = GetAttrIndex("ASU2");
      ValueSets[2].ac3 = GetAttrIndex("ASU3");
      ValueSets[3].ac1 = GetAttrIndex("AT005_CAB");
      ValueSets[3].ac2 = GetAttrIndex("AT005_CAB2");
      ValueSets[3].ac3 = GetAttrIndex("AT005_CAB3");
      ValueSets[4].ac1 = GetAttrIndex("BBMCA");
      ValueSets[4].ac2 = GetAttrIndex("BBMCA2");
      ValueSets[4].ac3 = GetAttrIndex("BBMCA3");
      ValueSets[5].ac1 = GetAttrIndex("BBMCB");
      ValueSets[5].ac2 = GetAttrIndex("BBMCB2");
      ValueSets[5].ac3 = GetAttrIndex("BBMCB3");
      ValueSets[6].ac1 = GetAttrIndex("BC034_BRF");
      ValueSets[6].ac2 = GetAttrIndex("BC034_BRF2");
      ValueSets[6].ac3 = -999;
      ValueSets[7].ac1 = GetAttrIndex("BC034_MRT");
      ValueSets[7].ac2 = GetAttrIndex("BC034_MRT2");
      ValueSets[7].ac3 = GetAttrIndex("BC034_MRT3");
      ValueSets[8].ac1 = GetAttrIndex("BMC");
      ValueSets[8].ac2 = GetAttrIndex("BMC2");
      ValueSets[8].ac3 = GetAttrIndex("BMC3");
      ValueSets[9].ac1 = GetAttrIndex("BRF");
      ValueSets[9].ac2 = GetAttrIndex("BRF2");
      ValueSets[9].ac3 = -999;
      ValueSets[10].ac1 = GetAttrIndex("BSC");
      ValueSets[10].ac2 = GetAttrIndex("BSC2");
      ValueSets[10].ac3 = GetAttrIndex("BSC3");
      ValueSets[11].ac1 = GetAttrIndex("CAB");
      ValueSets[11].ac2 = GetAttrIndex("CAB2");
      ValueSets[11].ac3 = GetAttrIndex("CAB3");
      ValueSets[12].ac1 = GetAttrIndex("CSC");
      ValueSets[12].ac2 = GetAttrIndex("CSC2");
      ValueSets[12].ac3 = GetAttrIndex("CSC3");
      ValueSets[13].ac1 = GetAttrIndex("DKC");
      ValueSets[13].ac2 = GetAttrIndex("DKC2");
      ValueSets[13].ac3 = GetAttrIndex("DKC3");
      ValueSets[14].ac1 = GetAttrIndex("DPG");
      ValueSets[14].ac2 = GetAttrIndex("DPG2");
      ValueSets[14].ac3 = GetAttrIndex("DPG3");
      ValueSets[15].ac1 = GetAttrIndex("FFN");
      ValueSets[15].ac2 = GetAttrIndex("FFN2");
      ValueSets[15].ac3 = GetAttrIndex("FFN3");
      ValueSets[16].ac1 = GetAttrIndex("FHC");
      ValueSets[16].ac2 = GetAttrIndex("FHC2");
      ValueSets[16].ac3 = GetAttrIndex("FHC3");

      ValueSets[17].ac1 = GetAttrIndex("FRT");
      ValueSets[17].ac2 = GetAttrIndex("FRT2");
      ValueSets[17].ac3 = GetAttrIndex("FRT3");
      ValueSets[18].ac1 = GetAttrIndex("HST");
      ValueSets[18].ac2 = GetAttrIndex("HST2");
      ValueSets[18].ac3 = GetAttrIndex("HST3");
      ValueSets[19].ac1 = GetAttrIndex("LFC");
      ValueSets[19].ac2 = GetAttrIndex("LFC2");
      ValueSets[19].ac3 = GetAttrIndex("LFC3");
      ValueSets[20].ac1 = GetAttrIndex("MCC");
      ValueSets[20].ac2 = GetAttrIndex("MCC2");
      ValueSets[20].ac3 = GetAttrIndex("MCC3");
      ValueSets[21].ac1 = GetAttrIndex("MCY");
      ValueSets[21].ac2 = GetAttrIndex("MCY2");
      ValueSets[21].ac3 = GetAttrIndex("MCY3");
      ValueSets[22].ac1 = GetAttrIndex("MGL");
      ValueSets[22].ac2 = GetAttrIndex("MGL2");
      ValueSets[22].ac3 = GetAttrIndex("MGL3");
      ValueSets[23].ac1 = GetAttrIndex("MNR");
      ValueSets[23].ac2 = GetAttrIndex("MNR2");
      ValueSets[23].ac3 = GetAttrIndex("MNR3");

      ValueSets[24].ac1 = GetAttrIndex("MRR");
      ValueSets[24].ac2 = GetAttrIndex("MRR2");
      ValueSets[24].ac3 = GetAttrIndex("MRR3");
      ValueSets[25].ac1 = GetAttrIndex("MST");
      ValueSets[25].ac2 = GetAttrIndex("MST2");
      ValueSets[25].ac3 = GetAttrIndex("MST3");
      ValueSets[26].ac1 = GetAttrIndex("NFP");
      ValueSets[26].ac2 = GetAttrIndex("NFP2");
      ValueSets[26].ac3 = GetAttrIndex("NFP3");
      ValueSets[27].ac1 = GetAttrIndex("NMC");
      ValueSets[27].ac2 = GetAttrIndex("NMC2");
      ValueSets[27].ac3 = GetAttrIndex("NMC3");
      ValueSets[28].ac1 = GetAttrIndex("NOA");
      ValueSets[28].ac2 = GetAttrIndex("NOA2");
      ValueSets[28].ac3 = GetAttrIndex("NOA3");

      ValueSets[29].ac1 = GetAttrIndex("ORS");
      ValueSets[29].ac2 = GetAttrIndex("ORS2");
      ValueSets[29].ac3 = GetAttrIndex("ORS3");
      ValueSets[30].ac1 = GetAttrIndex("PBY");
      ValueSets[30].ac2 = GetAttrIndex("PBY2");
      ValueSets[30].ac3 = GetAttrIndex("PBY3");
      ValueSets[31].ac1 = GetAttrIndex("POS");
      ValueSets[31].ac2 = GetAttrIndex("POS2");
      ValueSets[31].ac3 = GetAttrIndex("POS3");
      ValueSets[32].ac1 = GetAttrIndex("PPO");
      ValueSets[32].ac2 = GetAttrIndex("PPO2");
      ValueSets[32].ac3 = GetAttrIndex("PPO3");
      ValueSets[33].ac1 = GetAttrIndex("PRW");
      ValueSets[33].ac2 = GetAttrIndex("PRW2");
      ValueSets[33].ac3 = GetAttrIndex("PRW3");
      ValueSets[34].ac1 = GetAttrIndex("RRC");
      ValueSets[34].ac2 = GetAttrIndex("RRC2");
      ValueSets[34].ac3 = GetAttrIndex("RRC3");
      ValueSets[35].ac1 = GetAttrIndex("RTN");
      ValueSets[35].ac2 = GetAttrIndex("RTN2");
      ValueSets[35].ac3 = GetAttrIndex("RTN3");
      ValueSets[36].ac1 = GetAttrIndex("RTN_ROI");
      ValueSets[36].ac2 = GetAttrIndex("RTN_ROI2");
      ValueSets[36].ac3 = GetAttrIndex("RTN_ROI3");
      ValueSets[37].ac1 = GetAttrIndex("SBT");
      ValueSets[37].ac2 = GetAttrIndex("SBT2");
      ValueSets[37].ac3 = GetAttrIndex("SBT3");
      ValueSets[38].ac1 = GetAttrIndex("SSR");
      ValueSets[38].ac2 = GetAttrIndex("SSR2");
      ValueSets[38].ac3 = GetAttrIndex("SSR3");
      ValueSets[39].ac1 = GetAttrIndex("STA");
      ValueSets[39].ac2 = GetAttrIndex("STA2");
      ValueSets[39].ac3 = GetAttrIndex("STA3");
      ValueSets[40].ac1 = GetAttrIndex("STL");
      ValueSets[40].ac2 = GetAttrIndex("STL2");
      ValueSets[40].ac3 = GetAttrIndex("STL3");
      ValueSets[41].ac1 = GetAttrIndex("TRS");
      ValueSets[41].ac2 = GetAttrIndex("TRS2");
      ValueSets[41].ac3 = GetAttrIndex("TRS3");
      ValueSets[42].ac1 = GetAttrIndex("TSM");
      ValueSets[42].ac2 = GetAttrIndex("TSM2");
      ValueSets[42].ac3 = GetAttrIndex("TSM3");
      ValueSets[43].ac1 = GetAttrIndex("TTC");
      ValueSets[43].ac2 = GetAttrIndex("TTC2");
      ValueSets[43].ac3 = GetAttrIndex("TTC3");
      ValueSets[44].ac1 = GetAttrIndex("UTY");
      ValueSets[44].ac2 = GetAttrIndex("UTY2");
      ValueSets[44].ac3 = GetAttrIndex("UTY3");
      ValueSets[45].ac1 = GetAttrIndex("VCA");
      ValueSets[45].ac2 = GetAttrIndex("VCA2");
      ValueSets[45].ac3 = GetAttrIndex("VCA3");
      ValueSets[46].ac1 = GetAttrIndex("VCM");
      ValueSets[46].ac2 = GetAttrIndex("VCM2");
      ValueSets[46].ac3 = GetAttrIndex("VCM3");
      ValueSets[47].ac1 = GetAttrIndex("VCT");
      ValueSets[47].ac2 = GetAttrIndex("VCT2");
      ValueSets[47].ac3 = GetAttrIndex("VCT3");
      ValueSets[48].ac1 = GetAttrIndex("VIS");
      ValueSets[48].ac2 = GetAttrIndex("VIS2");
      ValueSets[48].ac3 = GetAttrIndex("VIS3");
      ValueSets[49].ac1 = GetAttrIndex("VSP");
      ValueSets[49].ac2 = GetAttrIndex("VSP2");
      ValueSets[49].ac3 = GetAttrIndex("VSP3");
      ValueSets[50].ac1 = GetAttrIndex("WEQ");
      ValueSets[50].ac2 = GetAttrIndex("WEQ2");
      ValueSets[50].ac3 = GetAttrIndex("WEQ3");
      ValueSets[51].ac1 = GetAttrIndex("WPC");
      ValueSets[51].ac2 = GetAttrIndex("WPC2");
      ValueSets[51].ac3 = GetAttrIndex("WPC3");
      ValueSets[52].ac1 = GetAttrIndex("WWM");
      ValueSets[52].ac2 = GetAttrIndex("WWM2");
      ValueSets[52].ac3 = GetAttrIndex("WWM3");
      ValueSets[53].ac1 = GetAttrIndex("ZHBH_DKC");
      ValueSets[53].ac2 = GetAttrIndex("ZHBH_DKC2");
      ValueSets[53].ac3 = GetAttrIndex("ZHBH_DKC3");
      ValueSets[54].ac1 = GetAttrIndex("ZHBH_TEC");
      ValueSets[54].ac2 = GetAttrIndex("ZHBH_TEC2");
      ValueSets[54].ac3 = GetAttrIndex("ZHBH_TEC3");
      ValueSets[55].ac1 = GetAttrIndex("ZHDP_DKC");
      ValueSets[55].ac2 = GetAttrIndex("ZHDP_DKC2");
      ValueSets[55].ac3 = GetAttrIndex("ZHDP_DKC3");
      ValueSets[56].ac1 = GetAttrIndex("ZHDP_TEC");
      ValueSets[56].ac2 = GetAttrIndex("ZHDP_TEC2");
      ValueSets[56].ac3 = GetAttrIndex("ZHDP_TEC3");
      ValueSets[57].ac1 = GetAttrIndex("ZI005_FNA");
      ValueSets[57].ac2 = GetAttrIndex("ZI005_FNA2");
      ValueSets[57].ac3 = GetAttrIndex("ZI005_FNA3");
      ValueSets[58].ac1 = GetAttrIndex("ZI005_GNT");
      ValueSets[58].ac2 = GetAttrIndex("ZI005_GNT2");
      ValueSets[58].ac3 = GetAttrIndex("ZI005_GNT3");
      ValueSets[59].ac1 = GetAttrIndex("ZI005_NFN");
      ValueSets[59].ac2 = GetAttrIndex("ZI005_NFN2");
      ValueSets[59].ac3 = GetAttrIndex("ZI005_NFN3");
      ValueSets[60].ac1 = GetAttrIndex("ZI012_TEC");
      ValueSets[60].ac2 = GetAttrIndex("ZI012_TEC2");
      ValueSets[60].ac3 = GetAttrIndex("ZI012_TEC3");
      ValueSets[61].ac1 = GetAttrIndex("ZI013_CSP");
      ValueSets[61].ac2 = GetAttrIndex("ZI013_CSP2");
      ValueSets[61].ac3 = GetAttrIndex("ZI013_CSP3");
      ValueSets[62].ac1 = GetAttrIndex("ZI013_FFP");
      ValueSets[62].ac2 = GetAttrIndex("ZI013_FFP2");
      ValueSets[62].ac3 = GetAttrIndex("ZI013_FFP3");
      ValueSets[63].ac1 = GetAttrIndex("ZI013_FMM");
      ValueSets[63].ac2 = GetAttrIndex("ZI013_FMM2");
      ValueSets[63].ac3 = GetAttrIndex("ZI013_FMM3");
      ValueSets[64].ac1 = GetAttrIndex("ZI014_PBY");
      ValueSets[64].ac2 = GetAttrIndex("ZI014_PBY2");
      ValueSets[64].ac3 = GetAttrIndex("ZI014_PBY3");
      ValueSets[65].ac1 = GetAttrIndex("ZI014_PPO");
      ValueSets[65].ac2 = GetAttrIndex("ZI014_PPO2");
      ValueSets[65].ac3 = GetAttrIndex("ZI014_PPO3");
      ValueSets[66].ac1 = GetAttrIndex("ZI014_PRW");
      ValueSets[66].ac2 = GetAttrIndex("ZI014_PRW2");
      ValueSets[66].ac3 = GetAttrIndex("ZI014_PRW3");
      ValueSets[67].ac1 = GetAttrIndex("ZI019_ASP");
      ValueSets[67].ac2 = GetAttrIndex("ZI019_ASP2");
      ValueSets[67].ac3 = GetAttrIndex("ZI019_ASP3");
      ValueSets[68].ac1 = GetAttrIndex("ZI019_ASU");
      ValueSets[68].ac2 = GetAttrIndex("ZI019_ASU2");
      ValueSets[68].ac3 = GetAttrIndex("ZI019_ASU3");
      ValueSets[69].ac1 = GetAttrIndex("ZI024_PUR");
      ValueSets[69].ac2 = GetAttrIndex("ZI024_PUR2");
      ValueSets[69].ac3 = GetAttrIndex("ZI024_PUR3");
      ValueSets[70].ac1 = GetAttrIndex("ZI024_WUR");
      ValueSets[70].ac2 = GetAttrIndex("ZI024_WUR2");
      ValueSets[70].ac3 = GetAttrIndex("ZI024_WUR3");
      ValueSets[71].ac1 = GetAttrIndex("ZI025_TEC");
      ValueSets[71].ac2 = GetAttrIndex("ZI025_TEC2");
      ValueSets[71].ac3 = GetAttrIndex("ZI025_TEC3");
      ValueSets[72].ac1 = GetAttrIndex("ZI071_FFN");
      ValueSets[72].ac2 = GetAttrIndex("ZI071_FFN2");
      ValueSets[72].ac3 = GetAttrIndex("ZI071_FFN3");
      }

   else if(ATTRTYPE_GGDM22() > 0) /*** GGDM v2.2****/
      {
      ValueSets[0].ac1 = GetAttrIndex("APT");
      ValueSets[0].ac2 = GetAttrIndex("APT2");
      ValueSets[0].ac3 = GetAttrIndex("APT3");
      ValueSets[1].ac1 = GetAttrIndex("APU");
      ValueSets[1].ac2 = GetAttrIndex("APU2");
      ValueSets[1].ac3 = GetAttrIndex("APU3");
      ValueSets[2].ac1 = GetAttrIndex("AQO");
      ValueSets[2].ac2 = GetAttrIndex("AQO2");
      ValueSets[2].ac3 = GetAttrIndex("AQO3");
      ValueSets[3].ac1 = GetAttrIndex("AQP");
      ValueSets[3].ac2 = GetAttrIndex("AQP2");
      ValueSets[3].ac3 = GetAttrIndex("AQP3");
      ValueSets[4].ac1 = GetAttrIndex("ASU");
      ValueSets[4].ac2 = GetAttrIndex("ASU2");
      ValueSets[4].ac3 = GetAttrIndex("ASU3");
      ValueSets[5].ac1 = GetAttrIndex("AT005_CAB");
      ValueSets[5].ac2 = GetAttrIndex("AT005_CAB2");
      ValueSets[5].ac3 = GetAttrIndex("AT005_CAB3");
      ValueSets[6].ac1 = GetAttrIndex("BBMCA");
      ValueSets[6].ac2 = GetAttrIndex("BBMCA2");
      ValueSets[6].ac3 = GetAttrIndex("BBMCA3");
      ValueSets[7].ac1 = GetAttrIndex("BBMCB");
      ValueSets[7].ac2 = GetAttrIndex("BBMCB2");
      ValueSets[7].ac3 = GetAttrIndex("BBMCB3");
      ValueSets[8].ac1 = GetAttrIndex("BC034_BRF");
      ValueSets[8].ac2 = GetAttrIndex("BC034_BRF2");
      ValueSets[9].ac1 = GetAttrIndex("BC034_MRT");
      ValueSets[9].ac2 = GetAttrIndex("BC034_MRT2");
      ValueSets[9].ac3 = GetAttrIndex("BC034_MRT3");
      ValueSets[10].ac1 = GetAttrIndex("BMC");
      ValueSets[10].ac2 = GetAttrIndex("BMC2");
      ValueSets[10].ac3 = GetAttrIndex("BMC3");
      ValueSets[11].ac1 = GetAttrIndex("BRF");
      ValueSets[11].ac2 = GetAttrIndex("BRF2");
      ValueSets[12].ac1 = GetAttrIndex("BSC");
      ValueSets[12].ac2 = GetAttrIndex("BSC2");
      ValueSets[12].ac3 = GetAttrIndex("BSC3");
      ValueSets[13].ac1 = GetAttrIndex("CAB");
      ValueSets[13].ac2 = GetAttrIndex("CAB2");
      ValueSets[13].ac3 = GetAttrIndex("CAB3");
      ValueSets[14].ac1 = GetAttrIndex("CSC");
      ValueSets[14].ac2 = GetAttrIndex("CSC2");
      ValueSets[14].ac3 = GetAttrIndex("CSC3");
      ValueSets[15].ac1 = GetAttrIndex("CVT");
      ValueSets[15].ac2 = GetAttrIndex("CVT2");
      ValueSets[15].ac3 = GetAttrIndex("CVT3");
      ValueSets[16].ac1 = GetAttrIndex("DKC");
      ValueSets[16].ac2 = GetAttrIndex("DKC2");
      ValueSets[16].ac3 = GetAttrIndex("DKC3");
      ValueSets[17].ac1 = GetAttrIndex("DPG");
      ValueSets[17].ac2 = GetAttrIndex("DPG2");
      ValueSets[17].ac3 = GetAttrIndex("DPG3");
      ValueSets[18].ac1 = GetAttrIndex("FFN");
      ValueSets[18].ac2 = GetAttrIndex("FFN2");
      ValueSets[18].ac3 = GetAttrIndex("FFN3");
      ValueSets[19].ac1 = GetAttrIndex("FHC");
      ValueSets[19].ac2 = GetAttrIndex("FHC2");
      ValueSets[19].ac3 = GetAttrIndex("FHC3");
      ValueSets[20].ac1 = GetAttrIndex("FRT");
      ValueSets[20].ac2 = GetAttrIndex("FRT2");
      ValueSets[20].ac3 = GetAttrIndex("FRT3");
      ValueSets[21].ac1 = GetAttrIndex("HST");
      ValueSets[21].ac2 = GetAttrIndex("HST2");
      ValueSets[21].ac3 = GetAttrIndex("HST3");
      ValueSets[22].ac1 = GetAttrIndex("LFC");
      ValueSets[22].ac2 = GetAttrIndex("LFC2");
      ValueSets[22].ac3 = GetAttrIndex("LFC3");
      ValueSets[23].ac1 = GetAttrIndex("MCC");
      ValueSets[23].ac2 = GetAttrIndex("MCC2");
      ValueSets[23].ac3 = GetAttrIndex("MCC3");
      ValueSets[24].ac1 = GetAttrIndex("MCY");
      ValueSets[24].ac2 = GetAttrIndex("MCY2");
      ValueSets[24].ac3 = GetAttrIndex("MCY3");
      ValueSets[25].ac1 = GetAttrIndex("MGL");
      ValueSets[25].ac2 = GetAttrIndex("MGL2");
      ValueSets[25].ac3 = GetAttrIndex("MGL3");
      ValueSets[26].ac1 = GetAttrIndex("MNR");
      ValueSets[26].ac2 = GetAttrIndex("MNR2");
      ValueSets[26].ac3 = GetAttrIndex("MNR3");
      ValueSets[27].ac1 = GetAttrIndex("MRR");
      ValueSets[27].ac2 = GetAttrIndex("MRR2");
      ValueSets[27].ac3 = GetAttrIndex("MRR3");
      ValueSets[28].ac1 = GetAttrIndex("MST");
      ValueSets[28].ac2 = GetAttrIndex("MST2");
      ValueSets[28].ac3 = GetAttrIndex("MST3");
      ValueSets[29].ac1 = GetAttrIndex("NFP");
      ValueSets[29].ac2 = GetAttrIndex("NFP2");
      ValueSets[29].ac3 = GetAttrIndex("NFP3");
      ValueSets[30].ac1 = GetAttrIndex("NMC");
      ValueSets[30].ac2 = GetAttrIndex("NMC2");
      ValueSets[30].ac3 = GetAttrIndex("NMC3");
      ValueSets[31].ac1 = GetAttrIndex("NOA");
      ValueSets[31].ac2 = GetAttrIndex("NOA2");
      ValueSets[31].ac3 = GetAttrIndex("NOA3");
      ValueSets[32].ac1 = GetAttrIndex("ORS");
      ValueSets[32].ac2 = GetAttrIndex("ORS2");
      ValueSets[32].ac3 = GetAttrIndex("ORS3");
      ValueSets[33].ac1 = GetAttrIndex("PBY");
      ValueSets[33].ac2 = GetAttrIndex("PBY2");
      ValueSets[33].ac3 = GetAttrIndex("PBY3");
      ValueSets[34].ac1 = GetAttrIndex("PLT");
      ValueSets[34].ac2 = GetAttrIndex("PLT2");
      ValueSets[34].ac3 = GetAttrIndex("PLT3");
      ValueSets[35].ac1 = GetAttrIndex("POS");
      ValueSets[35].ac2 = GetAttrIndex("POS2");
      ValueSets[35].ac3 = GetAttrIndex("POS3");
      ValueSets[36].ac1 = GetAttrIndex("PPO");
      ValueSets[36].ac2 = GetAttrIndex("PPO2");
      ValueSets[36].ac3 = GetAttrIndex("PPO3");
      ValueSets[37].ac1 = GetAttrIndex("PRW");
      ValueSets[37].ac2 = GetAttrIndex("PRW2");
      ValueSets[37].ac3 = GetAttrIndex("PRW3");
      ValueSets[38].ac1 = GetAttrIndex("RIN_ROI");
      ValueSets[38].ac2 = GetAttrIndex("RIN_ROI2");
      ValueSets[38].ac3 = GetAttrIndex("RIN_ROI3");
      ValueSets[39].ac1 = GetAttrIndex("RIN_RTN");
      ValueSets[39].ac2 = GetAttrIndex("RIN_RTN2");
      ValueSets[39].ac3 = GetAttrIndex("RIN_RTN3");
      ValueSets[40].ac1 = GetAttrIndex("RRC");
      ValueSets[40].ac2 = GetAttrIndex("RRC2");
      ValueSets[40].ac3 = GetAttrIndex("RRC3");
      ValueSets[41].ac1 = GetAttrIndex("RTN");
      ValueSets[41].ac2 = GetAttrIndex("RTN2");
      ValueSets[41].ac3 = GetAttrIndex("RTN3");
      ValueSets[42].ac1 = GetAttrIndex("SBT");
      ValueSets[42].ac2 = GetAttrIndex("SBT2");
      ValueSets[42].ac3 = GetAttrIndex("SBT3");
      ValueSets[43].ac1 = GetAttrIndex("SSR");
      ValueSets[43].ac2 = GetAttrIndex("SSR2");
      ValueSets[43].ac3 = GetAttrIndex("SSR3");
      ValueSets[44].ac1 = GetAttrIndex("STA");
      ValueSets[44].ac2 = GetAttrIndex("STA2");
      ValueSets[44].ac3 = GetAttrIndex("STA3");
      ValueSets[45].ac1 = GetAttrIndex("STL");
      ValueSets[45].ac2 = GetAttrIndex("STL2");
      ValueSets[45].ac3 = GetAttrIndex("STL3");
      ValueSets[46].ac1 = GetAttrIndex("TRS");
      ValueSets[46].ac2 = GetAttrIndex("TRS2");
      ValueSets[46].ac3 = GetAttrIndex("TRS3");
      ValueSets[47].ac1 = GetAttrIndex("TSM");
      ValueSets[47].ac2 = GetAttrIndex("TSM2");
      ValueSets[47].ac3 = GetAttrIndex("TSM3");
      ValueSets[48].ac1 = GetAttrIndex("TSSM");
      ValueSets[48].ac2 = GetAttrIndex("TSSM2");
      ValueSets[48].ac3 = GetAttrIndex("TSSM3");
      ValueSets[49].ac1 = GetAttrIndex("TTC");
      ValueSets[49].ac2 = GetAttrIndex("TTC2");
      ValueSets[49].ac3 = GetAttrIndex("TTC3");
      ValueSets[50].ac1 = GetAttrIndex("UTY");
      ValueSets[50].ac2 = GetAttrIndex("UTY2");
      ValueSets[50].ac3 = GetAttrIndex("UTY3");
      ValueSets[51].ac1 = GetAttrIndex("VCA");
      ValueSets[51].ac2 = GetAttrIndex("VCA2");
      ValueSets[51].ac3 = GetAttrIndex("VCA3");
      ValueSets[52].ac1 = GetAttrIndex("VCM");
      ValueSets[52].ac2 = GetAttrIndex("VCM2");
      ValueSets[52].ac3 = GetAttrIndex("VCM3");
      ValueSets[53].ac1 = GetAttrIndex("VCT");
      ValueSets[53].ac2 = GetAttrIndex("VCT2");
      ValueSets[53].ac3 = GetAttrIndex("VCT3");
      ValueSets[54].ac1 = GetAttrIndex("VIS");
      ValueSets[54].ac2 = GetAttrIndex("VIS2");
      ValueSets[54].ac3 = GetAttrIndex("VIS3");
      ValueSets[55].ac1 = GetAttrIndex("VSP");
      ValueSets[55].ac2 = GetAttrIndex("VSP2");
      ValueSets[55].ac3 = GetAttrIndex("VSP3");
      ValueSets[56].ac1 = GetAttrIndex("WEQ");
      ValueSets[56].ac2 = GetAttrIndex("WEQ2");
      ValueSets[56].ac3 = GetAttrIndex("WEQ3");
      ValueSets[57].ac1 = GetAttrIndex("WPC");
      ValueSets[57].ac2 = GetAttrIndex("WPC2");
      ValueSets[57].ac3 = GetAttrIndex("WPC3");
      ValueSets[58].ac1 = GetAttrIndex("WWM");
      ValueSets[58].ac2 = GetAttrIndex("WWM2");
      ValueSets[58].ac3 = GetAttrIndex("WWM3");
      ValueSets[59].ac1 = GetAttrIndex("ZHBH_DKC");
      ValueSets[59].ac2 = GetAttrIndex("ZHBH_DKC2");
      ValueSets[59].ac3 = GetAttrIndex("ZHBH_DKC3");
      ValueSets[60].ac1 = GetAttrIndex("ZHBH_TEC");
      ValueSets[60].ac2 = GetAttrIndex("ZHBH_TEC2");
      ValueSets[60].ac3 = GetAttrIndex("ZHBH_TEC3");
      ValueSets[61].ac1 = GetAttrIndex("ZHDP_DKC");
      ValueSets[61].ac2 = GetAttrIndex("ZHDP_DKC2");
      ValueSets[61].ac3 = GetAttrIndex("ZHDP_DKC3");
      ValueSets[62].ac1 = GetAttrIndex("ZHDP_TEC");
      ValueSets[62].ac2 = GetAttrIndex("ZHDP_TEC2");
      ValueSets[62].ac3 = GetAttrIndex("ZHDP_TEC3");
      ValueSets[63].ac1 = GetAttrIndex("ZI005_FNA");
      ValueSets[63].ac2 = GetAttrIndex("ZI005_FNA2");
      ValueSets[63].ac3 = GetAttrIndex("ZI005_FNA3");
      ValueSets[64].ac1 = GetAttrIndex("ZI005_GNT");
      ValueSets[64].ac2 = GetAttrIndex("ZI005_GNT2");
      ValueSets[64].ac3 = GetAttrIndex("ZI005_GNT3");
      ValueSets[65].ac1 = GetAttrIndex("ZI005_NFN");
      ValueSets[65].ac2 = GetAttrIndex("ZI005_NFN2");
      ValueSets[65].ac3 = GetAttrIndex("ZI005_NFN3");
      ValueSets[66].ac1 = GetAttrIndex("ZI012_DKC");
      ValueSets[66].ac2 = GetAttrIndex("ZI012_DKC2");
      ValueSets[66].ac3 = GetAttrIndex("ZI012_DKC3");
      ValueSets[67].ac1 = GetAttrIndex("ZI012_TEC");
      ValueSets[67].ac2 = GetAttrIndex("ZI012_TEC2");
      ValueSets[67].ac3 = GetAttrIndex("ZI012_TEC3");
      ValueSets[68].ac1 = GetAttrIndex("ZI013_CSP");
      ValueSets[68].ac2 = GetAttrIndex("ZI013_CSP2");
      ValueSets[68].ac3 = GetAttrIndex("ZI013_CSP3");
      ValueSets[69].ac1 = GetAttrIndex("ZI013_FFP");
      ValueSets[69].ac2 = GetAttrIndex("ZI013_FFP2");
      ValueSets[69].ac3 = GetAttrIndex("ZI013_FFP3");
      ValueSets[70].ac1 = GetAttrIndex("ZI013_FMM");
      ValueSets[70].ac2 = GetAttrIndex("ZI013_FMM2");
      ValueSets[70].ac3 = GetAttrIndex("ZI013_FMM3");
      ValueSets[71].ac1 = GetAttrIndex("ZI014_PBY");
      ValueSets[71].ac2 = GetAttrIndex("ZI014_PBY2");
      ValueSets[71].ac3 = GetAttrIndex("ZI014_PBY3");
      ValueSets[72].ac1 = GetAttrIndex("ZI014_PPO");
      ValueSets[72].ac2 = GetAttrIndex("ZI014_PPO2");
      ValueSets[72].ac3 = GetAttrIndex("ZI014_PPO3");
      ValueSets[73].ac1 = GetAttrIndex("ZI014_PRW");
      ValueSets[73].ac2 = GetAttrIndex("ZI014_PRW2");
      ValueSets[73].ac3 = GetAttrIndex("ZI014_PRW3");
      ValueSets[74].ac1 = GetAttrIndex("ZI019_ASP");
      ValueSets[74].ac2 = GetAttrIndex("ZI019_ASP2");
      ValueSets[74].ac3 = GetAttrIndex("ZI019_ASP3");
      ValueSets[75].ac1 = GetAttrIndex("ZI019_ASU");
      ValueSets[75].ac2 = GetAttrIndex("ZI019_ASU2");
      ValueSets[75].ac3 = GetAttrIndex("ZI019_ASU3");
      ValueSets[76].ac1 = GetAttrIndex("ZI020_GE4");
      ValueSets[76].ac2 = GetAttrIndex("ZI020_GE42");
      ValueSets[76].ac3 = GetAttrIndex("ZI020_GE43");
      ValueSets[76].ac4 = GetAttrIndex("ZI020_GE44");
      ValueSets[77].ac1 = GetAttrIndex("ZI024_PUR");
      ValueSets[77].ac2 = GetAttrIndex("ZI024_PUR2");
      ValueSets[77].ac3 = GetAttrIndex("ZI024_PUR3");
      ValueSets[77].ac4 = GetAttrIndex("ZI024_PUR4");
      ValueSets[78].ac1 = GetAttrIndex("ZI024_WUR");
      ValueSets[78].ac2 = GetAttrIndex("ZI024_WUR2");
      ValueSets[78].ac3 = GetAttrIndex("ZI024_WUR3");
      ValueSets[78].ac4 = GetAttrIndex("ZI024_WUR4");
      ValueSets[79].ac1 = GetAttrIndex("ZI071_FFN");
      ValueSets[79].ac2 = GetAttrIndex("ZI071_FFN2");
      ValueSets[79].ac3 = GetAttrIndex("ZI071_FFN3");
      }
   else if(ATTRTYPE_GGDM3() > 0)
      {
      ValueSets[0].ac1 = GetAttrIndex("APT");
      ValueSets[0].ac2 = GetAttrIndex("APT2");
      ValueSets[0].ac3 = GetAttrIndex("APT3");
      ValueSets[1].ac1 = GetAttrIndex("APU");
      ValueSets[1].ac2 = GetAttrIndex("APU2");
      ValueSets[1].ac3 = GetAttrIndex("APU3");
      ValueSets[2].ac1 = GetAttrIndex("AQO");
      ValueSets[2].ac2 = GetAttrIndex("AQO2");
      ValueSets[2].ac3 = GetAttrIndex("AQO3");
      ValueSets[3].ac1 = GetAttrIndex("AQP");
      ValueSets[3].ac2 = GetAttrIndex("AQP2");
      ValueSets[3].ac3 = GetAttrIndex("AQP3");
      ValueSets[4].ac1 = GetAttrIndex("ASU");
      ValueSets[4].ac2 = GetAttrIndex("ASU2");
      ValueSets[4].ac3 = GetAttrIndex("ASU3");
      ValueSets[5].ac1 = GetAttrIndex("AT005_CAB");
      ValueSets[5].ac2 = GetAttrIndex("AT005_CAB2");
      ValueSets[5].ac3 = GetAttrIndex("AT005_CAB3");
      ValueSets[6].ac1 = GetAttrIndex("BBMCA");
      ValueSets[6].ac2 = GetAttrIndex("BBMCA2");
      ValueSets[6].ac3 = GetAttrIndex("BBMCA3");
      ValueSets[7].ac1 = GetAttrIndex("BBMCB");
      ValueSets[7].ac2 = GetAttrIndex("BBMCB2");
      ValueSets[7].ac3 = GetAttrIndex("BBMCB3");
      ValueSets[8].ac1 = GetAttrIndex("BC034_BRF");
      ValueSets[8].ac2 = GetAttrIndex("BC034_BRF2");
      ValueSets[9].ac1 = GetAttrIndex("BC034_MRT");
      ValueSets[9].ac2 = GetAttrIndex("BC034_MRT2");
      ValueSets[9].ac3 = GetAttrIndex("BC034_MRT3");
      ValueSets[10].ac1 = GetAttrIndex("BMC");
      ValueSets[10].ac2 = GetAttrIndex("BMC2");
      ValueSets[10].ac3 = GetAttrIndex("BMC3");
      ValueSets[11].ac1 = GetAttrIndex("BRF");
      ValueSets[11].ac2 = GetAttrIndex("BRF2");
      ValueSets[12].ac1 = GetAttrIndex("BSC");
      ValueSets[12].ac2 = GetAttrIndex("BSC2");
      ValueSets[12].ac3 = GetAttrIndex("BSC3");
      ValueSets[13].ac1 = GetAttrIndex("CAB");
      ValueSets[13].ac2 = GetAttrIndex("CAB2");
      ValueSets[13].ac3 = GetAttrIndex("CAB3");
      ValueSets[14].ac1 = GetAttrIndex("CSC");
      ValueSets[14].ac2 = GetAttrIndex("CSC2");
      ValueSets[14].ac3 = GetAttrIndex("CSC3");
      ValueSets[15].ac1 = GetAttrIndex("CVT");
      ValueSets[15].ac2 = GetAttrIndex("CVT2");
      ValueSets[15].ac3 = GetAttrIndex("CVT3");
      ValueSets[16].ac1 = GetAttrIndex("DFU");
      ValueSets[16].ac2 = GetAttrIndex("DFU2");
      ValueSets[16].ac3 = GetAttrIndex("DFU3");
      ValueSets[17].ac1 = GetAttrIndex("DKC");
      ValueSets[17].ac2 = GetAttrIndex("DKC2");
      ValueSets[17].ac3 = GetAttrIndex("DKC3");
      ValueSets[18].ac1 = GetAttrIndex("DPG");
      ValueSets[18].ac2 = GetAttrIndex("DPG2");
      ValueSets[18].ac3 = GetAttrIndex("DPG3");
      ValueSets[19].ac1 = GetAttrIndex("FFN");
      ValueSets[19].ac2 = GetAttrIndex("FFN2");
      ValueSets[19].ac3 = GetAttrIndex("FFN3");
      ValueSets[20].ac1 = GetAttrIndex("FHC");
      ValueSets[20].ac2 = GetAttrIndex("FHC2");
      ValueSets[20].ac3 = GetAttrIndex("FHC3");
      ValueSets[21].ac1 = GetAttrIndex("FRT");
      ValueSets[21].ac2 = GetAttrIndex("FRT2");
      ValueSets[21].ac3 = GetAttrIndex("FRT3");
      ValueSets[22].ac1 = GetAttrIndex("HST");
      ValueSets[22].ac2 = GetAttrIndex("HST2");
      ValueSets[22].ac3 = GetAttrIndex("HST3");
      ValueSets[23].ac1 = GetAttrIndex("LFC");
      ValueSets[23].ac2 = GetAttrIndex("LFC2");
      ValueSets[23].ac3 = GetAttrIndex("LFC3");
      ValueSets[24].ac1 = GetAttrIndex("MCC");
      ValueSets[24].ac2 = GetAttrIndex("MCC2");
      ValueSets[24].ac3 = GetAttrIndex("MCC3");
      ValueSets[25].ac1 = GetAttrIndex("MCY");
      ValueSets[25].ac2 = GetAttrIndex("MCY2");
      ValueSets[25].ac3 = GetAttrIndex("MCY3");
      ValueSets[26].ac1 = GetAttrIndex("MGL");
      ValueSets[26].ac2 = GetAttrIndex("MGL2");
      ValueSets[26].ac3 = GetAttrIndex("MGL3");
      ValueSets[27].ac1 = GetAttrIndex("MNR");
      ValueSets[27].ac2 = GetAttrIndex("MNR2");
      ValueSets[27].ac3 = GetAttrIndex("MNR3");
      ValueSets[28].ac1 = GetAttrIndex("MRR");
      ValueSets[28].ac2 = GetAttrIndex("MRR2");
      ValueSets[28].ac3 = GetAttrIndex("MRR3");
      ValueSets[29].ac1 = GetAttrIndex("MST");
      ValueSets[29].ac2 = GetAttrIndex("MST2");
      ValueSets[29].ac3 = GetAttrIndex("MST3");
      ValueSets[30].ac1 = GetAttrIndex("NDX");
      ValueSets[30].ac2 = GetAttrIndex("NDX2");
      ValueSets[30].ac3 = GetAttrIndex("NDX3");
      ValueSets[31].ac1 = GetAttrIndex("NFP");
      ValueSets[31].ac2 = GetAttrIndex("NFP2");
      ValueSets[31].ac3 = GetAttrIndex("NFP3");
      ValueSets[32].ac1 = GetAttrIndex("NMC");
      ValueSets[32].ac2 = GetAttrIndex("NMC2");
      ValueSets[32].ac3 = GetAttrIndex("NMC3");
      ValueSets[33].ac1 = GetAttrIndex("NOA");
      ValueSets[33].ac2 = GetAttrIndex("NOA2");
      ValueSets[33].ac3 = GetAttrIndex("NOA3");
      ValueSets[34].ac1 = GetAttrIndex("ORS");
      ValueSets[34].ac2 = GetAttrIndex("ORS2");
      ValueSets[34].ac3 = GetAttrIndex("ORS3");
      ValueSets[35].ac1 = GetAttrIndex("PBY");
      ValueSets[35].ac2 = GetAttrIndex("PBY2");
      ValueSets[35].ac3 = GetAttrIndex("PBY3");
      ValueSets[36].ac1 = GetAttrIndex("PLT");
      ValueSets[36].ac2 = GetAttrIndex("PLT2");
      ValueSets[36].ac3 = GetAttrIndex("PLT3");
      ValueSets[37].ac1 = GetAttrIndex("POS");
      ValueSets[37].ac2 = GetAttrIndex("POS2");
      ValueSets[37].ac3 = GetAttrIndex("POS3");
      ValueSets[38].ac1 = GetAttrIndex("PPO");
      ValueSets[38].ac2 = GetAttrIndex("PPO2");
      ValueSets[38].ac3 = GetAttrIndex("PPO3");
      ValueSets[39].ac1 = GetAttrIndex("PRW");
      ValueSets[39].ac2 = GetAttrIndex("PRW2");
      ValueSets[39].ac3 = GetAttrIndex("PRW3");
      ValueSets[40].ac1 = GetAttrIndex("RIN_ROI");
      ValueSets[40].ac2 = GetAttrIndex("RIN_ROI2");
      ValueSets[40].ac3 = GetAttrIndex("RIN_ROI3");
      ValueSets[41].ac1 = GetAttrIndex("RIN_RTN");
      ValueSets[41].ac2 = GetAttrIndex("RIN_RTN2");
      ValueSets[41].ac3 = GetAttrIndex("RIN_RTN3");
      ValueSets[42].ac1 = GetAttrIndex("RRC");
      ValueSets[42].ac2 = GetAttrIndex("RRC2");
      ValueSets[42].ac3 = GetAttrIndex("RRC3");
      ValueSets[43].ac1 = GetAttrIndex("RTN");
      ValueSets[43].ac2 = GetAttrIndex("RTN2");
      ValueSets[43].ac3 = GetAttrIndex("RTN3");
      ValueSets[44].ac1 = GetAttrIndex("SBT");
      ValueSets[44].ac2 = GetAttrIndex("SBT2");
      ValueSets[44].ac3 = GetAttrIndex("SBT3");
      ValueSets[45].ac1 = GetAttrIndex("SSR");
      ValueSets[45].ac2 = GetAttrIndex("SSR2");
      ValueSets[45].ac3 = GetAttrIndex("SSR3");
      ValueSets[46].ac1 = GetAttrIndex("STA");
      ValueSets[46].ac2 = GetAttrIndex("STA2");
      ValueSets[46].ac3 = GetAttrIndex("STA3");
      ValueSets[47].ac1 = GetAttrIndex("STL");
      ValueSets[47].ac2 = GetAttrIndex("STL2");
      ValueSets[47].ac3 = GetAttrIndex("STL3");
      ValueSets[48].ac1 = GetAttrIndex("TRS");
      ValueSets[48].ac2 = GetAttrIndex("TRS2");
      ValueSets[48].ac3 = GetAttrIndex("TRS3");
      ValueSets[49].ac1 = GetAttrIndex("TSM");
      ValueSets[49].ac2 = GetAttrIndex("TSM2");
      ValueSets[49].ac3 = GetAttrIndex("TSM3");
      ValueSets[50].ac1 = GetAttrIndex("TSSM");
      ValueSets[50].ac2 = GetAttrIndex("TSSM2");
      ValueSets[50].ac3 = GetAttrIndex("TSSM3");
      ValueSets[51].ac1 = GetAttrIndex("TTC");
      ValueSets[51].ac2 = GetAttrIndex("TTC2");
      ValueSets[51].ac3 = GetAttrIndex("TTC3");
      ValueSets[52].ac1 = GetAttrIndex("UTY");
      ValueSets[52].ac2 = GetAttrIndex("UTY2");
      ValueSets[52].ac3 = GetAttrIndex("UTY3");
      ValueSets[53].ac1 = GetAttrIndex("VCA");
      ValueSets[53].ac2 = GetAttrIndex("VCA2");
      ValueSets[53].ac3 = GetAttrIndex("VCA3");
      ValueSets[54].ac1 = GetAttrIndex("VCM");
      ValueSets[54].ac2 = GetAttrIndex("VCM2");
      ValueSets[54].ac3 = GetAttrIndex("VCM3");
      ValueSets[55].ac1 = GetAttrIndex("VCT");
      ValueSets[55].ac2 = GetAttrIndex("VCT2");
      ValueSets[55].ac3 = GetAttrIndex("VCT3");
      ValueSets[56].ac1 = GetAttrIndex("VIS");
      ValueSets[56].ac2 = GetAttrIndex("VIS2");
      ValueSets[56].ac3 = GetAttrIndex("VIS3");
      ValueSets[57].ac1 = GetAttrIndex("VSP");
      ValueSets[57].ac2 = GetAttrIndex("VSP2");
      ValueSets[57].ac3 = GetAttrIndex("VSP3");
      ValueSets[58].ac1 = GetAttrIndex("WEQ");
      ValueSets[58].ac2 = GetAttrIndex("WEQ2");
      ValueSets[58].ac3 = GetAttrIndex("WEQ3");
      ValueSets[59].ac1 = GetAttrIndex("WPC");
      ValueSets[59].ac2 = GetAttrIndex("WPC2");
      ValueSets[59].ac3 = GetAttrIndex("WPC3");
      ValueSets[60].ac1 = GetAttrIndex("WWM");
      ValueSets[60].ac2 = GetAttrIndex("WWM2");
      ValueSets[60].ac3 = GetAttrIndex("WWM3");
      ValueSets[61].ac1 = GetAttrIndex("ZHBH_DKC");
      ValueSets[61].ac2 = GetAttrIndex("ZHBH_DKC2");
      ValueSets[61].ac3 = GetAttrIndex("ZHBH_DKC3");
      ValueSets[62].ac1 = GetAttrIndex("ZHBH_TEC");
      ValueSets[62].ac2 = GetAttrIndex("ZHBH_TEC2");
      ValueSets[62].ac3 = GetAttrIndex("ZHBH_TEC3");
      ValueSets[63].ac1 = GetAttrIndex("ZHDP_DKC");
      ValueSets[63].ac2 = GetAttrIndex("ZHDP_DKC2");
      ValueSets[63].ac3 = GetAttrIndex("ZHDP_DKC3");
      ValueSets[64].ac1 = GetAttrIndex("ZHDP_TEC");
      ValueSets[64].ac2 = GetAttrIndex("ZHDP_TEC2");
      ValueSets[64].ac3 = GetAttrIndex("ZHDP_TEC3");
      ValueSets[65].ac1 = GetAttrIndex("ZI005_FNA");
      ValueSets[65].ac2 = GetAttrIndex("ZI005_FNA2");
      ValueSets[65].ac3 = GetAttrIndex("ZI005_FNA3");
      ValueSets[66].ac1 = GetAttrIndex("ZI005_GNR");
      ValueSets[66].ac2 = GetAttrIndex("ZI005_GNR2");
      ValueSets[66].ac3 = GetAttrIndex("ZI005_GNR3");
      ValueSets[67].ac1 = GetAttrIndex("ZI005_GNT");
      ValueSets[67].ac2 = GetAttrIndex("ZI005_GNT2");
      ValueSets[67].ac3 = GetAttrIndex("ZI005_GNT3");
      ValueSets[68].ac1 = GetAttrIndex("ZI005_NFN");
      ValueSets[68].ac2 = GetAttrIndex("ZI005_NFN2");
      ValueSets[68].ac3 = GetAttrIndex("ZI005_NFN3");
      ValueSets[69].ac1 = GetAttrIndex("ZI012_DKC");
      ValueSets[69].ac2 = GetAttrIndex("ZI012_DKC2");
      ValueSets[69].ac3 = GetAttrIndex("ZI012_DKC3");
      ValueSets[70].ac1 = GetAttrIndex("ZI012_TEC");
      ValueSets[70].ac2 = GetAttrIndex("ZI012_TEC2");
      ValueSets[70].ac3 = GetAttrIndex("ZI012_TEC3");
      ValueSets[71].ac1 = GetAttrIndex("ZI013_CSP");
      ValueSets[71].ac2 = GetAttrIndex("ZI013_CSP2");
      ValueSets[71].ac3 = GetAttrIndex("ZI013_CSP3");
      ValueSets[72].ac1 = GetAttrIndex("ZI013_FFP");
      ValueSets[72].ac2 = GetAttrIndex("ZI013_FFP2");
      ValueSets[72].ac3 = GetAttrIndex("ZI013_FFP3");
      ValueSets[73].ac1 = GetAttrIndex("ZI013_FMM");
      ValueSets[73].ac2 = GetAttrIndex("ZI013_FMM2");
      ValueSets[73].ac3 = GetAttrIndex("ZI013_FMM3");
      ValueSets[74].ac1 = GetAttrIndex("ZI014_PBY");
      ValueSets[74].ac2 = GetAttrIndex("ZI014_PBY2");
      ValueSets[74].ac3 = GetAttrIndex("ZI014_PBY3");
      ValueSets[75].ac1 = GetAttrIndex("ZI014_PPO");
      ValueSets[75].ac2 = GetAttrIndex("ZI014_PPO2");
      ValueSets[75].ac3 = GetAttrIndex("ZI014_PPO3");
      ValueSets[76].ac1 = GetAttrIndex("ZI014_PRW");
      ValueSets[76].ac2 = GetAttrIndex("ZI014_PRW2");
      ValueSets[76].ac3 = GetAttrIndex("ZI014_PRW3");
      ValueSets[77].ac1 = GetAttrIndex("ZI019_ASP");
      ValueSets[77].ac2 = GetAttrIndex("ZI019_ASP2");
      ValueSets[77].ac3 = GetAttrIndex("ZI019_ASP3");
      ValueSets[78].ac1 = GetAttrIndex("ZI019_ASU");
      ValueSets[78].ac2 = GetAttrIndex("ZI019_ASU2");
      ValueSets[78].ac3 = GetAttrIndex("ZI019_ASU3");
      ValueSets[79].ac1 = GetAttrIndex("ZI020_GE4");
      ValueSets[79].ac2 = GetAttrIndex("ZI020_GE42");
      ValueSets[79].ac3 = GetAttrIndex("ZI020_GE43");
      ValueSets[79].ac4 = GetAttrIndex("ZI020_GE44");
      ValueSets[80].ac1 = GetAttrIndex("ZI024_PUR");
      ValueSets[80].ac2 = GetAttrIndex("ZI024_PUR2");
      ValueSets[80].ac3 = GetAttrIndex("ZI024_PUR3");
      ValueSets[80].ac4 = GetAttrIndex("ZI024_PUR4");
      ValueSets[81].ac1 = GetAttrIndex("ZI024_WUR");
      ValueSets[81].ac2 = GetAttrIndex("ZI024_WUR2");
      ValueSets[81].ac3 = GetAttrIndex("ZI024_WUR3");
      ValueSets[81].ac4 = GetAttrIndex("ZI024_WUR4");
      ValueSets[82].ac1 = GetAttrIndex("ZI071_FFN");
      ValueSets[82].ac2 = GetAttrIndex("ZI071_FFN2");
      ValueSets[82].ac3 = GetAttrIndex("ZI071_FFN3");
      }


}




void FreeVVTstructs()
{
int i;
struct LongAttrValList *lavc, *lavp;

   MGCP_Vc = MGCP_VVT_root;
   while(MGCP_Vc != NULL)
      {
      MGCP_Vp = MGCP_Vc;
      MGCP_Vc = MGCP_Vc->next;

      if(MGCP_Vp->shapename != NULL)
         free(MGCP_Vp->shapename);
      i = 0;
      while(i < 2)
         {
         ++i;
         if(i == 1)
            VVTac = MGCP_Vp->a;
         else
            VVTac = MGCP_Vp->o;

         while(VVTac != NULL)
            {
            VVTap = VVTac;
            VVTac = VVTac->next;

            VVTdc = VVTap->dep;
            while(VVTdc != NULL)
               {
               VVTdp = VVTdc;
               VVTdc = VVTdc->next;
               if(VVTdp != NULL)
                  free(VVTdp);
               }
            if(VVTap->presentvalue != NULL)
               free(VVTap->presentvalue);
            lavc = VVTap->lav;
            while(lavc != NULL)
               {
               lavp = lavc;
               lavc = lavc->next;
               free(lavp);
               }
            VVTap->lav = NULL;
            if(VVTap != NULL)
               free(VVTap);
            }
         }
      if(MGCP_Vp != NULL)
         free(MGCP_Vp);
      }

   MGCP_VVT_root = NULL;

   VVTdomc = VVTdomainRoot;
   while(VVTdomc != NULL)
      {
      VVTdomp = VVTdomc;
      VVTdomc = VVTdomc->next;

      VVTec = VVTdomp->values;
      while(VVTec != NULL)
         {
         VVTep = VVTec;
         VVTec = VVTec->next;

         if(VVTep->evalue != NULL)
            free(VVTep->evalue);
         if(VVTep->value2 != NULL)
            free(VVTep->value2);
         if(VVTep != NULL)
            free(VVTep);
         }
      if(VVTdomp->name != NULL)
         free(VVTdomp->name);
      if(VVTdomp != NULL)
         free(VVTdomp);
      }

   VVTdomainRoot = NULL;

}




char * IneqSymbol(int flag, int fromwhere)
{
static char answer[10];

   switch(flag)
      {
      case 0:
         if(fromwhere == 1)
            strcpy(answer,"is");
         else if(fromwhere == 2)
            strcpy(answer,"equal to");
         break;
      case 1: strcpy(answer,">="); break;
      case 2: strcpy(answer,">"); break;
      case 3: strcpy(answer,"<="); break;
      case 4: strcpy(answer,"<"); break;
      case 5: strcpy(answer,"="); break;
      default: printf("unrecognized inequality flag %d\n",flag); exit(1);
      }
   return(answer);
}








void ReadVVT3WayEntries()
{
FILE *fin;
char junk[1000];
char dname[100];
char last_name[100];
char thisattr[100];
char evalue[1000];
char value2[200];
char slen[10];
char wchar;
int i,j,sc1,sc2,bi,bj,bk;
int SzEVL = sizeof(struct EnumValList);
int Sz3Way = sizeof(struct VVT_3Way);
int SzVVTD = sizeof(struct VVTDomains);


   strcpy(evalue,GetVV3DomainsFile());
   if(BIN_ATTR_TYPE==1)
      fin = fopen(evalue,"rb");
   else
      fin = fopen(evalue,"rt");
   if(fin == NULL)
      {
      printf("could not open VV3domains file\n");
      exit(1);
      }
   if(BIN_ATTR_TYPE==1)
      {
      fread(&wchar,1,1,fin);
      }
   else
      {
      fgets(junk,999,fin);  /** discard header line **/
      fgets(junk,999,fin);
      }
   strcpy(last_name,"jnsdcjkwenucnexkmmximxmcmeicmn");
   DMroot = NULL;
   DMc = NULL;
   while(feof(fin) == 0)
      {
      if(BIN_ATTR_TYPE==1)
         {
         if(wchar == '\0')
            break;
         else
            {
            bi = (int) wchar;
            fread(slen,bi,1,fin);
            slen[bi] = '\0';
            bj = 0;
            bk = 0;
            while(slen[bj] != '\0')
               {
               bk = bk * 10 + ((int) (slen[bj] - 48));
               ++bj;
               }
            fread(junk,bk,1,fin);
            junk[bk] = '\n';
            ++bk;
            junk[bk] = '\0';
            }
         }
      i = 0;
      while(junk[i] != ',')
         {
         dname[i] = junk[i];
         ++i;
         if(i > 24)
            {
            printf("VVT3way domain name violation - must be 24 characters or less %s\n",junk);
            exit(1);
            }
         dname[i] = '\0';
         }
      if(strcmp(dname,last_name) != 0)
         {
         DMc = (struct VVTDomains *) (malloc(SzVVTD));
         if(DMc == NULL)
            {
            printf("all available memory has been exhausted during VVT 3-way read operation\n");
            exit(1);
            }
         DMc->Dname = (char *) (malloc(100));
         if(DMc->Dname == NULL)
            {
            printf("all available memory has been exhausted during VVT 3-way read operation\n");
            exit(1);
            }
         strcpy(DMc->Dname,dname);
         strcpy(last_name,dname);
         DMc->ev = NULL;
         DMc->next = NULL;

         if(DMc != NULL)
            {
            if(DMroot == NULL)
               DMroot = DMc;
            else
               DMp->next = DMc;
            }
         DMp = DMc;
         }
      ++i;
      while(junk[i] != ',') /** skip over the datatype = all should be enums **/
         ++i;
      ++i;  /** should be on first char of the enum code ***/
      j = 0;
      sc1 = 0;
      while(junk[i] != ',')
         {
         evalue[j] = junk[i];
         ++sc1;
         ++j;
         ++i;
         evalue[j] = '\0';
         }
      ++i; /** should be on first char of the enum label ***/
      j = 0;
      sc2 = 0;
      while(junk[i] >= ' ')
         {
         value2[j] = junk[i];
         ++sc2;
         ++j;
         ++i;
         value2[j] = '\0';
         }
      evlc = (struct EnumValList *) (malloc(SzEVL));
      if(evlc == NULL)
         {
         printf("all available memory has been exhausted during VVT 3-way read operation\n");
         exit(1);
         }
      evlc->value = (char *) (malloc(sc1 + 2));
      evlc->label = (char *) (malloc(sc2 + 2));
      if(evlc->label == NULL)
         {
         printf("all available memory has been exhausted during VVT 3-way read operation\n");
         exit(1);
         }
      strcpy(evlc->value,evalue);
      strcpy(evlc->label,value2);
      evlc->next = NULL;
      if(DMc->ev == NULL)
         DMc->ev = evlc;
      else
         evlp->next = evlc;
      evlp = evlc;
      /***fgets(junk,999, fin); ***/
      if(BIN_ATTR_TYPE==1)
         {
         fread(&wchar,1,1,fin);
         }
      else
         {
         fgets(junk,999,fin);
         }
      }

   fclose(fin);

   strcpy(evalue,GetVV3_File());
   if(BIN_ATTR_TYPE==1)
      fin = fopen(evalue,"rb");
   else
      fin = fopen(evalue,"rt");
   if(fin == NULL)
      {
      printf("could not open VV3 specification file\n");
      exit(1);
      }
   if(BIN_ATTR_TYPE==1)
      {
      fread(&wchar,1,1,fin);
      }
   else
      {
      fgets(junk,999,fin);  /** discard header line **/
      fgets(junk,999,fin);
      }

   strcpy(last_name,"jnsdcjkwenucnexkmmximxmcmeicmn");
   while(feof(fin) == 0)
      {
      if(BIN_ATTR_TYPE==1)
         {
         if(wchar == '\0')
            break;
         else
            {
            bi = (int) wchar;
            fread(slen,bi,1,fin);
            slen[bi] = '\0';
            bj = 0;
            bk = 0;
            while(slen[bj] != '\0')
               {
               bk = bk * 10 + ((int) (slen[bj] - 48));
               ++bj;
               }
            fread(junk,bk,1,fin);
            junk[bk] = '\n';
            ++bk;
            junk[bk] = '\0';
            }
         }
      Twayc = (struct VVT_3Way *) (malloc(Sz3Way));
      if(Twayc == NULL)
         {
         printf("all available memory has been exhausted during VVT 3-way read operation\n");
         exit(1);
         }
      Twayc->next = NULL;

      Twayc->shapename = NULL;
      Twayc->presentvalue1 = NULL;
      Twayc->presentvalue2 = NULL;
      Twayc->depvalue = NULL;
      Twayc->v1 = NULL;
      Twayc->v2 = NULL;
      Twayc->v3 = NULL;
      i = 0;
      while(junk[i] != ',')
         {
         Twayc->FCODE[i] = junk[i];
         ++i;
         if(i > 9)
            {
            printf("Feature code length exception, should be < 10 characters (%s)\n",junk);
            exit(1);
            }
         Twayc->FCODE[i] = '\0';
         }
      Twayc->code = GetCodeIndex(Twayc->FCODE);

      ++i;
      while(junk[i] != ',') /*** skip over the fcode name ***/
         ++i;

      ++i;
      if(junk[i] == 'A')
         Twayc->geom = 1;
      else if(junk[i] == 'S')
         Twayc->geom = 1;
      else if(junk[i] == 'L')
         Twayc->geom = 4;
      else if(junk[i] == 'C')
         Twayc->geom = 4;
      else if(junk[i] == 'P')
         Twayc->geom = 5;
      ++i;
      ++i; /** should now be on first char of the first attr code ***/
      j = 0;
      while(junk[i] != ',')
         {
         value2[j] = junk[i];
         ++i;
         ++j;
         value2[j] = '\0';
         }
      Twayc->Attr1 = GetAttrIndex(value2);
      ++i;
      while(junk[i] != ',')  /** discard the attr name ***/
         ++i;
      ++i;
      j = 0;
      while(junk[i] != ',')
         {
         thisattr[j] = junk[i];
         ++i;
         ++j;
         thisattr[j] = '\0';
         }
      ++i;

      DMc = DMroot;
      while(DMc != NULL)
         {
         if(strcmp(DMc->Dname,thisattr) == 0)
            break;
         DMc = DMc->next;
         }
      if(DMc == NULL)
         {
         printf("could not find enum spec for domain %s\n",thisattr);
         exit(1);
         }
      Twayc->v1 = DMc->ev;

      j = 0;
      while(junk[i] != ',')
         {
         value2[j] = junk[i];
         ++i;
         ++j;
         value2[j] = '\0';
         }
      Twayc->Attr2 = GetAttrIndex(value2);
      ++i;
      while(junk[i] != ',')  /** discard the attr name ***/
         ++i;
      ++i;
      j = 0;
      while(junk[i] != ',')
         {
         thisattr[j] = junk[i];
         ++i;
         ++j;
         thisattr[j] = '\0';
         }
      ++i;

      DMc = DMroot;
      while(DMc != NULL)
         {
         if(strcmp(DMc->Dname,thisattr) == 0)
            break;
         DMc = DMc->next;
         }
      if(DMc == NULL)
         {
         printf("could not find enum spec for domain %s\n",thisattr);
         exit(1);
         }
      Twayc->v2 = DMc->ev;

      j = 0;
      while(junk[i] != ',')
         {
         value2[j] = junk[i];
         ++i;
         ++j;
         value2[j] = '\0';
         }
      Twayc->DependentAttr = GetAttrIndex(value2);
      ++i;
      while(junk[i] != ',')  /** discard the attr name ***/
         ++i;
      ++i;
      j = 0;
      while(junk[i] >= ' ')
         {
         thisattr[j] = junk[i];
         ++i;
         ++j;
         thisattr[j] = '\0';
         }
      DMc = DMroot;
      while(DMc != NULL)
         {
         if(strcmp(DMc->Dname,thisattr) == 0)
            break;
         DMc = DMc->next;
         }
      if(DMc == NULL)
         {
         printf("could not find enum spec for domain %s\n",thisattr);
         exit(1);
         }
      Twayc->v3 = DMc->ev;

      if(TWay_Root == NULL)
         TWay_Root = Twayc;
      else
         Twayp->next = Twayc;

      Twayp = Twayc;

      if(BIN_ATTR_TYPE==1)
         {
         fread(&wchar,1,1,fin);
         }
      else
         {
         fgets(junk,999,fin);
         }
      }
   fclose(fin);

   DMc = DMroot;
   while(DMc != NULL)
      {
      free(DMc->Dname);
      DMc->Dname = NULL;
      DMc = DMc->next;
      }
}


void FreeVVT3WayEntries()
{

   Twayc = TWay_Root;
   while(Twayc != NULL)
      {
      Twayp = Twayc;
      Twayc = Twayc->next;

      if(Twayp->shapename != NULL)
         free(Twayp->shapename);
      if(Twayp->presentvalue1 != NULL)
         free(Twayp->presentvalue1);
      if(Twayp->presentvalue2 != NULL)
         free(Twayp->presentvalue2);
      if(Twayp->depvalue != NULL)
         free(Twayp->depvalue);

      free(Twayp);
      }

   DMc = DMroot;
   while(DMc != NULL)
      {
      DMp = DMc;
      DMc = DMc->next;
      evlc = DMp->ev;
      while(evlc != NULL)
         {
         evlp = evlc;
         evlc = evlc->next;
         if(evlp->value != NULL)
            free(evlp->value);
         if(evlp->label != NULL)
            free(evlp->label);
         free(evlp);
         }
      free(DMp);
      }
}



void AddToVVT3Way(int ECC, int geom, int EAC, char *enumcodestring, char * shapefilename)
{
   Twayc = TWay_Root;
   while(Twayc != NULL)
      {
      if((Twayc->code == ECC) && (Twayc->geom == geom))
         {
         if(Twayc->shapename == NULL)
            {
            Twayc->shapename = (char *) (malloc(strlen(shapefilename) + 2));
            strcpy(Twayc->shapename,shapefilename);
            }
         if(Twayc->Attr1 == EAC)
            {
            evlc = Twayc->v1;
            while(evlc != NULL)
               {
               if(strcmp(enumcodestring,evlc->value) == 0)
                  {
                  Twayc->presentvalue1 = (char *) (malloc(strlen(enumcodestring) + 2));
                  strcpy(Twayc->presentvalue1,enumcodestring);
                  break;
                  }
               evlc = evlc->next;
               }
            if(evlc != NULL)
               break;
            }

         if(Twayc->Attr2 == EAC)
            {
            evlc = Twayc->v2;
            while(evlc != NULL)
               {
               if(strcmp(enumcodestring,evlc->value) == 0)
                  {
                  Twayc->presentvalue2 = (char *) (malloc(strlen(enumcodestring) + 2));
                  strcpy(Twayc->presentvalue2,enumcodestring);
                  break;
                  }
               evlc = evlc->next;
               }
            if(evlc != NULL)
               break;
            }

         if(Twayc->DependentAttr == EAC)
            {
            evlc = Twayc->v3;
            while(evlc != NULL)
               {
               if(strcmp(enumcodestring,evlc->value) == 0)
                  {
                  break;
                  }
               evlc = evlc->next;
               }
            if(evlc == NULL)
               {
               Twayc->depvalue = (char *) (malloc(strlen(enumcodestring) + 2));
               strcpy(Twayc->depvalue,enumcodestring);
               }
            }
         }
      Twayc = Twayc->next;
      }
}


void ResetVVT3Way()
{

   Twayc = TWay_Root;
   while(Twayc != NULL)
      {
      if(Twayc->presentvalue1 != NULL)
         {
         free(Twayc->presentvalue1);
         Twayc->presentvalue1 = NULL;
         }
      if(Twayc->presentvalue2 != NULL)
         {
         free(Twayc->presentvalue2);
         Twayc->presentvalue2 = NULL;
         }
      if(Twayc->depvalue != NULL)
         {
         free(Twayc->depvalue);
         Twayc->depvalue = NULL;
         }
      if(Twayc->shapename != NULL)
         {
         free(Twayc->shapename);
         Twayc->shapename = NULL;
         }
      Twayc = Twayc->next;
      }

}

void ResetPortrayRuleValues(int ECC, int geom)
{
struct PortrayalValues *PVc;
struct RuleAttrs *RAc;

   PVc = NULL;
   switch(geom)
      {
      case 1: PVc = PVF[ECC].surface; break;
      case 4: PVc = PVF[ECC].curve; break;
      case 5: PVc = PVF[ECC].point; break;
      default: printf("geometry mismatch for value %d during capture portray values\n",geom);
              exit(1);
      }
   if(PVc != NULL)
      {
      RAc = PVc->attrs;
      while(RAc != NULL)
         {
         if(RAc->value != NULL)
            {
            free(RAc->value);
            RAc->value = NULL;
            }
         RAc = RAc->next;
         }
      }

}

int PortrayClauseEval(char * rule, struct RuleAttrs *R, int LLindex)
{
int i,j,k,kk;
int answer = 0;
char code[100];
char operator[100];
char value[100];
char endmark;
int rule_val;
int attr_val;
int NegNumber;

   if(R->value == NULL)
      {
      return(answer);
      }
   i =0;
   j = 0;
   if(rule[i] == '{')
      ++i;
   else
      {
      printf("PortrayClauseEval - clause string out of sync\n");
      exit(1);
      }
   while(rule[i] != ' ')
      {
      code[j] = rule[i];
      ++i;
      ++j;
      code[j] = '\0';
      }
   ++i;
   j = 0;
   while(rule[i] != ' ')
      {
      operator[j] = rule[i];
      ++i;
      ++j;
      operator[j] = '\0';
      }
   ++i;
   j = 0;
   if(rule[i] == '"')
      {
      endmark = '"';
      value[j] = '"';
      ++j;
      value[j] = '\0';
      ++i;
      }
   else
      endmark = ';';
   while(rule[i] != endmark)
      {
      value[j] = rule[i];
      ++i;
      ++j;
      value[j] = '\0';
      }
   if(endmark == '"')
      {
      value[j] = '"';
      ++j;
      value[j] = '\0';
      ++i;
      }
   if((strcmp(code,"RTN") != 0) && (strcmp(code,"TXT") != 0))  /** string values ... w/ RTN looking for <> "No Information"  ****/
      sscanf(value,"%d",&rule_val);
   while(R != NULL)
      {
      if(strcmp(code,R->code) == 0)
         break;
      R = R->next;
      }
   if((R != NULL) && (R->value != NULL))
      {
      k = 0;
      kk = 0;
      if((strcmp(R->code,"RTN") != 0) && (strcmp(R->code,"TXT") != 0))
         {
         NegNumber = 0;
         if(R->value[0] == '-')
            {
            NegNumber = 1;
            ++k;
            }
         while((R->value[k] != ' ') && (R->value[k] >= '0') && (R->value[k] <= '9'))
            {
            value[kk] = R->value[k];
            ++k;
            ++kk;
            value[kk] = '\0';
            }
         sscanf(value,"%d",&attr_val);
         if((NegNumber > 0) && (attr_val > 0))
            attr_val = 0 - attr_val;
         }
      if((ATTRTYPE_MGCP4() > 0) || (ATTRTYPE_TDS6() > 0))
         {
         if((strcmp(R->code,"TXT") == 0) && (strcmp(operator,"=") == 0))
            {
            if(strcmp(R->value,value) == 0)
               answer = 1;
            }
         else if((strcmp(operator,"=") == 0) && (rule_val == attr_val))
            answer = 1;
         else if((strcmp(operator,">") == 0) && (attr_val > rule_val))
            answer = 1;
         else if((strcmp(operator,">=") == 0) && (attr_val >= rule_val))
            answer = 1;
         else if((strcmp(operator,"<") == 0) && (attr_val < rule_val))
            answer = 1;
         else if((strcmp(operator,"<=") == 0) && (attr_val <= rule_val))
            answer = 1;
         }
      else
         {
         if(strcmp(operator,"<>") == 0) /*** only time this operator is used is with string valued RTN attribute ***/
            {
            if((strcmp(R->value,"No Information") != 0) && (strstr(R->value,"No Information") == NULL))
               answer = 1;
            }
         if((strcmp(operator,"=") == 0) && ((attr_val == -999999.0) || (rule_val == attr_val)))
            answer = 1;
         else if((strcmp(operator,">") == 0) && ((attr_val == -999999.0) || (attr_val > rule_val)))
            answer = 1;
         else if((strcmp(operator,">=") == 0) && ((attr_val == -999999.0) || (attr_val >= rule_val)))
            answer = 1;
         else if((strcmp(operator,"<") == 0) && ((attr_val == -999999.0) || (attr_val < rule_val)))
            answer = 1;
         else if((strcmp(operator,"<=") == 0) && ((attr_val == -999999.0) || (attr_val <= rule_val)))
            answer = 1;
         }
      }
   return(answer);
}


int PortrayOrEval(char * rule,struct RuleAttrs *R, int LLindex)
{
int i,j;
int answer, cstop;
int level;

   answer = 0; /***** assume expression will fail ****/

   if(strncmp(rule,"{or;",4) != 0)
      {
      printf("PortrayOrEval - clause string out of sync\n");
      exit(1);
      }
   level = 1;
   i = 4;
   while(rule[i] >= ' ')
      {
      if(rule[i] == '{')
         ++level;
      else if(rule[i] == '}')
         --level;
      if(level == 0)
         break;
      ++i;
      }
   if(level == 0)
      cstop = i;
   else
      {
      printf("PortrayOrEval - test 2: clause string out of sync\n");
      exit(1);
      }
   i = 4;
   while(i < cstop)
      {
      if(rule[i] != '{')
         {
         printf("PortrayOrEval - test3: clause string out of sync\n");
         exit(1);
         }
      level = 1;
      j = i;
      ++i;
      while(rule[i] >= ' ')
         {
         if(rule[i] == '{')
            ++level;
         else if(rule[i] == '}')
            --level;
         if(level == 0)
            break;
         ++i;
         }
      ++i;
      if(strncmp(&rule[j],"{and",4) == 0)
         {
         answer = PortrayAndEval(&rule[j],R,LLindex);
         }
      else if(strncmp(&rule[j],"{or",3) == 0)
         {
         answer = PortrayOrEval(&rule[j],R,LLindex);
         }
      else /*** must just be a single clause without logical operator ***/
         {
         answer = PortrayClauseEval(&rule[j],R,LLindex);
         }

      if(answer == 1)
         break;
      }
   if(LLindex >= 0)
      {
      if(answer > 0)
         R->apply_success += LongListInstances[LLindex];
      else
         R->apply_fail += LongListInstances[LLindex];
      }
   else
      {
      if(answer > 0)
         R->apply_success += (0 - LLindex);
      else
         R->apply_fail += (0 - LLindex);
      }
   return(answer);
}




int PortrayAndEval(char * rule,struct RuleAttrs *R, int LLindex)
{
int i,j;
int answer, cstop;
int level;

   answer = 1; /***** assume expression will pass ****/
   
   if(strncmp(rule,"{and;",5) != 0)
      {
      printf("PortrayAndEval - clause string out of sync\n");
      exit(1);
      } 
   level = 1;
   i = 5;
   while(rule[i] >= ' ')
      {
      if(rule[i] == '{')
         ++level;
      else if(rule[i] == '}')
         --level;
      if(level == 0)
         break;
      ++i;
      }
   if(level == 0)
      cstop = i;
   else
      {
      printf("PortrayAndEval - test 2: clause string out of sync\n");
      exit(1);
      }
   i = 5;
   while(i < cstop)
      {
      if(rule[i] != '{')
         {
         printf("PortrayAndEval - test3: clause string out of sync\n");
         exit(1);
         }
      level = 1;
      j = i;
      ++i;
      while(rule[i] >= ' ')
         {
         if(rule[i] == '{')
            ++level;
         else if(rule[i] == '}')
            --level;
         if(level == 0)
            break;
         ++i;
         }
      ++i;
      if(strncmp(&rule[j],"{and",4) == 0)
         {
         answer = PortrayAndEval(&rule[j],R,LLindex);
         }
      else if(strncmp(&rule[j],"{or",3) == 0)
         {
         answer = PortrayOrEval(&rule[j],R,LLindex);
         }
      else /*** must just be a single clause without logical operator ***/
         {
         answer = PortrayClauseEval(&rule[j],R,LLindex);
         }

      if(answer == 0)
         break;
      }
   if(LLindex >= 0)
      {
      if(answer > 0)
         R->apply_success += LongListInstances[LLindex];
      else
         R->apply_fail += LongListInstances[LLindex];
      }
   else
      {
      if(answer > 0)
         R->apply_success += (0 - LLindex);
      else
         R->apply_fail += (0 - LLindex);
      }
   return(answer);
}


int EvaluatePortrayResult(int ECC,int geom, FILE * report, int RoadIndex, int LLindex)
{
struct PortrayalValues *PVc;
struct RuleAttrs *RAc;
struct PortrayRules *PRc;
int answer = 0;  /** default is rule fails, so answer == 0 ***/
int fullanswer = 0; /** did any of the applicable rules succeed ***/
int NumFeatures = 0;

   PVc = NULL;
   switch(geom)
      {
      case 1: PVc = PVF[ECC].surface; break;
      case 4: PVc = PVF[ECC].curve; break;
      case 5: PVc = PVF[ECC].point; break;
      default: printf("geometry mismatch for value %d during capture portray values\n",geom);
              exit(1);
      }
   if(PVc != NULL)
      {
      if(LLindex < 0)
         NumFeatures = 0 - LLindex;  /** should always be 1 but . . .  ***/
      else
         NumFeatures = LongListInstances[LLindex];

      RAc = PVc->attrs;
      PRc = PVc->rules;
      answer = 0;
      while(PRc != NULL)
         {
         if(PVc->attrs == NULL) /** an 'all symbolized' rule ***/
            answer = 1;
         else if(strstr(PRc->rule,"all features symbolized") != NULL)
            answer = 1;
         else if(PRc->rule[0] == '{')
            {
            if(strncmp(&PRc->rule[1],"and",3) == 0)
               {
               answer = PortrayAndEval(PRc->rule,RAc,LLindex);
               }
            else if(strncmp(&PRc->rule[1],"or",2) == 0)
               {
               answer = PortrayOrEval(PRc->rule,RAc,LLindex);
               }
            else /*** must just be a single clause without logical operator ***/
               {
               answer = PortrayClauseEval(PRc->rule,RAc,LLindex);
               if(answer > 0)
                  RAc->apply_success += NumFeatures;
               else
                  RAc->apply_fail += NumFeatures;
               }
            }
         PRc->applied += NumFeatures;
         if(answer > 0)
            {
            PRc->success += NumFeatures;
            }
         fullanswer += answer;
         PRc = PRc->next;
         }

      if(answer == 0)
         {
         fprintf(report,"%d,%s,%s,%s",NumFeatures,
                               GetECCCode(ECC),GetECCLabel(ECC),ParseGAITgeometry((unsigned char) geom, 2));
         RAc = PVc->attrs;
         while(RAc != NULL)
            {
            if(RAc->value == NULL)
               fprintf(report,",%s,%s,Attribute Not Assigned",GetEACCode(RAc->EAC),GetEACLabel(RAc->EAC));
            else
               fprintf(report,",%s,%s,%s",GetEACCode(RAc->EAC),GetEACLabel(RAc->EAC),RAc->value);
   
            RAc = RAc->next;
            }
         fprintf(report,"\n");
         if(PSroot == NULL)
            {
            PSn = (struct PortraySummary *) (malloc(SzPS));
            PSn->ECC = ECC;
            switch(geom)
               {
               case 1: PSn->Scount = NumFeatures; 
                      PSn->Pcount = 0; PSn->Ccount = 0; break;
               case 4: PSn->Ccount = NumFeatures;
                      PSn->Pcount = 0; PSn->Scount = 0; break;
               case 5: PSn->Pcount = NumFeatures; 
                      PSn->Scount = 0; PSn->Ccount = 0; break;
               default: printf("geometry mismatch for value %d during capture portray values\n",geom);
                       exit(1);
               }
            PSn->next = NULL;
            PSroot = PSn;
            }
         else
            {
            PSp = PSc = PSroot;
            while(PSc != NULL)
               {
               if(PSc->ECC == ECC)
                  {
                  switch(geom)
                     {
                     case 1: PSc->Scount += NumFeatures; break;
                     case 4: PSc->Ccount += NumFeatures; break;
                     case 5: PSc->Pcount += NumFeatures; break;
                     }
                  break;
                  }
               else if(ECC < PSc->ECC)
                  {
                  PSn = (struct PortraySummary *) (malloc(SzPS));
                  PSn->ECC = ECC;
                  switch(geom)
                     {
                     case 1: PSn->Scount = NumFeatures; 
                             PSn->Pcount = 0; PSn->Ccount = 0; break;
                     case 4: PSn->Ccount = NumFeatures; 
                             PSn->Pcount = 0; PSn->Scount = 0; break;
                     case 5: PSn->Pcount = NumFeatures; 
                             PSn->Scount = 0; PSn->Ccount = 0; break;
                     }
                  PSn->next = PSc;
                  if(PSc == PSroot)
                     PSroot = PSn;
                  else
                     PSp->next = PSn;
                  break;
                  }
               PSp = PSc;
               PSc = PSc->next;
               }
            if(PSc == NULL)
               {
               PSn = (struct PortraySummary *) (malloc(SzPS));
               PSn->ECC = ECC;
               switch(geom)
                  {
                  case 1: PSn->Scount = NumFeatures; 
                             PSn->Pcount = 0; PSn->Ccount = 0; break;
                  case 4: PSn->Ccount = NumFeatures; 
                             PSn->Pcount = 0; PSn->Scount = 0; break;
                  case 5: PSn->Pcount = NumFeatures; 
                             PSn->Scount = 0; PSn->Ccount = 0; break;
                  }
               PSn->next = NULL;
               PSp->next = PSn;
               }
            }
         }
      } 
   return(fullanswer);

}



void CapturePortrayRuleValue(int ECC, int geom, int EAC, char *value)
{
struct PortrayalValues *PVc;
struct RuleAttrs *RAc;

   PVc = NULL;
   switch(geom)
      {
      case 1: PVc = PVF[ECC].surface; break;
      case 4: PVc = PVF[ECC].curve; break;
      case 5: PVc = PVF[ECC].point; break;
      default: printf("geometry mismatch for value %d during capture portray values\n",geom);
              exit(1);
      }
   if(PVc != NULL)
      {
      RAc = PVc->attrs;
      while(RAc != NULL)
         {
         if(RAc->EAC == EAC)
            {
            if(RAc->value != NULL)
               free(RAc->value);
            RAc->value = (char *) (malloc(strlen(value) + 1));
            strcpy(RAc->value,value);
            break;
            }
         RAc = RAc->next;
         }
      }
}

void FreeOrWritePortrayalRules(int FreeMem, int ReportPortraySuccess, FILE *reptfile)
{
struct PortrayRules *PRc, *PRn;
struct RuleAttrs *RAc, *RAn;
struct PortrayalValues *PVc;
char temp[10];
int i,j;

   if(reptfile == NULL)
      ReportPortraySuccess = 0;

   if(ReportPortraySuccess > 0)
      {
      fprintf(reptfile,"\n\n\n");
      fprintf(reptfile,"FCODE,Feature Name,Geometry,Rule ID,Rule Label,Rule application attempts,# Features Passing this Rule\n");
      }

   for(i=0; i<MaxPortrayRules; i++)
      {
      for(j=0; j<3; j++)
         {
         if(j == 0)
            {
            PVc = PVF[i].curve;
            if(ATTRTYPE_MGCP4() > 0)
               strcpy(temp,"Line");
            else
               strcpy(temp,"Curve");
            }
         else if(j == 1)
            {
            PVc = PVF[i].point;
            strcpy(temp,"Point");
            }
         else
            {
            PVc = PVF[i].surface;
            if(ATTRTYPE_MGCP4() > 0)
               strcpy(temp,"Area");
            else
               strcpy(temp,"Surface");
            }

         if(PVc != NULL)
            {
            if(PVc->rules != NULL)
               {
               PRc = PVc->rules;
               while(PRc != NULL)
                  {
                  if((ReportPortraySuccess > 0) && (PRc->applied > 0))
                     {
                     fprintf(reptfile,"%s,%s,%s,%s,%s,%d,%d\n",
                             GetECCCode(i),GetECCLabel(i),temp,PRc->RuleID,PRc->Rname,PRc->applied,PRc->success);
                     }
                  if(FreeMem > 0)
                     {
                     if(PRc->rule != NULL)
                        free(PRc->rule);
                     if(PRc->Rname != NULL)
                        free(PRc->Rname);
                     }
                  PRn = PRc;
                  PRc = PRc->next;
                  if(FreeMem > 0)
                     {
                     free(PRn);
                     }
                  }
               if(FreeMem > 0)
                  PVc->rules = NULL;
               }
            if(PVc->attrs != NULL)
               {
               RAc = PVc->attrs;
               while(RAc != NULL)
                  {
                  if(FreeMem > 0)
                     {
                     if(RAc->code != NULL)
                        free(RAc->code);
                     if(RAc->value != NULL)
                        free(RAc->value);
                     }
                  RAn = RAc;
                  RAc = RAc->next;
                  if(FreeMem > 0)
                     {
                     free(RAn);
                     }
                  }
               if(FreeMem > 0)
                  PVc->attrs = NULL;
               }
            if(FreeMem > 0)
               {
               free(PVc); 
               }
            }
         if(FreeMem > 0)
            {
            if(j == 0)
               PVF[i].curve = NULL;
            else if(j == 1)
               PVF[i].point = NULL;
            else
               PVF[i].surface = NULL;
            }
         }
      }
}



void ReadPortrayalAttrs(void)
{
FILE *pvin;
char linein[12000];
char junk[12000];
char FCODE[20];
char ACODE[20];
char Rulename[100];
char geom;
int i,j,k,jj,ECC,numrules;
int SzPV = sizeof(struct PortrayalValues);
int SzRA = sizeof(struct RuleAttrs);
int SzPR = sizeof(struct PortrayRules);
struct PortrayRules *PRc, *PRn;
struct RuleAttrs *RAc, *RAp;
struct PortrayalValues *PVc;

   strcpy(junk,GetPVfile());
   if(strcmp(junk,"NOFILE") == 0)
      return;
   pvin = fopen(junk,"rt");
   if(pvin == NULL)
      return;
   for(i=0; i<MaxPortrayRules; i++)
      {
      PVF[i].curve = NULL;
      PVF[i].point = NULL;
      PVF[i].surface = NULL;
      }
   fgets(linein,11999,pvin);
   while(feof(pvin) == 0)
      {
      i = j = 0;
      while(linein[i] != ',')
         {
         FCODE[j] = linein[i];
         ++i;
         ++j;
         FCODE[j] = '\0';
         }
      ++i;
      geom = linein[i];
      i += 2;
      numrules = 0;
      while(linein[i] != ',')
         {
         numrules = numrules * 10 + (int) (linein[i]) - 48;
         ++i;
         }

      ECC = GetCodeIndex(FCODE);  /*** will use this as the array index into PVF array ****/
      PVc = (struct PortrayalValues *) (malloc(SzPV));
      PVc->attrs = NULL;
      PVc->rules = NULL;
      if(geom == 'c')
         PVF[ECC].curve = PVc;
      else if(geom == 'p')
         PVF[ECC].point = PVc;
      else if(geom == 's')
         PVF[ECC].surface = PVc;
      else
         {
         printf("bad geometry flag in Portrayal Rules file (%c encountered)\n FCODE is %s\nLinein is %s\n",geom,FCODE,linein);
         exit(1);
         }

      ++i;
      RAp = NULL;

      if(strncmp(&linein[i],"no attributes",13) != 0)
         {
         while(linein[i] > ' ')
            {
            j = 0;
            while(linein[i] != ',')
               {
               ACODE[j] = linein[i];
               ++i;
               ++j;
               ACODE[j] = '\0';
               if(linein[i] < ' ') /** could also hit newline instead of comma ...  ****/
                  break;
               }

            RAc = (struct RuleAttrs *) (malloc(SzRA));
            RAc->code = (char *) (malloc(strlen(ACODE) + 1));
            strcpy(RAc->code,ACODE);
            RAc->EAC = GetAttrIndex(ACODE);
            RAc->apply_fail = 0;
            RAc->apply_success = 0;
            RAc->value = NULL;
            RAc->next = NULL;
            if(RAp == NULL)
               PVc->attrs = RAc;
            else
               RAp->next = RAc;
            RAp = RAc;
            if(linein[i] == ',')
               ++i;
            }
         }
      PRn = NULL;
      k = 0;
      while(k < numrules)
         {
         fgets(linein,11999,pvin);
         PRc = (struct PortrayRules *) (malloc(SzPR));
         ++k;
         i = 0;
         while(linein[i] != '|')
            {
            PRc->RuleID[i] = linein[i];
            ++i;
            PRc->RuleID[i] = '\0';
            }
         ++i;
         jj = 0;
         while(linein[i] != '|')
            {
            Rulename[jj] = linein[i];
            ++i;
            ++jj;
            Rulename[jj] = '\0';
            }
         ++i;
         PRc->Rname = (char *) (malloc(jj + 2));
         strcpy(PRc->Rname,Rulename);
         PRc->rule = (char *)(malloc(strlen(&linein[i]) + 1));
         strcpy(PRc->rule,&linein[i]);
         PRc->success = 0;
         PRc->applied = 0;
         PRc->next = NULL;
         if(PRn == NULL)
            PVc->rules = PRc;
         else
            PRn->next = PRc;
         PRn = PRc;
         }

      fgets(linein,11999,pvin);
      }
   fclose(pvin);
}




char * GetNextFieldLessQuotes(char *input, int *index, int limit, int *invalid)
{
int i,j;
int onquote;
char endchar;
static char shortanswer[100];
char temp[100];

   *invalid = 0;
   if((*index > 0) && (input[*index] != ','))
      {
      sprintf(shortanswer,"leading comma out of sequence at position %d - input is:\n%s\n",*index,input);
      *invalid = 1;
      return(shortanswer);
      }
   if(input[*index] == ',')
      i = *index + 1;
   else
      i = *index;
   if(input[i] == '"')
      {
      onquote = 1;
      endchar = '"';
      ++i;
      }
   else
      {
      onquote = 0;
      endchar = ',';
      }

   j = 0;
   while(input[i] != endchar)
      {
      shortanswer[j] = input[i];
      ++i;
      ++j;
      shortanswer[j] = '\0';
      if(input[i] < ' ')
         break;
      }
   if(j > limit)
      {
      sprintf(temp,"field length exceeds limit of %d characters\n",limit);
      strcat(shortanswer,temp);
      *invalid = 1;
      }
   if(onquote > 0)
      ++i;  /** should now be on a comma ***/

   *index = i;
   return(shortanswer);
}



char * ParseUserVVFiles(char * BaseFile, char *DomainFile)
{
FILE *vvtin, *vvtdomin;
char junk[1000];
char temp[1000];
char temp2[1000];
char temp3[500];
char featurename[200];
char dname[100];
char thisname[100];
char thisattr[100];
char depattr[100];
char evalue[100];
char value2[100];
char DT[20];
char InEq[10];
int optreq,datatype;
int InEquality;
char domain[100];
char geom;
static char ParseResult[100];
double set_value;
int i,j, k, kk, g, negsign, decimalpt, linenumber, invalid, isboolean;
int attrcode,featindex,findex;
int SzDom = sizeof(struct VVTdomains);
int SzEl = sizeof(struct elist);
int SzVVT = sizeof(struct MGCP_VVT);
int SzAttr = sizeof(struct MGCP_VVT_attr);
int SzDep = sizeof(struct MGCP_VVT_depend);
extern char *NFDD_attr_types[];
extern char *DFDD_attr_types[];

   ParseResult[0] = '\0';

   if(ATTRINSTYPE != 4)
      return(ParseResult);

   MGCP_VVT_root = NULL;

   vvtin = vvtdomin = NULL;
   vvtin = fopen(BaseFile,"rt");
   if(vvtin == NULL)
      {
      sprintf(ParseResult,"Failed to open Valid Value specification file %s\n",BaseFile);
      return(ParseResult);
      }

   vvtdomin = fopen(DomainFile,"rt");

   if(vvtdomin == NULL)
      {
      fclose(vvtin);
      sprintf(ParseResult,"Failed to open domain file %s\n",DomainFile);
      return(ParseResult);
      }

   VVTdomainRoot = NULL;
   strcpy(dname,"Z1Z2zx3--aA5ZzZzZzZz");

   fgets(junk,999,vvtdomin);  /** discard header line **/
   fgets(junk,999,vvtdomin);
   linenumber = 2;
   while(feof(vvtdomin) == 0)
      {
      i = k = 0;
      while(junk[i] >= ' ')
         {
         if(junk[i] == '"')
            {
            ++i;
            while(junk[i] != '"')
               {
               if(junk[i] < ' ')
                  {
                  sprintf(ParseResult,"Domain file has unbalanced quotation marks on input line number %d\n",linenumber);
                  if(VVTdomainRoot != NULL)
                     FreeVVTstructs();
                  fclose(vvtin);
                  fclose(vvtdomin);
                  return(ParseResult);
                  }
               ++i;
               }
            ++i;
            }
         else if(junk[i] == ',')
            ++k;

         ++i;
         }
      if(k != 3)
         {
         sprintf(ParseResult,"Each domain file entry should have 4 comma-delimited fields; found %d fields on input line number %d\n",
                  k + 1,linenumber);
         if(VVTdomainRoot != NULL)
            FreeVVTstructs();
         fclose(vvtin);
         fclose(vvtdomin);
         return(ParseResult);
         }
      else if(i > 989)
         {
         sprintf(ParseResult,"Each domain file entry should be less than 990 characters; additional characters on input line number %d\n",
                   linenumber);
         if(VVTdomainRoot != NULL)
            FreeVVTstructs();
         fclose(vvtin);
         fclose(vvtdomin);
         return(ParseResult);
         }
      i = 0;

      strcpy(thisname,GetNextFieldLessQuotes(junk,&i,25,&invalid)); 
      if(invalid > 0)
         {
         sprintf(ParseResult,"Domain name needs to be shortened (%s); input line %d\n",
              thisname, linenumber);
         if(VVTdomainRoot != NULL)
            FreeVVTstructs();
         fclose(vvtin);
         fclose(vvtdomin);
         return(ParseResult);
         }

      if(strcmp(thisname,dname) != 0)  /*** found a new domain listing ****/
         {
         if(VVTdomainRoot != NULL)
            {
            VVTdomp = VVTdomainRoot;
            while(VVTdomp != NULL)
               {
               if(strcmp(VVTdomp->name,thisname) == 0)  /*** found an out of order domain listing ***/
                  break;
               VVTdomp = VVTdomp->next;
               }
            if(VVTdomp != NULL)
               {
               sprintf(ParseResult,"Domain entries should be contiguous; at least domain %s is between entries for domain %s\n",
                                 dname,thisname);
               if(VVTdomainRoot != NULL)
                  FreeVVTstructs();
            
               fclose(vvtin);
               fclose(vvtdomin);
               return(ParseResult);
               }
            }
         strcpy(dname,thisname);
         VVTdomc = (struct VVTdomains *) (malloc(SzDom));
         if(VVTdomc == NULL)
            {
            printf("all availble memory has been consumed during attribute dependency analysis parsing\n  exiting now\n");
            exit(-1);
            }
         VVTdomc->name = (char *) (malloc(i+1));
         strcpy(VVTdomc->name,thisname);
         VVTdomc->values = NULL;
         VVTdomc->next = NULL;
         if(VVTdomainRoot == NULL)
            VVTdomainRoot = VVTdomc;
         else
            {
            VVTdomp = VVTdomainRoot;
            while(VVTdomp->next != NULL)
               VVTdomp = VVTdomp->next;
            VVTdomp->next = VVTdomc;
            }
         }

      datatype = 99;
      if(strncmp(&junk[i+1],"Short Integer",13) == 0)
         datatype = 1;
      else if(strncmp(&junk[i+1],"Enumeration",11) == 0)
         datatype = 1;
      else if(strncmp(&junk[i+1],"Real",4) == 0)
         datatype = 2;
      else if(strncmp(&junk[i+1],"String",6) == 0)
         datatype = 3;
      else if(strncmp(&junk[i+1],"Integer",7) == 0)
         datatype = 4;

      if(datatype > 2)
         {
         sprintf(ParseResult,"Data type specifications must be one of 'Enumeration' or 'Real'; found %s on input line %d\n",
                                 &junk[i+1],linenumber);
         if(VVTdomainRoot != NULL)
            FreeVVTstructs();

         fclose(vvtin);
         fclose(vvtdomin);
         return(ParseResult);
         }
      if(datatype >= 0)
         {
         strcpy(temp,GetNextFieldLessQuotes(junk,&i,99,&invalid)); /*** don't really care about datatype now ... ***/
         strcpy(evalue,GetNextFieldLessQuotes(junk,&i,99,&invalid));

         if(datatype >= 1)
            strcpy(value2,GetNextFieldLessQuotes(junk,&i,50,&invalid));
         if((datatype > 1) && (strcmp(evalue,"*EQ*") == 0))
            {
            if((value2[0] < '0') || (value2[0] > '9'))
               {
               if(value2[0] != '-')
                  {
                  sprintf(ParseResult,"Numeric specifications must be well formed; found %s on input line %d\n", value2,linenumber);
                  if(VVTdomainRoot != NULL)
                     FreeVVTstructs();

                  fclose(vvtin);
                  fclose(vvtdomin);
                  return(ParseResult);
                  }
               }
            kk = negsign = decimalpt = 0;
            j = strlen(value2);
            for(k=0; k<j; k++)
               {
               if(value2[k] == '.')
                  ++decimalpt;
               else if(value2[k] == '-')
                  ++negsign;
               else if((value2[k] < '0') || (value2[k] > '9'))
                  ++kk;
               }
            if(decimalpt > 1)
               {
               sprintf(ParseResult,"Numeric specifications must be well formed; found multiple decimal points in %s on input line %d\n",
                        value2,linenumber);
               if(VVTdomainRoot != NULL)
                  FreeVVTstructs();

               fclose(vvtin);
               fclose(vvtdomin);
               return(ParseResult);
               }
            if(negsign > 1)
               {
               sprintf(ParseResult,"Numeric specifications must be well formed; found multiple negative signs in %s on input line %d\n",
                         value2,linenumber);
               if(VVTdomainRoot != NULL)
                  FreeVVTstructs();

               fclose(vvtin);
               fclose(vvtdomin);
               return(ParseResult);
               }
            if(kk > 0)
               {
               sprintf(ParseResult,"Numeric specifications must be well formed; found non-digit character in %s on input line %d\n",
                         value2,linenumber);
               if(VVTdomainRoot != NULL)
                  FreeVVTstructs();

               fclose(vvtin);
               fclose(vvtdomin);
               return(ParseResult);
               }
            }
         VVTec = (struct elist *) (malloc(SzEl));
         if(VVTec == NULL)
            {
            printf("all availble memory has been consumed during attribute dependency analysis preparation\n  exiting now\n");
            exit(-1);
            }
         VVTec->dt = datatype;
         VVTec->evalue = (char *) (malloc(strlen(evalue) + 1));
         strcpy(VVTec->evalue,evalue);
            VVTec->value2 = (char *) (malloc(strlen(value2) + 1));
            strcpy(VVTec->value2,value2);
         VVTec->next = NULL;
         if(VVTdomc->values == NULL)
            {
            VVTdomc->values = VVTec;
            }
         else
            {
            VVTep = VVTdomc->values;
            while(VVTep->next != NULL)
               VVTep = VVTep->next;
            VVTep->next = VVTec;
            }
         }

      fgets(junk,999,vvtdomin);
      ++linenumber;
      }

   fclose(vvtdomin);


   strcpy(dname,"Z1Z2zx3--aA5ZzZzZzZz");
   fgets(junk,999,vvtin);  /** discard header line **/
   fgets(junk,999,vvtin);
   linenumber = 2;
   while(feof(vvtin) == 0)
      {
      i = k = 0;
      while(junk[i] >= ' ')
         {
         if(junk[i] == '"')
            {
            ++i;
            while(junk[i] != '"')
               {
               if(junk[i] < ' ')
                  {
                  sprintf(ParseResult,"Valid Value file has unbalanced quote marks on input line number %d\n",linenumber);
                  if(VVTdomainRoot != NULL)
                     FreeVVTstructs();
                  fclose(vvtin);
                  return(ParseResult);
                  }
               ++i;
               }
            ++i;
            }
         if(junk[i] == ',')
            ++k;

         ++i;
         }
      if(k != 12)
         {
         sprintf(ParseResult,
             "Each Valid Value file entry should have 13 comma-delimited fields; found %d fields on input line number %d\n",
                  k + 1,linenumber);
         if(VVTdomainRoot != NULL)
            FreeVVTstructs();
         fclose(vvtin);
         return(ParseResult);
         }
      else if(i > 989)
         {
         sprintf(ParseResult,
                    "Each Valid Value file entry should be less than 990 characters; additional characters on input line number %d\n",
                   linenumber);
         if(VVTdomainRoot != NULL)
            FreeVVTstructs();
         fclose(vvtin);
         return(ParseResult);
         }
      i = 0;
      strcpy(featurename,GetNextFieldLessQuotes(junk,&i,40,&invalid));
      strcpy(thisname,GetNextFieldLessQuotes(junk,&i,40,&invalid)); /*** should hold the fcode ***/
      findex = strlen(thisname);
      featindex = GetCodeIndex(thisname);
      strcpy(temp3,GetECCCode(featindex));
      if(strcmp(thisname,temp3) != 0)
         {
         sprintf(ParseResult,
            "the feature code %s is not defined in the current schema; found references on input line number %d\n",
                  thisname,linenumber);
         if(VVTdomainRoot != NULL)
            FreeVVTstructs();
         fclose(vvtin);
         return(ParseResult);
         }
      
      strcpy(temp3,GetECCLabel(featindex));
      if(strcmp(featurename,temp3) != 0)
         {
         sprintf(ParseResult,
            "the feature %s is not defined in the current schema; found references on input line number %d\n",
                  featurename,linenumber);
         if(VVTdomainRoot != NULL)
            FreeVVTstructs();
         fclose(vvtin);
         return(ParseResult);
         }

      strcpy(temp,GetNextFieldLessQuotes(junk,&i,1,&invalid));
      if(invalid > 0)
         {
         sprintf(ParseResult,
             "The geometry field should be a single character ('p', 'a', or 'l'); found %s on input line number %d\n",
                  temp,linenumber);
         if(VVTdomainRoot != NULL)
            FreeVVTstructs();
         fclose(vvtin);
         return(ParseResult);
         }
      geom = temp[0];

      k = strlen(thisname);
      thisname[k] = geom;
      ++k;
      thisname[k] = '\0';

      strcpy(thisattr,GetNextFieldLessQuotes(junk,&i,25,&invalid));
      attrcode = GetAttrIndex(thisattr);
      if(attrcode >= 0)
         strcpy(temp3,GetEACCode(attrcode));
      if((attrcode < 0) || (strcmp(thisattr,temp3) != 0))
         {
         sprintf(ParseResult,
            "the attribute code %s is invalid in the currently selected schema; found reference on input line number %d\n",
                  thisattr,linenumber);
         if(VVTdomainRoot != NULL)
            FreeVVTstructs();
         fclose(vvtin);
         return(ParseResult);
         }
      strcat(thisname,thisattr);
      
      strcpy(temp,GetNextFieldLessQuotes(junk,&i,100,&invalid)); /** don't really care about the attr label ... ***/
      strcpy(temp2,GetEACLabel(attrcode));
      if(strcmp(temp,temp2) != 0)
         {
         sprintf(ParseResult,
            "the attribute code %s does not correspond to the attribute label %s; found references on input line number %d\n",
                  thisattr,temp2,linenumber);
         if(VVTdomainRoot != NULL)
            FreeVVTstructs();
         fclose(vvtin);
         return(ParseResult);
         }
      strcpy(DT,GetNextFieldLessQuotes(junk,&i,40,&invalid));
      k = 99;
      if(strncmp(DT,"Short Integer",13) == 0)
         k = 1;
      else if(strncmp(DT,"Enumeration",11) == 0)
         k = 1;
      else if(strncmp(DT,"Real",4) == 0)
         k = 2;
      else if(strncmp(DT,"Real>",5) == 0)
         k = 2;
      else if(strncmp(DT,"Real>=",6) == 0)
         k = 2;
      else if(strncmp(DT,"Real<",5) == 0)
         k = 2;
      else if(strncmp(DT,"Real<=",6) == 0)
         k = 2;
      else if(strncmp(DT,"Real=",5) == 0)
         k = 2;
      else if(strncmp(DT,"String",6) == 0)
         k = 3;
      else if(strncmp(DT,"Integer",7) == 0)
         k = 4;
      else if(strncmp(DT,"Integer>",5) == 0)
         k = 4;
      else if(strncmp(DT,"Integer>=",6) == 0)
         k = 4;
      else if(strncmp(DT,"Integer<",5) == 0)
         k = 4;
      else if(strncmp(DT,"Integer<=",6) == 0)
         k = 4;
      else if(strncmp(DT,"Integer=",5) == 0)
         k = 4;
      if(k > 10)
         {
         sprintf(ParseResult,
            "the data type %s is not defined for use in valid value inspection files; found references on input line number %d\n",
                  DT,linenumber);
         if(VVTdomainRoot != NULL)
            FreeVVTstructs();
         fclose(vvtin);
         return(ParseResult);
         }
      k = strlen(DT);

      if((DT[k-1] >= '<') && (DT[k-1] <= '>')) /** this includes '<' = 60, '=' = 61 and '>' = 62 ASCII Decimal ***/
         {
         k = 0;
         while((DT[k] < '<') || (DT[k] > '>'))
            ++k;
         kk = 0;
         while((DT[k] >= '<') && (DT[k] <= '>')) /** this will grab off the trailing '>', '>=', '=', '<', or '<=' ***/
            {
            InEq[kk] = DT[k];
            ++kk;
            DT[k] = '\0';
            ++k;
            }
         InEq[kk] = '\0';
         }
      else
         InEq[0] = '\0';

      strcpy(temp,GetNextFieldLessQuotes(junk,&i,1,&invalid));
      optreq = 0;

      if(temp[0] == 'O')
         optreq = -1;
      else if(temp[0] == 'M')
         optreq = -2;
      else
         {
         sprintf(ParseResult,
             "The optional / mandatory field should be a single character ('O' or 'M'); found %s on input line number %d\n",
                  temp,linenumber);
         if(VVTdomainRoot != NULL)
            FreeVVTstructs();
         fclose(vvtin);
         return(ParseResult);
         }

      if(optreq < 0)
         {
         strcpy(domain,GetNextFieldLessQuotes(junk,&i,25,&invalid));

         InEquality = 0;
         if(strcmp(domain,"GTEQ") == 0)
            InEquality = 1;
         else if(strcmp(domain,"GT") == 0)
            InEquality = 2;
         else if(strcmp(domain,"LTEQ") == 0)
            InEquality = 3;
         else if(strcmp(domain,"LT") == 0)
            InEquality = 4;
         else if(strcmp(domain,"EQUALS") == 0)
            InEquality = 5;
         else if((strncmp(DT,"Short Integer",13) != 0) && (strncmp(DT,"Enumeration",11) != 0) &&
                      (InEq[0] != '\0') && (AllDigits(domain, 1) > 0))
            {
            if((InEq[0] == '=') && (InEq[1] == '\0'))
               InEquality = 6;
            else if(InEq[0] == '<')
               {
               if(InEq[1] == '\0')
                  InEquality = 7;
               else if(InEq[1] == '=')
                  InEquality = 9;
               }
            else if(InEq[0] == '>')
               {
               if(InEq[1] == '\0')
                  InEquality = 8;
               else if(InEq[1] == '=')
                  InEquality = 10;
               }
            sscanf(domain,"%lf",&set_value);
            }
         VVTdomc = NULL;
         if(InEquality == 0)
            {
            VVTdomc = VVTdomainRoot;
            while(VVTdomc != NULL)
               {
               if(strcmp(domain,VVTdomc->name) == 0)
                  break;
               VVTdomc = VVTdomc->next;
               }
            if(VVTdomc == NULL)
               {
               sprintf(ParseResult,
                "The domain %s has not been defined for use in valid value inspections; found reference on input line number %d\n",
                  domain,linenumber);
               if(VVTdomainRoot != NULL)
                  FreeVVTstructs();
               fclose(vvtin);
               return(ParseResult);
               }
            else
               {
               VVTec = VVTdomc->values;
               while(VVTec != NULL)
                  {
                  if((strstr(VVTec->evalue,"-3276") == NULL) && (strstr(VVTec->evalue,"-999999") == NULL) &&
                        (strcmp(VVTec->evalue,"998") != 0) && (strcmp(VVTec->evalue,"999") != 0))
                     {
                     isboolean = 0;
                     if((ATTRTYPE_NFDD() > 0) && (strcmp(NFDD_attr_types[attrcode-1],"Boolean") == 0)) /*** NFDD ***/
                        isboolean = 1;
                     else if((ATTRTYPE_DFDD() > 0) && (strcmp(DFDD_attr_types[attrcode-1],"Boolean") == 0)) /*** DFDD ***/
                        isboolean = 1;

                     if(isboolean > 0)
                        {
                        if((strcmp(VVTec->evalue,"1000") != 0) && (strcmp(VVTec->evalue,"1001") != 0))
                           {
                           sprintf(ParseResult,
                              "The boolean value code %s has not been defined for use with attribute %s (see domain %s)\n",
                                      VVTec->evalue,GetEACLabel(attrcode),VVTdomc->name);
                           if(VVTdomainRoot != NULL)
                              FreeVVTstructs();
                           fclose(vvtin);
                           return(ParseResult);
                           }
                        if((strcmp(VVTec->value2,"True") != 0) && (strcmp(VVTec->value2,"False") != 0))
                           {
                           sprintf(ParseResult,
                              "The boolean value label %s has not been defined for use with attribute %s (see domain %s)\n",
                                      VVTec->evalue,GetEACLabel(attrcode),VVTdomc->name);
                           if(VVTdomainRoot != NULL)
                              FreeVVTstructs();
                           fclose(vvtin);
                           return(ParseResult);
                           }
                        }
                     else
                        {
                        k = GetEEindex(attrcode,VVTec->evalue);
                        if(k < 0)
                           {
                           sprintf(ParseResult,
                              "The enumerated value code %s has not been defined for use with attribute %s (see domain %s)\n",
                                      VVTec->evalue,GetEACLabel(attrcode),VVTdomc->name);
                           if(VVTdomainRoot != NULL)
                              FreeVVTstructs();
                           fclose(vvtin);
                           return(ParseResult);
                           }
                        else
                           {
                           strcpy(temp2,GetEELabel(attrcode,k));
                           if(strcmp(temp2,VVTec->value2) != 0)
                              {
                              sprintf(ParseResult,
                           "The enumerated value %s has not been defined for use with attribute %s, enumerate code %s (see domains %s)\n",
                                   VVTec->value2,GetEACLabel(attrcode),VVTec->evalue,VVTdomc->name);
                              if(VVTdomainRoot != NULL)
                                 FreeVVTstructs();
                              fclose(vvtin);
                              return(ParseResult);
                              }
                           }
                        }
                     }
                     
                  VVTec = VVTec->next;
                  }
               }
            }

         strcat(thisname,domain);

         if(strcmp(thisname,dname) != 0) /** a new fcode, geom, attr, attr value domain specification **/
            {
            strcpy(dname,thisname);
            thisname[findex] = '\0'; /*** strip off all following the fcode **/
            g = -1;
            switch(geom)
               {
               case 'A':
                  g = 1;
                  break;
               case 'L':
                  g = 4;
                  break;
               case 'P':
                  g = 5;
                  break;
               case '_':
                  g = 99;
                  break;
               }
            MGCP_Vc = MGCP_VVT_root;
            while(MGCP_Vc != NULL)
               {
               if((strcmp(MGCP_Vc->FCODE,thisname) == 0) && (MGCP_Vc->geom == g))
                  break;
               MGCP_Vc = MGCP_Vc->next;
               }
            if(MGCP_Vc == NULL)
               {
               MGCP_Vc = (struct MGCP_VVT *) (malloc(SzVVT));
               if(MGCP_Vc == NULL)
                  {
                  printf("all available memory has been consumed during MGCP attribute dependency analysis preparation\n  exiting now\n");
                  exit(-1);
                  }
               strcpy(MGCP_Vc->FCODE,thisname);
               if((thisname[0] == '_') || (strcmp(thisname,"ANY FEATURE") == 0))
                  MGCP_Vc->code = -99;
               else
                  MGCP_Vc->code = GetCodeIndex(thisname);
               MGCP_Vc->geom = g;
               MGCP_Vc->a = NULL;
               MGCP_Vc->o = NULL;
               MGCP_Vc->shapename = NULL;
               MGCP_Vc->next = NULL;
               if(MGCP_VVT_root == NULL)
                  MGCP_VVT_root = MGCP_Vc;
               else
                  {
                  MGCP_Vp = MGCP_VVT_root;
                  while(MGCP_Vp->next != NULL)
                     MGCP_Vp = MGCP_Vp->next;
                  MGCP_Vp->next = MGCP_Vc;
                  }
               }
            VVTac = (struct MGCP_VVT_attr *) (malloc(SzAttr));
            if(VVTac == NULL)
               {
               printf("all available memory has been consumed during MGCP attribute dependency analysis preparation\n  exiting now\n");
               exit(-1);
               }
            VVTac->attr = attrcode;
            VVTac->inequality = InEquality;
            VVTac->lav = NULL; /*** will add the list of long attr values as necessary ***/
            if((InEquality >= 6) && (InEquality <= 10))
               VVTac->SetValue = set_value;
            else
               VVTac->SetValue = -12345.0;
            VVTac->dep = NULL;
            VVTac->dom = VVTdomc;
            VVTac->presentvalue = NULL;

            VVTac->next = NULL;
            if(MGCP_Vc->a == NULL)
               MGCP_Vc->a = VVTac;
            else
               {
               VVTap = MGCP_Vc->a;
               while(VVTap->next != NULL)
                  VVTap = VVTap->next;
               VVTap->next = VVTac;
               }

            }

         strcpy(depattr,GetNextFieldLessQuotes(junk,&i,25,&invalid));
         attrcode = GetAttrIndex(depattr);
      if(attrcode >= 0)
         strcpy(temp3,GetEACCode(attrcode));
      if((attrcode < 0) || (strcmp(depattr,temp3) != 0))
         {
         sprintf(ParseResult,
            "the attribute code %s is invalid in the currently selected schema; found reference on input line number %d\n",
                  depattr,linenumber);
         if(VVTdomainRoot != NULL)
            FreeVVTstructs();
         fclose(vvtin);
         return(ParseResult);
         }
      strcat(thisname,thisattr);
         VVTdc = (struct MGCP_VVT_depend *) (malloc(SzDep));
         if(VVTdc == NULL)
            {
            printf("all avaialble memory has been consumed during MGCP attribute dependency analysis preparation\n  exiting now\n");
            exit(-1);
            }
         VVTdc->attr = attrcode;

         strcpy(temp,GetNextFieldLessQuotes(junk,&i,100,&invalid)); /*** attr name ***/
         strcpy(temp2,GetEACLabel(attrcode));
         if(strcmp(temp,temp2) != 0)
            {
            sprintf(ParseResult,
               "the attribute code %s does not correspond to the attribute label %s; found references on input line number %d\n",
                  depattr,temp2,linenumber);
            if(VVTdomainRoot != NULL)
               FreeVVTstructs();
            fclose(vvtin);
            return(ParseResult);
            }

         strcpy(temp,GetNextFieldLessQuotes(junk,&i,50,&invalid)); /*** attr type ****/
         k = 99;
         if(strncmp(DT,"Short Integer",13) == 0)
            k = 1;
         else if(strncmp(DT,"Enumeration",11) == 0)
            k = 1;
         else if(strncmp(DT,"Real",4) == 0)
            k = 2;
         else if(strncmp(DT,"String",6) == 0)
            k = 3;
         else if(strncmp(DT,"Integer",7) == 0)
            k = 4;
         if(k > 10)
            {
            sprintf(ParseResult,
               "the data type %s is not defined for use in valid value inspection files; found references on input line number %d\n",
                  DT,linenumber);
            if(VVTdomainRoot != NULL)
               FreeVVTstructs();
            fclose(vvtin);
            return(ParseResult);
            }

         strcpy(domain,GetNextFieldLessQuotes(junk,&i,25,&invalid)); /*** second domain name ***/

         VVTdomc = NULL;
         if((InEquality == 0) || (InEquality > 5))
            {
            VVTdomc = VVTdomainRoot;
            while(VVTdomc != NULL)
               {
               if(strcmp(domain,VVTdomc->name) == 0)
                  break;
               VVTdomc = VVTdomc->next;
               }
            if(VVTdomc == NULL)
               {
               sprintf(ParseResult,
                "The domain %s has not been defined for use in valid value inspections; found reference on input line number %d\n",
                  domain,linenumber);
               if(VVTdomainRoot != NULL)
                  FreeVVTstructs();
               fclose(vvtin);
               return(ParseResult);
               }
            else
               {
               VVTec = VVTdomc->values;
               while(VVTec != NULL)
                  {
                  if((strstr(VVTec->evalue,"-3276") == NULL) && (strstr(VVTec->evalue,"-999999") == NULL) &&
                        (strcmp(VVTec->evalue,"998") != 0) && (strcmp(VVTec->evalue,"999") != 0) &&
                              (strcmp(VVTec->evalue,"*EQ*") != 0))
                     {
                     isboolean = 0;
                     if((ATTRTYPE_NFDD() > 0) && (strcmp(NFDD_attr_types[attrcode-1],"Boolean") == 0))  /** NFDD **/
                        isboolean = 1;
                     else if((ATTRTYPE_DFDD() > 0) && (strcmp(DFDD_attr_types[attrcode-1],"Boolean") == 0))  /** DFDD **/
                        isboolean = 1;

                     if(isboolean > 0)
                        {
                        if((strcmp(VVTec->evalue,"1000") != 0) && (strcmp(VVTec->evalue,"1001") != 0))
                           {
                           sprintf(ParseResult,
                              "The boolean value code %s has not been defined for use with attribute %s (see domain %s)\n",
                                      VVTec->evalue,GetEACLabel(attrcode),VVTdomc->name);
                           if(VVTdomainRoot != NULL)
                              FreeVVTstructs();
                           fclose(vvtin);
                           return(ParseResult);
                           }
                        if((strcmp(VVTec->value2,"True") != 0) && (strcmp(VVTec->value2,"False") != 0))
                           {
                           sprintf(ParseResult,
                              "The boolean value label %s has not been defined for use with attribute %s (see domain %s)\n",
                                      VVTec->evalue,GetEACLabel(attrcode),VVTdomc->name);
                           if(VVTdomainRoot != NULL)
                              FreeVVTstructs();
                           fclose(vvtin);
                           return(ParseResult);
                           }
                        }
                     else
                        {
                        k = GetEEindex(attrcode,VVTec->evalue);
                        if(k < 0)
                           {
                           sprintf(ParseResult,
                              "The enumerated value code %s has not been defined for use with attribute %s (see domain %s)\n",
                                      VVTec->evalue,GetEACLabel(attrcode),VVTdomc->name);
                           if(VVTdomainRoot != NULL)
                              FreeVVTstructs();
                           fclose(vvtin);
                           return(ParseResult);
                           }
                        else
                           {
                           strcpy(temp2,GetEELabel(attrcode,k));
                           if(strcmp(temp2,VVTec->value2) != 0)
                              {
                              sprintf(ParseResult,
                           "The enumerated value %s has not been defined for use with attribute %s, enumerate code %s (see domains %s)\n",
                                   VVTec->value2,GetEACLabel(attrcode),VVTec->evalue,VVTdomc->name);
                              if(VVTdomainRoot != NULL)
                                 FreeVVTstructs();
                              fclose(vvtin);
                              return(ParseResult);
                              }
                           }
                        }
                     }

                  VVTec = VVTec->next;
                  }
               }
            }
         VVTdc->d = VVTdomc;
         VVTdc->req = optreq;
         VVTdc->isok = 0;
         VVTdc->next = NULL;
         if(VVTac->dep == NULL)
            VVTac->dep = VVTdc;
         else
            {
            VVTdp = VVTac->dep;
            while(VVTdp->next != NULL)
               VVTdp = VVTdp->next;
            VVTdp->next = VVTdc;
            }

         } /*** end have an optreq field < 0 ***/

      fgets(junk,999,vvtin);
      ++linenumber;
      }


   fclose(vvtin);

   if(MGCP_VVT_root != NULL)
      FreeVVTstructs();

   return(ParseResult);
}




void ReadVVTentries()
{
FILE *vvtin, *vvtdomin;
char junk[1000];
char dname[100];
char thisname[100];
char thisattr[100];
char depattr[100];
char evalue[100];
char value2[100];
char DT[20];
char InEq[10];
char slen[10];
char wchar;
int optreq,datatype;
int InEquality;
char domain[100];
char geom;
double set_value;
int i,j, k, kk, g, bi, bj, bk;
int attrcode;
int SzDom = sizeof(struct VVTdomains);
int SzEl = sizeof(struct elist);
int SzVVT = sizeof(struct MGCP_VVT);
int SzAttr = sizeof(struct MGCP_VVT_attr);
int SzDep = sizeof(struct MGCP_VVT_depend);

   MGCP_VVT_root = NULL;
   vvtin = vvtdomin = NULL;
   strcpy(junk,GetVVFile());
   if(BIN_ATTR_TYPE==1)
      vvtin = fopen(junk,"rb");
   else
      vvtin = fopen(junk,"rt");

   strcpy(junk,GetVVDomainsFile());
   if(BIN_ATTR_TYPE==1)
      vvtdomin = fopen(junk,"rb");
   else
      vvtdomin = fopen(junk,"rt"); 

   if((vvtin == NULL) || (vvtdomin == NULL))
      {
      return;
      }


   VVTdomainRoot = NULL;
   strcpy(dname,"Z1Z2zx3--aA5ZzZzZzZz");

   if(BIN_ATTR_TYPE==1)
      {
      fread(&wchar,1,1,vvtdomin);
      }
   else
      {
      fgets(junk,999,vvtdomin);  /** discard header line **/
      fgets(junk,999,vvtdomin);
      }

   while(feof(vvtdomin) == 0)
      {
      if(BIN_ATTR_TYPE==1)
         {
         if(wchar == '\0')
            break;
         else
            {
            bi = (int) wchar;
            fread(slen,bi,1,vvtdomin);
            slen[bi] = '\0';
            bj = 0;
            bk = 0;
            while(slen[bj] != '\0')
               {
               bk = bk * 10 + ((int) (slen[bj] - 48));
               ++bj;
               }
            fread(junk,bk,1,vvtdomin);
            junk[bk] = '\n';
            ++bk;
            junk[bk] = '\0';
            }
         }

      i = 0;
      while(junk[i] != ',')
         ++i;  /*** should be at end of domain name ***/
      junk[i] = '\0';
      strcpy(thisname,junk);
      if(strcmp(thisname,dname) != 0)
         {
         strcpy(dname,thisname);
         VVTdomc = (struct VVTdomains *) (malloc(SzDom));
         if(VVTdomc == NULL)
            {
            printf("all availble memory has been consumed during attribute dependency analysis preparation\n  exiting now\n");
            exit(-1);
            }
         VVTdomc->name = (char *) (malloc(i+1));
         strcpy(VVTdomc->name,thisname);
         VVTdomc->values = NULL;
         VVTdomc->next = NULL;
         if(VVTdomainRoot == NULL)
            VVTdomainRoot = VVTdomc;
         else
            {
            VVTdomp = VVTdomainRoot;
            while(VVTdomp->next != NULL)
               VVTdomp = VVTdomp->next;
            VVTdomp->next = VVTdomc;
            }
         }
      ++i;
      if(strncmp(&junk[i],"Short Integer",13) == 0)
         datatype = 1;
      else if(strncmp(&junk[i],"Real",4) == 0)
         datatype = 2;
      else if(strncmp(&junk[i],"String",6) == 0)
         datatype = 3;
      else if(strncmp(&junk[i],"Integer",7) == 0)
         datatype = 4;

      else
         {
         datatype = -1;
         printf("bad type specification in file of Valid Value - Attribute Dependencies\n");
         printf("found:   %s\n",&junk[i]);
         }
      if(datatype >= 0)
         {
         while(junk[i] != ',')
            ++i;
         ++i;
         j = 0;
         while(junk[i] != ',')
            {
            evalue[j] = junk[i];
            ++i;
            ++j;
            }
         evalue[j] = '\0';
         if(datatype > 1)
            {
            ++i;
            j = 0;
            while(junk[i] >= ' ')
               {
               value2[j] = junk[i];
               ++j;
               ++i;
               }
            value2[j] = '\0';
            }
         VVTec = (struct elist *) (malloc(SzEl));
         if(VVTec == NULL)
            {
            printf("all availble memory has been consumed during attribute dependency analysis preparation\n  exiting now\n");
            exit(-1);
            }
         VVTec->dt = datatype;
         VVTec->evalue = (char *) (malloc(strlen(evalue) + 1));
         strcpy(VVTec->evalue,evalue);
         if(datatype == 1) 
            VVTec->value2 = NULL;  /*** don't need the second value for enum values, just the code **/
         else
            {
            VVTec->value2 = (char *) (malloc(strlen(value2) + 1));
            strcpy(VVTec->value2,value2);
            }
         VVTec->next = NULL;
         if(VVTdomc->values == NULL)
            {
            VVTdomc->values = VVTec;
            }
         else
            {
            VVTep = VVTdomc->values;
            while(VVTep->next != NULL)
               VVTep = VVTep->next;
            VVTep->next = VVTec;
            }
         }
      
      if(BIN_ATTR_TYPE==1)
         {
         fread(&wchar,1,1,vvtdomin);
         }
      else
         {
         fgets(junk,999,vvtdomin);
         }
      }

   fclose(vvtdomin);

   strcpy(dname,"Z1Z2zx3--aA5ZzZzZzZz");
   if(BIN_ATTR_TYPE==1)
      {
      fread(&wchar,1,1,vvtin);
      }
   else
      {
      fgets(junk,999,vvtin);  /** discard header line **/
      fgets(junk,999,vvtin);
      }
   while(feof(vvtin) == 0)
      {
      if(BIN_ATTR_TYPE==1)
         {
         if(wchar == '\0')
            break;
         else
            {
            bi = (int) wchar;
            fread(slen,bi,1,vvtin);
            slen[bi] = '\0';
            bj = 0;
            bk = 0;
            while(slen[bj] != '\0')
               {
               bk = bk * 10 + ((int) (slen[bj] - 48));
               ++bj;
               }
            fread(junk,bk,1,vvtin);
            junk[bk] = '\n';
            ++bk;
            junk[bk] = '\0';
            }
         }

      i = 0;
      while(junk[i] != ',')
         ++i;
      ++i;
      k = 0;
      while(junk[i] != ',')
         {
         thisname[k] = junk[i];
         ++i;
         ++k;
         }
      j = k; /*** end of fcode field - set to '\0' below when need just fcode ***/
      ++i; /*** should now be on geometry character ***/
      geom = junk[i];
      ++i; /** should be a comma **/
      ++i; /*** should be start of attribute code ***/
      thisname[k] = geom;
      ++k;
      thisname[k] = '\0';
      k = 0;
      while(junk[i] != ',')
         {
         thisattr[k] = junk[i];
         ++k;
         ++i;
         }
      ++i;
      thisattr[k] = '\0';
      attrcode = GetAttrIndex(thisattr);
      strcat(thisname,thisattr);

      while(junk[i] != ',') /** can just skip over the attribute name ***/
         ++i;
      ++i;
      k = 0;
      while(junk[i] != ',')
         {
         DT[k] = junk[i];
         ++i;
         ++k;
         }
      DT[k] = '\0';
      if((DT[k-1] >= '<') && (DT[k-1] <= '>')) /** this includes '<' = 60, '=' = 61 and '>' = 62 ASCII Decimal ***/
         {
         k = 0;
         while((DT[k] < '<') || (DT[k] > '>'))
            ++k;
         kk = 0;
         while((DT[k] >= '<') && (DT[k] <= '>')) /** this will grab off the trailing '>', '>=', '=', '<', or '<=' ***/
            {
            InEq[kk] = DT[k];
            ++kk;
            DT[k] = '\0';
            ++k;
            }
         InEq[kk] = '\0';
         }
      else
         InEq[0] = '\0';
      ++i; /*** should now be at start of opt / required field ***/
      optreq = 0;
      if(junk[i] == 'O')
         {
         optreq = -1;
         while(junk[i] != ',')
            ++i;
         }
      else if(junk[i] == 'M')
         {
         optreq = -2;
         while(junk[i] != ',')
            ++i;
         }
      else if((junk[i] >= 48) && (junk[i] <= 57)) /*** showing linkage between depedent attributes ***/
         {
if(junk[i] == 48)
{
printf("VVT input %s\n",junk);
printf("This contains the numeral '0' instead of the Upper Case letter 'O' in the optional / mandatory field\n");
printf("Please correct the Valid Value specification file and restart the project creation and analysis\n");
exit(1);
}
optreq = 101;
         while(junk[i] != ',')
            {
            /***optreq = optreq + (junk[i] - 48); ***/
            ++i;
            }
         }
      if(optreq < 0)
         {
         ++i; /*** should be at start of attribute domain name ***/
         k = 0;
         while(junk[i] != ',')
            {
            domain[k] = junk[i];
            ++i;
            ++k;
            }
         domain[k] = '\0';
         ++i; /** leave i at index starting with dep attr code ***/
         InEquality = 0;
         if(strcmp(domain,"GTEQ") == 0)
            InEquality = 1;
         else if(strcmp(domain,"GT") == 0)
            InEquality = 2;
         else if(strcmp(domain,"LTEQ") == 0)
            InEquality = 3;
         else if(strcmp(domain,"LT") == 0)
            InEquality = 4;
         else if(strcmp(domain,"EQUALS") == 0)
            InEquality = 5;
         else if((strncmp(DT,"Short Integer",13) != 0) && (InEq[0] != '\0') && (AllDigits(domain, 1) > 0))
            {
            if((InEq[0] == '=') && (InEq[1] == '\0'))
               InEquality = 6;
            else if(InEq[0] == '<')
               {
               if(InEq[1] == '\0')
                  InEquality = 7;
               else if(InEq[1] == '=')
                  InEquality = 9;
               }
            else if(InEq[0] == '>')
               {
               if(InEq[1] == '\0')
                  InEquality = 8;
               else if(InEq[1] == '=')
                  InEquality = 10;
               }
            strcat(thisname,InEq);
            sscanf(domain,"%lf",&set_value);
            }
         VVTdomc = NULL;
         if(InEquality == 0)
            {
            VVTdomc = VVTdomainRoot;
            while(VVTdomc != NULL)
               {
               if(strcmp(domain,VVTdomc->name) == 0)
                  break;
               VVTdomc = VVTdomc->next;
               }
            if(VVTdomc == NULL)
               {
               printf("1: mismatch between value domain names - could not locate %s\nKnown Domain names:\n",domain);
               VVTdomc = VVTdomainRoot;
               while(VVTdomc != NULL)
                  {
                  printf("   %s\n",VVTdomc->name);
                  VVTdomc = VVTdomc->next;
                  }
               exit(-1);
               }
            }

         strcat(thisname,domain);

         if(strcmp(thisname,dname) != 0) /** a new fcode, geom, attr, attr value domain specification **/
            {
            strcpy(dname,thisname);
            thisname[j] = '\0'; /*** strip off all following the fcode **/
            g = -1;
            switch(geom)
               {
               case 'A':
                  g = 1;
                  break;
               case 'L':
                  g = 4;
                  break;
               case 'P':
                  g = 5;
                  break;
               case '_':
                  g = 99;
                  break;
               }
            MGCP_Vc = MGCP_VVT_root;
            while(MGCP_Vc != NULL)
               {
               if((strcmp(MGCP_Vc->FCODE,thisname) == 0) && (MGCP_Vc->geom == g))
                  break;
               MGCP_Vc = MGCP_Vc->next;
               }
            if(MGCP_Vc == NULL)
               {
               MGCP_Vc = (struct MGCP_VVT *) (malloc(SzVVT));
               if(MGCP_Vc == NULL)
                  {
                  printf("all avaialble memory has been consumed during MGCP attribute dependency analysis preparation\n  exiting now\n");
                  exit(-1);
                  }
               strcpy(MGCP_Vc->FCODE,thisname);
               if((thisname[0] == '_') || (strcmp(thisname,"ANY FEATURE") == 0))
                  MGCP_Vc->code = -99;
               else
                  MGCP_Vc->code = GetCodeIndex(thisname);
               MGCP_Vc->geom = g;
               MGCP_Vc->a = NULL;
               MGCP_Vc->o = NULL;
               MGCP_Vc->shapename = NULL;
               MGCP_Vc->next = NULL;
               if(MGCP_VVT_root == NULL)
                  MGCP_VVT_root = MGCP_Vc;
               else
                  {
                  MGCP_Vp = MGCP_VVT_root;
                  while(MGCP_Vp->next != NULL)
                     MGCP_Vp = MGCP_Vp->next;
                  MGCP_Vp->next = MGCP_Vc;
                  }
               }
            VVTac = (struct MGCP_VVT_attr *) (malloc(SzAttr));
            if(VVTac == NULL)
               {
               printf("all available memory has been consumed during MGCP attribute dependency analysis preparation\n  exiting now\n");
               exit(-1);
               }
            VVTac->attr = attrcode;
            VVTac->inequality = InEquality;
            VVTac->lav = NULL; /*** will add the list of long attr values as necessary ***/
            if((InEquality >= 6) && (InEquality <= 10))
               VVTac->SetValue = set_value;
            else
               VVTac->SetValue = -12345.0;
            VVTac->dep = NULL;
            VVTac->dom = VVTdomc;
            /**VVTac->OptReq = 'z'; **/
            VVTac->presentvalue = NULL;
   
            VVTac->next = NULL;
            if(MGCP_Vc->a == NULL)
               MGCP_Vc->a = VVTac;
            else
               {
               VVTap = MGCP_Vc->a;
               while(VVTap->next != NULL)
                  VVTap = VVTap->next;
               VVTap->next = VVTac;
               }

            }
         k = 0;
         while(junk[i] != ',')
            {
            depattr[k] = junk[i];
            ++i;
            ++k;
            }
         depattr[k] = '\0';
         ++i;
         attrcode = GetAttrIndex(depattr);
         VVTdc = (struct MGCP_VVT_depend *) (malloc(SzDep));
         if(VVTdc == NULL)
            {
            printf("all avaialble memory has been consumed during MGCP attribute dependency analysis preparation\n  exiting now\n");
            exit(-1);
            }
         VVTdc->attr = attrcode;
         while(junk[i] != ',')
            ++i;
         ++i;
         while(junk[i] != ',')
            ++i;
         ++i; /** should now be at start of dependent domain name ***/
         k = 0;
         while(junk[i] != ',')
            {
            domain[k] = junk[i];
            ++i;
            ++k;
            }
         domain[k] = '\0';

         VVTdomc = NULL;
         if((InEquality == 0) || (InEquality > 5))
            {
            VVTdomc = VVTdomainRoot;
            while(VVTdomc != NULL)
               {
               if(strcmp(domain,VVTdomc->name) == 0)
                  break;
               VVTdomc = VVTdomc->next;
               }
            if(VVTdomc == NULL)
               {
               printf("2: mismatch between value domain names - could not locate %s\n",domain);
/**/printf("input: %s\n",junk);/***/
               exit(-1);
               }
            }
         VVTdc->d = VVTdomc;
         VVTdc->req = optreq;
         VVTdc->isok = 0;
         VVTdc->next = NULL;
         if(VVTac->dep == NULL)
            VVTac->dep = VVTdc;
         else
            {
            VVTdp = VVTac->dep;
            while(VVTdp->next != NULL)
               VVTdp = VVTdp->next;
            VVTdp->next = VVTdc;
            }

         } /*** end have an optreq field < 0 ***/

      if(BIN_ATTR_TYPE==1)
         {
         fread(&wchar,1,1,vvtin);
         }
      else
         {
         fgets(junk,999,vvtin);
         }
      }


   fclose(vvtin);
}


void AddToVVTcounts(int ECC, int geom, int EAC, char *enumcodestring, char * shapefilename, double dvalue, int FIDlookupIndex)
{
int i,foundit;
const int SzOth = sizeof(struct MGCP_VVT_attr);

   MGCP_Vc = MGCP_VVT_root;
   while(MGCP_Vc != NULL)
      {
      if((MGCP_Vc->code == ECC) && (MGCP_Vc->geom == geom))
         {
         if(MGCP_Vc->shapename != NULL)
            free(MGCP_Vc->shapename);
         i = strlen(shapefilename);
         MGCP_Vc->shapename = (char *) (malloc(i + 2));
         strcpy(MGCP_Vc->shapename,shapefilename);

         VVTac = MGCP_Vc->a;
         foundit = 0;
         while(VVTac != NULL)
            {
            if(VVTac->attr == EAC)
               {
               if(enumcodestring != NULL)
                  {
                  if(VVTac->presentvalue != NULL)
                     free(VVTac->presentvalue);
                  i = strlen(enumcodestring);
                  VVTac->presentvalue = (char *) (malloc(i + 2));
                  strcpy(VVTac->presentvalue,enumcodestring);
                  foundit += 1;
                  }
               else if(dvalue != -999999.0)
                  {
                  LAVn = (struct LongAttrValList *) (malloc(sizeof(struct LongAttrValList)));
                  LAVn->FID_Index = FIDlookupIndex;
                  LAVn->v = dvalue;
                  LAVn->next = VVTac->lav;
                  VVTac->lav = LAVn;
                  }
               }

            VVTac = VVTac->next;
            }
         if((VVTac == NULL) && (foundit == 0))
            {
            if((enumcodestring != NULL) || (dvalue != -999999.0))
               {
               VVTac = (struct MGCP_VVT_attr *) (malloc(SzOth));
               VVTac->presentvalue = NULL;
               VVTac->lav = NULL;
               if(VVTac == NULL)
                  {
                  printf("all available memory has been consumed during MGCP attribute dependecy analysis\n");
                  printf("execution must terminate now!\n");
                  exit(-1);
                  }
               VVTac->attr = EAC;
               if(enumcodestring != NULL)
                  {
                  i = strlen(enumcodestring);
                  VVTac->presentvalue = (char *) (malloc(i + 2));
                  strcpy(VVTac->presentvalue,enumcodestring); 
                  }
               else
                  {
                  LAVn = (struct LongAttrValList *) (malloc(sizeof(struct LongAttrValList)));
                  LAVn->FID_Index = FIDlookupIndex;
                  LAVn->v = dvalue;
                  LAVn->next = VVTac->lav;
                  VVTac->lav = LAVn;
                  }
               /**VVTac->OptReq = O_R; **/
               VVTac->dom = NULL;
               VVTac->dep = NULL;
               VVTac->next = MGCP_Vc->o;
               MGCP_Vc->o = VVTac;
               }
            }
         break;
         }

      MGCP_Vc = MGCP_Vc->next;
      }
}




int SpecialMGCP_BuildingRulesApply(int BldgCode, int ECC, int geom, char *UnkATTR, int *PPOproblem)
{
int answer = 1;
int NumNotUnknown,NumApply,NumNA,CountValue, NumCounted, NumUnknown;
int IsOptional;
int PPOnull, PPOapplicable, AFCapplicable, ICFapplicable, UUCapplicable;
int Missing = 20;
int MissingCode[20];
int AddCode, NULL_OK;
int loops,i, counter;
char attrcode[100];
char Applicable[500];
char NotApplicable[500];
char OptNULL[500];

   if(BldgCode != ECC)
      return(2);
   for(i=0; i<20; i++)
      MissingCode[i] = 1;
   Applicable[0] = '\0';
   NotApplicable[0] = '\0';
   NULL_OK = 0;
   OptNULL[0] = '\0';
   strcpy(UnkATTR,"Unknown Value: ");
   strcpy(Applicable,"Known Applicable Value: ");
   strcpy(NotApplicable,"998 ('Not Applicable') Value: ");
   strcpy(OptNULL,"Optional with Null value: ");

   PPOapplicable = AFCapplicable = ICFapplicable = UUCapplicable = 0;
   *PPOproblem = 0;
   while(MGCP_Vc != NULL)
      {
      if((MGCP_Vc->code == BldgCode) && (MGCP_Vc->geom == geom))
         {
         loops = 0;
         NumNotUnknown = NumApply = NumNA = NumUnknown = NumCounted = 0;
         PPOnull = 0;

         VVTac = MGCP_Vc->a; /** loops variable used to set it to ->o as well ***/
         if(VVTac == NULL)
            {
            VVTac = MGCP_Vc->o;
            loops = 2;
            }

         while(VVTac != NULL)
            {
            if(VVTac->presentvalue != NULL)
               {
               strcpy(attrcode,GetEACCode(VVTac->attr));
               CountValue = 0;
               switch(attrcode[0])
                  {
                  case 'A':
                     if(strcmp(attrcode,"AFC") == 0)
                        {
                        CountValue = 1;
                        IsOptional = 1;
                        if(strcmp(VVTac->presentvalue,"998") != 0)
                           AFCapplicable = 1;
                        MissingCode[0] = 0;
                        }
                     break;
                  case 'C':
                     if(strcmp(attrcode,"CEF") == 0)
                        {
                        CountValue = 1;
                        IsOptional = 1;
                        MissingCode[1] = 0;
                        }
                     else if(strcmp(attrcode,"CFC") == 0)
                        {
                        CountValue = 1;
                        IsOptional = 1;
                        MissingCode[2] = 0;
                        }
                     else if(strcmp(attrcode,"CIT") == 0)
                        {
                        CountValue = 1;
                        IsOptional = 1;
                        MissingCode[3] = 0;
                        }
                     else if(strcmp(attrcode,"CUS") == 0)
                        {
                        CountValue = 1;
                        IsOptional = 1;
                        MissingCode[4] = 0;
                        }
                     break;
                  case 'D':
                     if(strcmp(attrcode,"DDC") == 0)
                        {
                        CountValue = 1;
                        IsOptional = 1;
                        MissingCode[5] = 0;
                        }
                     break;
                  case 'E':
                     if(strcmp(attrcode,"EBT") == 0)
                        {
                        CountValue = 1;
                        IsOptional = 1;
                        MissingCode[6] = 0;
                        }
                     break;
                  case 'G':
                     if(strcmp(attrcode,"GFC") == 0)
                        {
                        CountValue = 1;
                        IsOptional = 0;
                        MissingCode[7] = 0;
                        }
                     break;
                  case 'H':
                     if(strcmp(attrcode,"HWT") == 0)
                        {
                        CountValue = 1;
                        IsOptional = 0;
                        MissingCode[8] = 0;
                        }
                     break;
                  case 'I':
                     if(strcmp(attrcode,"ICF") == 0)
                        {
                        CountValue = 1;
                        IsOptional = 1;
                        if(strcmp(VVTac->presentvalue,"998") != 0)
                           ICFapplicable = 1;
                        MissingCode[9] = 0;
                        }
                     break;
                  case 'M':
                     if(strcmp(attrcode,"MFC") == 0)
                        {
                        CountValue = 1;
                        IsOptional = 1;
                        MissingCode[10] = 0;
                        }
                     break;
                  case 'P':
                     if(strcmp(attrcode,"PAF") == 0)
                        {
                        CountValue = 1;
                        IsOptional = 1;
                        MissingCode[11] = 0;
                        }
                     else if(strcmp(attrcode,"PPO") == 0)
                        {
                        CountValue = 1;
                        IsOptional = 1;
                        if(strcmp(VVTac->presentvalue,"998") != 0)
                           PPOapplicable = 1;
                        if(strcmp(VVTac->presentvalue,"-32768") == 0)
                           PPOnull = 1;
                        MissingCode[12] = 0;
                        }
                     else if(strcmp(attrcode,"PSF") == 0)
                        {
                        CountValue = 1;
                        IsOptional = 0;
                        MissingCode[13] = 0;
                        }
                     break;
                  case 'R':
                     if(strcmp(attrcode,"RES") == 0)
                        {
                        CountValue = 1;
                        IsOptional = 1;
                        MissingCode[14] = 0;
                        }
                     else if(strcmp(attrcode,"RFC") == 0)
                        {
                        CountValue = 1;
                        IsOptional = 0;
                        MissingCode[15] = 0;
                        }
                     break;
                  case 'S':
                     if(strcmp(attrcode,"SFY") == 0)
                        {
                        CountValue = 1;
                        IsOptional = 1;
                        MissingCode[16] = 0;
                        }
                     else if(strcmp(attrcode,"SUC") == 0)
                        {
                        CountValue = 1;
                        IsOptional = 1;
                        MissingCode[17] = 0;
                        }
                     break;
                  case 'T':
                     if(strcmp(attrcode,"TFC") == 0)
                        {
                        CountValue = 1;
                        IsOptional = 0;
                        MissingCode[18] = 0;
                        }
                     break;
                  case 'U':
                     if(strcmp(attrcode,"UUC") == 0)
                        {
                        CountValue = 1;
                        IsOptional = 1;
                        if(strcmp(VVTac->presentvalue,"998") != 0)
                           UUCapplicable = 1;
                        MissingCode[19] = 0;
                        }
                     break;
                  }
               if((CountValue > 0) && (IsOptional > 0))
                  {
                  if(strcmp(VVTac->presentvalue,"-32768") == 0)
                     {
                     CountValue = 0;
                     --Missing;
                     ++NULL_OK;
                     if(NULL_OK == 1)
                        strcat(OptNULL,attrcode);
                     else
                        {
                        strcat(OptNULL,", ");
                        strcat(OptNULL,attrcode);
                        }
                     }
                  }
               if(CountValue > 0)
                  {
                  AddCode = 0;
                  --Missing;
                  ++NumCounted;
                  if(strcmp(VVTac->presentvalue,"998") != 0)
                     {
                     ++AddCode;
                     NumApply += 1;
                     }
                  else
                     {
                     NumNA += 1;
                     if(NumNA == 1)
                        strcat(NotApplicable,attrcode);
                     else
                        {
                        strcat(NotApplicable,", ");
                        strcat(NotApplicable,attrcode);
                        }
                     }
                  if(strcmp(VVTac->presentvalue,"0") == 0)
                     {
                     ++AddCode;
                     NumUnknown += 1;
                     if(NumUnknown == 1)
                        strcat(UnkATTR,attrcode);
                     else
                        {
                        strcat(UnkATTR,", ");
                        strcat(UnkATTR,attrcode);
                        }
                     }
                  else
                     {
                     NumNotUnknown += 1;
                     if(AddCode > 0)
                        {
                        if(NumNotUnknown == 1)
                           strcat(Applicable,attrcode);
                        else
                           {
                           strcat(Applicable,", ");
                           strcat(Applicable,attrcode);
                           }
                        }
                     }
                  }
               }

            if(VVTac->next != NULL)
               {
               while((VVTac->next != NULL) && (VVTac->next->attr == VVTac->attr) && (VVTac->next->presentvalue != NULL) &&
                         (VVTac->presentvalue != NULL) && (strcmp(VVTac->next->presentvalue,VVTac->presentvalue) == 0))
                  VVTac = VVTac->next;

               }

            VVTac = VVTac->next;
            if(VVTac == NULL)
               {
               if(loops == 0)
                 {
                 VVTac = MGCP_Vc->o;
                 ++loops;
                 }
               }
            }

         if(NumNotUnknown == 0) 
            answer = 0;
         else if(NumApply == 0)
            answer = -1;
         else if(NumUnknown == NumCounted)
            answer = -3;
         else if((NumUnknown > 2) && (NumUnknown < NumCounted))
            answer = -2;
         break;
         }
      MGCP_Vc = MGCP_Vc->next;
      }

   if((PPOapplicable > 0) && (PPOnull == 0))
      {
      if((AFCapplicable == 0) && (ICFapplicable == 0) && (UUCapplicable == 0))
         *PPOproblem = 1;
      }

   if(NumUnknown == 0)
      strcat(UnkATTR,"(none); ");
   else
      strcat(UnkATTR,"; ");
   if(NumApply == NumUnknown)
      {
      strcat(Applicable,"(none); ");
      strcat(UnkATTR,Applicable);
      }
   else
      {
      strcat(UnkATTR,Applicable);
      strcat(UnkATTR,"; ");
      }
   if(NULL_OK == 0)
      {
      strcat(OptNULL,"(none); ");
      strcat(UnkATTR,OptNULL);
      }
   else
      {
      strcat(UnkATTR,OptNULL);
      strcat(UnkATTR,"; ");
      }

   if(NumApply == NumCounted)
      {
      strcat(NotApplicable,"(none)");
      strcat(UnkATTR,NotApplicable);
      }
   else
      {
      strcat(UnkATTR,NotApplicable);
      }
   if(Missing > 0)
      {
      counter = 0;
      sprintf(Applicable,"; Missing from feature in this GAIT project:");
      for(i=0; i< 20; i++)
         {
         if(MissingCode[i] > 0)
            {
            if(counter > 0)
               strcat(Applicable,",");
            ++counter;
            switch(i)
               {
               case 0:
                  strcat(Applicable," AFC"); break;
               case 1:
                  strcat(Applicable," CEF"); break;
               case 2:
                  strcat(Applicable," CFC"); break;
               case 3:
                  strcat(Applicable," CIT"); break;
               case 4:
                  strcat(Applicable," CUS"); break;
               case 5:
                  strcat(Applicable," DDC"); break;
               case 6:
                  strcat(Applicable," EBT"); break;
               case 7:
                  strcat(Applicable," GFC"); break;
               case 8:
                  strcat(Applicable," HWT"); break;
               case 9:
                  strcat(Applicable," ICF"); break;
               case 10:
                  strcat(Applicable," MFC"); break;
               case 11:
                  strcat(Applicable," PAF"); break;
               case 12:
                  strcat(Applicable," PPO"); break;
               case 13:
                  strcat(Applicable," PSF"); break;
               case 14:
                  strcat(Applicable," RES"); break;
               case 15:
                  strcat(Applicable," RFC"); break;
               case 16:
                  strcat(Applicable," SFY"); break;
               case 17:
                  strcat(Applicable," SUC"); break;
               case 18:
                  strcat(Applicable," TFC"); break;
               case 19:
                  strcat(Applicable," UUC"); break;
               }
            }
         }
      strcat(UnkATTR,Applicable);
      }

   return(answer);
}


void ZeroMGCP_VVT(int ECC, int geom)
{
   MGCP_Vc = MGCP_VVT_root;
   while(MGCP_Vc != NULL)
      {
      if((MGCP_Vc->code == ECC) && (MGCP_Vc->geom == geom))
         {
         VVTac = MGCP_Vc->a;
         while(VVTac != NULL)
            {
            if(VVTac->presentvalue != NULL)
               {
               free(VVTac->presentvalue);
               }
            VVTac->presentvalue = NULL;

            if(VVTac->lav != NULL)
               {
               LAVc = VVTac->lav;
               while(LAVc != NULL)
                  {
                  LAVp = LAVc;
                  LAVc = LAVc->next;
                  free(LAVp);
                  }
               VVTac->lav = NULL;
               }

            VVTac = VVTac->next;
            }
         VVTac = MGCP_Vc->o;
         while(VVTac != NULL)
            {
            VVTap = VVTac;
            VVTac = VVTac->next;
 
            if(VVTap->presentvalue != NULL)
               free(VVTap->presentvalue);

            LAVc = VVTap->lav;
            while(LAVc != NULL)
               {
               LAVp = LAVc;
               LAVc = LAVc->next;
               free(LAVp);
               }
            VVTap->lav = NULL;

            free(VVTap);
            }
         MGCP_Vc->o = NULL;
         break;
         }

      MGCP_Vc = MGCP_Vc->next;
      }
}


void WriteQACRdata(FILE * qfile, char * Etype, char * Emsg, int Ecount)
{
int ki,i,j,lastj;
char QACRstring[300];

            strcpy(QACRstring,Etype);
            QACRstring[74] = '\0';
            ki = strlen(QACRstring);
            SEEIT_fwrite_int(&ki,qfile);
            fwrite(&QACRstring[0],ki,1,qfile);

            i = j = 0;
            lastj = 0;
            while(Emsg[j] >= ' ')
               {
               if(Emsg[j] == ' ')
                  {
                  if(lastj > 0) /** should have 2 or more blanks in a row, skip this one for copy **/
                     {
                     ++j;
                     }
                  else
                     {
                     lastj += 1;
                     QACRstring[i] = Emsg[j];
                     ++i;
                     ++j;
                     }
                  }
               else
                  {
                  lastj = 0;
                  QACRstring[i] = Emsg[j];
                  ++i;
                  ++j;
                  }
               if(i >= 149)
                  break;
               }
            QACRstring[i] = '\0';

            ki = strlen(QACRstring);
            SEEIT_fwrite_int(&ki,qfile);
            fwrite(&QACRstring[0],ki,1,qfile);

            SEEIT_fwrite_int(&Ecount,qfile);
}




int IsJunkValue(int datatype,int Ivalue, double Fvalue, char *Svalue, int Evalue, char *Elabel)
{
int answer = 0;

   switch(datatype)
      {
      case 0:  /*** regular integer ***/
         if((ATTRTYPE_ANY_TDS() > 0) || (ATTRTYPE_ANY_GGDM() > 0))
            {
            if(Ivalue == -999999)
               answer = 1;
            }
         else
            {
            if((Ivalue <= -32764) && (Ivalue >= -32768))
               answer = 1;
            else if(Ivalue == 0)
               answer = 1;
            else if((Ivalue >= 996) && (Ivalue <= 999))
               answer = 1;
            else if(Ivalue == -29999)
               answer = 1;
            else if(Ivalue == -50000)
               answer = 1;
            }
         break;
      case 1:  /*** double ****/
         if((ATTRTYPE_ANY_TDS() > 0) || (ATTRTYPE_ANY_GGDM() > 0))
            {
            if(Fvalue == -999999.0)
               answer = 1;
            }
         else
            {
            if((Fvalue <= -32763.0) && (Fvalue >= -32768.0))
               answer = 1;
            else if(Fvalue == 0)
               answer = 1;
            else if((Fvalue >= 996.0) && (Fvalue <= 999.0))
               answer = 1;
            else if(Fvalue == -29999.0)
               answer = 1;
            else if(Fvalue == -50000.0)
               answer = 1;
            }
         break;
      case 2:   /*** string ***/
      case 6:   /*** date  ***/
         if(Svalue[0] == '"')  /*** expected case for a string - enclosed in quotes ***/
            {
            if((strncmp(&Svalue[1],"Unknown",7) == 0) && (Svalue[8] == '"'))
               answer = 1;
            else if((strncmp(&Svalue[1],"UNK",3) == 0) && (Svalue[4] == '"'))
               answer = 1;
            else if((strncmp(&Svalue[1],"N/A",3) == 0) && (Svalue[4] == '"'))
               answer = 1;
            else if((strncmp(&Svalue[1],"N_A",3) == 0) && (Svalue[4] == '"'))
               answer = 1;
            else if((strncmp(&Svalue[1],"N_P",3) == 0) && (Svalue[4] == '"'))
               answer = 1;
            else if((strncmp(&Svalue[1],"Other",5) == 0) && (Svalue[6] == '"'))
               answer = 1;
            else if((strncmp(&Svalue[1],"other",5) == 0) && (Svalue[6] == '"'))
               answer = 1;
            else if((strncmp(&Svalue[1],"Oth",3) == 0) && (Svalue[4] == '"'))
               answer = 1;
            else if((strncmp(&Svalue[1],"NA",2) == 0) && (Svalue[3] == '"'))
               answer = 1;
            else if((strncmp(&Svalue[1],"NP",2) == 0) && (Svalue[3] == '"'))
               answer = 1;
            else if((strncmp(&Svalue[1],"996",3) == 0) && (Svalue[4] == '"'))
               answer = 1;
            else if((strncmp(&Svalue[1],"997",3) == 0) && (Svalue[4] == '"'))
               answer = 1;
            else if((strncmp(&Svalue[1],"998",3) == 0) && (Svalue[4] == '"'))
               answer = 1;
            else if((strncmp(&Svalue[1],"999",3) == 0) && (Svalue[4] == '"'))
               answer = 1;
            else if((strncmp(&Svalue[1],"0",1) == 0) && (Svalue[2] == '"'))
               answer = 1;
            else if((strncmp(&Svalue[1],"-32764",6) == 0) && (Svalue[7] == '"'))
               answer = 1;
            else if((strncmp(&Svalue[1],"-32765",6) == 0) && (Svalue[7] == '"'))
               answer = 1;
            else if((strncmp(&Svalue[1],"-32766",6) == 0) && (Svalue[7] == '"'))
               answer = 1;
            else if((strncmp(&Svalue[1],"-32767",6) == 0) && (Svalue[7] == '"'))
               answer = 1;
            else if((strncmp(&Svalue[1],"-32768",6) == 0) && (Svalue[7] == '"'))
               answer = 1;
            else if((strncmp(&Svalue[1],"-50000",6) == 0) && (Svalue[7] == '"'))
               answer = 1;
            else if((strncmp(&Svalue[1],"-29999",6) == 0) && (Svalue[7] == '"'))
               answer = 1;
            else if((strncmp(&Svalue[1],"996.0",5) == 0) && (Svalue[6] == '"'))
               answer = 1;
            else if((strncmp(&Svalue[1],"997.0",5) == 0) && (Svalue[6] == '"'))
               answer = 1;
            else if((strncmp(&Svalue[1],"998.0",5) == 0) && (Svalue[6] == '"'))
               answer = 1;
            else if((strncmp(&Svalue[1],"999.0",5) == 0) && (Svalue[6] == '"'))
               answer = 1;
            else if((strncmp(&Svalue[1],"0.0",3) == 0) && (Svalue[4] == '"'))
               answer = 1;
            else if((strncmp(&Svalue[1],"-32764.0",8) == 0) && (Svalue[9] == '"'))
               answer = 1;
            else if((strncmp(&Svalue[1],"-32765.0",8) == 0) && (Svalue[9] == '"'))
               answer = 1;
            else if((strncmp(&Svalue[1],"-32766.0",8) == 0) && (Svalue[9] == '"'))
               answer = 1;
            else if((strncmp(&Svalue[1],"-32767.0",8) == 0) && (Svalue[9] == '"'))
               answer = 1;
            else if((strncmp(&Svalue[1],"-32768.0",8) == 0) && (Svalue[9] == '"'))
               answer = 1;
            else if((strncmp(&Svalue[1],"-50000.0",8) == 0) && (Svalue[9] == '"'))
               answer = 1;
            else if((strncmp(&Svalue[1],"-29999.0",8) == 0) && (Svalue[9] == '"'))
               answer = 1;
            else if(strncmp(&Svalue[1],"No Information",14) == 0) //&& (Svalue[15] == '"'))
               answer = 1;
            else if(strncmp(&Svalue[1],"noInformation",13) == 0) //&& (Svalue[14] == '"'))
               answer = 1;
            else if(strncmp(&Svalue[1],"notApplicable",13) == 0) 
               answer = 1;
            else if(strncmp(&Svalue[1],"Not Applicable",14) == 0)
               answer = 1;

            }
         break;
      case 3:  /** enum as int ***/
         if(Evalue <= -32764)
            answer = 1;
         else if(strcmp(Elabel,"Other") == 0)
            answer = 1;
         else if(strcmp(Elabel,"OTHER") == 0)
            answer = 1;
         else if(strcmp(Elabel,"Unknown") == 0)
            answer = 1;
         else if(strcmp(Elabel,"UNKNOWN") == 0)
            answer = 1;
         else if(strcmp(Elabel,"UNK") == 0)
            answer = 1;
         else if(strcmp(Elabel,"Not Applicable") == 0)
            answer = 1;
         else if(strcmp(Elabel,"No Information") == 0)
            answer = 1;
         else if(strcmp(Elabel,"N/A") == 0)
            answer = 1;
         else if(strcmp(Elabel,"N_P") == 0)
            answer = 1;
         else if(strcmp(Elabel,"Oth") == 0)
            answer = 1;
         else if(strcmp(Elabel,"NA") == 0)
            answer = 1;
         else if(strcmp(Elabel,"NP") == 0)
            answer = 1;
         else if(strstr(Elabel,"999") != NULL)
            answer = 1;
         else if(strstr(Elabel,"-999999") != NULL)
            answer = 1;
         break;
      }
   return(answer);
}


void IncludeIntervalValues(int TgtEAC,double dval,char * sval)
{
int i;
int arraylimit = 17; /** limit for version 4 TDS ***/

   if(ATTRTYPE_TDS6() > 0)
      arraylimit = 20;
   else if(ATTRTYPE_GGDM21() > 0)
      arraylimit = 25;
   else if(ATTRTYPE_GGDM22() > 0)
      arraylimit = 25;
   else if(ATTRTYPE_GGDM3() > 0)
      arraylimit = 26;

   for(i=0; i<arraylimit; i++)
      {
      if(Int_VVT[i].EAClower == TgtEAC)
         {
         Int_VVT[i].values_found += 1;
         Int_VVT[i].lower = dval;
         break;
         }
      else if(Int_VVT[i].EACupper == TgtEAC)
         {
         Int_VVT[i].values_found += 2;
         Int_VVT[i].upper = dval;
         break;
         }
      else if(Int_VVT[i].EACclosure == TgtEAC)
         {
         Int_VVT[i].values_found += 4;
         strcpy(Int_VVT[i].closure,sval);
         break;
         }
      }
}


void ResetInternalVVT(void)
{
int i;

   for(i=0; i<26; i++)
      {
      Int_VVT[i].closure[0] = '\0';
      Int_VVT[i].values_found = 0;
      Int_VVT[i].lower = 100.0;
      Int_VVT[i].upper = -100.0;
      }
}



void InitializeIntervalVVT(void)
{
   if(ATTRTYPE_GGDM21() > 0) /**** GGDM ****/
      {
      Int_VVT[0].EACclosure = GetAttrIndex("AQTC");
      Int_VVT[0].EAClower = GetAttrIndex("AQTL");
      Int_VVT[0].EACupper = GetAttrIndex("AQTU");
      Int_VVT[1].EACclosure = GetAttrIndex("AYRC");
      Int_VVT[1].EAClower = GetAttrIndex("AYRL");
      Int_VVT[1].EACupper = GetAttrIndex("AYRU");
      Int_VVT[2].EACclosure = GetAttrIndex("BPWHAC");
      Int_VVT[2].EAClower = GetAttrIndex("BPWHAL");
      Int_VVT[2].EACupper = GetAttrIndex("BPWHAU");
      Int_VVT[3].EACclosure = GetAttrIndex("BPWHBC");
      Int_VVT[3].EAClower = GetAttrIndex("BPWHBL");
      Int_VVT[3].EACupper = GetAttrIndex("BPWHBU");
      Int_VVT[4].EACclosure = GetAttrIndex("BPWSAC");
      Int_VVT[4].EAClower = GetAttrIndex("BPWSAL");
      Int_VVT[4].EACupper = GetAttrIndex("BPWSAU");
      Int_VVT[5].EACclosure = GetAttrIndex("BPWSBC");
      Int_VVT[5].EAClower = GetAttrIndex("BPWSBL");
      Int_VVT[5].EACupper = GetAttrIndex("BPWSBU");
      Int_VVT[6].EACclosure = GetAttrIndex("BWVCAC");
      Int_VVT[6].EAClower = GetAttrIndex("BWVCAL");
      Int_VVT[6].EACupper = GetAttrIndex("BWVCAU");
      Int_VVT[7].EACclosure = GetAttrIndex("BWVCBC");
      Int_VVT[7].EAClower = GetAttrIndex("BWVCBL");
      Int_VVT[7].EACupper = GetAttrIndex("BWVCBU");
      Int_VVT[8].EACclosure = GetAttrIndex("DMBC");
      Int_VVT[8].EAClower = GetAttrIndex("DMBL");
      Int_VVT[8].EACupper = GetAttrIndex("DMBU");
      Int_VVT[9].EACclosure = GetAttrIndex("DPAC");
      Int_VVT[9].EAClower = GetAttrIndex("DPAL");
      Int_VVT[9].EACupper = GetAttrIndex("DPAU");
      Int_VVT[10].EACclosure = GetAttrIndex("FEOC");
      Int_VVT[10].EAClower = GetAttrIndex("FEOL");
      Int_VVT[10].EACupper = GetAttrIndex("FEOU");
      Int_VVT[11].EACclosure = GetAttrIndex("GSGCHC");
      Int_VVT[11].EAClower = GetAttrIndex("GSGCHL");
      Int_VVT[11].EACupper = GetAttrIndex("GSGCHU");
      Int_VVT[12].EACclosure = GetAttrIndex("GSGCLC");
      Int_VVT[12].EAClower = GetAttrIndex("GSGCLL");
      Int_VVT[12].EACupper = GetAttrIndex("GSGCLU");
      Int_VVT[13].EACclosure = GetAttrIndex("PFHC");
      Int_VVT[13].EAClower = GetAttrIndex("PFHL");
      Int_VVT[13].EACupper = GetAttrIndex("PFHU");
      Int_VVT[14].EACclosure = GetAttrIndex("PWAC");
      Int_VVT[14].EAClower = GetAttrIndex("PWAL");
      Int_VVT[14].EACupper = GetAttrIndex("PWAU");
      Int_VVT[15].EACclosure = GetAttrIndex("RMWC");
      Int_VVT[15].EAClower = GetAttrIndex("RMWL");
      Int_VVT[15].EACupper = GetAttrIndex("RMWU");
      Int_VVT[16].EACclosure = GetAttrIndex("SDCC");
      Int_VVT[16].EAClower = GetAttrIndex("SDCL");
      Int_VVT[16].EACupper = GetAttrIndex("SDCU");
      Int_VVT[17].EACclosure = GetAttrIndex("SDSC");
      Int_VVT[17].EAClower = GetAttrIndex("SDSL");
      Int_VVT[17].EACupper = GetAttrIndex("SDSU");
      Int_VVT[18].EACclosure = GetAttrIndex("SGCC");
      Int_VVT[18].EAClower = GetAttrIndex("SGCL");
      Int_VVT[18].EACupper = GetAttrIndex("SGCU");
      Int_VVT[19].EACclosure = GetAttrIndex("SNDC");
      Int_VVT[19].EAClower = GetAttrIndex("SNDL");
      Int_VVT[19].EACupper = GetAttrIndex("SNDU");
      Int_VVT[20].EACclosure = GetAttrIndex("TSCC");
      Int_VVT[20].EAClower = GetAttrIndex("TSCL");
      Int_VVT[20].EACupper = GetAttrIndex("TSCU");
      Int_VVT[21].EACclosure = GetAttrIndex("VLMC");
      Int_VVT[21].EAClower = GetAttrIndex("VLML");
      Int_VVT[21].EACupper = GetAttrIndex("VLMU");
      Int_VVT[22].EACclosure = GetAttrIndex("VTIC");
      Int_VVT[22].EAClower = GetAttrIndex("VTIL");
      Int_VVT[22].EACupper = GetAttrIndex("VTIU");
      Int_VVT[23].EACclosure = GetAttrIndex("WDAC");
      Int_VVT[23].EAClower = GetAttrIndex("WDAL");
      Int_VVT[23].EACupper = GetAttrIndex("WDAU");
      Int_VVT[24].EACclosure = GetAttrIndex("VAVC");
      Int_VVT[24].EAClower = GetAttrIndex("VAVL");
      Int_VVT[24].EACupper = GetAttrIndex("VAVU");
      }

   else if(ATTRTYPE_GGDM22() > 0) /**** GGDM ****/
      {
      Int_VVT[0].EACclosure = GetAttrIndex("AQTC");
      Int_VVT[0].EAClower = GetAttrIndex("AQTL");
      Int_VVT[0].EACupper = GetAttrIndex("AQTU");
      Int_VVT[1].EACclosure = GetAttrIndex("AYRC");
      Int_VVT[1].EAClower = GetAttrIndex("AYRL");
      Int_VVT[1].EACupper = GetAttrIndex("AYRU");
      Int_VVT[2].EACclosure = GetAttrIndex("BPWHAC");
      Int_VVT[2].EAClower = GetAttrIndex("BPWHAL");
      Int_VVT[2].EACupper = GetAttrIndex("BPWHAU");
      Int_VVT[3].EACclosure = GetAttrIndex("BPWHBC");
      Int_VVT[3].EAClower = GetAttrIndex("BPWHBL");
      Int_VVT[3].EACupper = GetAttrIndex("BPWHBU");
      Int_VVT[4].EACclosure = GetAttrIndex("BPWSAC");
      Int_VVT[4].EAClower = GetAttrIndex("BPWSAL");
      Int_VVT[4].EACupper = GetAttrIndex("BPWSAU");
      Int_VVT[5].EACclosure = GetAttrIndex("BPWSBC");
      Int_VVT[5].EAClower = GetAttrIndex("BPWSBL");
      Int_VVT[5].EACupper = GetAttrIndex("BPWSBU");
      Int_VVT[6].EACclosure = GetAttrIndex("BWVCAC");
      Int_VVT[6].EAClower = GetAttrIndex("BWVCAL");
      Int_VVT[6].EACupper = GetAttrIndex("BWVCAU");
      Int_VVT[7].EACclosure = GetAttrIndex("BWVCBC");
      Int_VVT[7].EAClower = GetAttrIndex("BWVCBL");
      Int_VVT[7].EACupper = GetAttrIndex("BWVCBU");
      Int_VVT[8].EACclosure = GetAttrIndex("DMBC");
      Int_VVT[8].EAClower = GetAttrIndex("DMBL");
      Int_VVT[8].EACupper = GetAttrIndex("DMBU");
      Int_VVT[9].EACclosure = GetAttrIndex("DPAC");
      Int_VVT[9].EAClower = GetAttrIndex("DPAL");
      Int_VVT[9].EACupper = GetAttrIndex("DPAU");
      Int_VVT[10].EACclosure = GetAttrIndex("GSGCHC");
      Int_VVT[10].EAClower = GetAttrIndex("GSGCHL");
      Int_VVT[10].EACupper = GetAttrIndex("GSGCHU");
      Int_VVT[11].EACclosure = GetAttrIndex("GSGCLC");
      Int_VVT[11].EAClower = GetAttrIndex("GSGCLL");
      Int_VVT[11].EACupper = GetAttrIndex("GSGCLU");
      Int_VVT[12].EACclosure = GetAttrIndex("PFHC");
      Int_VVT[12].EAClower = GetAttrIndex("PFHL");
      Int_VVT[12].EACupper = GetAttrIndex("PFHU");
      Int_VVT[13].EACclosure = GetAttrIndex("PWAC");
      Int_VVT[13].EAClower = GetAttrIndex("PWAL");
      Int_VVT[13].EACupper = GetAttrIndex("PWAU");
      Int_VVT[14].EACclosure = GetAttrIndex("RMWC");
      Int_VVT[14].EAClower = GetAttrIndex("RMWL");
      Int_VVT[14].EACupper = GetAttrIndex("RMWU");
      Int_VVT[15].EACclosure = GetAttrIndex("SDCC");
      Int_VVT[15].EAClower = GetAttrIndex("SDCL");
      Int_VVT[15].EACupper = GetAttrIndex("SDCU");
      Int_VVT[16].EACclosure = GetAttrIndex("SDSC");
      Int_VVT[16].EAClower = GetAttrIndex("SDSL");
      Int_VVT[16].EACupper = GetAttrIndex("SDSU");
      Int_VVT[17].EACclosure = GetAttrIndex("SGCC");
      Int_VVT[17].EAClower = GetAttrIndex("SGCL");
      Int_VVT[17].EACupper = GetAttrIndex("SGCU");
      Int_VVT[18].EACclosure = GetAttrIndex("SNDC");
      Int_VVT[18].EAClower = GetAttrIndex("SNDL");
      Int_VVT[18].EACupper = GetAttrIndex("SNDU");
      Int_VVT[19].EACclosure = GetAttrIndex("TSCC");
      Int_VVT[19].EAClower = GetAttrIndex("TSCL");
      Int_VVT[19].EACupper = GetAttrIndex("TSCU");
      Int_VVT[20].EACclosure = GetAttrIndex("WARRC");
      Int_VVT[20].EAClower = GetAttrIndex("WARRL");
      Int_VVT[20].EACupper = GetAttrIndex("WARRU");
      Int_VVT[21].EACclosure = GetAttrIndex("WDAC");
      Int_VVT[21].EAClower = GetAttrIndex("WDAL");
      Int_VVT[21].EACupper = GetAttrIndex("WDAU");
      Int_VVT[22].EACclosure = GetAttrIndex("WWRTC");
      Int_VVT[22].EAClower = GetAttrIndex("WWRTL");
      Int_VVT[22].EACupper = GetAttrIndex("WWRTU");
      Int_VVT[23].EACclosure = GetAttrIndex("ZI026_CTUC");
      Int_VVT[23].EAClower = GetAttrIndex("ZI026_CTUL");
      Int_VVT[23].EACupper = GetAttrIndex("ZI026_CTUU");
      Int_VVT[24].EACclosure = GetAttrIndex("VAVC");
      Int_VVT[24].EAClower = GetAttrIndex("VAVL");
      Int_VVT[24].EACupper = GetAttrIndex("VAVU");
      }
   else if(ATTRTYPE_GGDM3() > 0)
      {
      Int_VVT[0].EACclosure = GetAttrIndex("AQTC");
      Int_VVT[0].EAClower = GetAttrIndex("AQTL");
      Int_VVT[0].EACupper = GetAttrIndex("AQTU");
      Int_VVT[1].EACclosure = GetAttrIndex("AYRC");
      Int_VVT[1].EAClower = GetAttrIndex("AYRL");
      Int_VVT[1].EACupper = GetAttrIndex("AYRU");
      Int_VVT[2].EACclosure = GetAttrIndex("BPWHAC");
      Int_VVT[2].EAClower = GetAttrIndex("BPWHAL");
      Int_VVT[2].EACupper = GetAttrIndex("BPWHAU");
      Int_VVT[3].EACclosure = GetAttrIndex("BPWHBC");
      Int_VVT[3].EAClower = GetAttrIndex("BPWHBL");
      Int_VVT[3].EACupper = GetAttrIndex("BPWHBU");
      Int_VVT[4].EACclosure = GetAttrIndex("BPWSAC");
      Int_VVT[4].EAClower = GetAttrIndex("BPWSAL");
      Int_VVT[4].EACupper = GetAttrIndex("BPWSAU");
      Int_VVT[5].EACclosure = GetAttrIndex("BPWSBC");
      Int_VVT[5].EAClower = GetAttrIndex("BPWSBL");
      Int_VVT[5].EACupper = GetAttrIndex("BPWSBU");
      Int_VVT[6].EACclosure = GetAttrIndex("BWVCAC");
      Int_VVT[6].EAClower = GetAttrIndex("BWVCAL");
      Int_VVT[6].EACupper = GetAttrIndex("BWVCAU");
      Int_VVT[7].EACclosure = GetAttrIndex("BWVCBC");
      Int_VVT[7].EAClower = GetAttrIndex("BWVCBL");
      Int_VVT[7].EACupper = GetAttrIndex("BWVCBU");
      Int_VVT[8].EACclosure = GetAttrIndex("DMBC");
      Int_VVT[8].EAClower = GetAttrIndex("DMBL");
      Int_VVT[8].EACupper = GetAttrIndex("DMBU");
      Int_VVT[9].EACclosure = GetAttrIndex("DPAC");
      Int_VVT[9].EAClower = GetAttrIndex("DPAL");
      Int_VVT[9].EACupper = GetAttrIndex("DPAU");
      Int_VVT[10].EACclosure = GetAttrIndex("GSGCHC");
      Int_VVT[10].EAClower = GetAttrIndex("GSGCHL");
      Int_VVT[10].EACupper = GetAttrIndex("GSGCHU");
      Int_VVT[11].EACclosure = GetAttrIndex("GSGCLC");
      Int_VVT[11].EAClower = GetAttrIndex("GSGCLL");
      Int_VVT[11].EACupper = GetAttrIndex("GSGCLU");
      Int_VVT[12].EACclosure = GetAttrIndex("PFHC");
      Int_VVT[12].EAClower = GetAttrIndex("PFHL");
      Int_VVT[12].EACupper = GetAttrIndex("PFHU");
      Int_VVT[13].EACclosure = GetAttrIndex("PWAC");
      Int_VVT[13].EAClower = GetAttrIndex("PWAL");
      Int_VVT[13].EACupper = GetAttrIndex("PWAU");
      Int_VVT[14].EACclosure = GetAttrIndex("RMWC");
      Int_VVT[14].EAClower = GetAttrIndex("RMWL");
      Int_VVT[14].EACupper = GetAttrIndex("RMWU");
      Int_VVT[15].EACclosure = GetAttrIndex("SDCC");
      Int_VVT[15].EAClower = GetAttrIndex("SDCL");
      Int_VVT[15].EACupper = GetAttrIndex("SDCU");
      Int_VVT[16].EACclosure = GetAttrIndex("SDSC");
      Int_VVT[16].EAClower = GetAttrIndex("SDSL");
      Int_VVT[16].EACupper = GetAttrIndex("SDSU");
      Int_VVT[17].EACclosure = GetAttrIndex("SGCC");
      Int_VVT[17].EAClower = GetAttrIndex("SGCL");
      Int_VVT[17].EACupper = GetAttrIndex("SGCU");
      Int_VVT[18].EACclosure = GetAttrIndex("SNDC");
      Int_VVT[18].EAClower = GetAttrIndex("SNDL");
      Int_VVT[18].EACupper = GetAttrIndex("SNDU");
      Int_VVT[19].EACclosure = GetAttrIndex("TSCC");
      Int_VVT[19].EAClower = GetAttrIndex("TSCL");
      Int_VVT[19].EACupper = GetAttrIndex("TSCU");
      Int_VVT[20].EACclosure = GetAttrIndex("VAVC");
      Int_VVT[20].EAClower = GetAttrIndex("VAVL");
      Int_VVT[20].EACupper = GetAttrIndex("VAVU");
      Int_VVT[21].EACclosure = GetAttrIndex("WDAC");
      Int_VVT[21].EAClower = GetAttrIndex("WDAL");
      Int_VVT[21].EACupper = GetAttrIndex("WDAU");
      Int_VVT[22].EACclosure = GetAttrIndex("WRCC");
      Int_VVT[22].EAClower = GetAttrIndex("WRCL");
      Int_VVT[22].EACupper = GetAttrIndex("WRCU");
      Int_VVT[23].EACclosure = GetAttrIndex("WWRC");
      Int_VVT[23].EAClower = GetAttrIndex("WWRL");
      Int_VVT[23].EACupper = GetAttrIndex("WWRU");
      Int_VVT[24].EACclosure = GetAttrIndex("ZI015_GCUC");
      Int_VVT[24].EAClower = GetAttrIndex("ZI015_GCUL");
      Int_VVT[24].EACupper = GetAttrIndex("ZI015_GCUU");
      Int_VVT[25].EACclosure = GetAttrIndex("ZI026_CTUC");
      Int_VVT[25].EAClower = GetAttrIndex("ZI026_CTUL");
      Int_VVT[25].EACupper = GetAttrIndex("ZI026_CTUU");
      }
   else if(ATTRTYPE_TDS6() > 0)
      {
      Int_VVT[0].EACclosure = GetAttrIndex("AQTC");
      Int_VVT[0].EAClower = GetAttrIndex("AQTL");
      Int_VVT[0].EACupper = GetAttrIndex("AQTU");
      Int_VVT[1].EACclosure = GetAttrIndex("AYRC");
      Int_VVT[1].EAClower = GetAttrIndex("AYRL");
      Int_VVT[1].EACupper = GetAttrIndex("AYRU");
      Int_VVT[2].EACclosure = GetAttrIndex("BPWHAC");
      Int_VVT[2].EAClower = GetAttrIndex("BPWHAL");
      Int_VVT[2].EACupper = GetAttrIndex("BPWHAU");
      Int_VVT[3].EACclosure = GetAttrIndex("BPWHBC");
      Int_VVT[3].EAClower = GetAttrIndex("BPWHBL");
      Int_VVT[3].EACupper = GetAttrIndex("BPWHBU");
      Int_VVT[4].EACclosure = GetAttrIndex("BPWSAC");
      Int_VVT[4].EAClower = GetAttrIndex("BPWSAL");
      Int_VVT[4].EACupper = GetAttrIndex("BPWSAU");
      Int_VVT[5].EACclosure = GetAttrIndex("BPWSBC");
      Int_VVT[5].EAClower = GetAttrIndex("BPWSBL");
      Int_VVT[5].EACupper = GetAttrIndex("BPWSBU");
      Int_VVT[6].EACclosure = GetAttrIndex("BWVCAC");
      Int_VVT[6].EAClower = GetAttrIndex("BWVCAL");
      Int_VVT[6].EACupper = GetAttrIndex("BWVCAU");
      Int_VVT[7].EACclosure = GetAttrIndex("BWVCBC");
      Int_VVT[7].EAClower = GetAttrIndex("BWVCBL");
      Int_VVT[7].EACupper = GetAttrIndex("BWVCBU");
      Int_VVT[8].EACclosure = GetAttrIndex("DMBC");
      Int_VVT[8].EAClower = GetAttrIndex("DMBL");
      Int_VVT[8].EACupper = GetAttrIndex("DMBU");
      Int_VVT[9].EACclosure = GetAttrIndex("DPAC");
      Int_VVT[9].EAClower = GetAttrIndex("DPAL");
      Int_VVT[9].EACupper = GetAttrIndex("DPAU");
      Int_VVT[10].EACclosure = GetAttrIndex("GSGCHC");
      Int_VVT[10].EAClower = GetAttrIndex("GSGCHL");
      Int_VVT[10].EACupper = GetAttrIndex("GSGCHU");
      Int_VVT[11].EACclosure = GetAttrIndex("GSGCLC");
      Int_VVT[11].EAClower = GetAttrIndex("GSGCLL");
      Int_VVT[11].EACupper = GetAttrIndex("GSGCLU");
      Int_VVT[12].EACclosure = GetAttrIndex("PWAC");
      Int_VVT[12].EAClower = GetAttrIndex("PWAL");
      Int_VVT[12].EACupper = GetAttrIndex("PWAU");
      Int_VVT[13].EACclosure = GetAttrIndex("RMWC");
      Int_VVT[13].EAClower = GetAttrIndex("RMWL");
      Int_VVT[13].EACupper = GetAttrIndex("RMWU");
      Int_VVT[14].EACclosure = GetAttrIndex("SDCC");
      Int_VVT[14].EAClower = GetAttrIndex("SDCL");
      Int_VVT[14].EACupper = GetAttrIndex("SDCU");
      Int_VVT[15].EACclosure = GetAttrIndex("SDSC");
      Int_VVT[15].EAClower = GetAttrIndex("SDSL");
      Int_VVT[15].EACupper = GetAttrIndex("SDSU");
      Int_VVT[16].EACclosure = GetAttrIndex("SGCC");
      Int_VVT[16].EAClower = GetAttrIndex("SGCL");
      Int_VVT[16].EACupper = GetAttrIndex("SGCU");
      Int_VVT[17].EACclosure = GetAttrIndex("TSCC");
      Int_VVT[17].EAClower = GetAttrIndex("TSCL");
      Int_VVT[17].EACupper = GetAttrIndex("TSCU");
      Int_VVT[18].EACclosure = GetAttrIndex("WDAC");
      Int_VVT[18].EAClower = GetAttrIndex("WDAL");
      Int_VVT[18].EACupper = GetAttrIndex("WDAU");
      Int_VVT[19].EACclosure = GetAttrIndex("ZI026_CTUC");
      Int_VVT[19].EAClower = GetAttrIndex("ZI026_CTUL");
      Int_VVT[19].EACupper = GetAttrIndex("ZI026_CTUU");
      }
   else
      {
      Int_VVT[0].EAClower = GetAttrIndex("BPWHAL");
      Int_VVT[0].EACupper = GetAttrIndex("BPWHAU");
      Int_VVT[0].EACclosure = GetAttrIndex("BPWHAC");

      Int_VVT[1].EAClower = GetAttrIndex("BPWHBL");
      Int_VVT[1].EACupper = GetAttrIndex("BPWHBU");
      Int_VVT[1].EACclosure = GetAttrIndex("BPWHBC");

      Int_VVT[2].EAClower = GetAttrIndex("BPWSAL");
      Int_VVT[2].EACupper = GetAttrIndex("BPWSAU");
      Int_VVT[2].EACclosure = GetAttrIndex("BPWSAC");

      Int_VVT[3].EAClower = GetAttrIndex("BPWSBL");
      Int_VVT[3].EACupper = GetAttrIndex("BPWSBU");
      Int_VVT[3].EACclosure = GetAttrIndex("BPWSBC");

      Int_VVT[4].EAClower = GetAttrIndex("BWVCAL");
      Int_VVT[4].EACupper = GetAttrIndex("BWVCAU");
      Int_VVT[4].EACclosure = GetAttrIndex("BWVCAC");

      Int_VVT[5].EAClower = GetAttrIndex("BWVCBL");
      Int_VVT[5].EACupper = GetAttrIndex("BWVCBU");
      Int_VVT[5].EACclosure = GetAttrIndex("BWVCBC");

      Int_VVT[6].EAClower = GetAttrIndex("DMBL");
      Int_VVT[6].EACupper = GetAttrIndex("DMBU");
      Int_VVT[6].EACclosure = GetAttrIndex("DMBC");

      Int_VVT[7].EAClower = GetAttrIndex("GSGCHL");
      Int_VVT[7].EACupper = GetAttrIndex("GSGCHU");
      Int_VVT[7].EACclosure = GetAttrIndex("GSGCHC");

      Int_VVT[8].EAClower = GetAttrIndex("GSGCLL");
      Int_VVT[8].EACupper = GetAttrIndex("GSGCLU");
      Int_VVT[8].EACclosure = GetAttrIndex("GSGCLC");

      Int_VVT[9].EAClower = GetAttrIndex("RMWL");
      Int_VVT[9].EACupper = GetAttrIndex("RMWU");
      Int_VVT[9].EACclosure = GetAttrIndex("RMWC");

      Int_VVT[10].EAClower = GetAttrIndex("SDCL");
      Int_VVT[10].EACupper = GetAttrIndex("SDCU");
      Int_VVT[10].EACclosure = GetAttrIndex("SDCC");

      Int_VVT[11].EAClower = GetAttrIndex("SDSL");
      Int_VVT[11].EACupper = GetAttrIndex("SDSU");
      Int_VVT[11].EACclosure = GetAttrIndex("SDSC");

      Int_VVT[12].EAClower = GetAttrIndex("SGCL");
      Int_VVT[12].EACupper = GetAttrIndex("SGCU");
      Int_VVT[12].EACclosure = GetAttrIndex("SGCC");

      Int_VVT[13].EAClower = GetAttrIndex("TSCL");
      Int_VVT[13].EACupper = GetAttrIndex("TSCU");
      Int_VVT[13].EACclosure = GetAttrIndex("TSCC");

      Int_VVT[14].EAClower = GetAttrIndex("AQTL");
      Int_VVT[14].EACupper = GetAttrIndex("AQTU");
      Int_VVT[14].EACclosure = GetAttrIndex("AQTC");

      Int_VVT[15].EAClower = GetAttrIndex("AYRL");
      Int_VVT[15].EACupper = GetAttrIndex("AYRU");
      Int_VVT[15].EACclosure = GetAttrIndex("AYRC");

      Int_VVT[16].EAClower = GetAttrIndex("DPAL");
      Int_VVT[16].EACupper = GetAttrIndex("DPAU");
      Int_VVT[16].EACclosure = GetAttrIndex("DPAC");

      }
   ResetInternalVVT();
}





void WriteCSV_MD_Entry(FILE * fptr,int count,char *errmsg)
{
int i;

   fprintf(fptr,"%d,",count);
   i = 0;
   while(errmsg[i] != ' ')
      ++i;
   ++i;
   while(errmsg[i] != ' ')
      ++i;
   ++i;
   while(errmsg[i] != ':') /** should have skipped over 'Layer' & 'Identifier' and now print the layer name ***/
      {
      fprintf(fptr,"%c",errmsg[i]);
      ++i;
      }
   fprintf(fptr,",");
   ++i;
   while(errmsg[i] == ' ') /*** should skip over word any blanks ****/
      ++i;
   while(errmsg[i] != ' ') /*** should skip over word 'Feature' ****/
      ++i;
   ++i;
   while(errmsg[i] != ':') /** print FCODE ***/
      {
      fprintf(fptr,"%c",errmsg[i]);
      ++i;
      if((errmsg[i] == ' ') && (errmsg[i+1] == '('))
         break;
      }
   fprintf(fptr,",");
   i += 2;
   while(errmsg[i] != ':') /*** print FName ***/
      {
      fprintf(fptr,"%c",errmsg[i]);
      ++i;
      if((errmsg[i] == ')') && (errmsg[i+1] == ':'))
         break;
      }
   fprintf(fptr,",");
   i += 2;
   while(errmsg[i] == ' ') /*** should skip over word any blanks ****/
      ++i;
   while(errmsg[i] != ' ') /*** should skip over word 'Attribute' ****/
      ++i;
   ++i;
   while(errmsg[i] != ':') /** print ACODE ***/
      {
      fprintf(fptr,"%c",errmsg[i]);
      ++i;
      if((errmsg[i] == ' ') && (errmsg[i+1] == '('))
         break;
      }
   fprintf(fptr,",");
   i += 2;
   while(errmsg[i] != ':') /*** print AName ***/
      {
      fprintf(fptr,"%c",errmsg[i]);
      ++i;
      if((errmsg[i] == ')') && (errmsg[i+1] == ':'))
         break;
      }
   fprintf(fptr,",");
   i += 2;

   while(errmsg[i] >= ' ')
      {
      if(errmsg[i] == ',')
         fprintf(fptr,";");
      else
         fprintf(fptr,"%c",errmsg[i]);
      ++i;
      }
   fprintf(fptr,"\n");
}




int IsNUNANPO_OK_for_SAC(char fcode[], char acode[], char geom, char value[])
{
   if((strstr(value,"-32767") == NULL) && (strstr(value,"-32768") == NULL) &&
        (strstr(value,"-32765") == NULL) && (strstr(value,"-32764") == NULL))
      return(0);

   if((strcmp(fcode,"AF010") == 0) && (geom == 'P'))
      {
      if(strcmp(acode,"AEH") == 0)
         return(1);
      else if(strcmp(acode,"ALA") == 0)
         return(1);
      else if(strcmp(acode,"ALO") == 0)
         return(1);
      else if(strcmp(acode,"AOH") == 0)
         return(1);
      else if(strcmp(acode,"HGF") == 0)
         return(1);
      else if(strcmp(acode,"HGT") == 0)
         return(1);
      else if(strcmp(acode,"Z5F") == 0)
         return(1);
      else if(strcmp(acode,"Z5M") == 0)
         return(1);
      else if(strcmp(acode,"Z7F") == 0)
         return(1);
      else if(strcmp(acode,"ZV7") == 0)
         return(1);
      }
   else if((strcmp(fcode,"AH060") == 0) && (geom == 'A'))
      {
      if(strcmp(acode,"AEH") == 0)
         return(1);
      else if(strcmp(acode,"ALA") == 0)
         return(1);
      else if(strcmp(acode,"ALO") == 0)
         return(1);
      else if(strcmp(acode,"AOH") == 0)
         return(1);
      else if(strcmp(acode,"Z5F") == 0)
         return(1);
      else if(strcmp(acode,"Z5M") == 0)
         return(1);
      else if(strcmp(acode,"Z7F") == 0)
         return(1);
      else if(strcmp(acode,"ZV7") == 0)
         return(1);
      }
   else if((strcmp(fcode,"AL015") == 0) && (geom == 'A'))
      {
      if(strcmp(acode,"AEH") == 0)
         return(1);
      else if(strcmp(acode,"ALA") == 0)
         return(1);
      else if(strcmp(acode,"ALO") == 0)
         return(1);
      else if(strcmp(acode,"AOH") == 0)
         return(1);
      else if(strcmp(acode,"HGF") == 0)
         return(1);
      else if(strcmp(acode,"HGT") == 0)
         return(1);
      else if(strcmp(acode,"LEF") == 0)
         return(1);
      else if(strcmp(acode,"LEN") == 0)
         return(1);
      else if(strcmp(acode,"WGF") == 0)
         return(1);
      else if(strcmp(acode,"WGP") == 0)
         return(1);
      else if(strcmp(acode,"Z5F") == 0)
         return(1);
      else if(strcmp(acode,"Z5M") == 0)
         return(1);
      else if(strcmp(acode,"Z7F") == 0)
         return(1);
      else if(strcmp(acode,"ZV7") == 0)
         return(1);
      }
   else if((strcmp(fcode,"AL015") == 0) && (geom == 'P'))
      {
      if(strcmp(acode,"AEH") == 0)
         return(1);
      else if(strcmp(acode,"ALA") == 0)
         return(1);
      else if(strcmp(acode,"ALO") == 0)
         return(1);
      else if(strcmp(acode,"AOH") == 0)
         return(1);
      else if(strcmp(acode,"HGF") == 0)
         return(1);
      else if(strcmp(acode,"HGT") == 0)
         return(1);
      else if(strcmp(acode,"Z5F") == 0)
         return(1);
      else if(strcmp(acode,"Z5M") == 0)
         return(1);
      else if(strcmp(acode,"Z7F") == 0)
         return(1);
      else if(strcmp(acode,"ZV7") == 0)
         return(1);
      }
   else if((strcmp(fcode,"AL070") == 0) && (geom == 'L'))
      {
      if(strcmp(acode,"AEH") == 0)
         return(1);
      else if(strcmp(acode,"ALA") == 0)
         return(1);
      else if(strcmp(acode,"ALO") == 0)
         return(1);
      else if(strcmp(acode,"AOH") == 0)
         return(1);
      else if(strcmp(acode,"HGF") == 0)
         return(1);
      else if(strcmp(acode,"HGT") == 0)
         return(1);
      else if(strcmp(acode,"Z5F") == 0)
         return(1);
      else if(strcmp(acode,"Z5M") == 0)
         return(1);
      else if(strcmp(acode,"Z7F") == 0)
         return(1);
      else if(strcmp(acode,"ZV7") == 0)
         return(1);
      }
   else if((strcmp(fcode,"AL110") == 0) && (geom == 'P'))
      {
      if(strcmp(acode,"AEH") == 0)
         return(1);
      else if(strcmp(acode,"ALA") == 0)
         return(1);
      else if(strcmp(acode,"ALO") == 0)
         return(1);
      else if(strcmp(acode,"AOH") == 0)
         return(1);
      else if(strcmp(acode,"HGF") == 0)
         return(1);
      else if(strcmp(acode,"HGT") == 0)
         return(1);
      else if(strcmp(acode,"Z5F") == 0)
         return(1);
      else if(strcmp(acode,"Z5M") == 0)
         return(1);
      else if(strcmp(acode,"Z7F") == 0)
         return(1);
      else if(strcmp(acode,"ZV7") == 0)
         return(1);
      }
   else if((strcmp(fcode,"AL241") == 0) && (geom == 'P'))
      {
      if(strcmp(acode,"AEH") == 0)
         return(1);
      else if(strcmp(acode,"ALA") == 0)
         return(1);
      else if(strcmp(acode,"ALO") == 0)
         return(1);
      else if(strcmp(acode,"AOH") == 0)
         return(1);
      else if(strcmp(acode,"HGF") == 0)
         return(1);
      else if(strcmp(acode,"HGT") == 0)
         return(1);
      else if(strcmp(acode,"Z5F") == 0)
         return(1);
      else if(strcmp(acode,"Z5M") == 0)
         return(1);
      else if(strcmp(acode,"Z7F") == 0)
         return(1);
      else if(strcmp(acode,"ZV7") == 0)
         return(1);
      }
   else if((strcmp(fcode,"AL260") == 0) && (geom == 'L'))
      {
      if(strcmp(acode,"AEH") == 0)
         return(1);
      else if(strcmp(acode,"ALA") == 0)
         return(1);
      else if(strcmp(acode,"ALO") == 0)
         return(1);
      else if(strcmp(acode,"AOH") == 0)
         return(1);
      else if(strcmp(acode,"HGF") == 0)
         return(1);
      else if(strcmp(acode,"HGT") == 0)
         return(1);
      else if(strcmp(acode,"Z5F") == 0)
         return(1);
      else if(strcmp(acode,"Z5M") == 0)
         return(1);
      else if(strcmp(acode,"Z7F") == 0)
         return(1);
      else if(strcmp(acode,"ZV7") == 0)
         return(1);
      }
   else if((strcmp(fcode,"AM010") == 0) && (geom == 'A'))
      {
      if(strcmp(acode,"AEH") == 0)
         return(1);
      else if(strcmp(acode,"ALA") == 0)
         return(1);
      else if(strcmp(acode,"ALO") == 0)
         return(1);
      else if(strcmp(acode,"AOH") == 0)
         return(1);
      else if(strcmp(acode,"Z5F") == 0)
         return(1);
      else if(strcmp(acode,"Z5M") == 0)
         return(1);
      else if(strcmp(acode,"Z7F") == 0)
         return(1);
      else if(strcmp(acode,"ZV7") == 0)
         return(1);
      }
   else if((strcmp(fcode,"AM060") == 0) && (geom == 'A'))
      {
      if(strcmp(acode,"AEH") == 0)
         return(1);
      else if(strcmp(acode,"ALA") == 0)
         return(1);
      else if(strcmp(acode,"ALO") == 0)
         return(1);
      else if(strcmp(acode,"AOH") == 0)
         return(1);
      else if(strcmp(acode,"HGF") == 0)
         return(1);
      else if(strcmp(acode,"HGT") == 0)
         return(1);
      else if(strcmp(acode,"Z5F") == 0)
         return(1);
      else if(strcmp(acode,"Z5M") == 0)
         return(1);
      else if(strcmp(acode,"Z7F") == 0)
         return(1);
      else if(strcmp(acode,"ZV7") == 0)
         return(1);
      }
   else if((strcmp(fcode,"AM065") == 0) && (geom == 'A'))
      {
      if(strcmp(acode,"AEH") == 0)
         return(1);
      else if(strcmp(acode,"ALA") == 0)
         return(1);
      else if(strcmp(acode,"ALO") == 0)
         return(1);
      else if(strcmp(acode,"AOH") == 0)
         return(1);
      else if(strcmp(acode,"Z5F") == 0)
         return(1);
      else if(strcmp(acode,"Z5M") == 0)
         return(1);
      else if(strcmp(acode,"Z7F") == 0)
         return(1);
      else if(strcmp(acode,"ZV7") == 0)
         return(1);
      }
   else if((strcmp(fcode,"AM070") == 0) && (geom == 'A'))
      {
      if(strcmp(acode,"AEH") == 0)
         return(1);
      else if(strcmp(acode,"ALA") == 0)
         return(1);
      else if(strcmp(acode,"ALO") == 0)
         return(1);
      else if(strcmp(acode,"AOH") == 0)
         return(1);
      else if(strcmp(acode,"HGF") == 0)
         return(1);
      else if(strcmp(acode,"HGT") == 0)
         return(1);
      else if(strcmp(acode,"Z5F") == 0)
         return(1);
      else if(strcmp(acode,"Z5M") == 0)
         return(1);
      else if(strcmp(acode,"Z7F") == 0)
         return(1);
      else if(strcmp(acode,"ZV7") == 0)
         return(1);
      }
   else if((strcmp(fcode,"AM070") == 0) && (geom == 'P'))
      {
      if(strcmp(acode,"AEH") == 0)
         return(1);
      else if(strcmp(acode,"ALA") == 0)
         return(1);
      else if(strcmp(acode,"ALO") == 0)
         return(1);
      else if(strcmp(acode,"AOH") == 0)
         return(1);
      else if(strcmp(acode,"HGF") == 0)
         return(1);
      else if(strcmp(acode,"HGT") == 0)
         return(1);
      else if(strcmp(acode,"Z5F") == 0)
         return(1);
      else if(strcmp(acode,"Z5M") == 0)
         return(1);
      else if(strcmp(acode,"Z7F") == 0)
         return(1);
      else if(strcmp(acode,"ZV7") == 0)
         return(1);
      }
   else if((strcmp(fcode,"AM075") == 0) && (geom == 'A'))
      {
      if(strcmp(acode,"AEH") == 0)
         return(1);
      else if(strcmp(acode,"ALA") == 0)
         return(1);
      else if(strcmp(acode,"ALO") == 0)
         return(1);
      else if(strcmp(acode,"AOH") == 0)
         return(1);
      else if(strcmp(acode,"Z5F") == 0)
         return(1);
      else if(strcmp(acode,"Z5M") == 0)
         return(1);
      else if(strcmp(acode,"Z7F") == 0)
         return(1);
      else if(strcmp(acode,"ZV7") == 0)
         return(1);
      }
   else if((strcmp(fcode,"AM080") == 0) && (geom == 'P'))
      {
      if(strcmp(acode,"AEH") == 0)
         return(1);
      else if(strcmp(acode,"ALA") == 0)
         return(1);
      else if(strcmp(acode,"ALO") == 0)
         return(1);
      else if(strcmp(acode,"AOH") == 0)
         return(1);
      else if(strcmp(acode,"HGF") == 0)
         return(1);
      else if(strcmp(acode,"HGT") == 0)
         return(1);
      else if(strcmp(acode,"Z5F") == 0)
         return(1);
      else if(strcmp(acode,"Z5M") == 0)
         return(1);
      else if(strcmp(acode,"Z7F") == 0)
         return(1);
      else if(strcmp(acode,"ZV7") == 0)
         return(1);
      }
   else if((strcmp(fcode,"AN010") == 0) && (geom == 'L'))
      {
      if(strcmp(acode,"AEH") == 0)
         return(1);
      else if(strcmp(acode,"ALA") == 0)
         return(1);
      else if(strcmp(acode,"ALO") == 0)
         return(1);
      else if(strcmp(acode,"AOH") == 0)
         return(1);
      else if(strcmp(acode,"LTN") == 0)
         return(1);
      else if(strcmp(acode,"Z5F") == 0)
         return(1);
      else if(strcmp(acode,"Z5M") == 0)
         return(1);
      else if(strcmp(acode,"Z7F") == 0)
         return(1);
      else if(strcmp(acode,"ZV7") == 0)
         return(1);
      }
   else if((strcmp(fcode,"AN050") == 0) && (geom == 'L'))
      {
      if(strcmp(acode,"AEH") == 0)
         return(1);
      else if(strcmp(acode,"ALA") == 0)
         return(1);
      else if(strcmp(acode,"ALO") == 0)
         return(1);
      else if(strcmp(acode,"AOH") == 0)
         return(1);
      else if(strcmp(acode,"LTN") == 0)
         return(1);
      else if(strcmp(acode,"Z5F") == 0)
         return(1);
      else if(strcmp(acode,"Z5M") == 0)
         return(1);
      else if(strcmp(acode,"Z7F") == 0)
         return(1);
      else if(strcmp(acode,"ZV7") == 0)
         return(1);
      }
   else if((strcmp(fcode,"AP030") == 0) && (geom == 'L'))
      {
      if(strcmp(acode,"AEH") == 0)
         return(1);
      else if(strcmp(acode,"ALA") == 0)
         return(1);
      else if(strcmp(acode,"ALO") == 0)
         return(1);
      else if(strcmp(acode,"AOH") == 0)
         return(1);
      else if(strcmp(acode,"LTN") == 0)
         return(1);
      else if(strcmp(acode,"WGF") == 0)
         return(1);
      else if(strcmp(acode,"WGP") == 0)
         return(1);
      else if(strcmp(acode,"Z5F") == 0)
         return(1);
      else if(strcmp(acode,"Z5M") == 0)
         return(1);
      else if(strcmp(acode,"Z7F") == 0)
         return(1);
      else if(strcmp(acode,"ZV7") == 0)
         return(1);
      }
   else if((strcmp(fcode,"AP041") == 0) && (geom == 'L'))
      {
      if(strcmp(acode,"AEH") == 0)
         return(1);
      else if(strcmp(acode,"ALA") == 0)
         return(1);
      else if(strcmp(acode,"ALO") == 0)
         return(1);
      else if(strcmp(acode,"AOH") == 0)
         return(1);
      else if(strcmp(acode,"HGF") == 0)
         return(1);
      else if(strcmp(acode,"HGT") == 0)
         return(1);
      else if(strcmp(acode,"Z5F") == 0)
         return(1);
      else if(strcmp(acode,"Z5M") == 0)
         return(1);
      else if(strcmp(acode,"Z7F") == 0)
         return(1);
      else if(strcmp(acode,"ZV7") == 0)
         return(1);
      }
   else if((strcmp(fcode,"AQ040") == 0) && (geom == 'A'))
      {
      if(strcmp(acode,"AEH") == 0)
         return(1);
      else if(strcmp(acode,"ALA") == 0)
         return(1);
      else if(strcmp(acode,"ALO") == 0)
         return(1);
      else if(strcmp(acode,"AOH") == 0)
         return(1);
      else if(strcmp(acode,"Z5F") == 0)
         return(1);
      else if(strcmp(acode,"Z5M") == 0)
         return(1);
      else if(strcmp(acode,"Z7F") == 0)
         return(1);
      else if(strcmp(acode,"ZV7") == 0)
         return(1);
      }
   else if((strcmp(fcode,"AQ060") == 0) && (geom == 'A'))
      {
      if(strcmp(acode,"AEH") == 0)
         return(1);
      else if(strcmp(acode,"ALA") == 0)
         return(1);
      else if(strcmp(acode,"ALO") == 0)
         return(1);
      else if(strcmp(acode,"AOH") == 0)
         return(1);
      else if(strcmp(acode,"HGF") == 0)
         return(1);
      else if(strcmp(acode,"HGT") == 0)
         return(1);
      else if(strcmp(acode,"Z5F") == 0)
         return(1);
      else if(strcmp(acode,"Z5M") == 0)
         return(1);
      else if(strcmp(acode,"Z7F") == 0)
         return(1);
      else if(strcmp(acode,"ZV7") == 0)
         return(1);
      }
   else if((strcmp(fcode,"AQ065") == 0) && (geom == 'P'))
      {
      if(strcmp(acode,"AEH") == 0)
         return(1);
      else if(strcmp(acode,"ALA") == 0)
         return(1);
      else if(strcmp(acode,"ALO") == 0)
         return(1);
      else if(strcmp(acode,"AOH") == 0)
         return(1);
      else if(strcmp(acode,"Z5F") == 0)
         return(1);
      else if(strcmp(acode,"Z5M") == 0)
         return(1);
      else if(strcmp(acode,"Z7F") == 0)
         return(1);
      else if(strcmp(acode,"ZV7") == 0)
         return(1);
      }
   else if((strcmp(fcode,"AQ090") == 0) && (geom == 'P'))
      {
      if(strcmp(acode,"AEH") == 0)
         return(1);
      else if(strcmp(acode,"ALA") == 0)
         return(1);
      else if(strcmp(acode,"ALO") == 0)
         return(1);
      else if(strcmp(acode,"AOH") == 0)
         return(1);
      else if(strcmp(acode,"Z5F") == 0)
         return(1);
      else if(strcmp(acode,"Z5M") == 0)
         return(1);
      else if(strcmp(acode,"Z7F") == 0)
         return(1);
      else if(strcmp(acode,"ZV7") == 0)
         return(1);
      }
   else if((strcmp(fcode,"AQ095") == 0) && (geom == 'P'))
      {
      if(strcmp(acode,"AEH") == 0)
         return(1);
      else if(strcmp(acode,"ALA") == 0)
         return(1);
      else if(strcmp(acode,"ALO") == 0)
         return(1);
      else if(strcmp(acode,"AOH") == 0)
         return(1);
      else if(strcmp(acode,"MVC") == 0)
         return(1);
      else if(strcmp(acode,"WD2") == 0)
         return(1);
      else if(strcmp(acode,"Z5F") == 0)
         return(1);
      else if(strcmp(acode,"Z5M") == 0)
         return(1);
      else if(strcmp(acode,"Z7F") == 0)
         return(1);
      else if(strcmp(acode,"ZV7") == 0)
         return(1);
      }
   else if((strcmp(fcode,"AQ113") == 0) && (geom == 'L'))
      {
      if(strcmp(acode,"AEH") == 0)
         return(1);
      else if(strcmp(acode,"ALA") == 0)
         return(1);
      else if(strcmp(acode,"ALO") == 0)
         return(1);
      else if(strcmp(acode,"AOH") == 0)
         return(1);
      else if(strcmp(acode,"HGF") == 0)
         return(1);
      else if(strcmp(acode,"HGT") == 0)
         return(1);
      else if(strcmp(acode,"Z5F") == 0)
         return(1);
      else if(strcmp(acode,"Z5M") == 0)
         return(1);
      else if(strcmp(acode,"Z7F") == 0)
         return(1);
      else if(strcmp(acode,"ZV7") == 0)
         return(1);
      }
   else if((strcmp(fcode,"BA010") == 0) && (geom == 'L'))
      {
      if(strcmp(acode,"AEH") == 0)
         return(1);
      else if(strcmp(acode,"ALA") == 0)
         return(1);
      else if(strcmp(acode,"ALO") == 0)
         return(1);
      else if(strcmp(acode,"AOH") == 0)
         return(1);
      else if(strcmp(acode,"Z5F") == 0)
         return(1);
      else if(strcmp(acode,"Z5M") == 0)
         return(1);
      else if(strcmp(acode,"Z7F") == 0)
         return(1);
      else if(strcmp(acode,"ZV7") == 0)
         return(1);
      }
   else if((strcmp(fcode,"BH030") == 0) && (geom == 'L'))
      {
      if(strcmp(acode,"AEH") == 0)
         return(1);
      else if(strcmp(acode,"ALA") == 0)
         return(1);
      else if(strcmp(acode,"ALO") == 0)
         return(1);
      else if(strcmp(acode,"AOH") == 0)
         return(1);
      else if(strcmp(acode,"WGF") == 0)
         return(1);
      else if(strcmp(acode,"WGP") == 0)
         return(1);
      else if(strcmp(acode,"Z5F") == 0)
         return(1);
      else if(strcmp(acode,"Z5M") == 0)
         return(1);
      else if(strcmp(acode,"Z7F") == 0)
         return(1);
      else if(strcmp(acode,"ZV7") == 0)
         return(1);
      }
   else if((strcmp(fcode,"DB185") == 0) && (geom == 'A'))
      {
      if(strcmp(acode,"AEH") == 0)
         return(1);
      else if(strcmp(acode,"ALA") == 0)
         return(1);
      else if(strcmp(acode,"ALO") == 0)
         return(1);
      else if(strcmp(acode,"AOH") == 0)
         return(1);
      else if(strcmp(acode,"LEF") == 0)
         return(1);
      else if(strcmp(acode,"LEN") == 0)
         return(1);
      else if(strcmp(acode,"WGF") == 0)
         return(1);
      else if(strcmp(acode,"WGP") == 0)
         return(1);
      else if(strcmp(acode,"Z5F") == 0)
         return(1);
      else if(strcmp(acode,"Z5M") == 0)
         return(1);
      else if(strcmp(acode,"Z7F") == 0)
         return(1);
      else if(strcmp(acode,"ZV7") == 0)
         return(1);
      }
   else if((strcmp(fcode,"EC031") == 0) && (geom == 'P'))
      {
      if(strcmp(acode,"AEH") == 0)
         return(1);
      else if(strcmp(acode,"ALA") == 0)
         return(1);
      else if(strcmp(acode,"ALO") == 0)
         return(1);
      else if(strcmp(acode,"AOH") == 0)
         return(1);
      else if(strcmp(acode,"HGF") == 0)
         return(1);
      else if(strcmp(acode,"HGT") == 0)
         return(1);
      else if(strcmp(acode,"Z5F") == 0)
         return(1);
      else if(strcmp(acode,"Z5M") == 0)
         return(1);
      else if(strcmp(acode,"Z7F") == 0)
         return(1);
      else if(strcmp(acode,"ZV7") == 0)
         return(1);
      }
   else if((strcmp(fcode,"GA035") == 0) && (geom == 'P'))
      {
      if(strcmp(acode,"AEH") == 0)
         return(1);
      else if(strcmp(acode,"ALA") == 0)
         return(1);
      else if(strcmp(acode,"ALO") == 0)
         return(1);
      else if(strcmp(acode,"AOH") == 0)
         return(1);
      else if(strcmp(acode,"HGF") == 0)
         return(1);
      else if(strcmp(acode,"HGT") == 0)
         return(1);
      else if(strcmp(acode,"Z5F") == 0)
         return(1);
      else if(strcmp(acode,"Z5M") == 0)
         return(1);
      else if(strcmp(acode,"Z7F") == 0)
         return(1);
      else if(strcmp(acode,"ZV7") == 0)
         return(1);
      }
   else if((strcmp(fcode,"GA048") == 0) && (geom == 'P'))
      {
      if(strcmp(acode,"AEH") == 0)
         return(1);
      else if(strcmp(acode,"ALA") == 0)
         return(1);
      else if(strcmp(acode,"ALO") == 0)
         return(1);
      else if(strcmp(acode,"AOH") == 0)
         return(1);
      else if(strcmp(acode,"HGF") == 0)
         return(1);
      else if(strcmp(acode,"HGT") == 0)
         return(1);
      else if(strcmp(acode,"Z5F") == 0)
         return(1);
      else if(strcmp(acode,"Z5M") == 0)
         return(1);
      else if(strcmp(acode,"Z7F") == 0)
         return(1);
      else if(strcmp(acode,"ZV7") == 0)
         return(1);
      }
   else if((strcmp(fcode,"GB015") == 0) && (geom == 'A'))
      {
      if(strcmp(acode,"AEH") == 0)
         return(1);
      else if(strcmp(acode,"ALA") == 0)
         return(1);
      else if(strcmp(acode,"ALO") == 0)
         return(1);
      else if(strcmp(acode,"AOH") == 0)
         return(1);
      else if(strcmp(acode,"ARA") == 0)
         return(1);
      else if(strcmp(acode,"LCX") == 0)
         return(1);
      else if(strcmp(acode,"LEF") == 0)
         return(1);
      else if(strcmp(acode,"LEN") == 0)
         return(1);
      else if(strcmp(acode,"WGF") == 0)
         return(1);
      else if(strcmp(acode,"WGP") == 0)
         return(1);
      else if(strcmp(acode,"Z5F") == 0)
         return(1);
      else if(strcmp(acode,"Z5M") == 0)
         return(1);
      else if(strcmp(acode,"Z7F") == 0)
         return(1);
      else if(strcmp(acode,"ZV7") == 0)
         return(1);
      }
   else if((strcmp(fcode,"GB020") == 0) && (geom == 'L'))
      {
      if(strcmp(acode,"AEH") == 0)
         return(1);
      else if(strcmp(acode,"ALA") == 0)
         return(1);
      else if(strcmp(acode,"ALO") == 0)
         return(1);
      else if(strcmp(acode,"AOH") == 0)
         return(1);
      else if(strcmp(acode,"Z5F") == 0)
         return(1);
      else if(strcmp(acode,"Z5M") == 0)
         return(1);
      else if(strcmp(acode,"Z7F") == 0)
         return(1);
      else if(strcmp(acode,"ZV7") == 0)
         return(1);
      }
   else if((strcmp(fcode,"GB025") == 0) && (geom == 'L'))
      {
      if(strcmp(acode,"AEH") == 0)
         return(1);
      else if(strcmp(acode,"ALA") == 0)
         return(1);
      else if(strcmp(acode,"ALO") == 0)
         return(1);
      else if(strcmp(acode,"AOH") == 0)
         return(1);
      else if(strcmp(acode,"HGF") == 0)
         return(1);
      else if(strcmp(acode,"HGT") == 0)
         return(1);
      else if(strcmp(acode,"Z5F") == 0)
         return(1);
      else if(strcmp(acode,"Z5M") == 0)
         return(1);
      else if(strcmp(acode,"Z7F") == 0)
         return(1);
      else if(strcmp(acode,"ZV7") == 0)
         return(1);
      }
   else if((strcmp(fcode,"GB030") == 0) && (geom == 'A'))
      {
      if(strcmp(acode,"AEH") == 0)
         return(1);
      else if(strcmp(acode,"ALA") == 0)
         return(1);
      else if(strcmp(acode,"ALO") == 0)
         return(1);
      else if(strcmp(acode,"AOH") == 0)
         return(1);
      else if(strcmp(acode,"LEF") == 0)
         return(1);
      else if(strcmp(acode,"LEN") == 0)
         return(1);
      else if(strcmp(acode,"WGF") == 0)
         return(1);
      else if(strcmp(acode,"WGP") == 0)
         return(1);
      else if(strcmp(acode,"Z5F") == 0)
         return(1);
      else if(strcmp(acode,"Z5M") == 0)
         return(1);
      else if(strcmp(acode,"Z7F") == 0)
         return(1);
      else if(strcmp(acode,"ZV7") == 0)
         return(1);
      }
   else if((strcmp(fcode,"GB045") == 0) && (geom == 'A'))
      {
      if(strcmp(acode,"AEH") == 0)
         return(1);
      else if(strcmp(acode,"ALA") == 0)
         return(1);
      else if(strcmp(acode,"ALO") == 0)
         return(1);
      else if(strcmp(acode,"AOH") == 0)
         return(1);
      else if(strcmp(acode,"LEF") == 0)
         return(1);
      else if(strcmp(acode,"LEN") == 0)
         return(1);
      else if(strcmp(acode,"WGF") == 0)
         return(1);
      else if(strcmp(acode,"WGP") == 0)
         return(1);
      else if(strcmp(acode,"Z5F") == 0)
         return(1);
      else if(strcmp(acode,"Z5M") == 0)
         return(1);
      else if(strcmp(acode,"Z7F") == 0)
         return(1);
      else if(strcmp(acode,"ZV7") == 0)
         return(1);
      }
   else if((strcmp(fcode,"GB050") == 0) && (geom == 'L'))
      {
      if(strcmp(acode,"AEH") == 0)
         return(1);
      else if(strcmp(acode,"ALA") == 0)
         return(1);
      else if(strcmp(acode,"ALO") == 0)
         return(1);
      else if(strcmp(acode,"AOH") == 0)
         return(1);
      else if(strcmp(acode,"HGF") == 0)
         return(1);
      else if(strcmp(acode,"HGT") == 0)
         return(1);
      else if(strcmp(acode,"Z5F") == 0)
         return(1);
      else if(strcmp(acode,"Z5M") == 0)
         return(1);
      else if(strcmp(acode,"Z7F") == 0)
         return(1);
      else if(strcmp(acode,"ZV7") == 0)
         return(1);
      }
   else if((strcmp(fcode,"GB055") == 0) && (geom == 'A'))
      {
      if(strcmp(acode,"AEH") == 0)
         return(1);
      else if(strcmp(acode,"ALA") == 0)
         return(1);
      else if(strcmp(acode,"ALO") == 0)
         return(1);
      else if(strcmp(acode,"AOH") == 0)
         return(1);
      else if(strcmp(acode,"LCX") == 0)
         return(1);
      else if(strcmp(acode,"LEF") == 0)
         return(1);
      else if(strcmp(acode,"LEN") == 0)
         return(1);
      else if(strcmp(acode,"WGF") == 0)
         return(1);
      else if(strcmp(acode,"WGP") == 0)
         return(1);
      else if(strcmp(acode,"Z5F") == 0)
         return(1);
      else if(strcmp(acode,"Z5M") == 0)
         return(1);
      else if(strcmp(acode,"Z7F") == 0)
         return(1);
      else if(strcmp(acode,"ZV7") == 0)
         return(1);
      }
   else if((strcmp(fcode,"GB056") == 0) && (geom == 'P'))
      {
      if(strcmp(acode,"AEH") == 0)
         return(1);
      else if(strcmp(acode,"ALA") == 0)
         return(1);
      else if(strcmp(acode,"ALO") == 0)
         return(1);
      else if(strcmp(acode,"AOH") == 0)
         return(1);
      else if(strcmp(acode,"Z5F") == 0)
         return(1);
      else if(strcmp(acode,"Z5M") == 0)
         return(1);
      else if(strcmp(acode,"Z7F") == 0)
         return(1);
      else if(strcmp(acode,"ZV7") == 0)
         return(1);
      }
   else if((strcmp(fcode,"GB075") == 0) && (geom == 'A'))
      {
      if(strcmp(acode,"AEH") == 0)
         return(1);
      else if(strcmp(acode,"ALA") == 0)
         return(1);
      else if(strcmp(acode,"ALO") == 0)
         return(1);
      else if(strcmp(acode,"AOH") == 0)
         return(1);
      else if(strcmp(acode,"LCX") == 0)
         return(1);
      else if(strcmp(acode,"WGF") == 0)
         return(1);
      else if(strcmp(acode,"WGP") == 0)
         return(1);
      else if(strcmp(acode,"Z5F") == 0)
         return(1);
      else if(strcmp(acode,"Z5M") == 0)
         return(1);
      else if(strcmp(acode,"Z7F") == 0)
         return(1);
      else if(strcmp(acode,"ZV7") == 0)
         return(1);
      }
   else if((strcmp(fcode,"GB090") == 0) && (geom == 'A'))
      {
      if(strcmp(acode,"AEH") == 0)
         return(1);
      else if(strcmp(acode,"ALA") == 0)
         return(1);
      else if(strcmp(acode,"ALO") == 0)
         return(1);
      else if(strcmp(acode,"AOH") == 0)
         return(1);
      else if(strcmp(acode,"DTF") == 0)
         return(1);
      else if(strcmp(acode,"DTM") == 0)
         return(1);
      else if(strcmp(acode,"WGF") == 0)
         return(1);
      else if(strcmp(acode,"WGP") == 0)
         return(1);
      else if(strcmp(acode,"Z5F") == 0)
         return(1);
      else if(strcmp(acode,"Z5M") == 0)
         return(1);
      else if(strcmp(acode,"Z7F") == 0)
         return(1);
      else if(strcmp(acode,"ZV7") == 0)
         return(1);
      }
   else if((strcmp(fcode,"GB090") == 0) && (geom == 'P'))
      {
      if(strcmp(acode,"AEH") == 0)
         return(1);
      else if(strcmp(acode,"ALA") == 0)
         return(1);
      else if(strcmp(acode,"ALO") == 0)
         return(1);
      else if(strcmp(acode,"AOH") == 0)
         return(1);
      else if(strcmp(acode,"Z5F") == 0)
         return(1);
      else if(strcmp(acode,"Z5M") == 0)
         return(1);
      else if(strcmp(acode,"Z7F") == 0)
         return(1);
      else if(strcmp(acode,"ZV7") == 0)
         return(1);
      }
   else if((strcmp(fcode,"GB230") == 0) && (geom == 'A'))
      {
      if(strcmp(acode,"AEH") == 0)
         return(1);
      else if(strcmp(acode,"ALA") == 0)
         return(1);
      else if(strcmp(acode,"ALO") == 0)
         return(1);
      else if(strcmp(acode,"AOH") == 0)
         return(1);
      else if(strcmp(acode,"HDW") == 0)
         return(1);
      else if(strcmp(acode,"HGF") == 0)
         return(1);
      else if(strcmp(acode,"HGT") == 0)
         return(1);
      else if(strcmp(acode,"HNG") == 0)
         return(1);
      else if(strcmp(acode,"LEF") == 0)
         return(1);
      else if(strcmp(acode,"LEN") == 0)
         return(1);
      else if(strcmp(acode,"WGF") == 0)
         return(1);
      else if(strcmp(acode,"WGP") == 0)
         return(1);
      else if(strcmp(acode,"Z5F") == 0)
         return(1);
      else if(strcmp(acode,"Z5M") == 0)
         return(1);
      else if(strcmp(acode,"Z7F") == 0)
         return(1);
      else if(strcmp(acode,"ZV7") == 0)
         return(1);
      }
   else if((strcmp(fcode,"GB250") == 0) && (geom == 'A'))
      {
      if(strcmp(acode,"AEH") == 0)
         return(1);
      else if(strcmp(acode,"ALA") == 0)
         return(1);
      else if(strcmp(acode,"ALO") == 0)
         return(1);
      else if(strcmp(acode,"AOH") == 0)
         return(1);
      else if(strcmp(acode,"HDW") == 0)
         return(1);
      else if(strcmp(acode,"HGF") == 0)
         return(1);
      else if(strcmp(acode,"HGT") == 0)
         return(1);
      else if(strcmp(acode,"HNG") == 0)
         return(1);
      else if(strcmp(acode,"LEF") == 0)
         return(1);
      else if(strcmp(acode,"LEN") == 0)
         return(1);
      else if(strcmp(acode,"WGF") == 0)
         return(1);
      else if(strcmp(acode,"WGP") == 0)
         return(1);
      else if(strcmp(acode,"Z5F") == 0)
         return(1);
      else if(strcmp(acode,"Z5M") == 0)
         return(1);
      else if(strcmp(acode,"Z7F") == 0)
         return(1);
      else if(strcmp(acode,"ZV7") == 0)
         return(1);
      }
   return(0);
}


void Fwrite_Portray_TreeInorder(rb_red_blk_tree* tree, rb_red_blk_node* x, FILE * PortrayFile)
{
struct RB_IDkey *k;

   if (x != tree->nil)
      {
      Fwrite_Portray_TreeInorder(tree,x->left,PortrayFile);

      k = (struct RB_IDkey *) (x->info);

      if(k->counter >= 1)
         {
         fprintf(PortrayFile, "%d,%s",k->counter,k->idstr);  /*** line should already include '\n' ****/
         }

      Fwrite_Portray_TreeInorder(tree,x->right,PortrayFile);
      }
}



int OTHvalueCorrectFormat(void)
{
char target[100];
char *CopyOfOTHvalue;
int i,j,k;

   if(BadOTH.OTHvalue[0] < ' ')
      return(0);

   CopyOfOTHvalue = (char *) (malloc(strlen(BadOTH.OTHvalue) + 2));
   strcpy(CopyOfOTHvalue,BadOTH.OTHvalue);

   AFOc = BadOTH.attrs;
   while(AFOc != NULL)
      {
      strcpy(target,GetEACLabel(AFOc->acode));
      j = strlen(target);
      i = 0;
      while(CopyOfOTHvalue[i] != '(')
         {
         ++i;
         if(CopyOfOTHvalue[i] < ' ')
            {
            free(CopyOfOTHvalue);
            return(0);
            }
         }
      ++i;
      while(CopyOfOTHvalue[i] == ' ')
         ++i;
      if(strncmp(&CopyOfOTHvalue[i],target,j) == 0)
         {
         k = i;
         i += j;
         while(CopyOfOTHvalue[i] == ' ')
            ++i;
         if(CopyOfOTHvalue[i] != ':')
            {
            free(CopyOfOTHvalue);
            return(0);
            }
         ++i;
         while(CopyOfOTHvalue[i] != ')')
            {
            if(CopyOfOTHvalue[i] < ' ')
               {
               free(CopyOfOTHvalue);
               return(0);
               }
            ++i;
            }
         if(CopyOfOTHvalue[i] == ')')
            {
            for(j = k; j<= i; j++)
               CopyOfOTHvalue[j] = ' ';
            }
         else
            {
            free(CopyOfOTHvalue);
            return(0);
            }
         }
      AFOc = AFOc->next;
      }
   free(CopyOfOTHvalue);
   return(1);
}




void CheckGIFDcompliance(int SACfull_x_2,int model_polys,int areals_done,int linears_done,int points_done,
              int sphere_cv,int parallel_cv,int stamps_done,int footprints_done, int bridges_done,unsigned int g_read,unsigned int g_write,
              int FMpointsdone,int FMlinesdone,int FMarealsdone, char * projectpath)
{
extern char * ConflateSourceFiles;
extern char * GetFileNamefile();
FILE *errrpt;
FILE *fidreport;
FILE *csv_errrpt;
FILE *fileptr;
FILE *qacr;
FILE *portrayreport;
FILE *portrayfails;
FILE *TDS_NE_SPEC;
rb_red_blk_tree * Portray_RB_Tree;
int SzIDK = sizeof(struct RB_IDkey);
int ECC,EEC, seeitgeom,NumAttr,EAC,EAC2,EAC3,EAC4,uom, uomscale,SEDRIStype,datatype,Idtvalue;
int year, month, day;
int enumcode, MDcode,paragraph,namesize;
int TDS_GE4_sentinel, TDS_GE4_3letter, TDS_GE4_17letter;
int enoted[15];
double Fdtvalue;
struct indexlist *I1, *I2;
struct EnumList *en, *ep, *ec;
int numchar,nc2;
int WriteTheError;
int BadFcodeGeomPair,NE_FcodeGeomPair;
char QACRstring[300];
char * titlechar;
char * res2;
char shapefile[1000];
char tshapefile[1000];
char enumcodestring[2000];
char resultmessage[2000];
char tempstring[2000];
char MinString[50], MaxString[50];
int tlimit, tlimittest;
char wchar,GEOM;
char errkey;
char geomkey[10];
int ni,nj,si,i,j,k, ii, ii1, ii2, jj, ki, l, l2, l3, loops,CheckIt,fid_written, TDS_Interval_Vals,unusedint;
int ijunk, kjunk, jjunk, thistype, counter,HGT_code, ZV2_code, ARA_code, Loop_code;
int NAM_code, LEN_code;
int Type0,Type1, Type2, Type3, Type4, Type5, Type6;
int P_pass, C_pass, S_pass, P_try, C_try, S_try;
int ErrorNoted, MGCP_PPO_violation;
int AcodeErr, AcodePoss;
int useid, entryindex, linkageOK;
long double NUNANPOlower, NUNANPOupper;
int *Indices;
double di;
double NumToCheck;
double djunk,djunk2,unuseddbl;
double PCdone;
double NumDone = 0.0;
double minallowed, maxallowed;
char ECCstr[200];
char ECCname[200];
char EACname[1000];
char EACcode[200];
char EEname[1000];
char domainstr[200];
char DoubleAsString[100];
char MGCP_NAM_str[258];
char MGCP_NFN_str[258];
char MGCP_NFI_str[258];
char MGCP_CAA_str[258];
char InequalityType[20];
int MGCP_NAM_index, MGCP_NFN_index, MGCP_NFI_index, resetNFN, resetNFI;
int MGCP_DMT_index, MGCP_DMB_index, MGCP_Wood_index, MGCP_Thicket_index;
int MGCP_Heliport_index, MGCP_Runway_index, MGCP_L_Aerodrome_index, MGCP_W_Aerodrome_index;
int MGCP_CAA_index,MGCP_IKO_index,LTDS4_Road_Index,TDS_OTH_index;
int TDS_GE4_index,TDS_GE42_index,TDS_GE43_index,TDS_GE44_index;
int SRC_DATE_index, UPD_DATE_index;
int MGCP_UID_Indices_index;
struct RuleAttrs *RAc;
struct NameList *cnl, *pnl;
struct LocalAttrList *ML2;
struct LocalAttrList *cal;
struct LocalAttrValList *cvl;
struct EnumList *cel, *nel, *pel;
long int TodayTime;
char timestring[200];
char YearLimit[20];
char Smonth[10], Sday[10];
char Hint[100];
int * LLtoGeom;
int IntYearLimit, MGCP_BldgCode;
int DayLimit;
extern char *GetLongCode (int attr_type);
struct N_N_N
   {
   char *NNNstr;
   char *NAMstr;
   char *NFIstr;
   char *NFNstr;
   int count;
   struct N_N_N *next;
   } *NNNroot, *UNKroot, *NNc, *NNp, *NNn, *NNtemp;
struct AE_NotExtracted /** used to generate an Attr Error (fcode + geom pair) ***/
   {
   int ecc;
   int geom;
   struct AE_NotExtracted * next;
   }  *AE_TDS_NEroot, *AE_TDS_NEc, *AE_TDS_NEp;
int SzAE_NE = sizeof(struct AE_NotExtracted);
int SzNNN = sizeof(struct N_N_N);

   TodayTime = time(NULL);
   sprintf(timestring,"%s",ctime(&TodayTime));
   i = strlen(timestring);
   while(timestring[i] != ' ')
      {
      if(timestring[i] < ' ')
         timestring[i] = '\0';
      --i;
      }
   strcpy(YearLimit,&timestring[i+1]);
   sscanf(YearLimit,"%d",&IntYearLimit);
   i = 0;
   while(timestring[i] != ' ') /**skip the actual clock time ***/
      ++i;
   ++i;
   if(strncmp(&timestring[i],"Jan",3) == 0)
      {
      strcpy(Smonth,"01");
      }
   else if(strncmp(&timestring[i],"Feb",3) == 0)
      {
      strcpy(Smonth,"02");
      }
   else if(strncmp(&timestring[i],"Mar",3) == 0)
      {
      strcpy(Smonth,"03");
      }
   else if(strncmp(&timestring[i],"Apr",3) == 0)
      {
      strcpy(Smonth,"04");
      }
   else if(strncmp(&timestring[i],"May",3) == 0)
      {
      strcpy(Smonth,"05");
      }
   else if(strncmp(&timestring[i],"Jun",3) == 0)
      {
      strcpy(Smonth,"06");
      }
   else if(strncmp(&timestring[i],"Jul",3) == 0)
      {
      strcpy(Smonth,"07");
      }
   else if(strncmp(&timestring[i],"Aug",3) == 0)
      {
      strcpy(Smonth,"08");
      }
   else if(strncmp(&timestring[i],"Sep",3) == 0)
      {
      strcpy(Smonth,"09");
      }
   else if(strncmp(&timestring[i],"Oct",3) == 0)
      {
      strcpy(Smonth,"10");
      }
   else if(strncmp(&timestring[i],"Nov",3) == 0)
      {
      strcpy(Smonth,"11");
      }
   else
      {
      strcpy(Smonth,"12");
      }

   i += 4;
   j = 0;
   DayLimit = 0;
   while(timestring[i] != ' ')
      {
      Sday[j] = timestring[i];
      ++j;
      Sday[j] = '\0';
      DayLimit = DayLimit * 10 + (int) (timestring[i] - 48);
      ++i;
      }

   UPD_DATE_root = SRC_DATE_root = NULL;
   NNNroot = UNKroot = NULL;

   TDSmeta = 0;
   TDSm1 = TDSm2 = TDSm3 = TDSm4 = TDSm5 = TDSm6 = TDS_ARA = TDS_HGT = TDS_EQC = -1;
   EQCvalue[0] = '\0';
   if(ATTRTYPE_ANY_MGCP() > 0) /*** MGCP   **/
      {
      DoMetadataChecking = 1;
      MGCP_BldgCode = GetCodeIndex("AL015");
      if(ATTRTYPE_MGCP4() > 0)
         TDS_HGT = GetAttrIndex("HGT");
      }
   else if((ATTRTYPE_ANY_TDS() > 0) ||
                 (ATTRTYPE_ANY_GGDM() > 0)) /*** GGDM ***/
      {
         TDSmeta = 1;
      if((ATTRTYPE_TDS4() > 0) || (ATTRTYPE_GGDM21() > 0))
         {
         TDSm1 = GetCodeIndex("ZI041");
         TDSm2 = GetCodeIndex("ZI040");
         TDSm3 = GetCodeIndex("ZI031");
         }
      if((ATTRTYPE_GGDM22() > 0) || (ATTRTYPE_GGDM3() > 0) || (ATTRTYPE_TDS6() > 0))
         {
         TDSm3 = GetCodeIndex("ZI031");
         }
      if(ATTRTYPE_GGDM3() == 0)
         TDS_EQC = GetAttrIndex("EQC");
      TDS_HGT = GetAttrIndex("HGT");
      TDS_ARA = GetAttrIndex("ARA");

      }
   NumToCheck = (double) SACfull_x_2;
   NumToCheck /= 2.0;

   LLtoGeom = (int *) (malloc(SzI * ((int) NumToCheck)));

   namesize = strlen(indirectory) + 50;

   if(ATTRTYPE_TDS6() > 0)
      {
      ConflateSourceFiles = (char *) (malloc(namesize));
      sprintf(ConflateSourceFiles,"%s",GetFileNamefile());

      fileptr = fopen(ConflateSourceFiles,"rt");
      if(fileptr != NULL)
         {
         fgets(resultmessage,1999,fileptr);
         if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
           {
           sprintf(EACname,"%sinternal_data\\MarkersForAttributeStats.csv",indirectory);
           }
         else
           {
           sprintf(EACname,"%sinternal_data/MarkersForAttributeStats.csv",indirectory);
           }
         csv_errrpt = fopen(EACname,"wt");
         fprintf(csv_errrpt,"0=Off;1=On,Symbol,Source File Name\n");
         k = 0;
         while(feof(fileptr) == 0)
            {
            j = 0;
            while(resultmessage[j] != ',')
               ++j;
            ++j; /*** should now be on a space ***/
            ++j; /*** should now be on a digit 0 - 9 ***/
            while(resultmessage[j] != ' ')
               ++j;
            ++j;  /*** should now be on the first char of pathname to input source file ***/
            i = k % 4;
            switch(i)
               {
               case 0:
                  fprintf(csv_errrpt,"0,Triangle,%s",&resultmessage[j]);
                  break;
               case 1:
                  fprintf(csv_errrpt,"0,Star,%s",&resultmessage[j]);
                  break;
               case 2:
                  fprintf(csv_errrpt,"0,X,%s",&resultmessage[j]);
                  break;
               case 3:
                  fprintf(csv_errrpt,"0,Circle,%s",&resultmessage[j]);
                  break;
               }
            fgets(resultmessage,1999,fileptr);
            ++k;
            }
         fclose(fileptr);
         fclose(csv_errrpt);
         }
      }


   Iroot = NULL;
   j = (int) NumToCheck;
   Iroot = (struct indexlist *) (malloc(sizeof(struct indexlist) * (j + 2)));
   if(Iroot == NULL)
      {
      printf("available memory has been exhausted in preparations for attribute analysis\n");
      printf("failed in attempt to allocate %d bytes\n",(int) sizeof(struct indexlist) * (j + 2));
      exit(-1);
      }
   for(i=0; i<=j; i++)
      {
      Iroot[i].next = NULL;
      Iroot[i].msgid = -1;
      }
   Eroot = NULL;
   GIFD_Eroot = NULL;
   GIFD_Mroot = NULL;
   GIFD_MTroot = NULL;
   MGCP_VVT_root = NULL;
   VVTdomainRoot = NULL;
   TWay_Root = NULL;

   if((ATTRTYPE_ANY_TDS() > 0) || 
            (ATTRTYPE_ANY_GGDM() > 0)) 
      {
      InitializeNotEqualEnums();
      }
   else if(ATTRTYPE_SAC() > 0)  /** SAC **/

      {
      InitializeSAC_StructText();
      }


   Indices = NULL;

   AttrErrMsgID = 0; 

   NGAclassRoot = NULL;
   NGAmetaRoot = NULL;

   NUNANPOlower = 1073741824 * -2;
   NUNANPOupper = 1073741822 * -2;

   tlimit = 300;
   tlimittest = 290;

   titlechar = (char *) (malloc(tlimit));
   if(titlechar == NULL)
      {
       printf("all available memory has been used\n  processing cannot continue\n");
       exit(-1);
      }

   BadOTH.attrs = NULL;
   BadOTH.OTHvalue = NULL;


   i = ParseNGApicklist(GetDomainFile());
   if(i > 0)
      i = ReadNGAclass(GetComboFile(),1);

   UseNUNANPO = SetNUNANPO();

   HGT_code = GetAttrIndex(GetLongCode(LONG_ATTR_HGT));
   if(ATTRTYPE_NFDD() > 0)
      NAM_code = GetAttrIndex("NAM");
   else if(ATTRTYPE_SAC() == 0)
      NAM_code = GetAttrIndex(GetLongCode(LONG_ATTR_NAM));
   LEN_code = GetAttrIndex(GetLongCode(LONG_ATTR_LEN));
   if(ATTRTYPE_ANY_MGCP() > 0) /** no ZV2 code in MGCP ***/
      ZV2_code = -1;
   else if(ATTRTYPE_SAC() > 0) /** no ZV2 code in SAC ***/
      {
      ZV2_code = GetAttrIndex(GetLongCode(LONG_ATTR_ZV2));
      NAM_code = -1; /*** with SAC2.6, no NAM attr in spec ****/
      }
   else
      ZV2_code = GetAttrIndex(GetLongCode(LONG_ATTR_ZV2));
   if((ATTRTYPE_UFD2() > 0) || (ATTRTYPE_UFD1() > 0) || (ATTRTYPE_UFD3() > 0) ||
              (ATTRTYPE_MGCP4() > 0))
      ARA_code = -1;
   else
      ARA_code = GetAttrIndex(GetLongCode(LONG_ATTR_AREA));
   

   if(i == 0)
      {
      printf("could not find attribution analysis files \n");
      printf("no attribution analysis can be completed without the information provided in these file\n");
      return;
      }


   PSroot = NULL;
   if((ATTRTYPE_MGCP4() > 0) || (ATTRTYPE_TDS6() > 0))
      {
      portrayreport = fopen(portrayalfile,"wt");
      }
   else
      {
      portrayreport = NULL;
      }


   AE_TDS_NEroot = NULL;
   if(ATTRTYPE_ANY_TDS() > 0) /*** all TDS ***/
      {
      strcpy(resultmessage,GetTDS_NotExtracted_File());
      if(strcmp(resultmessage,"UNKNOWN") != 0)
         {
         if(BIN_ATTR_TYPE==1)
            {
            TDS_NE_SPEC = fopen(resultmessage,"rb");
            if(TDS_NE_SPEC != NULL)
               {
               fread(&wchar,1,1,TDS_NE_SPEC);
               j = (int) wchar;
               fread(&resultmessage[0],j,1,TDS_NE_SPEC);
               resultmessage[j] = '\0';
               fread(&GEOM,1,1,TDS_NE_SPEC);
               while(feof(TDS_NE_SPEC) == 0)
                  {
                  AE_TDS_NEc = (struct AE_NotExtracted *) (malloc(SzAE_NE));
                  if(AE_TDS_NEc != NULL)
                     {
                     AE_TDS_NEc->ecc = GetCodeIndex(resultmessage);
                     switch(GEOM)
                        {
                        case 'P':
                        case 'p':
                           AE_TDS_NEc->geom = 5;
                           break;
                        case 'A':
                        case 'a':
                        case 'S':
                        case 's':
                           AE_TDS_NEc->geom = 1;
                           break;
                        case 'L':
                        case 'l':
                        case 'C':
                        case 'c':
                           AE_TDS_NEc->geom = 4;
                           break;
                        default:
                           {
                           printf("unrecognized geometry code in TDS Not Extracted file - exiting now\n");
                           exit(-1);
                           }
                        }
                     AE_TDS_NEc->next = NULL;
                     if(AE_TDS_NEroot == NULL)
                        AE_TDS_NEroot = AE_TDS_NEc;
                     else
                        AE_TDS_NEp->next = AE_TDS_NEc;
                     AE_TDS_NEp = AE_TDS_NEc;
                     }

                  fread(&wchar,1,1,TDS_NE_SPEC);
                  j = (int) wchar;
                  if(j == 0)
                     {
                     break;
                     }
                  fread(&resultmessage[0],j,1,TDS_NE_SPEC);
                  resultmessage[j] = '\0';
                  fread(&GEOM,1,1,TDS_NE_SPEC);
                  }
               }
            }
         else
            {
            TDS_NE_SPEC = fopen(resultmessage,"rt");
            if(TDS_NE_SPEC != NULL)
               {
               fgets(resultmessage,999,TDS_NE_SPEC);
               while(feof(TDS_NE_SPEC) == 0)
                  {
                  AE_TDS_NEc = (struct AE_NotExtracted *) (malloc(SzAE_NE));
                  if(AE_TDS_NEc != NULL)
                     {
                     j = 0;
                     while((resultmessage[j] != ',') && (j < 9))
                        {
                        ++j;
                        }
                     if(resultmessage[j] == ',')
                        {
                        resultmessage[j] = '\0';
                        AE_TDS_NEc->ecc = GetCodeIndex(resultmessage);

                        ++j;
                        switch(resultmessage[j])
                           {
                           case 'P':
                           case 'p':
                              AE_TDS_NEc->geom = 5;
                              break;
                           case 'A':
                           case 'a':
                           case 'S':
                           case 's':
                              AE_TDS_NEc->geom = 1;
                              break;
                           case 'L':
                           case 'l':
                           case 'C':
                           case 'c':
                              AE_TDS_NEc->geom = 4;
                              break;
                           default:
                              {
                              printf("unrecognized geometry code in TDS Not Extracted file - exiting now\n");
                              exit(-1);
                              }
                           }
                        }

                     AE_TDS_NEc->next = NULL;
                     if(AE_TDS_NEroot == NULL)
                        AE_TDS_NEroot = AE_TDS_NEc;
                     else
                        AE_TDS_NEp->next = AE_TDS_NEc;
                     AE_TDS_NEp = AE_TDS_NEc;
                     }
                  fgets(resultmessage,999,TDS_NE_SPEC);
                  }
               }
            }

         fclose(TDS_NE_SPEC);
         }
      }


   fileptr = fopen(SACvaluesfile,"rb");
   SEEIT_fread_int(&ECC,fileptr);

   portrayfails = NULL;

   entryindex = -1;

   TDS_ZSAX_RX0_index = TDS_ZSAX_RX3_index = TDS_SAX_RY2_index = TDS_OTH_index = -12345;
   TDS_GE4_index = TDS_GE42_index = TDS_GE43_index = TDS_GE44_index = -12355;
   TDS_SAX_RY1_index = TDS_SAX_RX6_index = TDS_SAX_RX7_index = -123245;
   TDS_SAX_RX1_index = TDS_SAX_RX2_index = TDS_SAX_RX5_index = TDS_ZSAX_RX4_index = -12345;
   TDS_GE4_sentinel = TDS_GE4_3letter = TDS_GE4_17letter = 0;


   if(DoMetadataChecking > 0)
      {
      MGCP_Heliport_index = -1; 
      MGCP_Runway_index = -1; 
      MGCP_L_Aerodrome_index = -1; 
      MGCP_W_Aerodrome_index = -1;
      SRC_DATE_index = UPD_DATE_index = -1;
      if(ATTRTYPE_MGCP3() > 0) /*** MGCP V3   **/
         {
         Indices = (int *) (malloc(SzI * Num_MGCP_Meta));
         SetUp_MGCP_MetadataIndexArray(Indices);

         ReadVVTentries();
         MGCP_NAM_index = GetAttrIndex(GetLongCode(LONG_ATTR_NAM)); /** was GetAttrIndex("NAM");**/
         MGCP_NFN_index = GetAttrIndex("NFN");
         MGCP_NFI_index = GetAttrIndex("NFI");
         MGCP_DMT_index = GetAttrIndex("DMT");
         MGCP_DMB_index = GetAttrIndex("DMB");
         MGCP_CAA_index = GetAttrIndex("CAA");
         MGCP_IKO_index = GetAttrIndex("IKO");
         SRC_DATE_index = GetAttrIndex("SRC_DATE");
         UPD_DATE_index = GetAttrIndex("UPD_DATE");
         MGCP_Thicket_index = GetCodeIndex("EB020");
         MGCP_Wood_index = GetCodeIndex("EC030");  
         MGCP_UID_Indices_index = 11;
         }
      else if(ATTRTYPE_MGCP4() > 0) /*** MGCP  V4  **/
         {
         Indices = (int *) (malloc(SzI * Num_MGCP4_Meta));
         SetUp_MGCP_4_MetadataIndexArray(Indices);

         MGCP_NAM_index = GetAttrIndex(GetLongCode(LONG_ATTR_NAM)); /** was GetAttrIndex("NAM");**/
         MGCP_NFN_index = GetAttrIndex("NFN");
         MGCP_NFI_index = GetAttrIndex("NFI");
         MGCP_DMT_index = GetAttrIndex("DMT");
         MGCP_DMB_index = GetAttrIndex("DMB");
         MGCP_CAA_index = GetAttrIndex("CAA");
         MGCP_IKO_index = GetAttrIndex("IKO");
         SRC_DATE_index = GetAttrIndex("SDV");
         MGCP_Thicket_index = GetCodeIndex("EB020");
         MGCP_Wood_index = GetCodeIndex("EC030");
         MGCP_Heliport_index = GetCodeIndex("GB035");
         MGCP_Runway_index = GetCodeIndex("GB005");
         MGCP_L_Aerodrome_index = GetCodeIndex("GB055");
         MGCP_W_Aerodrome_index =  GetCodeIndex("GB065");
         MGCP_UID_Indices_index = 6;

         ReadPortrayalAttrs();
         if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
           {
           sprintf(resultmessage,"%sinternal_data\\PortrayFailures.bin",indirectory);
           }
         else
           {
           sprintf(resultmessage,"%sinternal_data/PortrayFailures.bin",indirectory);
           }
         portrayfails = fopen(resultmessage,"wb");
         }

      else if(ATTRTYPE_UFD1() > 0) /*** UFD1   **/
         {
         Indices = (int *) (malloc(SzI * NumMeta));
         SetUp_D4_MetadataIndexArray(Indices);
         SRC_DATE_index = GetAttrIndex("ORIG_SOURCE_DATE");
         UPD_DATE_index = GetAttrIndex("UPDATE_SOURCE_DATE");

         ReadVVTentries();
         }
      else if(ATTRTYPE_TDS4() > 0)
         {
         TDS_OTH_index = GetAttrIndex("OTH");
         Indices = NULL;
         ReadVVTentries();
         ReadVVT3WayEntries();
         }
      else if(ATTRTYPE_TDS6() > 0)
         {
         TDS_OTH_index = GetAttrIndex("OTH");
         TDS_GE4_index = GetAttrIndex("ZI020_GE4");
         TDS_GE42_index = GetAttrIndex("ZI020_GE42");
         TDS_GE43_index = GetAttrIndex("ZI020_GE43");
         TDS_GE44_index = GetAttrIndex("ZI020_GE44");
         TDS_SAX_RY2_index = GetAttrIndex("SAX_RY2");
         TDS_ZSAX_RX3_index = GetAttrIndex("ZSAX_RX3");
         TDS_ZSAX_RX0_index = GetAttrIndex("ZSAX_RX0");
         TDS_SAX_RY1_index = GetAttrIndex("SAX_RY1");
         TDS_SAX_RX1_index = GetAttrIndex("SAX_RX1");
         TDS_SAX_RX2_index = GetAttrIndex("SAX_RX2");
         TDS_SAX_RX5_index = GetAttrIndex("SAX_RX5");
         TDS_SAX_RX7_index = GetAttrIndex("SAX_RX7");
         TDS_SAX_RX6_index = GetAttrIndex("SAX_RX6");
         TDS_ZSAX_RX4_index = GetAttrIndex("ZSAX_RX4");

         MGCP_NAM_index = GetAttrIndex(GetLongCode(LONG_ATTR_NAM)); /** was GetAttrIndex("NAM");**/
         MGCP_NFN_index = GetAttrIndex("ZI005_NFN");

         SRC_DATE_index = GetAttrIndex("ZI001_SDV");
         UPD_DATE_index = GetAttrIndex("ZI001_VSD");

         TDS_URI_index = GetAttrIndex("URI");
         TDS_MDE_index = GetAttrIndex("MDE");
         TDS_SAX_RS4_index = GetAttrIndex("SAX_RS4");
         TDS_SAX_RS3_index = GetAttrIndex("SAX_RS3");
         TDS_RIDL_index = GetAttrIndex("GB052_RIDL");
         TDS_RIDH_index = GetAttrIndex("GB052_RIDH");
         TDS_SSE_index = GetAttrIndex("SSE");
         TDS_IKO_index = GetAttrIndex("IKO");
         TDS_PSE_index = GetAttrIndex("PSE");
         TDS_VOI_index = GetAttrIndex("VOI");
         TDS_BEN_index = GetAttrIndex("BEN");

         ReadPortrayalAttrs();
         if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
           {
           sprintf(resultmessage,"%sinternal_data\\PortrayFailures.bin",indirectory);
           }
         else
           {
           sprintf(resultmessage,"%sinternal_data/PortrayFailures.bin",indirectory);
           }
         portrayfails = fopen(resultmessage,"wb");

         Indices = NULL;
         ReadVVTentries();
         }
      else if(ATTRTYPE_ANY_GGDM() > 0) /** GGDM ***/
         {
         if(ATTRTYPE_GGDM3() > 0)
            {
            TDS_SAX_RY2_index = GetAttrIndex("SAX_RY2");
            TDS_ZSAX_RX3_index = GetAttrIndex("ZSAX_RX3");
            TDS_ZSAX_RX0_index = GetAttrIndex("ZSAX_RX0");
            TDS_SAX_RY1_index = GetAttrIndex("SAX_RY1");
            TDS_SAX_RX1_index = GetAttrIndex("SAX_RX1");
            TDS_SAX_RX2_index = GetAttrIndex("SAX_RX2");
            TDS_SAX_RX5_index = GetAttrIndex("SAX_RX5");
            TDS_SAX_RX7_index = GetAttrIndex("SAX_RX7");
            TDS_SAX_RX6_index = GetAttrIndex("SAX_RX6");
            TDS_ZSAX_RX4_index = GetAttrIndex("ZSAX_RX4");
            SRC_DATE_index = GetAttrIndex("ZI001_SDV");
            UPD_DATE_index = GetAttrIndex("ZI001_VSD");
            TDS_URI_index = GetAttrIndex("URI");
            TDS_MDE_index = GetAttrIndex("MDE");
            TDS_SAX_RS4_index = GetAttrIndex("SAX_RS4");
            TDS_RIDL_index = GetAttrIndex("GB052_RIDL");
            TDS_RIDH_index = GetAttrIndex("GB052_RIDH");
            TDS_SSE_index = GetAttrIndex("SSE");
            TDS_IKO_index = GetAttrIndex("IKO");
            TDS_PSE_index = GetAttrIndex("PSE");
            TDS_VOI_index = GetAttrIndex("VOI");
            TDS_BEN_index = GetAttrIndex("BEN");

            GGDM_HSE_index = GetAttrIndex("HSE");
            GGDM_SAX_RS6_index = GetAttrIndex("SAX_RS6");
            GGDM_BRR_index = GetAttrIndex("BRR");
            GGDM_MLR_index = GetAttrIndex("MLR");
            GGDM_ZI103_MVD_index = GetAttrIndex("ZI103_MVD");
            GGDM_ZI001_VSD_index = GetAttrIndex("ZI001_VSD");
            GGDM_PRVR_index = GetAttrIndex("PRVR");
            GGDM_SCVN_index = GetAttrIndex("SCVN");
            GGDM_BC040_MLR_index = GetAttrIndex("BC040_MLR");
            GGDM_BC040_COL_index = GetAttrIndex("BC040_COL");
            GGDM_COL_index = GetAttrIndex("COL");
            GGDM_DIA_index = GetAttrIndex("DIA");
            GGDM_CNCP_index = GetAttrIndex("CNCP");
            GGDM_FUFI_index = GetAttrIndex("FUFI");
            GGDM_FURL_index = GetAttrIndex("FURL");
            GGDM_ZI039S_UFI_index = GetAttrIndex("ZI039S_UFI");
            GGDM_ZI031S_URI_index = GetAttrIndex("ZI031S_URI");
            }
         TDS_OTH_index = GetAttrIndex("OTH");
         Indices = NULL;
         ReadVVTentries();
         }
      else if((ATTRTYPE_D4() > 0) || /*** D4  ****/
              (ATTRTYPE_FACC() > 0) || /*** FACC ****/
              (ATTRTYPE_VMAP() > 0) || /*** VMAP ****/
              (ATTRTYPE_UFD2() > 0) || /*** UFD2 ****/
              (ATTRTYPE_UFD3() > 0)) /*** UFD3 ****/
         {
         Indices = (int *) (malloc(SzI * NumMeta));
         SetUp_D4_MetadataIndexArray(Indices);
         SRC_DATE_index = GetAttrIndex("ORIG_SOURCE_DATE");
         UPD_DATE_index = GetAttrIndex("UPDATE_SOURCE_DATE");

         }
      else if((ATTRTYPE_NFDD() > 0) || (ATTRTYPE_DFDD() > 0))
         {
         Indices = NULL;
         if(ATTRINSTYPE == 4)
            ReadVVTentries();
         if(ATTRTYPE_NFDD() > 0)
            {
            SRC_DATE_index = GetAttrIndex("SDV");
            UPD_DATE_index = GetAttrIndex("VSD");
            }
         }
      else if(ATTRTYPE_SAC() > 0) /*** Stereo Airfield, SAC ***/
         {
         Indices = (int *) (malloc(SzI * Num_SAC_Meta));
         SetUp_SAC_MetadataIndexArray(Indices);
         }
      }

   while(feof(fileptr) == 0)
      {
      if((DoMetadataChecking > 0) && (NGAmetaRoot != NULL))
         {
         ngameta = NGAmetaRoot;
         Ameta = ngameta->attr;
         while(Ameta != NULL)
            {
            Ameta->present = 'N';
            if(Ameta->strval != NULL)
               {
               free(Ameta->strval);
               Ameta->strval = NULL;
               }
            Ameta = Ameta->next;
            }
         }
      SEEIT_fread_int(&seeitgeom,fileptr);
    
      SEEIT_fread_int(&NumAttr,fileptr);

      if(ECC == 0)
         {
         for(k=1; k<=NumAttr; k++)
            {
            SEEIT_fread_int(&EAC,fileptr);
            if(EAC >= 0)
               {
               SEEIT_fread_int(&uom,fileptr);
               SEEIT_fread_int(&uomscale,fileptr);
               SEEIT_fread_int(&SEDRIStype,fileptr);
               SEEIT_fread_int(&datatype,fileptr);
               switch(datatype)
                  {
                  case 0: /** regular integer **/
                     SEEIT_fread_int(&Idtvalue,fileptr);
                     break;
                  case 1: /** a double **/
                     SEEIT_fread_double(&Fdtvalue,fileptr);
                     break;
                  case 2: /** a string **/
                     SEEIT_fread_int(&numchar,fileptr);
                     if(numchar >= tlimittest)
                        {
                        tlimit = numchar + 5;
                        tlimittest = tlimit - 10;
                        titlechar = (char *) (realloc(titlechar,tlimit));
                        if(titlechar == NULL)
                           {
                            printf("all available memory has been used\n  processing cannot continue\n");
                            exit(-1);
                           }
                        }

                     for(i=0; i<numchar; i++)
                        {
                        fread(&titlechar[i],1,1,fileptr);
                        }
                      titlechar[i] = '\0';
                     break;
                  case 3: /** enum as int **/
                     SEEIT_fread_int(&enumcode,fileptr);
                     break;
                  case 4: /** metadata as int - stored & treated as an enum in spec file**/
                     SEEIT_fread_int(&MDcode,fileptr);
                     break;
                  }
               }
            else  /** EAC of -1, -2 indicates LOD name, Assgd model name, or poly flag string, respectively **/
               {
               SEEIT_fread_int(&numchar,fileptr);
               for(j=0; j<numchar; j++)
                  fread(&tshapefile[j],1,1,fileptr);
               tshapefile[j] = '\0';
               if(EAC != -3)
                  {
                  j = 0; /*** move forward to the first blank ***/
                  while(j < numchar)
                     {
                     if(tshapefile[j] == ' ')
                        break;
                     ++j;
                     }
                  ++j; /*** move forward to the second blank character  **/
                  while(j < numchar)
                     {
                     if(tshapefile[j] == ' ')
                        break;
                     ++j;
                     }
                  ++j;
                  strcpy(shapefile,&tshapefile[j]);  /*** rest of tshapefile should be the layer identifier/name ***/
                  }
               }
            } /** end for number of attributes **/


         SEEIT_fread_int(&ECC,fileptr);

         continue;
         }


      ngac = NGAclassRoot;
      BadFcodeGeomPair = 0;

      while(ngac != NULL)
         {
         if(ngac->codeindex == ECC)
            {
            if((ngac->geom < 0) || (ngac->geom == seeitgeom) || (ngac->geom == 0)) /** == 0 signals a metadata (geom independent) attribute ***/
               break;
            }
         ngac = ngac->next;
         }
      if(ngac == NULL)
         {
ngac = NGAclassRoot;
while(ngac != NULL)
{
if(ngac->codeindex == ECC)
   break;
ngac = ngac->next;
}
BadFcodeGeomPair = 1;
         }
      if(ngac == NULL)
         {
         strcpy(ngaNoRecord->name,GetECCLabel(ECC));
         ngaNoRecord->codeindex = ECC;
         ngac = ngaNoRecord;
         }

      ngac->present = 'Y';
      Ac = ngac->attr;
      while(Ac != NULL)
         {
         Ac->present = 'N';
         Ac = Ac->next;
         }

      ++entryindex;  /** a new ECC record ***/

      LLtoGeom[entryindex] = seeitgeom;


      ZeroMGCP_VVT(ECC, seeitgeom);
      MGCP_NAM_str[0] = '\0';
      MGCP_NFN_str[0] = '\0';
      MGCP_NFI_str[0] = '\0';
      MGCP_CAA_str[0] = '\0';


      NE_FcodeGeomPair = 0;
      AE_TDS_NEc = AE_TDS_NEroot;
      while(AE_TDS_NEc != NULL)
         {
         if((AE_TDS_NEc->ecc == ECC) && (AE_TDS_NEc->geom == seeitgeom))
            {
            NE_FcodeGeomPair = 1;
            break;
            }
         AE_TDS_NEc = AE_TDS_NEc->next;
         }

      for(k=1; k<=NumAttr; k++)
         {
         SEEIT_fread_int(&EAC,fileptr);
if(EAC > TTF_MaximumEACcount)
{
printf("EAC read %d\n",EAC);
printf("uom %d uomscale %d SEDRIStype %d datatype %d\n",uom,uomscale,SEDRIStype,datatype);
exit(-1);
}
else if(feof(fileptr) != 0)
{
printf("premature end of file\n");
exit(-1);
}

         if(EAC >= 0)
            {
            if(BadFcodeGeomPair > 0)
               {
               ngac = NULL;
               Ac = NULL;

               if((DoMetadataChecking > 0) && (NGAmetaRoot != NULL))  /** see if have a fit with metadata ***/
                  {
                  ngameta = NGAmetaRoot;
                  Ameta = ngameta->attr;
                  while(Ameta != NULL)
                     {
                     if(Ameta->codeindex == EAC)
                        break;
                     Ameta = Ameta->next;
                     }
                  if(Ameta != NULL)
                     Ameta->present = 'Y';
                  }
               else
                  Ameta = NULL;

               }
            if((ngac != NULL) && (BadFcodeGeomPair == 0))
               {

               Ac = ngac->attr;
               while(Ac != NULL)
                  {
                  if(Ac->codeindex == EAC)
                     break;
                  Ac = Ac->next;
                  }
               
               if((Ac == NULL) && (DoMetadataChecking > 0) && (NGAmetaRoot != NULL))  /** see if have a fit with metadata ***/
                  {
                  ngameta = NGAmetaRoot;
                  Ameta = ngameta->attr;
                  while(Ameta != NULL)
                     {
                     if(Ameta->codeindex == EAC)
                        break;
                     Ameta = Ameta->next;
                     }
                  if(Ameta != NULL)
                     Ameta->present = 'Y';
                  }
               else if(Ac != NULL)
                  {
                  Ameta = NULL;
                  Ac->present = 'Y';
                  }
               else
                  {
                  Ameta = NULL;
                  }
               } /*** end if ngac != NULL ****/

            SEEIT_fread_int(&uom,fileptr);
            SEEIT_fread_int(&uomscale,fileptr);
            SEEIT_fread_int(&SEDRIStype,fileptr);
            SEEIT_fread_int(&datatype,fileptr);

             if(Ameta == NULL)
                {
                if((ngac != NULL) && (Ac == NULL) && (seeitgeom != C_GRID))
                  {
                  if((DoMetadataChecking == 0) && (NGAmetaRoot != NULL))
                     {
                     Tmeta = NGAmetaRoot->attr;
                     while(Tmeta != NULL)
                        {
                        if(Tmeta->codeindex == EAC)
                           break;
                        Tmeta = Tmeta->next;
                        }
                     }
                  else
                     Tmeta = NULL;

                  if(Tmeta == NULL)
                     {
                     if((ECC == TDSm1) || (ECC == TDSm2) || (ECC == TDSm3) || (ECC == TDSm4) || (ECC == TDSm5) || (ECC == TDSm6))
                        {
                        sprintf(resultmessage,"Layer Identifier %s: Feature %s (%s): Attribute %s (%s): attribute is not designated for use with this feature\n",
                             shapefile,GetECCCode(ECC),
                        GetECCLabel(ECC),GetEACCode(EAC),GetEACLabel(EAC));
                        InsertIntoGIFD_MetaData_ErrorList(resultmessage,entryindex);
                        }
                     else if(PrintSchemaCodes > 0)
                        {
                        sprintf(resultmessage,"1%s Layer Identifier %s: Feature %s %s\n   Assigned Attribute %s %s\n",
                             ParseGAITgeometry((unsigned char) seeitgeom, 2), shapefile,GetECCCode(ECC),
                        GetECCLabel(ECC),GetEACCode(EAC),GetEACLabel(EAC));
                        InsertIntoGIFD_AttrErrorList(resultmessage,entryindex);

                        sprintf(resultmessage,"1Assigned Attribute: %s (%s)\n", GetEACCode(EAC),GetEACLabel(EAC));
                        useid = InsertIntoAttrErrorList(resultmessage,entryindex);
                        InsertIntoAttrIndexList(entryindex,useid);

                        sprintf(resultmessage,"1|%s|%s|%s|%d %d %d",GetECCCode(ECC),GetECCLabel(ECC),GetEACLabel(EAC),ECC,EAC,seeitgeom);
                        InsertIntoSummary_AttrErrorList(resultmessage,entryindex);

if(EAC < 10)
   sprintf(resultmessage,"5 000%d",EAC);
else if(EAC < 100)
   sprintf(resultmessage,"5 00%d",EAC);
else if(EAC < 1000)
   sprintf(resultmessage,"5 0%d",EAC);
else
   sprintf(resultmessage,"5 %d",EAC);
                        InsertIntoSummary_AttrErrorList(resultmessage,entryindex);
                        }
                     else
                        {
                        sprintf(resultmessage,"1%s Layer Identifier %s: Feature %s\n   Assigned Attribute %s\n",
                             ParseGAITgeometry((unsigned char) seeitgeom, 2), shapefile,GetECCLabel(ECC),GetEACLabel(EAC));
                        InsertIntoGIFD_AttrErrorList(resultmessage,entryindex);

                        sprintf(resultmessage,"1Assigned Attribute - %s\n", GetEACLabel(EAC));
                        useid = InsertIntoAttrErrorList(resultmessage,entryindex);
                        InsertIntoAttrIndexList(entryindex,useid);

                        sprintf(resultmessage,"1|%s|%s|%s|%d %d %d",GetECCCode(ECC),GetECCLabel(ECC),GetEACLabel(EAC),ECC,EAC,seeitgeom);
                        InsertIntoSummary_AttrErrorList(resultmessage,entryindex);

if(EAC < 10)
   sprintf(resultmessage,"5 000%d",EAC);
else if(EAC < 100)
   sprintf(resultmessage,"5 00%d",EAC);
else if(EAC < 1000)
   sprintf(resultmessage,"5 0%d",EAC);
else
   sprintf(resultmessage,"5 %d",EAC);
                        InsertIntoSummary_AttrErrorList(resultmessage,entryindex);
                        }
                     }
                  }
               }
else if(Ac == NULL)
Ac = Ameta;


if(Ameta != NULL)
{
Ameta->DT_as_read = datatype;
}

            switch(datatype)
               {
               case 0: /** regular integer **/
                  SEEIT_fread_int(&Idtvalue,fileptr);
                  if(Ameta != NULL)
                     {
                     Ameta->intval = Idtvalue;
                     Ameta->floatval = (double) Idtvalue;
                     Ameta->strval = (char *)(malloc(50));
                     sprintf(Ameta->strval,"%d",Idtvalue);
                     }
                  WriteTheError = 1;

                  if(IsJunkValue(datatype,Idtvalue,-1312452,NULL,-1312452,NULL) > 0)
                     {
                     sprintf(resultmessage,"w|%s|%d|%d|%d|%d",GetEACCode(EAC),EAC,Idtvalue,ECC,seeitgeom);
                     InsertIntoSummary_AttrErrorList(resultmessage,entryindex);
                     }

                  if((ATTRTYPE_MGCP3() > 0) || (ATTRTYPE_UFD1() > 0))  /*** MGCP3, UFD1 ***/
                     {
                     sprintf(resultmessage,"%.1lf",(double) Idtvalue);
                     AddToVVTcounts(ECC, seeitgeom, EAC, resultmessage,shapefile, -999999.0, -999);
                     }
                  else if(ATTRTYPE_MGCP4() > 0)
                     {
                     sprintf(resultmessage,"%d",Idtvalue);
                     CapturePortrayRuleValue(ECC,seeitgeom,EAC,resultmessage);
                     }
                  else if((ATTRTYPE_ANY_TDS() > 0) || /*** ?TDS schema ***/
                          (ATTRTYPE_ANY_GGDM() > 0)) /** GGDM ***/
                     { 
                     sprintf(resultmessage,"%.1lf",(double) Idtvalue);
                     if(ATTRTYPE_TDS6() > 0)
                        {
                        CapturePortrayRuleValue(ECC,seeitgeom,EAC,resultmessage);
                        }

                     AddToVVTcounts(ECC, seeitgeom, EAC, resultmessage,shapefile, -999999.0, -999);

                     }
                  else if((ATTRTYPE_NFDD() > 0) || (ATTRTYPE_DFDD() > 0))
                     { /*** for NFDD and DFDD ****/
                     if(ATTRINSTYPE == 4)
                        {
                        sprintf(resultmessage,"%.1lf",(double) Idtvalue);
                        AddToVVTcounts(ECC, seeitgeom, EAC, resultmessage,shapefile, -999999.0, -999);
                        }
                     }

                  if(ATTRTYPE_SAC() > 0) /*** SAC ***/
                     {
                     AddToSACconversions(EAC, ((double) Idtvalue));
                     }


                  if((Ac != NULL) && (seeitgeom != C_GRID) && (ATTRTYPE_MGCP3() > 0)) /*** only for MGCP V3 **/
                     {
                     Atemp = NGAmetaRoot->attr;
                     while(Atemp != NULL)
                        {
                        if(Atemp->codeindex == EAC)
                           break;
                        Atemp = Atemp->next;
                        }
                     if((Atemp != NULL) || (Ac->OptReq == 'M') || (Ac->OptReq == 'R'))
                        {
                        if(Idtvalue == -32768)  /*** have a NULL value on MGCP reqired attribute ****/
                           {
                           WriteTheError = 0;
                           if((ECC == TDSm1) || (ECC == TDSm2) || (ECC == TDSm3) || (ECC == TDSm4) || (ECC == TDSm5) || (ECC == TDSm6))
                              {
                              sprintf(resultmessage,"Layer Identifier %s: Feature %s (%s): Attribute %s (%s): Required attribute with Null value (%d) assigned\n",
                                shapefile, GetECCCode(ECC),GetECCLabel(ECC),
                               GetEACCode(EAC),GetEACLabel(EAC),Idtvalue);
                              InsertIntoGIFD_MetaData_ErrorList(resultmessage,entryindex);
                              }
                           else if(PrintSchemaCodes > 0)
                              {
          sprintf(resultmessage,"2%s Layer Identifier %s: Feature %s %s\n   Attribute: %s %s  Required attribute with Null value (%d) assigned\n",
                                ParseGAITgeometry((unsigned char) seeitgeom, 2),shapefile, GetECCCode(ECC),GetECCLabel(ECC),
                               GetEACCode(EAC),GetEACLabel(EAC),Idtvalue);
                              InsertIntoGIFD_AttrErrorList(resultmessage,entryindex);

sprintf(resultmessage,"2Attribute: %s (%s) (Null value (%d) assigned to required attribute)\n", GetEACCode(EAC),GetEACLabel(EAC),Idtvalue);
useid = InsertIntoAttrErrorList(resultmessage,entryindex);
InsertIntoAttrIndexList(entryindex,useid);

                              sprintf(resultmessage,"2|%s|%d %d",
                                   GetEACLabel(EAC),ECC,EAC);
                              InsertIntoSummary_AttrErrorList(resultmessage,entryindex);
      
                              sprintf(resultmessage,"6 %d", EAC);
                              InsertIntoSummary_AttrErrorList(resultmessage,entryindex);
                              }
                           else
                              {
         sprintf(resultmessage,"2%s Layer Identifier %s: Feature %s\n   Attribute %s  Required attribute with Null value (%d) assigned\n",
                                      ParseGAITgeometry((unsigned char) seeitgeom, 2),shapefile, GetECCLabel(ECC),GetEACLabel(EAC),Idtvalue);
                              InsertIntoGIFD_AttrErrorList(resultmessage,entryindex);

sprintf(resultmessage,"2Attribute: %s (Null value assigned to required attribute)\n", GetEACCode(EAC));
useid = InsertIntoAttrErrorList(resultmessage,entryindex);
InsertIntoAttrIndexList(entryindex,useid);

                              sprintf(resultmessage,"2|%s|%d %d",
                                   GetEACLabel(EAC),ECC,EAC);
                              InsertIntoSummary_AttrErrorList(resultmessage,entryindex);

                              sprintf(resultmessage,"6 %d", EAC);
                              InsertIntoSummary_AttrErrorList(resultmessage,entryindex);
                              }
                           }
                        }
                     }

                  if((WriteTheError > 0) && (Ac != NULL) && ((Ac->MinValPresent > 0) || (Ac->MaxValPresent > 0)) &&(seeitgeom != C_GRID))
                     {
                     WriteTheError = 1;
                     if(UseNUNANPO > 0)
                        {
                        if((Idtvalue >= -32768) && (Idtvalue <= -32764))
                           WriteTheError = 0;
                        }
                     else if(ATTRTYPE_ANY_MGCP() > 0) /*** MGCP  3 and 4  **/
                        {
                        if((0 >= Ac->minval) && (0 < Ac->maxval))
                           {
                           if((Idtvalue == -32768) || (Idtvalue == -32767) || (Idtvalue == -32765) || (Idtvalue == -32764))
                              WriteTheError = 0;
                           }
                        }
                     else if((ATTRTYPE_ANY_TDS() > 0)  ||
                                        (ATTRTYPE_ANY_GGDM() > 0)) /** GGDM ***/
                        {
                        if(Idtvalue == -999999)
                           WriteTheError = 0;
                        }

                     else if(ATTRTYPE_SAC() > 0) /*** sac ****/
                        {
                        sprintf(DoubleAsString,"%.1lf",(double) Idtvalue);
                        strcpy(resultmessage,ParseGAITgeometry((unsigned char) seeitgeom, 0));

                        if(IsNUNANPO_OK_for_SAC(GetECCCode(ECC), GetEACCode(EAC), resultmessage[0], DoubleAsString) > 0)
                           WriteTheError = 0;
                        }
                     if(WriteTheError > 0)
                        {
                        unusedint = 0;
                        if((Ac->MinValPresent > 0) && (Ac->MinOpen == 0) && (Idtvalue < Ac->minval))
                           unusedint = 1;
                        else if((Ac->MinValPresent > 0) && (Ac->MinOpen == 1) && (Idtvalue <= Ac->minval))
                           unusedint = 1;
                        if((Ac->MaxValPresent > 0) && (Ac->MaxOpen == 0) && (Idtvalue > Ac->maxval))
                           unusedint = 1;
                        else if((Ac->MaxValPresent > 0) && (Ac->MaxOpen == 1) && (Idtvalue >= Ac->maxval))
                           unusedint = 1;
                        WriteTheError = unusedint;
                        }

                     if(WriteTheError > 0)
                        {
                        pc = NULL;
                        if((Ac->codeDomain != NULL) && (Ac->codeDomain[0] == 'A') && (Ac->codeDomain[1] == 'D'))
                           {
                           pc = Ac->picks;
                           sprintf(enumcodestring,"%d",Idtvalue);
                           while(pc != NULL)
                              {
                              if(strcmp(enumcodestring,pc->code) == 0)
                                 break;
 
                              pc = pc->next;
                              }
                           }
                        if(pc == NULL)
                           {
                           strcpy(MinString,"(Unbounded)");
                           strcpy(MaxString,"(Unbounded)");
                           if(Ac->MinValPresent > 0)
                              {
                              if(Ac->MinOpen == 1)
                                 sprintf(MinString,">%d",(int) (Ac->minval));
                              else
                                 sprintf(MinString,">=%d",(int) (Ac->minval));
                              }
                           if(Ac->MaxValPresent > 0)
                              {
                              if(Ac->MaxOpen == 1)
                                 sprintf(MaxString,"<%d", (int) (Ac->maxval));
                              else
                                 sprintf(MaxString,"<=%d",(int) (Ac->maxval));
                              }
                           if((ECC == TDSm1) || (ECC == TDSm2) || (ECC == TDSm3) || (ECC == TDSm4) || (ECC == TDSm5) || (ECC == TDSm6))
                              {
                               sprintf(resultmessage,"Layer Identifier %s: Feature %s (%s): Attribute %s (%s): Value: %d (expected range %s to %s)\n",
                               shapefile,GetECCCode(ECC),
                               GetECCLabel(ECC),GetEACCode(EAC),GetEACLabel(EAC),Idtvalue, MinString,MaxString);

                              InsertIntoGIFD_MetaData_ErrorList(resultmessage,entryindex);
                              }
                           else if(PrintSchemaCodes > 0)
                              {
                              sprintf(resultmessage,"3%s Layer Identifier %s: Feature %s: %s\n   Attribute %s %s\n     Value: %d (expected range %s to %s)\n",
                               ParseGAITgeometry((unsigned char) seeitgeom, 2),shapefile,GetECCCode(ECC),
                               GetECCLabel(ECC),GetEACCode(EAC),GetEACLabel(EAC),Idtvalue, MinString,MaxString);
                               InsertIntoGIFD_AttrErrorList(resultmessage,entryindex);

                               sprintf(resultmessage,"3Value of attribute %s (%s): %d (expected range %s to %s)\n", 
                                   GetEACCode(EAC),GetEACLabel(EAC),Idtvalue, MinString,MaxString);
                               useid = InsertIntoAttrErrorList(resultmessage,entryindex);
                               InsertIntoAttrIndexList(entryindex,useid);

                               sprintf(resultmessage,"3|%s|%s|%lf %d %d %d %d",
                                   GetEACCode(EAC),GetEACLabel(EAC),(double) Idtvalue,(int) (Ac->minval),(int) (Ac->maxval),ECC,EAC);
                               InsertIntoSummary_AttrErrorList(resultmessage,entryindex);

                               sprintf(resultmessage,"7 %d", EAC);
                               InsertIntoSummary_AttrErrorList(resultmessage,entryindex);
                               }
                            else
                              {
                              sprintf(resultmessage,"3%s Layer Identifier %s: Feature %s:\n   Attribute: %s\n     Value: %d (expected range %s to %s)\n",
                               ParseGAITgeometry((unsigned char) seeitgeom, 2),shapefile,
                               GetECCLabel(ECC),GetEACLabel(EAC),Idtvalue, MinString,MaxString);
                               InsertIntoGIFD_AttrErrorList(resultmessage,entryindex);

                               sprintf(resultmessage,"3Value of attribute %s: %d (expected range %s to %s)\n",
                                   GetEACLabel(EAC),Idtvalue, MinString,MaxString);
                               useid = InsertIntoAttrErrorList(resultmessage,entryindex);
                               InsertIntoAttrIndexList(entryindex,useid);

                               sprintf(resultmessage,"3|%s|%s|%lf %d %d %d %d",
                                   GetEACCode(EAC),GetEACLabel(EAC),(double) Idtvalue,(int) (Ac->minval),(int) (Ac->maxval),ECC,EAC);
                               InsertIntoSummary_AttrErrorList(resultmessage,entryindex);

                               sprintf(resultmessage,"7 %d", EAC);
                               InsertIntoSummary_AttrErrorList(resultmessage,entryindex);
                               }
                            }
                        }
                     }
                  break;
               case 1: /** a double **/
                  SEEIT_fread_double(&Fdtvalue,fileptr);
                  if(Ameta != NULL)
                     {
                     Ameta->floatval = Fdtvalue;
                     Ameta->intval = (int) Fdtvalue;
                     Ameta->strval = (char *)(malloc(50));
                     sprintf(Ameta->strval,"%lf",Fdtvalue);
                     }
                  WriteTheError = 1;
                  if(IsJunkValue(datatype,-1312452,Fdtvalue,NULL,-1312452,NULL) > 0)
                     {
                     sprintf(resultmessage,"w|%s|%d|%lf|%d|%d",GetEACCode(EAC),EAC,Fdtvalue,ECC,seeitgeom);
                     InsertIntoSummary_AttrErrorList(resultmessage,entryindex);
                     }

                  if((ATTRTYPE_MGCP3() > 0) || (ATTRTYPE_UFD1() > 0))  /*** MGCP3, UFD1 ***/
                     {
                     unusedint = (int) Fdtvalue;
                     unuseddbl = (double) unusedint;
                     if(unuseddbl == Fdtvalue)
                        sprintf(resultmessage,"%.1lf",Fdtvalue);
                     else
                        sprintf(resultmessage,"%.7lf",Fdtvalue);
                     AddToVVTcounts(ECC, seeitgeom, EAC, resultmessage,shapefile, -999999.0, -999);
                     }
                  else if(ATTRTYPE_MGCP4() > 0)
                     {
                     sprintf(resultmessage,"%.1lf",Fdtvalue);
                     CapturePortrayRuleValue(ECC,seeitgeom,EAC,resultmessage);
                     }
                  else if((ATTRTYPE_ANY_TDS() > 0)  ||/*** ?TDS schema ***/
                            (ATTRTYPE_ANY_GGDM() > 0)) /** GGDM ***/
                     { 
                     sprintf(resultmessage,"%.1lf",Fdtvalue);
                     if(ATTRTYPE_TDS6() > 0)
                        {
                        CapturePortrayRuleValue(ECC,seeitgeom,EAC,resultmessage);
                        }
                     AddToVVTcounts(ECC, seeitgeom, EAC, resultmessage,shapefile, -999999.0, -999);
                     IncludeIntervalValues(EAC,Fdtvalue,"\0");
                     }
                  else if((ATTRTYPE_NFDD() > 0) || (ATTRTYPE_DFDD() > 0))
                     { /*** for NFDD and DFDD ****/
                     if(ATTRINSTYPE == 4)
                        {
                        sprintf(resultmessage,"%.1lf",(double) Fdtvalue);
                        AddToVVTcounts(ECC, seeitgeom, EAC, resultmessage,shapefile, -999999.0, -999);
                        }
                     }

                  if(ATTRTYPE_SAC() > 0) /*** SAC ***/
                     {
                     AddToSACconversions(EAC, Fdtvalue);
                     }


                  if((Ac != NULL) && (seeitgeom != C_GRID) && (ATTRTYPE_ANY_MGCP() > 0)) /*** MGCP   **/
                     {
                     Atemp = NGAmetaRoot->attr;
                     while(Atemp != NULL)
                        {
                        if(Atemp->codeindex == EAC)
                           break;
                        Atemp = Atemp->next;
                        }
                     CheckIt = 0;
                     if(Atemp != NULL) /** we are looking at a metadata attribute ***/
                        CheckIt = 1;
                     else if((ATTRTYPE_MGCP3() > 0) && ((Ac->OptReq == 'M') || (Ac->OptReq == 'R')))
                        CheckIt = 1; /** if is MGCP v3, then either metadata or required attributes can't be NULL ***/

                     if(CheckIt > 0)
                        {
                        if(Fdtvalue == -32768.0)  /*** have a NULL value on MGCP reqired attribute ****/
                           {
                           WriteTheError = 0;
                           if((ECC == TDSm1) || (ECC == TDSm2) || (ECC == TDSm3) || (ECC == TDSm4) || (ECC == TDSm5) || (ECC == TDSm6))
                              {
            sprintf(resultmessage,"Layer Identifier %s: Feature %s (%s): Attribute: %s (%s): Required attribute with Null value (%.1lf) assigned\n",
                                shapefile, GetECCCode(ECC),GetECCLabel(ECC),
                               GetEACCode(EAC),GetEACLabel(EAC),Fdtvalue);
                              InsertIntoGIFD_MetaData_ErrorList(resultmessage,entryindex);
                              }
                           else if(PrintSchemaCodes > 0)
                              {
            sprintf(resultmessage,"2%s Layer Identifier %s: Feature %s %s\n   Attribute: %s %s  Required attribute with Null value (%.1lf) assigned\n",
                                ParseGAITgeometry((unsigned char) seeitgeom, 2),shapefile, GetECCCode(ECC),GetECCLabel(ECC),
                               GetEACCode(EAC),GetEACLabel(EAC),Fdtvalue);
                              InsertIntoGIFD_AttrErrorList(resultmessage,entryindex);

sprintf(resultmessage,"2Attribute: %s (%s) (Null value assigned to required attribute)\n", GetEACCode(EAC),GetEACLabel(EAC));
useid = InsertIntoAttrErrorList(resultmessage,entryindex);
InsertIntoAttrIndexList(entryindex,useid);

                              sprintf(resultmessage,"2|%s|%d %d",
                                   GetEACLabel(EAC),ECC,EAC);
                              InsertIntoSummary_AttrErrorList(resultmessage,entryindex);

                              sprintf(resultmessage,"6 %d", EAC);
                              InsertIntoSummary_AttrErrorList(resultmessage,entryindex);
                              }
                           else
                              {
           sprintf(resultmessage,"2%s Layer Identifier %s: Feature %s\n   Attribute %s  Required attribute with Null value (%.1lf) assigned\n",
                                ParseGAITgeometry((unsigned char) seeitgeom, 2),shapefile, GetECCLabel(ECC),GetEACLabel(EAC),Fdtvalue);
                              InsertIntoGIFD_AttrErrorList(resultmessage,entryindex);

sprintf(resultmessage,"2Attribute: %s (Null value assigned to required attribute)\n", GetEACCode(EAC));
useid = InsertIntoAttrErrorList(resultmessage,entryindex);
InsertIntoAttrIndexList(entryindex,useid);

                              sprintf(resultmessage,"2|%s|%d %d",
                                   GetEACLabel(EAC),ECC,EAC);
                              InsertIntoSummary_AttrErrorList(resultmessage,entryindex);

                              sprintf(resultmessage,"6 %d", EAC);
                              InsertIntoSummary_AttrErrorList(resultmessage,entryindex);
                              }
                           }
                        }
                     }

                  if((WriteTheError > 0) && (Ac != NULL) && (ATTRTYPE_ANY_MGCP() > 0))
                     {
                     unusedint = 0;
                     if(ATTRTYPE_MGCP3() > 0)
                        {
                        if(((ECC == MGCP_Wood_index) && (EAC == MGCP_DMT_index)) ||
                            ((ECC == MGCP_Thicket_index) && (EAC == MGCP_DMB_index))  )
                           {
                           unusedint = 0;

                           if((ATTRTYPE_MGCP3() > 0) &&
                               (AlmostTheSameValue(Fdtvalue,-32764.0) == 0) &&
                               (AlmostTheSameValue(Fdtvalue,-32765.0) == 0) &&
                               (AlmostTheSameValue(Fdtvalue,-32767.0) == 0) &&
                               (AlmostTheSameValue(Fdtvalue,-32768.0) == 0) &&
                               (AlmostTheSameValue(Fdtvalue,25.0) == 0) &&
                                      (AlmostTheSameValue(Fdtvalue,51.0) == 0))
                                 unusedint = 1;
                           }
                        } /** end if using MGCP v3 ***/
                     if(unusedint > 0)
                        {
                        if(PrintSchemaCodes > 0)
                           {
                           sprintf(resultmessage,"3%s Layer Identifier %s: Feature %s: %s\n   Attribute: %s %s\n     Value: %lf (expected reserved value, 25, or 51)\n",
                             ParseGAITgeometry((unsigned char) seeitgeom, 2),shapefile,GetECCCode(ECC),
                             GetECCLabel(ECC),GetEACCode(EAC),GetEACLabel(EAC),Fdtvalue);
                           InsertIntoGIFD_AttrErrorList(resultmessage,entryindex);
                           sprintf(resultmessage,"3Value of attribute %s (%s): %lf (expected NULL, Unknown, 25, or 51)\n",
                                  GetEACCode(EAC),GetEACLabel(EAC),Fdtvalue);
                           useid = InsertIntoAttrErrorList(resultmessage,entryindex);
                           InsertIntoAttrIndexList(entryindex,useid);

                           sprintf(resultmessage,"3|%s|%s|%lf %lf %lf %d %d",
                             GetEACCode(EAC),GetEACLabel(EAC),Fdtvalue,25.0,51.0,ECC,EAC);
                           InsertIntoSummary_AttrErrorList(resultmessage,entryindex);

                           sprintf(resultmessage,"7 %d", EAC);
                           InsertIntoSummary_AttrErrorList(resultmessage,entryindex);
                           }
                        else
                           {
                           sprintf(resultmessage,"3%s Layer Identifier %s: Feature %s:\n   Attribute: %s\n     Value: %lf (expected reserved value, 25, or 51)\n",
                             ParseGAITgeometry((unsigned char) seeitgeom, 2),shapefile,
                             GetECCLabel(ECC),GetEACLabel(EAC),Fdtvalue);
                           InsertIntoGIFD_AttrErrorList(resultmessage,entryindex);
                           sprintf(resultmessage,"3Value of attribute %s: %lf (expected NULL, Unknown, 25, or 51)\n",
                               GetEACLabel(EAC),Fdtvalue);
                           useid = InsertIntoAttrErrorList(resultmessage,entryindex);
                           InsertIntoAttrIndexList(entryindex,useid);

                           sprintf(resultmessage,"3|%s|%s|%lf %lf %lf %d %d",
                             GetEACCode(EAC),GetEACLabel(EAC),Fdtvalue,25.0,51.0,ECC,EAC);
                           InsertIntoSummary_AttrErrorList(resultmessage,entryindex);

                           sprintf(resultmessage,"7 %d", EAC);
                           InsertIntoSummary_AttrErrorList(resultmessage,entryindex);
                           }
                        } /** if unusedint > 0 ***/
                     } /*** end is one version of MGCP ***/

                  if((WriteTheError > 0) && (Ac != NULL) && ((Ac->MinValPresent > 0) || (Ac->MaxValPresent > 0)) &&(seeitgeom != C_GRID))
                     {
                     unusedint = 0;
                     if((Ac->MinValPresent > 0) && (Ac->MinOpen == 0) && (Fdtvalue < Ac->minval))
                        unusedint = 1;
                     else if((Ac->MinValPresent > 0) && (Ac->MinOpen == 1) && (Fdtvalue <= Ac->minval))
                        unusedint = 1;
                     if((Ac->MaxValPresent > 0) && (Ac->MaxOpen == 0) && (Fdtvalue > Ac->maxval))
                        unusedint = 1;
                     else if((Ac->MaxValPresent > 0) && (Ac->MaxOpen == 1) && (Fdtvalue >= Ac->maxval))
                        unusedint = 1;
                     WriteTheError = unusedint;
                     if(WriteTheError > 0)
                        {
                        if(UseNUNANPO > 0)
                           {
                           if((Ac->NGAdatatype == 6) && (Fdtvalue >= NUNANPOlower) && (Fdtvalue <= NUNANPOupper))
                              WriteTheError = 0;
                           else if((Ac->NGAdatatype == 3) && (Fdtvalue >= -32768) && (Fdtvalue <= -32764))
                              WriteTheError = 0;
                           }
                        else if(ATTRTYPE_MGCP3() > 0) /*** MGCP3 ***/
                           {
                           if((AlmostTheSameValue(Fdtvalue,-32764.0) == 1) ||
                            (AlmostTheSameValue(Fdtvalue,-32765.0) == 1) ||
                            (AlmostTheSameValue(Fdtvalue,-32767.0) == 1) ||
                            (AlmostTheSameValue(Fdtvalue,-32768.0) == 1))
                              {
                              WriteTheError = 0;
                              }
                           }
                        else if(ATTRTYPE_MGCP4() > 0) /*** MGCP4 ***/
                           {
                           if((AlmostTheSameValue(Fdtvalue,-32764.0) == 1) ||
                            (AlmostTheSameValue(Fdtvalue,-32765.0) == 1) ||
                            (AlmostTheSameValue(Fdtvalue,-32767.0) == 1) ||
                             (AlmostTheSameValue(Fdtvalue,-32768.0) == 1))
                              {
                              WriteTheError = 0;
                              }
                           }
                        else if((ATTRTYPE_ANY_TDS() > 0)  ||
                                         (ATTRTYPE_ANY_GGDM() > 0)) /*** GGDM ***/
                           {
                           if(Fdtvalue == -999999.0)
                              WriteTheError = 0;
                           }

                        else if(ATTRTYPE_SAC() > 0) /*** sac ****/
                           {
                           sprintf(DoubleAsString,"%.1lf",Fdtvalue);
                           strcpy(resultmessage,ParseGAITgeometry((unsigned char) seeitgeom, 0));

                           if(IsNUNANPO_OK_for_SAC(GetECCCode(ECC), GetEACCode(EAC), resultmessage[0], DoubleAsString) > 0)
                              WriteTheError = 0;
                           }

                        if(WriteTheError > 0)
                           {
                           strcpy(MinString,"(Unbounded)");
                           strcpy(MaxString,"(Unbounded)");
                           if(Ac->MinValPresent > 0)
                              {
                              if(Ac->MinOpen == 1)
                                 sprintf(MinString,">%.5lf",Ac->minval);
                              else
                                 sprintf(MinString,">=%.5lf",Ac->minval);
                              }
                           if(Ac->MaxValPresent > 0)
                              {
                              if(Ac->MaxOpen == 1)
                                 sprintf(MaxString,"<%.5lf",Ac->maxval);
                              else
                                 sprintf(MaxString,"<=%.5lf",Ac->maxval);
                              }

                           if((ECC == TDSm1) || (ECC == TDSm2) || (ECC == TDSm3) || (ECC == TDSm4) || (ECC == TDSm5) || (ECC == TDSm6))
                              {
                              sprintf(resultmessage,"Layer Identifier %s: Feature %s (%s): Attribute: %s (%s): Value: %lf (expected range %s to %s)\n",
                                shapefile,GetECCCode(ECC),
                                GetECCLabel(ECC),GetEACCode(EAC),GetEACLabel(EAC),Fdtvalue, MinString,MaxString);
                              InsertIntoGIFD_MetaData_ErrorList(resultmessage,entryindex);
                              }
                           else if(PrintSchemaCodes > 0)
                              {
                              sprintf(resultmessage,"3%s Layer Identifier %s: Feature %s: %s\n   Attribute: %s %s\n     Value: %lf (expected range %s to %s)\n",
                                ParseGAITgeometry((unsigned char) seeitgeom, 2),shapefile,GetECCCode(ECC),
                                GetECCLabel(ECC),GetEACCode(EAC),GetEACLabel(EAC),Fdtvalue, MinString, MaxString);
                              InsertIntoGIFD_AttrErrorList(resultmessage,entryindex);
                              sprintf(resultmessage,"3Value of attribute %s (%s): %lf (expected range %s - %s)\n",
                                  GetEACCode(EAC),GetEACLabel(EAC),Fdtvalue, MinString, MaxString);
                              useid = InsertIntoAttrErrorList(resultmessage,entryindex);
                              InsertIntoAttrIndexList(entryindex,useid);

                              sprintf(resultmessage,"3|%s|%s|%lf %d %d %d %d",
                                GetEACCode(EAC),GetEACLabel(EAC),Fdtvalue,(int) (Ac->minval),(int) (Ac->maxval),ECC,EAC);
                              InsertIntoSummary_AttrErrorList(resultmessage,entryindex);

                              sprintf(resultmessage,"7 %d", EAC);
                              InsertIntoSummary_AttrErrorList(resultmessage,entryindex);
                              }
                           else
                              {
                              sprintf(resultmessage,"3%s Layer Identifier %s: Feature %s:\n   Attribute: %s\n     Value: %lf (expected range %s to %s)\n",
                                ParseGAITgeometry((unsigned char) seeitgeom, 2),shapefile,
                                GetECCLabel(ECC),GetEACLabel(EAC),Fdtvalue, MinString, MaxString);
                              InsertIntoGIFD_AttrErrorList(resultmessage,entryindex);
                              sprintf(resultmessage,"3Value of attribute %s: %lf (expected range %s to %s)\n",
                                  GetEACLabel(EAC),Fdtvalue, MinString, MaxString);
                              useid = InsertIntoAttrErrorList(resultmessage,entryindex);
                              InsertIntoAttrIndexList(entryindex,useid);

                              sprintf(resultmessage,"3|%s|%s|%lf %d %d %d %d",
                                GetEACCode(EAC),GetEACLabel(EAC),Fdtvalue,(int) (Ac->minval),(int) (Ac->maxval),ECC,EAC);
                              InsertIntoSummary_AttrErrorList(resultmessage,entryindex);

                              sprintf(resultmessage,"7 %d", EAC);
                              InsertIntoSummary_AttrErrorList(resultmessage,entryindex);
                              }
                           }
                        }
                     }
                  break;
               case 2: /** a string **/
               case 6: /*** a Date type ***/
                  SEEIT_fread_int(&numchar,fileptr);
                  if(numchar >= tlimittest)
                     {
                     tlimit = numchar + 5;
                     tlimittest = tlimit - 10;
                     titlechar = (char *) (realloc(titlechar,tlimit));
                     if(titlechar == NULL)
                        {
                         printf("all available memory has been used\n  processing cannot continue\n");
                         exit(-1);
                        }
                     }

                  for(i=0; i<numchar; i++)
                     {
                     fread(&titlechar[i],1,1,fileptr);
                     }
                  titlechar[i] = '\0';
                  if((ATTRTYPE_ANY_TDS() > 0)  ||/*** ?TDS schema ***/
                            (ATTRTYPE_ANY_GGDM() > 0)) /** GGDM ***/
                     {
                     strcpy(resultmessage,RemoveOuterQuotes(titlechar));
                     AddToVVTcounts(ECC, seeitgeom, EAC, resultmessage,shapefile, -999999.0, -999);
                     }

                  if(ATTRTYPE_MGCP4() > 0)
                     {
                     CapturePortrayRuleValue(ECC,seeitgeom,EAC,titlechar);
                     }
                  else if(ATTRTYPE_TDS6() > 0)
                     {
                     CapturePortrayRuleValue(ECC,seeitgeom,EAC,titlechar);
                     }

                  if((SRC_DATE_index >= 0) && (EAC == SRC_DATE_index))
                     {
                     if(SRC_DATE_root == NULL)
                        {
                        strcpy(resultmessage,FindGoodDateValue(titlechar));
                        date_n = (struct DateValueToLindex *) (malloc(sizeof(struct DateValueToLindex)));
                        date_n->date = (char *) (malloc(strlen(resultmessage) + 1));
                        strcpy(date_n->date,resultmessage);
                        en = (struct EnumList *) (malloc(sizeof(struct EnumList)));
                        en->val = entryindex;
                        en->next = NULL;
                        date_n->Lindex = en;
                        date_n->next = NULL;
                        SRC_DATE_root = date_n;
                        }
                     else
                        InsertIntoDateList(&SRC_DATE_root,entryindex,titlechar);
                     }
                  else if((UPD_DATE_index >= 0) && (EAC == UPD_DATE_index))
                     {
                     if(UPD_DATE_root == NULL)
                        {
                        strcpy(resultmessage,FindGoodDateValue(titlechar));
                        date_n = (struct DateValueToLindex *) (malloc(sizeof(struct DateValueToLindex)));
                        date_n->date = (char *) (malloc(strlen(resultmessage) + 1));
                        strcpy(date_n->date,resultmessage);
                        en = (struct EnumList *) (malloc(sizeof(struct EnumList)));
                        en->val = entryindex;
                        en->next = NULL;
                        date_n->Lindex = en;
                        date_n->next = NULL;
                        UPD_DATE_root = date_n;
                        }
                     else
                        InsertIntoDateList(&UPD_DATE_root,entryindex,titlechar);
                     }
                   WriteTheError = 1;
                  if(IsJunkValue(datatype,-1312452,-1312452,titlechar,-1312452,NULL) > 0)
                     {
                     sprintf(resultmessage,"w|%s|%d|%s|%d|%d",GetEACCode(EAC),EAC,titlechar,ECC,seeitgeom);
                     InsertIntoSummary_AttrErrorList(resultmessage,entryindex);
                     }

                  if(datatype == 2) /** a string, not a date ****/
                     {
                     if((ATTRTYPE_TDS6() > 0) || (ATTRTYPE_ANY_GGDM() > 0)) 
                        {
                        if(ATTRTYPE_TDS6() > 0)
                           {
                           if(EAC == MGCP_NFN_index)
                              strncpy(MGCP_NFN_str,titlechar,254);
                           }
                        jj = 2;
                        jj = Check_TDS_StrucText(EAC,titlechar);
                        if(jj < 1)
                           {
                           resultmessage[0] = '\0';
                           sprintf(resultmessage,"Layer Identifier %s: Feature %s (%s): Attribute %s (%s): 'No Information' assigned to structured text attribute: %s\n",
                                shapefile,GetECCCode(ECC),GetECCLabel(ECC),
                                 GetEACCode(EAC),GetEACLabel(EAC),titlechar);
                           if((EAC == TDS_SAX_RS3_index) || (EAC == TDS_SAX_RS4_index))
                              InsertIntoGIFD_MetaData_ErrorList(resultmessage,entryindex);
                           else
                              {
                                 InsertIntoGIFD_AttrErrorList(resultmessage,entryindex);
                                 sprintf(resultmessage,"3Value of attribute %s (%s): %s (expected reserved value appropriate for String data type)\n",
                                    GetEACCode(EAC),GetEACLabel(EAC),titlechar);
                                 useid = InsertIntoAttrErrorList(resultmessage,entryindex);
                                 InsertIntoAttrIndexList(entryindex,useid);

                                 sprintf(resultmessage,"3|%s|%s (string assigned as value: %s)|8 reserved String Value %d %d",
                                      GetEACCode(EAC),GetEACLabel(EAC),titlechar,ECC,EAC);
                                 InsertIntoSummary_AttrErrorList(resultmessage,entryindex);

                                 sprintf(resultmessage,"7 %d", EAC);
                                 InsertIntoSummary_AttrErrorList(resultmessage,entryindex);
                              }
                           }
                        jj = 2;
                        jj = Check_TDS_Specials(EAC,titlechar);
                        if(jj < 1)
                           {
                           resultmessage[0] = '\0';
                           sprintf(resultmessage,"Layer Identifier %s: Feature %s (%s): Attribute %s (%s): incorrect structured text value: %s\n",
                                shapefile,GetECCCode(ECC),GetECCLabel(ECC),
                                 GetEACCode(EAC),GetEACLabel(EAC),titlechar);
                           InsertIntoGIFD_MetaData_ErrorList(resultmessage,entryindex);
                            }
                        }
                     if((EAC == TDS_OTH_index) && (ATTRTYPE_ANY_TDS() > 0)) /*** only applies to TDS models ***/
                        {
                        if(BadOTH.OTHvalue != NULL)
                           free(BadOTH.OTHvalue);
                        BadOTH.OTHvalue = (char *) (malloc(strlen(titlechar) + 1));
                        jj = 0;
                        if(titlechar[0] == '"')
                           {
                           strcpy(BadOTH.OTHvalue,&titlechar[1]);
                           jj = strlen(BadOTH.OTHvalue);
                           while(BadOTH.OTHvalue[jj] != '"')
                              {
                              --jj;
                              if(jj == 0)
                                 break;
                              }
                           if(BadOTH.OTHvalue[jj] == '"')
                              BadOTH.OTHvalue[jj] = '\0';
                           }
                        else
                           strcpy(BadOTH.OTHvalue,titlechar);
                        
                        }
                     }


                  if((Ac != NULL) && (seeitgeom != C_GRID) && (ATTRTYPE_ANY_MGCP() > 0)) 
                     {
                     if((datatype == 2) && /*** a string and, as above, are working with MGCP *****/
                         (EAC != MGCP_NFI_index) && (EAC != MGCP_NFN_index))
                        {
                        if(titlechar[0] == '"')
                           {
                           if((strcmp(&titlechar[1],"-32768\"") == 0) ||
                               (strcmp(&titlechar[1],"-32767\"") == 0) ||
                               (strcmp(&titlechar[1],"-32765\"") == 0) ||
                               (strcmp(&titlechar[1],"-32764\"") == 0) ||
                               (strcmp(&titlechar[1],"-32768.0\"") == 0) ||
                               (strcmp(&titlechar[1],"-32767.0\"") == 0) ||
                               (strcmp(&titlechar[1],"-32765.0\"") == 0) ||
                               (strcmp(&titlechar[1],"-32764.0\"") == 0) ||
                               (strcmp(&titlechar[1],"-2147483648\"") == 0) ||
                               (strcmp(&titlechar[1],"-2147483647\"") == 0) ||
                               (strcmp(&titlechar[1],"-2147483645\"") == 0) ||
                               (strcmp(&titlechar[1],"-2147483644\"") == 0) ||
                               (strcmp(&titlechar[1],"996\"") == 0) ||
                               (strcmp(&titlechar[1],"997\"") == 0) ||
                               (strcmp(&titlechar[1],"998\"") == 0) ||
                               (strcmp(&titlechar[1],"999\"") == 0) ||
                               ((titlechar[1] == '0') && (titlechar[2] == '"') && (titlechar[3] == '\0')))
                              {
                                 sprintf(resultmessage,"3%s Layer Identifier %s: Feature %s: %s\n   Attribute: %s %s\n     Value: %s (expected reserved value appropriate for String data type)\n",
                                   ParseGAITgeometry((unsigned char) seeitgeom, 2),shapefile,GetECCCode(ECC),
                                   GetECCLabel(ECC),GetEACCode(EAC),GetEACLabel(EAC),titlechar);
                                 InsertIntoGIFD_AttrErrorList(resultmessage,entryindex);
                                 sprintf(resultmessage,"3Value of attribute %s (%s): %s (expected reserved value appropriate for String data type)\n",
                                    GetEACCode(EAC),GetEACLabel(EAC),titlechar);
                                 useid = InsertIntoAttrErrorList(resultmessage,entryindex);
                                 InsertIntoAttrIndexList(entryindex,useid);

                                 sprintf(resultmessage,"3|%s|%s (string assigned as value: %s)|8 reserved String Value %d %d",
                                      GetEACCode(EAC),GetEACLabel(EAC),titlechar,ECC,EAC);
                                 InsertIntoSummary_AttrErrorList(resultmessage,entryindex);

                                 sprintf(resultmessage,"7 %d", EAC);
                                 InsertIntoSummary_AttrErrorList(resultmessage,entryindex);
                              }
                           }
                        else
                           {
                           if((strcmp(titlechar,"-32768") == 0) ||
                               (strcmp(titlechar,"-32767") == 0) ||
                               (strcmp(titlechar,"-32765") == 0) ||
                               (strcmp(titlechar,"-32764") == 0) ||
                               (strcmp(titlechar,"-32768.0") == 0) ||
                               (strcmp(titlechar,"-32767.0") == 0) ||
                               (strcmp(titlechar,"-32765.0") == 0) ||
                               (strcmp(titlechar,"-32764.0") == 0) ||
                               (strcmp(titlechar,"-2147483648") == 0) ||
                               (strcmp(titlechar,"-2147483647") == 0) ||
                               (strcmp(titlechar,"-2147483645") == 0) ||
                               (strcmp(titlechar,"-2147483644") == 0) ||
                               (strcmp(titlechar,"996") == 0) ||
                               (strcmp(titlechar,"997") == 0) ||
                               (strcmp(titlechar,"998") == 0) ||
                               (strcmp(titlechar,"999") == 0) ||
                               ((titlechar[0] == '0') && (titlechar[1] == '\0')))
                              {
                                 sprintf(resultmessage,"3%s Layer Identifier %s: Feature %s: %s\n   Attribute: %s %s\n     Value: %s (expected reserved value appropriate for String data type)\n",
                                   ParseGAITgeometry((unsigned char) seeitgeom, 2),shapefile,GetECCCode(ECC),
                                   GetECCLabel(ECC),GetEACCode(EAC),GetEACLabel(EAC),titlechar);
                                 InsertIntoGIFD_AttrErrorList(resultmessage,entryindex);
                                 sprintf(resultmessage,"3Value of attribute %s (%s): %s (expected reserved value appropriate for String data type)\n",
                                    GetEACCode(EAC),GetEACLabel(EAC),titlechar);
                                 useid = InsertIntoAttrErrorList(resultmessage,entryindex);
                                 InsertIntoAttrIndexList(entryindex,useid);

                                 sprintf(resultmessage,"3|%s|%s (string assigned as value: %s)|8 reserved String Value %d %d",
                                      GetEACCode(EAC),GetEACLabel(EAC),titlechar,ECC,EAC);
                                 InsertIntoSummary_AttrErrorList(resultmessage,entryindex);

                                 sprintf(resultmessage,"7 %d", EAC);
                                 InsertIntoSummary_AttrErrorList(resultmessage,entryindex);
                              }
                           }
                        }

                     if(EAC == MGCP_IKO_index)
                        {
                        i = j = 0;
                        while(titlechar[i] > '\0')
                           {
                           if(titlechar[i] != '"')
                              {
                              enumcodestring[j] = titlechar[i];
                              ++j;
                              enumcodestring[j] = '\0';
                              }
                           ++i;
                           }
                        counter = 0;
                        if(enumcodestring[4] == '\0')
                           {
                           for(i=0; i<4; i++)
                              {
                              if((enumcodestring[i] >= '0') && (enumcodestring[i] <= '9'))
                                 ++counter;
                              else if((enumcodestring[i] >= 'A') && (enumcodestring[i] <= 'z'))
                                 ++counter;
                              }
                           }
                        if(counter != 4)  /*** preclude double count error with bad sentinel string error ....  ***/
                           {
                           if((strcmp(enumcodestring,"-32768") == 0) ||
                               (strcmp(enumcodestring,"-32767") == 0) ||
                               (strcmp(enumcodestring,"-32765") == 0) ||
                               (strcmp(enumcodestring,"-32764") == 0) ||
                               (strcmp(enumcodestring,"-32768.0") == 0) ||
                               (strcmp(enumcodestring,"-32767.0") == 0) ||
                               (strcmp(enumcodestring,"-32765.0") == 0) ||
                               (strcmp(enumcodestring,"-32764.0") == 0) ||
                               (strcmp(enumcodestring,"-2147483648") == 0) ||
                               (strcmp(enumcodestring,"-2147483647") == 0) ||
                               (strcmp(enumcodestring,"-2147483645") == 0) ||
                               (strcmp(enumcodestring,"-2147483644") == 0) ||
                               (strcmp(enumcodestring,"996") == 0) ||
                               (strcmp(enumcodestring,"997") == 0) ||
                               (strcmp(enumcodestring,"998") == 0) ||
                               (strcmp(enumcodestring,"999") == 0) ||
                               ((enumcodestring[0] == '0') && (enumcodestring[1] == '\0')))
                              {
                              counter = 4;
                              }
                           }
                        if(counter != 4)
                           {
                           if((strcmp(enumcodestring,"UNK") != 0) && (strcmp(enumcodestring,"N_A") != 0))
                              {
                              sprintf(resultmessage,"3%s Layer Identifier %s: Feature %s: %s\n   Attribute: %s %s\n     Value: %s (expected value to be 4-character ICAO code, 'UNK' or 'N_A')\n",
                                ParseGAITgeometry((unsigned char) seeitgeom, 2),shapefile,GetECCCode(ECC),
                                GetECCLabel(ECC),GetEACCode(EAC),GetEACLabel(EAC),enumcodestring);
                              InsertIntoGIFD_AttrErrorList(resultmessage,entryindex);
                              sprintf(resultmessage,"3Value of attribute %s (%s): %s (expected value to be 4-character ICAO code, 'UNK' or 'N_A')\n",
                                    GetEACCode(EAC),GetEACLabel(EAC),enumcodestring);
                              useid = InsertIntoAttrErrorList(resultmessage,entryindex);
                              InsertIntoAttrIndexList(entryindex,useid);

                              sprintf(resultmessage,"3|%s|%s (string assigned as value: %s)|8 unexpected ICAO value %d %d",
                                   GetEACCode(EAC),GetEACLabel(EAC),enumcodestring,ECC,EAC);
                              InsertIntoSummary_AttrErrorList(resultmessage,entryindex);

                              sprintf(resultmessage,"7 %d", EAC);
                              InsertIntoSummary_AttrErrorList(resultmessage,entryindex);
                              }
                           }
                        }

                     if(EAC == MGCP_NAM_index)
                        strncpy(MGCP_NAM_str,titlechar,254);
                     else if(EAC == MGCP_NFN_index)
                        strncpy(MGCP_NFN_str,titlechar,254);
                     else if(EAC == MGCP_NFI_index)
                        strncpy(MGCP_NFI_str,titlechar,254);

                     MGCP_NAM_str[255] = MGCP_NFN_str[255] = MGCP_NFI_str[255] = '\0';
                     Atemp = NGAmetaRoot->attr;
                     while(Atemp != NULL)
                        {
                        if(Atemp->codeindex == EAC)
                           break;
                        Atemp = Atemp->next;
                        }
                     CheckIt = 0;
                     if(Atemp != NULL) /** we are looking at a metadata attribute ***/
                        CheckIt = 1;
                     else if((ATTRTYPE_MGCP3() > 0) && ((Ac->OptReq == 'M') || (Ac->OptReq == 'R')))
                        CheckIt = 1; /** if is MGCP v3, then either metadata or required attributes can't be NULL ***/

                     if(CheckIt > 0)
                        {
                        if((titlechar[0] == '\0') || (strcmp(titlechar,"N/A") == 0) ||
                           ((titlechar[0] == '"') && (strncmp(&titlechar[1],"N/A",3) == 0) && (titlechar[4] == '"'))) 
                                /*** have a NULL value on MGCP reqired attribute ****/
                           {
                           WriteTheError = 0;
                           
                           if((ECC == TDSm1) || (ECC == TDSm2) || (ECC == TDSm3) || (ECC == TDSm4) || (ECC == TDSm5) || (ECC == TDSm6))
                              {
         sprintf(resultmessage,"Layer Identifier %s: Feature %s (%s): Attribute: %s (%s): Required attribute with Null value (%s) assigned\n",
                                shapefile, GetECCCode(ECC),GetECCLabel(ECC),
                               GetEACCode(EAC),GetEACLabel(EAC),titlechar);
                              InsertIntoGIFD_MetaData_ErrorList(resultmessage,entryindex);
                              }
                           else if(PrintSchemaCodes > 0)
                              {
         sprintf(resultmessage,"2%s Layer Identifier %s: Feature %s %s\n   Attribute: %s %s  Required attribute with Null value (%s) assigned\n",
                                ParseGAITgeometry((unsigned char) seeitgeom, 2),shapefile, GetECCCode(ECC),GetECCLabel(ECC),
                               GetEACCode(EAC),GetEACLabel(EAC),titlechar);
                              InsertIntoGIFD_AttrErrorList(resultmessage,entryindex);

sprintf(resultmessage,"2Attribute: %s (%s) (Null value assigned to required attribute)\n", GetEACCode(EAC),GetEACLabel(EAC));
useid = InsertIntoAttrErrorList(resultmessage,entryindex);
InsertIntoAttrIndexList(entryindex,useid);

                              sprintf(resultmessage,"2|%s|%d %d",
                                   GetEACLabel(EAC),ECC,EAC);
                              InsertIntoSummary_AttrErrorList(resultmessage,entryindex);

                              sprintf(resultmessage,"6 %d", EAC);
                              InsertIntoSummary_AttrErrorList(resultmessage,entryindex);
                              }
                           else
                              {
                sprintf(resultmessage,"2%s Layer Identifier %s: Feature %s\n   Attribute %s  Required attribute with Null value (%s) assigned\n",
                                      ParseGAITgeometry((unsigned char) seeitgeom, 2),shapefile, GetECCLabel(ECC),GetEACLabel(EAC),titlechar);
                              InsertIntoGIFD_AttrErrorList(resultmessage,entryindex);

sprintf(resultmessage,"2Attribute: %s (Null value assigned to required attribute)\n", GetEACCode(EAC));
useid = InsertIntoAttrErrorList(resultmessage,entryindex);
InsertIntoAttrIndexList(entryindex,useid);

                              sprintf(resultmessage,"2|%s|%d %d",
                                   GetEACLabel(EAC),ECC,EAC);
                              InsertIntoSummary_AttrErrorList(resultmessage,entryindex);

                              sprintf(resultmessage,"6 %d", EAC);
                              InsertIntoSummary_AttrErrorList(resultmessage,entryindex);
                              }
                           }
                        }
                     }

                   if((WriteTheError > 0)&& (seeitgeom != C_GRID) && (ATTRTYPE_ANY_MGCP() > 0)) /*** MGCP   ****/
                      {
                      if((ATTRTYPE_MGCP3() > 0) && (strcmp(titlechar,"N/A") == 0)) /** only valid NUNANPO for MGCP v3 **/
                         WriteTheError = 0;
                      else if((ATTRTYPE_MGCP4() > 0) && (strcmp(titlechar,"N/A") == 0)) /** late change valid NUNANPO for MGCP v4 **/
                         WriteTheError = 0;
                      else if(strcmp(titlechar,"N_A") == 0)
                         WriteTheError = 0;
                      else if(strcmp(titlechar,"UNK") == 0)
                         WriteTheError = 0;
                      else if(strcmp(titlechar,"OTH") == 0)
                         WriteTheError = 0;
                      }

                   if((WriteTheError > 0) && (Ac != NULL))
                      {
                      nc2 = numchar;
                      if((titlechar[0] == '"') && (titlechar[numchar-1] == '"'))
                         nc2 = nc2- 2;

                        if(datatype == 6) /*** a Date datatype ***/
                           {
                           year = 0;
                           for(i=0; i<4; i++)
                              {
                              year = year * 10 + (int) titlechar[i];
                              }
                           month = 0;
                           for(i=4; i<6; i++)
                              {
                              month = month * 10 + (int) titlechar[i];
                              }
                           day = 0;
                           for(i=6; i<8; i++)
                              {
                              day = day * 10 + (int) titlechar[i];
                              }
                           i = strlen(titlechar);
                           if((year < 2940) || (year > IntYearLimit) || (month < 1) || (month > 12) || (day < 1) || (day > 31) || (i > 8))
                              {
                           if((ECC == TDSm1) || (ECC == TDSm2) || (ECC == TDSm3) || (ECC == TDSm4) || (ECC == TDSm5) || (ECC == TDSm6))
                              {
                                 sprintf(resultmessage,"Layer Identifier %s: Feature %s (%s): Attribute: %s (%s): Value: %s (expected 8-character YYYYMMDD Date value between 19400101 and today)\n",
                                   shapefile,GetECCCode(ECC),
                                   GetECCLabel(ECC),GetEACCode(EAC),GetEACLabel(EAC),titlechar);
                              InsertIntoGIFD_MetaData_ErrorList(resultmessage,entryindex);
                              }

                              else if(PrintSchemaCodes > 0)
                                 {
                                 sprintf(resultmessage,"3%s Layer Identifier %s: Feature %s: %s\n   Attribute: %s %s\n     Value: %s (expected 8-character YYYYMMDD Date value between 19400101 and today)\n",
                                   ParseGAITgeometry((unsigned char) seeitgeom, 2),shapefile,GetECCCode(ECC),
                                   GetECCLabel(ECC),GetEACCode(EAC),GetEACLabel(EAC),titlechar);
                                 InsertIntoGIFD_AttrErrorList(resultmessage,entryindex);
                                 sprintf(resultmessage,"3Value of attribute %s (%s): %s (expected 8-character YYYYMMDD Date value between 19400101 and today)\n",
                                    GetEACCode(EAC),GetEACLabel(EAC),titlechar);
                                 useid = InsertIntoAttrErrorList(resultmessage,entryindex);
                                 InsertIntoAttrIndexList(entryindex,useid);

                                 sprintf(resultmessage,"3|%s|%s (string value: %s)|8 19400101 %s0101 %d %d",
                                      GetEACCode(EAC),GetEACLabel(EAC),titlechar,YearLimit,ECC,EAC);
                                 InsertIntoSummary_AttrErrorList(resultmessage,entryindex);

                                 sprintf(resultmessage,"7 %d", EAC);
                                 InsertIntoSummary_AttrErrorList(resultmessage,entryindex);
                                 }
                               else
                                 {
                                 sprintf(resultmessage,"3%s Layer Identifier %s: Feature %s:\n   Attribute: %s\n     Value: %s (expected 8-character YYYYMMDD Date value between 19400101 and today)\n",
                                   ParseGAITgeometry((unsigned char) seeitgeom, 2),shapefile,
                                   GetECCLabel(ECC),GetEACLabel(EAC),titlechar);
                                 InsertIntoGIFD_AttrErrorList(resultmessage,entryindex);
                                 sprintf(resultmessage,"3Value of attribute %s: %s (expected 8-character YYYYMMDD Date value between 19400101 and today)\n",
                                       GetEACLabel(EAC),titlechar);
                                 useid = InsertIntoAttrErrorList(resultmessage,entryindex);
                                 InsertIntoAttrIndexList(entryindex,useid);

                                 sprintf(resultmessage,"3|%s|%s (string value: %s)|8 19400101 %s0101 %d %d",
                                      GetEACCode(EAC),GetEACLabel(EAC),titlechar,YearLimit,ECC,EAC);
                                 InsertIntoSummary_AttrErrorList(resultmessage,entryindex);
   
                                 sprintf(resultmessage,"7 %d", EAC);
                                 InsertIntoSummary_AttrErrorList(resultmessage,entryindex);
                                 }
                               }
                           }  /*** end if is a Date datatype ***/
                        else if((datatype == Ac->datatype) && 
                              ((nc2 < Ac->minval) || (nc2 > Ac->maxval)))/** note that Ac->maxval should be maxstrlen value for String types***/
                           {
                           if((ECC == TDSm1) || (ECC == TDSm2) || (ECC == TDSm3) || (ECC == TDSm4) || (ECC == TDSm5) || (ECC == TDSm6))
                              {
                              sprintf(resultmessage,"Layer Identifier %s: Feature %s (%s): Attribute: %s (%s): Value: %s (%d characters, expected %d to %d characters)\n",
                                 shapefile,GetECCCode(ECC),
                                GetECCLabel(ECC),GetEACCode(EAC),GetEACLabel(EAC),titlechar, nc2,(int) Ac->minval, (int) Ac->maxval);
                              InsertIntoGIFD_MetaData_ErrorList(resultmessage,entryindex);
                              }
                           else if(PrintSchemaCodes > 0)
                              {
                              sprintf(resultmessage,"3%s Layer Identifier %s: Feature %s: %s\n   Attribute: %s %s\n     Value: %s (%d characters, expected %d to %d characters)\n",
                                ParseGAITgeometry((unsigned char) seeitgeom, 2),shapefile,GetECCCode(ECC),
                                GetECCLabel(ECC),GetEACCode(EAC),GetEACLabel(EAC),titlechar, nc2,(int) Ac->minval, (int) Ac->maxval);
                              InsertIntoGIFD_AttrErrorList(resultmessage,entryindex);
                              sprintf(resultmessage,"3Value of attribute %s (%s): %s (%d characters, expected %d - %d characters)\n",
                                    GetEACCode(EAC),GetEACLabel(EAC),titlechar, nc2, (int) Ac->minval, (int) Ac->maxval);
                              useid = InsertIntoAttrErrorList(resultmessage,entryindex);
                              InsertIntoAttrIndexList(entryindex,useid);

                              sprintf(resultmessage,"3|%s|%s (string value: %s)|%lf %lf %lf %d %d",
                                   GetEACCode(EAC),GetEACLabel(EAC),titlechar,(double) strlen(titlechar),Ac->minval,Ac->maxval,ECC,EAC);
                              InsertIntoSummary_AttrErrorList(resultmessage,entryindex);
   
                              sprintf(resultmessage,"7 %d", EAC);
                              InsertIntoSummary_AttrErrorList(resultmessage,entryindex);
                              }
                            else
                              {
                              sprintf(resultmessage,"3%s Layer Identifier %s: Feature %s:\n   Attribute: %s\n     Value: %s (%d characters, expected %d to %d characters)\n",
                                ParseGAITgeometry((unsigned char) seeitgeom, 2),shapefile,
                                GetECCLabel(ECC),GetEACLabel(EAC),titlechar, nc2, (int) Ac->minval, (int) Ac->maxval);
                              InsertIntoGIFD_AttrErrorList(resultmessage,entryindex);
                              sprintf(resultmessage,"3Value of attribute %s: %s (%d characters, expected %d - %d characters)\n",
                                    GetEACLabel(EAC),titlechar, nc2, (int) Ac->minval, (int) Ac->maxval);
                              useid = InsertIntoAttrErrorList(resultmessage,entryindex);
                              InsertIntoAttrIndexList(entryindex,useid);

                              sprintf(resultmessage,"3|%s|%s (string value: %s)|%lf %lf %lf %d %d",
                                   GetEACCode(EAC),GetEACLabel(EAC),titlechar,(double) strlen(titlechar),Ac->minval,Ac->maxval,ECC,EAC);
                              InsertIntoSummary_AttrErrorList(resultmessage,entryindex);

                              sprintf(resultmessage,"7 %d", EAC);
                              InsertIntoSummary_AttrErrorList(resultmessage,entryindex);
                              }
                            }
                         }


                   if(Ameta != NULL)
                      {
                      Ameta->strval = (char *) (malloc(numchar + 6));
                      strcpy(Ameta->strval,RemoveOuterQuotes(titlechar));
                      Ameta->intval = -1;
                      Ameta->floatval = -1.0;
                      }
                  if((Ac != NULL) && (Ac->picks != NULL))  /** must be an enum type ***/
                     {
                     ii = 0;
                     if(titlechar[0] == '"')
                        {
                        ii = strlen(titlechar);
                        while((ii > 0) && ((titlechar[ii] < ' ') || (titlechar[ii] == '"')))
                           {
                           titlechar[ii] = '\0';
                           --ii;
                           }
                        ii = 1;
                        }
                     pc = Ac->picks;

                     while(pc != NULL)
                        {
                        if(strcmp(&titlechar[ii],pc->code) == 0)
                           break;
                        pc = pc->next;
                        }
                     if((pc == NULL) && (seeitgeom != C_GRID))
                        {
                        WriteTheError = IsNUNANPOString(titlechar,Ac->NGAdatatype,Ac->varchar,Ac->maxstrlen);
                           
                        if(WriteTheError > 0)
                           {
                           if((ECC == TDSm1) || (ECC == TDSm2) || (ECC == TDSm3) || (ECC == TDSm4) || (ECC == TDSm5) || (ECC == TDSm6))
                              {
                              sprintf(resultmessage,"Layer Identifier %s: Feature %s (%s): Attribute %s (%s): Value - %s Not Allowed\n",
                                shapefile,
                                GetECCCode(ECC),GetECCLabel(ECC),Ac->codeDomain,GetEACCode(EAC),GetEACLabel(EAC));
                              InsertIntoGIFD_MetaData_ErrorList(resultmessage,entryindex);
                              }
                           else if(PrintSchemaCodes > 0)
                              {
                              sprintf(resultmessage,"4%s Layer Identifier %s: Feature %s %s\n   Domain  %s\n     Attribute %s %s, Value - %s\n",
                                ParseGAITgeometry((unsigned char) seeitgeom, 2),shapefile,
                                GetECCCode(ECC),GetECCLabel(ECC),Ac->codeDomain,GetEACCode(EAC),GetEACLabel(EAC),titlechar);
                              InsertIntoGIFD_AttrErrorList(resultmessage,entryindex);

                              sprintf(resultmessage,"4Attribute: %s (%s), Value: %s\n", GetEACCode(EAC),GetEACLabel(EAC),titlechar);
                              useid = InsertIntoAttrErrorList(resultmessage,entryindex);
                              InsertIntoAttrIndexList(entryindex,useid);

                              sprintf(resultmessage,"4|%s|%s|%s|%s|%s|%d %d %d %d",
                                GetECCCode(ECC),GetECCLabel(ECC),Ac->codeDomain,GetEACLabel(EAC),titlechar,ECC,seeitgeom,EAC,-1);
                              InsertIntoSummary_AttrErrorList(resultmessage,entryindex);

                              sprintf(resultmessage,"8 %d",EAC);
                              InsertIntoSummary_AttrErrorList(resultmessage,entryindex);
                              }
                           else
                              {
                              sprintf(resultmessage,"4%s Layer Identifier %s: Feature %s\n   Domain %s\n     Attribute: %s, Value: %s\n",
                                ParseGAITgeometry((unsigned char) seeitgeom, 2),shapefile,
                                GetECCLabel(ECC),Ac->codeDomain,GetEACLabel(EAC),titlechar);
                              InsertIntoGIFD_AttrErrorList(resultmessage,entryindex);

                              sprintf(resultmessage,"4Attribute: %s, Value: %s\n", GetEACLabel(EAC),titlechar);
                              useid = InsertIntoAttrErrorList(resultmessage,entryindex);
                              InsertIntoAttrIndexList(entryindex,useid);

                              sprintf(resultmessage,"4|%s|%s|%s|%s|%s|%d %d %d %d",
                                GetECCCode(ECC),GetECCLabel(ECC),Ac->codeDomain,GetEACLabel(EAC),titlechar,ECC,seeitgeom,EAC,-1);
                              InsertIntoSummary_AttrErrorList(resultmessage,entryindex);

                              sprintf(resultmessage,"8 %d",EAC);
                           /*****sprintf(resultmessage,"8|%s|%s|", GetEACLabel(EAC),titlechar); *****/
                              InsertIntoSummary_AttrErrorList(resultmessage,entryindex);
                              }
                           }
                        }
                     }
                  break;
               case 3: /** enum as int **/
                  SEEIT_fread_int(&enumcode,fileptr);

                  strcpy(enumcodestring,RemoveOuterQuotes(GetEECode(EAC, enumcode)));
                  if((ATTRTYPE_ANY_MGCP() > 0) && (EAC == MGCP_CAA_index))  /*** MGCP v3, v4 only ***/
                     {
                     strncpy(MGCP_CAA_str,enumcodestring,254);
                     MGCP_CAA_str[255] = '\0';
                     }
                  strcpy(EEname,GetEELabel(EAC, enumcode));

                  if(Ameta != NULL)
                     {
                     Ameta->intval = enumcode;
                     Ameta->strval = (char *) (malloc(strlen(enumcodestring) + 6));
                     strcpy(Ameta->strval,enumcodestring);
                     Ameta->floatval = (double) enumcode;
                     }

                  if(IsJunkValue(datatype,-1312452,-1312452,NULL,enumcode,EEname) > 0)
                     {
                     sprintf(resultmessage,"w|%s|%d|%s|%d|%d",GetEACCode(EAC),EAC,EEname,ECC,seeitgeom);
                     InsertIntoSummary_AttrErrorList(resultmessage,entryindex);
                     }

                  if(ATTRTYPE_UFD1() > 0) /*** will add to VVT counts for UFD1 in below loop ***/
                     {
                     AddToVVTcounts(ECC, seeitgeom, EAC, enumcodestring,shapefile, -999999.0, -999);
                     }
                  else if(ATTRTYPE_MGCP4() > 0)
                     {
                     sprintf(resultmessage,"%s (\"%s\")",enumcodestring,GetEELabel(EAC, enumcode));
                     CapturePortrayRuleValue(ECC,seeitgeom,EAC,resultmessage);
                     }
                  else if((ATTRTYPE_ANY_TDS() > 0) || 
                                (ATTRTYPE_ANY_GGDM() > 0)) 
                     {
                     if((ATTRTYPE_TDS6() > 0) && ((EAC == TDS_GE4_index) || (EAC == TDS_GE42_index) ||
                                                  (EAC == TDS_GE43_index) || (EAC == TDS_GE44_index)))
                        {
                        if((strcmp(enumcodestring,"other") == 0) || (strcmp(enumcodestring,"noInformation") == 0))
                           TDS_GE4_sentinel  += LongListInstances[entryindex];
                        else
                           {
                           jj = strlen(enumcodestring);
                           if((enumcodestring[0] == '"') && (enumcodestring[jj] == '"'))
                              {
                              if(jj == 5)
                                 TDS_GE4_3letter += LongListInstances[entryindex];
                              else if(jj == 19)
                                 TDS_GE4_17letter += LongListInstances[entryindex];
                              }
                           else
                              {
                              if(jj == 3)
                                 TDS_GE4_3letter += LongListInstances[entryindex];
                              else if(jj == 17)
                                 TDS_GE4_17letter += LongListInstances[entryindex];
                              }
                           }
                        }

                     if(ATTRTYPE_TDS6() > 0)
                        {
                        sprintf(resultmessage,"%s (\"%s\")",enumcodestring,GetEELabel(EAC, enumcode));
                        CapturePortrayRuleValue(ECC,seeitgeom,EAC,resultmessage);
                        }
                     if(ATTRTYPE_ANY_TDS() > 0)  /*** will add to VVT counts for ?TDS in below loop ***/
                        {
                        if((strcmp(enumcodestring,"999") == 0) || (strcmp(enumcodestring,"other") == 0))
                                  /*** then have an enum value of "Other" ***/
                           {
                           AFOn = (struct AttrsForOTH *) (malloc(sizeof(struct AttrsForOTH)));
                           AFOn->acode = EAC;
                           AFOn->next = BadOTH.attrs;
                           BadOTH.attrs = AFOn;
                           }
                        }
                     AddToVVTcounts(ECC, seeitgeom, EAC, enumcodestring,shapefile, -999999.0, -999);
                     AddToVVT3Way(ECC, seeitgeom, EAC, enumcodestring,shapefile);
                     IncludeIntervalValues(EAC,-1.0,EEname);
                     AddToValueSets(ECC, (char) seeitgeom, EAC, EEname);
                     }
                  else if((ATTRTYPE_NFDD() > 0) || (ATTRTYPE_DFDD() > 0))
                     { /*** for NFDD and DFDD ****/
                     if(ATTRINSTYPE == 4)
                        {
                        AddToVVTcounts(ECC, seeitgeom, EAC, enumcodestring,shapefile, -999999.0, -999);
                        }
                     }

                  if((Ac != NULL) && (seeitgeom != C_GRID) &&
                       (ATTRTYPE_ANY_MGCP() > 0)) /*** MGCP  **/
                     {
                     Atemp = NGAmetaRoot->attr;
                     while(Atemp != NULL)
                        {
                        if(Atemp->codeindex == EAC)
                           break;
                        Atemp = Atemp->next;
                        }
                     if((Atemp != NULL) || (Ac->OptReq == 'M') || (Ac->OptReq == 'R'))
                        {
                        if((ATTRTYPE_MGCP3() > 0) && (strcmp(enumcodestring,"-32768") == 0))  /*** have a NULL value on MGCPv3 required attribute ****/
                           {
                           WriteTheError = 0;
                           if((ECC == TDSm1) || (ECC == TDSm2) || (ECC == TDSm3) || (ECC == TDSm4) || (ECC == TDSm5) || (ECC == TDSm6))
                              {
       sprintf(resultmessage,"Layer Identifier %s: Feature %s (%s): Attribute: %s (%s): Required attribute with Null value (%s) assigned\n",
                                shapefile, GetECCCode(ECC),GetECCLabel(ECC),
                               GetEACCode(EAC),GetEACLabel(EAC),enumcodestring);
                              InsertIntoGIFD_MetaData_ErrorList(resultmessage,entryindex);
                              }
                           else if(PrintSchemaCodes > 0)
                              {
       sprintf(resultmessage,"2%s Layer Identifier %s: Feature %s %s\n   Attribute: %s %s  Required attribute with Null value (%s) assigned\n",
                                ParseGAITgeometry((unsigned char) seeitgeom, 2),shapefile, GetECCCode(ECC),GetECCLabel(ECC),
                               GetEACCode(EAC),GetEACLabel(EAC),enumcodestring);
                              InsertIntoGIFD_AttrErrorList(resultmessage,entryindex);

sprintf(resultmessage,"2Attribute: %s (%s) (Null value assigned to required attribute)\n", GetEACCode(EAC),GetEACLabel(EAC));
useid = InsertIntoAttrErrorList(resultmessage,entryindex);
InsertIntoAttrIndexList(entryindex,useid);

                              sprintf(resultmessage,"2|%s|%d %d",
                                   GetEACLabel(EAC),ECC,EAC);
                              InsertIntoSummary_AttrErrorList(resultmessage,entryindex);

                              sprintf(resultmessage,"6 %d", EAC);
                              InsertIntoSummary_AttrErrorList(resultmessage,entryindex);
                              }
                           else
                              {
             sprintf(resultmessage,"2%s Layer Identifier %s: Feature %s\n   Attribute %s  Required attribute with Null value (%s) assigned\n",
                                      ParseGAITgeometry((unsigned char) seeitgeom, 2),shapefile, GetECCLabel(ECC),GetEACLabel(EAC),enumcodestring);
                              InsertIntoGIFD_AttrErrorList(resultmessage,entryindex);

sprintf(resultmessage,"2Attribute: %s (Null value assigned to required attribute)\n", GetEACCode(EAC));
useid = InsertIntoAttrErrorList(resultmessage,entryindex);
InsertIntoAttrIndexList(entryindex,useid);

                              sprintf(resultmessage,"2|%s|%d %d",
                                   GetEACLabel(EAC),ECC,EAC);
                              InsertIntoSummary_AttrErrorList(resultmessage,entryindex);

                              sprintf(resultmessage,"6 %d", EAC);
                              InsertIntoSummary_AttrErrorList(resultmessage,entryindex);
                              }
                           }
                        }
                     if(ATTRTYPE_MGCP3() > 0)
                        AddToVVTcounts(ECC, seeitgeom, EAC, enumcodestring,shapefile, -999999.0, -999);
                     }

                  if(Ac != NULL)
                     {
                     pc = Ac->picks;

                     while(pc != NULL)
                        {
                        if(strcmp(enumcodestring,pc->code) == 0)
                           break; 
                        pc = pc->next;
                        }
                     if(pc == NULL)
                        {
                        WriteTheError = 1;
                        if(UseNUNANPO > 0)
                           {
                           if(Ac->NGAdatatype == 2) /*** short int type ***/
                              {
                              if(strcmp(enumcodestring,"-32768") == 0)
                                 WriteTheError = 0;
                              else if (strcmp(enumcodestring,"0") == 0)
                                 WriteTheError = 0;
                              else if(strcmp(enumcodestring,"997") == 0)
                                 WriteTheError = 0;
                              else if(strcmp(enumcodestring,"998") == 0)
                                 WriteTheError = 0;
                              else if(strcmp(enumcodestring,"999") == 0)
                                 WriteTheError = 0;
                              else 
                                 WriteTheError = 1;
                              }
                           }
                        if((WriteTheError > 0) && (seeitgeom != C_GRID))
                           {
                           if((ECC == TDSm1) || (ECC == TDSm2) || (ECC == TDSm3) || (ECC == TDSm4) || (ECC == TDSm5) || (ECC == TDSm6))
                              {
                              sprintf(resultmessage,"Layer Identifier %s: Feature %s (%s): Attribute %s (%s): Value: %s %s Not Allowed\n",
                                shapefile,GetECCCode(ECC),
                                GetECCLabel(ECC),GetEACCode(EAC),GetEACLabel(EAC),enumcodestring,GetEELabel(EAC, enumcode));
                              InsertIntoGIFD_MetaData_ErrorList(resultmessage,entryindex);
                              }
                           else if(PrintSchemaCodes > 0)
                              {
                              sprintf(resultmessage,"4%s Layer Identifier %s: Feature %s %s\n     Attribute %s %s, Value: %s %s\n",
                                ParseGAITgeometry((unsigned char) seeitgeom, 2),shapefile,GetECCCode(ECC),
                                GetECCLabel(ECC),GetEACCode(EAC),GetEACLabel(EAC),enumcodestring,GetEELabel(EAC, enumcode));
                              InsertIntoGIFD_AttrErrorList(resultmessage,entryindex);

                              sprintf(resultmessage,"4Attribute: %s (%s), Value: %s %s\n",
                                           GetEACCode(EAC),GetEACLabel(EAC),enumcodestring,GetEELabel(EAC, enumcode));
                              useid = InsertIntoAttrErrorList(resultmessage,entryindex);
                              InsertIntoAttrIndexList(entryindex,useid);

                              sprintf(resultmessage,"4|%s|%s|%s|%s|%s|%d %d %d %d",
                                   GetECCCode(ECC),GetECCLabel(ECC),Ac->codeDomain,GetEACLabel(EAC),enumcodestring,ECC,seeitgeom,EAC,enumcode);
                              InsertIntoSummary_AttrErrorList(resultmessage,entryindex);

                              sprintf(resultmessage,"8 %d",EAC);
                              InsertIntoSummary_AttrErrorList(resultmessage,entryindex);
                              }
                           else
                              {
                              sprintf(resultmessage,"4%s Layer Identifier %s: Feature %s %s\n     Attribute %s %s, Value: %s %s\n",
                                ParseGAITgeometry((unsigned char) seeitgeom, 2),shapefile,GetECCCode(ECC),
                                GetECCLabel(ECC),GetEACCode(EAC),GetEACLabel(EAC),enumcodestring,GetEELabel(EAC, enumcode));
                              InsertIntoGIFD_AttrErrorList(resultmessage,entryindex);

                              sprintf(resultmessage,"4Attribute: %s, Value: %s %s\n", GetEACLabel(EAC),enumcodestring,GetEELabel(EAC, enumcode));
                              useid = InsertIntoAttrErrorList(resultmessage,entryindex);
                              InsertIntoAttrIndexList(entryindex,useid);

                              sprintf(resultmessage,"4|%s|%s|%s|%s|%s|%d %d %d %d",
                                   GetECCCode(ECC),GetECCLabel(ECC),Ac->codeDomain,GetEACLabel(EAC),enumcodestring,ECC,seeitgeom,EAC,enumcode);
                              InsertIntoSummary_AttrErrorList(resultmessage,entryindex);

                              sprintf(resultmessage,"8 %d",EAC);
                              InsertIntoSummary_AttrErrorList(resultmessage,entryindex);
                              }
                           }
                        }
                     }
                  break;
               case 4: /** metadata as int - stored & treated as an enum in spec file**/
                  SEEIT_fread_int(&MDcode,fileptr);
                  if(Ameta != NULL)
                     Ameta->intval = Idtvalue;
                  MDcode = 0 - MDcode;   /** use neg number as metadata flag in spec file ***/
                  break;
               }

            }
         else
            {

               SEEIT_fread_int(&numchar,fileptr);
               for(j=0; j<numchar; j++)
                  fread(&tshapefile[j],1,1,fileptr);
               tshapefile[j] = '\0';
               j = 0; /*** move forward to the first blank ***/
               while(j < numchar)
                  {
                  if(tshapefile[j] == ' ')
                     break;
                  ++j;
                  }
               ++j; /*** move forward to the second blank character  **/
               while(j < numchar)
                  {
                  if(tshapefile[j] == ' ')
                     break;
                  ++j;
                  }
               ++j;
               strcpy(shapefile,&tshapefile[j]);  /*** rest of tshapefile should be the layer identifier/name ***/

            }
         } /** end for number of attributes **/
      if(ngac != NULL) 
         {
         for(l=0; l<5; l++)
            {
            if(l == 0) Loop_code = ARA_code;
            else if(l == 1) Loop_code = HGT_code;
            else if(l == 2) Loop_code = ZV2_code;
            else if(l == 3) Loop_code = LEN_code;
            else if(l == 4)
              {
              if(ATTRTYPE_NFDD() > 0)
                 break;
              else
                 Loop_code = NAM_code;
              }

            if(Loop_code >= 0)
               {
               Ac = ngac->attr;
               while(Ac != NULL)
                  {
                  if(Ac->codeindex == Loop_code)
                     break;
                  Ac = Ac->next;
                  }

               counter = 0;
               for(i=0; i<LLtoIDmap[entryindex].count; i++)
                  {
                  if((i % 100000) == 0)
                     {
                     if(NGA_TYPE == 1)
                        {
                        PCdone = (NumDone * 100.0) / NumToCheck;
                        BuildOpenMenu(PCdone,SACfull_x_2,SACfull_x_2,linears_done, areals_done,model_polys,areals_done,
                                   linears_done,points_done,sphere_cv,parallel_cv,stamps_done,
                                   footprints_done, bridges_done,g_read,g_write,
                                FMpointsdone,FMlinesdone,FMarealsdone,100.0,100.0,100.0,0.0, 0);
                        }
                     }
                  if(LLtoIDmap[entryindex].IDentries[i] >= 0)
                     {
                     if(Loop_code == ARA_code)
                        {
                        if((ATTRTYPE_MGCP4() > 0) ||(ATTRTYPE_UFD1() > 0) ||
                              (ATTRTYPE_UFD2() > 0) || (ATTRTYPE_UFD3() > 0))
                           kjunk = NOTYPE;
                        else
                           kjunk = GetLongAttrVal(LONG_ATTR_AREA,LLtoIDmap[entryindex].IDentries[i],
                                   &ijunk,&djunk,&resultmessage[0]);
                        }
                     else if(Loop_code == HGT_code)
                        {
                        kjunk = GetLongAttrVal(LONG_ATTR_HGT,LLtoIDmap[entryindex].IDentries[i],
                                   &ijunk,&djunk,&resultmessage[0]);
                        }
                     else if(Loop_code == ZV2_code)
                        {
                        if(ATTRTYPE_ANY_MGCP() > 0)
                           kjunk = NOTYPE;
                        else
                           kjunk = GetLongAttrVal(LONG_ATTR_ZV2,LLtoIDmap[entryindex].IDentries[i],
                                   &ijunk,&djunk,&resultmessage[0]);
                        if(ATTRTYPE_SAC() > 0)
                           {
                           if(kjunk == D_TYPE)
                              AddToSACconversions(ZV2_code, djunk);
                           else if(kjunk == I_TYPE)
                              AddToSACconversions(ZV2_code, (double) ijunk);
                           }
                        }
                     else if(Loop_code == NAM_code)
                        {
                        if((ATTRTYPE_NFDD() > 0) || (ATTRTYPE_SAC() > 0))
                           kjunk = NOTYPE;
                        else
                           {
                           kjunk = GetLongAttrVal(LONG_ATTR_NAM,LLtoIDmap[entryindex].IDentries[i],
                                   &ijunk,&djunk,&enumcodestring[0]);
                           resultmessage[0] = '"';
                           resultmessage[1] = '\0';
                           strcat(resultmessage,enumcodestring);
                           strcat(resultmessage,"\"");
                           }
                        }
                     else if(Loop_code == LEN_code)
                        kjunk = GetLongAttrVal(LONG_ATTR_LEN,LLtoIDmap[entryindex].IDentries[i],
                                   &ijunk,&djunk,&resultmessage[0]);
                     if(kjunk != NOTYPE)
                        {
if((TDS_HGT >= 0) && (Loop_code == HGT_code) && (kjunk == D_TYPE))
   { 

   if(djunk >45.0)
      {
      AddToVVTcounts(ECC, seeitgeom, TDS_HGT, NULL, shapefile, djunk,LLtoIDmap[entryindex].IDentries[i]);
      }
   }
   

                        ++counter;
                           if(kjunk == C_TYPE)
                              {
                              if(IsJunkValue(2,-1312452,-1312452,resultmessage,-1312452,NULL) > 0)
                                 {
                                 sprintf(EACname,"w|%s|%d|%s|%d|%d",GetEACCode(Loop_code),Loop_code,resultmessage,ECC,seeitgeom);
                                 InsertIntoSummary_AttrErrorList(EACname,-1);
                                 }
                              Ac = ngac->attr;
                              while(Ac != NULL)
                                 {
                                 if(Ac->codeindex == Loop_code)
                                    break;
                                 Ac = Ac->next;
                                 }
                              if(Ac != NULL)
                                 {
                                 jjunk = strlen(resultmessage);
                                 if((resultmessage[0] == '"') && (resultmessage[jjunk-1] == '"'))
                                    jjunk -= 2;
                                 if(((Ac->MinValPresent > 0) && (jjunk < Ac->minval)) ||
                                      ((Ac->MaxValPresent > 0) && (jjunk > Ac->maxval)))
                                    {
                                    if((int)strlen(resultmessage) >= tlimittest)
                                       {
                                       tlimit = strlen(resultmessage) + 10;
                                       tlimittest = tlimit - 10;
                                       titlechar = (char *) (realloc(titlechar,tlimit));
                                       if(titlechar == NULL)
                                          {
                                           printf("all available memory has been used\n  processing cannot continue\n");
                                           exit(-1);
                                          }
                                       }


                                    strcpy(titlechar,resultmessage);
                              sprintf(resultmessage,"3%s Layer Identifier %s: Feature %s: %s\n   Attribute: %s %s\n     Value: %s (%d characters, expected %d to %d characters)\n",
                                ParseGAITgeometry((unsigned char) seeitgeom, 2),shapefile,GetECCCode(ECC),
                                GetECCLabel(ECC),GetEACCode(Loop_code),GetEACLabel(Loop_code),titlechar, jjunk,(int) Ac->minval, (int) Ac->maxval);
                              InsertIntoGIFD_AttrErrorList(resultmessage,entryindex);
                              sprintf(resultmessage,"3Value of attribute %s (%s): %s (%d characters, expected %d - %d characters)\n",
                                    GetEACCode(Loop_code),GetEACLabel(Loop_code),titlechar, jjunk, (int) Ac->minval, (int) Ac->maxval);
                              useid = InsertIntoAttrErrorList(resultmessage,entryindex);
                              InsertIntoAttrIndexList(entryindex,useid);

                              sprintf(resultmessage,"3|%s|%s (string value: %s)|%lf %lf %lf %d %d",
                                   GetEACCode(Loop_code),GetEACLabel(Loop_code),titlechar,(double) jjunk,Ac->minval,Ac->maxval,ECC,Loop_code);
                              InsertIntoSummary_AttrErrorList(resultmessage,entryindex);

                              sprintf(resultmessage,"7 %d", Loop_code);
                              InsertIntoSummary_AttrErrorList(resultmessage,entryindex);
                                    }
                                 }
                              }
                           else
                              {
                              if(kjunk == I_TYPE)
                                 Fdtvalue = (double) ijunk;
                              else if(kjunk == D_TYPE)
                                 Fdtvalue = djunk;
                              if(IsJunkValue(1,-1312452,Fdtvalue,NULL,-1312452,NULL) > 0)
                                 {
                                 sprintf(resultmessage,"w|%s|%d|%lf|%d|%d",GetEACCode(Loop_code),Loop_code,Fdtvalue,ECC,seeitgeom);
                                 InsertIntoSummary_AttrErrorList(resultmessage,-1);
                                 }
                              }
                        }
                     if((kjunk != NOTYPE) && (Ac != NULL))  /** then expected this attribute & found it - is there a range violation?  ****/
                        {
                        if((Ac->MinValPresent > 0) || (Ac->MaxValPresent > 0))
                           {
                           if(kjunk == I_TYPE)
                              Fdtvalue = (double) ijunk;
                           else if(kjunk == D_TYPE)
                              Fdtvalue = djunk;
                           else if(kjunk == C_TYPE) /** a string type value???   ***/
                              {
                              if(Loop_code != NAM_code)
                                 sscanf(resultmessage,"%lf",&Fdtvalue);
                              else
                                 {
                                 si = strlen(resultmessage);
                                 Fdtvalue = (double) si;
                                 --si;
                                 if((resultmessage[0] == '"') && (resultmessage[si] == '"'))
                                    Fdtvalue -= 2;
                                 }
                              }
                           WriteTheError = 1;
                           if(UseNUNANPO > 0)
                              {
                              if((Fdtvalue >= -32768) && (Fdtvalue <= -32764))
                                 WriteTheError = 0;
                              }
                           else if(ATTRTYPE_MGCP3() > 0)
                              {
                              if(((Ac->MinValPresent > 0) && (0 >= Ac->minval)) ||
                                     ((Ac->MaxValPresent > 0) && (0 <= Ac->maxval)))
                                 {
                                 if((AlmostTheSameValue(Fdtvalue,-32764.0) == 1) ||
                                  (AlmostTheSameValue(Fdtvalue,-32765.0) == 1) ||
                                  (AlmostTheSameValue(Fdtvalue,-32768.0) == 1) ||
                                  (AlmostTheSameValue(Fdtvalue,-32767.0) == 1))
                                    {
                                    WriteTheError = 0;
                                    }
                                 }
                              else if((Fdtvalue == 0) || (Fdtvalue == -32768))
                                 WriteTheError = 0;
                              }
                           else if(ATTRTYPE_MGCP4() > 0) /*** MGCP4 ***/
                              {
                              if((AlmostTheSameValue(Fdtvalue,-32764.0) == 1) ||
                               (AlmostTheSameValue(Fdtvalue,-32765.0) == 1) ||
                               (AlmostTheSameValue(Fdtvalue,-32768.0) == 1) ||
                               (AlmostTheSameValue(Fdtvalue,-32767.0) == 1))
                                 {
                                 WriteTheError = 0;
                                 }
                              }

                           else if((ATTRTYPE_ANY_TDS() > 0)  ||
                                           (ATTRTYPE_ANY_GGDM() > 0)) /** GGDM ***/
                              {
                              if(Fdtvalue == -999999.0)
                                 WriteTheError = 0;
                              }
                           else if(ATTRTYPE_SAC() > 0) /*** sac ****/
                              {
                              sprintf(DoubleAsString,"%.1lf",Fdtvalue);
                              strcpy(resultmessage,ParseGAITgeometry((unsigned char) seeitgeom, 0));

                              if(IsNUNANPO_OK_for_SAC(GetECCCode(ECC), GetEACCode(Loop_code), resultmessage[0], DoubleAsString) > 0)
                                 WriteTheError = 0;
                              }
                           if(WriteTheError > 0)
                              {
                              WriteTheError = 0;
                              if((Ac->MinValPresent > 0) && (Fdtvalue < Ac->minval))
                                 WriteTheError = 1;
                              if((Ac->MaxValPresent > 0) && (Fdtvalue > Ac->maxval))
                                 WriteTheError = 1;
                              if(WriteTheError > 0)
                                 {
                                 strcpy(MinString,"(Unbounded)");
                                 strcpy(MaxString,"(Unbounded)");
                                 if(Ac->MinValPresent > 0)
                                    {
                                    if(Ac->MinOpen == 1)
                                       sprintf(MinString,">%.5lf",Ac->minval);
                                    else
                                       sprintf(MinString,">=%.5lf",Ac->minval);
                                    }
                                 if(Ac->MaxValPresent > 0)
                                    {
                                    if(Ac->MaxOpen == 1)
                                       sprintf(MaxString,"<%.5lf",Ac->maxval);
                                    else
                                       sprintf(MaxString,"<=%.5lf",Ac->maxval);
                                    }

                                 if((ECC == TDSm1) || (ECC == TDSm2) || (ECC == TDSm3) || (ECC == TDSm4) || (ECC == TDSm5) || (ECC == TDSm6))
                                    {
                                    sprintf(resultmessage,"Layer Identifier %s: Feature %s (%s): Attribute: %s (%s): Value: %lf (expected range %s to %s)\n",
                                      shapefile,GetECCCode(ECC),
                                      GetECCLabel(ECC),GetEACCode(Loop_code),GetEACLabel(Loop_code),Fdtvalue, MinString, MaxString);
                                    InsertIntoGIFD_MetaData_ErrorList(resultmessage,entryindex);
                                    }
                                 else if(PrintSchemaCodes > 0)
                                    {
                                    sprintf(resultmessage,"3%s Layer Identifier %s: Feature %s: %s\n   Attribute: %s %s\n     Value: %lf (expected range %s to %s)\n",
                                      ParseGAITgeometry((unsigned char) seeitgeom, 2),shapefile,GetECCCode(ECC),
                                      GetECCLabel(ECC),GetEACCode(Loop_code),GetEACLabel(Loop_code),Fdtvalue, MinString, MaxString);
                                    InsertIntoSpecial_GIFD_AttrErrorList(resultmessage,entryindex);
                                    sprintf(resultmessage,"3Value of attribute %s (%s): %lf (expected range %s - %s)\n",
                                        GetEACCode(Loop_code),GetEACLabel(Loop_code),Fdtvalue, MinString, MaxString);
                                    useid = InsertIntoAttrErrorList(resultmessage,-1);
                                    InsertIntoAttrIndexList(entryindex,useid);

                                    sprintf(resultmessage,"3|%s|%s|%lf %d %d %d %d",
                                      GetEACCode(Loop_code),GetEACLabel(Loop_code),Fdtvalue,(int) (Ac->minval),(int) (Ac->maxval),ECC,Loop_code);
                                    InsertIntoSummary_AttrErrorList(resultmessage,-1);
   
                                    sprintf(resultmessage,"7 %d", Loop_code);
                                    InsertIntoSummary_AttrErrorList(resultmessage,-1);
                                    }
                                 else
                                    {
                                    sprintf(resultmessage,"3%s Layer Identifier %s: Feature %s:\n   Attribute: %s\n     Value: %lf (expected range %s to %s)\n",
                                      ParseGAITgeometry((unsigned char) seeitgeom, 2),shapefile,
                                      GetECCLabel(ECC),GetEACLabel(Loop_code),Fdtvalue, MinString, MaxString);
                                    InsertIntoSpecial_GIFD_AttrErrorList(resultmessage,entryindex);
                                    sprintf(resultmessage,"3Value of attribute %s: %lf (expected range %s to %s)\n",
                                        GetEACLabel(Loop_code),Fdtvalue, MinString, MaxString);
                                    useid = InsertIntoAttrErrorList(resultmessage,-1);
                                    InsertIntoAttrIndexList(entryindex,useid);

                                    sprintf(resultmessage,"3|%s|%s|%lf %d %d %d %d",
                                      GetEACCode(Loop_code),GetEACLabel(Loop_code),Fdtvalue,(int) (Ac->minval),(int) (Ac->maxval),ECC,Loop_code);
                                    InsertIntoSummary_AttrErrorList(resultmessage,-1);

                                    sprintf(resultmessage,"7 %d", Loop_code);
                                    InsertIntoSummary_AttrErrorList(resultmessage,-1);
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               if(counter > 0)  /*** then found 1 or more long value list attributes for this Lindex  ***/
                  {
                  if(Ac == NULL)   /*** then we have an unexpected attribute *****/
                  {
                     counter = 0 - counter;   /** make it negative so doesn't appear to be an Lindex below ***/
                     if((ECC == TDSm1) || (ECC == TDSm2) || (ECC == TDSm3) || (ECC == TDSm4) || (ECC == TDSm5) || (ECC == TDSm6))
                        {
                        sprintf(resultmessage,"Layer Identifier %s: Feature %s (%s): Attribute %s (%s): Attribute not designated for use with this feature type\n",
                             shapefile,GetECCCode(ECC),
                             GetECCLabel(ECC),GetEACCode(Loop_code),GetEACLabel(Loop_code));
                        InsertIntoGIFD_MetaData_ErrorList(resultmessage,entryindex);
                        }
                     else if(PrintSchemaCodes > 0)
                        {
                        sprintf(resultmessage,"1%s Layer Identifier %s: Feature %s %s\n   Assigned Attribute %s %s\n",
                             ParseGAITgeometry((unsigned char) seeitgeom, 2), shapefile,GetECCCode(ECC),
                             GetECCLabel(ECC),GetEACCode(Loop_code),GetEACLabel(Loop_code));
                        InsertIntoGIFD_AttrErrorList(resultmessage,counter);

                        sprintf(resultmessage,"1Assigned Attribute: %s (%s)\n", GetEACCode(Loop_code),GetEACLabel(Loop_code));
                        useid = InsertIntoAttrErrorList(resultmessage,counter);
                        InsertIntoAttrIndexList(entryindex,useid);

                        sprintf(resultmessage,"1|%s|%s|%s|%d %d %d",GetECCCode(ECC),GetECCLabel(ECC),GetEACLabel(Loop_code),ECC,Loop_code,seeitgeom);
                        InsertIntoSummary_AttrErrorList(resultmessage,counter);

                        if(Loop_code < 10)
                           sprintf(resultmessage,"5 000%d",Loop_code);
                        else if(Loop_code < 100)
                           sprintf(resultmessage,"5 00%d",Loop_code);
                        else if(Loop_code < 1000)
                           sprintf(resultmessage,"5 0%d",Loop_code);
                        else
                           sprintf(resultmessage,"5 %d",Loop_code);

                        InsertIntoSummary_AttrErrorList(resultmessage,counter);
                        }
                     else
                        {
                        sprintf(resultmessage,"1%s Layer Identifier %s: Feature %s\n   Assigned Attribute %s\n",
                             ParseGAITgeometry((unsigned char) seeitgeom, 2), shapefile,GetECCLabel(ECC),GetEACLabel(Loop_code));
                        InsertIntoGIFD_AttrErrorList(resultmessage,counter);
   
                        sprintf(resultmessage,"1Assigned Attribute - %s\n", GetEACLabel(Loop_code));
                        useid = InsertIntoAttrErrorList(resultmessage,counter);
                        InsertIntoAttrIndexList(entryindex,useid);

                        sprintf(resultmessage,"1|%s|%s|%s|%d %d %d",GetECCCode(ECC),GetECCLabel(ECC),GetEACLabel(Loop_code),ECC,Loop_code,seeitgeom);
                        InsertIntoSummary_AttrErrorList(resultmessage,counter);

                        if(Loop_code < 10)
                           sprintf(resultmessage,"5 000%d",Loop_code);
                        else if(Loop_code < 100)
                           sprintf(resultmessage,"5 00%d",Loop_code);
                        else if(Loop_code < 1000)
                           sprintf(resultmessage,"5 0%d",Loop_code);
                        else
                           sprintf(resultmessage,"5 %d",Loop_code);

                        InsertIntoSummary_AttrErrorList(resultmessage,counter);
                        }
                     }
                  }
               }
            }
         }
      if((ATTRTYPE_MGCP4() > 0) || (ATTRTYPE_TDS6() > 0))
         {
         counter = 0;
         LTDS4_Road_Index = GetCodeIndex("AP030");
         for(i=0; i<LLtoIDmap[entryindex].count; i++)
            {
            if(LLtoIDmap[entryindex].IDentries[i] >= 0)
               {
               kjunk = GetLongAttrVal(LONG_ATTR_HGT,LLtoIDmap[entryindex].IDentries[i],
                          &ijunk,&djunk,&resultmessage[0]);
               if((kjunk == D_TYPE) || (kjunk == I_TYPE))
                  {  
                  ++counter;
                  if(kjunk == I_TYPE)
                     sprintf(resultmessage,"%.0lf",(double) ijunk);
                  else if(kjunk == D_TYPE)
                     sprintf(resultmessage,"%.1lf",djunk);
                  CapturePortrayRuleValue(ECC,seeitgeom,TDS_HGT,resultmessage);
                  ijunk = EvaluatePortrayResult(ECC,seeitgeom,portrayreport,LTDS4_Road_Index,-1);
                  if((ijunk < 1) && (portrayfails != NULL))
                     {
                     SEEIT_fwrite_int(&entryindex,portrayfails);
                     SEEIT_fwrite_int(&LLtoIDmap[entryindex].IDentries[i],portrayfails);
                     }
                  }  
               }
            }
         if(counter == 0) /** did not find any HGT attr values at all ***/
            {
            ijunk = EvaluatePortrayResult(ECC,seeitgeom,portrayreport,LTDS4_Road_Index,entryindex);
            if((ijunk < 1) && (portrayfails != NULL))
               {
               counter = -1;
               SEEIT_fwrite_int(&entryindex,portrayfails);
               SEEIT_fwrite_int(&counter,portrayfails);
               }
            }
         ResetPortrayRuleValues(ECC, seeitgeom);
         }

      if(ATTRTYPE_SAC() > 0) /*** SAC **/
         {
         for(jjunk=0; jjunk<LLtoIDmap[entryindex].count; jjunk++)
            {
            kjunk = GetLongAttrVal(LONG_ATTR_LEN,LLtoIDmap[entryindex].IDentries[jjunk],
                                   &ijunk,&djunk,&resultmessage[0]);
            if(kjunk == D_TYPE)
               {
               SAC_CONV[2].val2 = djunk;
               SAC_CONV[2].foundboth += 1;
               break;
               }
            }
         for(ijunk=0; ijunk < 6; ijunk++)
            {
            if(TestSACconversions(ijunk) == 0)
               {
               if(PrintSchemaCodes > 0)
                  {
                  sprintf(resultmessage,
          "x%s Layer Identifier %s: Feature %s %s\n   Attribute %s %s, Value %lf assigned with Attribute: %s (%s) Value %lf\n",
                    ParseGAITgeometry((unsigned char) seeitgeom, 2),shapefile,GetECCCode(ECC),
                    GetECCLabel(ECC),GetEACCode(SAC_CONV[ijunk].acode1),
                    GetEACLabel(SAC_CONV[ijunk].acode1),SAC_CONV[ijunk].val1,
                     GetEACCode(SAC_CONV[ijunk].acode2),GetEACLabel(SAC_CONV[ijunk].acode2),SAC_CONV[ijunk].val2);
                   }
               else
                  {
                  sprintf(resultmessage,
                     "x%s Layer Identifier %s: Feature %s\n   Attribute %s, Value %lf assigned with Attribute: %s Value %lf\n",
                    ParseGAITgeometry((unsigned char) seeitgeom, 2),shapefile,
                    GetECCLabel(ECC), GetEACLabel(SAC_CONV[ijunk].acode1),SAC_CONV[ijunk].val1,
                           GetEACLabel(SAC_CONV[ijunk].acode2),SAC_CONV[ijunk].val2);
                  }
               InsertIntoGIFD_AttrErrorList(resultmessage,entryindex);
               sprintf(resultmessage,"xAttribute: %s, Value: %lf with Attribute: %s Value: %lf\n",
                    GetEACLabel(SAC_CONV[ijunk].acode1),SAC_CONV[ijunk].val1,
                             GetEACLabel(SAC_CONV[ijunk].acode2),SAC_CONV[ijunk].val2);

               useid = InsertIntoAttrErrorList(resultmessage,entryindex);
               InsertIntoAttrIndexList(entryindex,useid);

               sprintf(resultmessage,"x|%s|%s|%s|%s|%s|%lf|%s|%s|%lf\n",
                   GetECCCode(ECC),GetECCLabel(ECC),ParseGAITgeometry((unsigned char) seeitgeom, 2),
                   GetEACCode(SAC_CONV[ijunk].acode1),GetEACLabel(SAC_CONV[ijunk].acode1),SAC_CONV[ijunk].val1,
                   GetEACCode(SAC_CONV[ijunk].acode2),GetEACLabel(SAC_CONV[ijunk].acode2),SAC_CONV[ijunk].val2);

               InsertIntoSummary_AttrErrorList(resultmessage,entryindex);

               sprintf(resultmessage,"X %d %d",SAC_CONV[ijunk].acode1,SAC_CONV[ijunk].acode2);

               InsertIntoSummary_AttrErrorList(resultmessage,entryindex);
               }
            }
         ResetSACconversions();
         }


      if((ATTRTYPE_MGCP4() > 0) || (ATTRTYPE_TDS6() > 0))
         {
         resetNFI = resetNFN = 0;
         for(jjunk=0; jjunk<LLtoIDmap[entryindex].count; jjunk++)
            {
            strcpy(resultmessage,"UNK");
            if(resetNFI > 0)
               {
               MGCP_NFI_str[0] = '\0';
               resetNFI = 0;
               }
            if(resetNFN > 0)
               {
               MGCP_NFN_str[0] = '\0';
               resetNFN = 0;
               }
            kjunk = GetLongAttrVal(LONG_ATTR_NAM,LLtoIDmap[entryindex].IDentries[jjunk],
                                   &ijunk,&djunk, resultmessage);
            if((ECC == MGCP_Heliport_index) || (ECC ==  MGCP_Runway_index) ||
                  (ECC ==  MGCP_L_Aerodrome_index) || (ECC == MGCP_W_Aerodrome_index))
               {
               if(MGCP_NFI_str[0] == '\0')
                  {
                  resetNFI = 1;
                  strcpy(MGCP_NFI_str,"NFI not assigned");
                  }
               if(MGCP_NFN_str[0] == '\0')
                  {
                  resetNFN = 1;
                  strcpy(MGCP_NFN_str,"NFN not assigned");
                  }
               }
            else if((strcmp(resultmessage,"UNK") != 0) && (strcmp(resultmessage,"NULL string found") != 0))
               {
               if(MGCP_NFI_str[0] == '\0')
                  {
                  resetNFI = 1;
                  strcpy(MGCP_NFI_str,"NFI not assigned");
                  }
               if(MGCP_NFN_str[0] == '\0')
                  {
                  resetNFN = 1;
                  strcpy(MGCP_NFN_str,"NFN not assigned");
                  }
               }

            if((kjunk == C_TYPE) && (MGCP_NFI_str[0] != '\0') && (MGCP_NFN_str[0] != '\0'))
               {
               ni = nj = 0;
               while(resultmessage[ni] != '\0')
                  {
                  if((unsigned char) resultmessage[ni] >= ' ')
                     {
                     tempstring[nj] = resultmessage[ni];
                     ++nj;
                     tempstring[nj] = '\0';
                     }
                  else
                     {
                     tempstring[nj] = '<'; ++nj;
                     tempstring[nj] = 's'; ++nj;
                     tempstring[nj] = 'p'; ++nj;
                     tempstring[nj] = 'e'; ++nj;
                     tempstring[nj] = 'c'; ++nj;
                     tempstring[nj] = ' '; ++nj;
                     tempstring[nj] = 'c'; ++nj;
                     tempstring[nj] = 'h'; ++nj;
                     tempstring[nj] = 'a'; ++nj;
                     tempstring[nj] = 'r'; ++nj;
                     tempstring[nj] = '>'; ++nj;
                     tempstring[nj] = '\0';
                     }
                  ++ni;
                  }
               strcpy(resultmessage,tempstring);
sprintf(tempstring,"%d_%s",ECC,resultmessage);
               strcat( tempstring,MGCP_NFI_str);
               strcat( tempstring,MGCP_NFN_str);
               if(strncmp( resultmessage,"UNK",3) == 0)  /*** use UNKroot ***/
                  {
                  if(UNKroot == NULL)
                     {
                     NNn = (struct N_N_N *) (malloc(SzNNN));
                     NNn->NAMstr = (char *) (malloc(strlen(resultmessage) + 1));
                     strcpy( NNn->NAMstr, resultmessage);
                     NNn->NFIstr =  (malloc(strlen(MGCP_NFI_str) + 1));
                     strcpy(NNn->NFIstr,MGCP_NFI_str);
                     NNn->NFNstr =  (malloc(strlen(MGCP_NFN_str) + 1));
                     strcpy(NNn->NFNstr,MGCP_NFN_str);
NNn->NNNstr = (char *) (malloc(strlen(tempstring) + 1));
strcpy( NNn->NNNstr, tempstring);
                     NNn->count = 1;
                     NNn->next = NULL;
                     UNKroot = NNn;
                     NNtemp = NULL;
                     }
                  else
                     NNtemp = UNKroot;
                  }
               else /*** working with real names ***/
                  {
                  if(NNNroot == NULL)
                     {
                     NNn = (struct N_N_N *) (malloc(SzNNN));
                     NNn->NAMstr = (char *) (malloc(strlen(resultmessage) + 1));
                     strcpy( NNn->NAMstr, resultmessage);
                     NNn->NFIstr =  (malloc(strlen(MGCP_NFI_str) + 1));
                     strcpy(NNn->NFIstr,MGCP_NFI_str);
                     NNn->NFNstr =  (malloc(strlen(MGCP_NFN_str) + 1));
                     strcpy(NNn->NFNstr,MGCP_NFN_str);
NNn->NNNstr = (char *) (malloc(strlen(tempstring) + 1));
strcpy( NNn->NNNstr, tempstring);
                     NNn->count = 1;
                     NNn->next = NULL;
                     NNNroot = NNn;
                     NNtemp = NULL;
                     }
                  else
                     NNtemp = NNNroot;
                  }
               NNc = NNp = NNtemp;
               while(NNc != NULL)
                  {
                  unusedint = strcmp( NNc->NNNstr, tempstring);
                  if(unusedint > 0)
                     {
                     NNn = (struct N_N_N *) (malloc(SzNNN));
                     NNn->NAMstr = (char *) (malloc(strlen(resultmessage) + 1));
                     strcpy( NNn->NAMstr, resultmessage);
                     NNn->NFIstr =  (malloc(strlen(MGCP_NFI_str) + 1));
                     strcpy(NNn->NFIstr,MGCP_NFI_str);
                     NNn->NFNstr =  (malloc(strlen(MGCP_NFN_str) + 1));
                     strcpy(NNn->NFNstr,MGCP_NFN_str);
NNn->NNNstr = (char *) (malloc(strlen(tempstring) + 1));
strcpy( NNn->NNNstr, tempstring);
                     NNn->count = 1;
                     NNn->next = NNc;
                     if(NNc == NNtemp)
                        {
                        if(NNtemp == NNNroot)
                           NNNroot = NNn;
                        else
                           UNKroot = NNn;
                        }
                     else
                        NNp->next = NNn;
                     break;
                     }
                  else if(unusedint == 0)
                     {
                     NNc->count += 1;
                     break;
                     }
                  NNp = NNc;
                  NNc = NNc->next;
                  if(NNc == NULL)
                     {
                     NNn = (struct N_N_N *) (malloc(SzNNN));
                     NNn->NAMstr = (char *) (malloc(strlen(resultmessage) + 1));
                     strcpy( NNn->NAMstr,resultmessage);
                     NNn->NFIstr =  (malloc(strlen(MGCP_NFI_str) + 1));
                     strcpy(NNn->NFIstr,MGCP_NFI_str);
                     NNn->NFNstr =  (malloc(strlen(MGCP_NFN_str) + 1));
                     strcpy(NNn->NFNstr,MGCP_NFN_str);
NNn->NNNstr = (char *) (malloc(strlen(tempstring) + 1));
strcpy( NNn->NNNstr, tempstring);
                     NNn->count = 1;
                     NNn->next = NULL;
                     NNp->next = NNn;
                     break;
                     }
                  }
               }
            } /** end for jjunk **/
         } /*** end working with MGCP4 and NAME, NFI, NFN ***/



      if(ATTRTYPE_MGCP3() > 0) /*** MGCP3  **/
         {
         for(jjunk=0; jjunk<LLtoIDmap[entryindex].count; jjunk++)
            {
            kjunk = GetLongAttrVal(LONG_ATTR_NAM,LLtoIDmap[entryindex].IDentries[jjunk],
                                   &ijunk,&djunk,&resultmessage[0]);
            if(kjunk == C_TYPE)
               {
               strcpy(MGCP_NAM_str,"\"");
               strcat(MGCP_NAM_str,resultmessage);
               strcat(MGCP_NAM_str,"\"");
               //break;
               }
         if((kjunk == C_TYPE) && (strcmp(MGCP_NAM_str,"\"UNK\"") == 0))
            {
            if((MGCP_NFN_str[0] != '\0') && (strcmp(MGCP_NFN_str,"\"N_A\"") != 0))
               {
               if(PrintSchemaCodes > 0)
                  {
                  sprintf(resultmessage,
                    "x%s Layer Identifier %s: Feature %s %s:   Attribute %s %s, Value %s assigned with Attribute: %s (%s) Value %s\n",
                    ParseGAITgeometry((unsigned char) seeitgeom, 2),shapefile,GetECCCode(ECC),
                    GetECCLabel(ECC),GetEACCode(MGCP_NAM_index),
                    GetEACLabel(MGCP_NAM_index),MGCP_NAM_str,
                     GetEACCode(MGCP_NFN_index),GetEACLabel(MGCP_NFN_index),MGCP_NFN_str);
                  }
               else
                  {
                  sprintf(resultmessage,
                     "x%s Layer Identifier %s: Feature %s\n   Attribute %s, Value %s assigned with Attribute: %s Value %s\n",
                    ParseGAITgeometry((unsigned char) seeitgeom, 2),shapefile,
                    GetECCLabel(ECC), GetEACLabel(MGCP_NAM_index),MGCP_NAM_str, GetEACLabel(MGCP_NFN_index),MGCP_NFN_str);
                  }
               InsertIntoGIFD_AttrErrorList(resultmessage,-1); //entryindex);
               sprintf(resultmessage,"xAttribute: %s, Value: %s with Attribute: %s Value: %s\n",
                    GetEACLabel(MGCP_NAM_index),MGCP_NAM_str, GetEACLabel(MGCP_NFN_index),MGCP_NFN_str);

               useid = InsertIntoAttrErrorList(resultmessage,-1); //entryindex);
               InsertIntoAttrIndexList(entryindex,useid);

               sprintf(resultmessage,"x|%s|%s|%s|%s|%s|%s|%s|%s|%s\n",
                   GetECCCode(ECC),GetECCLabel(ECC),ParseGAITgeometry((unsigned char) seeitgeom, 2),
                   GetEACCode(MGCP_NAM_index),GetEACLabel(MGCP_NAM_index),MGCP_NAM_str,
                   GetEACCode(MGCP_NFN_index),GetEACLabel(MGCP_NFN_index),MGCP_NFN_str);

               InsertIntoSummary_AttrErrorList(resultmessage,-1); //entryindex);

               sprintf(resultmessage,"X %d %d",MGCP_NAM_index,MGCP_NFN_index);

               InsertIntoSummary_AttrErrorList(resultmessage,-1); //entryindex);
               }
            if((MGCP_NFI_str[0] != '\0') && (strcmp(MGCP_NFI_str,"\"N_A\"") != 0))
               {
               if(PrintSchemaCodes > 0)
                  {
                  sprintf(resultmessage,
                    "x%s Layer Identifier %s: Feature %s %s\n   Attribute %s %s, Value %s assigned with Attribute: %s (%s) Value %s\n",
                    ParseGAITgeometry((unsigned char) seeitgeom, 2),shapefile,GetECCCode(ECC),
                    GetECCLabel(ECC),GetEACCode(MGCP_NAM_index),
                    GetEACLabel(MGCP_NAM_index),MGCP_NAM_str,
                     GetEACCode(MGCP_NFI_index),GetEACLabel(MGCP_NFI_index),MGCP_NFI_str);
                  }
               else
                  {
                  sprintf(resultmessage,
                     "x%s Layer Identifier %s: Feature %s\n   Attribute %s, Value %s assigned with Attribute: %s Value %s\n",
                    ParseGAITgeometry((unsigned char) seeitgeom, 2),shapefile,
                    GetECCLabel(ECC), GetEACLabel(MGCP_NAM_index),MGCP_NAM_str, GetEACLabel(MGCP_NFI_index),MGCP_NFI_str);
                  }
               InsertIntoGIFD_AttrErrorList(resultmessage,-1); //entryindex);
               sprintf(resultmessage,"xAttribute: %s, Value: %s with Attribute: %s Value: %s\n",
                   GetEACLabel(MGCP_NAM_index),MGCP_NAM_str, GetEACLabel(MGCP_NFI_index),MGCP_NFI_str);

               useid = InsertIntoAttrErrorList(resultmessage,-1); //entryindex);
               InsertIntoAttrIndexList(entryindex,useid);

               sprintf(resultmessage,"x|%s|%s|%s|%s|%s|%s|%s|%s|%s\n",
                   GetECCCode(ECC),GetECCLabel(ECC),ParseGAITgeometry((unsigned char) seeitgeom, 2),
                   GetEACCode(MGCP_NAM_index),GetEACLabel(MGCP_NAM_index),MGCP_NAM_str,
                   GetEACCode(MGCP_NFI_index),GetEACLabel(MGCP_NFI_index),MGCP_NFI_str);

               InsertIntoSummary_AttrErrorList(resultmessage,-1); //entryindex);

               sprintf(resultmessage,"X %d %d",MGCP_NAM_index,MGCP_NFI_index);

               InsertIntoSummary_AttrErrorList(resultmessage,-1); //entryindex);
               }
            }   /**** end check based on NAM is UNK ***/


         if((ATTRTYPE_MGCP3() > 0) && (strcmp(MGCP_NFN_str,"\"N_A\"") == 0))
            {
            if((kjunk == C_TYPE) && (MGCP_NAM_str[0] != '\0') && (strcmp(MGCP_NAM_str,"\"UNK\"") != 0))
               {
               if(PrintSchemaCodes > 0)
                  {
                  sprintf(resultmessage,
                    "x%s Layer Identifier %s: Feature %s %s\n   Attribute %s %s, Value %s assigned with Attribute: %s (%s) Value %s\n",
                    ParseGAITgeometry((unsigned char) seeitgeom, 2),shapefile,GetECCCode(ECC),
                    GetECCLabel(ECC),GetEACCode(MGCP_NFN_index),
                    GetEACLabel(MGCP_NFN_index),MGCP_NFN_str,
                     GetEACCode(MGCP_NAM_index),GetEACLabel(MGCP_NAM_index),MGCP_NAM_str);
                  }
               else
                  {
                  sprintf(resultmessage,
                     "x%s Layer Identifier %s: Feature %s\n   Attribute %s, Value %s assigned with Attribute: %s Value %s\n",
                    ParseGAITgeometry((unsigned char) seeitgeom, 2),shapefile,
                    GetECCLabel(ECC), GetEACLabel(MGCP_NFN_index),MGCP_NFN_str, GetEACLabel(MGCP_NAM_index),MGCP_NAM_str);
                  }
               InsertIntoGIFD_AttrErrorList(resultmessage,-1); //entryindex);
               sprintf(resultmessage,"xAttribute: %s, Value: %s with Attribute: %s Value: %s\n",
                    GetEACLabel(MGCP_NAM_index),MGCP_NAM_str, GetEACLabel(MGCP_NFN_index),MGCP_NFN_str);

               useid = InsertIntoAttrErrorList(resultmessage,-1); //entryindex);
               InsertIntoAttrIndexList(entryindex,useid);

               sprintf(resultmessage,"x|%s|%s|%s|%s|%s|%s|%s|%s|%s\n",
                   GetECCCode(ECC),GetECCLabel(ECC),ParseGAITgeometry((unsigned char) seeitgeom, 2),
                   GetEACCode(MGCP_NFN_index),GetEACLabel(MGCP_NFN_index),MGCP_NFN_str,
                   GetEACCode(MGCP_NAM_index),GetEACLabel(MGCP_NAM_index),MGCP_NAM_str);

               InsertIntoSummary_AttrErrorList(resultmessage,-1); //entryindex);

               sprintf(resultmessage,"X %d %d",MGCP_NAM_index,MGCP_NFN_index);

               InsertIntoSummary_AttrErrorList(resultmessage,-1); //entryindex);
               }
            if((jjunk == 0) && (MGCP_NFI_str[0] != '\0') && (strcmp(MGCP_NFI_str,"\"N_A\"") != 0))
               {
               if(PrintSchemaCodes > 0)
                  {
                  sprintf(resultmessage,
                    "x%s Layer Identifier %s: Feature %s %s\n   Attribute %s %s, Value %s assigned with Attribute: %s (%s) Value %s\n",
                    ParseGAITgeometry((unsigned char) seeitgeom, 2),shapefile,GetECCCode(ECC),
                    GetECCLabel(ECC),GetEACCode(MGCP_NFN_index),
                    GetEACLabel(MGCP_NFN_index),MGCP_NFN_str,
                     GetEACCode(MGCP_NFI_index),GetEACLabel(MGCP_NFI_index),MGCP_NFI_str);
                  }
               else
                  {
                  sprintf(resultmessage,
                     "x%s Layer Identifier %s: Feature %s\n   Attribute %s, Value %s assigned with Attribute: %s Value %s\n",
                    ParseGAITgeometry((unsigned char) seeitgeom, 2),shapefile,
                    GetECCLabel(ECC), GetEACLabel(MGCP_NFN_index),MGCP_NFN_str, GetEACLabel(MGCP_NFI_index),MGCP_NFI_str);
                  }
               InsertIntoGIFD_AttrErrorList(resultmessage,entryindex);
               sprintf(resultmessage,"xAttribute: %s, Value: %s with Attribute: %s Value: %s\n",
                    GetEACLabel(MGCP_NFN_index),MGCP_NFN_str, GetEACLabel(MGCP_NFI_index),MGCP_NFI_str);

               useid = InsertIntoAttrErrorList(resultmessage,entryindex);
               InsertIntoAttrIndexList(entryindex,useid);

               sprintf(resultmessage,"x|%s|%s|%s|%s|%s|%s|%s|%s|%s\n",
                   GetECCCode(ECC),GetECCLabel(ECC),ParseGAITgeometry((unsigned char) seeitgeom, 2),
                   GetEACCode(MGCP_NFN_index),GetEACLabel(MGCP_NFN_index),MGCP_NFN_str,
                   GetEACCode(MGCP_NFI_index),GetEACLabel(MGCP_NFI_index),MGCP_NFI_str);

               InsertIntoSummary_AttrErrorList(resultmessage,entryindex);

               sprintf(resultmessage,"X %d %d",MGCP_NFN_index,MGCP_NFI_index);

               InsertIntoSummary_AttrErrorList(resultmessage,entryindex);
               }
            }   /**** end check based on NFN is N_A ***/
         if(strcmp(MGCP_NFI_str,"\"N_A\"") == 0)
            {
            if((kjunk == C_TYPE) && (MGCP_NAM_str[0] != '\0') && (strcmp(MGCP_NAM_str,"\"UNK\"") != 0))
               {
               if(PrintSchemaCodes > 0)
                  {
                  sprintf(resultmessage,
                    "x%s Layer Identifier %s: Feature %s %s\n   Attribute %s %s, Value %s assigned with Attribute: %s (%s) Value %s\n",
                    ParseGAITgeometry((unsigned char) seeitgeom, 2),shapefile,GetECCCode(ECC),
                    GetECCLabel(ECC),GetEACCode(MGCP_NFI_index),
                    GetEACLabel(MGCP_NFI_index),MGCP_NFI_str,
                     GetEACCode(MGCP_NAM_index),GetEACLabel(MGCP_NAM_index),MGCP_NAM_str);
                  }
               else
                  {
                  sprintf(resultmessage,
                     "x%s Layer Identifier %s: Feature %s\n   Attribute %s, Value %s assigned with Attribute: %s Value %s\n",
                    ParseGAITgeometry((unsigned char) seeitgeom, 2),shapefile,
                    GetECCLabel(ECC), GetEACLabel(MGCP_NFI_index),MGCP_NFI_str, GetEACLabel(MGCP_NAM_index),MGCP_NAM_str);
                  }
               InsertIntoGIFD_AttrErrorList(resultmessage,-1); //entryindex);
               sprintf(resultmessage,"xAttribute: %s, Value: %s with Attribute: %s Value: %s\n",
                    GetEACLabel(MGCP_NAM_index),MGCP_NAM_str, GetEACLabel(MGCP_NFI_index),MGCP_NFI_str);

               useid = InsertIntoAttrErrorList(resultmessage,-1); //entryindex);
               InsertIntoAttrIndexList(entryindex,useid);

               sprintf(resultmessage,"x|%s|%s|%s|%s|%s|%s|%s|%s|%s\n",
                   GetECCCode(ECC),GetECCLabel(ECC),ParseGAITgeometry((unsigned char) seeitgeom, 2),
                   GetEACCode(MGCP_NFI_index),GetEACLabel(MGCP_NFI_index),MGCP_NFI_str,
                   GetEACCode(MGCP_NAM_index),GetEACLabel(MGCP_NAM_index),MGCP_NAM_str);

               InsertIntoSummary_AttrErrorList(resultmessage,-1); //entryindex);

               sprintf(resultmessage,"X %d %d",MGCP_NAM_index,MGCP_NFI_index);

               InsertIntoSummary_AttrErrorList(resultmessage,-1); //entryindex);
               }
            if((jjunk == 0) && (MGCP_NFN_str[0] != '\0') && (strcmp(MGCP_NFN_str,"\"N_A\"") != 0))
               {
               if(PrintSchemaCodes > 0)
                  {
                  sprintf(resultmessage,
                    "x%s Layer Identifier %s: Feature %s %s\n   Attribute %s %s, Value %s assigned with Attribute: %s (%s) Value %s\n",
                    ParseGAITgeometry((unsigned char) seeitgeom, 2),shapefile,GetECCCode(ECC),
                    GetECCLabel(ECC),GetEACCode(MGCP_NFI_index),
                    GetEACLabel(MGCP_NFI_index),MGCP_NFI_str,
                     GetEACCode(MGCP_NFN_index),GetEACLabel(MGCP_NFN_index),MGCP_NFN_str);
                  }
               else
                  {
                  sprintf(resultmessage,
                     "x%s Layer Identifier %s: Feature %s\n   Attribute %s, Value %s assigned with Attribute: %s Value %s\n",
                    ParseGAITgeometry((unsigned char) seeitgeom, 2),shapefile,
                    GetECCLabel(ECC), GetEACLabel(MGCP_NFI_index),MGCP_NFI_str, GetEACLabel(MGCP_NFN_index),MGCP_NFN_str);
                  }
               InsertIntoGIFD_AttrErrorList(resultmessage,entryindex);
               sprintf(resultmessage,"xAttribute: %s, Value: %s with Attribute: %s Value: %s\n",
                    GetEACLabel(MGCP_NFI_index),MGCP_NFI_str, GetEACLabel(MGCP_NFN_index),MGCP_NFN_str);

               useid = InsertIntoAttrErrorList(resultmessage,entryindex);
               InsertIntoAttrIndexList(entryindex,useid);

               sprintf(resultmessage,"x|%s|%s|%s|%s|%s|%s|%s|%s|%s\n",
                   GetECCCode(ECC),GetECCLabel(ECC),ParseGAITgeometry((unsigned char) seeitgeom, 2),
                   GetEACCode(MGCP_NFI_index),GetEACLabel(MGCP_NFI_index),MGCP_NFI_str,
                   GetEACCode(MGCP_NFN_index),GetEACLabel(MGCP_NFN_index),MGCP_NFN_str);

               InsertIntoSummary_AttrErrorList(resultmessage,entryindex);

               sprintf(resultmessage,"X %d %d",MGCP_NFN_index,MGCP_NFI_index);

               InsertIntoSummary_AttrErrorList(resultmessage,entryindex);
               }
            }   /**** end check based on NFN is N_A ***/
          } /** moved the for jjunk end of loop brace down to here to accomodate move of NAM to long attr val set ***/
         }
      if(MGCP_VVT_root != NULL)
         {
         MGCP_Vc = MGCP_VVT_root;
         while(MGCP_Vc != NULL)
            {
            if((MGCP_Vc->code == ECC) && (MGCP_Vc->geom == seeitgeom))
               break;
            MGCP_Vc = MGCP_Vc->next;
            }
         CheckIt = 1;
         if(ATTRTYPE_MGCP3() > 0) /*** all the special building constraints were deleted with MGCPv4, still exist in MGCPv3 **/
            {
            if(MGCP_Vc != NULL)
               {
               CheckIt = 2;
               MGCP_PPO_violation = 0;
               if(ECC == MGCP_BldgCode)
                  CheckIt = SpecialMGCP_BuildingRulesApply(MGCP_BldgCode, ECC, MGCP_Vc->geom, enumcodestring, &MGCP_PPO_violation);

               if(MGCP_PPO_violation > 0)
                  {
                  if(PrintSchemaCodes > 0)
                     {
                     sprintf(resultmessage,
                      "y%s Layer Identifier %s: Feature %s %s\n   PPO is applicable, AFC, ICF, and UUC are all 'Not Applicable' (998)\n",
                       ParseGAITgeometry((unsigned char) MGCP_Vc->geom, 2),MGCP_Vc->shapename,GetECCCode(MGCP_Vc->code),
                       GetECCLabel(MGCP_Vc->code));
                     InsertIntoGIFD_AttrErrorList(resultmessage,entryindex);

                     sprintf(resultmessage,"yPPO is applicable, AFC, ICF, and UUC are all 'Not Applicable' (998)\n");

                     useid = InsertIntoAttrErrorList(resultmessage,entryindex);
                     InsertIntoAttrIndexList(entryindex,useid);

                     sprintf(resultmessage,"y|%s|%s|%s| PPO is applicable, AFC, ICF, and UUC are all 'Not Applicable' (998)\n",
                         GetECCCode(MGCP_Vc->code),GetECCLabel(MGCP_Vc->code),ParseGAITgeometry((unsigned char) MGCP_Vc->geom, 2));

                     InsertIntoSummary_AttrErrorList(resultmessage,entryindex);

                     sprintf(resultmessage,"Y %d %d",MGCP_Vc->code,MGCP_Vc->geom);

                     InsertIntoSummary_AttrErrorList(resultmessage,entryindex);
                     }
                  else
                     {
                 sprintf(resultmessage,"y%s Layer Identifier %s: Feature %s\n   PPO is applicable, AFC, ICF, and UUC are all 'Not Applicable' (998)\n",
                        ParseGAITgeometry((unsigned char) MGCP_Vc->geom, 2),MGCP_Vc->shapename, GetECCLabel(MGCP_Vc->code));
                     InsertIntoGIFD_AttrErrorList(resultmessage,entryindex);

                     sprintf(resultmessage,"yPPO is applicable, AFC, ICF, and UUC are all 'Not Applicable' (998)\n");

                     useid = InsertIntoAttrErrorList(resultmessage,entryindex);
                     InsertIntoAttrIndexList(entryindex,useid);

                     sprintf(resultmessage,"y|%s|%s|%s| PPO is applicable, AFC, ICF, and UUC are all 'Not Applicable' (998)\n",
                         GetECCCode(MGCP_Vc->code),GetECCLabel(MGCP_Vc->code),ParseGAITgeometry((unsigned char) MGCP_Vc->geom, 2));

                     InsertIntoSummary_AttrErrorList(resultmessage,entryindex);

                     sprintf(resultmessage,"Y %d %d",ECC,MGCP_Vc->geom);

                     InsertIntoSummary_AttrErrorList(resultmessage,entryindex);
                     }
                  }


               if(CheckIt == -1) /** then no attrs apply ... at least one must be applicable ***/
                  {
                  if(PrintSchemaCodes > 0)
                     {
                     sprintf(resultmessage,"y%s Layer Identifier %s: Feature %s %s\n   All function type attributes are 998 ('Not Applicable') (%s)\n",
                       ParseGAITgeometry((unsigned char) MGCP_Vc->geom, 2),MGCP_Vc->shapename,GetECCCode(MGCP_Vc->code),
                       GetECCLabel(MGCP_Vc->code),enumcodestring);
                     InsertIntoGIFD_AttrErrorList(resultmessage,entryindex);

                     sprintf(resultmessage,"yAll function type attributes are 998 ('Not Applicable') (%s)\n",enumcodestring);

                     useid = InsertIntoAttrErrorList(resultmessage,entryindex);
                     InsertIntoAttrIndexList(entryindex,useid);

                     sprintf(resultmessage,"y|%s|%s|%s| all function type attributes are 998 ('Not Applicable')\n",
                         GetECCCode(MGCP_Vc->code),GetECCLabel(MGCP_Vc->code),ParseGAITgeometry((unsigned char) MGCP_Vc->geom, 2));

                     InsertIntoSummary_AttrErrorList(resultmessage,entryindex);

                     sprintf(resultmessage,"Y %d %d",MGCP_Vc->code,MGCP_Vc->geom);

                     InsertIntoSummary_AttrErrorList(resultmessage,entryindex);
                     }
                  else
                     {
                     sprintf(resultmessage,"y%s Layer Identifier %s: Feature %s\n   All function type attributes are 998 ('Not Applicable') (%s)\n",
                       ParseGAITgeometry((unsigned char) MGCP_Vc->geom, 2),MGCP_Vc->shapename, GetECCLabel(MGCP_Vc->code),enumcodestring);
                     InsertIntoGIFD_AttrErrorList(resultmessage,entryindex);

                     sprintf(resultmessage,"yAll function type attributes are 998 ('Not Applicable') (%s)\n",enumcodestring);

                     useid = InsertIntoAttrErrorList(resultmessage,entryindex);
                     InsertIntoAttrIndexList(entryindex,useid);

                     sprintf(resultmessage,"y|%s|%s|%s| all function type attributes (e.g. HWT, UUC, CIT, ...) are 998 ('Not Applicable)'\n",
                         GetECCCode(MGCP_Vc->code),GetECCLabel(MGCP_Vc->code),ParseGAITgeometry((unsigned char) MGCP_Vc->geom, 2));

                     InsertIntoSummary_AttrErrorList(resultmessage,entryindex);

                     sprintf(resultmessage,"Y %d %d",ECC,MGCP_Vc->geom);

                     InsertIntoSummary_AttrErrorList(resultmessage,entryindex);
                     }
                  }
               else if(CheckIt == -2)
                  {
                  if(PrintSchemaCodes > 0)
                     {
                     sprintf(resultmessage,"y%s Layer Identifier %s: Feature %s %s\n   Multiple (not all) function type attributes 0 ('Unknown') (%s)\n",
                       ParseGAITgeometry((unsigned char) MGCP_Vc->geom, 2),MGCP_Vc->shapename,GetECCCode(MGCP_Vc->code),
                       GetECCLabel(MGCP_Vc->code),enumcodestring);
                     InsertIntoGIFD_AttrErrorList(resultmessage,entryindex);

                     sprintf(resultmessage,"yMultiple (not all) function type attributes are 0 ('Unknown') (%s)\n",enumcodestring);

                     useid = InsertIntoAttrErrorList(resultmessage,entryindex);
                     InsertIntoAttrIndexList(entryindex,useid);

                     sprintf(resultmessage,"y|%s|%s|%s| multiple (not all) function type attributes are 0 ('Unknown') (%s)\n",
                         GetECCCode(MGCP_Vc->code),GetECCLabel(MGCP_Vc->code),ParseGAITgeometry((unsigned char) MGCP_Vc->geom, 2),
                           enumcodestring);

                     InsertIntoSummary_AttrErrorList(resultmessage,entryindex);

                     sprintf(resultmessage,"Y %d %d",MGCP_Vc->code,MGCP_Vc->geom);

                     InsertIntoSummary_AttrErrorList(resultmessage,entryindex);
                     }
                  else
                     {
                     sprintf(resultmessage,"y%s Layer Identifier %s: Feature %s\n   Multiple (not all) function type attributes are 0 ('Unknown') (%s)\n",
                       ParseGAITgeometry((unsigned char) MGCP_Vc->geom, 2),MGCP_Vc->shapename, GetECCLabel(MGCP_Vc->code),enumcodestring);
                     InsertIntoGIFD_AttrErrorList(resultmessage,entryindex);

                     sprintf(resultmessage,"yMultiple (not all) function type attributes are 0 ('Unknown') (%s)\n",enumcodestring);

                     useid = InsertIntoAttrErrorList(resultmessage,entryindex);
                     InsertIntoAttrIndexList(entryindex,useid);

                     sprintf(resultmessage,"y|%s|%s|%s| multiple (not all) function type attributes 0 ('Unknown') (%s)\n",
                         GetECCCode(MGCP_Vc->code),GetECCLabel(MGCP_Vc->code),ParseGAITgeometry((unsigned char) MGCP_Vc->geom, 2),
                           enumcodestring);

                     InsertIntoSummary_AttrErrorList(resultmessage,entryindex);

                     sprintf(resultmessage,"Y %d %d",ECC,MGCP_Vc->geom);

                     InsertIntoSummary_AttrErrorList(resultmessage,entryindex);
                     }
                  }
               }
            }
         if((CheckIt > 0) && (MGCP_Vc != NULL))
            {

            VVTac = MGCP_Vc->a;
            while(VVTac != NULL)
               {
               if((VVTac->presentvalue != NULL) || (VVTac->lav != NULL))
                  {

                  if(VVTac->dom != NULL)
                     VVTec = VVTac->dom->values;
                  else
                     {
                     VVTec = NULL;
                     }
                  while((VVTec != NULL) && (VVTec->dt ==  1)) /*** only want to do this for enum types ***/
                     {
                     if(strcmp(VVTac->presentvalue,VVTec->evalue) == 0)
                        break;
                     VVTec = VVTec->next;
                     }
                  if(VVTec != NULL)
                     {
                     VVTdc = VVTac->dep;
                     while(VVTdc != NULL)
                        {
                        loops = 0;
                        while(loops < 2)
                           {
                           loops += 1;
                           if(loops == 1)
                              VVTap = MGCP_Vc->a;
                           else
                              VVTap = MGCP_Vc->o;
                           while(VVTap != NULL)
                              {
                              if(VVTap->attr == VVTdc->attr)
                                 {
                                 if((VVTdc->req == -2) && (VVTap->presentvalue == NULL))  /** a required dependency **/
                                    {
                                    if(PrintSchemaCodes > 0)
                                       {
                                       strcpy(EACname,GetEACLabel(VVTdc->attr));
                                       sprintf(resultmessage,"x%s Layer Identifier %s: Feature %s %s\n   Attribute %s %s, Value: %s and Attribute:  %s is not assigned\n",
                                         ParseGAITgeometry((unsigned char) MGCP_Vc->geom, 2),shapefile,GetECCCode(MGCP_Vc->code),
                                         GetECCLabel(MGCP_Vc->code),GetEACCode(VVTac->attr),GetEACLabel(VVTac->attr),VVTac->presentvalue,EACname);
                                       InsertIntoGIFD_AttrErrorList(resultmessage,entryindex);

                                       sprintf(resultmessage,"xAttribute - %s (%s), Value - %s\n",
                                           GetEACCode(VVTac->attr),GetEACLabel(VVTac->attr),VVTac->presentvalue);

                                       useid = InsertIntoAttrErrorList(resultmessage,entryindex);
                                       InsertIntoAttrIndexList(entryindex,useid);

                                       strcpy(EACcode,GetEACCode(VVTdc->attr));
                                       sprintf(resultmessage,"x|%s|%s|%s|%s|%s|%s|%s|%s| is not assigned\n",
                                           GetECCCode(MGCP_Vc->code),GetECCLabel(MGCP_Vc->code),ParseGAITgeometry((unsigned char) MGCP_Vc->geom, 2),
                                           GetEACCode(VVTac->attr),GetEACLabel(VVTac->attr),VVTac->presentvalue,
                                           EACcode,EACname);

                                       InsertIntoSummary_AttrErrorList(resultmessage,entryindex);

                                       sprintf(resultmessage,"X %d %d",VVTac->attr,VVTdc->attr);

                                       InsertIntoSummary_AttrErrorList(resultmessage,entryindex);
                                       }
                                    else
                                       {
                                       strcpy(EACname,GetEACLabel(VVTdc->attr));
                                       sprintf(resultmessage,"x%s Layer Identifier %s: Feature %s\n   Attribute %s, Value %s and Attribute:  %s is not assigned\n",
                                         ParseGAITgeometry((unsigned char) MGCP_Vc->geom, 2),shapefile,
                                         GetECCLabel(MGCP_Vc->code),GetEACLabel(VVTac->attr),VVTac->presentvalue,EACname);
                                       InsertIntoGIFD_AttrErrorList(resultmessage,entryindex);

                                       sprintf(resultmessage,"xAttribute - %s, Value - %s\n", GetEACLabel(VVTac->attr),VVTac->presentvalue);

                                       useid = InsertIntoAttrErrorList(resultmessage,entryindex);
                                       InsertIntoAttrIndexList(entryindex,useid);

                                       strcpy(EACcode,GetEACCode(VVTdc->attr));
                                       sprintf(resultmessage,"x|%s|%s|%s|%s|%s|%s|%s|%s| is not assigned\n",
                                           GetECCCode(MGCP_Vc->code),GetECCLabel(MGCP_Vc->code),ParseGAITgeometry((unsigned char) MGCP_Vc->geom, 2),
                                           GetEACCode(VVTac->attr),GetEACLabel(VVTac->attr),VVTac->presentvalue,
                                           EACcode,EACname);

                                       InsertIntoSummary_AttrErrorList(resultmessage,entryindex);

                                       sprintf(resultmessage,"X %d %d",VVTac->attr,VVTdc->attr);

                                       InsertIntoSummary_AttrErrorList(resultmessage,entryindex);
                                       }

                                    }
                                 else if((VVTdc->req <= -1) && (VVTap->presentvalue != NULL))
                                    {
                                    VVTep = VVTdc->d->values;
                                    EAC4 = EAC3 = -1;
                                    Hint[0] = '\0';
                                    while(VVTep != NULL)
                                       {
                                       if(VVTep->value2 != NULL)
                                          {
                                          if(strcmp(VVTep->evalue,"*GT*") == 0)
                                            sprintf(Hint,"(should be greater than %s)",VVTep->value2);
                                          else if(strcmp(VVTep->evalue,"*LT*") == 0)
                                            sprintf(Hint,"(should be less than %s)",VVTep->value2);
                                          else if(strcmp(VVTep->evalue,"*EQ*") == 0)
                                            sprintf(Hint,"(should be equal to %s)",VVTep->value2);
                                          }
                                       else
                                          {
                                          Hint[0] = '\0';
                                          EAC4 = GetEEindex(VVTdc->attr,VVTap->presentvalue);
if(EAC4 >= 0)
strcpy(Hint,GetEELabel(VVTdc->attr,EAC4));
                                          }
                                       if(VVTep->value2 != NULL)
                                          {
                                          if(strcmp(VVTep->evalue,"*GT*") == 0)
                                             {
                                             sscanf(VVTep->value2,"%lf",&djunk);
                                             sscanf(VVTap->presentvalue,"%lf",&djunk2);
                                             if(djunk2 > djunk)
                                                {
                                                loops = 10;
                                                EAC4 = -1;
                                                break;
                                                }
                                             }
                                          else if(strcmp(VVTep->evalue,"*LT*") == 0)
                                             {
                                             sscanf(VVTep->value2,"%lf",&djunk);
                                             sscanf(VVTap->presentvalue,"%lf",&djunk2); 
                                             if(djunk2 < djunk)
                                                {
                                                loops = 10;
                                                EAC4 = -1;
                                                break;
                                                }
                                             }
                                          else if(strcmp(VVTep->evalue,"*EQ*") == 0)
                                             {
                                             sscanf(VVTep->value2,"%lf",&djunk);
                                             sscanf(VVTap->presentvalue,"%lf",&djunk2);
                                             if(djunk2 == djunk)
                                                {
                                                loops = 10;
                                                EAC4 = -1;
                                                break;
                                                }
                                             }
                                          else if(strcmp(VVTep->evalue, VVTap->presentvalue) == 0)
                                             {
                                             EAC4 = GetEEindex(VVTdc->attr,VVTap->presentvalue);
                                             if(EAC4 >= 0)
                                                strcpy(Hint,GetEELabel(VVTdc->attr,EAC4));
                                             loops = 10;
                                             break;
                                             }
                                          }
                                       else if(strcmp(VVTep->evalue, VVTap->presentvalue) == 0)
                                          {
 EAC4 = GetEEindex(VVTdc->attr,VVTap->presentvalue);
strcpy(Hint,GetEELabel(VVTdc->attr,EAC4));
                                          loops = 10;
                                          break;
                                          }
                                       VVTep = VVTep->next;
                                       }
                                    WriteTheError = 1;
                                    if((VVTep == NULL) && (WriteTheError == 1))
                                       {
                                       EAC3 =  GetEEindex(VVTac->attr, VVTac->presentvalue);
                                       EAC4 = GetEEindex(VVTdc->attr,VVTap->presentvalue);
                                       if(EAC3 >= 0)
                                          strcpy(EEname,GetEELabel(VVTac->attr,EAC3));
                                       else
                                          EEname[0] = '\0';
                                       strcpy(EACname,GetEACLabel(VVTdc->attr));
                                       if((EAC3 < 0) || (EAC4 < 0))
                                          {
                                          if(PrintSchemaCodes > 0)
                                             {
                                             if(EEname[0] == '\0')
                                                {
                                                sprintf(resultmessage,
                                               "x%s Layer Identifier %s: Feature %s %s\n   Attribute %s %s, Value %s assigned with Attribute: %s (%s) Value %s %s\n",
                                                  ParseGAITgeometry((unsigned char) MGCP_Vc->geom, 2),shapefile,GetECCCode(MGCP_Vc->code),
                                                  GetECCLabel(MGCP_Vc->code),GetEACCode(VVTac->attr),
                                                  GetEACLabel(VVTac->attr),VVTac->presentvalue,GetEACCode(VVTdc->attr),EACname,VVTap->presentvalue,Hint);
                                                }
                                             else
                                                {
                                                sprintf(resultmessage,
                                                  "x%s Layer Identifier %s: Feature %s %s\n   Attribute %s %s, Value %s (%s) assigned with Attribute: %s (%s) Value %s %s\n",
                                                  ParseGAITgeometry((unsigned char) MGCP_Vc->geom, 2),shapefile,GetECCCode(MGCP_Vc->code),
                                                  GetECCLabel(MGCP_Vc->code),GetEACCode(VVTac->attr),
                                                  GetEACLabel(VVTac->attr),VVTac->presentvalue,EEname,
                                                  GetEACCode(VVTdc->attr),EACname,VVTap->presentvalue,Hint);
                                                }
                                             }
                                          else
                                             {
                                             if(EEname[0] == '\0')
                                                {
                                                sprintf(resultmessage,
                                                  "x%s Layer Identifier %s: Feature %s\n   Attribute %s, Value %s assigned with Attribute: %s Value %s %s\n",
                                                  ParseGAITgeometry((unsigned char) MGCP_Vc->geom, 2),shapefile,
                                                  GetECCLabel(MGCP_Vc->code),GetEACLabel(VVTac->attr),VVTac->presentvalue,EACname,VVTap->presentvalue,Hint);
                                                }
                                             else
                                                {
                                                sprintf(resultmessage,
                                                  "x%s Layer Identifier %s: Feature %s\n   Attribute %s, Value %s (%s) assigned with Attribute: %s Value %s %s\n",
                                                  ParseGAITgeometry((unsigned char) MGCP_Vc->geom, 2),shapefile,
                                                  GetECCLabel(MGCP_Vc->code),GetEACLabel(VVTac->attr),VVTac->presentvalue,EEname,
                                                  EACname,VVTap->presentvalue,Hint);
                                                }
                                             }
                                          }
                                       else
                                          {
                                          if(PrintSchemaCodes > 0)
                                             {
                                             sprintf(resultmessage,
                                               "x%s Layer Identifier %s: Feature %s %s\n   Attribute %s %s, Value %s (%s) assigned with Attribute: %s (%s) Value %s (%s)\n",
                                               ParseGAITgeometry((unsigned char) MGCP_Vc->geom, 2),shapefile,GetECCCode(MGCP_Vc->code),
                                               GetECCLabel(MGCP_Vc->code),GetEACCode(VVTac->attr),
                                               GetEACLabel(VVTac->attr),VVTac->presentvalue,EEname,
                                                GetEACCode(VVTdc->attr),EACname,VVTap->presentvalue,GetEELabel(VVTdc->attr,EAC4));
                                             }
                                          else
                                             {
                                             sprintf(resultmessage,
                                               "x%s Layer Identifier %s: Feature %s\n   Attribute %s, Value %s (%s) assigned with Attribute: %s Value %s (%s)\n",
                                               ParseGAITgeometry((unsigned char) MGCP_Vc->geom, 2),shapefile,
                                               GetECCLabel(MGCP_Vc->code), GetEACLabel(VVTac->attr),VVTac->presentvalue,EEname,
                                                EACname,VVTap->presentvalue,GetEELabel(VVTdc->attr,EAC4));
                                             }
                                          }

                                       InsertIntoGIFD_AttrErrorList(resultmessage,entryindex);
                                       if(EAC4 >= 0)
                                          {
                                          sprintf(resultmessage,"xAttribute: %s, Value: %s (%s) with Attribute: %s Value: %s (%s)\n",
                                          GetEACLabel(VVTac->attr),VVTac->presentvalue, EEname, EACname,VVTap->presentvalue,
                                           GetEELabel(VVTdc->attr,EAC4));
                                          }
                                       else
                                          {
                                          sprintf(resultmessage,"xAttribute: %s, Value: %s (%s) with Attribute: %s Value: %s\n",
                                          GetEACLabel(VVTac->attr),VVTac->presentvalue, EEname, EACname,VVTap->presentvalue);
                                          }

                                       useid = InsertIntoAttrErrorList(resultmessage,entryindex);
                                       InsertIntoAttrIndexList(entryindex,useid);

                                       strcpy(EACcode,GetEACCode(VVTdc->attr));
                                       sprintf(resultmessage,"x|%s|%s|%s|%s|%s|%s|%s|%s|%s\n",
                                           GetECCCode(MGCP_Vc->code),GetECCLabel(MGCP_Vc->code),ParseGAITgeometry((unsigned char) MGCP_Vc->geom, 2),
                                           GetEACCode(VVTac->attr),GetEACLabel(VVTac->attr),VVTac->presentvalue,
                                           EACcode,EACname,VVTap->presentvalue);

                                       InsertIntoSummary_AttrErrorList(resultmessage,entryindex);

                                       sprintf(resultmessage,"X %d %d",VVTac->attr,VVTdc->attr);

                                       InsertIntoSummary_AttrErrorList(resultmessage,entryindex);

                                       }
                                    }
                                 else if(VVTdc->req > 0)
                                    {
                                    linkageOK = 0;
                                    VVTdn = VVTac->dep;
                                    while(VVTdn != NULL)
                                       {
                                       if(VVTdn->req  == VVTdc->req)
                                          {
                                          VVTan = MGCP_Vc->a;
                                          while(VVTan != NULL)
                                             {
                                             if(VVTan->attr == VVTdn->attr)
                                                {
                                                if(VVTan->presentvalue != NULL)
                                                   {
                                                   VVTen = VVTdn->d->values;
                                                   while(VVTen != NULL)
                                                      {
                                                      if(strcmp(VVTen->evalue, VVTan->presentvalue) == 0)
                                                         {
                                                         linkageOK = 1;
                                                         loops = 10;
                                                         break;
                                                         }
                                                      VVTen = VVTen->next;
                                                      }
                                                   }
                                                }
                                             if(linkageOK > 0)
                                                break;
                                             VVTan = VVTan->next;
                                             }
                                          }
                                       if(linkageOK > 0)
                                          break;
                                       VVTdn = VVTdn->next;
                                       }
                                    if(linkageOK == 0)
                                       {
                                       if(PrintSchemaCodes > 0)
                                          {
                                          sprintf(resultmessage,
                                      "x%s Layer Identifier %s: Feature %s %s\n   Attribute %s %s, Value %s assigned without designated dependent attributes\n",
                                            ParseGAITgeometry((unsigned char) MGCP_Vc->geom, 2),shapefile,GetECCCode(MGCP_Vc->code),
                                            GetECCLabel(MGCP_Vc->code),GetEACCode(VVTac->attr),GetEACLabel(VVTac->attr),VVTac->presentvalue);
                                          InsertIntoGIFD_AttrErrorList(resultmessage,entryindex);

                                          sprintf(resultmessage,"xAttribute: %s, Value: %s without designated dependent attributes\n", GetEACLabel(VVTac->attr),VVTac->presentvalue);
                                          useid = InsertIntoAttrErrorList(resultmessage,entryindex);
                                          InsertIntoAttrIndexList(entryindex,useid);

                                          sprintf(resultmessage,"x|%s|%s|%s|%s|%s|%s|%s|%s|%s",
                                              GetECCCode(MGCP_Vc->code),GetECCLabel(MGCP_Vc->code),ParseGAITgeometry((unsigned char) MGCP_Vc->geom, 2),
                                                       GetEACCode(VVTac->attr), GetEACLabel(VVTac->attr),VVTac->presentvalue,
                                                       GetEACCode(VVTac->dep->attr), GetEACLabel(VVTac->dep->attr),"N/A");
                                          InsertIntoSummary_AttrErrorList(resultmessage,entryindex);

                                          sprintf(resultmessage,"X %d %d",VVTac->attr, VVTac->dep->attr);
                                          InsertIntoSummary_AttrErrorList(resultmessage,entryindex);
                                          }
                                       else
                                          {
                                          sprintf(resultmessage,
                                            "x%s Layer Identifier %s: Feature %s\n   Attribute %s, Value %s assigned without designated dependent attributes\n",
                                            ParseGAITgeometry((unsigned char) MGCP_Vc->geom, 2),shapefile,
                                            GetECCLabel(MGCP_Vc->code),GetEACLabel(VVTac->attr),VVTac->presentvalue);
                                          InsertIntoGIFD_AttrErrorList(resultmessage,entryindex);

                                          sprintf(resultmessage,"xAttribute: %s, Value: %s without dependent attributes\n", GetEACLabel(VVTac->attr),VVTac->presentvalue);
                                          useid = InsertIntoAttrErrorList(resultmessage,entryindex);
                                          InsertIntoAttrIndexList(entryindex,useid);

                                          sprintf(resultmessage,"x|%s|%s|%s|%s|%s|%s|%s|%s|%s",
                                              GetECCCode(MGCP_Vc->code),GetECCLabel(MGCP_Vc->code),ParseGAITgeometry((unsigned char) MGCP_Vc->geom, 2),
                                                       GetEACCode(VVTac->attr), GetEACLabel(VVTac->attr),VVTac->presentvalue,
                                                         GetEACCode(VVTac->dep->attr), GetEACLabel(VVTac->dep->attr),"N/A");
                                          InsertIntoSummary_AttrErrorList(resultmessage,entryindex);
                                          }
                                       }
                                    }
                                 loops = 10;
                                 break;
                                 }
    
                              VVTap = VVTap->next;
                              }
                           }
                        VVTdc = VVTdc->next;
                        }
                     }
                  else if((VVTac->inequality > 0) && (VVTac->presentvalue != NULL))
                     {
                     VVTdc = VVTac->dep;
                     while(VVTdc != NULL)
                        {
                        ErrorNoted = 0;
                        loops = 0;
                        while(loops < 2)
                           {
                           loops += 1;
                           if(loops == 1)
                              VVTap = MGCP_Vc->a;
                           else
                              VVTap = MGCP_Vc->o;
                           while(VVTap != NULL)
                              {
                              if((VVTap->attr == VVTdc->attr) && (VVTap->presentvalue != NULL))
                                 {
                                 ErrorNoted = 0;
                                 if(VVTac->inequality == 1 ) /*** GTEQ relationship **/
                                    {
                                    sscanf(VVTac->presentvalue,"%lf",&djunk);
                                    sscanf(VVTap->presentvalue,"%lf",&djunk2);
                                    if((djunk > -32764) && (djunk2 > -32764) && (djunk < djunk2))
                                       {
                                       ErrorNoted = 1;
                                       strcpy(InequalityType, ">=");
                                       }
                                    } /*** end GTEQ relationship ***/
                                 else if(VVTac->inequality == 2 ) /*** GT relationship **/
                                    {
                                    sscanf(VVTac->presentvalue,"%lf",&djunk);
                                    sscanf(VVTap->presentvalue,"%lf",&djunk2);
                                    if((djunk > -32764) && (djunk2 > -32764) && (djunk <= djunk2))
                                       {
                                       ErrorNoted = 1;
                                       strcpy(InequalityType, ">");
                                       }
                                    } /*** end GT relationship ***/
                                 else if(VVTac->inequality == 3 ) /*** LTEQ relationship **/
                                    {
                                    sscanf(VVTac->presentvalue,"%lf",&djunk);
                                    sscanf(VVTap->presentvalue,"%lf",&djunk2);
                                    if((djunk > -32764) && (djunk2 > -32764) && (djunk > djunk2))
                                       {
                                       ErrorNoted = 1;
                                       strcpy(InequalityType, "<=");
                                       }
                                    } /*** end LTEQ relationship ***/
                                 else if(VVTac->inequality == 4 ) /*** LT relationship **/
                                    {
                                    sscanf(VVTac->presentvalue,"%lf",&djunk);
                                    sscanf(VVTap->presentvalue,"%lf",&djunk2);
                                    if((djunk > -32764) && (djunk2 > -32764) && (djunk >= djunk2))
                                       {
                                       ErrorNoted = 1;
                                       strcpy(InequalityType, "<");
                                       }
                                    } /*** end LT relationship test **/
                                 else if(VVTac->inequality == 5 ) /*** EQUALS relationship **/
                                    {
                                    sscanf(VVTac->presentvalue,"%lf",&djunk);
                                    sscanf(VVTap->presentvalue,"%lf",&djunk2);
                                    if((djunk > -32764) && (djunk2 > -32764) && ((djunk < djunk2) || (djunk > djunk2)))
                                       {
                                       ErrorNoted = 1;
                                       strcpy(InequalityType, "equals");
                                       }
                                    }
                                 else if((VVTac->inequality >= 6) && (VVTac->inequality <= 10)) /*** defining attribute must have specific numeric value ***/
                                    {
                                    sscanf(VVTac->presentvalue,"%lf",&djunk);
                                    CheckIt = 0;
                                    if((djunk < -32768) || (djunk > -32768)) /** was (djunk > -32764)) ***/
                                       {
                                       if((VVTac->inequality == 6) && (VVTac->SetValue == djunk))
                                          CheckIt = 1;
                                       else if((VVTac->inequality == 7) && (djunk < VVTac->SetValue))
                                          CheckIt = 1;
                                       else if((VVTac->inequality == 8) && (djunk > VVTac->SetValue))
                                          CheckIt = 1;
                                       else if((VVTac->inequality == 9) && (djunk <= VVTac->SetValue))
                                          CheckIt = 1;
                                       else if((VVTac->inequality == 10) && (djunk >= VVTac->SetValue))
                                          CheckIt = 1;
                                       }

                                    if(CheckIt > 0) /*** then meet the precondition for this rule to fire ***/
                                       {
                                       VVTetest = VVTac->dep->d->values;
                                       while(VVTetest != NULL)
                                          {
                                          if(strcmp(VVTap->presentvalue,VVTetest->evalue) == 0)
                                             break;
                                          VVTetest = VVTetest->next;
                                          }
                                       if(VVTetest == NULL) /***if(VVTac->dep->d->values == NULL) ***/
                                          {
                                          ErrorNoted = 1;
                                          }
                                       }
                                    } /*** end inequality relationship check***/
                                 
                                 if(ErrorNoted > 0)
                                    {
                                    if((VVTac->inequality >= 6) && (VVTac->inequality <= 10))
                                       {
                                       EAC4 = GetEEindex(VVTdc->attr,VVTap->presentvalue);
                                       if(PrintSchemaCodes > 0)
                                           {
                                           sprintf(resultmessage,
                                             "x%s Layer Identifier %s: Feature %s %s\n   Attribute %s %s, Numeric Value %s assigned with Attribute: %s (%s) Value %s (%s)\n",
                                             ParseGAITgeometry((unsigned char) MGCP_Vc->geom, 2),shapefile,GetECCCode(MGCP_Vc->code),
                                             GetECCLabel(MGCP_Vc->code),GetEACCode(VVTac->attr),
                                             GetEACLabel(VVTac->attr),VVTac->presentvalue,
                                              GetEACCode(VVTdc->attr),GetEACLabel(VVTdc->attr),VVTap->presentvalue,GetEELabel(VVTdc->attr,EAC4));
                                           }
                                        else
                                           {
                                           sprintf(resultmessage,
                                             "x%s Layer Identifier %s: Feature %s\n   Attribute %s, Numeric Value %s assigned with Attribute: %s Value %s (%s)\n",
                                             ParseGAITgeometry((unsigned char) MGCP_Vc->geom, 2),shapefile,
                                             GetECCLabel(MGCP_Vc->code), GetEACLabel(VVTac->attr),VVTac->presentvalue,
                                              EACname,VVTap->presentvalue,GetEELabel(VVTdc->attr,EAC4));
                                           }
                                       }
                                    else
                                       {
                                       if(PrintSchemaCodes > 0)
                                          {
                                          sprintf(resultmessage,
                                            "x%s Layer Identifier %s: Feature %s %s\n   Attribute %s %s, Value %s fails inequality requirement (%s) with Attribute: %s (%s) Value %s\n",
                                            ParseGAITgeometry((unsigned char) MGCP_Vc->geom, 2),shapefile,GetECCCode(MGCP_Vc->code),
                                            GetECCLabel(MGCP_Vc->code),GetEACCode(VVTac->attr),
                                            GetEACLabel(VVTac->attr),VVTac->presentvalue,InequalityType,
                                             GetEACCode(VVTdc->attr),GetEACLabel(VVTap->attr),VVTap->presentvalue);
                                          }
                                       else
                                          {
                                          sprintf(resultmessage,
                                            "x%s Layer Identifier %s: Feature %s\n   Attribute %s, Value %s fails inequality requirement (%s) with Attribute: %s Value %s\n",
                                            ParseGAITgeometry((unsigned char) MGCP_Vc->geom, 2),shapefile,
                                            GetECCLabel(MGCP_Vc->code),GetEACLabel(VVTac->attr),VVTac->presentvalue,InequalityType,
                                             GetEACLabel(VVTac->attr),VVTap->presentvalue);
                                          }
                                       }
                                    InsertIntoGIFD_AttrErrorList(resultmessage,entryindex);
                                    sprintf(resultmessage,"xAttribute: %s, Value: %s fails inequality requirement\n", GetEACLabel(VVTac->attr),VVTac->presentvalue);

                                    useid = InsertIntoAttrErrorList(resultmessage,entryindex);
                                    InsertIntoAttrIndexList(entryindex,useid);

                                    strcpy(EACcode,GetEACCode(VVTdc->attr));
                                    sprintf(resultmessage,"x|%s|%s|%s|%s|%s|%s|%s|%s|%s\n",
                                           GetECCCode(MGCP_Vc->code),GetECCLabel(MGCP_Vc->code),ParseGAITgeometry((unsigned char) MGCP_Vc->geom, 2),
                                           GetEACCode(VVTac->attr),GetEACLabel(VVTac->attr),VVTac->presentvalue,
                                           GetEACCode(VVTap->attr),GetEACLabel(VVTap->attr),VVTap->presentvalue);

                                    InsertIntoSummary_AttrErrorList(resultmessage,entryindex);

                                    sprintf(resultmessage,"X %d %d",VVTac->attr,VVTdc->attr);

                                    InsertIntoSummary_AttrErrorList(resultmessage,entryindex);
                                    } /*** end  ErrorNoted > 0 ***/
                                 loops = 10;
                                 break;
                                 } /*** end if(VVTap->attr == VVTdc->attr) ****/

                              VVTap = VVTap->next;
                              } /*** end while(VVTap != NULL) ****/

                           } /*** end while loops < 2 ***/
                        if(ErrorNoted > 0)
                           break;

                        VVTdc = VVTdc->next;
                        } /*** end while(VVTdc != NULL) ***/

                     } /*** end  if(VVTac->inequality > 0)  && (VVTac->presentvalue != NULL)  ***/

                  else if((VVTac->inequality > 0) && (VVTac->lav != NULL)) /*** have to deal with one of the long attr values (HGT, ZV2, ARA) ***/
                     {
                     LAVc = VVTac->lav;
                     while(LAVc != NULL)
                        {
                        Global_FID_Index = LAVc->FID_Index;
                     VVTdc = VVTac->dep;
                     sprintf(DoubleAsString,"%.3lf",LAVc->v);
                     djunk = LAVc->v;
                     while(VVTdc != NULL)
                        {
                        loops = 0;
                        while(loops < 2)
                           {
                           loops += 1;
                           if(loops == 1)
                              VVTap = MGCP_Vc->a;
                           else
                              VVTap = MGCP_Vc->o;
                           while(VVTap != NULL)
                              {
                              if(VVTap->attr == VVTdc->attr)
                                 {
                                 ErrorNoted = 0;
                                 if(VVTac->inequality == 1 ) /*** GTEQ relationship **/
                                    {
                                    sscanf(DoubleAsString,"%lf",&djunk);
                                    sscanf(VVTap->presentvalue,"%lf",&djunk2);
                                    if((djunk > -32764) && (djunk2 > -32764) && (djunk < djunk2))
                                       {
                                       ErrorNoted = 1;
                                       strcpy(InequalityType, ">=");
                                       }
                                    } /*** end GTEQ relationship ***/
                                 else if(VVTac->inequality == 2 ) /*** GT relationship **/
                                    {
                                    sscanf(DoubleAsString,"%lf",&djunk);
                                    sscanf(VVTap->presentvalue,"%lf",&djunk2);
                                    if((djunk > -32764) && (djunk2 > -32764) && (djunk <= djunk2))
                                       {
                                       ErrorNoted = 1;
                                       strcpy(InequalityType, ">");
                                       }
                                    } /*** end GT relationship ***/
                                 else if(VVTac->inequality == 3 ) /*** LTEQ relationship **/
                                    {
                                    sscanf(DoubleAsString,"%lf",&djunk);
                                    sscanf(VVTap->presentvalue,"%lf",&djunk2);
                                    if((djunk > -32764) && (djunk2 > -32764) && (djunk > djunk2))
                                       {
                                       ErrorNoted = 1;
                                       strcpy(InequalityType, "<=");
                                       }
                                    } /*** end LTEQ relationship ***/
                                 else if(VVTac->inequality == 4 ) /*** LT relationship **/
                                    {
                                    sscanf(DoubleAsString,"%lf",&djunk);
                                    sscanf(VVTap->presentvalue,"%lf",&djunk2);
                                    if((djunk > -32764) && (djunk2 > -32764) && (djunk >= djunk2))
                                       {
                                       ErrorNoted = 1;
                                       strcpy(InequalityType, "<");
                                       }
                                    } /*** end LT relationship test **/
                                 else if(VVTac->inequality == 5 ) /*** EQUALS relationship **/
                                    {
                                    sscanf(DoubleAsString,"%lf",&djunk);
                                    sscanf(VVTap->presentvalue,"%lf",&djunk2);
                                    if((djunk > -32764) && (djunk2 > -32764) && ((djunk < djunk2) || (djunk > djunk2)))
                                       {
                                       ErrorNoted = 1;
                                       strcpy(InequalityType, "equals");
                                       }
                                    }
                                 else if((VVTac->inequality >= 6) && (VVTac->inequality <= 10)) /*** defining attribute must have specific numeric value ***/
                                    {
                                    sscanf(DoubleAsString,"%lf",&djunk);
                                    CheckIt = 0;
                                    if((VVTac->inequality == 6) && (VVTac->SetValue == djunk))
                                       CheckIt = 1;
                                    else if((VVTac->inequality == 7) && (djunk < VVTac->SetValue))
                                       CheckIt = 1;
                                    else if((VVTac->inequality == 8) && (djunk > VVTac->SetValue))
                                       CheckIt = 1;
                                    else if((VVTac->inequality == 9) && (djunk <= VVTac->SetValue))
                                       CheckIt = 1;
                                    else if((VVTac->inequality == 10) && (djunk >= VVTac->SetValue))
                                       CheckIt = 1;

                                    if((CheckIt > 0) && (VVTap->presentvalue != NULL))
                                       {
                                       VVTetest = VVTac->dep->d->values;
                                       while(VVTetest != NULL)
                                          {
                                          if(strcmp(VVTap->presentvalue,VVTetest->evalue) == 0)
                                             break;
                                          VVTetest = VVTetest->next;
                                          }
                                       if(VVTetest == NULL) /***if(VVTac->dep->d->values == NULL) ***/
                                          {
                                          ErrorNoted = 1;
                                          }
                                       }
                                    } /*** end inequality relationship check***/

                                 if(ErrorNoted > 0)
                                    {
                                    if((VVTac->inequality >= 6) && (VVTac->inequality <= 10))
                                       {
                                       EAC4 = GetEEindex(VVTdc->attr,VVTap->presentvalue);
                                       if(PrintSchemaCodes > 0)
                                           {
                                           sprintf(resultmessage,
                                             "x%s Layer Identifier %s: Feature %s %s\n   Attribute %s %s, Numeric Value %s assigned with Attribute: %s (%s) Value %s (%s)\n",
                                             ParseGAITgeometry((unsigned char) MGCP_Vc->geom, 2),shapefile,GetECCCode(MGCP_Vc->code),
                                             GetECCLabel(MGCP_Vc->code),GetEACCode(VVTac->attr),
                                             GetEACLabel(VVTac->attr),DoubleAsString,
                                              GetEACCode(VVTdc->attr),GetEACLabel(VVTdc->attr),VVTap->presentvalue,GetEELabel(VVTdc->attr,EAC4));
                                           }
                                        else
                                           {
                                           sprintf(resultmessage,
                                             "x%s Layer Identifier %s: Feature %s\n   Attribute %s, Numeric Value %s assigned with Attribute: %s Value %s (%s)\n",
                                             ParseGAITgeometry((unsigned char) MGCP_Vc->geom, 2),shapefile,
                                             GetECCLabel(MGCP_Vc->code), GetEACLabel(VVTac->attr),DoubleAsString,
                                              EACname,VVTap->presentvalue,GetEELabel(VVTdc->attr,EAC4));
                                           }
                                       }
                                    else
                                       {
                                       if(PrintSchemaCodes > 0)
                                          {
                                          sprintf(resultmessage,
                                            "x%s Layer Identifier %s: Feature %s %s\n   Attribute %s %s, Value %s fails inequality requirement (%s) with Attribute: %s (%s) Value %s\n",
                                            ParseGAITgeometry((unsigned char) MGCP_Vc->geom, 2),shapefile,GetECCCode(MGCP_Vc->code),
                                            GetECCLabel(MGCP_Vc->code),GetEACCode(VVTac->attr),
                                            GetEACLabel(VVTac->attr),DoubleAsString,InequalityType,
                                             GetEACCode(VVTdc->attr),GetEACLabel(VVTap->attr),VVTap->presentvalue);
                                          }
                                       else
                                          {
                                          sprintf(resultmessage,
                                            "x%s Layer Identifier %s: Feature %s\n   Attribute %s, Value %s fails inequality requirement (%s) with Attribute: %s Value %s\n",
                                            ParseGAITgeometry((unsigned char) MGCP_Vc->geom, 2),shapefile,
                                            GetECCLabel(MGCP_Vc->code),GetEACLabel(VVTac->attr),DoubleAsString,InequalityType,
                                             GetEACLabel(VVTac->attr),VVTap->presentvalue);
                                          }
                                       }
                                    InsertIntoGIFD_AttrErrorList(resultmessage,-1); //entryindex);
                                    sprintf(resultmessage,"xAttribute: %s, Value: %s fails inequality requirement\n", GetEACLabel(VVTac->attr),DoubleAsString);

                                    useid = InsertIntoAttrErrorList(resultmessage,-1);  //entryindex);
                                    InsertIntoAttrIndexList(entryindex,useid);

                                    strcpy(EACcode,GetEACCode(VVTdc->attr));
                                    sprintf(resultmessage,"x|%s|%s|%s|%s|%s|%s|%s|%s|%s\n",
                                           GetECCCode(MGCP_Vc->code),GetECCLabel(MGCP_Vc->code),ParseGAITgeometry((unsigned char) MGCP_Vc->geom, 2),                                           GetEACCode(VVTac->attr),GetEACLabel(VVTac->attr),DoubleAsString,
                                           GetEACCode(VVTap->attr),GetEACLabel(VVTap->attr),VVTap->presentvalue);

                                    InsertIntoSummary_AttrErrorList(resultmessage,-1);//entryindex);

                                    sprintf(resultmessage,"X %d %d",VVTac->attr,VVTdc->attr);

                                    InsertIntoSummary_AttrErrorList(resultmessage,-1);//entryindex);
                                    } /*** end  ErrorNoted > 0 ***/
                                 loops = 10;
                                 break;
                                 } /*** end if(VVTap->attr == VVTdc->attr) ****/

                              VVTap = VVTap->next;
                              } /*** end while(VVTap != NULL) ****/

                           } /*** end while loops < 2 ***/

                        VVTdc = VVTdc->next;
                        } /*** end while(VVTdc != NULL) ***/ 

                        LAVc = LAVc->next;
                        }
                     Global_FID_Index = -999;
                     }


                  } /**** end if(VVTac->presentvalue != NULL) || (VVTac->lav != NULL)   ***/

               VVTac = VVTac->next;
               } /*** end while(VVTac != NULL) ***/

            } /*** end if(MGCP_Vc != NULL) ***/

         } /*** end if(MGCP_VVT_root != NULL) ***/

      if(ngac != NULL)
         {
         Ac = ngac->attr;
      
         while(Ac != NULL)
            {
            CheckIt = 0;
            if(ATTRTYPE_ANY_MGCP() > 0) /** for MGCP, all attr have to be present, perhaps not filled in, but present ***/
               CheckIt = 1;
            else if(ATTRTYPE_ANY_GGDM() > 0) /** explicitly, no required attributes in any GGDM model ***/
               CheckIt = 0;
            else if((Ac->OptReq == 'M') || (Ac->OptReq == 'R'))  /** signals a mandatory (required) attribute for the fcode/geom ***/
               CheckIt = 1;
            if(CheckIt > 0)
               {
               if(Ac->IsLong > 0)   /*** one of the special long attr was required for this FCODE - how many are there for the this Lindex?  ***/
                  {
                  thistype = GetLongAttrType(Ac->codeindex,0);
                  if(thistype >= 0) /** really has to be, or Ac->IsLong should be 0  ****/
                     {
                     counter = 0;
                     for(i=0; i<LLtoIDmap[entryindex].count; i++)
                        {
                  if((i % 30000) == 0)
                     {
                     if(NGA_TYPE == 1)
                        {
                        PCdone = (NumDone * 100.0) / NumToCheck;
                        BuildOpenMenu(PCdone,SACfull_x_2,SACfull_x_2,linears_done, areals_done,model_polys,areals_done,
                                   linears_done,points_done,sphere_cv,parallel_cv,stamps_done,
                                   footprints_done, bridges_done,g_read,g_write,
                                FMpointsdone,FMlinesdone,FMarealsdone,100.0,100.0,100.0,0.0, 0);
                        }
                     }
                        if(LLtoIDmap[entryindex].IDentries[i] >= 0)
                           {
                           kjunk = GetLongAttrVal(thistype,LLtoIDmap[entryindex].IDentries[i],
                                                  &ijunk,&djunk,&resultmessage[0]);
                           if(kjunk != NOTYPE)
                              ++counter;
                           }
                        }
                     }
                  if(counter != LongListInstances[entryindex])
                     {
                     i = LongListInstances[entryindex] - counter;
                     i = 0 - i;
                     if((ECC == TDSm1) || (ECC == TDSm2) || (ECC == TDSm3) || (ECC == TDSm4) || (ECC == TDSm5) || (ECC == TDSm6))
                        {
                        sprintf(resultmessage,"Layer Identifier %s: Feature %s (%s): Attribute %s (%s): Required attribute is not assigned\n",
                          shapefile,GetECCCode(ECC),GetECCLabel(ECC),
                          GetEACCode(Ac->codeindex), GetEACLabel(Ac->codeindex));
                        InsertIntoGIFD_MetaData_ErrorList(resultmessage,entryindex);
                        }
                     else if(PrintSchemaCodes > 0)
                        {
                        sprintf(resultmessage,"z%s Layer Identifier %s: Feature %s %s\n   Required Attribute %s %s\n",
                          ParseGAITgeometry((unsigned char) seeitgeom, 2), shapefile,GetECCCode(ECC),GetECCLabel(ECC),
                          GetEACCode(Ac->codeindex), GetEACLabel(Ac->codeindex));
                        InsertIntoGIFD_AttrErrorList(resultmessage,i);

                        sprintf(resultmessage,"zRequired Attribute - %s (%s)\n", GetEACCode(Ac->codeindex),GetEACLabel(Ac->codeindex));
                        useid = InsertIntoAttrErrorList(resultmessage,i);
                        InsertIntoAttrIndexList(entryindex,useid);

                        sprintf(resultmessage,"z|%s|%s|%s|%d %d %d",GetECCCode(ECC),GetECCLabel(ECC),GetEACLabel(Ac->codeindex),ECC,Ac->codeindex,seeitgeom);
                        InsertIntoSummary_AttrErrorList(resultmessage,i);

                        if(Ac->codeindex < 10)
                           sprintf(resultmessage,"Z 000%d",Ac->codeindex);
                        else if(Ac->codeindex < 100)
                           sprintf(resultmessage,"Z 00%d",Ac->codeindex);
                        else if(Ac->codeindex < 1000)
                           sprintf(resultmessage,"Z 0%d",Ac->codeindex);
                        else
                           sprintf(resultmessage,"Z %d",Ac->codeindex);

                        InsertIntoSummary_AttrErrorList(resultmessage,i);
                        }
                     else
                        {
                        sprintf(resultmessage,"z%s Layer Identifier %s: Feature %s\n   Required Attribute %s\n",
                          ParseGAITgeometry((unsigned char) seeitgeom, 2), shapefile,GetECCLabel(ECC),
                          GetEACLabel(Ac->codeindex));
                        InsertIntoGIFD_AttrErrorList(resultmessage,i);

                        sprintf(resultmessage,"zRequired Attribute - %s\n", GetEACLabel(Ac->codeindex));
                        useid = InsertIntoAttrErrorList(resultmessage,i);
                        InsertIntoAttrIndexList(entryindex,useid);

                        sprintf(resultmessage,"z|%s|%s|%s|%d %d %d",GetECCCode(ECC),GetECCLabel(ECC),GetEACLabel(Ac->codeindex),ECC,Ac->codeindex,seeitgeom);
                        InsertIntoSummary_AttrErrorList(resultmessage,i);

                        if(Ac->codeindex < 10)
                           sprintf(resultmessage,"Z 000%d",Ac->codeindex);
                        else if(Ac->codeindex < 100)
                           sprintf(resultmessage,"Z 00%d",Ac->codeindex);
                        else if(Ac->codeindex < 1000)
                           sprintf(resultmessage,"Z 0%d",Ac->codeindex);
                        else
                           sprintf(resultmessage,"Z %d",Ac->codeindex);
                        InsertIntoSummary_AttrErrorList(resultmessage,i);
                        }
                     }
                  }
               else
                  {
                  if(Ac->present != 'Y')
                     {
                     if((ECC == TDSm1) || (ECC == TDSm2) || (ECC == TDSm3) || (ECC == TDSm4) || (ECC == TDSm5) || (ECC == TDSm6))
                        {
                        sprintf(resultmessage,"Layer Identifier %s: Feature %s (%s): Attribute %s (%s): Attribute is required but is not assigned\n",
                          shapefile,GetECCCode(ECC),GetECCLabel(ECC),
                          GetEACCode(Ac->codeindex), GetEACLabel(Ac->codeindex));
                        InsertIntoGIFD_MetaData_ErrorList(resultmessage,entryindex);
                        }
                     else if(PrintSchemaCodes > 0)
                        {
                        sprintf(resultmessage,"z%s Layer Identifier %s: Feature %s %s\n   Required Attribute %s %s\n",
                          ParseGAITgeometry((unsigned char) seeitgeom, 2), shapefile,GetECCCode(ECC),GetECCLabel(ECC),
                          GetEACCode(Ac->codeindex), GetEACLabel(Ac->codeindex));
                        InsertIntoGIFD_AttrErrorList(resultmessage,entryindex);

                        sprintf(resultmessage,"zRequired Attribute - %s (%s)\n", GetEACCode(Ac->codeindex),GetEACLabel(Ac->codeindex));
                        useid = InsertIntoAttrErrorList(resultmessage,entryindex);
                        InsertIntoAttrIndexList(entryindex,useid);

                        sprintf(resultmessage,"z|%s|%s|%s|%d %d %d",GetECCCode(ECC),GetECCLabel(ECC),GetEACLabel(Ac->codeindex),ECC,Ac->codeindex,seeitgeom);
                        InsertIntoSummary_AttrErrorList(resultmessage,entryindex);

if(Ac->codeindex < 10)
   sprintf(resultmessage,"Z 000%d",Ac->codeindex);
else if(Ac->codeindex < 100)
   sprintf(resultmessage,"Z 00%d",Ac->codeindex);
else if(Ac->codeindex < 1000)
   sprintf(resultmessage,"Z 0%d",Ac->codeindex);
else
   sprintf(resultmessage,"Z %d",Ac->codeindex);
                        InsertIntoSummary_AttrErrorList(resultmessage,entryindex);
                        }
                     else
                        {
                        sprintf(resultmessage,"z%s Layer Identifier %s: Feature %s\n   Required Attribute %s\n",
                          ParseGAITgeometry((unsigned char) seeitgeom, 2), shapefile,GetECCLabel(ECC),
                          GetEACLabel(Ac->codeindex));
                        InsertIntoGIFD_AttrErrorList(resultmessage,entryindex);

                        sprintf(resultmessage,"zRequired Attribute - %s\n", GetEACLabel(Ac->codeindex));
                        useid = InsertIntoAttrErrorList(resultmessage,entryindex);
                        InsertIntoAttrIndexList(entryindex,useid);

                        sprintf(resultmessage,"z|%s|%s|%s|%d %d %d",GetECCCode(ECC),GetECCLabel(ECC),GetEACLabel(Ac->codeindex),ECC,Ac->codeindex,seeitgeom);
                        InsertIntoSummary_AttrErrorList(resultmessage,entryindex);

if(Ac->codeindex < 10)
   sprintf(resultmessage,"Z 000%d",Ac->codeindex);
else if(Ac->codeindex < 100)
   sprintf(resultmessage,"Z 00%d",Ac->codeindex);
else if(Ac->codeindex < 1000)
   sprintf(resultmessage,"Z 0%d",Ac->codeindex);
else
   sprintf(resultmessage,"Z %d",Ac->codeindex);
                        InsertIntoSummary_AttrErrorList(resultmessage,entryindex);
                        }
                     }
                  }
               }

            Ac = Ac->next;
            }
         }


      if((BadFcodeGeomPair == 1) || (NE_FcodeGeomPair == 1))
         {
         if(seeitgeom != C_GRID)
            {
            if((ECC == TDSm1) || (ECC == TDSm2) || (ECC == TDSm3) || (ECC == TDSm4) || (ECC == TDSm5) || (ECC == TDSm6))
               {
               sprintf(resultmessage,"Layer Identifier %s: Feature %s (%s): Attribute n/a (None Involved): Assigned geometry: %s not designated for use with this feature\n",
                    shapefile,GetECCCode(ECC),GetECCLabel(ECC),
                         ParseGAITgeometry((unsigned char) seeitgeom, 2));
                        InsertIntoGIFD_MetaData_ErrorList(resultmessage,entryindex);
               }
            else if(PrintSchemaCodes > 0)
               {
               if(NE_FcodeGeomPair == 0)
                  {
                  sprintf(resultmessage,"0%s Layer Identifier %s: Feature %s %s\n   Unexpected Geometry: %s\n",
                    ParseGAITgeometry((unsigned char) seeitgeom, 2), shapefile,GetECCCode(ECC),GetECCLabel(ECC),
                         ParseGAITgeometry((unsigned char) seeitgeom, 2));
                  InsertIntoGIFD_AttrErrorList(resultmessage,entryindex);

                  sprintf(resultmessage,"0Unexpected Geometry - %s\n", ParseGAITgeometry((unsigned char) seeitgeom, 2));
                  }
               else
                  {
                  sprintf(resultmessage,"0%s Layer Identifier %s: Feature %s %s\n   Unexpected Geometry (not desiginated for extraction): %s\n",
                    ParseGAITgeometry((unsigned char) seeitgeom, 2), shapefile,GetECCCode(ECC),GetECCLabel(ECC),
                         ParseGAITgeometry((unsigned char) seeitgeom, 2));
                  InsertIntoGIFD_AttrErrorList(resultmessage,entryindex);

                  sprintf(resultmessage,"0Unexpected Geometry (not desiginated for extraction) - %s\n", ParseGAITgeometry((unsigned char) seeitgeom, 2));
                  }
               useid = InsertIntoAttrErrorList(resultmessage,entryindex);
               InsertIntoAttrIndexList(entryindex,useid);
               sprintf(resultmessage,"0|%s|%s|%d %d",GetECCCode(ECC),GetECCLabel(ECC), ECC, seeitgeom);
               InsertIntoSummary_AttrErrorList(resultmessage,entryindex);

if(ECC < 10)
   sprintf(resultmessage,"9 00%d %d",ECC,seeitgeom);
else if(ECC < 100)
   sprintf(resultmessage,"9 0%d %d",ECC,seeitgeom);
else
   sprintf(resultmessage,"9 %d %d",ECC,seeitgeom);
               InsertIntoSummary_AttrErrorList(resultmessage,entryindex);
               }
            else
               {
               if(NE_FcodeGeomPair == 0)
                  {
                  sprintf(resultmessage,"0%s Layer Identifier %s: Feature %s\n   Unexpected Geometry: %s\n",
                    ParseGAITgeometry((unsigned char) seeitgeom, 2), shapefile,GetECCLabel(ECC),
                         ParseGAITgeometry((unsigned char) seeitgeom, 2));
                  InsertIntoGIFD_AttrErrorList(resultmessage,entryindex);

                  sprintf(resultmessage,"0Unexpected Geometry - %s\n", ParseGAITgeometry((unsigned char) seeitgeom, 2));
                  }
               else
                  {
                  sprintf(resultmessage,"0%s Layer Identifier %s: Feature %s\n   Unexpected Geometry (not designated for extraction): %s\n",
                    ParseGAITgeometry((unsigned char) seeitgeom, 2), shapefile,GetECCLabel(ECC),
                         ParseGAITgeometry((unsigned char) seeitgeom, 2));
                  InsertIntoGIFD_AttrErrorList(resultmessage,entryindex);

                  sprintf(resultmessage,"0Unexpected Geometry (not designated for extraction) - %s\n", ParseGAITgeometry((unsigned char) seeitgeom, 2));
                  }
               useid = InsertIntoAttrErrorList(resultmessage,entryindex);
               InsertIntoAttrIndexList(entryindex,useid);
               sprintf(resultmessage,"0|%s|%s|%d %d",GetECCCode(ECC),GetECCLabel(ECC), ECC, seeitgeom);
               InsertIntoSummary_AttrErrorList(resultmessage,entryindex);

if(ECC < 10)
   sprintf(resultmessage,"9 00%d %d",ECC,seeitgeom);
else if(ECC < 100)
   sprintf(resultmessage,"9 0%d %d",ECC,seeitgeom);
else
   sprintf(resultmessage,"9 %d %d",ECC,seeitgeom);
               InsertIntoSummary_AttrErrorList(resultmessage,entryindex);
               }
            }
         NE_FcodeGeomPair = 0;
         }


      if(DoMetadataChecking > 0)
         {
         if(LongListBadUID[entryindex] > 0)
              {
              if((LongListBadUID[entryindex] == 1) && (ECC != TDSm3))  /** 1 means "No UID Found" and 2 means a blank UID found ***/
                 {
                  sprintf(resultmessage,"Layer Identifier %s: Feature %s (%s): Attribute %s (%s): required unique ID attribute not present\n",
                      shapefile,GetECCCode(ECC),GetECCLabel(ECC),GetFrontPart(),GetIDName());
                 if((ATTRTYPE_ANY_TDS() <= 0) && (ATTRTYPE_ANY_MGCP() <= 0))
                    InsertIntoGIFD_MetaData_ErrorList(resultmessage,entryindex);
                 }
               else if((LongListBadUID[entryindex] == 2) && (ECC != TDSm3))  /** 1 means "No UID Found" and 2 means a blank UID found ***/
                 {
                  sprintf(resultmessage,"Layer Identifier %s: Feature %s (%s): Attribute %s (%s): required unique ID attribute has no assigned, informative value (value is blank)\n",
                      shapefile,GetECCCode(ECC),GetECCLabel(ECC),GetFrontPart(),GetIDName());
                 if((ATTRTYPE_ANY_TDS() <= 0) && (ATTRTYPE_ANY_MGCP() <= 0))
                    InsertIntoGIFD_MetaData_ErrorList(resultmessage,entryindex);
                 }
               else if((LongListBadUID[entryindex] == 7) && (ECC != TDSm3)) 
                 {
                  sprintf(resultmessage,"Layer Identifier %s: Feature %s (%s): Attribute %s (%s): required unique ID attribute has value 'No Information'\n",
                      shapefile,GetECCCode(ECC),GetECCLabel(ECC),GetFrontPart(), GetIDName());
                 if((ATTRTYPE_ANY_TDS() <= 0) && (ATTRTYPE_ANY_MGCP() <= 0))
                    InsertIntoGIFD_MetaData_ErrorList(resultmessage,entryindex); 
                 }
               else if((LongListBadUID[entryindex] == 4) && (ECC != TDSm3))
                 {
                  sprintf(resultmessage,"Layer Identifier %s: Feature %s (%s): Attribute %s (%s): required unique ID attribute has value 'noInformation'\n",
                      shapefile,GetECCCode(ECC),GetECCLabel(ECC),GetFrontPart(), GetIDName());
                 if((ATTRTYPE_ANY_TDS() <= 0) && (ATTRTYPE_ANY_MGCP() <= 0))
                    InsertIntoGIFD_MetaData_ErrorList(resultmessage,entryindex); 
                 }
               else if((LongListBadUID[entryindex] == 5) && (ECC != TDSm3))
                 {
                  sprintf(resultmessage,"Layer Identifier %s: Feature %s (%s): Attribute %s (%s): required unique ID attribute has value 'Not Applicable'\n",
                      shapefile,GetECCCode(ECC),GetECCLabel(ECC),GetFrontPart(), GetIDName());
                 if((ATTRTYPE_ANY_TDS() <= 0) && (ATTRTYPE_ANY_MGCP() <= 0))
                    InsertIntoGIFD_MetaData_ErrorList(resultmessage,entryindex); 
                 }
               else if((LongListBadUID[entryindex] == 6) && (ECC != TDSm3))
                 {
                  sprintf(resultmessage,"Layer Identifier %s: Feature %s (%s): Attribute %s (%s): required unique ID attribute has value 'Other'\n",
                      shapefile,GetECCCode(ECC),GetECCLabel(ECC),GetFrontPart(),GetIDName());
                 if((ATTRTYPE_ANY_TDS() <= 0) && (ATTRTYPE_ANY_MGCP() <= 0))
                    InsertIntoGIFD_MetaData_ErrorList(resultmessage,entryindex); 
                 }
               else if(LongListBadUID[entryindex] == 3) /** 3 means str len was not 36, but o/w OK ***/
                 {
                 if((ECC == TDSm1) || (ECC == TDSm2) || (ECC == TDSm3) || (ECC == TDSm4) || (ECC == TDSm5) || (ECC == TDSm6))
                    {
                    sprintf(resultmessage,"Layer Identifier %s: Feature %s (%s): Attribute %s (%s): required Unique ID attribute incorrect string length\n",
                      shapefile,GetECCCode(ECC),GetECCLabel(ECC),GetEACCode(Indices[MGCP_UID_Indices_index]),
                              GetEACLabel(Indices[MGCP_UID_Indices_index]));
                    InsertIntoGIFD_MetaData_ErrorList(resultmessage,entryindex);
                    }
                 else if(PrintSchemaCodes > 0)
                    {
                    sprintf(resultmessage,"Layer Identifier %s: Feature %s (%s): Attribute %s (%s): required metadata attribute incorrect string length\n",
                      shapefile,GetECCCode(ECC),GetECCLabel(ECC),GetEACCode(Indices[MGCP_UID_Indices_index]),
                              GetEACLabel(Indices[MGCP_UID_Indices_index]));
                    }
                  else
                    {
                    sprintf(resultmessage,"Layer Identifier %s: Feature %s: %s: required metadata attribute incorrect string length\n",
                      shapefile,GetECCLabel(ECC),GetEACLabel(Indices[MGCP_UID_Indices_index]));
                    }
                 }
              else if(LongListBadUID[entryindex] > 9) /** >= 10 means had a bad character in position LongListBadUID[index] - 10 ***/
                 {
                 ki = LongListBadUID[entryindex] - 10;
                 if((ki == 8) || (ki == 13) || (ki == 18) || (ki == 23))  /** should be a dash in these positions ***/
                    {
                    if((ECC == TDSm1) || (ECC == TDSm2) || (ECC == TDSm3)  || (ECC == TDSm4) || (ECC == TDSm5) || (ECC == TDSm6))
                       {
                       sprintf(resultmessage,"Layer Identifier %s: Feature %s (%s): Attribute %s (%s): Required character '-' missing or misplaced\n",
                         shapefile,GetECCCode(ECC),GetECCLabel(ECC),GetEACCode(Indices[MGCP_UID_Indices_index]),
                              GetEACLabel(Indices[MGCP_UID_Indices_index]));
                       InsertIntoGIFD_MetaData_ErrorList(resultmessage,entryindex);
                       }
                    else if(PrintSchemaCodes > 0)
                       {
                       sprintf(resultmessage,"Layer Identifier %s: Feature %s (%s): Attribute %s (%s): Required character '-' missing or misplaced\n",
                         shapefile,GetECCCode(ECC),GetECCLabel(ECC),GetEACCode(Indices[MGCP_UID_Indices_index]),
                              GetEACLabel(Indices[MGCP_UID_Indices_index]));
                       }
                     else
                       {
                       sprintf(resultmessage,"Layer Identifier %s: Feature %s: %s Required character '-' missing or misplaced\n",
                          shapefile,GetECCLabel(ECC),GetEACLabel(Indices[MGCP_UID_Indices_index]));
                       }
                    }
                 else
                    {
                    if((ECC == TDSm1) || (ECC == TDSm2) || (ECC == TDSm3)  || (ECC == TDSm4) || (ECC == TDSm5) || (ECC == TDSm6))
                       {
                       sprintf(resultmessage,"Layer Identifier %s: Feature %s (%s): Attribute %s (%s): Unique Identifier contains character that is not hexadecimal\n",
                         shapefile,GetECCCode(ECC),GetECCLabel(ECC),GetEACCode(Indices[MGCP_UID_Indices_index]),
                              GetEACLabel(Indices[MGCP_UID_Indices_index]));
                       InsertIntoGIFD_MetaData_ErrorList(resultmessage,entryindex);
                       }
                    else if(PrintSchemaCodes > 0)
                       {
                       sprintf(resultmessage,"Layer Identifier %s: Feature %s (%s): Attribute %s (%s): contains character that is not hexadecimal\n",
                         shapefile,GetECCCode(ECC),GetECCLabel(ECC),GetEACCode(Indices[MGCP_UID_Indices_index]),
                              GetEACLabel(Indices[MGCP_UID_Indices_index]));
                       }
                     else
                       {
                       sprintf(resultmessage,"Layer Identifier %s: Feature %s: %s contains character that is not hexadecimal\n",
                          shapefile,GetECCLabel(ECC),GetEACLabel(Indices[MGCP_UID_Indices_index]));
                       }
                    }
                 }

              if(ATTRTYPE_SAC() == 0) /** SAC UUID problems recorded in the above clauses ***/
                 {
                 if((ECC != TDSm1) && (ECC != TDSm2) && (ECC != TDSm3) && (ECC != TDSm4) && (ECC != TDSm5) && (ECC != TDSm6))
                    InsertIntoGIFD_MetaData_ErrorList(resultmessage, 0 - LongListBadUIDcount[entryindex]);
                 }
              }


         if(seeitgeom != C_GRID)
            {
            if(ATTRTYPE_MGCP3() > 0)
               Inspect_MGCP_Metadata(ECC,Indices,entryindex,shapefile,NumAttr,seeitgeom, YearLimit, Smonth, Sday);
            else if(ATTRTYPE_MGCP4() > 0)
               Inspect_MGCP_4_Metadata(ECC,Indices,entryindex,shapefile,NumAttr,seeitgeom, YearLimit, Smonth, Sday);
            else if((ATTRTYPE_D4() > 0) || (ATTRTYPE_FACC() > 0) || (ATTRTYPE_VMAP() > 0)) 
               InspectGIFD_D4_Metadata(ECC,Indices,entryindex,shapefile,NumAttr,seeitgeom,YearLimit);
            else if((ATTRTYPE_UFD2() > 0) || (ATTRTYPE_UFD1() > 0) || (ATTRTYPE_UFD3() > 0))
               InspectGIFD_D4_Metadata(ECC,Indices,entryindex,shapefile,NumAttr,seeitgeom,YearLimit);
            else if(ATTRTYPE_SAC() > 0) /** SAC ***/
               Inspect_SAC_Metadata(ECC,Indices,entryindex,shapefile,NumAttr,seeitgeom, YearLimit);
            }
         }
      else
         {
         errrpt = fopen(metadatagigs,"wt");
         fprintf(errrpt,"Attributes were not inspected\n");
         fclose(errrpt);
         }

      if(ATTRTYPE_ANY_TDS() > 0)  /***  all TDS  have some 3-attribute VVT requirements****/
         {
         Twayc = TWay_Root;
         while(Twayc != NULL)
            {
            if((Twayc->presentvalue1 != NULL) && (Twayc->presentvalue2 != NULL) && (Twayc->depvalue != NULL))
               {
               sprintf(resultmessage,
              "x%s Layer Identifier %s: Feature %s %s\n   Attribute %s (%s), Value %s and Attribute %s (%s), Value %s assigned with Attribute: %s (%s) Value %s\n",
                  ParseGAITgeometry((unsigned char) Twayc->geom, 2),Twayc->shapename,GetECCCode(Twayc->code),GetECCLabel(Twayc->code),
                  GetEACCode(Twayc->Attr1),GetEACLabel(Twayc->Attr1),Twayc->presentvalue1,
                  GetEACCode(Twayc->Attr2),GetEACLabel(Twayc->Attr2),Twayc->presentvalue2,
                  GetEACCode(Twayc->DependentAttr),GetEACLabel(Twayc->DependentAttr),Twayc->depvalue);

               InsertIntoGIFD_AttrErrorList(resultmessage,entryindex);
               sprintf(resultmessage,"xAttribute - %s, Value - %s fails 3-way dependency requirement with %s and %s\n",
                  GetEACLabel(Twayc->DependentAttr),Twayc->depvalue,GetEACLabel(Twayc->Attr1),GetEACLabel(Twayc->Attr2));

               useid = InsertIntoAttrErrorList(resultmessage,entryindex);
               InsertIntoAttrIndexList(entryindex,useid);

               strcpy(EACcode,GetEACCode(Twayc->DependentAttr));
               sprintf(resultmessage,"x|%s|%s|%s|%s (%s)|%s (%s)|%s and %s|%s|%s|%s\n",
                           GetECCCode(Twayc->code),GetECCLabel(Twayc->code),ParseGAITgeometry((unsigned char) Twayc->geom, 2),
                           GetEACCode(Twayc->Attr1),GetEACLabel(Twayc->Attr1),
                           GetEACCode(Twayc->Attr2),GetEACLabel(Twayc->Attr2),
                           Twayc->presentvalue1,Twayc->presentvalue2,
                           GetEACCode(Twayc->DependentAttr),GetEACLabel(Twayc->DependentAttr),Twayc->depvalue);

               InsertIntoSummary_AttrErrorList(resultmessage,entryindex);

               sprintf(resultmessage,"X %d %d",Twayc->Attr1,Twayc->DependentAttr);

               InsertIntoSummary_AttrErrorList(resultmessage,entryindex);
               }
            Twayc = Twayc->next;
            }

         ResetVVT3Way();
         }
      if(ATTRTYPE_ANY_TDS() > 0)
         {
         if((BadOTH.OTHvalue == NULL) && (BadOTH.attrs != NULL))
            {
            sprintf(resultmessage,
        "x%s Layer Identifier %s: Feature %s %s\n   Attribute %s %s, Value 'Other' assigned without corresponding value in OTH attribute\n",
              ParseGAITgeometry((unsigned char) seeitgeom, 2),shapefile,GetECCCode(ECC),
              GetECCLabel(ECC),GetEACCode(BadOTH.attrs->acode),GetEACLabel(BadOTH.attrs->acode));
            InsertIntoGIFD_AttrErrorList(resultmessage,entryindex);

            sprintf(resultmessage,"xAttribute: %s, Value: %s without required value in OTH attribute\n",
                GetEACLabel(BadOTH.attrs->acode),"Other");
            useid = InsertIntoAttrErrorList(resultmessage,entryindex);
            InsertIntoAttrIndexList(entryindex,useid);

            sprintf(resultmessage,"x|%s|%s|%s|%s|%s|Other|%s|%s|%s",
                GetECCCode(ECC),GetECCLabel(ECC),ParseGAITgeometry((unsigned char) seeitgeom, 2),
                         GetEACCode(BadOTH.attrs->acode), GetEACLabel(BadOTH.attrs->acode),
                         GetEACCode(TDS_OTH_index), GetEACLabel(TDS_OTH_index),"Unassigned");
            InsertIntoSummary_AttrErrorList(resultmessage,entryindex);

            sprintf(resultmessage,"X %d %d",BadOTH.attrs->acode, TDS_OTH_index);
            InsertIntoSummary_AttrErrorList(resultmessage,entryindex);
            }
         else if((BadOTH.OTHvalue != NULL) &&
                    ((strcmp(BadOTH.OTHvalue,"noInformation") == 0) || (strcmp(BadOTH.OTHvalue,"No Information") == 0)) &&
                       (BadOTH.attrs != NULL))
            {
            sprintf(resultmessage,
        "x%s Layer Identifier %s: Feature %s %s\n   Attribute %s %s, Value is 'Other', but assigned 'No Information' value in OTH attribute\n",
              ParseGAITgeometry((unsigned char) seeitgeom, 2),shapefile,GetECCCode(ECC),
              GetECCLabel(ECC),GetEACCode(BadOTH.attrs->acode),GetEACLabel(BadOTH.attrs->acode));
            InsertIntoGIFD_AttrErrorList(resultmessage,entryindex);

            sprintf(resultmessage,"xAttribute: %s, Value: %s 'No Information' value in OTH attribute\n",
                       GetEACLabel(BadOTH.attrs->acode),"Other");
            useid = InsertIntoAttrErrorList(resultmessage,entryindex);
            InsertIntoAttrIndexList(entryindex,useid);

            sprintf(resultmessage,"x|%s|%s|%s|%s|%s|Other|%s|%s|%s",
                GetECCCode(ECC),GetECCLabel(ECC),ParseGAITgeometry((unsigned char) seeitgeom, 2),
                         GetEACCode(BadOTH.attrs->acode), GetEACLabel(BadOTH.attrs->acode),
                          GetEACCode(TDS_OTH_index), GetEACLabel(TDS_OTH_index),"No Information");
            InsertIntoSummary_AttrErrorList(resultmessage,entryindex);

            sprintf(resultmessage,"X %d %d",BadOTH.attrs->acode, TDS_OTH_index);
            InsertIntoSummary_AttrErrorList(resultmessage,entryindex);
            }
         else if((ATTRTYPE_TDS6() > 0) &&
                  (BadOTH.OTHvalue != NULL) &&  (strcmp(BadOTH.OTHvalue,"noInformation") != 0) &&
                        (BadOTH.attrs == NULL))
            {
            sprintf(resultmessage,
        "x%s Layer Identifier %s: Feature %s %s\n   Attribute %s %s, Value '%s', but no enumerated attributes are assigned value 'Other'\n",
              ParseGAITgeometry((unsigned char) seeitgeom, 2),shapefile,GetECCCode(ECC),
              GetECCLabel(ECC),GetEACCode(TDS_OTH_index),GetEACLabel(TDS_OTH_index),BadOTH.OTHvalue);
            InsertIntoGIFD_AttrErrorList(resultmessage,entryindex);

            sprintf(resultmessage,"xAttribute: %s, Value: '%s' No corresponding attributes assigned 'Other'\n",
                        GetEACLabel(TDS_OTH_index),BadOTH.OTHvalue);
            useid = InsertIntoAttrErrorList(resultmessage,entryindex);
            InsertIntoAttrIndexList(entryindex,useid);

            sprintf(resultmessage,"x|%s|%s|%s|%s|%s|Other|%s|%s|%s",
                GetECCCode(ECC),GetECCLabel(ECC),ParseGAITgeometry((unsigned char) seeitgeom, 2),
                         GetEACCode(TDS_OTH_index), GetEACLabel(TDS_OTH_index),
                          GetEACCode(TDS_OTH_index), GetEACLabel(TDS_OTH_index),BadOTH.OTHvalue);
            InsertIntoSummary_AttrErrorList(resultmessage,entryindex);

            sprintf(resultmessage,"X %d %d",TDS_OTH_index, TDS_OTH_index);
            InsertIntoSummary_AttrErrorList(resultmessage,entryindex);
            }
         else if((ATTRTYPE_TDS4() > 0) &&
                  (BadOTH.OTHvalue != NULL) &&  (strcmp(BadOTH.OTHvalue,"No Information") != 0) &&
                  /**(strcmp(BadOTH.OTHvalue,"No Information") != 0) &&**/
                        (BadOTH.attrs == NULL))
            {
            sprintf(resultmessage,
        "x%s Layer Identifier %s: Feature %s %s\n   Attribute %s %s, Value '%s', but no enumerated attributes are assigned value 'Other'\n",
              ParseGAITgeometry((unsigned char) seeitgeom, 2),shapefile,GetECCCode(ECC),
              GetECCLabel(ECC),GetEACCode(TDS_OTH_index),GetEACLabel(TDS_OTH_index),BadOTH.OTHvalue);
            InsertIntoGIFD_AttrErrorList(resultmessage,entryindex);

            sprintf(resultmessage,"xAttribute: %s, Value: '%s' No corresponding attributes assigned 'Other'\n",
                        GetEACLabel(TDS_OTH_index),BadOTH.OTHvalue);
            useid = InsertIntoAttrErrorList(resultmessage,entryindex);
            InsertIntoAttrIndexList(entryindex,useid);

            sprintf(resultmessage,"x|%s|%s|%s|%s|%s|Other|%s|%s|%s",
                GetECCCode(ECC),GetECCLabel(ECC),ParseGAITgeometry((unsigned char) seeitgeom, 2),
                         GetEACCode(TDS_OTH_index), GetEACLabel(TDS_OTH_index),
                          GetEACCode(TDS_OTH_index), GetEACLabel(TDS_OTH_index),BadOTH.OTHvalue);
            InsertIntoSummary_AttrErrorList(resultmessage,entryindex);

            sprintf(resultmessage,"X %d %d",TDS_OTH_index, TDS_OTH_index);
            InsertIntoSummary_AttrErrorList(resultmessage,entryindex);
            }
         else if((BadOTH.OTHvalue != NULL) && (BadOTH.attrs != NULL))
            {
            jj = OTHvalueCorrectFormat();
            if(jj == 0)
               {
               sprintf(resultmessage,
        "x%s Layer Identifier %s: Feature %s %s\n   Attribute %s %s, Value '%s', in incorrect format: see Entity Catalog requirement for datatype 'SpecifiedDomainValuesStructText'\n",
              ParseGAITgeometry((unsigned char) seeitgeom, 2),shapefile,GetECCCode(ECC),
              GetECCLabel(ECC),GetEACCode(TDS_OTH_index),GetEACLabel(TDS_OTH_index),BadOTH.OTHvalue);
               InsertIntoGIFD_AttrErrorList(resultmessage,entryindex);

               sprintf(resultmessage,"xAttribute: %s, Value: '%s' incorrect format\n",
                        GetEACLabel(TDS_OTH_index),BadOTH.OTHvalue);
               useid = InsertIntoAttrErrorList(resultmessage,entryindex);
               InsertIntoAttrIndexList(entryindex,useid);

               sprintf(resultmessage,"x|%s|%s|%s|%s|%s|Other|%s|%s|%s",
                GetECCCode(ECC),GetECCLabel(ECC),ParseGAITgeometry((unsigned char) seeitgeom, 2),
                         GetEACCode(TDS_OTH_index), GetEACLabel(TDS_OTH_index),
                          GetEACCode(TDS_OTH_index), GetEACLabel(TDS_OTH_index),BadOTH.OTHvalue);
               InsertIntoSummary_AttrErrorList(resultmessage,entryindex);

               sprintf(resultmessage,"X %d %d",TDS_OTH_index, TDS_OTH_index);
               InsertIntoSummary_AttrErrorList(resultmessage,entryindex);
               }
            }
         if(BadOTH.OTHvalue != NULL)
            {
            free(BadOTH.OTHvalue);
            BadOTH.OTHvalue = NULL;
            }
         if(BadOTH.attrs != NULL)
            {
            AFOc = BadOTH.attrs;
            while(AFOc != NULL)
               {
               AFOn = AFOc;
               AFOc = AFOc->next;
               free(AFOn);
               }
            BadOTH.attrs = NULL;
            }
         TDS_Interval_Vals = 17; /*** number in TDS schema v4.0 ***/
         if(ATTRTYPE_TDS6() > 0)
            TDS_Interval_Vals = 19; /*** the number in TDS v6 ***/
         else if(ATTRTYPE_GGDM21() > 0)
            TDS_Interval_Vals = 25;
         else if(ATTRTYPE_GGDM22() > 0)
            TDS_Interval_Vals = 25;
         else if(ATTRTYPE_GGDM3() > 0)
            TDS_Interval_Vals = 26;
         for(i=0; i< TDS_Interval_Vals; i++)
            {
            j = 0;
            if((Int_VVT[i].values_found == 3) || (Int_VVT[i].values_found == 7))  /*** found upper & lower **/
               {
               if((Int_VVT[i].lower != -999999.0) && (Int_VVT[i].upper != -999999.0))
                  {
                  if(Int_VVT[i].lower > Int_VVT[i].upper)
                     j = 1;
                  else if((Int_VVT[i].lower == Int_VVT[i].upper) && (Int_VVT[i].values_found == 7) && (strcmp(Int_VVT[i].closure,"Closed Interval") != 0))
                     j = 2;
                  }
               else if((ATTRTYPE_ANY_GGDM() == 0) && (Int_VVT[i].values_found == 7) && (Int_VVT[i].lower == -999999.0) && (Int_VVT[i].upper == -999999.0))
                  {
                  if(strcmp(Int_VVT[i].closure,"Closed Interval") != 0)
                     j = 2;
                  }
               }
            if(j == 1)
               {
               sprintf(resultmessage,
              "x%s Layer Identifier %s: Feature %s %s\n   Attribute %s (%s), Value %.1lf assigned with Attribute: %s (%s) Value %.1lf\n",
                  ParseGAITgeometry((unsigned char) seeitgeom, 2),shapefile,GetECCCode(ECC),GetECCLabel(ECC),
                  GetEACCode(Int_VVT[i].EAClower),GetEACLabel(Int_VVT[i].EAClower),Int_VVT[i].lower,
                  GetEACCode(Int_VVT[i].EACupper),GetEACLabel(Int_VVT[i].EACupper),Int_VVT[i].upper);

               InsertIntoGIFD_AttrErrorList(resultmessage,entryindex);
               sprintf(resultmessage,"xAttribute: %s, Value: %.1lf with Attribute: %s Value: %.4lf\n",
                    GetEACLabel(Int_VVT[i].EAClower),Int_VVT[i].lower,GetEACLabel(Int_VVT[i].EACupper),Int_VVT[i].upper);

               useid = InsertIntoAttrErrorList(resultmessage,entryindex);
               InsertIntoAttrIndexList(entryindex,useid);

               sprintf(resultmessage,"x|%s|%s|%s|%s|%s|%s|%s|%.1lf|%.1lf\n",
                           GetECCCode(ECC),GetECCLabel(ECC),ParseGAITgeometry((unsigned char) seeitgeom, 2),
                           GetEACCode(Int_VVT[i].EAClower),GetEACLabel(Int_VVT[i].EAClower),
                           GetEACCode(Int_VVT[i].EACupper),GetEACLabel(Int_VVT[i].EACupper),
                           Int_VVT[i].lower, Int_VVT[i].upper);

               InsertIntoSummary_AttrErrorList(resultmessage,entryindex);

               sprintf(resultmessage,"X %d %d",Int_VVT[i].EAClower,Int_VVT[i].EACupper);

               InsertIntoSummary_AttrErrorList(resultmessage,entryindex);
               }
            else if(j == 2)
               {
               sprintf(resultmessage,
              "x%s Layer Identifier %s: Feature %s %s\n   Attribute %s (%s), Value %.1lf and Attribute %s (%s), Value %.1lf  assigned with Attribute: %s (%s) Value %s\n",
                  ParseGAITgeometry((unsigned char) seeitgeom, 2),shapefile,GetECCCode(ECC),GetECCLabel(ECC),
                  GetEACCode(Int_VVT[i].EAClower),GetEACLabel(Int_VVT[i].EAClower),Int_VVT[i].lower,
                  GetEACCode(Int_VVT[i].EACupper),GetEACLabel(Int_VVT[i].EACupper),Int_VVT[i].upper,
                    GetEACCode(Int_VVT[i].EACclosure),GetEACLabel(Int_VVT[i].EACclosure),Int_VVT[i].closure);

               InsertIntoGIFD_AttrErrorList(resultmessage,entryindex);
               sprintf(resultmessage,"xAttribute: %s, Value: %.1lf with Attribute: %s Value: %.4lf\n",
                    GetEACLabel(Int_VVT[i].EAClower),Int_VVT[i].lower,GetEACLabel(Int_VVT[i].EACupper),Int_VVT[i].upper);

               useid = InsertIntoAttrErrorList(resultmessage,entryindex);
               InsertIntoAttrIndexList(entryindex,useid);

               sprintf(resultmessage,"x|%s|%s|%s|%s (%s)|%s (%s)|%.1lf|%.1lf|%s|%s\n",
                           GetECCCode(ECC),GetECCLabel(ECC),ParseGAITgeometry((unsigned char) seeitgeom, 2),
                           GetEACCode(Int_VVT[i].EAClower),GetEACLabel(Int_VVT[i].EAClower),
                           GetEACCode(Int_VVT[i].EACupper),GetEACLabel(Int_VVT[i].EACupper),
                           Int_VVT[i].lower, Int_VVT[i].upper,
                            GetEACCode(Int_VVT[i].EACclosure),GetEACLabel(Int_VVT[i].EACclosure));

               InsertIntoSummary_AttrErrorList(resultmessage,entryindex);

               sprintf(resultmessage,"X %d %d",Int_VVT[i].EAClower,Int_VVT[i].EACupper);

               InsertIntoSummary_AttrErrorList(resultmessage,entryindex);
               }

            }
         ResetInternalVVT();
         }

      if((ATTRTYPE_ANY_TDS() > 0)  ||
           (ATTRTYPE_ANY_GGDM() > 0)) /*** GGDM ***/
         {
         TDS_Interval_Vals = TDS4_MultiAttr; /*** number in TDS schema v4.0 ***/
         if(ATTRTYPE_TDS6() > 0)
            TDS_Interval_Vals = TDS6_MultiAttr; /*** the number in TDS v6 ***/
         else if(ATTRTYPE_GGDM22() > 0) /** number in GGDM ***/
            TDS_Interval_Vals = GGDM_22_MultiAttr;
         else if(ATTRTYPE_GGDM21() > 0) /** number in GGDM ***/
            TDS_Interval_Vals = GGDM_21_MultiAttr;
         else if(ATTRTYPE_GGDM3() > 0)
            TDS_Interval_Vals = GGDM_3_MultiAttr;
         for(i=0; i< TDS_Interval_Vals; i++)
            {
            if((ValueSets[i].vc1 != NULL) && (ValueSets[i].ac1 != -999))
               {
               if((ValueSets[i].vc2 != NULL) && (strcmp(ValueSets[i].vc1,ValueSets[i].vc2) == 0))
                  {
                  if(PrintSchemaCodes > 0)
                     {
                     sprintf(resultmessage,
      "x%s Layer Identifier %s: Feature %s %s\n   Attribute %s %s, Value %s assigned with Attribute: %s (%s) Value %s (values should differ)\n",
                       ParseGAITgeometry((unsigned char) ValueSets[i].geom, 2),shapefile,GetECCCode(ValueSets[i].fcode),
                       GetECCLabel(ValueSets[i].fcode),GetEACCode(ValueSets[i].ac1),
                       GetEACLabel(ValueSets[i].ac1),ValueSets[i].vc1,
                        GetEACCode(ValueSets[i].ac2),GetEACLabel(ValueSets[i].ac2),ValueSets[i].vc2);
                     }
                  else
                     {
                     sprintf(resultmessage,
      "x%s Layer Identifier %s: Feature %s\n   Attribute %s, Value %s assigned with Attribute: %s Value %s (values should differ)\n",
                       ParseGAITgeometry((unsigned char) ValueSets[i].geom, 2),shapefile,
                       GetECCLabel(ValueSets[i].fcode),
                       GetEACLabel(ValueSets[i].ac1),ValueSets[i].vc1,
                       GetEACLabel(ValueSets[i].ac2),ValueSets[i].vc2);
                     }

                  InsertIntoGIFD_AttrErrorList(resultmessage,entryindex);
                  sprintf(resultmessage,"xAttribute: %s, Value: %s with Attribute: %s Value: %s\n",
                  GetEACLabel(ValueSets[i].ac1),ValueSets[i].vc1, GetEACLabel(ValueSets[i].ac2),ValueSets[i].vc2);

                  useid = InsertIntoAttrErrorList(resultmessage,entryindex);
                  InsertIntoAttrIndexList(entryindex,useid);

                  sprintf(resultmessage,"x|%s|%s|%s|%s|%s|%s|%s|%s|%s\n",
                      GetECCCode(ValueSets[i].fcode),GetECCLabel(ValueSets[i].fcode),ParseGAITgeometry((unsigned char) ValueSets[i].geom, 2),
                      GetEACCode(ValueSets[i].ac1),GetEACLabel(ValueSets[i].ac1),ValueSets[i].vc1,
                      GetEACCode(ValueSets[i].ac2),GetEACLabel(ValueSets[i].ac2),ValueSets[i].vc2);

                  InsertIntoSummary_AttrErrorList(resultmessage,entryindex);

                  sprintf(resultmessage,"X %d %d",ValueSets[i].ac1,ValueSets[i].ac2);
                  InsertIntoSummary_AttrErrorList(resultmessage,entryindex);
                  }

               if((ValueSets[i].vc3 != NULL) && (strcmp(ValueSets[i].vc1,ValueSets[i].vc3) == 0))
                  {
                  if(PrintSchemaCodes > 0)
                     {
                     sprintf(resultmessage,
      "x%s Layer Identifier %s: Feature %s %s\n   Attribute %s %s, Value %s assigned with Attribute: %s (%s) Value %s (values should differ)\n",
                       ParseGAITgeometry((unsigned char) ValueSets[i].geom, 2),shapefile,GetECCCode(ValueSets[i].fcode),
                       GetECCLabel(ValueSets[i].fcode),GetEACCode(ValueSets[i].ac1),
                       GetEACLabel(ValueSets[i].ac1),ValueSets[i].vc1,
                        GetEACCode(ValueSets[i].ac3),GetEACLabel(ValueSets[i].ac3),ValueSets[i].vc3);
                     }
                  else
                     {
                     sprintf(resultmessage,
      "x%s Layer Identifier %s: Feature %s\n   Attribute %s, Value %s assigned with Attribute: %s Value %s (values should differ)\n",
                       ParseGAITgeometry((unsigned char) ValueSets[i].geom, 2),shapefile,
                       GetECCLabel(ValueSets[i].fcode),
                       GetEACLabel(ValueSets[i].ac1),ValueSets[i].vc1,
                       GetEACLabel(ValueSets[i].ac3),ValueSets[i].vc3);
                     }

                  InsertIntoGIFD_AttrErrorList(resultmessage,entryindex);
                  sprintf(resultmessage,"xAttribute: %s, Value: %s with Attribute: %s Value: %s\n",
                  GetEACLabel(ValueSets[i].ac1),ValueSets[i].vc1, GetEACLabel(ValueSets[i].ac3),ValueSets[i].vc3);

                  useid = InsertIntoAttrErrorList(resultmessage,entryindex);
                  InsertIntoAttrIndexList(entryindex,useid);

                  sprintf(resultmessage,"x|%s|%s|%s|%s|%s|%s|%s|%s|%s\n",
                      GetECCCode(ValueSets[i].fcode),GetECCLabel(ValueSets[i].fcode),ParseGAITgeometry((unsigned char) ValueSets[i].geom, 2),
                      GetEACCode(ValueSets[i].ac1),GetEACLabel(ValueSets[i].ac1),ValueSets[i].vc1,
                      GetEACCode(ValueSets[i].ac3),GetEACLabel(ValueSets[i].ac3),ValueSets[i].vc3);

                  InsertIntoSummary_AttrErrorList(resultmessage,entryindex);

                  sprintf(resultmessage,"X %d %d",ValueSets[i].ac1,ValueSets[i].ac3);
                  InsertIntoSummary_AttrErrorList(resultmessage,entryindex);

                  }

               }

            if((ValueSets[i].vc2 != NULL) && (ValueSets[i].ac2 != -999))
               {
               if((ValueSets[i].vc3 != NULL) && (strcmp(ValueSets[i].vc2,ValueSets[i].vc3) == 0))
                  {
                  if(PrintSchemaCodes > 0)
                     {
                     sprintf(resultmessage,
      "x%s Layer Identifier %s: Feature %s %s\n   Attribute %s %s, Value %s assigned with Attribute: %s (%s) Value %s (values should differ)\n",
                       ParseGAITgeometry((unsigned char) ValueSets[i].geom, 2),shapefile,GetECCCode(ValueSets[i].fcode),
                       GetECCLabel(ValueSets[i].fcode),GetEACCode(ValueSets[i].ac2),
                       GetEACLabel(ValueSets[i].ac2),ValueSets[i].vc2,
                        GetEACCode(ValueSets[i].ac3),GetEACLabel(ValueSets[i].ac3),ValueSets[i].vc3);
                     }
                  else
                     {
                     sprintf(resultmessage,
      "x%s Layer Identifier %s: Feature %s\n   Attribute %s, Value %s assigned with Attribute: %s Value %s (values should differ)\n",
                       ParseGAITgeometry((unsigned char) ValueSets[i].geom, 2),shapefile,
                       GetECCLabel(ValueSets[i].fcode),
                       GetEACLabel(ValueSets[i].ac2),ValueSets[i].vc2,
                       GetEACLabel(ValueSets[i].ac3),ValueSets[i].vc3);
                     }

                  InsertIntoGIFD_AttrErrorList(resultmessage,entryindex);
                  sprintf(resultmessage,"xAttribute: %s, Value: %s with Attribute: %s Value: %s\n",
                  GetEACLabel(ValueSets[i].ac2),ValueSets[i].vc2, GetEACLabel(ValueSets[i].ac3),ValueSets[i].vc3);

                  useid = InsertIntoAttrErrorList(resultmessage,entryindex);
                  InsertIntoAttrIndexList(entryindex,useid);

                  sprintf(resultmessage,"x|%s|%s|%s|%s|%s|%s|%s|%s|%s\n",
                      GetECCCode(ValueSets[i].fcode),GetECCLabel(ValueSets[i].fcode),ParseGAITgeometry((unsigned char) ValueSets[i].geom, 2),
                      GetEACCode(ValueSets[i].ac2),GetEACLabel(ValueSets[i].ac2),ValueSets[i].vc2,
                      GetEACCode(ValueSets[i].ac3),GetEACLabel(ValueSets[i].ac3),ValueSets[i].vc3);

                  InsertIntoSummary_AttrErrorList(resultmessage,entryindex);

                  sprintf(resultmessage,"X %d %d",ValueSets[i].ac2,ValueSets[i].ac3);
                  InsertIntoSummary_AttrErrorList(resultmessage,entryindex);
                  }
               }

            if((ValueSets[i].vc1 != NULL) && (ValueSets[i].ac1 != -999))
               {
               if((ValueSets[i].vc4 != NULL) && (strcmp(ValueSets[i].vc1,ValueSets[i].vc4) == 0))
                  {
                  if(PrintSchemaCodes > 0)
                     {
                     sprintf(resultmessage,
      "x%s Layer Identifier %s: Feature %s %s\n   Attribute %s %s, Value %s assigned with Attribute: %s (%s) Value %s (values should differ)\n",
                       ParseGAITgeometry((unsigned char) ValueSets[i].geom, 2),shapefile,GetECCCode(ValueSets[i].fcode),
                       GetECCLabel(ValueSets[i].fcode),GetEACCode(ValueSets[i].ac1),
                       GetEACLabel(ValueSets[i].ac1),ValueSets[i].vc1,
                        GetEACCode(ValueSets[i].ac4),GetEACLabel(ValueSets[i].ac4),ValueSets[i].vc4);
                     }
                  else
                     {
                     sprintf(resultmessage,
      "x%s Layer Identifier %s: Feature %s\n   Attribute %s, Value %s assigned with Attribute: %s Value %s (values should differ)\n",                       ParseGAITgeometry((unsigned char) ValueSets[i].geom, 2),shapefile,
                       GetECCLabel(ValueSets[i].fcode),
                       GetEACLabel(ValueSets[i].ac1),ValueSets[i].vc1,
                       GetEACLabel(ValueSets[i].ac4),ValueSets[i].vc4);
                     }

                  InsertIntoGIFD_AttrErrorList(resultmessage,entryindex);
                  sprintf(resultmessage,"xAttribute: %s, Value: %s with Attribute: %s Value: %s\n",
                  GetEACLabel(ValueSets[i].ac1),ValueSets[i].vc1, GetEACLabel(ValueSets[i].ac4),ValueSets[i].vc4);

                  useid = InsertIntoAttrErrorList(resultmessage,entryindex);
                  InsertIntoAttrIndexList(entryindex,useid);

                  sprintf(resultmessage,"x|%s|%s|%s|%s|%s|%s|%s|%s|%s\n",
                      GetECCCode(ValueSets[i].fcode),GetECCLabel(ValueSets[i].fcode),ParseGAITgeometry((unsigned char) ValueSets[i].geom, 2),
                      GetEACCode(ValueSets[i].ac1),GetEACLabel(ValueSets[i].ac1),ValueSets[i].vc1,
                      GetEACCode(ValueSets[i].ac4),GetEACLabel(ValueSets[i].ac4),ValueSets[i].vc4);

                  InsertIntoSummary_AttrErrorList(resultmessage,entryindex);

                  sprintf(resultmessage,"X %d %d",ValueSets[i].ac1,ValueSets[i].ac4);
                  InsertIntoSummary_AttrErrorList(resultmessage,entryindex);
                  }
               }

            if((ValueSets[i].vc2 != NULL) && (ValueSets[i].ac2 != -999))
               {
               if((ValueSets[i].vc4 != NULL) && (strcmp(ValueSets[i].vc2,ValueSets[i].vc4) == 0))
                  {
                  if(PrintSchemaCodes > 0)
                     {
                     sprintf(resultmessage,
      "x%s Layer Identifier %s: Feature %s %s\n   Attribute %s %s, Value %s assigned with Attribute: %s (%s) Value %s (values should differ)\n",
                       ParseGAITgeometry((unsigned char) ValueSets[i].geom, 2),shapefile,GetECCCode(ValueSets[i].fcode),
                       GetECCLabel(ValueSets[i].fcode),GetEACCode(ValueSets[i].ac2),
                       GetEACLabel(ValueSets[i].ac2),ValueSets[i].vc2,
                        GetEACCode(ValueSets[i].ac4),GetEACLabel(ValueSets[i].ac4),ValueSets[i].vc4);
                     }
                  else
                     {
                     sprintf(resultmessage,
      "x%s Layer Identifier %s: Feature %s\n   Attribute %s, Value %s assigned with Attribute: %s Value %s (values should differ)\n",                       ParseGAITgeometry((unsigned char) ValueSets[i].geom, 2),shapefile,
                       GetECCLabel(ValueSets[i].fcode),
                       GetEACLabel(ValueSets[i].ac2),ValueSets[i].vc2,
                       GetEACLabel(ValueSets[i].ac4),ValueSets[i].vc4);
                     }

                  InsertIntoGIFD_AttrErrorList(resultmessage,entryindex);
                  sprintf(resultmessage,"xAttribute: %s, Value: %s with Attribute: %s Value: %s\n",
                  GetEACLabel(ValueSets[i].ac2),ValueSets[i].vc2, GetEACLabel(ValueSets[i].ac4),ValueSets[i].vc4);

                  useid = InsertIntoAttrErrorList(resultmessage,entryindex);
                  InsertIntoAttrIndexList(entryindex,useid);

                  sprintf(resultmessage,"x|%s|%s|%s|%s|%s|%s|%s|%s|%s\n",
                      GetECCCode(ValueSets[i].fcode),GetECCLabel(ValueSets[i].fcode),ParseGAITgeometry((unsigned char) ValueSets[i].geom, 2),
                      GetEACCode(ValueSets[i].ac2),GetEACLabel(ValueSets[i].ac2),ValueSets[i].vc2,
                      GetEACCode(ValueSets[i].ac4),GetEACLabel(ValueSets[i].ac4),ValueSets[i].vc4);

                  InsertIntoSummary_AttrErrorList(resultmessage,entryindex);

                  sprintf(resultmessage,"X %d %d",ValueSets[i].ac2,ValueSets[i].ac4);
                  InsertIntoSummary_AttrErrorList(resultmessage,entryindex);
                  }
               }

            if((ValueSets[i].vc3 != NULL) && (ValueSets[i].ac3 != -999))
               {
               if((ValueSets[i].vc4 != NULL) && (strcmp(ValueSets[i].vc3,ValueSets[i].vc4) == 0))
                  {
                  if(PrintSchemaCodes > 0)
                     {
                     sprintf(resultmessage,
      "x%s Layer Identifier %s: Feature %s %s\n   Attribute %s %s, Value %s assigned with Attribute: %s (%s) Value %s (values should differ)\n",
                       ParseGAITgeometry((unsigned char) ValueSets[i].geom, 2),shapefile,GetECCCode(ValueSets[i].fcode),
                       GetECCLabel(ValueSets[i].fcode),GetEACCode(ValueSets[i].ac3),
                       GetEACLabel(ValueSets[i].ac3),ValueSets[i].vc3,
                        GetEACCode(ValueSets[i].ac4),GetEACLabel(ValueSets[i].ac4),ValueSets[i].vc4);
                     }
                  else
                     {
                     sprintf(resultmessage,
      "x%s Layer Identifier %s: Feature %s\n   Attribute %s, Value %s assigned with Attribute: %s Value %s (values should differ)\n",                       ParseGAITgeometry((unsigned char) ValueSets[i].geom, 2),shapefile,
                       GetECCLabel(ValueSets[i].fcode),
                       GetEACLabel(ValueSets[i].ac3),ValueSets[i].vc3,
                       GetEACLabel(ValueSets[i].ac4),ValueSets[i].vc4);
                     }

                  InsertIntoGIFD_AttrErrorList(resultmessage,entryindex);
                  sprintf(resultmessage,"xAttribute: %s, Value: %s with Attribute: %s Value: %s\n",
                  GetEACLabel(ValueSets[i].ac3),ValueSets[i].vc3, GetEACLabel(ValueSets[i].ac4),ValueSets[i].vc4);

                  useid = InsertIntoAttrErrorList(resultmessage,entryindex);
                  InsertIntoAttrIndexList(entryindex,useid);

                  sprintf(resultmessage,"x|%s|%s|%s|%s|%s|%s|%s|%s|%s\n",
                      GetECCCode(ValueSets[i].fcode),GetECCLabel(ValueSets[i].fcode),ParseGAITgeometry((unsigned char) ValueSets[i].geom, 2),
                      GetEACCode(ValueSets[i].ac3),GetEACLabel(ValueSets[i].ac3),ValueSets[i].vc3,
                      GetEACCode(ValueSets[i].ac4),GetEACLabel(ValueSets[i].ac4),ValueSets[i].vc4);

                  InsertIntoSummary_AttrErrorList(resultmessage,entryindex);

                  sprintf(resultmessage,"X %d %d",ValueSets[i].ac3,ValueSets[i].ac4);
                  InsertIntoSummary_AttrErrorList(resultmessage,entryindex);
                  }
               }

            }

         FreeNotEqualEnums();
         }



      SEEIT_fread_int(&ECC,fileptr);

      NumDone += 1.0;
      PCdone = (NumDone * 100.0) / NumToCheck;

      BuildOpenMenu(PCdone,SACfull_x_2,SACfull_x_2,linears_done, areals_done,model_polys,areals_done,linears_done,points_done,
              sphere_cv,parallel_cv,stamps_done,footprints_done, bridges_done,g_read,g_write,
              FMpointsdone,FMlinesdone,FMarealsdone,100.0,100.0,100.0,0.0, 0);
      }

   if(portrayfails != NULL)
      {
      counter = -1;
      SEEIT_fwrite_int(&counter,portrayfails);
      SEEIT_fwrite_int(&counter,portrayfails);
      fclose(portrayfails);
      }

   fclose(fileptr);

   portrayfails = NULL;
   if((UNKroot != NULL) || (NNNroot != NULL))
      {
      if(ATTRTYPE_MGCP4() > 0)
         sprintf(resultmessage,"%sMGCP4_NAM_NFI_NFN.txt",outsumdirectory);
      else if(ATTRTYPE_TDS6() > 0)
         sprintf(resultmessage,"%sTDS6_FNA_NFN.txt",outsumdirectory);
      portrayfails = fopen(resultmessage,"wt");
      if(ATTRTYPE_MGCP4() > 0)
         fprintf(portrayfails,"FCODE\tFeature\tNAM\tNFI\tNFN\tAttention\n");
      else if(ATTRTYPE_TDS6() > 0)
         fprintf(portrayfails,"FCODE\tFeature\tZI005_FNA\tZI005_NFN\n");
      unusedint = 0;
      }

   if(UNKroot != NULL)
      {
      NNc = UNKroot;
      while(NNc != NULL)
         {
         NNp = NNc;

         ii1 = 0;
         for(ii2 = 0; ii2 < 10; ii2++)
            {
            if((NNp->NNNstr[ii2] >= '0') && (NNp->NNNstr[ii2] <= '9'))
               {
               ii1 = (ii1 * 10) + ((int) (NNp->NNNstr[ii2]) - 48);
               }
            else
               break;
            }

         if(unusedint < 63990)
            {
            if(ATTRTYPE_MGCP4() > 0)
               fprintf(portrayfails,"\"%s\"\t\"%s\"\t\"%s\"\t%s\t%s\t",
                    GetECCCode(ii1),GetECCLabel(ii1),NNc->NAMstr,NNc->NFIstr,NNc->NFNstr);
            else if(ATTRTYPE_TDS6() > 0)
               {
               if((strcmp(NNc->NAMstr,"No Information") != 0) || (strcmp(NNc->NFNstr,"No Information") != 0))
                  fprintf(portrayfails,"\"%s\"\t\"%s\"\t\"%s\"\t%s\n",
                    GetECCCode(ii1),GetECCLabel(ii1),NNc->NAMstr,NNc->NFNstr);
               }
            }
         NNc = NNc->next;
         if((ATTRTYPE_MGCP4() > 0)&& (unusedint < 63990))
            {
            ii1 = 0;
            for(ii2 = 0; ii2 < 10; ii2++)
               {
               if((NNp->NNNstr[ii2] >= '0') && (NNp->NNNstr[ii2] <= '9'))
                  {
                  ii1 = (ii1 * 10) + ((int) (NNp->NNNstr[ii2]) - 48);
                  }
               else
                  break;
               }
            if((strcmp(NNp->NFIstr,"\"N_A\"") != 0) && (strcmp(NNp->NFNstr,"\"N_A\"") != 0))
               {
               if(strcmp(NNp->NFIstr,NNp->NFNstr) == 0)
                  fprintf(portrayfails,"NFI equals NFN\n");
               else if(strcmp(NNp->NFIstr,"\"N_A\"") == 0)
                  fprintf(portrayfails,"Only NFI is N_A\n");
               else if(strcmp(NNp->NFNstr,"\"N_A\"") == 0)
                  fprintf(portrayfails,"Only NFN is N_A\n");
               else
                  fprintf(portrayfails," \n");
               }
            else
               fprintf(portrayfails," \n");
            }
         free(NNp->NAMstr);
         free(NNp->NFIstr);
         free(NNp->NFNstr);
         free(NNp->NNNstr);
         free(NNp);
         ++unusedint;
         }
      }
   if(NNNroot != NULL)
      {
      NNc = NNNroot;
      while(NNc != NULL)
         {
         NNp = NNc;
         ii1 = 0;
         for(ii2 = 0; ii2 < 10; ii2++)
            {
            if((NNp->NNNstr[ii2] >= '0') && (NNp->NNNstr[ii2] <= '9'))
               {
               ii1 = (ii1 * 10) + ((int) (NNp->NNNstr[ii2]) - 48);
               }
            else
               break;
            }

         if(unusedint < 63990)
            {
            if(ATTRTYPE_MGCP4() > 0)
               fprintf(portrayfails,"\"%s\"\t\"%s\"\t\"%s\"\t%s\t%s\t",
                    GetECCCode(ii1),GetECCLabel(ii1),NNc->NAMstr,NNc->NFIstr,NNc->NFNstr);
            else if(ATTRTYPE_TDS6() > 0)
               {
               if(strstr(NNc->NAMstr,"No Information") == NULL)
                  fprintf(portrayfails,"\"%s\"\t\"%s\"\t\"%s\"\t%s\n",
                    GetECCCode(ii1),GetECCLabel(ii1),NNc->NAMstr,NNc->NFNstr);
               else if(strstr(NNc->NFNstr,"No Information") == NULL)
                  fprintf(portrayfails,"\"%s\"\t\"%s\"\t\"%s\"\t%s\n",
                    GetECCCode(ii1),GetECCLabel(ii1),NNc->NAMstr,NNc->NFNstr);
               }
            }
         NNc = NNc->next;
         if((ATTRTYPE_MGCP4() > 0) && (unusedint < 63990))
            {
            if((strcmp(NNp->NFIstr,"\"N_A\"") != 0) && (strcmp(NNp->NFNstr,"\"N_A\"") != 0))
               {
               if(strcmp(NNp->NFIstr,NNp->NFNstr) == 0)
                  fprintf(portrayfails,"NFI equals NFN\n");
               else if(strcmp(NNp->NFIstr,"\"N_A\"") == 0)
                  fprintf(portrayfails,"Only NFI is N_A\n");
               else if(strcmp(NNp->NFNstr,"\"N_A\"") == 0)
                  fprintf(portrayfails,"Only NFN is N_A\n");
               else
                  fprintf(portrayfails," \n");
               }
            else
               fprintf(portrayfails," \n");
            }
         free(NNp->NAMstr);
         free(NNp->NFIstr);
         free(NNp->NFNstr);
         free(NNp->NNNstr);
         free(NNp);
         ++unusedint;
         }
      }
   if(portrayfails != NULL)
      {
      if(unusedint >= 63990)
         fprintf(portrayfails,"maximum row limit reached - more values are in the project\n");
      fclose(portrayfails);
      portrayfails = NULL;
      }

   AE_TDS_NEc = AE_TDS_NEroot;
   while(AE_TDS_NEc != NULL)
      {
      AE_TDS_NEp = AE_TDS_NEc;
      AE_TDS_NEc = AE_TDS_NEc->next;
      free(AE_TDS_NEp);
      }
   AE_TDS_NEroot = NULL;

   free(titlechar);


   FreeNGAattrSpec();

   if(TWay_Root != NULL)
      FreeVVT3WayEntries();
   if(MGCP_VVT_root != NULL)
      FreeVVTstructs();

   PRc = PickRoot;
   while(PRc != NULL)
      {
      PRp = PRc;
      PRc = PRc->next;

      pc = PRp->picks;
      while(pc != NULL)
         {
         pp = pc;
         pc = pc->next;
         if(pp->code != NULL)
            free(pp->code);
         if(pp->value != NULL)
            free(pp->value);
         free(pp);
         }
      free(PRp);
      }

   if(portrayreport != NULL)
      {
      fclose(portrayreport);
      Portray_RB_Tree = TTF_RBTreeCreate(TTF_StdStrComp,TTF_IDstr_StrDest,RB_ID_InfoDest,TTF_IntPrint,TTF_InfoPrint);
      portrayreport = fopen(portrayalfile,"rt");
      fgets(resultmessage,1999,portrayreport);
      while(feof(portrayreport) == 0)
         {
         i = j = 0;
         while(resultmessage[i] != ',')
            {
            if((resultmessage[i] >= '0') && (resultmessage[i] <= '9'))
               j = j * 10 + (((int) resultmessage[i] - 48));
            ++i;
            }
         ++i;
         ki = i;
         while(resultmessage[ki] != ',') /** should skip over the fcode for sort key purposes ***/
            ++ki;
         ++ki;
         res2 = (char *) (malloc(strlen(&resultmessage[ki]) + 1));
         strcpy(res2,&resultmessage[ki]);
         if((RB_newNode = TTF_RBExactQuery(Portray_RB_Tree,res2)))
            {
            free(res2);
            RB_ID1 = (struct RB_IDkey *) RB_newNode->info;
            RB_ID1->counter += j;
            }
         else
            {
            RB_ID1 = (struct RB_IDkey *)(malloc(SzIDK));
            if(RB_ID1 == NULL)
               {
               printf("memory has been exhausted during RB-Tree information alloction for Unique Identifier frequency analysis\n");
               exit(-1);
               }
            RB_ID1->idstr = (char *) malloc(strlen(&resultmessage[i]) + 1);
            strcpy(RB_ID1->idstr,&resultmessage[i]);
            RB_ID1->counter = j;
            TTF_RBTreeInsert(Portray_RB_Tree,res2,RB_ID1);
            }

         fgets(resultmessage,1999,portrayreport);
         }
      fclose(portrayreport);
      portrayreport = fopen(portrayalfile,"wt");

      if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
        {
        sprintf(resultmessage,"%sinternal_data\\PFF.bin",indirectory);
        }
      else
        {
        sprintf(resultmessage,"%sinternal_data/PFF.bin",indirectory);
        }
      portrayfails = fopen(resultmessage,"wt");

      fprintf(portrayreport,"FCODE,Feature,Geometry,# Applicable Rules,Features In Project,Portrayed Features,Percent Portrayed\n");

      for(i=0; i<MaxPortrayRules; i++)
         {
         P_pass = C_pass = S_pass = 0;
         P_try = C_try = S_try = 0;
         Type1 = Type2 = Type3 = 0;
         cnl = NULL;
         if((PVF[i].curve != NULL) || (PVF[i].surface != NULL) || (PVF[i].point != NULL))
            {
            cnl = NListRoot;
            while(cnl != NULL)
               {
               if(cnl->ECC == i)
                  break;
               cnl = cnl->next;
               }
            }
         if(cnl != NULL)
            {
            pnl = cnl;
            if(PVF[i].curve != NULL)
               {
               PRc1 = PVF[i].curve->rules;
               while(PRc1 != NULL)
                  {
                  C_try += 1;
                  C_pass += PRc1->success;
                  PRc1 = PRc1->next;
                  }
               while((pnl != NULL) && (pnl->ECC == i))
                  {
                  if(pnl->configcount[C_LINE] > 0)
                     {
                     Type1 += (int) pnl->configcount[C_LINE];
                     }
                  pnl = pnl->next;
                  }
               }
            pnl = cnl;
            if(PVF[i].point != NULL)
               {
               PRc1 = PVF[i].point->rules;
               while(PRc1 != NULL)
                  {
                  P_try += 1;
                  P_pass += PRc1->success;
                  PRc1 = PRc1->next;
                  }
               while((pnl != NULL) && (pnl->ECC == i))
                  {
                  if(pnl->configcount[C_POFE] > 0)
                     {
                     Type2 += (int) pnl->configcount[C_POFE];
                     }
                  pnl = pnl->next;
                  }
               }
            pnl = cnl;

            if(PVF[i].surface != NULL)
               {
               PRc1 = PVF[i].surface->rules;
               while(PRc1 != NULL)
                  {
                  S_try += 1;
                  S_pass += PRc1->success;
                  PRc1 = PRc1->next;
                  }
               while((pnl != NULL) && (pnl->ECC == i))
                  {
                  if(pnl->configcount[C_AREA] > 0)
                     {
                     Type3 += (int) pnl->configcount[C_AREA];
                     }
                  pnl = pnl->next;
                  }
               }
            }
         if((ATTRTYPE_MGCP4() > 0) || (ATTRTYPE_TDS6() > 0))
            {
            if((P_try > 0) && (Type2 > 0))
               {
               fprintf(portrayreport,"%s,%s,Point,%d,%d,%d,%.2lf\n",
                    GetECCCode(i), GetECCLabel(i),P_try,Type2, P_pass,((double) P_pass) / ((double) Type2) *100.0);

               if(Type2 > P_pass)
                  {
                  fprintf(portrayfails,"%s P\n",GetECCCode(i));
                  RAc = PVF[i].point->attrs;
                  if(RAc == NULL)
                     fprintf(portrayfails,"(no attributes involved)\n");
                  else
                     {
                     fprintf(portrayfails,"failure caused by value of ");
                     fprintf(portrayfails,"%s",GetEACCode(RAc->EAC));
                     RAc = RAc->next;
                     if(RAc == NULL)
                        fprintf(portrayfails,"\n");
                     while(RAc != NULL)
                        {
                        if(RAc->next == NULL)
                           fprintf(portrayfails," and / or %s\n",GetEACCode(RAc->EAC));
                        else
                           fprintf(portrayfails,", %s",GetEACCode(RAc->EAC));
                        RAc = RAc->next;
                        }
                     }
                  }
               }
            if((C_try > 0) && (Type1 > 0))
               {
               fprintf(portrayreport,"%s,%s,Line,%d,%d,%d,%.2lf\n",
                    GetECCCode(i), GetECCLabel(i),C_try,Type1, C_pass,((double) C_pass) / ((double) Type1) *100.0);

               if(Type1 > C_pass)
                  {
                  fprintf(portrayfails,"%s L\n",GetECCCode(i));
                  RAc = PVF[i].curve->attrs;
                  if(RAc == NULL)
                     fprintf(portrayfails,"(no attributes involved)\n");
                  else
                     {
                     fprintf(portrayfails,"failure caused by value of ");
                     fprintf(portrayfails,"%s",GetEACCode(RAc->EAC));
                     RAc = RAc->next;
                     if(RAc == NULL)
                        fprintf(portrayfails,"\n");
                     while(RAc != NULL)
                        {
                        if(RAc->next == NULL)
                           fprintf(portrayfails," and / or %s\n",GetEACCode(RAc->EAC));
                        else
                           fprintf(portrayfails,", %s",GetEACCode(RAc->EAC));
                        RAc = RAc->next;
                        }
                     }
                  }
               }
            if((S_try > 0) && (Type3 > 0))
               {
               fprintf(portrayreport,"%s,%s,Area,%d,%d,%d,%.2lf\n",
                    GetECCCode(i), GetECCLabel(i),S_try,Type3, S_pass,((double) S_pass) / ((double) Type3) *100.0);

               if(Type3 > S_pass)
                  {
                  fprintf(portrayfails,"%s A\n",GetECCCode(i));
                  RAc = PVF[i].surface->attrs;
                  if(RAc == NULL)
                     fprintf(portrayfails,"(no attributes involved)\n");
                  else
                     {
                     fprintf(portrayfails,"failure caused by value of ");
                     fprintf(portrayfails,"%s",GetEACCode(RAc->EAC));
                     RAc = RAc->next;
                     if(RAc == NULL)
                        fprintf(portrayfails,"\n");
                     while(RAc != NULL)
                        {
                        if(RAc->next == NULL)
                           fprintf(portrayfails," and / or %s\n",GetEACCode(RAc->EAC));
                        else
                           fprintf(portrayfails,", %s",GetEACCode(RAc->EAC));
                        RAc = RAc->next;
                        }
                     }
                  }
               }
            }
         else
            {
            if((P_try > 0) && (Type2 > 0))
               {
               fprintf(portrayreport,"%s,%s,Point,%d,%d,%d,%.2lf\n",
                    GetECCCode(i), GetECCLabel(i),P_try,Type2, P_pass,((double) P_pass) / ((double) Type2) *100.0);
               }
            if((C_try > 0) && (Type1 > 0))
               {
               fprintf(portrayreport,"%s,%s,Curve,%d,%d,%d,%.2lf\n",
                    GetECCCode(i), GetECCLabel(i),C_try,Type1, C_pass,((double) C_pass) / ((double) Type1) *100.0);
               }
            if((S_try > 0) && (Type3 > 0))
               {
               fprintf(portrayreport,"%s,%s,Surface,%d,%d,%d,%.2lf\n",
                    GetECCCode(i), GetECCLabel(i),S_try,Type3, S_pass,((double) S_pass) / ((double) Type3) *100.0);
               }
            }
         }



      P_pass = C_pass = S_pass = 0;
      Type1 = Type2 = Type3 = 0;
      for(i=0; i<MaxPortrayRules; i++)
         {
         cnl = NULL;
         if((PVF[i].curve != NULL) || (PVF[i].surface != NULL) || (PVF[i].point != NULL))
            {
            cnl = NListRoot;
            while(cnl != NULL)
               {
               if(cnl->ECC == i)
                  break;
               cnl = cnl->next;
               }
            }
         if(cnl != NULL)
            {
            pnl = cnl;
            if(PVF[i].curve != NULL)
               {
               PRc1 = PVF[i].curve->rules;
               while(PRc1 != NULL)
                  {
                  C_pass += PRc1->success;
                  PRc1 = PRc1->next;
                  }
               while((pnl != NULL) && (pnl->ECC == i))
                  {
                  if(pnl->configcount[C_LINE] > 0)
                     {
                     Type1 += (int) pnl->configcount[C_LINE];
                     }
                  pnl = pnl->next;
                  }
               }
            pnl = cnl;
            if(PVF[i].point != NULL)
               {
               PRc1 = PVF[i].point->rules;
               while(PRc1 != NULL)
                  {
                  P_pass += PRc1->success;
                  PRc1 = PRc1->next;
                  }
               while((pnl != NULL) && (pnl->ECC == i))
                  {
                  if(pnl->configcount[C_POFE] > 0)
                     {
                     Type2 += (int) pnl->configcount[C_POFE];
                     }
                  pnl = pnl->next;
                  }
               }
            pnl = cnl;
            if(PVF[i].surface != NULL)
               {
               PRc1 = PVF[i].surface->rules;
               while(PRc1 != NULL)
                  {
                  S_pass += PRc1->success;
                  PRc1 = PRc1->next;
                  }
               while((pnl != NULL) && (pnl->ECC == i))
                  {
                  if(pnl->configcount[C_AREA] > 0)
                     {
                     Type3 += (int) pnl->configcount[C_AREA];
                     }
                  pnl = pnl->next;
                  }
               }
            }
         }

      fclose(portrayfails);
      portrayfails = NULL;


      FreeOrWritePortrayalRules(0,1,portrayreport);

      TTF_RBTreeDestroy(Portray_RB_Tree);
      }

   if((ATTRTYPE_TDS6() > 0) ||  (ATTRTYPE_MGCP4() > 0))
      {
      FreeOrWritePortrayalRules(1,0,NULL);
      fclose(portrayreport);
      portrayreport = NULL;
      }

   Eroot = NULL;
   Eparent = NULL;
   Retrieve_Regular_AE_TreeInorder(Regular_AE_Tree,Regular_AE_Tree->root->left);
   errrpt = fopen(binSACgigs,"wb");
   SEEIT_fwrite_int(&AttrErrMsgID,errrpt);
   for(i=1; i<=AttrErrMsgID; i++)
      {
      E1 = Eroot;
      while((E1 != NULL) && (E1->idnumber != i))
         E1 = E1->next;
      if((E1 != NULL) && (E1->idnumber == i))
         {
         if(E1->msgline[0] != 'w') /*** this is flag for the filler value note - no assoc output file here ****/
            {
            j = strlen(E1->msgline);
            E1->msgline[j] = '\0';

            SEEIT_fwrite_int(&j,errrpt);
            fwrite(&E1->msgline[0],j,1,errrpt);
            }
         }
      }

   E1 = Eroot;
   while(E1 != NULL)
      {
      E2 = E1;
      E1 = E1->next;
      free(E2->msgline);
      if(E2->LindexList != NULL)
         {
         ec = E2->LindexList;
         while(ec != NULL)
            {
            ep = ec;
            ec = ec->next;
            free(ep);
            }
         }
      free(E2);
      }
   Eroot = NULL;

    TTF_RBTreeDestroy(Regular_AE_Tree);

   j = (int) NumToCheck;
   for(i=0; i<=j; i++)
      {
      if(Iroot[i].msgid > -1)
         {
         k = Iroot[i].msgid - 1;
         SEEIT_fwrite_int(&i,errrpt);
         SEEIT_fwrite_int(&k,errrpt);
         I1 = Iroot[i].next;
         while(I1 != NULL)
            {
            SEEIT_fwrite_int(&I1->index,errrpt);
            I1->msgid -= 1;
            SEEIT_fwrite_int(&I1->msgid,errrpt);

            I2 = I1;
            I1 = I1->next;
            free(I2);
            }
         }
      }
   fclose(errrpt);
   free(Iroot);

   strcpy(resultmessage,dtgigs);
   i = strlen(resultmessage);
   --i;
   while(resultmessage[i] != 'R')
      --i;
   sprintf(resultmessage,"%sAttrStub.bin",outdirectory);
   qacr = fopen(resultmessage,"wb");

   strcpy(resultmessage,geomgigs);
   i = strlen(resultmessage);
   --i;
   while(resultmessage[i] != '.')
      --i;
   ++i;
   strcpy(&resultmessage[i],"csv");

   errrpt = fopen(resultmessage,"wt");

   Eparent = NULL;
   Summary_AEroot = NULL;
   Retrieve_Summary_AE_TreeInorder(Summary_AE_Tree,Summary_AE_Tree->root->left);

   Eparent = GIFD_Eroot;
   if(Eparent != NULL)
      {
      while(Eparent->next != NULL)
         Eparent = Eparent->next;
      }
   Retrieve_GIFD_AE_TreeInorder(GIFD_AE_Tree,GIFD_AE_Tree->root->left);


               if(ATTRTYPE_NFDD() > 0)
                  {
                  di = 0;
                  ML2 = AListRoot;
                  while(ML2 != NULL)
                     {
                     if(ML2->code == NAM_code)
                        di += ML2->occurrences;
                     ML2 = ML2->next;
                     }
                  TtlNAMattr = (int) di;
                  }

   E1 = Summary_AEroot;
   if(PrintSchemaCodes > 0)
      {
      fprintf(errrpt,"FCODE,\"FCODE Name\",\"FCODE Occurrences\",\"Illegal Geometry\",\"Illegal Geometry Occurrences\",\"Percent\"\n");
      }
   else
      {
      fprintf(errrpt,"\"FCODE Name\",\"FCODE Occurrences\",\"Illegal Geometry\",\"Illegal Geometry Occurrences\",\"Percent\"\n");
      }
   while(E1 != NULL)
      {
      if(E1->msgline[0] == '0') /*** unexpected geometry has been assigned ***/
         {
         i = 2;
         j = 0;
         while(E1->msgline[i] != '|')
            {
            ECCstr[j] = E1->msgline[i];
            ++j;
            ++i;
            }
         ECCstr[j] = '\0';
         j = 0;
         ++i;
         while(E1->msgline[i] != '|')
            {
            ECCname[j] = E1->msgline[i];
            ++j;
            ++i;
            }
         ECCname[j] = '\0';
         
         ++i;
         sscanf(&E1->msgline[i],"%d %d",&ECC,&seeitgeom);
         cnl = NListRoot;
         di = 0;
         while(cnl != NULL)
            {
            if(cnl->ECC == ECC)
               di += cnl->occurrences;
            cnl = cnl->next;
            }
         if(di == 0)
            {
            printf("Fatal Error (1) - couldn't find frequency data for %s %s %s geom %d\n",ECCstr,ECCname,EACname,seeitgeom);
            exit(-1);
            }
         if(PrintSchemaCodes > 0)
            {
            fprintf(errrpt,"\"%s\",\"%s\",%.0lf,\"%s\",%d,%.1lf\n",
                ECCstr,ECCname,di,ParseGAITgeometry((unsigned char) seeitgeom, 2),
                  E1->count,100.0 * ((double) E1->count / di));
            }
         else
            {
            fprintf(errrpt,"\",\"%s\",%.0lf,\"%s\",%d,%.1lf\n",
                ECCname,di,ParseGAITgeometry((unsigned char) seeitgeom, 2),
                  E1->count,100.0 * ((double) E1->count / di));
            }
         }
      E1 = E1->next;
      }
   fclose(errrpt);

   strcpy(resultmessage,fillervaluegigs);
   i = strlen(resultmessage);
   --i;
   while(resultmessage[i] != '.')
      --i;
   ++i;
   strcpy(&resultmessage[i],"csv");

   errrpt = fopen(resultmessage,"wt");
   if(errrpt != NULL)
      {
      E1 = Summary_AEroot;
      if(PrintSchemaCodes > 0)
         {
         fprintf(errrpt,
           "\"Attribute Code\",\"Attribute Name\",\"FCODE\",\"Feature Name\",\"Geometry\",\"Sentinel Value\",\"Sentinel Value Occurrences\",\"Attribute Occurrences This FCODE\",\"Total Attribute Occurrences\",\"Percent Sentinel Values\",\"Cumulative Sentinel Values This Attribute\",\"Cumulative Percent Sentinel Values\"\n");
         }
      else
         {
         fprintf(errrpt,
           "\"Attribute Name\",\"Feature Name\",\"Geometry\",\"Sentinel Value\",\"Sentinel Value Occurrences\",\"Attribute Occurrences This FCODE\",\"Total Attribute Occurrences\",\"Percent Sentinel Values\",\"Cumulative Sentinel Values This Attribute\",\"Cumulative Percent Sentinel Values\"\n");
         }

      l2 = -1;

      E1 = Summary_AEroot;
      while(E1 != NULL)
         {
         if(E1->msgline[0] == 'w')  
            {
            j = 2;
            while(E1->msgline[j] != '|') /*** just throw away the leading EAC Code strings, used to set up sort order ***/
               ++j;
            ++j;
            EAC = 0;
            while(E1->msgline[j] != '|')
               {
               EAC = (EAC * 10) + E1->msgline[j] - 48;
               ++j;
               }
            ++j;
            i = 0;
            while(E1->msgline[j] != '|')
               {
               if(E1->msgline[j] < ' ')
                  break;
               if(E1->msgline[j] != '"')
                  {
                  resultmessage[i] = E1->msgline[j];
                  ++i;
                  }
               ++j;
               }
            resultmessage[i] = '\0';
           
            ++j;
            i = j; /** should be first numeric char after the last '|'  ****/
            while(E1->msgline[j] != '|')
               ++j;
            E1->msgline[j] = ' ';
            sscanf(&E1->msgline[i],"%d %d",&ECC,&seeitgeom);
            
            di = 0;
            if(EAC == ARA_code)
               di = TtlARAattr;
            else if(EAC == HGT_code)
               di = TtlHGTattr;
            else if(EAC == ZV2_code)
               di = TtlZV2attr;
            else if(EAC == NAM_code)
               di = TtlNAMattr;
            else if(EAC == LEN_code)
               di = TtlLENattr;
            else
               {
               di = 0;
               ML2 = AListRoot;
               while(ML2 != NULL)
                  {
                  if(ML2->code == EAC)
                     di += ML2->occurrences;
                  ML2 = ML2->next;
                  }
               }

            if(di > 0) /** now need the number of times the fcode - geometry - attribute triple occurs ***/
               {
               l3 = 0;
               if((EAC == ARA_code) || (EAC == HGT_code) || (EAC == ZV2_code) || (EAC == NAM_code) || (EAC == LEN_code))
                  {
                  pnl = NListRoot;
                  while(pnl != NULL)
                     {
                     if(pnl->occurrences > 0)
                        {
                        if(pnl->ECC == ECC)
                           {
                           thistype = GetLongAttrType(EAC,1);
                           if(thistype >= 0)
                              {
                              pel = pnl->indices;
                              while(pel != NULL)
                                 {
                                 if(LLtoGeom[pel->val] == seeitgeom)
                                    l3 += LongAttrCounts(pel->val, thistype);
                                 pel = pel->next;
                                 }
                              }
                           }
                        }
                     pnl = pnl->next;
                     }
                  }
               else
                  {
                  cal = AListRoot;
                  while(cal != NULL)
                     {
                     if(cal->code == EAC)
                        {
                        cvl = cal->values;
                        while(cvl != NULL)
                           {
                           if(cvl->ClassCode == ECC)
                              l3 += (int) cvl->occurrences;
                           cvl = cvl->next;
                           }
                        }
                     cal = cal->next;
                     }
                  }

               if(l2 != EAC)
                  {
                  l2 = EAC;
                  djunk = (double) E1->count;
                  djunk2 = di;
                  }
               else
                  {
                  djunk += (double) E1->count;
                  }
               if(PrintSchemaCodes > 0)
                  {
                  fprintf(errrpt,"\"%s\",\"%s\",\"%s\",\"%s\",\"%s\",\"%s\",%d,%d,%.0lf,%.1lf,%d,%.1lf\n",
                                GetEACCode(EAC),GetEACLabel(EAC),GetECCCode(ECC),GetECCLabel(ECC),ParseGAITgeometry((unsigned char) seeitgeom, 2),
                                     resultmessage,E1->count,l3,di,(double) E1->count / di * 100.0,(int) djunk, (djunk / djunk2) * 100.0);
                  }
               else
                  {
                  fprintf(errrpt,"\"%s\",\"%s\",\"%s\",\"%s\",%d,%d,%.0lf,%.1lf,%d,%.1lf\n",
                                GetEACLabel(EAC),GetECCLabel(ECC),ParseGAITgeometry((unsigned char) seeitgeom, 2),
                                  resultmessage,E1->count,l3,di,(double) E1->count / di * 100.0,(int) djunk,(djunk / djunk2) * 100.0);
                  }
               }
            }
         E1 = E1->next;
         }


      fclose(errrpt);
      }

   free(LLtoGeom);

   strcpy(resultmessage,missingattrgigs);
   i = strlen(resultmessage);
   --i;
   while(resultmessage[i] != '.')
      --i;
   ++i;
   strcpy(&resultmessage[i],"csv");

   errrpt = fopen(resultmessage,"wt");
   E1 = Summary_AEroot;
   if(PrintSchemaCodes > 0)
      {
      fprintf(errrpt,
        "FCODE,\"FCODE Name\",\"FCODE Occurrences\",\"Required Attribute\",\"Attribute Name\",\"Attribute Missing Occurrences\",\"Percent\"\n");
      }
   else
      {
      fprintf(errrpt,
        "\"FCODE Name\",\"FCODE Occurrences\",\"Required Attribute\",\"Attribute Missing Occurrences\",\"Percent\"\n");
      }
   while(E1 != NULL)
      {
      if(E1->msgline[0] == 'z') /*** a required attribute was not assigned ***/
         {
         i = 2;
         j = 0;
         while(E1->msgline[i] != '|')
            {
            ECCstr[j] = E1->msgline[i];
            ++j;
            ++i;
            }
         ECCstr[j] = '\0'; 
         j = 0;
         ++i;
         while(E1->msgline[i] != '|')
            {
            ECCname[j] = E1->msgline[i];
            ++j;
            ++i;
            }
         ECCname[j] = '\0';
         j = 0;
         ++i;
         while(E1->msgline[i] != '|')
            {
            EACname[j] = E1->msgline[i];
            ++j;
            ++i;
            }
         EACname[j] = '\0';
         ++i;
         sscanf(&E1->msgline[i],"%d %d %d",&ECC,&EAC,&seeitgeom);
         cnl = NListRoot;
         i = 0;
         while(cnl != NULL)
            {
            if((cnl->ECC == ECC) && (cnl->configcount[seeitgeom] > 0))
               break;
            if(cnl->occurrences > 0)
               ++i;
            cnl = cnl->next;
            }
         if(cnl == NULL)
            {
            printf("Fatal Error (2) - couldn't find frequency data for %s %s %s geom %d\n",ECCstr,ECCname,EACname,seeitgeom);
            exit(-1);
            }
         if(PrintSchemaCodes > 0)
            {
            fprintf(errrpt,"\"%s\",\"%s\",%.0lf,\"%s\",\"%s\",%d,%.1lf\n",
              ECCstr,ECCname,cnl->occurrences,GetEACCode(EAC),EACname,E1->count,100.0 * ((double) E1->count / cnl->occurrences));
            }
         else
            {
            fprintf(errrpt,"\"%s\",%.0lf,\"%s\",%d,%.1lf\n",
              ECCname,cnl->occurrences,EACname,E1->count,100.0 * ((double) E1->count / cnl->occurrences));
            }

         }
      E1 = E1->next;
      }
   fclose(errrpt);


   strcpy(resultmessage,TTFattrgigs);
   i = strlen(resultmessage);
   --i;
   while(resultmessage[i] != '.')
      --i;
   ++i;
   strcpy(&resultmessage[i],"csv");
   
   errrpt = fopen(resultmessage,"wt");
   E1 = Summary_AEroot;
   if(PrintSchemaCodes > 0)
      {
      fprintf(errrpt,
        "FCODE,\"FCODE Name\",\"FCODE Occurrences\",\"Illegal Attribute\",\"Attribute Name\",\"Illegal Attribute Occurrences\",\"Percent\"\n");
      }
   else
      {
      fprintf(errrpt,"\"FCODE Name\",\"FCODE Occurrences\",\"Illegal Attribute\",\"Illegal Attribute Occurrences\",\"Percent\"\n");
      }
   while(E1 != NULL)
      {
      if(E1->msgline[0] == '1') /*** unexpected attribute has been assigned ***/
         {
         i = 2;
         j = 0;
         while(E1->msgline[i] != '|')
            {
            ECCstr[j] = E1->msgline[i];
            ++j;
            ++i;
            }
         ECCstr[j] = '\0';
         j = 0;
         ++i;
         while(E1->msgline[i] != '|')
            {
            ECCname[j] = E1->msgline[i];
            ++j;
            ++i;
            }
         ECCname[j] = '\0';
         j = 0;
         ++i;
         while(E1->msgline[i] != '|')
            {
            EACname[j] = E1->msgline[i];
            ++j;
            ++i;
            }
         EACname[j] = '\0';
         ++i;
         sscanf(&E1->msgline[i],"%d %d %d",&ECC,&EAC,&seeitgeom);
         cnl = NListRoot;
         i = 0;
         while(cnl != NULL)
            {
            if((cnl->ECC == ECC) && (cnl->configcount[seeitgeom] > 0))
               break;
            if(cnl->occurrences > 0)
               ++i;
            cnl = cnl->next;
            }
         if(cnl == NULL)
            {
            printf("Fatal Error(3) - couldn't find frequency data for %s %s %s geom %d\n",ECCstr,ECCname,EACname,seeitgeom);
            exit(-1);
            }
         if(PrintSchemaCodes > 0)
            {
            fprintf(errrpt,"\"%s\",\"%s\",%.0lf,\"%s\",\"%s\",%d,%.1lf\n",
             ECCstr,ECCname,cnl->occurrences,GetEACCode(EAC),EACname,E1->count,100.0 * ((double) E1->count / cnl->occurrences));
            }
         else
            {
            fprintf(errrpt,"\"%s\",%.0lf,\"%s\",%d,%.1lf\n",
             ECCname,cnl->occurrences,EACname,E1->count,100.0 * ((double) E1->count / cnl->occurrences));
            }
         }
      E1 = E1->next;
      }
   fclose(errrpt);



   strcpy(resultmessage,pickgigs);
   i = strlen(resultmessage);
   --i;
   while(resultmessage[i] != '.')
      --i;
   ++i;
   strcpy(&resultmessage[i],"csv");

   errrpt = fopen(resultmessage,"wt");
   E1 = Summary_AEroot;
   if(PrintSchemaCodes > 0)
      {
      fprintf(errrpt,
"FCODE,\"FCODE Name\",\"Geometry\",\"Domain Name\",\"Domain Attribute\",\"Attribute Name\",\"Domain Attribute Occurrences\",\"Invalid Value Code\",\"Invalid Value Label\",\"Invalid Value Occurrences\",\"Percent\"\n");
      }
   else
      {
      fprintf(errrpt,
"\"FCODE Name\",\"Geometry\",\"Domain Name\",\"Domain Attribute\",\"Domain Attribute Occurrences\",\"Invalid Value Code\",\"Invalid Value Label\",\"Invalid Value Occurrences\",\"Percent\"\n");
      }
   while(E1 != NULL)
      {
      if(E1->msgline[0] == '4') /*** pick list violation ***/
         {
         i = 2;
         j = 0;
         while(E1->msgline[i] != '|')
            {
            ECCstr[j] = E1->msgline[i];
            ++j;
            ++i;
            }
         ECCstr[j] = '\0';
         j = 0;
         ++i;
         while(E1->msgline[i] != '|')
            {
            ECCname[j] = E1->msgline[i];
            ++j;
            ++i;
            }
         ECCname[j] = '\0';
         j = 0;
         ++i;
         while(E1->msgline[i] != '|')
            {
            domainstr[j] = E1->msgline[i];
            ++j;
            ++i;
            }
         domainstr[j] = '\0';
         j = 0;
         ++i;
         while(E1->msgline[i] != '|')
            {
            EACname[j] = E1->msgline[i];
            ++j;
            ++i;
            }
         EACname[j] = '\0';
         j = 0;
         ++i;
         while(E1->msgline[i] != '|')
            {
            enumcodestring[j] = E1->msgline[i];
            ++j;
            ++i;
            }
         enumcodestring[j] = '\0';
         ++i;

         sscanf(&E1->msgline[i],"%d %d %d %d",&ECC,&seeitgeom,&EAC,&EEC);

         ML2 = AListRoot;
         while(ML2 != NULL)
            {
            if(ML2->code == EAC)
               break;
            ML2 = ML2->next;
            }
         if(ML2 == NULL)
            {
            printf("Fatal error  - couldn't find attr index crsref for %s %s %s geom %d\n",ECCstr,ECCname,EACname,seeitgeom);
            exit(-1);
            }

         cnl = NListRoot;
         i = 0;
         while(cnl != NULL)
            {
            if((cnl->ECC == ECC) && (cnl->configcount[seeitgeom] > 0))
               break;
            if(cnl->occurrences > 0)
               ++i;
            cnl = cnl->next;
            }
         if(cnl == NULL)
            {
            printf("Fatal error(4) - couldn't find frequency data for %s %s %s geom %d\n",ECCstr,ECCname,EACname,seeitgeom);
            exit(-1);
            }
         if(NameAttrCross[i].count > 0)
            {
            di = 0;
            if(NameAttrCross[i].AIndex == ML2->thisindex)
               di += NameAttrCross[i].occurrences;
            NAC1 = NameAttrCross[i].next;
            while(NAC1 != NULL)
               {
               if(NAC1->AIndex == ML2->thisindex)
                  di += NAC1->occurrences;
               NAC1 = NAC1->next;
               }
            if(EEC >= 0)
               {
               if(PrintSchemaCodes > 0)
                  {
                  fprintf(errrpt,"\"%s\",\"%s\",\"%s\",\"%s\",\"%s\",\"%s\",%.0lf,\"%s\",\"%s\",%d,%.1lf\n",
                   ECCstr,ECCname,ParseGAITgeometry((unsigned char) seeitgeom, 2),
                      domainstr,GetEACCode(EAC),EACname,di,
                       GetEECode(EAC,EEC),GetEELabel(EAC,EEC),E1->count,100.0 * ((double) E1->count / di));
                  }
               else
                  {
                  fprintf(errrpt,"\"%s\",\"%s\",\"%s\",\"%s\",%.0lf,\"%s\",\"%s\",%d,%.1lf\n",
                   ECCname,ParseGAITgeometry((unsigned char) seeitgeom, 2),
                      domainstr,EACname,di,
                        GetEECode(EAC,EEC),GetEELabel(EAC,EEC),E1->count,100.0 * ((double) E1->count / di));
                  }
               }
            else
               {
               if(PrintSchemaCodes > 0)
                  {
                  fprintf(errrpt,"\"%s\",\"%s\",\"%s\",\"%s\",\"%s\",\"%s\",%.0lf,\"%s\",%d,%.1lf\n",
                   ECCstr,ECCname,ParseGAITgeometry((unsigned char) seeitgeom, 2),
                      domainstr,GetEACCode(EAC),EACname,di,enumcodestring,E1->count,100.0 * ((double) E1->count / di));
                  }
               else
                  {
                  fprintf(errrpt,"\"%s\",\"%s\",\"%s\",\"%s\",%d,\"%s\",%d,%.1lf\n",
                   ECCname,ParseGAITgeometry((unsigned char) seeitgeom, 2),
                      domainstr,EACname,j,enumcodestring,E1->count,100.0 * ((double) E1->count / (double) j));
                  }
               }
            }
         else
            {
            printf("Fatal error - couldn't find Name CRS  for %s %s %s geom %d\n",ECCstr,ECCname,EACname,seeitgeom);
            exit(-1);
            }
         }
      E1 = E1->next;
      }
   fclose(errrpt);



   strcpy(resultmessage,dtgigs);
   i = strlen(resultmessage);
   --i;
   while(resultmessage[i] != '.')
      --i;
   ++i;
   strcpy(&resultmessage[i],"csv");

   errrpt = fopen(resultmessage,"wt");
   E1 = Summary_AEroot;
   if(PrintSchemaCodes > 0)
      {
      fprintf(errrpt,
    "FCODE,\"Feature Name\",\"Attribute Code\",\"Attribute Name\",\"Attribute Occurrences\",\"NULL Value Occurrences\",\"Percent\"\n");
      }
   else
      {
      fprintf(errrpt,
       "\"Feature Name\",\"Attribute Name\",\"Attribute Occurrences\",\"NULL Value Occurrences\",\"Percent\"\n");
      }
   while(E1 != NULL)
      {
      if(E1->msgline[0] == '2') /*** used to be assigned data type not as prescsribed now is NULL value on MGCP required attribute ***/
         {
         i = 2;
         j = 0;
         while(E1->msgline[i] != '|')
            {
            EACname[j] = E1->msgline[i];
            ++j;
            ++i;
            }
         EACname[j] = '\0';






         ++i;
         sscanf(&E1->msgline[i],"%d",&ECC);
         ++i;
         while(E1->msgline[i] != ' ')
            ++i;
         sscanf(&E1->msgline[i],"%d",&EAC);

         ML2 = AListRoot;
         while(ML2 != NULL)
            {
            if(ML2->code == EAC)
               break;
            ML2 = ML2->next;
            }
         if(ML2 == NULL)
            {
            printf("Fatal Error (position 1) - couldn't find attr index crsref for %s \n",EACname);
            }
         else
            {
            if(PrintSchemaCodes > 0)
               {
               fprintf(errrpt,"\"%s\",\"%s\",\"%s\",\"%s\",%.0lf,%d,%.1lf\n",
                         GetECCCode(ECC),GetECCLabel(ECC),GetEACCode(EAC),EACname,ML2->occurrences,
                         E1->count,100.0 * ((double) E1->count / ML2->occurrences));
               }
            else
               {
               fprintf(errrpt,"\"%s\",\"%s\",%.0lf,%d,%.1lf\n", GetECCLabel(ECC),EACname,ML2->occurrences,
                         E1->count,100.0 * ((double) E1->count / ML2->occurrences));
               }
            }
         }
      E1 = E1->next;
      }
   fclose(errrpt);





   strcpy(resultmessage,valuegigs);
   i = strlen(resultmessage);
   --i;
   while(resultmessage[i] != '.')
      --i;
   ++i;
   strcpy(&resultmessage[i],"csv");

   errrpt = fopen(resultmessage,"wt");
   E1 = Summary_AEroot;
   if(PrintSchemaCodes > 0)
      {
      fprintf(errrpt,
"\"Feature Code\",\"Feature Name\",\"Attribute Code\",\"Attribute Name\",\"Attribute Occurrences\",\"Invalid Value\",\"Invalid Value Occurrences\",\"Allowed Range\",\"Percent\"\n");
      }
   else
      {
      fprintf(errrpt,
"\"Feature Name\",\"Attribute Name\",\"Attribute Occurrences\",\"Invalid Value\",\"Invalid Value Occurrences\",\"Allowed Range\",\"Percent\"\n");
      }
   while(E1 != NULL)
      {
      if(E1->msgline[0] == '3') /*** assigned value outside allowed range ***/
         {
         i = 2;
         j = 0;
         while(E1->msgline[i] != '|')
            {
            EACcode[j] = E1->msgline[i];
            ++j;
            ++i;
            }
         EACcode[j] = '\0';
         ++i;

         j = 0;
         while(E1->msgline[i] != '|')
            {
            EACname[j] = E1->msgline[i];
            ++j;
            ++i;
            }
         EACname[j] = '\0';
         ++i;

         if(strstr(E1->msgline,"(string assigned as value: ") == NULL)
            sscanf(&E1->msgline[i],"%lf %lf %lf %d %d",&Fdtvalue,&minallowed, &maxallowed,&ECC,&EAC);
         else
            {
            j = strlen(E1->msgline);
            --j;
            while(E1->msgline[j] == ' ')
               --j;
            --j;
            while(E1->msgline[j] != ' ')
               --j;
            --j;
            while(E1->msgline[j] != ' ')
               --j;
            sscanf(&E1->msgline[j],"%d %d",&ECC,&EAC);
            }
            if(EAC == ARA_code)
               di = TtlARAattr;
            else if(EAC == HGT_code)
               di = TtlHGTattr;
            else if(EAC == ZV2_code)
               di = TtlZV2attr;
            else if(EAC == NAM_code)
               di = TtlNAMattr;
            else if(EAC == LEN_code)
               di = TtlLENattr;
            else
               {
               di = 0;
               ML2 = AListRoot;
               while(ML2 != NULL)
                  {
                  if(ML2->code == EAC)
                     di += ML2->occurrences;
                  ML2 = ML2->next;
                  }
               }
         if(di == 0)
            {
            printf("Fatal Error (position 2) - couldn't find attr index crsref for %s \n",EACname);
ML2 = AListRoot;
printf("looking for code %d\n",EAC);
printf("Fatal error  - couldn't find attr index crsref for %s %s %s geom %d\n",ECCstr,ECCname,EACname,seeitgeom);
while(ML2 != NULL)
{
printf("code %d %s %s \n",ML2->code,GetEACCode(ML2->code),GetEACLabel(ML2->code));
ML2 = ML2->next;
}
            exit(-1);
            }

         if(strstr(EACname,"string value:") != NULL)
            {
            if(PrintSchemaCodes > 0)
               {
               fprintf(errrpt,"\"%s\",\"%s\",\"%s\",\"%s\",%.0lf,string length %d,%d,\"length %d to %d characters\",%lf\n",
                          GetECCCode(ECC),GetECCLabel(ECC),EACcode,EACname,di,(int) Fdtvalue,
                         E1->count,(int) minallowed,(int) maxallowed,100.0 * ((double) E1->count / di));
               }
            else
               {
               fprintf(errrpt,"\"%s\",\"%s\",%.0lf,string length %d,%d,\"length %d to %d characters\",%lf\n", 
                          GetECCLabel(ECC),EACname,di,(int) Fdtvalue,
                         E1->count,(int) minallowed,(int) maxallowed,100.0 * ((double) E1->count / di));
               }
            }
         else if(strstr(EACname,"string assigned as value") != NULL)
            {
            if(PrintSchemaCodes > 0)
               {
               fprintf(errrpt,"\"%s\",\"%s\",\"%s\",\"%s\",%.0lf,\"%s\",%d,\"expected string-appropriate sentinel value\",%lf\n",
                          GetECCCode(ECC),GetECCLabel(ECC),EACcode,EACname,di,EACname,
                         E1->count,((double) E1->count / di));
               }
            else
               {
               fprintf(errrpt,"\"%s\",\"%s\",%.0lf,\"%s\",%d,\"expected string-appropriate sentinel value\",%lf\n",
                          GetECCLabel(ECC),EACname,di,EACname,
                         E1->count,((double) E1->count / di));
               }

            }
         else
            {
            if(PrintSchemaCodes > 0)
               {
               fprintf(errrpt,"\"%s\",\"%s\",\"%s\",\"%s\",%.0lf,%lf,%d,\"%.1lf to %.1lf\",%lf\n", 
                   GetECCCode(ECC),GetECCLabel(ECC),EACcode,EACname,di,Fdtvalue,
                         E1->count,minallowed,maxallowed,100.0 * ((double) E1->count / di));
               }
            else
               {
               fprintf(errrpt,"\"%s\",\"%s\",%.0lf,%lf,%d,\"%.1lf to %.1lf\",%lf\n",
                        GetECCLabel(ECC),EACname,di,Fdtvalue,
                         E1->count,minallowed,maxallowed,100.0 * ((double) E1->count / di));
               }
            
            }
         }
      E1 = E1->next;
      }
   fclose(errrpt);



   strcpy(resultmessage,vvtgigs);
   i = strlen(resultmessage);
   --i;
   while(resultmessage[i] != '.')
      --i;
   ++i;
   strcpy(&resultmessage[i],"csv");

   errrpt = fopen(resultmessage,"wt");
   E1 = Summary_AEroot;

   if(PrintSchemaCodes > 0)
      {
      fprintf(errrpt,
 "\"Feature Code\",\"Feature Name\",\"Geometry\",\"Attribute Code\",\"Attribute Name\",\"Attribute Value\",\"Dependent Attribute Code\",\"Dependent Attribute Name\",\"Dependent Attribute Value\"\n");
      }
   else
      {
      fprintf(errrpt, 
 "\"Feature Name\",\"Geometry\",\"Attribute Name\",\"Attribute Value\",\"Dependent Attribute Name\",\"Dependent Attribute Value\"\n");
      }

   while(E1 != NULL)
      {
      if((E1->msgline[0] == 'x') || (E1->msgline[0] == 'p')) /*** dependency violation from MGCP extraction guide ***/
         {
         i = 2;
         j = 0;
 
         while(E1->msgline[i] != '|')
            {
            if(PrintSchemaCodes > 0)
               {
               resultmessage[j] = E1->msgline[i];
               ++j;
               }
            ++i;
            }
         if(PrintSchemaCodes > 0)
            {
            resultmessage[j] = ',';
            ++j;
            }
         ++i;
         while(E1->msgline[i] != '|')
            {
            resultmessage[j] = E1->msgline[i];
            ++j;
            ++i;
            }
         resultmessage[j] = ',';
         ++j;
         ++i;
         while(E1->msgline[i] != '|')
            {
            resultmessage[j] = E1->msgline[i];
            ++j;
            ++i;
            }
         resultmessage[j] = ',';
         ++j;
         ++i;
         while(E1->msgline[i] != '|')
            {
            if(PrintSchemaCodes > 0)
               {
               resultmessage[j] = E1->msgline[i];
               ++j;
               }
            ++i;
            }
         if(PrintSchemaCodes > 0)
            {
            resultmessage[j] = ',';
            ++j;
            }
         ++i;
         while(E1->msgline[i] != '|')
            {
            resultmessage[j] = E1->msgline[i];
            ++j;
            ++i;
            }
         resultmessage[j] = ',';
         ++j;
         ++i;
         while(E1->msgline[i] != '|')
            {
            resultmessage[j] = E1->msgline[i];
            ++j;
            ++i;
            }
         resultmessage[j] = ',';
         ++j;
         ++i;
         while(E1->msgline[i] != '|')
            {
            if(PrintSchemaCodes > 0)
               {
               resultmessage[j] = E1->msgline[i];
               ++j;
               }
            ++i;
            }
         if(PrintSchemaCodes > 0)
            {
            resultmessage[j] = ',';
            ++j;
            }
         ++i;
         while(E1->msgline[i] != '|')
            {
            resultmessage[j] = E1->msgline[i];
            ++j;
            ++i;
            }
         resultmessage[j] = ',';
         ++j;
         ++i;
         while(E1->msgline[i] >= 32)
            {
            resultmessage[j] = E1->msgline[i];
            ++j;
            ++i;
            }
         resultmessage[j] = '\0';
         ++j;
         ++i;


         fprintf(errrpt,"%s\n",resultmessage);
         }

      E1 = E1->next;
      }
   fclose(errrpt);




   Type0 = Type1 = Type2 = Type3 = Type4 = Type5 = Type6 = 0;
   E1 = Summary_AEroot;
   while(E1 != NULL)
      {

      switch(E1->msgline[0])
         {
         case '5': Type1 += 1; break;
         case '6': Type2 += 1; break;
         case '7': Type3 += 1; break;
         case '8': Type4 += 1; break;
         case '9': Type0 += 1; break;
         case 'Z': Type5 += 1; break;
         case 'X': Type6 += 1; break;
         case 'P': Type6 += 1;  /***printf("stored value with 'P' flag: %s\n",E1->msgline); ***/break;
         case 'Y': Type6 += 1; break;
         }
      E1 = E1->next;
      }

   strcpy(resultmessage,dtgigs);
   i = strlen(resultmessage);
   --i;
   while(resultmessage[i] != 'R')
      --i;
   sprintf(resultmessage,"%sAttrErrorRollup.bin",outdirectory);

   errrpt = fopen(resultmessage,"wt");

  


   AcodeErr = AcodePoss = 0;


   if(ATTRTYPE_MGCP3() > 0) /*** MGCP3 ****/
      paragraph = 6;
   else if(ATTRTYPE_MGCP4() > 0) /*** MGCP4 ***/
      paragraph = 5;
   else if(ATTRTYPE_ANY_TDS() > 0) 
      paragraph = 5;
   else
      paragraph = 4;

   fprintf(errrpt,"\n%d. Domain-specific pick-list errors occur when a value assigned\n",paragraph);
   fprintf(errrpt,"   to a recognized attribute attached to a feature with a recognized FCODE\n");
   fprintf(errrpt,"   is not a member of the associated domain of allowed pick-list values.\n");
   fprintf(errrpt,"\n   Attributes with domain-specific pick list errors: %d\n\n",Type4);

   if(Type4 > 0)
      {
      fprintf(errrpt,"        Attribute                     Attribute    Invalid Pick     Percent\n");
      fprintf(errrpt,"        Name                             Occurs     List Values     Invalid\n");

      E1 = Summary_AEroot;
      l2 = 1;
      while(E1 != NULL)
         {
         if(E1->msgline[0] == '8')
            {
            sscanf(&E1->msgline[2],"%d",&EAC);
   
            if(EAC == ARA_code)
               di = TtlARAattr;
            else if(EAC == HGT_code)
               di = TtlHGTattr;
            else if(EAC == ZV2_code)
               di = TtlZV2attr;
            else if(EAC == NAM_code)
               di = TtlNAMattr;
            else if(EAC == LEN_code)
               di = TtlLENattr;
            else
               {
               di = 0;
               ML2 = AListRoot;
               while(ML2 != NULL)
                  {
                  if(ML2->code == EAC)
                     di += ML2->occurrences;
                  ML2 = ML2->next;
                  }
               }
            if(di == 0)
               {
               printf("Fatal Error 1 - couldn't find attr in AListRoot for %s %d\n",GetEACLabel(EAC), EAC);
               exit(-1);
               }

            AcodeErr += E1->count;
            AcodePoss += (int) di;

            sprintf(resultmessage,"%s (%s)",GetEACCode(EAC),GetEACLabel(EAC));

            sprintf(QACRstring,"%s",GetEACCode(EAC));
            WriteQACRdata(qacr, "Domain-Specific Pick-list error", QACRstring, E1->count);

            i = strlen(resultmessage);
            if(i > 24)
               {
               l = 0;
               for(j=0; j<24; j++)
                  {
                  if(resultmessage[j] == ' ')
                     l = j;
                  }
               if(l == 0)
                  l = 23;

               for(j=l; j<25; j++)
                  resultmessage[j] = ' ';
               sprintf(&resultmessage[24],"%15u %15d %10.3lf",(unsigned int) di,E1->count,100.0 * ((double) E1->count /di));
               if(l2 < 10) fprintf(errrpt,"     %d. ",l2);
               else if(l2 < 100) fprintf(errrpt,"    %d. ",l2);
               else if(l2 < 1000) fprintf(errrpt,"   %d. ",l2);
               else if(l2 < 10000) fprintf(errrpt,"  %d. ",l2);
               else if(l2 < 100000) fprintf(errrpt," %d. ",l2);
               else fprintf(errrpt,"%d. ",l2);
               fprintf(errrpt,"%s%%\n",resultmessage);

               sprintf(resultmessage,"%s (%s)",GetEACCode(EAC),GetEACLabel(EAC));
               fprintf(errrpt,"         %s\n",&resultmessage[l]);
               }
            else
               {
               for(j=i; j<25; j++)
                  resultmessage[j] = ' ';
               sprintf(&resultmessage[24],"%15u %15d %10.3lf",(unsigned int) di,E1->count,100.0 * ((double) E1->count /di));
               if(l2 < 10) fprintf(errrpt,"     %d. ",l2);
               else if(l2 < 100) fprintf(errrpt,"    %d. ",l2);
               else if(l2 < 1000) fprintf(errrpt,"   %d. ",l2);
               else if(l2 < 10000) fprintf(errrpt,"  %d. ",l2);
               else if(l2 < 100000) fprintf(errrpt," %d. ",l2);
               else fprintf(errrpt,"%d. ",l2);
               fprintf(errrpt,"%s%%\n",resultmessage);
               }
            ++l2;
            }
         E1 = E1->next;
         }
      fprintf(errrpt,"                          TOTAL %15d %15d %10.3f%%\n",AcodePoss,AcodeErr,100.0 * ((double) AcodeErr / (double) AcodePoss));
      }



   AcodeErr = AcodePoss = 0;

   if(ATTRTYPE_MGCP3() > 0) /*** MGCP3 ****/
      paragraph = 7;
   else if(ATTRTYPE_MGCP4() > 0) /*** MGCP4 ***/
      paragraph = 6;
   else if(ATTRTYPE_ANY_TDS() > 0)
      paragraph = 6;
   else
      paragraph = 5;



   fprintf(errrpt,"\n%d. Unexpected FCODE - geometry pair errors occur when a feature has a recognized\n",paragraph);
   fprintf(errrpt,"   FCODE but the geometry of the feature (e.g. point, line, area) has not\n");
   fprintf(errrpt,"   been associated with an instance of that FCODE in the current schema\n");
   fprintf(errrpt,"\n   FCODES with unexpected FCODE - geometry pair errors: %d\n\n",Type0);

   if(Type0 > 0)
      {
      fprintf(errrpt,"        Geometry FCODE:                  FCODE      Unexpected      Percent\n");
      fprintf(errrpt,"        FCODE Name                       Occurs     Geom Occurs     Invalid\n");

      E1 = Summary_AEroot;
      l2 = 1;
      while(E1 != NULL)
         {
         if(E1->msgline[0] == '9')
            {
            sscanf(&E1->msgline[2],"%d %d",&ECC,&seeitgeom);
               di = 0;
               cnl = NListRoot;
               while(cnl != NULL)
                  {
                  if(cnl->ECC == ECC)
                     di += cnl->occurrences; /**/
                  cnl = cnl->next;
                  }
            if(di == 0)
               {
               printf("Fatal Error 29 - couldn't find feature in NListRoot for %s %d\n",GetECCLabel(ECC), ECC);
               exit(-1);
               }

            AcodeErr += E1->count;
            AcodePoss += (int) di;

            sprintf(QACRstring,"feature %s assigned unexpected geometry",GetECCCode(ECC));
            WriteQACRdata(qacr, "Unexpected FCODE-Geometry Pair error", QACRstring, E1->count);

            sprintf(resultmessage,"%s %s: %s",ParseGAITgeometry((unsigned char) seeitgeom,2),GetECCCode(ECC),GetECCLabel(ECC));

            i = strlen(resultmessage);
            if(i > 24)
               {
               l = 0;
               for(j=0; j<24; j++)
                  {
                  if(resultmessage[j] == ' ')
                     l = j;
                  }
               if(l == 0)
                  l = 23;

               for(j=l; j<25; j++)
                  resultmessage[j] = ' ';
               sprintf(&resultmessage[24],"%15u %15d %10.3lf",(unsigned int) di,E1->count,100.0 * ((double) E1->count /di));
               if(l2 < 10) fprintf(errrpt,"     %d. ",l2);
               else if(l2 < 100) fprintf(errrpt,"    %d. ",l2);
               else if(l2 < 1000) fprintf(errrpt,"   %d. ",l2);
               else if(l2 < 10000) fprintf(errrpt,"  %d. ",l2);
               else if(l2 < 100000) fprintf(errrpt," %d. ",l2);
               else fprintf(errrpt,"%d. ",l2);
               fprintf(errrpt,"%s%%\n",resultmessage);

               sprintf(resultmessage,"%s %s: %s",ParseGAITgeometry((unsigned char) seeitgeom,2),GetECCCode(ECC),GetECCLabel(ECC));
               fprintf(errrpt,"         %s\n",&resultmessage[l]);
               }
            else
               {
               for(j=i; j<25; j++)
                  resultmessage[j] = ' ';
               sprintf(&resultmessage[24],"%15u %15d %10.3lf",(unsigned int) di,E1->count,100.0 * ((double) E1->count /di));
               if(l2 < 10) fprintf(errrpt,"     %d. ",l2);
               else if(l2 < 100) fprintf(errrpt,"    %d. ",l2);
               else if(l2 < 1000) fprintf(errrpt,"   %d. ",l2);
               else if(l2 < 10000) fprintf(errrpt,"  %d. ",l2);
               else if(l2 < 100000) fprintf(errrpt," %d. ",l2);
               else fprintf(errrpt,"%d. ",l2);
               fprintf(errrpt,"%s%%\n",resultmessage);
               }
            ++l2;
            }
         E1 = E1->next;
         }
      fprintf(errrpt,"                          TOTAL %15d %15d %10.3f%%\n",AcodePoss,AcodeErr,100.0 * ((double) AcodeErr / (double) AcodePoss));
      }



   if(ATTRTYPE_MGCP3() > 0) /*** MGCP3 ****/
      paragraph = 8;
   else if(ATTRTYPE_MGCP4() > 0) /*** MGCP4 ***/
      paragraph = 7;
   else if(ATTRTYPE_ANY_TDS() > 0)
      paragraph = 7;
   else
      paragraph = 6;


   fprintf(errrpt,"\n%d. Value range errors occur when a value has been assigned to a\n",paragraph);
   fprintf(errrpt,"   recognized attribute and that value is outside (e.g., above or below)\n");
   fprintf(errrpt,"   the range of valid values prescribed for use with that feature (FCODE),\n");
   fprintf(errrpt,"   attribute, and geometry.\n");
   fprintf(errrpt,"\n   Attributes with value range errors: %d\n\n",Type3);

   AcodeErr = AcodePoss = 0;
   
   if(Type3 > 0)
      {
      fprintf(errrpt,"        Attribute                     Attribute   Invalid Range     Percent\n");
      fprintf(errrpt,"        Name                             Occurs     Occurrences     Invalid\n");

      E1 = Summary_AEroot;
      l2 = 1;
      while(E1 != NULL)
         {
         if(E1->msgline[0] == '7')
            {
            sscanf(&E1->msgline[2],"%d",&EAC);
   
            di = 0;
            if(EAC == ARA_code)
               di = TtlARAattr;
            else if(EAC == HGT_code)
               di = TtlHGTattr;
            else if(EAC == ZV2_code)
               di = TtlZV2attr;
            else if(EAC == NAM_code)
               di = TtlNAMattr;
            else if(EAC == LEN_code)
               di = TtlLENattr;
            else
               {
               di = 0;
               ML2 = AListRoot;
               while(ML2 != NULL)
                  {
                  if(ML2->code == EAC)
                     di += ML2->occurrences;
                  ML2 = ML2->next;
                  }
               }

            AcodeErr += E1->count;
            AcodePoss += (int) di;

            if(di == 0)
               {
               printf("Fatal Error 3 - couldn't find attr in AListRoot for %s %d\n",GetEACLabel(EAC), EAC);
               exit(-1);
               }

            sprintf(QACRstring,"%s",GetEACCode(EAC));
            WriteQACRdata(qacr, "Value Range error", QACRstring, E1->count);


            sprintf(resultmessage,"%s (%s)",GetEACCode(EAC),GetEACLabel(EAC));
            i = strlen(resultmessage);
            i = strlen(resultmessage);
            if(i > 24)
               {
               l = 0;
               for(j=0; j<24; j++)
                  {
                  if(resultmessage[j] == ' ')
                     l = j;
                  }
               if(l == 0)
                  l = 23;

               for(j=l; j<25; j++)
                  resultmessage[j] = ' ';
               sprintf(&resultmessage[24],"%15u %15d %10.3lf",(unsigned int) di,E1->count,100.0 * ((double) E1->count /di));
               if(l2 < 10) fprintf(errrpt,"     %d. ",l2);
               else if(l2 < 100) fprintf(errrpt,"    %d. ",l2);
               else if(l2 < 1000) fprintf(errrpt,"   %d. ",l2);
               else if(l2 < 10000) fprintf(errrpt,"  %d. ",l2);
               else if(l2 < 100000) fprintf(errrpt," %d. ",l2);
               else fprintf(errrpt,"%d. ",l2);
               fprintf(errrpt,"%s%%\n",resultmessage);

               sprintf(resultmessage,"%s (%s)",GetEACCode(EAC),GetEACLabel(EAC));
               fprintf(errrpt,"         %s\n",&resultmessage[l]);
               }
            else
               {
               for(j=i; j<25; j++)
                  resultmessage[j] = ' ';
               sprintf(&resultmessage[24],"%15u %15d %10.3lf",(unsigned int) di,E1->count,100.0 * ((double) E1->count /di));
               if(l2 < 10) fprintf(errrpt,"     %d. ",l2);
               else if(l2 < 100) fprintf(errrpt,"    %d. ",l2);
               else if(l2 < 1000) fprintf(errrpt,"   %d. ",l2);
               else if(l2 < 10000) fprintf(errrpt,"  %d. ",l2);
               else if(l2 < 100000) fprintf(errrpt," %d. ",l2);
               else fprintf(errrpt,"%d. ",l2);
               fprintf(errrpt,"%s%%\n",resultmessage);
               }
            ++l2;
            }
         E1 = E1->next;
         }
      fprintf(errrpt,"                          TOTAL %15d %15d %10.3f%%\n",AcodePoss,AcodeErr,100.0 * ((double) AcodeErr / (double) AcodePoss));
      }

   if(ATTRTYPE_ANY_MGCP() > 0) /*** MGCP ****/
      {
      if(ATTRTYPE_MGCP3() > 0) /*** MGCP3 ****/
         paragraph = 9;
      else if(ATTRTYPE_MGCP4() > 0) /*** MGCP4 ***/
         paragraph = 8;

      if(ATTRTYPE_MGCP3() > 0)
         {
         fprintf(errrpt,"\n%d. MGCP \"Required Attribute Assigned Null Value\" errors occur when an attribute\n",paragraph);
         fprintf(errrpt,"   has been designated as metadata or is required for a specific feature, by\n");
         fprintf(errrpt,"   feature type and geometry, according to the MGCP feature catalog and the\n");
         fprintf(errrpt,"   value assigned to that attibute is the Null value.\n");
         }
      else if(ATTRTYPE_MGCP4() > 0)
         {
         fprintf(errrpt,"\n%d. MGCP \"Required Attribute Assigned Null Value\" errors occur when an attribute\n",paragraph);
         fprintf(errrpt,"   has been designated as string-type metadata by the MGCP feature catalogue\n");
         fprintf(errrpt,"   and the value assigned to that metadata attibute is the Null value (N/A).\n");
         }

         fprintf(errrpt,"\n   MGCP \"Required Attributes Assigned Null Value\" errors: %d\n\n",Type2);
         if(Type2 > 0)
            {
            fprintf(errrpt,"        Attribute                     Attribute      Null Value     Percent\n");
            fprintf(errrpt,"        Name                             Occurs     Occurrences     Invalid\n");
   
            AcodeErr = AcodePoss = 0;
   
            E1 = Summary_AEroot;
            l2 = 1;
            while(E1 != NULL)
               {
               if(E1->msgline[0] == '6')
                  {
                  sscanf(&E1->msgline[2],"%d",&EAC);
   
                  di = 0;
                  if(EAC == ARA_code)
                     di = TtlARAattr;
                  else if(EAC == HGT_code)
                     di = TtlHGTattr;
                  else if(EAC == ZV2_code)
                     di = TtlZV2attr;
                  else if(EAC == NAM_code)
                     di = TtlNAMattr;
                  else if(EAC == LEN_code)
                     di = TtlLENattr;
                  else
                     {
                     di = 0;
                     ML2 = AListRoot;
                     while(ML2 != NULL)
                        {
                        if(ML2->code == EAC)
                           di += ML2->occurrences;
                        ML2 = ML2->next;
                        }
                     }
   
                  AcodeErr += E1->count;
                  AcodePoss += (int) di;
   
                  sprintf(QACRstring,"%s",GetEACCode(EAC));
                  WriteQACRdata(qacr, "MGCP \"Required Attribute Assigned NULL Value\" error", QACRstring, E1->count);

   
                  if(di == 0)
                     {
                     printf("Fatal Error 4 - couldn't find attr in AListRoot for %s %d\n",GetEACLabel(EAC), EAC);
                     exit(-1);
                     }
                  sprintf(resultmessage,"%s (%s)",GetEACCode(EAC),GetEACLabel(EAC));
                  i = strlen(resultmessage);
                  i = strlen(resultmessage);
                  if(i > 24)
                     {
                     l = 0;
                     for(j=0; j<24; j++)
                        {
                        if(resultmessage[j] == ' ')
                           l = j;
                        }
                     if(l == 0)
                        l = 23;
   
                     for(j=l; j<25; j++)
                        resultmessage[j] = ' ';
                     sprintf(&resultmessage[24],"%15u %15d %10.3lf",(unsigned int) di,E1->count,100.0 * ((double) E1->count / di));
                     if(l2 < 10) fprintf(errrpt,"     %d. ",l2);
                     else if(l2 < 100) fprintf(errrpt,"    %d. ",l2);
                     else if(l2 < 1000) fprintf(errrpt,"   %d. ",l2);
                     else if(l2 < 10000) fprintf(errrpt,"  %d. ",l2);
                     else if(l2 < 100000) fprintf(errrpt," %d. ",l2);
                     else fprintf(errrpt,"%d. ",l2);
                     fprintf(errrpt,"%s%%\n",resultmessage);
      
                     sprintf(resultmessage,"%s (%s)",GetEACCode(EAC),GetEACLabel(EAC));
                     fprintf(errrpt,"         %s\n",&resultmessage[l]);
                     }
                  else
                     {
                     for(j=i; j<25; j++)
                        resultmessage[j] = ' ';
                     sprintf(&resultmessage[24],"%15u %15d %10.3lf",(unsigned int) di,E1->count,100.0 * ((double) E1->count / di));
                     if(l2 < 10) fprintf(errrpt,"     %d. ",l2);
                     else if(l2 < 100) fprintf(errrpt,"    %d. ",l2);
                     else if(l2 < 1000) fprintf(errrpt,"   %d. ",l2);
                     else if(l2 < 10000) fprintf(errrpt,"  %d. ",l2);
                     else if(l2 < 100000) fprintf(errrpt," %d. ",l2);
                     else fprintf(errrpt,"%d. ",l2);
                     fprintf(errrpt,"%s%%\n",resultmessage);
                     }
                  ++l2;
                  }
               E1 = E1->next;
               }
            fprintf(errrpt,"                          TOTAL %15d %15d %10.3f%%\n",AcodePoss,AcodeErr,100.0 * ((double) AcodeErr / (double) AcodePoss));
         }
      }



   if(ATTRTYPE_ANY_MGCP() > 0) /*** MGCP ****/
      {
      if(ATTRTYPE_MGCP3() > 0) /*** MGCP3 ****/
         paragraph = 10;
      else if(ATTRTYPE_MGCP4() > 0) /*** MGCP4 ***/
         paragraph = 9;

      fprintf(errrpt,"\n%d.Unexpected attribute errors occur when a recognized\n",paragraph);
      }
   else
      {
      if(ATTRTYPE_ANY_TDS() > 0)
         paragraph = 8;
      else
         paragraph = 7;
      fprintf(errrpt,"\n%d. Unexpected attribute errors occur when a recognized\n",paragraph);
      }


   fprintf(errrpt,"   attribute is assigned to a feature having a recognized FCODE and that\n");
   fprintf(errrpt,"   attribute is not a member of the list of attributes prescribed for use\n");
   fprintf(errrpt,"   with features having the FCODE and geometry.\n");

   fprintf(errrpt,"\n   Attributes with unexpected attribute errors: %d\n\n",Type1);
   if(Type1 > 0)
      {
      fprintf(errrpt,"        Attribute                     Attribute      Unexpected     Percent\n");
      fprintf(errrpt,"        Name                             Occurs     Occurrences     Invalid\n");

      AcodeErr = AcodePoss = 0;

      E1 = Summary_AEroot;
      l2 = 1;
      while(E1 != NULL)
         {
         if(E1->msgline[0] == '5')
            {
            sscanf(&E1->msgline[2],"%d",&EAC);

            di = 0;
            if(EAC == ARA_code)
               di = TtlARAattr;
            else if(EAC == HGT_code)
               di = TtlHGTattr;
            else if(EAC == ZV2_code)
               di = TtlZV2attr;
            else if(EAC == NAM_code)
               di = TtlNAMattr;
            else if(EAC == LEN_code)
               di = TtlLENattr;
            else
               {
               di = 0;
               ML2 = AListRoot;
               while(ML2 != NULL)
                  {
                  if(ML2->code == EAC)
                     di += ML2->occurrences;
                  ML2 = ML2->next;
                  }
               }

            AcodeErr += E1->count;
            AcodePoss += (int) di;

               sprintf(QACRstring,"%s",GetEACCode(EAC));
               WriteQACRdata(qacr, "Unexpected Attribute error", QACRstring, E1->count);


            if(di == 0)
               {
               printf("Fatal Error 5 - couldn't find attr in AListRoot for %s %d\n",GetEACLabel(EAC), EAC);
               exit(-1);
               }
            sprintf(resultmessage,"%s (%s)",GetEACCode(EAC),GetEACLabel(EAC));
            i = strlen(resultmessage);
            if(i > 24)
               {
               l = 0;
               for(j=0; j<24; j++)
                  {
                  if(resultmessage[j] == ' ')
                     l = j;
                  }
               if(l == 0)
                  l = 23;

               for(j=l; j<25; j++)
                  resultmessage[j] = ' ';
               sprintf(&resultmessage[24],"%15u %15d %10.3lf",(unsigned int) di,E1->count,100.0 * ((double) E1->count / di));
               if(l2 < 10) fprintf(errrpt,"     %d. ",l2);
               else if(l2 < 100) fprintf(errrpt,"    %d. ",l2);
               else if(l2 < 1000) fprintf(errrpt,"   %d. ",l2);
               else if(l2 < 10000) fprintf(errrpt,"  %d. ",l2);
               else if(l2 < 100000) fprintf(errrpt," %d. ",l2);
               else fprintf(errrpt,"%d. ",l2);
               fprintf(errrpt,"%s%%\n",resultmessage);

               sprintf(resultmessage,"%s (%s)",GetEACCode(EAC),GetEACLabel(EAC));
               fprintf(errrpt,"         %s\n",&resultmessage[l]);
               }
            else
               {
               for(j=i; j<25; j++)
                  resultmessage[j] = ' ';
               sprintf(&resultmessage[24],"%15u %15d %10.3lf",(unsigned int) di,E1->count,100.0 * ((double) E1->count / di));
               if(l2 < 10) fprintf(errrpt,"     %d. ",l2);
               else if(l2 < 100) fprintf(errrpt,"    %d. ",l2);
               else if(l2 < 1000) fprintf(errrpt,"   %d. ",l2);
               else if(l2 < 10000) fprintf(errrpt,"  %d. ",l2);
               else if(l2 < 100000) fprintf(errrpt," %d. ",l2);
               else fprintf(errrpt,"%d. ",l2);
               fprintf(errrpt,"%s%%\n",resultmessage);
               }
            ++l2;
            }
         E1 = E1->next;
         }
      fprintf(errrpt,"                          TOTAL %15d %15d %10.3f%%\n",AcodePoss,AcodeErr,100.0 * ((double) AcodeErr / (double) AcodePoss));
      }


   if(ATTRTYPE_ANY_MGCP() > 0) /*** MGCP ****/
      {
      if(ATTRTYPE_MGCP3() > 0) /*** MGCP3 ****/
         paragraph = 11;
      else if(ATTRTYPE_MGCP4() > 0) /*** MGCP4 ***/
         paragraph = 10;
      fprintf(errrpt,"\n%d.Missing attribute field or value errors occur when the MGCP Schema\n",paragraph);
      fprintf(errrpt,"   designates an attribute as mandatory or optional for assignment to a specific\n");
      fprintf(errrpt,"   feature (according to the assigned classification and geometry), and one or\n");
      fprintf(errrpt,"   more of those attributes is not assigned to the feature in the GAIT project.\n");
      fprintf(errrpt,"   Attributes may be reported as missing when: 1) there is no field for the\n");
      fprintf(errrpt,"   attribute in the input data; 2) the field name is not exactly the same as the\n");
      fprintf(errrpt,"   attrbute code; 3) the correct field appears in the input data, but the value\n");
      fprintf(errrpt,"   for a specific record is invalid.  Any attributes reported in the below list\n");
      fprintf(errrpt,"   should be cross-checked with other errors reported as: 1) Unrecognized Column\n");
      fprintf(errrpt,"   Names (see Input Data Anomalies); 2) Blank Attribute errors; and 3) Non\n");
      fprintf(errrpt,"   Domain Specific Pick-list errors.\n");
      }
   else
      {
      if(ATTRTYPE_ANY_TDS() > 0)
         paragraph = 9;
      else
         paragraph = 8;
      fprintf(errrpt,"\n%d. Missing attribute field or value errors occur when a specific\n",paragraph);
      fprintf(errrpt,"   attribute has been designated as mandatory for assignment to a feature\n");
      fprintf(errrpt,"   (according to the assigned classification and geometry), and one or more of\n");
      fprintf(errrpt,"   those attributes is not associated with the feature in the GAIT project.\n");
      fprintf(errrpt,"   Attributes may be reported as missing when: 1) there is no field for the\n");
      fprintf(errrpt,"   attribute in the input data; 2) the field name is not exactly the same as the\n");
      fprintf(errrpt,"   attrbute code; 3) the correct field appears in the input data, but the value\n");
      fprintf(errrpt,"   for a specific record is invalid.  Any attributes reported in the below list\n");
      fprintf(errrpt,"   should be cross-checked with other errors reported as: 1) Unrecognized Column\n");
      fprintf(errrpt,"   Names (see Input Data Anomalies); 2) Blank Attribute errors; and 3) Non\n");
      fprintf(errrpt,"   Domain Specific Pick-list errors.\n");
      }

   fprintf(errrpt,"\n   Attributes identifed as missing attribute field or value errors: %d\n\n",Type5);
   if(Type5 > 0)
      {
      fprintf(errrpt,"        Attribute                     Attribute       Attribute     Percent\n");
      fprintf(errrpt,"        Name                             Occurs         Missing     Invalid\n");

      AcodeErr = AcodePoss = 0;

      E1 = Summary_AEroot;
      l2 = 1;
      while(E1 != NULL)
         {
         if(E1->msgline[0] == 'Z')
            {
            sscanf(&E1->msgline[2],"%d",&EAC);

            di = 0;

            if(EAC == ARA_code)
               di = TtlARAattr;
            else if(EAC == HGT_code)
               di = TtlHGTattr;
            else if(EAC == ZV2_code)
               di = TtlZV2attr;
            else if(EAC == NAM_code)
               di = TtlNAMattr;
            else if(EAC == LEN_code)
               di = TtlLENattr;
            else
               {
               di = 0;
               ML2 = AListRoot;
               while(ML2 != NULL)
                  {
                  if(ML2->code == EAC)
                     di += ML2->occurrences;
                  ML2 = ML2->next;
                  }
               }


            AcodeErr += E1->count;
            AcodePoss += (int) di;
            sprintf(QACRstring,"%s",GetEACCode(EAC));
            WriteQACRdata(qacr, "Missing Attribute Field Or Value error", QACRstring, E1->count);

            sprintf(resultmessage,"%s (%s)",GetEACCode(EAC),GetEACLabel(EAC));
            i = strlen(resultmessage);
            if(i > 24)
               {
               l = 0;
               for(j=0; j<24; j++)
                  {
                  if(resultmessage[j] == ' ')
                     l = j;
                  }
               if(l == 0)
                  l = 23;

               for(j=l; j<25; j++)
                  resultmessage[j] = ' ';
               sprintf(&resultmessage[24],"%15d %15d %10.3lf",(unsigned int) di,E1->count,100.0 * (((double) E1->count) / (di + (double) (E1->count))));
               if(l2 < 10) fprintf(errrpt,"     %d. ",l2);
               else if(l2 < 100) fprintf(errrpt,"    %d. ",l2);
               else if(l2 < 1000) fprintf(errrpt,"   %d. ",l2);
               else if(l2 < 10000) fprintf(errrpt,"  %d. ",l2);
               else if(l2 < 100000) fprintf(errrpt," %d. ",l2);
               else fprintf(errrpt,"%d. ",l2);
               fprintf(errrpt,"%s%%\n",resultmessage);

               sprintf(resultmessage,"%s (%s)",GetEACCode(EAC),GetEACLabel(EAC));
               fprintf(errrpt,"         %s\n",&resultmessage[l]);
               }
            else
               {
               for(j=i; j<25; j++)
                  resultmessage[j] = ' ';
               sprintf(&resultmessage[24],"%15d %15d %10.3lf",(unsigned int) di,E1->count,100.0 * (((double) E1->count) / (di + (double) (E1->count))));
               if(l2 < 10) fprintf(errrpt,"     %d. ",l2);
               else if(l2 < 100) fprintf(errrpt,"    %d. ",l2);
               else if(l2 < 1000) fprintf(errrpt,"   %d. ",l2);
               else if(l2 < 10000) fprintf(errrpt,"  %d. ",l2);
               else if(l2 < 100000) fprintf(errrpt," %d. ",l2);
               else fprintf(errrpt,"%d. ",l2);
               fprintf(errrpt,"%s%%\n",resultmessage);
               }
            ++l2;
            }
         E1 = E1->next;
         }
      fprintf(errrpt,"                          TOTAL %15d %15d %10.3f%%\n",
                      AcodePoss,AcodeErr,100.0 * ((double) AcodeErr / (double) (AcodeErr + AcodePoss)));
      }



   
   if((ATTRTYPE_ANY_MGCP() > 0)  ||/*** MGCP ****/
       (ATTRTYPE_UFD1() > 0) ||
       (ATTRTYPE_ANY_TDS() > 0) ||
       (ATTRTYPE_NFDD() > 0) || /*** NFDD ***/
       (ATTRTYPE_DFDD() > 0) || /** DFDD ***/
       (ATTRTYPE_SAC() > 0) || /*** SAC ***/
       (ATTRTYPE_ANY_GGDM() > 0)) /*** GGDM ***/
      {
      if(ATTRTYPE_MGCP3() > 0)
         fprintf(errrpt,"\n12.MGCP attribute dependency errors occur when the allowed value (or presence)\n");
      else if(ATTRTYPE_UFD1() > 0)
         fprintf(errrpt,"\n9. UFD1 attribute dependency errors occur when the allowed value (or presence)\n");
      else if(ATTRTYPE_SAC() > 0) 
         fprintf(errrpt,"\n9. AFD attribute dependency errors occur when the allowed value (or presence)\n");
      else if(ATTRTYPE_NFDD() > 0)
         fprintf(errrpt,"\n9. NFDD attribute dependency errors occur when the allowed value (or presence)\n");
      else if(ATTRTYPE_DFDD() > 0)
         {
         if(ATTRINSTYPE == 4)
            fprintf(errrpt,"\n9. DFDD attribute dependency errors occur when the allowed value (or presence)\n");
         else
            fprintf(errrpt,"\n9. Attribute dependency errors occur when the allowed value (or presence)\n");
         }
      else if(ATTRTYPE_ANY_GGDM() > 0)
         fprintf(errrpt,"\n9. GGDM attribute dependency errors occur when the allowed value (or presence)\n");
      else if(ATTRTYPE_TDS4() > 0)
         fprintf(errrpt,"\n10.TDSv4 attribute dependency errors occur when the allowed value\n");
      else if(ATTRTYPE_TDS6() > 0)
         fprintf(errrpt,"\n10.TDS v6 attribute dependency errors occur when the allowed value\n");

      if(ATTRTYPE_MGCP4() > 0)
         {
         fprintf(errrpt,"\n11.MGCP attribute dependency errors are reported as conditions based on\n");
         fprintf(errrpt,"   the specifications provided in the Illogical Attribute / Enumerate\n");
         fprintf(errrpt,"   Combinations spreadsheet.\n");
         }
      else
         {
         fprintf(errrpt,"   of one attribute depends on the value assigned to another attribute - as\n");
         fprintf(errrpt,"   an example, if a river is designated as intermittent or dry, then it may\n");
         fprintf(errrpt,"   also be required to be non-tidal, so river features described as dry and\n");
         fprintf(errrpt,"   tide-influenced would violate this dependency relationship.\n");
         }

      if((ATTRTYPE_MGCP3() > 0) || (ATTRTYPE_MGCP4() > 0))
         fprintf(errrpt,"\n   Pairs of attributes involved in MGCP attribute dependency errors: %d\n\n",Type6);
      else if(ATTRTYPE_UFD1() > 0)
         fprintf(errrpt,"\n   Pairs of attributes involved in UFD1 attribute dependency errors: %d\n\n",Type6);
      else if((ATTRTYPE_TDS4() > 0) || (ATTRTYPE_TDS6() >0))
         fprintf(errrpt,"\n   Attributes involved in TDS attribute dependency errors: %d\n\n",Type6);
      else if(ATTRTYPE_SAC() > 0)
         fprintf(errrpt,"\n   Pairs of attributes involved in AFD attribute dependency errors: %d\n\n",Type6);
      else if(ATTRTYPE_ANY_GGDM() > 0)
         fprintf(errrpt,"\n   Pairs of attributes involved in GGDM attribute dependency errors: %d\n\n",Type6);
      if((ATTRTYPE_NFDD() > 0) || (ATTRTYPE_DFDD() > 0))
         {
         if(ATTRINSTYPE == 4)
            {
            if(ATTRTYPE_NFDD() > 0)
               fprintf(errrpt,"\n   Pairs of attributes involved in NFDD attribute dependency errors: %d\n\n",Type6);
            else if(ATTRTYPE_DFDD() > 0)
               fprintf(errrpt,"\n   Pairs of attributes involved in DFDD attribute dependency errors: %d\n\n",Type6);
            }
         else
            {
            fprintf(errrpt,"\n   The project was not inspected for attribute dependency errors\n");
            Type6 = 0;
            }
         }

      if(Type6 > 0)
         {
         fprintf(errrpt,"        Related                                                  Dependency\n");
         fprintf(errrpt,"        Attributes                                               Violations\n");

         AcodeErr = AcodePoss = 0;

         E1 = Summary_AEroot;
         l2 = 1;
         while(E1 != NULL)
            {
            if((E1->msgline[0] == 'X') || (E1->msgline[0] == 'P'))
               {
               sscanf(&E1->msgline[2],"%d %d",&EAC, &EAC2);
               di = 0;
               if(EAC == ARA_code)
                  di = TtlARAattr;
               else if(EAC == HGT_code)
                  di = TtlHGTattr;
               else if(EAC == ZV2_code)
                  di = TtlZV2attr;
               else if(EAC == NAM_code)
                  di = TtlNAMattr;
               else if(EAC == LEN_code)
                  di = TtlLENattr;
               else
                  {
                  di = 0;
                  ML2 = AListRoot;
                  while(ML2 != NULL)
                     {
                     if(ML2->code == EAC)
                        di += ML2->occurrences;
                     ML2 = ML2->next;
                     }
                  }

               AcodeErr += E1->count;
               AcodePoss += (int) di;
               if(di == 0)
                  {
                  printf("Fatal Error 6 - couldn't find attr in AListRoot for %s %d\n",GetEACLabel(EAC), EAC);
ML2 = AListRoot;
while(ML2 != NULL)
{
printf("%d %s\n",ML2->code,GetEACLabel(ML2->code));
ML2 = ML2->next;
}

                  exit(-1);
                  }
               sprintf(resultmessage,"%s (%s)",GetEACCode(EAC),GetEACLabel(EAC));
               if(EAC2 == EAC)
                  strcpy(EACname," (multiple related attributes)");
               else if(EAC2 == -99)
                  strcpy(EACname," (capture condition violation)");
               else
                  sprintf(EACname," and %s (%s)",GetEACCode(EAC2),GetEACLabel(EAC2));
               if(EAC2 == EAC)
                  sprintf(QACRstring,"%s and (multiple related attributes)",GetEACCode(EAC));
               else if(EAC2 == -99)
                  sprintf(QACRstring,"%s (capture condition violation)",GetEACCode(EAC));
               else
                  sprintf(QACRstring,"%s and %s",GetEACCode(EAC),GetEACCode(EAC2));
               WriteQACRdata(qacr, "Attribute Dependency error", QACRstring, E1->count);
               
               strcat(resultmessage,EACname);
               i = strlen(resultmessage);
               if(i > 49)
                  {
                  l = 0;
                  for(j=0; j<49; j++)
                     {
                     if(resultmessage[j] == ' ')
                        l = j;
                     }
                  if(l == 0)
                     l = 48;
   
                  for(j=l; j<49; j++)
                     resultmessage[j] = ' ';
                  sprintf(&resultmessage[49],"%15d",E1->count);
                  if(l2 < 10) fprintf(errrpt,"     %d. ",l2);
                  else if(l2 < 100) fprintf(errrpt,"    %d. ",l2);
                  else if(l2 < 1000) fprintf(errrpt,"   %d. ",l2);
                  else if(l2 < 10000) fprintf(errrpt,"  %d. ",l2);
                  else if(l2 < 100000) fprintf(errrpt," %d. ",l2);
                  else fprintf(errrpt,"%d. ",l2);
                  fprintf(errrpt,"%s\n",resultmessage);

                  sprintf(resultmessage,"%s (%s)",GetEACCode(EAC),GetEACLabel(EAC));
                  if(EAC2 == EAC)
                     strcpy(EACname," (multiple related attributes)");
                  else if(EAC2 == -99)
                     strcpy(EACname," (capture condition violation)");
                  else
                     sprintf(EACname," and %s (%s)",GetEACCode(EAC2),GetEACLabel(EAC2));
               
                  strcat(resultmessage,EACname);

                  fprintf(errrpt,"         %s\n",&resultmessage[l]);
                  }
               else
                  {
                  for(j=i; j<49; j++)
                     resultmessage[j] = ' ';
                  sprintf(&resultmessage[49],"%15d",E1->count);
                  if(l2 < 10) fprintf(errrpt,"     %d. ",l2);
                  else if(l2 < 100) fprintf(errrpt,"    %d. ",l2);
                  else if(l2 < 1000) fprintf(errrpt,"   %d. ",l2);
                  else if(l2 < 10000) fprintf(errrpt,"  %d. ",l2);
                  else if(l2 < 100000) fprintf(errrpt," %d. ",l2);
                  else fprintf(errrpt,"%d. ",l2);
                  fprintf(errrpt,"%s\n",resultmessage);
                  }
               ++l2;
               }
            E1 = E1->next;
            }
         fprintf(errrpt,"                          TOTAL %40d\n", AcodeErr);

         E1 = Summary_AEroot;
         AcodeErr = 0;
         while(E1 != NULL)
            {
            if(E1->msgline[0] == 'Y')
               {
               if((E1->count > 0) && (AcodeErr == 0))
                  fprintf(errrpt,"\n      Building function-type (e.g. HWT, UUC, CIT, ...) conflict\n");
               for(j=0; j<55; j++)
                  resultmessage[j] = ' ';
               sscanf(&E1->msgline[2],"%d %d",&ECC, &seeitgeom);
               sprintf(resultmessage,"%s: %s %s",ParseGAITgeometry((unsigned char) seeitgeom, 2), GetECCCode(ECC),GetECCLabel(ECC));
               for(j=0; j<51; j++)
                  {
                  if(resultmessage[j] < ' ')
                     resultmessage[j] = ' ';
                  }
               sprintf(&resultmessage[50],"%16d",E1->count);
               fprintf(errrpt,"      %s\n",resultmessage);

               WriteQACRdata(qacr, "Attribute Dependency error", "Building function-type attribute (e.g. HWT, UUC, CIT, ...) conflict", E1->count);
               }
            E1 = E1->next;
            }
         }
      }

   if(ATTRTYPE_TDS6() > 0)
      {
      fprintf(errrpt,"\n11.GAIT recognizes both 3-character and 17-character codes for the\n");
      fprintf(errrpt,"   \"(Location Country) Designation : GENC Short URN-based Identifier\"\n");
      fprintf(errrpt,"   set of attributes (ZI020_GE4, ZI020_GE42, ZI020_GE43, and ZI020_GE44).\n");
      fprintf(errrpt,"   The sentinel codes \"other\" and \"noInformation\" are also recognized.\n");
      fprintf(errrpt,"   Frequency counts for these 3 catgories of code values are provided below.\n");
      fprintf(errrpt,"\n     Sentinel: %d     3-character code: %d     17-character code: %d\n\n",
                                  TDS_GE4_sentinel,TDS_GE4_3letter,TDS_GE4_17letter);
      }



   if(DoMetadataChecking > 0)
      {
      E1 = GIFD_MTroot;
      Type1 = 0;
      while(E1 != NULL)
         {
         Type1 += 1;
         E1 = E1->next;
         }
      }
   if(ATTRTYPE_MGCP3() > 0) /*** MGCP3 ****/
      {
      fprintf(errrpt,"\n13.MGCP metadata errors occur when the metadata is not in compliance with\n");
      fprintf(errrpt,"   the metadata requirements detailed in the MGCP TRD3 \"Feature and Attribute \n");
      fprintf(errrpt,"   Catalogue\" (HTML version).  Example errors include cases of\n");
      fprintf(errrpt,"   missing attributes that are required and invalid pick list values.\n");
      }
   else if(ATTRTYPE_MGCP4() > 0) /*** MGCP4 ****/
      {
      fprintf(errrpt,"\n12.MGCP metadata errors occur when the metadata is not in compliance with\n");
      fprintf(errrpt,"   the requirements detailed in the MGCP TRD4 \"Feature and Attribute\n");
      fprintf(errrpt,"   Catalogue\" (HTML version).  Example errors include cases of\n");
      fprintf(errrpt,"   missing attributes that are required and invalid pick list values.\n");
      }
   else if((ATTRTYPE_D4() > 0) || (ATTRTYPE_FACC() > 0) || (ATTRTYPE_VMAP() > 0)) /*** GIFD, FACC, or VMAP  ***/
      {
      fprintf(errrpt,"\n9. GIFD_D4 metadata errors occur when the metadata is not in compliance\n");
      fprintf(errrpt,"   with the metadata requirements detailed in the document \"GIFD Delivery\n");
      fprintf(errrpt,"   4 Metadata Definitions\", version dated 2/1/2005.  Example errors include\n");
      fprintf(errrpt,"   cases of missing attributes that are required, invalid pick list values,\n");
      fprintf(errrpt,"   and the assignment of invalid values given the existing values for other\n");
      fprintf(errrpt,"   metadata attributes.\n");
      }
   else if(ATTRTYPE_UFD1() > 0) /**** UFD1 ***/
      {
      fprintf(errrpt,"\n10.GIFD_D4 metadata errors occur when the metadata is not in compliance\n");
      fprintf(errrpt,"   with the metadata requirements detailed in the document \"GIFD Delivery\n");
      fprintf(errrpt,"   4 Metadata Definitions\", version dated 2/1/2005.  Example errors include\n");
      fprintf(errrpt,"   cases of missing attributes that are required, invalid pick list values,\n");
      fprintf(errrpt,"   and the assignment of invalid values given the existing values for other\n");
      fprintf(errrpt,"   metadata attributes.\n");
      }
   else if((ATTRTYPE_UFD2() > 0) || (ATTRTYPE_UFD3() > 0)) /****  UFD2 or UFD3 ***/
      {
      fprintf(errrpt,"\n9. GIFD_D4 metadata errors occur when the metadata is not in compliance\n");
      fprintf(errrpt,"   with the metadata requirements detailed in the document \"GIFD Delivery\n");
      fprintf(errrpt,"   4 Metadata Definitions\", version dated 2/1/2005.  Example errors include\n");
      fprintf(errrpt,"   cases of missing attributes that are required, invalid pick list values,\n");
      fprintf(errrpt,"   and the assignment of invalid values given the existing values for other\n");
      fprintf(errrpt,"   metadata attributes.\n");
      }
   else if((ATTRTYPE_TDS4() > 0) || (ATTRTYPE_TDS6() > 0)) /**** TDS ***/
      {
      if(ATTRTYPE_TDS4() > 0)
         {
         fprintf(errrpt,"\n11.TDS metadata errors occur when the metadata is not in compliance\n");
         fprintf(errrpt,"   with the related requirements detailed in the spreadsheet \"TDS DCS EC\n");
         fprintf(errrpt,"   (V4.0).xls\", version dated 7 July 2011.  Example errors include\n");
         }
      else if(ATTRTYPE_TDS6() > 0)
         {
         fprintf(errrpt,"\n12.TDS metadata errors occur when the metadata is not in compliance\n");
         fprintf(errrpt,"   with the requirements detailed in the spreadsheet \"TDS_6_1_20140424\"\n");
         fprintf(errrpt,"   version dated 24 April, 2014.  Example errors include\n");
         }
      fprintf(errrpt,"   cases of missing attributes that are required, invalid pick list values,\n");
      fprintf(errrpt,"   and the assignment of invalid values given the existing values for other\n");
      fprintf(errrpt,"   metadata attributes.\n");
      }
   else if(ATTRTYPE_SAC() > 0) /****  SAC ***/
      {
      fprintf(errrpt,"\n10. AFD metadata errors occur when the metadata is not in compliance\n");
      fprintf(errrpt,"   with the requirements detailed in the document \"Airfield Foundation\n");
      fprintf(errrpt,"   Data, Stereo Airfield Collection Extraction Manual, V2.6 (Appendix B),\"\n");
      fprintf(errrpt,"   version dated 05/03/2016.  Example errors include cases of invalid pick\n");
      fprintf(errrpt,"   list values, missing attributes, and the assignment of invalid values\n");
      fprintf(errrpt,"   given the existing values for other metadata attributes.\n");
      }
   else if(ATTRTYPE_GGDM21() > 0) /****  GGDM ***/
      {
      fprintf(errrpt,"\n10. GGDM metadata errors occur when the metadata is not in compliance\n");
      fprintf(errrpt,"   with the requirements given in the document \"GGDM Logical Entity Catalog\n");
      fprintf(errrpt,"   (GGDM LEC), version 2.1 (NFDD 4.0)\", version dated 17 Nov 2011.  Example\n");
      fprintf(errrpt,"   errors include cases of invalid pick list values, missing attributes,\n");
      fprintf(errrpt,"   and the assignment of invalid values given the existing values for other\n");
      fprintf(errrpt,"   metadata attributes.\n");
      }
   else if(ATTRTYPE_GGDM22() > 0) /****  GGDM ***/
      {
      fprintf(errrpt,"\n10. GGDM metadata errors occur when the metadata is not in compliance\n");
      fprintf(errrpt,"   with the requirements given in the document \"GGDM Logical Entity Catalog\n");
      fprintf(errrpt,"   (GGDM LEC), version 2.2\", version dated 11 November, 2013.  Example\n");
      fprintf(errrpt,"   errors include cases of invalid pick list values, missing attributes,\n");
      fprintf(errrpt,"   and the assignment of invalid values given the existing values for other\n");
      fprintf(errrpt,"   metadata attributes.\n");
      }
   else if(ATTRTYPE_GGDM3() > 0) /****  GGDM ***/
      {
      fprintf(errrpt,"\n10. GGDM metadata errors occur when the metadata is not in compliance\n");
      fprintf(errrpt,"   with the requirements given in the document \"Groud-warfighter Geospatial\n");
      fprintf(errrpt,"   Data Model Logical Entity Catalog (GGDM LEC), version 3.0\", version\n");
      fprintf(errrpt,"   dated 16 January, 2016.  Example errors include cases of invalid pick\n");
      fprintf(errrpt,"   list values, missing attributes, and the assignment of invalid values\n");
      fprintf(errrpt,"   given the existing values for other metadata attributes.\n");
      }

   if(DoMetadataChecking == 0)
      {
      if(ATTRTYPE_ANY_MGCP() > 0)
         fprintf(errrpt,"\n  This project was not inspected for MGCP metadata errors.\n\n");
      else if((ATTRTYPE_D4() > 0) || (ATTRTYPE_FACC() > 0) || (ATTRTYPE_VMAP() > 0))
         fprintf(errrpt,"\n  This project was not inspected for GIFD_D4 metadata errors.\n\n");
      else if((ATTRTYPE_UFD1() > 0) || (ATTRTYPE_UFD2() > 0) || (ATTRTYPE_UFD3() > 0))
         fprintf(errrpt,"\n  This project was not inspected for GIFD_D4 metadata errors.\n\n");
      else if(ATTRTYPE_ANY_TDS() > 0)
         fprintf(errrpt,"\n  This project was not inspected for TDS DCS metadata errors.\n\n");
      else if(ATTRTYPE_ANY_GGDM() > 0) /**** GGDM ***/
         fprintf(errrpt,"\n  This project was not inspected for GGDM metadata errors.\n\n");
      }
   else
      {
      if(ATTRTYPE_ANY_MGCP() > 0) /*** MGCP **/
         fprintf(errrpt,"\n   Attributes with MGCP metadata errors: %d\n\n",Type1);
      else if((ATTRTYPE_D4() > 0) || (ATTRTYPE_FACC() > 0) || (ATTRTYPE_VMAP() > 0)) /***GIFD, FACC, or VMAP ***/
         fprintf(errrpt,"\n   Attributes with GIFD_D4 metadata errors: %d\n\n",Type1);
      else if((ATTRTYPE_UFD1() > 0) || (ATTRTYPE_UFD2() > 0) || (ATTRTYPE_UFD3() > 0))
         fprintf(errrpt,"\n   Attributes with GIFD_D4 metadata errors: %d\n\n",Type1);
      else if(ATTRTYPE_ANY_TDS() > 0)
         fprintf(errrpt,"\n   Attributes with TDS DCS metadata errors: %d\n\n",Type1);
      else if(ATTRTYPE_SAC() > 0) /** SAC ***/
         fprintf(errrpt,"\n   Attributes with AFD metadata errors: %d\n\n",Type1);
      else if(ATTRTYPE_ANY_GGDM() > 0) /** GGDM ***/
         fprintf(errrpt,"\n   Attributes with GGDM metadata errors: %d\n\n",Type1);

      if(Type1 > 0)
         {
         fprintf(errrpt,"          Condition  Condition\n");
         fprintf(errrpt,"        Occurrences  Description\n");

         AcodeErr = AcodePoss = 0;

         E1 = GIFD_MTroot;
         l2 = 1;
         while(E1 != NULL)
            {
            if(l2 < 10) fprintf(errrpt,"     %d. ",l2);
            else if(l2 < 100) fprintf(errrpt,"    %d. ",l2);
            else if(l2 < 1000) fprintf(errrpt,"   %d. ",l2);
            else if(l2 < 10000) fprintf(errrpt,"  %d. ",l2);
            else if(l2 < 100000) fprintf(errrpt," %d. ",l2);
            else fprintf(errrpt,"%d. ",l2);

            AcodeErr += E1->count;

            numchar = strlen(E1->msgline);
            ki = 0;
            i = 0;
            kjunk = 0;
            while(i < numchar)
               {
               if(E1->msgline[i] == '\n')
                  {
                  resultmessage[ki] = '\0';
                  ++i;
                  break;
                  }
               else if(E1->msgline[i] == '(')
                  {
                  ++kjunk;
                  while((E1->msgline[i] >= ' ') && (kjunk > 0))
                     {
                     if(E1->msgline[i] == ')')
                        --kjunk;
                     ++i;
                     if(E1->msgline[i] == '(')
                        ++kjunk;
                     }
                  }
               else
                  {
                  resultmessage[ki] = E1->msgline[i];
                  ++i;
                  ++ki;
                  }
               if(ki > 285)
                  {
                  resultmessage[ki] = '\0';
                  break;
                  }
               resultmessage[ki] = '\0';
               }
            ki = 0;
            while(resultmessage[ki] == ' ')
               {
               if(resultmessage[ki] < ' ')
                  {
                  resultmessage[ki] = '\0';
                  ki = 0;
                  break;
                  }
               ++ki;
               }
            WriteQACRdata(qacr, "Metadata error", &resultmessage[ki], E1->count);

            fprintf(errrpt,"%11d ",E1->count);
            strcpy(resultmessage,E1->msgline);

            i = strlen(resultmessage);
            for(j=0; j<i; j++)
               {
               if(resultmessage[j] < 32)
                  resultmessage[j] = ' ';
               }
            if(i< 53)
               fprintf(errrpt,"%s\n",resultmessage);
            else
               {
               k = j = 0;
               while(j < i)
                  {
                  if(k > 0)
                     {
                     fprintf(errrpt,"                      ");
                     }
                  l = 0;
                  if(i < (k + 53))
                     {
                     fprintf(errrpt,"%s\n",&resultmessage[k]);
                     j = i + 100;
                     }
                  else
                     {
                     for(j=k; j<(k + 53); j++)
                        {
                        if(resultmessage[j] == 32)
                           l = j;
                        }
                     if(l == 0)
                        l = k+53;
                     resultmessage[l] = '\0';
                     fprintf(errrpt,"%s\n",&resultmessage[k]);
                     k = l + 1;
                     }
                  }
               }
            ++l2;
            E1 = E1->next;
            }
         fprintf(errrpt,"  TOTAL %11d\n",AcodeErr);
         }
      }

   fprintf(errrpt,"\n");

   fclose(errrpt);
   fclose(qacr);

   E1 = Summary_AEroot;
   while(E1 != NULL)
      {
      E2 = E1;
      E1 = E1->next;
      if(E2->msgline != NULL)
         free(E2->msgline);
      if(E2->LindexList != NULL)
         free(E2->LindexList);
      free(E2);
      }
   Summary_AEroot = NULL;

   TTF_RBTreeDestroy(Summary_AE_Tree);


   E1 = GIFD_Eroot;
   while(E1 != NULL)
      {
      if(E1->msgline[0] == 'y')
         E1->msgline[0] = 'x';
      E1 = E1->next;
      }
   strcpy(geomkey,"Junk");
   errkey = '@';
   E1 = GIFD_Eroot;
   ErrorNoted = 0;
   for(i=0; i<15; i++)
      enoted[i] = 0;

   fidreport = fopen(fid_details,"wt");
   while(E1 != NULL)
      {
      if(E1->msgline[0] != 'q')

         {
         if(E1->msgline[0] != errkey)
            {
            if(errkey != '@')
               fclose(errrpt);
            switch(E1->msgline[0])
               {
               case '0':
                  errrpt = fopen(geomgigs,"wt");
                  fprintf(errrpt,"Unexpected FCODE - Geometry Pair\n");
                  fprintf(fidreport,"Unexpected FCODE - Geometry Pair\n");
                  enoted[0] = 1;
                  break; 
               case '1':
                  errrpt = fopen(TTFattrgigs,"wt");
                  fprintf(errrpt,"Unexpected Attributes\n");
                  fprintf(fidreport,"Unexpected Attributes\n");
                  enoted[1] = 1;
                  break; 
               case '2':
                  errrpt = fopen(dtgigs,"wt");
                  fprintf(errrpt,"MGCP Required Attribute NULL Value Violation\n");
                  fprintf(fidreport,"MGCP Required Attribute NULL Value Violation\n");
                  enoted[2] = 1;
                  break; 
               case '3':
                  errrpt = fopen(valuegigs,"wt");
                  fprintf(errrpt,"Attribute Value Out Of Range\n");
                  fprintf(fidreport,"Attribute Value Out Of Range\n");
                  enoted[3] = 1;
                  break; 
               case '4':
                  errrpt = fopen(pickgigs,"wt");
                  fprintf(errrpt,"Pick List Violation\n");
                  fprintf(fidreport,"Pick List Violation\n");
                  enoted[4] = 1;
                  break;
               case 'x':
               case 'p':
                  enoted[6] = 1;
                  errrpt = fopen(vvtgigs,"wt");
                  fprintf(errrpt,"Attribute Dependency Violation\n");
                  fprintf(fidreport,"Attribute Dependency Violation\n");
                  break;
               case 'z':
                  errrpt = fopen(missingattrgigs,"wt");
                  fprintf(errrpt,"Missing Attribute Field Or Value\n");
                  fprintf(errrpt,"(Cross-check with: 1) Unrecognized Column Names (listed as Input Data Anomalies);\n");
                  fprintf(errrpt,"2) Blank Attribute errors; and 3) Non Domain Specific Pick-list errors)\n");
                  fprintf(fidreport,"Missing Attribute Field Or Value\n");
                  fprintf(fidreport,"(Cross-check with: 1) Unrecognized Column Names (listed as Input Data Anomalies);\n");
                  fprintf(fidreport,"2) Blank Attribute errors; and 3) Non Domain Specific Pick-list errors)\n");
                  enoted[5] = 1;
                  break;
               }
            strcpy(geomkey,"Junk");
            ErrorNoted = 0;
            errkey = E1->msgline[0];
            i = 0;
            }
         if(E1->msgline[1] != geomkey[0])
            {
            if((ATTRTYPE_ANY_TDS() > 0) || /*** LTDS, UTDS , etc  geometries ***/
                (ATTRTYPE_ANY_GGDM() > 0)) /** GGDM ***/
               {
               if(E1->msgline[1] == 'S')
                  {
                  strcpy(geomkey,"Surface");
                  fprintf(errrpt,"\n-----------\n  The following pertain to Surface feature data:\n\n");
                  k = 9;
                  }
               else if(E1->msgline[1] == 'P')
                  {
                  strcpy(geomkey,"Point");
                  fprintf(errrpt,"\n-----------\n  The following pertain to Point feature data:\n\n");
                  k = 7;
                  }
               else if(E1->msgline[1] == 'C')
                  {
                  strcpy(geomkey,"Curve");
                  fprintf(errrpt,"\n-----------\n  The following pertain to Curve feature data:\n\n");
                  k = 6;
                  }
               else if(E1->msgline[1] == 'G')
                  {
                  strcpy(geomkey,"Grid");
                  fprintf(errrpt,"\n-----------\n  The following pertain to Grid feature data:\n\n");
                  k = 6;
                  }
   
               }
            else
               {
               if(E1->msgline[1] == 'A')
                  {
                  strcpy(geomkey,"Areal");
                  fprintf(errrpt,"\n-----------\n  The following pertain to Area feature data:\n\n");
                  k = 6;
                  }
               else if(E1->msgline[1] == 'P')
                  {
                  strcpy(geomkey,"Point");
                  fprintf(errrpt,"\n-----------\n  The following pertain to Point feature data:\n\n");
                  k = 7;
                  }
               else if(E1->msgline[1] == 'L')
                  {
                  strcpy(geomkey,"Linear");
                  fprintf(errrpt,"\n-----------\n  The following pertain to Line feature data:\n\n");
                  k = 6;
                  }
               else if(E1->msgline[1] == 'G')
                  {
                  strcpy(geomkey,"Grid");
                  fprintf(errrpt,"\n-----------\n  The following pertain to Grid feature data:\n\n");
                  k = 6;
                  }
               }
            }
         if(E1->count == 1)
            {
            ++ErrorNoted;
            fprintf(errrpt,"(1 occurrence) %s",&E1->msgline[k]);
            fprintf(fidreport,"(1 occurrence) %s",&E1->msgline[k]);
            if(E1->long_attr_fid != -999)
               {
               nel = E1->LindexList;
               if(nel != NULL)
                  {
fprintf(errrpt,"\n");
fprintf(fidreport,"\n");


                  free(E1->LindexList);
                  E1->LindexList = NULL;
                  }
               }
            else
               {
               nel = E1->LindexList;
               if(nel != NULL)
                  {
                  cel = LLtoFeatureID[nel->val].fidlist;
                  if(cel == NULL)
                     {
                     fprintf(errrpt,"\n\n");
                     fprintf(fidreport,"\n\n");
                     }
                  else
                     {
                     fprintf(errrpt,"Feature identifier: %d\n\n",cel->val);
                     fprintf(fidreport,"Feature identifier: %d\n\n",cel->val);
                     }
                  free(E1->LindexList);
                  E1->LindexList = NULL;
                  }
               }
            }
         else if(E1->count >= 2)
            {
            fid_written = 0;
            l3 = 0;
            ++ErrorNoted;
            fprintf(errrpt,"(%d occurrences) %s",E1->count,&E1->msgline[k]);
            if(E1->long_attr_fid == -999)
               {
            if(E1->LindexList != NULL)
               fprintf(errrpt,"Feature identifiers:  ");
            else
               fprintf(errrpt,"\n");
            fprintf(fidreport,"(%d occurrences) %s",E1->count,&E1->msgline[k]);
            if(E1->LindexList != NULL)
               fprintf(fidreport,"Feature identifiers:  ");
            else
               fprintf(fidreport,"\n");
               }
            nel = E1->LindexList;
            if(E1->long_attr_fid == -999)
               {
               while(nel != NULL)
                  {
                  pel = nel;
                  cel = LLtoFeatureID[nel->val].fidlist;
                  while(cel != NULL)
                     {
                     if(fid_written < 50)
                        fprintf(errrpt,"%d",cel->val); 
                     else if(fid_written == 50)
                        fprintf(errrpt,"\n(See report in file %s for more feature identifiers)\n\n",fid_details);
                     fprintf(fidreport,"%d",cel->val);
                     ++fid_written;
                     ++l3;
                     if(l3 >= 10)
                        {
                        if((fid_written >= E1->count) || ((cel->next == NULL) && (nel->next == NULL)))
                           {
                           if(fid_written < 50)
                              fprintf(errrpt,"\n");
                           fprintf(fidreport,"\n");
                           }
                        else
                           {
                           if(fid_written < 50)
                              fprintf(errrpt,",\n");
                           fprintf(fidreport,"\n");
                           }
                        l3 = 0;
                        }
                     else
                        {
                        if((fid_written >= E1->count) || ((cel->next == NULL) && (nel->next == NULL)))
                           {
                           if(fid_written < 50)
                              fprintf(errrpt,"\n");
                           fprintf(fidreport,"\n");
                           }
                        else
                           {
                           if(fid_written < 50)
                              fprintf(errrpt,", ");
                           fprintf(fidreport,", ");
                           }
                        }
                     cel = cel->next;
                     }
                  nel = nel->next;
                  free(pel);
                  }
               }
            else
               {
               while(nel != NULL)
                  {
                  pel = nel;
if(nel == E1->LindexList)
{
fprintf(errrpt,"\n");
fprintf(fidreport,"\n");
}

                  nel = nel->next;
                  free(pel);
                  }
               }
            if(fid_written < 50)
               fprintf(errrpt,"\n");
            fprintf(fidreport,"\n");
            E1->LindexList = NULL;
            }
         }

      E2 = E1;
      nel = E1->LindexList;
      while(nel != NULL)
         {
         pel = nel;
         nel = nel->next;
         free(pel);
         }
      E1 = E1->next;
      if(E2->msgline != NULL)
         free(E2->msgline);
      if(E2->LindexList != NULL)
         free(E2->LindexList);
      if(E2 != NULL)
         free(E2);
      }

   TTF_RBTreeDestroy(GIFD_AE_Tree);


   if(errkey != '@')
      fclose(errrpt);
   if(enoted[0] < 1)
      {
      errrpt = fopen(geomgigs,"wt");
      fprintf(errrpt,"Unexpected FCODE - Geometry Pair\n");
      fprintf(errrpt,"  No violations noted\n");
      fclose(errrpt);
      }
   if(enoted[1] < 1)
      {
      errrpt = fopen(TTFattrgigs,"wt");
      fprintf(errrpt,"Unexpected Attributes\n");
      fprintf(errrpt,"  No violations noted\n");
      fclose(errrpt);
      }
   if(enoted[2] < 1)
      {
      errrpt = fopen(dtgigs,"wt");
      fprintf(errrpt,"MGCP Required Attribute Null Value Violation\n");
      fprintf(errrpt,"  No violations noted\n");
      fclose(errrpt);
      }
   if(enoted[3] < 1)
      {
      errrpt = fopen(valuegigs,"wt");
      fprintf(errrpt,"Attribute Value Out Of Range\n");
      fprintf(errrpt,"  No violations noted\n");
      fclose(errrpt);
      }
   if(enoted[4] < 1)
      {
      errrpt = fopen(pickgigs,"wt");
      fprintf(errrpt,"Pick List Violation\n");
      fprintf(errrpt,"  No violations noted\n");
      fclose(errrpt);
      }
   if(enoted[5] < 1)
      {
      errrpt = fopen(missingattrgigs,"wt");
      fprintf(errrpt,"Missing Attribute Field Or Value\n");
      fprintf(errrpt,"  No violations noted\n");
      fclose(errrpt);
      }
   if(enoted[6] < 1)
      {
      if((ATTRTYPE_MGCP3() > 0) || /*** MGCP **/
          (ATTRTYPE_UFD1() > 0)) /*** UFD1  **/
         {
         errrpt = fopen(vvtgigs,"wt");
         fprintf(errrpt,"Attribute Dependency Violation\n");
         fprintf(errrpt,"  No violations noted\n");
         fclose(errrpt);
         }
      else if(ATTRTYPE_MGCP4() > 0)
         {
         errrpt = fopen(vvtgigs,"wt");
         fprintf(errrpt,"Attribute Dependency Violation\n");
         fprintf(errrpt,"  These types of errors are reported as conditions\n");
         fclose(errrpt);
         }
      else if((ATTRTYPE_ANY_TDS() > 0) || /*** ?TDS schema ***/
                (ATTRTYPE_ANY_GGDM() > 0)) /*** GGDM ***/
         {
         errrpt = fopen(vvtgigs,"wt");
         fprintf(errrpt,"Attribute Dependency Violation\n");
         fprintf(errrpt,"  No violations noted\n");
         fclose(errrpt);
         }
      else if((ATTRTYPE_NFDD() > 0) || (ATTRTYPE_DFDD() > 0))
         { /*** NFDD, DFDD ***/
         errrpt = fopen(vvtgigs,"wt");
         fprintf(errrpt,"Attribute Dependency Violation\n");
         if(ATTRINSTYPE == 4)
            {
            fprintf(errrpt,"  No violations noted\n");
            }
         else
            {
            fprintf(errrpt,"  The project was not inspected for this type of error\n");
            }
         fclose(errrpt);
         }
      else
         {
         errrpt = fopen(vvtgigs,"wt");
         fprintf(errrpt,"Attribute Dependency Violation\n");
         fprintf(errrpt,"  The project was not inspected for this type of error\n");
         fclose(errrpt);
         }
      }


   fclose(fidreport);
   errrpt = fopen(metadatagigs,"wt");
   strcpy(resultmessage,metadatagigs);
   i = strlen(resultmessage);
   while(resultmessage[i] != '.')
      --i;
   strcpy(&resultmessage[i],".csv");
   csv_errrpt = fopen(resultmessage,"wt");
   fprintf(csv_errrpt,"Error Count,Layer Name,Feature Code,Feature Name,Attribute Code,Attribute Name,Error Description\n");


   if(ATTRTYPE_ANY_MGCP() > 0) /*** MGCP **/
      {
      fprintf(errrpt,"Metadata not in accordance with the MGCP Metadata specification\n");
      }
   else if((ATTRTYPE_D4() > 0) || (ATTRTYPE_FACC() > 0) || (ATTRTYPE_VMAP() > 0)) /***GIFD, FACC, or VMAP ***/
      {
      fprintf(errrpt,"Metadata not in accordance with the GIFD D4 Metadata specification\n");
      }
   else if((ATTRTYPE_UFD1() > 0) || (ATTRTYPE_UFD2() > 0) || (ATTRTYPE_UFD3() > 0)) /**** UFD2, UFD1 or UFD3 ***/
      {
      fprintf(errrpt,"Metadata not in accordance with the GIFD D4 Metadata specification\n");
      }
   else if(TDSmeta > 0)
      {
      fprintf(errrpt,"Metadata not in accordance with the Topographic Data Store (TDS) Metadata specification\n");
      }
   E1 = GIFD_Mroot;
   if(E1 == NULL)
      {
      if(DoMetadataChecking == 0)
         fprintf(errrpt,"   No Metadata inspections were applied to this project\n");
      else
         fprintf(errrpt,"   No deficiencies noted\n");
      }
   else
      {
      fprintf(errrpt,"Totals by error type\n\n");

      E1 = GIFD_MTroot;
      while(E1 != NULL)
         {
         if(E1->count == 1)
            fprintf(errrpt,"    (%d occurrence) %s\n",E1->count,E1->msgline);
         else if(E1->count >= 2)
            fprintf(errrpt,"    (%d occurrences) %s\n",E1->count,E1->msgline);
         E2 = E1;
         E1 = E1->next;
         free(E2->msgline);
         if(E2->LindexList != NULL)
            free(E2->LindexList);
         free(E2);
         }

      fprintf(errrpt,"\n\n Detailed Recap - errors by FCODE and error type\n");
      E1 = GIFD_Mroot;
      ErrorNoted = 0;
      while(E1 != NULL)
         {
         WriteCSV_MD_Entry(csv_errrpt,E1->count,E1->msgline);
         if(E1->count == 1)
            fprintf(errrpt,"    (%d occurrence) %s\n",E1->count,E1->msgline);
         else if(E1->count >= 2)
            fprintf(errrpt,"    (%d occurrences) %s\n",E1->count,E1->msgline);
         E2 = E1;
         E1 = E1->next;
         free(E2->msgline);
         if(E2->LindexList != NULL)
            free(E2->LindexList);
         free(E2);
         }
      }

   fclose(errrpt);
   fclose(csv_errrpt);
   if(Indices != NULL)
      free(Indices);
   return;

}



#if(NGA_TYPE==0)

void CheckAssignedSAC(char * SpecFile, int LLnumber)
{
FILE *errrpt;
FILE *fileptr;
int ECC, seeitgeom,NumAttr,EAC,uom, uomscale,SEDRIStype,datatype,Idtvalue;
int IdtVal2;
int enumcode, MDcode;
double Fdtvalue;
double FdtVal2;
int IntervalType;
int numchar;
char titlechar;
int AllUsedNumber;
char resultmessage[1000];
int i,j,k;
int useid, entryindex;
RedBlackTree *featureList;
Feature *feature;
FeatureKey key;
RB_status status;
Attribute *A;
Enumeration *E;
struct indexlist *I1, *I2;
extern void freeFeatureList( void *fin);
extern char * SeeitCodeToNameString(int Scode);
extern RedBlackTree *readFeatureAttributionFile(char *filename);
#include "parse_files.h"

struct UseEmAll
{
   char check;
   Attribute *Aaddress;
} *AllUsed;
int SzUEA = sizeof(struct UseEmAll);
#define MAKE_KEY(key, ecc, geo, var) \
        key.ECC = ecc; key.geoCode = geo; key.variant = var


   Iroot = (struct indexlist *) (malloc(sizeof(struct indexlist) * (LLnumber + 2)));
   if(Iroot == NULL)
      {
      printf("available memory has been exhausted in preparations for attribute analysis\n");
      printf("failed in attempt to allocate %d bytes\n",(int) sizeof(struct indexlist) * (LLnumber + 2));
      exit(-1);
      }
   for(i=0; i<=LLnumber; i++)
      {
      Iroot[i].next = NULL;
      Iroot[i].msgid = -1;
      }

   Eroot = NULL;

   fileptr = fopen(SpecFile,"rt");
   if(fileptr == NULL)
      {
      printf("could not find attribution analysis file %s\n",SpecFile);
      printf("no attribution analysis can be completed without the information provided in the file\n");
      return;
      }
   else
      fclose(fileptr);

   AttrErrMsgID = 0;

   featureList = readFeatureAttributionFile(SpecFile);  /** read the feature specification file into a RB tree structure ***/

   if(featureList == NULL)
      return;

   fileptr = fopen(SACvaluesfile,"rb");
   

   SEEIT_fread_int(&ECC,fileptr);
   entryindex = -1;
   
   while(feof(fileptr) == 0)
      {
      ++entryindex;  /** a new ECC record ***/
      SEEIT_fread_int(&seeitgeom,fileptr);
      SEEIT_fread_int(&NumAttr,fileptr);

      key.ECC = ECC;
      key.geoCode = seeitgeom;
      key.variant = -1;

      status = rbGetData(featureList, &key,  (void **) &feature);

      if(status != rbOkay) /** could not find an entry in the spec file for this ECC, geom, & variant triple ***/
         {
         if(key.variant >= 0)
            sprintf(resultmessage,"ECL %s, geometry %s, variant %d - not prescribed in specification file %s\n",
                   GetECCLabel(ECC), ParseGAITgeometry((unsigned char) seeitgeom, 2),key.variant,SpecFile);
         else
            sprintf(resultmessage,"ECL %s, geometry %s  - not prescribed in specification file %s\n",
                   GetECCLabel(ECC), ParseGAITgeometry((unsigned char) seeitgeom, 2),SpecFile);
         useid = InsertIntoAttrErrorList(resultmessage,entryindex);
         InsertIntoAttrIndexList(entryindex,useid);
         }
  
      if(status == rbOkay)
         {
         i = 0;
         A = feature->attr;
         while(A != NULL)
            {
            ++i;
            A = A->next;
            }
         AllUsed = (struct UseEmAll *) (malloc(SzUEA * i));
         if(AllUsed == NULL)
            {
            printf("available memory has been exhausted during attribute analysis - \n  HALTING EXECUTION\n");
            exit(-1);
            }
         AllUsedNumber = i;
         A = feature->attr;
         for(j = 0; j< i; j++)
            {
            AllUsed[j].Aaddress = A;
            AllUsed[j].check = 0;
            A = A->next;
            }
         }
      else
         {
         AllUsedNumber = 0;
         AllUsed = NULL;
         }

      for(k=1; k<=NumAttr; k++)
         {
         SEEIT_fread_int(&EAC,fileptr);
         if((status == rbOkay) && (EAC >= 0))
            {
            A = feature->attr;
            i = 0;
            while(A != NULL)
               {
               if(A->EAC == EAC)
                  break;
               ++i;
               A = A->next;
               }
            if(A == NULL)
               {
               if(key.variant >= 0)
                  sprintf(resultmessage,"ECL %s, geometry %s, variant %d: assigned EAL: %s not in allowed specification\n",
                         GetECCLabel(feature->key.ECC), ParseGAITgeometry((unsigned char) seeitgeom, 2),key.variant,GetEACLabel(EAC));
               else
                  sprintf(resultmessage,"ECL %s, geometry %s: assigned EAL: %s not in allowed specification\n",
                         GetECCLabel(feature->key.ECC), ParseGAITgeometry((unsigned char) seeitgeom, 2),GetEACLabel(EAC));
               useid = InsertIntoAttrErrorList(resultmessage,entryindex);
               InsertIntoAttrIndexList(entryindex,useid);
               }
            else
               {
               AllUsed[i].check = 1;
               }
            }
         if(EAC >= 0)
            {
            SEEIT_fread_int(&uom,fileptr);
            SEEIT_fread_int(&uomscale,fileptr);
            SEEIT_fread_int(&SEDRIStype,fileptr);
            SEEIT_fread_int(&datatype,fileptr);

            if((status == rbOkay) && (A != NULL))
               {
               if((datatype != 4) && (uom != A->unitCode)) /** datatype 4 is metadata so is unitless, uni **/
                  {
                  if(key.variant >= 0)
                     sprintf(resultmessage,"ECL %s, geometry %s, variant %d, EAL %s - UOM mismatch: %s specified, %s found\n",
                      GetECCLabel(feature->key.ECC), ParseGAITgeometry((unsigned char) seeitgeom, 2),key.variant,GetEACLabel(A->EAC),
                      GetUnitsLabel(A->unitCode), GetUnitsLabel(uom));
                  else
                     sprintf(resultmessage,"ECL %s, geometry %s, EAL %s - UOM mismatch: %s specified, %s found\n",
                      GetECCLabel(feature->key.ECC), ParseGAITgeometry((unsigned char) seeitgeom, 2),GetEACLabel(A->EAC),
                      GetUnitsLabel(A->unitCode), GetUnitsLabel(uom));
                  useid = InsertIntoAttrErrorList(resultmessage,entryindex);
                  InsertIntoAttrIndexList(entryindex,useid);
                  }

               if((datatype != 4) && (uomscale != A->scaleCode)) /** datatype 4 is metadata so is unitless, uni **/
                  {
                  if(key.variant >= 0)
                     sprintf(resultmessage,"ECL %s, geometry %s, variant %d, EAL %s  UOM %s - UOM scale mismatch: %s specified, %s found\n",
                      GetECCLabel(feature->key.ECC), ParseGAITgeometry((unsigned char) seeitgeom, 2),key.variant,GetEACLabel(A->EAC),
                      GetUnitsLabel(A->unitCode), GetScaleLabel(A->scaleCode), GetScaleLabel(uomscale));
                  else
                     sprintf(resultmessage,"ECL %s, geometry %s, EAL %s  UOM %s - UOM scale mismatch: %s specified, %s found\n",
                      GetECCLabel(feature->key.ECC), ParseGAITgeometry((unsigned char) seeitgeom, 2),GetEACLabel(A->EAC),
                      GetUnitsLabel(A->unitCode), GetScaleLabel(A->scaleCode), GetScaleLabel(uomscale));
                  useid = InsertIntoAttrErrorList(resultmessage,entryindex);
                  InsertIntoAttrIndexList(entryindex,useid);
                  }
               if((datatype != 4) && (datatype != A->typeCode)) /** code 4 is metadata **/
                  {
                  if(key.variant >= 0)
                     sprintf(resultmessage,"ECL %s, geometry %s, variant %d, EAL %s - data type mismatch: %s specified, %s found\n",
                      GetECCLabel(feature->key.ECC), ParseGAITgeometry((unsigned char) seeitgeom, 2),key.variant,GetEACLabel(A->EAC),
                      SeeitCodeToNameString(A->typeCode), SeeitCodeToNameString(datatype));
                  else
                     sprintf(resultmessage,"ECL %s, geometry %s, EAL %s - data type mismatch: %s specified (%d), %s found (%d)\n",
                      GetECCLabel(feature->key.ECC), ParseGAITgeometry((unsigned char) seeitgeom, 2),GetEACLabel(A->EAC),
                      SeeitCodeToNameString(A->typeCode), A->typeCode, SeeitCodeToNameString(datatype), datatype);
                  useid = InsertIntoAttrErrorList(resultmessage,entryindex);
                  InsertIntoAttrIndexList(entryindex,useid);
                  }
               }
               
            switch(datatype)
               {
               case 0: /** regular integer **/
                  SEEIT_fread_int(&Idtvalue,fileptr);

                  if((status == rbOkay) && (A != NULL) && (datatype == A->typeCode))
                     {
                     if(A->range == NULL)
                        {
                        if(key.variant >= 0)
                           sprintf(resultmessage,"ECL %s, geometry %s, variant %d, EAL %s - expected a range of allowed values, none specified\n",
                            GetECCLabel(feature->key.ECC), ParseGAITgeometry((unsigned char) seeitgeom, 2),key.variant,GetEACLabel(A->EAC));
                        else
                           sprintf(resultmessage,"ECL %s, geometry %s, EAL %s - expected a range of allowed values, none specified\n",
                            GetECCLabel(feature->key.ECC), ParseGAITgeometry((unsigned char) seeitgeom, 2),GetEACLabel(A->EAC));
                        useid = InsertIntoAttrErrorList(resultmessage,entryindex);
                        InsertIntoAttrIndexList(entryindex,useid);
                        }
                     else if((Idtvalue < A->range->minimum) || (Idtvalue > A->range->maximum))
                        {
                        if(key.variant >= 0)
                           sprintf(resultmessage,"ECL %s, geometry %s, variant %d, EAL %s - assigned value %d outside specified range (%d to %d)\n",
                            GetECCLabel(feature->key.ECC), ParseGAITgeometry((unsigned char) seeitgeom, 2),key.variant,GetEACLabel(A->EAC),
                            Idtvalue, (int) A->range->minimum, (int) A->range->maximum);
                        else
                           sprintf(resultmessage,"ECL %s, geometry %s, EAL %s - assigned value %d outside specified range (%d to %d)\n",
                            GetECCLabel(feature->key.ECC), ParseGAITgeometry((unsigned char) seeitgeom, 2),GetEACLabel(A->EAC),
                            Idtvalue, (int) A->range->minimum, (int) A->range->maximum);
                        useid = InsertIntoAttrErrorList(resultmessage,entryindex);
                        InsertIntoAttrIndexList(entryindex,useid);
                        }
                     }
                  break;
               case 1: /** a double **/
                  SEEIT_fread_double(&Fdtvalue,fileptr);
                  if((status == rbOkay) && (A != NULL) && (datatype == A->typeCode))
                     {
                     if(A->range == NULL)
                        {
                        if(key.variant >= 0)
                           sprintf(resultmessage,"ECL %s, geometry %s, variant %d, EAL %s - expected a range of allowed values, none specified\n",
                            GetECCLabel(feature->key.ECC), ParseGAITgeometry((unsigned char) seeitgeom, 2),key.variant,GetEACLabel(A->EAC));
                        else
                           sprintf(resultmessage,"ECL %s, geometry %s, EAL %s - expected a range of allowed values, none specified\n",
                            GetECCLabel(feature->key.ECC), ParseGAITgeometry((unsigned char) seeitgeom, 2),GetEACLabel(A->EAC));
                        useid = InsertIntoAttrErrorList(resultmessage,entryindex);
                        InsertIntoAttrIndexList(entryindex,useid);
                        }
                     else if((Fdtvalue < A->range->minimum) || (Fdtvalue > A->range->maximum))
                        {
                        if(key.variant >= 0)
                           sprintf(resultmessage,"ECL %s, geometry %s, variant %d, EAL %s - assigned value %lf outside specified range (%lf to %lf)\n",
                            GetECCLabel(feature->key.ECC), ParseGAITgeometry((unsigned char) seeitgeom, 2),key.variant,GetEACLabel(A->EAC),
                            Fdtvalue, A->range->minimum, A->range->maximum);
                        else
                           sprintf(resultmessage,"ECL %s, geometry %s, EAL %s - assigned value %lf outside specified range (%lf to %lf)\n",
                            GetECCLabel(feature->key.ECC), ParseGAITgeometry((unsigned char) seeitgeom, 2),GetEACLabel(A->EAC),
                            Fdtvalue, A->range->minimum, A->range->maximum);
                        useid = InsertIntoAttrErrorList(resultmessage,entryindex);
                        InsertIntoAttrIndexList(entryindex,useid);
                        }
                     }
                  break;
               case 2: /** a string **/
                  SEEIT_fread_int(&numchar,fileptr);
                  for(i=0; i<numchar; i++)
                     {
                     fread(&titlechar,1,1,fileptr);
                     }
                  break;
               case 3: /** enum as int **/
                  SEEIT_fread_int(&enumcode,fileptr);
                  if((status == rbOkay) && (A != NULL) && (datatype == A->typeCode))
                     {
                     if(A->enumeration == NULL)
                        {
                        if(key.variant >= 0)
                           sprintf(resultmessage,"ECL %s, geometry %s, variant %d, EAL %s - expected a list of allowed enumerants, none specified\n",
                            GetECCLabel(feature->key.ECC), ParseGAITgeometry((unsigned char) seeitgeom, 2),key.variant,GetEACLabel(A->EAC));
                        else
                           sprintf(resultmessage,"ECL %s, geometry %s, EAL %s - expected a list of allowed enumerants, none specified\n",
                            GetECCLabel(feature->key.ECC), ParseGAITgeometry((unsigned char) seeitgeom, 2),GetEACLabel(A->EAC));
                        useid = InsertIntoAttrErrorList(resultmessage,entryindex);
                        InsertIntoAttrIndexList(entryindex,useid);
                        }
                     else 
                        {
                        E = A->enumeration;
                        while(E != NULL)
                           {
                           if(E->EEC == enumcode)
                              break;
                           E = E->next;
                           }
                        if(E == NULL)
                           {
                        if(key.variant >= 0)
                           sprintf(resultmessage,"ECL %s, geometry %s, variant %d, EAL %s - assigned enumerant %s not allowed\n",
                            GetECCLabel(feature->key.ECC), ParseGAITgeometry((unsigned char) seeitgeom, 2),key.variant,GetEACLabel(A->EAC),
                            GetEELabel(A->EAC,enumcode));
                        else
                           sprintf(resultmessage,"ECL %s, geometry %s, EAL %s - assigned enumerant %s not allowed\n",
                            GetECCLabel(feature->key.ECC), ParseGAITgeometry((unsigned char) seeitgeom, 2),GetEACLabel(A->EAC),
                            GetEELabel(A->EAC,enumcode));
                        useid = InsertIntoAttrErrorList(resultmessage,entryindex);
                        InsertIntoAttrIndexList(entryindex,useid);
                           }
                        }
                     }

                  break;
               case 4: /** metadata as int - stored & treated as an enum in spec file**/
                  SEEIT_fread_int(&MDcode,fileptr);
                  MDcode = 0 - MDcode; 
                  if((status == rbOkay) && (A != NULL))
                     {
                     if(A->enumeration == NULL)
                        {
                        if(key.variant >= 0)
                           sprintf(resultmessage,"ECL %s, geometry %s, variant %d, EAL %s - expected a list of allowed enumerants, none specified\n",
                            GetECCLabel(feature->key.ECC), ParseGAITgeometry((unsigned char) seeitgeom, 2),key.variant,GetEACLabel(A->EAC));
                        else
                           sprintf(resultmessage,"ECL %s, geometry %s, EAL %s - expected a list of allowed enumerants, none specified\n",
                            GetECCLabel(feature->key.ECC), ParseGAITgeometry((unsigned char) seeitgeom, 2),GetEACLabel(A->EAC));
                        useid = InsertIntoAttrErrorList(resultmessage,entryindex);
                        InsertIntoAttrIndexList(entryindex,useid);
                        }
                     else
                        {
                        E = A->enumeration;
                        while(E != NULL)
                           {
                           if(E->EEC == MDcode)
                              break;
                           E = E->next;
                           }
                        if(E == NULL)
                           {
                        if(key.variant >= 0)
                           sprintf(resultmessage,"ECL %s, geometry %s, variant %d, EAL %s - assigned enumerant %s not allowed\n",
                            GetECCLabel(feature->key.ECC), ParseGAITgeometry((unsigned char) seeitgeom, 2),key.variant,GetEACLabel(A->EAC),
                            GetEMLabel(0 - MDcode));
                        else
                           sprintf(resultmessage,"ECL %s, geometry %s, EAL %s - assigned enumerant %s not allowed\n",
                            GetECCLabel(feature->key.ECC), ParseGAITgeometry((unsigned char) seeitgeom, 2),GetEACLabel(A->EAC),
                            GetEMLabel(0 - MDcode));
                        useid = InsertIntoAttrErrorList(resultmessage,entryindex);
                        InsertIntoAttrIndexList(entryindex,useid);
                           }
                        }
                     }

                  break;
               case 5: /** a float interval **/
                  SEEIT_fread_double(&Fdtvalue,fileptr);
                  SEEIT_fread_double(&FdtVal2,fileptr);
                  SEEIT_fread_int(&IntervalType,fileptr);
                  break;
               case 6: /** an integer interval **/
                  SEEIT_fread_int(&Idtvalue,fileptr);
                  SEEIT_fread_int(&IdtVal2,fileptr);
                  SEEIT_fread_int(&IntervalType,fileptr);
                  break;
               case 7: /** an unsigned integer interval **/
                  SEEIT_fread_int(&Idtvalue,fileptr);
                  SEEIT_fread_int(&IdtVal2,fileptr);
                  SEEIT_fread_int(&IntervalType,fileptr);
                  break;
               }
            }
         else /** EAC of -1, -2, -3 indicates LOD name, Assgd model name, or poly flag string, respectively **/
            {
            SEEIT_fread_int(&numchar,fileptr);
            for(j=0; j<numchar; j++)
               fread(&titlechar,1,1,fileptr);
            }
         } /** end for number of attributes **/

      SEEIT_fread_int(&ECC,fileptr);
      }


  freeFeatureList( (void *) featureList); /** free up RB tree of specifications ***/

   errrpt = fopen(binSACgigs,"wb");
   SEEIT_fwrite_int(&AttrErrMsgID,errrpt);
   for(i=1; i<=AttrErrMsgID; i++)
      {
      E1 = Eroot;
      while((E1 != NULL) && (E1->idnumber != i))
         E1 = E1->next;
      if(E1->idnumber == i)
         {
         j = strlen(E1->msgline);
         E1->msgline[j] = '\0';
         ++j;
         SEEIT_fwrite_int(&j,errrpt);
         fwrite(&E1->msgline[0],j,1,errrpt);
         }
      }

   for(i=0; i<=LLnumber; i++)
      {
      if(Iroot[i].msgid > -1)
         {
         k = Iroot[i].msgid - 1;
         SEEIT_fwrite_int(&i,errrpt);
         SEEIT_fwrite_int(&k,errrpt);
         I1 = Iroot[i].next;
         while(I1 != NULL)
            {
            SEEIT_fwrite_int(&I1->index,errrpt);
            I1->msgid -= 1;
            SEEIT_fwrite_int(&I1->msgid,errrpt);
            I2 = I1;
            I1 = I1->next;
            free(I2);
            }
         }
      }
   fclose(errrpt);
   free(Iroot);

   errrpt = fopen(SACgigs,"at");
   E1 = Eroot;
   while(E1 != NULL)
      {
      j = 0;
      if(E1->count == 1)
         fprintf(errrpt,"(1 occurrence) %s\n",&E1->msgline[j]);
      else
         fprintf(errrpt,"(%d occurrences) %s\n",E1->count,&E1->msgline[j]);
      E2 = E1;
      E1 = E1->next;
      free(E2->msgline);
      if(E2->LindexList != NULL)
         free(E2->LindexList);
      free(E2);
      }

   fclose(errrpt);


   return;
}

#endif





void AddToLODlist(char *LODspec, int Sz, int SzENL, int index)
{
int s;
struct LODranges *r1, *r2, *rc;
struct EnumList *cel;

   s = strlen(LODspec);
   if(LODroot == NULL)
      {
      LODroot = (struct LODranges *) (malloc(Sz));
      LODroot->length = s;
      LODroot->range = (char *) (malloc(s + 1));
      strcpy(LODroot->range,LODspec);
      LODroot->range[s] = '\0';
      cel = (struct EnumList *) (malloc(SzENL));
      if(cel == NULL)
        {
        printf("allocation memory exhausted during Layer name processing\n");
        exit(-1);
        }
      LODroot->numindices = 1;
      LODroot->indices = cel;
      cel->val = index;
      cel->next = NULL;
      LODroot->next = NULL;
      }
   else
      {
      r2 = r1 = LODroot;
      while(r1 != NULL)
         {
         if(strncmp(r1->range,LODspec,s) >= 0)
            break;
         r2 = r1;
         r1 = r1->next;
         }
      if((r1 == NULL) || (strncmp(r1->range,LODspec,s) > 0))
         {
         rc = (struct LODranges *) (malloc(Sz));
         if(rc == NULL)
           {
           printf("allocation memory exhausted during Layer name processing (2)\n");
           exit(-1);
           }
         rc->length = s;
         rc->numindices = 1;
         rc->range = (char *) (malloc(s + 1));
         cel = (struct EnumList *) (malloc(SzENL));
         if(cel == NULL)
           {
           printf("allocation memory exhausted during Layer name processing (3)\n");
           exit(-1);
           }
         rc->indices = cel;
         cel->val = index;
         cel->next = NULL;
         strcpy(rc->range,LODspec);
         rc->range[s] = '\0';
         rc->next = r1;
         if(r1 == LODroot)
            LODroot = rc;
         else
            r2->next = rc;
         }
      else if(strncmp(r1->range,LODspec,s) == 0)
         {
         cel = (struct EnumList *) (malloc(SzENL));
         if(cel == NULL)
           {
           printf("allocation memory exhausted during Layer name processing(4)\n");
           exit(-1);
           }
         cel->val = index;
         cel->next = r1->indices;
         r1->numindices += 1;
         r1->indices = cel;
         }
      }
}




void RetrieveNGA_LAL_TreeInorder( rb_red_blk_tree* tree, rb_red_blk_node* x)
{
   if (x != tree->nil)
      {
      RetrieveNGA_LAL_TreeInorder(tree,x->left);

      if(VListRoot == NULL)
         {
         VListRoot = (struct  LocalAttrValList *) (x->info);
         VListRoot->next = NULL;
         VListLast = VListRoot;
         }
      else
         {
         VListLast->next = (struct  LocalAttrValList *) (x->info);
         VListLast = VListLast->next;
         VListLast->next = NULL;
         }

      RetrieveNGA_LAL_TreeInorder(tree,x->right);
      }
}




int AssembleNames(int indexlimit)
{
struct LocalAttrList *nal, *pal, *cal;
struct reflist *cref, *nref;
struct LocalAttrValList *cvl, *nvl, *nvl2, *pvl, *newroot;
FILE *realdata;
extern char * GetECCLabel(int code);
char title[500];
char longtitle[500];
char valuestring[500];
int ECC, SEEITgeom,NumAttr,EAC,uom, uomscale,SEDRIStype,datatype,Idtvalue;
int IdtV2, IntervalType;
double Fdtvalue,FdtV2;
int numchar;
char tc;
int i,j,k,ii,index,announce;
int AListCount = 0;
int *LLIcheck;
int SzLOD = sizeof(struct LODranges);
int SzENL = sizeof(struct EnumList);
int SzAL = sizeof(struct LocalAttrList);
int AdviseLimit;
int fileentries;


   AdviseLimit = indexlimit * 2;
   realdata = fopen(SACvaluesfile,"rb");
   if(realdata == NULL)
      {
      printf("could not open attribute specification file %s\n",SACvaluesfile);
      return(0);
      }

   ECC = EAC = uom = uomscale = datatype = Idtvalue = IdtV2 = IntervalType = index = -1;
   valuestring[0] = '\0';
   Fdtvalue = FdtV2 = -1.0;

   fileentries = 0;


   if(NGA_TYPE == SortAttrByNGA)
      {
      LALentries = NULL;

      NGA_LALentries = (struct  NGA_AListEntryPoints *) (malloc(sizeof(struct NGA_AListEntryPoints) * (TTF_MaximumEACcount + 5)));
      if(NGA_LALentries == NULL)
         {
         printf("insufficient remaining memory for attribution catalog creation\n");
         exit(-1);
         }
      
      j = TTF_MaximumEACcount + 3;
      for(i=0; i<j; i++)
         {
         for(k=0; k<5; k++)
            NGA_LALentries[i].SortTree[k] = NULL;
         }
      }
   else
      {
      NGA_LALentries = NULL;

      LALentries = (struct AListEntryPoints *) (malloc(sizeof(struct AListEntryPoints) * (TTF_MaximumEACcount + 5)));
      if(LALentries == NULL)
         {
         printf("insufficient remaining memory for attribution catalog creation\n");
         exit(-1);
         }
      j = TTF_MaximumEACcount + 5;
      for(i=0; i<j; i++)
         {
         for(k=0; k<8; k++)
            LALentries[i].Entry[k] = NULL;
         }
      }

   index = -1;
   if(indexlimit > 200)
     announce = 50;
   else if(indexlimit > 10)
   announce = indexlimit / 10;
   else
      announce = 1;
   SEEIT_fread_int(&ECC,realdata);
   while(feof(realdata) == 0)
      {
      ++fileentries;

      IdtV2 = IntervalType = -1;
      FdtV2 = -1;
      for(i=0; i<499; i++)
         {
         longtitle[i] = '\0';
         title[i] = '\0';
         }

      ++index;
      if(index > indexlimit)
         {
         printf("array size violation during object name construction\n");
         printf("processing cannot continue\n");
         exit(-1);
         }
      if((index  % announce) == 0)
         {
         BuildOpenMenu(0.0,index,AdviseLimit,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0);
         }
      NArray[index].occurrences = 0;
      NArray[index].areaholes = 0;
      for(i=0; i<NUM_C; i++)
         NArray[index].configcount[i] = 0;

      SEEIT_fread_int(&SEEITgeom,realdata);
      SEEIT_fread_int(&NumAttr,realdata);

      for(k=1; k<=NumAttr; k++)
         {
         SEEIT_fread_int(&EAC,realdata);

         if((EAC >= 0) || (EAC < -3))
            {
            SEEIT_fread_int(&uom,realdata);
            SEEIT_fread_int(&uomscale,realdata);
            SEEIT_fread_int(&SEDRIStype,realdata);
            SEEIT_fread_int(&datatype,realdata);
            switch(datatype)
               {
               case 0: /** regular integer **/
                  SEEIT_fread_int(&Idtvalue,realdata);
                  break;
               case 1: /** a double **/
                  SEEIT_fread_double(&Fdtvalue,realdata);

                  break;
               case 2: /** a string **/
                  SEEIT_fread_int(&numchar,realdata);
                  if(numchar < 499)
                     {
                     for(i=0; i<=numchar; i++)
                        valuestring[i] = '\0';
                     fread(&valuestring[0],numchar,1,realdata);
                     valuestring[numchar] = '\0';
                     Idtvalue = numchar;
                     Fdtvalue = (double) numchar;
                     }
                  else 
                     {
                     fread(&valuestring[0],499,1,realdata);
                     valuestring[499] = '\0';
                     Idtvalue = 499;
                     Fdtvalue = (double) Idtvalue;
                     for(i=499; i<numchar; i++)
                        fread(&tc,1,1,realdata);
                     }
                  break;
               case 3: /** enum as int **/
                  SEEIT_fread_int(&Idtvalue,realdata);
                  break;
               case 4: /** attribute metadata as int **/
                  SEEIT_fread_int(&Idtvalue,realdata);
                  break;
               case 5: /** double interval specification **/
                  SEEIT_fread_double(&Fdtvalue,realdata);
                  SEEIT_fread_double(&FdtV2,realdata);
                  SEEIT_fread_int(&IntervalType,realdata);
                  break;
               case 6:
               case 7: /** integer intervals **/
                  SEEIT_fread_int(&Idtvalue,realdata);
                  SEEIT_fread_int(&IdtV2,realdata);
                  SEEIT_fread_int(&IntervalType,realdata);
                  break;
               }
            if(NGA_TYPE == SortAttrByNGA)
               {
               NGA_InsertIntoAttributeList(ECC,EAC,uom,uomscale,datatype,Idtvalue,Fdtvalue,IdtV2,FdtV2,IntervalType,valuestring,index);
               }
            else
               {
               InsertIntoAttributeList(ECC,EAC,uom,uomscale,datatype,Idtvalue,Fdtvalue,IdtV2,FdtV2,IntervalType,valuestring,index);
               }
            }
         else
            {
            SEEIT_fread_int(&numchar,realdata);
            if(numchar < 499)
               {
               fread(&longtitle[0],1,numchar,realdata);
               longtitle[numchar] = '\0';
               }
            else
               {
               for(j=0; j<numchar; j++)
                  {
                  if(j < 490)
                     fread(&longtitle[j],1,1,realdata);
                  else
                     fread(&longtitle[490],1,1,realdata);
                  }
               numchar = 490;
               longtitle[numchar] = '\0';
               }
            if(EAC == -1)
               {
               AddToLODlist(longtitle, SzLOD, SzENL, index);
               }
            else if(EAC == -2)
               {
               strcpy(title,longtitle);
               }
            }
         } /** end for number of attributes **/
      title[ModelNameMaxLength - 1] = '\0';
      if(NGA_TYPE == 1)
         {
         switch(SEEITgeom)
            {
            case C_AREA: title[ModelNameMaxLength - 7]='\0'; strcat(title,"(AREA)"); break;
            case C_LINE: title[ModelNameMaxLength - 7]='\0'; strcat(title,"(LINE)"); break;
            case C_POFE: title[ModelNameMaxLength - 8]='\0'; strcat(title,"(POINT)"); break;
            case C_GRID: title[ModelNameMaxLength - 7]='\0'; strcat(title, "(GRID)"); break;
            default: title[ModelNameMaxLength - 11]='\0'; strcat(title,"(Unknown)"); break;
            }
         }

      strcpy(&NArray[index].name[0],title);
      NArray[index].name[ModelNameMaxLength - 1] = '\0';
      NArray[index].crossindex = -1;
      NArray[index].code = ECC;
      SEEIT_fread_int(&ECC,realdata);
      }

   if(fileentries != indexlimit)
      {
      printf("expected %s to contain %d entries\n",SACvaluesfile,indexlimit);
      printf("only encountered %d\n",fileentries);
      }


   fclose(realdata);

   j = TTF_MaximumEACcount + 2;

   if(NGA_TYPE == SortAttrByNGA)
      {
      for(i=0; i<j; i++)
         {
         cal = NULL;
         for(ii=0; ii<5; ii++)
            {
            if(NGA_LALentries[i].SortTree[ii] != NULL)
               {
               if(cal == NULL)
                  {
                  cal = (struct LocalAttrList *) (malloc(SzAL));
                  if(cal == NULL)
                     {
                     printf("available memory has been exhausted during attribute catalog processing\n");
                     exit(-1);
                     }
         
                  cal->thisindex = NGA_LALentries[i].SortTree[ii]->thisindex;
                  cal->values = NULL;
                  cal->occurrences = 0;
                  cal->code = NGA_LALentries[i].SortTree[ii]->code;
                  cal->stringdigits = NGA_LALentries[i].SortTree[ii]->stringdigits;
                  cal->count = 0;
                  cal->refcount = 0;
                  cal->references = NULL;
                  }

               if(NGA_LALentries[i].SortTree[ii]->RB_Entry != NULL)
                  {
                  VListRoot = NULL;
                  VListLast = NULL;
                  RetrieveNGA_LAL_TreeInorder(NGA_LALentries[i].SortTree[ii]->RB_Entry,NGA_LALentries[i].SortTree[ii]->RB_Entry->root->left);
                  if(cal->values == NULL)
                     {
                     cal->values = VListRoot;
                     pvl = VListLast;
                     pvl->next = NULL;
                     }
                  else
                     {
                     pvl->next = VListRoot;
                     pvl = VListLast;
                     pvl->next = NULL;
                     }

                  TTF_RBTreeDestroy(NGA_LALentries[i].SortTree[ii]->RB_Entry); 
                  }

               NGA_LALentries[i].SortTree[ii]->thisindex = 0;
               cal->occurrences += NGA_LALentries[i].SortTree[ii]->occurrences;
               cal->count += NGA_LALentries[i].SortTree[ii]->count;
               cal->refcount += NGA_LALentries[i].SortTree[ii]->refcount;
               if(cal->references == NULL)
                  cal->references = NGA_LALentries[i].SortTree[ii]->references;
               else
                  {
                  nref = cal->references;
                  while(nref->next != NULL)
                     nref = nref->next;
                  nref->next = NGA_LALentries[i].SortTree[ii]->references;
                  }
   
               if(AListRoot == NULL)
                  {
                  AListRoot = cal;
                  cal->next = NULL;
                  pal = cal;
                  }
               else
                  {
                  pal->next = cal;
                  cal->next = NULL;
                  pal = cal;
                  }
               free(NGA_LALentries[i].SortTree[ii]);
               }
            }
         }
      free(NGA_LALentries);
      }
   else
      {
      for(i=0; i<j; i++)
         {
         for(ii=0; ii<8; ii++)
            {
            if(LALentries[i].Entry[ii] != NULL)
               {
               if(AListRoot == NULL)
                  {
                  AListRoot = LALentries[i].Entry[ii];
                  nal = AListRoot;
                  AListRoot->next = NULL;
                  }
               else
                  {
                  nal->next = LALentries[i].Entry[ii];
                  nal = nal->next;
                  nal->next = NULL;
                  }
               }
            }
         }

      free(LALentries);
      }

   LLIcheck = (int *) (malloc(SzI * (indexlimit + 10)));
   if(LLIcheck == NULL)
      {
      printf("can not allocate sufficient memory to recheck long list index to attribute value assignments\n");
      printf("memory requested %d elements of size %d each (total %d)\n",SzI,indexlimit,indexlimit*SzI);
      exit(-1);
      }
   nal = AListRoot;
   j = indexlimit + 5;
   for(i=0; i<j; i++)
      LLIcheck[i] = 0;
   while(nal != NULL)
      {
      ++AListCount;
      cref = nal->values->LongListIndices;
      while(cref != NULL)
         {
         if(cref->index >= indexlimit)
            {
            printf("cref - long list bounds violation\n");
            printf("bounds %d attempt to reference %d\n",indexlimit,cref->index);
            exit(-1);
            }
         if(LLIcheck[cref->index] == 0)
            LLIcheck[cref->index] = 1;
         else
            {
            printf("duplicate Long List Reference %d\n",cref->index);
            exit(-1);
            }
         cref = cref->next;
         }
      cref = nal->values->LongListIndices;
      for(i=0; i<j; i++)
         {
         if(LLIcheck[i] > 0)
            {
            if(cref != NULL)
               cref->index = i;
            else
               {
               printf("fatal exception - cref null prior to Long List end\n");
               printf("index limit %d current index %d\n",indexlimit,i);
               exit(-1);
               }
            cref = cref->next;
            LLIcheck[i] = 0;
            }
         }
      if(cref != NULL)
         {
         nref = cref->next;
         cref->next = NULL;
         cref = nref;
         while(cref != NULL)
            {
            nref = cref;
            cref = cref->next;
            free(nref);
            }
         }

      nal = nal->next;
      }
   free(LLIcheck);

   nal = AListRoot;
   while(nal != NULL)
      {
      if(nal->stringdigits > 0)
         {
         cvl = nal->values;
         newroot = NULL;
         while(cvl != NULL)
            {
            pvl = cvl;
            if(cvl->sortlabel != NULL)
               free(cvl->sortlabel);
            cvl = cvl->next;
            if(pvl->type == 2)
               sscanf(pvl->label,"%d",&pvl->scale);
            else
               {
               printf("stringdigits set but attribute value type is not string\n");
               printf("value %s\n",pvl->label);
               exit(-1);
               }
            if(newroot == NULL)
               {
               newroot = pvl;
               pvl->next = NULL;
               }
            else
               {
               nvl2 = nvl = newroot;
               while(nvl != NULL)
                  {
                  if(pvl->scale < nvl->scale)
                      {
                      if(nvl == newroot)
                         {
                         pvl->next = newroot;
                         newroot = pvl;
                         }
                      else
                         {
                         nvl2->next = pvl;
                         pvl->next = nvl;
                         }
                      break;
                      }
                  nvl2 = nvl;
                  nvl = nvl->next;
                  }
               if(nvl == NULL)
                  {
                  nvl2->next = pvl;
                  pvl->next = NULL;
                  }
               }
            }
         nal->values = newroot;
         }
      else /** here, just make sure we free up sortlabel memory if was used ****/
         {
         cvl = nal->values;
         newroot = NULL;
         while(cvl != NULL)
            {
            pvl = cvl;
            if(cvl->sortlabel != NULL)
               free(cvl->sortlabel);
            cvl = cvl->next;
            }
         }
      nal = nal->next;
      }
   return(AListCount);

}

   

void ShadedReliefSetUp(void)
{
int i,j;
int SzC, SzR;

   if(NGA_TYPE == 1)
      return;

   SzC = sizeof(struct ColPixels);
   SzR = sizeof(struct RowPixels);
   PBM = (struct ColPixels *) (malloc(SzC * ImageMaxSize));
   PBM2 = (struct ColPixels *) (malloc(SzC * ImageMaxSize));
   if((PBM == NULL) || (PBM2 == NULL))
      {
      printf("allocation memory exhausted during shaded relief calculation\n");
      printf("  processing must halt given this memory limitation\n");
      printf("try freeing some used memory, using a smaller database, or a larger machine\n");
      exit(-1);
      }
   for(i=0; i<ImageMaxSize; i++)
      {
      PBM[i].Row = (struct RowPixels *) (malloc(SzR * ImageMaxSize));
      PBM2[i].Row = (struct RowPixels *) (malloc(SzR * ImageMaxSize));
      if((PBM[i].Row == NULL)|| (PBM2[i].Row == NULL))
         {
         printf("allocation memory exhausted during shaded relief calculation\n");
         printf("  processing halts at this condition\n");
         exit(-1);
         }
      for(j=0; j<ImageMaxSize; j++)
         {
         PBM[i].Row[j].color = (unsigned char) InitColor;
         PBM2[i].Row[j].color = (unsigned char) InitColor;
         }
      }
}



int LocalLineSegmentsIntersect(double xl,double yl,double xk,double yk,double xm,double ym,double xn,double yn,double * xi,double * yi)
{
int answer;

   answer = LineSegmentsIntersect(xl,yl,xk,yk,xm,ym,xn,yn,xi,yi);
   return(answer);
}





int LocalPointInsideTriangle(double x,double y,double x1,double y1,double x2,double y2,double x3,double y3)
{
double c1;
double c2;
double c3;
int answer;

      c1 = ((x - x1) * (y2 - y1)) - ((x2 - x1) * (y - y1));
      c2 = ((x - x2) * (y3 - y2)) - ((x3 - x2) * (y - y2));
      c3 = ((x - x3) * (y1 - y3)) - ((x1 - x3) * (y - y3));

      if((c1 <= 0) && (c2 <= 0) && (c3 <= 0))
         answer = 1;
      else if ((c1 >= 0) && (c2 >= 0) && (c3 >= 0))
         answer = 1;
      else
         answer = 0;
      
   return(answer);
}




int LocalPointInsidePoly(double px,double py,double * x,double * y,int numb)
{
int j;
   if(numb == 3)
      j = LocalPointInsideTriangle(px,py, x[0], y[0],x[1], y[1],x[2],y[2]);
   else
      {
      j = PointInsidePoly(px,py, x, y,numb);
      }
   return(j);
}





int PointInsideAreal(double px,double py,double * fx,double * fy,int numb, double *lasty)
{
int numInts, i, j;
double nx, ny;
double *x, *y;
int Yset = 0;

   numInts = 0;
   if(numb == 3)
      j = LocalPointInsideTriangle(px,py,(double) fx[0],(double) fy[0],(double) fx[1],
                (double) fy[1],(double) fx[2],(double) fy[2]);
   else
      {
      x = (double *) (malloc(numb * SzD));
      y = (double *) (malloc(numb * SzD));
      for(i=0; i<numb; i++)
         {
         x[i] = (double) fx[i];
         y[i] = (double) fy[i];
         }
      for(i=0; i<numb; i++)
         {
         j = (i + 1) % numb;
         if((x[i] == x[j]) && (x[i] == px))
            {
            if((y[i] <= py) && (py <= y[j]))
               {
               ++numInts;
               if(Yset == 0)
                  {
                  Yset = 1;
                  *lasty = y[j];
                  }
               else if(y[j] < *lasty)
                  *lasty = y[j];
               }
            else if((y[j] <= py) && (py <= y[i]))
               {
               ++numInts;
               if(Yset == 0)
                  {
                  Yset = 1;
                  *lasty = y[i];
                  }
               else if(y[i] < *lasty)
                  *lasty = y[i];
               }
            }
         else if((x[i] < px) && (px < x[j]))
            {
            nx = (x[j] - px) / (x[j] - x[i]);
            ny = y[j] - ((y[j] - y[i]) * nx);
            if(ny > py)
               {
               ++numInts;
               if(Yset == 0)
                  {
                  Yset = 1;
                  *lasty = ny;
                  }
               else if(ny < *lasty)
                  *lasty = ny;
               }
            }
         else if((x[j] < px) && (px < x[i]))
            {
            nx = (x[i] - px) / (x[i] - x[j]);
            ny = y[i] - ((y[i] - y[j]) * nx);
            if(ny > py)
               {
               ++numInts;
               if(Yset == 0)
                  {
                  Yset = 1;
                  *lasty = ny;
                  }
               else if(ny < *lasty)
                  *lasty = ny;
               }
            }
         }
      free(x);
      free(y);
      j = (numInts % 2);
      }
   return(j);
}



void SurfNormal(double x1,double y1,double z1,double x2,double y2,double z2,double x3,double y3,double z3,double *A,double *B,double *C)
{
double a,b,c,length;
   a = ((z1+z2)*(y2-y1) + (z2+z3)*(y3-y2) + (z3+z1)*(y1-y3));
   a = a * 0.5;
   b = 0 - ((x1+x2)*(z2-z1) + (x2+x3)*(z3-z2) + (x3+x1)*(z1-z3));
   b = b * 0.5;
   c = ((y1+y2)*(x2-x1) + (y2+y3)*(x3-x2) + (y3+y1)*(x1-x3));
   c = c * 0.5;
   length = sqrt(a*a + b*b + c*c);
   *A = a / length;
   *B = b / length;
   *C = c / length;
}


int Three3DPointsAreColinear(double x0, double y0, double z0,
                    double x1, double y1, double z1,
                    double x2, double y2, double z2)
{
int answer = 0;
double t,t2;
   if(x1 == x2)
      {
      if(x0 == x1)
         {
         if(y1 == y2)
            {
            if(y1 == y0)
               answer = 1;
            }
         else if(z1 == z2)
            {
            if(z1 == z0)
               answer = 1;
            }
         else
            {
            t = (y0 - y1) / (y2 - y1);
            t2 = z0 - (z1 + (z2 - z1) * t);
            if((-0.0001 < t2) && (t2 < 0.0001)) /***/
               answer = 1;
            }
         }
      }
   else
      {
      t = (x0 - x1) / (x2 - x1);
      t2 = y0 - (y1 + (y2 - y1) * t);
      if((-0.0001 < t2) && (t2 < 0.0001))
         {
         t2 = z0 - (z1 + (z2 - z1) * t);
         if((-0.0001 < t2) && (t2 < 0.0001))
            answer = 1;
         }
      }
   return(answer);
}



void InspectUID(int Lindex,int index, int featureid, char * Geom)
{
long int seekposn;
long int index_seekposn;
int i,j,DoInspect;
short int uid_str_len;
char * IDstr;
char IDstrarray[100];
char IDnotfoundString[50];
char BlankIDString[50];
extern int * LLFidTable;


   if(LLFidTable[index] < 0)
      return;

   index_seekposn = index * (SzShort + SzL);
   fseek(IDDfp,index_seekposn,SEEK_SET);

   SEEIT_fread_short(&uid_str_len,IDDfp);
   SEEIT_fread_long(&seekposn,IDDfp);

   DoInspect = 0;
   if(ATTRTYPE_D4() > 0) /**** GIFD ***/
      DoInspect = 1;
   else if(ATTRTYPE_UFD2() > 0) /*** UFD2  ***/
      DoInspect = 1;
   else if(ATTRTYPE_UFD1() > 0) /*** UFD1  ***/
      DoInspect = 1;
   else if(ATTRTYPE_UFD3() > 0) /*** UFD3  ***/
      DoInspect = 1;
   else if(ATTRTYPE_SAC() > 0)
      {
      sprintf(IDnotfoundString,"No %s found",GetFrontPart());
      sprintf(BlankIDString," Blank %s found ",GetFrontPart());
      fseek(IDHfp,seekposn,SEEK_SET);
      if(uid_str_len < 100)
         {
         fread(&IDstrarray[0], uid_str_len, 1,  IDHfp);
         IDstrarray[uid_str_len] = '\0';
         if(strcmp(IDstrarray,IDnotfoundString) == 0)
            {
            LongListBadUID[Lindex] = 1;
            LongListBadUIDcount[Lindex] += 1;
            }
         else if((ATTRTYPE_TDS4() == 0) && (strcmp(IDstrarray,BlankIDString) == 0))
            {
            LongListBadUID[Lindex] = 2;
            LongListBadUIDcount[Lindex] += 1;
            }
         }
      }
   else if((ATTRTYPE_ANY_TDS() > 0) ||
        (ATTRTYPE_ANY_GGDM() > 0)) /*** GGDM ***/
      {
      if(uid_str_len == 12) /** str length of "No UID found"  - need to read it and see if that is the content ***/
         {
         sprintf(IDnotfoundString,"No %s found",GetFrontPart());
         sprintf(BlankIDString," Blank %s found ",GetFrontPart());
         fseek(IDHfp,seekposn,SEEK_SET);
         if(uid_str_len < 100)
            {
            fread(&IDstrarray[0], uid_str_len, 1,  IDHfp);
            IDstrarray[uid_str_len] = '\0';
            if(strcmp(IDstrarray,IDnotfoundString) == 0)
               {
               LongListBadUID[Lindex] = 1;
               LongListBadUIDcount[Lindex] += 1;
               }
            else if((ATTRTYPE_TDS4() == 0) && (strcmp(IDstrarray,BlankIDString) == 0))
               {
               LongListBadUID[Lindex] = 2;
               LongListBadUIDcount[Lindex] += 1;
               }
            else if(strcmp(IDstrarray,"No Information") == 0)
               {
               LongListBadUID[Lindex] = 7;
               LongListBadUIDcount[Lindex] += 1;
               }
            else if((ATTRTYPE_TDS6() > 0) && (strcmp(IDstrarray,"noInformation") == 0))
               {
               LongListBadUID[Lindex] = 4;
               LongListBadUIDcount[Lindex] += 1;
               }
            else if(strcmp(IDstrarray,"Not Applicable") == 0)
               {
               LongListBadUID[Lindex] = 5;
               LongListBadUIDcount[Lindex] += 1;
               }
            else if(strcmp(IDstrarray,"Other") == 0)
               {
               LongListBadUID[Lindex] = 6;
               LongListBadUIDcount[Lindex] += 1;
               }
            }
         }
      else
         {
         sprintf(BlankIDString," Blank %s found ",GetFrontPart());
         fseek(IDHfp,seekposn,SEEK_SET);
         if(uid_str_len < 100)
            {
            fread(&IDstrarray[0], uid_str_len, 1,  IDHfp);
            IDstrarray[uid_str_len] = '\0';
            if(strcmp(IDstrarray,"No Information") == 0)
               {
               LongListBadUID[Lindex] = 7;
               LongListBadUIDcount[Lindex] += 1;
               }
            else if((ATTRTYPE_ANY_GGDM() <= 0) && (strcmp(IDstrarray,"noInformation") == 0))
               {
               LongListBadUID[Lindex] = 4;
               LongListBadUIDcount[Lindex] += 1;
               }
            else if((ATTRTYPE_TDS4() == 0) && (strcmp(IDstrarray,BlankIDString) == 0))
               {
               LongListBadUID[Lindex] = 2;
               LongListBadUIDcount[Lindex] += 1;
               }
            else if(strcmp(IDstrarray,"Not Applicable") == 0)
               {
               LongListBadUID[Lindex] = 5;
               LongListBadUIDcount[Lindex] += 1;
               }
            else if(strcmp(IDstrarray,"Other") == 0)
               {
               LongListBadUID[Lindex] = 6;
               LongListBadUIDcount[Lindex] += 1;
               }
            }
         }
      }
   if(DoInspect > 0)
      {
      if(uid_str_len > 38)
         {
         if(BUID != NULL)
            {
            fseek(IDHfp,seekposn,SEEK_SET);
            if(uid_str_len < 100)
               {
               fread(&IDstrarray[0], uid_str_len, 1,  IDHfp);
               IDstrarray[uid_str_len] = '\0';
               fprintf(BUID,"%s %s %s FID/Objid/OBJECTID: %d, GFID %s : Incorrect string length (%d characters)\n",Geom,
                 GetECCCode(NArray[Lindex].code), GetECCLabel(NArray[Lindex].code),featureid,IDstrarray,uid_str_len);
               }
            else
               {
               IDstr = (char *) (malloc(uid_str_len + 10));
               if(IDstr == NULL)
                  {
                  printf("all available memory has been consumed during id string read attempt\n");
                  printf("   (requested %d bytes of memory and failed)\n",uid_str_len);
                  exit(-1);
                  }
               fread(IDstr, uid_str_len, 1,  IDHfp);
               IDstr[uid_str_len] = '\0';

               fprintf(BUID,"%s %s %s FID/Objid/OBJECTID: %d, GFID %s : Incorrect string length (%d characters)\n",Geom,
                 GetECCCode(NArray[Lindex].code), GetECCLabel(NArray[Lindex].code),featureid,IDstr,uid_str_len);
               free(IDstr);
               }
            }
         }

      return;
      }

   else if(ATTRTYPE_ANY_MGCP() > 0) /**** inspecting MGCP id string ***/
      {
      if(uid_str_len == 12) /** str length of "No UID found"  - need to read it and see if that is the content ***/
         {
         fseek(IDHfp,seekposn,SEEK_SET);
         if(uid_str_len < 100)
            {
            fread(&IDstrarray[0], uid_str_len, 1,  IDHfp);
            IDstrarray[uid_str_len] = '\0';
            if(strcmp(IDstrarray,"No UID found") == 0)
               {
               LongListBadUID[Lindex] = 1;
               LongListBadUIDcount[Lindex] += 1; 
               }
            }
         else
            {
            IDstr = (char *) (malloc(uid_str_len + 10));
            if(IDstr == NULL)
               {
               printf("all available memory has been consumed during id string read attempt\n");
               printf("   (requested %d bytes of memory and failed)\n",uid_str_len);
               exit(-1);
               }
            fread(IDstr, uid_str_len, 1,  IDHfp);
            IDstr[uid_str_len] = '\0';
            if(strcmp(IDstr,"No UID found") == 0)
               {
               LongListBadUID[Lindex] = 1;
               LongListBadUIDcount[Lindex] += 1; 
               }
            free(IDstr);
            }
         }
      else if(uid_str_len == 0)
         {
         LongListBadUID[Lindex] = 2;
         LongListBadUIDcount[Lindex] += 1; 
         }
      else if(uid_str_len != 36)
         {
         LongListBadUID[Lindex] = 3;
         LongListBadUIDcount[Lindex] += 1; 
         if(BUID != NULL)
            {
            fseek(IDHfp,seekposn,SEEK_SET);
            if(uid_str_len < 100)
               {
               fread(&IDstrarray[0], uid_str_len, 1,  IDHfp);
               IDstrarray[uid_str_len] = '\0';
               fprintf(BUID,"%s %s %s FID/Objid/OBJECTID: %d, UID %s : Incorrect string length (%d characters)\n",Geom,
                 GetECCCode(NArray[Lindex].code), GetECCLabel(NArray[Lindex].code),featureid,IDstrarray,uid_str_len);
               }
            else
               {
               IDstr = (char *) (malloc(uid_str_len + 10));
               if(IDstr == NULL)
                  {
                  printf("all available memory has been consumed during id string read attempt\n");
                  printf("   (requested %d bytes of memory and failed)\n",uid_str_len);
                  exit(-1);
                  }
               fread(IDstr, uid_str_len, 1,  IDHfp);
               IDstr[uid_str_len] = '\0';
              
               fprintf(BUID,"%s %s %s FID/Objid/OBJECTID: %d, UID %s : Incorrect string length (%d characters)\n",Geom,
                 GetECCCode(NArray[Lindex].code), GetECCLabel(NArray[Lindex].code),featureid,IDstr,uid_str_len);
               free(IDstr);
               }
            }
         }
      else /*** must be the right str length - is it formed correctly?  ***/
         {
         IDstr = (char *) (malloc(uid_str_len + 10));
         if(IDstr == NULL)
            {
            printf("all available memory has been consumed during id string read attempt\n");
            printf("   (requested %d bytes of memory and failed)\n",uid_str_len);
            exit(-1);
            }
         fseek(IDHfp,seekposn,SEEK_SET);
         fread(IDstr, uid_str_len, 1,  IDHfp);
         IDstr[uid_str_len] = '\0';
         j = 0;
         for(i=0; i<8; i++)
            {
            if(IDstr[i] < 58)  /** should be in interval from '0' to '9' ***/
               {
               if(IDstr[i] < 48)   /*** out of allowed range ***/
                  {
                  j = 1;
                  break;
                  }
               }
            else if(IDstr[i] < 71)  /*** should be in interval of 'A' to 'F' ***/
               {
               if(IDstr[i] < 65)   /*** out of allowed range ***/
                  {
                  j = 1;
                  break;
                  }
               }
            else if(IDstr[i] < 103)  /*** should be in interval of 'a' to 'f' ***/
               {
               if(IDstr[i] < 97)   /*** out of allowed range ***/
                  {
                  j = 1;
                  break;
                  }
               }
            else if(IDstr[i] > 102) /** no legal hex characters above 'f' = 102 ***/
               {
               j = 1;
               break;
               }
            }
         if(j == 0)
            {
            i = 8;
            if(IDstr[i] != '-')
               {
               j = 1;
               }
            }
   
         if(j == 0)
            {
            for(i=9; i<13; i++)
               {
               if(IDstr[i] < 58)  /** should be in interval from '0' to '9' ***/
                  {
                  if(IDstr[i] < 48)   /*** out of allowed range ***/
                     {
                     j = 1;
                     break;
                     }
                  }
               else if(IDstr[i] < 71)  /*** should be in interval of 'A' to 'F' ***/
                  {
                  if(IDstr[i] < 65)   /*** out of allowed range ***/
                     {
                     j = 1;
                     break;
                     }
                  }
               else if(IDstr[i] < 103)  /*** should be in interval of 'a' to 'f' ***/
                  {
                  if(IDstr[i] < 97)   /*** out of allowed range ***/
                     {
                     j = 1;
                     break;
                     }
                  }
               else if(IDstr[i] > 102) /** no legal hex characters above 'f' = 102 ***/
                  {
                  j = 1;
                  break;
                  }
               }
            }
         if(j == 0)
            {
            i = 13;
            if(IDstr[i] != '-')
               {
               j = 1;
               }
            }
         if(j == 0)
            {
            for(i=14; i<18; i++)
               {
               if(IDstr[i] < 58)  /** should be in interval from '0' to '9' ***/
                  {
                  if(IDstr[i] < 48)   /*** out of allowed range ***/
                     {
                     j = 1;
                     break;
                     }
                  }
               else if(IDstr[i] < 71)  /*** should be in interval of 'A' to 'F' ***/
                  {
                  if(IDstr[i] < 65)   /*** out of allowed range ***/
                     {
                     j = 1;
                     break;
                     }
                  }
               else if(IDstr[i] < 103)  /*** should be in interval of 'a' to 'f' ***/
                  {
                  if(IDstr[i] < 97)   /*** out of allowed range ***/
                     {
                     j = 1;
                     break;
                     }
                  }
               else if(IDstr[i] > 102) /** no legal hex characters above 'f' = 102 ***/
                  {
                  j = 1;
                  break;
                  }
               }
            }
         if(j == 0)
            {
            i = 18;
            if(IDstr[i] != '-')
               {
               j = 1;
               }
            }
   
         if(j == 0)
            {
            for(i=19; i<23; i++)
               {
               if(IDstr[i] < 58)  /** should be in interval from '0' to '9' ***/
                  {
                  if(IDstr[i] < 48)   /*** out of allowed range ***/
                     {
                     j = 1;
                     break;
                     }
                  }
               else if(IDstr[i] < 71)  /*** should be in interval of 'A' to 'F' ***/
                  {
                  if(IDstr[i] < 65)   /*** out of allowed range ***/
                     {
                     j = 1;
                     break;
                     }
                  }
               else if(IDstr[i] < 103)  /*** should be in interval of 'a' to 'f' ***/
                  {
                  if(IDstr[i] < 97)   /*** out of allowed range ***/
                     {
                     j = 1;
                     break;
                     }
                  }
               else if(IDstr[i] > 102) /** no legal hex characters above 'f' = 102 ***/
                  {
                  j = 1;
                  break;
                  }
               }
            }
         if(j == 0)
            {
            i = 23;
            if(IDstr[i] != '-')
               {
               j = 1;
               }
            }
   
         if(j == 0)
            {
            for(i=24; i<36; i++)
               {
               if(IDstr[i] < 58)  /** should be in interval from '0' to '9' ***/
                  {
                  if(IDstr[i] < 48)   /*** out of allowed range ***/
                     {
                     j = 1;
                     break;
                     }
                  }
               else if(IDstr[i] < 71)  /*** should be in interval of 'A' to 'F' ***/
                  {
                  if(IDstr[i] < 65)   /*** out of allowed range ***/
                     {
                     j = 1;
                     break;
                     }
                  }
               else if(IDstr[i] < 103)  /*** should be in interval of 'a' to 'f' ***/
                  {
                  if(IDstr[i] < 97)   /*** out of allowed range ***/
                     {
                     j = 1;
                     break;
                     }
                  }
               else if(IDstr[i] > 102) /** no legal hex characters above 'f' = 102 ***/
                  {
                  j = 1;
                  break;
                  }
               }
            }

         if(j > 0)  /**** record an error for character in position i  ****/
            {
            LongListBadUID[Lindex] = 10 + i + 1;
            LongListBadUIDcount[Lindex] += 1;
            if(BUID != NULL)
               {
               if((i == 8) || (i == 13) || (i == 18) || (i == 23))  /** should be a dash in these positions ***/
                  {
                  fprintf(BUID,"%s %s FID/Objid/OBJECTID: %d, UID %s : Character in position %d s not '-'(illegal character is %c)\n",
                    GetECCCode(NArray[Lindex].code), GetECCLabel(NArray[Lindex].code),featureid,IDstr,i+1,IDstr[i]);
                  }
               else
                  {
                  fprintf(BUID,"%s %s FID/Objid/OBJECTID: %d, UID %s : Non-hexadecimal character in position %d (illegal character is %c)\n",
                    GetECCCode(NArray[Lindex].code), GetECCLabel(NArray[Lindex].code),featureid,IDstr,i+1,IDstr[i]);
                  }
               }

            }

         free(IDstr);
         }
      }
}




void FormatFromDynamicDefsFile(int TotalECC)
{
FILE *tblin;
int i, ECCcode;

   if(SCCdataArray == NULL)
      {
      tblin = fopen(scctablefile,"rb");
      if(tblin == NULL)
        {
         printf("Could not locate ECC value table %s\n",scctablefile);
         exit(-1);
         }
      ClassData = (struct Classifications *) (malloc(TotalECC * sizeof(struct Classifications)));
      if(ClassData == NULL)
         {
         printf("allocation memory exhausted during classification mapping format\n");
         exit(-1);
         }
      SCCdataArray = (struct sccdataarray *) (malloc(TotalECC * sizeof(struct sccdataarray)));
      if(SCCdataArray == NULL)
         {
         printf("allocation memory exhausted during attempt to read %d ECC table entries\n",TotalECC);
         exit(-1);
         }

      SEEIT_fread_int(&ECCcode,tblin);
      for(i=0; i<TotalECC; i++)
         {
         fread(&SCCdataArray[i].C,1,1,tblin);
         fread(&SCCdataArray[i].S,1,1,tblin);
         fread(&SCCdataArray[i].D,1,1,tblin);
         ClassData[i].ECC = ECCcode;
         ClassData[i].C = SCCdataArray[i].C;
         ClassData[i].S = SCCdataArray[i].S;
         ClassData[i].D = SCCdataArray[i].D;
         ClassData[i].occurrences = 0;
         SEEIT_fread_int(&ECCcode,tblin);

         if(feof(tblin) != 0)
            break;
         }
      fclose(tblin);
      }
   return;
}



double GetMaxGridSpacing()
{
  char gridinfo2[1000];
  FILE *gridinfo;
  double tempdouble;
  
  sprintf(gridinfo2,"%sgridspace.txt",indirectory);
  gridinfo = fopen(gridinfo2,"r");
  if(gridinfo==NULL)
    {
      printf("coulf not open %s\n",gridinfo2);
      exit(-1);
    }
  fscanf(gridinfo,"%lf",&tempdouble);
  fclose(gridinfo);
  
  return tempdouble;  
}




void RetrieveTreeInorder( rb_red_blk_tree* tree, rb_red_blk_node* x)
{     
   
   if (x != tree->nil)
      {
      RetrieveTreeInorder(tree,x->left);
      
      if(NListRoot == NULL)
         {
         NListRoot = (struct NameList *) (x->info);
         NListRoot->next = NULL;
         NListLast = NListRoot;
         }
      else
         {
         NListLast->next = (struct NameList *) (x->info);
         NListLast = NListLast->next;
         NListLast->next = NULL;
         }
         
      RetrieveTreeInorder(tree,x->right);
      }  
}           





void CountMPObjects(char *indirectory)
{
char filename[1000];
double td;
FILE *fin;
int SzMPO = sizeof(struct MultiPO);
int numpoints, numlines, numareals;
int fid, ijunk,i;


   LineMProot = PointMProot = AreaMProot = NULL;

   sprintf(filename,"%smultipart.txt",indirectory);
   fin = fopen(filename,"rt");
   if(fin == NULL)
      {
      return;
      }
   else
      {
      fscanf(fin,"%d %d %d",&numpoints, &numlines, &numareals);
      fclose(fin);
      if(numpoints > 0)
         {
         sprintf(filename,"%smultipartpoints.bin",indirectory);
         fin = fopen(filename,"rb");
         SEEIT_fread_int(&ijunk,fin); /** feature id ***/
         while(feof(fin) == 0)
            {
            SEEIT_fread_int(&ijunk,fin); /** long index **/
            SEEIT_fread_int(&ijunk,fin); /** short index **/
            SEEIT_fread_int(&fid,fin); /** GIFD index **/

            SEEIT_fread_double(&td,fin); /** x coord ***/
            SEEIT_fread_double(&td,fin); /** y coord ***/
            SEEIT_fread_double(&td,fin); /** z coord ***/
            ijunk = 1; /** num nodes  always == 1 for a point **/
               
            MPoc = PointMProot;
            while(MPoc != NULL)
               {
               if(MPoc->featureid == fid)
                  {
                  MPoc->parts += 1;
                  break;
                  }
               MPoc = MPoc->next;
               }
            if(MPoc == NULL)
               {
               MPon = (struct MultiPO *) (malloc(SzMPO));
               if(MPon == NULL)
                  {
                  printf("memory has been exhausted during multi-part point data read\n");
                  exit(-1);
                  }
               MPon->used = 0;
               MPon->parts = 1;
               MPon->featureid = fid;
               MPon->next = PointMProot;
               PointMProot = MPon;
               }

            SEEIT_fread_int(&ijunk,fin);
            }
         fclose(fin);
         }

      if(numlines > 0)
         {
         sprintf(filename,"%smultipartlines.bin",indirectory);
         fin = fopen(filename,"rb");
         SEEIT_fread_int(&ijunk,fin);
         while(feof(fin) == 0)
            {
            SEEIT_fread_int(&ijunk,fin); /** long index **/
            SEEIT_fread_int(&ijunk,fin); /** short index **/
            SEEIT_fread_int(&fid,fin); /** GIFD index **/
            SEEIT_fread_int(&ijunk,fin); /** num nodes **/
            for(i=0; i<ijunk; i++)
               {
               SEEIT_fread_double(&td,fin); /*** x coord ***/
               SEEIT_fread_double(&td,fin); /*** y coord ***/
               SEEIT_fread_double(&td,fin); /*** z coord ***/
               }

            MPoc = LineMProot;
            while(MPoc != NULL)
               {
               if(MPoc->featureid == fid)
                  {
                  MPoc->parts += 1;
                  break;
                  }
               MPoc = MPoc->next;
               }
            if(MPoc == NULL)
               {
               MPon = (struct MultiPO *) (malloc(SzMPO));
               if(MPon == NULL)
                  {
                  printf("memory has been exhausted during multi-part line data read\n");
                  exit(-1);
                  }
               MPon->used = 0;
               MPon->parts = 1;
               MPon->featureid = fid;
               MPon->next = LineMProot;
               LineMProot = MPon;
               }


            SEEIT_fread_int(&ijunk,fin);
            }
         fclose(fin);
         }


      if(numareals > 0)
         {
         sprintf(filename,"%smultipartareas.bin",indirectory);
         fin = fopen(filename,"rb");
         SEEIT_fread_int(&ijunk,fin);
         while(feof(fin) == 0)
            {
            SEEIT_fread_int(&ijunk,fin); /** long index **/
            SEEIT_fread_int(&ijunk,fin); /** short index **/
            SEEIT_fread_int(&fid,fin); /** GIFD index **/
            SEEIT_fread_int(&ijunk,fin); /** num nodes **/
            for(i=0; i<ijunk; i++)
               {
               SEEIT_fread_double(&td,fin); /*** x coord **/
               SEEIT_fread_double(&td,fin); /*** y coord **/
               SEEIT_fread_double(&td,fin); /*** z coord **/
               }
            MPoc = AreaMProot;
            while(MPoc != NULL)
               {
               if(MPoc->featureid == fid)
                  {
                  MPoc->parts += 1;
                  break;
                  }
               MPoc = MPoc->next;
               }
            if(MPoc == NULL)
               {
               MPon = (struct MultiPO *) (malloc(SzMPO));
               if(MPon == NULL)
                  {
                  printf("memory has been exhausted during multi-part area data read\n");
                  exit(-1);
                  }
               MPon->used = 0;
               MPon->parts = 1;
               MPon->featureid = fid;
               MPon->next = AreaMProot;
               AreaMProot = MPon;
               }


            SEEIT_fread_int(&ijunk,fin);
            }
         fclose(fin);
         }
      }

   return;

}




void FreeMPO(void)
{
   MPon = PointMProot;
   while(MPon != NULL)
      {
      MPoc = MPon;
      MPon = MPon->next;
      free(MPoc);
      }
   PointMProot = NULL;

   MPon = LineMProot;
   while(MPon != NULL)
      {
      MPoc = MPon;
      MPon = MPon->next;
      free(MPoc);
      }
   LineMProot = NULL;

   MPon = AreaMProot;
   while(MPon != NULL)
      {
      MPoc = MPon;
      MPon = MPon->next;
      free(MPoc);
      }
   AreaMProot = NULL;
}





unsigned char FormatPolys(int *SACfull, int *TotalSCC, int *TtlNames, int *TtlGrids,
			  int *polys_read, int *polys_done,int model_polys,int areals_done,int linears_done,int points_done,
			  int sphere_cv,int parallel_cv,int stamps_done,int footprints_done,
			  int bridges_done,unsigned int  g_read, unsigned int g_write, int FMpointsdone, int FMlinesdone, int FMarealsdone)
{
  int listlength;
  FILE *summaryout;
  FILE *header;
  FILE *polyin;
  FILE *polyout;
  FILE *otherout;
  FILE *tableout;
  
  int i,j, LODindex;
  int IM = ImageMaxSize - 1;
  int offXpix, offYpix,Sxi,Syj;
  unsigned char coordflag;
  int ind1;
  int ind2;
  int si1,si2;
  struct RawPoly *cp, *pp;
  struct PtrList *plst, *clst;
  struct LODranges *LR, *PR;
  struct EnumList *cel, *pel;
  long int ttlpolys;
  int numgrids;
  int gridpolys;
  double featureverts,featurefraction;
  long fileposn, readfileposn;
  double d1, d2,px,py,offx,offy;
  double minX, minY, maxX, maxY;
  double RminX,RminY;
  int i1,i2,j1,j2;
  int idiff, jdiff;
  int Sx,Sy,Ex,Ey;
  int XindexExtent, YindexExtent;
  unsigned char pixcolor;
  
  double tempRegionSize,tempRegionSize2,maxGridspacing;
  
  
  int SzRP = sizeof(struct RawPoly);
  int SzOL = sizeof(struct ObjectLookup);
  int SzPtrList = sizeof(struct PtrList);
  int SzNL = sizeof(struct NameList);
  int SzEL = sizeof(struct EnumList);
  
  
  double SunRadianAngle, SunTangent;
  double L1,L2,L3,N1,N2,N3;
  long int ImageSize;
  unsigned int TempL;
  int TempL2;
  double Xextent, Yextent;
  double interval;
  double SunX = 10000.0;
  double SunY = 10000.0;
  double SunAngle = 45.0;
  double Ip = 1.0;
  double Kd = 0.95;
  
  extern int CoordinateSystem;
  /***extern int ThisClassLevel; ***/
  extern int Ctype();
  extern double ModifyFormatMult(double oldmult);
  
#define ScrnMaxCol 790
#define ScrnMaxRow 990


  header = fopen(Lmetadata,"rb");
  
  summaryout = fopen(summarydatafile,"wt");
  
  if(header == NULL)
    {
      printf("attempt to format: could not open summary file %s\n",Lmetadata);
      printf("processing cannot continue without this input file\n");
      exit(-1);
    }
  
  
  fprintf(summaryout,"Content summary compiled by GAIT %s\n",VersionStr);
  fprintf(summaryout,"Project: %s (%s)\n",indirectory,SetThisClassLevel(1,1));

  fread(&coordflag,SzUC,1,header);
  
  CoordinateSystem = (int)coordflag;
  
  
  fprintf(summaryout,"Coordinate system in effect: ");
  switch(coordflag)
    {
    case 1: fprintf(summaryout,"GDC (Geodetic)\n"); break;
    case 2: fprintf(summaryout,"UTM (Universal Transverse Mercator)\n"); break;
    case 3: fprintf(summaryout,"TM (Transverse Mercator)\n"); break;
    case 4: fprintf(summaryout,"LCC (Lambert Conformal Conic)\n"); break;
    case 5: fprintf(summaryout,"EC (Equidistant Cylindrical)\n"); break;
    case 6: fprintf(summaryout,"PS (Polar Stereographic)\n"); break;
    case 7: fprintf(summaryout,"GSE (Geocentric Solar Ecliptic)\n"); break;
    case 8: fprintf(summaryout,"GM (Geomagnetic)\n"); break;
    case 9: fprintf(summaryout,"GSM (Geocentric Solar Magnetic)\n"); break;
    case 10: fprintf(summaryout,"SM (Solar Magnetic)\n"); break;
    case 11: fprintf(summaryout,"OM (Augmented Oblique Mercator)\n"); break;
    case 12: fprintf(summaryout,"LTP (Local Tangent Plane)\n"); break;
    case 13: fprintf(summaryout,"M (Augmented Mercator)\n"); break;
    case 14: fprintf(summaryout,"LSR (Local Space Rectangular)\n"); break;
      
    default: fprintf(summaryout,"UNRECOGNIZED\n"); break;
    }
  
  SEEIT_fread_double(&MinXcoord,header);
  SEEIT_fread_double(&MinYcoord,header);
  SEEIT_fread_double(&MaxXcoord,header);
  SEEIT_fread_double(&MaxYcoord,header);
  
  
  
  SEEIT_fread_double(&minX,header);
  SEEIT_fread_double(&minY,header);
  SEEIT_fread_double(&maxX,header);
  SEEIT_fread_double(&maxY,header);
  
  
  if((minX < maxX) && (minY < maxY))
    {
      if(minX < MinXcoord)
	MinXcoord = minX;
      if(maxX > MaxXcoord)
	MaxXcoord = maxX;
      if(minY < MinYcoord)
	MinYcoord = minY;
      if(maxY > MaxYcoord)
	MaxYcoord = maxY;
    }
  
  SEEIT_fread_long(&ttlpolys,header);
  SEEIT_fread_uint(&TempL,header);
  ttlgridpoints = (unsigned int) TempL;
  SEEIT_fread_long(&pointverts,header);
  SEEIT_fread_long(&lineverts,header);
  SEEIT_fread_long(&arealverts,header);
  SEEIT_fread_int(&numgrids,header);
  SEEIT_fread_int(&si1,header);
  SEEIT_fread_int(&si2,header);
  
  
  *TtlGrids = numgrids;
  
  if(ttlgridpoints > 0)
    {
      gridpolys = ttlgridpoints / 100; /* in order to not get way too many load modules */
    }
  else
    gridpolys = 0;
  
  *SACfull = si1;
  *TotalSCC = si2;
  
  BuildOpenMenu(0.0,0,*SACfull+*SACfull,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0);
  fclose(header);
  
  header = fopen(headerout,"wb");
  fwrite(&coordflag,SzUC,1,header);
  SEEIT_fwrite_double(&MinXcoord,header);
  SEEIT_fwrite_double(&MinYcoord,header);
  SEEIT_fwrite_double(&MaxXcoord,header);
  SEEIT_fwrite_double(&MaxYcoord,header);
  /*** below is terrain max, min **/
  SEEIT_fwrite_double(&minX,header);
  SEEIT_fwrite_double(&minY,header);
  SEEIT_fwrite_double(&maxX,header);
  SEEIT_fwrite_double(&maxY,header); 
  
  SEEIT_fwrite_long(&ttlpolys,header);
  TempL2 = ttlgridpoints;
  SEEIT_fwrite_int(&TempL2,header);
  SEEIT_fwrite_long(&pointverts,header);
  SEEIT_fwrite_long(&lineverts,header);
  SEEIT_fwrite_long(&arealverts,header);
  SEEIT_fwrite_int(&numgrids,header);
  SEEIT_fwrite_int(&si1,header);
  SEEIT_fwrite_int(&si2,header);
  fclose(header);
  
  Xtranslation = MinXcoord;
  Ytranslation = MinYcoord;
  
  
  if(Ctype()==1)  /** GDC type ***/
    {
      MinXcoord = MinYcoord = 0.0;
      MaxXcoord = (MaxXcoord - Xtranslation) * 100000.0;
      MaxYcoord = (MaxYcoord - Ytranslation) * 100000.0;
      
      minX = minY = 0.0;
      maxX = (maxX - Xtranslation) * 100000.0;
      maxY = (maxY - Ytranslation) * 100000.0;
      coordflag = 1;
    }
  else if(Ctype()==2) /** UTM type  **/
    {
      MinXcoord = MinYcoord = 0.0;
      MaxXcoord = MaxXcoord - Xtranslation;
      MaxYcoord = MaxYcoord - Ytranslation;
      
      minX = minY = 0.0;
      maxX = maxX - Xtranslation;
      maxY = maxY - Ytranslation;
      coordflag = 2;
    }
  else
    {
      printf("unable to translate coordinate system correctly (coord system identifier %d)\n", coordflag);
      exit(-1);
    }


  fprintf(summaryout,"Southwest corner of data %s\n",Coordinate2DtoString(MinXcoord,MinYcoord));
  fprintf(summaryout,"Northeast corner of data %s\n",Coordinate2DtoString(MaxXcoord,MaxYcoord));

  if(NGA_TYPE == 0)
     {
     fprintf(summaryout,"Polygons (excluding models): %ld\n",ttlpolys);
     fprintf(summaryout,"%ld point-related data\n",pointverts);
     }
  fprintf(summaryout,"%d Grids containing %u grid points\n",numgrids,ttlgridpoints);

  fclose(summaryout);
  
  
  featureverts = pointverts + lineverts + arealverts + gridpolys + ttlpolys*3;
  

  featurefraction = (featureverts) / 5000000.0;
  
  featurefraction = ModifyFormatMult(featurefraction);


  tempRegionSize  = MaxYcoord / (262.0 * sqrt(featurefraction));
  if(tempRegionSize > (MaxYcoord + 2))
    tempRegionSize = MaxYcoord + 2;
  tempRegionSize2 = MaxXcoord / (329.0 * sqrt(featurefraction));
  if(tempRegionSize2 > (MaxXcoord + 2))
    tempRegionSize2 = MaxXcoord + 2;
  
  
  
  maxGridspacing = GetMaxGridSpacing();
  
  
  if(tempRegionSize<tempRegionSize2)
    {
      LRegionSize = tempRegionSize2;
    }
  else
    {
      LRegionSize = tempRegionSize;
    }

  
  if(maxGridspacing>0)
    {
      if(LRegionSize<(maxGridspacing*2.0))
	{
	  LRegionSize = maxGridspacing*2.0;
	}
    }

  
  XindexExtent = (int) (MaxXcoord / LRegionSize) + 2;
  YindexExtent = (int) (MaxYcoord / LRegionSize) + 2;
  
  


  listlength = XindexExtent * YindexExtent;
  NumberOfLoadModules = (double) listlength;

  if(ConserveMemory == 0)
    {
      SingleRegionPolys = (struct singles *) (malloc(sizeof(struct singles) * listlength));
      SingleRegionPolyRoot = NULL;
    }
  else
    {
      SingleRegionPolys = NULL;
      SingleRegionPolyRoot = (struct PtrList *) (malloc(SzPtrList * listlength));
    }
  LocalPolyTable = (struct ObjectLookup *) (malloc(SzOL * listlength));
  SCCroot = (struct SCClookup *) (malloc(listlength * sizeof(struct SCClookup)));
  FIDroot = (struct SCClookup *) (malloc(listlength * sizeof(struct SCClookup)));
  LLtoFeatureID = (struct LongListToFeatureIDmap *) (malloc((*SACfull + 1) * sizeof(struct SCClookup)));
  
  for(i=0; i<listlength; i++)
    {
      if(ConserveMemory == 0)
	{
	  SingleRegionPolys[i].root = NULL;
	}
      else
	{
	  SingleRegionPolyRoot[i].fileptr = -1;
	  SingleRegionPolyRoot[i].count = 0;
	  SingleRegionPolyRoot[i].next = NULL;
	}
      
      LocalPolyTable[i].fileptr = 0;
      LocalPolyTable[i].numpoly = 0;
      LocalPolyTable[i].numother = 0;
      LocalPolyTable[i].others = NULL;
      SCCroot[i].inside = 0;
      SCCroot[i].next = NULL;
      FIDroot[i].inside = 0;
      FIDroot[i].next = NULL;
    }
  for(i=0; i<=*SACfull; i++)
    {
    LLtoFeatureID[i].fidlist = NULL;
    LLtoFeatureID[i].counter = 0;
    }
  
  
  LongListInstances = (int *) (malloc(*SACfull * SzI));

  LL_to_Layer_Map = (int *) (malloc(*SACfull * SzI));
  
  LongToShortMap = (int *) (malloc(*SACfull * SzI));

  LongListBadUID = (char *) (malloc(*SACfull + 2));
  LongListBadUIDcount = (int *) (malloc(SzI * (*SACfull + 2))); 
  
  NArray = (struct NameArray *) (malloc(*SACfull * sizeof(struct NameArray)));
  if(NArray == NULL)
    {
      printf("allocation memory exhausted during name space format\n");
      exit(-1);
    }
  
  for(i=0; i<*SACfull; i++)
    {
      LongListInstances[i] = 0;
      LongToShortMap[i] = -1;
      LongListBadUID[i] = 0;
      LongListBadUIDcount[i] = 0; 
      LL_to_Layer_Map[i] = -1;
    }
  
  LODroot = NULL;
  
  i = *SACfull * 2;
  NumberAListEntries = AssembleNames(*SACfull);
  otherout = fopen(LODrangefile,"rb");
  if(otherout != NULL)
    {
      fclose(otherout);
      remove(LODrangefile);
    }
  if(LODroot != NULL)
    {
      i = 0;
      otherout = fopen(LODrangefile,"wb");
      LR = LODroot;
      while(LR != NULL)
	{
	  ++i;
	  LR = LR->next;
	}
      SEEIT_fwrite_int(&i,otherout);
      LR = LODroot;
      LODindex = 1;
      while(LR != NULL)
	{
	  i = 0;
	  while(LR->range[i] != '\0')
            {
	      ++i;
            }
	  ++i;
	  SEEIT_fwrite_int(&i,otherout);
	  fwrite(&LR->range[0],1,i,otherout);
	  SEEIT_fwrite_int(&LR->numindices,otherout);
	  cel = LR->indices;
	  while(cel != NULL)
            {
	      SEEIT_fwrite_int(&cel->val,otherout);

              LL_to_Layer_Map[cel->val] = LODindex;
	      pel = cel;
	      cel = cel->next;
	      free(pel); 
            }
	  PR = LR;
	  LR = LR->next;
          ++LODindex;
	  free(PR->range);
	  free(PR);
	}
      fclose(otherout);
    }

   NALentries = (struct NListEntryPoints *) (malloc(sizeof(struct NListEntryPoints) * (MaximumECCcount + 5)));
   if(NALentries == NULL)
      {
      printf("insufficient remaining memory for attribution catalog creation\n");
      exit(-1);
      }
   j = MaximumECCcount + 5;
   for(i=0; i<j; i++)
      {
      NALentries[i].RB_Entry = NULL;
      }


   j = *SACfull * 2;

   for(i=0; i<*SACfull; i++)
      {
      *TtlNames += InsertIntoNameList(NArray[i].code,NArray[i].name,i,SzNL,SzEL);
      BuildOpenMenu(0.0,*SACfull+i,j,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0);
      }

   j = MaximumECCcount + 2;

   for(i=0; i<j; i++)
      {
         if(NALentries[i].RB_Entry != NULL)
            {
            RetrieveTreeInorder(NALentries[i].RB_Entry,NALentries[i].RB_Entry->root->left);
            }
      }

   for(i=0; i<j; i++)
      {
      if(NALentries[i].RB_Entry != NULL)
         TTF_RBTreeDestroy(NALentries[i].RB_Entry);   
      }

   free(NALentries);


   if(SCCdataArray == NULL)
      {
      FormatFromDynamicDefsFile(*TotalSCC);
      }

   SunRadianAngle = ((double) SunAngle * PI) / 180.0;
   SunTangent = tan(SunRadianAngle);
   d1 = sqrt(SunX*SunX + SunY*SunY);
   d2 = SunTangent * d1; /* z height at SunX,SunY, angle of SunAngle */
   d1 = sqrt(SunX*SunX + SunY*SunY + d2*d2); /* "dist" to sun?? */
   L1 = (double) SunX / d1;
   L2 = (double) (0 - SunY) / d1;
   L3 = d2 / d1;

   Xextent = (double) (XindexExtent);
   Yextent = (double) (YindexExtent); 

   PixPerRow = (int) floor((((double) ScrnMaxRow) / Xextent));
   PixPerCol = (int) floor((((double) ScrnMaxCol) / Yextent));
   if(PixPerRow > PixPerCol)
      PixPerLM = PixPerCol;
   else
      PixPerLM = PixPerRow;
   interval = floor(LRegionSize / ((double) PixPerLM));

   if(interval < 1)
      interval = 1;
   ImageSize = PixPerLM * PixPerLM;
   ImageSize = ImageSize * ((long int) Xextent);
   ImageSize = ImageSize * ((long int) Yextent);
   NumRows = (int) (Yextent * PixPerLM);
   NumCols = (int) (Xextent * PixPerLM);
   ShadedReliefSetUp();

   polyout = fopen(polyfile,"wb");

   polyin = fopen(Linfile,"rb");
   if(polyin == NULL)
      {
      printf("attempt to format: could not open polygon file %s\n",Linfile);
      printf("processing cannot continue without this input file\n");
      exit(-1);
      }

   PointsPerPixel = LRegionSize / ((double) PixPerLM);

   BuildOpenMenu(0.0,*SACfull*2, *SACfull*2, *polys_read, *polys_done,model_polys,areals_done,linears_done,points_done,
   sphere_cv,parallel_cv,stamps_done,footprints_done, bridges_done,g_read,g_write,
   FMpointsdone,FMlinesdone,FMarealsdone,0.0,0.0,0.0,0.0,0);

   readfileposn = ftell(polyin);
   SEEIT_fread_int(&ind1,polyin);
   while(feof(polyin) == 0)
      {
      cp = (struct RawPoly *) malloc(SzRP);
      if(cp == NULL)
         {
         printf("allocation memory exhausted during polygon format\n");
         exit(-1);
         }
      cp->next = NULL;
      cp->Lindex = ind1;
      SEEIT_fread_int(&cp->Sindex,polyin);
      SEEIT_fread_int(&cp->idn, polyin);
      SEEIT_fread_int(&cp->TblIdn, polyin);
      SEEIT_fread_int(&cp->numverts,polyin);
      ClassData[cp->Sindex].occurrences += 1;
      NArray[cp->Lindex].occurrences += 1;
      NArray[cp->Lindex].configcount[ClassData[cp->Sindex].C] += 1; /** bump polygon counter **/
      LongListInstances[cp->Lindex] += 1;
      if(LongToShortMap[cp->Lindex] < 0)
         LongToShortMap[cp->Lindex] = cp->Sindex;
      else if(LongToShortMap[cp->Lindex] != cp->Sindex)
         {
         printf("FATAL ERROR -- found one too many mappings from long to short list!!\n");
         printf("mapping long list index %d into both %d and %d on short list\n",cp->Lindex,
                 LongToShortMap[cp->Lindex],cp->Sindex);
         exit(-1);
         }
      cp->x = (double *) (malloc(cp->numverts * SzD));
      cp->y = (double *) (malloc(cp->numverts * SzD));
      cp->z = (double *) (malloc(cp->numverts * SzD));
      if((cp->x == NULL) || (cp->y == NULL) || (cp->z == NULL))
         {
         printf("allocation memory exhausted during polygon format\n");
         exit(-1);
         }
      maxX = maxY = 0.0;
      minX = MaxXcoord;
      minY = MaxYcoord;

      for(i=0; i<cp->numverts; i++)
         {
            SEEIT_fread_double(&cp->x[i],polyin);
            SEEIT_fread_double(&cp->y[i],polyin);
            SEEIT_fread_double(&cp->z[i],polyin);


         if(coordflag == 1) /** GDC ***/
            {
            cp->x[i] = (cp->x[i] - Xtranslation) * 100000.0;
            cp->y[i] = (cp->y[i] - Ytranslation) * 100000.0;
            }
         else if(coordflag == 2) /** UTM **/
            {
            cp->x[i] = cp->x[i] - Xtranslation;
            cp->y[i] = cp->y[i] - Ytranslation;
            }
         if(cp->x[i] < minX)
            minX = cp->x[i];
         if(cp->x[i] > maxX)
            maxX = cp->x[i];
         if(cp->y[i] < minY)
            minY = cp->y[i];
         if(cp->y[i] > maxY)
            maxY = cp->y[i];
         }


      pixcolor = SpecialDomainColors[SCCdataArray[cp->Sindex].D];




      *polys_read += 1;
      if((*polys_read % 100) == 0)
         BuildOpenMenu(0.0,*SACfull*2, *SACfull*2, *polys_read, *polys_done,model_polys,areals_done,linears_done,points_done,
               sphere_cv,parallel_cv,stamps_done,footprints_done, bridges_done,g_read,g_write,
               FMpointsdone,FMlinesdone,FMarealsdone,0.0,0.0,0.0,0.0,0);

      Sx = (int) floor((minX / LRegionSize));
      Ex = (int) floor((maxX / LRegionSize));
      Sy = (int) floor((minY / LRegionSize));
      Ey = (int) floor((maxY / LRegionSize));

      RminX = (double) Sx * LRegionSize;
      RminY = (double) Sy * LRegionSize;

      if((RminX == minX) && (Sx > 0))
         --Sx;
      if((RminY == minY) && (Sy > 0))
         --Sy;
      if((Sx == Ex) && (Sy == Ey)) /** single region poly **/
         {
         cp->next = NULL;
         ++SinglePolys;
         ind2 = (Sx * YindexExtent) + Sy;
         if(ConserveMemory == 0)
            {
            if(SingleRegionPolys[ind2].root == NULL)
               SingleRegionPolys[ind2].root = cp;
            else
               {
               pp = SingleRegionPolys[ind2].root;
               while(pp->next != NULL)
                  pp = pp->next;
               pp->next = cp;
               }
            }
         else
            {
            if(SingleRegionPolyRoot[ind2].count == 0)
               {
               SingleRegionPolyRoot[ind2].fileptr = readfileposn;
               SingleRegionPolyRoot[ind2].next = NULL;
               SingleRegionPolyRoot[ind2].count = 1;
               }
            else
               {
               srpr1 = (struct PtrList *) (malloc(SzPtrList));
	       if(srpr1 == NULL)
                  {
                  printf("Allocation memeory exhausted during polygon format\n");
                  printf("Terminating format operation\n");
                  exit(-1);
                  }
               srpr1->fileptr = readfileposn;
               srpr1->next = SingleRegionPolyRoot[ind2].next;
               SingleRegionPolyRoot[ind2].next = srpr1;
               SingleRegionPolyRoot[ind2].count += 1;
               }
            }
if(ind2 < listlength)
         InsertIntoSCCtable(0,ind2, cp->Lindex,cp->idn,-1);

         LocalPolyTable[ind2].numpoly += 1;

         if((ShadedReliefRequired) && (NGA_TYPE == 0))
            {
            si1 = 1;
            si2 = 2;
            if(cp->numverts > 3)
               {
               while(Three3DPointsAreColinear(cp->x[0],cp->y[0],cp->z[0], cp->x[si1],cp->y[si1],cp->z[si1],
                                    cp->x[si2],cp->y[si2],cp->z[si2]) > 0)
                  {
                  si1 = si2;
                  si2 += 1;
                  if(si2 >= cp->numverts) /** all vertices are colinear **/
                     break;
                  }
               }
            if(si2 < cp->numverts)
               {
               SurfNormal(cp->x[0],cp->y[0],cp->z[0], cp->x[si1],cp->y[si1],cp->z[si1],
                                    cp->x[si2],cp->y[si2],cp->z[si2], &N1,&N2,&N3);
               d1 = N1*L1 + N2*L2 + N3*L3;
               d2 = Ip * Kd * d1 * 63.0;
               if(d2 < 0) d2 = 0 - d2;
               if(d2 > 63)
                  {
                  printf("over range %f\n",d2);
                  d2 = 63;
                  }
               offx = (double) Sx * LRegionSize;
               offy = (double) Sy * LRegionSize;
               i1 = (int) floor((minX - offx) / PointsPerPixel);
               i2 = (int) ceil((maxX - offx) / PointsPerPixel);
               idiff = i2 - i1;
               j1 = (int) floor((minY - offy) / PointsPerPixel);
               j2 = (int) ceil((maxY - offy) / PointsPerPixel);
               jdiff = j2 - j1;
               offXpix = Sx * PixPerLM + i1;
               offYpix = Sy * PixPerLM + j1;
               for(i = 0; i<=idiff; i++)
                  {
                  px = offx + (double) (i1 + i) * PointsPerPixel;
                  for(j = 0; j<=jdiff; j++)
                     {
                     py = offy + (double) (j1 + j) * PointsPerPixel;
                     i2 = offXpix + i;
                     j2 = offYpix + j;
                     if(LocalPointInsidePoly(px,py,cp->x,cp->y,cp->numverts))
                        {
                        if((NGA_TYPE == 1) && (LandMarksSet > 0) && (pixcolor > 0))
                           {
                           PBM2[IM - j2].Row[i2].color = pixcolor;
                           }
                        PBM[IM - j2].Row[i2].color = (unsigned char) d2;
                        }
                     else if(PBM[IM - j2].Row[i2].color == InitColor)
                        {
                        if((NGA_TYPE == 1) && (LandMarksSet > 0) && (PBM2[IM - j2].Row[i2].color == InitColor) && (pixcolor > 0))
                           {
                           PBM2[IM - j2].Row[i2].color = pixcolor;
                           }
                        PBM[IM - j2].Row[i2].color = (unsigned char) d2;
                        }
                     }
                  }
               }
            }
         if(ConserveMemory == 1)
            {
            free(cp->x);
            free(cp->y);
            free(cp->z);
            free(cp);
            }
         }
      else if((Sx >= 0) && (Sy >= 0))/** multi-region poly **/
         {
         *polys_done += 1;
         ++MultiPolys;
         fileposn = ftell(polyout);
         SEEIT_fwrite_int(&cp->Lindex,polyout);
         SEEIT_fwrite_int(&cp->Sindex,polyout);
         SEEIT_fwrite_int(&cp->idn,polyout);
         SEEIT_fwrite_int(&cp->TblIdn,polyout);
         SEEIT_fwrite_int(&cp->numverts,polyout);
         for(i=0; i<cp->numverts; i++)
            {
            SEEIT_fwrite_double(&cp->x[i],polyout);
            SEEIT_fwrite_double(&cp->y[i],polyout);
            SEEIT_fwrite_double(&cp->z[i],polyout);
            }
         for(i=Sx; i<= Ex; i++)
            {
            for(j=Sy; j <= Ey; j++)
               {
               ind2 = (i * YindexExtent) + j;
if(ind2 < listlength)
{
               LocalPolyTable[ind2].numother += 1;
               plst = (struct PtrList *) (malloc(SzPtrList));
               plst->fileptr = fileposn;
               plst->next = LocalPolyTable[ind2].others;
               LocalPolyTable[ind2].others = plst;
               InsertIntoSCCtable(0,ind2, cp->Lindex,cp->idn,-1);
}
               }
            }

         if((NGA_TYPE == 0) && (ShadedReliefRequired) && (Sx >= 0) && (Sy >= 0))
            {
            si1 = 1;
            si2 = 2;
            if(cp->numverts > 3)
               {
               while(Three3DPointsAreColinear(cp->x[0],cp->y[0],cp->z[0], cp->x[si1],cp->y[si1],cp->z[si1],
                                    cp->x[si2],cp->y[si2],cp->z[si2]) > 0)
                  {
                  si1 = si2;
                  si2 += 1;
                  if(si2 >= cp->numverts) /** all vertices are colinear **/
                     break;
                  }
               }
            if(si2 < cp->numverts)
               {
               SurfNormal(cp->x[0],cp->y[0],cp->z[0], cp->x[si1],cp->y[si1],cp->z[si1],
                                    cp->x[si2],cp->y[si2],cp->z[si2], &N1,&N2,&N3);
               d1 = N1*L1 + N2*L2 + N3*L3;
               d2 = Ip * Kd * d1 * 63.0;
               if(d2 < 0) d2 = 0 - d2;
               if(d2 > 63)
                  {
                  printf("over range %f\n",d2);
                  d2 = 63;
                  }
               for(Sxi = Sx; Sxi <= Ex; Sxi++)
                  {
                  offx = (double) Sxi * LRegionSize;
                  if(Sxi == Sx)
                     i1 = (int) floor((minX - offx) / PointsPerPixel);
                  else
                     i1 = 0;
                  if(Sxi == Ex)
                     i2 = (int) ceil((maxX - offx) / PointsPerPixel);
                  else
                     i2 = PixPerLM;
                  idiff = i2 - i1;
                  offXpix = Sxi * PixPerLM + i1;
                  for(Syj = Sy; Syj <= Ey; Syj++)
                     {
                     offy = (double) Syj * LRegionSize;
                     if(Syj == Sy)
                        j1 = (int) floor((minY - offy) / PointsPerPixel);
                     else
                        j1 = 0;
                     if(Syj == Ey)
                        j2 = (int) ceil((maxY - offy) / PointsPerPixel);
                     else
                        j2 = PixPerLM;
                     jdiff = j2 - j1;
                     offYpix = Syj * PixPerLM + j1;
                     for(i = 0; i<=idiff; i++)
                        {
                        px = offx + (double) (i1 + i) * PointsPerPixel;
                        for(j = 0; j<=jdiff; j++)
                           {
                           py = offy + (double) (j1 + j) * PointsPerPixel;
                           if(LocalPointInsidePoly(px,py,cp->x,cp->y,cp->numverts))
                              {
                              i2 = offXpix + i;
                              j2 = offYpix + j;
                              if((NGA_TYPE == 1) && (LandMarksSet > 0) && (pixcolor > 0))
                                 {
                                 PBM2[IM - j2].Row[i2].color = pixcolor;
                                 }
                              PBM[IM - j2].Row[i2].color = (unsigned char) d2;
                              }
                           }
                        }
                     }
                  }
               }
            }
         free(cp->x);
         free(cp->y);
         free(cp->z);
         free(cp);
         }

         readfileposn = ftell(polyin);

         SEEIT_fread_int(&ind1,polyin);
      }

   if(ConserveMemory == 0)
      {
      fclose(polyin);

      for(i=0; i<listlength; i++)
         {
         cp = SingleRegionPolys[i].root;
         LocalPolyTable[i].fileptr = ftell(polyout);
         while(cp != NULL)
            {
            *polys_done += 1;
            SEEIT_fwrite_int(&cp->Lindex,polyout);
            SEEIT_fwrite_int(&cp->Sindex,polyout);
            SEEIT_fwrite_int(&cp->idn,polyout);
            SEEIT_fwrite_int(&cp->TblIdn,polyout);
            SEEIT_fwrite_int(&cp->numverts,polyout);
            for(j=0; j<cp->numverts; j++)
               {
               SEEIT_fwrite_double(&cp->x[j],polyout);
               SEEIT_fwrite_double(&cp->y[j],polyout);
               SEEIT_fwrite_double(&cp->z[j],polyout);
               }
            pp = cp;
            cp = cp->next;
            free(pp->x);
            free(pp->y);
            free(pp->z);
            free(pp); 

            if((*polys_done % 100) == 0)
               BuildOpenMenu(0.0,*SACfull*2, *SACfull*2, *polys_read, *polys_done,model_polys,areals_done,linears_done,points_done,
                     sphere_cv,parallel_cv,stamps_done,footprints_done, bridges_done,g_read,g_write,
                     FMpointsdone,FMlinesdone,FMarealsdone,0.0,0.0,0.0,0.0,0);

            }
         }
      free(SingleRegionPolys);
      }
   else
      {
      rewind(polyin);
      for(i=0; i<listlength; i++)
         {
         if(SingleRegionPolyRoot[i].fileptr >= 0)
            {
            srpr1 = &SingleRegionPolyRoot[i];
            fseek(polyin,srpr1->fileptr,SEEK_SET);
            LocalPolyTable[i].fileptr = ftell(polyout);
            while(srpr1 != NULL)
               {
               fseek(polyin,srpr1->fileptr,SEEK_SET);
               *polys_done += 1;

               SEEIT_fread_int(&i1,polyin);
               SEEIT_fwrite_int(&i1,polyout); /*** Lindex **/
               SEEIT_fread_int(&i1,polyin);
               SEEIT_fwrite_int(&i1,polyout); /*** Sindex **/
               SEEIT_fread_int(&i1,polyin);
               SEEIT_fwrite_int(&i1,polyout); /*** idn **/
               SEEIT_fread_int(&i1,polyin);
               SEEIT_fwrite_int(&i1,polyout); /*** TblIdn **/
               SEEIT_fread_int(&i1,polyin);
               SEEIT_fwrite_int(&i1,polyout); /*** numverts **/

               for(j=0; j<i1; j++) /** i1 is still numverts from read ***/
                  {
                  SEEIT_fread_double(&d1,polyin); /** x[j] value **/
                  d1 = d1 - Xtranslation;
                  if(coordflag == 1) /** GDC ***/
                     {
                     d1 = d1 * 100000.0;
                     }
                  SEEIT_fwrite_double(&d1,polyout); /*** write translated x[j] value ***/

                  SEEIT_fread_double(&d1,polyin); /** read y[j] value ***/
                  d1 = d1 - Ytranslation;
                  if(coordflag == 1) /** GDC ***/
                     {
                     d1 = d1 * 100000.0;
                     }
                  SEEIT_fwrite_double(&d1,polyout); /*** write translated y[j] value ***/

                  SEEIT_fread_double(&d1,polyin);  /*** read z[j] value ***/
                  SEEIT_fwrite_double(&d1,polyout); /*** write z[j] value ***/
                  }

               srpr1 = srpr1->next;

               if((*polys_done % 100) == 0)
                  BuildOpenMenu(0.0,*SACfull*2, *SACfull*2, *polys_read, *polys_done,model_polys,areals_done,linears_done,points_done,
                        sphere_cv,parallel_cv,stamps_done,footprints_done, bridges_done,g_read,g_write,
                        FMpointsdone,FMlinesdone,FMarealsdone,0.0,0.0,0.0,0.0,0);
               }
            }
         srpr1 = SingleRegionPolyRoot[i].next;
         while(srpr1 != NULL)
            {
            srpr2 = srpr1;
            srpr1 = srpr1->next;
            free(srpr2);
            }
         }
      free(SingleRegionPolyRoot);

      fclose(polyin);
      }

   fclose(polyout);


   tableout = fopen(tablefile,"wb");
   for(i=0; i<listlength; i++)
      {
      SEEIT_fwrite_int(&LocalPolyTable[i].numpoly,tableout);
      SEEIT_fwrite_long(&LocalPolyTable[i].fileptr,tableout);
      SEEIT_fwrite_int(&LocalPolyTable[i].numother,tableout);
      plst = LocalPolyTable[i].others;
      while(plst != NULL)
         {
         clst = plst;
         plst = plst->next;
         SEEIT_fwrite_long(&clst->fileptr,tableout);
         free(clst);
         }
      }
   fclose(tableout);
   free(LocalPolyTable); 

   BuildOpenMenu(0.0,*SACfull*2, *SACfull*2, *polys_read, *polys_done,model_polys,areals_done,linears_done,points_done,
         sphere_cv,parallel_cv,stamps_done,footprints_done, bridges_done,g_read,g_write,
         FMpointsdone,FMlinesdone,FMarealsdone,0.0,0.0,0.0,0.0,0);
   
   header = fopen(headerout,"ab");
   if(header == NULL)
      {
      printf("attempt to format: could not open polygon file %s\n",headerout);
      printf("processing cannot continue without this input file\n");
      exit(-1);
      }

   SEEIT_fwrite_double(&LRegionSize,header);
   SEEIT_fwrite_double(&MinXcoord,header);
   SEEIT_fwrite_double(&MinYcoord,header);
   SEEIT_fwrite_double(&MaxXcoord,header);
   SEEIT_fwrite_double(&MaxYcoord,header);
XindexExtent -= 1;
YindexExtent -= 1;
   SEEIT_fwrite_int(&XindexExtent,header);
   SEEIT_fwrite_int(&YindexExtent,header);
   SEEIT_fwrite_double(&Xtranslation,header);
   SEEIT_fwrite_double(&Ytranslation,header);
   fclose(header);

   return(coordflag);
}


void DrawTopLevelImageArea(struct AreaAndHoles *aa)
{
  extern void ProcessTopLevel(struct AreaAndHoles *areafeature,double *X,double *Y,int numverts,
			      double x,double y,int layer, int geomtype);
  
  ProcessTopLevel(aa,NULL,NULL,-1,-1,-1,aa->Lindex,C_AREA);
}


void DrawTopLevelImageGridOutline(double *x, double *y, int layer)
{
  extern void ProcessTopLevel(struct AreaAndHoles *areafeature,double *X,double *Y,int numverts,
			      double x,double y,int layer, int geomtype);
  
  ProcessTopLevel(NULL,x,y,4,-1,-1,layer,C_GRID);
}


void DrawTopLevelImageLine(double *x, double *y, int numverts, int layer)
{
  extern void ProcessTopLevel(struct AreaAndHoles *areafeature,double *X,double *Y,int numverts,
			      double x,double y,int layer, int geomtype);
  
  ProcessTopLevel(NULL,x,y,numverts,-1,-1,layer,C_LINE);
}

void DrawTopLevelImagePoint(double x, double y, int layer)
{
  extern void ProcessTopLevel(struct AreaAndHoles *areafeature,double *X,double *Y,int numverts,
			      double x,double y,int layer, int geomtype);
  
  ProcessTopLevel(NULL,NULL,NULL,-1,x,y,layer,C_POFE);
}



void DrawPGMlines(double dsx, double dsy, double dex, double dey, unsigned char pixcolor)
{
int i,j;
int sx, sy, ex, ey;
double dx, dy, td, tdy, tdx;
int IM = ImageMaxSize - 1;

   if(NGA_TYPE == 1)
      return;

   sx = (int) dsx;
   sy = (int) dsy;
   ex = (int) dex;
   ey = (int) dey;
   if((sx == ex) && (sy == ey))
      PBM2[IM - sy].Row[sx].color = pixcolor;
   else if(sx == ex)
      {
      if(ey > sy)
         {
         for(i = sy; i<=ey; i++)
            PBM2[IM - i].Row[sx].color = pixcolor;
         }
      else
         {
         for(i = sy; i>=ey; i--)
            PBM2[IM - i].Row[sx].color = pixcolor;
         }
      }
   else if(sy == ey)
      {
      if(ex > sx)
         {
         for(i = sx; i<=ex; i++)
            PBM2[IM - sy].Row[i].color = pixcolor;
         }
      else
         {
         for(i = sx; i>=ex; i--)
            PBM2[IM - sy].Row[i].color = pixcolor;
         }
      }
   else
      {
      if(ex > sx)
         {
         dx = dex - dsx;
         dy = dey - dsy;
         td = dy / dx;
         tdy = dsy;
         for(i=sx; i<= ex; i++)
            {
            j = (int) (tdy + 0.5);
            PBM2[IM - j - 1].Row[i].color = pixcolor;
            tdy += td;
            }
         }
      else
         {
         dx = dsx - dex;
         dy = dsy - dey;
         td = dy / dx;
         tdy = dey;
         for(i=ex; i<= sx; i++)
            {
            j = (int) (tdy + 0.5);
            PBM2[IM - j].Row[i].color = pixcolor;
            tdy += td;
            }
         }

      if(ey > sy)
         {
         dx = dex - dsx;
         dy = dey - dsy;
         td = dx / dy;
         tdx = dsx;
         for(j=sy; j<= ey; j++)
            {
            i = (int) (tdx + 0.5);
            PBM2[IM - j].Row[i].color = pixcolor;
            tdx += td;
            }
         }
      else
         {
         dx = dsx - dex;
         dy = dsy - dey;
         td = dx / dy;
         tdx = dex;
         for(j=ey; j<= sy; j++)
            {
            i = (int) (tdx + 0.5);
            PBM2[IM - j].Row[i].color = pixcolor;
            tdx += td;
            }
         }
      }
}


void LocalByteSwapInt(char *data)
{
char c;
c = data[0];
data[0] = data[3];
data[3] = c;

c = data[1];
data[1] = data[2];
data[2] = c;

}


void LocalByteSwapDouble(char *data)
{
char c;
c = data[0];
data[0] = data[7];
data[7] = c;

c = data[1];
data[1] = data[6];
data[6] = c;

c = data[2];
data[2] = data[5];
data[5] = c;

c = data[3];
data[3] = data[4];
data[4] = c;

}



void FormatAreals(int SACttl,unsigned char CoordSystem, int TotalSCC, int polys_read, int polys_done,
                 int model_polys, int *areals_done,int linears_done,int points_done,
                 int sphere_cv,int parallel_cv,int stamps_done,int footprints_done,
                 int bridges_done, unsigned int g_read, unsigned int g_write, int FMpointsdone, int FMlinesdone, int *FMarealsdone)
{
struct Vertex
{
double x;
double y;
double z;
};
struct LocalRawAreal
   {
   int featureid;
   int ishole;
   int Lindex;
   int Sindex;
   int idn;
   int numverts;
   struct Vertex *coord;
   struct LocalRawAreal * next;
   } ;

FILE *arealin;
int IM = ImageMaxSize - 1;
FILE *tableout;
FILE *dataout;
FILE *intermediate;

int SzRP = sizeof(struct LocalRawAreal);
int SzAL;
int SzPtrList = sizeof(struct ObjPtrList);
int SzV = sizeof(struct Vertex);
struct LocalRawAreal *cp, *pp, *parent;
struct ObjPtrList *plst, *clst;
int LastArealID;
int ii,i,j,listlength,ix,iy, i1,j1;
int i0, j0, i2, j2, i3, j3;
int i4, i5, j4, j5, i6;
int SingleAreals,MultiAreals;
int USA, UMA, USAh, UMAh;
int ind1, MonsterPoly;
int XindexExtent, YindexExtent;
long int fileposn;
int outfilenumber, infilenumber;
long int outfilesize;

int Sx,Sy,Ex,Ey, inside;
double minX, minY, maxX, maxY;
double minx1,maxx1,miny1,maxy1;
double dNumCols, dNumRows;
double d1,d2,d3,d4;
double dx1,dy1,dx2,dy2, Xint,Yint;
int NumArealFiles;
int LastParentIsMulti;
int featureID, IsHole, HolesThisAreal;
short int *XscaledPts;
short int *YscaledPts;

short int colornudge;
double *Xmap;
double *Ymap;
int NumMapVerts;

int MaxVerts = 15000;
unsigned char pixcolor;
double px,py;
char suffix[5];
char afilein[200];
char afileout[200];
char afileIntermed[200];
int *IntermediateIndex;
int MaxBytes = 0;
char junk[250];
int ArealsRead = 0;
/**int arealsalloc = 0;
int vertsalloc = 0; **/
long int ftellCalc = 0;
long int parentseekposn = -1;
long int saveseekposn;
int ParentID;
struct AreaLookup
   {
   int numpoly;
   int numholes;
   struct LocalRawAreal * inside;
   /**int *insideindices;**/
   int numother;
   long int fileptr;
   int filenumber;
   struct ObjPtrList *others;
   } * ArealTable;
struct InFiles
{
   FILE * fp;
} *InFileHandles;
 
extern void ScalePolygon(int lwidth, int lheight, short int *Xpt, short int *Ypt, int numpoints);
extern unsigned char PolyPixels[2500][2500];
extern int AREALNODELIMIT;
void * ReadStuff;
double *Xvertex;
double *Yvertex;
int minIindex, minJindex;
struct AreaRing *ringc, *ringp;
struct AreaAndHoles *aa;
int SzAH = sizeof(struct AreaAndHoles);
int SzAR = sizeof(struct AreaRing);
int SzMP = sizeof(struct MonsterP);


   aa = (struct AreaAndHoles *) (malloc(SzAH));
   if(aa == NULL)
      {
      printf("memory has been totally consumed top-level image drawing area feature inner and outer rings\n");
      exit(-1);
      }
   aa->outer = NULL;
   aa->inner = NULL;
   aa->numholes = 0;

   strcpy(afilein,indirectory);
   strcat(afilein,"arealinfo.txt");
   HolesThisAreal = 0;
   USA = UMA = USAh = UMAh = 0;

   arealin = fopen(afilein,"rt");
   if(arealin == NULL)
      {
      printf("No associated file of areal data meta information (%s is missing)\n",afilein);
      return;
      }
   TotalArealObjects = 0;
   NumArealFiles = 0;

   MPoc = AreaMProot;
   while(MPoc != NULL)
      {
      MPoc->used = 0;
      MPoc = MPoc->next;
      }

   MonsterRoot = Mn = NULL;


   fgets(junk,99,arealin);
   while(feof(arealin) == 0)
      {
      sscanf(junk,"%d", &i);
      TotalArealObjects += i;
      ++NumArealFiles;
      fgets(junk,99,arealin);
      }
   fclose(arealin);
   if(TotalArealObjects > 0)
      {
      if(NumArealFiles > 1)
         printf("starting to process %d areal features from %d files\n",TotalArealObjects,NumArealFiles);
      else
         printf("starting to process %d areal features\n",TotalArealObjects);
      }

   InFileHandles = (struct InFiles *) (malloc(sizeof(struct InFiles) * NumArealFiles));
   if(InFileHandles == NULL)
      {
      printf("memory has been exhausted during allocation of areal input file handles\n");
      printf("attempt to allocate memory for %d file handles has failed\n",NumArealFiles);
      exit(-1);
      }
   for(infilenumber=1; infilenumber<=NumArealFiles; infilenumber++)
      {
      if(infilenumber > 1)
        {
        i4 = 0;
        i5 = 0;
        while(arealfile[i4] != '\0')
           {
           afilein[i5] = arealfile[i4];
           ++i4;
           ++i5;
           }

        while((i5 > 0) && (afilein[i5] != '.'))
           --i5;

        sprintf(&afilein[i5],"%d",infilenumber);
        strcat(afilein,".bin");
        InFileHandles[infilenumber-1].fp = fopen(afilein,"rb");
        if(InFileHandles[infilenumber-1].fp == NULL)
           {
           printf("(1) fatal error when reopening areal input file %s\n", afilein);
           exit(-1);
           }
         }
      else
         {
         InFileHandles[infilenumber-1].fp = fopen(arealfile,"rb");
         if(InFileHandles[infilenumber-1].fp == NULL)
            {
            printf("(2) fatal error when reopening areal input file %s\n", arealfile);
            exit(-1);
            }
         }
      }

   XscaledPts = (short int *) (malloc(SzShort * MaxVerts));
   YscaledPts = (short int *) (malloc(SzShort * MaxVerts));
   Xvertex = (double *) (malloc(SzD * MaxVerts));
   Yvertex = (double *) (malloc(SzD * MaxVerts));
   if(Yvertex == NULL)
      {
      printf("available memory has been exhausted during areal format oeration\n");
      exit(-1);
      }
   Xmap = (double *) (malloc(SzD * MaxVerts));
   if(Xmap == NULL)
      {
      printf("all memory has been consumed during area feature format operation\n");
      printf(" please create a smaller GAIT project and restart\n");
      printf("   (attempt to allocate area feature with %d vertices failed)\n",MaxVerts);
      exit(-1);
      }
   Ymap = (double *) (malloc(SzD * MaxVerts));
   if(Ymap == NULL)
      {
      printf("all memory has been consumed during area feature format operation\n");
      printf(" please create a smaller GAIT project and restart\n");
      exit(-1);
      }


   arealin = InFileHandles[0].fp;
   if(arealin == NULL)
      {
      printf("No associated file of areal data (%s is missing)\n",arealfile);
      return;
      }

   infilenumber = 1;
   if(NGA_TYPE == 1)
      BuildOpenMenu(0.0,SACttl*2,SACttl*2,linears_done,ArealsRead,model_polys,*areals_done,linears_done,points_done,
          sphere_cv,parallel_cv,stamps_done,footprints_done, bridges_done,g_read,g_write,
          FMpointsdone,FMlinesdone,*FMarealsdone,0.0,0.0,0.0,0.0,0);
   else
      BuildOpenMenu(0.0,SACttl*2,SACttl*2,polys_read,polys_done,model_polys,*areals_done,linears_done,points_done,
          sphere_cv,parallel_cv,stamps_done,footprints_done, bridges_done,g_read,g_write,
          FMpointsdone,FMlinesdone,*FMarealsdone,0.0,0.0,0.0,0.0,0);

   colornudge = 0;
   if(SCCdataArray == NULL)
      {
      FormatFromDynamicDefsFile(TotalSCC);
      colornudge = -15;
      }

   dataout = fopen(arealdata,"wb");
   outfilesize = 0;
   outfilenumber = 0;

   XindexExtent = (int) (MaxXcoord / LRegionSize) + 2;
   YindexExtent = (int) (MaxYcoord / LRegionSize) + 2;

   listlength = XindexExtent * YindexExtent;

   SzAL = sizeof(struct AreaLookup);
   ArealTable = (struct AreaLookup *) (malloc(SzAL * listlength));
   if(ArealTable == NULL)
      {
      printf("allocation memory exhausted during areal processing (file %s)\n",arealfile);
      exit(-1);
      }

   LastArealID = -1;
   for(i=0; i<listlength; i++)
      {
      ArealTable[i].numpoly = 0;
      ArealTable[i].numholes = 0;
      ArealTable[i].inside = NULL;
      ArealTable[i].numother = 0;
      /***ArealTable[i].fileptr = (int) NULL; ***/
      ArealTable[i].fileptr = 0;
      ArealTable[i].filenumber = -1;
      ArealTable[i].others = NULL;
      }
ii=0;
   printf("processing areal data from file %s\n",arealfile);
   dNumCols = PointsPerPixel;
   dNumRows = PointsPerPixel;

   CutOutRoot = NULL;

   LastParentIsMulti = -1;

   NumAreaHoles = 0;

   SEEIT_fread_int(&featureID,arealin);
   while(feof(arealin) == 0)
      {
      if(NGA_TYPE == 1)
         {
         ++ArealsRead;
         }
      cp = (struct LocalRawAreal *) malloc(SzRP);
      if(cp == NULL)
         {
         printf("allocation memory exhausted during areal format\n");
         exit(-1);
         }
      cp->next = NULL;

      cp->featureid = featureID;

      SEEIT_fread_int(&IsHole,arealin);
      cp->ishole = IsHole;

if((IsHole < 0) || (IsHole > 2))
{
printf("unexpected hole value read %d\n",IsHole);
exit(-1);
}
      SEEIT_fread_int(&ind1,arealin);
      cp->Lindex = ind1;
      SEEIT_fread_int(&cp->Sindex,arealin);
      if(LongToShortMap[cp->Lindex] < 0)
         LongToShortMap[cp->Lindex] = cp->Sindex;
      else if(LongToShortMap[cp->Lindex] != cp->Sindex)
         {
         printf("FATAL ERROR -- found one too many mappings from long to short list!\n");
         printf("mapping long list index %d into both %d and %d on short list\n",cp->Lindex,
                 LongToShortMap[cp->Lindex],cp->Sindex);
         exit(-1);
         }
      SEEIT_fread_int(&cp->idn,arealin);

      if(IsHole >= 1)
         {
         ++NumAreaHoles;
         HolesThisAreal += 1;
if(ParentID != cp->idn)
{
printf("mismatch between parent id and hole \n");
exit(-1);
}
         if(NGA_TYPE == 1)
            --ArealsRead;
         }
      else
         {
         if(HolesThisAreal > 0)
            {
            if((parent == NULL) && (parentseekposn >= 0))
               {
               saveseekposn = ftell(dataout);
               fseek(dataout,parentseekposn,SEEK_SET);
               HolesThisAreal = 0 - HolesThisAreal;
               SEEIT_fwrite_int(&HolesThisAreal,dataout);
               fseek(dataout,saveseekposn,SEEK_SET);
               }
            else
               {
if(parent == NULL)
{
printf("ERROR! trying to assign based on a null parent pointer\n");
exit(-1);
}
               parent->ishole = 0 - HolesThisAreal;
               }
            }
         parent = cp;
         parentseekposn = -1;
ParentID = cp->idn;
         HolesThisAreal = 0;
         }


      if(cp->ishole <= 0) /*** was if(cp->ishole != 1)  ***/
         {
         MPoc = AreaMProot;
         while(MPoc != NULL)
            {
            if(MPoc->featureid == cp->idn)
               {
               if(MPoc->used > 0)
                  --ArealsRead;
               else
                  {
                  MPoc->ECC = ClassData[cp->Sindex].ECC;
                  if(IDHfp != NULL)    /*** no need to inspect UID on a hole - will do the parent only  ***/
                     {
                     InspectUID(cp->Lindex,cp->idn, cp->featureid, "Area");
                     }
                  }

               MPoc->used += 1;
               break;
               }
            MPoc = MPoc->next;
            }
         if((MPoc == NULL) && (IDHfp != NULL))
            {
            InspectUID(cp->Lindex,cp->idn, cp->featureid, "Area");
            }
         }

      SEEIT_fread_int(&cp->numverts,arealin);
      if(NGA_TYPE == 1)
         {
         if(ArealsRead == 1)
            {
            MaxAreaVerts = MinAreaVerts = cp->numverts;
            }
         else
            {
            if(cp->numverts > MaxAreaVerts)
               MaxAreaVerts = cp->numverts;
            if(cp->numverts < MinAreaVerts)
               MinAreaVerts = cp->numverts;
            }
         }

         
      cp->coord = (struct Vertex *) (malloc(cp->numverts * SzV));
      if(cp->coord == NULL)
         {
         printf("allocation memory exhausted during areal format\n");
         exit(-1);
         }
         
      maxX = maxY = 0.0;
      minX = MaxXcoord;
      minY = MaxYcoord;
      for(i=0; i<cp->numverts; i++)
         {
         SEEIT_fread_double(&cp->coord[i].x,arealin);
         SEEIT_fread_double(&cp->coord[i].y,arealin);
         SEEIT_fread_double(&cp->coord[i].z,arealin);
            
         if(CoordSystem == 1) /** GDC ***/
            {
            cp->coord[i].x = (cp->coord[i].x - Xtranslation) * 100000.0;
            cp->coord[i].y = (cp->coord[i].y - Ytranslation) * 100000.0;
            }
         else if(CoordSystem == 2) /** UTM **/
            {
            cp->coord[i].x = cp->coord[i].x - Xtranslation;
            cp->coord[i].y = cp->coord[i].y - Ytranslation;
            }
         if(cp->coord[i].x < minX)
            minX = cp->coord[i].x;
         if(cp->coord[i].x > maxX)
            maxX = cp->coord[i].x;
         if(cp->coord[i].y < minY)
            minY = cp->coord[i].y;
         if(cp->coord[i].y > maxY)
            maxY = cp->coord[i].y;
         }

      if(NGA_TYPE == 1)
         {
         if(cp->ishole >= 1)
            {
            ringc = (struct AreaRing *) (malloc(SzAR));
            if(ringc == NULL)
               {
               printf("memory has been totally consumed top-level image drawing area feature inner ring allocation\n");
               exit(-1);
               }
            ringc->x = (double *) (malloc(cp->numverts * SzD));
            ringc->y = (double *) (malloc(cp->numverts * SzD));
            if(ringc->y == NULL)
               {
               printf("memory has been totally consumed top-level image drawing area feature inner ring allocation\n");
               exit(-1);
               }
            ringc->numverts = cp->numverts;
            for(i=0; i<cp->numverts; i++)
               {
               ringc->x[i] = cp->coord[i].x;
               ringc->y[i] = cp->coord[i].y;
               }
            ringc->next = aa->inner;
            aa->inner = ringc;
            aa->numholes += 1;
            }
         else
            {
            if(aa->outer != NULL)
               {
               DrawTopLevelImageArea(aa);
               }
            ringc = aa->inner;
            while(ringc != NULL)
               {
               ringp = ringc;
               ringc = ringc->next;
               free(ringp->x);
               free(ringp->y);
               free(ringp);
               }
            aa->inner = NULL;
         
            ringc = aa->outer;
            if(ringc != NULL)
               {
               free(ringc->x);
               free(ringc->y);
               free(ringc);
               }

            ringc = (struct AreaRing *) (malloc(SzAR));
            if(ringc == NULL)
               {
               printf("memory has been totally consumed top-level image drawing area feature inner ring allocation\n");
               exit(-1);
               }
            ringc->x = (double *) (malloc(cp->numverts * SzD));
            ringc->y = (double *) (malloc(cp->numverts * SzD));
            if(ringc->y == NULL)
               {
               printf("memory has been totally consumed top-level image drawing area feature inner ring allocation\n");
               exit(-1);
               }

            aa->numholes = 0;
            aa->Lindex = LL_to_Layer_Map[cp->Lindex];

            ringc->numverts = cp->numverts;

            for(i=0; i<cp->numverts; i++)
               {
               ringc->x[i] = cp->coord[i].x;
               ringc->y[i] = cp->coord[i].y;
               }
            ringc->next = NULL;
            aa->outer = ringc;
            }
         }

         if(NGA_TYPE == 0)
            {
            ClassData[cp->Sindex].occurrences += 1;
            NArray[cp->Lindex].occurrences += 1;
            NArray[cp->Lindex].configcount[ClassData[cp->Sindex].C] += 1; /** bump areal counter **/
            LongListInstances[cp->Lindex] += 1;
            }
         else if(NGA_TYPE == 1)
            {
            if(cp->ishole <= 0)
               {
               if((MPoc == NULL) || ((MPoc != NULL) && (MPoc->used == 1)))
                  {
                  ClassData[cp->Sindex].occurrences += 1;
                  NArray[cp->Lindex].occurrences += 1;
                  NArray[cp->Lindex].configcount[ClassData[cp->Sindex].C] += 1; /** bump areal counter **/
                  LongListInstances[cp->Lindex] += 1;
                  }
               }
            else
               {
               NArray[cp->Lindex].areaholes += 1;
               }
            }
         if(SCCdataArray[cp->Sindex].C == 1)
            {
            if(NGA_TYPE == 0)
               *areals_done += 1;
            }
         else if(SCCdataArray[cp->Sindex].C == 15)
            *FMarealsdone += 1;

      if((LastArealID != cp->idn) || (cp->idn < 0))
         {
         if(NGA_TYPE == 1)
            BuildOpenMenu(0.0,SACttl*2,SACttl*2,linears_done,ArealsRead,model_polys,*areals_done,linears_done,points_done,
                sphere_cv,parallel_cv,stamps_done,footprints_done, bridges_done,g_read,g_write,
                FMpointsdone,FMlinesdone,*FMarealsdone,0.0,0.0,0.0,0.0,0);
         else
            BuildOpenMenu(0.0,SACttl*2,SACttl*2,polys_read,polys_done,model_polys,*areals_done,linears_done,points_done,
                sphere_cv,parallel_cv,stamps_done,footprints_done, bridges_done,g_read,g_write,
                FMpointsdone,FMlinesdone,*FMarealsdone,0.0,0.0,0.0,0.0,0);
         }
      LastArealID = cp->idn;

         if(cp->numverts >= MaxVerts)
            {
            MaxVerts = cp->numverts + 10; 
            Xvertex = (double *) (realloc(Xvertex, SzD * MaxVerts));
            Yvertex = (double *) (realloc(Yvertex, SzD * MaxVerts));
            Xmap = (double *) (realloc(Xmap, SzD * MaxVerts));
            Ymap = (double *) (realloc(Ymap, SzD * MaxVerts));
            XscaledPts = (short int *) (realloc(XscaledPts, SzShort * MaxVerts));
            YscaledPts = (short int *) (realloc(YscaledPts, SzShort * MaxVerts));
            if(YscaledPts == NULL)
              {
              printf("all available memory has been consumed during re-allocation of scaled points\n");
              exit(-1);
              }
            }



         i1 = 0;
         if((ShadedReliefRequired) && (LandMarksSet > 0) && (DO_LINES))
            {
            switch (SCCdataArray[cp->Sindex].D)
               {
               case D_NONE: 
                  i1 = 0;
                  break;
               default:
                  i1 = 1;
                  break;
               }
            }

         if(NGA_TYPE==1)
          {
           i1 = 1;
	  }
    

         if((i1 > 0) && (cp->numverts > 1) && (NGA_TYPE == 0))
            {

	      pixcolor = SpecialDomainColors[SCCdataArray[cp->Sindex].D];
            NumMapVerts = 1;
            minx1 = maxx1 = Xmap[0] = (double) ((int) (cp->coord[0].x / dNumCols + 0.5));
            miny1 = maxy1 = Ymap[0] = (double) ((int) (cp->coord[0].y / dNumRows + 0.5));
            i2 = 0;
            for(i1 = 1; i1< cp->numverts; i1++)
               {
               Xmap[NumMapVerts] = (double) ((int) (cp->coord[i1].x / dNumCols + 0.5));
               Ymap[NumMapVerts] = (double) ((int) (cp->coord[i1].y / dNumRows + 0.5));

               if((Xmap[i2] != Xmap[NumMapVerts]) || (Ymap[i2] != Ymap[NumMapVerts]))
                  {
                  ++NumMapVerts;
                  ++i2;
                  if(Xmap[i2] < minx1)
                     minx1 = Xmap[i2];
                  if(Xmap[i2] > maxx1)
                     maxx1 = Xmap[i2];
                  if(Ymap[i2] < miny1)
                     miny1 = Ymap[i2];
                  if(Ymap[i2] > maxy1)
                     maxy1 = Ymap[i2];
                  }
               }
            if((NumMapVerts > 1) &&
                   (Xmap[NumMapVerts - 1] == Xmap[0]) && (Ymap[NumMapVerts-1] == Ymap[0]))
               --NumMapVerts;

            if(NumMapVerts == 1)
               {
               i1 = (int) Xmap[0];
               j1 = (int) Ymap[0];
               PBM2[IM - j1].Row[i1].color = pixcolor;
               }
            else if(NumMapVerts == 2)
               {
               DrawPGMlines(Xmap[0], Ymap[0], Xmap[1], Ymap[1], pixcolor);
               }
            else if((NumMapVerts > 2) && (DO_LINES > 0))
               {
               i1 = 0;
               for(i2 = 1; i2 <NumMapVerts; i2++)
                  {
                  DrawPGMlines(Xmap[i1], Ymap[i1], Xmap[i2], Ymap[i2], pixcolor);
                  ++i1;
                  }
               --i2;
               DrawPGMlines(Xmap[0], Ymap[0], Xmap[i2], Ymap[i2], pixcolor);
               }
            else if(NumMapVerts > 2)
               {
               for(px = minx1; px < maxx1; px += 1.0)
                  {
                  i1 = (int) px;
                  for(py = miny1; py < maxy1; py += 1.0)
                     {
                     if(LocalPointInsidePoly(px,py,Xmap,Ymap,NumMapVerts))
                        {
                        j1 = (int) py;
                        PBM2[IM - j1].Row[i1].color = pixcolor;
                        }
                     }
                  }
               }

            if(colornudge == 15)
               colornudge = -15;
            else
               ++colornudge;
            }

      inside = 0;
      Sx = (int) (minX / LRegionSize);
      Ex = (int) (maxX / LRegionSize);
      Sy = (int) (minY / LRegionSize);
      Ey = (int) (maxY / LRegionSize);

     if((cp->ishole > 0) && (LastParentIsMulti < 0))
        {
        printf("need to process inner ring, but outer ring IsMulti value has not been set\n");
        exit(-1);
        }
     MonsterPoly = 0;
     d1 = (double) ((Ex - Sx) * (Ey - Sy));
     d3 = d1 / ((double) listlength);
     if(d3 > 0.24)
        {
        MonsterPoly = 1;
        ++ii;
        }

      if((Sx != Ex) || (Sy != Ey) || ((cp->ishole >= 1) && (LastParentIsMulti > 0)))
         {
         if(cp->ishole <= 0)
            LastParentIsMulti = 1;
UMA += 1;
if(cp->ishole > 0)
UMAh += 1;
         if(NGA_TYPE == 1)
            BuildOpenMenu(0.0,SACttl*2,SACttl*2,linears_done,ArealsRead,model_polys,*areals_done,linears_done,points_done,
                sphere_cv,parallel_cv,stamps_done,footprints_done, bridges_done,g_read,g_write,
                FMpointsdone,FMlinesdone,*FMarealsdone,0.0,0.0,0.0,0.0,0);
         else
            BuildOpenMenu(0.0,SACttl*2,SACttl*2,polys_read,polys_done,model_polys,*areals_done,linears_done,points_done,
                sphere_cv,parallel_cv,stamps_done,footprints_done, bridges_done,g_read,g_write,
                FMpointsdone,FMlinesdone,*FMarealsdone,0.0,0.0,0.0,0.0,0);

         if(outfilesize > AREALNODELIMIT)
            {
            outfilesize = 0;
            fclose(dataout);
            ++outfilenumber;
            sprintf(suffix,"%d",outfilenumber);
            strcpy(afileout,arealdata);
            strcat(afileout,suffix);
            dataout = fopen(afileout,"wb");
            ftellCalc = 0;
            }

         if((NGA_TYPE == 1) && (cp->ishole <= 0))  /*** was (cp->ishole != 1)) ***/
            {
            *areals_done += 1;
            }

         fileposn = ftellCalc;
         SEEIT_fwrite_int(&cp->featureid,dataout);
         if(cp->ishole <= 0) /*** was if(cp->ishole != 1) ***/
            {
            parentseekposn = ftell(dataout);

            parent = NULL;
            }
         SEEIT_fwrite_int(&cp->ishole,dataout);
         SEEIT_fwrite_int(&cp->Lindex,dataout);
         SEEIT_fwrite_int(&cp->Sindex,dataout);
         SEEIT_fwrite_int(&cp->idn,dataout);
         SEEIT_fwrite_int(&cp->numverts,dataout);
         for(i=0; i<cp->numverts; i++)
            {
            SEEIT_fwrite_double(&cp->coord[i].x,dataout);
            SEEIT_fwrite_double(&cp->coord[i].y,dataout);
            SEEIT_fwrite_double(&cp->coord[i].z,dataout);
            }
         if(MonsterPoly > 0)
            {
            Mn = (struct MonsterP *) (malloc(SzMP));
            Mn->fileposn = fileposn;
            Mn->outfilenumber = outfilenumber;
            Mn->Lindex = cp->Lindex;
            Mn->idn = cp->idn;
            Mn->LM = (char *) (malloc(listlength));
            Mn->next = NULL;
            for(i=0; i<listlength; i++)
               Mn->LM[i] = 0;
            if(MonsterRoot == NULL)
               MonsterRoot = Mn;
            else
               Mp->next = Mn;
            Mp = Mn;
            }
         outfilesize += cp->numverts;
         ftellCalc += (6 * SzI) + (3 * cp->numverts * SzD);

         for(i=0; i<cp->numverts; i++)
            {
            Xvertex[i] = cp->coord[i].x;
            Yvertex[i] = cp->coord[i].y;
            }

         d1 = (Ex - Sx + 1) * (Ey - Sy + 1);
         if(d1 > 3)
            {
            minIindex = i1 = (int) (minX / LRegionSize);
            minJindex = j1 = (int) (minY / LRegionSize);

            if(YscaledPts == NULL)
               {
               printf("Available memory has been exhausted during large areal format\n");
               printf("number of areal vertices %d\n",cp->numverts);
               exit(-1);
               }
            for(i=0; i<cp->numverts; i++)
               {
               d1 = (cp->coord[i].x /**- minX**/) / LRegionSize;
               d2 = (cp->coord[i].y /**- minY**/) / LRegionSize;

               XscaledPts[i] = (short int) d1 - minIindex;
               YscaledPts[i] = (short int) d2 - minJindex;

               }
   
            ix = 2+ (int) ((maxX - minX) / LRegionSize);  /** should be the range ***/
            iy = 2+ (int) ((maxY - minY) / LRegionSize);

   
            ScalePolygon(ix,iy,XscaledPts,YscaledPts,cp->numverts);
            minIindex = i1 = (int) (minX / LRegionSize);
            minJindex = j1 = (int) (minY / LRegionSize);


            for(i=0; i<ix; i++)
               {
               for(j=0; j<iy; j++)
                  {
                  if(PolyPixels[i][j] > 0)
                     {
                     ind1 = ((i +i1) * YindexExtent) + j + j1;
                     if(ind1 < listlength)
                        {
                        if(MonsterPoly == 0)
                           {
                           ArealTable[ind1].numother += 1;
                           plst = ArealTable[ind1].others;
                           while(plst != NULL)
                              {
                              if((plst->fileptr == fileposn) && (plst->filenumber == outfilenumber))
                                 {
                                 break;
                                 }
                              plst = plst->next;
                              }
                           if(plst == NULL)
                              {
                              plst = (struct ObjPtrList *) (malloc(SzPtrList));
                              if(plst == NULL)
                                 {
                                 printf("all available memory has been consumed during allocation of file pointers for area table\n");
                                 exit(-1);
                                 }
                              plst->fileptr = fileposn;
                              plst->filenumber = outfilenumber;
                              plst->next = ArealTable[ind1].others;
                              ArealTable[ind1].others = plst;
                              InsertIntoSCCtable(MonsterPoly,ind1, cp->Lindex,cp->idn,cp->featureid); 
                              }
                           }
                        else
                           {
                           if(Mn != NULL)
                              {
                              Mn->LM[ind1] = 1;
                              InsertIntoSCCtable(MonsterPoly,ind1, cp->Lindex,cp->idn,cp->featureid);
                              }
                           }
                        }
                     }
                  }
               }

            i2 = (int) (cp->coord[cp->numverts-1].x / LRegionSize);
            j2 = (int) (cp->coord[cp->numverts-1].y / LRegionSize);

            for(i=0; i<cp->numverts; i++) 
               {
               if(i == 0)
                  i6 = cp->numverts - 1;
               else
                  i6 = i - 1;
               i0 = i2;
               j0 = j2;
               i2 = (int) (cp->coord[i].x / LRegionSize);
               j2 = (int) (cp->coord[i].y / LRegionSize);
               if(PolyPixels[i2 - minIindex][j2 - minJindex] < 1)  
                  {
                  ind1 = (i2 * YindexExtent) +j2;
                  if(ind1 < listlength)
                     {
                     if(MonsterPoly == 0)
                        {
                        plst = ArealTable[ind1].others;
                        while(plst != NULL)
                           {
                           if((plst->fileptr == fileposn) && (plst->filenumber == outfilenumber))
                              {
                              break;
                              }
                           plst = plst->next;
                           }
                        if(plst == NULL)
                           {
                           ArealTable[ind1].numother += 1;
      
                           plst = (struct ObjPtrList *) (malloc(SzPtrList));
                           if(plst == NULL)
                              {
                              printf("all available memory has been consumed during allocation of file pointers for area table\n");
                              exit(-1);
                              }
                           plst->fileptr = fileposn;
                           plst->filenumber = outfilenumber;
                           plst->next = ArealTable[ind1].others;
                           ArealTable[ind1].others = plst;
                           PolyPixels[i2 - minIindex][j2 - minJindex] = 1;
                           InsertIntoSCCtable(MonsterPoly,ind1, cp->Lindex,cp->idn,cp->featureid);
                           }
                        }
                     else
                        {
                        if(Mn != NULL)
                           {
                           Mn->LM[ind1] = 1;
                           InsertIntoSCCtable(MonsterPoly,ind1, cp->Lindex,cp->idn,cp->featureid);
                           }
                        }
                     }
                  }
               if((i2 != i0) || (j2 != j0))
                  {
                  if(i0 > i2)
                     {
                     i5 = i0;
                     i4 = i2;
                     }
                  else
                     {
                     i4 = i0;
                     i5 = i2;
                     }
                  if(j0 > j2)
                     {
                     j5 = j0;
                     j4 = j2;
                     }
                  else
                     {
                     j4 = j0;
                     j5 = j2;
                     }
                  i3 = i5 - i4;
                  j3 = j5 - j4;
                  if((i3 + j3) > 1)
                     {
                     dx1 = (double) cp->coord[i6].x;
                     dy1 = (double) cp->coord[i6].y;
                     dx2 = (double) cp->coord[i].x;
                     dy2 = (double) cp->coord[i].y;
                     for(i3 = i4; i3 <= i5; i3++)
                        {
                        d1 = (double) i3 * LRegionSize;
                        d2 = d1 + LRegionSize;
                        for(j3 = j4; j3 <= j5; j3++)
                           {
                           ind1 = (i3 * YindexExtent) + j3;
                           if(PolyPixels[i3 - minIindex][j3 - minJindex] < 1)
                              {

                              d3 = (double) j3 * LRegionSize;
                              d4 = d3 + LRegionSize;
   
                              inside = 0;
   
                              if(LocalLineSegmentsIntersect(d1,d3,d2,d3,dx1,dy1,dx2,dy2,&Xint,&Yint) > 0)
                                 inside = 1;
                              else if(LocalLineSegmentsIntersect(d1,d3,d1,d4,dx1,dy1,dx2,dy2,&Xint,&Yint) > 0)
                                 inside = 1;
                              else if(LocalLineSegmentsIntersect(d2,d4,d2,d3,dx1,dy1,dx2,dy2,&Xint,&Yint) > 0)
                                 inside = 1;
                              else if(LocalLineSegmentsIntersect(d2,d4,d1,d4,dx1,dy1,dx2,dy2,&Xint,&Yint) > 0)
                                 inside = 1;
                              if(inside > 0)
                                 {
                                 ind1 = (i3 * YindexExtent) + j3;
                                 if(ind1 < listlength)
                                    {
                                    if(MonsterPoly == 0)
                                       {
                                       plst = ArealTable[ind1].others;
                                       while(plst != NULL)
                                          {
                                          if((plst->fileptr == fileposn) && (plst->filenumber == outfilenumber))
                                             {
                                             break;
                                             }
                                          plst = plst->next;
                                          }
                                       if(plst == NULL)
                                          {
                                          PolyPixels[i3 - minIindex][j3 - minJindex] = 1;
                                          ArealTable[ind1].numother += 1;
                                          plst = (struct ObjPtrList *) (malloc(SzPtrList));
                                          if(plst == NULL)
                                             {
                                             printf("all available memory has been consumed during allocation of file pointers for area table\n");
                                             exit(-1);
                                             }
                                          plst->fileptr = fileposn;
                                          plst->filenumber = outfilenumber;
                                          plst->next = ArealTable[ind1].others;
                                          ArealTable[ind1].others = plst;
                                          InsertIntoSCCtable(MonsterPoly,ind1, cp->Lindex,cp->idn,cp->featureid);
                                          }
                                       }
                                    else
                                       {
                                       if(Mn != NULL)
                                          {
                                          Mn->LM[ind1] = 1;
                                          InsertIntoSCCtable(MonsterPoly,ind1, cp->Lindex,cp->idn,cp->featureid);
                                          }
                                       }
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               } /*** end for i= to recheck perimeter ***/
            } /*** end have an areal in a large number  load modules ****/
         else
            {
            for(ix = Sx; ix <= Ex; ix ++)
               {
               d1 = (double) ix * LRegionSize;
               d2 = d1 + LRegionSize;
               for(iy = Sy; iy <= Ey; iy++)
                  {
                  d3 = (double) iy * LRegionSize;
                  d4 = d3 + LRegionSize;
                  inside = 0;
                  if((Sx == Ex) && (Sy == Ey) && (cp->ishole >= 1))
                     inside = 2;
                  else if(LocalPointInsidePoly(d1,d3,Xvertex,Yvertex,cp->numverts))
                     {
                     inside = 1;
                     }
                  else if(LocalPointInsidePoly(d1,d4,Xvertex,Yvertex,cp->numverts))
                     {
                     inside = 1;
                     }
                  else if(LocalPointInsidePoly(d2,d3,Xvertex,Yvertex,cp->numverts))
                     {
                     inside = 1;
                     }
                  else if(LocalPointInsidePoly(d2,d4,Xvertex,Yvertex,cp->numverts))
                     {
                     inside = 1;
                     }
                  if(inside > 0)
                     {
                     ind1 = (ix * YindexExtent) + iy;
                     if(ind1 < listlength)
                        {
                        if(MonsterPoly == 0)
                           {
                           plst = ArealTable[ind1].others;
                           while(plst != NULL)
                              {
                              if((plst->fileptr == fileposn) && (plst->filenumber == outfilenumber))
                                 {
                                 break;
                                 }
                              plst = plst->next;
                              }

                           if(plst == NULL)
                              {
                              ArealTable[ind1].numother += 1;
                              plst = (struct ObjPtrList *) (malloc(SzPtrList));
                              if(plst == NULL)
                                 {
                                 printf("all available memory has been consumed during allocation of file pointers for area table\n");
                                 exit(-1);
                                 }
                              plst->fileptr = fileposn;
                              plst->filenumber = outfilenumber;
                              plst->next = ArealTable[ind1].others;
                              ArealTable[ind1].others = plst;
                              InsertIntoSCCtable(MonsterPoly,ind1, cp->Lindex,cp->idn,cp->featureid);
                              }
                           }
                        else
                           {
                           if(Mn != NULL)
                              {
                              Mn->LM[ind1] = 1;
                              InsertIntoSCCtable(MonsterPoly,ind1, cp->Lindex,cp->idn,cp->featureid);
                              }
                           }
                        }
                     }
                  else /** above case did not occur, so check for intersections **/
                     {
                     dx2 = (double) cp->coord[0].x;
                     dy2 = (double) cp->coord[0].y;
                     for(i=0; i<cp->numverts; i++)
                        {
                        j = (i + 1) % cp->numverts;
                        dx1 = dx2;
                        dy1 = dy2;
                        dx2 = (double) cp->coord[j].x;
                        dy2 = (double) cp->coord[j].y;
                        if(LocalLineSegmentsIntersect(d1,d3,d2,d3,dx1,dy1,dx2,dy2,&Xint,&Yint) > 0)
                           inside = 1;
                        else if(LocalLineSegmentsIntersect(d1,d3,d1,d4,dx1,dy1,dx2,dy2,&Xint,&Yint) > 0)
                           inside = 1;
                        else if(LocalLineSegmentsIntersect(d2,d4,d2,d3,dx1,dy1,dx2,dy2,&Xint,&Yint) > 0)
                           inside = 1;
                        else if(LocalLineSegmentsIntersect(d2,d4,d1,d4,dx1,dy1,dx2,dy2,&Xint,&Yint) > 0)
                           inside = 1;
                        if(inside > 0)
                           {
                           ind1 = (ix * YindexExtent) + iy;
                           if(ind1 < listlength)
                              {
                              if(MonsterPoly == 0)
                                 {
                                 plst = ArealTable[ind1].others;
                                 while(plst != NULL)
                                    {
                                    if((plst->fileptr == fileposn) && (plst->filenumber == outfilenumber))
                                       {
                                       break;
                                       }
                                    plst = plst->next;
                                    }
                                 if(plst == NULL)
                                    {
                                    ArealTable[ind1].numother += 1;
                                    plst = (struct ObjPtrList *) (malloc(SzPtrList));
                                    if(plst == NULL)
                                       {
                                       printf("all available memory has been consumed during allocation of file pointers for area table\n");
                                       exit(-1);
                                       }
                                    plst->fileptr = fileposn;
                                    plst->filenumber = outfilenumber;
                                    plst->next = ArealTable[ind1].others;
                                    ArealTable[ind1].others = plst;
                                    InsertIntoSCCtable(MonsterPoly,ind1, cp->Lindex,cp->idn,cp->featureid);
                                    }
                                 }
                              else
                                 {
                                 if(Mn != NULL)
                                    {
                                    Mn->LM[ind1] = 1;
                                    InsertIntoSCCtable(MonsterPoly,ind1, cp->Lindex,cp->idn,cp->featureid);
                                    }
                                 }
                              break;
                              }
                           }
                        }
                     }
                  }
               }
            }

         free(cp->coord);
         free(cp);
         cp = NULL;
         }
      else
         {
         if(cp->ishole <= 0)
            LastParentIsMulti = 0;
USA += 1;
if(cp->ishole > 0)
USAh += 1;
         ind1 = (Sx * YindexExtent) + Sy;
         if(ind1 < listlength)
            {
         ArealTable[ind1].numpoly += 1;
         if(cp->ishole >= 1)
            ArealTable[ind1].numholes += 1;
            
         cp->next = ArealTable[ind1].inside;
         ArealTable[ind1].inside = cp;
            
         InsertIntoSCCtable(0,ind1, cp->Lindex,cp->idn,cp->featureid);
            }
         }

         SEEIT_fread_int(&featureID,arealin);
         if(feof(arealin) != 0)
            {
            ++infilenumber;
               
            if(infilenumber <= NumArealFiles)
               {
               arealin = InFileHandles[infilenumber-1].fp;
               rewind(arealin);
               }

            i4 = 0;
            i5 = 0;
        while(arealfile[i4] != '\0')
           {
           afilein[i5] = arealfile[i4];
           afileIntermed[i5] = arealfile[i4];
           ++i4;
           ++i5;
           }

        while((i5 > 0) && (afilein[i5] != '.'))
           --i5;

        sprintf(&afileIntermed[i5],"%dInt",infilenumber-1);
        strcat(afileIntermed,".bin");
            if(infilenumber <= NumArealFiles)
               {
               sprintf(&afilein[i5],"%d",infilenumber);
               strcat(afilein,".bin");

               printf("processing areal data from file %s\n",afilein);
printf("will use temp file %s\n",afileIntermed);
               }

            if(NumArealFiles > 1)
               {
               intermediate = fopen(afileIntermed,"wb");
               for(i4=0; i4<listlength; i4++)
                  {
                  fwrite(&i4,SzI,1,intermediate);
                  fwrite(&ArealTable[i4].numpoly,SzI,1,intermediate); 
                  fwrite(&ArealTable[i4].numholes,SzI,1,intermediate);

                  i5 = 0;
                  cp = ArealTable[i4].inside;
                  while(cp != NULL)
                     {
                     i5 += cp->numverts;
                     cp = cp->next;
                     }
                  i5 = (i5 *  SzV) + (ArealTable[i4].numpoly * 6 * SzI);
                  fwrite(&i5,SzI,1,intermediate);
                  if(i5 > MaxBytes)
                     MaxBytes = i5;

                  if(ArealTable[i4].numpoly > 0)
                     {
                     cp = ArealTable[i4].inside;
                     while(cp != NULL)
                        {
                        if((cp == parent) && (HolesThisAreal > 0))
                           {
                           parent->ishole = 0 - HolesThisAreal;
                           parent = NULL;
                           parentseekposn = -100;
                           HolesThisAreal = 0;
                           }
                        if(machine_endianness != file_endianness) 
                           {
                           LocalByteSwapInt((char *) &cp->featureid);
                           LocalByteSwapInt((char *) &cp->ishole);
                           LocalByteSwapInt((char *) &cp->Lindex);
                           LocalByteSwapInt((char *) &cp->Sindex);
                           LocalByteSwapInt((char *) &cp->idn);
                           for(i5=0; i5<cp->numverts; i5++)
                              {
                              LocalByteSwapDouble((char *) &cp->coord[i5].x);
                              LocalByteSwapDouble((char *) &cp->coord[i5].y);
                              LocalByteSwapDouble((char *) &cp->coord[i5].z);
                              }
                           i5 = cp->numverts;
                           LocalByteSwapInt((char *) &cp->numverts);
                           fwrite(&cp->featureid,SzI,6,intermediate); 
                           fwrite(&cp->coord[0].x,SzV,i5,intermediate);
                           }
                        else
                           {
                           fwrite(&cp->featureid,SzI,6,intermediate); 
                           fwrite(&cp->coord[0].x,SzV,cp->numverts,intermediate);
                           }

                        pp = cp;
                        cp = cp->next;
                        free(pp->coord);
                        free(pp);
                        }
                     ArealTable[i4].inside = NULL;
                     ArealTable[i4].numpoly = 0;
                     ArealTable[i4].numholes = 0;

                     if(NGA_TYPE == 1)
                        BuildOpenMenu(0.0,SACttl*2,SACttl*2,linears_done,ArealsRead,model_polys,*areals_done,linears_done,points_done,
                            sphere_cv,parallel_cv,stamps_done,footprints_done, bridges_done,g_read,g_write,
                            FMpointsdone,FMlinesdone,*FMarealsdone,0.0,0.0,0.0,0.0,0);
                     else
                        BuildOpenMenu(0.0,SACttl*2,SACttl*2,polys_read,polys_done,model_polys,*areals_done,linears_done,points_done,
                            sphere_cv,parallel_cv,stamps_done,footprints_done, bridges_done,g_read,g_write,
                            FMpointsdone,FMlinesdone,*FMarealsdone,0.0,0.0,0.0,0.0,0);

                     }
                  }
               fclose(intermediate);
               }

            if(infilenumber > NumArealFiles)
               break;
            if(arealin == NULL)
               {
               break;
               }

            SEEIT_fread_int(&featureID,arealin);
            }
      }


         if(HolesThisAreal > 0)
            {
            if((parent == NULL) && (parentseekposn >= 0))
               {
               saveseekposn = ftell(dataout);
               fseek(dataout,parentseekposn,SEEK_SET);
               HolesThisAreal = 0 - HolesThisAreal;
               SEEIT_fwrite_int(&HolesThisAreal,dataout);
               fseek(dataout,saveseekposn,SEEK_SET);
               }
            else
               {
               parent->ishole = 0 - HolesThisAreal;
               }
            }

   free(Xvertex);
   free(Yvertex);
   free(Xmap);
   free(Ymap);
   free(XscaledPts);
   free(YscaledPts);

   if(NumArealFiles > 1)
      {
      for(i=0; i<NumArealFiles; i++)
         {
         fclose(InFileHandles[i].fp);
         }

      if(NGA_TYPE == 1)
         BuildOpenMenu(0.0,SACttl*2,SACttl*2,linears_done,ArealsRead,model_polys,*areals_done,linears_done,points_done,
             sphere_cv,parallel_cv,stamps_done,footprints_done, bridges_done,g_read,g_write,
             FMpointsdone,FMlinesdone,*FMarealsdone,0.0,0.0,0.0,0.0,0);
      else
         BuildOpenMenu(0.0,SACttl*2,SACttl*2,polys_read,polys_done,model_polys,*areals_done,linears_done,points_done,
             sphere_cv,parallel_cv,stamps_done,footprints_done, bridges_done,g_read,g_write,
             FMpointsdone,FMlinesdone,*FMarealsdone,0.0,0.0,0.0,0.0,0);

      for(infilenumber=1; infilenumber<=NumArealFiles; infilenumber++)
         {
         i4 = 0;
         i5 = 0;
         while(arealfile[i4] != '\0')
            {
            afileIntermed[i5] = arealfile[i4];
            ++i4;
            ++i5;
            }

         --i5;

         while((i5 > 0) && (afileIntermed[i5] != '.'))
            --i5;


         sprintf(&afileIntermed[i5],"%dInt",infilenumber);
         
         strcat(afileIntermed,".bin");

         InFileHandles[infilenumber-1].fp = fopen(afileIntermed,"rb");
         if(InFileHandles[infilenumber-1].fp == NULL)
            {
            printf("(1) fatal error when opening areal intermediate file %s\n", afileIntermed);
printf("intermediate file constructed from %s\n",arealfile);
            exit(-1);
            }
         }
      IntermediateIndex = (int *) (malloc(SzI * NumArealFiles));
      if(IntermediateIndex == NULL)
         {
         printf("available memory exhausted during areal intermediate file process\n");
         printf("unable to allocate memory for %d intermediate file indices\n",NumArealFiles);
         exit(-1);
         }

      ReadStuff = (void *) (malloc(MaxBytes + 10));
      if(ReadStuff == NULL)
         {
         printf("available memory has been exhausted during rewrite of intermediate files\n");
         exit(-1);
         }


      for(i=0; i<NumArealFiles; i++)
         {
         fread(&IntermediateIndex[i],SzI,1,InFileHandles[i].fp);
         }

      for(i=0; i<listlength; i++)
         {
         ArealTable[i].fileptr = ftellCalc;

         ArealTable[i].filenumber = outfilenumber;

         for(j = 0; j < NumArealFiles; j++)
            {
            if(IntermediateIndex[j] == i)
               {
               fread(&i1,SzI,1,InFileHandles[j].fp); /** should be the number of areals for this LM in this file ***/
               ArealTable[i].numpoly += i1;
               fread(&i0,SzI,1,InFileHandles[j].fp);   /*** should be the number of area cut-outs in this LM ***/
               fread(&i2,SzI,1,InFileHandles[j].fp); /** should be the number of bytes to copy into output file  ***/

               fread(ReadStuff,1,i2,InFileHandles[j].fp);

               fwrite(ReadStuff,1,i2,dataout);

               outfilesize += (i2 - (SzI * 6 * i1)) / (3 * SzD);

               ftellCalc += i2;

               if(NGA_TYPE == 1)
                  {
                  *areals_done += i1;
                  *areals_done -= i0;
                  }

               fread(&IntermediateIndex[j],SzI,1,InFileHandles[j].fp);
               if(feof(InFileHandles[j].fp) != 0)
                  IntermediateIndex[j] = -1;

               if(NGA_TYPE == 1)
                  BuildOpenMenu(0.0,SACttl*2,SACttl*2,linears_done,ArealsRead,model_polys,*areals_done,linears_done,points_done,
                      sphere_cv,parallel_cv,stamps_done,footprints_done, bridges_done,g_read,g_write,
                      FMpointsdone,FMlinesdone,*FMarealsdone,0.0,0.0,0.0,0.0,0);
               else
                  BuildOpenMenu(0.0,SACttl*2,SACttl*2,polys_read,polys_done,model_polys,*areals_done,linears_done,points_done,
                      sphere_cv,parallel_cv,stamps_done,footprints_done, bridges_done,g_read,g_write,
                      FMpointsdone,FMlinesdone,*FMarealsdone,0.0,0.0,0.0,0.0,0);

               } /*** end IntermediateIndex[j] == i ***/
            } /*** end  j < NumArealFiles ***/

         if(outfilesize > AREALNODELIMIT)
            {
            outfilesize = 0;
            fclose(dataout);
            ++outfilenumber;
            sprintf(suffix,"%d",outfilenumber);
            strcpy(afileout,arealdata);
            strcat(afileout,suffix);
            dataout = fopen(afileout,"wb");
            ftellCalc = 0;
            }

         if(ArealTable[i].numpoly == 0)
            ArealTable[i].fileptr = 0;

         } /** end for i<listlength ***/

      fclose(dataout);
      printf("areal output file %s closed\n",arealdata);

      free(IntermediateIndex);
      free(ReadStuff);


      for(infilenumber=1; infilenumber<=NumArealFiles; infilenumber++)
         {
         fclose(InFileHandles[infilenumber - 1].fp);

         i4 = 0;
         i5 = 0; 
         while(arealfile[i4] != '\0')
            {
            afileIntermed[i5] = arealfile[i4];
            ++i4;
            ++i5;
            }
         --i5;

         while((i5 > 0) && (afileIntermed[i5] != '.'))
            --i5;

         sprintf(&afileIntermed[i5],"%dInt",infilenumber);
         strcat(afileIntermed,".bin");

         if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
	   {
	     sprintf(junk,"del \"%s\"",afileIntermed);
	   }
         else
	   {
	     sprintf(junk,"rm \"%s\"",afileIntermed);
	   }
	 
         system(junk);
         }
      }

   if(NumArealFiles == 1)
      {
      for(i=0; i<listlength; i++)
         {
         if(ArealTable[i].numpoly > 0)
            ArealTable[i].fileptr = ftell(dataout);
         else
            ArealTable[i].fileptr = 0;
         ArealTable[i].filenumber = outfilenumber;
         cp = ArealTable[i].inside;
         while(cp != NULL)
            {
            if((NGA_TYPE == 1) && (cp->ishole <= 0))
               *areals_done += 1;

            SEEIT_fwrite_int(&cp->featureid,dataout);
            SEEIT_fwrite_int(&cp->ishole,dataout);
            SEEIT_fwrite_int(&cp->Lindex,dataout);
            SEEIT_fwrite_int(&cp->Sindex,dataout);
            SEEIT_fwrite_int(&cp->idn,dataout);
            SEEIT_fwrite_int(&cp->numverts,dataout);
            for(j=0; j<cp->numverts; j++)
               {
               SEEIT_fwrite_double(&cp->coord[j].x,dataout);
               SEEIT_fwrite_double(&cp->coord[j].y,dataout);
               SEEIT_fwrite_double(&cp->coord[j].z,dataout);
               }

            outfilesize += cp->numverts;

            pp = cp;
            cp = cp->next;
            free(pp->coord);
            free(pp);
            }

         if(outfilesize > AREALNODELIMIT)
            {
            outfilesize = 0;
            fclose(dataout);
            ++outfilenumber;
            sprintf(suffix,"%d",outfilenumber);
            strcpy(afileout,arealdata);
            strcat(afileout,suffix);
            dataout = fopen(afileout,"wb");
printf("new areal (single) output file %s\n",afileout);
            }

         if(NGA_TYPE == 1)
            BuildOpenMenu(0.0,SACttl*2,SACttl*2,linears_done,ArealsRead,model_polys,*areals_done,linears_done,points_done,
                sphere_cv,parallel_cv,stamps_done,footprints_done, bridges_done,g_read,g_write,
                FMpointsdone,FMlinesdone,*FMarealsdone,0.0,0.0,0.0,0.0,0);
         else
            BuildOpenMenu(0.0,SACttl*2,SACttl*2,polys_read,polys_done,model_polys,*areals_done,linears_done,points_done,
                sphere_cv,parallel_cv,stamps_done,footprints_done, bridges_done,g_read,g_write,
                FMpointsdone,FMlinesdone,*FMarealsdone,0.0,0.0,0.0,0.0,0);
         }
      fclose(dataout);
      printf("areal output file %s closed\n",arealdata);
      }

   if(NumArealFiles == 1)
      {
      fclose(InFileHandles[0].fp);
      }
   free(InFileHandles);


   MPoc = AreaMProot;
   while(MPoc != NULL)
      {
      if(MPoc->used > 1)
         *areals_done = *areals_done - MPoc->used + 1;
      MPoc = MPoc->next;
      }


   SingleAreals = 0;
   MultiAreals = 0;
   tableout = fopen(arealtablefile,"wb");
   for(i=0; i<listlength; i++)
      {
      Mc = MonsterRoot;
      while(Mc != NULL)
         {
         if(Mc->LM[i] == 1)
            ArealTable[i].numother += 1;
         Mc = Mc->next;
         }
      SingleAreals +=  ArealTable[i].numpoly;
      MultiAreals += ArealTable[i].numother;
      SEEIT_fwrite_int(&ArealTable[i].numpoly,tableout);
      SEEIT_fwrite_long(&ArealTable[i].fileptr,tableout);
      SEEIT_fwrite_int(&ArealTable[i].filenumber,tableout);
      SEEIT_fwrite_int(&ArealTable[i].numother,tableout);
      plst = ArealTable[i].others;
      Mc = MonsterRoot;
      while(Mc != NULL)
         {
         if(Mc->LM[i] == 1)
            {
            SEEIT_fwrite_long(&Mc->fileposn,tableout);
            SEEIT_fwrite_int(&Mc->outfilenumber,tableout);
            }
         Mc = Mc->next;
         }
      while(plst != NULL)
         {
         clst = plst;
         plst = plst->next;
         SEEIT_fwrite_long(&clst->fileptr,tableout);
         SEEIT_fwrite_int(&clst->filenumber,tableout);
         free(clst);
         }
      if(NGA_TYPE == 1)
         BuildOpenMenu(0.0,SACttl*2,SACttl*2,linears_done,ArealsRead,model_polys,*areals_done,linears_done,points_done,
             sphere_cv,parallel_cv,stamps_done,footprints_done, bridges_done,g_read,g_write,
             FMpointsdone,FMlinesdone,*FMarealsdone,0.0,0.0,0.0,0.0,0);
      else
         BuildOpenMenu(0.0,SACttl*2,SACttl*2,polys_read,polys_done,model_polys,*areals_done,linears_done,points_done,
             sphere_cv,parallel_cv,stamps_done,footprints_done, bridges_done,g_read,g_write,
             FMpointsdone,FMlinesdone,*FMarealsdone,0.0,0.0,0.0,0.0,0);
      }
   fclose(tableout);
   free(ArealTable);

   if(aa != NULL)
      {
      if(aa->outer != NULL)
         {
         DrawTopLevelImageArea(aa);
         
         ringc = aa->inner;
         while(ringc != NULL)
            {
            ringp = ringc;
            ringc = ringc->next;
            free(ringp->x);
            free(ringp->y);
            free(ringp);
            }
         aa->inner = NULL;

         ringc = aa->outer;
         if(ringc != NULL)
            {
            free(ringc->x);
            free(ringc->y);
            free(ringc);
            }
         }

      free(aa);
      }
}




void FormatLinears(int SACttl,unsigned char CoordSystem,
                 int polys_read, int polys_done,int model_polys,int areals_done,int *linears_done,int points_done,
                 int sphere_cv,int parallel_cv,int stamps_done,int footprints_done,
                 int bridges_done, unsigned int g_read, unsigned int g_write, int FMpointsdone, int FMlinesdone, int FMarealsdone)
{
struct RawFormatLinear
   { 
   double * x;
   double * y;
   double * z;
   int featureid;
   int Lindex;
   int Sindex;
   int idn;
   int numnodes;
   struct RawFormatLinear * next;
   } ;

struct LinearLookup
   {
   int numlinear;
   int filenumber;
   int numother;
   long int fileptr;
   struct RawFormatLinear * inside;
   int * insideindices;
   struct ObjPtrList *others;
   } * LinearTable;

struct CM_ObjPtrList
  {
  int filenumber;
  int compositeindex;
  long fileptr;
  } *CM_Objects;


FILE *linearsin;
FILE *tableout;
FILE *dataout;
long int infileposn;
int SzRL = sizeof(struct RawFormatLinear);
int SzLL = sizeof(struct LinearLookup);
int SzPtrList = sizeof(struct ObjPtrList);
int LastLinearID;
struct RawFormatLinear *cl, *pl;
struct RawFormatLinear *L;
int SingleLinears, MultiLinears;
struct ObjPtrList *plst, *clst;
int i,j,listlength,ix,iy,idnumber;
int XindexExtent, YindexExtent;
long int fileposn;
int Sx,Sy,Ex,Ey, inside,ind1;
int SxSegment,SySegment,ExSegment,EySegment;
double minX, minY, maxX, maxY;
double d1,d2,d3,d4;
double dx1,dy1,dx2,dy2, Xint,Yint;
double dNumCols, dNumRows;
double *Xmap;
double *Ymap;
int NumMapVerts;
int MaxVerts = 2000;
unsigned char pixcolor;
int i1, i2, j1;
int ObjectIndex;
int i4, i5;
double minx1,maxx1,miny1,maxy1;
int IM = ImageMaxSize - 1;
int outfilenumber, infilenumber;
long int outfilesize;
extern int LINEARNODELIMIT;
char suffix[5];
char lfilein[200];
char lfileout[200];
char junk[300];
int TotalLinearObjects = 0;
int NumParts = 0;
int NumLinearFiles = 0;
int MaxInside = 0;
int clindex;
int LinearsRead = 0;
int smallvertexnum=1000,vertexallocnum;
int num_realloc = 0;


struct InFiles
{
   FILE * fp;
} *InFileHandles;


   strcpy(lfilein,indirectory);
   strcat(lfilein,"multiinfo.txt");

   linearsin = fopen(lfilein,"rt");
   if(linearsin == NULL)
      {
      printf("No associated file of linear data meta information (%s is missing)\n",lfilein);
      return;
      }
   fgets(junk,249,linearsin); /*** number of Point feature files  - discard here ***/
   fgets(junk,249,linearsin); /*** number of Line feature files  - discard here ***/
   fgets(junk,249,linearsin); /*** number of Area feature files  - discard here ***/
   fgets(junk,249,linearsin); /*** number of Grid feature files  - discard here ***/
   fgets(junk,249,linearsin); /*** number of Code feature files  - discard here ***/

   fgets(junk,249,linearsin); /*** number of multi-part Point features  - discard here ***/
   fgets(junk,249,linearsin); /*** number of multi-part Line features  - discard here ***/
   fgets(junk,249,linearsin); /*** number of multi-part Area features  - discard here ***/

   fgets(junk,249,linearsin); /*** number of parts of multi-part point features - discard here***/
   fgets(junk,249,linearsin); /*** number of parts of multi-part line features ***/

   sscanf(junk,"%d", &i);
   NumParts = i;
   fclose(linearsin);

   strcpy(lfilein,indirectory);
   strcat(lfilein,"linearinfo.txt");

   linearsin = fopen(lfilein,"rt");
   if(linearsin == NULL)
      {
      printf("No associated file of linear data meta information (%s is missing)\n",lfilein);
      return;
      }
   TotalLinearObjects = 0;
   NumLinearFiles = 0;
   fgets(junk,249,linearsin);
   while(feof(linearsin) == 0)
      {
      sscanf(junk,"%d", &i);
      TotalLinearObjects += i;
      ++NumLinearFiles;
      fgets(junk,249,linearsin);
      }
   fclose(linearsin);


   if(TotalLinearObjects > 0)
      {
      if(NumLinearFiles > 1)
         printf("starting to process %d linear features (%d total parts) from %d files\n",TotalLinearObjects,NumParts,NumLinearFiles);
      else
         printf("starting to process %d linear features (%d total parts)\n",TotalLinearObjects,NumParts);
      }

   InFileHandles = (struct InFiles *) (malloc(sizeof(struct InFiles) * NumLinearFiles));
   if(InFileHandles == NULL)
      {
      printf("memory has been exhausted during allocation of areal input file handles\n");
      printf("attempt to allocate memory for %d file handles has failed\n",NumLinearFiles);
      exit(-1);
      }

   MPoc = LineMProot;
   while(MPoc != NULL)
      {
      MPoc->used = 0;
      MPoc = MPoc->next;
      }


   for(infilenumber = 1; infilenumber <= NumLinearFiles; infilenumber++)
      {
      if(infilenumber > 1)
        {
        i4 = 0;
        i5 = 0;
        while(linearfile[i4] != '\0')
           {
           lfilein[i5] = linearfile[i4];
           ++i4;
           ++i5;
           }
        
        while((i5 > 0) && (lfilein[i5] != '.'))
           --i5;

        sprintf(&lfilein[i5],"%d",infilenumber);
        strcat(lfilein,".bin");

        InFileHandles[infilenumber-1].fp = fopen(lfilein,"rb");
        if(InFileHandles[infilenumber-1].fp == NULL)
           {
           printf("(1) fatal error when reopening linear input file %s\n", lfilein);
           exit(-1);
           }
         }
      else
         {
         InFileHandles[infilenumber-1].fp = fopen(linearfile,"rb");
         if(InFileHandles[infilenumber-1].fp == NULL)
            {
            printf("(2) fatal error when reopening linear input file %s\n", linearfile);
            exit(-1);
            }
         }
      }



   infilenumber = 1;
   linearsin = InFileHandles[0].fp;

   dataout = fopen(lineardata,"wb");
   outfilesize = 0;
   outfilenumber = 0;


   XindexExtent = (int) (MaxXcoord / LRegionSize) + 2;
   YindexExtent = (int) (MaxYcoord / LRegionSize) + 2;

   dNumCols = PointsPerPixel;
   dNumRows = PointsPerPixel;

   listlength = XindexExtent * YindexExtent;
   LinearTable = (struct LinearLookup *) (malloc(SzLL * listlength));
   if(LinearTable == NULL)
      {
      printf("allocation memory exhausted during linear processing (file %s)\n",linearfile);
      exit(-1);
      }

   for(i=0; i<listlength; i++)
      {
      LinearTable[i].numlinear = 0;
      LinearTable[i].insideindices = NULL;
      LinearTable[i].inside = NULL;
      LinearTable[i].numother = 0;
      LinearTable[i].fileptr = 0;
      LinearTable[i].filenumber = -1;
      LinearTable[i].others = NULL;
      }

   if(ConserveMemory == 0)
      {
      CM_Objects = NULL;
      }
   else
      {
      CM_Objects = (struct CM_ObjPtrList *) (malloc(sizeof(struct CM_ObjPtrList) * (TotalLinearObjects + NumParts + 1)));
      if(CM_Objects == NULL)
         {
         printf("allocation memory exhausted during linear processing (file %s)\n",linearfile);
         exit(-1);
         }

      for(i=0; i<TotalLinearObjects; i++)
         {
         CM_Objects[i].filenumber = -1;
         CM_Objects[i].compositeindex = -1;
         CM_Objects[i].fileptr = -1;
         }
      }

   if(ConserveMemory == 1)
      {
      cl = (struct RawFormatLinear *) malloc(SzRL);
      if(cl == NULL)
         {
         printf("allocation memory exhausted during linear format\n");
         exit(-1);
         }
      cl->next = NULL;

      cl->featureid = -1;
      cl->Lindex = -1;
      cl->Sindex = -1;
      cl->idn = -1;
      cl->numnodes =  0;

      cl->x = (double *) (malloc(MaxVerts * SzD));
      cl->y = (double *) (malloc(MaxVerts * SzD));
      cl->z = (double *) (malloc(MaxVerts * SzD));
      if((cl->x == NULL) || (cl->y == NULL) || (cl->z == NULL))
         {
         printf("allocation memory exhausted during linear format\n");
         exit(-1);
         }
      cl->next = NULL;
      }

   if(NGA_TYPE == 1)
      BuildOpenMenu(0.0,SACttl*2,SACttl*2,LinearsRead,areals_done,model_polys,areals_done,*linears_done,points_done,
          sphere_cv,parallel_cv,stamps_done,footprints_done, bridges_done,g_read,g_write,
          FMpointsdone,FMlinesdone,FMarealsdone,0.0,0.0,0.0,0.0,0);
   else
      BuildOpenMenu(0.0,SACttl*2,SACttl*2,polys_read,polys_done,model_polys,areals_done,*linears_done,points_done,
                sphere_cv,parallel_cv,stamps_done,footprints_done, bridges_done,g_read,g_write,
                FMpointsdone,FMlinesdone,FMarealsdone,0.0,0.0,0.0,0.0,0);

   infileposn = ftell(linearsin);

   SEEIT_fread_int(&idnumber,linearsin);
   LastLinearID = -1;
   ObjectIndex = 0;

   while(feof(linearsin) == 0)
      {
      if(NGA_TYPE == 1)
         ++LinearsRead;
      if(ConserveMemory == 0)
         {
         cl = (struct RawFormatLinear *) (malloc(SzRL));
         if(cl == NULL)
            {
            printf("allocation memory exhausted during linear data format\n");
            exit(-1);
            }
         }
      cl->next = NULL;
      cl->featureid = idnumber;
      SEEIT_fread_int(&cl->Lindex,linearsin);
      SEEIT_fread_int(&cl->Sindex,linearsin);
      SEEIT_fread_int(&cl->idn,linearsin);

      MPoc = LineMProot;
      while(MPoc != NULL)
         {       
         if(MPoc->featureid == cl->idn)
            {
            MPoc->used += 1;
            if(MPoc->used > 1)
               --LinearsRead;
            else
               {
               MPoc->ECC = ClassData[cl->Sindex].ECC;
               if(IDHfp != NULL)
                  {
                  InspectUID(cl->Lindex,cl->idn, cl->featureid, "Line");
                  }
               }
            break;
            }
         MPoc = MPoc->next;
         }
      if((MPoc == NULL) && (IDHfp != NULL))
         {
         InspectUID(cl->Lindex,cl->idn, cl->featureid, "Line");
         }

      SEEIT_fread_int(&cl->numnodes,linearsin);

      if(NGA_TYPE == 1)
         {
         if(LinearsRead == 1)
            {
            MaxLineVerts = MinLineVerts = cl->numnodes;
            }
         else
            {
            if(cl->numnodes > MaxLineVerts)
               MaxLineVerts = cl->numnodes;
            if(cl->numnodes < MinLineVerts)
               MinLineVerts = cl->numnodes;
            }
         }

      if((MPoc == NULL) || ((MPoc != NULL) && (MPoc->used == 1)))
         {
         ClassData[cl->Sindex].occurrences += 1;
         NArray[cl->Lindex].occurrences += 1;
         NArray[cl->Lindex].configcount[ClassData[cl->Sindex].C] += 1; /** bump linear counter **/
         LongListInstances[cl->Lindex] += 1;
         }
      if(LongToShortMap[cl->Lindex] < 0)
         LongToShortMap[cl->Lindex] = cl->Sindex;
      else if(LongToShortMap[cl->Lindex] != cl->Sindex)
         {
         printf("FATAL ERROR -- found one too many mappings from long to short list\n");
         printf("mapping long list index %d into both %d and %d on short list\n",cl->Lindex,
                 LongToShortMap[cl->Lindex],cl->Sindex);
         exit(-1);
         }

      if(ConserveMemory == 0)
         {
         cl->x = (double *) (malloc(cl->numnodes * SzD));
         cl->y = (double *) (malloc(cl->numnodes * SzD));
         cl->z = (double *) (malloc(cl->numnodes * SzD));
         if((cl->x == NULL) || (cl->y == NULL) || (cl->z == NULL))
            {
            printf("allocation memory exhausted during linear format\n");
            exit(-1);
            }
         }
      else if((ConserveMemory == 1) && (cl->numnodes > MaxVerts))
         {
         MaxVerts = cl->numnodes;
         cl->x = (double *) (realloc(cl->x, cl->numnodes * SzD));
         cl->y = (double *) (realloc(cl->y, cl->numnodes * SzD));
         cl->z = (double *) (realloc(cl->z, cl->numnodes * SzD));
         if((cl->x == NULL) || (cl->y == NULL) || (cl->z == NULL))
            {
            printf("allocation memory exhausted during linear format\n");
            exit(-1);
            }
         }

      maxX = maxY = 0.0;
      minX = MaxXcoord;
      minY = MaxYcoord;
      for(i=0; i<cl->numnodes; i++)
         {
          SEEIT_fread_double(&cl->x[i],linearsin);
          SEEIT_fread_double(&cl->y[i],linearsin);
          SEEIT_fread_double(&cl->z[i],linearsin);
            
         if(CoordSystem == 1) /** GDC ***/
            {
            cl->x[i] = (cl->x[i] - Xtranslation) * 100000.0;
            cl->y[i] = (cl->y[i] - Ytranslation) * 100000.0;
            }
         else if(CoordSystem == 2) /** UTM **/
            {
            cl->x[i] = cl->x[i] - Xtranslation;
            cl->y[i] = cl->y[i] - Ytranslation;
            }
         if(cl->x[i] < minX)
            minX = cl->x[i];
         if(cl->x[i] > maxX)
            maxX = cl->x[i];
         if(cl->y[i] < minY)
            minY = cl->y[i];
         if(cl->y[i] > maxY)
            maxY = cl->y[i];
         }


      if(NGA_TYPE == 1)
         {
         DrawTopLevelImageLine(cl->x, cl->y, cl->numnodes, LL_to_Layer_Map[cl->Lindex]);
         }


      if((LastLinearID != cl->idn) && (cl->idn >= 0))
         {
         if(NGA_TYPE == 1)
            BuildOpenMenu(0.0,SACttl*2,SACttl*2,LinearsRead,areals_done,model_polys,areals_done,*linears_done,points_done,
                sphere_cv,parallel_cv,stamps_done,footprints_done, bridges_done,g_read,g_write,
                FMpointsdone,FMlinesdone,FMarealsdone,0.0,0.0,0.0,0.0,0);
         else
            {
            *linears_done += 1;
            BuildOpenMenu(0.0,SACttl*2,SACttl*2,polys_read,polys_done,model_polys,areals_done,*linears_done,points_done,
             sphere_cv,parallel_cv,stamps_done,footprints_done, bridges_done,g_read,g_write,
             FMpointsdone,FMlinesdone,FMarealsdone,0.0,0.0,0.0,0.0,0);
            }
         }
      else if((LastLinearID != cl->featureid) && (cl->featureid >= 0))
         {
         if(NGA_TYPE == 1)
            BuildOpenMenu(0.0,SACttl*2,SACttl*2,LinearsRead,areals_done,model_polys,areals_done,*linears_done,points_done,
                sphere_cv,parallel_cv,stamps_done,footprints_done, bridges_done,g_read,g_write,
                FMpointsdone,FMlinesdone,FMarealsdone,0.0,0.0,0.0,0.0,0);
         else
            {
            *linears_done += 1;
            BuildOpenMenu(0.0,SACttl*2,SACttl*2,polys_read,polys_done,model_polys,areals_done,*linears_done,points_done,
             sphere_cv,parallel_cv,stamps_done,footprints_done, bridges_done,g_read,g_write,
             FMpointsdone,FMlinesdone,FMarealsdone,0.0,0.0,0.0,0.0,0);
            }
         }
      if(cl->idn > 0)
         LastLinearID = cl->idn;
      else if(cl->featureid > 0)
         LastLinearID = cl->featureid;


      Sx = (int) (minX / LRegionSize);
      Ex = (int) (maxX / LRegionSize);
      Sy = (int) (minY / LRegionSize);
      Ey = (int) (maxY / LRegionSize);
      if((Sx != Ex) || (Sy != Ey))
         {
         if(outfilesize > LINEARNODELIMIT)
            {
            outfilesize = 0;
            fclose(dataout);
            ++outfilenumber;
            sprintf(suffix,"%d",outfilenumber);
            strcpy(lfileout,lineardata);
            strcat(lfileout,suffix);
            dataout = fopen(lfileout,"wb");
printf("new linear output file %s\n",lfileout);
            }

         if(NGA_TYPE == 1)
            {
            *linears_done += 1;
            }

         fileposn = ftell(dataout);

         SEEIT_fwrite_int(&cl->featureid,dataout);
         SEEIT_fwrite_int(&cl->Lindex,dataout);
         SEEIT_fwrite_int(&cl->Sindex,dataout);
         SEEIT_fwrite_int(&cl->idn,dataout);
         SEEIT_fwrite_int(&cl->numnodes,dataout);
         for(i=0; i<cl->numnodes; i++)
            {
            SEEIT_fwrite_double(&cl->x[i],dataout);
            SEEIT_fwrite_double(&cl->y[i],dataout);
            SEEIT_fwrite_double(&cl->z[i],dataout);
            }

         outfilesize += cl->numnodes;

dx2 = (double) cl->x[0];
dy2 = (double) cl->y[0];
for(i=0; i<cl->numnodes - 1; i++)
   {
   j = i + 1;
   dx1 = dx2;
   dy1 = dy2;
   dx2 = (double) cl->x[j];
   dy2 = (double) cl->y[j];

   if(dx1 < dx2)
      {
      SxSegment = (int) (dx1 / LRegionSize);
      ExSegment = (int) (dx2 / LRegionSize);
      }
   else
      {
      SxSegment = (int) (dx2 / LRegionSize);
      ExSegment = (int) (dx1 / LRegionSize);
      }
   if(dy1 < dy2)
      {
      SySegment = (int) (dy1 / LRegionSize);
      EySegment = (int) (dy2 / LRegionSize);
      }
   else
      {
      SySegment = (int) (dy2 / LRegionSize);
      EySegment = (int) (dy1 / LRegionSize);
      }


   for(ix = SxSegment; ix <= ExSegment; ix++)
      {
      d1 = (double) ix * LRegionSize;
      d2 = d1 + LRegionSize;
      for(iy = SySegment; iy <= EySegment; iy++)
         {
         ind1 = (ix * YindexExtent) + iy;
         plst = LinearTable[ind1].others;
         while(plst != NULL)
            {
            if((plst->fileptr == fileposn) && (plst->filenumber == outfilenumber))
               break;
            plst = plst->next;
            }
         if(plst == NULL)
            {
            d3 = (double) iy * LRegionSize;
            d4 = d3 + LRegionSize;
            inside = 0;


            if((dx1 >= d1) && (dx1 <= d2) && (dy1 >= d3) && (dy1 <= d4))
               {
               inside = 1;
               }
            else if((dx2 >= d1) && (dx2 <= d2) && (dy2 >= d3) && (dy2 <= d4))
               {
               inside = 1;
               }
            else if(LocalLineSegmentsIntersect(d1,d3,d2,d3,dx1,dy1,dx2,dy2,&Xint,&Yint) > 0)
               {
               inside = 1;
               }
            else if(LocalLineSegmentsIntersect(d1,d3,d1,d4,dx1,dy1,dx2,dy2,&Xint,&Yint) > 0)
               {
               inside = 1;
               }
            else if(LocalLineSegmentsIntersect(d2,d4,d2,d3,dx1,dy1,dx2,dy2,&Xint,&Yint) > 0)
               {
               inside = 1;
               }
            else if(LocalLineSegmentsIntersect(d2,d4,d1,d4,dx1,dy1,dx2,dy2,&Xint,&Yint) > 0)
               {
               inside = 1;
               }
            if(inside > 0)
               {
               LinearTable[ind1].numother += 1;
               plst = (struct ObjPtrList *) (malloc(SzPtrList));
               plst->fileptr = fileposn;
               plst->filenumber = outfilenumber;
               plst->next = LinearTable[ind1].others;
               LinearTable[ind1].others = plst;
               InsertIntoSCCtable(0,ind1, cl->Lindex,cl->idn,cl->featureid);
               }
            }
         }
      }
   }


         i1 = 0;
         if((ShadedReliefRequired) && (LandMarksSet > 0) && (DO_LINES))
            {
            switch (SCCdataArray[cl->Sindex].D)
               {
               case D_NONE:
                  i1 = 0;
                  break;
               default:
                  i1 = 1;
                  break;
               }
            }

         if(NGA_TYPE==1)
	   {
	     i1 = 0;
	   }


         if((NGA_TYPE == 0) && (i1 > 0) && (cl->numnodes > 1))
            {

	      pixcolor = SpecialDomainColors[SCCdataArray[cl->Sindex].D];


            Xmap = (double *) (malloc(SzD * cl->numnodes));
            Ymap = (double *) (malloc(SzD * cl->numnodes));
            NumMapVerts = 1;
            minx1 = maxx1 = Xmap[0] = (double) ((int) (cl->x[0] / dNumCols + 0.5));
            miny1 = maxy1 = Ymap[0] = (double) ((int) (cl->y[0] / dNumRows + 0.5));
            i2 = 0;
            for(i1 = 1; i1< cl->numnodes; i1++)
               {
               Xmap[NumMapVerts] = (double) ((int) (cl->x[i1] / dNumCols + 0.5));
               Ymap[NumMapVerts] = (double) ((int) (cl->y[i1] / dNumRows + 0.5));

               if((Xmap[i2] != Xmap[NumMapVerts]) || (Ymap[i2] != Ymap[NumMapVerts]))
                  {
                  ++NumMapVerts;
                  ++i2;
                  if(Xmap[i2] < minx1)
                     minx1 = Xmap[i2];
                  if(Xmap[i2] > maxx1)
                     maxx1 = Xmap[i2];
                  if(Ymap[i2] < miny1)
                     miny1 = Ymap[i2];
                  if(Ymap[i2] > maxy1)
                     maxy1 = Ymap[i2];
                  }
               }
            if(NumMapVerts == 1)
               {
               i1 = (int) Xmap[0];
               j1 = (int) Ymap[0];
               PBM2[IM - j1].Row[i1].color = pixcolor;
               }
            else if(NumMapVerts == 2)
               {
               DrawPGMlines(Xmap[0], Ymap[0], Xmap[1], Ymap[1], pixcolor);
               }
            else if(NumMapVerts > 2)
               {
               i1 = 0;
               for(i2 = 1; i2 <NumMapVerts; i2++)
                  {
                  DrawPGMlines(Xmap[i1], Ymap[i1], Xmap[i2], Ymap[i2], pixcolor);
                  ++i1;
                  }
               }
               
            free(Xmap);
            free(Ymap);

            }
         if(ConserveMemory == 0)
            {
            free(cl->x);
            free(cl->y);
            free(cl->z);
            free(cl);
            }
         }
      else
         {
         ind1 = (Sx * YindexExtent) + Sy;
         LinearTable[ind1].numlinear += 1;
         if(ConserveMemory == 0)
            {
            cl->next = LinearTable[ind1].inside;
            LinearTable[ind1].inside = cl;
            }
         else
            {
            CM_Objects[ObjectIndex].filenumber = infilenumber;
            CM_Objects[ObjectIndex].compositeindex = ind1;
            CM_Objects[ObjectIndex].fileptr = infileposn;
            ++ObjectIndex;
            }
         
         InsertIntoSCCtable(0,ind1, cl->Lindex, cl->idn,cl->featureid);


         i1 = 0;
         if((ShadedReliefRequired) && (LandMarksSet > 0) && (DO_LINES))
            {
            switch (SCCdataArray[cl->Sindex].D)
               {
               case D_NONE:
                  i1 = 0;
                  break;
               default:
                  i1 = 1;
                  break;
               }
            }

	 if(NGA_TYPE==1)
	   {
	     i1 = 0;
	   }

         if((NGA_TYPE == 0) && (i1 > 0) && (cl->numnodes > 1))
            {

	   pixcolor = SpecialDomainColors[SCCdataArray[cl->Sindex].D];


            Xmap = (double *) (malloc(SzD * cl->numnodes));
            Ymap = (double *) (malloc(SzD * cl->numnodes));
            NumMapVerts = 1;            minx1 = maxx1 = Xmap[0] = (double) ((int) (cl->x[0] / dNumCols + 0.5));
            miny1 = maxy1 = Ymap[0] = (double) ((int) (cl->y[0] / dNumRows + 0.5));
            i2 = 0;
            for(i1 = 1; i1< cl->numnodes; i1++)
               {
               Xmap[NumMapVerts] = (double) ((int) (cl->x[i1] / dNumCols + 0.5));
               Ymap[NumMapVerts] = (double) ((int) (cl->y[i1] / dNumRows + 0.5));

               if((Xmap[i2] != Xmap[NumMapVerts]) || (Ymap[i2] != Ymap[NumMapVerts]))
                  {
                  ++NumMapVerts;
                  ++i2;
                  if(Xmap[i2] < minx1)
                     minx1 = Xmap[i2];
                  if(Xmap[i2] > maxx1)
                     maxx1 = Xmap[i2];
                  if(Ymap[i2] < miny1)
                     miny1 = Ymap[i2];
                  if(Ymap[i2] > maxy1)
                     maxy1 = Ymap[i2];
                  }
               }
            if(NumMapVerts == 1)
               {
               i1 = (int) Xmap[0];
               j1 = (int) Ymap[0];
               PBM2[IM - j1].Row[i1].color = pixcolor;
               }
            else if(NumMapVerts == 2)
               {
               DrawPGMlines(Xmap[0], Ymap[0], Xmap[1], Ymap[1], pixcolor);
               }
            else if(NumMapVerts > 2)
               {
               i1 = 0;
               for(i2 = 1; i2 <NumMapVerts; i2++)
                  {
                  DrawPGMlines(Xmap[i1], Ymap[i1], Xmap[i2], Ymap[i2], pixcolor);
                  ++i1;
                  }
               }

            free(Xmap);
            free(Ymap);

            }

         } /*** end linear is inside a single region ***/

         infileposn = ftell(linearsin);

         SEEIT_fread_int(&idnumber,linearsin);
         if(feof(linearsin) != 0)
            {
            ++infilenumber;
            if(infilenumber > NumLinearFiles)
               break;
            i4 = 0;
            i5 = 0;
            while(linearfile[i4] != '\0')
               {
               lfilein[i5] = linearfile[i4];
               ++i4;
               ++i5;
               }
            while((i5 > 0) && (lfilein[i5] != '.'))
               --i5;

            sprintf(&lfilein[i5],"%d",infilenumber);
            strcat(lfilein,".bin");
            
            linearsin = InFileHandles[infilenumber-1].fp;

printf("opening input file %s\n",lfilein);
            if(linearsin == NULL)
               {
 printf("no such file - breaking\n");
               break;
               }
            infileposn = ftell(linearsin);
            SEEIT_fread_int(&idnumber,linearsin);
            }
      }

   if(ConserveMemory == 1)
      {
      for(i=0; i<listlength; i++)
         {
         if(LinearTable[i].numlinear > 0)
            {
            LinearTable[i].insideindices = (int *) (malloc(SzI * (LinearTable[i].numlinear + 1)));
            LinearTable[i].insideindices[0] = 1;
            for(j=1; j<=LinearTable[i].numlinear; j++)
               LinearTable[i].insideindices[j] = -1;
            if(LinearTable[i].numlinear > MaxInside)
               MaxInside = LinearTable[i].numlinear;
            }
         else
            LinearTable[i].insideindices = NULL;
         }
     free(cl->x);
     free(cl->y);
     free(cl->z);
     free(cl);


      L = (struct RawFormatLinear *) malloc(SzRL * MaxInside);
      if(L == NULL)
         {
         printf("allocation memory exhausted during linear format\n");
         exit(-1);
         }


      /* tim added */
      if(MaxVerts<=smallvertexnum)
	{
	  vertexallocnum = MaxVerts;
	}
      else
	{
	  vertexallocnum = smallvertexnum;
	}


      for(i=0; i<MaxInside; i++)
         {
         L[i].featureid = -1;
         L[i].Lindex = -1;
         L[i].Sindex = -1;
         L[i].idn = -1;
         L[i].numnodes =  0;

         L[i].x = (double *) (malloc(vertexallocnum * SzD));
         L[i].y = (double *) (malloc(vertexallocnum * SzD));
         L[i].z = (double *) (malloc(vertexallocnum * SzD));
         if((L[i].x == NULL) || (L[i].y == NULL) || (L[i].z == NULL))
            {
            printf("allocation memory exhausted during linear format\n");
            exit(-1);
            }
         }

      for(i=0; i<ObjectIndex; i++)
         {
         i1 = CM_Objects[i].compositeindex;
         j1 = LinearTable[i1].insideindices[0];
         if(j1 <= LinearTable[i1].numlinear)
            LinearTable[i1].insideindices[j1] = i;
         else
            {
            printf("mismatch between expected number of inside linear and number foound\n");
            printf("array index violation will result\n");
            exit(-1);
            }
         ++j1;
         LinearTable[i1].insideindices[0] = j1;
         }

      infilenumber = 1;
      linearsin = InFileHandles[0].fp;

      if(linearsin == NULL)
         {
         printf("(0) fatal error when reopening linear input file %s\n", linearfile);
         exit(-1);
         }

      for(i=0; i<listlength; i++)
         {

         if(outfilesize > LINEARNODELIMIT)
            {
            outfilesize = 0;
            fclose(dataout);
            ++outfilenumber;
            sprintf(suffix,"%d",outfilenumber);
            strcpy(lfileout,lineardata);
            strcat(lfileout,suffix);
            dataout = fopen(lfileout,"wb");
printf("new linear output file %s\n",lfileout);
            }

         if(NGA_TYPE == 1)
            BuildOpenMenu(0.0,SACttl*2,SACttl*2,LinearsRead,areals_done,model_polys,areals_done,*linears_done,points_done,
                sphere_cv,parallel_cv,stamps_done,footprints_done, bridges_done,g_read,g_write,
                FMpointsdone,FMlinesdone,FMarealsdone,0.0,0.0,0.0,0.0,0);
         else
            BuildOpenMenu(0.0,SACttl*2,SACttl*2,polys_read,polys_done,model_polys,areals_done,*linears_done,points_done,
             sphere_cv,parallel_cv,stamps_done,footprints_done, bridges_done,g_read,g_write,
             FMpointsdone,FMlinesdone,FMarealsdone,0.0,0.0,0.0,0.0,0);

         LinearTable[i].fileptr = ftell(dataout);
         LinearTable[i].filenumber = outfilenumber;

         if(LinearTable[i].numlinear > 0)
            {
            clindex = 0;
            for(j=1; j<=LinearTable[i].numlinear; j++)
               {
               i1 = LinearTable[i].insideindices[j];

               if(CM_Objects[i1].filenumber != infilenumber)
                  {
                  infilenumber = CM_Objects[i1].filenumber;
                  linearsin = InFileHandles[infilenumber-1].fp;
                  }
               fseek(linearsin,CM_Objects[i1].fileptr,SEEK_SET);

               SEEIT_fread_int(&L[clindex].featureid,linearsin);
               SEEIT_fread_int(&L[clindex].Lindex,linearsin);
               SEEIT_fread_int(&L[clindex].Sindex,linearsin);
               SEEIT_fread_int(&L[clindex].idn,linearsin);
               SEEIT_fread_int(&L[clindex].numnodes,linearsin);
               if(L[clindex].numnodes > MaxVerts)
                  {
printf("Maxverts is %d new requirement %d\n",MaxVerts,L[clindex].numnodes);
exit(-1);
                  }

               if(L[clindex].numnodes > vertexallocnum)
		 {
		   num_realloc++;
		   if(num_realloc%1000==0)
		     {
		       printf("reallocced %d\n",num_realloc);
		     }

		   L[clindex].x = (double *) (realloc(L[clindex].x,  SzD * L[clindex].numnodes));
		   L[clindex].y = (double *) (realloc(L[clindex].y,  SzD * L[clindex].numnodes));
		   L[clindex].z = (double *) (realloc(L[clindex].z,  SzD * L[clindex].numnodes));
		 }
	       


               for(j1=0; j1<L[clindex].numnodes; j1++)
                  {
                  SEEIT_fread_double(&L[clindex].x[j1],linearsin);
                  SEEIT_fread_double(&L[clindex].y[j1],linearsin);
                  SEEIT_fread_double(&L[clindex].z[j1],linearsin);
                  if(CoordSystem == 1) /** GDC ***/
                     {
                     L[clindex].x[j1] = (L[clindex].x[j1] - Xtranslation) * 100000.0;
                     L[clindex].y[j1] = (L[clindex].y[j1] - Ytranslation) * 100000.0;
                     }
                  else if(CoordSystem == 2) /** UTM **/
                     {
                     L[clindex].x[j1] = L[clindex].x[j1] - Xtranslation;
                     L[clindex].y[j1] = L[clindex].y[j1] - Ytranslation;
                     }
                  }

               ++clindex;
               }

            clindex = 0;
            for(j=1; j<=LinearTable[i].numlinear; j++)
               {
               if(NGA_TYPE == 1)
                  *linears_done += 1;

               SEEIT_fwrite_int(&L[clindex].featureid,dataout);
               SEEIT_fwrite_int(&L[clindex].Lindex,dataout);
               SEEIT_fwrite_int(&L[clindex].Sindex,dataout);
               SEEIT_fwrite_int(&L[clindex].idn,dataout);
               SEEIT_fwrite_int(&L[clindex].numnodes,dataout);
               for(j1=0; j1<L[clindex].numnodes; j1++)
                  {
                  SEEIT_fwrite_double(&L[clindex].x[j1],dataout);
                  SEEIT_fwrite_double(&L[clindex].y[j1],dataout);
                  SEEIT_fwrite_double(&L[clindex].z[j1],dataout);
                  }

               outfilesize += L[clindex].numnodes;
               ++clindex;
               }
            }
         }

      }

   else if(ConserveMemory == 0)
      {
      for(i=0; i<listlength; i++)
         {
         if(LinearTable[i].numlinear > 0) 
            {
            LinearTable[i].fileptr = ftell(dataout);
            LinearTable[i].filenumber = outfilenumber;
            cl = LinearTable[i].inside;
            while(cl != NULL)
               {
               SEEIT_fwrite_int(&cl->featureid,dataout);
               SEEIT_fwrite_int(&cl->Lindex,dataout);
               SEEIT_fwrite_int(&cl->Sindex,dataout);
               SEEIT_fwrite_int(&cl->idn,dataout);
               SEEIT_fwrite_int(&cl->numnodes,dataout);
               for(j=0; j<cl->numnodes; j++)
                  {
                  SEEIT_fwrite_double(&cl->x[j],dataout);
                  SEEIT_fwrite_double(&cl->y[j],dataout);
                  SEEIT_fwrite_double(&cl->z[j],dataout);
                  }
               if(NGA_TYPE == 1)
                  *linears_done += 1;

               outfilesize += cl->numnodes;
               cl = cl->next;
               }
            if(outfilesize > LINEARNODELIMIT)
               {
               outfilesize = 0;
               fclose(dataout);
               ++outfilenumber;
               sprintf(suffix,"%d",outfilenumber);
               strcpy(lfileout,lineardata);
               strcat(lfileout,suffix);
               dataout = fopen(lfileout,"wb");
printf("new linear output file %s\n",lfileout);
               }
            }
         }
      }
   fclose(dataout);

   for(i=0; i<NumLinearFiles; i++)
      {
      fclose(InFileHandles[i].fp);
      }
   free(InFileHandles);

   MPoc = LineMProot;
   while(MPoc != NULL)
      {
      if(MPoc->used > 1)
         *linears_done = *linears_done - MPoc->parts + 1;
      MPoc = MPoc->next;
      }


   if(NGA_TYPE == 1)
      BuildOpenMenu(0.0,SACttl*2,SACttl*2,LinearsRead,areals_done,model_polys,areals_done,*linears_done,points_done,
          sphere_cv,parallel_cv,stamps_done,footprints_done, bridges_done,g_read,g_write,
          FMpointsdone,FMlinesdone,FMarealsdone,0.0,0.0,0.0,0.0,0);
   else
      BuildOpenMenu(0.0,SACttl*2,SACttl*2,polys_read,polys_done,model_polys,areals_done,*linears_done,points_done,
       sphere_cv,parallel_cv,stamps_done,footprints_done, bridges_done,g_read,g_write,
       FMpointsdone,FMlinesdone,FMarealsdone,0.0,0.0,0.0,0.0,0);


   SingleLinears = 0;
   MultiLinears = 0;
   tableout = fopen(lineartablefile,"wb");
   for(i=0; i<listlength; i++)
      {
      SingleLinears +=  LinearTable[i].numlinear;
      MultiLinears += LinearTable[i].numother;
      SEEIT_fwrite_int(&LinearTable[i].numlinear,tableout);
      SEEIT_fwrite_long(&LinearTable[i].fileptr,tableout);
      SEEIT_fwrite_int(&LinearTable[i].filenumber,tableout);
      SEEIT_fwrite_int(&LinearTable[i].numother,tableout);
      plst = LinearTable[i].others;
      while(plst != NULL)
         {
         clst = plst;
         plst = plst->next;
         SEEIT_fwrite_long(&clst->fileptr,tableout);
         SEEIT_fwrite_int(&clst->filenumber,tableout);
         free(clst);
         }
      if(ConserveMemory == 0)
         {
         cl = LinearTable[i].inside;
         while(cl != NULL)
            {
            pl = cl;
            cl = cl->next;
            free(pl->x);
            free(pl->y);
            free(pl->z);
            free(pl);
            }
         }
      else
         {
         if(LinearTable[i].insideindices != NULL)
            free(LinearTable[i].insideindices);
         }
      }

   if(NGA_TYPE == 1)
      BuildOpenMenu(0.0,SACttl*2,SACttl*2,LinearsRead,areals_done,model_polys,areals_done,*linears_done,points_done,
          sphere_cv,parallel_cv,stamps_done,footprints_done, bridges_done,g_read,g_write,
          FMpointsdone,FMlinesdone,FMarealsdone,0.0,0.0,0.0,0.0,0);
   else
      BuildOpenMenu(0.0,SACttl*2,SACttl*2,polys_read,polys_done,model_polys,areals_done,*linears_done,points_done,
       sphere_cv,parallel_cv,stamps_done,footprints_done, bridges_done,g_read,g_write,
       FMpointsdone,FMlinesdone,FMarealsdone,0.0,0.0,0.0,0.0,0);


   if(ConserveMemory == 1)
      {
      free(CM_Objects);

      for(i=0; i<MaxInside; i++)
         {
         free(L[i].x);
         free(L[i].y);
         free(L[i].z);
         }
      free(L);
      }
   fclose(tableout);
   free(LinearTable);
}
                



void FormatBridges(int SACttl,unsigned char CoordSystem,
                 int polys_read, int polys_done,int model_polys,int areals_done,int linears_done,int points_done,
                 int sphere_cv,int parallel_cv,int stamps_done,int *footprints_done,
                 int *bridges_done, unsigned int g_read, unsigned int g_write, int FMpointsdone, int FMlinesdone, int FMarealsdone)
{
FILE *bin, *bout, *tableout;
struct RawBridge
   {
   int Bindex;
   int Lindex;
   int Sindex;
   int numverts;
   int idn;
   double * x;
   double * y;
   double * z;
   double * h;
   struct RawBridge * next;
   } ;
struct BridgeLookup
   {
   int numpoints;
   struct RawBridge * inside;
   int numother;
   long int fileptr;
   struct ObjPtrList *others;
   } * BridgeTable;
int SzBL = sizeof(struct BridgeLookup);
int SzRB = sizeof(struct RawBridge);
int SzPtrList = sizeof(struct ObjPtrList);
int XindexExtent, YindexExtent;
int listlength;
double fx, fy, fz ,fh;
int i,j,k,bridgeindex;
struct RawBridge *cp, *pp;
struct ObjPtrList *plst, *clst;
int ix,iy;
int SinglePoints;
int MultiPoints;
int ind1;
long int fileposn;
int Sx,Sy,Ex,Ey, inside;
double minX, minY, maxX, maxY;
double d1,d2,d3,d4;
double dx1,dy1,dx2,dy2, Xint,Yint;
double dNumCols, dNumRows;
double *Xmap;
double *Ymap;
double minx1, maxx1, miny1, maxy1;
int NumMapVerts;
unsigned char pixcolor;
double px,py;
int i1, i2, j1;
int IM = ImageMaxSize - 1;


      bin = fopen(bridgefile,"rb");
   if(bin == NULL)
      {
      printf("No associated file of bridge feature data (%s is missing)\n",bridgefile);
      return;
      }

   bout = fopen(bridgedata,"wb");

   if(NGA_TYPE==1)
    {
      pixcolor =  SpecialDomainColors[D_GRTR];
    }    
  else
    {
      pixcolor = SpecialDomainColors[D_BRID];
    }


   dNumCols = PointsPerPixel;
   dNumRows = PointsPerPixel;


   BuildOpenMenu(0.0,SACttl*2,SACttl*2,polys_read,polys_done,model_polys,areals_done,linears_done,points_done,
          sphere_cv,parallel_cv,stamps_done,*footprints_done, *bridges_done,g_read,g_write,
          FMpointsdone,FMlinesdone,FMarealsdone,0.0,0.0,0.0,0.0,0); 

   XindexExtent = (int) (MaxXcoord / LRegionSize) + 2;
   YindexExtent = (int) (MaxYcoord / LRegionSize) + 2;

   listlength = XindexExtent * YindexExtent;
   BridgeTable = (struct BridgeLookup *) (malloc(SzBL * listlength));
   if(BridgeTable == NULL)
      {
      printf("allocation memory exhausted during point feature processing (file %s)\n",bridgefile);
      exit(-1);
      }

   for(i=0; i<listlength; i++)
      {
      BridgeTable[i].numpoints = 0;
      BridgeTable[i].inside = NULL;
      BridgeTable[i].numother = 0;
      BridgeTable[i].fileptr = 0;
      BridgeTable[i].others = NULL;
      }

   SEEIT_fread_int(&bridgeindex,bin);

   while(feof(bin) == 0)
      {
      cp = (struct RawBridge *) malloc(SzRB);
      if(cp == NULL)
         {
         printf("allocation memory exhausted during bridge format\n");
         exit(-1);
         }
      cp->next = NULL;

         cp->Bindex = bridgeindex;
         SEEIT_fread_int(&cp->Lindex,bin);
         SEEIT_fread_int(&cp->Sindex,bin);
         cp->idn = -1;
         SEEIT_fread_int(&k,bin);
         cp->numverts = (int) k;
         

      ClassData[cp->Sindex].occurrences += 1;
      NArray[cp->Lindex].occurrences += 1;
      NArray[cp->Lindex].configcount[ClassData[cp->Sindex].C] += 1; /** bump bridge model counter **/
      LongListInstances[cp->Lindex] += 1;
      if(LongToShortMap[cp->Lindex] < 0)
         LongToShortMap[cp->Lindex] = cp->Sindex;
      else if(LongToShortMap[cp->Lindex] != cp->Sindex)
         {
         printf("FATAL ERROR -- found one too many mappings from long to short list!!!!\n");
         printf("mapping long list index %d into both %d and %d on short list\n",cp->Lindex,
                 LongToShortMap[cp->Lindex],cp->Sindex);
         exit(-1);
         }

      cp->x = (double *) (malloc(cp->numverts * SzD));
      cp->y = (double *) (malloc(cp->numverts * SzD));
      cp->z = (double *) (malloc(cp->numverts * SzD));
      cp->h = (double *) (malloc(cp->numverts * SzD));
      if((cp->h == NULL) || (cp->y == NULL) || (cp->z == NULL))
         {
         printf("allocation memory exhausted during bridge feature format\n");
         exit(-1);
         }

         maxX = maxY = 0.0;
         minX = MaxXcoord;
         minY = MaxYcoord;
         for(i=0; i<cp->numverts; i++)
            {
               SEEIT_fread_double(&fx,bin);
               SEEIT_fread_double(&fy,bin);
               SEEIT_fread_double(&fz,bin);
               SEEIT_fread_double(&fh,bin);
               
            if(CoordSystem == 1) /** GDC ***/
               {
               cp->x[i] = (fx - Xtranslation) * 100000.0;
               cp->y[i] = (fy - Ytranslation) * 100000.0;
               }
            else if(CoordSystem == 2) /** UTM **/
               {
               cp->x[i] = fx - Xtranslation;
               cp->y[i] = fy - Ytranslation;
               }
            cp->z[i] = fz;
            cp->h[i] = fh;
            if(cp->x[i] < minX)
               minX = cp->x[i];
            if(cp->x[i] > maxX)
               maxX = cp->x[i];
            if(cp->y[i] < minY)
               minY = cp->y[i];
            if(cp->y[i] > maxY)
               maxY = cp->y[i];
            }

      *bridges_done += 1;
      *footprints_done += 1;
      if((*bridges_done % 100) == 0)
         BuildOpenMenu(0.0,SACttl*2,SACttl*2,polys_read,polys_done,model_polys,areals_done,linears_done,points_done,
                sphere_cv,parallel_cv,stamps_done,*footprints_done, *bridges_done,g_read,g_write,
                FMpointsdone,FMlinesdone,FMarealsdone,0.0,0.0,0.0,0.0,0);

         if((NGA_TYPE == 0) && (ShadedReliefRequired) && (LandMarksSet > 0) &&(DO_LINES))
            {
            Xmap = (double *) (malloc(SzD * cp->numverts));
            Ymap = (double *) (malloc(SzD * cp->numverts));
            NumMapVerts = 1;
            minx1 = maxx1 = Xmap[0] = (double) ((int) (cp->x[0] / dNumCols + 0.5));
            miny1 = maxy1 = Ymap[0] = (double) ((int) (cp->y[0] / dNumRows + 0.5));
            i2 = 0;
            for(i1 = 1; i1< cp->numverts; i1++)
               {
               Xmap[NumMapVerts] = (double) ((int) (cp->x[i1] / dNumCols + 0.5));
               Ymap[NumMapVerts] = (double) ((int) (cp->y[i1] / dNumRows + 0.5));

               if((Xmap[i2] != Xmap[NumMapVerts]) || (Ymap[i2] != Ymap[NumMapVerts]))
                  {
                  ++NumMapVerts;
                  ++i2;
                  if(Xmap[i2] < minx1)
                     minx1 = Xmap[i2];
                  if(Xmap[i2] > maxx1)
                     maxx1 = Xmap[i2];
                  if(Ymap[i2] < miny1)
                     miny1 = Ymap[i2];
                  if(Ymap[i2] > maxy1)
                     maxy1 = Ymap[i2];
                  }
               }
            if((NumMapVerts > 1) &&
                   (Xmap[NumMapVerts - 1] == Xmap[0]) && (Ymap[NumMapVerts-1] == Ymap[0]))
               --NumMapVerts;

            if(NumMapVerts == 1)
               {
               i1 = (int) Xmap[0];
               j1 = (int) Ymap[0];
               PBM2[IM - j1].Row[i1].color = pixcolor;
               }
            else if(NumMapVerts == 2)
               {
               DrawPGMlines(Xmap[0], Ymap[0], Xmap[1], Ymap[1], pixcolor);
               }
            else if((NumMapVerts > 2) && (DO_LINES > 0))
               {
               i1 = 0;
               for(i2 = 1; i2 <NumMapVerts; i2++)
                  {
                  DrawPGMlines(Xmap[i1], Ymap[i1], Xmap[i2], Ymap[i2], pixcolor);
                  ++i1;
                  }
               --i2;
               DrawPGMlines(Xmap[0], Ymap[0], Xmap[i2], Ymap[i2], pixcolor);
               }
            else if(NumMapVerts > 2)
               {
               for(px = minx1; px < maxx1; px += 1.0)
                  {
                  i1 = (int) px;
                  for(py = miny1; py < maxy1; py += 1.0)
                     {
                     if(LocalPointInsidePoly(px,py,Xmap,Ymap,NumMapVerts))
                        {
                        j1 = (int) py;
                        PBM2[IM - j1].Row[i1].color = pixcolor;
                        }
                     }
                  }
               }
            free(Xmap);
            free(Ymap);
            }



      inside = 0;
      Sx = (int) (minX / LRegionSize);
      Ex = (int) (maxX / LRegionSize);
      Sy = (int) (minY / LRegionSize);
      Ey = (int) (maxY / LRegionSize);
      if((Sx != Ex) || (Sy != Ey))
         {
         fileposn = ftell(bout);

         SEEIT_fwrite_int(&cp->Bindex,bout);
         SEEIT_fwrite_int(&cp->Lindex,bout);
         SEEIT_fwrite_int(&cp->Sindex,bout);
         SEEIT_fwrite_int(&cp->numverts,bout);

         for(i=0; i<cp->numverts; i++)
            {
            SEEIT_fwrite_double(&cp->x[i],bout);
            SEEIT_fwrite_double(&cp->y[i],bout);
            SEEIT_fwrite_double(&cp->z[i],bout);
            SEEIT_fwrite_double(&cp->h[i],bout);
            }

         for(ix = Sx; ix <= Ex; ix ++)
            {
            d1 = (double) ix * LRegionSize;
            d2 = d1 + LRegionSize;
            for(iy = Sy; iy <= Ey; iy++)
               {
               d3 = (double) iy * LRegionSize;
               d4 = d3 + LRegionSize;
               inside = 0;
               if(LocalPointInsidePoly(d1,d3,cp->x,cp->y,cp->numverts))
                  {
                  inside = 1;
                  }
               else if(LocalPointInsidePoly(d1,d4,cp->x,cp->y,cp->numverts))
                  {
                  inside = 1;
                  }
               else if(LocalPointInsidePoly(d2,d3,cp->x,cp->y,cp->numverts))
                  {
                  inside = 1;
                  }
               else if(LocalPointInsidePoly(d2,d4,cp->x,cp->y,cp->numverts))
                  {
                  inside = 1;
                  }
               if(inside > 0)
                  {
                  ind1 = (ix * YindexExtent) + iy;
                  BridgeTable[ind1].numother += 1;
                  plst = (struct ObjPtrList *) (malloc(SzPtrList));
                  plst->fileptr = fileposn;
                  plst->next = BridgeTable[ind1].others;
                  BridgeTable[ind1].others = plst;
                  InsertIntoSCCtable(0,ind1, cp->Lindex, cp->idn,-1);
                  }
               else /** above case did not occur, so check for intersections **/
                  {
                  dx2 = (double) cp->x[0];
                  dy2 = (double) cp->y[0];
                  for(i=0; i<cp->numverts; i++)
                     {
                     j = (i + 1) % cp->numverts;
                     dx1 = dx2;
                     dy1 = dy2;
                     dx2 = (double) cp->x[j];
                     dy2 = (double) cp->y[j];
                     if(LocalLineSegmentsIntersect(d1,d3,d2,d3,dx1,dy1,dx2,dy2,&Xint,&Yint) > 0)
                        inside = 1;
                     else if(LocalLineSegmentsIntersect(d1,d3,d1,d4,dx1,dy1,dx2,dy2,&Xint,&Yint) > 0)
                        inside = 1;
                     else if(LocalLineSegmentsIntersect(d2,d4,d2,d3,dx1,dy1,dx2,dy2,&Xint,&Yint) > 0)
                        inside = 1;
                     else if(LocalLineSegmentsIntersect(d2,d4,d1,d4,dx1,dy1,dx2,dy2,&Xint,&Yint) > 0)
                        inside = 1;
                     if(inside > 0)
                        {
                        ind1 = (ix * YindexExtent) + iy;
                        BridgeTable[ind1].numother += 1;
                        plst = (struct ObjPtrList *) (malloc(SzPtrList));
                        plst->fileptr = fileposn;
                        plst->next = BridgeTable[ind1].others;
                        BridgeTable[ind1].others = plst;
                        InsertIntoSCCtable(0,ind1, cp->Lindex, cp->idn,-1);
                        break;
                        }
                     }
                  }
               }
            }
         free(cp->x);
         free(cp->y);
         free(cp->z);
         free(cp->h);
         free(cp);
         }
      else
         {
         ind1 = (Sx * YindexExtent) + Sy;
         BridgeTable[ind1].numpoints += 1;
         cp->next = BridgeTable[ind1].inside;
         BridgeTable[ind1].inside = cp;
         InsertIntoSCCtable(0,ind1, cp->Lindex, cp->idn,-1);
         }
      if(feof(bin) == 0)
         {
         SEEIT_fread_int(&bridgeindex,bin);
         }
      }
   fclose(bin);

   for(i=0; i<listlength; i++)
      {
      if(BridgeTable[i].numpoints > 0)
         BridgeTable[i].fileptr = ftell(bout);
      cp = BridgeTable[i].inside;
      while(cp != NULL)
         {
         SEEIT_fwrite_int(&cp->Bindex,bout);
         SEEIT_fwrite_int(&cp->Lindex,bout);
         SEEIT_fwrite_int(&cp->Sindex,bout);
         SEEIT_fwrite_int(&cp->numverts,bout);
         for(j=0; j<cp->numverts; j++)
            {
            SEEIT_fwrite_double(&cp->x[j],bout);
            SEEIT_fwrite_double(&cp->y[j],bout);
            SEEIT_fwrite_double(&cp->z[j],bout);
            SEEIT_fwrite_double(&cp->h[j],bout);
            }
         cp = cp->next;
         }
      }

   fclose(bout);

   SinglePoints = 0;
   MultiPoints = 0;
   tableout = fopen(bridgetablefile,"wb");
   for(i=0; i<listlength; i++)
      {
      SinglePoints +=  BridgeTable[i].numpoints;
      MultiPoints += BridgeTable[i].numother;
      SEEIT_fwrite_int(&BridgeTable[i].numpoints,tableout);
      SEEIT_fwrite_long(&BridgeTable[i].fileptr,tableout);
      SEEIT_fwrite_int(&BridgeTable[i].numother,tableout);
      plst = BridgeTable[i].others;
      while(plst != NULL)
         {
         clst = plst;
         plst = plst->next;
         SEEIT_fwrite_long(&clst->fileptr,tableout);
         free(clst);
         }
      cp = BridgeTable[i].inside;
      while(cp != NULL)
         {
         pp = cp;
         cp = cp->next;
         free(pp->x);
         free(pp->y);
         free(pp->z);
         free(pp->h);
         free(pp);
         }
      }
   fclose(tableout);
   free(BridgeTable);

}




void FormatPoints(int SACttl,unsigned char CoordSystem,
                 int polys_read, int polys_done,int model_polys,int areals_done,int linears_done,int *points_done,
                 int *sphere_cv,int *parallel_cv,int *stamps_done,int *footprints_done,
                 int bridges_done, unsigned int g_read, unsigned int g_write, int *FMpointsdone, int FMlinesdone, int FMarealsdone)
{

FILE *pin, *pout, *tableout;
struct RawFormatPoint
   {
   int Lindex;
   int Sindex;
   int idn;
   int featureid;
   double x;
   double y;
   double z;
   struct RawFormatPoint * next;
   } *ThePoints;
struct SeekPosnList
   {
   long int posn;
   struct SeekPosnList *next;
   };
struct PointLookup
   {
   int numpoints;
   struct RawFormatPoint * inside;
   long int fileptr;
   struct SeekPosnList *sp;
   } * PointTable;

FILE * gcppoints;
char *gcpfilename;

int SzPL = sizeof(struct PointLookup);
int SzRP = sizeof(struct RawFormatPoint);
int SzSPL = sizeof(struct SeekPosnList);
int XindexExtent, YindexExtent, listlength;
int Lindex, Sindex;
int numverts, FIXnumverts;
int featureID;
long int seekposition;
double fx, fy, fz, FIXrad,FIXh;
int FIXnumother;
int i,k,j,sl;
double ttlpoints;
int Sidn;
struct RawFormatPoint *cp;
struct SeekPosnList *spc, *spn;
int SinglePoints,MultiPoints;
int WriteIndex, maxperLM;
int Sx,Sy,Ex,Ey;
int IsGCP, IsICESAT;
double minX, minY, maxX, maxY;

   GCPread = 0;
   ICESATread = 0;
   ThePoints = NULL;
   maxperLM = 0;
   ttlpoints = 0.0;
   pin = fopen(pointfile,"rb");
   if(pin == NULL)
      {
      printf("No associated file of point feature data (%s is missing)\n",pointfile);
      return;
      }

   pout = fopen(pointdata,"wb");
   if(pout == NULL)
      {
      printf("cannot open file %s for write update\n",pointdata);
      exit(-1);
      }


   BuildOpenMenu(0.0,SACttl*2,SACttl*2,linears_done,polys_done,model_polys,areals_done,linears_done,*points_done,
          *sphere_cv,*parallel_cv,*stamps_done,*footprints_done, bridges_done,g_read,g_write,
          *FMpointsdone,FMlinesdone,FMarealsdone,0.0,0.0,0.0,0.0,0);

   XindexExtent = (int) (MaxXcoord / LRegionSize) + 2;
   YindexExtent = (int) (MaxYcoord / LRegionSize) + 2;

   listlength = XindexExtent * YindexExtent;
   PointTable = (struct PointLookup *) (malloc(SzPL * listlength));
   if(PointTable == NULL)
      {
      printf("allocation memory exhausted during point feature processing (file %s)\n",pointfile);
      exit(-1);
      }

   for(i=0; i<listlength; i++)
      {
      PointTable[i].numpoints = 0;
      PointTable[i].inside = NULL;
      PointTable[i].fileptr = 0;
      PointTable[i].sp = NULL;
      }

   MPoc = PointMProot;
   while(MPoc != NULL)
      {
      MPoc->used = 0;
      MPoc = MPoc->next;
      }


   printf("processing point feature data from file %s\n",pointfile);
   FIXnumverts = -1;
   FIXnumother = 0;
   FIXrad = FIXh = 0.0;

   cp = (struct RawFormatPoint *) malloc(SzRP);
   if(cp == NULL)
      {
      printf("allocation memory exhausted during point format operation\n");
      exit(-1);
      }
   cp->next = NULL;

   j = 0;

   gcppoints = NULL;

   seekposition = ftell(pin);

   SEEIT_fread_int(&featureID,pin);

   while(feof(pin) == 0)
      {

      SEEIT_fread_int(&Lindex,pin);
      SEEIT_fread_int(&Sindex,pin);
      SEEIT_fread_int(&Sidn,pin); /*** point object ID **/
      SEEIT_fread_int(&numverts,pin);
      if(numverts != -1)
         {
         printf("unexpected numverts in formating NGA point data: %d\n",numverts);
         exit(-1);
         }

      cp->featureid = featureID;
      cp->Lindex = Lindex;
      cp->Sindex = Sindex;
      cp->idn = Sidn;

      if(IDHfp != NULL)
         {
         InspectUID(cp->Lindex,cp->idn, cp->featureid, "Point");
         }

      MPoc = PointMProot;
      while(MPoc != NULL)
         {
         if(MPoc->featureid == cp->idn)
            {
            MPoc->used += 1;
            if(MPoc->used == 1)
               MPoc->ECC = ClassData[cp->Sindex].ECC;
            break;
            }
         MPoc = MPoc->next;
         }

      if((MPoc == NULL) || ((MPoc != NULL) && (MPoc->used == 1)))
         {
         ClassData[cp->Sindex].occurrences += 1;
         NArray[cp->Lindex].occurrences += 1;
         NArray[cp->Lindex].configcount[ClassData[cp->Sindex].C] += 1; /** bump point counter **/
         LongListInstances[cp->Lindex] += 1;
         }

      if(LongToShortMap[cp->Lindex] < 0)
         LongToShortMap[cp->Lindex] = cp->Sindex;
      else if(LongToShortMap[cp->Lindex] != cp->Sindex)
         {
         printf("FATAL ERROR -- found one too many mappings from long to short list!!!!!\n");
         printf("mapping long list index %d into both %d and %d on short list\n",cp->Lindex,
                 LongToShortMap[cp->Lindex],cp->Sindex);
         exit(-1);
         }
      if(numverts == -1)
        {
        ++j;
        ttlpoints += 0.3;
        SEEIT_fread_double(&fx,pin);
        SEEIT_fread_double(&fy,pin);
        SEEIT_fread_double(&fz,pin);
      IsGCP = IsICESAT = 0;
      if(cp->Lindex == gcpindex1_0)
         IsGCP = 1;
      else if(cp->Lindex == gcpindex1_1)
         IsGCP = 2;
      else if(cp->Lindex == gcpindex1_2)
         IsGCP = 3;
      else if(cp->Lindex == gcpindex1_3)
         IsGCP = 4;
      else if(cp->Lindex == gcpindex2_0)
         IsICESAT = 5;
      else if(cp->Lindex == gcpindex2_1)
         IsICESAT = 6;
      else if(cp->Lindex == gcpindex2_2)
         IsICESAT = 7;
      else if(cp->Lindex == gcpindex2_3)
         IsICESAT = 8;
      if(IsGCP > 0)
         {
         ++GCPread;
         if(gcppoints == NULL)
            {
            sl = strlen(indirectory) + 45;
            gcpfilename = (char *) (malloc(sl));
            if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
              {
              sprintf(gcpfilename,"%sinternal_data\\GCPdataToTest.csv",indirectory);
              }
            else
              {
              sprintf(gcpfilename,"%sinternal_data/GCPdataToTest.csv",indirectory);
              }
            gcppoints = fopen(gcpfilename,"wt");
            if(gcppoints == NULL)
               {
               printf("\nfailed to create internal file %s - exiting now\n",gcpfilename);
               exit(-1);
               }
            free(gcpfilename);
            }
         fprintf(gcppoints,"%d,%lf,%lf,%lf\n",IsGCP,fx,fy,fz);
         }
      else if(IsICESAT > 0)
         {
         ++ICESATread;
         if(gcppoints == NULL)
            {
            sl = strlen(indirectory) + 45;
            gcpfilename = (char *) (malloc(sl));
            if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
              {
              sprintf(gcpfilename,"%sinternal_data\\GCPdataToTest.csv",indirectory);
              }
            else
              {
              sprintf(gcpfilename,"%sinternal_data/GCPdataToTest.csv",indirectory);
              }
            gcppoints = fopen(gcpfilename,"wt");
            if(gcppoints == NULL)
               {
            printf("\nfailed to create internal file %s - exiting now\n",gcpfilename);
               exit(-1);
               }
            free(gcpfilename);
            }
         fprintf(gcppoints,"%d,%lf,%lf,%lf\n",IsICESAT,fx,fy,fz);
         }

      if(CoordSystem == 1) /** GDC ***/
         {
         cp->x = (double) ((fx - Xtranslation) * 100000.0);
         cp->y = (double) ((fy - Ytranslation) * 100000.0);
         }
      else if(CoordSystem == 2) /** UTM **/
         {
         cp->x = (double) (fx - Xtranslation);
         cp->y = (double) (fy - Ytranslation);
         }
      cp->z = fz;
      minX = maxX = cp->x;
      minY = maxY = cp->y;

         if(NGA_TYPE==1)
        {
        DrawTopLevelImagePoint(cp->x, cp->y, LL_to_Layer_Map[cp->Lindex]);
        }

     }
   if(SCCdataArray[cp->Sindex].C == 13)
      *FMpointsdone = (int) (ttlpoints);
   else
      *points_done = (int) (ttlpoints);


      BuildOpenMenu(0.0,SACttl*2,SACttl*2,linears_done,polys_done,model_polys,areals_done,linears_done,*points_done,
             *sphere_cv,*parallel_cv,*stamps_done,*footprints_done, bridges_done,g_read,g_write,
             *FMpointsdone,FMlinesdone,FMarealsdone,0.0,0.0,0.0,0.0,0);

      Sx = (int) (minX / LRegionSize);
      Ex = (int) (maxX / LRegionSize);
      Sy = (int) (minY / LRegionSize);
      Ey = (int) (maxY / LRegionSize);
      if((Sx != Ex) || (Sy != Ey))
         {
         printf("bad point - in multiple regions\n");
         exit(-1);
         }
      else
         {
         WriteIndex = (Sx * YindexExtent) + Sy;
         PointTable[WriteIndex].numpoints += 1;
         if(PointTable[WriteIndex].numpoints > maxperLM)
            maxperLM = PointTable[WriteIndex].numpoints;
         spc = (struct SeekPosnList *) (malloc(SzSPL));
         spc->posn = seekposition;
         spc->next = PointTable[WriteIndex].sp;
         PointTable[WriteIndex].sp = spc;
         }


      seekposition = ftell(pin);
      SEEIT_fread_int(&featureID,pin);
      }

   maxperLM += 1;

   ThePoints = (struct RawFormatPoint *) (malloc(SzRP * maxperLM));
   for(i=0; i<listlength; i++)
      {
      k = 0;
      spc = PointTable[i].sp;
      while(spc != NULL)
         {
         spn = spc;
         fseek(pin,spc->posn,SEEK_SET);

         ttlpoints += 0.35;

         SEEIT_fread_int(&ThePoints[k].featureid,pin);
         SEEIT_fread_int(&ThePoints[k].Lindex,pin);
         SEEIT_fread_int(&ThePoints[k].Sindex,pin);
         SEEIT_fread_int(&ThePoints[k].idn,pin);
         SEEIT_fread_int(&numverts,pin);
         SEEIT_fread_double(&fx,pin);
         SEEIT_fread_double(&fy,pin);
         SEEIT_fread_double(&fz,pin);
         if(CoordSystem == 1) /** GDC ***/
            {
            ThePoints[k].x = (double) ((fx - Xtranslation) * 100000.0);
            ThePoints[k].y = (double) ((fy - Ytranslation) * 100000.0);
            }
         else if(CoordSystem == 2) /** UTM **/
            {
            ThePoints[k].x = (double) (fx - Xtranslation);
            ThePoints[k].y = (double) (fy - Ytranslation);
            }
         ThePoints[k].z = fz;

         ++k;
         spc = spc->next;
         free(spn);
         }
      if(k > 0)
         {
         if(SCCdataArray[cp->Sindex].C == 13)
            *FMpointsdone = (int) (ttlpoints);
         else
            *points_done = (int) (ttlpoints);
         }
      BuildOpenMenu(0.0,SACttl*2,SACttl*2,linears_done,polys_done,model_polys,areals_done,linears_done,*points_done,
                *sphere_cv,*parallel_cv,*stamps_done,*footprints_done, bridges_done,g_read,g_write,
                *FMpointsdone,FMlinesdone,FMarealsdone,0.0,0.0,0.0,0.0,0);

      if(PointTable[i].numpoints > 0)
         PointTable[i].fileptr = ftell(pout);
      for(k=0; k<PointTable[i].numpoints; k++)
         {
         ttlpoints += 0.35;
         SEEIT_fwrite_int(&ThePoints[k].featureid,pout);
         SEEIT_fwrite_int(&ThePoints[k].Lindex,pout);
         SEEIT_fwrite_int(&ThePoints[k].Sindex,pout);
         SEEIT_fwrite_int(&ThePoints[k].idn,pout);
         SEEIT_fwrite_int(&FIXnumverts,pout);
         SEEIT_fwrite_double(&FIXrad,pout);

         SEEIT_fwrite_double(&ThePoints[k].x,pout);
         SEEIT_fwrite_double(&ThePoints[k].y,pout);
         SEEIT_fwrite_double(&ThePoints[k].z,pout);

         InsertIntoSCCtable(0,i, ThePoints[k].Lindex, ThePoints[k].idn,ThePoints[k].featureid);
         }

      if(k > 0)
         {
         if(SCCdataArray[cp->Sindex].C == 13)
            *FMpointsdone = (int) (ttlpoints);
         else
            *points_done = (int) (ttlpoints);
         }
      BuildOpenMenu(0.0,SACttl*2,SACttl*2,linears_done,polys_done,model_polys,areals_done,linears_done,*points_done,
                *sphere_cv,*parallel_cv,*stamps_done,*footprints_done, bridges_done,g_read,g_write,
                *FMpointsdone,FMlinesdone,FMarealsdone,0.0,0.0,0.0,0.0,0);
      }

   *points_done = j;
   BuildOpenMenu(0.0,SACttl*2,SACttl*2,linears_done,polys_done,model_polys,areals_done,linears_done,*points_done,
                *sphere_cv,*parallel_cv,*stamps_done,*footprints_done, bridges_done,g_read,g_write,
                *FMpointsdone,FMlinesdone,FMarealsdone,0.0,0.0,0.0,0.0,0);

   fclose(pout);
   fclose(pin);

   free(cp);
   free(ThePoints);

   MPoc = PointMProot;
   while(MPoc != NULL)
      {
      if(MPoc->used > 1)
         *points_done = *points_done - MPoc->parts + 1;
      MPoc = MPoc->next;
      }

   SinglePoints = 0;
   MultiPoints = 0;
   tableout = fopen(pointtablefile,"wb");
   for(i=0; i<listlength; i++)
      {
      SinglePoints +=  PointTable[i].numpoints;
      SEEIT_fwrite_int(&PointTable[i].numpoints,tableout);
      SEEIT_fwrite_long(&PointTable[i].fileptr,tableout);
      SEEIT_fwrite_int(&FIXnumother,tableout);

      BuildOpenMenu(0.0,SACttl*2,SACttl*2,linears_done,polys_done,model_polys,areals_done,linears_done,*points_done,
             *sphere_cv,*parallel_cv,*stamps_done,*footprints_done, bridges_done,g_read,g_write,
             *FMpointsdone,FMlinesdone,FMarealsdone,0.0,0.0,0.0,0.0,0);
      }
   fclose(tableout);
   printf("processed %d single-region and %d multi-region point features\n",SinglePoints,MultiPoints);

   free(PointTable);

   if(gcppoints != NULL)
      {
      fclose(gcppoints);
      }

}










void FormatS_Points(int SACttl,unsigned char CoordSystem,
                 int polys_read, int polys_done,int model_polys,int areals_done,int linears_done,int *points_done,
                 int *sphere_cv,int *parallel_cv,int *stamps_done,int *footprints_done,
                 int bridges_done, unsigned int g_read, unsigned int g_write, int *FMpointsdone, int FMlinesdone, int FMarealsdone)
{
FILE *pin, *pout, *tableout;
struct RawFormatPoint
   {
   int Lindex;
   int Sindex;
   int idn;
   int featureid;
   int numverts;
   double rad;
   double * x;
   double * y;
   double * z;
   double * h;
   struct RawFormatPoint * next;
   } ;
struct PointLookup
   {
   int numpoints;
   struct RawFormatPoint * inside;
   int numother;
   long int fileptr;
   struct ObjPtrList *others;
   } * PointTable;
int SzPL = sizeof(struct PointLookup);
int SzRP = sizeof(struct RawFormatPoint);
int SzPtrList = sizeof(struct ObjPtrList);
int XindexExtent, YindexExtent, listlength;
int Lindex, Sindex;
int numverts;
int featureID;
double fx, fy, fz, fh, frad;
int i,j, i2;
int Sidn;
struct RawFormatPoint *cp, *pp;
struct ObjPtrList *plst, *clst;
int ix,iy;
int SinglePoints,MultiPoints;
int ind1, WriteIndex;
long int fileposn;
int Sx,Sy,Ex,Ey, inside;
double minX, minY, maxX, maxY;
double d1,d2,d3,d4;
double dx1,dy1,dx2,dy2, Xint,Yint;
unsigned char pixcolor;
double dNumCols, dNumRows;
int i1,index1,index2;
int IM = ImageMaxSize - 1;
double Xmap, Ymap;
double XM, YM;


      pin = fopen(pointfile,"rb");
   if(pin == NULL)
      {
      printf("No associated file of point feature data (%s is missing)\n",pointfile);
      return;
      }

   pout = fopen(pointdata,"wb");
   if(pout == NULL)
      {
      printf("cannot open file %s for write update\n",pointdata);
      exit(-1);
      }

   dNumCols = PointsPerPixel;
   dNumRows = PointsPerPixel;

   if(NGA_TYPE == 1)
      BuildOpenMenu(0.0,SACttl*2,SACttl*2,linears_done,polys_done,model_polys,areals_done,linears_done,*points_done,
          *sphere_cv,*parallel_cv,*stamps_done,*footprints_done, bridges_done,g_read,g_write,
          *FMpointsdone,FMlinesdone,FMarealsdone,0.0,0.0,0.0,0.0,0);
   else
      BuildOpenMenu(0.0,SACttl*2,SACttl*2,polys_read,polys_done,model_polys,areals_done,linears_done,*points_done,
          *sphere_cv,*parallel_cv,*stamps_done,*footprints_done, bridges_done,g_read,g_write,
          *FMpointsdone,FMlinesdone,FMarealsdone,0.0,0.0,0.0,0.0,0);

   XindexExtent = (int) (MaxXcoord / LRegionSize) + 2;
   YindexExtent = (int) (MaxYcoord / LRegionSize) + 2;

   listlength = XindexExtent * YindexExtent;
   PointTable = (struct PointLookup *) (malloc(SzPL * listlength));
   if(PointTable == NULL)
      {
      printf("allocation memory exhausted during point feature processing (file %s)\n",pointfile);
      exit(-1);
      }

   for(i=0; i<listlength; i++)
      {
      PointTable[i].numpoints = 0;
      PointTable[i].inside = NULL;
      PointTable[i].numother = 0;
      /****PointTable[i].fileptr = (int) NULL; ****/
      PointTable[i].fileptr = 0;
      PointTable[i].others = NULL;
      }

   MPoc = PointMProot;
   while(MPoc != NULL)
      {
      MPoc->used = 0;
      MPoc = MPoc->next;
      }


   printf("processing point feature data from file %s\n",pointfile);

   SEEIT_fread_int(&featureID,pin);
      
   while(feof(pin) == 0)
      {
      cp = (struct RawFormatPoint *) malloc(SzRP);
      if(cp == NULL)
         {
         printf("allocation memory exhausted during point format operation\n");
         exit(-1);
         }
      cp->next = NULL;

      SEEIT_fread_int(&Lindex,pin);
      SEEIT_fread_int(&Sindex,pin);
      SEEIT_fread_int(&Sidn,pin); /*** point object ID **/
      SEEIT_fread_int(&numverts,pin);
      
      cp->featureid = featureID;
      cp->Lindex = Lindex;
      cp->Sindex = Sindex;
      cp->idn = Sidn;

      if(IDHfp != NULL)
         {
         InspectUID(cp->Lindex,cp->idn, cp->featureid, "Point");
         }

      MPoc = PointMProot;
      while(MPoc != NULL)
         {
         if(MPoc->featureid == cp->idn)
            {
            MPoc->used += 1;
            if(MPoc->used == 1)
               MPoc->ECC = ClassData[cp->Sindex].ECC;
            break;
            }
         MPoc = MPoc->next;
         }
      if(NGA_TYPE == 0)
         {
         ClassData[cp->Sindex].occurrences += 1;
         NArray[cp->Lindex].occurrences += 1;
         NArray[cp->Lindex].configcount[ClassData[cp->Sindex].C] += 1; /** bump point counter **/
         LongListInstances[cp->Lindex] += 1;
         }
      else
         {
         if((MPoc == NULL) || ((MPoc != NULL) && (MPoc->used == 1)))
            {
            ClassData[cp->Sindex].occurrences += 1;
            NArray[cp->Lindex].occurrences += 1;
            NArray[cp->Lindex].configcount[ClassData[cp->Sindex].C] += 1; /** bump point counter **/
            LongListInstances[cp->Lindex] += 1;
            }
         }
      if(LongToShortMap[cp->Lindex] < 0)
         LongToShortMap[cp->Lindex] = cp->Sindex;
      else if(LongToShortMap[cp->Lindex] != cp->Sindex)
         {
         printf("FATAL ERROR -- found one too many mappings from long to short list!!!!!\n");
         printf("mapping long list index %d into both %d and %d on short list\n",cp->Lindex,
                 LongToShortMap[cp->Lindex],cp->Sindex);
         exit(-1);
         }

      cp->numverts = numverts;
      if((numverts > -3) && (numverts < 1))
         ind1 = 1;
      else if(numverts < -2)
         ind1 = 0 - numverts;
      else
         ind1 = numverts;
      cp->x = (double *) (malloc(ind1 * SzD));
      cp->y = (double *) (malloc(ind1 * SzD));
      cp->z = (double *) (malloc(ind1 * SzD));
      cp->h = (double *) (malloc(ind1 * SzD));
      if((cp->x == NULL) || (cp->y == NULL) || (cp->z == NULL) || (cp->h == NULL))
         {
         printf("allocation memory exhausted during point feature format\n");
         printf("last allocation attempt based on data with %d vertices\n",ind1);
         exit(-1);
         }
      if(numverts == -1) /** dimensionless point feature **/
         {
        if(SCCdataArray[cp->Sindex].C == 13)
           *FMpointsdone += 1;
        else
         *points_done += 1;
            SEEIT_fread_double(&fx,pin);
            SEEIT_fread_double(&fy,pin);
            SEEIT_fread_double(&fz,pin);
         if(CoordSystem == 1) /** GDC ***/
            {
            cp->x[0] = (double) ((fx - Xtranslation) * 100000.0);
            cp->y[0] = (double) ((fy - Ytranslation) * 100000.0);
            }
         else if(CoordSystem == 2) /** UTM **/
            {
            cp->x[0] = (double) (fx - Xtranslation);
            cp->y[0] = (double) (fy - Ytranslation);
            }
         cp->z[0] = fz;
         cp->h[0] = 0.0;
         cp->rad = 0.0;
         minX = maxX = cp->x[0];
         minY = maxY = cp->y[0];

         i1 = 0;
         if((NGA_TYPE == 0) && (ShadedReliefRequired) && (LandMarksSet > 0) && (DO_LINES))
            {
            switch (SCCdataArray[cp->Sindex].D)
               {
               case D_NONE:
                  i1 = 0;
                  break;
               default:
                  i1 = 1;
                  break;
               }
            }

         if(NGA_TYPE==1)
           {
           DrawTopLevelImagePoint(cp->x[0], cp->y[0], LL_to_Layer_Map[cp->Lindex]);
           }


         if(i1 > 0)
            {

	      pixcolor = SpecialDomainColors[SCCdataArray[cp->Sindex].D];

            Xmap = (double) ((int) (cp->x[0] / dNumCols + 0.5));
            Ymap = (double) ((int) (cp->y[0] / dNumRows + 0.5));

            index2 = (int) Xmap;
            index1 = (int) Ymap;

            PBM2[IM - index1].Row[index2].color = pixcolor; 
            }

         }
      else if(numverts == 0) /** stamp model **/
         {
         *stamps_done += 1;
            SEEIT_fread_double(&fx,pin);
            SEEIT_fread_double(&fy,pin);
            SEEIT_fread_double(&fz,pin);
            SEEIT_fread_double(&frad,pin);
            SEEIT_fread_double(&fh,pin);
            
         if(CoordSystem == 1) /** GDC ***/
            {
            cp->x[0] = (fx - Xtranslation) * 100000.0;
            cp->y[0] = (fy - Ytranslation) * 100000.0;
            }
         else if(CoordSystem == 2) /** UTM **/
            {
            cp->x[0] = fx - Xtranslation;
            cp->y[0] = fy - Ytranslation;
            }
         cp->z[0] = fz;
         cp->h[0] = fh;
         cp->rad = frad;
         minX = maxX = cp->x[0];
         minY = maxY = cp->y[0];

         i1 = 0;
         if((NGA_TYPE == 0) && (ShadedReliefRequired) && (LandMarksSet > 0) && (DO_LINES))
            {
            switch (SCCdataArray[cp->Sindex].D)
               {
               case D_NONE:
                  i1 = 0;
                  break;
               default:
                  i1 = 1;
                  break;
               }
            }


         if((i1 > 0) && (cp->numverts > 1))
            {

	      pixcolor = SpecialDomainColors[SCCdataArray[cp->Sindex].D];

            Xmap = (double) ((int) (cp->x[0] / dNumCols + 0.5));
            Ymap = (double) ((int) (cp->y[0] / dNumRows + 0.5));

            index2 = (int) Xmap;
            index1 = (int) Ymap;

            PBM2[IM - index1].Row[index2].color = pixcolor;
            }
         }
      else if(numverts > 1)/** must be a footprint model **/ 
         {
         *footprints_done += 1;
         maxX = maxY = 0.0;
         minX = MaxXcoord;
         minY = MaxYcoord;
         cp->rad = 0.0;
         for(i=0; i<numverts; i++)
            {
               SEEIT_fread_double(&fx,pin);
               SEEIT_fread_double(&fy,pin);
               SEEIT_fread_double(&fz,pin);
               SEEIT_fread_double(&fh,pin);
               
            if(CoordSystem == 1) /** GDC ***/
               {
               cp->x[i] = (fx - Xtranslation) * 100000.0;
               cp->y[i] = (fy - Ytranslation) * 100000.0;
               }
            else if(CoordSystem == 2) /** UTM **/
               {
               cp->x[i] = fx - Xtranslation;
               cp->y[i] = fy - Ytranslation;
               }
            cp->z[i] = fz;
            cp->h[i] = fh;
            if(cp->x[i] < minX)
               minX = cp->x[i];
            if(cp->x[i] > maxX)
               maxX = cp->x[i];
            if(cp->y[i] < minY)
               minY = cp->y[i];
            if(cp->y[i] > maxY)
               maxY = cp->y[i];
            }
         i1 = 0;
         if((ShadedReliefRequired) && (LandMarksSet > 0) && (DO_LINES))
            {
            switch (SCCdataArray[cp->Sindex].D)
               {
               case D_NONE:
                  i1 = 0;
                  break;
               default:
                  i1 = 1;
                  break;
               }
            }

	 if(NGA_TYPE==1)
	   {
	     i1 = 1;
	   }


         if((i1 > 0) && (cp->numverts > 1))
            {

	      pixcolor = SpecialDomainColors[SCCdataArray[cp->Sindex].D];

            i1 = 0;
            for(i2 = 1; i2 <numverts; i2++)
               {
               Xmap = (double) ((int) (cp->x[i1] / dNumCols + 0.5));
               Ymap = (double) ((int) (cp->y[i1] / dNumRows + 0.5));
               XM = (double) ((int) (cp->x[i2] / dNumCols + 0.5));
               YM = (double) ((int) (cp->y[i2] / dNumRows + 0.5));
               DrawPGMlines(Xmap, Ymap, XM, YM, pixcolor);
               ++i1;
               }

            Xmap = (double) ((int) (cp->x[0] / dNumCols + 0.5));
            Ymap = (double) ((int) (cp->y[0] / dNumRows + 0.5));
            DrawPGMlines(Xmap, Ymap, XM, YM, pixcolor);
            }

         }
      else if(numverts == -2) /**** a spherical collision footprint ****/
         {
         *sphere_cv += 1;
            SEEIT_fread_double(&fx,pin);
            SEEIT_fread_double(&fy,pin);
            SEEIT_fread_double(&fz,pin);
            SEEIT_fread_double(&frad,pin);
            SEEIT_fread_double(&fh,pin);
            
         if(CoordSystem == 1) /** GDC ***/
            {
            cp->x[0] = (fx - Xtranslation) * 100000.0;
            cp->y[0] = (fy - Ytranslation) * 100000.0;
            }
         else if(CoordSystem == 2) /** UTM **/
            {
            cp->x[0] = fx - Xtranslation;
            cp->y[0] = fy - Ytranslation;
            }
         cp->z[0] = fz;
         cp->h[0] = fh;
         cp->rad = frad;
         minX = maxX = cp->x[0];
         minY = maxY = cp->y[0];
         }
      else if(numverts < -2)/** must be a parallelpiped collision volume **/
         {
         *parallel_cv += 1;
         maxX = maxY = 0.0;
         minX = MaxXcoord;
         minY = MaxYcoord;
         cp->rad = 0.0;
         for(i=0; i<ind1; i++)
            {
               SEEIT_fread_double(&fx,pin);
               SEEIT_fread_double(&fy,pin);
               SEEIT_fread_double(&fz,pin);
               SEEIT_fread_double(&fh,pin);
               
            if(CoordSystem == 1) /** GDC ***/
               {
               cp->x[i] = (fx - Xtranslation) * 100000.0;
               cp->y[i] = (fy - Ytranslation) * 100000.0;
               }
            else if(CoordSystem == 2) /** UTM **/
               {
               cp->x[i] = fx - Xtranslation;
               cp->y[i] = fy - Ytranslation;
               }
            cp->z[i] = fz;
            cp->h[i] = fh;
            if(cp->x[i] < minX)
               minX = cp->x[i];
            if(cp->x[i] > maxX)
               maxX = cp->x[i];
            if(cp->y[i] < minY)
               minY = cp->y[i];
            if(cp->y[i] > maxY)
               maxY = cp->y[i];
            }
         }

      if(NGA_TYPE == 1)
         BuildOpenMenu(0.0,SACttl*2,SACttl*2,linears_done,polys_done,model_polys,areals_done,linears_done,*points_done,
             *sphere_cv,*parallel_cv,*stamps_done,*footprints_done, bridges_done,g_read,g_write,
             *FMpointsdone,FMlinesdone,FMarealsdone,0.0,0.0,0.0,0.0,0);
      else
         BuildOpenMenu(0.0,SACttl*2,SACttl*2,polys_read,polys_done,model_polys,areals_done,linears_done,*points_done,
             *sphere_cv,*parallel_cv,*stamps_done,*footprints_done, bridges_done,g_read,g_write,
             *FMpointsdone,FMlinesdone,FMarealsdone,0.0,0.0,0.0,0.0,0);


      inside = 0;
      Sx = (int) (minX / LRegionSize);
      Ex = (int) (maxX / LRegionSize);
      Sy = (int) (minY / LRegionSize);
      Ey = (int) (maxY / LRegionSize);
      if((Sx != Ex) || (Sy != Ey))
         {
         fileposn = ftell(pout);

         SEEIT_fwrite_int(&cp->featureid,pout);
         SEEIT_fwrite_int(&cp->Lindex,pout);
         SEEIT_fwrite_int(&cp->Sindex,pout);
         SEEIT_fwrite_int(&cp->idn,pout);
         SEEIT_fwrite_int(&cp->numverts,pout);
         SEEIT_fwrite_double(&cp->rad,pout);

         if((cp->numverts > -3) && (cp->numverts < 1))
            ind1 = 1;
         else if(cp->numverts < -2)
            ind1 = 0-cp->numverts;
         else
            ind1 = cp->numverts;

         for(i=0; i<ind1; i++)
            {
            SEEIT_fwrite_double(&cp->x[i],pout);
            SEEIT_fwrite_double(&cp->y[i],pout);
            SEEIT_fwrite_double(&cp->z[i],pout);
            if(cp->numverts != -1) 
               SEEIT_fwrite_double(&cp->h[i],pout);
            }

         for(ix = Sx; ix <= Ex; ix ++)
            {
            d1 = (double) ix * LRegionSize;
            d2 = d1 + LRegionSize;
            for(iy = Sy; iy <= Ey; iy++)
               {
               d3 = (double) iy * LRegionSize;
               d4 = d3 + LRegionSize;
               inside = 0;
               if(LocalPointInsidePoly(d1,d3,cp->x,cp->y,ind1))
                  {
                  inside = 1;
                  }
               else if(LocalPointInsidePoly(d1,d4,cp->x,cp->y,ind1))
                  {
                  inside = 1;
                  }
               else if(LocalPointInsidePoly(d2,d3,cp->x,cp->y,ind1))
                  {
                  inside = 1;
                  }
               else if(LocalPointInsidePoly(d2,d4,cp->x,cp->y,ind1))
                  {
                  inside = 1;
                  }
               if(inside > 0)
                  {
                  WriteIndex = (ix * YindexExtent) + iy;
                  PointTable[WriteIndex].numother += 1;
                  plst = (struct ObjPtrList *) (malloc(SzPtrList));
                  plst->fileptr = fileposn;
                  plst->next = PointTable[WriteIndex].others;
                  PointTable[WriteIndex].others = plst;
                  InsertIntoSCCtable(0,WriteIndex, cp->Lindex, cp->idn,cp->featureid);
                  }
               else /** above case did not occur, so check for intersections **/
                  {
                  dx2 = (double) cp->x[0];
                  dy2 = (double) cp->y[0];
                  for(i=0; i<ind1; i++)
                     {
                     j = (i + 1) % ind1;
                     dx1 = dx2;
                     dy1 = dy2;
                     dx2 = (double) cp->x[j];
                     dy2 = (double) cp->y[j];
                     if(LocalLineSegmentsIntersect(d1,d3,d2,d3,dx1,dy1,dx2,dy2,&Xint,&Yint) > 0)
                        inside = 1;
                     else if(LocalLineSegmentsIntersect(d1,d3,d1,d4,dx1,dy1,dx2,dy2,&Xint,&Yint) > 0)
                        inside = 1;
                     else if(LocalLineSegmentsIntersect(d2,d4,d2,d3,dx1,dy1,dx2,dy2,&Xint,&Yint) > 0)
                        inside = 1;
                     else if(LocalLineSegmentsIntersect(d2,d4,d1,d4,dx1,dy1,dx2,dy2,&Xint,&Yint) > 0)
                        inside = 1;
                     if(inside > 0)
                        {
                        WriteIndex = (ix * YindexExtent) + iy;
                        PointTable[WriteIndex].numother += 1;
                        plst = (struct ObjPtrList *) (malloc(SzPtrList));
                        plst->fileptr = fileposn;
                        plst->next = PointTable[WriteIndex].others;
                        PointTable[WriteIndex].others = plst;
                        InsertIntoSCCtable(0,WriteIndex, cp->Lindex, cp->idn,cp->featureid);
                        break;
                        }
                     }
                  }
               }
            }
         free(cp->x);
         free(cp->y);
         free(cp->z);
         free(cp->h);
         free(cp);
         }
      else
         {
         WriteIndex = (Sx * YindexExtent) + Sy;
         PointTable[WriteIndex].numpoints += 1;
         cp->next = PointTable[WriteIndex].inside;
         PointTable[WriteIndex].inside = cp;
         InsertIntoSCCtable(0,WriteIndex, cp->Lindex, cp->idn,cp->featureid);
         }

         SEEIT_fread_int(&featureID,pin);
      }
   fclose(pin);

   for(i=0; i<listlength; i++)
      {
      if(PointTable[i].numpoints > 0)
         PointTable[i].fileptr = ftell(pout);
      cp = PointTable[i].inside;
      while(cp != NULL)
         {
         SEEIT_fwrite_int(&cp->featureid,pout);
         SEEIT_fwrite_int(&cp->Lindex,pout);
         SEEIT_fwrite_int(&cp->Sindex,pout);
         SEEIT_fwrite_int(&cp->idn,pout);
         SEEIT_fwrite_int(&cp->numverts,pout);
         SEEIT_fwrite_double(&cp->rad,pout);
         if((cp->numverts > -3) && (cp->numverts < 1))
            ind1 = 1;
         else if(cp->numverts < -2)
            ind1 = 0-cp->numverts;
         else
            ind1 = cp->numverts;
         for(j=0; j<ind1; j++)
            {
            SEEIT_fwrite_double(&cp->x[j],pout);
            SEEIT_fwrite_double(&cp->y[j],pout);
            SEEIT_fwrite_double(&cp->z[j],pout);
            if(cp->numverts != -1)
               SEEIT_fwrite_double(&cp->h[j],pout);
            }
         if(NGA_TYPE == 1)
            BuildOpenMenu(0.0,SACttl*2,SACttl*2,linears_done,polys_done,model_polys,areals_done,linears_done,*points_done,
                *sphere_cv,*parallel_cv,*stamps_done,*footprints_done, bridges_done,g_read,g_write,
                *FMpointsdone,FMlinesdone,FMarealsdone,0.0,0.0,0.0,0.0,0);
         else
            BuildOpenMenu(0.0,SACttl*2,SACttl*2,polys_read,polys_done,model_polys,areals_done,linears_done,*points_done,
                *sphere_cv,*parallel_cv,*stamps_done,*footprints_done, bridges_done,g_read,g_write,
                *FMpointsdone,FMlinesdone,FMarealsdone,0.0,0.0,0.0,0.0,0);
         cp = cp->next;
         }
      }

   fclose(pout);

   MPoc = PointMProot;
   while(MPoc != NULL)
      {
      if(MPoc->used > 1)
         *points_done = *points_done - MPoc->parts + 1;
      MPoc = MPoc->next;
      }

   SinglePoints = 0;
   MultiPoints = 0;
   tableout = fopen(pointtablefile,"wb");
   for(i=0; i<listlength; i++)
      {
      SinglePoints +=  PointTable[i].numpoints;
      MultiPoints += PointTable[i].numother;
      SEEIT_fwrite_int(&PointTable[i].numpoints,tableout);
      SEEIT_fwrite_long(&PointTable[i].fileptr,tableout);
      SEEIT_fwrite_int(&PointTable[i].numother,tableout);
      plst = PointTable[i].others;
      while(plst != NULL)
         {
         clst = plst;
         plst = plst->next;
         SEEIT_fwrite_long(&clst->fileptr,tableout);
         free(clst);
         }
      cp = PointTable[i].inside;
      while(cp != NULL)
         {
         pp = cp;
         cp = cp->next;
         free(pp->x);
         free(pp->y);
         free(pp->z);
         free(pp->h);
         free(pp);
         }

      if(NGA_TYPE == 1)
         BuildOpenMenu(0.0,SACttl*2,SACttl*2,linears_done,polys_done,model_polys,areals_done,linears_done,*points_done,
             *sphere_cv,*parallel_cv,*stamps_done,*footprints_done, bridges_done,g_read,g_write,
             *FMpointsdone,FMlinesdone,FMarealsdone,0.0,0.0,0.0,0.0,0);
      else
         BuildOpenMenu(0.0,SACttl*2,SACttl*2,polys_read,polys_done,model_polys,areals_done,linears_done,*points_done,
             *sphere_cv,*parallel_cv,*stamps_done,*footprints_done, bridges_done,g_read,g_write,
             *FMpointsdone,FMlinesdone,FMarealsdone,0.0,0.0,0.0,0.0,0);
      }
   fclose(tableout);
   printf("processed %d single-region and %d multi-region point features\n",SinglePoints,MultiPoints);
   free(PointTable);
}





void NewFormatGrid(int SACttl,unsigned char CoordSystem, int TotalSCC, int NGrids,
                 int polys_read, int polys_done,int model_polys,int areals_done,int linears_done,int points_done,
                 int sphere_cv,int parallel_cv,int *stamps_done,int footprints_done,
                 int bridges_done, unsigned int *g_read, unsigned int *g_write, int FMpointsdone,
                  int FMlinesdone, int FMarealsdone, char * dirname)
{
FILE *gin, *tableout, *hdrout, *gcppoints, *tempout;
struct NewGridLookup
   {
   int NumGrids; /*** number of overlapping grids in the LM ***/
   int *FileNumber; /** the file number of each of the grids in this LM ***/
   int *GridIndex; /*** index (id) of the grid ***/
   int *NumRows; /*** number of elevation data rows per grid in the LM ***/
   int *NumCols; /*** number of elevation data columns per grid in the LM ***/
   char *OnEdge; /** is this part of the outer edge of the DEM data ***/
   long *fileptr; /*** pointer into the file(number) where the data starts ***/
   double *BaseX; /*** southwest corner x coord in GAIT coords ***/
   double *BaseY; /*** southwest corner y coord in GAIT coords ***/
   double *BaseZ; /*** southwest corner z value in GAIT coords - use as a double check on read ***/
   } * NGT;
int ICEused, GCPused;
double ICEmean, ICEstddev, ICEle90, ICErmse, GCPmean, GCPstddev, GCPle90, GCPrmse;
int SzNGL = sizeof(struct NewGridLookup);
int XindexExtent, YindexExtent;
int Lindex, Sindex;
double TrueXspace, TrueYspace;
int OrderFlag;
double XbaseCoord, YbaseCoord, X_LMbase, Y_LMbase;
double Xspace, Yspace;
double XC[4], YC[4];
int Xnumber, Ynumber;
int i,j,k,ii,jj,kk,sl,GCPexceptions,SomePossible;
int listlength,compositeindex;
int is,ie, js, je;
int FoundGrid, LastLayerUsed;
int ind1,ind2;
long int DataStartPosn, seekposn;
double Xlimit, Ylimit;
long int YptsToSeekPast,YptsToInclude,XptsToSeekPast,XptsToInclude;
int NumGridFiles, NumOverlappingGrids;
int PtsInGrid,PtsPerLM_RW, TotalPtsAllGrids;
double DEMESp1;
double DEMESp2;
double TGxloc, TGyloc, TGxMax, TGyMax;
double d0,d1,d2,d3,pd3,Xbt, Ybt, WBMvalue, LE90, RMSEgcp,RMSEice;
double Xextent, Yextent;
double interval,unuseddbl;
double mean, variance, std_dev, weighted_avg;
double t,u,t1,u1,biXcoord,biYcoord, interpelev,Ex_upper, Ex_lower;
int biX, biY, RMSEgcp_pts,RMSEice_pts;
int BytesPerValue;
int MGPRsquared;
int GridsToRead;
int infilenumber, i4, i5, i6, i7;
int MaxYIE, MaxXIE;
int xoffset, yoffset;
int IsTDF, IsWBM, TargetTDF;
unsigned int last_gread;
long int infileposn;
long int endseekposn;
char gridfilein[2000];
char junk[1000];
char * gcpfilename;
char * binsumfilename;
struct InFiles
{
   FILE *fp;
} *InFileHandles;

struct GCP
{
   char point_type;
   char keepit;
   double x;
   double y;
   double z;
   double sdev;
   double averageE;
   double difference;
   double interp;
} *GCParray;
double GCPref[5][5];

  unsigned char tempchar;
  short int tempshort;
  unsigned short int tempUshort;
  int tempint;
  unsigned int tempUint;
  float tempfloat;
  int CalculateBytesPerGridValue(int flag);



#define ScrnMaxCol 790
#define ScrnMaxRow 990
#define MaxOpenFiles 250

   DEMESp1 = NoiseThreshold;
   DEMESp2 =  MaxDifference;
   NGT = NULL;
   *g_read = *g_write = 0;
   last_gread = 0;
   TotalPtsAllGrids = 0;
   FoundGrid = -1;
   if(NGA_TYPE == 0)
      BuildOpenMenu(0.0,SACttl*2,SACttl*2,polys_read,polys_done,model_polys,areals_done,linears_done,points_done,
          sphere_cv,parallel_cv,*stamps_done,footprints_done, bridges_done,*g_read,*g_write,
          FMpointsdone,FMlinesdone,FMarealsdone,0.0,0.0,0.0,0.0,0);
   else
      BuildOpenMenu(0.0,SACttl*2,SACttl*2,polys_read,polys_done,model_polys,areals_done,linears_done,points_done,
          sphere_cv,parallel_cv,FoundGrid+1,footprints_done, bridges_done,*g_read,*g_write,
           FMpointsdone,FMlinesdone,FMarealsdone,0.0,0.0,0.0,0.0,0);


   strcpy(gridfilein,indirectory);
   strcat(gridfilein,"gridinfo.txt");
   NumGridFiles = 0;
   NumOverlappingGrids = 0;
   GridsToRead = 0;
   gin = fopen(gridfilein,"rt");
   if(gin == NULL)
      {
      printf("No associated file of grid data meta information (%s is missing)\n",gridfilein);
      return;
      }

   LastLayerUsed = -100;

   gcppoints = NULL;
   GCParray = NULL;
   RMSEgcp = RMSEice = 0.0;
   RMSEice_pts = RMSEgcp_pts = 0;
   ICEused = GCPused = 0;
   ICEmean = ICEstddev = ICEle90 = ICErmse = 0.0;
   GCPmean = GCPstddev = GCPle90 = GCPrmse = 0.0;
   if((GCPread > 0) || (ICESATread > 0))
      {
      sl = strlen(indirectory) + 45;
      gcpfilename = (char *) (malloc(sl));
      if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
        {
        sprintf(gcpfilename,"%sinternal_data\\GCPdataToTest.csv",indirectory);
        }
      else
        {
        sprintf(gcpfilename,"%sinternal_data/GCPdataToTest.csv",indirectory);
        }
      gcppoints = fopen(gcpfilename,"rt");
      if(gcppoints == NULL)
         {
         printf("\nfailed to open for reading internal file %s - exiting now\n",gcpfilename);
         exit(-1);
         }
      free(gcpfilename);

      sl = GCPread + ICESATread;
      GCParray = (struct GCP *) (malloc(sizeof(struct GCP) * sl));
      fgets(junk,999,gcppoints);
      j = 0;
      while(feof(gcppoints) == 0)
         {
         sscanf(junk,"%d,%lf,%lf,%lf",&i,&d0,&d1,&d2);
         GCParray[j].point_type = (char) i;
         GCParray[j].x = d0;
         GCParray[j].y = d1;
         GCParray[j].z = d2;
         GCParray[j].keepit = 1;
GCParray[j].sdev = -99199;
GCParray[j].difference = -99199;
GCParray[j].interp = -99199;
GCParray[j].averageE = 0.0;

         ++j;
         fgets(junk,999,gcppoints);
         }
      if(j != sl)
         {
         printf("mismatch in number of GCP during read - expected %d, found %d\n",sl,j);
         exit(-1);
         }
      }


   fgets(junk,99,gin);
   while(feof(gin) == 0)
      {
      sscanf(junk,"%d",&NumOverlappingGrids);
      GridsToRead += NumOverlappingGrids;
      ++NumGridFiles;
      fgets(junk,99,gin);
      }
   fclose(gin);


   --NumGridFiles;
   GridsToRead -= NumOverlappingGrids;
   if(GridsToRead > 0)
      {
      printf("Preparing to read and format %d grids from %d files\n",GridsToRead,NumGridFiles);
      printf("including %d grids that overlap at any one location (maximum)\n",NumOverlappingGrids);
      }

   TGxloc = MaxXcoord * 2;
   TGyloc = MaxYcoord * 2;

   TGxMax = TGyMax = -1000.0;

   InFileHandles = NULL;
   if(NGrids > 0)
      {
      if((NumGridFiles == 1) || (NumGridFiles >= MaxOpenFiles))
         {
         InFileHandles = (struct InFiles *) (malloc(sizeof(struct InFiles) * 2));
         }
      else if((NumGridFiles > 1) && (NumGridFiles < MaxOpenFiles))
         {
         InFileHandles = (struct InFiles *) (malloc(sizeof(struct InFiles) * NumGridFiles));
         }
      if(InFileHandles == NULL)
         {
         printf("memory has been exhausted during allocation of areal input file handles\n");
         printf("attempt to allocate memory for %d file handles has failed\n",NumGridFiles);
         exit(-1);
         }
      if(NumGridFiles > 0)
         {
         InFileHandles[0].fp = fopen(gridfile,"rb");
         if(InFileHandles[0].fp == NULL)
            {
            printf("(2) fatal error when reopening grid input file %s\n", gridfile);
            exit(-1);
            }
         }
      if((NumGridFiles > 1) && (NumGridFiles < MaxOpenFiles))
         {
         for(infilenumber=2; infilenumber<=NumGridFiles; infilenumber++)
           {
           i4 = 0;
           i5 = 0;
           while(gridfile[i4] != '\0')
              {
              gridfilein[i5] = gridfile[i4];
              ++i4;
              ++i5;
              }
           --i5;
           while((i5 > 0) && (gridfilein[i5] != '.'))
              --i5;

           sprintf(&gridfilein[i5],"%d",infilenumber);
           strcat(gridfilein,".bin");
           InFileHandles[infilenumber-1].fp = fopen(gridfilein,"rb");
           if(InFileHandles[infilenumber-1].fp == NULL)
              {
              printf("(1) fatal error when reopening grid input file %s\n", gridfilein);
              exit(-1);
              }
            }
         }


      infilenumber = 1;

      gin = InFileHandles[0].fp;
      if(gin == NULL)
         {
         printf("No associated file of grid data (%s is missing)\n",gridfile);
         return;
         }
      GridHeader = (struct GlobalGridInfo *) (malloc(sizeof(struct GlobalGridInfo) * NGrids));
      if(GridHeader == NULL)
         {
         printf("allocation memory exhausted during grid data processing (header allocation) (file %s)\n",gridfile);
         printf("number of grids to be processed %d\n",NGrids);
         exit(-1);
         }
      }
   else /** have to write out the 'NULL' NGT entries, so do something even when NGrids == 0 ****/
      {
      gin = fopen(gridfile,"rb");
      infilenumber = 1;
      GridHeader = NULL;
      }

   XindexExtent = (int) (MaxXcoord / LRegionSize) + 2;
   YindexExtent = (int) (MaxYcoord / LRegionSize) + 2;

   listlength = XindexExtent * YindexExtent;

   NGT = (struct NewGridLookup *) (malloc(SzNGL * (listlength + 2)));
   if(NGT == NULL)
      {
      printf("allocation memory exhausted during grid data processing (table construction) (file %s)\n",gridfile);
      printf("number of grids to be processed %d\n",NGrids);
      exit(-1);
      }

   if(NGrids > 0)
      {
      i = (int) (LRegionSize / 100000.0);
      MGPRsquared = ((i * i) + ((i + 1) * 4)) * NumOverlappingGrids;
      }
   else
      MGPRsquared = 1;

            if(NGA_TYPE == 0)
               BuildOpenMenu(0.0,SACttl*2,SACttl*2,polys_read,polys_done,model_polys,areals_done,linears_done,points_done,
                   sphere_cv,parallel_cv,*stamps_done,footprints_done, bridges_done,*g_read,*g_write,
                   FMpointsdone,FMlinesdone,FMarealsdone,0.0,0.0,0.0,0.0,0);
            else
               BuildOpenMenu(0.0,SACttl*2,SACttl*2,polys_read,polys_done,model_polys,areals_done,linears_done,points_done,
                   sphere_cv,parallel_cv,FoundGrid+1,footprints_done, bridges_done,*g_read,*g_write,
                    FMpointsdone,FMlinesdone,FMarealsdone,0.0,0.0,0.0,0.0,0);


   for(i=0; i<(listlength + 2); i++)
      {
      NGT[i].FileNumber = (int *) (malloc(SzI * MGPRsquared));
      NGT[i].GridIndex = (int *) (malloc(SzI * MGPRsquared));
      NGT[i].NumRows = (int *) (malloc(SzI * MGPRsquared));
      NGT[i].NumCols = (int *) (malloc(SzI * MGPRsquared));
      NGT[i].OnEdge = (char *) (malloc(MGPRsquared));
      NGT[i].BaseX = (double *) (malloc(SzD * MGPRsquared));
      NGT[i].BaseY = (double *) (malloc(SzD * MGPRsquared));
      NGT[i].BaseZ = (double *) (malloc(SzD * MGPRsquared));
      NGT[i].fileptr = (long int *) (malloc(SzL * MGPRsquared));
      if(NGT[i].fileptr == NULL)
         {
         printf("allocation memory exhausted during grid data processing (filepointer allocation) (file %s)\n",gridfile);
         printf("number of grids to be processed %d\n",NGrids);
         printf("attempting to allocate %d times %d (%d) for %d array elements\n",SzL,MGPRsquared,SzL*MGPRsquared,listlength);
         exit(-1);
         }
      for(j=0; j<MGPRsquared; j++)
         {
         NGT[i].NumRows[j] = 0;
         NGT[i].NumCols[j] = 0;
         NGT[i].FileNumber[j] = -1;
         NGT[i].OnEdge[j] = 0;
         NGT[i].fileptr[j] = -1;
         NGT[i].GridIndex[j] = -1;
         NGT[i].BaseX[j] = -1;
         NGT[i].BaseY[j] = -1;
         NGT[i].BaseZ[j] = -1;
         }
      NGT[i].NumGrids = 0;
      }
   if((ShadedReliefRequired) && (NGrids > 0))
      {
      Xextent = (double) (XindexExtent);
      Yextent = (double) (YindexExtent);

      PixPerRow = (int) floor((((double) ScrnMaxRow) / Xextent));
      PixPerCol = (int) floor((((double) ScrnMaxCol) / Yextent));
      if(PixPerRow > PixPerCol)
         PixPerLM = PixPerCol;
      else
         PixPerLM = PixPerRow;
      interval = floor(LRegionSize / ((double) PixPerLM));

      if(interval < 1)
         interval = 1;
      NumRows = (int) (Yextent * PixPerLM);
      NumCols = (int) (Xextent * PixPerLM);
      }

   if(SCCdataArray == NULL)
      {
      FormatFromDynamicDefsFile(TotalSCC);
      }

   if(NGrids > 0)
       {
       printf("processing grid data from file %s\n",gridfile);

       FoundGrid = -1;
       }
   else
      {
      FoundGrid = 0;
      }

   if(NGrids > 0)
      {
      infileposn = ftell(gin);
      SEEIT_fread_int(&Lindex,gin);

      if(feof(gin) != 0)
         {
         free(GridHeader);
         for(i=0; i<(listlength + 2); i++)
            {
            free(NGT[i].FileNumber);
            free(NGT[i].GridIndex);
            free(NGT[i].NumRows);
            free(NGT[i].NumCols);
            free(NGT[i].OnEdge);
            free(NGT[i].BaseX);
            free(NGT[i].BaseY);
            free(NGT[i].BaseZ);
            free(NGT[i].fileptr);
            }
         free(NGT);
         NGT = NULL;

         fclose(gin);

         return;
         }
      while(feof(gin) == 0)
         {
         SEEIT_fread_int(&Sindex,gin);
         SEEIT_fread_double(&TrueXspace,gin);
         SEEIT_fread_double(&TrueYspace,gin);
         SEEIT_fread_double(&XbaseCoord,gin);
         SEEIT_fread_double(&YbaseCoord,gin);
         SEEIT_fread_int(&OrderFlag,gin);
         SEEIT_fread_int(&Xnumber,gin);
         SEEIT_fread_int(&Ynumber,gin);

         SEEIT_fread_int(&BytesPerValue, gin);

         DataStartPosn = ftell(gin);

         Xspace = TrueXspace;
         Yspace = TrueYspace;
         PtsInGrid = Xnumber * Ynumber;
         ClassData[Sindex].occurrences += PtsInGrid;
         NArray[Lindex].occurrences += PtsInGrid;

         TotalPtsAllGrids += PtsInGrid;

         endseekposn = DataStartPosn + (PtsInGrid * CalculateBytesPerGridValue(BytesPerValue));


         NArray[Lindex].configcount[ClassData[Sindex].C] += 1; /** bump grid counter **/
         LongListInstances[Lindex] += Xnumber * Ynumber; /*** was 1; ***/
         if(LongToShortMap[Lindex] < 0)
            LongToShortMap[Lindex] = Sindex;
         else if(LongToShortMap[Lindex] != Sindex)
            {
            printf("FATAL ERROR -- found one too many mappings from long to short list!!!!!!\n");
            printf("mapping long list index %d into both %d and %d on short list\n",Lindex,
                    LongToShortMap[Lindex],Sindex);
            exit(-1);
            }

         IsTDF = IsWBM = 0;
         if(Lindex == trexfinishedindex0)
            IsTDF = 1;
         else if(Lindex == trexfinishedindex1)
            IsTDF = 2;
         else if(Lindex == trexfinishedindex2)
            IsTDF = 3;
         else if(Lindex == trexfinishedindex3)
            IsTDF = 4;
         else if(Lindex == trexwatermaskindex0)
            IsWBM = 1;
         else if(Lindex == trexwatermaskindex1)
            IsWBM = 2;
         else if(Lindex == trexwatermaskindex2)
            IsWBM = 3;
         else if(Lindex == trexwatermaskindex3)
            IsWBM = 4;

         if(IsTDF > 0)
            {
            d2 = XbaseCoord + (Xnumber * TrueXspace); /** d2 and d3 should be the ending extent of the finished DEM **/
            d3 = YbaseCoord + (Ynumber * TrueYspace);
            sl = GCPread + ICESATread;
            mean = 0;
            for(ii = 0; ii<sl; ii++)
               {
               if((GCParray[ii].point_type == ((char) IsTDF)) || (GCParray[ii].point_type == ((char) (IsTDF + 4))))
                  {
                  if(GCParray[ii].point_type == ((char) IsTDF)) /** this should be a GCP, not an ICESat ***/
                     {
                     d0 = d1 = GCParray[ii].x;
                     }
                  else
                     {
                     d0 = GCParray[ii].x / TrueXspace;
                     js = (int) (d0 + 0.5);
                     d0 = ((double) (js - 2)) * TrueXspace;
                     d1 = ((double) (js + 2)) * TrueXspace;
                     }
                  if((d0 >= XbaseCoord) && (d1 <= d2))
                     {
                     if(GCParray[ii].point_type == ((char) IsTDF)) /** this should be a GCP, not an ICESat ***/
                        {
                        d0 = d1 = GCParray[ii].y;
                        }
                     else
                        {
                        d0 = GCParray[ii].y / TrueYspace;
                        js = (int) (d0 + 0.5);
                        d0 = ((double) (js - 2)) * TrueYspace;
                        d1 = ((double) (js + 2)) * TrueYspace;
                        }
                     if((d0 >= YbaseCoord) && (d1 <= d3))
                        {
                        Xbt = (GCParray[ii].x - XbaseCoord) / TrueXspace;
                        js = (int) (Xbt + 0.5);
                        biX = (int) Xbt;
                        biXcoord = (((double) biX) * TrueXspace) + XbaseCoord;
                        if(biX == js)
                           biX = 2;
                        else
                           biX = 1;

                        Ybt = (GCParray[ii].y - YbaseCoord) / TrueYspace;
                        is = (int) (Ybt + 0.5);
                        biY = (int) Ybt;
                        biYcoord = (((double) biY) * TrueYspace) + YbaseCoord;
                        if(biY == is)
                           biY = 2;
                        else
                           biY = 1;

                        js = js - 2;
                        is = is - 2;
                        mean = 0;
                        for(jj = 0; jj < 5; jj++)
                           {
                           for(kk = 0; kk < 5; kk++)
                              {
                              GCPref[jj][kk] = GetGridValue(gin,DataStartPosn,BytesPerValue,js+jj, is+kk,Xnumber,Ynumber);
                              if((jj == 0) || (jj == 4))
                                 {
                                 if((kk > 0) && (kk < 4))
                                    {
                                    mean = mean + GCPref[jj][kk];
                                    if(GCPref[jj][kk] == -32767.0)
                                       GCParray[ii].keepit = 0;
                                    }
                                 }
                              else
                                 {
                                 mean = mean + GCPref[jj][kk];
                                 if(GCPref[jj][kk] == -32767.0)
                                    GCParray[ii].keepit = 0;
                                 }
                              }
                           }
                        mean = mean / 21.0; /** mean holds the mean value for the non-zero-weight elevations in the 5x5 GCPref array **/
                        variance = 0.0;
                        weighted_avg = 0;
                        t = (GCParray[ii].x - biXcoord) / TrueXspace;
                        u = (GCParray[ii].y - biYcoord) / TrueYspace;
                        t1 = 1.0 - t;
                        u1 = 1.0 - u;
                        Ex_upper = (t * GCPref[biX+1][biY+1]) + (t1 * GCPref[biX][biY+1]);
                        Ex_lower = (t * GCPref[biX+1][biY]) + (t1 * GCPref[biX][biY]);
                        interpelev = (u * Ex_upper) + (u1 * Ex_lower);

                        GCParray[ii].interp = interpelev; /** .interp holds the bilinear interpolated value of 4 points about the control point **/

                        for(jj = 0; jj< 5; jj++)
                           {
                           for(kk=0; kk<5; kk++)
                              {
                              if((jj == 0) || (jj == 4))
                                 {
                                 if((kk > 0) && (kk < 4))
                                    variance = variance + ((GCPref[jj][kk] - mean) * (GCPref[jj][kk] - mean));
                                 }
                              else
                                 variance = variance + ((GCPref[jj][kk] - mean) * (GCPref[jj][kk] - mean));
                              if((jj == 2) && (kk == 2))
                                 weighted_avg = weighted_avg + (GCPref[jj][kk] / 3.0);
                              else if(jj == 0)
                                 {
                                 if((kk > 0) && (kk < 4))
                                    weighted_avg = weighted_avg + (GCPref[jj][kk] / 36.0);
                                 }
                              else if(jj == 4)
                                 {
                                 if((kk > 0) && (kk < 4))
                                    weighted_avg = weighted_avg + (GCPref[jj][kk] / 36.0);
                                 }
                              else if(kk == 0)
                                 {
                                 if((jj > 0) && (jj < 4))
                                    weighted_avg = weighted_avg + (GCPref[jj][kk] / 36.0);
                                 }
                              else if(kk == 4)
                                 {
                                 if((jj > 0) && (jj < 4))
                                    weighted_avg = weighted_avg + (GCPref[jj][kk] / 36.0);
                                 }
                              else
                                 weighted_avg = weighted_avg + (GCPref[jj][kk] / 24.0);
                              } /** end looping through array second index ***/
                           } /** end looping through array first index ***/
                        variance = variance / 20.0;
                        std_dev = sqrt(variance);
                        GCParray[ii].sdev = std_dev;
                        GCParray[ii].averageE = weighted_avg;

                        GCParray[ii].difference = weighted_avg - GCParray[ii].z;  /** keep the signed difference **/

                        } /** end we are inside the y limits of the elevation array ***/
                     else
                        {
                        GCParray[ii].keepit = 4;
                        }
                     } /** end we are inside the x limits of the elevation array ***/
                  else
                     {
                     GCParray[ii].keepit = 5;
                     }
                  } /*** end gcp is matched with this TDF ***/
               } /** end for ii =    run through the array of GCP points ***/
            } /** end working withthe finished DEM ***/
         else if(IsWBM > 0)
            {
            d2 = XbaseCoord + (Xnumber * TrueXspace);
            d3 = YbaseCoord + (Ynumber * TrueYspace);
            sl = GCPread + ICESATread;
            for(ii = 0; ii<sl; ii++)
               {
               if(GCParray[ii].point_type == ((char) (IsWBM + 4)))
                  {
                  d0 = GCParray[ii].x - (2 * TrueXspace);
                  d1 = GCParray[ii].x + (2 * TrueXspace);
                  if((d0 > XbaseCoord) && (d1 < d2))
                     {
                     d0 = GCParray[ii].y - (2 * TrueYspace);
                     d1 = GCParray[ii].y + (2 * TrueYspace);
                     if((d0 > YbaseCoord) && (d1 < d3))
                        {
                        Xbt = (GCParray[ii].x - XbaseCoord) / TrueXspace;
                        js = (int) (Xbt + 0.5);

                        Ybt = (GCParray[ii].y - YbaseCoord) / TrueYspace;
                        is = (int) (Ybt + 0.5);

                        js = js - 2;
                        is = is - 2;
                        mean = 0;
                        for(jj = 0; jj < 5; jj++)
                           {
                           for(kk = 0; kk < 5; kk++)
                              {
                              WBMvalue = GetGridValue(gin,DataStartPosn,BytesPerValue,js+jj, is+kk,Xnumber,Ynumber);
                              if(WBMvalue > 0)
                                 {
                                 if((jj == 0) || (jj == 4))
                                    {
                                    if((kk > 0) && (kk < 4))
                                       {
                                       GCParray[ii].keepit = 2;
                                       }
                                    }
                                 else
                                    GCParray[ii].keepit = 2;
                                 }
                              } /*** end for kk **/
                           } /** end for jj **/
                        } /** end point is within the y limits ***/
                     } /** end within the x limits of WBM ***/
                  } /*** end matched gcp to the correct WBM ***/
               } /*** end for ii and looping thru the GCP array ***/
            } /*** end working with the WBM to disqualify GCP ***/

         if(NGA_TYPE == 0)
            BuildOpenMenu(0.0,SACttl*2,SACttl*2,polys_read,polys_done,model_polys,areals_done,linears_done,points_done,
                sphere_cv,parallel_cv,*stamps_done,footprints_done, bridges_done,*g_read,*g_write,
                FMpointsdone,FMlinesdone,FMarealsdone,0.0,0.0,0.0,0.0,0);
         else
            BuildOpenMenu(0.0,SACttl*2,SACttl*2,polys_read,polys_done,model_polys,areals_done,linears_done,points_done,
                sphere_cv,parallel_cv,FoundGrid+1,footprints_done, bridges_done,*g_read,*g_write,
                 FMpointsdone,FMlinesdone,FMarealsdone,0.0,0.0,0.0,0.0,0);



         ++FoundGrid;

         GridHeader[FoundGrid].FileNumber = infilenumber;
         GridHeader[FoundGrid].fileptr = infileposn;
         GridHeader[FoundGrid].Lindex = Lindex;
         GridHeader[FoundGrid].Sindex = Sindex;
         GridHeader[FoundGrid].Xpts = Xnumber;
         GridHeader[FoundGrid].Ypts = Ynumber;
         GridHeader[FoundGrid].BPGV = BytesPerValue;


         if(CoordSystem == 1) /** GDC ***/
            {
            Xspace = Xspace * 100000.0;
            Yspace = Yspace * 100000.0;
            GridHeader[FoundGrid].BaseX = (XbaseCoord - Xtranslation) * 100000.0;
            GridHeader[FoundGrid].BaseY = (YbaseCoord - Ytranslation) * 100000.0;
            }
         else
            {
            GridHeader[FoundGrid].BaseX = XbaseCoord - Xtranslation;
            GridHeader[FoundGrid].BaseY = YbaseCoord - Ytranslation;
            }

         MaxXIE = (int) ((GridHeader[FoundGrid].BaseX + (Xnumber * Xspace)) / LRegionSize);
         MaxYIE = (int) ((GridHeader[FoundGrid].BaseY + (Ynumber * Yspace)) / LRegionSize);



         GridHeader[FoundGrid].Xspacing = Xspace;
         GridHeader[FoundGrid].Yspacing = Yspace;

         XC[0] = GridHeader[FoundGrid].BaseX;
         YC[0] = GridHeader[FoundGrid].BaseY;
         XC[2] = XC[0] + Xspace * (Xnumber - 1);
         YC[2] = YC[0] + Yspace * (Ynumber - 1);
         XC[1] = XC[0];
         YC[1] = YC[2];
         XC[3] = XC[2];
         YC[3] = YC[0];

         if(LastLayerUsed == LL_to_Layer_Map[GridHeader[FoundGrid].Lindex])
            {
            if(XC[2] > TGxMax)
               TGxMax = XC[2];
            if(YC[2] > TGyMax)
               TGyMax = YC[2];
            if(GridHeader[FoundGrid].BaseX < TGxloc)
               {
               TGxloc = GridHeader[FoundGrid].BaseX;
               }
            if(GridHeader[FoundGrid].BaseY < TGyloc)
               {
               TGyloc = GridHeader[FoundGrid].BaseY;
               }
            }

         DrawTopLevelImageGridOutline(XC, YC, LL_to_Layer_Map[GridHeader[FoundGrid].Lindex]);

         PtsPerLM_RW = PtsInGrid / (XindexExtent * YindexExtent);

         if(OrderFlag == 2)
            {

            ind1 = (int) (GridHeader[FoundGrid].BaseX / LRegionSize);
            ind2 = (int) (GridHeader[FoundGrid].BaseY / LRegionSize);
            xoffset = (int) ((GridHeader[FoundGrid].BaseX - (ind1 * LRegionSize)) / GridHeader[FoundGrid].Xspacing);
            yoffset = (int) ((GridHeader[FoundGrid].BaseY - (ind2 * LRegionSize)) / GridHeader[FoundGrid].Yspacing);
            compositeindex = (ind1 * (YindexExtent + 1)) + ind2;

            Xlimit = GridHeader[FoundGrid].BaseX + (GridHeader[FoundGrid].Xpts * GridHeader[FoundGrid].Xspacing);
                                     /*** should be the max x coord in grid in GAIT coordinates ***/
            Ylimit = GridHeader[FoundGrid].BaseY + (GridHeader[FoundGrid].Ypts * GridHeader[FoundGrid].Yspacing);
                                      /*** should be the max y coord in grid in GAIT coordinates ***/

            for(j=ind2; j<= MaxYIE; j++)
               {
               d2 = (j - ind2) * LRegionSize; /*** GAIT coords of LM Y corner ****/
               js = (int) (d2 / GridHeader[FoundGrid].Yspacing); /*** move to point index space of the grid ***/
               if(d2 > 0)
                  js = js - yoffset;
               je = (int) (((double) ((j - ind2) + 1) * LRegionSize) / GridHeader[FoundGrid].Yspacing); /** should be last index in this LM **/
               if(d2 == 0)
                  je -= yoffset;
if(js > Ynumber)
{
continue;
}
if(je > Ynumber)
je = Ynumber;
               
d2 = GridHeader[FoundGrid].BaseY + ((double) js) * GridHeader[FoundGrid].Yspacing; /** find the GAIT coord of the DEM point for this LM ***/
               d3 = d2 + LRegionSize + (2 * GridHeader[FoundGrid].Yspacing); /** GAIT coords , max y + pad ****/
               if(d2 < 0)
                  d2 = 0;
               if(d3 > Ylimit)
                  d3 = Ylimit;
if(js > 0)
  YptsToSeekPast = js -1 ;
else
               YptsToSeekPast = js; // - 1;  
Y_LMbase = GridHeader[FoundGrid].BaseY + (YptsToSeekPast * GridHeader[FoundGrid].Yspacing);
               if(j == MaxYIE)
                  YptsToInclude = (je - js) + 1;
               else
{
YptsToInclude = (long int) (LRegionSize / GridHeader[FoundGrid].Yspacing) + 4;
if((YptsToSeekPast + YptsToInclude) > GridHeader[FoundGrid].Ypts)
   YptsToInclude = GridHeader[FoundGrid].Ypts - YptsToSeekPast;
}
unuseddbl = Y_LMbase + (YptsToInclude * GridHeader[FoundGrid].Yspacing);
unuseddbl -= GridHeader[FoundGrid].Yspacing * 0.1;
if(unuseddbl > Ylimit)
{
printf("YptsToInlude is %ld  trying to include up to %lf in LM while limit should be %lf\n",YptsToInclude,unuseddbl,Ylimit);
while(unuseddbl > Ylimit)
   {
   YptsToInclude = YptsToInclude - 1;
   unuseddbl = Y_LMbase + (YptsToInclude * GridHeader[FoundGrid].Yspacing);
   }
printf("    reset YptsToInlude to %ld  now trying to include up to %lf in LM\n",YptsToInclude,unuseddbl);
}
               for(i=ind1; i<= MaxXIE; i ++)
                  {
                  d0 = ((double) (i - ind1)) * LRegionSize; /*** GAIT coords of LM X corner ****/
                  is = (int) (d0 / GridHeader[FoundGrid].Xspacing); /*** move to point index space of the grid ***/
                  if(d0 > 0)
                     is = is - xoffset;
                  ie = (int) (((double) ((i - ind1) + 1) * LRegionSize) / GridHeader[FoundGrid].Xspacing);  /** should be last index in this LM **/
                  if(d0 == 0)
                     ie -= xoffset;
if(is > Xnumber)
{
continue;
}
if(ie > Xnumber)
  ie = Xnumber;
d0 = GridHeader[FoundGrid].BaseX + ((double) is) * GridHeader[FoundGrid].Xspacing; /** find the GAIT coord of the DEM point for this LM ***/

                  d1 = d0 + LRegionSize + (2 * GridHeader[FoundGrid].Xspacing); /** GAIT coords , max X + pad ****/
                  if(d0 < 0)
                     d0 = 0;
                  if(d1 > Xlimit)
                     d1 = Xlimit;
if(is > 0)
 XptsToSeekPast = is - 1;
else
                  XptsToSeekPast = is; 
X_LMbase = GridHeader[FoundGrid].BaseX + (XptsToSeekPast * GridHeader[FoundGrid].Xspacing);
                  if(i == MaxXIE)
                     XptsToInclude = (ie - is) + 1;
                  else
{
XptsToInclude = (long int) (LRegionSize / GridHeader[FoundGrid].Xspacing) + 4;
if((XptsToSeekPast + XptsToInclude) > GridHeader[FoundGrid].Xpts)
   XptsToInclude = GridHeader[FoundGrid].Xpts - XptsToSeekPast;
}
unuseddbl = X_LMbase + (XptsToInclude * GridHeader[FoundGrid].Xspacing);
unuseddbl -= GridHeader[FoundGrid].Xspacing * 0.1;
if(unuseddbl > Xlimit)
{
printf("XptsToInlude is %ld  trying to include up to %lf in LM while limit should be %lf\n",XptsToInclude,unuseddbl,Xlimit);
while(unuseddbl > Xlimit)
   {
   XptsToInclude = XptsToInclude - 1;
   unuseddbl = X_LMbase + (XptsToInclude * GridHeader[FoundGrid].Xspacing);
   }
printf("    reset XptsToInlude to %ld  now trying to include up to %lf in LM\n",XptsToInclude,unuseddbl);
}

                  seekposn =(YptsToSeekPast * GridHeader[FoundGrid].Xpts) + XptsToSeekPast;


                  seekposn = seekposn * CalculateBytesPerGridValue(BytesPerValue);


                  seekposn += DataStartPosn;

                  compositeindex = (i * YindexExtent ) + j; 





                  fseek(gin,seekposn,SEEK_SET);

                 if(BytesPerValue==1)
				 { 
                    fread(&tempchar, 1,1,gin);
	                pd3 = (double)tempchar;
				 } 
                 else if(BytesPerValue==2)
				 { 
                    SEEIT_fread_short(&tempshort,gin);
	                pd3 = (double)tempshort;
				 }
                 else if(BytesPerValue==3)
				 { 
                    SEEIT_fread_ushort(&tempUshort,gin);
	                pd3 = (double)tempUshort;
				 } 
                 else if(BytesPerValue==4)
				 { 
                    SEEIT_fread_int(&tempint,gin);
	                pd3 = (double)tempint;
				 }
                 else if(BytesPerValue==5)
				 { 
                    SEEIT_fread_uint(&tempUint,gin);
	                pd3 = (double)tempUint;
				 } 
                 else if(BytesPerValue==6)
				 { 
                    SEEIT_fread_float(&tempfloat,gin);
	                pd3 = (double)tempfloat;
				 } 
                 else if(BytesPerValue==9)
				 { 
                    SEEIT_fread_double(&pd3,gin);
				 }

                  i4 = 0;
                  while(NGT[compositeindex].GridIndex[i4] >= 0)
                     {
                     ++i4;
                     if(i4 >= MGPRsquared)
                        {
                        printf("FATAL ERROR IN GRID PROCESSING - Grid index out of range\n");
                        exit(-1);
                        }
                     }
                  NGT[compositeindex].NumRows[i4] = YptsToInclude;
                  NGT[compositeindex].NumCols[i4] = XptsToInclude;
                  *g_read += PtsPerLM_RW;

                  if(NGA_TYPE == 0)
                     BuildOpenMenu(0.0,SACttl*2,SACttl*2,polys_read,polys_done,model_polys,areals_done,linears_done,points_done,
                         sphere_cv,parallel_cv,*stamps_done,footprints_done, bridges_done,*g_read,*g_write,
                         FMpointsdone,FMlinesdone,FMarealsdone,0.0,0.0,0.0,0.0,0);
                  else
                     BuildOpenMenu(0.0,SACttl*2,SACttl*2,polys_read,polys_done,model_polys,areals_done,linears_done,points_done,
                         sphere_cv,parallel_cv,FoundGrid+1,footprints_done, bridges_done,*g_read,*g_write,
                          FMpointsdone,FMlinesdone,FMarealsdone,0.0,0.0,0.0,0.0,0);

                  NGT[compositeindex].FileNumber[i4] = infilenumber;
                  if((d0 <= 0) || (d1 >= Xlimit) || (d2 <= 0) || (d3 >= Ylimit))
                     {
                     if(d0 == 0)
                        NGT[compositeindex].OnEdge[i4] += 1;
                     if(d2 == 0)
                        NGT[compositeindex].OnEdge[i4] += 2;
                     if(d1 >= Xlimit)
                        NGT[compositeindex].OnEdge[i4] += 4;
                     if(d3 >= Ylimit)
                        NGT[compositeindex].OnEdge[i4] += 8;
                     }
                  NGT[compositeindex].fileptr[i4] = seekposn;
                  NGT[compositeindex].GridIndex[i4] = FoundGrid;

                  InsertIntoSCCtable(0,compositeindex,GridHeader[FoundGrid].Lindex, -1, -1);/** grids don't have an idn, so send -1 as a flag to skip that step **/
                  NGT[compositeindex].BaseX[i4] = X_LMbase; //d0;
                  NGT[compositeindex].BaseY[i4] = Y_LMbase; //d2;
                  NGT[compositeindex].BaseZ[i4] = pd3;
                  NGT[compositeindex].NumGrids += 1;
                  } /*** end for(i=ind1  ****/
               } /*** end for(j=ind2  ****/

            *g_read = last_gread + PtsInGrid;
            last_gread = *g_read;


            }
         else /** OrdFlag is not 2, as agreed - must give up here ***/
            {
            printf("Serious GAIT internal error - DEM data in incorrect order\n");
            exit(-1);
            }
         fseek(gin,endseekposn,SEEK_SET);
         infileposn = ftell(gin);
         SEEIT_fread_int(&Lindex,gin);
         if((feof(gin) != 0) && (infilenumber < NumGridFiles))
            {
            fclose(gin);
            if((infilenumber > 0) && (NumGridFiles < MaxOpenFiles))
               {
               gin = InFileHandles[infilenumber].fp;
               ++infilenumber;
               }
            else if(NumGridFiles >= MaxOpenFiles)
               {
               i6 = 0;
               i7 = 0;
               while(gridfile[i6] != '.')
                  {
                  gridfilein[i7] = gridfile[i6];
                  ++i6;
                  ++i7;
                  }
               ++infilenumber;
               sprintf(&gridfilein[i7],"%d",infilenumber);
               strcat(gridfilein,&gridfile[i6]);
               InFileHandles[0].fp = fopen(gridfilein,"rb");
               if(InFileHandles[0].fp == NULL)
                  {
                  printf("(3) fatal error when reopening grid input file %s\n", gridfilein);
                  exit(-1);
                  }
               gin = InFileHandles[0].fp;
printf("opening grid file %s\n",gridfilein);
               }
            rewind(gin);
            infileposn = ftell(gin);
            SEEIT_fread_int(&Lindex,gin);
            }
         } /** end while feof(gin) == 0) ***/

fclose(gin);
if(InFileHandles != NULL)
   free(InFileHandles);/***/

      PtsPerLM_RW = TotalPtsAllGrids / listlength;
      tableout = fopen(gridtablefile,"wb");
      for(i=0; i<listlength; i++)
         {
         k = 0;
         for(j=0; j<MGPRsquared; j++)
            {
            if(NGT[i].FileNumber[j] >= 0)
               ++k;
            }
         SEEIT_fwrite_int(&k,tableout);
         for(j=0; j<k; j++)
            {
            SEEIT_fwrite_int(&NGT[i].NumRows[j],tableout);
            SEEIT_fwrite_int(&NGT[i].NumCols[j],tableout);
            SEEIT_fwrite_int(&NGT[i].FileNumber[j],tableout);
            fwrite(&NGT[i].OnEdge[j],1,1,tableout);
            SEEIT_fwrite_long(&NGT[i].fileptr[j],tableout);
            SEEIT_fwrite_int(&NGT[i].GridIndex[j],tableout);
            SEEIT_fwrite_double(&NGT[i].BaseX[j],tableout);
            SEEIT_fwrite_double(&NGT[i].BaseY[j],tableout);
            SEEIT_fwrite_double(&NGT[i].BaseZ[j],tableout);
            }

         *g_write += PtsPerLM_RW;

         if(NGA_TYPE == 0)
            BuildOpenMenu(0.0,SACttl*2,SACttl*2,polys_read,polys_done,model_polys,areals_done,linears_done,points_done,
                sphere_cv,parallel_cv,*stamps_done,footprints_done, bridges_done,*g_read,*g_write,
                FMpointsdone,FMlinesdone,FMarealsdone,0.0,0.0,0.0,0.0,0);
         else
            BuildOpenMenu(0.0,SACttl*2,SACttl*2,polys_read,polys_done,model_polys,areals_done,linears_done,points_done,
                sphere_cv,parallel_cv,FoundGrid+1,footprints_done, bridges_done,*g_read,*g_write,
                 FMpointsdone,FMlinesdone,FMarealsdone,0.0,0.0,0.0,0.0,0);

         }

      *g_write = TotalPtsAllGrids;
      if(NGA_TYPE == 0)
         BuildOpenMenu(0.0,SACttl*2,SACttl*2,polys_read,polys_done,model_polys,areals_done,linears_done,points_done,
             sphere_cv,parallel_cv,*stamps_done,footprints_done, bridges_done,*g_read,*g_write,
             FMpointsdone,FMlinesdone,FMarealsdone,0.0,0.0,0.0,0.0,0);
      else
         BuildOpenMenu(0.0,SACttl*2,SACttl*2,polys_read,polys_done,model_polys,areals_done,linears_done,points_done,
             sphere_cv,parallel_cv,FoundGrid+1,footprints_done, bridges_done,*g_read,*g_write,
              FMpointsdone,FMlinesdone,FMarealsdone,0.0,0.0,0.0,0.0,0);

      fclose(tableout);

      for(i=0; i<(listlength + 2); i++)
         {
         free(NGT[i].FileNumber);
         free(NGT[i].GridIndex);
         free(NGT[i].NumRows);
         free(NGT[i].NumCols);
         free(NGT[i].OnEdge);
         free(NGT[i].BaseX);
         free(NGT[i].BaseY);
         free(NGT[i].BaseZ);
         free(NGT[i].fileptr);
         }
      free(NGT);
      NGT = NULL;


      } /*** end    if(NGrids > 0)  ***/
   if(NGT != NULL)
      {
      for(i=0; i<(listlength + 2); i++)
         {
         free(NGT[i].FileNumber);
         free(NGT[i].GridIndex);
         free(NGT[i].NumRows);
         free(NGT[i].NumCols);
         free(NGT[i].OnEdge);
         free(NGT[i].BaseX);
         free(NGT[i].BaseY);
         free(NGT[i].BaseZ);
         free(NGT[i].fileptr);
         }
      free(NGT);
      NGT = NULL;
      }
   hdrout = fopen(gridheader,"wb");
   SEEIT_fwrite_int(&NGrids,hdrout);
   for(i=0; i<NGrids; i++)
      {
      SEEIT_fwrite_int(&GridHeader[i].Lindex,hdrout);
      SEEIT_fwrite_int(&GridHeader[i].Sindex,hdrout);
      SEEIT_fwrite_int(&GridHeader[i].Xpts,hdrout);
      SEEIT_fwrite_int(&GridHeader[i].Ypts,hdrout);
      SEEIT_fwrite_int(&GridHeader[i].BPGV,hdrout);
      SEEIT_fwrite_int(&GridHeader[i].FileNumber,hdrout);
      SEEIT_fwrite_long(&GridHeader[i].fileptr,hdrout);
      SEEIT_fwrite_double(&GridHeader[i].BaseX,hdrout);
      SEEIT_fwrite_double(&GridHeader[i].BaseY,hdrout);
      SEEIT_fwrite_double(&GridHeader[i].Xspacing,hdrout);
      SEEIT_fwrite_double(&GridHeader[i].Yspacing,hdrout);
      }
   fclose(hdrout);
   if((GridHeader != NULL) && (ATTRTYPE_TREX() == 0))
      {
      free(GridHeader);
      GridHeader = NULL;
      }

   sl = strlen(indirectory) + 45;
   binsumfilename =  (char *) (malloc(sl));
   sprintf(binsumfilename,"%sctrlpt.bin",outdirectory);
   tempout = fopen(binsumfilename,"wt");
   free(binsumfilename);
  
   GCPexceptions = 0;
   if(gcppoints != NULL)
      {
      fclose(gcppoints);

      if(GCPread > 0)
         {
         sl = strlen(indirectory) + 45;
         gcpfilename = (char *) (malloc(sl));
         if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
            {
            sprintf(gcpfilename,"%ssummary_files\\GCPreport.csv",indirectory);
            }
         else
            {
            sprintf(gcpfilename,"%ssummary_files/GCPreport.csv",indirectory);
            }
         gcppoints = fopen(gcpfilename,"wt");
         if(gcppoints == NULL)
            {
            printf("\nfailed to open for writing GCP individual point report %s - exiting now\n",gcpfilename);
            exit(-1);
            }

         fprintf(gcppoints,"Control Point Type,Qualifies,Control Point Longitude,Control Point Latitude,Control Point Elevation,Std Deviation,DEM Weighted Avg Elevation,Difference,DEM 4-Nearest Neighbor Interpolated Elevation,Difference\n");

         sl = GCPread + ICESATread;

         for(TargetTDF = 1; TargetTDF < 5; TargetTDF++)
            {
            weighted_avg = 0;
            kk = 0;
            std_dev = 0;
            variance = 0;
            RMSEgcp = 0;
            RMSEgcp_pts = 0;
            SomePossible = 0;
            for(ii=0; ii<sl; ii++)
               {
               if(GCParray[ii].point_type == TargetTDF)
                  {
                  unuseddbl = GCParray[ii].interp - GCParray[ii].z; 
                  ++SomePossible;
                  fprintf(gcppoints,"GCP,");
                  if((GCParray[ii].keepit == 4) || (GCParray[ii].keepit == 5))
                     {
                     strcpy(junk,"Control point outside of TDF area");
                     ++GCPexceptions;
                     }

                  else if((unuseddbl >= 0) && (unuseddbl >= GCPdifLimit))
                     {
                     GCParray[ii].keepit = 99;
                     sprintf(junk,"Elev Difference Above Limit (%.2lf)",GCPdifLimit);
                     ++GCPexceptions;
                     }
                  else if((unuseddbl < 0) && (unuseddbl < (0 - GCPdifLimit)))
                     {
                     GCParray[ii].keepit = 99;
                     sprintf(junk,"Elev Difference Above Limit (%.2lf)",GCPdifLimit);
                     ++GCPexceptions;
                     }
                  else if(GCParray[ii].keepit == 0)
                     {
                     strcpy(junk,"Kernel Includes -32767");
                     ++GCPexceptions;
                     }
                  else
                     {
                     strcpy(junk,"Yes");
                     GCPused += 1;
                     }
                  fprintf(gcppoints,"%s,",junk);
                  if((GCParray[ii].keepit == 4) || (GCParray[ii].keepit == 5))
                     fprintf(gcppoints,"%.8lf,%.8lf,%.2lf, , , , , \n",GCParray[ii].x,GCParray[ii].y,GCParray[ii].z);
                  else
                     fprintf(gcppoints,"%.8lf,%.8lf,%.2lf,%.2lf,%.2lf,%.2lf,%.2lf,%.2lf\n",
                                   GCParray[ii].x,GCParray[ii].y,GCParray[ii].z,
                                   GCParray[ii].sdev,GCParray[ii].averageE,GCParray[ii].difference,
                                   GCParray[ii].interp, unuseddbl);
                  if((unuseddbl >= 0) && (unuseddbl < GCPdifLimit))
                     {
                     RMSEgcp += unuseddbl * unuseddbl;
                     RMSEgcp_pts += 1;
                     }
                  else if((unuseddbl < 0) && (unuseddbl > (0 - GCPdifLimit)))
                     {
                     RMSEgcp += unuseddbl * unuseddbl;
                     RMSEgcp_pts += 1;
                     }
                  else
                     GCParray[ii].keepit = 98;

                  if(GCParray[ii].keepit == 1)
                     {
                     weighted_avg = weighted_avg + unuseddbl;
                     ++kk;
                     }
                  }
               }

            if(kk > 0)
               {

               weighted_avg = weighted_avg / ((double) kk);
               variance = 0;
               kk = 0;
               for(ii=0; ii<sl; ii++)
                  {
                 if((GCParray[ii].point_type == TargetTDF) && (GCParray[ii].keepit == 1))
                     {
                     unuseddbl = GCParray[ii].interp - GCParray[ii].z;
                     variance = variance + ((unuseddbl - weighted_avg) * (unuseddbl - weighted_avg));
                     ++kk;
                     }
                  }
               if(kk > 1)
                  {
                  variance = variance / ((double) (kk - 1));
                  std_dev = sqrt(variance);
                  if(weighted_avg < 0)
                     d0 = (0 - weighted_avg) / std_dev;
                  else
                     d0 = weighted_avg / std_dev;
                  if(d0 > 1.4)
                     d1 = 1.28;
                  else
                     {
                     d2 = d0 * d0;
                     d3 = d2 * d0;
                     d1 = 1.6435 - (0.999556 * d0) + (0.923237 * d2) - (0.282533 * d3);
                     }
                  if(weighted_avg < 0)
                     LE90 = (0 - weighted_avg) + (d1 * std_dev);
                  else
                     LE90 = weighted_avg + (d1 * std_dev);

                  if(FORMATBUTTON == 0)
                     {
                     fprintf(badtrex,"\nGCP analyses for %s: \n", GetTRExSubName2(dirname,1));
                     fprintf(badtrex,"Number of GCP used in the statistical analyses: %d\n",kk);
                     if(kk > 0)
                        {
                        fprintf(badtrex,"  mean vertical error: %.2lf,\n  standard deviation: %.2lf,\n  LE90 ratio: %.4lf,\n  LE90: %.5lf\n",
                              weighted_avg,std_dev,d1,LE90);
                        if(RMSEgcp_pts > 0)
                           {
                           fprintf(badtrex,"  RMSE for GCP: %.2lf\n",sqrt(RMSEgcp / ((double) RMSEgcp_pts)));
                           GCPrmse = sqrt(RMSEgcp / ((double) RMSEgcp_pts));
                           }
                        GCPmean = weighted_avg;
                        GCPstddev = std_dev;
                        GCPle90 = LE90;
                        }
                     else
                        fprintf(badtrex,"no analyses applied given no qualifying control points\n");
                     }
                  }
               }
            else if(SomePossible > 0)
               {
               fprintf(badtrex,"\nGCP analyses for %s:\n", GetTRExSubName2(dirname,1));
               fprintf(badtrex,"Number of GCP used in the statistical analyses: %d\n",kk);
               fprintf(badtrex,"no analyses applied: no control points qualify for use\n");
               }
            if(TargetTDF == 4)
               {
               fprintf(badtrex,"\n  individual GCP analysis report is available in:\n    %s\n",gcpfilename);
               fprintf(badtrex,"\n  Maximum Allowed Elevation Difference value %.2lf\n", GCPdifLimit);
               }

            } /** end for TargetTDF ***/

         free(gcpfilename);
         fclose(gcppoints);
         }


      if(ICESATread > 0)
         {
         sl = strlen(indirectory) + 45;
         gcpfilename = (char *) (malloc(sl));
         if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
            {
            sprintf(gcpfilename,"%ssummary_files\\ICESATreport.csv",indirectory);
            }
         else
            {
            sprintf(gcpfilename,"%ssummary_files/ICESATreport.csv",indirectory);
            }
         gcppoints = fopen(gcpfilename,"wt");
         if(gcppoints == NULL)
            {
            printf("\nfailed to open for ICESAT individual point report %s - exiting now\n",gcpfilename);
            exit(-1);
            }

         fprintf(gcppoints,"Control Point Type,Qualifies,Control Point Longitude,Control Point Latitude,Control Point Elevation,Std Deviation,DEM Weighted Avg Elevation,Difference,DEM 4-Nearest Neighbor Interpolated Elevation,Difference\n");
         sl = GCPread + ICESATread;
         for(TargetTDF = 5; TargetTDF < 9; TargetTDF++)
            {
            weighted_avg = 0;
            kk = 0;
            std_dev = 0;
            variance = 0;
            RMSEice = 0;
            RMSEice_pts = 0;
            SomePossible = 0;
            for(ii=0; ii<sl; ii++)
               {
               if(GCParray[ii].point_type == TargetTDF)
                  {
                  ++SomePossible;
                  fprintf(gcppoints,"ICESAT,");
                  if((GCParray[ii].keepit == 4) || (GCParray[ii].keepit == 5))
                     {
                     strcpy(junk,"Control point too close to boundary to apply LE90");
                     ++GCPexceptions;
                     }
                  else if((GCParray[ii].sdev >= 0) && (GCParray[ii].sdev > DEMESp1))
                     {
                     GCParray[ii].keepit = 99;
                     sprintf(junk,"Std Deviation Above Limit (%.1lf)",DEMESp1);
                     ++GCPexceptions;
                     }
                  else if((GCParray[ii].sdev < 0) && (GCParray[ii].sdev < (0 - DEMESp1)))
                     {
                     GCParray[ii].keepit = 99;
                     sprintf(junk,"Std Deviation Above Limit (%.1lf)",DEMESp1);
                     ++GCPexceptions;
                     }
                  else if((GCParray[ii].difference >= 0) && (GCParray[ii].difference > DEMESp2))
                     {
                     GCParray[ii].keepit = 99;
                     sprintf(junk,"Elev Difference Above Limit (%.1lf)",DEMESp2);
                     ++GCPexceptions;
                     }
                  else if((GCParray[ii].difference < 0) && (GCParray[ii].difference < (0 - DEMESp2)))
                     {
                     GCParray[ii].keepit = 99;
                     sprintf(junk,"Elev Difference Above Limit (%.1lf)",DEMESp2);
                     ++GCPexceptions;
                     }
                  else if(GCParray[ii].keepit == 98)
                     {
                     sprintf(junk,"Elev Difference Above GCP Limit (%.1lf)",GCPdifLimit);
                     ++GCPexceptions;
                     }
                  else if(GCParray[ii].keepit == 0)
                     {
                     strcpy(junk,"Kernel Includes -32767");
                     ++GCPexceptions;
                     }
                  else if(GCParray[ii].keepit == 2)
                     {
                     strcpy(junk,"Kernel in WBM");
                     ++GCPexceptions;
                     }
                  else
                     {
                     strcpy(junk,"Yes");
                     RMSEice += (GCParray[ii].averageE - GCParray[ii].z) * (GCParray[ii].averageE - GCParray[ii].z);
                     RMSEice_pts += 1;
                     ICEused += 1;
                     }
                  fprintf(gcppoints,"%s,",junk);
                  unuseddbl = GCParray[ii].interp - GCParray[ii].z;
                  if(unuseddbl < 0)
                     unuseddbl = 0 - unuseddbl;
                  if((GCParray[ii].keepit == 2) || (GCParray[ii].keepit == 4) || (GCParray[ii].keepit == 5))
                     fprintf(gcppoints,"%.8lf,%.8lf,%.2lf, , , , , \n",GCParray[ii].x,GCParray[ii].y,GCParray[ii].z);
                  else
                     fprintf(gcppoints,"%.8lf,%.8lf,%.2lf,%.2lf,%.2lf,%.2lf,%.2lf,%.2lf\n",
                                   GCParray[ii].x,GCParray[ii].y,GCParray[ii].z,
                                   GCParray[ii].sdev,GCParray[ii].averageE,GCParray[ii].difference,
                                   GCParray[ii].interp, unuseddbl);

                  if(GCParray[ii].keepit == 1)
                     {
                     weighted_avg = weighted_avg + GCParray[ii].difference;
                     ++kk;
                     }
                  }
               }

            if(kk > 0)
               {
               weighted_avg = weighted_avg / ((double) kk);
               variance = 0;
               kk = 0;
               for(ii=0; ii<sl; ii++)
                  {
                  if((GCParray[ii].point_type == TargetTDF) && (GCParray[ii].keepit == 1))
                     {
                     variance = variance + ((GCParray[ii].difference - weighted_avg) * (GCParray[ii].difference - weighted_avg));
                     ++kk;
                     }
                  }
               if(kk > 1)
                  {
                  if(kk >= MinICESATqualified)
                     {
                     variance = variance / ((double) (kk - 1));
                     std_dev = sqrt(variance);
                     if(weighted_avg < 0)
                        d0 = (0 - weighted_avg) / std_dev;
                     else
                        d0 = weighted_avg / std_dev;
                     if(d0 > 1.4)
                        d1 = 1.28;
                     else
                        {
                        d2 = d0 * d0;
                        d3 = d2 * d0;
                        d1 = 1.6435 - (0.999556 * d0) + (0.923237 * d2) - (0.282533 * d3);
                        }
                     if(weighted_avg < 0)
                        LE90 = (0 - weighted_avg) + (d1 *std_dev);
                     else
                        LE90 = weighted_avg + (d1 * std_dev);
                     if(FORMATBUTTON == 0)
                        {
                        if(GCPread == 0)
                           fprintf(badtrex,"\n");
                        fprintf(badtrex,"\nICESAT point analyses for %s:\n", GetTRExSubName2(dirname,1));
                        fprintf(badtrex,"Number of ICESAT points used in the statistical analyses: %d\n",kk);
                        if(kk > 0)
                           {
                           fprintf(badtrex,"  mean vertical error: %.2lf,\n  standard deviation: %.2lf,\n  LE90 ratio: %.4lf,\n  LE90: %.5lf\n",
                                 weighted_avg,std_dev,d1,LE90);
                           if(RMSEice_pts > 0)
                              {
                              fprintf(badtrex,"  RMSE for ICESAT points: %.2lf\n",sqrt(RMSEice / ((double) RMSEice_pts)));
                              ICErmse = sqrt(RMSEice / ((double) RMSEice_pts));
                              }
                           ICEmean = weighted_avg;
                           ICEstddev = std_dev;
                           ICEle90 = LE90;
                           }
                        else
                           fprintf(badtrex,"no analyses applied given no qualifying control points\n");
                        }
                     }
                  else
                     {
                     fprintf(badtrex,"\nICESAT point analyses for %s:\n", GetTRExSubName2(dirname,1));
                     fprintf(badtrex,"Number of ICESAT points used in the statistical analyses: %d\n",kk);
                     fprintf(badtrex,"No analyses applied: Number of qualified points is less than the minimum required (%d)\n",  
                                MinICESATqualified);
                     }
                  }
               }
            else if(SomePossible > 0)
               {
               fprintf(badtrex,"\nICESAT point analyses for %s:\n", GetTRExSubName2(dirname,1));
               fprintf(badtrex,"Number of ICESAT points used in the statistical analyses: %d\n",kk);
               fprintf(badtrex,"no analyses applied: no control points qualify for use\n");
               }
            if(TargetTDF == 8)
               {
               fprintf(badtrex,"\n  individual ICESAT point analysis report is available in:\n    %s\n",gcpfilename);
               fprintf(badtrex,"\n  Standard Deviation 'Reference Noise Influenced Parameter' value %.2lf\n", NoiseThreshold);
               fprintf(badtrex,"  Elevation Difference 'Reference Max Difference' value %.2lf\n", MaxDifference);
               }
            } /** end for TargetTDF ***/

         free(gcpfilename);
         fclose(gcppoints);
         }

      gcppoints = NULL;
      }

   fprintf(tempout,"%d\n",ICEused);
   if(ICEused >= MinICESATqualified)
      {
      fprintf(tempout,"%.5lf\n%.5lf\n%.5lf\n%.5lf\n",ICEstddev,ICEmean,ICErmse,ICEle90);
      }
   else
      {
      fprintf(tempout,"N/A\nN/A\nN/A\nN/A\n");
      }
   fprintf(tempout,"%d\n",GCPused);
   if(GCPused > 0)
      {
      fprintf(tempout,"%.5lf\n%.5lf\n%.5lf\n%.5lf\n",GCPstddev,GCPmean,GCPrmse,GCPle90);
      }
   else
      {
      fprintf(tempout,"N/A\nN/A\nN/A\nN/A\n");
      }
   fclose(tempout);

   if(GCParray != NULL)
      {
      free(GCParray);
      GCParray = NULL;
      }

}  /*** end function NewFormatGrid   ***/






void FormatModelPolys(int SACttl,int coordflag, int TotalSCC, int polys_read, int polys_done, int *model_polys,int areals_done,int linears_done,
                      int points_done, int sphere_cv,int parallel_cv,int stamps_done,int footprints_done,
                      int bridges_done, unsigned int g_read, unsigned int g_write, int FMpointsdone, int FMlinesdone, int FMarealsdone)
{
int listlength;
FILE *polyin;
FILE *polyout;
FILE *tableout;
int i,j;
int XindexExtent, YindexExtent;
int polyID;
int ind1,ind2;
long fileposn;
double minX, minY, maxX, maxY;
int IM = ImageMaxSize - 1;
double RminX,RminY;
int Sx,Sy,Ex,Ey;
int FormatRequired = 1;

double SunRadianAngle, SunTangent;
double L1,L2,L3,N1,N2,N3;
int si1, si2;
int i1,i2,j1,j2;
int offXpix, offYpix;


int idiff, jdiff;
double d1, d2,px,py,offx,offy;

int Sxi, Syj;
double SunX = 10000.0;
double SunY = 10000.0;
double SunAngle = 45.0;
double Ip = 1.0;
double Kd = 0.95;

struct RawPoly *cp, *pp;
struct PtrList *plst, *clst;

int SzRP = sizeof(struct RawPoly);
int SzOL = sizeof(struct ObjectLookup);
int SzPtrList = sizeof(struct PtrList);
unsigned char pixcolor;


   SunRadianAngle = ((double) SunAngle * PI) / 180.0;
   SunTangent = tan(SunRadianAngle);
   d1 = sqrt(SunX*SunX + SunY*SunY);
   d2 = SunTangent * d1; /* z height at SunX,SunY, angle of SunAngle */
   d1 = sqrt(SunX*SunX + SunY*SunY + d2*d2); /* "dist" to sun?? */
   L1 = (double) SunX / d1;
   L2 = (double) (0 - SunY) / d1;
   L3 = d2 / d1;
   if(SCCdataArray == NULL)
      {
      FormatFromDynamicDefsFile(TotalSCC);
      }


   XindexExtent = (int) (MaxXcoord / LRegionSize) + 2;
   YindexExtent = (int) (MaxYcoord / LRegionSize) + 2;

   listlength = XindexExtent * YindexExtent;

   SingleRegionPolys = (struct singles *) (malloc(sizeof(struct singles) * listlength));
   LocalPolyTable = (struct ObjectLookup *) (malloc(SzOL * listlength));

   for(i=0; i<listlength; i++)
      {
      SingleRegionPolys[i].root = NULL;
      LocalPolyTable[i].fileptr = 0;
      LocalPolyTable[i].numpoly = 0;
      LocalPolyTable[i].numother = 0;
      LocalPolyTable[i].others = NULL;
      }



   polyout = fopen(modelPdata,"wb");

   polyin = fopen(modelPfile,"rb");
   if(polyin == NULL)
      {
      printf("attempt to format: could not open polygon file %s\n",modelPfile);
      FormatRequired = 0;
      }


   BuildOpenMenu(0.0,SACttl*2,SACttl*2,polys_read,polys_done,*model_polys,areals_done,linears_done,points_done,
          sphere_cv,parallel_cv,stamps_done,footprints_done, bridges_done,g_read,g_write,
           FMpointsdone,FMlinesdone,FMarealsdone,0.0,0.0,0.0,0.0,0);

   polyID = -1;
   if(FormatRequired)
      {
      SEEIT_fread_int(&ind1,polyin);
      while(feof(polyin) == 0)
         {
         cp = (struct RawPoly *) malloc(SzRP);
         if(cp == NULL)
            {
            printf("allocation memory exhausted during polygon format\n");
            exit(-1);
            }
         cp->next = NULL;
         cp->idn = polyID;
         cp->Lindex = ind1;
            SEEIT_fread_int(&cp->Sindex,polyin);
            SEEIT_fread_int(&cp->numverts,polyin);
         ClassData[cp->Sindex].occurrences += 1;
         NArray[cp->Lindex].occurrences += 1;  
         NArray[cp->Lindex].configcount[ClassData[cp->Sindex].C] += 1; /** bump polygon counter **/
         LongListInstances[cp->Lindex] += 1;
         if(LongToShortMap[cp->Lindex] < 0)
            LongToShortMap[cp->Lindex] = cp->Sindex;
         else if(LongToShortMap[cp->Lindex] != cp->Sindex)
            {
            printf("FATAL ERROR -- found one too many mappings from long to short list!!!\n");
            printf("mapping long list index %d into both %d and %d on short list\n",cp->Lindex,
                    LongToShortMap[cp->Lindex],cp->Sindex);
            exit(-1);
            }
         cp->x = (double *) (malloc(cp->numverts * SzD));
         cp->y = (double *) (malloc(cp->numverts * SzD));
         cp->z = (double *) (malloc(cp->numverts * SzD));
         if((cp->x == NULL) || (cp->y == NULL) || (cp->z == NULL))
            {
               printf("allocation memory exhausted during polygon format\n");
            exit(-1);
            }
         maxX = maxY = 0.0;
         minX = MaxXcoord;
         minY = MaxYcoord;
         for(i=0; i<cp->numverts; i++)
            {
               SEEIT_fread_double(&cp->x[i],polyin);
               SEEIT_fread_double(&cp->y[i],polyin);
               SEEIT_fread_double(&cp->z[i],polyin);
   
            if(coordflag == 1) /** GDC ***/
               {
               cp->x[i] = (cp->x[i] - Xtranslation) * 100000.0;
               cp->y[i] = (cp->y[i] - Ytranslation) * 100000.0;
               }
            else if(coordflag == 2) /** UTM **/
               {
               cp->x[i] = cp->x[i] - Xtranslation;
               cp->y[i] = cp->y[i] - Ytranslation;
               }
            if(cp->x[i] < minX)
               minX = cp->x[i];
            if(cp->x[i] > maxX)
               maxX = cp->x[i];
            if(cp->y[i] < minY)
               minY = cp->y[i];
            if(cp->y[i] > maxY)
               maxY = cp->y[i];
            }
      pixcolor = 0;
      if(
	 ((NGA_TYPE==1)||(SCCdataArray[cp->Sindex].D != D_NONE)) && 
	 (cp->numverts > 1)
	 )
         {

	   pixcolor = SpecialDomainColors[SCCdataArray[cp->Sindex].D];
         }

         *model_polys += 1;
         if((*model_polys % 100) == 0)
            BuildOpenMenu(0.0,SACttl*2,SACttl*2,polys_read,polys_done,*model_polys,areals_done,linears_done,points_done,
                   sphere_cv,parallel_cv,stamps_done,footprints_done, bridges_done,g_read,g_write,
                    FMpointsdone,FMlinesdone,FMarealsdone,0.0,0.0,0.0,0.0,0);

         Sx = (int) floor((minX / LRegionSize));
         Ex = (int) floor((maxX / LRegionSize));
         Sy = (int) floor((minY / LRegionSize));
         Ey = (int) floor((maxY / LRegionSize));

         RminX = (double) Sx * LRegionSize;
         RminY = (double) Sy * LRegionSize;
   
         if((RminX == minX) && (Sx > 0))
            --Sx;
         if((RminY == minY) && (Sy > 0))
            --Sy;

         if((Sx == Ex) && (Sy == Ey)) /** single region poly **/
            {
            cp->next = NULL;
            ++SinglePolys;
            ind2 = (Sx * YindexExtent) + Sy;
            if(SingleRegionPolys[ind2].root == NULL)
               SingleRegionPolys[ind2].root = cp;
            else
               {
               pp = SingleRegionPolys[ind2].root;
               while(pp->next != NULL)
                  pp = pp->next;
               pp->next = cp;
               }
            if(ind2 < listlength)
               InsertIntoSCCtable(0,ind2, cp->Lindex, cp->idn, -1);
   
            LocalPolyTable[ind2].numpoly += 1;
 
         if((NGA_TYPE == 0) && (ShadedReliefRequired) && (SCCdataArray[cp->Sindex].S == 5)) /**a surface polygona**/
            {
            si1 = 1;
            si2 = 2;
            if(cp->numverts > 3)
               {
               while(Three3DPointsAreColinear(cp->x[0],cp->y[0],cp->z[0], cp->x[si1],cp->y[si1],cp->z[si1],
                                    cp->x[si2],cp->y[si2],cp->z[si2]) > 0)
                  {
                  si1 = si2;
                  si2 += 1;
                  if(si2 >= cp->numverts) /** all vertices are colinear **/
                     break;
                  }
               }
            if(si2 < cp->numverts)
               {
               SurfNormal(cp->x[0],cp->y[0],cp->z[0], cp->x[si1],cp->y[si1],cp->z[si1],
                                    cp->x[si2],cp->y[si2],cp->z[si2], &N1,&N2,&N3);
               d1 = N1*L1 + N2*L2 + N3*L3;
               d2 = Ip * Kd * d1 * 63.0;
               if(d2 < 0) d2 = 0 - d2;
               if(d2 > 63)
                  {
                  printf("over range %f\n",d2);
                  d2 = 63;
                  }
               offx = (double) Sx * LRegionSize;
               offy = (double) Sy * LRegionSize;
               i1 = (int) floor((minX - offx) / PointsPerPixel);
               i2 = (int) ceil((maxX - offx) / PointsPerPixel);
               idiff = i2 - i1;
               j1 = (int) floor((minY - offy) / PointsPerPixel);
               j2 = (int) ceil((maxY - offy) / PointsPerPixel);
               jdiff = j2 - j1;
               offXpix = Sx * PixPerLM + i1;
               offYpix = Sy * PixPerLM + j1;
               for(i = 0; i<=idiff; i++)
                  {
                  px = offx + (double) (i1 + i) * PointsPerPixel;
                  for(j = 0; j<=jdiff; j++)
                     {
                     py = offy + (double) (j1 + j) * PointsPerPixel;
                     if(LocalPointInsidePoly(px,py,cp->x,cp->y,cp->numverts))
                        {
                        i2 = offXpix + i;
                        j2 = offYpix + j;
                        if((LandMarksSet > 0) && (pixcolor > 0))
                           {
                           PBM2[IM - j2].Row[i2].color = pixcolor;
                           }
                        if(PBM[IM - j2].Row[i2].color == InitColor)
                           PBM[IM - j2].Row[i2].color = (unsigned char) d2;
                        }
                     }
                  }
               }
            }  


            }
         else if((Sx >= 0) && (Sy >= 0))
            {
            ++MultiPolys;
            fileposn = ftell(polyout);
            SEEIT_fwrite_int(&cp->Lindex,polyout);
            SEEIT_fwrite_int(&cp->Sindex,polyout);
            SEEIT_fwrite_int(&cp->idn,polyout);
            SEEIT_fwrite_int(&cp->idn,polyout); /*** bogus, should be the location table id # ***/
            SEEIT_fwrite_int(&cp->numverts,polyout);
            for(i=0; i<cp->numverts; i++)
               {
               SEEIT_fwrite_double(&cp->x[i],polyout);
               SEEIT_fwrite_double(&cp->y[i],polyout);
               SEEIT_fwrite_double(&cp->z[i],polyout);
               }
            for(i=Sx; i<= Ex; i++)
               {
               for(j=Sy; j <= Ey; j++)
                  {
                  ind2 = (i * YindexExtent) + j;
                  if(ind2 < listlength)
                     {
                     LocalPolyTable[ind2].numother += 1;
                     plst = (struct PtrList *) (malloc(SzPtrList));
                     plst->fileptr = fileposn;
                     plst->next = LocalPolyTable[ind2].others;
                     LocalPolyTable[ind2].others = plst;
                     InsertIntoSCCtable(0,ind2, cp->Lindex, cp->idn, -1);
                     }
                  }
               }

         if((NGA_TYPE == 0) && (ShadedReliefRequired) && (Sx >= 0) && (Sy >= 0) && (SCCdataArray[cp->Sindex].S == 5))
            {
            si1 = 1;
            si2 = 2;
            if(cp->numverts > 3)
               {
               while(Three3DPointsAreColinear(cp->x[0],cp->y[0],cp->z[0], cp->x[si1],cp->y[si1],cp->z[si1],
                                    cp->x[si2],cp->y[si2],cp->z[si2]) > 0)
                  {
                  si1 = si2;
                  si2 += 1;
                  if(si2 >= cp->numverts) /** all vertices are colinear **/
                     break;
                  }
               }
            if(si2 < cp->numverts)
               {
               SurfNormal(cp->x[0],cp->y[0],cp->z[0], cp->x[si1],cp->y[si1],cp->z[si1],
                                    cp->x[si2],cp->y[si2],cp->z[si2], &N1,&N2,&N3);
               d1 = N1*L1 + N2*L2 + N3*L3;
               d2 = Ip * Kd * d1 * 63.0;
               if(d2 < 0) d2 = 0 - d2;
               if(d2 > 63)
                  {
                  printf("over range %f\n",d2);
                  d2 = 63;
                  }
               for(Sxi = Sx; Sxi <= Ex; Sxi++)
                  {
                  offx = (double) Sxi * LRegionSize;
                  if(Sxi == Sx)
                     i1 = (int) floor((minX - offx) / PointsPerPixel);
                  else
                     i1 = 0;
                  if(Sxi == Ex)
                     i2 = (int) ceil((maxX - offx) / PointsPerPixel);
                  else
                     i2 = PixPerLM;
                  idiff = i2 - i1;
                  offXpix = Sxi * PixPerLM + i1;
                  for(Syj = Sy; Syj <= Ey; Syj++)
                     {
                     offy = (double) Syj * LRegionSize;
                     if(Syj == Sy)
                        j1 = (int) floor((minY - offy) / PointsPerPixel);
                     else
                        j1 = 0;
                     if(Syj == Ey)
                        j2 = (int) ceil((maxY - offy) / PointsPerPixel);
                     else
                        j2 = PixPerLM;
                     jdiff = j2 - j1;
                     offYpix = Syj * PixPerLM + j1;
                     for(i = 0; i<=idiff; i++)
                        {
                        px = offx + (double) (i1 + i) * PointsPerPixel;
                        for(j = 0; j<=jdiff; j++)
                           {
                           py = offy + (double) (j1 + j) * PointsPerPixel;
                           if(LocalPointInsidePoly(px,py,cp->x,cp->y,cp->numverts))
                              {
                              i2 = offXpix + i;
                              j2 = offYpix + j;
                              if((LandMarksSet > 0) && (pixcolor > 0))
                                 {
                                 PBM2[IM - j2].Row[i2].color = pixcolor;
                                 }
                              if(PBM[IM - j2].Row[i2].color == InitColor)
                                 PBM[IM - j2].Row[i2].color = (unsigned char) d2;
                              }
                           }
                        }
                     }
                  }
               }
            }

            free(cp->x);
            free(cp->y);
            free(cp->z);
            free(cp);
            }
   
            SEEIT_fread_int(&ind1,polyin);
         }
      fclose(polyin);
      }

   for(i=0; i<listlength; i++)
      {
      cp = SingleRegionPolys[i].root;
      LocalPolyTable[i].fileptr = ftell(polyout);
      while(cp != NULL)
         {
         SEEIT_fwrite_int(&cp->Lindex,polyout);
         SEEIT_fwrite_int(&cp->Sindex,polyout);
         SEEIT_fwrite_int(&cp->idn,polyout);
         SEEIT_fwrite_int(&cp->idn,polyout); /*** bogus, should be the location table id # ***/
         SEEIT_fwrite_int(&cp->numverts,polyout);
         for(j=0; j<cp->numverts; j++)
            {
            SEEIT_fwrite_double(&cp->x[j],polyout);
            SEEIT_fwrite_double(&cp->y[j],polyout);
            SEEIT_fwrite_double(&cp->z[j],polyout);
            }
         pp = cp;
         cp = cp->next;
         free(pp->x);
         free(pp->y);
         free(pp->z);
         free(pp);
         }
      }
   fclose(polyout);
   free(SingleRegionPolys);


   tableout = fopen(modelPtablefile,"wb");
   for(i=0; i<listlength; i++)
      {
      SEEIT_fwrite_int(&LocalPolyTable[i].numpoly,tableout);
      SEEIT_fwrite_long(&LocalPolyTable[i].fileptr,tableout);
      SEEIT_fwrite_int(&LocalPolyTable[i].numother,tableout);
      plst = LocalPolyTable[i].others;
      while(plst != NULL)
         {
         clst = plst;
         plst = plst->next;
         SEEIT_fwrite_long(&clst->fileptr,tableout);
         free(clst);
         }
      }
   fclose(tableout);
   free(LocalPolyTable);
  
}




void CombineImages(void)
{
  int i,j;  
  
  if(NGA_TYPE == 1)
     return;

  for(i = (ImageMaxSize - NumRows); i<ImageMaxSize; i++)
    {
      for(j=0; j<NumCols; j++)
	{
	  if(PBM2[i].Row[j].color != InitColor)
            {
	      PBM[i].Row[j].color = PBM2[i].Row[j].color;
            }
	}
    }
}



void FormatTheTerrain(char *dirname)
{
#define OccLimit 0
int SACfull, TotalSCC,Si;
/*** int  debug1;**/
unsigned char CoordSystem;
int NumID,NumDupID,i,j,k,l,sl,sli,gi,counter,parts_count,MPOcount,MPO_L, MPO_A, MPO_P;
int RCO_By_Geom[10];
double uniqueattrentry;
int MGCPmissing;
int AttrIndex, ValueIndex;
int listlength,EACindex,thistype;
int NumNames;
int NumGrids;
struct NameList *cnl, *pnl;
struct EnumList *cel, *pel, *elc;
FILE *sout;
FILE *summaryout;
FILE *summarycsvout;
FILE *datesummaryout;
FILE *REQin;
FILE *REQout, *REQ2out, *REQ3out, *REQ4out;
char * req_filename;
char Req_FCODE[7];
char GEOM,wchar;
char ReqA, ReqP, ReqL;
char resultmessage[1000];
char *res2;

struct SCClookup *csl, *psl;
int FIDindex;
int CheckIDformat;
int CheckIDlength;
int XindexExtent;
int YindexExtent;
int polys_read = 0;
int polys_done = 0;
int areals_done = 0;
int linears_done = 0;
int points_done = 0;
int bridges_done = 0;
int model_polys = 0;
int sphere_cv = 0;
int parallel_cv = 0;
int stamps_done = 0;
int footprints_done = 0;
int FMpointsdone = 0;
int FMlinesdone = 0;
int FMarealsdone = 0;
int idstrlen;
int SzIDK = sizeof(struct RB_IDkey);
short int si2;
long int seekposn;
unsigned int g_read = 0;
unsigned int g_write = 0;
double maxcounter;
double PCdone;
double AttrPCdone,dj;
char IDnotfoundString[50];
char BlankIDString[50];

struct LocalAttrList *MainList, *ML2;
struct LocalAttrValList *SubList, *SL2, *SL1, *SL0;
struct reflist *RL1, *RL2;
struct MatchList
   {
   int Aindex;
   int Vindex;
   struct MatchList * next;
   } *TempLL, *el1, *el2;
struct NotExtracted
   {
   char fcode[10];
   char geom;
   struct NotExtracted * next;
   }  *TDS_NEroot, *TDS_NEc, *TDS_NEp;


extern void InitializeInStreams(void );

int SzML = sizeof(struct MatchList);
int SzNE = sizeof(struct NotExtracted);

extern void BuildLLTable(int a1, int a2);
extern int GetNumLongAttr(int type, int override);
extern void FreeLLTable(void);
extern int * LLFidTable;


   PBM = NULL;
   PBM2 = NULL;
   ConstructFileNames(dirname,1);




   SCCdataArray = NULL;
   NListRoot = NULL;
   AListRoot = NULL;
   NumNames = 0;
   GridHeader = NULL;

   ngaNoRecord = NULL;

   AreaMProot = PointMProot = LineMProot = NULL;

   NumID = 0;
   NumDupID = 0;

   strcpy(indirectory,dirname);

   CheckIDformat = 0;
   CheckIDlength = 1;
   Summary_AE_Tree = NULL;
   GIFD_AE_Tree = NULL;
   if(NGA_TYPE == 1)
      {

Summary_AE_Tree = TTF_RBTreeCreate(TTF_StdStrComp,TTF_StrDestroy,TTF_InfoDest,TTF_IntPrint,TTF_InfoPrint);
GIFD_AE_Tree = TTF_RBTreeCreate(TTF_StdStrComp,TTF_StrDestroy,TTF_InfoDest,TTF_IntPrint,TTF_InfoPrint);
Regular_AE_Tree = TTF_RBTreeCreate(TTF_StdStrComp,TTF_StrDestroy,TTF_InfoDest,TTF_IntPrint,TTF_InfoPrint);


      if(ATTRTYPE_ANY_MGCP() > 0) /*** MGCP ***/
         CheckIDformat = 1;
      else if(ATTRTYPE_D4() > 0) /*** GIFD ***/
         CheckIDformat = 1;
      else if(ATTRTYPE_UFD2() > 0) /*** UFD2 ***/
         CheckIDformat = 1;
      else if(ATTRTYPE_UFD1() > 0) /*** UFD1 ***/
         CheckIDformat = 1;
      else if(ATTRTYPE_UFD3() > 0) /*** UFD3 ***/
         CheckIDformat = 1;
      else if(ATTRTYPE_ANY_TDS() > 0)
         {
         CheckIDformat = 1;
         CheckIDlength = 0;
         }
      else if(ATTRTYPE_ANY_GGDM() > 0) /** GGDM ***/
         {
         CheckIDformat = 1;
         CheckIDlength = 0;
         }
      else if(ATTRTYPE_SAC() > 0) /** SAC ***/
         {
         CheckIDformat = 1;
         CheckIDlength = 0;
         }
      }
   if(CheckIDformat > 0)
      {
      BuildLLTable(-1,-1);

      IDDfp = fopen(TTF_IDdatafile,"rb");
      IDHfp = fopen(TTF_IDheaderfile,"rb");
      if((IDDfp == NULL) || (IDHfp == NULL) /*****|| (IDPfp == NULL)***/)
         {
         if(IDDfp != NULL)
            fclose(IDDfp);
         if(IDHfp != NULL)
            fclose(IDHfp);
         IDDfp = IDHfp = /**IDPfp =**/ NULL;
         printf("unable to open unique id file - Unique Identifier format validity will not be inspected\n");
         }
      else if(CheckIDlength > 0)
         {
         sprintf(IDnotfoundString,"No %s found",GetFrontPart());
         sprintf(BlankIDString," Blank %s found ",GetFrontPart());

         IDstr_RB_Tree = TTF_RBTreeCreate(TTF_StdStrComp,TTF_IDstr_StrDest,RB_ID_InfoDest,TTF_IntPrint,TTF_InfoPrint);
         SEEIT_fread_short(&si2,IDDfp);
         SEEIT_fread_long(&seekposn,IDDfp);
         idstrlen = (int) si2;
         FIDindex = 0;
         while(feof(IDDfp) == 0)
            {
            if((LLFidTable[FIDindex] >= 0) && (seekposn >= 0))
               {
               if(idstrlen < 125)
                  {
                  fseek(IDHfp,seekposn,SEEK_SET);
                  fread(&resultmessage[0],idstrlen,1,IDHfp);
                  resultmessage[idstrlen] = '\0';
                  if((strcmp(resultmessage,IDnotfoundString) != 0) &&
                           (strcmp(resultmessage,BlankIDString) != 0))
                     {
                     res2 = (char *) (malloc(strlen(resultmessage) + 1));
                     strcpy(res2,resultmessage);
                     if((RB_newNode = TTF_RBExactQuery(IDstr_RB_Tree,res2)))
                        {
                        free(res2);
                        RB_ID1 = (struct RB_IDkey *) RB_newNode->info;
                        RB_ID1->counter += 1;
                        if(RB_ID1->counter == 2)
                           NumDupID += 1;
                        }
                     else
                        {
                        RB_ID1 = (struct RB_IDkey *)(malloc(SzIDK));
                        if(RB_ID1 == NULL)
                           {
                           printf("memory has been exhausted during RB-Tree information alloction for Unique Identifier frequency analysis\n");
                           exit(-1);
                           }
                        RB_ID1->idstr = (char *) malloc(strlen(resultmessage) + 1);
                        strcpy(RB_ID1->idstr,resultmessage);
                        RB_ID1->counter = 1;
                        TTF_RBTreeInsert(IDstr_RB_Tree,res2,RB_ID1);
                        NumID += 1;
                        }
                     }
                  }
               else
                  printf("unique identifier string too long to process (string length %d)\n",idstrlen);
               }
            ++FIDindex;
            SEEIT_fread_short(&si2,IDDfp);
            SEEIT_fread_long(&seekposn,IDDfp);
            idstrlen = (int) si2;
         /***SEEIT_fread_int (&idstrlen,IDDfp);***/
            }


         rewind(IDDfp);

         BUID = fopen(TTF_IDproblems,"wt");
         fprintf(BUID,"%d\n",NumDupID);
         Fwrite_IDstr_TreeInorder(IDstr_RB_Tree,IDstr_RB_Tree->root->left);
         fclose(BUID);
         BUID = NULL;
         TTF_RBTreeDestroy(IDstr_RB_Tree);   /*** free up the rb tree memory ****/
         }
      }
   else
      {
      IDDfp = IDHfp = NULL;
      }


   CountMPObjects(indirectory);

   if((NGA_TYPE == 1) && (DoAttrChecking > 0))
      {
      if((ATTRTYPE_D4() > 0) || (ATTRTYPE_ANY_MGCP() > 0))
         { /*** then is either GFDI or MGCP   ***/
         BUID = fopen(IDformat,"wt");
         }
      else if((ATTRTYPE_UFD1() > 0) || (ATTRTYPE_UFD2() > 0) || (ATTRTYPE_UFD3() > 0))
         { /*** then is either UFD1, UFD2, or UFD3   ***/
         BUID = fopen(IDformat,"wt");
         }
      else
         BUID = NULL;
      }


   CoordSystem = FormatPolys(&SACfull, &TotalSCC, &NumNames, &NumGrids, &polys_read, &polys_done, model_polys,areals_done,
                              linears_done,points_done,sphere_cv,parallel_cv,stamps_done,footprints_done,
                              bridges_done,g_read,g_write,FMpointsdone, FMlinesdone,FMarealsdone);

   if(NGA_TYPE == 1)
      BuildOpenMenu(0.0,SACfull*2,SACfull*2,linears_done, areals_done,model_polys,areals_done,linears_done,points_done,
               sphere_cv,parallel_cv,stamps_done,footprints_done, bridges_done,g_read,g_write,
               FMpointsdone,FMlinesdone,FMarealsdone,0.0,0.0, 0.0, 0.0, 0);
   else
      BuildOpenMenu(0.0,SACfull*2,SACfull*2,polys_read, polys_done,model_polys,areals_done,linears_done,points_done,
               sphere_cv,parallel_cv,stamps_done,footprints_done, bridges_done,g_read,g_write,
               FMpointsdone,FMlinesdone,FMarealsdone,0.0,0.0, 0.0, 0.0, 0);

   FormatModelPolys(SACfull,CoordSystem, TotalSCC, polys_read, polys_done, &model_polys,areals_done,linears_done,
                      points_done,sphere_cv,parallel_cv,stamps_done,footprints_done,
                              bridges_done, g_read, g_write,FMpointsdone, FMlinesdone,FMarealsdone);

   if(NGA_TYPE == 1)
      FormatPoints(SACfull,CoordSystem,polys_read, polys_done, model_polys,areals_done,
                              linears_done,&points_done,&sphere_cv,&parallel_cv,&stamps_done,&footprints_done,
                              bridges_done,g_read,g_write,&FMpointsdone, FMlinesdone,FMarealsdone);
   else
      FormatS_Points(SACfull,CoordSystem,polys_read, polys_done, model_polys,areals_done,
                              linears_done,&points_done,&sphere_cv,&parallel_cv,&stamps_done,&footprints_done,
                              bridges_done,g_read,g_write,&FMpointsdone, FMlinesdone,FMarealsdone);

   if(NumGrids > 0)
      NewFormatGrid(SACfull,CoordSystem,TotalSCC,NumGrids,polys_read, polys_done, model_polys,areals_done,
                              linears_done,points_done,sphere_cv,parallel_cv,&stamps_done,footprints_done,
                              bridges_done,&g_read,&g_write,FMpointsdone, FMlinesdone,FMarealsdone, dirname);
   FormatBridges(SACfull,CoordSystem,polys_read, polys_done, model_polys,areals_done,
                              linears_done,points_done,sphere_cv,parallel_cv,stamps_done,&footprints_done,
                              &bridges_done,g_read,g_write,FMpointsdone, FMlinesdone,FMarealsdone);


   FormatLinears(SACfull,CoordSystem,polys_read, polys_done, model_polys,areals_done,
                              &linears_done,points_done,sphere_cv,parallel_cv,stamps_done,footprints_done,
                              bridges_done,g_read,g_write,FMpointsdone, FMlinesdone,FMarealsdone);

   MonsterRoot = NULL;
   FormatAreals(SACfull,CoordSystem,TotalSCC,polys_read, polys_done, model_polys,&areals_done,
                              linears_done,points_done,sphere_cv,parallel_cv,stamps_done,footprints_done,
                              bridges_done,g_read,g_write,FMpointsdone, FMlinesdone,&FMarealsdone);  


   if(FORMATBUTTON == 0)
      {
      fclose(badtrex);
      }

   if(CheckIDformat > 0)
      FreeLLTable();

   if(BUID != NULL) 
      {
      fclose(BUID);
      BUID = NULL;
      }

   free(LL_to_Layer_Map);


   if(IDDfp != NULL)
      fclose(IDDfp);
   if(IDHfp != NULL)
      fclose(IDHfp);

   if(ShadedReliefRequired)
      {
      if(NGA_TYPE == 1)
         BuildOpenMenu(0.0,SACfull*2,SACfull*2,linears_done, areals_done,model_polys,areals_done,linears_done,points_done,
               sphere_cv,parallel_cv,stamps_done,footprints_done, bridges_done,g_read,g_write,
               FMpointsdone,FMlinesdone,FMarealsdone,0.0,0.0, 0.0, 0.0, 0);
      else
         BuildOpenMenu(0.0,SACfull*2,SACfull*2,polys_read, polys_done,model_polys,areals_done,linears_done,points_done,
               sphere_cv,parallel_cv,stamps_done,footprints_done, bridges_done,g_read,g_write,
               FMpointsdone,FMlinesdone,FMarealsdone,0.0,0.0, 0.0, 0.0, 0);

      if(NGA_TYPE == 0)
         {
         if(DO_LINES)
            CombineImages();
         }

      if(NGA_TYPE == 0)
         {
         printf("writing shaded image to file %s\n",imageout);
         sout = fopen(imageout,"wb");
         fprintf(sout,"P5 %d %d 255\n",NumCols,NumRows);
   
         for(i = (ImageMaxSize - NumRows); i<ImageMaxSize; i++)
            {
            if(NGA_TYPE == 1)
               BuildOpenMenu(0.0,SACfull*2,SACfull*2,linears_done, areals_done,model_polys,areals_done,linears_done,points_done,
                  sphere_cv,parallel_cv,stamps_done,footprints_done, bridges_done,g_read,g_write,
                  FMpointsdone,FMlinesdone,FMarealsdone,0.0,0.0, 0.0, 0.0, 0);
            else
               BuildOpenMenu(0.0,SACfull*2,SACfull*2,polys_read, polys_done,model_polys,areals_done,linears_done,points_done,
                  sphere_cv,parallel_cv,stamps_done,footprints_done, bridges_done,g_read,g_write,
                  FMpointsdone,FMlinesdone,FMarealsdone,0.0,0.0, 0.0, 0.0, 0);
   
            fwrite(&PBM[i].Row[0].color,1,NumCols,sout);
            }
         fclose(sout);
         
         if(PBM != NULL)
            {
            for(i=0; i<ImageMaxSize; i++)
               {
               free(PBM[i].Row);
               }
            free(PBM);
            }
         if(PBM2 != NULL)
            {
            for(i=0; i<ImageMaxSize; i++)
               {
               free(PBM2[i].Row);
               }
            free(PBM2);
            }
         }
      }


   if(NGA_TYPE == 1)
      BuildOpenMenu(0.0,SACfull*2,SACfull*2,linears_done, areals_done,model_polys,areals_done,linears_done,points_done,
               sphere_cv,parallel_cv,stamps_done,footprints_done, bridges_done,g_read,g_write,
               FMpointsdone,FMlinesdone,FMarealsdone,0.0,0.0, 0.0, 0.0, 0);
   else
      BuildOpenMenu(0.0,SACfull*2,SACfull*2,polys_read, polys_done,model_polys,areals_done,linears_done,points_done,
               sphere_cv,parallel_cv,stamps_done,footprints_done, bridges_done,g_read,g_write,
               FMpointsdone,FMlinesdone,FMarealsdone,0.0,0.0, 0.0, 0.0, 0);

   SetUpCrosswalk();
   if(NGA_TYPE == 1) 
      BuildOpenMenu(0.0,SACfull*2,SACfull*2,linears_done, areals_done,model_polys,areals_done,linears_done,points_done,
               sphere_cv,parallel_cv,stamps_done,footprints_done, bridges_done,g_read,g_write,
               FMpointsdone,FMlinesdone,FMarealsdone,0.0,0.0, 0.0, 0.0, 0);
   else
      BuildOpenMenu(0.0,SACfull*2,SACfull*2,polys_read, polys_done,model_polys,areals_done,linears_done,points_done,
               sphere_cv,parallel_cv,stamps_done,footprints_done, bridges_done,g_read,g_write,
               FMpointsdone,FMlinesdone,FMarealsdone,0.0,0.0, 0.0, 0.0, 0);


   summaryout = fopen(summarydatafile,"at");

   if(NGA_TYPE == 1)
      {
      sprintf(summarydatafile,"%scontentsummary.csv",outsumdirectory);

      if(ATTRTYPE_TREX() == 0)
         {
         summarycsvout = fopen(summarydatafile,"wt");
         fprintf(summarycsvout,"\"Content summary compiled by GAIT %s\"\n",VersionStr);
         fprintf(summarycsvout,"\"Project: %s (%s)\"\n",indirectory,SetThisClassLevel(1,1));
         }

      if((ATTRTYPE_TDS4() > 0) || (ATTRTYPE_GGDM21() > 0) ||
                     (ATTRTYPE_GGDM22() > 0))
         {
         datesummaryout = NULL;
         }
      else
         {
         sprintf(summarydatafile,"%sfeature_date_summary.csv",outsumdirectory);
         datesummaryout = fopen(summarydatafile,"wt");
         sprintf(summarydatafile,"%scontentsummary.csv",outsumdirectory);
         fprintf(datesummaryout,"\"Content summary compiled by GAIT %s\"\n",VersionStr);
         fprintf(datesummaryout,"\"Project: %s (classification: %s)\"\n",indirectory,SetThisClassLevel(1,1));
         }

      }

   if(NGA_TYPE == 0)
      {
      fprintf(summaryout,"%d Linear features containing %ld vertices\n",linears_done,lineverts);
      fprintf(summaryout,"%d Area features containing %ld vertices\n",areals_done,arealverts);
      }
   else
      {
      parts_count = 0;
      MPOcount = 0;
      MPoc = PointMProot;
      while(MPoc != NULL)
         {
         ++MPOcount;
         parts_count += MPoc->parts;
         MPoc = MPoc->next;
         }
      fprintf(summaryout,"%d Point features\n",points_done);
      fprintf(summaryout,"   Multi-part point features: %d (%d total parts)\n",MPOcount,parts_count);


      if((ATTRTYPE_ANY_TDS() > 0) ||
                     (ATTRTYPE_ANY_GGDM() > 0))
         {
         if(linears_done > 0)
            {
            fprintf(summaryout,"%d Curve features including %ld vertices (average %.1lf vertices per feature)\n",
               linears_done,lineverts, (double) lineverts / (double) linears_done);
            fprintf(summaryout,"   Minimum vertices on any curve feature: %d\n",MinLineVerts);
            fprintf(summaryout,"   Maximum vertices on any curve feature: %d\n",MaxLineVerts);
            }
         else
            {
            fprintf(summaryout,"%d Curve features\n",linears_done);
            }

         parts_count = 0;
         MPOcount = 0;
         MPoc = LineMProot;
         while(MPoc != NULL)
            {
            ++MPOcount;
            parts_count += MPoc->parts;
            MPoc = MPoc->next;
            }
         fprintf(summaryout,"   Multi-part curve features: %d (%d total parts)\n",MPOcount,parts_count);

         if(areals_done > 0)
            {
            fprintf(summaryout,"%d Surface features including %ld vertices (average %.1lf vertices per feature)\n",
               areals_done,arealverts, (double) arealverts / (double) areals_done);
            fprintf(summaryout,"   Number of surface feature cut-outs (not included in above surface feature count): %d\n",NumAreaHoles);
            fprintf(summaryout,"   Minimum vertices on any surface feature: %d\n",MinAreaVerts);
            fprintf(summaryout,"   Maximum vertices on any surface feature: %d\n",MaxAreaVerts);
            }
         else
            {
            fprintf(summaryout,"%d Surface features\n",areals_done);
            }
         parts_count = 0;
         MPOcount = 0;
         MPoc = AreaMProot;
         while(MPoc != NULL)
            {
            ++MPOcount;
            parts_count += MPoc->parts;
            MPoc = MPoc->next;
            }
         fprintf(summaryout,"   Multi-part surface features: %d (%d total parts)\n",MPOcount,parts_count);
         }
      else
         {
         if(linears_done > 0)
            {
            fprintf(summaryout,"%d Line features including %ld vertices (average %.1lf vertices per feature)\n",
               linears_done,lineverts, (double) lineverts / (double) linears_done);
            fprintf(summaryout,"   Minimum vertices on any line feature: %d\n",MinLineVerts);
            fprintf(summaryout,"   Maximum vertices on any line feature: %d\n",MaxLineVerts);
            }
         else
            {
            fprintf(summaryout,"%d Line features\n",linears_done);
            }

         parts_count = 0;
         MPOcount = 0;
         MPoc = LineMProot;
         while(MPoc != NULL)
            {
            ++MPOcount;
            parts_count += MPoc->parts;
            MPoc = MPoc->next;
            }
         fprintf(summaryout,"   Multi-part line features: %d (%d total parts)\n",MPOcount,parts_count);

         if(areals_done > 0)
            {
            fprintf(summaryout,"%d Area features including %ld vertices (average %.1lf vertices per feature)\n",
               areals_done,arealverts, (double) arealverts / (double) areals_done);
            fprintf(summaryout,"   Number of area feature cut-outs (not included in above area feature count): %d\n",NumAreaHoles);
            fprintf(summaryout,"   Minimum vertices on any area feature: %d\n",MinAreaVerts);
            fprintf(summaryout,"   Maximum vertices on any area feature: %d\n",MaxAreaVerts);
            }
         else
            {
            fprintf(summaryout,"%d Area features\n",areals_done);
            }
         parts_count = 0;
         MPOcount = 0;
         MPoc = AreaMProot;
         while(MPoc != NULL)
            {
            ++MPOcount;
            parts_count += MPoc->parts;
            MPoc = MPoc->next;
            }
         fprintf(summaryout,"   Multi-part area features: %d (%d total parts)\n",MPOcount,parts_count);
         }

      }

   if(NGA_TYPE > 0)
      {
      if((ATTRTYPE_ANY_TDS() > 0) ||
                     (ATTRTYPE_ANY_GGDM() > 0))
         fprintf(summaryout,"\nTotal feature count (point features + curve features + surface features): %d\n",points_done+areals_done+linears_done);
      else
         fprintf(summaryout,"\nTotal feature count (point features + line features + area features): %d\n",points_done+areals_done+linears_done);
      }
   
   if(NGA_TYPE == 1)
      {
      if((ATTRTYPE_ANY_TDS() > 0) ||
                        (ATTRTYPE_ANY_GGDM() > 0))
         {
         InitializeIntervalVVT();
         fprintf(summarycsvout,"FCODE,Name,\"Point Features\",\"Curve Features\",\"Surface Features\",\"Total Features\", ,");
         fprintf(summarycsvout,"\"Surface Cut-outs\",\"Multi-part Point Features\",\"Multi-Part Curve Features\",\"Multi-part Surface Features\"\n");
         }
      else if(ATTRTYPE_TREX() == 0)
         {
         fprintf(summarycsvout,"FCODE,Name,\"Point Features\",\"Line Features\",\"Area Features\",\"Total Features\", ,");
         fprintf(summarycsvout,"\"Area Cut-outs\",\"Multi-part Point Features\",\"Multi-Part Line Features\",\"Multi-part Area Features\"\n");
         }
      }



  
   ML2 = AListRoot;
   AttrIndex = 0;
   while(ML2 != NULL)
    {
    PCdone = ((double) AttrIndex) / ((double) NumberAListEntries);
    PCdone *= 100.0;
    ML2->thisindex = AttrIndex;
    ML2->occurrences = 0;
    SL0 = SL2 = ML2->values;
    ValueIndex = 0;
    while(SL2 != NULL)
       {
       if(NGA_TYPE == 1) 
          BuildOpenMenu(0.0,SACfull*2,SACfull*2,linears_done, areals_done,model_polys,areals_done,linears_done,points_done,
               sphere_cv,parallel_cv,stamps_done,footprints_done, bridges_done,g_read,g_write,
               FMpointsdone,FMlinesdone,FMarealsdone,PCdone,0.0, 0.0, 0.0, 0);
       else
          BuildOpenMenu(0.0,SACfull*2,SACfull*2,polys_read, polys_done,model_polys,areals_done,linears_done,points_done,
               sphere_cv,parallel_cv,stamps_done,footprints_done, bridges_done,g_read,g_write,
               FMpointsdone,FMlinesdone,FMarealsdone,PCdone,0.0, 0.0, 0.0, 0);

       SL2->occurrences = 0;
       RL1 = SL2->LongListIndices;
       while(RL1 != NULL)
          {
          ML2->occurrences += LongListInstances[RL1->index];
          SL2->occurrences += LongListInstances[RL1->index];
          RL1 = RL1->next;
          }
       SL2->Unique = -1;
       SL2->UniqueCounts = SL2->occurrences;

       if(SL2->occurrences > 0)
          {
          SL2->thisindex = ValueIndex;
          ++ValueIndex;
          SL0 = SL2;
          SL2 = SL2->next;
          }
       else
          {
          ML2->count -= 1;
          if(SL2 == ML2->values)
             {
             SL1 = ML2->values;
             SL2 = SL2->next;
             ML2->values = SL2;
             SL0 = ML2->values;
             }
          else
             {
             SL1 = SL2;
             SL2 = SL2->next;
             SL0->next = SL2;
             }
          RL1 = SL1->LongListIndices;
          while(RL1 != NULL)
             {
             RL2 = RL1;
             RL1 = RL1->next;
             free(RL2);
             }
          if(SL1->label != NULL)
             free(SL1->label);
          RL1 = SL1->references;
          while(RL1 != NULL)
             {
             RL2 = RL1;
             RL1 = RL1->next;
             free(RL2);
             }
          RL1 = SL1->UniqueLLindices;
          while(RL1 != NULL)
             {
             RL2 = RL1;
             RL1 = RL1->next;
             free(RL2);
             }
          free(SL1);
          }
       }

    SL2 = ML2->values;
    while(SL2 != NULL)
       {
       if(NGA_TYPE == 1)
          BuildOpenMenu(0.0,SACfull*2,SACfull*2,linears_done, areals_done,model_polys,areals_done,linears_done,points_done,
               sphere_cv,parallel_cv,stamps_done,footprints_done, bridges_done,g_read,g_write,
               FMpointsdone,FMlinesdone,FMarealsdone,PCdone,0.0, 0.0, 0.0, 0);
       else
          BuildOpenMenu(0.0,SACfull*2,SACfull*2,polys_read, polys_done,model_polys,areals_done,linears_done,points_done,
               sphere_cv,parallel_cv,stamps_done,footprints_done, bridges_done,g_read,g_write,
               FMpointsdone,FMlinesdone,FMarealsdone,PCdone,0.0, 0.0, 0.0, 0);

       if(SL2->Unique < 0)
          {
          SL2->Unique = 1;
          SL2->UniqueLLindexcount = 0;
          SL2->UniqueLLindices = NULL;
          SL1 = SL2->next;
          while(SL1 != NULL)
             {
             if((SL1->type == SL2->type) && (SL1->uom == SL2->uom) && (SL1->scale == SL2->scale))
                {
                switch(SL1->type)
                   {
                   case 0:
                   case 1:
                      if(SL1->value == SL2->value)
                         {
                         SL1->Unique = 0;
                         SL1->UniqueCounts = 0;
                         SL2->UniqueCounts += SL1->occurrences;
                         }
                      break;
                   case 2:
                      if(strcmp(SL1->label,SL2->label) == 0)
                         {
                         SL1->Unique = 0;
                         SL1->UniqueCounts = 0;
                         SL2->UniqueCounts += SL1->occurrences;
                         }
                      break;
                   case 3:
                   case 4:
                      if(SL1->value == SL2->value)
                         {
                         SL1->Unique = 0;
                         SL1->UniqueCounts = 0;
                         SL2->UniqueCounts += SL1->occurrences;
                         }
                      break;
                   case 5:
                   case 6:
                   case 7:
                      if((SL1->value == SL2->value) && (SL1->value2 == SL2->value2))
                         {
                         SL1->Unique = 0;
                         SL1->UniqueCounts = 0;
                         SL2->UniqueCounts += SL1->occurrences;
                         }
                      break;
                   }
                if(SL1->Unique == 0)
                   {
                   RL1 = SL1->LongListIndices;
                   while(RL1 != NULL)
                      {
                      
                      RL2 = (struct reflist *) (malloc(sizeof(struct reflist)));
                      if(RL2 == NULL)
                         {
                         printf("memory allocation failure during attribute index creation\n");
                         exit(-1);
                         }
                      RL2->index = RL1->index;
                      RL2->next = SL2->UniqueLLindices;
                      SL2->UniqueLLindices = RL2;
                      SL2->UniqueLLindexcount += 1;
                      RL1 = RL1->next;
                      }
                   }
                }
             SL1 = SL1->next;
             }
          }
       SL2 = SL2->next;
       }
    ++AttrIndex;
    ML2 = ML2->next;
    }



   NumNames = 0;
   cnl = NListRoot;
   while(cnl != NULL)
      {
      if(cnl->occurrences > 0) 
         ++NumNames;
      cnl = cnl->next;
      }

   NameAttrCross = (struct crsref *) (malloc(sizeof(struct crsref) * NumNames));
   if(NameAttrCross == NULL)
      {
      printf("allocation memory exhausted during attribute - named item cross reference\n");
      printf("program execution must terminate\n");
      exit(-1);
      }
   for(i=0; i<NumNames; i++)
      {
      NameAttrCross[i].count = 0;
      NameAttrCross[i].numunique = 0;
      NameAttrCross[i].unique = 0;
      NameAttrCross[i].AIndex = -1;
      NameAttrCross[i].VIndex = -1;
      NameAttrCross[i].next = NULL;
      }



   TempLL = (struct MatchList *) (malloc(SzML * SACfull));
   for(i=0; i<SACfull; i++)
      {
      TempLL[i].Aindex = 0;
      TempLL[i].Vindex = 0;
      TempLL[i].next = NULL;
      }
   counter = 0;
   ML2 = AListRoot;
   while(ML2 != NULL)
      {
      PCdone = ((double) counter) / ((double) NumberAListEntries);
      PCdone *= 100.0;
       if(NGA_TYPE == 1)
          BuildOpenMenu(0.0,SACfull*2,SACfull*2,linears_done, areals_done,model_polys,areals_done,linears_done,points_done,
               sphere_cv,parallel_cv,stamps_done,footprints_done, bridges_done,g_read,g_write,
               FMpointsdone,FMlinesdone,FMarealsdone,100.0,PCdone, 0.0, 0.0, 0);
       else
          BuildOpenMenu(0.0,SACfull*2,SACfull*2,polys_read, polys_done,model_polys,areals_done,linears_done,points_done,
               sphere_cv,parallel_cv,stamps_done,footprints_done, bridges_done,g_read,g_write,
               FMpointsdone,FMlinesdone,FMarealsdone,100.0,PCdone, 0.0, 0.0, 0);

      SL2 = ML2->values;
      while(SL2 != NULL)
         {
         RL1 = SL2->LongListIndices;
         while(RL1 != NULL)
            {
if(RL1->index >= SACfull)
{
printf("index overrun at %d\n",RL1->index);
exit(-1);
}
            el1 = (struct MatchList *) (malloc(SzML));
            el1->Aindex = ML2->thisindex;
            el1->Vindex = SL2->thisindex;
            el1->next = NULL;
            ++TempLL[RL1->index].Aindex;
            ++TempLL[RL1->index].Vindex;
            if(TempLL[RL1->index].next == NULL)
               TempLL[RL1->index].next = el1;
            else
               {
               el2 = TempLL[RL1->index].next;
               while(el2->next != NULL)
                  {
                  el2 = el2->next;
                  }
               el2->next = el1;
               }
               
            RL1 = RL1->next;
            }
         SL2 = SL2->next;
         }
      ML2 = ML2->next;
      ++counter;
      }
   maxcounter = 0.0;
   for(i=0; i<SACfull; i++)
      {
      maxcounter += (double) TempLL[i].Aindex;
      }

   i = 0; 
   counter = 0;
   cnl = NListRoot;
   while(cnl != NULL)
      {
         cel = cnl->indices; /*** these are LongList indices assoc with this NListRoot entry ***/
         while(cel != NULL)
            {
            LastNAC = NameAttrCross[i].next;
            if(TempLL[cel->val].next != NULL)
               {
               el1 = TempLL[cel->val].next;
               while(el1 != NULL)
                  {
                  ++counter;
                  PCdone = ((double) counter) / (maxcounter);
                  PCdone *= 100.0; 
                  if(NGA_TYPE == 1)
                     BuildOpenMenu(0.0,SACfull*2,SACfull*2,linears_done, areals_done,model_polys,areals_done,linears_done,points_done,
                          sphere_cv,parallel_cv,stamps_done,footprints_done, bridges_done,g_read,g_write,
                          FMpointsdone,FMlinesdone,FMarealsdone,100.0,100.0,PCdone, 0.0, 0);
                  else
                     BuildOpenMenu(0.0,SACfull*2,SACfull*2,polys_read, polys_done,model_polys,areals_done,linears_done,points_done,
                          sphere_cv,parallel_cv,stamps_done,footprints_done, bridges_done,g_read,g_write,
                          FMpointsdone,FMlinesdone,FMarealsdone,100.0,100.0, PCdone, 0.0, 0);


               if(NameAttrCross[i].count == 0)
                     {
                     NameAttrCross[i].occurrences = LongListInstances[cel->val]; 
                     NameAttrCross[i].count = 1;
                     NameAttrCross[i].numunique = 1;
                     NameAttrCross[i].unique = 1;
                     NameAttrCross[i].AIndex = el1->Aindex;
                     NameAttrCross[i].VIndex = el1->Vindex;
                     LastNAC = NameAttrCross[i].next;
                     }
                  else if((NameAttrCross[i].AIndex == el1->Aindex) &&
                          (NameAttrCross[i].VIndex == el1->Vindex))
                     {
                     NameAttrCross[i].occurrences += LongListInstances[cel->val];
                     LastNAC = NameAttrCross[i].next;
                     }
                  else
                     {
                     NAC2 = LastNAC;
                     while(NAC2 != NULL)
                        {
                        if((NAC2->AIndex == el1->Aindex) && (NAC2->VIndex == el1->Vindex))
                           break;
                        NAC2 = NAC2->next;
                        }
                     if(NAC2 == NULL)
                        {
                        NAC1 = (struct crsref *) (malloc(sizeof(struct crsref)));
                        if(NAC1 == NULL)
                           {
                           printf("allocation memory exhausted during attribute - named item cross reference\n");
                           printf("program execution must terminate\n");
                           exit(-1);
                           }
                        NameAttrCross[i].count += 1;
                        NAC1->unique = 0;
                        NAC1->occurrences = LongListInstances[cel->val]; 
                        NAC1->AIndex = el1->Aindex;
                        NAC1->VIndex = el1->Vindex;
                        NAC1->next = NULL;

                        if((NameAttrCross[i].AIndex > el1->Aindex) ||
                             ((NameAttrCross[i].AIndex == el1->Aindex) && (NameAttrCross[i].VIndex > el1->Vindex)))
                           {
                           NAC1->occurrences = NameAttrCross[i].occurrences;
                           NAC1->AIndex = NameAttrCross[i].AIndex;
                           NAC1->VIndex = NameAttrCross[i].VIndex;
                           NAC1->next =  NameAttrCross[i].next;
                           NameAttrCross[i].AIndex = el1->Aindex;
                           NameAttrCross[i].VIndex = el1->Vindex;
                           NameAttrCross[i].occurrences = LongListInstances[cel->val];
                           NameAttrCross[i].next = NAC1;
                           LastNAC = NameAttrCross[i].next;
                           }
                        else if(NameAttrCross[i].next == NULL)
                           {
                           NameAttrCross[i].next = NAC1;
                           LastNAC = NameAttrCross[i].next;
                           }
                        else if((NameAttrCross[i].next->AIndex > el1->Aindex) ||
                             ((NameAttrCross[i].next->AIndex == el1->Aindex) && (NameAttrCross[i].next->VIndex > el1->Vindex)))
                           {
                           NAC1->next =  NameAttrCross[i].next;
                           NameAttrCross[i].next = NAC1;
                           LastNAC = NameAttrCross[i].next;
                           }
                        else
                           {
                           NAC1->next = NULL;
                           /***NAC3 = NAC2 = NameAttrCross[i].next; ***/
                           NAC3 = NAC2 = LastNAC;

                           while(NAC2 != NULL)
                              {
                              if((NAC2->AIndex > NAC1->AIndex) ||
                                   ((NAC2->AIndex == NAC1->AIndex) && (NAC2->VIndex > NAC1->VIndex)))
                                       break;
                              NAC3 = NAC2;
                              NAC2 = NAC2->next;
                              }
                           NAC3->next = NAC1;
                           NAC1->next = NAC2;
                           }
                        }
                     else
                        {
                        NAC2->occurrences += LongListInstances[cel->val];
                        LastNAC = NAC2;
                        }
                     }
               
                  el1 = el1->next;
                  }  /** end while(el1 != NULL) ***/
               }  /*** end if(TempLL[cel->val].next != NULL) ***/
            cel = cel->next;
            }   /** end while(cel != NULL) ***/

         if(cnl->occurrences > 0)
            ++i;

      cnl = cnl->next;
      PCdone = ((double) i) / ((double) NumNames);
      PCdone *= 100.0;
      if(NGA_TYPE == 1)
         BuildOpenMenu(0.0,SACfull*2,SACfull*2,linears_done, areals_done,model_polys,areals_done,linears_done,points_done,
              sphere_cv,parallel_cv,stamps_done,footprints_done, bridges_done,g_read,g_write,
              FMpointsdone,FMlinesdone,FMarealsdone,100.0,100.0,PCdone, 0.0, 0);
      else
         BuildOpenMenu(0.0,SACfull*2,SACfull*2,polys_read, polys_done,model_polys,areals_done,linears_done,points_done,
              sphere_cv,parallel_cv,stamps_done,footprints_done, bridges_done,g_read,g_write,
              FMpointsdone,FMlinesdone,FMarealsdone,100.0,100.0, PCdone, 0.0, 0);
      } /** end while cnl != NULL ***/


   cnl = NListRoot;
   i = 0;
   while(cnl != NULL)
      {
      pnl = cnl;
      cnl = cnl->next;
      if(NGA_TYPE == 1)
         BuildOpenMenu(0.0,SACfull*2,SACfull*2,linears_done, areals_done,model_polys,areals_done,linears_done,points_done,
              sphere_cv,parallel_cv,stamps_done,footprints_done, bridges_done,g_read,g_write,
              FMpointsdone,FMlinesdone,FMarealsdone,100.0,100.0,PCdone, 0.0, 0);
      else
         BuildOpenMenu(0.0,SACfull*2,SACfull*2,polys_read, polys_done,model_polys,areals_done,linears_done,points_done,
              sphere_cv,parallel_cv,stamps_done,footprints_done, bridges_done,g_read,g_write,
              FMpointsdone,FMlinesdone,FMarealsdone,100.0,100.0, PCdone, 0.0, 0);
      if(NameAttrCross[i].count > 0)
         NameAttrCross[i].numunique = 1;
      else
         NameAttrCross[i].numunique = 0;
      if(pnl->occurrences > 0)
         {
         j = NameAttrCross[i].AIndex;
         NAC1 = NameAttrCross[i].next;
         while(NAC1 != NULL)
            {
            if(NAC1->AIndex > j)
               {
               NAC1->unique = 1;
               j = NAC1->AIndex;
               ++NameAttrCross[i].numunique;
               }
            else
               NAC1->unique = 0;
            NAC1 = NAC1->next;
            }
         ++i;
         }
      }




   for(i=0; i<SACfull; i++)
      {
      el1 = TempLL[i].next;
      while(el1 != NULL)
         {
         el2 = el1;
         el1 = el1->next;
         free(el2);
         }
      }
   free(TempLL);

   BuildLLTable(-1,-1);

   ReverseLLFidTable(SACfull);

   TtlHGTattr = GetNumLongAttr(LONG_ATTR_HGT,0);
   TtlARAattr = GetNumLongAttr(LONG_ATTR_AREA,0);
   TtlZV2attr = GetNumLongAttr(LONG_ATTR_ZV2,0);
   TtlLENattr = GetNumLongAttr(LONG_ATTR_LEN,0);
   TtlNAMattr = GetNumLongAttr(LONG_ATTR_NAM,0);

   FreeLLTable();


   if(DoAttrChecking > 0)
      {
      #if(NGA_TYPE == 1)
         CheckGIFDcompliance(SACfull*2,model_polys,areals_done,linears_done,points_done,
              sphere_cv,parallel_cv,stamps_done,footprints_done, bridges_done,g_read,g_write,
              FMpointsdone,FMlinesdone,FMarealsdone,dirname);
      #else 
         CheckAssignedSAC(allowedSAC,SACfull);
      #endif
      AttrPCdone = 100.0;
      }
   else
      {
      sout = fopen(binSACgigs,"wb");
      i = -1; /*** this is a flag that attr checking was not performed ***/
      SEEIT_fwrite_int(&i,sout);
      fclose(sout);

      sout = fopen(TTFattrgigs,"wt");
      fprintf(sout,"Attributes were not inspected\n");
      fclose(sout);
    
      sout = fopen(dtgigs,"wt");
      fprintf(sout,"Attributes were not inspected\n");
      fclose(sout);
   
      sout = fopen(valuegigs,"wt");
      fprintf(sout,"Attributes were not inspected\n");
      fclose(sout);
   
      sout = fopen(pickgigs,"wt");
      fprintf(sout,"Attributes were not inspected\n");
      fclose(sout);
    
      sout = fopen(metadatagigs,"wt");
      fprintf(sout,"Attributes were not inspected\n");
      fclose(sout);

      sout = fopen(vvtgigs,"wt");
      fprintf(sout,"Attributes were not inspected\n");
      fclose(sout);

      AttrPCdone = 0.0;
      }

   if((NGA_TYPE == 1) && (DoAttrChecking > 0))
      {
      if(ATTRTYPE_ANY_MGCP() > 0)
         {
         if(BIN_ATTR_TYPE==1)
            ReadNGAclass(GetComboFile(), 0);
         ReadMGCPrequirements(); 
     
         if(BIN_ATTR_TYPE==1)
            FreeNGAattrSpec();
         }
      }


   if(datesummaryout != NULL)
      {
      if((SRC_DATE_root == NULL) && (UPD_DATE_root == NULL))
         {
         fprintf(datesummaryout,"no attributes with source dates available\n");
         }
      else if(datesummaryout != NULL)
         {
         fprintf(datesummaryout,"FCODE,Feature Name,Point,Line,Area");

         date_c = SRC_DATE_root;
         while(date_c != NULL)
            {
            fprintf(datesummaryout,",\"Source=%s\"",date_c->date);
            date_c = date_c->next;
            }
         date_c = UPD_DATE_root;
         if(ATTRTYPE_TDS6() > 0)
            {
            while(date_c != NULL)
               {
               fprintf(datesummaryout,",\"Vertical=%s\"",date_c->date);
               date_c = date_c->next;
               }
            }
         else
            {
            while(date_c != NULL)
               {
               fprintf(datesummaryout,",\"Update=%s\"",date_c->date);
               date_c = date_c->next;
               }
            }
         fprintf(datesummaryout,"\n");

         pnl = NListRoot;
         while(pnl != NULL)
            {
            fprintf(datesummaryout,"%s,\"%s\",%.0lf,%.0lf,%.0lf",GetECCCode(pnl->ECC),GetECCLabel(pnl->ECC),
                                       pnl->configcount[C_POFE],pnl->configcount[C_LINE],pnl->configcount[C_AREA]);
            date_c = SRC_DATE_root;
            while(date_c != NULL)
               {
               date_c->count = 0;
               date_c = date_c->next;
               }
   
            cel = pnl->indices;
            while(cel != NULL)
               {
               date_c = SRC_DATE_root;
               while(date_c != NULL)
                  {
                  pel = date_c->Lindex;
                  while(pel != NULL)
                     {
                     if(pel->val == cel->val)
                        {
                        date_c->count += LongListInstances[pel->val];
                        }
                     pel = pel->next;
                     }
                  date_c = date_c->next;
                  }
               cel = cel->next;
               }
            date_c = SRC_DATE_root;
            while(date_c != NULL)
               {
               fprintf(datesummaryout,",%d",date_c->count);
               date_c = date_c->next;
               }


            date_c = UPD_DATE_root;
            while(date_c != NULL)
               {
               date_c->count = 0;
               date_c = date_c->next;
               }

            cel = pnl->indices;
            while(cel != NULL)
               {
               date_c = UPD_DATE_root;
               while(date_c != NULL)
                  {
                  pel = date_c->Lindex;
                  while(pel != NULL)
                     {
                     if(pel->val == cel->val)
                        {
                        date_c->count += LongListInstances[pel->val];
                        }
                     pel = pel->next;
                     }
                  date_c = date_c->next;
                  }
               cel = cel->next;
               }
            date_c = UPD_DATE_root;
            while(date_c != NULL)
               {
               fprintf(datesummaryout,",%d",date_c->count);
               date_c = date_c->next;
               }


   
            fprintf(datesummaryout,"\n");
            pnl = pnl->next;
            }
         }

      fclose(datesummaryout);
      if(SRC_DATE_root != NULL)
         {
         FreeDateList(SRC_DATE_root);
         SRC_DATE_root = NULL;
         }
      if(UPD_DATE_root != NULL)
         {
         FreeDateList(UPD_DATE_root);
         UPD_DATE_root = NULL;
         }
      }



   sout = fopen(scclist,"wb");
   SEEIT_fwrite_int(&NumNames,sout);
   cnl = NListRoot;
   i = 0; 
   while(cnl != NULL)
      {
      if(NGA_TYPE == 1)
         BuildOpenMenu(100.0,SACfull*2,SACfull*2,linears_done, areals_done,model_polys,areals_done,linears_done,points_done,
              sphere_cv,parallel_cv,stamps_done,footprints_done, bridges_done,g_read,g_write,
              FMpointsdone,FMlinesdone,FMarealsdone,100.0,100.0,100.0, 0.0, 0);
      else
         BuildOpenMenu(100.0,SACfull*2,SACfull*2,polys_read, polys_done,model_polys,areals_done,linears_done,points_done,
              sphere_cv,parallel_cv,stamps_done,footprints_done, bridges_done,g_read,g_write,
              FMpointsdone,FMlinesdone,FMarealsdone,100.0,100.0, 100.0, 0.0, 0);

      pnl = cnl;
      cnl = cnl->next;
      if(pnl->occurrences > 0)
         {
         SEEIT_fwrite_int(&pnl->ECC,sout);
         fwrite(&pnl->name[0],ModelNameMaxLength,1,sout);
         SEEIT_fwrite_double(&pnl->occurrences,sout);
         SEEIT_fwrite_int(&pnl->references,sout);
         if((NGA_TYPE == 1) && (DoAttrChecking > 0))
            {
            if(ATTRTYPE_ANY_MGCP() > 0)
               {
               if(pnl->occurrences > 0)
                  {
                  FORc = FORroot;
                  while(FORc != NULL)
                     {
                     if((FORc->code == pnl->ECC) && (pnl->configcount[FORc->geom] > 0))
                        {
                        AORc = FORc->atl;
                        while(AORc != NULL)
                           {
                           thistype = GetLongAttrType(AORc->code,1);
                           if(thistype >= 0)
                              {
                              pel = pnl->indices;
                              while(pel != NULL)
                                 {
                                 AORc->ttl += LongAttrCounts(pel->val, thistype);
                                 pel = pel->next;
                                 }
                              }
                           AORc = AORc->next;
                           }
                        /**break; **/
                        }
                     FORc = FORc->next;
                     }
                  FORc = FORroot;
                  while(FORc != NULL)
                     {
                     if((FORc->code == pnl->ECC) && (pnl->configcount[FORc->geom] > 0))
                        {
                        FORc->ttl += pnl->configcount[FORc->geom];
                        if((NameAttrCross[i].count > 0) && (NameAttrCross[i].unique > 0))
                           {
                           ML2 = AListRoot;
                           EACindex = -1;
                           while(ML2 != NULL)
                              {
                              if(ML2->thisindex == NameAttrCross[i].AIndex)
                                 {
                                 EACindex = ML2->code;
                                 break;
                                 }
                              ML2 = ML2->next;
                              }
                           if(EACindex >= 0)
                              {
                              AORc = FORc->atl;
                              while(AORc != NULL)
                                 {
                                 if(AORc->code == EACindex)
                                    {
                                    AORc->ttl += NameAttrCross[i].occurrences;
                                    }
                                 AORc = AORc->next;
                                 }
                              }
                           }
                        break;
                        }
                     FORc = FORc->next;
                     }
                  }
               }  /*** end attribution type for MGCP ***/
            } /*** end NGA_TYPE ***/

         cel = pnl->indices;
         while(cel != NULL)
            {
            pel = cel;
            cel = cel->next;
            SEEIT_fwrite_int(&pel->val,sout); /** read into TT.c with SEEIT_fread_int(&MdlNames[j].indices[k],SCC1)  ****/
            if(ATTRTYPE_TREX() == 0)
               free(pel);
            }
      
         SEEIT_fwrite_int(&NameAttrCross[i].numunique,sout); /*** read into TT.c with SEEIT_fread_int(&MdlNames[j].numuniqueAttr,SCC1) ***/
         SEEIT_fwrite_int(&NameAttrCross[i].count,sout); /** read into TT.c with SEEIT_fread_int(&MdlNames[j].numattributes,SCC1)***/
         if((NameAttrCross[i].count >= 0) && (NameAttrCross[i].AIndex >= 0) && (NameAttrCross[i].VIndex >= 0))
            {
            SEEIT_fwrite_int(&NameAttrCross[i].AIndex,sout); /** # of AttrIndices - SEEIT_fread_int(&MdlNames[j].AttrIndices[k],SCC1) ***/
            SEEIT_fwrite_int(&NameAttrCross[i].VIndex,sout); /** # of ValueIndices - SEEIT_fread_int(&MdlNames[j].ValueIndices[k],SCC1)***/
            SEEIT_fwrite_double(&NameAttrCross[i].occurrences,sout); /** # of ValueCounts - SEEIT_fread_int(&MdlNames[j].ValueCounts[k],SCC1) ***/
            if(NameAttrCross[i].count > 1)
               {
               NAC1 = NameAttrCross[i].next;
               while(NAC1 != NULL)
                  {
                  SEEIT_fwrite_int(&NAC1->AIndex,sout); /** AttrIndices **/
                  SEEIT_fwrite_int(&NAC1->VIndex,sout); /** ValueIndices ***/
                  SEEIT_fwrite_double(&NAC1->occurrences,sout); /** ValueCounts ***/
                  if((NGA_TYPE == 1) && (DoAttrChecking > 0))
                     {
                     if(ATTRTYPE_ANY_MGCP() > 0)
                        {
                        if(pnl->ECC >= 0)
                           {
                           ML2 = AListRoot;
                           EACindex = -1;
                           while(ML2 != NULL)
                              {
                              if(ML2->thisindex == NAC1->AIndex)
                                 {
                                 EACindex = ML2->code;
                                 break;
                                 }
                              ML2 = ML2->next;
                              }
                           if((EACindex >= 0) && (FORc != NULL))
                              {
                              AORc = FORc->atl;
                              while(AORc != NULL)
                                 {
                                 if(AORc->code == EACindex)
                                    {
                                    AORc->ttl += NAC1->occurrences;
                                    }
                                 AORc = AORc->next;
                                 }
                              }
                           }
                        }
                     }
                  NAC1 = NAC1->next;
                  }
               }
            SEEIT_fwrite_int(&NameAttrCross[i].AIndex,sout); /** if only 1 attr, it must be unique ***/
            uniqueattrentry = NameAttrCross[i].occurrences;
            NAC2 = NameAttrCross[i].next;
            while(NAC2 != NULL)
               {
               if(NAC2->AIndex == NameAttrCross[i].AIndex)
                  uniqueattrentry += NAC2->occurrences;
               NAC2 = NAC2->next;
               }
            SEEIT_fwrite_double(&uniqueattrentry,sout);
            if(NameAttrCross[i].numunique > 1)
               {
               NAC1 = NameAttrCross[i].next;
               while(NAC1 != NULL)
                  {
                  if(NAC1->unique > 0)
                     {
                     SEEIT_fwrite_int(&NAC1->AIndex,sout);
                     uniqueattrentry = 0; /** note we'll add count for NAC1 when hit it below ***/
                     NAC2 = NameAttrCross[i].next;
                     while(NAC2 != NULL)
                        {
                        if(NAC2->AIndex == NAC1->AIndex)
                           uniqueattrentry += NAC2->occurrences;
                        NAC2 = NAC2->next;
                        }
                     SEEIT_fwrite_double(&uniqueattrentry,sout);
                     }
                  NAC1 = NAC1->next;
                  }
               }
            }
         
         ++i;
         }
      else if(ATTRTYPE_TREX() == 0)
         {
         cel = pnl->indices;
         while(cel != NULL)
            {
            pel = cel;
            cel = cel->next;
            free(pel);
            }
         }
      if(ATTRTYPE_TREX() == 0)
         pnl->indices = NULL;
      }
   fclose(sout);

   FreeLLtoIDmap(SACfull);
   if((NGA_TYPE == 1) && (DoAttrChecking > 0))
      {
      if(ATTRTYPE_MGCP3() > 0)
         {
         j = strlen(outattrdirectory) + 1;
         req_filename = (char *) (malloc(j + 30));

         if(req_filename == NULL)
            {
            printf("all available memory on this platform has been used - execution must terminate now\n");
            exit(-1);
            }

         BuildOpenMenu(0.0,SACfull*2,SACfull*2,linears_done, areals_done,model_polys,areals_done,linears_done,points_done,
              sphere_cv,parallel_cv,stamps_done,footprints_done, bridges_done,g_read,g_write,
              FMpointsdone,FMlinesdone,FMarealsdone,100.0,100.0,PCdone, 0.0, 0);


         sprintf(req_filename,"%sAttrByReq_InProject.txt",outsumdirectory);
         REQout = fopen(req_filename,"wt");
         PrintMGCP_OptReq_Lists(REQout,&i, &j, &k, &l);
         fclose(REQout);

         BuildOpenMenu(0.0,SACfull*2,SACfull*2,linears_done, areals_done,model_polys,areals_done,linears_done,points_done,
              sphere_cv,parallel_cv,stamps_done,footprints_done, bridges_done,g_read,g_write,
              FMpointsdone,FMlinesdone,FMarealsdone,100.0,100.0,PCdone, 0.0, 0);

         sprintf(req_filename,"%sFeat_AttrReq_Summary.txt",outsumdirectory);
         REQout = fopen(req_filename,"wt");
         PrintMGCP_OptReq_Summary(REQout,i,j,k,l);
         fclose(REQout);

         free(req_filename);

         BuildOpenMenu(0.0,SACfull*2,SACfull*2,linears_done, areals_done,model_polys,areals_done,linears_done,points_done,
              sphere_cv,parallel_cv,stamps_done,footprints_done, bridges_done,g_read,g_write,
              FMpointsdone,FMlinesdone,FMarealsdone,100.0,100.0,PCdone, 0.0, 0);

         FreeMGCP_OptReq_Lists();
         }
      }

   cnl = NListRoot;
   while(cnl != NULL)
      {
      pnl = cnl->next;
      while((pnl != NULL) && (pnl->ECC == cnl->ECC))
         {
         for(j=0; j<NUM_C; j++)
            {
            if(j != C_GRID)
               {
               if(pnl->configcount[j] > 0)
                  {
                  cnl->occurrences += pnl->configcount[j];
                  cnl->configcount[j] += pnl->configcount[j];
                  pnl->occurrences -= pnl->configcount[j];
                  pnl->configcount[j] = 0;
                  }
               }
            }
         pnl = pnl->next;
         }
      cnl = cnl->next;
      }
   i = 0; 

   MGCPmissing = 0;
   if((NGA_TYPE == 1) && (DoAttrChecking > 0))
      {
      if((ATTRTYPE_MGCP3() > 0) || (ATTRTYPE_MGCP4() > 0))
         {
         for(j=0; j<10; j++)
            RCO_By_Geom[j] = 0;

         j = strlen(outattrdirectory) + 1;
         req_filename = (char *) (malloc(j + 30));

         if(req_filename == NULL)
            {
            printf("all available memory on this platform has been used - execution must terminate now\n");
            exit(-1);
            }

         strcpy(req_filename,GetMGCP_ReqFCODESFile());

         if(BIN_ATTR_TYPE==1)
            REQin = fopen(req_filename,"rb");
         else
            REQin = fopen(req_filename,"rt");

         if(REQin != NULL)
            {
            MGCPmissing = 0;
         
            sprintf(req_filename,"%sFeatureInventory.csv",outsumdirectory);
            REQout = fopen(req_filename,"wt");

            REQ2out = REQ4out = NULL;
            if(ATTRTYPE_MGCP3() > 0)
               {
               sprintf(req_filename,"%sMissingFCODES.csv",outsumdirectory);
               REQ2out = fopen(req_filename,"wt");

               sprintf(req_filename,"%sFeatByReq_InProject.txt",outsumdirectory);
               REQ4out = fopen(req_filename,"wt");
               }
            if(ATTRTYPE_MGCP3() > 0)
               fprintf(REQout,"Violation,FCODE,Name,Total,Area Req,Area Found,Line Req,Line Found,Point Req,Point Found\n");
            else if(ATTRTYPE_MGCP4() > 0)
               fprintf(REQout,"FCODE,Name,Total,Area Found,Line Found,Point Found\n");
        
            if(REQ4out != NULL)
               {
               fprintf(REQ4out,"Mandatory, conditional, and optional features present in the data\n");
               fprintf(REQ4out,"('M' signifies 'Mandatory' requirements, 'C' signifies 'Conditional' requirements, and 'O'\n");
               fprintf(REQ4out,"     signifies 'Optional requirements\n");
               fprintf(REQ4out,"For each feature code, following lines show:\n");
               fprintf(REQ4out,"Violation ('M' or 'C') Feature code Feature Name\n");
               fprintf(REQ4out,"        Area (Requirement - M, C, or O) Area Found\n");
               fprintf(REQ4out,"        Line (Requirement - M, C, or O) Line Found\n");
               fprintf(REQ4out,"        Point (Requirement - M, C, or O) Point Found\n");
               fprintf(REQ4out,"('M' or 'C' as 'violation' indicates missing mandatory or conditional features, by geometry))\n");
               }
   
            if(REQ2out != NULL)
               fprintf(REQ2out,"CODE,Name,Area-Req,Area-Found,Line-Req,Line-Found,Point-Req,Point-Found\n");

            if(BIN_ATTR_TYPE==1)
               {
               fread(&wchar,1,1,REQin);
               j = (int) wchar;
               fread(&Req_FCODE[0],j,1,REQin);
               Req_FCODE[j] = '\0';
               fread(&ReqP,1,1,REQin);
               fread(&ReqA,1,1,REQin);
               fread(&ReqL,1,1,REQin);
               }
            else
               fgets(req_filename,29,REQin);
            while(feof(REQin) == 0)
               {
               if(BIN_ATTR_TYPE != 1)
                  {
                  i = 0;
                  while(req_filename[i] != ',')
                     {
                     Req_FCODE[i] = req_filename[i];
                     ++i;
                     }
                  Req_FCODE[i] = '\0';
                  ++i;
                  ReqA = req_filename[i];
                  i += 2;
                  ReqP = req_filename[i];
                  i += 2;
                  ReqL = req_filename[i];
                  }
               j = GetCodeIndex(Req_FCODE);
               k = 0;
               cnl = NListRoot;
               while(cnl != NULL)
                  {
                  if(cnl->ECC == j) /** same ECC ***/
                     {
                     switch(ReqA)
                        {
                        case 'M':
                           RCO_By_Geom[0] += (int) cnl->configcount[1];
                           break;
                        case 'C':
                           RCO_By_Geom[3] += (int) cnl->configcount[1];
                           break;
                        default:
                           RCO_By_Geom[6] += (int) cnl->configcount[1];
                           break;
                        }
                     switch(ReqP)
                        {
                        case 'M':
                           RCO_By_Geom[1] += (int) cnl->configcount[5];
                           break;
                        case 'C':
                           RCO_By_Geom[4] += (int) cnl->configcount[5];
                           break;
                        default:
                           RCO_By_Geom[7] += (int) cnl->configcount[5];
                           break;
                        }
                     switch(ReqL)
                        {
                        case 'M':
                           RCO_By_Geom[2] += (int) cnl->configcount[4];
                           break;
                        case 'C':
                           RCO_By_Geom[5] += (int) cnl->configcount[4];
                           break;
                        default:
                           RCO_By_Geom[8] += (int) cnl->configcount[4];
                           break;
                        }

                     
                     if((ReqA == 'M') && (cnl->configcount[1] <= 0))
                        {
                        k = 1;
                        }
                     if((ReqP == 'M') && (cnl->configcount[5] <= 0))
                        {
                        k = 1;
                        }
                     if((ReqL == 'M') && (cnl->configcount[4] <= 0))
                        {
                        k = 1;
                        }
                     if(k < 1)
                        {
                        if((ReqA == 'C') && (cnl->configcount[1] <= 0))
                           {
                           k = 2;
                           }
                        if((ReqP == 'C') && (cnl->configcount[5] <= 0))
                           {
                           k = 2; 
                           }
                        if((ReqL == 'C') && (cnl->configcount[4] <= 0))
                           {
                           k = 2; 
                           }
                        }
                     break;
                     }
                  cnl = cnl->next;
                  }
               if(cnl == NULL)
                  {
                  if((ReqA == 'M') || (ReqP == 'M') || (ReqL == 'M'))
                     {
                     ++MGCPmissing;
                     if(ATTRTYPE_MGCP4() > 0)
                        fprintf(REQout,"%s,\"%s\",0,0,0,0\n",GetECCCode(j), GetECCLabel(j));
                     else if(ATTRTYPE_MGCP3() > 0)
                        fprintf(REQout,"M,%s,\"%s\",0,%c,0,%c,0,%c,0\n",GetECCCode(j), GetECCLabel(j),ReqA,ReqL,ReqP);
                     
                     if(REQ2out != NULL)
                        fprintf(REQ2out,"%s,\"%s\",%c,0,%c,0,%c,0\n",GetECCCode(j), GetECCLabel(j),ReqA,ReqL,ReqP);
                     sprintf(resultmessage,"%3d. %s %s ",MGCPmissing,GetECCCode(j), GetECCLabel(j));
                     sl = strlen(resultmessage);
                     if(sl > 32)
                        {
                        /***fprintf(REQ3out,"%s\n",resultmessage); ***/
                        sl = 0;
                        }
                     for(sli=sl; sli<33; sli++)
                        resultmessage[sli] = ' ';
                     resultmessage[sli] = '\0';
                     sl = strlen(resultmessage);
                     sli = 0;
                     if((ReqA == 'M') || (ReqA == 'C'))
                        {
                        sprintf(&resultmessage[sl]," Area  %c %-6d",ReqA,sli);
                        sl = strlen(resultmessage);
                        }
                     if((ReqL == 'M') || (ReqL == 'C'))
                        {
                        sprintf(&resultmessage[sl]," Line  %c %-6d",ReqL,sli);
                        sl = strlen(resultmessage);
                        }
                     if((ReqP == 'M') || (ReqP == 'C'))
                        {
                        sprintf(&resultmessage[sl]," Point %c %-6d",ReqP,sli);
                        sl = strlen(resultmessage);
                        }
                     }
                  else if((ReqA == 'C') || (ReqP == 'C') || (ReqL == 'C'))
                     {
                     if(ATTRTYPE_MGCP3() > 0)
                        fprintf(REQout,"C,%s,\"%s\",0,%c,0,%c,0,%c,0\n",GetECCCode(j), GetECCLabel(j),ReqA,ReqL,ReqP);
                     else if(ATTRTYPE_MGCP4() > 0)
                        fprintf(REQout,"%s,\"%s\",0,0,0,0\n",GetECCCode(j), GetECCLabel(j));
                     }
                  else
                     {
                     if(ATTRTYPE_MGCP3() > 0)
                        fprintf(REQout," ,%s,\"%s\",0,%c,0,%c,0,%c,0\n",GetECCCode(j), GetECCLabel(j),ReqA,ReqL,ReqP);
                     else if(ATTRTYPE_MGCP4() > 0)
                        fprintf(REQout,"%s,\"%s\",0,0,0,0\n",GetECCCode(j), GetECCLabel(j));
                     }
                  }
               else
                  {
                  if(k == 1)
                     {
                     ++MGCPmissing;
                     if(ATTRTYPE_MGCP4() > 0)
                        fprintf(REQout,"%s,\"%s\",%.0lf,%.0lf,%.0lf,%.0lf\n",GetECCCode(j), GetECCLabel(j),
                                      cnl->configcount[1]+cnl->configcount[4]+cnl->configcount[5],
                                      cnl->configcount[1],cnl->configcount[4],cnl->configcount[5]);
                     else if(ATTRTYPE_MGCP3() > 0)
                        fprintf(REQout,"M,%s,\"%s\",%.0lf,%c,%.0lf,%c,%.0lf,%c,%.0lf\n",GetECCCode(j), GetECCLabel(j),
                                      cnl->configcount[1]+cnl->configcount[4]+cnl->configcount[5],
                                      ReqA,cnl->configcount[1],ReqL,cnl->configcount[4],ReqP,cnl->configcount[5]);

                     if(REQ2out != NULL)
                        fprintf(REQ2out,"%s,\"%s\",%c,%.0lf,%c,%.0lf,%c,%.0lf\n",GetECCCode(j), GetECCLabel(j),ReqA,cnl->configcount[1],
                                                                 ReqL,cnl->configcount[4],ReqP,cnl->configcount[5]);

                     if(REQ4out != NULL)
                        {
                        fprintf(REQ4out,"M  %s \"%s\"\n",GetECCCode(j), GetECCLabel(j));
                        if(ReqA != '-')
                           fprintf(REQ4out,"       Area (%c) %.0lf\n",ReqA,cnl->configcount[1]);
                        if(ReqL != '-')
                           fprintf(REQ4out,"       Line (%c) %.0lf\n",ReqL,cnl->configcount[4]);
                        if(ReqP != '-')
                           fprintf(REQ4out,"       Point (%c) %.0lf\n",ReqP,cnl->configcount[5]);
                        }

                     sprintf(resultmessage,"%3d. %s %s ",MGCPmissing,GetECCCode(j), GetECCLabel(j));
                     sl = strlen(resultmessage);
                     if(sl > 32)
                        {
                        sl = 0;
                        }
                     for(sli=sl; sli<33; sli++)
                        resultmessage[sli] = ' ';
                     resultmessage[sli] = '\0';
                     sl = strlen(resultmessage);
                     if((ReqA == 'M') || (ReqA == 'C'))
                        {
                        sprintf(&resultmessage[sl]," Area  %c %-6.0lf",ReqA,cnl->configcount[1]);
                        sl = strlen(resultmessage);
                        }
                     if((ReqL == 'M') || (ReqL == 'C'))
                        {
                        sprintf(&resultmessage[sl]," Line  %c %-6.0lf",ReqL,cnl->configcount[4]);
                        sl = strlen(resultmessage);
                        }
                     if((ReqP == 'M') || (ReqP == 'C'))
                        {
                        sprintf(&resultmessage[sl]," Point %c %-6.0lf",ReqP,cnl->configcount[5]);
                        sl = strlen(resultmessage);
                        }
                     }
                  else if(k == 2)
                     {
                     if(ATTRTYPE_MGCP4() > 0)
                        fprintf(REQout,"%s,\"%s\",%.0lf,%.0lf,%.0lf,%.0lf\n",GetECCCode(j), GetECCLabel(j),
                                   cnl->configcount[1]+cnl->configcount[4]+cnl->configcount[5],
                                   cnl->configcount[1],cnl->configcount[4],cnl->configcount[5]);
                     else if(ATTRTYPE_MGCP3() > 0)
                        fprintf(REQout,"C,%s,\"%s\",%.0lf,%c,%.0lf,%c,%.0lf,%c,%.0lf\n",GetECCCode(j), GetECCLabel(j),
                                   cnl->configcount[1]+cnl->configcount[4]+cnl->configcount[5],
                                   ReqA,cnl->configcount[1],ReqL,cnl->configcount[4],ReqP,cnl->configcount[5]);
                     if(REQ4out != NULL)
                        {
                        fprintf(REQ4out,"C  %s \"%s\"\n",GetECCCode(j), GetECCLabel(j));
                        if(ReqA != '-')
                           fprintf(REQ4out,"       Area (%c) %.0lf\n",ReqA,cnl->configcount[1]);
                        if(ReqL != '-')
                           fprintf(REQ4out,"       Line (%c) %.0lf\n",ReqL,cnl->configcount[4]);
                        if(ReqP != '-')
                           fprintf(REQ4out,"       Point (%c) %.0lf\n",ReqP,cnl->configcount[5]);
                        }
                     }
                  else
                     {
                     if(ATTRTYPE_MGCP4() > 0)
                        fprintf(REQout,"%s,\"%s\",%.0lf,%.0lf,%.0lf,%.0lf\n",GetECCCode(j), GetECCLabel(j),
                              cnl->configcount[1]+cnl->configcount[4]+cnl->configcount[5],
                              cnl->configcount[1],cnl->configcount[4],cnl->configcount[5]);
                     else if(ATTRTYPE_MGCP3() > 0)
                        fprintf(REQout," ,%s,\"%s\",%.0lf,%c,%.0lf,%c,%.0lf,%c,%.0lf\n",GetECCCode(j), GetECCLabel(j),
                              cnl->configcount[1]+cnl->configcount[4]+cnl->configcount[5],
                              ReqA,cnl->configcount[1],ReqL,cnl->configcount[4],ReqP,cnl->configcount[5]);
                     if(REQ4out != NULL)
                        {
                        fprintf(REQ4out,"   %s \"%s\"\n",GetECCCode(j), GetECCLabel(j));
                        if((ReqA != '-') && (cnl->configcount[1] > 0))
                           fprintf(REQ4out,"       Area (%c) %.0lf\n",ReqA,cnl->configcount[1]);
                        if((ReqL != '-') && (cnl->configcount[4] > 0))
                           fprintf(REQ4out,"       Line (%c) %.0lf\n",ReqL,cnl->configcount[4]);
                        if((ReqP != '-') && (cnl->configcount[5] > 0))
                           fprintf(REQ4out,"       Point (%c) %.0lf\n",ReqP,cnl->configcount[5]);
                        }
                     }
                  }
            if(BIN_ATTR_TYPE==1)
               {
               fread(&wchar,1,1,REQin);
               j = (int) wchar;
               if(j == 0)
                  break;
               fread(&Req_FCODE[0],j,1,REQin);
               Req_FCODE[j] = '\0';
               fread(&ReqP,1,1,REQin);
               fread(&ReqA,1,1,REQin);
               fread(&ReqL,1,1,REQin);
               }
            else
               fgets(req_filename,29,REQin);
               }

            if(REQ4out != NULL)
               {
               fprintf(REQ4out,"\nFeature Count Totals\n");
               fprintf(REQ4out,"                   Area      Line     Point\n");
               fprintf(REQ4out,"  Mandatory   %9d %9d %9d\n",RCO_By_Geom[0],RCO_By_Geom[2],RCO_By_Geom[1]);
               fprintf(REQ4out,"  Conditional %9d %9d %9d\n",RCO_By_Geom[3],RCO_By_Geom[5],RCO_By_Geom[4]);
               fprintf(REQ4out,"  Optional    %9d %9d %9d\n",RCO_By_Geom[6],RCO_By_Geom[8],RCO_By_Geom[7]);
               }


            fclose(REQin);
            fclose(REQout);
            if(REQ2out != NULL)
               fclose(REQ2out);
            if(REQ4out != NULL)
               fclose(REQ4out);
            } /*** end were able to open the requirements definition file, REQin ***/
         free(req_filename);
         }  /*** end if(ATTRTYPE_MGCP3() > 0)) ***/

      strcpy(resultmessage,outdirectory);
      strcat(resultmessage,"AttrStub.bin");
      if(ATTRTYPE_MGCP3() > 0)
         {
         REQ3out = fopen(resultmessage,"at");
         j = -1;
         SEEIT_fwrite_int(&j,REQ3out);
         SEEIT_fwrite_int(&MGCPmissing,REQ3out);
         fclose(REQ3out);
         }
      }


   TDS_NEroot = NULL;
   if(ATTRTYPE_ANY_TDS() > 0)
      {
      strcpy(resultmessage,GetTDS_NotExtracted_File());
      if(strcmp(resultmessage,"UNKNOWN") != 0)
         {
         if(BIN_ATTR_TYPE==1)
            {
            REQin = fopen(resultmessage,"rb");
            if(REQin != NULL)
               {
               fread(&wchar,1,1,REQin);
               j = (int) wchar;
               fread(&resultmessage[0],j,1,REQin);
               resultmessage[j] = '\0';
               fread(&GEOM,1,1,REQin);
               while(feof(REQin) == 0)
                  {
                  TDS_NEc = (struct NotExtracted *) (malloc(SzNE));
                  if(TDS_NEc != NULL)
                     {
                     strcpy(TDS_NEc->fcode,resultmessage);
                     TDS_NEc->geom = GEOM;
                     TDS_NEc->next = NULL;
                     if(TDS_NEroot == NULL)
                        TDS_NEroot = TDS_NEc;
                     else
                        TDS_NEp->next = TDS_NEc;
                     TDS_NEp = TDS_NEc;
                     }

                  fread(&wchar,1,1,REQin);
                  j = (int) wchar;
                  if(j == 0)
                     {
                     break;
                     }
                  fread(&resultmessage[0],j,1,REQin);
                  resultmessage[j] = '\0';
                  fread(&GEOM,1,1,REQin);
                  }
               }
            }
         else
            {
            REQin = fopen(resultmessage,"rt");
            if(REQin != NULL)
               {
               fgets(resultmessage,999,REQin);
               while(feof(REQin) == 0)
                  {
                  TDS_NEc = (struct NotExtracted *) (malloc(SzNE));
                  if(TDS_NEc != NULL)
                     {
                     j = 0;
                     while((resultmessage[j] != ',') && (j < 9))
                        {
                        TDS_NEc->fcode[j] = resultmessage[j];
                        TDS_NEc->fcode[j+1] = '\0';
                        ++j;
                        }
                     if(resultmessage[j] == ',')
                        {
                        ++j;
                        TDS_NEc->geom = resultmessage[j];
                        }

                     TDS_NEc->next = NULL;
                     if(TDS_NEroot == NULL)
                        TDS_NEroot = TDS_NEc;
                     else
                        TDS_NEp->next = TDS_NEc;
                     TDS_NEp = TDS_NEc;
                     }
                  fgets(resultmessage,999,REQin);
                  }
               }
            }

            fclose(REQin);

            dj = 0;
            fprintf(summaryout,"The TDS Entity Catalog includes several feature types (e.g., classification plus\n");
            fprintf(summaryout,"geometry) that are described as \"geometry not included\" or \"Feature only in the EC\"\n");
            fprintf(summaryout,"and these feature types are noted as \"not allowed\" by associated extraction guide.\n");
            fprintf(summaryout,"Such \"EG disallowed\" features will be included in GAIT projects (when present), but \n");
            fprintf(summaryout,"will only be inspected for schema violations (e.g., attribute data type) and only those\n");
            fprintf(summaryout,"geometric inspections that are applied to all feature types (e.g., duplication) will be\n");
            fprintf(summaryout,"applied to these features as part of Master Profile inspections.\n");
            fprintf(summaryout,"TDS features in this category and included in this project are listed below\n");

            cnl = NListRoot;
            while(cnl != NULL)
               {
               if(cnl->occurrences > 0)
                  {
                  strcpy(resultmessage,GetECCCode(cnl->ECC));
                  TDS_NEp = TDS_NEroot;
                  while(TDS_NEp != NULL)
                     {
                     if(strcmp(TDS_NEp->fcode,resultmessage) == 0)
                        {
                        if((TDS_NEp->geom == 'S') && (cnl->configcount[1] > 0))
                           {
                           fprintf(summaryout,"  Surface Feature, %s, %s, count: %.0lf\n",resultmessage,GetECCLabel(cnl->ECC),cnl->configcount[1]);
                           dj += cnl->configcount[1];
                           }
                        else if((TDS_NEp->geom == 'C') && (cnl->configcount[4] > 0))
                           {
                           fprintf(summaryout,"  Curve Feature, %s, %s, count: %.0lf\n",resultmessage,GetECCLabel(cnl->ECC),cnl->configcount[4]);
                           dj += cnl->configcount[4];
                           }
                        else if((TDS_NEp->geom == 'P') && (cnl->configcount[5] > 0))
                           {
                           fprintf(summaryout,"  Point Feature, %s, %s, count: %.0lf\n",resultmessage,GetECCLabel(cnl->ECC),cnl->configcount[5]);
                           dj += cnl->configcount[5];
                           }
                        }
                     TDS_NEp = TDS_NEp->next;
                     }
                  }
               cnl = cnl->next;
               }
            if(dj == 0)
               fprintf(summaryout,"\nNo such features have been included in this project\n\n");
            else
               fprintf(summaryout,"\nThere are %.0lf \"Not Extracted\" features included in this project\n\n",dj);

            TDS_NEc = TDS_NEroot;
            while(TDS_NEc != NULL)
               {
               TDS_NEp = TDS_NEc;
               TDS_NEc = TDS_NEc->next;
               free(TDS_NEp);
               }
            TDS_NEroot = NULL;
            /** removed end brace here ****/
         }

      }


   fprintf(summaryout,"\nData content by classification and geometric form\n");

   cnl = NListRoot;
   MPO_L = MPO_A = MPO_P = 0;
   while(cnl != NULL)
      {
      if(NGA_TYPE == 1)
         BuildOpenMenu(100.0,SACfull*2,SACfull*2,linears_done, areals_done,model_polys,areals_done,linears_done,points_done,
              sphere_cv,parallel_cv,stamps_done,footprints_done, bridges_done,g_read,g_write,
              FMpointsdone,FMlinesdone,FMarealsdone,100.0,100.0,100.0, 0.0, 0);
      else
         BuildOpenMenu(100.0,SACfull*2,SACfull*2,polys_read, polys_done,model_polys,areals_done,linears_done,points_done,
              sphere_cv,parallel_cv,stamps_done,footprints_done, bridges_done,g_read,g_write,
              FMpointsdone,FMlinesdone,FMarealsdone,100.0,100.0, 100.0, 0.0, 0);

      pnl = cnl;
      cnl = cnl->next;
      if(pnl->occurrences > 0)
         {
         if(pnl->occurrences == 1)
            {
            for(j=0; j<NUM_C; j++)
               {
               if(pnl->configcount[j] > 0)
                  break;
               }
            if(j < NUM_C)
               {
               if(NGA_TYPE == 1)
                  {
                  if((j == 1) && (pnl->areaholes > 0))
                     {
                     fprintf(summaryout,"%s %s 1 occurrence of type %s (with %d total cut-outs)\n",GetECCCode(pnl->ECC), GetECCLabel(pnl->ECC),
                        ParseGAITgeometry((unsigned char) j, 2),pnl->areaholes);
                  
                     }
                  else
                     {
                     fprintf(summaryout,"%s %s 1 occurrence of type %s\n",GetECCCode(pnl->ECC), GetECCLabel(pnl->ECC),
                        ParseGAITgeometry((unsigned char) j, 2));
                     }
  
                 parts_count = 0;
                 MPOcount = 0;

                  switch(j)
                     {
                     case 1:  /*** area feature ***/
                        MPoc = AreaMProot;
                        break;
                     case 4: /** line feature ***/
                        MPoc = LineMProot;
                        break;
                     case 5:  /**** point feature ***/
                        MPoc = PointMProot;
                        break;
                     default:
                        MPoc = NULL;
                        break;
                     }
                  while(MPoc != NULL)
                     {
                     if(MPoc->ECC == pnl->ECC)
                        {
                        ++MPOcount;
                        parts_count += MPoc->parts;
                        }
                     MPoc = MPoc->next;
                     }
                  if(MPOcount > 0)
                     {
                     if(MPOcount > 1)
                        fprintf(summaryout,"       (including %d multi-part features with %d total parts)\n",MPOcount,parts_count);
                     else
                        fprintf(summaryout,"       (including %d multi-part feature with %d total parts)\n",MPOcount,parts_count);
                     }
                  }
               else
                  {
                  fprintf(summaryout,"%s 1 occurrence of type %s\n", GetECCLabel(pnl->ECC),
                        ParseGAITgeometry((unsigned char) j, 2));
                  }
               }
            }
         else if(pnl->occurrences > 1)
            {
            if(NGA_TYPE == 1)
               {
               if((ATTRTYPE_TREX() > 0) && (pnl->ECC == 0) && (GridHeader != NULL))
                  {
                  for(gi = 0; gi < NumGrids; gi++)
                     {
                     elc = pnl->indices;
                     while(elc != NULL)
                        {
                        if(elc->val == GridHeader[gi].Lindex)
                           {
                           fprintf(summaryout,"%s\n",pnl->name);
                           fprintf(summaryout,"   base coordinate %.8lf %.8lf\n",(GridHeader[gi].BaseX / 100000.0) + Xtranslation, 
                                      (GridHeader[gi].BaseY / 100000.0) + Ytranslation);
                           fprintf(summaryout,
                              "   maximum coordinate %.8lf ",
                                    ((GridHeader[gi].BaseX + ((double) (GridHeader[gi].Xpts - 1) * GridHeader[gi].Xspacing)) / 100000.0) + Xtranslation);
                           fprintf(summaryout,
                              " %.8lf\n",((GridHeader[gi].BaseY + ((double) (GridHeader[gi].Ypts - 1) * GridHeader[gi].Yspacing)) / 100000.0) + Ytranslation);
                           fprintf(summaryout,"   column (X) spacing %lf   row (Y) spacing %lf\n",GridHeader[gi].Xspacing,GridHeader[gi].Yspacing);
                           fprintf(summaryout,"   number of columns (X posts) %d  rows (Y posts) %d\n",GridHeader[gi].Xpts,GridHeader[gi].Ypts);
                           }
                        elc = elc->next;
                        }
                     }
                  }

               else if((ATTRTYPE_TREX() == 0) && (pnl->ECC == 0)) /** ECC 0 is used for grids so this is a non-TREx grid***/
                  {
                  fprintf(summaryout,"%s includes %.0lf post values\n",pnl->name, pnl->occurrences);
                  }
               else
                  {
                  fprintf(summaryout,"%s %s  %.0lf occurrences, by type\n",GetECCCode(pnl->ECC), GetECCLabel(pnl->ECC),
                      pnl->occurrences);
                  }
               }
            else
               {
               fprintf(summaryout,"%s  %.0lf occurrences, by type\n", GetECCLabel(pnl->ECC),
                      pnl->occurrences);
               }

            for(j=0; j<NUM_C; j++)
               {
               if(pnl->configcount[j] > 0)
                  {
                  if(NGA_TYPE == 0)
                     {
                     fprintf(summaryout,"    %.0lf %s\n",pnl->configcount[j],ParseGAITgeometry((unsigned char) j, 2));
                     }
                  else
                     {
                     if((j == 1) && (pnl->areaholes > 0))
                        {
                        fprintf(summaryout,"    %.0lf %s (with %d total cut-outs)\n",
                              pnl->configcount[j],ParseGAITgeometry((unsigned char) j, 2),pnl->areaholes);
                        }
                     else
                        {
                        if((ATTRTYPE_TREX() == 1) && (strcmp("CA030",GetECCCode(pnl->ECC)) == 0))
                           {
                           fprintf(summaryout,"    %d ICESAT points\n",ICESATread);
                           fprintf(summaryout,"    %d NGA Ground Control Points (GCP)\n",GCPread);
                           }
                        else if(j != C_GRID)
                           fprintf(summaryout,"    %.0lf %s\n",pnl->configcount[j],ParseGAITgeometry((unsigned char) j, 2));
                        }
                     parts_count = 0;
                     MPOcount = 0;
   
                     switch(j)
                        {
                        case 1:  /*** area feature ***/
                           MPoc = AreaMProot;
                           break;
                        case 4: /** line feature ***/
                           MPoc = LineMProot;
                           break;
                        case 5:  /**** point feature ***/
                           MPoc = PointMProot;
                           break;
                        default:
                           MPoc = NULL;
                           break;
                        }
                     while(MPoc != NULL)
                        {
                        if(MPoc->ECC == pnl->ECC)
                           {
                           ++MPOcount;
                           parts_count += MPoc->parts;
                           }
                        MPoc = MPoc->next;
                        }
                     if(MPOcount > 0)
                        {
                        if(MPOcount > 1)
                           fprintf(summaryout,"       (including %d multi-part features with %d total parts)\n",MPOcount,parts_count);
                        else
                           fprintf(summaryout,"       (including %d multi-part feature with %d total parts)\n",MPOcount,parts_count);
                        }
                     }
                  }
               }
            }
         if((NGA_TYPE == 1) && (ATTRTYPE_TREX() == 0) && (pnl->occurrences > 0))
            {
            fprintf(summarycsvout,"%s,\"%s\",%.0lf,%.0lf,%.0lf,%.0lf, ,%d,",GetECCCode(pnl->ECC),GetECCLabel(pnl->ECC),pnl->configcount[C_POFE],
                                    pnl->configcount[C_LINE],pnl->configcount[C_AREA],
                                    pnl->configcount[C_POFE]+pnl->configcount[C_AREA]+pnl->configcount[C_LINE],pnl->areaholes);
            MPOcount = 0;
            MPoc = PointMProot;
            while(MPoc != NULL)
               {
               if(MPoc->ECC == pnl->ECC)
                  {
                  ++MPOcount;
                  ++MPO_P;
                  }
               MPoc = MPoc->next;
               }
            fprintf(summarycsvout,"%d,",MPOcount);

            MPOcount = 0;
            MPoc = LineMProot;
            while(MPoc != NULL)
               {
               if(MPoc->ECC == pnl->ECC)
                  {
                  ++MPOcount;
                  ++MPO_L;
                  }
               MPoc = MPoc->next;
               }
            fprintf(summarycsvout,"%d,",MPOcount);
            
            MPOcount = 0;
            MPoc = AreaMProot;
            while(MPoc != NULL)
               {
               if(MPoc->ECC == pnl->ECC)
                  {
                  ++MPOcount;
                  ++MPO_A;
                  }
               MPoc = MPoc->next;
               }
            fprintf(summarycsvout,"%d\n",MPOcount);
            }
         } /*** end pnl->occurrence > 0 ****/
      if((ATTRTYPE_TREX() > 0) && (pnl->occurrences > 0))
         {
         cel = pnl->indices;
         while(cel != NULL)
            {
            pel = cel;
            cel = cel->next;
            free(pel);
            }
         pnl->indices = NULL;
         }

      free(pnl);
      }

   fclose(summaryout);

   if((ATTRTYPE_TREX() > 0) && (GridHeader != NULL))
      {
      free(GridHeader);
      GridHeader = NULL;
      }
   
   FreeMPO();


   if((NGA_TYPE == 1) && (ATTRTYPE_TREX() == 0))
     {
     fprintf(summarycsvout,"Totals, ,%d,%d,%d,%d, ,%d,",
                   points_done,linears_done,areals_done,points_done+areals_done+linears_done,NumAreaHoles);
     fprintf(summarycsvout,"%d,%d,%d\n",MPO_P, MPO_L, MPO_A);
     fclose(summarycsvout);
     }


   for(i=0; i<SACfull; i++)
      {
      cel = LLtoFeatureID[i].fidlist;
      while(cel != NULL)
         {
         pel = cel;
         cel = cel->next;
         free(pel);
         }
      }
   free(LLtoFeatureID);
   LLtoFeatureID = NULL;


   PCdone = 0.0;
   sout = fopen(scclookup,"wb");
   XindexExtent = (int) (MaxXcoord / LRegionSize) + 2;
   YindexExtent = (int) (MaxYcoord / LRegionSize) + 2;
   listlength = XindexExtent * YindexExtent;
   for(i=0; i<listlength; i++)
      {
      PCdone = ((double) i) / ((double) listlength);
      PCdone *= 25.0;

      Mc = MonsterRoot;
      while(Mc != NULL)
         {
         if(Mc->LM[i] == 1)
            SCCroot[i].inside += 1;
         Mc = Mc->next;
         }

      SEEIT_fwrite_int(&i,sout);
      SEEIT_fwrite_int(&SCCroot[i].inside,sout);

      Mc = MonsterRoot;
      while(Mc != NULL)
         {
         if(Mc->LM[i] == 1)
            SEEIT_fwrite_int(&Mc->Lindex,sout);
         Mc = Mc->next;
         }

      csl = SCCroot[i].next;
      while(csl != NULL)
         {
         if(NGA_TYPE == 1)
            BuildOpenMenu(100.0,SACfull*2,SACfull*2,linears_done, areals_done,model_polys,areals_done,linears_done,points_done,
                 sphere_cv,parallel_cv,stamps_done,footprints_done, bridges_done,g_read,g_write,
                 FMpointsdone,FMlinesdone,FMarealsdone,100.0,100.0,100.0, PCdone, 0);
         else
            BuildOpenMenu(100.0,SACfull*2,SACfull*2,polys_read, polys_done,model_polys,areals_done,linears_done,points_done,
                 sphere_cv,parallel_cv,stamps_done,footprints_done, bridges_done,g_read,g_write,
                 FMpointsdone,FMlinesdone,FMarealsdone,100.0,100.0, 100.0, PCdone, 0);
         SEEIT_fwrite_int(&csl->inside,sout);
         psl = csl;
         csl = csl->next;
         free(psl);
         }
      }
   fclose(sout);
   free(SCCroot);


   PCdone = 0.0;
   sout = fopen(fidlookup,"wb");
   for(i=0; i<listlength; i++)
      {
      PCdone = ((double) i) / ((double) listlength);
      PCdone *= 25.0;
      PCdone += 25.0;

      Mc = MonsterRoot;
      while(Mc != NULL)
         {
         if(Mc->LM[i] == 1)
            FIDroot[i].inside += 1;
         Mc = Mc->next;
         }

      SEEIT_fwrite_int(&i,sout);
      SEEIT_fwrite_int(&FIDroot[i].inside,sout);

      Mc = MonsterRoot;
      while(Mc != NULL)
         {
         if(Mc->LM[i] == 1)
            SEEIT_fwrite_int(&Mc->idn,sout);
         Mc = Mc->next;
         }

      csl = FIDroot[i].next;
      while(csl != NULL)
         {
         if(NGA_TYPE == 1)
            BuildOpenMenu(100.0,SACfull*2,SACfull*2,linears_done, areals_done,model_polys,areals_done,linears_done,points_done,
                 sphere_cv,parallel_cv,stamps_done,footprints_done, bridges_done,g_read,g_write,
                 FMpointsdone,FMlinesdone,FMarealsdone,100.0,100.0,100.0, PCdone, 0);
         else
            BuildOpenMenu(100.0,SACfull*2,SACfull*2,polys_read, polys_done,model_polys,areals_done,linears_done,points_done,
                 sphere_cv,parallel_cv,stamps_done,footprints_done, bridges_done,g_read,g_write,
                 FMpointsdone,FMlinesdone,FMarealsdone,100.0,100.0, 100.0, PCdone, 0);
         SEEIT_fwrite_int(&csl->inside,sout);
         psl = csl;
         csl = csl->next;
         free(psl);
         }
      }
   fclose(sout);
   free(FIDroot);

   Mc = MonsterRoot;
   while(Mc != NULL)
      {
      Mp = Mc;
      Mc = Mc->next;
      free(Mp->LM);
      free(Mp);
      }
   MonsterRoot = NULL;



   if(SCCdataArray != NULL)
      free(SCCdataArray);
   free(ClassData);
   free(NArray);

   
   sout = fopen(eaclookup,"wb");
   counter = 0;
   SEEIT_fwrite_int(&AttrIndex,sout);
   MainList = AListRoot;
   PCdone = 50.0;
   while(MainList != NULL)
    {
    ML2 = MainList;
    MainList = MainList->next;
    SubList = ML2->values;

    SEEIT_fwrite_double(&ML2->occurrences,sout);
    SEEIT_fwrite_int(&ML2->code,sout);
    SEEIT_fwrite_int(&ML2->count,sout);
    while(SubList != NULL)
       {
       SL2 = SubList;
       SEEIT_fwrite_double(&SL2->occurrences,sout);
       /**SEEIT_fwrite_int(&SL2->uniqueoccurrences,sout); **/
       SEEIT_fwrite_double(&SL2->UniqueCounts,sout);
       SEEIT_fwrite_int(&SL2->type,sout);
       SEEIT_fwrite_int(&SL2->uom,sout);
       if(ML2->stringdigits > 0)
          {
          SL2->scale = 0;
          }
       SEEIT_fwrite_int(&SL2->scale,sout);
       SEEIT_fwrite_double(&SL2->value,sout);
       if(SL2->type == 2)
          {
          i = (int) SL2->value;
          fwrite(&SL2->label[0],1,i,sout);
          }
       if((SL2->type == 5) || (SL2->type == 6) || (SL2->type == 7))
          {
          SEEIT_fwrite_double(&SL2->value2,sout);
          SEEIT_fwrite_int(&SL2->intervaltype,sout);
          }
       SEEIT_fwrite_int(&SL2->LLindexcount,sout);

       RL1 = SL2->LongListIndices;
       while(RL1 != NULL)
          {
          RL2 = RL1;
          SEEIT_fwrite_int(&RL2->index,sout);
          RL1 = RL1->next;
          free(RL2); 
          }
       SubList = SubList->next;
       if(SL2->label != NULL)
          free(SL2->label);
       RL1 = SL2->references;
       while(RL1 != NULL)
          {
          RL2 = RL1;
          RL1 = RL1->next;
          free(RL2);
          }
       SEEIT_fwrite_int(&SL2->UniqueLLindexcount,sout);
       RL1 = SL2->UniqueLLindices;
       while(RL1 != NULL)
          {
          RL2 = RL1;
          SEEIT_fwrite_int(&RL2->index,sout);
          RL1 = RL1->next;
          free(RL2);
          }
       free(SL2);
      if(NGA_TYPE == 1)
         BuildOpenMenu(100.0,SACfull*2,SACfull*2,linears_done, areals_done,model_polys,areals_done,linears_done,points_done,
              sphere_cv,parallel_cv,stamps_done,footprints_done, bridges_done,g_read,g_write,
              FMpointsdone,FMlinesdone,FMarealsdone,100.0,100.0,100.0,PCdone, 0);
      else
         BuildOpenMenu(100.0,SACfull*2,SACfull*2,polys_read, polys_done,model_polys,areals_done,linears_done,points_done,
              sphere_cv,parallel_cv,stamps_done,footprints_done, bridges_done,g_read,g_write,
              FMpointsdone,FMlinesdone,FMarealsdone,100.0,100.0, 100.0,PCdone, 0);
       }
    RL1 = ML2->references;
    while(RL1 != NULL)
       {
       RL2 = RL1;
       RL1 = RL1->next;
       free(RL2);
       }
    free(ML2);
    PCdone = ((double) counter) / ((double) AttrIndex);
    PCdone *= 50.0;
    PCdone += 50.0;
   if(NGA_TYPE == 1)
      BuildOpenMenu(100.0,SACfull*2,SACfull*2,linears_done, areals_done,model_polys,areals_done,linears_done,points_done,
              sphere_cv,parallel_cv,stamps_done,footprints_done, bridges_done,g_read,g_write,
              FMpointsdone,FMlinesdone,FMarealsdone,100.0,100.0,100.0,PCdone, 0);
   else
      BuildOpenMenu(100.0,SACfull*2,SACfull*2,polys_read, polys_done,model_polys,areals_done,linears_done,points_done,
              sphere_cv,parallel_cv,stamps_done,footprints_done, bridges_done,g_read,g_write,
              FMpointsdone,FMlinesdone,FMarealsdone,100.0,100.0, 100.0,PCdone, 0);
    ++counter;
    }
   fclose(sout);

   sout = fopen(LLfrequency,"wb");
   for(Si=0; Si<SACfull; Si++)
      {
      if(NGA_TYPE == 1)
         BuildOpenMenu(100.0,SACfull*2,SACfull*2,linears_done, areals_done,model_polys,areals_done,linears_done,points_done,
              sphere_cv,parallel_cv,stamps_done,footprints_done, bridges_done,g_read,g_write,
              FMpointsdone,FMlinesdone,FMarealsdone,100.0,100.0,100.0,100.0, 0);
      else
         BuildOpenMenu(100.0,SACfull*2,SACfull*2,polys_read, polys_done,model_polys,areals_done,linears_done,points_done,
              sphere_cv,parallel_cv,stamps_done,footprints_done, bridges_done,g_read,g_write,
              FMpointsdone,FMlinesdone,FMarealsdone,100.0,100.0, 100.0,100.0, 0);
      SEEIT_fwrite_int(&Si,sout);
      SEEIT_fwrite_int(&LongListInstances[Si],sout);
      SEEIT_fwrite_int(&LongToShortMap[Si],sout);
      }
   fclose(sout);

   free(LongToShortMap);

   free(LongListInstances);
   free(LongListBadUID);
   free(LongListBadUIDcount); 


   for(i=0; i<NumNames; i++)
      {
      NAC1 = NameAttrCross[i].next;
      while(NAC1 != NULL)
         {
         NAC2 = NAC1;
         NAC1 = NAC1->next;
         free(NAC2);
         }
      }
   free(NameAttrCross);

   ReleaseFileNames(1);

   printf("Format Operations Complete!\n");

   if(NGA_TYPE == 1)
      BuildOpenMenu(AttrPCdone,SACfull*2,SACfull*2,linears_done, areals_done,model_polys,areals_done,linears_done,points_done,
        sphere_cv,parallel_cv,stamps_done,footprints_done, bridges_done,g_read,g_write,
        FMpointsdone,FMlinesdone,FMarealsdone,1.0, 1.0,  1.0, 1.0,1);
   else
      BuildOpenMenu(AttrPCdone,SACfull*2,SACfull*2,polys_read, polys_done,model_polys,areals_done,linears_done,points_done,
        sphere_cv,parallel_cv,stamps_done,footprints_done, bridges_done,g_read,g_write,
        FMpointsdone,FMlinesdone,FMarealsdone,1.0, 1.0,  1.0, 1.0,1);


}

