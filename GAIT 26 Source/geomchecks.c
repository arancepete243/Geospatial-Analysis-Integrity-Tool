/************
GAIT (Geospatial Analysis Integrity Tool) is a geospatial data validation tool developed by the Institute for Defense Analyses (IDA) for the National Geospatial-Intelligence Agency (NGA).  

This source code was used to generate GAIT 26 executable software in accordance with Amendment 6 to Task Order DH-8-3815 under Contract HQ0034-14-D-0001.

IDA is furnishing this item "as is". IDA was not tasked or funded to generate developer documentation or to provide support for this source code. IDA does not provide any warranty of the item whatsoever, whether express, implied, or statutory, including, but not limited to, any warranty of fitness for a particular purpose or any warranty that the contents of the item will be error-free. In no event shall NGA or IDA be held liable for damages arising, directly or indirectly, from the use of this source code. 

This material may be reproduced by the U.S. Government pursuant to its unlimited use rights under DFARS 252.227-7014 [Feb 2014].

The Institute for Defense Analyses (IDA) is a Federally Funded Research and Development Center that provides scientific and technical expertise on issues important to national security to the Office of the Secretary of Defense, Joint Staff, Unified Commands, and Defense Agencies. 

© 2017 Institute for Defense Analyses
  4850 Mark Center Drive
  Alexandria, Virginia 22311-1882
  703.845-2000
  www.ida.org
************/


#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <string.h>
#include <time.h>

#include "share.h"
#include "TTshare.h"



#ifndef DATA_TYPE
#define DATA_TYPE void *
#endif
#ifdef DMALLOC
#include <dmalloc.h>
#endif

#define DEBUG_ASSERT 0

/*** type definitions ****/

extern struct PointAndID *PIroot, *pic, *pic2, *LAINTroot, *LSLICEroot;
extern struct AttributionErrors *AttrErr; /** array of text messages on attribution errors **/
extern struct MoreAttrErrIndices *MAEc, *MAEn;
extern struct SCCdata * SCCtable;
extern struct ObjectLookup * ArealTable;
extern struct ObjectLookup * LinearTable;
extern struct ObjectLookup * PointTable;
extern struct InputFiles *ArealFiles;
extern struct InputFiles *LinearFiles;
extern struct RawLinear *TgtLroot;
extern struct ArealAsRead ArealFromFile;
extern struct RawAreal *TgtAroot;
extern struct PointAsRead PointFromFile;
extern struct RawPoint *TgtProot;
extern struct LinearAsRead LinearFromFile;
extern struct ErrorTable ErrorLookup[]; /** var declared and storage allocated in errors.c **/
extern struct CloneErrorTable *CloneErrorLookup;  /** declared in errors.c **/
extern struct LindexLookup * LindexTable;
extern struct LindexLookup * FIDindexTable;
extern struct CrossWalk  *CrsWlk;
extern struct CombinedChecks *ActiveChecks;  /*** should be an array of size CONDITION_DEFINITIONS + CLONE_DEFINITIONS ***/
extern struct PairsCheckedEntry *AreaPairRoot, *LinePairRoot;
extern struct PairsChecked *LPc, *LPp, *LPn, *APc, *APp, *APn;
extern struct pairedwith *PWc, *PWn, *PWp;
extern rb_red_blk_tree * Check_RB_Tree;
extern rb_red_blk_node * RB_newNode;
extern struct ListOfArealEdges *LAEroot, *LAEc, *LAEn, *LAEp, *KnownRoot, *ProcessRoot, *EdgeAddRoot, *LAEadded, *LAEadded2;
extern struct CondToCollect *CTCroot, *CTCc, *CTCp;



extern int NumAttrErr;
extern int NumberOfGrids;
extern int GridFileInUse;
extern int GridNowLoaded;
extern int LoadedGridRows;
extern int LoadedGridCols;
extern int LoadedGridMres;
extern int IgnoreDrawingSettings;
extern int SzLAE;
extern char MessageLine[500];
extern char BndAttrMismatch[500];
extern char indirectory[500];
extern char outdirectory[500];
extern int TtlActiveChecks;
extern double Xtranslation ;
extern double Ytranslation ;
extern double MinXcoord;
extern double MaxXcoord;
extern double MinYcoord;
extern double MaxYcoord;
extern int MinXindex;
extern int MaxXindex;
extern int MinYindex;
extern int MaxYindex;
extern double LAEminx,LAEminy,LAEmaxx,LAEmaxy;
extern double CF_LAEminx,CF_LAEminy,CF_LAEmaxx,CF_LAEmaxy;
extern double PI;
extern double HalfPI;
extern double DistTolerance, SqDistTolerance;
extern double PTL_Dist_Xi, PTL_Dist_Yi;

extern int UseNUNANPO;
extern char * linearsin;
extern char * arealsin;
extern int SzD;
extern int SzI;
extern int AbsoluteAccuracy;
extern int SignificantDecimals;
extern int NeedIntersectingArealCalc;
extern int NeedSliverGuide;
extern int NeedAreaCalculation;
extern int SACfull;
extern int OSIDE_LatLon_Count;
extern int OSIDE_LL_Limit;
extern double RegionSize;
extern int RB_newKey;
extern double RB_newKey2;
extern int * RB_newInt;
extern double * RB_newDbl;
extern int CLAMPFEATURES;
extern int * Areal1ForIntersections;
extern int * Areal2ForIntersections;
extern int * Areal1Shared;
extern int * Areal2Shared;
extern int TtlCoverFailures;
extern double MinSurfXcoord;
extern double MaxSurfXcoord;
extern double MinSurfYcoord;
extern double MaxSurfYcoord;
extern struct GlobalGridInfo *GridHeader;
extern struct NewGridLookup * NGT;
extern struct MultiGrids *MG;



extern struct CodesAndValue * GetAttrCodesAndValues(int Lindex, int idn, FILE * fileptr, int SzCV, int SzCVl, int DiscardLengthAttr);
extern int AddToSameAttrAndVals(char geom, int ECC, struct CodesAndValue * CV1, struct CodesAndValue * CV2);
extern FILE * OpenGridFile(int index);
extern rb_red_blk_node* RBExactQuery(rb_red_blk_tree*, void*);
extern struct RawAreal * FindEdgeClosestToPoint(double px, double py,struct RawAreal * Aroot, struct RawAreal * Neighbors, struct RawAreal *tgt, int *answer);

extern void FwriteMsgMagPointObjects(int keyval, int Cnumber, char *msg, double magnitude, double pointX, double pointY, double pointZ,
                                  int index1, char gform1, int Lindex1, double localid1, int IDN1, double radius1, double height1,
                                  double *x1, double *y1, double *z1, int numverts1,
                                  int index2, char gform2, int Lindex2, double localid2, int IDN2, double radius2, double height2,
                                  double *x2, double *y2, double *z2, int numverts2);
extern void FwriteObject(int keyval, int Cnumber,
             int Lindex, int index, char gform, double LocalID, int IDN, double radius, double height,
             double *x, double *y, double *z, int numverts, int DrawNow);
extern void FwriteTreeInorder(rb_red_blk_tree* tree, rb_red_blk_node* x);
extern void FwriteMagnitudeAndTwoObjects(int keyval, int Cnumber, double magnitude,
                        int index1, char gform1, int Lindex1, double LocalID1, int IDN1, double radius1, double height1,
                        double *x1, double *y1, double *z1, int numverts1,
                        int index2, char gform2, int Lindex2, double LocalID2, int IDN2, double radius2, double height2,
                        double *x2, double *y2, double *z2, int numverts2);
extern void FwritePointAndObject(int keyval, int Cnumber, double pointX, double pointY, double pointZ, int pointIDN,
                                  int index1, char gform1, int Lindex, double localid, int IDN1, double radius1, double height1,
                                  double *x1, double *y1, double *z1, int numverts1);
extern void FwritePointAndTwoObjects(int keyval, int Cnumber, double pointX, double pointY, double pointZ,
                                  int index1, char gform1, int Lindex1, double localid1, int IDN1, double radius1, double height1,
                                  double *x1, double *y1, double *z1, int numverts1,
                                  int index2, char gform2, int Lindex2, double localid2, int IDN2, double radius2, double height2,
                                  double *x2, double *y2, double *z2, int numverts2);
extern void FwriteTwoObjects(int keyval, int Cnumber,
                  int IDN1, char gform1, int Lindex1, double localid1, int index1, double radius1, double height1,
                  int numverts1, double *x1, double *y1,  double *z1,
                  int IDN2, char gform2, int Lindex2, double localid2, int index2, double radius2, double height2,
                  int numverts2, double *x2, double *y2,  double *z2);
extern void FwriteObjectAndMessage(int keyval, int Cnumber,
                            int IDN, char gform, int Lindex, double localid, int index, double radius, double height,
                            double *x, double *y, double *z, int numverts, char *msg);
extern void FwriteObjectAndMagnitude(int keyval, int Cnumber, int IDN,
                             int index, char gform, int Lindex, double localid,  double radius, double height,
                             double magnitude, double *x, double *y, double *z, int numverts, int DrawNow);
extern void FwritePointEdgeAndMagnitude(int keyval, int Cnumber,  double magnitude, int IDN1, char gform1,
                                 int Lindex1, double localid1,
                                 int index1, double px, double py, double pz, int index2, int IDN2, char gform2,
                                 int Lindex2, double localid2,
                                 double ex1, double ey1, double ez1, double ex2, double ey2, double ez2,
                                 double *x, double *y, double *z);
extern void FwritePointObjectAndMagnitude(int keyval, int Cnumber,  double magnitude, int IDN1, char gform1,
                                 int Lindex1, double localid1,
                                 int index1, double px, double py, double pz, int index2, int IDN2, char gform2,
                                 int Lindex2, double localid2, int numverts, double *x, double *y, double *z);
extern void FwriteDynamicInfo(int keyval, int Cnumber, int PtUsed, int MagUsed, int NumObjects,
                                  char *msg, double magnitude, double pointX, double pointY, double pointZ,
                                  int index1, char gform1, int Lindex1, double localid1, int IDN1,
                                  double radius1, double height1,
                                  double *x1, double *y1, double *z1, int numverts1,
                                  int index2, char gform2, int Lindex2, double localid2, int IDN2,
                                  double radius2, double height2,
                                  double *x2, double *y2, double *z2, int numverts2);
extern double FindRelevantSensitivity(int checktype, int checknum, double *sensitivity2);
extern int FindSpecificSensitivity(int number, int checktype, int checknum, double *answer);
extern int CombinedCheckApplies(int IDlookupkey, int Instance, int TgtCheckType, int LongListIndx, int ShortListIndx,
                         int config, int stratum, int domain, int *p1, int *p2, int *p3);
extern int GetNextArealIndex(struct RawAreal *a, int lastusedindex, int firstuse, struct RB_Edgelist ** RE, int cindex, int *UsedTree);
extern double TurnAngle(double x1,double y1,double x2,double y2,double x3,double y3);
extern int ClipLineToRegion(double lx, double ly, double ux, double uy,
     double *x1, double *y1, double *z1, double *x2, double *y2, double *z2, unsigned char *cflag, double decimalplaces);
extern int MatchLinearSegment2D(double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4,
                         double *matchlen, double tolerance);
extern int MatchAndModifyLinearSegment(double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4,
                         double *matchlen, double *xa1, double *ya1, double *xa2, double *ya2,
                             int *on0, int *on1, int *on2, int *on3, double tolerance);
extern int Make_Correct(int keyval, int socalledinstance);
extern double PointToSmallArealDist2D(double px,double py,struct RawAreal *A, int *index, double *T);
extern double PointToLargeArealDist2D(double px,double py,struct RawAreal *A, int *index, double *T);
extern int SensitivityCheck(int GT_LT_EQ, int checktype, int checknum, double checkvalue);
extern double SquaredDistance_GAITcoords(double x1,double y1,double x2,double y2);
extern double PointToLineDist2DwithFlag(double xj,double yj,double xk,double yk,double xl,double yl, double *T);
extern int PointIsVertex(double px,double py,double *x,double *y,double *z,int vtxcnt,double *elev);
extern int PointOnEdge(double px,double py,double *x,double *y,double *z,int vtxcnt,double *elev,int *index);
extern int PointIsInside(double px,double py,double *x,double *y,double *z,int vtxcnt, unsigned char config, double *elev);
extern int PointIsLargeArealVertex(double px,double py, struct RawAreal *A, double *elev);
extern int PointOnLargeArealEdge(double px,double py,struct RawAreal *A,double *elev,int *index);
extern int PointInsideLargeAreal(double px, double py, struct RawAreal * A, int *OnEdge);
extern int LineSegmentsConnect(double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4, double Slack);
extern int LineSegmentsIntersect(double xl,double yl,double xk,double yk,double xm,double ym,double xn,double yn,double * xi,double * yi);
extern int MergeSeg_LineSegmentsOverlap(double xl,double yl,double xk,double yk, /***double Alk, double Blk, double Clk, ****/
                        double xm,double ym,double xn,double yn,double x1min, double x1max, double y1min, double y1max,
                        double * xi1,double * yi1,double * xi2,double * yi2, double tolerance);
extern int LineSegmentsOverlap(double xl,double yl,double xk,double yk,double xm,double ym,double xn,double yn,
                        double * xi1,double * yi1,double * xi2,double * yi2, double tolerance);
extern int PointWithinToleranceOfVertex(double px,double py,double *x,double *y,double *z,int vtxcnt,double *elev, double tolerance);
extern int PointWithinToleranceOfEdge(double px,double py,double *x,double *y,double *z,int vtxcnt,double *elev,int *index, double tolerance);
extern double PointToArealEdgeDist2D(double xp,double yp,struct RawAreal *Aroot, int *Index);
extern int PointWithinToleranceOfLargeArealVertex(double px,double py, struct RawAreal *A, double *elev,double tolerance);
extern int PointWithinToleranceOfLargeArealEdge(double px,double py,struct RawAreal *A,double *elev,int *index,double tolerance);
extern int ReadLinearFromFile(FILE * linearfile, double decimalplaces);
extern int ReadPointFromFile(FILE * pointfile, double decimalplaces);
extern int ReadArealFromFile(FILE * arealfile, double decimalplaces);
extern int ReadGridFromFile(int Gindex,FILE * gridfile, double decimalplaces, int index, int NGrids, int *Mcols, int *Mres);
extern void CloseGridFile(FILE * gridfile);
extern int IsSentinelZvalue(double v, int CountNUNANPOvaluesAs2D);
extern int TwoLinesIntersect(struct RawLinear *l1, int l1index, struct RawLinear *l2);
extern int LimitedTwoLinesIntersect(struct RawLinear *l1, int l1index, struct RawLinear *l2);
extern int PointInsidePoly(double px,double py,double * x,double * y,int numb);
extern double XCoordToProjectCoord(double x);
extern double YCoordToProjectCoord(double y);
extern double SegmentToSmallArealDist2D(double lx1, double ly1, double lx2, double ly2,
                                 double minx,double miny,double maxx,double maxy,struct RawAreal *A, int *Aindex1, int *Aindex2);
extern double SegmentToLargeArealDist2D(double lx1, double ly1, double lx2, double ly2,
                                 double minx,double miny,double maxx,double maxy,struct RawAreal *A, int *Aindex1, int *Aindex2);
extern double AvgSegmentToSmallArealDist2D(double lx1, double ly1, double lx2, double ly2,
                                 double minx,double miny,double maxx,double maxy,struct RawAreal *A, int *Aindex1, int *Aindex2);
extern double AvgSegmentToLargeArealDist2D(double lx1, double ly1, double lx2, double ly2,
                                 double minx,double miny,double maxx,double maxy,struct RawAreal *A, int *Aindex1, int *Aindex2);
extern int SegmentsOffsetOverlap(double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4);
extern double AvgSegmentToLineDist2D(double tgtslope, double lx1, double ly1, double lx2, double ly2,
                                 double minx,double miny,double maxx,double maxy,struct RawLinear *L, int *Lindex1, int *Lindex2);
extern double RadiansToDegrees(double radianmeasure);
extern unsigned char AssignDrawingColor(int fid, unsigned char D, int crsindex);
extern double ApproxPointToLineDist2D(double xj,double yj,double xk,double yk,double xl,double yl);
extern int RemoveByContainmentOrCoincidence(double px, double py, struct RawLinear *Lroot, int checkinstance, int check,
    double minx,double miny,double maxx,double maxy, double tolerance,
    struct RawAreal *Aroot, struct RawPoint *Proot);
extern double Line_SmallArealAngle(double px,double py, double ex, double ey, struct RawAreal *A, int *Aindex);
extern double Line_LargeArealAngle(double px,double py,double ex, double ey, struct RawAreal *A, int *Aindex);
extern double PointToLineDist2D(double xj,double yj,double xk,double yk,double xl,double yl);
extern int PointInsideTriangle(double x,double y,double x1,double y1,double x2,double y2,double x3,double y3);
extern rb_red_blk_node * RBTreeInsert(rb_red_blk_tree* tree, void* key, void* info);
extern int StrictlyBetween(double x,double y,double x1,double y1,double x2,double y2);
extern int Between(double x,double y,double x1,double y1,double x2,double y2);
extern int EqualWithinTolerance(double x1, double y1, double x2, double y2,double tolerance);
extern void CountConnectingNodeInts(int ECC, int NodePresent);
extern int NearlyEqual(double v1, double v2);
extern double PointToLineDist(double xp, double yp, double zp, double xl1, double yl1, double zl1, double xl2, double yl2, double zl2);
extern void FindAzimuthInteriorPoint(double xb,double yb,double xe,double ye,
   double tdist,double dist,double *px,double *py);
extern int PointOnQuarterDegreeBoundary(double px, double py, double tolerance);
extern int SameAttrAndVals(struct CodesAndValue * CV1, struct CodesAndValue * CV2, int MetaDataCounts);
extern void RBDelete(rb_red_blk_tree* tree, rb_red_blk_node* z);
extern void LineEquation(double x1,double y1,double x2,double y2,double * A,double * B,double * C);
extern void ImplicitLineToParametric(double A, double B, double C, double *X0, double *Y0, double *F, double *G);
extern int LineCircleIntersection(double XJ,double YJ,double RJ,double X0,double Y0,double F,double G,
          double  *X1,double *Y1,double *X2,double *Y2);
extern double FindXatYonSegment(double newy, double x1, double y1, double x2, double y2);
extern int PointIsAlmostVertex(double px,double py,double *x,double *y,double *z,int vtxcnt,double *elev);
extern int PointIsAlmostLargeArealVertex(double px,double py, struct RawAreal *A, double *elev);
extern int CheapLineSegmentsConnect(double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4, double Sl);
extern double FindMaxSensitivities(int checktype, double *sensitivity2);
extern int PointInAreal(double px,double py,double * x,double * y,int numverts, int *OnEdge);
extern double PointToArealDist2D(double xp,double yp,struct RawAreal *Aroot);
extern double AngleBetweenLineSegments(double lx1,double ly1,double lx2,double ly2,double x1,double y1,double x2,double y2);
extern void FreeLinearsList(struct RawLinear *root);
extern double RoundToNearestPartialDegree(int XorY, double ActualCoord, double increment);
extern double PointToFullLineDist2D(double px, double py, double lx1, double ly1, double lx2, double ly2);
extern int ThreePointsAreColinear(double *x, double *y, double *z);
extern int Get_LOC_AttrValues(int Lindex, int idn, FILE * fileptr, int * LOCvalue);

extern double FindAcuteAngleBetweenSegments(double x1, double y1, double x2, double y2,
                                           double x3, double y3, double x4, double y4);
extern char * FindCONFLATEsourceFile(int localid, int * entry);
extern int CalculateSliverRating(double *x,double *y,double *z,int vtxcnt,double *width,double *height, double *ratio);
extern int IntersectAcrossConnectingNode(double x1, double y1, double x2, double y2, double x3, double y3,
                double x4, double y4, double x5, double y5, double x6, double y6);
extern int AllCaseLineSegmentsIntersect(double x1, double y1, double x2, double y2,
                               double x3, double y3, double x4, double y4, double tolerance, double *xi, double *yi);
extern int ReCheckAtJoin(struct RawLinear *root, int Check, int checkinstance,struct RawLinear *rlc,
             int ii,int i,struct RawLinear *rln,int jj2,int jj,int j);
extern int TwoPointsOnSameSideOfLine(double px1, double py1, double px2, double py2,
        double lx1, double ly1, double lx2, double ly2);


int EdgesIntersectAtVertex(double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4);
int LineSegmentIntersectsLargeAreal(int tgtindex, double x1, double y1, double x2, double y2,
             struct RawAreal * A, int *OnEdge, double *xi, double *yi, int MallocSize);
void CreatePointInsideAreal(struct RawAreal *A, double *px, double *py);
int EdgesOverlap(double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4,
                     double *cx1, double *cy1, double *cx2, double *cy2, int *bothmatch, double ptltolerance);
int Line_ILA_WithTolerance(struct RawLinear *inside, struct RawAreal *outside,double tolerance);


void CalculateMidPoint(double x1, double y1, double x2, double y2, double *mx, double *my)
{

   *mx = x1 + ((x2 - x1) / 2.0);
   *my = y1 + ((y2 - y1) / 2.0);
}






int TwoPointsOnSameSideOfLineSegment(double px1, double py1, double px2, double py2,
                                        double lx1, double ly1, double lx2, double ly2)
{
int answer = 0; /*** return 1 if both points on same side of infinite line defined by segment ****/
double r1, r2;

r1 = ((px1 - lx1) * (ly2 - ly1)) - ((py1 - ly1) * (lx2 - lx1));
r2 = ((px2 - lx1) * (ly2 - ly1)) - ((py2 - ly1) * (lx2 - lx1));

   if((r1 < 0) && (r2 < 0))
      answer = 1;
   else if((r1 > 0) && (r2 > 0))
      answer = 1;

   return(answer);
}


int AllOnSameSideOfLine(double px1, double py1, double px2, double py2,double px3, double py3,
                          double lx1, double ly1, double lx2, double ly2)
{
double A, B, C;
double tx, ty, sx1, sy1, sx2, sy2, sx3, sy3;
int answer = 0;

   LineEquation(lx1,ly1,lx2,ly2,&A, &B, &C);
   tx = lx1 - lx2;
   if(tx < 0)
      tx = 0 - tx;
   ty = ly1 - ly2;
   if(ty < 0)
      ty = 0 - ty;

   if(tx > ty) /** change in x > change in y, so a more horizontal line ***/
      {
      sy1 = ((A*px1) + C) / B;
      sy1 =  0 - sy1;
      sy2 = ((A * px2) + C) / B;
      sy2 = 0 - sy2;
      sy3 = ((A * px3) + C) / B;
      sy3 = 0 - sy3;
      if((sy1 > py1) && (sy2 > py2) && (sy3 > py3))
         {
         sy2 = sy2 - py2;
         sy1 = sy1 - py1;
         sy3 = sy3 - py3;
         if((sy2 <= sy1) && (sy2 <= sy3))
            answer = 1;
         }
      else if((sy1 < py1) && (sy2 < py2) && (sy3 < py3))
         {
         sy2 = py2 - sy2;
         sy1 = py1 - sy1;
         sy3 = py3 - sy3;
         if((sy2 <= sy1) && (sy2 <= sy3))
            answer = 1;
         }
      }
   else
      {
      sx1 = ((B*py1) + C) / A;
      sx1 = 0 - sx1;
      sx2 = ((B*py2) + C) / A;
      sx2 = 0 - sx2;
      sx3 = ((B*py3) + C) / A;
      sx3 = 0 - sx3;
      if((sx1 > px1) && (sx2 > px2) && (sx3 > px3))
         {
         sx2 = sx2 - px2;
         sx1 = sx1 - px1;
         sx3 = sx3 - px3;
         if((sx2 <= sx1) && (sx2 <= sx3))
            answer = 1;
         }
      else if((sx1 < px1) && (sx2 < px2) && (sx3 < px3))
         {
         sx2 = px2 - sx2;
         sx1 = px1 - sx1;
         sx3 = px3 - sx3;
         if((sx2 <= sx1) && (sx2 <= sx3))
         answer = 1;
         }
      }

   return(answer);
}


int OnlyTwoOnSameSideOfLine(double px1, double py1, double px2, double py2,double px3, double py3,
                          double lx1, double ly1, double lx2, double ly2)
{
double A, B, C;
double tx, ty, sx1, sy1, sx2, sy2, sx3, sy3;
int answer = 0;


   LineEquation(lx1,ly1,lx2,ly2,&A, &B, &C);
   tx = lx1 - lx2;
   if(tx < 0)
      tx = 0 - tx;
   ty = ly1 - ly2;
   if(ty < 0)
      ty = 0 - ty;

   if(tx > ty) /** change in x > change in y, so a more horizontal line ***/
      {
      sy1 = ((A*px1) + C) / B;
      sy1 =  0 - sy1;
      sy2 = ((A * px2) + C) / B;
      sy2 = 0 - sy2;
      sy3 = ((A * px3) + C) / B;
      sy3 = 0 - sy3;
      if(NearlyEqual(sy1,py1) > 0)
         sy1 = py1;
      if(NearlyEqual(sy3,py3) > 0)
         sy3 = py3;
      if((sy1 >= py1) && (sy2 < py2) && (sy3 >= py3))
         {
         answer = 1;
         }
      else if((sy1 <= py1) && (sy2 > py2) && (sy3 <= py3))
         {
         answer = 1;
         }
      }
   else
      {
      sx1 = ((B*py1) + C) / A;
      sx1 = 0 - sx1;
      sx2 = ((B*py2) + C) / A;
      sx2 = 0 - sx2;
      sx3 = ((B*py3) + C) / A;
      sx3 = 0 - sx3;
      if(NearlyEqual(sx1,px1) > 0)
         sx1 = px1;
      if(NearlyEqual(sx3,px3) > 0)
         sx3 = px3;
      if((sx1 >= px1) && (sx2 < px2) && (sx3 >= px3))
         {
         answer = 1;
         }
      else if((sx1 <= px1) && (sx2 > px2) && (sx3 <= px3))
         {
         answer = 1;
         }
      }

   return(answer);
}






double AngleWithYaxis(double x1, double y1, double x2, double y2)
{
double rise, run;
double answer;

   if(x1 == x2)
      return(0.0);
   else
      {
      rise = x1 - x2;
      if(rise < 0)
         rise = 0 - rise;
      }
   if(y1 == y2)
      return(1.5719);
   else
      {
      run = y1 - y2;
      if(run < 0)
         run = 0 - run;
      }
   answer = atan(rise / run);
   return(answer);
}


double AngleWithXaxis(double x1, double y1, double x2, double y2)
{
double rise, run;
double answer;

   if(y1 == y2)
      return(0.0);
   else
      {
      rise = y1 - y2;
      if(rise < 0)
         rise = 0 - rise;
      }
   if(x1 == x2)
      return(1.5719);
   else
      {
      run = x1 - x2;
      if(run < 0)
         run = 0 - run;
      }
   answer = atan(rise / run);
   return(answer);
}






int ConditionOnDataEdge(double testx1, double testy1, double testx2, double testy2,
                    struct RawAreal *Aroot, struct RawPoint *Proot, struct RawLinear *Lroot,
                    struct RawAreal *ThisA, struct RawPoint *ThisP, struct RawLinear *ThisL,
                    int Ncount, int Scount, int Ecount, int Wcount, int checkinstance)
{
/*** if return answer > 0, will keep the condition, saying is not on the data edge ***/
int answer = 1;
int Nanswer, Sanswer, Wanswer, Eanswer;
struct RawAreal *rac;
struct RawPoint *rpc;
struct RawLinear *rlc;
double testpt,px,py, testhere,testangle;
int i, j, continue_test;
double AngleThreshold, testptbuffer;


   if(ActiveChecks[checkinstance].UseBorderConds != 0)
      return(1);

   AngleThreshold = 45.0; /*** this is in degrees  ***/
   AngleThreshold = AngleThreshold / OneRadianInDegrees;  /*** convert to degrees to match function return ***/
   testptbuffer = 0.1;

   continue_test = 1;
   Nanswer = Sanswer = Wanswer = Eanswer = 0;

   if(Ncount <= 0) /** does any data exist north of testy? ***/
      {
      if(testy1 > testy2)
         {
         testpt = testy1;
         px = testx1;
         py = testy1;
         }
      else
         {
         testpt = testy2;
         px = testx2;
         py = testy2;
         }
      testpt += testptbuffer;

      rlc = Lroot;
      while((rlc != NULL) && (Nanswer == 0))
         {
         if(rlc != ThisL)
            {
            for(i = 0; i<rlc->numnodes; i++)
               {
               if(rlc->y[i] > testpt)
                  {
                  testangle = AngleWithXaxis(px,py, rlc->x[i],rlc->y[i]);
                  if(testangle > AngleThreshold)
                     {
                     Nanswer = 1;
                     break;
                     }
                  else
                     {
                     for(j=1; j<rlc->numnodes; j++)
                        {
                        if(((rlc->x[j-1] <= px) && (rlc->x[j] >= px)) || ((rlc->x[j-1] >= px) && (rlc->x[j] <= px)))
                           {
                           testhere =  FindXatYonSegment(px,rlc->y[j-1],rlc->x[j-1],rlc->y[j],rlc->x[j]);
                           testhere -= 0.1;
                           if(testhere > py)
                              {
                              Nanswer = 1;
                              break;
                              }
                           }
                        }
                     }
                  if(Nanswer > 0)
                     break;
                  }
               if(Nanswer > 0)
                  break;
               }
            }
         rlc = rlc->next;
         }

      rac = Aroot;
      while((rac != NULL) && (Nanswer == 0))
         {
         if(rac != ThisA)
            {
            for(i=0; i<rac->numverts; i++)
               {
               if(rac->y[i] > testpt)
                  {
                  testangle = AngleWithXaxis(px,py, rac->x[i],rac->y[i]);
                  if(testangle > AngleThreshold)
                     {
                     Nanswer = 1;
                     break;
                     }
                  else
                     {
                     for(j=1; j<rac->numverts; j++)
                        {
                        if(((rac->x[j-1] <= px) && (rac->x[j] >= px)) || ((rac->x[j-1] >= px) && (rac->x[j] <= px)))
                           {
                           testhere =  FindXatYonSegment(px,rac->y[j-1],rac->x[j-1],rac->y[j],rac->x[j]);
                           testhere -= 0.1;
                           if(testhere > py)
                              {
                              Nanswer = 1;
                              break;
                              }
                           }
                        }
                     }
                  if(Nanswer > 0)
                     break;
                  }
               if(Nanswer > 0)
                  break;
               }
            }
         rac = rac->next;
         }

      rpc = Proot;
      while((rpc != NULL) && (Nanswer == 0))
         {
         if(rpc != ThisP)
            {
            if(rpc->y[0] > testpt)
               {
               testangle = AngleWithXaxis(px,py, rpc->x[0],rpc->y[0]);
               if(testangle > AngleThreshold)
                  {
                  Nanswer = 1;
                  break;
                  }
               }
            }
         rpc = rpc->next;
         }

      if(Nanswer == 0)/*** found there is nothing to the north, so no need to test further ***/
         continue_test = 0;
      }


   if((continue_test > 0) && (Scount <= 0)) /** does any data exist south of testy? ***/
      {
      if(testy1 < testy2)
         {
         testpt = testy1;
         px = testx1;
         py = testy1;
         }
      else
         {
         testpt = testy2;
         px = testx2;
         py = testy2;
         }
      testpt -= testptbuffer;

      rlc = Lroot;
      while((rlc != NULL) && (Sanswer == 0))
         {
         if(rlc != ThisL)
            {
            for(i = 0; i<rlc->numnodes; i++)
               {
               if(rlc->y[i] < testpt)
                  {
                  testangle = AngleWithXaxis(px,py, rlc->x[i],rlc->y[i]);
                  if(testangle > AngleThreshold)
                     {
                     Sanswer = 1;
                     break;
                     }
                  else
                     {
                     for(j=1; j<rlc->numnodes; j++)
                        {
                        if(((rlc->x[j-1] <= px) && (rlc->x[j] >= px)) || ((rlc->x[j-1] >= px) && (rlc->x[j] <= px)))
                           {
                           testhere =  FindXatYonSegment(px,rlc->y[j-1],rlc->x[j-1],rlc->y[j],rlc->x[j]);
                           testhere -= 0.1;
                           if(testhere < py)
                              {
                              Sanswer = 1;
                              break;
                              }
                           }
                        }
                     }
                  if(Sanswer > 0)
                     break;
                  }
               if(Sanswer > 0)
                  break;
               }
            }
         rlc = rlc->next;
         }

      rac = Aroot;
      while((rac != NULL) && (Sanswer == 0))
         {
         if(rac != ThisA)
            {
            for(i=0; i<rac->numverts; i++)
               {
               if(rac->y[i] < testpt)
                  {
                  testangle = AngleWithXaxis(px,py, rac->x[i],rac->y[i]);
                  if(testangle > AngleThreshold)
                     {
                     Sanswer = 1;
                     break;
                     }
                  else
                     {
                     for(j=1; j<rac->numverts; j++)
                        {
                        if(((rac->x[j-1] <= px) && (rac->x[j] >= px)) || ((rac->x[j-1] >= px) && (rac->x[j] <= px)))
                           {
                           testhere =  FindXatYonSegment(px,rac->y[j-1],rac->x[j-1],rac->y[j],rac->x[j]);
                           testhere -= 0.1;
                           if(testhere < py)
                              {
                              Sanswer = 1;
                              break;
                              }
                           }
                        }
                     }
                  if(Sanswer > 0)
                     break;
                  }
               if(Sanswer > 0)
                  break;
               }
            }
         rac = rac->next;
         }

      rpc = Proot;
      while((rpc != NULL) && (Sanswer == 0))
         {
         if(rpc != ThisP)
            {
            if(rpc->y[0] < testpt)
               {
               testangle = AngleWithXaxis(px,py, rpc->x[0],rpc->y[0]);
               if(testangle > AngleThreshold)
                  {
                  Sanswer = 1;
                  break;
                  }
               }
            }
         rpc = rpc->next;
         }

      if(Sanswer == 0)/*** found there is nothing to the south, so no need to test further ***/
         continue_test = 0;
      }


   if((continue_test > 0) && (Wcount <= 0)) /** does any data exist west of testx? ***/
      {
      if(testx1 < testx2)
         {
         testpt = testx1;
         px = testx1;
         py = testy1;
         }
      else
         {
         testpt = testx2;
         px = testx2;
         py = testy2;
         }
      testpt -= testptbuffer;

      rlc = Lroot;
      while((rlc != NULL) && (Wanswer == 0))
         {
         if(rlc != ThisL)
         {
            for(i = 0; i<rlc->numnodes; i++)
               {
               if(rlc->x[i] < testpt)
                  {
                  testangle = AngleWithYaxis(px,py, rlc->x[i],rlc->y[i]);
                  if(testangle > AngleThreshold)
                     {
                     Wanswer = 1;
                     break;
                     }
                  else
                     {
                     for(j=1; j<rlc->numnodes; j++)
                        {
                        if(((rlc->y[j-1] <= py) && (rlc->y[j] >= py)) || ((rlc->y[j-1] >= py) && (rlc->y[j] <= py)))
                           {
                           testhere =  FindXatYonSegment(py,rlc->x[j-1],rlc->y[j-1],rlc->x[j],rlc->y[j]);
                           testhere -= 0.1;
                           if(testhere < px)
                              {
                              Wanswer = 1;
                              break;
                              }
                           }
                        }
                     }
                  if(Wanswer > 0)
                     break;
                  }
               if(Wanswer > 0)
                  break;
               }
            }
         rlc = rlc->next;
         }

      rac = Aroot;
      while((rac != NULL) && (Wanswer == 0))
         {
         if(rac != ThisA)
            {
            for(i=0; i<rac->numverts; i++)
               {
               if(rac->x[i] < testpt)
                  {
                  testangle = AngleWithYaxis(px,py, rac->x[i],rac->y[i]);
                  if(testangle > AngleThreshold)
                     {
                     Wanswer = 1;
                     break;
                     }
                  else
                     {
                     for(j=1; j<rac->numverts; j++)
                        {
                        if(((rac->y[j-1] <= py) && (rac->y[j] >= py)) || ((rac->y[j-1] >= py) && (rac->y[j] <= py)))
                           {
                           testhere =  FindXatYonSegment(py,rac->x[j-1],rac->y[j-1],rac->x[j],rac->y[j]);
                           testhere -= 0.1;
                           if(testhere < px)
                              {
                              Wanswer = 1;
                              break;
                              }
                           }
                        }
                     }
                  if(Wanswer > 0)
                     break;
                  }
               if(Wanswer > 0)
                  break;
               }
            }

         rac = rac->next;
         }

      rpc = Proot;
      while((rpc != NULL) && (Wanswer == 0))
         {
         if(rpc != ThisP)
            {
            if(rpc->x[0] < testpt)
               {
               testangle = AngleWithYaxis(px,py, rpc->x[0],rpc->y[0]);
               if(testangle > AngleThreshold)
                  {
                  Wanswer = 1;
                  break;
                  }
               }
            }
         rpc = rpc->next;
         }

      if(Wanswer == 0)/*** found there is nothing to the west, so no need to test further ***/
         continue_test = 0;
      }


   if((continue_test > 0) && (Ecount <= 0)) /** does any data exist east of testx? ***/
      {
      if(testx1 > testx2)
         {
         testpt = testx1;
         px = testx1;
         py = testy1;
         }
      else
         {
         testpt = testx2;
         px = testx2;
         py = testy2;
         }
      testpt += testptbuffer;

      rlc = Lroot;
      while((rlc != NULL) && (Eanswer == 0))
         {
         if(rlc != ThisL)
            {
            for(i = 0; i<rlc->numnodes; i++)
               {
               if(rlc->x[i] > testpt)
                  {
                  testangle = AngleWithYaxis(px,py, rlc->x[i],rlc->y[i]);
                  if(testangle > AngleThreshold)
                     {
                     Eanswer = 1;
                     break;
                     }
                  else
                     {
                     for(j=1; j<rlc->numnodes; j++)
                        {
                        if(((rlc->y[j-1] <= py) && (rlc->y[j] >= py)) || ((rlc->y[j-1] >= py) && (rlc->y[j] <= py)))
                           {
                           testhere =  FindXatYonSegment(py,rlc->x[j-1],rlc->y[j-1],rlc->x[j],rlc->y[j]);
                           testhere -= 0.1;
                           if(testhere > px)
                              {
                              Eanswer = 1;
                              break;
                              }
                           }
                        }
                     }
                  if(Eanswer > 0)
                     break;
                  }
               if(Eanswer > 0)
                  break;
               }
            }

         rlc = rlc->next;
         }

      rac = Aroot;
      while((rac != NULL) && (Eanswer == 0))
         {
         if(rac != ThisA)
            {
            for(i=0; i<rac->numverts; i++)
               {
               if(rac->x[i] > testpt)
                  {
                  testangle = AngleWithYaxis(px,py, rac->x[i],rac->y[i]);
                  if(testangle > AngleThreshold)
                     {
                     Eanswer = 1;
                     break;
                     }
                  else
                     {
                     for(j=1; j<rac->numverts; j++)
                        {
                        if(((rac->y[j-1] <= py) && (rac->y[j] >= py)) || ((rac->y[j-1] >= py) && (rac->y[j] <= py)))
                           {
                           testhere =  FindXatYonSegment(py,rac->x[j-1],rac->y[j-1],rac->x[j],rac->y[j]);
                           testhere -= 0.1;
                           if(testhere > px)
                              {
                              Eanswer = 1;
                              break;
                              }
                           }
                        }
                     }
                  if(Eanswer > 0)
                     break;
                  }
               if(Eanswer > 0)
                  break;
               }
            }
         rac = rac->next;
         }

      rpc = Proot;
      while((rpc != NULL) && (Eanswer == 0))
         {
         if(rpc != ThisP)
            {
            if(rpc->x[0] > testpt)
               {
               testangle = AngleWithYaxis(px,py, rpc->x[0],rpc->y[0]);
               if(testangle > AngleThreshold)
                  {
                  Eanswer = 1;
                  break;
                  }
               }
            }
         rpc = rpc->next;
         }

      }

   if((Ecount <= 0) && (Eanswer == 0))
      answer = 0;
   else if((Wcount <= 0) && (Wanswer == 0))
      answer = 0;
   else if((Scount <= 0) && (Sanswer == 0))
      answer = 0;
   else if((Ncount <= 0) && (Nanswer == 0))
      answer = 0;

   return(answer);
}




void PerformAttrEdgeMatchChecks(char * prompt, int cindex,struct RawLinear *root,double minx,double miny,double maxx,double maxy, double multiplier,
    int NorthCount, int SouthCount, int EastCount, int WestCount,
    struct RawAreal *Aroot, struct RawBridge *Broot, struct RawPoint *Proot, struct ListOfEdges *PEroot, struct ListOfEdges *VPEroot,
    struct RawLinear *NLroot, struct ThePolys * Polyroot)
{
FILE * attrfileptr;
struct RawLinear *rlc, *rln;
struct RawAreal *rac, *ran, *rap;
struct CodesAndValue *CVc, *CVn;
struct RB_Edgelist *LastEdge1, *LastEdge2, *LastEdge3;
int i,j,k, jj, jj2, kk, kk2, kk3,ii, ii2, ii3, ii4, checkinstance;
int UsedTree, LastI, LastJ, LastK, AreaIndex, on;
/**int pairedIndex;
int end1, end2, k2; ***/
int part1, part2, part3;
int direction,direction2, dir1, dir2;
int FoundCondition, checkit, checkit2;
int fndpr, on0, on1, on2, on3, unusedint;
/**int sameedge;**/
int Config1, Strat1, Domain1;
unsigned char clipflag;
double minxPadded, maxxPadded;
double minyPadded, maxyPadded;
double xinside1, yinside1, LowerTolerance, UpperTolerance;
double LenToCover, CoveredSoFar, MatchLen, ptadist1, ptpdist1, whichvertex;
double x1, y1, x2, y2, z1, z2, bx1,by1,bx2,by2,bx3,by3,bx4,by4;
double LatLonBase, LatLonIncrement, Tolerance, Tolerance3;
double xt1, yt1, xt2, yt2, z3, z4,angle,tempdbl;
double minAx, maxAx, minAy, maxAy;
double ax1,ax2,ay1,ay2;
double LocalMinX, LocalMaxX, LocalMinY, LocalMaxY;
struct collection
   {
   int keyval;
   int Cnumber;
   int numpoints;
   double px, py, pz;
   double x[4];
   double y[4];
   double z[4];
   double magnitude;
   char *errmsg;
   int IDN;
   unsigned int Sindex, Sindex2;
   int vertexindex1, vertexindex2;
   struct RawAreal *aa, *aa2;
   struct RawPoint *pp;
   struct ListOfEdges *le;
   struct RawLinear *ll1,*ll2;
   struct collection * next;
   } *ERroot, *ERc, *ERn;
int SzC = sizeof(struct collection);
int SzCV = sizeof(struct CodesAndValue);
int SzCVl = sizeof(struct CandVlist);

   ERroot = NULL;

   attrfileptr = NULL;
   sprintf(MessageLine,"%scodesfull.bin",indirectory);
   attrfileptr = fopen(MessageLine,"rb");
   if(attrfileptr == NULL)
      {
      printf("could not find required file %s\n",MessageLine);
      exit(-1);
      }


   rac = Aroot;

   while(rac != NULL)
      {
       Config1 = SCCtable[rac->Sindex].C;
       Strat1 = SCCtable[rac->Sindex].S;
       Domain1 = SCCtable[rac->Sindex].D;

       for(checkinstance = 0; checkinstance < TtlActiveChecks; checkinstance++)
          {

           if((CombinedCheckApplies(rac->idn,checkinstance,AGEOM_UNM_LAT,rac->Lindex,rac->Sindex,Config1,Strat1,Domain1,&part1,&part2,&part3) > 0) && (part1 > 0))
             {
/*** need to get the offset for use with LatLonIncrement ***/
             i = Ctype();
             if(i == 1) /** geodetic **/
                {
                LocalMinY = miny / 100000.0 + Ytranslation;
                LocalMaxY = maxy / 100000.0 + Ytranslation;
                LatLonBase = 0.0;
                LatLonIncrement = FindRelevantSensitivity(AGEOM_UNM_LAT,checkinstance,&Tolerance);
                if(FindSpecificSensitivity(3,AGEOM_UNM_LAT,checkinstance,&Tolerance3) < 1)
                   Tolerance3 = 10.0;

                k = (int) ((LocalMinY - LatLonBase) / LatLonIncrement);

                LatLonBase += (double) k * LatLonIncrement;
                if(LatLonBase < LocalMinY)
                   LatLonBase += LatLonIncrement;

                if((miny <= (MinYcoord + (LatLonIncrement * 0.5))) || (maxy >= (MaxYcoord - (LatLonIncrement * 0.5))))
                   LatLonBase = maxy * 2.0; /** effectively says check will not be applied ***/
                else if(LatLonBase <= LocalMaxY)
                   {
                   LatLonIncrement *= 100000.0;
                   LatLonBase = (LatLonBase - Ytranslation) * 100000.0;
                   LocalMinY = LatLonBase - Tolerance3;
                   LocalMaxY = LatLonBase + Tolerance3;
                   }
                else
                   {
                   LatLonBase = maxy * 2.0; /** effectively says check will not be applied ***/
                   }
                }
             else if(i == 2)
                {
                LatLonBase = maxy * 2.0; /** effectively says check will not be applied ***/
                }

             while((LatLonBase > MinYcoord) && (LatLonBase < MaxYcoord) && (LatLonBase >= miny) && (LatLonBase <= maxy))
                {
                if(rac->RB_Tree_Edgelist != NULL)
                   {
                   LastEdge1 = NULL;
                   LastI = -1;
                   i = GetNextArealIndex(rac, LastI, 1, &LastEdge1, cindex, &UsedTree);
                   LastI = i;
                   }
                else
                   i = 0;
                while(i >= 0)
                   {
                   if(i == 0)
                      ii = rac->numverts - 1;
                   else
                      ii = i - 1;
                   checkit = 0;
                   if(rac->x[i] < rac->x[ii])
                      {
                      if((rac->x[i] <= maxx) && (rac->x[ii] >= minx))
                         checkit = 1;
                      }
                   else
                      {
                      if((rac->x[ii] <= maxx) && (rac->x[i] >= minx))
                         checkit = 1;
                      }
                   if(checkit > 0)
                      {
                      if(rac->y[i] == rac->y[ii])
                         j = 1;
                      else
                         {
                         j = 0;
                         angle = AngleWithXaxis(rac->x[i],rac->y[i],rac->x[ii],rac->y[ii]);
                         if(angle <= 0.105)
                            j = 1;
                         }

                      if(j > 0)
                         {
                         if(rac->x[i] > rac->x[ii])
                            {
                            if(rac->x[ii] > maxx)
                               j = 0;
                            else if(rac->x[i] < minx)
                               j = 0;
                            }
                         else
                            {
                            if(rac->x[i] > maxx)
                               j = 0;
                            else if(rac->x[ii] < minx)
                               j = 0;
                            }
                         }

                      if((j > 0) && (rac->y[i] >= LocalMinY) && (rac->y[i] <= LocalMaxY) &&
                            (rac->y[ii] >= LocalMinY) && (rac->y[ii] <= LocalMaxY))
                         {
                         CreatePointInsideAreal(rac, &xinside1, &yinside1);
                         if(yinside1 < LatLonBase)
                            {
                            FoundCondition = -1;
                            }
                         else
                            {
                            FoundCondition = 1;
                            }
                         x1 = rac->x[ii];
                         y1 = rac->y[ii];
                         z1 = rac->z[ii];
                         x2 = rac->x[i];
                         y2 = rac->y[i];
                         z2 = rac->z[i];
                         if(ClipLineToRegion(minx,miny,maxx,maxy,&x1,&y1,&z1,&x2,&y2,&z2,&clipflag,multiplier) > 0)
                            {
                            LenToCover = Distance(x1,y1,x2,y2);
                            CoveredSoFar = 0.0;
                            }
                         else
                            {
                            LenToCover = 0.0;
                            CoveredSoFar = 1.0;
                            }

                         ran = /***Aroot; **/  rac->next; /**/
                         while((ran != NULL) && (CoveredSoFar < LenToCover))
                            {
                            fndpr = 0;
                            if((ran != rac) && (SCCtable[rac->Sindex].ECC == SCCtable[ran->Sindex].ECC))
                               {
                               CreatePointInsideAreal(ran, &xinside1, &yinside1);
                               if((yinside1 < LatLonBase) && (FoundCondition > 0))
                                  {
                                  fndpr = 1;
                                  }
                               else if((yinside1 > LatLonBase) && (FoundCondition < 0))
                                  {
                                  fndpr = 1;
                                  }
                               }

                            if(fndpr > 0)
                               {
                               if(ran->RB_Tree_Edgelist != NULL)
                                  {
                                  LastEdge2 = NULL;
                                  LastJ = -1;
                                  j = GetNextArealIndex(ran, LastJ, 1, &LastEdge2, cindex, &UsedTree);
                                  LastJ = j;
                                  }
                               else
                                  j = 0;

                               while(j >= 0)
                                  {
                                  if(j == 0)
                                     jj = ran->numverts - 1;
                                  else
                                     jj = j - 1;

                                  checkit2 = 0;

                                  xt1 = ran->x[jj];
                                  yt1 = ran->y[jj];
                                  z3 = ran->z[jj];
                                  xt2 = ran->x[j];
                                  yt2 = ran->y[j];
                                  z4 = ran->z[j];
                                  if(ClipLineToRegion(minx,miny,maxx,maxy,&xt1,&yt1,&z3,&xt2,&yt2,&z4,&clipflag,multiplier) > 0)
                                     checkit2 = 1;
                                  if(checkit2 > 0)
                                     {
                                     if((MatchLinearSegment2D(x1,y1,x2,y2,xt1,yt1,xt2,yt2, &MatchLen,Tolerance) > 0) &&
                                                 (MatchLen > 0.1))
                                        {
                                        CVc = CVn = NULL;
                                        CVc = GetAttrCodesAndValues(rac->Lindex, rac->idn, attrfileptr,SzCV,SzCVl,1);
                                        CVn = GetAttrCodesAndValues(ran->Lindex, ran->idn, attrfileptr,SzCV,SzCVl,1);
                                        ii3 =   AddToSameAttrAndVals('A',SCCtable[rac->Sindex].ECC,CVc,CVn); /***/
                                        if(ii3 > 0)
                                           {
                                           FoundCondition = 0;
                                           ERc = (struct collection *) (malloc(SzC));
                                           if(ERc == NULL)
                                             {
                                             printf("allocation memory exhausted during area feature condition analysis (attribue-boundary analysis)\n");
                                             printf("processing cannot continue\n");
                                             exit(-1);
                                             }
                                           ERc->errmsg = (char *) (malloc(strlen(BndAttrMismatch) + 1));
                                           if(ERc->errmsg == NULL)
                                              {
                                              printf("4: all memory has been consumed during message allocation for boundary matching analysis: exiting now");
                                              exit(-1);
                                              }
                                           strcpy(ERc->errmsg,BndAttrMismatch);
                                           ERc->magnitude = 0;
/***/
   if(rac->x[1] < rac->x[ii])
      {
      minAx = rac->x[1];
      maxAx = rac->x[ii];
      }
   else
      {
      maxAx = rac->x[1];
      minAx = rac->x[ii];
      }

   if(rac->y[i] < rac->y[ii])
      {
      minAy = rac->y[i];
      maxAy = rac->y[ii];
      }
   else
      {
      maxAy = rac->y[i];
      minAy = rac->y[ii];
      }


if(MergeSeg_LineSegmentsOverlap(rac->x[i],rac->y[i],rac->x[ii],rac->y[ii],
                                           ran->x[j],ran->y[j],ran->x[jj],ran->y[jj],minAx,maxAx,minAy,maxAy,
                                           &ax1, &ay1, &ax2, &ay2, Tolerance ) > 0)
CalculateMidPoint(ax1,ay1,ax2,ay2,&ERc->px, &ERc->py);
else
{
ax1 = Distance(rac->x[i],rac->y[i],rac->x[ii],rac->y[ii]);
ax2 = Distance(ran->x[j],ran->y[j],ran->x[jj],ran->y[jj]);
if(ax1 < ax2)
  CalculateMidPoint(rac->x[i],rac->y[i], rac->x[ii],rac->y[ii],&ERc->px, &ERc->py);
else
  CalculateMidPoint(ran->x[j],ran->y[j],ran->x[jj],ran->y[jj],&ERc->px, &ERc->py);
}
ERc->pz = InterpLinearElev(rac->x[i],rac->y[i],rac->z[i], rac->x[ii],rac->y[ii],rac->z[ii],ERc->px,ERc->py);
                                             
                                           ERc->x[0] = rac->x[i];
                                           ERc->y[0] = rac->y[i];
                                           ERc->z[0] = rac->z[i];
                                           ERc->x[1] = rac->x[ii];
                                           ERc->y[1] = rac->y[ii];
                                           ERc->z[1] = rac->z[ii];
                                           ERc->x[2] = ran->x[j];
                                           ERc->y[2] = ran->y[j];
                                           ERc->z[2] = ran->z[j];
                                           ERc->x[3] = ran->x[jj];
                                           ERc->y[3] = ran->y[jj];
                                           ERc->z[3] = ran->z[jj];
                                           ERc->IDN = rac->idn;
                                           ERc->Sindex = rac->Sindex;
                                           ERc->Sindex2 = ran->Sindex;
                                           ERc->aa = rac; /** RawAreal **/
                                           ERc->aa2 = ran;
                                           ERc->pp = NULL; /** RawPoint **/
                                           ERc->le = NULL; /** ListOfEdges **/
                                           ERc->keyval = AGEOM_UNM_LAT;
                                           ERc->Cnumber = Make_Correct(AGEOM_UNM_LAT,checkinstance);
         
                                           if(ERroot == NULL)
                                              {
                                              ERroot = ERc;
                                              ERroot->next = NULL;
                                              }
                                           else
                                              {
                                              ERn = ERroot;
                                              while(ERn != NULL)
                                                 {
                                                 if((ERn->keyval == ERc->keyval) && (ERc->Cnumber == ERn->Cnumber))
                                                    {
                                                    if((ERn->aa == ERc->aa) && (ERn->aa2 == ERc->aa2))
                                                       {
                                                       if((ERc->x[0] == ERn->x[0]) && (ERc->y[0] == ERn->y[0]) && (ERc->z[0] == ERn->z[0]))
                                                          {
                                                          if((ERc->x[1] == ERn->x[1]) && (ERc->y[1] == ERn->y[1]) && (ERc->z[1] == ERn->z[1]))
                                                             break;
                                                          }
                                                       else if((ERc->x[0] == ERn->x[1]) && (ERc->y[0] == ERn->y[1]) && (ERc->z[0] == ERn->z[1]))
                                                          {
                                                          if((ERc->x[1] == ERn->x[0]) && (ERc->y[1] == ERn->y[0]) && (ERc->z[1] == ERn->z[0]))
                                                             break;
                                                          }
                                                       }
                                                    }
                                                 ERn = ERn->next;
                                                 }
                                              if(ERn == NULL)
                                                 {
                                                 ERc->next = ERroot;
                                                 ERroot = ERc;
                                                 }
                                              else
                                                 {
                                                 free(ERc);
                                                 }
                                              }
                                           } /*** end need to record a condition ***/
                                        if(CVc != NULL)
                                           {
                                           for(ii3=0; ii3<CVc->numttl; ii3++)
                                              {
                                              if(CVc->cv[ii3].strval != NULL)
                                                 free(CVc->cv[ii3].strval);
                                              }
                                           free(CVc->cv);
                                           free(CVc);
                                           CVc = NULL;
                                           }
                                        if(CVn != NULL)
                                           {
                                           for(ii3=0; ii3<CVn->numttl; ii3++)
                                              {
                                              if(CVn->cv[ii3].strval != NULL)
                                                 free(CVn->cv[ii3].strval);
                                              }
                                           free(CVn->cv);
                                           free(CVn);
                                           CVn = NULL;
                                           }
                                        }
                                     } /*** end if checkit2 ***/

                                  if(ran->RB_Tree_Edgelist != NULL)
                                     {
                                     j = GetNextArealIndex(ran, LastJ, 1, &LastEdge2, cindex, &UsedTree);
                                     LastJ = j;
                                     }
                                  else
                                     {
                                     ++j;
                                     if(j >= ran->numverts)
                                        j = -1;
                                     }
                                  }
                               }
                            ran = ran->next;
                            }

                         } /** end if endpoint[j] is in the load module  ***/
                      } /*** end if checkit ***/
                   if(rac->RB_Tree_Edgelist != NULL)
                      {
                      i = GetNextArealIndex(rac, LastI, 1, &LastEdge1, cindex, &UsedTree);
                      LastI = i;
                      }
                   else
                      {
                      ++i;
                      if(i >= rac->numverts)
                         i = -1;
                      }
                   } /*** while i >= 0 ***/
                LatLonBase = LatLonBase + LatLonIncrement;
                }  /*** end while LatLonBase in miny, maxy range **/
             } /*** end AGEOM_UNM_LAT check applies ***/


          if((CombinedCheckApplies(rac->idn,checkinstance,AGEOM_UNM_LON,rac->Lindex,rac->Sindex,Config1,Strat1,Domain1,&part1,&part2,&part3) > 0) && (part1 > 0))
             {
/*** need to get the offset for use with LatLonIncrement ***/
             i = Ctype();
             if(i == 1) /** geodetic **/
                {
                LocalMinX = minx / 100000.0 + Xtranslation;
                LocalMaxX = maxx / 100000.0 + Xtranslation;
                LatLonBase = 0.0;
                LatLonIncrement = FindRelevantSensitivity(AGEOM_UNM_LON,checkinstance,&Tolerance);
                if(FindSpecificSensitivity(3,AGEOM_UNM_LON,checkinstance,&Tolerance3) < 1)
                   Tolerance3 = 10.0;


                k = (int) ((LocalMinX - LatLonBase) / LatLonIncrement);

                LatLonBase += (double) k * LatLonIncrement;
                if(LatLonBase < LocalMinX)
                   LatLonBase += LatLonIncrement;
                if((minx <= (MinXcoord + (LatLonIncrement * 0.5))) || (maxx >= (MaxXcoord - (LatLonIncrement * 0.5))))
                   LatLonBase = maxx * 2.0; /** effectively says check will not be applied ***/
                else if(LatLonBase <= LocalMaxX)
                   {
                   LatLonIncrement *= 100000.0;
                   LatLonBase = (LatLonBase - Xtranslation) * 100000.0;
                   LocalMinX = LatLonBase - Tolerance3;
                   LocalMaxX = LatLonBase + Tolerance3;
                   }
                else
                   {
                   LatLonBase = maxx * 2.0; /** effectively says check will not be applied ***/
                   }
                }
             else if(i == 2)
                {
                LatLonBase = maxx * 2.0; /** effectively says check will not be applied ***/
                }

             while((LatLonBase > MinXcoord) && (LatLonBase < MaxXcoord) && (LatLonBase >= minx) && (LatLonBase <= maxx))
                {
                if(rac->RB_Tree_Edgelist != NULL)
                   {
                   LastEdge1 = NULL;
                   LastI = -1;
                   i = GetNextArealIndex(rac, LastI, 1, &LastEdge1, cindex, &UsedTree);
                   LastI = i;
                   }
                else
                   i = 0;
                while(i >= 0)
                   {
                   if(i == 0)
                      ii = rac->numverts - 1;
                   else
                      ii = i - 1;
                   checkit = 0;
                   if(rac->y[i] < rac->y[ii])
                      {
                      if((rac->y[i] <= maxy) && (rac->y[ii] >= miny))
                         checkit = 1;
                      }
                   else
                      {
                      if((rac->y[ii] <= maxy) && (rac->y[i] >= miny))
                         checkit = 1;
                      }
                   if(checkit > 0)
                      {
                      if(rac->x[i] == rac->x[ii])
                         {
                         j = 1;
                         }
                      else
                         {
                         j = 0;
                         angle = AngleWithYaxis(rac->x[i],rac->y[i],rac->x[ii],rac->y[ii]);
                         if(angle <= 0.105) /** less than 10 degrees, radian measure ***/
                            j = 1;
                         }
                      if(j > 0)
                         {
                         if(rac->y[i] > rac->y[ii])
                            {
                            if(rac->y[ii] > maxy)
                               j = 0;
                            else if(rac->y[i] < miny)
                               j = 0;
                            }
                         }

                      if((j > 0) && (rac->x[i] >= LocalMinX) && (rac->x[i] <= LocalMaxX) &&
                            (rac->x[ii] >= LocalMinX) && (rac->x[ii] <= LocalMaxX))
                         {
                         CreatePointInsideAreal(rac, &xinside1, &yinside1);
                         if(xinside1 < LatLonBase)
                            {
                            FoundCondition = -1;
                            }
                         else
                            {
                            FoundCondition = 1;
                            }
                         x1 = rac->x[ii];
                         y1 = rac->y[ii];
                         z1 = rac->z[ii];
                         x2 = rac->x[i];
                         y2 = rac->y[i];
                         z2 = rac->z[i];
                         if(ClipLineToRegion(minx,miny,maxx,maxy,&x1,&y1,&z1,&x2,&y2,&z2,&clipflag,multiplier) > 0)
                            {
                            LenToCover = Distance(x1,y1,x2,y2);
                            CoveredSoFar = 0.0;
                            }
                         else
                            {
                            LenToCover = 0.0;
                            CoveredSoFar = 1.0;
                            }

                         ran = /***Aroot; **/  rac->next; /**/
                         while((ran != NULL) && (CoveredSoFar < LenToCover))
                            {
                            fndpr = 0;
                            if((ran != rac) && (SCCtable[rac->Sindex].ECC == SCCtable[ran->Sindex].ECC))
                               {
                               CreatePointInsideAreal(ran, &xinside1, &yinside1);
                               if((xinside1 < LatLonBase) && (FoundCondition > 0))
                                  {
                                  fndpr = 1;
                                  }
                               else if((xinside1 > LatLonBase) && (FoundCondition < 0))
                                  {
                                  fndpr = 1;
                                  }
                               }
                            if(fndpr > 0)
                               {
                               if(ran->RB_Tree_Edgelist != NULL)
                                  {
                                  LastEdge2 = NULL;
                                  LastJ = -1;
                                  j = GetNextArealIndex(ran, LastJ, 1, &LastEdge2, cindex, &UsedTree);
                                  LastJ = j;
                                  }
                               else
                                  j = 0;

                               while(j >= 0)
                                  {
                                  if(j == 0)
                                     jj = ran->numverts - 1;
                                  else
                                     jj = j - 1;

                                  checkit2 = 0;

                                  xt1 = ran->x[jj];
                                  yt1 = ran->y[jj];
                                  z3 = ran->z[jj];
                                  xt2 = ran->x[j];
                                  yt2 = ran->y[j];
                                  z4 = ran->z[j];
                                  if(ClipLineToRegion(minx,miny,maxx,maxy,&xt1,&yt1,&z3,&xt2,&yt2,&z4,&clipflag,multiplier) > 0)
                                     checkit2 = 1;
                                  if(checkit2 > 0)
                                     {
                                     if((MatchLinearSegment2D(x1,y1,x2,y2,xt1,yt1,xt2,yt2, &MatchLen,Tolerance) > 0) && 
                                            (MatchLen > 0.1))
                                        {
                                        CVc = CVn = NULL;
                                        CVc = GetAttrCodesAndValues(rac->Lindex, rac->idn, attrfileptr,SzCV,SzCVl,1);
                                        CVn = GetAttrCodesAndValues(ran->Lindex, ran->idn, attrfileptr,SzCV,SzCVl,1);
                                        ii3 = AddToSameAttrAndVals('A',SCCtable[rac->Sindex].ECC,CVc,CVn); /***/
                                        if(ii3 > 0)
                                           {
                                           FoundCondition = 0;
                                           ERc = (struct collection *) (malloc(SzC));
                                           if(ERc == NULL)
                                             {
                                             printf("allocation memory exhausted during area feature condition analysis (attribue-boundary analysis)\n");
                                             printf("processing cannot continue\n");
                                             exit(-1);
                                             }
                                           ERc->errmsg = (char *) (malloc(strlen(BndAttrMismatch) + 1));
                                           if(ERc->errmsg == NULL)
                                              {
                                              printf("3: all memory has been consumed during message allocation for boundary matching analysis: exiting now");
                                              exit(-1);
                                              }
                                           strcpy(ERc->errmsg,BndAttrMismatch);
/***/
   if(rac->x[1] < rac->x[ii])
      {
      minAx = rac->x[1];
      maxAx = rac->x[ii];
      }
   else
      {
      maxAx = rac->x[1];
      minAx = rac->x[ii];
      }

   if(rac->y[i] < rac->y[ii])
      {
      minAy = rac->y[i];
      maxAy = rac->y[ii];
      }
   else
      {
      maxAy = rac->y[i];
      minAy = rac->y[ii];
      }


if(MergeSeg_LineSegmentsOverlap(rac->x[i],rac->y[i],rac->x[ii],rac->y[ii],
                                           ran->x[j],ran->y[j],ran->x[jj],ran->y[jj],minAx,maxAx,minAy,maxAy,
                                           &ax1, &ay1, &ax2, &ay2, Tolerance ) > 0)
CalculateMidPoint(ax1,ay1,ax2,ay2,&ERc->px, &ERc->py);
else
{
ax1 = Distance(rac->x[i],rac->y[i],rac->x[ii],rac->y[ii]);
ax2 = Distance(ran->x[j],ran->y[j],ran->x[jj],ran->y[jj]);
if(ax1 < ax2)   CalculateMidPoint(rac->x[i],rac->y[i], rac->x[ii],rac->y[ii],&ERc->px, &ERc->py);
else
  CalculateMidPoint(ran->x[j],ran->y[j],ran->x[jj],ran->y[jj],&ERc->px, &ERc->py);
}

ERc->pz = InterpLinearElev(rac->x[i],rac->y[i],rac->z[i], rac->x[ii],rac->y[ii],rac->z[ii],ERc->px,ERc->py);
/***/
                                           ERc->magnitude = 0;
                                           ERc->x[0] = rac->x[i];
                                           ERc->y[0] = rac->y[i];
                                           ERc->z[0] = rac->z[i];
                                           ERc->x[1] = rac->x[ii];
                                           ERc->y[1] = rac->y[ii];
                                           ERc->z[1] = rac->z[ii];
                                           ERc->x[2] = ran->x[j];
                                           ERc->y[2] = ran->y[j];
                                           ERc->z[2] = ran->z[j];
                                           ERc->x[3] = ran->x[jj];
                                           ERc->y[3] = ran->y[jj];
                                           ERc->z[3] = ran->z[jj];
                                           ERc->IDN = rac->idn;
                                           ERc->Sindex = rac->Sindex;
                                           ERc->Sindex2 = ran->Sindex;
                                           ERc->aa = rac; /** RawAreal **/
                                           ERc->aa2 = ran;
                                           ERc->pp = NULL; /** RawPoint **/
                                           ERc->le = NULL; /** ListOfEdges **/
                                           ERc->keyval = AGEOM_UNM_LON;
                                           ERc->Cnumber = Make_Correct(AGEOM_UNM_LON,checkinstance);

                                           if(ERroot == NULL)
                                              {
                                              ERroot = ERc;
                                              ERroot->next = NULL;
                                              }
                                           else
                                              {
                                              ERn = ERroot;
                                              while(ERn != NULL)
                                                 {
                                                 if((ERn->keyval == ERc->keyval) && (ERc->Cnumber == ERn->Cnumber))
                                                    {
                                                    if((ERn->aa == ERc->aa) && (ERn->aa2 == ERc->aa2))
                                                       {
                                                       if((ERc->x[0] == ERn->x[0]) && (ERc->y[0] == ERn->y[0]) && (ERc->z[0] == ERn->z[0]))
                                                          {
                                                          if((ERc->x[1] == ERn->x[1]) && (ERc->y[1] == ERn->y[1]) && (ERc->z[1] == ERn->z[1]))
                                                             break;
                                                          }
                                                       else if((ERc->x[0] == ERn->x[1]) && (ERc->y[0] == ERn->y[1]) && (ERc->z[0] == ERn->z[1]))
                                                          {
                                                          if((ERc->x[1] == ERn->x[0]) && (ERc->y[1] == ERn->y[0]) && (ERc->z[1] == ERn->z[0]))
                                                             break;
                                                          }
                                                       }
                                                    }
                                                 ERn = ERn->next;
                                                 }
                                              if(ERn == NULL)
                                                 {
                                                 ERc->next = ERroot;
                                                 ERroot = ERc;
                                                 }
                                              else
                                                 {
                                                 free(ERc);
                                                 }
                                              }
                                           } /*** end need to record a condition ***/
                                        if(CVc != NULL)
                                           {
                                           for(ii3=0; ii3<CVc->numttl; ii3++)
                                              {
                                              if(CVc->cv[ii3].strval != NULL)
                                                 free(CVc->cv[ii3].strval);
                                              }
                                           free(CVc->cv);
                                           free(CVc);
                                           CVc = NULL;
                                           }
                                        if(CVn != NULL)
                                           {
                                           for(ii3=0; ii3<CVn->numttl; ii3++)
                                              {
                                              if(CVn->cv[ii3].strval != NULL)
                                                 free(CVn->cv[ii3].strval);
                                              }
                                           free(CVn->cv);
                                           free(CVn);
                                           CVn = NULL;
                                           }
                                        }
                                     } /*** end if checkit2 ***/

                                  if(ran->RB_Tree_Edgelist != NULL)
                                     {
                                     j = GetNextArealIndex(ran, LastJ, 1, &LastEdge2, cindex, &UsedTree);
                                     LastJ = j;
                                     }
                                  else
                                     {
                                     ++j;
                                     if(j >= ran->numverts)
                                        j = -1;
                                     }
                                  }
                               }
                            ran = ran->next;
                            }

                         } /** end if endpoint[j] is in the load module  ***/
                      } /*** end if checkit ***/
                   if(rac->RB_Tree_Edgelist != NULL)
                      {
                      i = GetNextArealIndex(rac, LastI, 1, &LastEdge1, cindex, &UsedTree);
                      LastI = i;
                      }
                   else
                      {
                      ++i;
                      if(i >= rac->numverts)
                         i = -1;
                      }
                   } /*** while i >= 0 ***/
                LatLonBase = LatLonBase + LatLonIncrement;
                }  /*** end while LatLonBase in miny, maxy range **/
             } /*** end AGEOM_UNM_LON check applies ***/



          if((CombinedCheckApplies(rac->idn,checkinstance,AUNM_ATTR_A,rac->Lindex,rac->Sindex,Config1,Strat1,Domain1,&part1,&part2,&part3) > 0) &&
                 (part1 > 0))
             {
             CreatePointInsideAreal(rac, &xinside1, &yinside1);

             LowerTolerance = FindRelevantSensitivity(AUNM_ATTR_A,checkinstance,&UpperTolerance);

             if(rac->RB_Tree_Edgelist != NULL)
                {
                LastEdge1 = NULL;
                LastI = -1;
                i = GetNextArealIndex(rac, LastI, 1, &LastEdge1, cindex, &UsedTree);
                LastI = i;
                }
             else
                i = 0;
             while(i >= 0)
                {
                if(i == 0)
                   ii = rac->numverts - 1;
                else
                   ii = i - 1;
                checkit = 0;
                if(rac->x[i] < rac->x[ii])
                   {
                   if((rac->x[i] <= maxx) && (rac->x[ii] >= minx))
                      checkit = 1;
                   }
                else
                   {
                   if((rac->x[ii] <= maxx) && (rac->x[i] >= minx))
                      checkit = 1;
                   }
                if(checkit > 0)
                   {
                   x1 = rac->x[ii];
                   y1 = rac->y[ii];
                   z1 = rac->z[ii];
                   x2 = rac->x[i];
                   y2 = rac->y[i];
                   z2 = rac->z[i];
                   if(ClipLineToRegion(minx,miny,maxx,maxy,&x1,&y1,&z1,&x2,&y2,&z2,&clipflag,multiplier) <= 0)
                      {
                      checkit = 0;
                      }

                   }
                if(checkit > 0)
                   {
                   if(NorthCount <= 0)
                      checkit = ConditionOnDataEdge(rac->x[i],rac->y[i],rac->x[ii],rac->y[ii],Aroot,Proot,root,
                                            rac, NULL, NULL, NorthCount, 100,100,100,checkinstance);
                   if((checkit > 0) && (SouthCount <= 0))
                      checkit = ConditionOnDataEdge(rac->x[i],rac->y[i],rac->x[ii],rac->y[ii],Aroot,Proot,root,
                                            rac, NULL, NULL, 100, SouthCount, 100,100,checkinstance);
                   }
                if(checkit > 0)
                   {
                   ran = Aroot;
                   while(ran != NULL)
                      {
                      if((ran != rac) &&
                         (CombinedCheckApplies(ran->idn,checkinstance,AUNM_ATTR_A,ran->Lindex,ran->Sindex,
                            SCCtable[ran->Sindex].C,SCCtable[ran->Sindex].S,SCCtable[ran->Sindex].D,
                              &part1,&part2,&part3) > 0) &&
                           (part3 > 0))
                         {
                         if(ran->RB_Tree_Edgelist != NULL)
                            {
                            LastEdge2 = NULL;
                            LastJ = -1;
                            j = GetNextArealIndex(ran, LastJ, 1, &LastEdge2, cindex, &UsedTree);
                            LastJ = j;
                            }
                         else
                            j = 0;
                         while(j >= 0)
                            {
                            if(j == 0)
                               jj = ran->numverts - 1;
                            else
                               jj = j - 1;
                            xt1 = ran->x[jj];
                            yt1 = ran->y[jj];
                            z3 = ran->z[jj];
                            xt2 = ran->x[j];
                            yt2 = ran->y[j];
                            z4 = ran->z[j];
                            checkit = 1;
                            if(ClipLineToRegion(minx,miny,maxx,maxy,&xt1,&yt1,&z3,&xt2,&yt2,&z4,&clipflag,multiplier) <= 0)
                               checkit = 0;

                            if((checkit > 0) && (MatchAndModifyLinearSegment(x1, y1, x2, y2, xt1, yt1, xt2, yt2,
                                   &MatchLen, &bx1, &by1,&bx2, &by2, &on0, &on1, &on2, &on3, UpperTolerance) > 0) &&
                                      (MatchLen > 0.0001))
                               {
                               rap = Aroot;
                               while(rap != NULL)
                                  {
                                  if((rap != rac) && (rap != ran) &&
                                     (CombinedCheckApplies(rap->idn,checkinstance,AUNM_ATTR_A,rap->Lindex,rap->Sindex,
                                        SCCtable[rap->Sindex].C,SCCtable[rap->Sindex].S,SCCtable[rap->Sindex].D,
                                          &part1,&part2,&part3) > 0) &&
                                       (part2 > 0))
                                     {
                                     if(rap->RB_Tree_Edgelist != NULL)
                                        {
                                        LastEdge3 = NULL;
                                        LastK = -1;
                                        k = GetNextArealIndex(rap, LastK, 1, &LastEdge3, cindex, &UsedTree);
                                        LastK = k;
                                        }
                                     else
                                        k = 0;
                                     while(k >= 0)
                                        {
                                        if(k == 0)
                                           kk = rap->numverts - 1;
                                        else
                                           kk = k - 1;
                                        xt1 = rap->x[kk];
                                        yt1 = rap->y[kk];
                                        z3 = rap->z[kk];
                                        xt2 = rap->x[k];
                                        yt2 = rap->y[k];
                                        z4 = rap->z[k];
                                        checkit = 1;
                                        if(ClipLineToRegion(minx,miny,maxx,maxy,
                                                &xt1,&yt1,&z3,&xt2,&yt2,&z4,&clipflag,multiplier) <= 0)
                                           checkit = 0;
                                        if(checkit > 0)
                                           {
                                           if((MatchAndModifyLinearSegment(bx1, by1, bx2, by2, xt1, yt1, xt2, yt2,
                                                &MatchLen, &bx3, &by3,&bx4, &by4, &on0, &on1, &on2, &on3, LowerTolerance) > 0) &&
                                                    (MatchLen > 0.01))
                                              {
                                              CVc = CVn = NULL;
                                              CVc = GetAttrCodesAndValues(rac->Lindex, rac->idn, attrfileptr,SzCV,SzCVl,1);
                                              CVn = GetAttrCodesAndValues(rap->Lindex, rap->idn, attrfileptr,SzCV,SzCVl,1);
                                              unusedint =   AddToSameAttrAndVals('A',SCCtable[rac->Sindex].ECC,CVc,CVn); /***/
                                              if(unusedint > 0)  /*** need to write a condition ***/
                                                 {
                                                 ERc = (struct collection *) (malloc(SzC));
                                                 if(ERc == NULL)
                                                   {
                                                   printf("allocation memory exhausted during area feature boundary match analysis\n");
                                                   printf("processing cannot continue\n");
                                                   exit(-1);
                                                   }
                                                 ERc->errmsg = (char *) (malloc(strlen(BndAttrMismatch) + 1));
                                                 bx1 = bx1 + ((bx2 - bx1) / 2.0);
                                                 by1 = by1 + ((by2 - by1) / 2.0);
                                                 ERc->px = bx1;
                                                 ERc->py = by1;
                                                 ERc->pz = InterpLinearElev(rac->x[i], rac->y[i], rac->z[i],
                                                           rac->x[ii], rac->y[ii], rac->z[ii],bx1,by1);

                                                 strcpy(ERc->errmsg,BndAttrMismatch);
                                                 ERc->magnitude = 0;
                                                 ERc->x[0] = rac->x[i];
                                                 ERc->y[0] = rac->y[i];
                                                 ERc->z[0] = rac->z[i];
                                                 ERc->x[1] = rac->x[ii];
                                                 ERc->y[1] = rac->y[ii];
                                                 ERc->z[1] = rac->z[ii];
                                                 ERc->x[2] = rap->x[k];
                                                 ERc->y[2] = rap->y[k];
                                                 ERc->z[2] = rap->z[k];
                                                 ERc->x[3] = rap->x[kk];
                                                 ERc->y[3] = rap->y[kk];
                                                 ERc->z[3] = rap->z[kk];
                                                 ERc->IDN = rac->idn;
                                                 ERc->Sindex = rac->Sindex;
                                                 ERc->Sindex2 = rap->Sindex;
                                                 ERc->aa = rac; /** RawAreal **/
                                                 ERc->aa2 = rap;
                                                 ERc->pp = NULL; /** RawPoint **/
                                                 ERc->le = NULL; /** ListOfEdges **/
                                                 ERc->keyval = AUNM_ATTR_A;
                                                 ERc->Cnumber = Make_Correct(AUNM_ATTR_A,checkinstance);
      
                                                 if(ERroot == NULL)
                                                    {
                                                    ERroot = ERc;
                                                    ERroot->next = NULL;
                                                    }
                                                 else
                                                    {
                                                    ERn = ERroot;
                                                    while(ERn != NULL)
                                                       {
                                                       if((ERn->keyval == ERc->keyval) && (ERc->Cnumber == ERn->Cnumber))
                                                          {
                                                          if((ERn->aa == ERc->aa) && (ERn->aa2 == ERc->aa2))
                                                             {
                                                             if((ERc->x[0] == ERn->x[0]) && (ERc->y[0] == ERn->y[0]) && (ERc->z[0] == ERn->z[0]))
                                                                {
                                                                if((ERc->x[1] == ERn->x[1]) && (ERc->y[1] == ERn->y[1]) && (ERc->z[1] == ERn->z[1]))
                                                                   break;
                                                                }
                                                             else if((ERc->x[0] == ERn->x[1]) && (ERc->y[0] == ERn->y[1]) && (ERc->z[0] == ERn->z[1]))
                                                                {
                                                                if((ERc->x[1] == ERn->x[0]) && (ERc->y[1] == ERn->y[0]) && (ERc->z[1] == ERn->z[0]))
                                                                   break;
                                                                }
                                                             }
                                                          }
                                                       ERn = ERn->next;
                                                       }
                                                    if(ERn == NULL)
                                                       {
                                                       ERc->next = ERroot;
                                                       ERroot = ERc;
                                                       }
                                                    else
                                                       {
                                                       free(ERc);
                                                       }
                                                    }
                                                 } /*** end need to record a condition ***/
                                              if(CVc != NULL)
                                                 {
                                                 for(ii3=0; ii3<CVc->numttl; ii3++)
                                                    {
                                                    if(CVc->cv[ii3].strval != NULL)
                                                       free(CVc->cv[ii3].strval);
                                                    }
                                                 free(CVc->cv);
                                                 free(CVc);
                                                 CVc = NULL;
                                                 }
                                              if(CVn != NULL)
                                                 {
                                                 for(ii3=0; ii3<CVn->numttl; ii3++)
                                                    {
                                                    if(CVn->cv[ii3].strval != NULL)
                                                       free(CVn->cv[ii3].strval);
                                                    }
                                                 free(CVn->cv);
                                                 free(CVn);
                                                 CVn = NULL;
                                                 }
                                              }
                                           }
                                        if(rap->RB_Tree_Edgelist != NULL)
                                           {
                                           k = GetNextArealIndex(rap, LastK, 1, &LastEdge3, cindex, &UsedTree);
                                           LastK = k;
                                           }
                                        else
                                           {
                                           ++k;
                                           if(k >= rap->numverts)
                                              k = -1;
                                           }
                                        } /** end looping thru k edges of rap ***/
                                     } /*** end found a part 2 feature ***/
                                  rap = rap->next;
                                  } /*** end while rap ***/
                               } /** end found bx1, by1, bx2, by2 that needs coverage ***/

                            if(ran->RB_Tree_Edgelist != NULL)
                               {
                               j = GetNextArealIndex(ran, LastJ, 1, &LastEdge2, cindex, &UsedTree);
                               LastJ = j;
                               }
                            else
                               {
                               ++j;
                               if(j >= ran->numverts)
                                  j = -1;
                               }
                            }


                         } /** end found a part3 feature  ***/
                      ran = ran->next;
                      } /*** while ran != NULL ***/
                   } /** end if checking rac->edge[i] ****/
                if(rac->RB_Tree_Edgelist != NULL)
                   {
                   i = GetNextArealIndex(rac, LastI, 1, &LastEdge1, cindex, &UsedTree);
                   LastI = i;
                   }
                else
                   {
                   ++i;
                   if(i >= rac->numverts)
                      i = -1;
                   }
                } /*** while i >= 0 ***/
             } /*** end AUNM_ATTR_A check applies  to rac ***/


          }  /*** end for(checkinstance = 0; ...   ***/
       rac = rac->next;
       }




   rlc = root;

   while(rlc != NULL)
      {
       Config1 = SCCtable[rlc->Sindex].C;
       Strat1 = SCCtable[rlc->Sindex].S;
       Domain1 = SCCtable[rlc->Sindex].D;

       for(checkinstance = 0; checkinstance < TtlActiveChecks; checkinstance++)
          {

          if((CombinedCheckApplies(rlc->idn,checkinstance,LGEOM_UNM_LAT,rlc->Lindex,rlc->Sindex,Config1,Strat1,Domain1,&part1,&part2,&part3) > 0) && (part1 > 0))
             {
             i = Ctype();
             if(i == 1) /** geodetic **/
                {
                LocalMinY = miny / 100000.0 + Ytranslation;
                LocalMaxY = maxy / 100000.0 + Ytranslation;

                LatLonBase = 0.0;
                LatLonIncrement = FindRelevantSensitivity(LGEOM_UNM_LAT,checkinstance,&Tolerance);
                if(FindSpecificSensitivity(3,LGEOM_UNM_LAT,checkinstance,&Tolerance3) < 1)
                   Tolerance3 = 10.0;


                k = (int) ((LocalMinY - LatLonBase) / LatLonIncrement);

                LatLonBase += (double) k * LatLonIncrement;

                if(LatLonBase < LocalMinY)
                   LatLonBase += LatLonIncrement;
                if((miny <= (MinYcoord + (LatLonIncrement * 0.5))) || (maxy >= (MaxYcoord - (LatLonIncrement * 0.5))))
                   LatLonBase = maxy * 2.0; /** effectively says check will not be applied ***/
                else if(LatLonBase <= LocalMaxY)
                   {
                   LatLonIncrement *= 100000.0;
                   LatLonBase = (LatLonBase - Ytranslation) * 100000.0;
                   LocalMinY = LatLonBase - Tolerance3;
                   LocalMaxY = LatLonBase + Tolerance3;
                   }
                else
                   {
                   LatLonBase = maxy * 2.0; /** effectively says check will not be applied ***/
                   }
                }
             else if(i == 2)
                {
                LatLonBase = maxy * 2.0; /** effectively says check will not be applied ***/
                }

             j = 0;
             while((LatLonBase > MinYcoord) && (LatLonBase < MaxYcoord) && (LatLonBase >= miny) && (LatLonBase <= maxy))
                {
                while(j < rlc->numnodes)
                   {
                   FoundCondition = 0;
                   ii4 = 0;
                   if((rlc->x[j] >= minx) && (rlc->x[j] <= maxx) && (rlc->y[j] >= LocalMinY) && (rlc->y[j] <= LocalMaxY))
                      {
                      minyPadded = rlc->y[j] - Tolerance;
                      minxPadded = rlc->x[j] - Tolerance;

                      maxxPadded = rlc->x[j] + Tolerance;
                      maxyPadded = rlc->y[j] + Tolerance;

                      direction = 0;
                      dir1 = dir2 = 0;
                      for(i = 0; i< rlc->numnodes; i++)
                         {
                         if(rlc->y[i] > LatLonBase)
                            ++dir1;
                         else  if(rlc->y[i] < LatLonBase)
                            ++dir2;
                         }
                      if(dir1 == dir2)
                         {
                         tempdbl = rlc->y[0] + ((rlc->y[1] - rlc->y[0]) / 2);
                         if(tempdbl > LatLonBase)
                            ++dir1;
                         else
                            ++dir2;
                         }
                      if(dir1 > dir2)
                         ++direction;
                      else
                         --direction;


                      rln = root;
                      fndpr = 0;
                      while(rln != NULL)
                         {
                         if(rln != rlc) /*** try to match the rlc end node up with a node of ANY other type line ***/
                            {
                            if(SCCtable[rlc->Sindex].ECC == SCCtable[rln->Sindex].ECC) /*** make sure lines to be joined have same classification code ***/
                               {
                               for(i=0; i<rln->numnodes; i++)
                                  {
                                  if((rln->x[i] >= minxPadded) && (rln->x[i] <= maxxPadded) &&
                                       (rln->y[i] >= minyPadded) && (rln->y[i] <= maxyPadded))
                                     {
                                     direction2 = 0;
                                     dir1 = dir2 = 0;
                      for(k = 0; k< rln->numnodes; k++)
                         {
                         if(rln->y[k] > LatLonBase)
                            ++dir1;
                         else  if(rln->y[k] < LatLonBase)
                            ++dir2;
                         }
                      if(dir1 == dir2)
                         {
                         tempdbl = rln->y[0] + ((rln->y[1] - rln->y[0]) / 2);
                         if(tempdbl > LatLonBase)
                            ++dir1;
                         else
                            ++dir2;
                         }
                      if(dir1 > dir2)
                         ++direction2;
                      else
                         --direction2;


                                     k = direction * direction2;
                                     if(k <= 0)
                                        {
                                        fndpr = 1;
                                        break;
                                        }
                                     }
                                  }
                               }
                            }
                         if((rlc != rln) && (fndpr > 0))
                            {
                            CVc = CVn = NULL;
                            CVc = GetAttrCodesAndValues(rlc->Lindex, rlc->idn, attrfileptr,SzCV,SzCVl,1);
                            CVn = GetAttrCodesAndValues(rln->Lindex, rln->idn, attrfileptr,SzCV,SzCVl,1);
/**/ii4 =   AddToSameAttrAndVals('L',SCCtable[rlc->Sindex].ECC,CVc,CVn); /***/
/***/
                            if(CVc != NULL)
                               {
                               for(ii3=0; ii3<CVc->numttl; ii3++)
                                  {
                                  if(CVc->cv[ii3].strval != NULL)
                                     free(CVc->cv[ii3].strval);
                                  }
                               free(CVc->cv);
                               free(CVc);
                               CVc = NULL;
                               }
                            if(CVn != NULL)
                               {
                               for(ii3=0; ii3<CVn->numttl; ii3++)
                                  {
                                  if(CVn->cv[ii3].strval != NULL)
                                     free(CVn->cv[ii3].strval);
                                  }
                               free(CVn->cv);
                               free(CVn);
                               CVn = NULL;
                               }
                            break;
                            }
                         rln = rln->next;
                         }

                      if(fndpr == 0) /*** then could not find any match with another line feature for this end node ***/
                         {
                         FoundCondition = 1;
                         }
                      else
                         {
                         FoundCondition = 0;
                         }
/***reverse test ***/
if(fndpr == 0)
FoundCondition = 0;
else
FoundCondition = 1;


                      } /** end if endpoint[j] is in the load module  ***/
                   if((ii4 > 0) && (FoundCondition > 0)) /** need to add a condition to the list ***/
                      {
                      FoundCondition = 0;
                      ERc = (struct collection *) (malloc(SzC));
                      if(ERc == NULL)
                        {
                        printf("allocation memory exhausted during linear feature condition analysis (Z-shear analysis)\n");
                        printf("processing cannot continue\n");
                        exit(-1);
                        }
                      ERc->errmsg = (char *) (malloc(strlen(BndAttrMismatch) + 1));
                      if(ERc->errmsg == NULL)
                         {
                         printf("2: all available memory has been consumed during message allocation for boundary matching analysis: exiting now");
                         exit(-1);
                         }
                      strcpy(ERc->errmsg,BndAttrMismatch);
                      ERc->magnitude = 0;
                      ERc->x[1] = rlc->x[j];
                      ERc->y[1] = rlc->y[j];
                      ERc->z[1] = rlc->z[j];
                      if(j == 0)
                         {
                         ERc->x[2] = rlc->x[1];
                         ERc->y[2] = rlc->y[1];
                         ERc->z[2] = rlc->z[1];
                         }
                      else
                         {
                         ERc->x[2] = rlc->x[j-1];
                         ERc->y[2] = rlc->y[j-1];
                         ERc->z[2] = rlc->z[j-1];
                         }
                      if(i == 0)
                         {
                         ERc->x[0] = rln->x[1];
                         ERc->y[0] = rln->y[1];
                         ERc->z[0] = rln->z[1];
                         }
                      else
                         {
                         ERc->x[0] = rln->x[i-1];
                         ERc->y[0] = rln->y[i-1];
                         ERc->z[0] = rln->z[i-1];
                         }

                      ERc->IDN = rlc->idn;
                      ERc->Sindex = rlc->Sindex;
                      ERc->aa = NULL; /** RawAreal **/
                      ERc->aa2 = NULL;
                      ERc->pp = NULL; /** RawPoint **/
                      ERc->le = NULL; /** ListOfEdges **/
                      ERc->ll1 = rlc;
                      ERc->ll2 = rln;
                      ERc->keyval = LGEOM_UNM_LAT;
                      ERc->Cnumber = Make_Correct(LGEOM_UNM_LAT,checkinstance);

                      if(ERroot == NULL)
                         {
                         ERroot = ERc;
                         ERroot->next = NULL;
                         }
                      else
                         {
                         ERn = ERroot;
                         while(ERn != NULL)
                            {
                            if((ERn->keyval == ERc->keyval) && (ERc->Cnumber == ERn->Cnumber))
                               {
                               if(((ERn->ll1 == ERc->ll1) && (ERn->ll2 == ERc->ll2)) ||
                                    ((ERn->ll1 == ERc->ll2) && (ERn->ll2 == ERc->ll1)))
                                  {
                                  if((ERn->x[1] >= minxPadded) && (ERn->x[1] <= maxxPadded) &&
                                       (ERn->y[1] >= minyPadded) && (ERn->y[1] <= maxyPadded))
                                     {
                                     break;
                                     }
                                  }
                               }
                            ERn = ERn->next;
                            }
                         if(ERn == NULL)
                            {
                            ERc->next = ERroot;
                            ERroot = ERc;
                            }
                         else
                            {
                            free(ERc);
                            }
                         }
                      } /*** end FoundCondition ***/
                   j += rlc->numnodes - 1;
                   } /*** while j < rlc->numnodes ***/
                LatLonBase = LatLonBase + LatLonIncrement;
                }  /*** end while LatLonBase in miny, maxy range **/
             } /*** end LGEOM_UNM_LAT check applies ***/



          if((CombinedCheckApplies(rlc->idn,checkinstance,LGEOM_UNM_LON,rlc->Lindex,rlc->Sindex,Config1,Strat1,Domain1,&part1,&part2,&part3) > 0) && (part1 > 0))
             {
/*** need to get the offset for use with LatLonIncrement ***/
             i = Ctype();
             if(i == 1) /** geodetic **/
                {
                LocalMinX = minx / 100000.0 + Xtranslation;
                LocalMaxX = maxx / 100000.0 + Xtranslation;

                LatLonBase = 0.0;
                LatLonIncrement = FindRelevantSensitivity(LGEOM_UNM_LON,checkinstance,&Tolerance);
                if(FindSpecificSensitivity(3,LGEOM_UNM_LON,checkinstance,&Tolerance3) < 1)
                   Tolerance3 = 10.0;

                k = (int) ((LocalMinX - LatLonBase) / LatLonIncrement);

                LatLonBase += (double) k * LatLonIncrement;
                if(LatLonBase < LocalMinX) /** could be that we have exact multiple - if not need to add one increment ***/
                   LatLonBase += LatLonIncrement;

                if((minx <= (MinXcoord + (LatLonIncrement * 0.5))) || (maxx >= (MaxXcoord - (LatLonIncrement * 0.5))))
                   LatLonBase = maxx * 2.0; /** effectively says check will not be applied ***/
                else if(LatLonBase <= LocalMaxX)
                   {
                   LatLonIncrement *= 100000.0;
                   LatLonBase = (LatLonBase - Xtranslation) * 100000.0;
                   LocalMinX = LatLonBase - Tolerance3;
                   LocalMaxX = LatLonBase + Tolerance3;
                   }
                else
                   {
                   LatLonBase = maxx * 2.0; /** effectively says check will not be applied ***/
                   }
                }
             else if(i == 2)
                {
                LatLonBase = maxx * 2.0; /** effectively says check will not be applied ***/
                }

             j = 0;
             while((LatLonBase > MinXcoord) && (LatLonBase < MaxXcoord) && (LatLonBase >= minx) && (LatLonBase <= maxx))
                {
                while(j < rlc->numnodes)
                   {
                   FoundCondition = 0;
                   ii4 = 0;
                   if((rlc->x[j] >= LocalMinX) && (rlc->x[j] <= LocalMaxX) && (rlc->y[j] >= miny) && (rlc->y[j] <= maxy))
                      {
                      minyPadded = rlc->y[j] - Tolerance;
                      minxPadded = rlc->x[j] - Tolerance;

                      maxxPadded = rlc->x[j] + Tolerance;
                      maxyPadded = rlc->y[j] + Tolerance;

                      direction = 0;
                      dir1 = dir2 = 0;
                      for(i = 0; i< rlc->numnodes; i++)
                         {
                         if(rlc->x[i] > LatLonBase)
                            ++dir1;
                         else if(rlc->x[i] < LatLonBase)
                            ++dir2;
                         }
                      if(dir1 == dir2)
                         {
                         tempdbl = rlc->x[0] + ((rlc->x[1] - rlc->x[0]) / 2);
                         if(tempdbl > LatLonBase)
                            ++dir1;
                         else
                            ++dir2;
                         }
                      if(dir1 > dir2)
                         ++direction;
                      else
                         --direction;


                      rln = root;
                      fndpr = 0;
                      while(rln != NULL)
                         {
                         if(rln != rlc) /*** try to match the rlc end node up with a node of ANY other type line ***/
                            {
                            if(SCCtable[rlc->Sindex].ECC == SCCtable[rln->Sindex].ECC) /*** make sure lines to be joined have same classification code ***/
                               {
                               for(i=0; i<rln->numnodes; i++)
                                  {
                                  if((rln->x[i] >= minxPadded) && (rln->x[i] <= maxxPadded) &&
                                       (rln->y[i] >= minyPadded) && (rln->y[i] <= maxyPadded))
                                     {
                      direction2 = 0;
                      dir1 = dir2 = 0;
                      for(k = 0; k< rln->numnodes; k++)
                         {
                         if(rln->x[k] > LatLonBase)
                            ++dir1;
                         else if(rln->x[k] < LatLonBase)
                            ++dir2;
                         }
                      if(dir1 == dir2)
                         {
                         tempdbl = rln->x[0] + ((rln->x[1] - rln->x[0]) / 2);
                         if(tempdbl > LatLonBase)
                            ++dir1;
                         else
                            ++dir2;
                         }
                      if(dir1 > dir2)
                         ++direction2;
                      else
                         --direction2;

                                     k = direction * direction2;
                                     if(k <= 0)
                                        {
                                        fndpr = 1;
                                        break;
                                        }
                                     }
                                  }
                               }
                            }
                         if((rln != rlc) && (fndpr > 0))
                            {
                            CVc = CVn = NULL;
                            CVc = GetAttrCodesAndValues(rlc->Lindex, rlc->idn, attrfileptr,SzCV,SzCVl,1);
                            CVn = GetAttrCodesAndValues(rln->Lindex, rln->idn, attrfileptr,SzCV,SzCVl,1);
/**/ii4 =  AddToSameAttrAndVals('L',SCCtable[rlc->Sindex].ECC,CVc,CVn); /**/
                            if(CVc != NULL)
                               {
                               for(ii3=0; ii3<CVc->numttl; ii3++)
                                  {
                                  if(CVc->cv[ii3].strval != NULL)
                                     free(CVc->cv[ii3].strval);
                                  }
                               free(CVc->cv);
                               free(CVc);
                               CVc = NULL;
                               }
                            if(CVn != NULL)
                               {
                               for(ii3=0; ii3<CVn->numttl; ii3++)
                                  {
                                  if(CVn->cv[ii3].strval != NULL)
                                     free(CVn->cv[ii3].strval);
                                  }
                               free(CVn->cv);
                               free(CVn);
                               CVn = NULL;
                               }
                            break;
                            }
                         rln = rln->next;
                         }

                      if(fndpr == 0) /*** then could not find any match with another line feature for this end node ***/
                         {
                         FoundCondition = 1;
                         }
                      else
                         {
                         FoundCondition = 0;
                         }
/*** reverse test ***/
if(fndpr == 0)
FoundCondition = 0;
else
FoundCondition = 1;

                      } /** end if endpoint[j] is in the load module  ***/
                   if((ii4 > 0) && (FoundCondition > 0)) /** need to add a condition to the list ***/
                      {
                      FoundCondition = 0;
                      ERc = (struct collection *) (malloc(SzC));
                      if(ERc == NULL)
                        {
                        printf("allocation memory exhausted during linear feature condition analysis (Z-shear analysis)\n");
                        printf("processing cannot continue\n");
                        exit(-1);
                        }
                      ERc->errmsg = (char *) (malloc(strlen(BndAttrMismatch) + 1));
                      if(ERc->errmsg == NULL)
                         {
                         printf("1: all available memory has been consumed during message allocation for boundary matching analysis: exiting now");
                         exit(-1);
                         }
                      strcpy(ERc->errmsg,BndAttrMismatch);
                      ERc->magnitude = 0;
                      ERc->x[1] = rlc->x[j];
                      ERc->y[1] = rlc->y[j];
                      ERc->z[1] = rlc->z[j];
                      if(j == 0)
                         {
                         ERc->x[2] = rlc->x[1];
                         ERc->y[2] = rlc->y[1];
                         ERc->z[2] = rlc->z[1];
                         }
                      else
                         {
                         ERc->x[2] = rlc->x[j-1];
                         ERc->y[2] = rlc->y[j-1];
                         ERc->z[2] = rlc->z[j-1];
                         }
                      if(i == 0)
                         {
                         ERc->x[0] = rln->x[1];
                         ERc->y[0] = rln->y[1];
                         ERc->z[0] = rln->z[1];
                         }
                      else
                         {
                         ERc->x[0] = rln->x[i-1];
                         ERc->y[0] = rln->y[i-1];
                         ERc->z[0] = rln->z[i-1];
                         }
                      ERc->IDN = rlc->idn;
                      ERc->Sindex = rlc->Sindex;
                      ERc->aa = NULL; /** RawAreal **/
                      ERc->aa2 = NULL;
                      ERc->pp = NULL; /** RawPoint **/
                      ERc->le = NULL; /** ListOfEdges **/
                      ERc->ll1 = rlc;
                      ERc->ll2 = rln;
                      ERc->keyval = LGEOM_UNM_LON;
                      ERc->Cnumber = Make_Correct(LGEOM_UNM_LON,checkinstance);

                      if(ERroot == NULL)
                         {
                         ERroot = ERc;
                         ERroot->next = NULL;
                         }
                      else
                         {
                         ERn = ERroot;
                         while(ERn != NULL)
                            {
                            if((ERn->keyval == ERc->keyval) && (ERc->Cnumber == ERn->Cnumber))
                               {
                               if(((ERn->ll1 == ERc->ll1) && (ERn->ll2 == ERc->ll2)) ||
                                    ((ERn->ll1 == ERc->ll2) && (ERn->ll2 == ERc->ll1)))
                                  {
                                  if((ERn->x[1] >= minxPadded) && (ERn->x[1] <= maxxPadded) &&
                                       (ERn->y[1] >= minyPadded) && (ERn->y[1] <= maxyPadded)) 
                                     {
                                     break;
                                     }
                                  }
                               }
                            ERn = ERn->next;
                            }
                         if(ERn == NULL)
                            {
                            ERc->next = ERroot;
                            ERroot = ERc;
                            }
                         else
                            {
                            free(ERc);
                            }
                         }
                      } /*** end FoundCondition ***/
                   j += rlc->numnodes - 1;
                   } /*** while j < rlc->numnodes ***/
                LatLonBase = LatLonBase + LatLonIncrement;
                }  /*** end while LatLonBase in miny, maxy range **/
             } /*** end LGEOM_UNM_LON check applies ***/



         if(CombinedCheckApplies(rlc->idn,checkinstance,LUNM_ATTR_A,rlc->Lindex,rlc->Sindex,
                       Config1,Strat1,Domain1,&part1,&part2,&part3) > 0)
            {
            if((part1 > 0) && (rlc->numnodes > 1))
               {
               j = 0;
               while(j < rlc->numnodes)
                  {
                  rac = Aroot;
                  while(rac != NULL)
                     {
                     i = 0;
                     if(CombinedCheckApplies(rac->idn,checkinstance,LUNM_ATTR_A,rac->Lindex,rac->Sindex,
                            SCCtable[rac->Sindex].C,SCCtable[rac->Sindex].S,SCCtable[rac->Sindex].D,&part1,&part2,&part3) > 0)
                        {
                        if(part3 > 0)
                           {
                           i = 0;
                           if((rlc->x[j] >= minx) && (rlc->x[j] <= maxx) &&
                               (rlc->y[j] >= miny) && (rlc->y[j] <= maxy))
                              {
                              if(rac->RB_Tree_Edgelist == NULL)
                                 ptadist1 = PointToSmallArealDist2D(rlc->x[j], rlc->y[j],rac,&AreaIndex,&whichvertex);
                              else
                                 ptadist1 = PointToLargeArealDist2D(rlc->x[j], rlc->y[j],rac,&AreaIndex,&whichvertex);

                              if((ptadist1 >= 0) && (ptadist1 <= ActiveChecks[checkinstance].sensitivity2))
                                 {
                                 if(AreaIndex == 0)
                                   {
                                   kk2 = rac->numverts - 1;
                                   kk3 = 1;
                                   }
                                 else if(AreaIndex == (rac->numverts -1 ))
                                   {
                                   kk2 = AreaIndex - 1;
                                   kk3 = 0;
                                   }
                                 else
                                   {
                                   kk2 = AreaIndex - 1;
                                   kk3 = AreaIndex + 1;
                                   }

                                 if(j == 0)
                                    jj2 = 1;
                                 else
                                    jj2 = j - 1;

                                 rln = root;
                                 checkit = 0;
                                 while(rln != NULL)
                                    {
                                    if((rln != rlc) &&
                                        (CombinedCheckApplies(rln->idn,checkinstance,LUNM_ATTR_A,rln->Lindex,rln->Sindex,
                                               SCCtable[rln->Sindex].C,SCCtable[rln->Sindex].S,SCCtable[rln->Sindex].D,&part1,
                                                    &part2,&part3) > 0) &&
                                         (part2 > 0))
                                       {
                                       for(i=0; i<rln->numnodes; i++)
                                          {
                                          ptpdist1 = Distance3D(rlc->x[j],rlc->y[j],rlc->z[j],rln->x[i],rln->y[i],rln->z[i]);
                                          if(ptpdist1 <= ActiveChecks[checkinstance].sensitivity)
                                             {
                                             if(i == 0)
                                                ii2 = 1;
                                             else
                                                ii2 = i - 1;

                                             on = 0;
                                             on = TwoPointsOnSameSideOfLine(rlc->x[jj2],rlc->y[jj2],rln->x[ii2],rln->y[ii2],
                                                             rac->x[kk2],rac->y[kk2],rac->x[AreaIndex],rac->y[AreaIndex]);
                                             if((on == 0) && ((whichvertex < 0) || (whichvertex > 1)))
                                                {
                                                on = TwoPointsOnSameSideOfLine(rlc->x[jj2],rlc->y[jj2],rln->x[ii2],rln->y[ii2],
                                                             rac->x[kk3],rac->y[kk3],rac->x[AreaIndex],rac->y[AreaIndex]);
                                                if(on == 0)
                                                   {
                                                   if(jj2 != j)
                                                      on = TwoPointsOnSameSideOfLine(rac->x[kk3],rac->y[kk3],rac->x[AreaIndex],rac->y[AreaIndex],
                                                                rlc->x[jj2],rlc->y[jj2],rlc->x[j],rlc->y[j]);
                                                   if(on == 0)
                                                      {
                                                      if(jj2 != j)
                                                         on = TwoPointsOnSameSideOfLine(rac->x[kk3],rac->y[kk3],rac->x[AreaIndex],rac->y[AreaIndex],
                                                                rln->x[ii2],rln->y[ii2],rln->x[i],rln->y[i]);
                                                      }
                                                   }
                                                }
                                             if(on == 0)
                                                {
                                                CVc = CVn = NULL;
                                                CVc = GetAttrCodesAndValues(rlc->Lindex, rlc->idn, attrfileptr,SzCV,SzCVl,1);
                                                CVn = GetAttrCodesAndValues(rln->Lindex, rln->idn, attrfileptr,SzCV,SzCVl,1);
                                                unusedint =   AddToSameAttrAndVals('A',SCCtable[rlc->Sindex].ECC,CVc,CVn);
                                                if(unusedint > 0)  /*** need to write a condition ***/
                                                   {
                                                   checkit = 1;
                                                   break; 
                                                   }
                                                }
                                             } /** end found an rlc to rln connection **/
                                          } /*** end for i = 0 to rln->numnodes - 1 ***/
                                       }
                                    if(checkit > 0)
                                       break;
                                    rln = rln->next;
                                    }
                                 if(checkit > 0)
                                    {
                                    ERc = (struct collection *) (malloc(SzC));
                                    if(ERc == NULL)
                                      {
                                      printf("allocation memory exhausted during area feature boundary match analysis\n");
                                      printf("processing cannot continue\n");
                                      exit(-1);
                                      }
                                    ERc->errmsg = (char *) (malloc(strlen(BndAttrMismatch) + 1));
                                    ERc->px = rlc->x[j];
                                    ERc->py = rlc->y[j];
                                    ERc->pz = rlc->z[j];

                                    strcpy(ERc->errmsg,BndAttrMismatch);
                                    ERc->magnitude = 0;
                                    ERc->x[0] = rlc->x[j];
                                    ERc->y[0] = rlc->y[j];
                                    ERc->z[0] = rlc->z[j];
                                    ERc->x[1] = rlc->x[jj2];
                                    ERc->y[1] = rlc->y[jj2];
                                    ERc->z[1] = rlc->z[jj2];
                                    ERc->x[2] = rln->x[i];
                                    ERc->y[2] = rln->y[i];
                                    ERc->z[2] = rln->z[i];
                                    ERc->x[3] = rln->x[ii2];
                                    ERc->y[3] = rln->y[ii2];
                                    ERc->z[3] = rln->z[ii2];
                                    ERc->IDN = rlc->idn;
                                    ERc->Sindex = rlc->Sindex;
                                    ERc->Sindex2 = rln->Sindex;
                                    ERc->ll1 = rlc;
                                    ERc->ll2 = rln;
                                    ERc->aa = NULL; /** RawAreal **/
                                    ERc->aa2 = NULL;
                                    ERc->pp = NULL; /** RawPoint **/
                                    ERc->le = NULL; /** ListOfEdges **/
                                    ERc->keyval = LUNM_ATTR_A;
                                    ERc->Cnumber = Make_Correct(LUNM_ATTR_A,checkinstance);
                                    if(ERroot == NULL)
                                       {
                                       ERroot = ERc;
                                       ERroot->next = NULL;
                                       }
                                    else
                                       {
                                       ERn = ERroot;
                                       while(ERn != NULL)
                                          {
                                          if((ERn->keyval == ERc->keyval) && (ERc->Cnumber == ERn->Cnumber))
                                             {
                                             if((ERn->aa == ERc->aa) && (ERn->aa2 == ERc->aa2))
                                                {
                                                if((ERc->x[0] == ERn->x[0]) && (ERc->y[0] == ERn->y[0]) && (ERc->z[0] == ERn->z[0]))
                                                   {
                                                   if((ERc->x[1] == ERn->x[1]) && (ERc->y[1] == ERn->y[1]) && (ERc->z[1] == ERn->z[1]))
                                                      break;
                                                   }
                                                else if((ERc->x[0] == ERn->x[1]) && (ERc->y[0] == ERn->y[1]) && (ERc->z[0] == ERn->z[1]))
                                                   {
                                                   if((ERc->x[1] == ERn->x[0]) && (ERc->y[1] == ERn->y[0]) && (ERc->z[1] == ERn->z[0]))
                                                      break;
                                                   }
                                                }
                                             }
                                          ERn = ERn->next;
                                          }
                                       if(ERn == NULL)
                                          {
                                          ERc->next = ERroot;
                                          ERroot = ERc;
                                          }
                                       else
                                          {
                                          free(ERc);
                                          }
                                       }

                                    }
                                 } /** end found rlc to ran connection **/
                              } /*** end rlc->x,y is in the LM ***/
                           } /** end if part2 ***/
                        } /*** end check applies to the area feature ***/
                     rac = rac->next;
                     } /*** end while rac != NULL ***/
                  j = j + rlc->numnodes - 1;
                  } /*** end j < rlc->numnodes ... ***/
               } /** end check applies to line feature ***/
            }  /*** end LUNM_ATTR_A check ***/





          }  /*** end for(checkinstance = 0; ...   ***/
       rlc = rlc->next;
       }

   ERc = ERroot;
   while(ERc != NULL)
      {
      switch(ERc->keyval)
         {
         case LGEOM_UNM_LAT:
         case LGEOM_UNM_LON:
         case LUNM_ATTR_A:
            FwriteMsgMagPointObjects(ERc->keyval,ERc->Cnumber,ERc->errmsg,ERc->magnitude,
                               ERc->x[1],ERc->y[1],ERc->z[1],
                               ERc->ll1->Sindex,G_LINE,ERc->ll1->Lindex,ERc->ll1->localID,
                               ERc->ll1->idn,-1.0,-1.0,&ERc->x[1],&ERc->y[1],&ERc->z[1],2,
                               ERc->ll2->Sindex,G_LINE,ERc->ll2->Lindex,ERc->ll2->localID,
                               ERc->ll2->idn,-1.0,-1.0,&ERc->x[0],&ERc->y[0],&ERc->z[0],2);
            break;

         case AGEOM_UNM_LON:
         case AGEOM_UNM_LAT:
         case AUNM_ATTR_A:
            FwriteMsgMagPointObjects(ERc->keyval,ERc->Cnumber,ERc->errmsg,ERc->magnitude, ERc->px, ERc->py, ERc->pz,
                               ERc->aa->Sindex,G_AREAL,ERc->aa->Lindex,ERc->aa->localID,
                               ERc->aa->idn,-1.0,-1.0,&ERc->x[0],&ERc->y[0],&ERc->z[0],2,
                               ERc->aa2->Sindex,G_AREAL,ERc->aa2->Lindex,ERc->aa2->localID,
                               ERc->aa2->idn,-1.0,-1.0,&ERc->x[2],&ERc->y[2],&ERc->z[2],2);
            break;


         default:
            printf("unrecognized key condition flag received during linear feature analysis\n");
            break;
         }
      ERn = ERc;
      ERc = ERc->next;
      if(ERn->errmsg != NULL)
         free(ERn->errmsg);
      free(ERn);
      }

   if(attrfileptr != NULL)
      fclose(attrfileptr);

}




void PerformEdgeMatchChecks(char * prompt, int cindex,struct RawLinear *root,double minx,double miny,double maxx,double maxy, double multiplier,
    int NorthCount, int SouthCount, int EastCount, int WestCount,
    struct RawAreal *Aroot, struct RawBridge *Broot, struct RawPoint *Proot, struct ListOfEdges *PEroot, struct ListOfEdges *VPEroot,
    struct RawLinear *NLroot, struct ThePolys * Polyroot)
{
FILE * attrfileptr;
struct RawLinear *rlc, *rln;
struct RawAreal *rac, *ran;
int i,j,k, checkinstance;
int AreaIndex, kk2, kk3, jj2, ii2, checkit, on;
int part1, part2, part3;
int FoundCondition, keepit;
int fndpr;
int Config1, Strat1, Domain1;
double ptpdist1,ptadist1,whichvertex;
double minxPadded, maxxPadded;
double minyPadded, maxyPadded;
double Tolerance2;
double tolerancepad;
double T;
struct collection
   {
   int keyval;
   int Cnumber;
   int numpoints;
   double x[3];
   double y[3];
   double z[3];
   double magnitude;
   int IDN;
   unsigned int Sindex;
   int vertexindex1, vertexindex2;
   struct RawAreal *aa;
   struct RawBridge *bb;
   struct RawPoint *pp;
   struct ListOfEdges *le;
   struct RawLinear *ll1,*ll2;
   struct ThePolys *poly;
   struct collection * next;
   } *ERroot, *ERc, *ERn;
int SzC = sizeof(struct collection);

   ERroot = NULL;

   attrfileptr = NULL;
   sprintf(MessageLine,"%scodesfull.bin",indirectory);
   attrfileptr = fopen(MessageLine,"rb");
   if(attrfileptr == NULL)
      {
      printf("could not find required file %s\n",MessageLine);
      exit(-1);
      }


   rlc = root;

   while(rlc != NULL)
      {
       Config1 = SCCtable[rlc->Sindex].C;
       Strat1 = SCCtable[rlc->Sindex].S;
       Domain1 = SCCtable[rlc->Sindex].D;

       for(checkinstance = 0; checkinstance < TtlActiveChecks; checkinstance++)
          {
          if((CombinedCheckApplies(rlc->idn,checkinstance,L_UNM_A,rlc->Lindex,rlc->Sindex,Config1,Strat1,Domain1,&part1,&part2,&part3) > 0) && (part1 > 0))
             { 
             j = 0;
             tolerancepad = FindRelevantSensitivity(L_UNM_A,checkinstance,&Tolerance2);

             while(j < rlc->numnodes)
                {
                FoundCondition = 0;
                if((rlc->x[j] >= minx) && (rlc->x[j] <= maxx) && (rlc->y[j] >= miny) && (rlc->y[j] <= maxy))
                   {
                   minyPadded = rlc->y[j] - tolerancepad;
                   minxPadded = rlc->x[j] - tolerancepad;

                   maxxPadded = rlc->x[j] + tolerancepad;
                   maxyPadded = rlc->y[j] + tolerancepad;

                   rln = root;
                   fndpr = 0;
                   rac = NULL;
                   while(rln != NULL)
                      {
                      if(rln != rlc) /*** try to match the rlc end node up with a node of ANY other type line ***/
                         {
                         for(i=0; i<rln->numnodes; i++)
                            {
                            if((rln->x[i] >= minxPadded) && (rln->x[i] <= maxxPadded) &&
                                    (rln->y[i] >= minyPadded) && (rln->y[i] <= maxyPadded))
                               {
                               fndpr = 1;
                               break;
                               }
                            }
                         }
                      if(fndpr > 0)
                         break;
                      rln = rln->next;
                      }

                   if(fndpr == 0) /*** then could not find any match with another line feature for this end node - is it on an area edge? ***/
                      {
                      /**mindist1 = Tolerance2 * 2.0;**/
                      rac = Aroot;
                      }
                   else
                      {
                      FoundCondition = 0;
                      rac = NULL;
                      }

                   while(rac != NULL)
                      {
                      ptpdist1 = Tolerance2 * 2.0;
                      if((CombinedCheckApplies(rac->idn,checkinstance,L_UNM_A,rac->Lindex,rac->Sindex,
                               SCCtable[rac->Sindex].C,SCCtable[rac->Sindex].S,SCCtable[rac->Sindex].D,&part1,&part2,&part3) > 0) && (part2 > 0))
                         {
                         if(rac->RB_Tree_Edgelist == NULL)
                            ptpdist1 = PointToSmallArealDist2D(rlc->x[j], rlc->y[j],rac,&k,&T);
                         else
                            ptpdist1 = PointToLargeArealDist2D(rlc->x[j], rlc->y[j],rac,&k,&T);

                         if((ptpdist1 > -1.0) && (ptpdist1 <= Tolerance2))
                            {
                            FoundCondition = 1;
                            break; /** break from the while rac loop ***/
                            }
                         } /* end if combined check applies ***/
                      rac = rac->next;
                      } /** end while rac looking for interior segment close-to match ***/
                   } /** end if endpoint[j] is in the load module  ***/
                if(FoundCondition > 0)
                   {
                   keepit = ConditionOnDataEdge(rlc->x[j],rlc->y[j],rlc->x[j-1],rlc->y[j-1],Aroot,Proot,root,
                                                   NULL, NULL, rlc,
                                                   NorthCount,SouthCount,EastCount,WestCount,checkinstance);
                   if(keepit <= 0)
                      FoundCondition = 0;
                   }

                if(FoundCondition > 0) /** need to add a condition to the list ***/
                   {
                   FoundCondition = 0;
                   ERc = (struct collection *) (malloc(SzC));
                   if(ERc == NULL)
                     {
                     printf("allocation memory exhausted during linear feature condition analysis (Z-shear analysis)\n");
                     printf("processing cannot continue\n");
                     exit(-1);
                     }
                   ERc->x[0] = rlc->x[j];
                   ERc->y[0] = rlc->y[j];
                   ERc->z[0] = rlc->z[j];
                   if(j == 0)
                      {
                      ERc->x[1] = rlc->x[1];
                      ERc->y[1] = rlc->y[1];
                      ERc->z[1] = rlc->z[1];
                      }
                   else
                      {
                      ERc->x[1] = rlc->x[j-1];
                      ERc->y[1] = rlc->y[j-1];
                      ERc->z[1] = rlc->z[j-1];
                      }
                   ERc->IDN = rlc->idn;
                   ERc->Sindex = rlc->Sindex;
                   ERc->aa = NULL; /** RawAreal **/
                   ERc->bb = NULL; /** RawBridge **/
                   ERc->pp = NULL; /** RawPoint **/
                   ERc->le = NULL; /** ListOfEdges **/
                   ERc->poly = NULL; /** ThePolys **/
                   ERc->ll1 = rlc;
                   ERc->ll2 = NULL;
                   ERc->keyval = L_UNM_A;
                   ERc->Cnumber = Make_Correct(L_UNM_A,checkinstance);

                   if(ERroot == NULL)
                      {
                      ERroot = ERc;
                      ERroot->next = NULL;
                      }
                   else
                      {
                      ERn = ERroot;
                      while(ERn != NULL)
                         {
                         if((ERn->keyval == ERc->keyval) && (ERc->Cnumber == ERn->Cnumber))
                            {
                            if((ERn->ll1 == ERc->ll1) && (ERn->aa == ERc->aa))
                               {
                               if((ERc->x[0] == ERn->x[0]) && (ERc->y[0] == ERn->y[0]) && (ERc->z[0] == ERn->z[0]))
                                  {
                                  break;
                                  }
                               }
                            }
                         ERn = ERn->next;
                         }
                      if(ERn == NULL)
                         {
                         ERc->next = ERroot;
                         ERroot = ERc;
                         }
                      else
                         {
                         free(ERc);
                         }
                      }
                   } /*** end FoundCondition ***/
                j += rlc->numnodes - 1;
                } /*** while j < rlc->numnodes ***/
             } /*** end L_UNM_A check applies ***/



         if(CombinedCheckApplies(rlc->idn,checkinstance,LUNM_ACRS_A,rlc->Lindex,rlc->Sindex,
                       Config1,Strat1,Domain1,&part1,&part2,&part3) > 0)
            {
            if((part1 > 0) && (rlc->numnodes > 1))
               {
               j = 0;
               while(j < rlc->numnodes)
                  {
                  rac = Aroot;
                  while(rac != NULL)
                     {
                     i = 0;
                     if(CombinedCheckApplies(rac->idn,checkinstance,LUNM_ACRS_A,rac->Lindex,rac->Sindex,
                            SCCtable[rac->Sindex].C,SCCtable[rac->Sindex].S,SCCtable[rac->Sindex].D,&part1,&part2,&part3) > 0)
                        {
                        if(part3 > 0)
                           {
                           i = 0;
                           if((rlc->x[j] >= minx) && (rlc->x[j] <= maxx) &&
                               (rlc->y[j] >= miny) && (rlc->y[j] <= maxy))
                              {
                              if(rac->RB_Tree_Edgelist == NULL)
                                 ptadist1 = PointToSmallArealDist2D(rlc->x[j], rlc->y[j],rac,&AreaIndex,&whichvertex);
                              else
                                 ptadist1 = PointToLargeArealDist2D(rlc->x[j], rlc->y[j],rac,&AreaIndex,&whichvertex);

                              if((ptadist1 >= 0) && (ptadist1 <= ActiveChecks[checkinstance].sensitivity2))
                                 {
                                 if(AreaIndex == 0)
                                   {
                                   kk2 = rac->numverts - 1;
                                   kk3 = 1;
                                   }
                                 else if(AreaIndex == (rac->numverts -1 ))
                                   {
                                   kk2 = AreaIndex - 1;
                                   kk3 = 0;
                                   }
                                 else
                                   {
                                   kk2 = AreaIndex - 1;
                                   kk3 = AreaIndex + 1;
                                   }

                                 if(j == 0)
                                    jj2 = 1;
                                 else
                                    jj2 = j - 1;

                                 rln = root;
                                 checkit = 1;
                                 while(rln != NULL)
                                    {
                                    if((rln != rlc) && 
                                        (CombinedCheckApplies(rln->idn,checkinstance,LUNM_ACRS_A,rln->Lindex,rln->Sindex,
                                               SCCtable[rln->Sindex].C,SCCtable[rln->Sindex].S,SCCtable[rln->Sindex].D,&part1,
                                                    &part2,&part3) > 0) &&
                                         (part2 > 0))
                                       {
                                       for(i=0; i<rln->numnodes; i++)
                                          {
                                          ptpdist1 = Distance3D(rlc->x[j],rlc->y[j],rlc->z[j],rln->x[i],rln->y[i],rln->z[i]);
                                          if(ptpdist1 <= ActiveChecks[checkinstance].sensitivity)
                                             {
                                             if(i == 0)
                                                ii2 = 1;
                                             else
                                                ii2 = i - 1;

                                             on = 0;
                                             on = TwoPointsOnSameSideOfLine(rlc->x[jj2],rlc->y[jj2],rln->x[ii2],rln->y[ii2],
                                                             rac->x[kk2],rac->y[kk2],rac->x[AreaIndex],rac->y[AreaIndex]);
                                             if((on == 0) && ((whichvertex < 0) || (whichvertex > 1)))
                                                {
                                                on = TwoPointsOnSameSideOfLine(rlc->x[jj2],rlc->y[jj2],rln->x[ii2],rln->y[ii2],
                                                             rac->x[kk3],rac->y[kk3],rac->x[AreaIndex],rac->y[AreaIndex]);
                                                if(on == 0)
                                                   {
                                                   if(jj2 != j)
                                                      on = TwoPointsOnSameSideOfLine(rac->x[kk3],rac->y[kk3],rac->x[AreaIndex],rac->y[AreaIndex],
                                                                rlc->x[jj2],rlc->y[jj2],rlc->x[j],rlc->y[j]);
                                                   if(on == 0)
                                                      {
                                                      if(jj2 != j)
                                                         on = TwoPointsOnSameSideOfLine(rac->x[kk3],rac->y[kk3],rac->x[AreaIndex],rac->y[AreaIndex],
                                                                rln->x[ii2],rln->y[ii2],rln->x[i],rln->y[i]);
                                                      }
                                                   }
                                                }
                                             if(on == 0)
                                                {
                                                checkit = 0;
                                                break;
                                                }
                                             } /** end found an rlc to rln connection **/
                                          } /*** end for i = 0 to rln->numnodes - 1 ***/
                                       }
                                    if(checkit == 0)
                                       break;
                                    rln = rln->next;
                                    }
                                 if(checkit > 0)
                                    {
                                    ERc = (struct collection *) (malloc(SzC));
                                    if(ERc == NULL)
                                       {
                                       printf("allocation memory exhausted during linear feature condition analysis\n");
                                       printf("processing cannot continue\n");
                                       exit(-1);
                                       }
                                    ERc->x[0] = rlc->x[j];
                                    ERc->y[0] = rlc->y[j];
                                    ERc->z[0] = rlc->z[j];
                                    ERc->x[1] = rlc->x[jj2];
                                    ERc->y[1] = rlc->y[jj2];
                                    ERc->z[1] = rlc->z[jj2];
   
                                    ERc->magnitude = 0.0;
                                    ERc->keyval = LUNM_ACRS_A;
                                    ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                                    ERc->IDN = rlc->idn;
                                    ERc->Sindex = rlc->Sindex;
                                    ERc->aa = NULL; /** RawAreal **/
                                    ERc->bb = NULL; /** RawBridge **/
                                    ERc->pp = NULL; /** RawPoint **/
                                    ERc->le = NULL; /** ListOfEdges **/
                                    ERc->poly = NULL; /** ThePolys **/
                                    ERc->ll1 = rlc;
                                    ERc->ll2 = NULL;
                                    ERc->next = NULL;
                                    if(ERroot == NULL)
                                       ERroot = ERc;
                                    else
                                       {
                                       ERn = ERroot;
                                       while(ERn != NULL)
                                          {
                                          if((ERn->Cnumber == ERc->Cnumber) && (ERn->keyval == ERc->keyval) && (ERn->ll1 == ERc->ll1) &&
                                           (ERn->ll1->localID == ERc->ll1->localID) && (ERn->aa == ERc->aa) && (ERn->x[0] == ERc->x[0]) &&
                                                 (ERn->y[0] == ERc->y[0]) && (ERn->z[0] == ERc->z[0]))
                                             break;
   
                                          ERn = ERn->next;
                                          }
                                       if(ERn == NULL)
                                          {
                                          ERc->next = ERroot;
                                          ERroot = ERc;
                                          }
                                       else
                                         free(ERc);
                                       }
                                    }
                                 } /** end found rlc to ran connection **/
                              } /*** end rlc->x,y is in the LM ***/
                           } /** end if part2 ***/
                        } /*** end check applies to the area feature ***/
                     rac = rac->next;
                     } /*** end while rac != NULL ***/
                  j = j + rlc->numnodes - 1;
                  } /*** end j < rlc->numnodes ... ***/
               } /** end check applies to line feature ***/
            }  /*** end LUNM_ACRS_A check ***/



         if(CombinedCheckApplies(rlc->idn,checkinstance,LUNMA_ACRS_A,rlc->Lindex,rlc->Sindex,
                       Config1,Strat1,Domain1,&part1,&part2,&part3) > 0)
            {
            if((part1 > 0) && (rlc->numnodes > 1))
               {
               j = 0;
               while(j < rlc->numnodes)
                  {
                  rac = Aroot;
                  while(rac != NULL)
                     {
                     i = 0;
                     if(CombinedCheckApplies(rac->idn,checkinstance,LUNMA_ACRS_A,rac->Lindex,rac->Sindex,
                            SCCtable[rac->Sindex].C,SCCtable[rac->Sindex].S,SCCtable[rac->Sindex].D,&part1,&part2,&part3) > 0)
                        {
                        if(part3 > 0)
                           {
                           i = 0;
                           if((rlc->x[j] >= minx) && (rlc->x[j] <= maxx) &&
                               (rlc->y[j] >= miny) && (rlc->y[j] <= maxy))
                              {
                              if(rac->RB_Tree_Edgelist == NULL)
                                 ptadist1 = PointToSmallArealDist2D(rlc->x[j], rlc->y[j],rac,&AreaIndex,&whichvertex);
                              else
                                 ptadist1 = PointToLargeArealDist2D(rlc->x[j], rlc->y[j],rac,&AreaIndex,&whichvertex);

                              if((ptadist1 >= 0) && (ptadist1 <= ActiveChecks[checkinstance].sensitivity2))
                                 {
                                 if(AreaIndex == 0)
                                   {
                                   kk2 = rac->numverts - 1;
                                   kk3 = 1;
                                   }
                                 else if(AreaIndex == (rac->numverts -1 ))
                                   {
                                   kk2 = AreaIndex - 1;
                                   kk3 = 0;
                                   }
                                 else
                                   {
                                   kk2 = AreaIndex - 1;
                                   kk3 = AreaIndex + 1;
                                   }

                                 if(j == 0)
                                    jj2 = 1;
                                 else
                                    jj2 = j - 1;

                                 ran = Aroot;
                                 checkit = 1;
                                 while(ran != NULL)
                                    {
                                    if((ran != rac) &&
                                        (CombinedCheckApplies(ran->idn,checkinstance,LUNMA_ACRS_A,ran->Lindex,ran->Sindex,
                                               SCCtable[ran->Sindex].C,SCCtable[ran->Sindex].S,SCCtable[ran->Sindex].D,&part1,
                                                    &part2,&part3) > 0) &&
                                         (part2 > 0))
                                       {
                                       if(ran->RB_Tree_Edgelist == NULL)
                                          ptpdist1 = PointToSmallArealDist2D(rlc->x[j], rlc->y[j],ran,&AreaIndex,&whichvertex);
                                       else
                                          ptpdist1 = PointToLargeArealDist2D(rlc->x[j], rlc->y[j],ran,&AreaIndex,&whichvertex);
                                       if((ptpdist1 >= 0) && (ptpdist1 <= ActiveChecks[checkinstance].sensitivity2))
                                          {
                                          ptpdist1 = Distance(rlc->x[j],rlc->y[j],ran->x[AreaIndex],ran->y[AreaIndex]);
                                          if(ptpdist1 <= ActiveChecks[checkinstance].sensitivity) /**then no condition - we have a match**/
                                             {
                                             checkit = 0;
                                             break;
                                             }
                                          }
                                       }
                                    ran = ran->next;
                                    }
                                 if(checkit > 0)
                                    {
                                    ERc = (struct collection *) (malloc(SzC));
                                    if(ERc == NULL)
                                       {
                                       printf("allocation memory exhausted during linear feature condition analysis\n");
                                       printf("processing cannot continue\n");
                                       exit(-1);
                                       }
                                    ERc->x[0] = rlc->x[j];
                                    ERc->y[0] = rlc->y[j];
                                    ERc->z[0] = rlc->z[j];
                                    ERc->x[1] = rlc->x[jj2];
                                    ERc->y[1] = rlc->y[jj2];
                                    ERc->z[1] = rlc->z[jj2];

                                    ERc->magnitude = 0.0;
                                    ERc->keyval = LUNMA_ACRS_A;
                                    ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                                    ERc->IDN = rlc->idn;
                                    ERc->Sindex = rlc->Sindex;
                                    ERc->aa = NULL; /** RawAreal **/
                                    ERc->bb = NULL; /** RawBridge **/
                                    ERc->pp = NULL; /** RawPoint **/
                                    ERc->le = NULL; /** ListOfEdges **/
                                    ERc->poly = NULL; /** ThePolys **/
                                    ERc->ll1 = rlc;
                                    ERc->ll2 = NULL;
                                    ERc->next = NULL;
                                    if(ERroot == NULL)
                                       ERroot = ERc;
                                    else
                                       {
                                       ERn = ERroot;
                                       while(ERn != NULL)
                                          {
                                          if((ERn->Cnumber == ERc->Cnumber) && (ERn->keyval == ERc->keyval) && (ERn->ll1 == ERc->ll1) &&
                                           (ERn->ll1->localID == ERc->ll1->localID) && (ERn->aa == ERc->aa) && (ERn->x[0] == ERc->x[0]) &&
                                                 (ERn->y[0] == ERc->y[0]) && (ERn->z[0] == ERc->z[0]))
                                             break;

                                          ERn = ERn->next;
                                          }
                                       if(ERn == NULL)
                                          {
                                          ERc->next = ERroot;
                                          ERroot = ERc;
                                          }
                                       else
                                         free(ERc);
                                       }
                                    break;
                                    }
                                 } /** end found rlc to ran connection **/
                              } /*** end rlc->x,y is in the LM ***/
                           } /** end if part2 ***/
                        } /*** end check applies to the area feature ***/
                     rac = rac->next;
                     } /*** end while rac != NULL ***/
                  j = j + rlc->numnodes - 1;
                  } /*** end j < rlc->numnodes ... ***/
               } /** end check applies to line feature ***/
            }  /*** end LUNMA_ACRS_A check ***/






          if((0) && (CombinedCheckApplies(rlc->idn,checkinstance,LSAME_UNM_A,rlc->Lindex,rlc->Sindex,Config1,Strat1,Domain1,&part1,&part2,&part3) > 0) && (part1 > 0))
             {
             j = 0;
             tolerancepad = FindRelevantSensitivity(LSAME_UNM_A,checkinstance,&Tolerance2);

             while(j < rlc->numnodes)
                {
                FoundCondition = 0;
                if((rlc->x[j] >= minx) && (rlc->x[j] <= maxx) && (rlc->y[j] >= miny) && (rlc->y[j] <= maxy))
                   {
                   minyPadded = rlc->y[j] - tolerancepad;
                   minxPadded = rlc->x[j] - tolerancepad;

                   maxxPadded = rlc->x[j] + tolerancepad;
                   maxyPadded = rlc->y[j] + tolerancepad;

                   rln = root;
                   fndpr = 0;
                   rac = NULL;
                   while(rln != NULL)
                      {
                      if(rln != rlc) /*** try to match the rlc end node up with a node of ANY other type line ***/
                         {
                         if(SCCtable[rlc->Sindex].ECC == SCCtable[rln->Sindex].ECC) /*** make sure lines to be joined have same classification code ***/
                            {
                            for(i=0; i<rln->numnodes; i++)
                               {
                               if((rln->x[i] >= minxPadded) && (rln->x[i] <= maxxPadded) &&
                                       (rln->y[i] >= minyPadded) && (rln->y[i] <= maxyPadded))
                                  {
                                  fndpr = 1;
                                  break;
                                  }
                               }
                            }
                         }
                      if(fndpr > 0)
                         break;
                      rln = rln->next;
                      }

                   if(fndpr == 0) /*** then could not find any match with another line feature for this end node - is it on an area edge? ***/
                      {
                      rac = Aroot;
                      }
                   else
                      {
                      FoundCondition = 0;
                      rac = NULL;
                      }

                   while(rac != NULL)
                      {
                      ptpdist1 = Tolerance2 * 2.0;
                      if((CombinedCheckApplies(rac->idn,checkinstance,LSAME_UNM_A,rac->Lindex,rac->Sindex,
                               SCCtable[rac->Sindex].C,SCCtable[rac->Sindex].S,SCCtable[rac->Sindex].D,&part1,&part2,&part3) > 0) && (part2 > 0))
                         {
                         if(rac->RB_Tree_Edgelist == NULL)
                            ptpdist1 = PointToSmallArealDist2D(rlc->x[j], rlc->y[j],rac,&k,&T);
                         else
                            ptpdist1 = PointToLargeArealDist2D(rlc->x[j], rlc->y[j],rac,&k,&T);

                         if((ptpdist1 > -1.0) && (ptpdist1 <= Tolerance2))
                            {
                            FoundCondition = 1;
                            break; /** break from the while rac loop ***/
                            }
                         } /* end if combined check applies ***/
                      rac = rac->next;
                      } /** end while rac looking for interior segment close-to match ***/
                   } /** end if endpoint[j] is in the load module  ***/

                if(FoundCondition > 0)
                   {
                   keepit = ConditionOnDataEdge(rlc->x[j],rlc->y[j],rlc->x[j-1],rlc->y[j-1],Aroot,Proot,root,
                                                   NULL, NULL, rlc,
                                                   NorthCount,SouthCount,EastCount,WestCount,checkinstance);
                   if(keepit <= 0)
                      FoundCondition = 0;
                   }

                if(FoundCondition > 0) /** need to add a condition to the list ***/
                   {
                   FoundCondition = 0;
                   ERc = (struct collection *) (malloc(SzC));
                   if(ERc == NULL)
                     {
                     printf("allocation memory exhausted during linear feature condition analysis (Z-shear analysis)\n");
                     printf("processing cannot continue\n");
                     exit(-1);
                     }
                   ERc->x[0] = rlc->x[j];
                   ERc->y[0] = rlc->y[j];
                   ERc->z[0] = rlc->z[j];
                   if(j == 0)
                      {
                      ERc->x[1] = rlc->x[1];
                      ERc->y[1] = rlc->y[1];
                      ERc->z[1] = rlc->z[1];
                      }
                   else
                      {
                      ERc->x[1] = rlc->x[j-1];
                      ERc->y[1] = rlc->y[j-1];
                      ERc->z[1] = rlc->z[j-1];
                      }
                   ERc->IDN = rlc->idn;
                   ERc->Sindex = rlc->Sindex;
                   ERc->aa = NULL; /** RawAreal **/
                   ERc->bb = NULL; /** RawBridge **/
                   ERc->pp = NULL; /** RawPoint **/
                   ERc->le = NULL; /** ListOfEdges **/
                   ERc->poly = NULL; /** ThePolys **/
                   ERc->ll1 = rlc;
                   ERc->ll2 = NULL;
                   ERc->keyval = LSAME_UNM_A;
                   ERc->Cnumber = Make_Correct(LSAME_UNM_A,checkinstance);

                   if(ERroot == NULL)
                      {
                      ERroot = ERc;
                      ERroot->next = NULL;
                      }
                   else
                      {
                      ERn = ERroot;
                      while(ERn != NULL)
                         {
                         if((ERn->keyval == ERc->keyval) && (ERc->Cnumber == ERn->Cnumber))
                            {
                            if((ERn->ll1 == ERc->ll1) && (ERn->aa == ERc->aa))
                               {
                               if((ERc->x[0] == ERn->x[0]) && (ERc->y[0] == ERn->y[0]) && (ERc->z[0] == ERn->z[0]))
                                  {
                                  break;
                                  }
                               }
                            }
                         ERn = ERn->next;
                         }
                      if(ERn == NULL)
                         {
                         ERc->next = ERroot;
                         ERroot = ERc;
                         }
                      else
                         {
                         free(ERc);
                         }
                      }
                   } /*** end FoundCondition ***/
                j += rlc->numnodes - 1;
                } /*** while j < rlc->numnodes ***/
             } /*** end LSAME_UNM_A check applies ***/


          }  /*** end for(checkinstance = 0; ...   ***/
       rlc = rlc->next;
       }

   ERc = ERroot;
   while(ERc != NULL)
      {
      switch(ERc->keyval)
         {
         case L_UNM_A:
         case LSAME_UNM_A:
         case LUNM_ACRS_A:
         case LUNMA_ACRS_A:
            FwritePointAndObject(ERc->keyval,ERc->Cnumber,ERc->x[0],ERc->y[0],ERc->z[0], -1,
                       ERc->Sindex, G_LINE, ERc->ll1->Lindex,ERc->ll1->localID,
                          ERc->ll1->idn,10.0, 0.0,ERc->x, ERc->y, ERc->z, 2);
            break;

         default:
            printf("unrecognized key condition flag received during linear feature analysis\n");
            break;
         }
      ERn = ERc;
      ERc = ERc->next;
      free(ERn);
      }

   if(attrfileptr != NULL)
      fclose(attrfileptr);

}





int LineEndClosesOnItself2D(struct RawLinear *l, int endindex, double pad)
{
int i,k,answer;
double ptpdist2D, unuseddbl;

   answer = 0;
   ptpdist2D = pad + 100.0;

   if(endindex == 0)
      { 
      k = l->numnodes - 1;
      i = k - 1;
      while(i > 0)
         {
         ptpdist2D = PointToLineDist2DwithFlag(l->x[endindex], l->y[endindex], l->x[i], l->y[i], l->x[k], l->y[k],&unuseddbl);
         if(ptpdist2D < 0.001) /** l seems to close on itself, so do no further testing with it ***/
            {
            answer = 1;
            break; /** from while i loop ***/
            }
         k = i;
         --i;
         }
      }
   else /*** endindex must be l->numnodes - 1 ***/
      {
      k = 0;
      i = k + 1;
      while(i < endindex)
         {
         ptpdist2D = PointToLineDist2DwithFlag(l->x[endindex], l->y[endindex], l->x[i], l->y[i], l->x[k], l->y[k],&unuseddbl);
         if(ptpdist2D < 0.001) /** l seems to close on itself, so do no further testing with it ***/
            {
            answer = 1;
            break; /** from while i loop ***/
            }
         k = i;
         ++i;
         }
      }
   return(answer);
}





int LineAllInsideArea(struct RawLinear *inside, struct RawAreal *outside,double tolerance)
{
int answer = 1;
int i,ii,j,jj,k,vertexinside,vertexshared, insidevertex;
double unuseddbl;
int unusedint;
int TheyDoIntersect;
double xi, yi, xi2, yi2;

   vertexinside = vertexshared = insidevertex = 0;
   for(i=0; i<inside->numnodes; i++)
      {
      if(outside->RB_Tree_Edgelist == NULL)
         {
         if(PointIsVertex(inside->x[i],inside->y[i],outside->x,outside->y,outside->x,outside->numverts,&unuseddbl))
            {
            ++vertexshared;
            ++insidevertex;
            }
         else if(PointOnEdge(inside->x[i],inside->y[i],outside->x,outside->y,outside->x,outside->numverts,&unuseddbl,&unusedint))
            {
            ++vertexshared;
            ++insidevertex;
            }
         else if(PointIsInside(inside->x[i],inside->y[i],outside->x,outside->y,outside->x,outside->numverts,C_AREA,&unuseddbl))
            {
            ++vertexinside;
            ++insidevertex;
            }
         if(insidevertex <= i)
            {
            answer = 0;
            break;
            }
         }
      else
         {
         if(PointIsLargeArealVertex(inside->x[i],inside->y[i],outside,&unuseddbl) > 0)
            {
            ++vertexshared;
            ++insidevertex;
            }
         else if(PointOnLargeArealEdge(inside->x[i],inside->y[i],outside,&unuseddbl, &unusedint) > 0)
            {
            ++vertexshared;
            ++insidevertex;
            }
         else if(PointInsideLargeAreal(inside->x[i],inside->y[i],outside,&ii) > 0)
            {
            ++vertexinside;
            ++insidevertex;
            }
         if(insidevertex <= i)
            {
            answer = 0;
            break;
            }
         }
      }

   if(answer == 1)
      {
      TheyDoIntersect = 0;

      for(i=1; i<inside->numnodes; i++)
         {
         ii = i - 1;
         TheyDoIntersect = 0;
         for(j=0; j<outside->numverts; j++)
            {
            jj = j + 1;
            if(jj == outside->numverts)
               jj = 0;
            if(LineSegmentsConnect(inside->x[i],inside->y[i],inside->x[ii],inside->y[ii],
                                                 outside->x[j],outside->y[j],outside->x[jj],outside->y[jj],0.0001) == 0)
               {
               if(LineSegmentsOverlap(inside->x[i],inside->y[i],inside->x[ii],inside->y[ii],
                                                 outside->x[j],outside->y[j],outside->x[jj],outside->y[jj],
                                                 &xi, &yi, &xi2, &yi2, 0.01) == 0)
                  {
                  TheyDoIntersect = LineSegmentsIntersect(inside->x[i],inside->y[i],inside->x[ii],inside->y[ii],
                                                 outside->x[j],outside->y[j],outside->x[jj],outside->y[jj],&xi,&yi);
                  if(TheyDoIntersect > 0)
                     {
                     for(k=0; k<inside->numnodes; ++k)
                        {
                        unuseddbl = Distance(inside->x[k],inside->y[k],xi,yi);
                        if(unuseddbl <= tolerance)
                           break;
                        }
                     if(k >= inside->numnodes)
                        {
                        answer = 0;
                        break;
                        }
                     }
                  }
               }
            }
         }
      }
   return(answer);
}




int LinePartOrAllInsideArea(struct RawLinear *inside, struct RawAreal *outside, int *index1, int *index2, double tolerance,
                                      double angletolerance)
{
int answer = 0;
int i,ii,j,jj,vertexinside,vertexshared,sharedindex;
int LegalIntersect;
double unuseddbl, tempd;
double testx, testy;
/**int onedge;***/
int unusedint;
int TheyDoIntersect;
double xi, yi;


   vertexinside = vertexshared = 0;
   TheyDoIntersect = 0;
   for(i=0; i<inside->numnodes; i++)
      {
      if(outside->RB_Tree_Edgelist == NULL)
         {
         if(PointWithinToleranceOfVertex(inside->x[i],inside->y[i],outside->x,outside->y,outside->x,outside->numverts,&unuseddbl,tolerance) > 0)
            {
            ++vertexshared;
            if((vertexshared > 1) && (sharedindex == (i - 1)))
               {
               testx = inside->x[sharedindex] + ((inside->x[i] - inside->x[sharedindex]) / 2.0);
               testy = inside->y[sharedindex] + ((inside->y[i] - inside->y[sharedindex]) / 2.0);
               if(PointWithinToleranceOfEdge(testx,testy,outside->x,outside->y,outside->x,outside->numverts,&unuseddbl,&unusedint,tolerance) == 0)
                  {
                  if(PointIsInside(testx,testy,outside->x,outside->y,outside->x,outside->numverts,C_AREA,&unuseddbl))
                     {
                     unuseddbl = PointToArealEdgeDist2D(testx,testy,outside,&unusedint);
                     if(unuseddbl >= tolerance)
                        {
                        ++vertexinside;
                        answer = 1;
                        *index1 = i;
                        *index2 = sharedindex;
                        break;
                        }
                     }
                  }
               }
            else if(i > 0)
               {
               ii = i - 1;
               TheyDoIntersect = 0;
               for(j=0; j<outside->numverts; j++)
                  {
                  jj = j + 1;
                  if(jj == outside->numverts)
                     jj = 0;
                  TheyDoIntersect = LineSegmentsIntersect(inside->x[i],inside->y[i],inside->x[ii],inside->y[ii],
                                                 outside->x[j],outside->y[j],outside->x[jj],outside->y[jj],&xi,&yi);
                  if(TheyDoIntersect > 0)
                     {
                     unuseddbl = Distance(inside->x[i],inside->y[i],xi,yi);
                     if(unuseddbl > tolerance)
                        {
                        *index1 = i;
                        *index2 = ii;
                        answer = 1;
                        sharedindex = i;
                        break;
                        }
                     else
                        TheyDoIntersect = 0;
                     }
                  }
               }
            sharedindex = i;
            if(TheyDoIntersect > 0)
               break;
            }
         else if(PointWithinToleranceOfEdge(inside->x[i],inside->y[i],outside->x,outside->y,outside->x,outside->numverts,&unuseddbl,&unusedint,tolerance))
            {
            ++vertexshared;
            if((vertexshared > 1) && (sharedindex == (i - 1)))
               {
               testx = inside->x[sharedindex] + ((inside->x[i] - inside->x[sharedindex]) / 2.0);
               testy = inside->y[sharedindex] + ((inside->y[i] - inside->y[sharedindex]) / 2.0);
               if(PointWithinToleranceOfEdge(testx,testy,outside->x,outside->y,outside->x,outside->numverts,&unuseddbl,&unusedint,tolerance) == 0)
                  {
                  if(PointIsInside(testx,testy,outside->x,outside->y,outside->x,outside->numverts,C_AREA,&unuseddbl))
                     {
                     unuseddbl = PointToArealEdgeDist2D(testx,testy,outside,&unusedint);
                     if(unuseddbl >= tolerance)
                        {
                        ++vertexinside;
                        answer = 1;
                        *index1 = i;
                        *index2 = sharedindex;
                        break;
                        }
                     }
                  }
               }
            sharedindex = i;
            }
         else if(PointIsInside(inside->x[i],inside->y[i],outside->x,outside->y,outside->x,outside->numverts,C_AREA,&unuseddbl))
            {
            ++vertexinside;
            answer = 1;
            *index1 = i;
            if(i == 0)
               *index2 = 1;
            else
               *index2 = i - 1;
            break;
            }
         }
      else
         {
         if(PointWithinToleranceOfLargeArealVertex(inside->x[i],inside->y[i],outside,&unuseddbl,tolerance) > 0)
            {
            ++vertexshared;
            if((vertexshared > 1) && (sharedindex == (i - 1)))
               {
               testx = inside->x[sharedindex] + ((inside->x[i] - inside->x[sharedindex]) / 2.0);
               testy = inside->y[sharedindex] + ((inside->y[i] - inside->y[sharedindex]) / 2.0);
               if(PointWithinToleranceOfEdge(testx,testy,outside->x,outside->y,outside->x,outside->numverts,&unuseddbl,&unusedint,tolerance) == 0)
                  {
                  if(PointIsInside(testx,testy,outside->x,outside->y,outside->x,outside->numverts,C_AREA,&unuseddbl))
                     {
                     unuseddbl = PointToArealEdgeDist2D(testx,testy,outside,&unusedint);
                     if(unuseddbl >= tolerance)
                        {
                        ++vertexinside;
                        answer = 1;
                        *index1 = i;
                        *index2 = sharedindex;
                        break;
                        }
                     }
                  }
               }
            sharedindex = i;
            }
         else if(PointWithinToleranceOfLargeArealEdge(inside->x[i],inside->y[i],outside,&unuseddbl, &unusedint, tolerance) > 0)
            {
            ++vertexshared;
            if((vertexshared > 1) && (sharedindex == (i - 1)))
               {
               testx = inside->x[sharedindex] + ((inside->x[i] - inside->x[sharedindex]) / 2.0);
               testy = inside->y[sharedindex] + ((inside->y[i] - inside->y[sharedindex]) / 2.0);
               if(PointWithinToleranceOfEdge(testx,testy,outside->x,outside->y,outside->x,outside->numverts,&unuseddbl,&unusedint,tolerance) == 0)
                  {
                  if(PointIsInside(testx,testy,outside->x,outside->y,outside->x,outside->numverts,C_AREA,&unuseddbl))
                     {
                     unuseddbl = PointToArealEdgeDist2D(testx,testy,outside,&unusedint);
                     if(unuseddbl >= tolerance)
                        {
                        ++vertexinside;
                        answer = 1;
                        *index1 = i;
                        *index2 = sharedindex;
                        break;
                        }
                     }
                  }
               }
            sharedindex = i;
            }
         else if(PointInsideLargeAreal(inside->x[i],inside->y[i],outside,&ii) > 0)
            {
            ++vertexinside;
            answer = 1;
            *index1 = i;
            if(i == 0)
               *index2 = 1;
            else
               *index2 = i - 1;
            break;
            }
         }
      }

   if((vertexinside == 0) && (vertexshared == 0))
      {
      TheyDoIntersect = 0;

      for(i=1; i<inside->numnodes; i++)
         {
         ii = i - 1;
         TheyDoIntersect = 0;
         for(j=0; j<outside->numverts; j++)
            {
            jj = j + 1;
            if(jj == outside->numverts)
               jj = 0;
            if(LineSegmentsConnect(inside->x[i],inside->y[i],inside->x[ii],inside->y[ii],
                                                 outside->x[j],outside->y[j],outside->x[jj],outside->y[jj],0.0001) == 0)
               {
               TheyDoIntersect = LineSegmentsIntersect(inside->x[i],inside->y[i],inside->x[ii],inside->y[ii],
                                                 outside->x[j],outside->y[j],outside->x[jj],outside->y[jj],&xi,&yi);
               if(TheyDoIntersect > 0)
                  {
                  *index1 = i;
                  *index2 = ii;
                  answer = 1;
                  break;
                  }
               }
            }
         }
      }

   if((answer > 0) && (angletolerance <= 90.0))
      {
      vertexinside = vertexshared = 0;
      TheyDoIntersect = LegalIntersect = 0;
      for(i=1; i<inside->numnodes; i++)
         {
         ii = i - 1;
         TheyDoIntersect = 0;
         for(j=0; j<outside->numverts; j++)
            {
            jj = j + 1;
            if(jj == outside->numverts)
               jj = 0;
            TheyDoIntersect = LineSegmentsIntersect(inside->x[i],inside->y[i],inside->x[ii],inside->y[ii],
                                        outside->x[j],outside->y[j],outside->x[jj],outside->y[jj],&xi,&yi);
            if(TheyDoIntersect > 0)
               {
               tempd = AngleBetweenLineSegments(inside->x[i],inside->y[i],inside->x[ii],inside->y[ii],
                                              outside->x[j],outside->y[j],outside->x[jj],outside->y[jj]);
               tempd = RadiansToDegrees(acos(tempd));
               if(tempd > 90.0)
                  tempd = 180.0 - tempd;

               if(tempd < angletolerance)
                  {
                  *index1 = i;
                  *index2 = ii;
                  answer = 1;
                  sharedindex = i;
                  LegalIntersect = 0;
                  break;
                  }
               else
                  {
                  TheyDoIntersect = 0;
                  LegalIntersect = 1;
                  answer = 0;
                  }
               }
            }

         if(TheyDoIntersect > 0)
            break;
         }
      }

   return(answer);
}






void FindLineFeaturesWithLindex(char * TgtLindex, int cindex)
{
struct RawLinear * LFc;
int SzRL = sizeof(struct RawLinear);
int Lfilenumber, i, jj;
FILE * readingfile;
char lfilein[500];
char suffix[5];


   for(i=0; i<LinearTable[cindex].numother; i++)
      {
      Lfilenumber = LinearTable[cindex].others[i].filenumber;
      if(LinearFiles[Lfilenumber].isopen == 0)
         {
         sprintf(suffix,"%d",Lfilenumber);
         strcpy(lfilein,linearsin);
         if(Lfilenumber > 0)
             strcat(lfilein,suffix);
         readingfile = fopen(lfilein,"rb"); 
         if(readingfile == NULL)
            {
            printf("3 area feature data input file %s could not be opened for read\n",lfilein);
            exit(-1);
            }
         LinearFiles[Lfilenumber].fp = readingfile;
         LinearFiles[Lfilenumber].isopen = 1;
         }
      else
         {
         readingfile = LinearFiles[Lfilenumber].fp;
         }

      fseek(readingfile,LinearTable[cindex].others[i].fileptr,SEEK_SET);
      ReadLinearFromFile(readingfile, SignificantDecimals);

      if(TgtLindex[LinearFromFile.Lindex] > 0)
         {
         LFc = (struct RawLinear *) (malloc(SzRL));
         if(LFc == NULL)
            {
            printf("allocation memory exhausted during neighbor line feature read\n");
            printf("processing cannot continue\n");
            exit(-1);
            }
         LFc->numnodes = LinearFromFile.numnodes;
         LFc->Lindex = LinearFromFile.Lindex;
         LFc->Sindex = LinearFromFile.Sindex;
         LFc->idn = LinearFromFile.idn;
         LFc->NumIntersections = 0;
         LFc->length = LinearFromFile.length;
         LFc->IsMulti = 1;
         LFc->featureid = LinearFromFile.featureid;
         LFc->next = NULL;
         LFc->x = (double *) malloc(SzD * LinearFromFile.numnodes);
         LFc->y = (double *) malloc(SzD * LinearFromFile.numnodes);
         LFc->z = (double *) malloc(SzD * LinearFromFile.numnodes);
         if((LFc->x == NULL) || (LFc->y == NULL) || (LFc->z == NULL))
            {
            printf("allocation memory exhausted during neighbor line feature read\n");
            printf("processing cannot continue\n");
            exit(-1);
            }

         for(jj = 0; jj<LinearFromFile.numnodes; jj++)
            {
            LFc->x[jj] = LinearFromFile.x[jj];
            LFc->y[jj] = LinearFromFile.y[jj];
            LFc->z[jj] = LinearFromFile.z[jj];
            }
         LFc->next = TgtLroot;
         TgtLroot = LFc;
         }
      }

   if(LinearTable[cindex].numinside > 0)
      {
      Lfilenumber = LinearTable[cindex].filenumber;
      if(LinearFiles[Lfilenumber].isopen == 0)
         {
         sprintf(suffix,"%d",Lfilenumber);
         strcpy(lfilein,linearsin);
         if(Lfilenumber > 0)
             strcat(lfilein,suffix);
         readingfile = fopen(lfilein,"rb");
         if(readingfile == NULL)
            {
            printf("3 area feature data input file %s could not be opened for read\n",lfilein);
            exit(-1);
            }
         LinearFiles[Lfilenumber].fp = readingfile;
         LinearFiles[Lfilenumber].isopen = 1;
         }
      else
         {
         readingfile = LinearFiles[Lfilenumber].fp;
         }

      fseek(readingfile,LinearTable[cindex].fileptr,SEEK_SET);
      i = 0;
      while(i < LinearTable[cindex].numinside)
         {
         ReadLinearFromFile(readingfile, SignificantDecimals);
         ++i;

         if(TgtLindex[LinearFromFile.Lindex] > 0)
            {
            LFc = (struct RawLinear *) (malloc(SzRL));
            if(LFc == NULL)
               {
               printf("allocation memory exhausted during neighbor line feature read\n");
               printf("processing cannot continue\n");
               exit(-1);
               }
            LFc->numnodes = LinearFromFile.numnodes;
            LFc->Lindex = LinearFromFile.Lindex;
            LFc->Sindex = LinearFromFile.Sindex;
            LFc->idn = LinearFromFile.idn;
            LFc->NumIntersections = 0;
            LFc->length = LinearFromFile.length;
            LFc->IsMulti = 0;
            LFc->featureid = LinearFromFile.featureid;
            LFc->next = NULL;
            LFc->x = (double *) malloc(SzD * LinearFromFile.numnodes);
            LFc->y = (double *) malloc(SzD * LinearFromFile.numnodes);
            LFc->z = (double *) malloc(SzD * LinearFromFile.numnodes);
            if((LFc->x == NULL) || (LFc->y == NULL) || (LFc->z == NULL))
               {
               printf("allocation memory exhausted during neighbor line feature read\n");
               printf("processing cannot continue\n");
               exit(-1);
               }

            for(jj = 0; jj<LinearFromFile.numnodes; jj++)
               {
               LFc->x[jj] = LinearFromFile.x[jj];
               LFc->y[jj] = LinearFromFile.y[jj];
               LFc->z[jj] = LinearFromFile.z[jj];
               }
            LFc->next = TgtLroot;
            TgtLroot = LFc;
            }
         }
      }
}





void FindPointFeaturesWithLindex(char * TgtLindex, int cindex, FILE * readingfile)
{
struct RawPoint * PFc;
int SzRP = sizeof(struct RawPoint);
int i, jj, vertexcount;
long int fo;
double filedecimal = 0.1;


   for(i=0; i<PointTable[cindex].numother; i++)
      {
      fseek(readingfile,PointTable[cindex].others[i].fileptr,SEEK_SET);
      vertexcount = ReadPointFromFile(readingfile, SignificantDecimals);

      if(TgtLindex[PointFromFile.Lindex] > 0)
         {
         PFc = (struct RawPoint *) (malloc(SzRP));
         if(PFc == NULL)
            {
            printf("allocation memory exhausted during neighbor point feature read\n");
            printf("processing cannot continue\n");
            exit(-1); 
            }
         PFc->numverts = PointFromFile.numverts;
         PFc->Lindex = PointFromFile.Lindex;
         PFc->Sindex = PointFromFile.Sindex;
         PFc->idn = PointFromFile.idn;
         PFc->rad = PointFromFile.rad;
         PFc->featureid = PointFromFile.featureid;
         PFc->localID = PointTable[cindex].others[i].fileptr + filedecimal;
         PFc->next = NULL;
         PFc->h = (double *) malloc(SzD * vertexcount);
         PFc->x = (double *) malloc(SzD * vertexcount);
         PFc->y = (double *) malloc(SzD * vertexcount);
         PFc->z = (double *) malloc(SzD * vertexcount);
         if((PFc->x == NULL) || (PFc->y == NULL) || (PFc->z == NULL))
            {
            printf("1 -- allocation memory exhausted during neighbor point feature read\n");
            printf("processing cannot continue\n");
            exit(-1);
            }

         for(jj = 0; jj<vertexcount; jj++)
            {
            PFc->h[jj] = PointFromFile.h[jj];
            PFc->x[jj] = PointFromFile.x[jj];
            PFc->y[jj] = PointFromFile.y[jj];
            PFc->z[jj] = PointFromFile.z[jj];
            }
         PFc->next = TgtProot;
         TgtProot = PFc;
         }
      }

   if(PointTable[cindex].numinside > 0)
      {
      fseek(readingfile,PointTable[cindex].fileptr,SEEK_SET);
      i = 0;
      while(i < PointTable[cindex].numinside)
         {
         fo = ftell(readingfile);
         vertexcount = ReadPointFromFile(readingfile, SignificantDecimals);
         ++i;

         if(TgtLindex[PointFromFile.Lindex] > 0)
            {
            PFc = (struct RawPoint *) (malloc(SzRP));
            if(PFc == NULL)
               {
               printf("2 -- allocation memory exhausted during neighbor point feature read\n");
               printf("processing cannot continue\n");
               exit(-1);
               }
            PFc->numverts = PointFromFile.numverts;
            PFc->Lindex = PointFromFile.Lindex;
            PFc->Sindex = PointFromFile.Sindex;
            PFc->idn = PointFromFile.idn;
            PFc->localID = fo + filedecimal;
            PFc->rad = PointFromFile.rad;
            PFc->featureid = PointFromFile.featureid;
            PFc->next = NULL;
            PFc->h = (double *) malloc(SzD * vertexcount);
            PFc->x = (double *) malloc(SzD * vertexcount);
            PFc->y = (double *) malloc(SzD * vertexcount);
            PFc->z = (double *) malloc(SzD * vertexcount);
            if((PFc->x == NULL) || (PFc->y == NULL) || (PFc->z == NULL))
               {
               printf("3 -- allocation memory exhausted during neighbor point feature read\n");
               printf("requested memory for a point feature with %d vertices\n",PointFromFile.numverts);
               printf("processing cannot continue\n");
               exit(-1);
               }

            for(jj = 0; jj<vertexcount; jj++)
               {
               PFc->h[jj] = PointFromFile.h[jj];
               PFc->x[jj] = PointFromFile.x[jj];
               PFc->y[jj] = PointFromFile.y[jj];
               PFc->z[jj] = PointFromFile.z[jj]; 
               }
            PFc->next = TgtProot;
            TgtProot = PFc;
            }
         }
      }
}







void FindArealFeaturesWithLindex(char * TgtLindex, int cindex)
{
struct RawAreal * ARc;
int SzRA = sizeof(struct RawAreal);
int Afilenumber, i, jj;
FILE * readingfile;
char afilein[500];
char suffix[5];


   for(i=0; i<ArealTable[cindex].numother; i++)
      {
      Afilenumber = ArealTable[cindex].others[i].filenumber;
      if(ArealFiles[Afilenumber].isopen == 0)
         {
         sprintf(suffix,"%d",Afilenumber);
         strcpy(afilein,arealsin);
         if(Afilenumber > 0)
             strcat(afilein,suffix);
         readingfile = fopen(afilein,"rb");
         if(readingfile == NULL)
            {
            printf("3 area feature data input file %s could not be opened for read\n",afilein);
            exit(-1);
            }
         ArealFiles[Afilenumber].fp = readingfile;
         ArealFiles[Afilenumber].isopen = 1; 
         }
      else
         {
         readingfile = ArealFiles[Afilenumber].fp;
         }

      fseek(readingfile,ArealTable[cindex].others[i].fileptr,SEEK_SET);
      ReadArealFromFile(readingfile, SignificantDecimals);

      if(TgtLindex[ArealFromFile.Lindex] > 0)
         {
         ARc = (struct RawAreal *) (malloc(SzRA));
         if(ARc == NULL)
            {
            printf("allocation memory exhausted during neighbor area feature read\n");
            printf("processing cannot continue\n");
            exit(-1);
            }
         ARc->numverts = ArealFromFile.numverts;
         ARc->Lindex = ArealFromFile.Lindex;
         ARc->Sindex = ArealFromFile.Sindex;
         ARc->idn = ArealFromFile.idn;
         ARc->areaattr = ArealFromFile.areaattr;
         ARc->hgtattr = ArealFromFile.hgtattr;
         ARc->zv2attr = ArealFromFile.zv2attr;
         if(ArealFromFile.areastr[0] == '\0')
            ARc->areastr = NULL;
         else
            {
            ARc->areastr = (char *) (malloc(strlen(ArealFromFile.areastr) + 2));
            if(ARc->areastr != NULL)
               strcpy(ARc->areastr,ArealFromFile.areastr);
            }
         if(ArealFromFile.hgtstr[0] == '\0')
            ARc->hgtstr = NULL;
         else
            {
            ARc->hgtstr = (char *) (malloc(strlen(ArealFromFile.hgtstr) + 2));
            if(ARc->hgtstr != NULL)
               strcpy(ARc->hgtstr,ArealFromFile.hgtstr);
            }
         if(ArealFromFile.zv2str[0] == '\0')
            ARc->zv2str = NULL;
         else
            {
            ARc->zv2str = (char *) (malloc(strlen(ArealFromFile.zv2str) + 2));
            if(ARc->zv2str != NULL)
               strcpy(ARc->zv2str,ArealFromFile.zv2str);
            }
         if(ArealFromFile.lenstr[0] == '\0')
            ARc->lenstr = NULL;
         else
            {
            ARc->lenstr = (char *) (malloc(strlen(ArealFromFile.lenstr) + 2));
            if(ARc->lenstr != NULL)
               strcpy(ARc->lenstr,ArealFromFile.lenstr);
            }
         if(ArealFromFile.namstr[0] == '\0')
            ARc->namstr = NULL;
         else
            {
            ARc->namstr = (char *) (malloc(strlen(ArealFromFile.namstr) + 2));
            if(ARc->namstr != NULL)
               strcpy(ARc->namstr,ArealFromFile.namstr);
            }
         ARc->ishole = ArealFromFile.ishole;
         ARc->RB_Tree_Edgelist = NULL;
         ARc->area = ArealFromFile.area;
         ARc->ismulti = 1;
         ARc->featureid = ArealFromFile.featureid;
         ARc->minxvtx = ArealFromFile.minxvtx;
         ARc->next = NULL;
         ARc->x = (double *) malloc(SzD * ArealFromFile.numverts);
         ARc->y = (double *) malloc(SzD * ArealFromFile.numverts);
         ARc->z = (double *) malloc(SzD * ArealFromFile.numverts);
         if((ARc->x == NULL) || (ARc->y == NULL) || (ARc->z == NULL))
            {
            printf("allocation memory exhausted during neighbor area feature read\n");
            printf("processing cannot continue\n");
            exit(-1);
            }

         for(jj = 0; jj<ArealFromFile.numverts; jj++)
            {
            ARc->x[jj] = ArealFromFile.x[jj];
            ARc->y[jj] = ArealFromFile.y[jj];
            ARc->z[jj] = ArealFromFile.z[jj];
            }
         ARc->numverts = ArealFromFile.numverts;
         ARc->next = TgtAroot;
         TgtAroot = ARc;
         }
      }

   if(ArealTable[cindex].numinside > 0)
      {
      Afilenumber = ArealTable[cindex].filenumber;
      if(ArealFiles[Afilenumber].isopen == 0)
         {
         sprintf(suffix,"%d",Afilenumber);
         strcpy(afilein,arealsin);
         if(Afilenumber > 0)
             strcat(afilein,suffix);
         readingfile = fopen(afilein,"rb");
         if(readingfile == NULL)
            {
            printf("3 area feature data input file %s could not be opened for read\n",afilein);
            exit(-1);
            }
         ArealFiles[Afilenumber].fp = readingfile;
         ArealFiles[Afilenumber].isopen = 1;
         }
      else
         {
         readingfile = ArealFiles[Afilenumber].fp;
         }

      fseek(readingfile,ArealTable[cindex].fileptr,SEEK_SET);
      i = 0;
      while(i < ArealTable[cindex].numinside)
         {
         ReadArealFromFile(readingfile, SignificantDecimals);
         ++i;

         if(TgtLindex[ArealFromFile.Lindex] > 0)
            {
            ARc = (struct RawAreal *) (malloc(SzRA));
            if(ARc == NULL)
               {
               printf("allocation memory exhausted during neighbor area feature read\n");
               printf("processing cannot continue\n");
               exit(-1);
               }
            ARc->numverts = ArealFromFile.numverts;
            ARc->Lindex = ArealFromFile.Lindex;
            ARc->Sindex = ArealFromFile.Sindex;
            ARc->idn = ArealFromFile.idn;
            ARc->areaattr = ArealFromFile.areaattr;
            ARc->hgtattr = ArealFromFile.hgtattr;
            ARc->zv2attr = ArealFromFile.zv2attr;
            ARc->zv2attr = ArealFromFile.zv2attr;
            if(ArealFromFile.areastr[0] == '\0')
               ARc->areastr = NULL;
            else
               {
               ARc->areastr = (char *) (malloc(strlen(ArealFromFile.areastr) + 2));
               if(ARc->areastr != NULL)
                  strcpy(ARc->areastr,ArealFromFile.areastr);
               }
            if(ArealFromFile.hgtstr[0] == '\0')
               ARc->hgtstr = NULL;
            else
               {
               ARc->hgtstr = (char *) (malloc(strlen(ArealFromFile.hgtstr) + 2));
               if(ARc->hgtstr != NULL)
                  strcpy(ARc->hgtstr,ArealFromFile.hgtstr);
               }
            if(ArealFromFile.zv2str[0] == '\0')
               ARc->zv2str = NULL;
            else
               {
               ARc->zv2str = (char *) (malloc(strlen(ArealFromFile.zv2str) + 2));
               if(ARc->zv2str != NULL)
                  strcpy(ARc->zv2str,ArealFromFile.zv2str);
               }
            if(ArealFromFile.lenstr[0] == '\0')
               ARc->lenstr = NULL;
            else
               {
               ARc->lenstr = (char *) (malloc(strlen(ArealFromFile.lenstr) + 2));
               if(ARc->lenstr != NULL)
                  strcpy(ARc->lenstr,ArealFromFile.lenstr);
               }
            if(ArealFromFile.namstr[0] == '\0')
               ARc->namstr = NULL;
            else
               {
               ARc->namstr = (char *) (malloc(strlen(ArealFromFile.namstr) + 2));
               if(ARc->namstr != NULL)
                  strcpy(ARc->namstr,ArealFromFile.namstr);
               }
            ARc->ishole = ArealFromFile.ishole;
            ARc->RB_Tree_Edgelist = NULL;
            ARc->area = ArealFromFile.area;
            ARc->ismulti = 0;
            ARc->featureid = ArealFromFile.featureid;
            ARc->minxvtx = ArealFromFile.minxvtx;
            ARc->next = NULL;
            ARc->x = (double *) malloc(SzD * ArealFromFile.numverts);
            ARc->y = (double *) malloc(SzD * ArealFromFile.numverts);
            ARc->z = (double *) malloc(SzD * ArealFromFile.numverts);
            if((ARc->x == NULL) || (ARc->y == NULL) || (ARc->z == NULL))
               {
               printf("allocation memory exhausted during neighbor area feature read\n");
               printf("processing cannot continue\n");
               exit(-1);
               }

            for(jj = 0; jj<ArealFromFile.numverts; jj++)
               {
               ARc->x[jj] = ArealFromFile.x[jj];
               ARc->y[jj] = ArealFromFile.y[jj];
               ARc->z[jj] = ArealFromFile.z[jj];
               }
            ARc->numverts = ArealFromFile.numverts;
            ARc->next = TgtAroot;
            TgtAroot = ARc;
            }
         }
      }
}








void FindApplicableNeighborFeatures(int cindex, FILE *ptsin, double minx, double maxx, double miny, double maxy,
                                       int LoadAreas, int LoadLines, int LoadPoints, int LoadTertiary)
{
int i, k, k_sec, ThisCheck, checkinstance;
int FLindex, FSindex, SecFLindex;
int LookForFeature, LookForSecFeature, GoGetFeatures;
int li,ui,lj,uj;
int index1, index2, thisindex, strindex;
double temptolerance, ptldist;
double xi, yi, unuseddbl;
int NIAC, NSG, NAC;
char * P_LLstring;
char * A_LLstring;
char * L_LLstring;
struct LMtoLoad
   {
   int LM;
   struct LMtoLoad * next;
   } *LMLroot, *LMLc, *LMLp;
int SzLML = sizeof(struct LMtoLoad);


   NIAC = NeedIntersectingArealCalc;
   NSG = NeedSliverGuide;
   NAC = NeedAreaCalculation;
   NeedIntersectingArealCalc = 0;
   NeedSliverGuide = 0;
   NeedAreaCalculation = 0;

   GoGetFeatures = 0;

   if(LoadPoints > 0)
      {
      P_LLstring = (char *) (malloc(SACfull + 5));
      for(strindex=0; strindex<=SACfull; strindex++)
         P_LLstring[strindex] = 0;
      }
   if(LoadLines > 0)
      {
      L_LLstring = (char *) (malloc(SACfull + 5));
      for(strindex=0; strindex<=SACfull; strindex++)
         L_LLstring[strindex] = 0;
      }
   if(LoadAreas > 0)
      {
      A_LLstring = (char *) (malloc(SACfull + 5));
      for(strindex=0; strindex<=SACfull; strindex++)
         A_LLstring[strindex] = 0;
      }

   LMLroot = NULL;

   for(i=0; i < 6; i++)
      {
      switch(i)
         {
         case 0:  ThisCheck = PLPFAIL; 
               break;
         case 1:  ThisCheck = PTPTPROX;  break;
         case 2:  ThisCheck = PLPROX;  break;
         case 3:  ThisCheck = PLLPROXFAIL;  break;
         case 4:  ThisCheck = PLPROXEX; break;
         case 5:  ThisCheck = PSHOOTL;  break;
         }
      if(ErrorLookup[ThisCheck].anyactive > 0)
         {
         for(k=0; k<LindexTable[cindex].inside; k++)
            {
            LookForFeature = 0;
            FLindex =  LindexTable[cindex].indices[k];
            FSindex = CrsWlk[FLindex].LtoSmapping;
            for(checkinstance = 0; checkinstance < TtlActiveChecks; checkinstance++)
               {
               LookForFeature = 0;
               if(ActiveChecks[checkinstance].number == ThisCheck)
                  {
                  if(ActiveChecks[checkinstance].primaryEDCSstuff != NULL)
                     {
                     if(ActiveChecks[checkinstance].primaryEDCSstuff[FLindex] == 1)
                        {
                        LookForFeature = 1;
                        }
                     else if((ActiveChecks[checkinstance].Config1[SCCtable[FSindex].C] == 1) &&
                                     (ActiveChecks[checkinstance].Stratum1[SCCtable[FSindex].S] == 1) &&
                                     (ActiveChecks[checkinstance].Domain1[SCCtable[FSindex].D] == 1) &&
                                     (ActiveChecks[checkinstance].primaryEDCSstuff[FLindex] != 2))
                       {
                       LookForFeature = 1;
                       }
                     }
                  else /*** primaryEDCSstuff must be null ***/
                     {
                     if((ActiveChecks[checkinstance].Config1[SCCtable[FSindex].C] == 1) &&
                                     (ActiveChecks[checkinstance].Stratum1[SCCtable[FSindex].S] == 1) &&
                                     (ActiveChecks[checkinstance].Domain1[SCCtable[FSindex].D] == 1))
                       {
                       LookForFeature = 1;
                       }
                     }
                  if(LookForFeature > 0) /*** then there is a primary participant for this check in this load module ***/
                     {
                     temptolerance = FindRelevantSensitivity(ThisCheck,checkinstance,&unuseddbl);
                     ptldist = Distance(maxx,maxy,maxx+temptolerance, maxy);
                     xi = (temptolerance * temptolerance) / ptldist;

                     ptldist = Distance(maxx,maxy,maxx,maxy+temptolerance);
                     yi = (temptolerance * temptolerance) / ptldist;

                     li = (int) ((minx - xi) / RegionSize);
                     ui = (int) ((maxx + xi) / RegionSize);
                     lj = (int) ((miny - yi) / RegionSize);
                     uj = (int) ((maxy + yi) / RegionSize);

                     if(li < 0)   li = 0;
                     if(lj < 0)   lj = 0;
                     if(ui > MaxXindex)     ui = MaxXindex;
                     if(uj > MaxYindex)     uj = MaxYindex;

                     LookForSecFeature = 0;

                     for(index1 = li; index1 <= ui; index1++)
                        {
                        for(index2 = lj; index2 <= uj; index2++)
                           {
                           thisindex = (index1 * (MaxYindex + 1)) + index2;
                           LookForSecFeature = 0;
                           if(thisindex != cindex)
                              {
                              for(k_sec=0; k_sec<LindexTable[thisindex].inside; k_sec++)
                                 {
                                 LookForSecFeature = 0;
                                 SecFLindex =  LindexTable[thisindex].indices[k_sec];
                                 if(ActiveChecks[checkinstance].number == ThisCheck)
                                    {
                                    if(ActiveChecks[checkinstance].secondaryEDCSstuff != NULL)
                                       {
                                       if(ActiveChecks[checkinstance].secondaryEDCSstuff[SecFLindex] == 1)
                                          {
                                          LookForSecFeature = 1;
                                          }
                                       else if((ActiveChecks[checkinstance].Config2[SCCtable[FSindex].C] == 1) &&
                                              (ActiveChecks[checkinstance].Stratum2[SCCtable[FSindex].S] == 1) &&
                                              (ActiveChecks[checkinstance].Domain2[SCCtable[FSindex].D] == 1) &&
                                              (ActiveChecks[checkinstance].secondaryEDCSstuff[SecFLindex] != 2))
                                          {
                                          LookForSecFeature = 1;
                                          }
                                       }
                                    else if((ActiveChecks[checkinstance].Config2[SCCtable[FSindex].C] == 1) &&
                                           (ActiveChecks[checkinstance].Stratum2[SCCtable[FSindex].S] == 1) &&
                                           (ActiveChecks[checkinstance].Domain2[SCCtable[FSindex].D] == 1))
                                       {
                                       LookForSecFeature = 1;
                                       }
                                    if((LookForSecFeature == 0) && (LoadTertiary > 0))
                                       {
                                       if(ActiveChecks[checkinstance].tertiaryEDCSstuff != NULL)
                                          {
                                          if(ActiveChecks[checkinstance].tertiaryEDCSstuff[SecFLindex] == 1)
                                             {
                                             LookForSecFeature = 1;
                                             }
                                          else if((ActiveChecks[checkinstance].Config3[SCCtable[FSindex].C] == 1) &&
                                                 (ActiveChecks[checkinstance].Stratum3[SCCtable[FSindex].S] == 1) &&
                                                 (ActiveChecks[checkinstance].Domain3[SCCtable[FSindex].D] == 1) &&
                                                 (ActiveChecks[checkinstance].tertiaryEDCSstuff[SecFLindex] != 2))
                                             {
                                             LookForSecFeature = 1;
                                             }
                                          }
                                       else if((ActiveChecks[checkinstance].Config3[SCCtable[FSindex].C] == 1) &&
                                              (ActiveChecks[checkinstance].Stratum3[SCCtable[FSindex].S] == 1) &&
                                              (ActiveChecks[checkinstance].Domain3[SCCtable[FSindex].D] == 1))
                                          {
                                          LookForSecFeature = 1;
                                          }
                                       }
                                    }

                                 if(LookForSecFeature > 0)
                                    {
                                    switch(CrsWlk[SecFLindex].geomtype)
                                       {
                                       case C_LINE:
                                          if(LoadLines > 0)
                                             {
                                             L_LLstring[SecFLindex] = 1;
                                             GoGetFeatures += 1;
                                             LMLc = LMLroot;
                                             while(LMLc != NULL)
                                                {
                                                if(LMLc->LM == thisindex)
                                                   break;
                                                LMLc = LMLc->next;
                                                }
                                             if(LMLc == NULL)
                                                {
                                                LMLc = (struct LMtoLoad *) (malloc(SzLML));
                                                if(LMLc == NULL)
                                                   {
                                                   printf("all available memory has been consumed during neighbor region feature read\n");
                                                   exit(-1);
                                                   }
                                                LMLc->LM = thisindex;
                                                LMLc->next = LMLroot;
                                                LMLroot = LMLc;
                                                }
                                             }
                                          break;
                                       case C_AREA:
                                          if(LoadAreas > 0)
                                             {
                                             A_LLstring[SecFLindex] = 1;
                                             GoGetFeatures += 1;
                                             LMLc = LMLroot;
                                             while(LMLc != NULL)
                                                {
                                                if(LMLc->LM == thisindex)
                                                   break;
                                                LMLc = LMLc->next;
                                                }
                                             if(LMLc == NULL)
                                                {
                                                LMLc = (struct LMtoLoad *) (malloc(SzLML));
                                                if(LMLc == NULL)
                                                   {
                                                   printf("all available memory has been consumed during neighbor region feature read\n");
                                                   exit(-1);
                                                   }
                                                LMLc->LM = thisindex;
                                                LMLc->next = LMLroot;
                                                LMLroot = LMLc;
                                                }
                                             }
                                          break;
                                       case C_POFE:
                                          if(LoadPoints > 0)
                                             {
                                             P_LLstring[SecFLindex] = 1;
                                             GoGetFeatures += 1;
                                             LMLc = LMLroot;
                                             while(LMLc != NULL)
                                                {
                                                if(LMLc->LM == thisindex)
                                                   break;
                                                LMLc = LMLc->next;
                                                }
                                             if(LMLc == NULL)
                                                {
                                                LMLc = (struct LMtoLoad *) (malloc(SzLML));
                                                if(LMLc == NULL)
                                                   {
                                                   printf("all available memory has been consumed during neighbor region feature read\n");
                                                   exit(-1);
                                                   }
                                                LMLc->LM = thisindex;
                                                LMLc->next = LMLroot;
                                                LMLroot = LMLc;
                                                }
                                             }
                                          break;
                                       }
                                    } /*** end LookForSecFeature ***/
                                 } /*** end for k_sec ****/
                              } /*** end if(thisindex != cindex) ***/
                           } /*** end for(index2 ****/
                        }  /*** end for(index1  ***/
                     } /*** end if LookFor primary feature ***/
                  } /*** end if(ActiveChecks[checkinstance].number == ThisCheck) ****/
               }  /**** end for(checkinstance  ***/
            }   /**** end for(k=0; k<LindexTable[cindex].i ***/
         } /*** end if(ErrorLookup[ThisCheck].anyactive > 0) ***/
      } /*** end for i ****/


   if(GoGetFeatures > 0)
      {
      LMLc = LMLroot;
      while(LMLc != NULL)
         {
         if(LoadAreas > 0)
            FindArealFeaturesWithLindex(A_LLstring, LMLc->LM);
         if(LoadLines > 0)
            FindLineFeaturesWithLindex(L_LLstring, LMLc->LM);
         if(LoadPoints > 0)
            FindPointFeaturesWithLindex(P_LLstring, LMLc->LM, ptsin);

         LMLp = LMLc;
         LMLc = LMLc->next;
         free(LMLp);
         }
      }


   NeedIntersectingArealCalc = NIAC;
   NeedSliverGuide = NSG;
   NeedAreaCalculation = NAC;

   if(LoadPoints > 0)
      {
      free(P_LLstring);
      }
   if(LoadLines > 0)
      {
      free(L_LLstring);
      }
   if(LoadAreas > 0)
      {
      free(A_LLstring);
      }
}


int AdjacentLineSegments(double x1,double y1,double x2,double y2,
               double x3,double y3,double x4,double y4, double overlap_length)
{
double A1,B1,C1,A2,B2,C2;
double An, Bn, Cn;  /*** coefficients for normal to line ***/
double DetN;
double Xi, Yi, Xi2, Yi2, Xt, Yt, dist;
int numint;

   LineEquation(x1,y1,x2,y2,&A1,&B1,&C1);
   LineEquation(x3,y3,x4,y4,&A2,&B2,&C2);

      numint = 0;

      An = B1;
      Bn = 0 - A1;
      Cn = (A1 * y2) - (B1 * x2);

      /** if input lines are parallel, normal to one of them should not be parallel to the other .... ***/
      DetN = (An * B2) - (A2 * Bn);

      /*** find the int of the normal to line (x3,y3) - (x4, y4) ***/
      Xt = ((Bn * C2) - (B2 * Cn)) / DetN;
      Yt = ((A2 * Cn) - (An * C2)) / DetN;

      if(EqualWithinTolerance(x2,y2, x3, y3, 0.000001) > 0)
         {
         ++numint;
         Xi = x2;
         Yi = y2;
         }
      else if(EqualWithinTolerance(x2,y2, x4, y3, 0.000001) > 0)
         {
         ++numint;
         Xi = x2;
         Yi = y2;
         }
      else if(Between(Xt,Yt, x3, y3, x4, y4) > 0)
         {
         ++numint;
         if(numint == 1)
            {
            Xi = Xt;
            Yi = Yt;
            }
         else
            {
            Xi2 = Xt;
            Yi2 = Yt;
            }
         }
      Cn = (A1 * y1) - (B1 * x1);

      /*** find the int of the revised normal to line (x3,y3) - (x4, y4) ***/
      Xt = ((Bn * C2) - (B2 * Cn)) / DetN;
      Yt = ((A2 * Cn) - (An * C2)) / DetN;

      /** is (Xt,Yt) on the segment between (x3,y3) - (x4,y4) ***/
      if(EqualWithinTolerance(x1,y1, x3, y3, 0.000001) > 0)
         {
         ++numint;
         if(numint == 1)
            {
            Xi = x1;
            Yi = y1;
            }
         else
            {
            Xi2 = x1;
            Yi2 = y1;
            }
         }
      else if(EqualWithinTolerance(x1,y1, x4, y3, 0.000001) > 0)
         {
         ++numint;
         if(numint == 1)
            {
            Xi = x1;
            Yi = y1;
            }
         else
            {
            Xi2 = x1;
            Yi2 = y1;
            }
         }
      else if(Between(Xt,Yt, x3, y3, x4, y4) > 0)
         {
         ++numint;
         if(numint == 1)
            {
            Xi = Xt;
            Yi = Yt;
            }
         else
            {
            Xi2 = Xt;
            Yi2 = Yt;
            }
         }

      if(numint == 2) /*** done now so test overlap length and return answer ***/
         {
         dist = Distance(Xi,Yi,Xi2,Yi2);
         if(dist > overlap_length)
            {
            return(1);
            }
         else
            {
            return(0);
            }
         }
      else
         {
         An = B2;
         Bn = 0 - A2;
         Cn = (A2 * y3) - (B2 * x3);

         DetN = (An * B1) - (A1 * Bn);

      /*** find the int of the normal to line (x1,y1) - (x2, y2) ***/
         Xt = ((Bn * C1) - (B1 * Cn)) / DetN;
         Yt = ((A1 * Cn) - (An * C1)) / DetN;

      /** is (xt,yt) on the segment between (x1,y1) - (x2,y2) ***/
         if(Between(Xt,Yt, x1, y1, x2, y2) > 0)
            {
            ++numint;
            if(numint == 1)
               {
               Xi = Xt;
               Yi = Yt;
               }
            else
               {
               Xi2 = Xt;
               Yi2 = Yt;
               }


            if(numint == 2) /*** done now so test overlap length and return answer ***/
               {
               dist = Distance(Xi,Yi,Xi2,Yi2);
               if(dist > overlap_length)
                  {
                  return(1);
                  }
               else
                  {
                  return(0);
                  }
               }
            }
         Cn = (A2 * y4) - (B2 * x4);

      /*** find the int of the revised normal to line (x3,y3) - (x4, y4) ***/
         Xt = ((Bn * C1) - (B1 * Cn)) / DetN;
         Yt = ((A1 * Cn) - (An * C1)) / DetN;

      /** is (Xt,Yt) on the segment between (x3,y3) - (x4,y4) ***/
         if(Between(Xt,Yt, x1, y1, x2, y2) > 0)
            {
            ++numint;
            if(numint == 1)
               {
               Xi = Xt;
               Yi = Yt;
               }
            else
               {
               Xi2 = Xt;
               Yi2 = Yt;
               }
            if(numint == 2) /*** done now so test overlap length and return answer ***/
               {
               dist = Distance(Xi,Yi,Xi2,Yi2);
               if(dist > overlap_length)
                  {
                  return(1);
                  }
               else
                  {
                  return(0);
                  }
               }
            }
         return(0);
         }
}




int ParallelAndAdjacentLineSegments(double x1,double y1,double x2,double y2,
               double x3,double y3,double x4,double y4, double overlap_length)
{
double A1,B1,C1,A2,B2,C2;
double An, Bn, Cn;
double Det, DetN;
double Xi, Yi, Xi2, Yi2, Xt, Yt, dist;
int numint;

   LineEquation(x1,y1,x2,y2,&A1,&B1,&C1);
   LineEquation(x3,y3,x4,y4,&A2,&B2,&C2);
   Det = (A1 * B2) - (A2 * B1);
   if((Det > -0.2) && (Det < 0.2)) /* sufficiently parallel lines to apply remaining test**/
      {

      numint = 0;

      An = B1;
      Bn = 0 - A1;
      Cn = (A1 * y2) - (B1 * x2);

      /** if input lines are parallel, normal to one of them should not be parallel to the other .... ***/
      DetN = (An * B2) - (A2 * Bn);
      if((DetN > -0.00001) && (DetN < 0.00001))  /* should never happen that these two are also parallel ****/
         {
         printf("assumption 1 on parallelism failed\n");
         return(0);
         }

      /*** find the int of the normal to line (x3,y3) - (x4, y4) ***/
      Xt = ((Bn * C2) - (B2 * Cn)) / DetN;
      Yt = ((A2 * Cn) - (An * C2)) / DetN;

      /** is (xt,yt) on the segment between (x3,y3) - (x4,y4) ***/
      if(Between(Xt,Yt, x3, y3, x4, y4) > 0)
         {
         ++numint;
         if(numint == 1)
            {
            Xi = Xt;
            Yi = Yt;
            }
         else
            {
            Xi2 = Xt;
            Yi2 = Yt;
            }
         }
      Cn = (A1 * y1) - (B1 * x1);

      /*** find the int of the revised normal to line (x3,y3) - (x4, y4) ***/
      Xt = ((Bn * C2) - (B2 * Cn)) / DetN;
      Yt = ((A2 * Cn) - (An * C2)) / DetN;

      /** is (Xt,Yt) on the segment between (x3,y3) - (x4,y4) ***/
      if(Between(Xt,Yt, x3, y3, x4, y4) > 0)
         {
         ++numint;
         if(numint == 1)
            {
            Xi = Xt;
            Yi = Yt;
            }
         else
            {
            Xi2 = Xt;
            Yi2 = Yt;
            }
         }
      if(numint == 2) /*** done now so test overlap length and return answer ***/
         {
         dist = Distance(Xi,Yi,Xi2,Yi2);
         if(dist > overlap_length)
            return(1);
         else
            return(0);
         }
      else
         {
         An = B2;
         Bn = 0 - A2;
         Cn = (A2 * y3) - (B2 * x3);

         DetN = (An * B1) - (A1 * Bn);
         if((DetN > -0.00001) && (DetN < 0.00001))  /* should never happen that these two are also parallel ****/
            {
            printf("assumption 1 on parallelism failed\n");
            return(0);
            }

         Xt = ((Bn * C1) - (B1 * Cn)) / DetN;
         Yt = ((A1 * Cn) - (An * C1)) / DetN;

      /** is (xt,yt) on the segment between (x1,y1) - (x2,y2) ***/
         if(Between(Xt,Yt, x1, y1, x2, y2) > 0)
            {
            ++numint;
            if(numint == 1)
               {
               Xi = Xt;
               Yi = Yt;
               }
            else
               {
               Xi2 = Xt;
               Yi2 = Yt;
               }

            if(numint == 2) /*** done now so test overlap length and return answer ***/
               {
               dist = Distance(Xi,Yi,Xi2,Yi2);
               if(dist > overlap_length)
                  return(1);
               else
                  return(0);
               }
            }
/*** revise the normal to line (x3,y3) - (x4,y4) so it goes through point (x4,y4)  **/
         Cn = (A2 * y4) - (B2 * x4);

      /*** find the int of the revised normal to line (x3,y3) - (x4, y4) ***/
         Xt = ((Bn * C1) - (B1 * Cn)) / DetN;
         Yt = ((A1 * Cn) - (An * C1)) / DetN;

      /** is (Xt,Yt) on the segment between (x3,y3) - (x4,y4) ***/
         if(Between(Xt,Yt, x1, y1, x2, y2) > 0)
            {
            ++numint;
            if(numint == 1)
               {
               Xi = Xt;
               Yi = Yt;
               }
            else
               {
               Xi2 = Xt;
               Yi2 = Yt;
               }
            if(numint == 2) /*** done now so test overlap length and return answer ***/
               {
               dist = Distance(Xi,Yi,Xi2,Yi2);
               if(dist > overlap_length)
                  return(1);
               else
                  return(0);
               }
            }
         return(0);
         }
      }
   else
      return(0);
}




void PerformLinearOverUnderChecks(char * prompt, int cindex,struct RawLinear *root,double minx,double miny,double maxx,double maxy, double multiplier,
    int NorthCount, int SouthCount, int EastCount, int WestCount,
    struct RawAreal *Aroot, struct RawAreal *NeighborARoot, struct RawBridge *Broot, struct RawPoint *Proot, struct ListOfEdges *PEroot, struct ListOfEdges *VPEroot,
    struct RawLinear *NLroot, struct ThePolys * Polyroot)
{
struct RawLinear *rlc, *rln,*Nrln, *pairedl1;
struct RawAreal *rac, *ran, *paireda1;
struct RawPoint *rpc;
int i,j,k,jj,kk,km1,km2,km3,km4,i2,i3,checkinstance,onedge;
int pairedIndex,timesthru,endindex,keepit;
int end1, end2, end3, OnEdge, applycheck;
int part1, part2, part3;
int FoundCondition;
int foundpair,fndpr;
int Config1, Strat1, Domain1;
double ptpdist1,ptldist,ptldist2;
double ptpdist2,temp,DistToLMedge,tempx,tempy;
double minxPadded, maxxPadded, minyPadded, maxyPadded;
double mindist1, mindist2;
double minLx,minLy,maxLx,maxLy, tx2, ty2;
double unuseddbl, tolerancepad, tol2;
double pairedflag, T, segmentslope;
double LocalMinX, LocalMaxX, LocalMinY, LocalMaxY;
struct collection
   {
   int keyval;
   int Cnumber;
   int numpoints;
   double x[4];
   double y[4];
   double z[4];
   double magnitude;
   int IDN;
   unsigned int Sindex;
   int vertexindex1, vertexindex2;
   struct RawAreal *aa;
   struct RawBridge *bb;
   struct RawPoint *pp;
   struct ListOfEdges *le;
   struct RawLinear *ll1,*ll2;
   struct ThePolys *poly;
   struct collection * next;
   } *ERroot, *ERc, *ERn;
int SzC = sizeof(struct collection);
   

   ERroot = NULL;

   rlc = root;

   while(rlc != NULL)
      {
       Config1 = SCCtable[rlc->Sindex].C;
       Strat1 = SCCtable[rlc->Sindex].S;
       Domain1 = SCCtable[rlc->Sindex].D;

       for(checkinstance = 0; checkinstance < TtlActiveChecks; checkinstance++)
          {

          if((CombinedCheckApplies(rlc->idn,checkinstance,LELINEPROX,rlc->Lindex,rlc->Sindex,Config1,Strat1,Domain1,&part1,&part2,&part3) > 0) && (part1 > 0))
             {
             j = 0;
             FoundCondition = 0;
             tolerancepad = FindRelevantSensitivity(LELINEPROX,checkinstance,&unuseddbl);
             tol2 = tolerancepad;
             while(j < rlc->numnodes)
                {
                if((rlc->x[j] >= minx) && (rlc->x[j] <= maxx) && (rlc->y[j] >= miny) && (rlc->y[j] <= maxy) &&
                       (LineEndClosesOnItself2D(rlc,j,tolerancepad) == 0))
                   {
                   LocalMinX = rlc->x[j] - tolerancepad - 1;
                   LocalMaxX = rlc->x[j] + tolerancepad + 1;
                   LocalMinY = rlc->y[j] - tolerancepad - 1;
                   LocalMaxY = rlc->y[j] + tolerancepad + 1;
                   mindist1 = mindist2 = tolerancepad * 2.0;
                   pairedl1 = NULL;
                   rln = root;
                         
                   while(rln != NULL)
                      {
                      ptpdist1 = tolerancepad * 2.0;
                      if((rln != rlc) &&
                          (CombinedCheckApplies(rln->idn,checkinstance,LELINEPROX,rln->Lindex,rln->Sindex,
                               SCCtable[rln->Sindex].C,SCCtable[rln->Sindex].S,SCCtable[rln->Sindex].D,&part1,&part2,&part3) > 0) && (part2 > 0)) 
                         {
                         k = 1; 
                         while(k < rln->numnodes )
                            {
                            km1 = k - 1;
                            ptpdist1 = PointToLineDist2DwithFlag(rlc->x[j], rlc->y[j], /**rlc->z[j],**/
                                                   rln->x[km1], rln->y[km1], /**rln->z[km1],**/
                                 rln->x[k], rln->y[k], /**rln->z[k],**/&T);

                            if(ptpdist1 <= tolerancepad)
                               {
                               pairedl1 = rln;
                               pairedIndex = k;
                               pairedflag = T;
                               mindist1 = ptpdist1;
                               FoundCondition = 1;
                               break;
                               }
                            k++;
                            } /*** end while k ***/
                         } /* end rln != rlc ***/
                   
                     if(FoundCondition > 0)
                        {
                        FoundCondition = 0;
                        ERc = (struct collection *) (malloc(SzC));
                        if(ERc == NULL)
                          {
                          printf("allocation memory exhausted during linear feature condition analysis (Z-shear analysis)\n");
                          printf("processing cannot continue\n");
                          exit(-1);
                          }
                        ERc->magnitude = mindist1;
                        ERc->x[0] = rlc->x[j];
                        ERc->y[0] = rlc->y[j];
                        ERc->z[0] = rlc->z[j];
                        if(j == 0)
                           {
                           ERc->x[1] = rlc->x[1];
                           ERc->y[1] = rlc->y[1];
                           ERc->z[1] = rlc->z[1];
                           }
                        else
                           {
                           ERc->x[1] = rlc->x[j-1];
                           ERc->y[1] = rlc->y[j-1];
                           ERc->z[1] = rlc->z[j-1];
                           }
                        if((pairedflag <= 0) || (pairedflag >= 1)) /** then only want a vertex to vertex condition ***/
                           {
                           ERc->numpoints = 2;
                           if(pairedflag <= 0)
                              {
                              ERc->x[2] = pairedl1->x[pairedIndex-1];
                              ERc->y[2] = pairedl1->y[pairedIndex-1];
                              ERc->z[2] = pairedl1->z[pairedIndex-1];
                              }
                           else
                              {
                              ERc->x[2] = pairedl1->x[pairedIndex];
                              ERc->y[2] = pairedl1->y[pairedIndex];
                              ERc->z[2] = pairedl1->z[pairedIndex];
                              }
                           }
                        else
                           {
                           ERc->numpoints = 3;
                           ERc->x[2] = pairedl1->x[pairedIndex];
                           ERc->y[2] = pairedl1->y[pairedIndex];
                           ERc->z[2] = pairedl1->z[pairedIndex];
                           ERc->x[3] = pairedl1->x[pairedIndex-1];
                           ERc->y[3] = pairedl1->y[pairedIndex-1];
                           ERc->z[3] = pairedl1->z[pairedIndex-1];
                           }

                        ERc->IDN = rlc->idn;
                        ERc->Sindex = rlc->Sindex;
                        ERc->aa = NULL; /** RawAreal **/
                        ERc->bb = NULL; /** RawBridge **/
                        ERc->pp = NULL; /** RawPoint **/
                        ERc->le = NULL; /** ListOfEdges **/
                        ERc->poly = NULL; /** ThePolys **/
                        ERc->ll1 = rlc;
                        ERc->ll2 = pairedl1;
                        ERc->keyval = LELINEPROX;
                        ERc->Cnumber = Make_Correct(LELINEPROX,checkinstance);
     
                        if(ERroot == NULL)
                           {
                           ERroot = ERc;
                           ERroot->next = NULL;
                           }
                        else
                           {
                           ERn = ERroot;
                           while(ERn != NULL)
                              {
                              if((ERn->keyval == ERc->keyval) && (ERc->Cnumber == ERn->Cnumber))
                                 {
                                 if((ERn->ll1 == ERc->ll1) && (ERn->ll2 == ERc->ll2))
                                    {
                                    if((ERc->x[0] == ERn->x[0]) && (ERc->y[0] == ERn->y[0]) &&
                                         (ERc->z[0] == ERn->z[0]) && (ERc->x[1] == ERn->x[1]) &&
                                               (ERc->y[1] == ERn->y[1]) && (ERc->z[1] == ERn->z[1]))
                                       {
                                       break;
                                       }
                                    else if((ERc->x[0] == ERn->x[1]) && (ERc->y[0] == ERn->y[1]) &&
                                       (ERc->z[0] == ERn->z[1]) && (ERc->x[1] == ERn->x[0]) &&
                                            (ERc->y[1] == ERn->y[0]) && (ERc->z[1] == ERn->z[0]))
                                       {
                                       break;
                                       }
                                    }
                                 else if((ERn->ll1 == ERc->ll2) && (ERn->ll2 == ERc->ll1))
                                    {
                                    if((ERc->x[0] == ERn->x[0]) && (ERc->y[0] == ERn->y[0]) &&
                                         (ERc->z[0] == ERn->z[0]) && (ERc->x[1] == ERn->x[1]) &&
                                            (ERc->y[1] == ERn->y[1]) && (ERc->z[1] == ERn->z[1]))
                                       {
                                       break;
                                       }
                                    else if((ERc->x[0] == ERn->x[1]) && (ERc->y[0] == ERn->y[1]) &&
                                         (ERc->z[0] == ERn->z[1]) && (ERc->x[1] == ERn->x[0]) &&
                                              (ERc->y[1] == ERn->y[0]) && (ERc->z[1] == ERn->z[0]))
                                       {
                                       break;
                                       }
                                    }
                                 }
                              ERn = ERn->next;
                              }
                           if(ERn == NULL)
                              {
                              ERc->next = ERroot;
                              ERroot = ERc;
                              }
                           else
                              {
                              free(ERc);
                              }
                           }

                        } /*** end FoundCondition ***/
                     rln = rln->next;
                     } /** end while rln looking for interior segment close-to match ***/


                   rac = Aroot;
                   while((rac != NULL) && (FoundCondition == 0))
                      {
                      ptpdist1 = tolerancepad * 2.0;
                      if((CombinedCheckApplies(rac->idn,checkinstance,LELINEPROX,rac->Lindex,rac->Sindex,
                               SCCtable[rac->Sindex].C,SCCtable[rac->Sindex].S,SCCtable[rac->Sindex].D,
                                 &part1,&part2,&part3) > 0) && (part2 > 0))
                         {
                         if(rac->RB_Tree_Edgelist == NULL)
                            ptpdist1 = PointToSmallArealDist2D(rlc->x[j], rlc->y[j],rac,&k,&T);
                         else
                            ptpdist1 = PointToLargeArealDist2D(rlc->x[j], rlc->y[j],rac,&k,&T);

                         if((ptpdist1 > -1.0) && (ptpdist1 <= tol2))
                            {
                            if(rac->RB_Tree_Edgelist == NULL)
                               ptpdist1 = PointToSmallArealDist2D(rlc->x[j], rlc->y[j],rac,&k,&T);
                            else
                               ptpdist1 = PointToLargeArealDist2D(rlc->x[j], rlc->y[j],rac,&k,&T);
                            if((ptpdist1 > -1.0) && (ptpdist1 <= tol2)) /**MGCP_tolerance)) **/
                               {
                               if((rac->ishole <= 0)  && /** it is not a hole ***/
                                  (LinePartOrAllInsideArea(rlc, rac, &i2, &i3,
                                            ActiveChecks[checkinstance].sensitivity, 99.9) == 0))
                                  {
                                  FoundCondition = 1;
                                  break; /** break from the while rac loop ***/
                                  }
                               else if((rac->ishole > 0) &&
                                 (Line_ILA_WithTolerance(rlc,rac,ActiveChecks[checkinstance].sensitivity) > 0))
                                  {
                                  FoundCondition = 1;
                                  break; /** break from the while rac loop ***/
                                  }
                               }
                            }
                         } /* end if combined check applies ***/
                      rac = rac->next;
                      } /** end while rac  ***/
                   if(FoundCondition > 0)
                      {
                      FindEdgeClosestToPoint(rlc->x[j], rlc->y[j], NULL, NULL, rac, &jj);
                      if(jj == 0)
                         end1 = rac->numverts - 1;
                      else
                         end1 = jj - 1;
                      if(jj == rac->numverts - 1)
                         end2 = 0;
                      else
                         end2 = jj + 1;
                      if(j == 0)
                         end3 = j + 1;
                      else
                         end3 = j - 1;
                      if(rlc->x[j] < rlc->x[end3])
                         {
                         minLx = rlc->x[j];   maxLx = rlc->x[end3];
                         }
                      else
                         {
                         minLx = rlc->x[end3];   maxLx = rlc->x[j];
                         }
                      if(rlc->y[j] < rlc->y[end3])
                         {
                         minLy = rlc->y[j];   maxLy = rlc->y[end3];
                         }
                      else
                         {
                         minLy = rlc->y[end3];   maxLy = rlc->y[j];
                         }
                      if(MergeSeg_LineSegmentsOverlap(rlc->x[j],rlc->y[j],rlc->x[end3],rlc->y[end3],
                               rac->x[end1],rac->y[end1],rac->x[jj],rac->y[jj],minLx,maxLx,minLy,maxLy,
                               &tempx, &tempy, &tx2, &ty2, 0.0001 ) > 0)
                         {
                         FoundCondition = 0;
                         }
                      else if(MergeSeg_LineSegmentsOverlap(rlc->x[j],rlc->y[j],rlc->x[end3],rlc->y[end3],
                               rac->x[end2],rac->y[end2],rac->x[jj],rac->y[jj],minLx,maxLx,minLy,maxLy,
                               &tempx, &tempy, &tx2, &ty2, 0.0001 ) > 0)
                         {
                         FoundCondition = 0;
                         }
                      if(FoundCondition > 0)
                         {
                         FoundCondition = 0;
                         ERc = (struct collection *) (malloc(SzC));
                         if(ERc == NULL)
                           {
                           printf("allocation memory exhausted during linear feature condition analysis (Z-shear analysis)\n");
                           printf("processing cannot continue\n");
                           exit(-1);
                           }
                         ERc->magnitude = ptpdist1;
                         ERc->x[0] = rlc->x[j];
                         ERc->y[0] = rlc->y[j];
                         ERc->z[0] = rlc->z[j];
                         if(j == 0)
                            {
                            ERc->x[1] = rlc->x[1];
                            ERc->y[1] = rlc->y[1];
                            ERc->z[1] = rlc->z[1];
                            }
                         else
                            {
                            ERc->x[1] = rlc->x[j-1];
                            ERc->y[1] = rlc->y[j-1];
                            ERc->z[1] = rlc->z[j-1];
                            }
                         ERc->x[2] = rac->x[end1];
                         ERc->y[2] = rac->y[end1];
                         ERc->z[2] = rac->z[end1];
                         ERc->x[3] = rac->x[jj];
                         ERc->y[3] = rac->y[jj];
                         ERc->z[3] = rac->z[jj];

                         ERc->numpoints = 3;

                         ERc->IDN = rlc->idn;
                         ERc->Sindex = rlc->Sindex;
                         ERc->aa = rac; /** RawAreal **/
                         ERc->bb = NULL; /** RawBridge **/
                         ERc->pp = NULL; /** RawPoint **/
                         ERc->le = NULL; /** ListOfEdges **/
                         ERc->poly = NULL; /** ThePolys **/
                         ERc->ll1 = rlc;
                         ERc->ll2 = NULL;
                         ERc->keyval = LELINEPROX;
                         ERc->Cnumber = Make_Correct(LELINEPROX,checkinstance);

                         if(ERroot == NULL)
                            {
                            ERroot = ERc;
                            ERroot->next = NULL;
                            }
                         else
                            {
                            ERn = ERroot;
                            while(ERn != NULL)
                               {
                               if((ERn->keyval == ERc->keyval) && (ERc->Cnumber == ERn->Cnumber))
                                  {
                                  if((ERn->ll1 == ERc->ll1) && (ERn->pp == ERc->pp))
                                     break;
                                     }
                               ERn = ERn->next;
                               }
                            if(ERn == NULL)
                               {
                               ERc->next = ERroot;
                               ERroot = ERc;
                               }
                            else
                               {
                               free(ERc);
                               }
                            }
                         }
                      }
                   } /** end if endpoint[j] is in the load module  ***/

                rpc = Proot;
                while(rpc != NULL)
                   {
                   ptpdist1 = tolerancepad * 2.0;
                   if((rpc->numverts == -1) &&
                       (CombinedCheckApplies(rpc->idn,checkinstance,LELINEPROX,rpc->Lindex,rpc->Sindex,
                            SCCtable[rpc->Sindex].C,SCCtable[rpc->Sindex].S,SCCtable[rpc->Sindex].D,&part1,&part2,&part3) > 0) &&
                                  (part2 > 0))
                      {
                      ptpdist1 = Distance(rlc->x[j], rlc->y[j],rpc->x[0],rpc->y[0]);

                      if(ptpdist1 <= tolerancepad)
                         {
                         ERc = (struct collection *) (malloc(SzC));
                         if(ERc == NULL)
                           {
                           printf("allocation memory exhausted during linear feature condition analysis (Z-shear analysis)\n");
                           printf("processing cannot continue\n");
                           exit(-1);
                           }
                         ERc->magnitude = ptpdist1;
                         ERc->x[0] = rlc->x[j];
                         ERc->y[0] = rlc->y[j];
                         ERc->z[0] = rlc->z[j];
                         if(j == 0)
                            {
                            ERc->x[1] = rlc->x[1];
                            ERc->y[1] = rlc->y[1];
                            ERc->z[1] = rlc->z[1];
                            }
                         else
                            {
                            ERc->x[1] = rlc->x[j-1];
                            ERc->y[1] = rlc->y[j-1];
                            ERc->z[1] = rlc->z[j-1];
                            }
                         ERc->numpoints = 2;
                         ERc->x[2] = rpc->x[0];
                         ERc->y[2] = rpc->y[0];
                         ERc->z[2] = rpc->z[0];

                         ERc->IDN = rlc->idn;
                         ERc->Sindex = rlc->Sindex;
                         ERc->aa = NULL; /** RawAreal **/
                         ERc->bb = NULL; /** RawBridge **/
                         ERc->pp = rpc; /** RawPoint **/
                         ERc->le = NULL; /** ListOfEdges **/
                         ERc->poly = NULL; /** ThePolys **/
                         ERc->ll1 = rlc;
                         ERc->ll2 = NULL;
                         ERc->keyval = LELINEPROX;
                         ERc->Cnumber = Make_Correct(LELINEPROX,checkinstance);

                         if(ERroot == NULL)
                             {
                             ERroot = ERc;
                             ERroot->next = NULL;
                             }
                          else
                             {
                             ERn = ERroot;
                             while(ERn != NULL)
                                {
                                if((ERn->keyval == ERc->keyval) && (ERc->Cnumber == ERn->Cnumber))
                                   {
                                   if((ERn->ll1 == ERc->ll1) && (ERn->pp == ERc->pp))
                                      break;
                                   }
                                ERn = ERn->next;
                                }
                      if(ERn == NULL)
                         {
                         ERc->next = ERroot;
                         ERroot = ERc;
                         }
                      else
                         {
                         free(ERc);
                         }
                             }

                         }
                      } /* end check applies to rpc ***/

                  rpc = rpc->next;
                  } /** end while rpc looking for interior segment close-to match ***/


                j += rlc->numnodes - 1;
                } /*** while j < rlc->numnodes ***/
             } /*** end LELINEPROX check applies to rlc as primary***/




           if((CombinedCheckApplies(rlc->idn,checkinstance,EN_EN_PROX,rlc->Lindex,rlc->Sindex,Config1,Strat1,Domain1,&part1,&part2,&part3) > 0) && (part1 > 0))
             {
             j = 0;
             FoundCondition = 0;
             tol2 = FindRelevantSensitivity(EN_EN_PROX,checkinstance,&tolerancepad);
             while(j < rlc->numnodes)
                {
                if((rlc->x[j] >= minx) && (rlc->x[j] <= maxx) && (rlc->y[j] >= miny) && (rlc->y[j] <= maxy) &&
                       (LineEndClosesOnItself2D(rlc,j,tolerancepad) == 0))
                   {
                   LocalMinX = rlc->x[j] - tolerancepad - 1;
                   LocalMaxX = rlc->x[j] + tolerancepad + 1;
                   LocalMinY = rlc->y[j] - tolerancepad - 1;
                   LocalMaxY = rlc->y[j] + tolerancepad + 1;
                   mindist1 = mindist2 = tolerancepad * 2.0;
                   pairedl1 = NULL;
                   rln = root;
                   while(rln != NULL)
                      {
                      ptpdist1 = tolerancepad * 2.0;
                      if((rln != rlc) &&
                          (CombinedCheckApplies(rln->idn,checkinstance,EN_EN_PROX,rln->Lindex,rln->Sindex,
                               SCCtable[rln->Sindex].C,SCCtable[rln->Sindex].S,SCCtable[rln->Sindex].D,&part1,&part2,&part3) > 0) && (part2 > 0))
                         {
                         k = 0; /** just checking the end nodes here (for both rlc and rln) ***/
                         while(k < rln->numnodes )
                            {
                            if((IsSentinelZvalue(rlc->z[j],UseNUNANPO) == 1) || (IsSentinelZvalue(rln->z[k],UseNUNANPO) == 1))
                               ptpdist1 = Distance(rlc->x[j],rlc->y[j],rln->x[k],rln->y[k]);
                            else
                               ptpdist1 = Distance3D(rlc->x[j],rlc->y[j],rlc->z[j],rln->x[k],rln->y[k],rln->z[k]);
                            if(ptpdist1 <= tol2) /**0.001)**/ /** call these two end nodes a match ***/
                               {
                               break; /** from while rln loop ***/
                               }

                            else if((ptpdist1 < mindist1) && (SensitivityCheck(OPENINT, EN_EN_PROX, checkinstance, ptpdist1) > 0))
                               {
                               if(k == 0)
                                  km1 = 1;
                               else
                                  km1 = k - 1;
                               if(j == 0)
                                  {
                                  ptpdist2 = PointToLineDist2DwithFlag(rlc->x[rlc->numnodes-1], rlc->y[rlc->numnodes-1],
                                         rln->x[km1], rln->y[km1], rln->x[k], rln->y[k],&unuseddbl);
                                  }
                               else
                                  {
                                  ptpdist2 =  PointToLineDist2DwithFlag(rlc->x[0], rlc->y[0],
                                         rln->x[km1], rln->y[km1], rln->x[k], rln->y[k],&unuseddbl);
                                  }
                               if(ptpdist2 > tol2) /**MGCP_tolerance)**/ /** if ptpdist2 < 0.001, call this a match with other endpoint of rlc and don't use it ***/
                                  {
                                  pairedl1 = rln;
                                  pairedIndex = k;
                                  mindist1 = ptpdist1;
                                  }
                               }
                            k += rlc->numnodes - 1;
                            } /*** end while k ***/
                         } /* end rln != rlc ***/
                      if(ptpdist1 <= tol2) /**MGCP_tolerance) **/
                         break;
                      rln = rln->next;
                      } /** end while rln looking for interior segment close-to match ***/
                   if(rln == NULL) /*** did not find an end node to another (interior) node match ***/
                      {
                      if((pairedl1 != NULL) && (SensitivityCheck(OPENINT, EN_EN_PROX, checkinstance, mindist1) > 0)) /*** but did find a close node ***/
                         {
                         FoundCondition = 1;
                         }
                      else /*** look through the neighbor regions for a possible close-to match ***/
                         {
                         foundpair = 0;
                         FoundCondition = 0;
                         Nrln = NLroot;
                         mindist1 = mindist2 = tolerancepad * 2.0;
                         pairedl1 = NULL;
                         while(Nrln != NULL)
                            {
                            if((Nrln->numnodes > 1) &&
                                    (CombinedCheckApplies(Nrln->idn,checkinstance,EN_EN_PROX,Nrln->Lindex,Nrln->Sindex,
                                         SCCtable[Nrln->Sindex].C,SCCtable[Nrln->Sindex].S,SCCtable[Nrln->Sindex].D,&part1,&part2,&part3) > 0) &&
                                                (part2 > 0))
                               {
                               k = 0;
                               while(k < Nrln->numnodes)
                                  {
                                  if((IsSentinelZvalue(rlc->z[j],UseNUNANPO) == 1) || (IsSentinelZvalue(Nrln->z[k],UseNUNANPO) == 1))
                                     ptpdist1 = Distance(rlc->x[j],rlc->y[j],Nrln->x[k],Nrln->y[k]);
                                  else
                                     ptpdist1 = Distance3D(rlc->x[j],rlc->y[j],rlc->z[j],Nrln->x[k],Nrln->y[k],Nrln->z[k]);
                                  if((ptpdist1 < mindist1) && (SensitivityCheck(OPENINT, EN_EN_PROX, checkinstance, ptpdist1) > 0))
                                     {
                                     if(k == 0)
                                        km1 = 1;
                                     else
                                        km1 = k - 1;
                                     if(j == 0)
                                        {
                                        ptpdist2 = PointToLineDist2DwithFlag(rlc->x[rlc->numnodes-1], rlc->y[rlc->numnodes-1],
                                                     Nrln->x[km1], Nrln->y[km1], Nrln->x[k], Nrln->y[k],&unuseddbl);
                                        }
                                     else
                                        {
                                        ptpdist2 =  PointToLineDist2DwithFlag(rlc->x[0], rlc->y[0],
                                               Nrln->x[km1], Nrln->y[km1], Nrln->x[k], Nrln->y[k],&unuseddbl);
                                        }
                                     if(ptpdist2 > tol2) /**MGCP_tolerance)**/ /** if ptpdist2 < 0.001, call this a match with other endpoint of rlc and don't use it ***/
                                        {
                                        pairedl1 = Nrln;
                                        foundpair = 1;
                                        pairedIndex = k;
                                        mindist1 = ptpdist1;
                                        break; /*** break from the while k loop ***/
                                        }
                                     }
                                  k += Nrln->numnodes - 1;
                                  }
                               }

                            if(foundpair > 0)
                               break; /** break from the while Nrln loop ***/
                            Nrln = Nrln->next;
                            } /** end while Nlrn ***/
                         if((pairedl1 != NULL) && (foundpair > 0))
                            {
                            FoundCondition = 1;
                            } /**** end if((pairedl1 != NULL) && (foundpair > 0)) ***/
                         } /*** end else look thru neighbor load module line end nodes ***/
                      } /*** rln == NULL so end if found no end node to interior node match ***/


                   } /** end if endpoint[j] is in the load module  ***/

                if(FoundCondition > 0)
                   {
                   FoundCondition = 0;
                   rln = root;
                   while((rln != NULL) && (FoundCondition == 0))
                      {
                      if((rln != rlc) && 
                            (CombinedCheckApplies(rln->idn,checkinstance,EN_EN_PROX,rln->Lindex,rln->Sindex,
                               SCCtable[rln->Sindex].C,SCCtable[rln->Sindex].S,SCCtable[rln->Sindex].D,&part1,&part2,&part3) > 0) && (part3 > 0))
                         {
                         k = 1;
                         while((k < rln->numnodes ) && (FoundCondition == 0))
                            {
                            km1 = k - 1;
                            ptpdist1 = PointToLineDist2DwithFlag(rlc->x[j], rlc->y[j], rln->x[km1], rln->y[km1], rln->x[k], rln->y[k],&T);
                            if(ptpdist1 <= tol2)
                               {
                               km2 = 1;
                               while(km2 < rln->numnodes)
                                  {
                                  ptpdist1 = PointToLineDist2DwithFlag(pairedl1->x[pairedIndex], pairedl1->y[pairedIndex], rln->x[km1], rln->y[km1], rln->x[k], rln->y[k],&T);
                                  if(ptpdist1 <= tol2)
                                     {
                                     FoundCondition = 1;
                                     break; /** break from the while rac loop ***/
                                     }
                                  ++km2;
                                  }
                               }
                            ++k;
                            }
                         }
                      rln = rln->next;
                      }
                   rac = Aroot;
                   while((rac != NULL) && (FoundCondition == 0))
                      {
                      ptpdist1 = tolerancepad * 2.0;
                      if((CombinedCheckApplies(rac->idn,checkinstance,EN_EN_PROX,rac->Lindex,rac->Sindex,
                               SCCtable[rac->Sindex].C,SCCtable[rac->Sindex].S,SCCtable[rac->Sindex].D,&part1,&part2,&part3) > 0) && (part3 > 0))
                         {
                         if(rac->RB_Tree_Edgelist == NULL)
                            ptpdist1 = PointToSmallArealDist2D(rlc->x[j], rlc->y[j],rac,&k,&T);
                         else
                            ptpdist1 = PointToLargeArealDist2D(rlc->x[j], rlc->y[j],rac,&k,&T);

                         if((ptpdist1 > -1.0) && (ptpdist1 <= tol2)) /**<= MGCP_tolerance)) **/
                            {
                            if(rac->RB_Tree_Edgelist == NULL)
                               ptpdist1 = PointToSmallArealDist2D(pairedl1->x[pairedIndex], pairedl1->y[pairedIndex],rac,&k,&T);
                            else
                               ptpdist1 = PointToLargeArealDist2D(pairedl1->x[pairedIndex], pairedl1->y[pairedIndex],rac,&k,&T);
                            if((ptpdist1 > -1.0) && (ptpdist1 <= tol2)) /**MGCP_tolerance)) **/
                               {
                               FoundCondition = 1;
                               break; /** break from the while rac loop ***/
                               }
                            }
                         } /* end if combined check applies ***/
                      rac = rac->next;
                      } /** end while rac looking for interior segment close-to match ***/
                   }

                if(FoundCondition > 0) /** need to add a condition to the list ***/
                   {
                   FoundCondition = 0;
                   ERc = (struct collection *) (malloc(SzC));
                   if(ERc == NULL)
                     {
                     printf("allocation memory exhausted during linear feature condition analysis (Z-shear analysis)\n");
                     printf("processing cannot continue\n");
                     exit(-1);
                     }
                   ERc->magnitude = mindist1;
                   ERc->x[0] = rlc->x[j];
                   ERc->y[0] = rlc->y[j];
                   ERc->z[0] = rlc->z[j];
                   ERc->numpoints = 2;
                         
                   ERc->x[1] = pairedl1->x[pairedIndex];
                   ERc->y[1] = pairedl1->y[pairedIndex];
                   ERc->z[1] = pairedl1->z[pairedIndex];

                   ERc->IDN = rlc->idn;
                   ERc->Sindex = rlc->Sindex;
                   ERc->aa = NULL; /** RawAreal **/
                   ERc->bb = NULL; /** RawBridge **/
                   ERc->pp = NULL; /** RawPoint **/
                   ERc->le = NULL; /** ListOfEdges **/
                   ERc->poly = NULL; /** ThePolys **/
                   ERc->ll1 = rlc;
                   ERc->ll2 = pairedl1;
                   ERc->keyval = EN_EN_PROX;
                   ERc->Cnumber = Make_Correct(EN_EN_PROX,checkinstance);

                   if(ERroot == NULL)
                      {
                      ERroot = ERc;
                      ERroot->next = NULL;
                      }
                   else
                      {
                      ERn = ERroot;
                      while(ERn != NULL)
                         {
                         if((ERn->keyval == ERc->keyval) && (ERc->Cnumber == ERn->Cnumber))
                            {
                            if((ERn->ll1 == ERc->ll1) && (ERn->ll2 == ERc->ll2))
                               {
                               if((ERc->x[0] == ERn->x[0]) && (ERc->y[0] == ERn->y[0]) && (ERc->z[0] == ERn->z[0]) &&
                                      (ERc->x[1] == ERn->x[1]) && (ERc->y[1] == ERn->y[1]) && (ERc->z[1] == ERn->z[1]))
                                  {
                                  break;
                                  }
                               else if((ERc->x[0] == ERn->x[1]) && (ERc->y[0] == ERn->y[1]) && (ERc->z[0] == ERn->z[1]) &&
                                      (ERc->x[1] == ERn->x[0]) && (ERc->y[1] == ERn->y[0]) && (ERc->z[1] == ERn->z[0]))
                                  {
                                  break;
                                  }
                               }
                            else if((ERn->ll1 == ERc->ll2) && (ERn->ll2 == ERc->ll1))
                               {
                               if((ERc->x[0] == ERn->x[0]) && (ERc->y[0] == ERn->y[0]) && (ERc->z[0] == ERn->z[0]) &&
                                      (ERc->x[1] == ERn->x[1]) && (ERc->y[1] == ERn->y[1]) && (ERc->z[1] == ERn->z[1]))
                                  {
                                  break;
                                  }
                               else if((ERc->x[0] == ERn->x[1]) && (ERc->y[0] == ERn->y[1]) && (ERc->z[0] == ERn->z[1]) &&
                                      (ERc->x[1] == ERn->x[0]) && (ERc->y[1] == ERn->y[0]) && (ERc->z[1] == ERn->z[0]))
                                  {
                                  break;
                                  }
                               }
                            }
                         ERn = ERn->next;
                         }
                      if(ERn == NULL)
                         {
                         ERc->next = ERroot;
                         ERroot = ERc;
                         }
                      else
                         {
                         free(ERc);
                         }
                      }

                   } /*** end FoundCondition ***/
                j += rlc->numnodes - 1;
                } /*** while j < rlc->numnodes ***/
             } /*** end EN_EN_PROX check applies ***/



          if((CombinedCheckApplies(rlc->idn,checkinstance,LUSHTL_CLEAN,rlc->Lindex,rlc->Sindex,Config1,Strat1,Domain1,&part1,&part2,&part3) > 0) && (part1 > 0))
             {
             j = 0;
             FoundCondition = 0;
             tol2 = FindRelevantSensitivity(LUSHTL_CLEAN,checkinstance,&tolerancepad);
             while(j < rlc->numnodes)
                {
                if((rlc->x[j] >= minx) && (rlc->x[j] <= maxx) && (rlc->y[j] >= miny) && (rlc->y[j] <= maxy) &&
                       (LineEndClosesOnItself2D(rlc,j,tolerancepad) == 0))
                   {
                   LocalMinX = rlc->x[j] - tolerancepad - 1;
                   LocalMaxX = rlc->x[j] + tolerancepad + 1;
                   LocalMinY = rlc->y[j] - tolerancepad - 1;
                   LocalMaxY = rlc->y[j] + tolerancepad + 1;
                   mindist1 = mindist2 = tolerancepad * 2.0;
                   pairedl1 = NULL;
                   rln = root;
                   while(rln != NULL)
                      {
                      ptpdist1 = tolerancepad * 2.0;
                      if((rln != rlc) &&
                          (CombinedCheckApplies(rln->idn,checkinstance,LUSHTL_CLEAN,rln->Lindex,rln->Sindex,
                               SCCtable[rln->Sindex].C,SCCtable[rln->Sindex].S,SCCtable[rln->Sindex].D,&part1,&part2,&part3) > 0) && (part1 > 0))
                         {
                         k = 1;
                         while(k < rln->numnodes )
                            {
                            km1 = k - 1;
                            ptpdist1 = PointToLineDist2DwithFlag(rlc->x[j], rlc->y[j], rln->x[km1], rln->y[km1], rln->x[k], rln->y[k],&T);
                            if(ptpdist1 <= tol2) /**MGCP_tolerance)**/ /** call these two end nodes a match ***/
                               {
                               break; /** from while rln loop ***/
                               }

                            else if((ptpdist1 < mindist1) && (SensitivityCheck(OPENINT, LUSHTL_CLEAN, checkinstance, ptpdist1) > 0))
                               {
                               if(j == 0)                                   {
                                  ptpdist2 = PointToLineDist2DwithFlag(rlc->x[rlc->numnodes-1], rlc->y[rlc->numnodes-1],
                                         rln->x[km1], rln->y[km1], rln->x[k], rln->y[k],&unuseddbl);
                                  }
                               else
                                  {                                   ptpdist2 =  PointToLineDist2DwithFlag(rlc->x[0], rlc->y[0],
                                         rln->x[km1], rln->y[km1], rln->x[k], rln->y[k],&unuseddbl);
                                  }                                if(ptpdist2 > tol2)
                                  {
                                  if(LimitedTwoLinesIntersect(rlc,j,rln) == 0)
                                     {
                                     pairedl1 = rln;                                      pairedIndex = k;
                                     pairedflag = T;                                      mindist1 = ptpdist1;
                                     }
                                  }
                               }
                            k++;
                            } /*** end while k ***/
                         } /* end rln != rlc ***/
                      if(ptpdist1 <= tol2) /**MGCP_tolerance)**/
                         break;
                      rln = rln->next;
                      } /** end while rln looking for interior segment close-to match ***/
                   if(rln == NULL) /*** did not find an end node to another (interior) node match ***/
                      {
                      if((pairedl1 != NULL) && (SensitivityCheck(OPENINT, LUSHTL_CLEAN, checkinstance, mindist1) > 0)) /*** but did find a close node ***/
                         {
                         FoundCondition = 1;
                         }
                      else
                         {
                         foundpair = 0;
                         FoundCondition = 0;
                         Nrln = NLroot;
                         mindist1 = mindist2 = tolerancepad * 2.0;
                         pairedl1 = NULL;
                         while(Nrln != NULL)
                            {
                            if((Nrln->numnodes > 1) &&
                                    (CombinedCheckApplies(Nrln->idn,checkinstance,LUSHTL_CLEAN,Nrln->Lindex,Nrln->Sindex,
                                         SCCtable[Nrln->Sindex].C,SCCtable[Nrln->Sindex].S,SCCtable[Nrln->Sindex].D,&part1,&part2,&part3) > 0) &&
                                                (part1 > 0))
                               {
                               k = 1;
                               while(k < Nrln->numnodes)
                                  {
                                  km1 = k - 1;
                                  ptpdist1 = PointToLineDist2DwithFlag(rlc->x[j], rlc->y[j], Nrln->x[km1], Nrln->y[km1], Nrln->x[k], Nrln->y[k],&T);
                                  if((ptpdist1 < mindist1) && (SensitivityCheck(OPENINT, LUSHTL_CLEAN, checkinstance, ptpdist1) > 0))
                                     {
                                     if(j == 0)
                                        {
                                        ptpdist2 = PointToLineDist2DwithFlag(rlc->x[rlc->numnodes-1], rlc->y[rlc->numnodes-1],
                                                     Nrln->x[km1], Nrln->y[km1], Nrln->x[k], Nrln->y[k],&unuseddbl);
                                        }
                                     else
                                        {
                                        ptpdist2 =  PointToLineDist2DwithFlag(rlc->x[0], rlc->y[0],
                                               Nrln->x[km1], Nrln->y[km1], Nrln->x[k], Nrln->y[k],&unuseddbl);
                                        }
                                     if(ptpdist2 > tol2)
                                        {
                                        if(LimitedTwoLinesIntersect(rlc,j,Nrln) == 0)
                                           
                                           {
                                           pairedl1 = Nrln;
                                           foundpair = 1;
                                           pairedIndex = k;
                                           mindist1 = ptpdist1;
                                           pairedflag = T;
                                           break; /*** break from the while k loop ***/
                                           }
                                        }
                                     }
                                  ++k;
                                  }
                               }

                            if(foundpair > 0)
                               break; /** break from the while Nrln loop ***/
                            Nrln = Nrln->next;
                            } /** end while Nlrn ***/
                         if((pairedl1 != NULL) && (foundpair > 0))
                            {
                            FoundCondition = 1;
                            } /**** end if((pairedl1 != NULL) && (foundpair > 0)) ***/
                         } /*** end else look thru neighbor load module line end nodes ***/
                      } /*** rln == NULL so end if found no end node to interior node match ***/


                   } /** end if endpoint[j] is in the load module  ***/

                if(FoundCondition > 0) /*** should this report be removed based on undershoot between parallel lines?   ****/
                   {
                   if(mindist1 > ActiveChecks[checkinstance].sensitivity3)
                      {
                      if(j == 0)
                         km4 = 1;
                      else
                         km4 = 0 - 1;
                      km1 = j + km4;
                      unuseddbl = Distance(rlc->x[j],rlc->y[j],rlc->x[km1],rlc->y[km1]);
                      while((unuseddbl < ActiveChecks[checkinstance].sensitivity4) &&
                               (km1 > 0) && (km1 < (rlc->numnodes - 1)))
                         {
                         km1 += km4;
                         unuseddbl = Distance(rlc->x[j],rlc->y[j],rlc->x[km1],rlc->y[km1]);
                         }

                      if(pairedIndex == 0)
                         km4 = 1;
                      else
                         km4 = 0 - 1;
                      km2 = pairedIndex + km4;

                      unuseddbl = Distance(pairedl1->x[pairedIndex],pairedl1->y[pairedIndex],
                                           pairedl1->x[km2],pairedl1->y[km2]);
                      while((unuseddbl < ActiveChecks[checkinstance].sensitivity4) &&
                               (km2 > 0) && (km2 < (pairedl1->numnodes - 1)))
                         {
                         km2 += km4;
                         unuseddbl = Distance(pairedl1->x[pairedIndex],pairedl1->y[pairedIndex],
                                           pairedl1->x[km2],pairedl1->y[km2]);
                         }
                      if(ParallelAndAdjacentLineSegments(rlc->x[j],rlc->y[j],rlc->x[km1],rlc->y[km1],
                            pairedl1->x[pairedIndex],pairedl1->y[pairedIndex],pairedl1->x[km2],pairedl1->y[km2],
                                ActiveChecks[checkinstance].sensitivity4) > 0)
                         FoundCondition = 0;
                      }
                   }

                if(FoundCondition > 0) /** could a secondary participant lie between the undershoot nodes? **/
                   {
                   if(pairedflag <= 0)
                      {
                      tempx = pairedl1->x[pairedIndex-1];
                      tempy = pairedl1->y[pairedIndex-1];
                      }
                   else if(pairedflag >= 1)
                      {
                      tempx = pairedl1->x[pairedIndex];
                      tempy = pairedl1->y[pairedIndex];
                      }
                   else
                      {
                      tempx = pairedl1->x[pairedIndex] + ((pairedl1->x[pairedIndex-1] - pairedl1->x[pairedIndex]) / 2.0);
                      tempy = pairedl1->y[pairedIndex] + ((pairedl1->y[pairedIndex-1] - pairedl1->y[pairedIndex]) / 2.0);
                      }
                   rln = root;
                   while((rln != NULL) && (FoundCondition > 0))
                      {
                      if((rln != rlc) && (rln != pairedl1) &&
                        (CombinedCheckApplies(rln->idn,checkinstance,LUSHTL_CLEAN,rln->Lindex,rln->Sindex,
                            SCCtable[rln->Sindex].C,SCCtable[rln->Sindex].S,SCCtable[rln->Sindex].D,
                            &part1,&part2,&part3) > 0) && (part2 > 0))
                         {
                         for(kk=1; kk<rln->numnodes; kk++)
                            {
                            if(LineSegmentsIntersect(rlc->x[j],rlc->y[j],tempx,tempy,
                                     rln->x[kk],rln->y[kk],rln->x[kk-1],rln->y[kk-1],&unuseddbl,&temp) > 0)
                               {
                               FoundCondition = 0;
                               break;
                               }
                            }
                         }
                      rln = rln->next;
                      }
                   }

                if(FoundCondition > 0) /*** could proximity to a tertiary participant nullify the condition? ***/
                   {
                   rln = root;
                   while((rln != NULL) && (FoundCondition > 0))
                      {
                      ptpdist1 = tolerancepad * 2.0;
                      if((rln != rlc) &&
                          (CombinedCheckApplies(rln->idn,checkinstance,LUSHTL_CLEAN,rln->Lindex,rln->Sindex,
                               SCCtable[rln->Sindex].C,SCCtable[rln->Sindex].S,SCCtable[rln->Sindex].D,&part1,&part2,&part3) > 0) && (part3 > 0))
                         {
                         k = 1;
                         while(k < rln->numnodes )
                            {
                            km1 = k - 1;
                            ptpdist1 = PointToLineDist2DwithFlag(rlc->x[j], rlc->y[j], rln->x[km1], rln->y[km1], rln->x[k], rln->y[k],&T);
                            if(ptpdist1 <= tol2) /**MGCP_tolerance)**/ /** call these two end nodes a match ***/
                               {
                               FoundCondition = 0;
                               break; /** from while rln loop ***/
                               }
                            ++k;
                            }
                         } /** end if check applies as part3 ***/                       rln = rln->next;
                      } /** end while rln ***/
                   rln = NLroot;
                   while((rln != NULL) && (FoundCondition > 0))
                      {
                      ptpdist1 = tolerancepad * 2.0;
                      if((rln != rlc) &&
                          (CombinedCheckApplies(rln->idn,checkinstance,LUSHTL_CLEAN,rln->Lindex,rln->Sindex,
                               SCCtable[rln->Sindex].C,SCCtable[rln->Sindex].S,SCCtable[rln->Sindex].D,&part1,&part2,&part3) > 0) && (part3 > 0))
                         {
                         k = 1;
                         while(k < rln->numnodes )
                            {
                            km1 = k - 1;
                            ptpdist1 = PointToLineDist2DwithFlag(rlc->x[j], rlc->y[j], rln->x[km1], rln->y[km1], rln->x[k], rln->y[k],&T);
                            if(ptpdist1 <= tol2) /**MGCP_tolerance)**/ /** call these two end nodes a match ***/
                               {
                               FoundCondition = 0;
                               break; /** from while rln loop ***/
                               }
                            ++k;
                            }
                         } /** end if check applies as part3 ***/
                      rln = rln->next;
                      } /** end while rln ***/

                   rac = Aroot;
                   while((rac != NULL) && (FoundCondition > 0))
                      {
                      ptpdist1 = tolerancepad * 2.0;
                      if((CombinedCheckApplies(rac->idn,checkinstance,LUSHTL_CLEAN,rac->Lindex,rac->Sindex,
                               SCCtable[rac->Sindex].C,SCCtable[rac->Sindex].S,SCCtable[rac->Sindex].D,&part1,&part2,&part3) > 0) && (part3 > 0))
                         {
                         if(rac->RB_Tree_Edgelist == NULL)
                            ptpdist1 = PointToSmallArealDist2D(rlc->x[j], rlc->y[j],rac,&k,&T);
                         else
                            ptpdist1 = PointToLargeArealDist2D(rlc->x[j], rlc->y[j],rac,&k,&T);

                         if((ptpdist1 > -1.0) && (ptpdist1 <= tol2)) /**<= MGCP_tolerance)) **/
                            {
                            FoundCondition = 0;
                            break; /** break from the while rac loop ***/
                            }
                         } /* end if combined check applies ***/
                      rac = rac->next;
                      } /** end while rac looking for interior segment close-to match ***/
                   }

                if(FoundCondition > 0)
                   {
                   if(j == 0)
                      {
                      keepit = ConditionOnDataEdge(rlc->x[0],rlc->y[0],rlc->x[1],rlc->y[1],Aroot,Proot,root,
                                                   NULL, NULL, rlc,
                                                   NorthCount,SouthCount,EastCount,WestCount,checkinstance);
                      }
                   else                       {
                      keepit = ConditionOnDataEdge(rlc->x[j],rlc->y[j],rlc->x[j-1],rlc->y[j-1],Aroot,Proot,root,
                                                   NULL, NULL, rlc,
                                                   NorthCount,SouthCount,EastCount,WestCount,checkinstance);
                      }
                   if(keepit <= 0)
                      FoundCondition = 0;
                   }


                if(FoundCondition > 0) /** need to add a condition to the list ***/
                   {
                   FoundCondition = 0;
                   ERc = (struct collection *) (malloc(SzC));
                   if(ERc == NULL)
                     {
                     printf("allocation memory exhausted during linear feature condition analysis (Z-shear analysis)\n");
                     printf("processing cannot continue\n");
                     exit(-1);
                     }
                   ERc->magnitude = mindist1;
                   ERc->x[0] = rlc->x[j];
                   ERc->y[0] = rlc->y[j];
                   ERc->z[0] = rlc->z[j];
                   if((pairedflag <= 0) || (pairedflag >= 1)) /** then only want a vertex to vertex condition ***/
                      {
                      ERc->numpoints = 2;
                      if(pairedflag <= 0)
                         {
                         ERc->x[1] = pairedl1->x[pairedIndex-1];
                         ERc->y[1] = pairedl1->y[pairedIndex-1];
                         ERc->z[1] = pairedl1->z[pairedIndex-1];
                         }
                      else
                         {
                         ERc->x[1] = pairedl1->x[pairedIndex];
                         ERc->y[1] = pairedl1->y[pairedIndex];
                         ERc->z[1] = pairedl1->z[pairedIndex];
                         }
                      }
                   else
                      {
                      ERc->numpoints = 3;
                      ERc->x[1] = pairedl1->x[pairedIndex];
                      ERc->y[1] = pairedl1->y[pairedIndex];
                      ERc->z[1] = pairedl1->z[pairedIndex];
                      ERc->x[2] = pairedl1->x[pairedIndex-1];
                      ERc->y[2] = pairedl1->y[pairedIndex-1];
                      ERc->z[2] = pairedl1->z[pairedIndex-1];
                      }

                   ERc->IDN = rlc->idn;                    ERc->Sindex = rlc->Sindex;
                   ERc->aa = NULL; /** RawAreal **/
                   ERc->bb = NULL; /** RawBridge **/
                   ERc->pp = NULL; /** RawPoint **/
                   ERc->le = NULL; /** ListOfEdges **/
                   ERc->poly = NULL; /** ThePolys **/
                   ERc->ll1 = rlc;
                   ERc->ll2 = pairedl1;
                   ERc->keyval = LUSHTL_CLEAN;
                   ERc->Cnumber = Make_Correct(LUSHTL_CLEAN,checkinstance);

                   if(ERroot == NULL)
                      {
                      ERroot = ERc;
                      ERroot->next = NULL;
                      }
                   else
                      {
                      ERn = ERroot;
                      while(ERn != NULL)
                         {
                         if((ERn->keyval == ERc->keyval) && (ERc->Cnumber == ERn->Cnumber))
                            {
                            if((ERn->ll1 == ERc->ll1) && (ERn->ll2 == ERc->ll2))
                               {
break;
                               }
                            else if((ERn->ll1 == ERc->ll2) && (ERn->ll2 == ERc->ll1))
                               {
break;                                }
                            }                          ERn = ERn->next;
                         }
                      if(ERn == NULL)
                         {
                         ERc->next = ERroot;
                         ERroot = ERc;
                         }
                      else
                         {
                         free(ERc);
                         }
                      }

                   } /*** end FoundCondition ***/
                j += rlc->numnodes - 1;
                } /*** while j < rlc->numnodes ***/
             } /*** end LUSHTL_CLEAN check applies ***/







          if((CombinedCheckApplies(rlc->idn,checkinstance,LUNDERSHTL,rlc->Lindex,rlc->Sindex,Config1,Strat1,Domain1,&part1,&part2,&part3) > 0) && (part1 > 0))
             {
             j = 0;
             FoundCondition = 0;
             tol2 = FindRelevantSensitivity(LUNDERSHTL,checkinstance,&tolerancepad);
             while(j < rlc->numnodes)
                {
                if((rlc->x[j] >= minx) && (rlc->x[j] <= maxx) && (rlc->y[j] >= miny) && (rlc->y[j] <= maxy) &&
                       (LineEndClosesOnItself2D(rlc,j,tolerancepad) == 0))
                   {
                   LocalMinX = rlc->x[j] - tolerancepad - 1;
                   LocalMaxX = rlc->x[j] + tolerancepad + 1;
                   LocalMinY = rlc->y[j] - tolerancepad - 1;
                   LocalMaxY = rlc->y[j] + tolerancepad + 1;
                   mindist1 = mindist2 = tolerancepad * 2.0;
                   pairedl1 = NULL;
                   rln = root;
                   
                   while(rln != NULL)
                      {
                      ptpdist1 = tolerancepad * 2.0;
                      if((rln != rlc) &&
                          (CombinedCheckApplies(rln->idn,checkinstance,LUNDERSHTL,rln->Lindex,rln->Sindex,
                               SCCtable[rln->Sindex].C,SCCtable[rln->Sindex].S,SCCtable[rln->Sindex].D,&part1,&part2,&part3) > 0) && (part2 > 0))
                         {
                         k = 1; /** start at 1, end before rln->numnodes - 1 since already checked all the end nodes ***/
                         while(k < rln->numnodes )
                            {
                            km1 = k - 1;
                            ptpdist1 = PointToLineDist2DwithFlag(rlc->x[j], rlc->y[j], rln->x[km1], rln->y[km1], rln->x[k], rln->y[k],&T);
                            if(ptpdist1 <= tol2) /**MGCP_tolerance)**/ /** call these two end nodes a match ***/
                               {
                               break; /** from while rln loop ***/
                               }

                            else if((ptpdist1 < mindist1) && (SensitivityCheck(OPENINT, LUNDERSHTL, checkinstance, ptpdist1) > 0))
                               {
                               if(j == 0)
                                  {
                                  ptpdist2 = PointToLineDist2DwithFlag(rlc->x[rlc->numnodes-1], rlc->y[rlc->numnodes-1],
                                         rln->x[km1], rln->y[km1], rln->x[k], rln->y[k],&unuseddbl);
                                  }
                               else
                                  {
                                  ptpdist2 =  PointToLineDist2DwithFlag(rlc->x[0], rlc->y[0],
                                         rln->x[km1], rln->y[km1], rln->x[k], rln->y[k],&unuseddbl);
                                  }
                               if(ptpdist2 > tol2) /**MGCP_tolerance)**/ /** if ptpdist2 < 0.001, call this a match with other endpoint of rlc and don't use it ***/
                                  {
                                  if(LimitedTwoLinesIntersect(rlc,j,rln) == 0) /** this is the difference between under and over shoots - no int on undershoot **/
                                     {
                                     pairedl1 = rln;
                                     pairedIndex = k;
                                     pairedflag = T;
                                     mindist1 = ptpdist1;
                                     }
                                  }
                               }
                            k++;
                            } /*** end while k ***/
                         } /* end rln != rlc ***/
                      if(ptpdist1 <= tol2) /**MGCP_tolerance)**/
                         break;
                      rln = rln->next;
                      } /** end while rln looking for interior segment close-to match ***/
                   if(rln == NULL) /*** did not find an end node to another (interior) node match ***/
                      {
                      if((pairedl1 != NULL) && (SensitivityCheck(OPENINT, LUNDERSHTL, checkinstance, mindist1) > 0)) /*** but did find a close node ***/
                         {
                         FoundCondition = 1;
                         }
                      else
                         {
                         foundpair = 0;
                         FoundCondition = 0;
                         Nrln = NLroot;
                         mindist1 = mindist2 = tolerancepad * 2.0;
                         pairedl1 = NULL;
                         while(Nrln != NULL)
                            {
                            if((Nrln->numnodes > 1) &&
                                    (CombinedCheckApplies(Nrln->idn,checkinstance,LUNDERSHTL,Nrln->Lindex,Nrln->Sindex,
                                         SCCtable[Nrln->Sindex].C,SCCtable[Nrln->Sindex].S,SCCtable[Nrln->Sindex].D,&part1,&part2,&part3) > 0) &&
                                                (part2 > 0))
                               {
                               k = 1;
                               while(k < Nrln->numnodes)
                                  {
                                  km1 = k - 1;
                                  ptpdist1 = PointToLineDist2DwithFlag(rlc->x[j], rlc->y[j], Nrln->x[km1], Nrln->y[km1], Nrln->x[k], Nrln->y[k],&T);

                                  if(ptpdist1 <= tol2) /**MGCP_tolerance)**/ /** call these two end nodes a match ***/
                                     {
                                     break; /** from while rln loop ***/
                                     }

                                  else if((ptpdist1 < mindist1) && (SensitivityCheck(OPENINT, LUNDERSHTL, checkinstance, ptpdist1) > 0))
                                     {
                                     if(j == 0)
                                        {
                                        ptpdist2 = PointToLineDist2DwithFlag(rlc->x[rlc->numnodes-1], rlc->y[rlc->numnodes-1],
                                                     Nrln->x[km1], Nrln->y[km1], Nrln->x[k], Nrln->y[k],&unuseddbl);
                                        }
                                     else
                                        {
                                        ptpdist2 =  PointToLineDist2DwithFlag(rlc->x[0], rlc->y[0],
                                               Nrln->x[km1], Nrln->y[km1], Nrln->x[k], Nrln->y[k],&unuseddbl);
                                        }
                                     if(ptpdist2 > tol2)
                                        {
                                        if(LimitedTwoLinesIntersect(rlc,j,Nrln) == 0)
                                           {
                                           pairedl1 = Nrln;
                                           foundpair = 1;
                                           pairedIndex = k;
                                           mindist1 = ptpdist1;
                                           pairedflag = T;
                                           break; /*** break from the while k loop ***/
                                           }
                                        }
                                     }
                                  ++k;
                                  }
                               }

                            if(foundpair > 0)
                               break; /** break from the while Nrln loop ***/
                            Nrln = Nrln->next;
                            } /** end while Nlrn ***/
                         if((pairedl1 != NULL) && (foundpair > 0))
                            {
                            FoundCondition = 1;
                            } /**** end if((pairedl1 != NULL) && (foundpair > 0)) ***/
                         } /*** end else look thru neighbor load module line end nodes ***/
                      } /*** rln == NULL so end if found no end node to interior node match ***/


                   } /** end if endpoint[j] is in the load module  ***/

                if(FoundCondition > 0)
                   {
                   if(mindist1 > ActiveChecks[checkinstance].sensitivity3)
                      {
                      if(j == 0)
                         km4 = 1;
                      else
                         km4 = 0 - 1;
                      km1 = j + km4;
                      unuseddbl = Distance(rlc->x[j],rlc->y[j],rlc->x[km1],rlc->y[km1]);
                      while((unuseddbl < ActiveChecks[checkinstance].sensitivity4) &&
                               (km1 > 0) && (km1 < (rlc->numnodes - 1)))
                         {
                         km1 += km4;
                         unuseddbl = Distance(rlc->x[j],rlc->y[j],rlc->x[km1],rlc->y[km1]);
                         }
                          
                      if(pairedIndex == 0)
                         km4 = 1;
                      else
                         km4 = 0 - 1;
                      km2 = pairedIndex + km4;

                      unuseddbl = Distance(pairedl1->x[pairedIndex],pairedl1->y[pairedIndex],
                                           pairedl1->x[km2],pairedl1->y[km2]);
                      while((unuseddbl < ActiveChecks[checkinstance].sensitivity4) &&
                               (km2 > 0) && (km2 < (pairedl1->numnodes - 1)))
                         {
                         km2 += km4;
                         unuseddbl = Distance(pairedl1->x[pairedIndex],pairedl1->y[pairedIndex],
                                           pairedl1->x[km2],pairedl1->y[km2]);
                         }
                      if(ParallelAndAdjacentLineSegments(rlc->x[j],rlc->y[j],rlc->x[km1],rlc->y[km1],
                            pairedl1->x[pairedIndex],pairedl1->y[pairedIndex],pairedl1->x[km2],pairedl1->y[km2],
                                ActiveChecks[checkinstance].sensitivity4) > 0)
                         FoundCondition = 0;
                      }
                   }
                   
                if(FoundCondition > 0) /*** could proximity to a tertiary participant nullify the condition?   ***/
                   {
                   rln = root;
                   while((rln != NULL) && (FoundCondition > 0))
                      {
                      ptpdist1 = tolerancepad * 2.0;
                      if((rln != rlc) &&
                          (CombinedCheckApplies(rln->idn,checkinstance,LUNDERSHTL,rln->Lindex,rln->Sindex,
                               SCCtable[rln->Sindex].C,SCCtable[rln->Sindex].S,SCCtable[rln->Sindex].D,&part1,&part2,&part3) > 0) && (part3 > 0))
                         {
                         k = 1; 
                         while(k < rln->numnodes )
                            {
                            km1 = k - 1;
                            ptpdist1 = PointToLineDist2DwithFlag(rlc->x[j], rlc->y[j], rln->x[km1], rln->y[km1], rln->x[k], rln->y[k],&T);
                            if(ptpdist1 <= tol2) /**MGCP_tolerance)**/ /** call these two end nodes a match ***/
                               {
                               FoundCondition = 0;
                               break; /** from while rln loop ***/
                               }
                            ++k;
                            }
                         } /** end if check applies as part3 ***/
                      rln = rln->next;
                      } /** end while rln ***/

                   rln = NLroot;
                   while((rln != NULL) && (FoundCondition > 0))
                      {
                      ptpdist1 = tolerancepad * 2.0;
                      if((rln != rlc) &&
                          (CombinedCheckApplies(rln->idn,checkinstance,LUNDERSHTL,rln->Lindex,rln->Sindex,
                               SCCtable[rln->Sindex].C,SCCtable[rln->Sindex].S,SCCtable[rln->Sindex].D,&part1,&part2,&part3) > 0) && (part3 > 0))
                         {
                         k = 1;
                         while(k < rln->numnodes )
                            {
                            km1 = k - 1;
                            ptpdist1 = PointToLineDist2DwithFlag(rlc->x[j], rlc->y[j], rln->x[km1], rln->y[km1], rln->x[k], rln->y[k],&T);
                            if(ptpdist1 <= tol2) /**MGCP_tolerance)**/ /** call these two end nodes a match ***/
                               {
                               FoundCondition = 0;
                               break; /** from while rln loop ***/
                               }
                            ++k;
                            }
                         } /** end if check applies as part3 ***/
                      rln = rln->next;
                      } /** end while rln ***/

/*** see if a qualified area features bridges the gap ****/
                   rac = Aroot;
                   while((rac != NULL) && (FoundCondition > 0))
                      {
                      ptpdist1 = tolerancepad * 2.0;
                      if((CombinedCheckApplies(rac->idn,checkinstance,LUNDERSHTL,rac->Lindex,rac->Sindex,
                               SCCtable[rac->Sindex].C,SCCtable[rac->Sindex].S,SCCtable[rac->Sindex].D,&part1,&part2,&part3) > 0) && (part3 > 0))
                         {
                         if(rac->RB_Tree_Edgelist == NULL)
                            ptpdist1 = PointToSmallArealDist2D(rlc->x[j], rlc->y[j],rac,&k,&T);
                         else
                            ptpdist1 = PointToLargeArealDist2D(rlc->x[j], rlc->y[j],rac,&k,&T);

                         if((ptpdist1 > -1.0) && (ptpdist1 <= tol2)) /**<= MGCP_tolerance)) **/
                            {
                            FoundCondition = 0;
                            break; /** break from the while rac loop ***/
                            }
                         } /* end if combined check applies ***/
                      rac = rac->next;
                      } /** end while rac looking for interior segment close-to match ***/
                   }

                if(FoundCondition > 0)
                   {
                   if(j == 0)
                      {
                      keepit = ConditionOnDataEdge(rlc->x[0],rlc->y[0],rlc->x[1],rlc->y[1],Aroot,Proot,root,
                                                   NULL, NULL, rlc,
                                                   NorthCount,SouthCount,EastCount,WestCount,checkinstance);
                      }
                   else
                      {
                      keepit = ConditionOnDataEdge(rlc->x[j],rlc->y[j],rlc->x[j-1],rlc->y[j-1],Aroot,Proot,root,
                                                   NULL, NULL, rlc,
                                                   NorthCount,SouthCount,EastCount,WestCount,checkinstance);
                      }
                   if(keepit <= 0)
                      FoundCondition = 0;
                   }


                if(FoundCondition > 0) /** need to add a condition to the list ***/
                   {
                   FoundCondition = 0;
                   ERc = (struct collection *) (malloc(SzC));
                   if(ERc == NULL)
                     {
                     printf("allocation memory exhausted during linear feature condition analysis (Z-shear analysis)\n");
                     printf("processing cannot continue\n");
                     exit(-1);
                     }
                   ERc->magnitude = mindist1;
                   ERc->x[0] = rlc->x[j];
                   ERc->y[0] = rlc->y[j];
                   ERc->z[0] = rlc->z[j];
                   if((pairedflag <= 0) || (pairedflag >= 1)) /** then only want a vertex to vertex condition ***/
                      {
                      ERc->numpoints = 2;
                      if(pairedflag <= 0)
                         {
                         ERc->x[1] = pairedl1->x[pairedIndex-1];
                         ERc->y[1] = pairedl1->y[pairedIndex-1];
                         ERc->z[1] = pairedl1->z[pairedIndex-1];
                         }
                      else
                         {
                         ERc->x[1] = pairedl1->x[pairedIndex];
                         ERc->y[1] = pairedl1->y[pairedIndex];
                         ERc->z[1] = pairedl1->z[pairedIndex];
                         }
                      }
                   else
                      {
                      ERc->numpoints = 3;
                      ERc->x[1] = pairedl1->x[pairedIndex];
                      ERc->y[1] = pairedl1->y[pairedIndex];
                      ERc->z[1] = pairedl1->z[pairedIndex];
                      ERc->x[2] = pairedl1->x[pairedIndex-1];
                      ERc->y[2] = pairedl1->y[pairedIndex-1];
                      ERc->z[2] = pairedl1->z[pairedIndex-1];
                      }

                   ERc->IDN = rlc->idn;
                   ERc->Sindex = rlc->Sindex;
                   ERc->aa = NULL; /** RawAreal **/
                   ERc->bb = NULL; /** RawBridge **/
                   ERc->pp = NULL; /** RawPoint **/
                   ERc->le = NULL; /** ListOfEdges **/
                   ERc->poly = NULL; /** ThePolys **/
                   ERc->ll1 = rlc;
                   ERc->ll2 = pairedl1;
                   ERc->keyval = LUNDERSHTL;
                   ERc->Cnumber = Make_Correct(LUNDERSHTL,checkinstance);

                   if(ERroot == NULL)
                      {
                      ERroot = ERc;
                      ERroot->next = NULL;
                      }
                   else
                      {
                      ERn = ERroot;
                      while(ERn != NULL)
                         {
                         if((ERn->keyval == ERc->keyval) && (ERc->Cnumber == ERn->Cnumber))
                            {
                            if((ERn->ll1 == ERc->ll1) && (ERn->ll2 == ERc->ll2))
                               {
break;
                               }
                            else if((ERn->ll1 == ERc->ll2) && (ERn->ll2 == ERc->ll1))
                               {
break;
                               }
                            }
                         ERn = ERn->next;
                         }
                      if(ERn == NULL)
                         {
                         ERc->next = ERroot;
                         ERroot = ERc;
                         }
                      else
                         {
                         free(ERc);
                         }
                      }

                   } /*** end FoundCondition ***/
                j += rlc->numnodes - 1;
                } /*** while j < rlc->numnodes ***/
             } /*** end LUNDERSHTL check applies ***/




          if((CombinedCheckApplies(rlc->idn,checkinstance,LUSHTL_DF,rlc->Lindex,rlc->Sindex,Config1,Strat1,Domain1,&part1,&part2,&part3) > 0) && (part1 > 0))
             {
             j = 0;
             FoundCondition = 0;
             tol2 = FindRelevantSensitivity(LUSHTL_DF,checkinstance,&tolerancepad);
             while(j < rlc->numnodes)
                {
                if((rlc->x[j] >= minx) && (rlc->x[j] <= maxx) && (rlc->y[j] >= miny) && (rlc->y[j] <= maxy) &&
                       (LineEndClosesOnItself2D(rlc,j,tolerancepad) == 0))
                   {
                   LocalMinX = rlc->x[j] - tolerancepad - 1;
                   LocalMaxX = rlc->x[j] + tolerancepad + 1;
                   LocalMinY = rlc->y[j] - tolerancepad - 1;
                   LocalMaxY = rlc->y[j] + tolerancepad + 1;
                   mindist1 = mindist2 = tolerancepad * 2.0;
                   pairedl1 = NULL;
                   rln = root;
                   while(rln != NULL)
                      {
                      ptpdist1 = tolerancepad * 2.0;
                      if((rln != rlc) && 
                          (CombinedCheckApplies(rln->idn,checkinstance,LUSHTL_DF,rln->Lindex,rln->Sindex,
                               SCCtable[rln->Sindex].C,SCCtable[rln->Sindex].S,SCCtable[rln->Sindex].D,&part1,&part2,&part3) > 0) && (part2 > 0))
                         {
                         k = 1;
                         while(k < rln->numnodes )
                            {
                            km1 = k - 1;
                            ptpdist1 = PointToLineDist2DwithFlag(rlc->x[j], rlc->y[j], rln->x[km1], rln->y[km1], rln->x[k], rln->y[k],&T);
                            if(ptpdist1 <= tol2) /**MGCP_tolerance)**/ /** call these two end nodes a match ***/
                               {
                               break; /** from while rln loop ***/
                               }

                            else if((ptpdist1 > tol2) /**MGCP_tolerance)**/ && (ptpdist1 < mindist1) && (SensitivityCheck(OPENINT, LUSHTL_DF, checkinstance, ptpdist1) > 0)) 
                               {
                               if(j == 0)
                                  {
                                  ptpdist2 = PointToLineDist2DwithFlag(rlc->x[rlc->numnodes-1], rlc->y[rlc->numnodes-1],
                                         rln->x[km1], rln->y[km1], rln->x[k], rln->y[k],&unuseddbl);
                                  }
                               else
                                  {
                                  ptpdist2 =  PointToLineDist2DwithFlag(rlc->x[0], rlc->y[0],
                                         rln->x[km1], rln->y[km1], rln->x[k], rln->y[k],&unuseddbl);
                                  }
                               if(ptpdist2 > tol2)
                                  {
                                  if((SCCtable[rln->Sindex].ECC != SCCtable[rlc->Sindex].ECC) && 
                                          (LimitedTwoLinesIntersect(rlc,j,rln) == 0))
                                     {
                                     pairedl1 = rln;
                                     pairedIndex = k;
                                     pairedflag = T;
                                     mindist1 = ptpdist1;
                                     }
                                  }
                               }
                            k++;
                            } /*** end while k ***/
                         } /* end rln != rlc ***/
                      if(ptpdist1 <= tol2) /**MGCP_tolerance) **/
                         break;
                      rln = rln->next;
                      } /** end while rln looking for interior segment close-to match ***/
                   if(rln == NULL) /*** did not find an end node to another (interior) node match ***/
                      {
                      if((pairedl1 != NULL) && (SensitivityCheck(OPENINT, LUSHTL_DF, checkinstance, mindist1) > 0)) /*** but did find a close node ***/
                         {
                         FoundCondition = 1;
                         }
                      else
                         {
                         foundpair = 0;
                         FoundCondition = 0;
                         Nrln = NLroot;
                         mindist1 = mindist2 = tolerancepad * 2.0;
                         pairedl1 = NULL;
                         while(Nrln != NULL)
                            {
                            if((Nrln->numnodes > 1) && 
                                    (CombinedCheckApplies(Nrln->idn,checkinstance,LUSHTL_DF,Nrln->Lindex,Nrln->Sindex,
                                         SCCtable[Nrln->Sindex].C,SCCtable[Nrln->Sindex].S,SCCtable[Nrln->Sindex].D,&part1,&part2,&part3) > 0) &&
                                                (part2 > 0))
                               {
                               k = 1;
                               while(k < Nrln->numnodes)
                                  {
                                  km1 = k - 1;
                                  ptpdist1 = PointToLineDist2DwithFlag(rlc->x[j], rlc->y[j], Nrln->x[km1], Nrln->y[km1], Nrln->x[k], Nrln->y[k],&T);
                                  if((ptpdist1 < mindist1) && (SensitivityCheck(OPENINT, LUSHTL_DF, checkinstance, ptpdist1) > 0))
                                     {
                                     if(j == 0)
                                        {
                                        ptpdist2 = PointToLineDist2DwithFlag(rlc->x[rlc->numnodes-1], rlc->y[rlc->numnodes-1],
                                                     Nrln->x[km1], Nrln->y[km1], Nrln->x[k], Nrln->y[k],&unuseddbl);
                                        }
                                     else
                                        {
                                        ptpdist2 =  PointToLineDist2DwithFlag(rlc->x[0], rlc->y[0],
                                               Nrln->x[km1], Nrln->y[km1], Nrln->x[k], Nrln->y[k],&unuseddbl);
                                        }
                                     if(ptpdist2 > tol2)
                                        {
                                        if((SCCtable[Nrln->Sindex].ECC != SCCtable[rlc->Sindex].ECC) && 
                                               (LimitedTwoLinesIntersect(rlc,j,Nrln) == 0))
                                        /***if(TwoLinesIntersect(rlc,j,Nrln) == 0) ***/
                                           {
                                           pairedl1 = Nrln;
                                           foundpair = 1;
                                           pairedIndex = k;
                                           mindist1 = ptpdist1;
                                           pairedflag = T;
                                           break; /*** break from the while k loop ***/
                                           }
                                        }
                                     }
                                  ++k;
                                  }
                               }

                            if(foundpair > 0)
                               break; /** break from the while Nrln loop ***/
                            Nrln = Nrln->next;
                            } /** end while Nlrn ***/
                         if((pairedl1 != NULL) && (foundpair > 0))
                            {
                            FoundCondition = 1;
                            } /**** end if((pairedl1 != NULL) && (foundpair > 0)) ***/
                         } /*** end else look thru neighbor load module line end nodes ***/
                      } /*** rln == NULL so end if found no end node to interior node match ***/


                   } /** end if endpoint[j] is in the load module  ***/

                if((FoundCondition > 0) && (SCCtable[pairedl1->Sindex].ECC == SCCtable[rlc->Sindex].ECC))
                   {
                   FoundCondition = 0;
                   }

                if(FoundCondition > 0)
                   {
                   if(mindist1 > ActiveChecks[checkinstance].sensitivity3)
                      {
                      if(j == 0)
                         km4 = 1;
                      else
                         km4 = 0 - 1;
                      km1 = j + km4;
                      unuseddbl = Distance(rlc->x[j],rlc->y[j],rlc->x[km1],rlc->y[km1]);
                      while((unuseddbl < ActiveChecks[checkinstance].sensitivity4) &&
                               (km1 > 0) && (km1 < (rlc->numnodes - 1)))
                         {
                         km1 += km4;
                         unuseddbl = Distance(rlc->x[j],rlc->y[j],rlc->x[km1],rlc->y[km1]);
                         }

                      if(pairedIndex == 0)
                         km4 = 1;
                      else
                         km4 = 0 - 1;
                      km2 = pairedIndex + km4;

                      unuseddbl = Distance(pairedl1->x[pairedIndex],pairedl1->y[pairedIndex],
                                           pairedl1->x[km2],pairedl1->y[km2]);
                      while((unuseddbl < ActiveChecks[checkinstance].sensitivity4) &&
                               (km2 > 0) && (km2 < (pairedl1->numnodes - 1)))
                         {
                         km2 += km4;
                         unuseddbl = Distance(pairedl1->x[pairedIndex],pairedl1->y[pairedIndex],
                                           pairedl1->x[km2],pairedl1->y[km2]);
                         }
                      if(ParallelAndAdjacentLineSegments(rlc->x[j],rlc->y[j],rlc->x[km1],rlc->y[km1],
                            pairedl1->x[pairedIndex],pairedl1->y[pairedIndex],pairedl1->x[km2],pairedl1->y[km2],
                                ActiveChecks[checkinstance].sensitivity4) > 0)
                         FoundCondition = 0;
                      }
                   }


                if(FoundCondition > 0)
                   {
                   rln = root;
                   while((rln != NULL) && (FoundCondition > 0))
                      {
                      ptpdist1 = tolerancepad * 2.0;
                      if((rln != rlc) &&
                          (CombinedCheckApplies(rln->idn,checkinstance,LUSHTL_DF,rln->Lindex,rln->Sindex,
                               SCCtable[rln->Sindex].C,SCCtable[rln->Sindex].S,SCCtable[rln->Sindex].D,&part1,&part2,&part3) > 0) && (part3 > 0))
                         {
                         k = 1;
                         while(k < rln->numnodes )
                            {
                            km1 = k - 1;
                            ptpdist1 = PointToLineDist2DwithFlag(rlc->x[j], rlc->y[j], rln->x[km1], rln->y[km1], rln->x[k], rln->y[k],&T);
                            if(ptpdist1 <= tol2) /**MGCP_tolerance)**/ /** call these two end nodes a match ***/
                               {
                               FoundCondition = 0;
                               break; /** from while rln loop ***/
                               }
                            ++k;
                            }
                         } /** end if check applies as part3 ***/
                      rln = rln->next;
                      } /** end while rln ***/

                   rln = NLroot;
                   while((rln != NULL) && (FoundCondition > 0))
                      {
                      ptpdist1 = tolerancepad * 2.0;
                      if((rln != rlc) &&
                          (CombinedCheckApplies(rln->idn,checkinstance,LUSHTL_DF,rln->Lindex,rln->Sindex,
                               SCCtable[rln->Sindex].C,SCCtable[rln->Sindex].S,SCCtable[rln->Sindex].D,&part1,&part2,&part3) > 0) && (part3 > 0))
                         {
                         k = 1;
                         while(k < rln->numnodes )
                            {
                            km1 = k - 1;
                            ptpdist1 = PointToLineDist2DwithFlag(rlc->x[j], rlc->y[j], rln->x[km1], rln->y[km1], rln->x[k], rln->y[k],&T);
                            if(ptpdist1 <=  tol2) /**MGCP_tolerance)**/ /** call these two end nodes a match ***/
                               {
                               FoundCondition = 0;
                               break; /** from while rln loop ***/
                               }
                            ++k;
                            }
                         } /** end if check applies as part3 ***/
                      rln = rln->next;
                      } /** end while rln ***/

/*** see if a qualified area features bridges the gap ****/
                   rac = Aroot;
                   while((rac != NULL) && (FoundCondition > 0))
                      {
                      ptpdist1 = tolerancepad * 2.0;
                      if((CombinedCheckApplies(rac->idn,checkinstance,LUSHTL_DF,rac->Lindex,rac->Sindex,
                               SCCtable[rac->Sindex].C,SCCtable[rac->Sindex].S,SCCtable[rac->Sindex].D,&part1,&part2,&part3) > 0) && (part3 > 0))
                         {
                         if(rac->RB_Tree_Edgelist == NULL)
                            ptpdist1 = PointToSmallArealDist2D(rlc->x[j], rlc->y[j],rac,&k,&T);
                         else
                            ptpdist1 = PointToLargeArealDist2D(rlc->x[j], rlc->y[j],rac,&k,&T);

                         if((ptpdist1 > -1.0) && (ptpdist1 <= tol2)) /**<= MGCP_tolerance)) **/
                            {
                            FoundCondition = 0;
                            break; /** break from the while rac loop ***/
                            }
                         } /* end if combined check applies ***/
                      rac = rac->next;
                      } /** end while rac looking for interior segment close-to match ***/
                   }
                if(FoundCondition > 0)
                   {
                   if(j == 0)
                      {
                      keepit = ConditionOnDataEdge(rlc->x[0],rlc->y[0],rlc->x[1],rlc->y[1],Aroot,Proot,root,
                                                   NULL, NULL, rlc,
                                                   NorthCount,SouthCount,EastCount,WestCount,checkinstance);
                      }
                   else
                      {
                      keepit = ConditionOnDataEdge(rlc->x[j],rlc->y[j],rlc->x[j-1],rlc->y[j-1],Aroot,Proot,root,
                                                   NULL, NULL, rlc,
                                                   NorthCount,SouthCount,EastCount,WestCount,checkinstance);
                      }
                   if(keepit <= 0)
                      FoundCondition = 0;
                   }


                if(FoundCondition > 0) /** need to add a condition to the list ***/
                   {
                   FoundCondition = 0;
                   ERc = (struct collection *) (malloc(SzC));
                   if(ERc == NULL)
                     {
                     printf("allocation memory exhausted during linear feature condition analysis (Z-shear analysis)\n");
                     printf("processing cannot continue\n");
                     exit(-1);
                     }
                   ERc->magnitude = mindist1;
                   ERc->x[0] = rlc->x[j];
                   ERc->y[0] = rlc->y[j];
                   ERc->z[0] = rlc->z[j];
                   if((pairedflag <= 0) || (pairedflag >= 1)) /** then only want a vertex to vertex condition ***/
                      {
                      ERc->numpoints = 2;
                      if(pairedflag <= 0)
                         {
                         ERc->x[1] = pairedl1->x[pairedIndex-1];
                         ERc->y[1] = pairedl1->y[pairedIndex-1];
                         ERc->z[1] = pairedl1->z[pairedIndex-1];
                         }
                      else
                         {
                         ERc->x[1] = pairedl1->x[pairedIndex];
                         ERc->y[1] = pairedl1->y[pairedIndex];
                         ERc->z[1] = pairedl1->z[pairedIndex];
                         }
                      }
                   else
                      {
                      ERc->numpoints = 3;
                      ERc->x[1] = pairedl1->x[pairedIndex];
                      ERc->y[1] = pairedl1->y[pairedIndex];
                      ERc->z[1] = pairedl1->z[pairedIndex];
                      ERc->x[2] = pairedl1->x[pairedIndex-1];
                      ERc->y[2] = pairedl1->y[pairedIndex-1];
                      ERc->z[2] = pairedl1->z[pairedIndex-1];
                      }

                   ERc->IDN = rlc->idn;
                   ERc->Sindex = rlc->Sindex;
                   ERc->aa = NULL; /** RawAreal **/
                   ERc->bb = NULL; /** RawBridge **/
                   ERc->pp = NULL; /** RawPoint **/
                   ERc->le = NULL; /** ListOfEdges **/
                   ERc->poly = NULL; /** ThePolys **/
                   ERc->ll1 = rlc;
                   ERc->ll2 = pairedl1;
                   ERc->keyval = LUSHTL_DF;
                   ERc->Cnumber = Make_Correct(LUSHTL_DF,checkinstance);

                   if(ERroot == NULL)
                      {
                      ERroot = ERc;
                      ERroot->next = NULL;
                      }
                   else
                      {
                      ERn = ERroot;
                      while(ERn != NULL)
                         {
                         if((ERn->keyval == ERc->keyval) && (ERc->Cnumber == ERn->Cnumber))
                            {
                            if((ERn->ll1 == ERc->ll1) && (ERn->ll2 == ERc->ll2))
                               {
break;
                               }
                            else if((ERn->ll1 == ERc->ll2) && (ERn->ll2 == ERc->ll1))
                               {
break;
                               }
                            }
                         ERn = ERn->next;
                         }
                      if(ERn == NULL)
                         {
                         ERc->next = ERroot;
                         ERroot = ERc;
                         }
                      else
                         {
                         free(ERc);
                         }
                      }

                   } /*** end FoundCondition ***/
                j += rlc->numnodes - 1;
                } /*** while j < rlc->numnodes ***/
             } /*** end LUSHTL_DF check applies ***/





          if((CombinedCheckApplies(rlc->idn,checkinstance,VUSHTL_CLEAN,rlc->Lindex,rlc->Sindex,Config1,Strat1,Domain1,&part1,&part2,&part3) > 0) &&
                  (part1 > 0))
             {
             j = 1;
             endindex = rlc->numnodes - 1;
             FoundCondition = 0;
             tol2 = FindRelevantSensitivity(VUSHTL_CLEAN,checkinstance,&tolerancepad);
             while(j < endindex)
                {
                applycheck = 0;
                if((rlc->x[j] >= minx) && (rlc->x[j] <= maxx) && (rlc->y[j] >= miny) && (rlc->y[j] <= maxy))
                   {
                   temp = TurnAngle(rlc->x[j-1],rlc->y[j-1],rlc->x[j],rlc->y[j],rlc->x[j+1],rlc->y[j+1]);

                   if(temp < PI)
                      temp = RadiansToDegrees(temp);
                   else
                      temp = 180.0;

                   if((temp <= 180.0) && (temp >= ActiveChecks[checkinstance].sensitivity3))
                      {
                      applycheck = 1;
                      }
                   }
                if(applycheck > 0)
                   {
                   DistToLMedge = rlc->x[j] - minx;
                   temp = maxx - rlc->x[j];
                   if(temp < DistToLMedge)
                      DistToLMedge = temp;
                   temp = maxy - rlc->y[j];
                   if(temp < DistToLMedge)
                      DistToLMedge = temp;
                   temp = rlc->y[j] - miny;
                   if(temp < DistToLMedge)
                      DistToLMedge = temp;
                   if(DistToLMedge <= ActiveChecks[checkinstance].sensitivity2)
                      DistToLMedge = 1.0;
                   else
                      DistToLMedge = -100;

                   LocalMinX = rlc->x[j] - tolerancepad - 1;
                   LocalMaxX = rlc->x[j] + tolerancepad + 1;
                   LocalMinY = rlc->y[j] - tolerancepad - 1;
                   LocalMaxY = rlc->y[j] + tolerancepad + 1;
                   mindist1 = mindist2 = tolerancepad * 2.0;
                   pairedl1 = NULL;
                   rln = root;
                   while(rln != NULL)
                      {
                      ptpdist1 = tolerancepad * 2.0;
                      if((rln != rlc) &&
                          (CombinedCheckApplies(rln->idn,checkinstance,VUSHTL_CLEAN,rln->Lindex,rln->Sindex,
                               SCCtable[rln->Sindex].C,SCCtable[rln->Sindex].S,SCCtable[rln->Sindex].D,&part1,&part2,&part3) > 0) &&
                           (part1 > 0))
                         {
                         k = 1;
                         while(k < rln->numnodes )
                            {
                            km1 = k - 1;
                            ptpdist1 = PointToLineDist2DwithFlag(rlc->x[j], rlc->y[j], rln->x[km1], rln->y[km1], rln->x[k], rln->y[k],&T);
                            if((T <= 0) || (T >= 1))
                               ptpdist1 += mindist1;
                            if(ptpdist1 <= tol2) /** call the rlc vertex on a segment of rln ***/
                               {
                               break; /** from while rln loop ***/
                               }

                            else if((ptpdist1 < mindist1) && (SensitivityCheck(OPENINT, VUSHTL_CLEAN, checkinstance, ptpdist1) > 0))
                               {
                               if(AllOnSameSideOfLine(rlc->x[j-1],rlc->y[j-1],rlc->x[j],rlc->y[j],rlc->x[j+1],rlc->y[j+1],
                                            rln->x[km1], rln->y[km1], rln->x[k], rln->y[k]) > 0)
                                  {
                                  ptldist2 = PointToLineDist2DwithFlag(rlc->x[j-1], rlc->y[j-1],
                                              rln->x[km1], rln->y[km1], rln->x[k], rln->y[k],&temp);
                                  if(ptldist2 > tol2)
                                     {
                                     ptldist2 = PointToLineDist2DwithFlag(rlc->x[j+1], rlc->y[j+1],
                                              rln->x[km1], rln->y[km1], rln->x[k], rln->y[k],&temp);
                                     if(ptldist2 > tol2)
                                        {
                                        if(pairedl1 == NULL)
                                           {
                                           pairedl1 = rln;
                                           pairedIndex = k;
                                           pairedflag = T;
                                           mindist1 = ptpdist1;
                                           }
                                        else if(ptpdist1 < mindist1)
                                           {
                                           pairedl1 = rln;
                                           pairedIndex = k;
                                           pairedflag = T;
                                           mindist1 = ptpdist1;
                                           }
                                        }
                                     }
                                  }
                               }
                            k++;
                            } /*** end while k ***/
                         } /* end rln != rlc ***/
                      if(ptpdist1 <= tol2) /** then count this vertex as matching to something **/
                         break;
                      rln = rln->next;
                      } /** end while rln looking for interior segment close-to match ***/
                   if(rln == NULL) /*** did not find an interior node to another node match ***/
                      {
                      if((pairedl1 != NULL) && (SensitivityCheck(OPENINT, VUSHTL_CLEAN, checkinstance, mindist1) > 0)) /*** but did find a close node ***/
                         {
                         FoundCondition = 1;
                         }
                      if(DistToLMedge > 0)
                         {
                         foundpair = 0;
                         Nrln = NLroot;

                         while(Nrln != NULL)
                            {
                            if((Nrln->numnodes > 1) &&
                                    (CombinedCheckApplies(Nrln->idn,checkinstance,VUSHTL_CLEAN,Nrln->Lindex,Nrln->Sindex,
                                         SCCtable[Nrln->Sindex].C,SCCtable[Nrln->Sindex].S,SCCtable[Nrln->Sindex].D,&part1,&part2,&part3) > 0) &&
                                                (part1 > 0))
                               {
                               k = 1;
                               while(k < Nrln->numnodes)
                                  {
                                  km1 = k - 1;
                                  ptpdist1 = PointToLineDist2DwithFlag(rlc->x[j], rlc->y[j], Nrln->x[km1], Nrln->y[km1], Nrln->x[k], Nrln->y[k],&T);

                                  if((T <= 0) || (T >= 1))
                                     ptpdist1 += mindist1;
                                  if((ptpdist1 < mindist1) && (SensitivityCheck(OPENINT, VUSHTL_CLEAN, checkinstance, ptpdist1) > 0))
                                     {
                                     if(AllOnSameSideOfLine(rlc->x[j-1],rlc->y[j-1],rlc->x[j],rlc->y[j],rlc->x[j+1],rlc->y[j+1],
                                            Nrln->x[km1], Nrln->y[km1], Nrln->x[k], Nrln->y[k]) > 0)
                                        {
                                        ptldist2 = PointToLineDist2DwithFlag(rlc->x[j-1], rlc->y[j-1],
                                              Nrln->x[km1], Nrln->y[km1], Nrln->x[k], Nrln->y[k],&temp);
                                        if(ptldist2 > tol2)
                                           {
                                           ptldist2 = PointToLineDist2DwithFlag(rlc->x[j+1], rlc->y[j+1],
                                                    Nrln->x[km1], Nrln->y[km1], Nrln->x[k], Nrln->y[k],&temp);
                                           if(ptldist2 > tol2)
                                              {
                                              if(pairedl1 == NULL)
                                                 {
                                                 pairedl1 = Nrln;
                                                 pairedIndex = k;
                                                 pairedflag = T;
                                                 mindist1 = ptpdist1;
                                                 }
                                              else if(ptpdist1 < mindist1)
                                                 {
                                                 pairedl1 = Nrln;
                                                 pairedIndex = k;
                                                 pairedflag = T;
                                                 mindist1 = ptpdist1;
                                                 }
                                              }
                                           }
                                        }

                                     }
                                  ++k;
                                  }
                               }

                            Nrln = Nrln->next;
                            } /** end while Nlrn ***/
                         if(pairedl1 != NULL) //&& (foundpair > 0))
                            {
                            FoundCondition = 1;
                            } /**** end if((pairedl1 != NULL) && (foundpair > 0)) ***/
                         } /*** end else look thru neighbor load module line end nodes ***/
                      } /*** rln == NULL so end if found no end node to interior node match ***/


                   } /** end if endpoint[j] is in the load module  ***/


                if(FoundCondition > 0)
                   {
                   rln = root;
                   while((rln != NULL) && (FoundCondition > 0))
                      {
                      ptpdist1 = tolerancepad * 2.0;
                      if((rln != rlc) &&
                          (CombinedCheckApplies(rln->idn,checkinstance,VUSHTL_CLEAN,rln->Lindex,rln->Sindex,
                               SCCtable[rln->Sindex].C,SCCtable[rln->Sindex].S,SCCtable[rln->Sindex].D,&part1,&part2,&part3) > 0) && (part3 > 0))
                         {
                         k = 1;
                         while(k < rln->numnodes )
                            {
                            km1 = k - 1;
                            ptpdist1 = PointToLineDist2DwithFlag(rlc->x[j], rlc->y[j], rln->x[km1], rln->y[km1], rln->x[k], rln->y[k],&T);
                            if(ptpdist1 <= tol2) /**MGCP_tolerance)**/ /** call these two end nodes a match ***/
                               {
                               FoundCondition = 0;
                               break; /** from while rln loop ***/
                               }
                            ++k;
                            }
                         } /** end if check applies as part3 ***/
                      rln = rln->next;
                      } /** end while rln ***/

                   rln = NLroot;
                   while((rln != NULL) && (FoundCondition > 0))
                      {
                      ptpdist1 = tolerancepad * 2.0;
                      if((rln != rlc) &&
                          (CombinedCheckApplies(rln->idn,checkinstance,VUSHTL_CLEAN,rln->Lindex,rln->Sindex,
                               SCCtable[rln->Sindex].C,SCCtable[rln->Sindex].S,SCCtable[rln->Sindex].D,&part1,&part2,&part3) > 0) && (part3 > 0))
                         {
                         k = 1;
                         while(k < rln->numnodes )
                            {
                            km1 = k - 1;
                            ptpdist1 = PointToLineDist2DwithFlag(rlc->x[j], rlc->y[j], rln->x[km1], rln->y[km1], rln->x[k], rln->y[k],&T);
                            if(ptpdist1 <= tol2) /**MGCP_tolerance)**/ /** call these two end nodes a match ***/
                               {
                               FoundCondition = 0;
                               break; /** from while rln loop ***/
                               }
                            ++k;
                            }
                         } /** end if check applies as part3 ***/
                      rln = rln->next;
                      } /** end while rln ***/

/*** see if a qualified area features bridges the gap ****/
                   rac = Aroot;
                   while((rac != NULL) && (FoundCondition > 0))
                      {                       ptpdist1 = tolerancepad * 2.0;
                      if((CombinedCheckApplies(rac->idn,checkinstance,VUSHTL_CLEAN,rac->Lindex,rac->Sindex,
                               SCCtable[rac->Sindex].C,SCCtable[rac->Sindex].S,SCCtable[rac->Sindex].D,&part1,&part2,&part3) > 0) && (part3 > 0))
                         {
                         if(rac->RB_Tree_Edgelist == NULL)
                            ptpdist1 = PointToSmallArealDist2D(rlc->x[j], rlc->y[j],rac,&k,&T);
                         else
                            ptpdist1 = PointToLargeArealDist2D(rlc->x[j], rlc->y[j],rac,&k,&T);

                         if((ptpdist1 > -1.0) && (ptpdist1 <= tol2)) /**<= MGCP_tolerance)) **/
                            {
                            FoundCondition = 0;
                            break; /** break from the while rac loop ***/
                            }
                         } /* end if combined check applies ***/
                      rac = rac->next;
                      } /** end while rac looking for interior segment close-to match ***/
                   }

                if(FoundCondition > 0)
                   {
                   if(pairedflag <= 0)
                      {
                      tempx = pairedl1->x[pairedIndex-1];
                      tempy = pairedl1->y[pairedIndex-1];
                      }
                   else if(pairedflag >= 1)
                      {
                      tempx = pairedl1->x[pairedIndex];
                      tempy = pairedl1->y[pairedIndex];
                      }
                   else
                      {
                      tempx = pairedl1->x[pairedIndex] + ((pairedl1->x[pairedIndex-1] - pairedl1->x[pairedIndex]) / 2.0);
                      tempy = pairedl1->y[pairedIndex] + ((pairedl1->y[pairedIndex-1] - pairedl1->y[pairedIndex]) / 2.0);
                      }
                   rln = root;
                   while((rln != NULL) && (FoundCondition > 0))
                      {
                      if((rln != rlc) && (rln != pairedl1) &&
                        (CombinedCheckApplies(rln->idn,checkinstance,VUSHTL_CLEAN,rln->Lindex,rln->Sindex,
                            SCCtable[rln->Sindex].C,SCCtable[rln->Sindex].S,SCCtable[rln->Sindex].D,
                            &part1,&part2,&part3) > 0) && (part2 > 0))
                         {
                         for(kk=1; kk<rln->numnodes; kk++)
                            {
                            if(LineSegmentsIntersect(rlc->x[j],rlc->y[j],tempx,tempy,
                                     rln->x[kk],rln->y[kk],rln->x[kk-1],rln->y[kk-1],&unuseddbl,&temp) > 0)
                               {
                               FoundCondition = 0;
                               break;
                               }
                            }
                         }
                      rln = rln->next;
                      }
                   }


                if(FoundCondition > 0)
                   {
                   if((pairedIndex == 1) || (pairedIndex == pairedl1->numnodes - 1))
                      {
                      if(pairedIndex == 1)
                         km1 = 0;
                      else
                         km1 = pairedl1->numnodes - 1;
                      ptpdist2 = Distance(rlc->x[j],rlc->y[j],pairedl1->x[km1],pairedl1->y[km1]);
                      if(ptpdist2 < ActiveChecks[checkinstance].sensitivity2)
                         {
                         FoundCondition = 0;
                         }
                      }
                   }

                if(FoundCondition > 0) /** need to add a condition to the list ***/
                   {
                   FoundCondition = 0;
                   ERc = (struct collection *) (malloc(SzC));
                   if(ERc == NULL)
                     {
                     printf("allocation memory exhausted during linear feature condition analysis (Z-shear analysis)\n");
                     printf("processing cannot continue\n");
                     exit(-1);
                     }
                   ERc->magnitude = mindist1;
                   ERc->x[0] = rlc->x[j];
                   ERc->y[0] = rlc->y[j];
                   ERc->z[0] = rlc->z[j];
                   if((pairedflag <= 0) || (pairedflag >= 1)) /** then only want a vertex to vertex condition ***/
                      {
                      ERc->numpoints = 2;
                      if(pairedflag <= 0)
                         {
                         ERc->x[1] = pairedl1->x[pairedIndex-1];
                         ERc->y[1] = pairedl1->y[pairedIndex-1];
                         ERc->z[1] = pairedl1->z[pairedIndex-1];
                         }
                      else
                         {
                         ERc->x[1] = pairedl1->x[pairedIndex];
                         ERc->y[1] = pairedl1->y[pairedIndex];
                         ERc->z[1] = pairedl1->z[pairedIndex];
                         }
                      }
                   else
                      {
                      ERc->numpoints = 3;
                      ERc->x[1] = pairedl1->x[pairedIndex];
                      ERc->y[1] = pairedl1->y[pairedIndex];
                      ERc->z[1] = pairedl1->z[pairedIndex];
                      ERc->x[2] = pairedl1->x[pairedIndex-1];
                      ERc->y[2] = pairedl1->y[pairedIndex-1];
                      ERc->z[2] = pairedl1->z[pairedIndex-1];
                      }

                   ERc->IDN = rlc->idn;
                   ERc->Sindex = rlc->Sindex;
                   ERc->aa = NULL; /** RawAreal **/
                   ERc->bb = NULL; /** RawBridge **/
                   ERc->pp = NULL; /** RawPoint **/
                   ERc->le = NULL; /** ListOfEdges **/
                   ERc->poly = NULL; /** ThePolys **/
                   ERc->ll1 = rlc;
                   ERc->ll2 = pairedl1;
                   ERc->keyval = VUSHTL_CLEAN;
                   ERc->Cnumber = Make_Correct(VUSHTL_CLEAN,checkinstance);

                   if(ERroot == NULL)
                      {
                      ERroot = ERc;
                      ERroot->next = NULL;
                      }
                   else
                      {
                      ERn = ERroot;
                      while(ERn != NULL)
                         {
                         if((ERn->keyval == ERc->keyval) && (ERc->Cnumber == ERn->Cnumber))
                            {
                            if((ERn->ll1 == ERc->ll1) && (ERn->ll2 == ERc->ll2) &&
                               (ERc->x[0] == ERn->x[0]) && (ERc->y[0] == ERn->y[0]))
                               {
                               break;
                               }
                            }
                         ERn = ERn->next;
                         }
                      if(ERn == NULL)
                         {
                         ERc->next = ERroot;
                         ERroot = ERc;
                         }
                      else
                         {
                         free(ERc);
                         }
                      }

                   } /*** end FoundCondition ***/
                j += 1;
                } /*** while j < rlc->numnodes ***/
             } /*** end VUSHTL_CLEAN check applies ***/







          if((CombinedCheckApplies(rlc->idn,checkinstance,LVUSHTL,rlc->Lindex,rlc->Sindex,Config1,Strat1,Domain1,&part1,&part2,&part3) > 0) && (part1 > 0))
             {
             j = 1;
             endindex = rlc->numnodes - 1;
             FoundCondition = 0;
             tol2 = FindRelevantSensitivity(LVUSHTL,checkinstance,&tolerancepad);
             while(j < endindex)
                {
                applycheck = 0;
                if((rlc->x[j] >= minx) && (rlc->x[j] <= maxx) && (rlc->y[j] >= miny) && (rlc->y[j] <= maxy))
                   {
                   temp = TurnAngle(rlc->x[j-1],rlc->y[j-1],rlc->x[j],rlc->y[j],rlc->x[j+1],rlc->y[j+1]);

                   if(temp < PI)
                      temp = RadiansToDegrees(temp);
                   else
                      temp = 180.0;

		   if((temp <= 180.0) && (temp >= ActiveChecks[checkinstance].sensitivity3))
                      {
                      applycheck = 1;
                      }
                   }
                if(applycheck > 0)
                   {
                   DistToLMedge = rlc->x[j] - minx;
                   temp = maxx - rlc->x[j];
                   if(temp < DistToLMedge)
                      DistToLMedge = temp;
                   temp = maxy - rlc->y[j];
                   if(temp < DistToLMedge)
                      DistToLMedge = temp;
                   temp = rlc->y[j] - miny;
                   if(temp < DistToLMedge)
                      DistToLMedge = temp;
                   if(DistToLMedge <= ActiveChecks[checkinstance].sensitivity2)
                      DistToLMedge = 1.0;
                   else
                      DistToLMedge = -100;
                   
                   LocalMinX = rlc->x[j] - tolerancepad - 1;
                   LocalMaxX = rlc->x[j] + tolerancepad + 1;
                   LocalMinY = rlc->y[j] - tolerancepad - 1;
                   LocalMaxY = rlc->y[j] + tolerancepad + 1;
                   mindist1 = mindist2 = tolerancepad * 2.0;
                   pairedl1 = NULL;
                   rln = root;
                   while(rln != NULL)
                      {
                      ptpdist1 = tolerancepad * 2.0;
                      if((rln != rlc) &&
                          (CombinedCheckApplies(rln->idn,checkinstance,LVUSHTL,rln->Lindex,rln->Sindex,
                               SCCtable[rln->Sindex].C,SCCtable[rln->Sindex].S,SCCtable[rln->Sindex].D,&part1,&part2,&part3) > 0) &&
                           (part2 > 0))
                         {
                         k = 1; /** look thru all the nodes on second line, for any vertex - vertex connection ***/
                         while(k < rln->numnodes )
                            {
                            km1 = k - 1;
                            ptpdist1 = PointToLineDist2DwithFlag(rlc->x[j], rlc->y[j], rln->x[km1], rln->y[km1], rln->x[k], rln->y[k],&T);
                            if((T <= 0) || (T >= 1)) /*** this should turn off recording conditions when measured dist is pt to pt ***/
                               ptpdist1 += mindist1;
                            if(ptpdist1 <= tol2) /** call the rlc vertex on a segment of rln ***/
                               {
                               break; /** from while rln loop ***/
                               }

                            else if((ptpdist1 < mindist1) && (SensitivityCheck(OPENINT, LVUSHTL, checkinstance, ptpdist1) > 0))
                               {
                               if(AllOnSameSideOfLine(rlc->x[j-1],rlc->y[j-1],rlc->x[j],rlc->y[j],rlc->x[j+1],rlc->y[j+1],
                                            rln->x[km1], rln->y[km1], rln->x[k], rln->y[k]) > 0)
                                  {
                                  ptldist2 = PointToLineDist2DwithFlag(rlc->x[j-1], rlc->y[j-1],
                                              rln->x[km1], rln->y[km1], rln->x[k], rln->y[k],&temp);
                                  if(ptldist2 > tol2)
                                     {
                                     ptldist2 = PointToLineDist2DwithFlag(rlc->x[j+1], rlc->y[j+1],
                                              rln->x[km1], rln->y[km1], rln->x[k], rln->y[k],&temp);
                                     if(ptldist2 > tol2)
                                        {
                                        if(pairedl1 == NULL)
                                           {
                                           pairedl1 = rln;
                                           pairedIndex = k;
                                           pairedflag = T;
                                           mindist1 = ptpdist1;
                                           }
                                        else if(ptpdist1 < mindist1)
                                           {
                                           pairedl1 = rln;
                                           pairedIndex = k;
                                           pairedflag = T;
                                           mindist1 = ptpdist1;
                                           }
                                        }
                                     }
                                  }
                               }
                            k++;
                            } /*** end while k ***/
                         } /* end rln != rlc ***/
                      if(ptpdist1 <= tol2) /** then count this vertex as matching to something **/
                         break;
                      rln = rln->next;
                      } /** end while rln looking for interior segment close-to match ***/
                   if(rln == NULL) /*** did not find an interior node to another node match ***/
                      {
                      if((pairedl1 != NULL) && (SensitivityCheck(OPENINT, LVUSHTL, checkinstance, mindist1) > 0)) /*** but did find a close node ***/
                         {
                         FoundCondition = 1;
                         }
                      if(DistToLMedge > 0)
                         {
                         foundpair = 0;
                         Nrln = NLroot;

                         while(Nrln != NULL)
                            {
                            if((Nrln->numnodes > 1) &&
                                    (CombinedCheckApplies(Nrln->idn,checkinstance,LVUSHTL,Nrln->Lindex,Nrln->Sindex,
                                         SCCtable[Nrln->Sindex].C,SCCtable[Nrln->Sindex].S,SCCtable[Nrln->Sindex].D,&part1,&part2,&part3) > 0) &&
                                                (part2 > 0))
                               {
                               k = 1;
                               while(k < Nrln->numnodes)
                                  {
                                  km1 = k - 1;
                                  ptpdist1 = PointToLineDist2DwithFlag(rlc->x[j], rlc->y[j], Nrln->x[km1], Nrln->y[km1], Nrln->x[k], Nrln->y[k],&T);

                                  if((T <= 0) || (T >= 1))
                                     ptpdist1 += mindist1;
                                  if((ptpdist1 < mindist1) && (SensitivityCheck(OPENINT, LVUSHTL, checkinstance, ptpdist1) > 0))
                                     {
                                     if(AllOnSameSideOfLine(rlc->x[j-1],rlc->y[j-1],rlc->x[j],rlc->y[j],rlc->x[j+1],rlc->y[j+1],
                                            Nrln->x[km1], Nrln->y[km1], Nrln->x[k], Nrln->y[k]) > 0)
                                        {
                                        ptldist2 = PointToLineDist2DwithFlag(rlc->x[j-1], rlc->y[j-1],
                                              Nrln->x[km1], Nrln->y[km1], Nrln->x[k], Nrln->y[k],&temp);
                                        if(ptldist2 > tol2)
                                           {
                                           ptldist2 = PointToLineDist2DwithFlag(rlc->x[j+1], rlc->y[j+1],
                                                    Nrln->x[km1], Nrln->y[km1], Nrln->x[k], Nrln->y[k],&temp);
                                           if(ptldist2 > tol2)
                                              {
                                              if(pairedl1 == NULL)
                                                 {
                                                 pairedl1 = Nrln;
                                                 pairedIndex = k;
                                                 pairedflag = T;
                                                 mindist1 = ptpdist1;
                                                 }
                                              else if(ptpdist1 < mindist1)
                                                 {
                                                 pairedl1 = Nrln;
                                                 pairedIndex = k;
                                                 pairedflag = T;
                                                 mindist1 = ptpdist1;
                                                 }
                                              }
                                           }
                                        }

                                     }
                                  ++k;
                                  }
                               }

                            Nrln = Nrln->next;
                            } /** end while Nlrn ***/
                         if(pairedl1 != NULL)
                            {
                            FoundCondition = 1;
                            } /**** end if((pairedl1 != NULL) && (foundpair > 0)) ***/
                         } /*** end else look thru neighbor load module line end nodes ***/
                      } /*** rln == NULL so end if found no end node to interior node match ***/


                   } /** end if endpoint[j] is in the load module  ***/


                if(FoundCondition > 0)
                   {
                   rln = root;
                   while((rln != NULL) && (FoundCondition > 0))
                      {
                      ptpdist1 = tolerancepad * 2.0;
                      if((rln != rlc) &&
                          (CombinedCheckApplies(rln->idn,checkinstance,LVUSHTL,rln->Lindex,rln->Sindex,
                               SCCtable[rln->Sindex].C,SCCtable[rln->Sindex].S,SCCtable[rln->Sindex].D,&part1,&part2,&part3) > 0) && (part3 > 0))
                         {
                         k = 1;
                         while(k < rln->numnodes )
                            {
                            km1 = k - 1;
                            ptpdist1 = PointToLineDist2DwithFlag(rlc->x[j], rlc->y[j], rln->x[km1], rln->y[km1], rln->x[k], rln->y[k],&T);
                            if(ptpdist1 <= tol2) /**MGCP_tolerance)**/ /** call these two end nodes a match ***/
                               {
                               FoundCondition = 0;
                               break; /** from while rln loop ***/
                               }
                            ++k;
                            }
                         } /** end if check applies as part3 ***/
                      rln = rln->next;
                      } /** end while rln ***/

                   rln = NLroot;
                   while((rln != NULL) && (FoundCondition > 0))
                      {
                      ptpdist1 = tolerancepad * 2.0;
                      if((rln != rlc) &&
                          (CombinedCheckApplies(rln->idn,checkinstance,LVUSHTL,rln->Lindex,rln->Sindex,
                               SCCtable[rln->Sindex].C,SCCtable[rln->Sindex].S,SCCtable[rln->Sindex].D,&part1,&part2,&part3) > 0) && (part3 > 0))
                         {
                         k = 1;
                         while(k < rln->numnodes )
                            {
                            km1 = k - 1;
                            ptpdist1 = PointToLineDist2DwithFlag(rlc->x[j], rlc->y[j], rln->x[km1], rln->y[km1], rln->x[k], rln->y[k],&T);
                            if(ptpdist1 <= tol2) /**MGCP_tolerance)**/ /** call these two end nodes a match ***/
                               {
                               FoundCondition = 0;
                               break; /** from while rln loop ***/
                               }
                            ++k;
                            }
                         } /** end if check applies as part3 ***/
                      rln = rln->next;
                      } /** end while rln ***/

/*** see if a qualified area features bridges the gap ****/
                   rac = Aroot;
                   while((rac != NULL) && (FoundCondition > 0))
                      {                       ptpdist1 = tolerancepad * 2.0;
                      if((CombinedCheckApplies(rac->idn,checkinstance,LVUSHTL,rac->Lindex,rac->Sindex,
                               SCCtable[rac->Sindex].C,SCCtable[rac->Sindex].S,SCCtable[rac->Sindex].D,&part1,&part2,&part3) > 0) && (part3 > 0))
                         {
                         if(rac->RB_Tree_Edgelist == NULL)
                            ptpdist1 = PointToSmallArealDist2D(rlc->x[j], rlc->y[j],rac,&k,&T);
                         else
                            ptpdist1 = PointToLargeArealDist2D(rlc->x[j], rlc->y[j],rac,&k,&T);

                         if((ptpdist1 > -1.0) && (ptpdist1 <= tol2)) /**<= MGCP_tolerance)) **/
                            {
                            FoundCondition = 0;
                            break; /** break from the while rac loop ***/
                            }
                         } /* end if combined check applies ***/
                      rac = rac->next;
                      } /** end while rac looking for interior segment close-to match ***/
                   }

                if(FoundCondition > 0)
                   {
                   if((pairedIndex == 1) || (pairedIndex == pairedl1->numnodes - 1))
                      {
                      if(pairedIndex == 1)
                         km1 = 0;
                      else
                         km1 = pairedl1->numnodes - 1;
                      ptpdist2 = Distance(rlc->x[j],rlc->y[j],pairedl1->x[km1],pairedl1->y[km1]);
                      if(ptpdist2 < ActiveChecks[checkinstance].sensitivity2)
                         {
                         FoundCondition = 0;
                         }
                      }
                   }

                if(FoundCondition > 0) /** need to add a condition to the list ***/
                   {
                   FoundCondition = 0;
                   ERc = (struct collection *) (malloc(SzC));
                   if(ERc == NULL)
                     {
                     printf("allocation memory exhausted during linear feature condition analysis (Z-shear analysis)\n");
                     printf("processing cannot continue\n");
                     exit(-1);
                     }
                   ERc->magnitude = mindist1;
                   ERc->x[0] = rlc->x[j];
                   ERc->y[0] = rlc->y[j];
                   ERc->z[0] = rlc->z[j];
                   if((pairedflag <= 0) || (pairedflag >= 1)) /** then only want a vertex to vertex condition ***/
                      {
                      ERc->numpoints = 2;
                      if(pairedflag <= 0)
                         {
                         ERc->x[1] = pairedl1->x[pairedIndex-1];
                         ERc->y[1] = pairedl1->y[pairedIndex-1];
                         ERc->z[1] = pairedl1->z[pairedIndex-1];
                         }
                      else
                         {
                         ERc->x[1] = pairedl1->x[pairedIndex];
                         ERc->y[1] = pairedl1->y[pairedIndex];
                         ERc->z[1] = pairedl1->z[pairedIndex];
                         }
                      }
                   else
                      {
                      ERc->numpoints = 3;
                      ERc->x[1] = pairedl1->x[pairedIndex];
                      ERc->y[1] = pairedl1->y[pairedIndex];
                      ERc->z[1] = pairedl1->z[pairedIndex];
                      ERc->x[2] = pairedl1->x[pairedIndex-1];
                      ERc->y[2] = pairedl1->y[pairedIndex-1];
                      ERc->z[2] = pairedl1->z[pairedIndex-1];
                      }

                   ERc->IDN = rlc->idn;
                   ERc->Sindex = rlc->Sindex;
                   ERc->aa = NULL; /** RawAreal **/
                   ERc->bb = NULL; /** RawBridge **/
                   ERc->pp = NULL; /** RawPoint **/
                   ERc->le = NULL; /** ListOfEdges **/
                   ERc->poly = NULL; /** ThePolys **/
                   ERc->ll1 = rlc;
                   ERc->ll2 = pairedl1;
                   ERc->keyval = LVUSHTL;
                   ERc->Cnumber = Make_Correct(LVUSHTL,checkinstance);

                   if(ERroot == NULL)
                      {
                      ERroot = ERc;
                      ERroot->next = NULL;
                      }
                   else
                      {
                      ERn = ERroot;
                      while(ERn != NULL)
                         {
                         if((ERn->keyval == ERc->keyval) && (ERc->Cnumber == ERn->Cnumber))
                            {
                            if((ERn->ll1 == ERc->ll1) && (ERn->ll2 == ERc->ll2) &&
                               (ERc->x[0] == ERn->x[0]) && (ERc->y[0] == ERn->y[0]))
                               {
                               break;
                               }
                            }
                         ERn = ERn->next;
                         }
                      if(ERn == NULL)
                         {
                         ERc->next = ERroot;
                         ERroot = ERc;
                         }
                      else
                         {
                         free(ERc);
                         }
                      }

                   } /*** end FoundCondition ***/
                j += 1;
                } /*** while j < rlc->numnodes ***/
             } /*** end LVUSHTL check applies ***/




          if((CombinedCheckApplies(rlc->idn,checkinstance,LVOSHTL,rlc->Lindex,rlc->Sindex,Config1,Strat1,Domain1,&part1,&part2,&part3) > 0) && (part1 > 0))
             {
             j = 1;
             endindex = rlc->numnodes - 1;
             FoundCondition = 0;
             tol2 = FindRelevantSensitivity(LVOSHTL,checkinstance,&tolerancepad);
             while(j < endindex)
                {
                applycheck = 0;
                if((rlc->x[j] >= minx) && (rlc->x[j] <= maxx) && (rlc->y[j] >= miny) && (rlc->y[j] <= maxy))
                   {
                   temp = TurnAngle(rlc->x[j-1],rlc->y[j-1],rlc->x[j],rlc->y[j],rlc->x[j+1],rlc->y[j+1]);

                   if(temp < PI)
                      temp = RadiansToDegrees(temp);
                   else
                      temp = 180.0;

                   if((temp <= 180.0) && (temp >= ActiveChecks[checkinstance].sensitivity3))
                      {
                      applycheck = 1;
                      }
                   }
                if(applycheck > 0)
                   {
                   DistToLMedge = rlc->x[j] - minx;
                   temp = maxx - rlc->x[j];
                   if(temp < DistToLMedge)
                      DistToLMedge = temp;
                   temp = maxy - rlc->y[j];
                   if(temp < DistToLMedge)
                      DistToLMedge = temp;
                   temp = rlc->y[j] - miny;
                   if(temp < DistToLMedge)
                      DistToLMedge = temp;
                   if(DistToLMedge <= ActiveChecks[checkinstance].sensitivity2)
                      DistToLMedge = 1.0;
                   else
                      DistToLMedge = -100;

                   LocalMinX = rlc->x[j] - tolerancepad - 1;
                   LocalMaxX = rlc->x[j] + tolerancepad + 1;
                   LocalMinY = rlc->y[j] - tolerancepad - 1;
                   LocalMaxY = rlc->y[j] + tolerancepad + 1;
                   mindist1 = mindist2 = tolerancepad * 2.0;
                   pairedl1 = NULL;
                   rln = root;
                   while(rln != NULL)
                      {
                      ptpdist1 = tolerancepad * 2.0;
                      if((rln != rlc) &&
                          (CombinedCheckApplies(rln->idn,checkinstance,LVOSHTL,rln->Lindex,rln->Sindex,
                               SCCtable[rln->Sindex].C,SCCtable[rln->Sindex].S,SCCtable[rln->Sindex].D,&part1,&part2,&part3) > 0) &&
                           (part2 > 0))
                         {
                         k = 1; /** look thru all the nodes on second line, for any vertex - vertex connection ***/
                         while(k < rln->numnodes )
                            {
                            km1 = k - 1;
                            ptpdist1 = PointToLineDist2DwithFlag(rlc->x[j], rlc->y[j], rln->x[km1], rln->y[km1], rln->x[k], rln->y[k],&T);
                            if((T <= 0) || (T >= 1))
                               ptpdist1 += mindist1;
                            if(ptpdist1 <= tol2) /** call the rlc vertex on a segment of rln ***/
                               {
                               break; /** from while rln loop ***/
                               }

                            else if((ptpdist1 < mindist1) && (SensitivityCheck(OPENINT, LVOSHTL, checkinstance, ptpdist1) > 0))
                               {
                               if(OnlyTwoOnSameSideOfLine(rlc->x[j-1],rlc->y[j-1],rlc->x[j],rlc->y[j],rlc->x[j+1],rlc->y[j+1],
                                            rln->x[km1], rln->y[km1], rln->x[k], rln->y[k]) > 0)
                                  {
                                     if(ptpdist1 > tol2)
                                        {
                                        if(pairedl1 == NULL)
                                           {
                                           pairedl1 = rln;
                                           pairedIndex = k;
                                           pairedflag = T;
                                           mindist1 = ptpdist1;
                                           }
                                        else if(ptpdist1 < mindist1)
                                           {
                                           pairedl1 = rln;
                                           pairedIndex = k;
                                           pairedflag = T;
                                           mindist1 = ptpdist1;
                                           }
                                        }
                                  }
                               }
                            k++;
                            } /*** end while k ***/
                         } /* end rln != rlc ***/
                      if(ptpdist1 <= tol2) /** then count this vertex as matching to something **/
                         break;
                      rln = rln->next;
                      } /** end while rln looking for interior segment close-to match ***/
                   if(rln == NULL) /*** did not find an interior node to another node match ***/
                      {
                      if((pairedl1 != NULL) && (SensitivityCheck(OPENINT, LVOSHTL, checkinstance, mindist1) > 0)) /*** but did find a close node ***/
                         {
                         FoundCondition = 1;
                         }
                      if(DistToLMedge > 0)
                         {
                         foundpair = 0;
                         Nrln = NLroot;
                         while(Nrln != NULL)
                            {
                            if((Nrln->numnodes > 1) &&
                                    (CombinedCheckApplies(Nrln->idn,checkinstance,LVOSHTL,Nrln->Lindex,Nrln->Sindex,
                                         SCCtable[Nrln->Sindex].C,SCCtable[Nrln->Sindex].S,SCCtable[Nrln->Sindex].D,&part1,&part2,&part3) > 0) &&
                                                (part2 > 0))
                               {
                               k = 1;
                               while(k < Nrln->numnodes)
                                  {
                                  km1 = k - 1;
                                  ptpdist1 = PointToLineDist2DwithFlag(rlc->x[j], rlc->y[j], Nrln->x[km1], Nrln->y[km1], Nrln->x[k], Nrln->y[k],&T);
                                  if((T <= 0) || (T >= 1)) /*** this should turn off recording conditions when measured dist is pt to pt ***/
                                     ptpdist1 += mindist1;
                                  if((ptpdist1 < mindist1) && (SensitivityCheck(OPENINT, LVOSHTL, checkinstance, ptpdist1) > 0))
                                     {
                                     if(OnlyTwoOnSameSideOfLine(rlc->x[j-1],rlc->y[j-1],rlc->x[j],rlc->y[j],rlc->x[j+1],rlc->y[j+1],
                                            Nrln->x[km1], Nrln->y[km1], Nrln->x[k], Nrln->y[k]) > 0)
                                        {
                                           if(ptpdist1 > tol2)
                                              {
                                              if(pairedl1 == NULL)
                                                 {
                                                 pairedl1 = Nrln;
                                                 pairedIndex = k;
                                                 pairedflag = T;
                                                 mindist1 = ptpdist1;
                                                 }
                                              else if(ptpdist1 < mindist1)
                                                 {
                                                 pairedl1 = Nrln;
                                                 pairedIndex = k;
                                                 pairedflag = T;
                                                 mindist1 = ptpdist1;
                                                 }
                                              }
                                        }

                                     }
                                  ++k;
                                  }
                               }
                            Nrln = Nrln->next;
                            } /** end while Nlrn ***/
                         if(pairedl1 != NULL) 
                            {
                            FoundCondition = 1;
                            } /**** end if((pairedl1 != NULL) && (foundpair > 0)) ***/
                         } /*** end else look thru neighbor load module line end nodes ***/
                      } /*** rln == NULL so end if found no end node to interior node match ***/


                   } /** end if endpoint[j] is in the load module  ***/


                if(FoundCondition > 0)
                   {
                   rln = root;
                   while((rln != NULL) && (FoundCondition > 0))
                      {
                      ptpdist1 = tolerancepad * 2.0;
                      if((rln != rlc) &&
                          (CombinedCheckApplies(rln->idn,checkinstance,LVOSHTL,rln->Lindex,rln->Sindex,
                               SCCtable[rln->Sindex].C,SCCtable[rln->Sindex].S,SCCtable[rln->Sindex].D,&part1,&part2,&part3) > 0) && (part3 > 0))
                         {
                         k = 1;
                         while(k < rln->numnodes )
                            {
                            km1 = k - 1;
                            ptpdist1 = PointToLineDist2DwithFlag(rlc->x[j], rlc->y[j], rln->x[km1], rln->y[km1], rln->x[k], rln->y[k],&T);
                            if(ptpdist1 <= tol2) /**MGCP_tolerance)**/ /** call these two end nodes a match ***/
                               {
                               FoundCondition = 0;
                               break; /** from while rln loop ***/
                               }
                            ++k;
                            }
                         } /** end if check applies as part3 ***/
                      rln = rln->next;
                      } /** end while rln ***/

                   rln = NLroot;
                   while((rln != NULL) && (FoundCondition > 0))
                      {
                      ptpdist1 = tolerancepad * 2.0;
                      if((rln != rlc) &&
                          (CombinedCheckApplies(rln->idn,checkinstance,LVOSHTL,rln->Lindex,rln->Sindex,
                               SCCtable[rln->Sindex].C,SCCtable[rln->Sindex].S,SCCtable[rln->Sindex].D,&part1,&part2,&part3) > 0) && (part3 > 0))
                         {
                         k = 1;
                         while(k < rln->numnodes )
                            {
                            km1 = k - 1;
                            ptpdist1 = PointToLineDist2DwithFlag(rlc->x[j], rlc->y[j], rln->x[km1], rln->y[km1], rln->x[k], rln->y[k],&T);
                            if(ptpdist1 <= tol2) /**MGCP_tolerance)**/ /** call these two end nodes a match ***/
                               {
                               FoundCondition = 0;
                               break; /** from while rln loop ***/
                               }
                            ++k;
                            }
                         } /** end if check applies as part3 ***/
                      rln = rln->next;
                      } /** end while rln ***/

/*** see if a qualified area features bridges the gap ****/
                   rac = Aroot;
                   while((rac != NULL) && (FoundCondition > 0))
                      {                       ptpdist1 = tolerancepad * 2.0;
                      if((CombinedCheckApplies(rac->idn,checkinstance,LVOSHTL,rac->Lindex,rac->Sindex,
                               SCCtable[rac->Sindex].C,SCCtable[rac->Sindex].S,SCCtable[rac->Sindex].D,&part1,&part2,&part3) > 0) && (part3 > 0))
                         {
                         if(rac->RB_Tree_Edgelist == NULL)
                            ptpdist1 = PointToSmallArealDist2D(rlc->x[j], rlc->y[j],rac,&k,&T);
                         else
                            ptpdist1 = PointToLargeArealDist2D(rlc->x[j], rlc->y[j],rac,&k,&T);

                         if((ptpdist1 > -1.0) && (ptpdist1 <= tol2)) /**<= MGCP_tolerance)) **/
                            {
                            FoundCondition = 0;
                            break; /** break from the while rac loop ***/
                            }                          } /* end if combined check applies ***/
                      rac = rac->next;
                      } /** end while rac looking for interior segment close-to match ***/
                   }

                if(FoundCondition > 0)
                   {
                   if((pairedIndex == 1) || (pairedIndex == pairedl1->numnodes - 1))
                      {
                      if(pairedIndex == 1)
                         km1 = 0;
                      else
                         km1 = pairedl1->numnodes - 1;
                      ptpdist2 = Distance(rlc->x[j],rlc->y[j],pairedl1->x[km1],pairedl1->y[km1]);
                      if(ptpdist2 < ActiveChecks[checkinstance].sensitivity2)
                         {
                         FoundCondition = 0;
                         }
                      }
                   }

                if(FoundCondition > 0) /** need to add a condition to the list ***/
                   {                    FoundCondition = 0;
                   ERc = (struct collection *) (malloc(SzC));
                   if(ERc == NULL)
                     {
                     printf("allocation memory exhausted during linear feature condition analysis (Z-shear analysis)\n");
                     printf("processing cannot continue\n");
                     exit(-1);
                     }
                   ERc->magnitude = mindist1;
                   ERc->x[0] = rlc->x[j];
                   ERc->y[0] = rlc->y[j];
                   ERc->z[0] = rlc->z[j];
                   if((pairedflag <= 0) || (pairedflag >= 1)) /** then only want a vertex to vertex condition ***/
                      {
                      ERc->numpoints = 2;
                      if(pairedflag <= 0)
                         {
                         ERc->x[1] = pairedl1->x[pairedIndex-1];
                         ERc->y[1] = pairedl1->y[pairedIndex-1];
                         ERc->z[1] = pairedl1->z[pairedIndex-1];
                         }
                      else
                         {
                         ERc->x[1] = pairedl1->x[pairedIndex];
                         ERc->y[1] = pairedl1->y[pairedIndex];
                         ERc->z[1] = pairedl1->z[pairedIndex];
                         }
                      }
                   else
                      {
                      ERc->numpoints = 3;
                      ERc->x[1] = pairedl1->x[pairedIndex];
                      ERc->y[1] = pairedl1->y[pairedIndex];
                      ERc->z[1] = pairedl1->z[pairedIndex];
                      ERc->x[2] = pairedl1->x[pairedIndex-1];
                      ERc->y[2] = pairedl1->y[pairedIndex-1];
                      ERc->z[2] = pairedl1->z[pairedIndex-1];
                      }

                   ERc->IDN = rlc->idn;
                   ERc->Sindex = rlc->Sindex;
                   ERc->aa = NULL; /** RawAreal **/
                   ERc->bb = NULL; /** RawBridge **/
                   ERc->pp = NULL; /** RawPoint **/
                   ERc->le = NULL; /** ListOfEdges **/
                   ERc->poly = NULL; /** ThePolys **/
                   ERc->ll1 = rlc;
                   ERc->ll2 = pairedl1;
                   ERc->keyval = LVOSHTL;
                   ERc->Cnumber = Make_Correct(LVOSHTL,checkinstance);

                   if(ERroot == NULL)
                      {
                      ERroot = ERc;
                      ERroot->next = NULL;
                      }
                   else
                      {
                      ERn = ERroot;
                      while(ERn != NULL)
                         {
                         if((ERn->keyval == ERc->keyval) && (ERc->Cnumber == ERn->Cnumber))
                            {
                            if((ERn->ll1 == ERc->ll1) && (ERn->ll2 == ERc->ll2) &&
                               (ERc->x[0] == ERn->x[0]) && (ERc->y[0] == ERn->y[0]))
                               {
                               break;
                               }
                            }
                         ERn = ERn->next;
                         }
                      if(ERn == NULL)
                         {
                         ERc->next = ERroot;
                         ERroot = ERc;
                         }
                      else
                         {
                         free(ERc);
                         }
                      }

                   } /*** end FoundCondition ***/
                j += 1;
                } /*** while j < rlc->numnodes ***/
             } /*** end LVOSHTL check applies ***/






          if((CombinedCheckApplies(rlc->idn,checkinstance,LOVERSHTL,rlc->Lindex,rlc->Sindex,Config1,Strat1,Domain1,&part1,&part2,&part3) > 0) && (part1 > 0))
             {
             j = 0;
             FoundCondition = 0;
             tol2 = FindRelevantSensitivity(LOVERSHTL,checkinstance,&tolerancepad);
             while(j < rlc->numnodes)
                {
                if((rlc->x[j] >= minx) && (rlc->x[j] <= maxx) && (rlc->y[j] >= miny) && (rlc->y[j] <= maxy) &&
                       (LineEndClosesOnItself2D(rlc,j,tolerancepad) == 0))
                   {
                   LocalMinX = rlc->x[j] - tolerancepad - 1;
                   LocalMaxX = rlc->x[j] + tolerancepad + 1;
                   LocalMinY = rlc->y[j] - tolerancepad - 1;
                   LocalMaxY = rlc->y[j] + tolerancepad + 1;
                   mindist1 = mindist2 = tolerancepad * 2.0;
                   pairedl1 = NULL;
                   rln = root;
                   while(rln != NULL)
                      {
                      ptpdist1 = tolerancepad * 2.0;
                      if((rln != rlc) &&
                          (CombinedCheckApplies(rln->idn,checkinstance,LOVERSHTL,rln->Lindex,rln->Sindex,
                               SCCtable[rln->Sindex].C,SCCtable[rln->Sindex].S,SCCtable[rln->Sindex].D,&part1,&part2,&part3) > 0) && (part2 > 0))
                         {
                         k = 1;
                         while(k < rln->numnodes )
                            {
                            km1 = k - 1;
                            ptpdist1 = PointToLineDist2DwithFlag(rlc->x[j], rlc->y[j], rln->x[km1], rln->y[km1], rln->x[k], rln->y[k],&T);
                            if(ptpdist1 <= tol2) /**MGCP_tolerance)**/ /** call these two end nodes a match ***/
                               {
                               break; /** from while rln loop ***/
                               }

                            else if((ptpdist1 < mindist1) && (SensitivityCheck(OPENINT, LOVERSHTL, checkinstance, ptpdist1) > 0))
                               {
                               if(j == 0)
                                  {
                                  ptpdist2 = PointToLineDist2DwithFlag(rlc->x[rlc->numnodes-1], rlc->y[rlc->numnodes-1],
                                         rln->x[km1], rln->y[km1], rln->x[k], rln->y[k],&unuseddbl);
                                  }
                               else
                                  {
                                  ptpdist2 =  PointToLineDist2DwithFlag(rlc->x[0], rlc->y[0],
                                         rln->x[km1], rln->y[km1], rln->x[k], rln->y[k],&unuseddbl);
                                  }
                               if(ptpdist2 > tol2) /**MGCP_tolerance)**/ /** if ptpdist2 < 0.001, call this a match with other endpoint of rlc and don't use it ***/
                                  {
                                  if(LimitedTwoLinesIntersect(rlc,j,rln) > 0)
                                     {
                                     pairedl1 = rln;
                                     pairedIndex = k;
                                     pairedflag = T;
                                     mindist1 = ptpdist1;
                                     }
                                  }
                               }
                            k++;
                            } /*** end while k ***/
                         } /* end rln != rlc ***/
                      if(ptpdist1 <= tol2) /**MGCP_tolerance) **/
                         break;
                      rln = rln->next;
                      } /** end while rln looking for interior segment close-to match ***/
                   if(rln == NULL) /*** did not find an end node to another (interior) node match ***/
                      {
                      if((pairedl1 != NULL) && (SensitivityCheck(OPENINT, LOVERSHTL, checkinstance, mindist1) > 0)) /*** but did find a close node ***/
                         {
                         FoundCondition = 1;
                         }
                      else
                         {
                         foundpair = 0;
                         FoundCondition = 0;
                         Nrln = NLroot;
                         mindist1 = mindist2 = tolerancepad * 2.0;
                         pairedl1 = NULL;
                         while(Nrln != NULL)
                            {
                            if((Nrln->numnodes > 1) &&
                                    (CombinedCheckApplies(Nrln->idn,checkinstance,LOVERSHTL,Nrln->Lindex,Nrln->Sindex,
                                         SCCtable[Nrln->Sindex].C,SCCtable[Nrln->Sindex].S,SCCtable[Nrln->Sindex].D,&part1,&part2,&part3) > 0) &&
                                                (part2 > 0))
                               {
                               k = 1;
                               while(k < Nrln->numnodes)
                                  {
                                  km1 = k - 1;
                                  ptpdist1 = PointToLineDist2DwithFlag(rlc->x[j], rlc->y[j], Nrln->x[km1], Nrln->y[km1], Nrln->x[k], Nrln->y[k],&T);
                                  if(ptpdist1 <= tol2) /**MGCP_tolerance)**/ /** call these two end nodes a match ***/
                                     {
                                     break; /** from while rln loop ***/
                                     }

                                  else if((ptpdist1 < mindist1) && (SensitivityCheck(OPENINT, LOVERSHTL, checkinstance, ptpdist1) > 0))
                                     {
                                     if(j == 0)
                                        {
                                        ptpdist2 = PointToLineDist2DwithFlag(rlc->x[rlc->numnodes-1], rlc->y[rlc->numnodes-1],
                                                     Nrln->x[km1], Nrln->y[km1], Nrln->x[k], Nrln->y[k],&unuseddbl);
                                        }
                                     else
                                        {
                                        ptpdist2 =  PointToLineDist2DwithFlag(rlc->x[0], rlc->y[0],
                                               Nrln->x[km1], Nrln->y[km1], Nrln->x[k], Nrln->y[k],&unuseddbl);
                                        }
                                     if(ptpdist2 > tol2) /**MGCP_tolerance)**/ /** if ptpdist2 < 0.001, call this a match with other endpoint of rlc and don't use it ***/
                                        {
                                        if(LimitedTwoLinesIntersect(rlc,j,Nrln) > 0)
                                           {
                                           pairedl1 = Nrln;
                                           foundpair = 1;
                                           pairedIndex = k;
                                           mindist1 = ptpdist1;
                                           pairedflag = T;
                                           break; /*** break from the while k loop ***/
                                           }
                                        }
                                     }
                                  ++k;
                                  }
                               }

                            if(foundpair > 0)
                               break; /** break from the while Nrln loop ***/
                            Nrln = Nrln->next;
                            } /** end while Nlrn ***/
                         if((pairedl1 != NULL) && (foundpair > 0))
                            {
                            FoundCondition = 1;
                            } /**** end if((pairedl1 != NULL) && (foundpair > 0)) ***/
                         } /*** end else look thru neighbor load module line end nodes ***/
                      } /*** rln == NULL so end if found no end node to interior node match ***/


                   } /** end if endpoint[j] is in the load module  ***/

                if(FoundCondition > 0)
                   {
                   if(mindist1 > ActiveChecks[checkinstance].sensitivity3) /*** if closer than this, call a condition regardless ***/
                      {
                      if(j == 0)
                         km4 = 1;
                      else
                         km4 = 0 - 1;
                      km1 = j + km4;
                      unuseddbl = Distance(rlc->x[j],rlc->y[j],rlc->x[km1],rlc->y[km1]);
                      while((unuseddbl < ActiveChecks[checkinstance].sensitivity4) &&
                               (km1 > 0) && (km1 < (rlc->numnodes - 1)))
                         {
                         km1 += km4;
                         unuseddbl = Distance(rlc->x[j],rlc->y[j],rlc->x[km1],rlc->y[km1]);
                         }

                      if(pairedIndex == 0)
                         km4 = 1;
                      else
                         km4 = 0 - 1;
                      km2 = pairedIndex + km4;

                      unuseddbl = Distance(pairedl1->x[pairedIndex],pairedl1->y[pairedIndex],
                                           pairedl1->x[km2],pairedl1->y[km2]);
                      while((unuseddbl < ActiveChecks[checkinstance].sensitivity4) &&
                               (km2 > 0) && (km2 < (pairedl1->numnodes - 1)))
                         {
                         km2 += km4;
                         unuseddbl = Distance(pairedl1->x[pairedIndex],pairedl1->y[pairedIndex],
                                           pairedl1->x[km2],pairedl1->y[km2]);
                         }
                      if(ParallelAndAdjacentLineSegments(rlc->x[j],rlc->y[j],rlc->x[km1],rlc->y[km1],
                            pairedl1->x[pairedIndex],pairedl1->y[pairedIndex],pairedl1->x[km2],pairedl1->y[km2],
                                ActiveChecks[checkinstance].sensitivity4) > 0)
                         FoundCondition = 0;
                      }
                   }


                if(FoundCondition > 0)
                   {
                   rln = root;
                   while((rln != NULL) && (FoundCondition > 0))
                      {
                      ptpdist1 = tolerancepad * 2.0;
                      if((rln != rlc) &&
                          (CombinedCheckApplies(rln->idn,checkinstance,LOVERSHTL,rln->Lindex,rln->Sindex,
                               SCCtable[rln->Sindex].C,SCCtable[rln->Sindex].S,SCCtable[rln->Sindex].D,&part1,&part2,&part3) > 0) && (part3 > 0))
                         {
                         k = 1;
                         while(k < rln->numnodes )
                            {
                            km1 = k - 1;
                            ptpdist1 = PointToLineDist2DwithFlag(rlc->x[j], rlc->y[j], rln->x[km1], rln->y[km1], rln->x[k], rln->y[k],&T);
                            if(ptpdist1 <= tol2) /**MGCP_tolerance)**/ /** call these two end nodes a match ***/
                               {
                               FoundCondition = 0;
                               break; /** from while rln loop ***/
                               }
                            ++k;
                            }
                         } /** end if check applies as part3 ***/
                      rln = rln->next;
                      } /** end while rln ***/

                   rln = NLroot;
                   while((rln != NULL) && (FoundCondition > 0))
                      {
                      ptpdist1 = tolerancepad * 2.0;
                      if((rln != rlc) &&
                          (CombinedCheckApplies(rln->idn,checkinstance,LOVERSHTL,rln->Lindex,rln->Sindex,
                               SCCtable[rln->Sindex].C,SCCtable[rln->Sindex].S,SCCtable[rln->Sindex].D,&part1,&part2,&part3) > 0) && (part3 > 0))
                         {
                         k = 1;
                         while(k < rln->numnodes )
                            {
                            km1 = k - 1;
                            ptpdist1 = PointToLineDist2DwithFlag(rlc->x[j], rlc->y[j], rln->x[km1], rln->y[km1], rln->x[k], rln->y[k],&T);
                            if(ptpdist1 <= tol2) /**MGCP_tolerance)**/ /** call these two end nodes a match ***/
                               {
                               FoundCondition = 0;
                               break; /** from while rln loop ***/
                               }
                            ++k;
                            }
                         } /** end if check applies as part3 ***/
                      rln = rln->next;
                      } /** end while rln ***/

                   rac = Aroot;
                   while((FoundCondition > 0) && (rac != NULL))
                      {
                      ptpdist1 = tolerancepad * 2.0;
                      if((CombinedCheckApplies(rac->idn,checkinstance,LOVERSHTL,rac->Lindex,rac->Sindex,
                               SCCtable[rac->Sindex].C,SCCtable[rac->Sindex].S,SCCtable[rac->Sindex].D,&part1,&part2,&part3) > 0) && (part3 > 0))
                         {
                         if(rac->RB_Tree_Edgelist == NULL)
                            ptpdist1 = PointToSmallArealDist2D(rlc->x[j], rlc->y[j],rac,&k,&T);
                         else
                            ptpdist1 = PointToLargeArealDist2D(rlc->x[j], rlc->y[j],rac,&k,&T);

                         if((ptpdist1 > -1.0) && (ptpdist1 <= tol2)) /**<= MGCP_tolerance))**/
                            {
                            FoundCondition = 0;
                            break; /** break from the while rac loop ***/
                            }
                         } /* end if combined check applies ***/
                      rac = rac->next;
                      } /** end while rac looking for interior segment close-to match ***/
                   }

                if(FoundCondition > 0)
                   {
                   if(j == 0)
                      {
                      keepit = ConditionOnDataEdge(rlc->x[0],rlc->y[0],rlc->x[1],rlc->y[1],Aroot,Proot,root,
                                                   NULL, NULL, rlc,
                                                   NorthCount,SouthCount,EastCount,WestCount,checkinstance);
                      }
                   else
                      {
                      keepit = ConditionOnDataEdge(rlc->x[j],rlc->y[j],rlc->x[j-1],rlc->y[j-1],Aroot,Proot,root,
                                                   NULL, NULL, rlc,
                                                   NorthCount,SouthCount,EastCount,WestCount,checkinstance);
                      }
                   if(keepit <= 0)
                      FoundCondition = 0;
                   }

                if(FoundCondition > 0) /** need to add a condition to the list ***/
                   {
                   FoundCondition = 0;
                   ERc = (struct collection *) (malloc(SzC));
                   if(ERc == NULL)
                     {
                     printf("allocation memory exhausted during linear feature condition analysis (Z-shear analysis)\n");
                     printf("processing cannot continue\n");
                     exit(-1);
                     }
                   ERc->magnitude = mindist1;
                   ERc->x[0] = rlc->x[j];
                   ERc->y[0] = rlc->y[j];
                   ERc->z[0] = rlc->z[j];
                   if((pairedflag <= 0) || (pairedflag >= 1)) /** then only want a vertex to vertex condition ***/
                      {
                      ERc->numpoints = 2;
                      if(pairedflag <= 0)
                         {
                         ERc->x[1] = pairedl1->x[pairedIndex-1];
                         ERc->y[1] = pairedl1->y[pairedIndex-1];
                         ERc->z[1] = pairedl1->z[pairedIndex-1];
                         }
                      else
                         {
                         ERc->x[1] = pairedl1->x[pairedIndex];
                         ERc->y[1] = pairedl1->y[pairedIndex];
                         ERc->z[1] = pairedl1->z[pairedIndex];
                         }
                      }
                   else
                      {
                      ERc->numpoints = 3;
                      ERc->x[1] = pairedl1->x[pairedIndex];
                      ERc->y[1] = pairedl1->y[pairedIndex];
                      ERc->z[1] = pairedl1->z[pairedIndex];
                      ERc->x[2] = pairedl1->x[pairedIndex-1];
                      ERc->y[2] = pairedl1->y[pairedIndex-1];
                      ERc->z[2] = pairedl1->z[pairedIndex-1];
                      }

                   ERc->IDN = rlc->idn;
                   ERc->Sindex = rlc->Sindex;
                   ERc->aa = NULL; /** RawAreal **/
                   ERc->bb = NULL; /** RawBridge **/
                   ERc->pp = NULL; /** RawPoint **/
                   ERc->le = NULL; /** ListOfEdges **/
                   ERc->poly = NULL; /** ThePolys **/
                   ERc->ll1 = rlc;
                   ERc->ll2 = pairedl1;
                   ERc->keyval = LOVERSHTL;
                   ERc->Cnumber = Make_Correct(LOVERSHTL,checkinstance);

                   if(ERroot == NULL)
                      {
                      ERroot = ERc;
                      ERroot->next = NULL;
                      }
                   else
                      {
                      ERn = ERroot;
                      while(ERn != NULL)
                         {
                         if((ERn->keyval == ERc->keyval) && (ERc->Cnumber == ERn->Cnumber))
                            {
                            if((ERn->ll1 == ERc->ll1) && (ERn->ll2 == ERc->ll2))
                               {
break;
                               }
                            else if((ERn->ll1 == ERc->ll2) && (ERn->ll2 == ERc->ll1))
                               {
break;
                               }
                            }
                         ERn = ERn->next;
                         }
                      if(ERn == NULL)
                         {
                         ERc->next = ERroot;
                         ERroot = ERc;
                         }
                      else
                         {
                         free(ERc);
                         }
                      }

                   } /*** end FoundCondition ***/
                j += rlc->numnodes - 1;
                } /*** while j < rlc->numnodes ***/
             } /*** end LOVERSHTL check applies ***/



          if((CombinedCheckApplies(rlc->idn,checkinstance,LOSHTL_DF,rlc->Lindex,rlc->Sindex,Config1,Strat1,Domain1,&part1,&part2,&part3) > 0) && (part1 > 0))
             {
             j = 0;
             FoundCondition = 0;
             tol2 = FindRelevantSensitivity(LOSHTL_DF,checkinstance,&tolerancepad);
             while(j < rlc->numnodes)
                {
                if((rlc->x[j] >= minx) && (rlc->x[j] <= maxx) && (rlc->y[j] >= miny) && (rlc->y[j] <= maxy) &&
                       (LineEndClosesOnItself2D(rlc,j,tolerancepad) == 0))
                   {
                   LocalMinX = rlc->x[j] - tolerancepad - 1;
                   LocalMaxX = rlc->x[j] + tolerancepad + 1;
                   LocalMinY = rlc->y[j] - tolerancepad - 1;
                   LocalMaxY = rlc->y[j] + tolerancepad + 1;
                   mindist1 = mindist2 = tolerancepad * 2.0;
                   pairedl1 = NULL;
                   rln = root;
                   while(rln != NULL)
                      {
                      ptpdist1 = tolerancepad * 2.0;
                      if((rln != rlc) && 
                          (CombinedCheckApplies(rln->idn,checkinstance,LOSHTL_DF,rln->Lindex,rln->Sindex,
                               SCCtable[rln->Sindex].C,SCCtable[rln->Sindex].S,SCCtable[rln->Sindex].D,&part1,&part2,&part3) > 0) && (part2 > 0))
                         {
                         k = 1;
                         while(k < rln->numnodes )
                            {
                            km1 = k - 1;
                            ptpdist1 = PointToLineDist2DwithFlag(rlc->x[j], rlc->y[j], rln->x[km1], rln->y[km1], rln->x[k], rln->y[k],&T);
                            if(ptpdist1 <= tol2) /**MGCP_tolerance)**/ /** call these two end nodes a match ***/
                               {
                               break; /** from while rln loop ***/
                               }

                            else if((ptpdist1 < mindist1) && (SensitivityCheck(OPENINT, LOSHTL_DF, checkinstance, ptpdist1) > 0))                               {                               if(j == 0)
                                  {
                                  ptpdist2 = PointToLineDist2DwithFlag(rlc->x[rlc->numnodes-1], rlc->y[rlc->numnodes-1],
                                         rln->x[km1], rln->y[km1], rln->x[k], rln->y[k],&unuseddbl);
                                  }
                               else
                                  {
                                  ptpdist2 =  PointToLineDist2DwithFlag(rlc->x[0], rlc->y[0],
                                         rln->x[km1], rln->y[km1], rln->x[k], rln->y[k],&unuseddbl);
                                  }
                               if(ptpdist2 > tol2) /**MGCP_tolerance)**/ /** if ptpdist2 < 0.001, call this a match with other endpoint of rlc and don't use it ***/
                                  {
                                  if((SCCtable[rln->Sindex].ECC != SCCtable[rlc->Sindex].ECC) &&
                                          (LimitedTwoLinesIntersect(rlc,j,rln) > 0))
                                     {
                                     pairedl1 = rln;
                                     pairedIndex = k;
                                     pairedflag = T;
                                     mindist1 = ptpdist1;
                                     }
                                  }
                               }
                            k++;
                            } /*** end while k ***/
                         } /* end rln != rlc ***/
                      if(ptpdist1 <= tol2) /**MGCP_tolerance) **/
                         break;
                      rln = rln->next;
                      } /** end while rln looking for interior segment close-to match ***/
                   if(rln == NULL) /*** did not find an end node to another (interior) node match ***/
                      {
                      if((pairedl1 != NULL) && (SensitivityCheck(OPENINT, LOSHTL_DF, checkinstance, mindist1) > 0)) /*** but did find a close node ***/
                         {
                         FoundCondition = 1;
                         }
                      else
                         {
                         foundpair = 0;
                         FoundCondition = 0;
                         Nrln = NLroot;
                         mindist1 = mindist2 = tolerancepad * 2.0;
                         pairedl1 = NULL;
                         while(Nrln != NULL)
                            {
                            if((Nrln->numnodes > 1) && 
                                    (CombinedCheckApplies(Nrln->idn,checkinstance,LOSHTL_DF,Nrln->Lindex,Nrln->Sindex,
                                         SCCtable[Nrln->Sindex].C,SCCtable[Nrln->Sindex].S,SCCtable[Nrln->Sindex].D,&part1,&part2,&part3) > 0) &&
                                                (part2 > 0))
                               {
                               k = 1;
                               while(k < Nrln->numnodes)
                                  {
                                  km1 = k - 1;
                                  ptpdist1 = PointToLineDist2DwithFlag(rlc->x[j], rlc->y[j], Nrln->x[km1], Nrln->y[km1], Nrln->x[k], Nrln->y[k],&T);
                                  if((ptpdist1 > tol2) /**MGCP_tolerance)**/ && (ptpdist1 < mindist1) && (SensitivityCheck(OPENINT, LOSHTL_DF, checkinstance, ptpdist1) > 0))
                                     {
                                     if(j == 0)
                                        {
                                        ptpdist2 = PointToLineDist2DwithFlag(rlc->x[rlc->numnodes-1], rlc->y[rlc->numnodes-1],
                                                     Nrln->x[km1], Nrln->y[km1], Nrln->x[k], Nrln->y[k],&unuseddbl);
                                        }
                                     else
                                        {
                                        ptpdist2 =  PointToLineDist2DwithFlag(rlc->x[0], rlc->y[0],
                                               Nrln->x[km1], Nrln->y[km1], Nrln->x[k], Nrln->y[k],&unuseddbl);
                                        }
                                     if(ptpdist2 > tol2) /**MGCP_tolerance)**/ /** if ptpdist2 < 0.001, call this a match with other endpoint of rlc and don't use it ***/
                                        {
                                        if((SCCtable[Nrln->Sindex].ECC != SCCtable[rlc->Sindex].ECC) &&
                                                   (LimitedTwoLinesIntersect(rlc,j,Nrln) > 0))
                                           {
                                           pairedl1 = Nrln;
                                           foundpair = 1;
                                           pairedIndex = k;
                                           mindist1 = ptpdist1;
                                           pairedflag = T;
                                           break; /*** break from the while k loop ***/
                                           }
                                        }
                                     }
                                  ++k;
                                  }
                               }

                            if(foundpair > 0)
                               break; /** break from the while Nrln loop ***/
                            Nrln = Nrln->next;
                            } /** end while Nlrn ***/
                         if((pairedl1 != NULL) && (foundpair > 0))
                            {
                            FoundCondition = 1;
                            } /**** end if((pairedl1 != NULL) && (foundpair > 0)) ***/
                         } /*** end else look thru neighbor load module line end nodes ***/
                      } /*** rln == NULL so end if found no end node to interior node match ***/


                   } /** end if endpoint[j] is in the load module  ***/

                if((FoundCondition > 0) && (SCCtable[pairedl1->Sindex].ECC == SCCtable[rlc->Sindex].ECC))
                   FoundCondition = 0;

                if(FoundCondition > 0)
                   {
                   if(mindist1 > ActiveChecks[checkinstance].sensitivity3) /*** if closer than this, call a condition regardless ***/
                      {
                      if(j == 0)
                         km4 = 1;
                      else
                         km4 = 0 - 1;
                      km1 = j + km4;
                      unuseddbl = Distance(rlc->x[j],rlc->y[j],rlc->x[km1],rlc->y[km1]);
                      while((unuseddbl < ActiveChecks[checkinstance].sensitivity4) &&
                               (km1 > 0) && (km1 < (rlc->numnodes - 1)))
                         {
                         km1 += km4;
                         unuseddbl = Distance(rlc->x[j],rlc->y[j],rlc->x[km1],rlc->y[km1]);
                         }

                      if(pairedIndex == 0)
                         km4 = 1;
                      else
                         km4 = 0 - 1;
                      km2 = pairedIndex + km4;

                      unuseddbl = Distance(pairedl1->x[pairedIndex],pairedl1->y[pairedIndex],
                                           pairedl1->x[km2],pairedl1->y[km2]);
                      while((unuseddbl < ActiveChecks[checkinstance].sensitivity4) &&
                               (km2 > 0) && (km2 < (pairedl1->numnodes - 1)))
                         {
                         km2 += km4;
                         unuseddbl = Distance(pairedl1->x[pairedIndex],pairedl1->y[pairedIndex],
                                           pairedl1->x[km2],pairedl1->y[km2]);
                         }
                      if(ParallelAndAdjacentLineSegments(rlc->x[j],rlc->y[j],rlc->x[km1],rlc->y[km1],
                            pairedl1->x[pairedIndex],pairedl1->y[pairedIndex],pairedl1->x[km2],pairedl1->y[km2],
                                ActiveChecks[checkinstance].sensitivity4) > 0)
                         FoundCondition = 0;
                      }
                   }


                if(FoundCondition > 0)
                   {
                   rln = root;
                   while((rln != NULL) && (FoundCondition > 0))
                      {
                      ptpdist1 = tolerancepad * 2.0;
                      if((rln != rlc) &&
                          (CombinedCheckApplies(rln->idn,checkinstance,LOSHTL_DF,rln->Lindex,rln->Sindex,
                               SCCtable[rln->Sindex].C,SCCtable[rln->Sindex].S,SCCtable[rln->Sindex].D,&part1,&part2,&part3) > 0) && (part3 > 0))
                         {
                         k = 1;
                         while(k < rln->numnodes )
                            {
                            km1 = k - 1;
                            ptpdist1 = PointToLineDist2DwithFlag(rlc->x[j], rlc->y[j], rln->x[km1], rln->y[km1], rln->x[k], rln->y[k],&T);
                            if(ptpdist1 <= tol2) /**MGCP_tolerance)**/ /** call these two end nodes a match ***/
                               {
                               FoundCondition = 0;
                               break; /** from while rln loop ***/
                               }
                            ++k;
                            }
                         } /** end if check applies as part3 ***/
                      rln = rln->next;
                      } /** end while rln ***/

                   rln = NLroot;
                   while((rln != NULL) && (FoundCondition > 0))
                      {
                      ptpdist1 = tolerancepad * 2.0;
                      if((rln != rlc) &&
                          (CombinedCheckApplies(rln->idn,checkinstance,LOSHTL_DF,rln->Lindex,rln->Sindex,
                               SCCtable[rln->Sindex].C,SCCtable[rln->Sindex].S,SCCtable[rln->Sindex].D,&part1,&part2,&part3) > 0) && (part3 > 0))
                         {
                         k = 1;
                         while(k < rln->numnodes )
                            {
                            km1 = k - 1;
                            ptpdist1 = PointToLineDist2DwithFlag(rlc->x[j], rlc->y[j], rln->x[km1], rln->y[km1], rln->x[k], rln->y[k],&T);
                            if(ptpdist1 <= tol2) /**MGCP_tolerance)**/ /** call these two end nodes a match ***/
                               {
                               FoundCondition = 0;
                               break; /** from while rln loop ***/
                               }
                            ++k;
                            }
                         } /** end if check applies as part3 ***/
                      rln = rln->next;
                      } /** end while rln ***/

                   rac = Aroot;
                   while((FoundCondition > 0) && (rac != NULL))
                      {
                      ptpdist1 = tolerancepad * 2.0;
                      if((CombinedCheckApplies(rac->idn,checkinstance,LOSHTL_DF,rac->Lindex,rac->Sindex,
                               SCCtable[rac->Sindex].C,SCCtable[rac->Sindex].S,SCCtable[rac->Sindex].D,&part1,&part2,&part3) > 0) && (part3 > 0))
                         {
                         if(rac->RB_Tree_Edgelist == NULL)
                            ptpdist1 = PointToSmallArealDist2D(rlc->x[j], rlc->y[j],rac,&k,&T);
                         else
                            ptpdist1 = PointToLargeArealDist2D(rlc->x[j], rlc->y[j],rac,&k,&T);

                         if((ptpdist1 > -1.0) && (ptpdist1 <= tol2)) /**<= MGCP_tolerance)) **/
                            {
                            FoundCondition = 0;
                            break; /** break from the while rac loop ***/
                            }
                         } /* end if combined check applies ***/
                      rac = rac->next;
                      } /** end while rac looking for interior segment close-to match ***/
                   }
                if(FoundCondition > 0)
                   {
                   if(j == 0)
                      {
                      keepit = ConditionOnDataEdge(rlc->x[0],rlc->y[0],rlc->x[1],rlc->y[1],Aroot,Proot,root,
                                                   NULL, NULL, rlc,
                                                   NorthCount,SouthCount,EastCount,WestCount,checkinstance);
                      }
                   else
                      {
                      keepit = ConditionOnDataEdge(rlc->x[j],rlc->y[j],rlc->x[j-1],rlc->y[j-1],Aroot,Proot,root,
                                                   NULL, NULL, rlc,
                                                   NorthCount,SouthCount,EastCount,WestCount,checkinstance);
                      }
                   if(keepit <= 0)
                      FoundCondition = 0;
                   }


                if(FoundCondition > 0) /** need to add a condition to the list ***/
                   {
                   FoundCondition = 0;
                   ERc = (struct collection *) (malloc(SzC));
                   if(ERc == NULL)
                     {
                     printf("allocation memory exhausted during linear feature condition analysis (Z-shear analysis)\n");
                     printf("processing cannot continue\n");
                     exit(-1);
                     }
                   ERc->magnitude = mindist1;
                   ERc->x[0] = rlc->x[j];
                   ERc->y[0] = rlc->y[j];
                   ERc->z[0] = rlc->z[j];
                   if((pairedflag <= 0) || (pairedflag >= 1)) /** then only want a vertex to vertex condition ***/
                      {
                      ERc->numpoints = 2;
                      if(pairedflag <= 0)
                         {
                         ERc->x[1] = pairedl1->x[pairedIndex-1];
                         ERc->y[1] = pairedl1->y[pairedIndex-1];
                         ERc->z[1] = pairedl1->z[pairedIndex-1];
                         }
                      else
                         {
                         ERc->x[1] = pairedl1->x[pairedIndex];
                         ERc->y[1] = pairedl1->y[pairedIndex];
                         ERc->z[1] = pairedl1->z[pairedIndex];
                         }
                      }
                   else
                      {
                      ERc->numpoints = 3;
                      ERc->x[1] = pairedl1->x[pairedIndex];
                      ERc->y[1] = pairedl1->y[pairedIndex];
                      ERc->z[1] = pairedl1->z[pairedIndex];
                      ERc->x[2] = pairedl1->x[pairedIndex-1];
                      ERc->y[2] = pairedl1->y[pairedIndex-1];
                      ERc->z[2] = pairedl1->z[pairedIndex-1];
                      }

                   ERc->IDN = rlc->idn;
                   ERc->Sindex = rlc->Sindex;
                   ERc->aa = NULL; /** RawAreal **/
                   ERc->bb = NULL; /** RawBridge **/
                   ERc->pp = NULL; /** RawPoint **/
                   ERc->le = NULL; /** ListOfEdges **/
                   ERc->poly = NULL; /** ThePolys **/
                   ERc->ll1 = rlc;
                   ERc->ll2 = pairedl1;
                   ERc->keyval = LOSHTL_DF;
                   ERc->Cnumber = Make_Correct(LOSHTL_DF,checkinstance);

                   if(ERroot == NULL)
                      {
                      ERroot = ERc;
                      ERroot->next = NULL;
                      }
                   else
                      {
                      ERn = ERroot;
                      while(ERn != NULL)
                         {
                         if((ERn->keyval == ERc->keyval) && (ERc->Cnumber == ERn->Cnumber))
                            {
                            if((ERn->ll1 == ERc->ll1) && (ERn->ll2 == ERc->ll2))
                               {
break;
                               }
                            else if((ERn->ll1 == ERc->ll2) && (ERn->ll2 == ERc->ll1))
                               {
break;
                               }
                            }
                         ERn = ERn->next;
                         }
                      if(ERn == NULL)
                         {
                         ERc->next = ERroot;
                         ERroot = ERc;
                         }
                      else
                         {
                         free(ERc);
                         }
                      }

                   } /*** end FoundCondition ***/
                j += rlc->numnodes - 1;
                } /*** while j < rlc->numnodes ***/
             } /*** end LOSHTL_DF check applies ***/




          if((CombinedCheckApplies(rlc->idn,checkinstance,LOVERSHTA,rlc->Lindex,rlc->Sindex,Config1,Strat1,Domain1,&part1,&part2,&part3) > 0) && (part1 > 0))
             {
             j = 0;
             FoundCondition = 0;
             tol2 = FindRelevantSensitivity(LOVERSHTA,checkinstance,&tolerancepad);
             while(j < rlc->numnodes)
                {
                if((rlc->x[j] >= minx) && (rlc->x[j] <= maxx) && (rlc->y[j] >= miny) && (rlc->y[j] <= maxy))
                   {
                   rln = root;
                   fndpr = 0;
                   while(rln != NULL)
                      {
                      if((rln != rlc) &&
                          (CombinedCheckApplies(rln->idn,checkinstance,LOVERSHTA,rln->Lindex,rln->Sindex,
                               SCCtable[rln->Sindex].C,SCCtable[rln->Sindex].S,SCCtable[rln->Sindex].D,&part1,&part2,&part3) > 0) && (part2 > 0))
                         {
                         for(i=0; i<rln->numnodes; i++)
                            {
                            if((rln->x[i] == rlc->x[j]) && (rln->y[i] == rlc->y[j]))
                               {
                               fndpr = 1;
                               break;
                               }
                            }
                         }
                      if(fndpr > 0)
                         break;
                      rln = rln->next;
                      }

                   if(rln == NULL)
                      {
                      mindist1 = mindist2 = tolerancepad * 2.0;
                      paireda1 = NULL;
                      rac = Aroot;
                      }
                   else
                      {
                      paireda1 = NULL;
                      rac = NULL;
                      }
                         
                   while(rac != NULL)
                      {
                      ptpdist1 = tolerancepad * 2.0;
                      if((CombinedCheckApplies(rac->idn,checkinstance,LOVERSHTA,rac->Lindex,rac->Sindex,
                               SCCtable[rac->Sindex].C,SCCtable[rac->Sindex].S,SCCtable[rac->Sindex].D,&part1,&part2,&part3) > 0) && (part3 > 0))
                         {
                         if(rac->RB_Tree_Edgelist == NULL)
                            ptpdist1 = PointToSmallArealDist2D(rlc->x[j], rlc->y[j],rac,&k,&T);
                         else
                            ptpdist1 = PointToLargeArealDist2D(rlc->x[j], rlc->y[j],rac,&k,&T);

                         if((ptpdist1 > -1.0) && (ptpdist1 <= tol2)) /**MGCP_tolerance))**/ /** call these two end nodes a match ***/
                            {
                            break; /** from while rac loop ***/
                            }

                         else if((ptpdist1 < mindist1) && (SensitivityCheck(OPENINT, LOVERSHTA, checkinstance, ptpdist1) > 0))                          
                            {
                            if(j == 0) 
                               {
                               if(rac->RB_Tree_Edgelist == NULL)
                                  ptpdist2 = PointToSmallArealDist2D(rlc->x[rlc->numnodes-1], rlc->y[rlc->numnodes-1],rac,&km1,&unuseddbl);
                               else
                                  ptpdist2 = PointToLargeArealDist2D(rlc->x[rlc->numnodes-1], rlc->y[rlc->numnodes-1],rac,&km1,&unuseddbl);
                               }
                            else
                               {
                               if(rac->RB_Tree_Edgelist == NULL)
                                  ptpdist2 = PointToSmallArealDist2D(rlc->x[0], rlc->y[0],rac,&km1,&unuseddbl);
                               else
                                  ptpdist2 = PointToLargeArealDist2D(rlc->x[0], rlc->y[0],rac,&km1,&unuseddbl);
                               }
                            if((ptpdist2 < -99.0) || (ptpdist2 > tol2)) /**MGCP_tolerance))**/ /** if ptpdist2 < 0.001, call this a match with other endpoint of rlc and don't use it ***/
                               {
                               /**if(TwoLinesIntersect(rlc,rac) > 0) ***/
                               if(rac->RB_Tree_Edgelist == NULL)
                                  {
                                  end1 = PointInsidePoly(rlc->x[j],rlc->y[j],rac->x, rac->y, rac->numverts);
                                  if(j == 0)
                                     end2 = PointInsidePoly(rlc->x[rlc->numnodes-1],rlc->y[rlc->numnodes-1],rac->x, rac->y, rac->numverts);
                                  else
                                     end2 = PointInsidePoly(rlc->x[0],rlc->y[0],rac->x, rac->y, rac->numverts);
                                  } 
                               else 
                                  { 
                                  end1 = PointInsideLargeAreal(rlc->x[j], rlc->y[j] ,rac, &onedge);
                                  if(j == 0)
                                     end2 = PointInsideLargeAreal(rlc->x[rlc->numnodes-1], rlc->y[rlc->numnodes-1] ,rac, &onedge);
                                  else
                                     end2 = PointInsideLargeAreal(rlc->x[0], rlc->y[0] ,rac, &onedge);
                                  }
                               if((end1 > 0) && (end2 < 1))
                                  {
                                  paireda1 = rac;
                                  pairedIndex = k; 
                                  pairedflag = T; 
                                  mindist1 = ptpdist1;
                                  }
                               else if((end1 < 1) && (end2 > 0))
                                  {
                                  paireda1 = rac;
                                  pairedIndex = k;
                                  pairedflag = T;
                                  mindist1 = ptpdist1;
                                  }
                               }
                            }
                         } /* end if combined check applies ***/
                      if(ptpdist1 <= tol2) /**MGCP_tolerance)**/
                         break;
                      rac = rac->next;
                      } /** end while rac looking for interior segment close-to match ***/
                   if(rac == NULL) /*** did not find an end node to another (interior) node match ***/
                      {
                      if((paireda1 != NULL) && (SensitivityCheck(OPENINT, LOVERSHTA, checkinstance, mindist1) > 0)) /*** but did find a close node ***/
                         {
                         FoundCondition = 1;
                         }
                      } /*** rac == NULL so end if found no end node to interior node match ***/


                   } /** end if endpoint[j] is in the load module  ***/
                if(FoundCondition > 0) /** need to add a condition to the list ***/
                   {
                   FoundCondition = 0;
                   ERc = (struct collection *) (malloc(SzC));
                   if(ERc == NULL)
                     {
                     printf("allocation memory exhausted during linear feature condition analysis (Z-shear analysis)\n");
                     printf("processing cannot continue\n");
                     exit(-1);
                     }
                   ERc->magnitude = mindist1;
                   ERc->x[0] = rlc->x[j];
                   ERc->y[0] = rlc->y[j];
                   ERc->z[0] = rlc->z[j];
                   if((pairedflag <= 0) || (pairedflag >= 1)) /** then only want a vertex to vertex condition ***/
                      {
                      ERc->numpoints = 2;
                      ERc->x[1] = paireda1->x[pairedIndex];
                      ERc->y[1] = paireda1->y[pairedIndex];
                      ERc->z[1] = paireda1->z[pairedIndex];
                      }
                   else
                      {
                      ERc->numpoints = 3;
                      ERc->x[1] = paireda1->x[pairedIndex];
                      ERc->y[1] = paireda1->y[pairedIndex];
                      ERc->z[1] = paireda1->z[pairedIndex];
                      if(pairedIndex > 0)
                         {
                         ERc->x[2] = paireda1->x[pairedIndex-1];
                         ERc->y[2] = paireda1->y[pairedIndex-1];
                         ERc->z[2] = paireda1->z[pairedIndex-1];
                         }
                      else
                         {
                         ERc->x[2] = paireda1->x[paireda1->numverts-1];
                         ERc->y[2] = paireda1->y[paireda1->numverts-1];
                         ERc->z[2] = paireda1->z[paireda1->numverts-1];
                         }
                      }

                   ERc->IDN = rlc->idn;
                   ERc->Sindex = rlc->Sindex;
                   ERc->aa = paireda1; /** RawAreal **/
                   ERc->bb = NULL; /** RawBridge **/
                   ERc->pp = NULL; /** RawPoint **/
                   ERc->le = NULL; /** ListOfEdges **/
                   ERc->poly = NULL; /** ThePolys **/
                   ERc->ll1 = rlc;
                   ERc->ll2 = NULL;
                   ERc->keyval = LOVERSHTA;
                   ERc->Cnumber = Make_Correct(LOVERSHTA,checkinstance);

                   if(ERroot == NULL)
                      {
                      ERroot = ERc;
                      ERroot->next = NULL;
                      }
                   else
                      {
                      ERn = ERroot;
                      while(ERn != NULL)
                         {
                         if((ERn->keyval == ERc->keyval) && (ERc->Cnumber == ERn->Cnumber))
                            {
                            if((ERn->ll1 == ERc->ll1) && (ERn->aa == ERc->aa))
                               {
                               if((ERc->x[0] == ERn->x[0]) && (ERc->y[0] == ERn->y[0]) && (ERc->z[0] == ERn->z[0]) &&
                                      (ERc->x[1] == ERn->x[1]) && (ERc->y[1] == ERn->y[1]) && (ERc->z[1] == ERn->z[1]))
                                  {
                                  break;
                                  }
                               else if((ERc->x[0] == ERn->x[1]) && (ERc->y[0] == ERn->y[1]) && (ERc->z[0] == ERn->z[1]) &&
                                      (ERc->x[1] == ERn->x[0]) && (ERc->y[1] == ERn->y[0]) && (ERc->z[1] == ERn->z[0]))
                                  {
                                  break;
                                  }
                               }
                            }
                         ERn = ERn->next;
                         }
                      if(ERn == NULL)
                         {
                         ERc->next = ERroot;
                         ERroot = ERc;
                         }
                      else
                         {
                         free(ERc);
                         }
                      }

                   } /*** end FoundCondition ***/
                j += rlc->numnodes - 1;
                } /*** while j < rlc->numnodes ***/
             } /*** end LOVERSHTA check applies ***/



          if((CombinedCheckApplies(rlc->idn,checkinstance,LUNDERSHTA,rlc->Lindex,rlc->Sindex,Config1,Strat1,Domain1,&part1,&part2,&part3) > 0) && (part1 > 0))
             {
             j = 0;
             FoundCondition = 0;
             paireda1 = NULL;
             tol2 = FindRelevantSensitivity(LUNDERSHTA,checkinstance,&tolerancepad);
             while(j < rlc->numnodes)
                {
                FoundCondition = 0;
                if((rlc->x[j] >= minx) && (rlc->x[j] <= maxx) && (rlc->y[j] >= miny) && (rlc->y[j] <= maxy))
                   {
                   rln = root;
                   rac = NULL;
                   fndpr = 0;
                   while(rln != NULL)
                      {
                      if((rln != rlc) &&
                          (CombinedCheckApplies(rln->idn,checkinstance,LUNDERSHTA,rln->Lindex,rln->Sindex,
                               SCCtable[rln->Sindex].C,SCCtable[rln->Sindex].S,SCCtable[rln->Sindex].D,&part1,&part2,&part3) > 0) && (part2 > 0))
                         {
                         for(i=0; i<rln->numnodes; i++)
                            {
                            mindist1 = Distance(rlc->x[j],rlc->y[j],rln->x[i],rln->y[i]);
                            if(mindist1 <= tol2)
                               {
                               fndpr = 1;
                               break;
                               }
                            }
                         }
                      if(fndpr > 0)
                         break;
                      rln = rln->next;
                      }
                   if(rln == NULL)
                      {
                      rac = Aroot;
                      while(rac != NULL)
                         {
                         if((CombinedCheckApplies(rac->idn,checkinstance,LUNDERSHTA,rac->Lindex,rac->Sindex,
                          SCCtable[rac->Sindex].C,SCCtable[rac->Sindex].S,SCCtable[rac->Sindex].D,&part1,&part2,&part3) > 0) &&
                                    (part2 > 0))
                            {
                            if(rac->RB_Tree_Edgelist == NULL)
                               ptpdist1 = PointToSmallArealDist2D(rlc->x[j], rlc->y[j],rac,&k,&T);
                            else
                               ptpdist1 = PointToLargeArealDist2D(rlc->x[j], rlc->y[j],rac,&k,&T);

                            if((ptpdist1 > -1.0) && (ptpdist1 <= tol2)) /** call these two a match ***/
                               {
                               break; /** from while rac loop ***/
                               }
                            }

                         rac = rac->next;
                         }
                      }

                   if((rln == NULL) && (rac == NULL)) /** then could not be paired with either a secondary line or area **/
                      {
                      mindist1 = mindist2 = tolerancepad * 2.0;
                      paireda1 = NULL;
                      rac = Aroot;
                      timesthru = 0;
                      if(Aroot == NULL)
                         {
                         rac = NeighborARoot;
                         timesthru = 1;
                         }
                      }
                   else
                      {
                      paireda1 = NULL;
                      rac = NULL;
                      timesthru = 99;
                      }

                   while((timesthru < 2) && (rac != NULL))
                      {
                      ptpdist1 = tolerancepad * 2.0;
                      if((CombinedCheckApplies(rac->idn,checkinstance,LUNDERSHTA,rac->Lindex,rac->Sindex,
                               SCCtable[rac->Sindex].C,SCCtable[rac->Sindex].S,SCCtable[rac->Sindex].D,&part1,&part2,&part3) > 0) && (part3 > 0))
                         {
                         if(rac->RB_Tree_Edgelist == NULL)
                            ptpdist1 = PointToSmallArealDist2D(rlc->x[j], rlc->y[j],rac,&k,&T);
                         else
                            ptpdist1 = PointToLargeArealDist2D(rlc->x[j], rlc->y[j],rac,&k,&T);

                         if((ptpdist1 > -1.0) && (ptpdist1 <= tol2)) /**MGCP_tolerance))**/ /** call these two end nodes a match ***/
                            {
                            break; /** from while rac loop ***/
                            }

                         else if((ptpdist1 > -1) && (ptpdist1 < mindist1) && (SensitivityCheck(OPENINT, LUNDERSHTA, checkinstance, ptpdist1) > 0))
                            {
                            if(j == 0)
                               {
                               if(rac->RB_Tree_Edgelist == NULL)
                                  ptpdist2 = PointToSmallArealDist2D(rlc->x[rlc->numnodes-1], rlc->y[rlc->numnodes-1],rac,&km1,&unuseddbl);
                               else
                                  ptpdist2 = PointToLargeArealDist2D(rlc->x[rlc->numnodes-1], rlc->y[rlc->numnodes-1],rac,&km1,&unuseddbl);
                               }
                            else
                               {
                               if(rac->RB_Tree_Edgelist == NULL)
                                  ptpdist2 = PointToSmallArealDist2D(rlc->x[0], rlc->y[0],rac,&km1,&unuseddbl);
                               else
                                  ptpdist2 = PointToLargeArealDist2D(rlc->x[0], rlc->y[0],rac,&km1,&unuseddbl);
                               }
                            if((ptpdist2 < -99.0) || (ptpdist2 > tol2)) /**MGCP_tolerance))**/ /** if ptpdist2 < 0.001, call this a match with other endpoint of rlc and don't use it ***/
                               {
                               /**if(TwoLinesIntersect(rlc,rac) > 0) ***/
                               if(rac->RB_Tree_Edgelist == NULL)
                                  {
                                  end1 = PointInsidePoly(rlc->x[j],rlc->y[j],rac->x, rac->y, rac->numverts);
                                  if(j == 0)
                                     end2 = PointInsidePoly(rlc->x[rlc->numnodes-1],rlc->y[rlc->numnodes-1],rac->x, rac->y, rac->numverts);
                                  else
                                     end2 = PointInsidePoly(rlc->x[0],rlc->y[0],rac->x, rac->y, rac->numverts);
                                  }
                               else
                                  {
                                  end1 = PointInsideLargeAreal(rlc->x[j], rlc->y[j] ,rac, &onedge);
                                  if(j == 0)
                                     end2 = PointInsideLargeAreal(rlc->x[rlc->numnodes-1], rlc->y[rlc->numnodes-1] ,rac, &onedge);
                                  else
                                     end2 = PointInsideLargeAreal(rlc->x[0], rlc->y[0] ,rac, &onedge);
                                  }
                               if((end1 > 0) && (end2 > 0))
                                  {
                                  paireda1 = rac;
                                  pairedIndex = k;
                                  pairedflag = T;
                                  mindist1 = ptpdist1;
                                  }
                               else if((end1 < 1) && (end2 < 1))
                                  {
                                  paireda1 = rac;
                                  pairedIndex = k;
                                  pairedflag = T;
                                  mindist1 = ptpdist1;
                                  }
                               }
                            }
                         } /* end if combined check applies ***/
                      if((ptpdist1 > -1) && (ptpdist1 <= tol2)) /** MGCP_tolerance))**/
                         break;
                      rac = rac->next;
                      if(rac == NULL)
                         {
                         ++timesthru;
                         if(timesthru == 1)
                            rac = NeighborARoot;
                         }

                      } /** end while rac looking for interior segment close-to match ***/
                   if(rac == NULL) /*** did not find an end node to another (interior) node match ***/
                      {
                      if((paireda1 != NULL) && (mindist1 >= 0) && (SensitivityCheck(OPENINT, LUNDERSHTA, checkinstance, mindist1) > 0)) /*** but did find a close node ***/
                         {
                         FoundCondition = 1;
                         }
                      } /*** rac == NULL so end if found no end node to interior node match ***/


                   } /** end if endpoint[j] is in the load module  ***/
                if((FoundCondition > 0) && (paireda1 != NULL))
                   {
                   ran = Aroot;
                   while(ran != NULL)
                      {
                      if((ran != paireda1) &&
                             (CombinedCheckApplies(ran->idn,checkinstance,LUNDERSHTA,ran->Lindex,ran->Sindex,
                               SCCtable[ran->Sindex].C,SCCtable[ran->Sindex].S,SCCtable[ran->Sindex].D,&part1,&part2,&part3) > 0) && (part3 > 0))
                         {
                         if(paireda1->ishole <= 0)
                            {
                            if(ran->RB_Tree_Edgelist == NULL)
                               {
                               if(PointInsidePoly(rlc->x[j],rlc->y[j],ran->x,ran->y,ran->numverts) > 0)
                                  {
                                  FoundCondition = 0;
                                  break;
                                  }
                               }
                            else if(PointInsideLargeAreal(rlc->x[j],rlc->y[j],ran,&OnEdge) > 0)
                               {
                               FoundCondition = 0;
                               break;
                               }

                            else if((ran->ishole > 0) && (ran->idn == paireda1->idn))
                               {
                               if((ran->RB_Tree_Edgelist == NULL) &&
                                  (PointInsidePoly(rlc->x[j],rlc->y[j],ran->x,ran->y,ran->numverts) > 0))
                                  {
                                  end1 = 0;
                                  }
                               else if((ran->RB_Tree_Edgelist != NULL) && 
                                     (PointInsideLargeAreal(rlc->x[j],rlc->y[j],ran,&OnEdge) > 0))
                                  {
                                  end1 = 0;
                                  }
                               }
                            }
                         else /** rlc seems to be undershooting a hole ***/
                            {
                            if(ran->idn != paireda1->idn)
                               {
                               if(ran->RB_Tree_Edgelist == NULL)
                                  {
                                  if(PointInsidePoly(rlc->x[j],rlc->y[j],ran->x,ran->y,ran->numverts) > 0)
                                     {
                                     FoundCondition = 0;
                                     break;
                                     }
                                  }
                               else if(PointInsideLargeAreal(rlc->x[j],rlc->y[j],ran,&OnEdge) > 0)
                                  {
                                  FoundCondition = 0;
                                  break;
                                  }
                               }

                            }
                         }
                      ran = ran->next;
                      }
                   }

                if((paireda1 != NULL) && (FoundCondition > 0) && (paireda1->ishole > 0))
                   {
                   if(end1 > 0)
                      end1 = 0;
                   else
                      end1 = 1;
                   }
                if((FoundCondition > 0) && (paireda1 != NULL) && (end1 < 1)) /** need to add a condition to the list if the end node causing condition is not inside the poly ***/
                   {


                   FoundCondition = 0;
                   ERc = (struct collection *) (malloc(SzC));
                   if(ERc == NULL)
                     {
                     printf("allocation memory exhausted during linear feature condition analysis (Z-shear analysis)\n");
                     printf("processing cannot continue\n");
                     exit(-1);
                     }
                   ERc->magnitude = mindist1;
                   ERc->x[0] = rlc->x[j];
                   ERc->y[0] = rlc->y[j];
                   ERc->z[0] = rlc->z[j];
                   if((pairedflag <= 0) || (pairedflag >= 1)) /** then only want a vertex to vertex condition ***/
                      {
                      ERc->numpoints = 2;
                      ERc->x[1] = paireda1->x[pairedIndex];
                      ERc->y[1] = paireda1->y[pairedIndex];
                      ERc->z[1] = paireda1->z[pairedIndex];
                      }
                   else
                      {
                      ERc->numpoints = 3;
                      ERc->x[1] = paireda1->x[pairedIndex];
                      ERc->y[1] = paireda1->y[pairedIndex];
                      ERc->z[1] = paireda1->z[pairedIndex];
                      if(pairedIndex > 0)
                         {
                         ERc->x[2] = paireda1->x[pairedIndex-1];
                         ERc->y[2] = paireda1->y[pairedIndex-1];
                         ERc->z[2] = paireda1->z[pairedIndex-1];
                         }
                      else
                         {
                         ERc->x[2] = paireda1->x[paireda1->numverts-1];
                         ERc->y[2] = paireda1->y[paireda1->numverts-1];
                         ERc->z[2] = paireda1->z[paireda1->numverts-1];
                         }
                      }

                   ERc->IDN = rlc->idn;
                   ERc->Sindex = rlc->Sindex;
                   ERc->aa = paireda1; /** RawAreal **/
                   ERc->bb = NULL; /** RawBridge **/
                   ERc->pp = NULL; /** RawPoint **/
                   ERc->le = NULL; /** ListOfEdges **/
                   ERc->poly = NULL; /** ThePolys **/
                   ERc->ll1 = rlc;
                   ERc->ll2 = NULL;
                   ERc->keyval = LUNDERSHTA;
                   ERc->Cnumber = Make_Correct(LUNDERSHTA,checkinstance);

                   if(ERroot == NULL)
                      {
                      ERroot = ERc;
                      ERroot->next = NULL;
                      }
                   else
                      {
                      ERn = ERroot;
                      while(ERn != NULL)
                         {
                         if((ERn->keyval == ERc->keyval) && (ERc->Cnumber == ERn->Cnumber))
                            {
                            if((ERn->ll1 == ERc->ll1) && (ERn->aa == ERc->aa))
                               {
                               if((ERc->x[0] == ERn->x[0]) && (ERc->y[0] == ERn->y[0]) && (ERc->z[0] == ERn->z[0]) &&
                                      (ERc->x[1] == ERn->x[1]) && (ERc->y[1] == ERn->y[1]) && (ERc->z[1] == ERn->z[1]))
                                  {
                                  break;
                                  }
                               else if((ERc->x[0] == ERn->x[1]) && (ERc->y[0] == ERn->y[1]) && (ERc->z[0] == ERn->z[1]) &&
                                      (ERc->x[1] == ERn->x[0]) && (ERc->y[1] == ERn->y[0]) && (ERc->z[1] == ERn->z[0]))
                                  {
                                  break;
                                  }
                               }
                            }
                         ERn = ERn->next;
                         }
                      if(ERn == NULL)
                         {
                         ERc->next = ERroot;
                         ERroot = ERc;
                         }
                      else
                         {
                         free(ERc);
                         }
                      }

                   } /*** end FoundCondition ***/
                j += rlc->numnodes - 1;
                } /*** while j < rlc->numnodes ***/
             } /*** end LUNDERSHTA check applies ***/

          if((rlc->firstencounter == 1) &&
                       (CombinedCheckApplies(rlc->idn,checkinstance,FEATOUTSIDE,rlc->Lindex,rlc->Sindex,
                             Config1,Strat1,Domain1,&part1,&part2,&part3) > 0) &&
                        (part1 > 0))
             {
             j = 0;
             FoundCondition = 0;
             tolerancepad = FindRelevantSensitivity(FEATOUTSIDE,checkinstance,&unuseddbl);
             while(j < rlc->numnodes)
                {
                if(rlc->x[j] > LAEmaxx)
                    {
                    ptldist = Distance(rlc->x[j],rlc->y[j],LAEmaxx,rlc->y[j]);
                    if(ptldist > tolerancepad)
                       FoundCondition = 1;
                    }
                if((FoundCondition  == 0) && (rlc->x[j] < LAEminx))
                    {
                    ptldist = Distance(rlc->x[j],rlc->y[j],LAEminx,rlc->y[j]);
                    if(ptldist > tolerancepad)
                       FoundCondition = 1;
                    }
                if((FoundCondition  == 0) && (rlc->y[j] > LAEmaxy))
                    {
                    ptldist = Distance(rlc->x[j],rlc->y[j],rlc->x[j],LAEmaxy);
                    if(ptldist > tolerancepad)
                       FoundCondition = 1;
                    }
                if((FoundCondition  == 0) && (rlc->y[j] < LAEminy))
                    {
                    ptldist = Distance(rlc->x[j],rlc->y[j],rlc->x[j],LAEminy);
                    if(ptldist > tolerancepad)
                       FoundCondition = 1;
                    }
                if(FoundCondition > 0)
                   {
                   FoundCondition = 0;
                   ERc = (struct collection *) (malloc(SzC));
                   if(ERc == NULL)
                     {
                     printf("allocation memory exhausted during linear feature condition analysis (Z-shear analysis)\n");
                     printf("processing cannot continue\n");
                     exit(-1);
                     }
                   ERc->magnitude = ptldist;
                   ERc->x[0] = rlc->x[j];
                   ERc->y[0] = rlc->y[j];
                   ERc->z[0] = rlc->z[j];
                   ERc->IDN = rlc->idn;
                   ERc->Sindex = rlc->Sindex;
                   ERc->aa = NULL; /** RawAreal **/
                   ERc->bb = NULL; /** RawBridge **/
                   ERc->pp = NULL; /** RawPoint **/
                   ERc->le = NULL; /** ListOfEdges **/
                   ERc->poly = NULL; /** ThePolys **/
                   ERc->ll1 = rlc;
                   ERc->ll2 = NULL;
                   ERc->keyval = FEATOUTSIDE;
                   ERc->Cnumber = Make_Correct(FEATOUTSIDE,checkinstance);

                   if(ERroot == NULL)
                      {
                      ERroot = ERc;
                      ERroot->next = NULL;                                }
                   else
                      {
                      ERn = ERroot;
                      while(ERn != NULL)
                         {
                         if((ERn->keyval == ERc->keyval) && (ERc->Cnumber == ERn->Cnumber) && (ERn->ll1 == ERc->ll1))
                            {
                            if((ERn->x[0] == ERc->x[0]) && (ERn->y[0] == ERc->y[0]))
                               break;
                            }
                         ERn = ERn->next;
                         }
                      if(ERn == NULL)
                         {
                         ERc->next = ERroot;
                         ERroot = ERc;
                         }
                      else
                         {
                         free(ERc);
                         }
                      }
                   }
                ++j;
                }
             }


          if((rlc->firstencounter == 1) &&
                       (CombinedCheckApplies(rlc->idn,checkinstance,BNDRYUNDERSHT,rlc->Lindex,rlc->Sindex,
                             Config1,Strat1,Domain1,&part1,&part2,&part3) > 0) &&
                        (part1 > 0))
             {
             j = 0;
             FoundCondition = 0;
             tolerancepad = FindRelevantSensitivity(BNDRYUNDERSHT,checkinstance,&tol2);
             while(j < rlc->numnodes)
                {
                if(rlc->x[j] < LAEmaxx)
                    {
                    ptldist = Distance(rlc->x[j],rlc->y[j],LAEmaxx,rlc->y[j]);
                    if((ptldist > tolerancepad) && (ptldist < tol2))
                       FoundCondition = 1;
                    }
                if((FoundCondition  == 0) && (rlc->x[j] > LAEminx))
                    {
                    ptldist = Distance(rlc->x[j],rlc->y[j],LAEminx,rlc->y[j]);
                    if((ptldist > tolerancepad) && (ptldist < tol2))
                       FoundCondition = 1;
                    }
                if((FoundCondition  == 0) && (rlc->y[j] < LAEmaxy))
                    {
                    ptldist = Distance(rlc->x[j],rlc->y[j],rlc->x[j],LAEmaxy);
                    if((ptldist > tolerancepad) && (ptldist < tol2))
                       FoundCondition = 1;
                    }
                if((FoundCondition  == 0) && (rlc->y[j] > LAEminy))
                    {
                    ptldist = Distance(rlc->x[j],rlc->y[j],rlc->x[j],LAEminy);
                    if((ptldist > tolerancepad) && (ptldist < tol2))
                       FoundCondition = 1;
                    }
                if(FoundCondition > 0)
                   {
                   FoundCondition = 0;
                   ERc = (struct collection *) (malloc(SzC));
                   if(ERc == NULL)
                     {
                     printf("allocation memory exhausted during linear feature condition analysis (Z-shear analysis)\n");
                     printf("processing cannot continue\n");
                     exit(-1);
                     }
                   ERc->magnitude = ptldist;
                   ERc->x[0] = rlc->x[j];
                   ERc->y[0] = rlc->y[j];
                   ERc->z[0] = rlc->z[j];
                   ERc->IDN = rlc->idn;
                   ERc->Sindex = rlc->Sindex;
                   ERc->aa = NULL; /** RawAreal **/
                   ERc->bb = NULL; /** RawBridge **/
                   ERc->pp = NULL; /** RawPoint **/
                   ERc->le = NULL; /** ListOfEdges **/
                   ERc->poly = NULL; /** ThePolys **/
                   ERc->ll1 = rlc;
                   ERc->ll2 = NULL;
                   ERc->keyval = BNDRYUNDERSHT;
                   ERc->Cnumber = Make_Correct(BNDRYUNDERSHT,checkinstance);

                   if(ERroot == NULL)
                      {
                      ERroot = ERc;
                      ERroot->next = NULL;                                }
                   else
                      {
                      ERn = ERroot;
                      while(ERn != NULL)
                         {
                         if((ERn->keyval == ERc->keyval) && (ERc->Cnumber == ERn->Cnumber) && (ERn->ll1 == ERc->ll1))
                            {
                            if((ERn->x[0] == ERc->x[0]) && (ERn->y[0] == ERc->y[0]))
                               break;
                            }
                         ERn = ERn->next;
                         }
                      if(ERn == NULL)
                         {
                         ERc->next = ERroot;
                         ERroot = ERc;
                         }
                      else
                         {
                         free(ERc);
                         }
                      }
                   }
                ++j;
                }
             }







         if((rlc->firstencounter == 1) && 
             (OSIDE_LatLon_Count < OSIDE_LL_Limit) &&
                       (CombinedCheckApplies(rlc->idn,checkinstance,OSIDE_LON,rlc->Lindex,rlc->Sindex,
                             Config1,Strat1,Domain1,&part1,&part2,&part3) > 0) &&
                        (part1 > 0))
            {
            ptpdist1 = FindRelevantSensitivity(OSIDE_LON, checkinstance, &ptpdist2);

            ptpdist1 = XCoordToProjectCoord(ptpdist1);
            ptpdist2 = XCoordToProjectCoord(ptpdist2);

            if(ptpdist2 < ptpdist1)
               {
               unuseddbl = ptpdist2;
               ptpdist1 = ptpdist2;
               ptpdist2 = unuseddbl;
               }
            ptpdist1 -= ActiveChecks[checkinstance].sensitivity3;   //0.001;
            ptpdist2 += ActiveChecks[checkinstance].sensitivity3;   //0.001;

            for(j=0; j<rlc->numnodes; j++)
               {
               if((rlc->x[j] < ptpdist1) || (rlc->x[j] > ptpdist2))
                   {
                   ++OSIDE_LatLon_Count;
                   ERc = (struct collection *) (malloc(SzC));
                   if(ERc == NULL)
                     {
                     printf("allocation memory exhausted during linear feature condition analysis \n");
                     printf("processing cannot continue\n");
                     exit(-1);
                     }
                   if(rlc->x[j] >ptpdist2)
                      ERc->magnitude = rlc->x[j] - ptpdist2;
                   else
                      ERc->magnitude = ptpdist1 - rlc->x[j];
                   ERc->x[0] = rlc->x[j];
                   ERc->y[0] = rlc->y[j];
                   ERc->z[0] = rlc->z[j];
                   ERc->IDN = rlc->idn;
                   ERc->Sindex = rlc->Sindex;
                   ERc->aa = NULL; /** RawAreal **/
                   ERc->bb = NULL; /** RawBridge **/
                   ERc->pp = NULL; /** RawPoint **/
                   ERc->le = NULL; /** ListOfEdges **/
                   ERc->poly = NULL; /** ThePolys **/
                   ERc->ll1 = rlc;
                   ERc->ll2 = NULL;
                   ERc->keyval = OSIDE_LON;
                   ERc->Cnumber = Make_Correct(OSIDE_LON,checkinstance);

                   if(ERroot == NULL)
                      {
                      ERroot = ERc;
                      ERroot->next = NULL;                                }
                   else
                      {
                      ERn = ERroot;
                      while(ERn != NULL)
                         {
                         if((ERn->keyval == ERc->keyval) && (ERc->Cnumber == ERn->Cnumber) && (ERn->ll1 == ERc->ll1))
                            {
                            if((ERn->x[0] == ERc->x[0]) && (ERn->y[0] == ERc->y[0]))
                               break;
                            }
                         ERn = ERn->next;
                         }
                      if(ERn == NULL)
                         {
                         ERc->next = ERroot;
                         ERroot = ERc;
                         }
                      else
                         {
                         free(ERc);
                         }
                      }
                   }
                }
            } /*** end OSIDE_LON ***/




         if((rlc->firstencounter == 1) && 
             (OSIDE_LatLon_Count < OSIDE_LL_Limit) &&
                       (CombinedCheckApplies(rlc->idn,checkinstance,OSIDE_LAT,rlc->Lindex,rlc->Sindex,
                             Config1,Strat1,Domain1,&part1,&part2,&part3) > 0) &&
                        (part1 > 0))
            {
            ptpdist1 = FindRelevantSensitivity(OSIDE_LAT, checkinstance, &ptpdist2);

            ptpdist1 = YCoordToProjectCoord(ptpdist1);
            ptpdist2 = YCoordToProjectCoord(ptpdist2);

            if(ptpdist2 < ptpdist1)
               {
               unuseddbl = ptpdist2;
               ptpdist1 = ptpdist2;
               ptpdist2 = unuseddbl;
               }
            ptpdist1 -= ActiveChecks[checkinstance].sensitivity3;   //0.001;
            ptpdist2 += ActiveChecks[checkinstance].sensitivity3;   //0.001;

            for(j=0; j<rlc->numnodes; j++)
               {
               if((rlc->y[j] < ptpdist1) || (rlc->y[j] > ptpdist2))
                   {
                   ++OSIDE_LatLon_Count;
                   ERc = (struct collection *) (malloc(SzC));
                   if(ERc == NULL)
                     {
                     printf("allocation memory exhausted during linear feature condition analysis \n");
                     printf("processing cannot continue\n");
                     exit(-1);
                     }
                   if(rlc->y[j] >ptpdist2)
                      ERc->magnitude = rlc->y[j] - ptpdist2;
                   else
                      ERc->magnitude = ptpdist1 - rlc->y[j];
                   ERc->x[0] = rlc->x[j];
                   ERc->y[0] = rlc->y[j];
                   ERc->z[0] = rlc->z[j];
                   ERc->IDN = rlc->idn;
                   ERc->Sindex = rlc->Sindex;
                   ERc->aa = NULL; /** RawAreal **/
                   ERc->bb = NULL; /** RawBridge **/
                   ERc->pp = NULL; /** RawPoint **/
                   ERc->le = NULL; /** ListOfEdges **/
                   ERc->poly = NULL; /** ThePolys **/
                   ERc->ll1 = rlc;
                   ERc->ll2 = NULL;
                   ERc->keyval = OSIDE_LAT;
                   ERc->Cnumber = Make_Correct(OSIDE_LAT,checkinstance);

                   if(ERroot == NULL)
                      {
                      ERroot = ERc;
                      ERroot->next = NULL;                                }
                   else
                      {
                      ERn = ERroot;
                      while(ERn != NULL)
                         {
                         if((ERn->keyval == ERc->keyval) && (ERc->Cnumber == ERn->Cnumber) && (ERn->ll1 == ERc->ll1))
                            {
                            if((ERn->x[0] == ERc->x[0]) && (ERn->y[0] == ERc->y[0]))
                               break;
                            }
                         ERn = ERn->next;
                         }
                      if(ERn == NULL)
                         {
                         ERc->next = ERroot;
                         ERroot = ERc;
                         }
                      else
                         {
                         free(ERc);
                         }
                      }
                   }
                }
            } /*** end OSIDE_LAT ***/




          if((CombinedCheckApplies(rlc->idn,checkinstance,LAPROX,rlc->Lindex,rlc->Sindex,Config1,Strat1,Domain1,&part1,&part2,&part3) > 0) && (part1 > 0))
             {
             j = 1;
             FoundCondition = 0;
             tolerancepad = FindRelevantSensitivity(LAPROX,checkinstance,&unuseddbl);
             while(j < rlc->numnodes)
                {
                jj = j - 1;
                if(rlc->x[j] < rlc->x[jj])
                   {
                   minxPadded = rlc->x[j];
                   maxxPadded = rlc->x[jj];
                   }
                else
                   {
                   minxPadded = rlc->x[jj];
                   maxxPadded = rlc->x[j];
                   }

                if(rlc->y[j] < rlc->y[jj])
                   {
                   minyPadded = rlc->y[j];
                   maxyPadded = rlc->y[jj];
                   }
                else
                   {
                   minyPadded = rlc->y[jj];
                   maxyPadded = rlc->y[j];
                   }

                if((minxPadded <= maxx) && (maxxPadded >= minx) && (minyPadded <= maxy) && (maxyPadded >= miny))
                   {
                   minxPadded -= tolerancepad;
                   maxxPadded += tolerancepad;
                   minyPadded -= tolerancepad;
                   maxyPadded += tolerancepad;

                   rac = Aroot;

                   while(rac != NULL)
                      {
                      if((CombinedCheckApplies(rac->idn,checkinstance,LAPROX,rac->Lindex,rac->Sindex,
                               SCCtable[rac->Sindex].C,SCCtable[rac->Sindex].S,SCCtable[rac->Sindex].D,&part1,&part2,&part3) > 0) && (part2 > 0))
                         {
                         if(rac->RB_Tree_Edgelist == NULL)
                            ptpdist1 = SegmentToSmallArealDist2D(rlc->x[j], rlc->y[j],rlc->x[jj],rlc->y[jj],
                                                                  minxPadded,minyPadded,maxxPadded,maxyPadded,rac,&k,&kk);
                         else
                            ptpdist1 = SegmentToLargeArealDist2D(rlc->x[j], rlc->y[j],rlc->x[jj],rlc->y[jj],
                                                                  minxPadded,minyPadded,maxxPadded,maxyPadded,rac,&k,&kk);

                         if((ptpdist1 > -0.1) && (SensitivityCheck(LTEQ, LAPROX, checkinstance, ptpdist1) > 0))
                            {
                            ERc = (struct collection *) (malloc(SzC));
                            if(ERc == NULL)
                              {
                              printf("allocation memory exhausted during linear feature condition analysis (Z-shear analysis)\n");
                              printf("processing cannot continue\n");
                              exit(-1);
                              }
                            ERc->magnitude = ptpdist1;
                            ERc->x[0] = rlc->x[j];
                            ERc->y[0] = rlc->y[j];
                            ERc->z[0] = rlc->z[j];
                            ERc->x[1] = rlc->x[jj];
                            ERc->y[1] = rlc->y[jj];
                            ERc->z[1] = rlc->z[jj];
                            ERc->x[2] = rac->x[k];
                            ERc->y[2] = rac->y[k];
                            ERc->z[2] = rac->z[k];
                            ERc->x[3] = rac->x[kk];
                            ERc->y[3] = rac->y[kk];
                            ERc->z[3] = rac->z[kk];
         
                            ERc->IDN = rlc->idn;
                            ERc->Sindex = rlc->Sindex;
                            ERc->aa = rac; /** RawAreal **/
                            ERc->bb = NULL; /** RawBridge **/
                            ERc->pp = NULL; /** RawPoint **/
                            ERc->le = NULL; /** ListOfEdges **/
                            ERc->poly = NULL; /** ThePolys **/
                            ERc->ll1 = rlc;
                            ERc->ll2 = NULL;
                            ERc->keyval = LAPROX;
                            ERc->Cnumber = Make_Correct(LAPROX,checkinstance);
         
                            if(ERroot == NULL)
                               {
                               ERroot = ERc;
                               ERroot->next = NULL;
                               }
                            else
                               {
                               ERn = ERroot;
                               while(ERn != NULL)
                                  {
                                  if((ERn->keyval == ERc->keyval) && (ERc->Cnumber == ERn->Cnumber))
                                     {
                                     if((ERn->ll1 == ERc->ll1) && (ERn->aa == ERc->aa) && (ERc->aa == ERn->aa))
                                        {
                                        if(ERc->magnitude < ERn->magnitude)
                                           {
                                           ERn->magnitude = ERc->magnitude;
                                           ERn->x[0] = ERc->x[0];
                                           ERn->y[0] = ERc->y[0];
                                           ERn->z[0] = ERc->z[0];
                                           ERn->x[1] = ERc->x[1];
                                           ERn->y[1] = ERc->y[1];
                                           ERn->z[1] = ERc->z[1];
                                           ERn->x[2] = ERc->x[2];
                                           ERn->y[2] = ERc->y[2];
                                           ERn->z[2] = ERc->z[2];
                                           ERn->x[3] = ERc->x[3];
                                           ERn->y[3] = ERc->y[3];
                                           ERn->z[3] = ERc->z[3];
                                           }
                                        break;
                                        }
                                     }
                                  ERn = ERn->next;
                                  }
                               if(ERn == NULL)
                                  {
                                  ERc->next = ERroot;
                                  ERroot = ERc;
                                  }
                               else
                                  {
                                  free(ERc);
                                  }
                               }

                            }
                         } /* end if combined check applies ***/
                      rac = rac->next;
                      } /** end while rac ***/

                   } /** end if crosses or is in the load module  ***/
                j++;
                } /*** while j < rlc->numnodes ***/
             } /*** end LAPROX check applies ***/


          if((CombinedCheckApplies(rlc->idn,checkinstance,LASLIVER,rlc->Lindex,rlc->Sindex,Config1,Strat1,Domain1,&part1,&part2,&part3) > 0) && (part1 > 0))
             {
             j = 1;
             FoundCondition = 0;
             tolerancepad = FindRelevantSensitivity(LASLIVER,checkinstance,&unuseddbl);
             while(j < rlc->numnodes)
                {
                timesthru = 0;
                jj = j - 1;
                if(rlc->x[j] < rlc->x[jj])
                   {
                   minxPadded = rlc->x[j];
                   maxxPadded = rlc->x[jj];
                   if(rlc->y[jj] != rlc->y[j])
                      segmentslope = (rlc->x[jj] - rlc->x[j]) / (rlc->y[jj] - rlc->y[j]);
                   else
                      segmentslope = (rlc->x[jj] - rlc->x[j]) / 0.00001;
                   }
                else
                   {
                   minxPadded = rlc->x[jj];
                   maxxPadded = rlc->x[j];
                   if(rlc->y[jj] != rlc->y[j])
                      segmentslope = (rlc->x[j] - rlc->x[jj]) / (rlc->y[j] - rlc->y[jj]);
                   else 
                      segmentslope = (rlc->x[j] - rlc->x[jj]) / 0.00001;
                   }

                if(rlc->y[j] < rlc->y[jj])
                   {
                   minyPadded = rlc->y[j];
                   maxyPadded = rlc->y[jj];
                   }
                else
                   {
                   minyPadded = rlc->y[jj]; 
                   maxyPadded = rlc->y[j];
                   }

                if((minxPadded <= maxx) && (maxxPadded >= minx) && (minyPadded <= maxy) && (maxyPadded >= miny))
                   {
                   minxPadded -= tolerancepad;
                   maxxPadded += tolerancepad;
                   minyPadded -= tolerancepad;
                   maxyPadded += tolerancepad;

segmentslope = atan(segmentslope);
segmentslope = RadiansToDegrees(segmentslope);

                   rac = Aroot;

                   while(rac != NULL)
                      {
                      if((CombinedCheckApplies(rac->idn,checkinstance,LASLIVER,rac->Lindex,rac->Sindex,
                               SCCtable[rac->Sindex].C,SCCtable[rac->Sindex].S,SCCtable[rac->Sindex].D,&part1,&part2,&part3) > 0) && (part2 > 0))
                         {
                         if(rac->RB_Tree_Edgelist == NULL)
                            ptpdist1 = AvgSegmentToSmallArealDist2D(rlc->x[j], rlc->y[j],rlc->x[jj],rlc->y[jj],
                                                                  minxPadded,minyPadded,maxxPadded,maxyPadded,rac,&k,&kk);
                         else
                            ptpdist1 = AvgSegmentToLargeArealDist2D(rlc->x[j], rlc->y[j],rlc->x[jj],rlc->y[jj],
                                                                  minxPadded,minyPadded,maxxPadded,maxyPadded,rac,&k,&kk);

                         if(SensitivityCheck(OPENINT, LASLIVER, checkinstance, ptpdist1) > 0)
                            {
                            if(rac->x[k] > rac->x[kk])
                               {
                               if(rac->y[kk] != rac->y[k])
                                  unuseddbl = (rac->x[k] - rac->x[kk]) / (rac->y[k] - rac->y[kk]);
                               else
                                  unuseddbl = (rac->x[k] - rac->x[kk]) / 0.00001;
                               }
                            else
                               {
                               if(rac->y[kk] != rac->y[k])
                                  unuseddbl = (rac->x[kk] - rac->x[k]) / (rac->y[kk] - rac->y[k]);
                               else
                                  unuseddbl = (rac->x[kk] - rac->x[k]) / 0.00001;
                               }
                            unuseddbl = atan(unuseddbl);
                            unuseddbl = RadiansToDegrees(unuseddbl);
                            if(segmentslope > unuseddbl)
                               unuseddbl = segmentslope - unuseddbl;
                            else
                               unuseddbl = unuseddbl - segmentslope;

                            if((unuseddbl > -10.0) && (unuseddbl < 10.0) &&
                                 (SegmentsOffsetOverlap(rlc->x[j], rlc->y[j],rlc->x[jj],rlc->y[jj], rac->x[k], rac->y[k],rac->x[kk],rac->y[kk]) > 0))
                               {
                               keepit = 1;
                               rln = root;
                               while(rln != NULL)
                                  {
                                  if(rln != rlc)
                                     {
                                     if((CombinedCheckApplies(rln->idn,checkinstance,LASLIVER,rln->Lindex,rln->Sindex,
                                           SCCtable[rln->Sindex].C,SCCtable[rln->Sindex].S,SCCtable[rln->Sindex].D,&part1,&part2,&part3) > 0) &&
                                                 (part3 > 0))
                                        {
                                        for(km1 = 1; km1 < rln->numnodes; km1++)
                                           {
                                           unuseddbl = PointToLineDist2D(rln->x[km1-1],rln->y[km1-1],rac->x[k],rac->y[k],rac->x[kk],rac->y[kk]);
                                           temp = PointToLineDist2D(rln->x[km1],rln->y[km1],rac->x[k],rac->y[k],rac->x[kk],rac->y[kk]);
                                           temp = (unuseddbl + temp) / 2.0;
                                           if(temp < ptpdist1)
                                              {
                                              keepit = 0;
                                              break;
                                              }
                                           }
                                        }
                                     }
                                  if(keepit < 1)
                                     {
                                     keepit = 0;
                                     break;
                                     }
                                  rln = rln->next;
                                  }
                               if(keepit > 0)
                                  {
                                  ran = Aroot;

                                  while(ran != NULL)
                                     {
                                     if(ran != rac)
                                        {
                                        if((CombinedCheckApplies(ran->idn,checkinstance,LASLIVER,ran->Lindex,ran->Sindex,
                                           SCCtable[ran->Sindex].C,SCCtable[ran->Sindex].S,SCCtable[ran->Sindex].D,&part1,&part2,&part3) > 0) &&
                                                 (part3 > 0))
                                           {
                                           km3 = ran->numverts - 1;
                                           for(km1 = 0; km1 < ran->numverts; km1++)
                                              {
                                              unuseddbl = PointToLineDist2D(ran->x[km3],ran->y[km3],rac->x[k],rac->y[k],rac->x[kk],rac->y[kk]);
                                              temp = PointToLineDist2D(ran->x[km1],ran->y[km1],rac->x[k],rac->y[k],rac->x[kk],rac->y[kk]);
                                              temp = (unuseddbl + temp) / 2.0;
                                              if(temp < ptpdist1)
                                                 {
                                                 keepit = 0;
                                                 break;
                                                 }
                                              km3 = km1;
                                              }
                                           }
                                        }
                                     ran = ran->next;
                                     }
                                  }
                               if(keepit > 0)
                                  {
                                  timesthru = 1;
                                  ERc = (struct collection *) (malloc(SzC));
                                  if(ERc == NULL)
                                    {
                                    printf("allocation memory exhausted during linear feature condition analysis (Z-shear analysis)\n");
                                    printf("processing cannot continue\n");
                                    exit(-1);
                                    }
                                  ERc->magnitude = ptpdist1;
                                  ERc->x[0] = rlc->x[j];
                                  ERc->y[0] = rlc->y[j];
                                  ERc->z[0] = rlc->z[j];
                                  ERc->x[1] = rlc->x[jj];
                                  ERc->y[1] = rlc->y[jj];
                                  ERc->z[1] = rlc->z[jj];
                                  ERc->x[2] = rac->x[k];
                                  ERc->y[2] = rac->y[k];
                                  ERc->z[2] = rac->z[k];
                                  ERc->x[3] = rac->x[kk];
                                  ERc->y[3] = rac->y[kk];
                                  ERc->z[3] = rac->z[kk];

                                  ERc->vertexindex1 = j;
                                  ERc->vertexindex2 = jj;

                                  ERc->IDN = rlc->idn;
                                  ERc->Sindex = rlc->Sindex;
                                  ERc->aa = rac; /** RawAreal **/
                                  ERc->bb = NULL; /** RawBridge **/
                                  ERc->pp = NULL; /** RawPoint **/
                                  ERc->le = NULL; /** ListOfEdges **/
                                  ERc->poly = NULL; /** ThePolys **/
                                  ERc->ll1 = rlc;
                                  ERc->ll2 = NULL;
                                  ERc->keyval = LASLIVER;
                                  ERc->Cnumber = Make_Correct(LASLIVER,checkinstance);

                                  if(ERroot == NULL)
                                     {
                                     ERroot = ERc;
                                     ERroot->next = NULL;
                                     }
                                  else
                                     {
                                     ERn = ERroot;
                                     while(ERn != NULL)
                                        {
                                        if((ERn->keyval == ERc->keyval) && (ERc->Cnumber == ERn->Cnumber))
                                           {
                                           if((ERn->ll1 == ERc->ll1) && (ERn->aa == ERc->aa) && (ERc->aa == ERn->aa))
                                              {
                                              if(ERc->magnitude < ERn->magnitude)
                                                 {
                                                 ERn->magnitude = ERc->magnitude;
                                                 ERn->x[0] = ERc->x[0];
                                                 ERn->y[0] = ERc->y[0];
                                                 ERn->z[0] = ERc->z[0];
                                                 ERn->x[1] = ERc->x[1];
                                                 ERn->y[1] = ERc->y[1];
                                                 ERn->z[1] = ERc->z[1];
                                                 ERn->x[2] = ERc->x[2];
                                                 ERn->y[2] = ERc->y[2];
                                                 ERn->z[2] = ERc->z[2];
                                                 ERn->x[3] = ERc->x[3];
                                                 ERn->y[3] = ERc->y[3];
                                                 ERn->z[3] = ERc->z[3];
                                                 }
                                              break;
                                              }
                                           }
                                        ERn = ERn->next;
                                        }
                                     if(ERn == NULL)
                                        {
                                        ERc->next = ERroot;
                                        ERroot = ERc;
                                        }
                                     else
                                        {
                                        free(ERc);
                                        }
                                     }
                                  }
                               }
                            }
                         } /* end if combined check applies ***/
                      if(timesthru > 0)
                         break; /** move to the next line feature segment ***/
                      rac = rac->next;
                      } /** end while rac ***/

                   } /** end if crosses or is in the load module  ***/
                j++;
                } /*** while j < rlc->numnodes ***/
             } /*** end LASLIVER check applies ***/



          if((CombinedCheckApplies(rlc->idn,checkinstance,LLSLIVER,rlc->Lindex,rlc->Sindex,Config1,Strat1,Domain1,&part1,&part2,&part3) > 0) && (part1 > 0))
             {
             j = 1;
             FoundCondition = 0;
             tolerancepad = FindRelevantSensitivity(LLSLIVER,checkinstance,&unuseddbl);
             while(j < rlc->numnodes) 
                {
                jj = j - 1;
                if(rlc->x[j] < rlc->x[jj])
                   {
                   minxPadded = rlc->x[j];
                   maxxPadded = rlc->x[jj];
                   if(rlc->y[jj] != rlc->y[j])
                      segmentslope = (rlc->x[jj] - rlc->x[j]) / (rlc->y[jj] - rlc->y[j]);
                   else
                      segmentslope = (rlc->x[jj] - rlc->x[j]) / 0.00001;
                   }
                else
                   {
                   minxPadded = rlc->x[jj];
                   maxxPadded = rlc->x[j];
                   if(rlc->y[jj] != rlc->y[j])
                      segmentslope = (rlc->x[j] - rlc->x[jj]) / (rlc->y[j] - rlc->y[jj]);
                   else
                      segmentslope = (rlc->x[j] - rlc->x[jj]) / 0.00001;
                   }

                if(rlc->y[j] < rlc->y[jj]) 
                   {
                   minyPadded = rlc->y[j];
                   maxyPadded = rlc->y[jj]; 
                   }
                else
                   {
                   minyPadded = rlc->y[jj]; 
                   maxyPadded = rlc->y[j]; 
                   }

                if((minxPadded <= maxx) && (maxxPadded >= minx) && (minyPadded <= maxy) && (maxyPadded >= miny))
                   {
                   minxPadded -= tolerancepad;
                   maxxPadded += tolerancepad;
                   minyPadded -= tolerancepad;
                   maxyPadded += tolerancepad;
                   rln = root;

                   while(rln != NULL)
                      {
                      if((rln != rlc) && (CombinedCheckApplies(rln->idn,checkinstance,LLSLIVER,rln->Lindex,rln->Sindex,
                               SCCtable[rln->Sindex].C,SCCtable[rln->Sindex].S,SCCtable[rln->Sindex].D,&part1,&part2,&part3) > 0) && (part2 > 0))
                         {
                         ptpdist1 = AvgSegmentToLineDist2D(segmentslope,rlc->x[j], rlc->y[j],rlc->x[jj],rlc->y[jj],
                                                                  minxPadded,minyPadded,maxxPadded,maxyPadded,rln,&k,&kk);

                         if((SensitivityCheck(OPENINT, LLSLIVER, checkinstance, ptpdist1) > 0) &&
                                (SegmentsOffsetOverlap(rlc->x[j], rlc->y[j],rlc->x[jj],rlc->y[jj], rln->x[k], rln->y[k],rln->x[kk],rln->y[kk]) > 0))
                            {
                            ERc = (struct collection *) (malloc(SzC));
                            if(ERc == NULL)
                              {
                              printf("allocation memory exhausted during linear feature condition analysis (Z-shear analysis)\n");
                              printf("processing cannot continue\n");
                              exit(-1);
                              }
                            ERc->magnitude = ptpdist1;
                            ERc->x[0] = rlc->x[j];
                            ERc->y[0] = rlc->y[j];
                            ERc->z[0] = rlc->z[j];
                            ERc->x[1] = rlc->x[jj];
                            ERc->y[1] = rlc->y[jj];
                            ERc->z[1] = rlc->z[jj];
                            ERc->x[2] = rln->x[k];
                            ERc->y[2] = rln->y[k];
                            ERc->z[2] = rln->z[k];
                            ERc->x[3] = rln->x[kk];
                            ERc->y[3] = rln->y[kk];
                            ERc->z[3] = rln->z[kk];

                            ERc->IDN = rlc->idn;
                            ERc->Sindex = rlc->Sindex;
                            ERc->aa = NULL; /** RawAreal **/
                            ERc->bb = NULL; /** RawBridge **/
                            ERc->pp = NULL; /** RawPoint **/
                            ERc->le = NULL; /** ListOfEdges **/
                            ERc->poly = NULL; /** ThePolys **/
                            ERc->ll1 = rlc;
                            ERc->ll2 = rln;
                            ERc->keyval = LLSLIVER;
                            ERc->Cnumber = Make_Correct(LLSLIVER,checkinstance);

                            if(ERroot == NULL)
                               {
                               ERroot = ERc;
                               ERroot->next = NULL;
                               }
                            else
                               {
                               ERn = ERroot;
                               while(ERn != NULL)
                                  {
                                  if((ERn->keyval == ERc->keyval) && (ERc->Cnumber == ERn->Cnumber))
                                     {
                                     if((ERn->ll1 == ERc->ll1) && (ERn->aa == ERc->aa) && (ERc->aa == ERn->aa))
                                        {
                                        if(ERc->magnitude < ERn->magnitude)
                                           {
                                           ERn->magnitude = ERc->magnitude;
                                           ERn->x[0] = ERc->x[0];
                                           ERn->y[0] = ERc->y[0];
                                           ERn->z[0] = ERc->z[0];
                                           ERn->x[1] = ERc->x[1];
                                           ERn->y[1] = ERc->y[1];
                                           ERn->z[1] = ERc->z[1];
                                           ERn->x[2] = ERc->x[2];
                                           ERn->y[2] = ERc->y[2];
                                           ERn->z[2] = ERc->z[2];
                                           ERn->x[3] = ERc->x[3];
                                           ERn->y[3] = ERc->y[3];
                                           ERn->z[3] = ERc->z[3];
                                           }
                                        break;
                                        }
                                     }
                                  ERn = ERn->next;
                                  }
                               if(ERn == NULL)
                                  {
                                  ERc->next = ERroot;
                                  ERroot = ERc;
                                  }
                               else
                                  {
                                  free(ERc);
                                  }
                               }

                            }
                         } /* end if combined check applies ***/
                      rln = rln->next;
                      } /** end while rln ***/

                   } /** end if crosses or is in the load module  ***/
                j++;
                } /*** while j < rlc->numnodes ***/
             } /*** end LLSLIVER check applies ***/


          } /** end for checkinstance ***/
       rlc = rlc->next;
       } /*** end while rlc ***/


   ERc = ERroot;
   while(ERc != NULL)
      {
      switch(ERc->keyval)
         {
         case FEATOUTSIDE:
            FwriteDynamicInfo(ERc->keyval,ERc->Cnumber,0,1,1,NULL,
              ERc->magnitude, -1.0, -1.0, -1.0,
              ERc->Sindex,G_LINE,ERc->ll1->Lindex,ERc->ll1->localID,ERc->ll1->idn,-1.0,-1.0,
              ERc->x, ERc->y, ERc->z, 1,
              ERc->Sindex,G_LINE,ERc->ll1->Lindex,ERc->ll1->localID,ERc->ll1->idn,-1.0,-1.0,
              ERc->x, ERc->y, ERc->z, 1);

            break;

         case OSIDE_LAT:
         case OSIDE_LON:
         case BNDRYUNDERSHT:
            FwriteObjectAndMagnitude(ERc->keyval,ERc->Cnumber,
                        ERc->ll1->idn, ERc->Sindex,G_LINE,ERc->ll1->Lindex,ERc->ll1->localID,-1.0,-1.0,ERc->magnitude,ERc->x, ERc->y, ERc->z,1, 1);
            break;

         case LELINEPROX:
            if(ERc->numpoints == 2)
               {
               if(ERc->ll2 != NULL)
                  {
                  FwriteMagnitudeAndTwoObjects(ERc->keyval,ERc->Cnumber,ERc->magnitude,
                        ERc->ll1->Sindex,G_LINE,ERc->ll1->Lindex,
                        ERc->ll1->localID,ERc->ll1->idn,10.0,-1.0,&ERc->x[0],&ERc->y[0],&ERc->z[0],2,
                        ERc->ll2->Sindex,G_LINE,ERc->ll2->Lindex,
                        ERc->ll2->localID,ERc->ll2->idn,10.0,-1.0,&ERc->x[2],&ERc->y[2],&ERc->z[2],1);
                  }
               else if(ERc->pp != NULL)
                  {
                  FwriteMagnitudeAndTwoObjects(ERc->keyval,ERc->Cnumber,ERc->magnitude,
                        ERc->ll1->Sindex,G_LINE,ERc->ll1->Lindex,
                        ERc->ll1->localID,ERc->ll1->idn,10.0,-1.0,&ERc->x[0],&ERc->y[0],&ERc->z[0],2,
                        ERc->pp->Sindex,G_POINT,ERc->pp->Lindex,
                        ERc->pp->localID,ERc->pp->idn,10.0,-1.0,&ERc->x[2],&ERc->y[2],&ERc->z[2],1);
                  }
               else if(ERc->aa != NULL)
                  {
                  FwriteMagnitudeAndTwoObjects(ERc->keyval,ERc->Cnumber,ERc->magnitude,
                        ERc->ll1->Sindex,G_LINE,ERc->ll1->Lindex,
                        ERc->ll1->localID,ERc->ll1->idn,10.0,-1.0,&ERc->x[0],&ERc->y[0],&ERc->z[0],2,
                        ERc->aa->Sindex,G_POINT,ERc->aa->Lindex,
                        ERc->aa->localID,ERc->aa->idn,10.0,-1.0,&ERc->x[2],&ERc->y[2],&ERc->z[2],1);
                  }
               }
            else
               {
               if(ERc->ll2 != NULL)
                  {
                  FwriteMagnitudeAndTwoObjects(ERc->keyval,ERc->Cnumber,ERc->magnitude,
                        ERc->ll1->Sindex,G_LINE,ERc->ll1->Lindex,
                        ERc->ll1->localID,ERc->ll1->idn,10.0,-1.0,&ERc->x[0],&ERc->y[0],&ERc->z[0],2,
                        ERc->ll2->Sindex,G_LINE,ERc->ll2->Lindex,
                        ERc->ll2->localID,ERc->ll2->idn,10.0,-1.0,&ERc->x[2],&ERc->y[2],&ERc->z[2],2);
                  }
               else if(ERc->aa != NULL)
                  {
                  FwriteMagnitudeAndTwoObjects(ERc->keyval,ERc->Cnumber,ERc->magnitude,
                        ERc->ll1->Sindex,G_LINE,ERc->ll1->Lindex,
                        ERc->ll1->localID,ERc->ll1->idn,10.0,-1.0,&ERc->x[0],&ERc->y[0],&ERc->z[0],2,
                        ERc->aa->Sindex,G_LINE,ERc->aa->Lindex,
                        ERc->aa->localID,ERc->aa->idn,10.0,-1.0,&ERc->x[2],&ERc->y[2],&ERc->z[2],2);
                  }
               }
            break;


         case EN_EN_PROX:
         case LUSHTL_CLEAN:
         case LUNDERSHTL:
         case LVUSHTL:
         case VUSHTL_CLEAN:
         case LVOSHTL:
         case LOVERSHTL:
         case LOSHTL_DF:
         case LUSHTL_DF:
            if(ERc->numpoints == 2)
               {
               if(ERc->ll2 != NULL)
                  {
                  FwriteMagnitudeAndTwoObjects(ERc->keyval,ERc->Cnumber,ERc->magnitude,
                        ERc->ll1->Sindex,G_LINE,ERc->ll1->Lindex,
                        ERc->ll1->localID,ERc->ll1->idn,10.0,-1.0,&ERc->x[0],&ERc->y[0],&ERc->z[0],1,
                        ERc->ll2->Sindex,G_LINE,ERc->ll2->Lindex,
                        ERc->ll2->localID,ERc->ll2->idn,10.0,-1.0,&ERc->x[1],&ERc->y[1],&ERc->z[1],1);
                  }
               else if(ERc->pp != NULL)
                  {
                  FwriteMagnitudeAndTwoObjects(ERc->keyval,ERc->Cnumber,ERc->magnitude,
                        ERc->ll1->Sindex,G_LINE,ERc->ll1->Lindex,
                        ERc->ll1->localID,ERc->ll1->idn,10.0,-1.0,&ERc->x[0],&ERc->y[0],&ERc->z[0],1,
                        ERc->pp->Sindex,G_POINT,ERc->pp->Lindex,
                        ERc->pp->localID,ERc->pp->idn,10.0,-1.0,&ERc->x[1],&ERc->y[1],&ERc->z[1],1);
                  }
               else if(ERc->aa != NULL)
                  {
                  FwriteMagnitudeAndTwoObjects(ERc->keyval,ERc->Cnumber,ERc->magnitude,
                        ERc->ll1->Sindex,G_LINE,ERc->ll1->Lindex,
                        ERc->ll1->localID,ERc->ll1->idn,10.0,-1.0,&ERc->x[0],&ERc->y[0],&ERc->z[0],1,
                        ERc->aa->Sindex,G_POINT,ERc->aa->Lindex,
                        ERc->aa->localID,ERc->aa->idn,10.0,-1.0,&ERc->x[1],&ERc->y[1],&ERc->z[1],1);
                  }
               }
            else
               {
               if(ERc->ll2 != NULL)
                  {
                  FwriteMagnitudeAndTwoObjects(ERc->keyval,ERc->Cnumber,ERc->magnitude,
                        ERc->ll1->Sindex,G_LINE,ERc->ll1->Lindex,
                        ERc->ll1->localID,ERc->ll1->idn,10.0,-1.0,&ERc->x[0],&ERc->y[0],&ERc->z[0],1,
                        ERc->ll2->Sindex,G_LINE,ERc->ll2->Lindex,
                        ERc->ll2->localID,ERc->ll2->idn,10.0,-1.0,&ERc->x[1],&ERc->y[1],&ERc->z[1],2);
                  }
               else if(ERc->aa != NULL)
                  {
                  FwriteMagnitudeAndTwoObjects(ERc->keyval,ERc->Cnumber,ERc->magnitude,
                        ERc->ll1->Sindex,G_LINE,ERc->ll1->Lindex,
                        ERc->ll1->localID,ERc->ll1->idn,10.0,-1.0,&ERc->x[0],&ERc->y[0],&ERc->z[0],1,
                        ERc->aa->Sindex,G_LINE,ERc->aa->Lindex,
                        ERc->aa->localID,ERc->aa->idn,10.0,-1.0,&ERc->x[1],&ERc->y[1],&ERc->z[1],2);
                  }
               }
            break;
         case LUNDERSHTA:

         case LOVERSHTA:
            if(ERc->numpoints == 2)
               {
               FwriteMagnitudeAndTwoObjects(ERc->keyval,ERc->Cnumber,ERc->magnitude,
                        ERc->ll1->Sindex,G_LINE,ERc->ll1->Lindex,
                        ERc->ll1->localID,ERc->ll1->idn,10.0,-1.0,&ERc->x[0],&ERc->y[0],&ERc->z[0],1,
                        ERc->aa->Sindex,G_AREAL,ERc->aa->Lindex,
                        ERc->aa->localID,ERc->aa->idn,10.0,-1.0,&ERc->x[1],&ERc->y[1],&ERc->z[1],1);
               }
            else
               {
               FwriteMagnitudeAndTwoObjects(ERc->keyval,ERc->Cnumber,ERc->magnitude,
                        ERc->ll1->Sindex,G_LINE,ERc->ll1->Lindex,
                        ERc->ll1->localID,ERc->ll1->idn,10.0,-1.0,&ERc->x[0],&ERc->y[0],&ERc->z[0],1,
                        ERc->aa->Sindex,G_AREAL,ERc->aa->Lindex,
                        ERc->aa->localID,ERc->aa->idn,10.0,-1.0,&ERc->x[1],&ERc->y[1],&ERc->z[1],2);
               }
            break;

         case LAPROX:
         case LASLIVER:
               FwriteMagnitudeAndTwoObjects(ERc->keyval,ERc->Cnumber,ERc->magnitude,
                        ERc->ll1->Sindex,G_LINE,ERc->ll1->Lindex,
                        ERc->ll1->localID,ERc->ll1->idn,10.0,-1.0,&ERc->x[0],&ERc->y[0],&ERc->z[0],2,
                        ERc->aa->Sindex,G_AREAL,ERc->aa->Lindex,
                        ERc->aa->localID,ERc->aa->idn,10.0,-1.0,&ERc->x[2],&ERc->y[2],&ERc->z[2],2);
               break;

         case LLSLIVER:
               FwriteMagnitudeAndTwoObjects(ERc->keyval,ERc->Cnumber,ERc->magnitude,
                        ERc->ll1->Sindex,G_LINE,ERc->ll1->Lindex,
                        ERc->ll1->localID,ERc->ll1->idn,10.0,-1.0,&ERc->x[0],&ERc->y[0],&ERc->z[0],2,
                        ERc->ll2->Sindex,G_LINE,ERc->ll2->Lindex,
                        ERc->ll2->localID,ERc->ll2->idn,10.0,-1.0,&ERc->x[2],&ERc->y[2],&ERc->z[2],2);
               break;

         default:
            printf("unrecognized key condition flag received during linear feature over / under shoot analysis\n");
            break;
         }
      ERn = ERc;
      ERc = ERc->next;
      free(ERn);
      }

}


void PruneCheckedLinePairs(int Limit,int index)
{

   if(LinePairRoot[index].entry == NULL)
      {
      return;
      }
   LPp = LPc = LinePairRoot[index].entry;
   while(LPc != NULL)
      {
      if(LPc->maxindex < Limit) /*** want to prune this one ***/
         {
         if(LPc == LinePairRoot[index].entry)
            {
            LinePairRoot[index].entry = LinePairRoot[index].entry->next;
            PWc = LPc->p;
            while(PWc != NULL)
               {
               PWp = PWc;
               PWc = PWc->next;
               free(PWp);
               }
            free(LPc);
            LPp = LPc = LinePairRoot[index].entry;
            }
         else
            {
            LPp->next = LPc->next;
            PWc = LPc->p;
            while(PWc != NULL)
               {
               PWp = PWc;
               PWc = PWc->next;
               free(PWp);
               }
            free(LPc);
            LPc = LPp->next;
            }
         }
      else
         {
         LPp = LPc;
         LPc = LPc->next;
         }
      }
}


void FreeCheckedLinePairs(int index)
{
   if(LinePairRoot[index].entry == NULL)
      {
      return;
      }
   LPc = LinePairRoot[index].entry;
   while(LPc != NULL)
      {
      PWc = LPc->p;
      while(PWc != NULL)
         {
         PWp = PWc;
         PWc = PWc->next;
         free(PWp);
         }
      LPp = LPc;
      LPc = LPc->next;
      free(LPp);
      }
   LinePairRoot[index].entry = NULL;
}


int CheckThisLinePair(int index, int IndexLimit, int SzPC, int SzPW, double fidA, double fidB,char firstTime1, char firstTime2, double LengthA, double LengthB)
{
int answer;
double fid1, fid2;
extern int MaxXindex;
extern int MaxYindex;
double NumLM;


   NumLM = MaxXindex * MaxYindex;

   if(NumLM > 1000000)
      return(1);

   answer = 0;
   if(LengthB > LengthA) /** make the shorter line serve as the key ... ***/
      {
      fid1 = fidA;
      fid2 = fidB;
      }
   else
      {
      fid1 = fidB;
      fid2 = fidA;
      }

   LPc = LinePairRoot[index].entry;
   while(LPc != NULL)
      {
      if(LPc->fid == fid1)
         {
         LPc->maxindex = IndexLimit;
         PWc = LPc->p;
         while(PWc != NULL)
            {
            if(PWc->fid == fid2)
               break;
            PWc = PWc->next;
            }
         if(PWc == NULL)
            {
            answer = 1;
            PWn = (struct pairedwith *) (malloc(SzPW));
            if(PWn != NULL)
               {
               PWn->fid = fid2;
               PWn->next = LPc->p;
               LPc->p = PWn;
               }
            else
               {
               printf("out of memory in pair saving1\n");
               exit(-1);
               }
            }
         break;
         }
      LPc = LPc->next;
      }
   if(LPc == NULL)
      {
      answer = 1;
      LPn = (struct PairsChecked *) (malloc(SzPC));
      if(LPn != NULL)
         {
         LPn->maxindex = IndexLimit;
         LPn->fid = fid1;
         LPn->p = NULL;
         PWn = (struct pairedwith *) (malloc(SzPW));
         if(PWn != NULL)
            {
            PWn->fid = fid2;
            PWn->next = NULL;
            LPn->p = PWn;
            }
         else
            {
            printf("out of memory in pair saving4\n");
            exit(-1);
            }
         LPn->next = LinePairRoot[index].entry;
         LinePairRoot[index].entry = LPn;
         }
      }
   return(answer);
}



int SegOverlapsLine(double x1, double y1, double x2, double y2, struct RawLinear *L, int v1, int v2)
{
double d1,d2,d3,d4;
double minLx, maxLx, minLy, maxLy;
int i, ii, j;

   if(v1 < v2)
      {
      if(v1 > 0)
        i = v1 - 1;
      else
        i = v1;

      ii = v2 + 1;
      if(ii >= L->numnodes)
         --ii;
      } 
   else
      {
      if(v2 > 0)
        i = v2 - 1;
      else
        i = v2;

      ii = v1 + 1;
      if(ii >= L->numnodes)
         --ii;
      }

   if(x1 < x2)
      {
      minLx = x1;
      maxLx = x2;
      }
   else
      {
      maxLx = x1;
      minLx = x2;
      }

   if(y1 < y2)
      {
      minLy = y1;
      maxLy = y2;
      }
   else
      {
      maxLy = y1;
      minLy = y2;
      }

   for(j = i+1; j <= ii; j++)
      {
      if(MergeSeg_LineSegmentsOverlap(x1,y1,x2,y2,L->x[j-1],L->y[j-1],L->x[j],L->y[j],
                                      minLx,maxLx,minLy,maxLy, &d1, &d2, &d3, &d4, 0.09) > 0)
         {
         return(1);
         }
      }
   return(0);
}



int CNODE_ZBUST_Exception(double px, double py, int checkinstance, struct RawLinear *rlc, struct RawLinear *rln,
                            struct RawAreal *rac, struct RawAreal *ran,
                            struct RawPoint *rpc, struct RawPoint *rpn,
                            struct RawLinear *Lroot, struct RawAreal *Aroot, struct RawPoint *Proot)
{
struct RawLinear *rln2;
struct RawAreal *rac2;
struct RawPoint *rpc2;
int keepit, kk, kk2;
int Config3, Strat3,Domain3;
int part1, part2, part3;
double ptpdist3;

   keepit = 1;
   rln2 = Lroot;
   while(rln2 != NULL)
      {
      if((rlc == NULL) || (rln == NULL) || ((rln2 != rlc) && (rln2 != rln)))
         {
         Config3 = SCCtable[rln2->Sindex].C;
         Strat3 = SCCtable[rln2->Sindex].S;
         Domain3 = SCCtable[rln2->Sindex].D;
         if((CombinedCheckApplies(rln2->idn,checkinstance,CNODE_ZBUST,
                rln2->Lindex,rln2->Sindex,Config3,Strat3,Domain3,&part1,&part2,&part3) > 0) &&
                    (part3 > 0))
            {
            for(kk=1; kk<rln2->numnodes; kk++)
               {
               kk2 = kk - 1;
               ptpdist3 = PointToLineDist2D(px, py,
                           rln2->x[kk2],rln2->y[kk2],rln2->x[kk],rln2->y[kk]);
               if(ptpdist3 < 0.00001)
                  {
                  keepit = 0;
                  break;
                  }
               }
            }

         }
      if(keepit < 1)
         break;
      rln2 = rln2->next;
      }
   if(keepit > 0)
      {
      rpc2 = Proot;
      while(rpc2 != NULL)
         {
         if(rpc2->numverts == -1)  /*** only works with the pure points ***/
            {
            if((rpc == NULL) || (rpn == NULL) || ((rpc2 != rpc) && (rpc2 != rpn)))
               {
               Config3 = SCCtable[rpc2->Sindex].C;
               Strat3 = SCCtable[rpc2->Sindex].S;
               Domain3 = SCCtable[rpc2->Sindex].D;
               if((CombinedCheckApplies(rpc2->idn,checkinstance,CNODE_ZBUST,
                       rpc2->Lindex,rpc2->Sindex,Config3,Strat3,Domain3,&part1,&part2,&part3) > 0) &&
                    (part3 > 0))
                  {
                  ptpdist3 = Distance(px,py,rpc2->x[0],rpc2->y[0]);
                  if(ptpdist3 < 0.00001)
                     {
                     keepit = 0;
                     break;
                     }
                  }
               }
            }
         if(keepit < 1)
            break;
         rpc2 = rpc2->next;
         }
      }
   if(keepit > 0)
      {
      rac2 = Aroot;
      while(rac2 != NULL)
         {
         if((rac == NULL) || (ran == NULL) || ((rac2 != rac) && (rac2 != ran)))
            {
            Config3 = SCCtable[rac2->Sindex].C;
            Strat3 = SCCtable[rac2->Sindex].S;
            Domain3 = SCCtable[rac2->Sindex].D;
            if((CombinedCheckApplies(rac2->idn,checkinstance,CNODE_ZBUST,
                    rac2->Lindex,rac2->Sindex,Config3,Strat3,Domain3,&part1,&part2,&part3) > 0) &&
                    (part3 > 0))
               {
               if(rac2->RB_Tree_Edgelist == NULL)
                  {
                  if(PointInsidePoly(px,py,rac2->x, rac2->y, rac2->numverts) > 0)
                     {
                     keepit = 0;
                     }
                  }
               else if(PointInsideLargeAreal(px,py, rac2, &kk2) > 0)
                  {
                  keepit = 0;
                  }
               }
            }

         if(keepit < 1)
            break;
         rac2 = rac2->next;
         }
      }

   return(keepit);

}



void PerformAllGeomChecks(char * prompt, int cindex,struct RawLinear *Lroot,
     double minx,double miny,double maxx,double maxy, double multiplier,
     struct RawAreal *Aroot, struct RawBridge *Broot, struct RawPoint *Proot, struct ListOfEdges *PEroot,
     struct ListOfEdges *VPEroot, struct RawLinear *NLroot, struct ThePolys * Polyroot, int SzPC, int SzPW, int IndexLimit)
{
struct RawLinear *rlc, *rln;
struct RawAreal *rac, *ran;
struct RawPoint *rpc, *rpn;
struct ZmismatchNodes
   {
   double x[2];
   double y[2];
   double z[2];
   double magnitude;
   int keyval, Cnumber;
   int IDN1, IDN2;
   struct RawLinear *Lowner1, *Lowner2;
   struct RawAreal *Aowner1, *Aowner2;
   struct RawPoint *Powner1, *Powner2;
   unsigned int Sindex1, Sindex2;
   struct ZmismatchNodes * next;
   } *ZMNroot, *ZMNc, *ZMNp;

int SzZMN = sizeof(struct ZmismatchNodes);
int checkinstance,i,j,nodeindex,bestmatch;
int part1, part2, part3;
int Config2, Strat2,Domain2;
double ptpdist1, ptpdist2,closest;
double tolerance1, tolerance2;
int keepit;
struct RB_Edgelist * LastEdge, *Last_I_Edge;
int LastI, LastJ, UsedTree;


   ZMNroot = NULL;

   rlc = Lroot;
   while(rlc != NULL)
      {
      for(checkinstance = 0; checkinstance < TtlActiveChecks; checkinstance++)
         {
         if(CombinedCheckApplies(rlc->idn,checkinstance,CNODE_ZBUST,rlc->Lindex,rlc->Sindex,
               SCCtable[rlc->Sindex].C, SCCtable[rlc->Sindex].S, SCCtable[rlc->Sindex].D,&part1,&part2,&part3) > 0)
            {
            if(part1 > 0)
               {
               tolerance1 = FindRelevantSensitivity(CNODE_ZBUST,checkinstance,&tolerance2);
               nodeindex = 0;
               while(nodeindex < rlc->numnodes)
                  {
                  if((IsSentinelZvalue(rlc->z[nodeindex],UseNUNANPO) == 0) &&
                      (rlc->x[nodeindex] >= minx) && (rlc->x[nodeindex] <= maxx) &&
                         (rlc->y[nodeindex] >= miny) && (rlc->y[nodeindex] <= maxy))
                     {
                     rln = Lroot;
                     while(rln != NULL)
                        {
                        Config2 = SCCtable[rln->Sindex].C;
                        Strat2 = SCCtable[rln->Sindex].S;
                        Domain2 = SCCtable[rln->Sindex].D;
                        if((rln != rlc) &&
                           (CombinedCheckApplies(rln->idn,checkinstance,CNODE_ZBUST,rln->Lindex,rln->Sindex,
                              Config2,Strat2,Domain2,&part1,&part2,&part3) > 0))
                           {
                           if(part2 > 0)
                              {
                              if((CombinedCheckApplies(rln->idn,checkinstance,CNODE_ZBUST,rln->Lindex,rln->Sindex,
                                      Config2,Strat2,Domain2,&part1,&part2,&part3) > 0) &&
                                      (part3 > 0))
                                 part2 = 0;
                              }
                           if(part2 > 0)
                              {
                              j = 0; 
                              bestmatch = -1;
                              closest = tolerance1 * 100.0;
                              while(j < rln->numnodes)
                                 {
                                 if((IsSentinelZvalue(rln->z[j],UseNUNANPO) == 0) && 
                                         (rln->x[j] >= minx) && (rln->x[j] <= maxx) &&
                                           (rln->y[j] >= miny) && (rln->y[j] <= maxy))
                                    {
                                    ptpdist1 = Distance(rlc->x[nodeindex],rlc->y[nodeindex],rln->x[j],rln->y[j]);
                                    if((bestmatch < 0) || (ptpdist1 < closest))
                                       {
                                       bestmatch = j;
                                       closest = ptpdist1;
                                       }
                                    }
                                 j += 1;
                                 } /** end while j ***/
                              if(closest < tolerance1) /** consider the two nodes as matching in 2D ***/
                                 {
                                 if(rlc->z[nodeindex] > rln->z[bestmatch])
                                    ptpdist2 = rlc->z[nodeindex] - rln->z[bestmatch];
                                 else
                                    ptpdist2 = rln->z[bestmatch] - rlc->z[nodeindex];

                                 if(ptpdist2 >= tolerance2)
                                    {
                                    if((ptpdist2 >= ActiveChecks[checkinstance].sensitivity3) &&
                                         (ptpdist2 <= ActiveChecks[checkinstance].sensitivity4))
                                       {
                                       keepit = 0;
                                       }
                                    else
                                       {
                                       keepit = CNODE_ZBUST_Exception(rlc->x[nodeindex], rlc->y[nodeindex],
                                              checkinstance,rlc,rln,NULL,NULL,NULL,NULL,
                                              Lroot, Aroot, Proot);
                                       }
                                                             
                                    if(keepit > 0)
                                       {
                                    /** then we should have 2 end nodes that match in (x,y) but are off in Z as specified **/
                                       ZMNc = (struct ZmismatchNodes *) (malloc(SzZMN));
                                       if(ZMNc == NULL)
                                          {
                                          printf("available memory has been exhausted during analysis of Z-mismatch linear end nodes\n");
                                          exit(-1);
                                          }
                                       ZMNc->x[0] = rlc->x[nodeindex];
                                       ZMNc->y[0] = rlc->y[nodeindex];
                                       ZMNc->z[0] = rlc->z[nodeindex];
                                       ZMNc->x[1] = rln->x[bestmatch];
                                       ZMNc->y[1] = rln->y[bestmatch];
                                       ZMNc->z[1] = rln->z[bestmatch];
                                       ZMNc->IDN1 = rlc->idn;
                                       ZMNc->IDN2 = rln->idn;
                                       ZMNc->magnitude = ptpdist2;
                                       ZMNc->Lowner1 = rlc;
                                       ZMNc->Lowner2 = rln;
                                       ZMNc->Aowner1 = NULL;
                                       ZMNc->Aowner2 = NULL;
                                       ZMNc->Powner1 = NULL;
                                       ZMNc->Powner2 = NULL;
                                       ZMNc->Sindex1 = rlc->Sindex;
                                       ZMNc->Sindex2 = rln->Sindex;
                                       ZMNc->keyval = CNODE_ZBUST;
                                       ZMNc->Cnumber = Make_Correct(CNODE_ZBUST,checkinstance);
                                       if(ZMNroot == NULL)
                                          {
                                          ZMNc->next = NULL;
                                          ZMNroot = ZMNc;
                                          }
                                       else
                                          {
                                          keepit = 1;
                                          ZMNp = ZMNroot;
                                          while(ZMNp != NULL)
                                             {
                                             if((ZMNc->magnitude == ZMNp->magnitude) &&
                                                   (ZMNp->Lowner1 == ZMNc->Lowner1) && (ZMNp->Lowner2 == ZMNc->Lowner2))
                                                {
                                                if((ZMNc->x[0] == ZMNp->x[0]) && (ZMNc->y[0] == ZMNp->y[0]) && (ZMNc->z[0] == ZMNp->z[0]))
                                                   {
                                                   if((ZMNc->x[1] == ZMNp->x[1]) && (ZMNc->y[1] == ZMNp->y[1]) && (ZMNc->z[1] == ZMNp->z[1]))
                                                      {
                                                      keepit = 0;
                                                      break;
                                                      }
                                                   }
                                                }
                                             else if((ZMNc->magnitude == ZMNp->magnitude) &&
                                                   (ZMNp->Lowner1 == ZMNc->Lowner2) && (ZMNp->Lowner2 == ZMNc->Lowner1))
                                                {
                                                if((ZMNc->x[1] == ZMNp->x[0]) && (ZMNc->y[1] == ZMNp->y[0]) && (ZMNc->z[1] == ZMNp->z[0]))
                                                   {
                                                   if((ZMNc->x[0] == ZMNp->x[1]) && (ZMNc->y[0] == ZMNp->y[1]) && (ZMNc->z[0] == ZMNp->z[1]))
                                                      {
                                                      keepit = 0;
                                                      break;
                                                      }
                                                   }
                                                }
                                             ZMNp = ZMNp->next;
                                             }
                                          if(keepit > 0)
                                             {
                                             ZMNc->next = ZMNroot;
                                             ZMNroot = ZMNc;
                                             }
                                          else
                                             {
                                             free(ZMNc);
                                             }
                                          }
                                       }
                                    } /*** have a z mismatch this node ***/
                                 }
                              }
                           }
                        rln = rln->next;
                        }

                     ran = Aroot;
                     while(ran != NULL)
                        {
                        Config2 = SCCtable[ran->Sindex].C;
                        Strat2 = SCCtable[ran->Sindex].S;
                        Domain2 = SCCtable[ran->Sindex].D;
                        if(CombinedCheckApplies(ran->idn,checkinstance,CNODE_ZBUST,
                           ran->Lindex,ran->Sindex,Config2,Strat2,Domain2,&part1,&part2,&part3) > 0)
                           {
                           if(part2 > 0)
                              {
                              bestmatch = -1;
                              closest = tolerance1 * 100.0;
                              if(ran->RB_Tree_Edgelist != NULL)
                                 {
                                 LastEdge = NULL;
                                 LastJ = -1;
                                 j = GetNextArealIndex(ran, LastJ, 1, &LastEdge, cindex, &UsedTree);
                                 LastJ = j;
                                 }
                              else
                                 j = 0;
                              while(j >= 0)
                                 {
                                 if((IsSentinelZvalue(ran->z[j],UseNUNANPO) == 0) && (ran->x[j] >= minx) && (ran->x[j] <= maxx) && (ran->y[j] >= miny) && (ran->y[j] <= maxy))
                                    {
                                    ptpdist1 = Distance(rlc->x[nodeindex],rlc->y[nodeindex],ran->x[j],ran->y[j]);
                                    
                                    if((bestmatch < 0) || (ptpdist1 < closest))
                                       {
                                       bestmatch = j;
                                       closest = ptpdist1;
                                       }
                                    }
                                 if(ran->RB_Tree_Edgelist != NULL)
                                    {
                                    j = GetNextArealIndex(ran, LastJ, 1, &LastEdge, cindex, &UsedTree);
                                    LastJ = j;
                                    }
                                 else
                                    {
                                    ++j;
                                    if(j >= ran->numverts)
                                       j = -1;
                                    }
                                 } /*** while j >= 0 ***/
                              if(closest < tolerance1) /** consider the two nodes as matching in 2D ***/
                                 {
                                 if(rlc->z[nodeindex] > ran->z[bestmatch])
                                    ptpdist2 = rlc->z[nodeindex] - ran->z[bestmatch];
                                 else
                                    ptpdist2 = ran->z[bestmatch] - rlc->z[nodeindex];

                                 /***if(SensitivityCheck(GT, CNODE_ZBUST, checkinstance, ptpdist2) > 0) ***/
                                 if(ptpdist2 >= tolerance2)
                                    {
                                    if((ptpdist2 >= ActiveChecks[checkinstance].sensitivity3) &&
                                         (ptpdist2 <= ActiveChecks[checkinstance].sensitivity4))
                                       {
                                       keepit = 0;
                                       }
                                    else
                                       {
                                       keepit = CNODE_ZBUST_Exception(rlc->x[nodeindex], rlc->y[nodeindex],
                                              checkinstance,rlc,NULL,ran,NULL,NULL,NULL,
                                              Lroot, Aroot, Proot);
                                       }

                                    if(keepit > 0)
                                       {
                  /** then we should have 2 end nodes that match in (x,y) but are off in Z as specified **/
                                       ZMNc = (struct ZmismatchNodes *) (malloc(SzZMN));
                                       if(ZMNc == NULL)
                                          {
                                          printf("available memory has been exhausted during analysis of Z-mismatch linear end nodes\n");
                                          exit(-1);
                                          }
                                       ZMNc->x[0] = rlc->x[nodeindex];
                                       ZMNc->y[0] = rlc->y[nodeindex];
                                       ZMNc->z[0] = rlc->z[nodeindex];
                                       ZMNc->x[1] = ran->x[bestmatch];
                                       ZMNc->y[1] = ran->y[bestmatch];
                                       ZMNc->z[1] = ran->z[bestmatch];
                                       ZMNc->IDN1 = rlc->idn;
                                       ZMNc->IDN2 = ran->idn;
                                       ZMNc->magnitude = ptpdist2;
                                       ZMNc->Lowner1 = rlc;
                                       ZMNc->Lowner2 = NULL;
                                       ZMNc->Aowner1 = NULL;
                                       ZMNc->Aowner2 = ran;
                                       ZMNc->Powner1 = NULL;
                                       ZMNc->Powner2 = NULL;
                                       ZMNc->Sindex1 = rlc->Sindex;
                                       ZMNc->Sindex2 = ran->Sindex;
                                       ZMNc->keyval = CNODE_ZBUST;
                                       ZMNc->Cnumber = Make_Correct(CNODE_ZBUST,checkinstance);
                                       if(ZMNroot == NULL)
                                          {
                                          ZMNc->next = NULL;
                                          ZMNroot = ZMNc;
                                          }
                                       else
                                          {
                                          keepit = 1;
                                          ZMNp = ZMNroot;
                                          while(ZMNp != NULL)
                                             {
                                             if((ZMNc->magnitude == ZMNp->magnitude) &&
                                                   (ZMNp->Lowner1 == ZMNc->Lowner1) && (ZMNp->Aowner2 == ZMNc->Aowner2))
                                                {
                                                if((ZMNc->x[0] == ZMNp->x[0]) && (ZMNc->y[0] == ZMNp->y[0]) && (ZMNc->z[0] == ZMNp->z[0]))
                                                   {
                                                   if((ZMNc->x[1] == ZMNp->x[1]) && (ZMNc->y[1] == ZMNp->y[1]) && (ZMNc->z[1] == ZMNp->z[1]))
                                                      {
                                                      keepit = 0;
                                                      break;
                                                      }
                                                   }
                                                }
                                             ZMNp = ZMNp->next;
                                             }
                                          if(keepit > 0)
                                             {
                                             ZMNc->next = ZMNroot;
                                             ZMNroot = ZMNc;
                                             }
                                          else
                                             {
                                             free(ZMNc);
                                             }
                                          }
                                       }
                                    }
                                 }
                              }
                           }
                        ran = ran->next;
                        }

                     rpc = Proot;
                     while(rpc != NULL)
                        {
                        if(rpc->numverts == -1)
                           {
                        Config2 = SCCtable[rpc->Sindex].C;
                        Strat2 = SCCtable[rpc->Sindex].S;
                        Domain2 = SCCtable[rpc->Sindex].D;
                        if(CombinedCheckApplies(rpc->idn,checkinstance,CNODE_ZBUST,
                              rpc->Lindex,rpc->Sindex,Config2,Strat2,Domain2,&part1,&part2,&part3) > 0)
                           {
                           if(part2 > 0)
                              {
                              j = 0; 
                              if((IsSentinelZvalue(rpc->z[j],UseNUNANPO) == 0) && 
                                (rpc->x[j] >= minx) && (rpc->x[j] <= maxx) && (rpc->y[j] >= miny) && (rpc->y[j] <= maxy))
                                    {
                                    ptpdist1 = Distance(rlc->x[nodeindex],rlc->y[nodeindex],rpc->x[j],rpc->y[j]);
                                    if(ptpdist1 < tolerance1) /** consider the two nodes as matching in 2D ***/
                                       {
                                       if(rlc->z[nodeindex] > rpc->z[j])
                                          ptpdist2 = rlc->z[nodeindex] - rpc->z[j];
                                       else
                                          ptpdist2 = rpc->z[j] - rlc->z[nodeindex];

                                       if(ptpdist2 >= tolerance2)
                                          {
                                          if((ptpdist2 >= ActiveChecks[checkinstance].sensitivity3) &&
                                               (ptpdist2 <= ActiveChecks[checkinstance].sensitivity4))
                                             {
                                             keepit = 0;
                                             }
                                          else
                                             {
                                             keepit = CNODE_ZBUST_Exception(rlc->x[nodeindex], rlc->y[nodeindex],
                                                    checkinstance,rlc,NULL,NULL,NULL,rpc,NULL,
                                                    Lroot, Aroot, Proot);
                                             }

                                          if(keepit > 0)
                                             {
                                          /** then we should have 2 end nodes that match in (x,y) but are off in Z as specified **/
                                             ZMNc = (struct ZmismatchNodes *) (malloc(SzZMN));
                                             if(ZMNc == NULL)
                                                {
                                                printf("available memory has been exhausted during analysis of Z-mismatch linear end nodes\n");
                                                exit(-1);
                                                }
                                             ZMNc->x[0] = rlc->x[nodeindex];
                                             ZMNc->y[0] = rlc->y[nodeindex];
                                             ZMNc->z[0] = rlc->z[nodeindex];
                                             ZMNc->x[1] = rpc->x[j];
                                             ZMNc->y[1] = rpc->y[j];
                                             ZMNc->z[1] = rpc->z[j];
                                             ZMNc->IDN1 = rlc->idn;
                                             ZMNc->IDN2 = rpc->idn;
                                             ZMNc->magnitude = ptpdist2;
                                             ZMNc->Lowner1 = rlc;
                                             ZMNc->Lowner2 = NULL;
                                             ZMNc->Aowner1 = NULL;
                                             ZMNc->Aowner2 = NULL;
                                             ZMNc->Powner1 = NULL;
                                             ZMNc->Powner2 = rpc;
                                             ZMNc->Sindex1 = rlc->Sindex;
                                             ZMNc->Sindex2 = rpc->Sindex;
                                             ZMNc->keyval = CNODE_ZBUST;
                                             ZMNc->Cnumber = Make_Correct(CNODE_ZBUST,checkinstance);
                                             if(ZMNroot == NULL)
                                                {
                                                ZMNc->next = NULL;
                                                ZMNroot = ZMNc;
                                                }
                                             else
                                                {
                                                keepit = 1;
                                                ZMNp = ZMNroot;
                                                while(ZMNp != NULL)
                                                   {
                                                   if((ZMNc->magnitude == ZMNp->magnitude) &&
                                                         (ZMNp->Lowner1 == ZMNc->Lowner1) && (ZMNp->Powner2 == ZMNc->Powner2))
                                                      {
                                                      if((ZMNc->x[0] == ZMNp->x[0]) && (ZMNc->y[0] == ZMNp->y[0]) && (ZMNc->z[0] == ZMNp->z[0]))
                                                         {
                                                         if((ZMNc->x[1] == ZMNp->x[1]) && (ZMNc->y[1] == ZMNp->y[1]) && (ZMNc->z[1] == ZMNp->z[1]))
                                                            {
                                                            keepit = 0;
                                                            break;
                                                            }
                                                         }
                                                      }
                                                   ZMNp = ZMNp->next;
                                                   }
                                                if(keepit > 0)
                                                   {
                                                   ZMNc->next = ZMNroot;
                                                   ZMNroot = ZMNc;
                                                   }
                                                else
                                                   {
                                                   free(ZMNc);
                                                   }
                                                }
                                             }
                                          }
                                       }
                                    }
                                 j += 1;
                                 }
                              }
                           }
                        rpc = rpc->next;
                        }



                     }
                  nodeindex += 1;
                  }
               }
             } /*** end CNODE_ZBUST check  for line primary****/


         } /*** end checkinstance ****/

      rlc = rlc->next;
      }


   rac = Aroot;
   while(rac != NULL)
      {
      for(checkinstance = 0; checkinstance < TtlActiveChecks; checkinstance++)
         {
         if(CombinedCheckApplies(rac->idn,checkinstance,CNODE_ZBUST,rac->Lindex,rac->Sindex,
               SCCtable[rac->Sindex].C, SCCtable[rac->Sindex].S, SCCtable[rac->Sindex].D,&part1,&part2,&part3) > 0)
            {
            if(part1 > 0)
               {
               tolerance1 = FindRelevantSensitivity(CNODE_ZBUST,checkinstance,&tolerance2);
               if(rac->RB_Tree_Edgelist != NULL)
                  {
                  Last_I_Edge = NULL;
                  LastI = -1;
                  i = GetNextArealIndex(rac, LastI, 1, &Last_I_Edge, cindex, &UsedTree);
                  LastI = i;
                  }
               else
                  i = 0;
               while(i >= 0)
                  {
                  if((IsSentinelZvalue(rac->z[i],UseNUNANPO) == 0) &&
                      (rac->x[i] >= minx) && (rac->x[i] <= maxx) &&
                         (rac->y[i] >= miny) && (rac->y[i] <= maxy))
                     {
                     rln = Lroot;
                     while(rln != NULL)
                        {
                        Config2 = SCCtable[rln->Sindex].C;
                        Strat2 = SCCtable[rln->Sindex].S;
                        Domain2 = SCCtable[rln->Sindex].D;
                        if(CombinedCheckApplies(rln->idn,checkinstance,CNODE_ZBUST,rln->Lindex,rln->Sindex,
                              Config2,Strat2,Domain2,&part1,&part2,&part3) > 0)
                           {
                           if(part2 > 0)
                              {
                              j = 0;
                              bestmatch = -1;
                              closest = tolerance1 * 100.0;
                              while(j < rln->numnodes)
                                 {
                                 if((IsSentinelZvalue(rln->z[j],UseNUNANPO) == 0) &&
                                         (rln->x[j] >= minx) && (rln->x[j] <= maxx) &&
                                           (rln->y[j] >= miny) && (rln->y[j] <= maxy))
                                    {
                                    ptpdist1 = Distance(rac->x[i],rac->y[i],rln->x[j],rln->y[j]);
                                    if((bestmatch < 0) || (ptpdist1 < closest))
                                       {
                                       bestmatch = j;
                                       closest = ptpdist1;
                                       }
                                    }
                                 j += 1;
                                 } /** end while j ***/
                              if(closest < tolerance1) /** consider the two nodes as matching in 2D ***/
                                 {
                                 if(rac->z[i] > rln->z[bestmatch])
                                    ptpdist2 = rac->z[i] - rln->z[bestmatch];
                                 else
                                    ptpdist2 = rln->z[bestmatch] - rac->z[i];

                                 if(ptpdist2 >= tolerance2)
                                    {
                                    if((ptpdist2 >= ActiveChecks[checkinstance].sensitivity3) &&
                                         (ptpdist2 <= ActiveChecks[checkinstance].sensitivity4))
                                       {
                                       keepit = 0;
                                       }
                                    else
                                       {
                                       keepit = CNODE_ZBUST_Exception(rac->x[i], rac->y[i],
                                              checkinstance,NULL,rln,rac,NULL,NULL,NULL,
                                              Lroot, Aroot, Proot);
                                       }

                                    if(keepit > 0)
                                       {
                                    /** then we should have 2 end nodes that match in (x,y) but are off in Z as specified **/
                                       ZMNc = (struct ZmismatchNodes *) (malloc(SzZMN));
                                       if(ZMNc == NULL)
                                          {
                                          printf("available memory has been exhausted during analysis of Z-mismatch linear end nodes\n");
                                          exit(-1);
                                          }
                                       ZMNc->x[0] = rac->x[i];
                                       ZMNc->y[0] = rac->y[i];
                                       ZMNc->z[0] = rac->z[i];
                                       ZMNc->x[1] = rln->x[bestmatch];
                                       ZMNc->y[1] = rln->y[bestmatch];
                                       ZMNc->z[1] = rln->z[bestmatch];
                                       ZMNc->IDN1 = rac->idn;
                                       ZMNc->IDN2 = rln->idn;
                                       ZMNc->magnitude = ptpdist2;
                                       ZMNc->Lowner1 = NULL;
                                       ZMNc->Lowner2 = rln;
                                       ZMNc->Aowner1 = rac;
                                       ZMNc->Aowner2 = NULL;
                                       ZMNc->Powner1 = NULL;
                                       ZMNc->Powner2 = NULL;
                                       ZMNc->Sindex1 = rac->Sindex;
                                       ZMNc->Sindex2 = rln->Sindex;
                                       ZMNc->keyval = CNODE_ZBUST;
                                       ZMNc->Cnumber = Make_Correct(CNODE_ZBUST,checkinstance);
                                       if(ZMNroot == NULL)
                                          {
                                          ZMNc->next = NULL;
                                          ZMNroot = ZMNc;
                                          }
                                       else
                                          {
                                          keepit = 1;
                                          ZMNp = ZMNroot;
                                          while(ZMNp != NULL)
                                             {
                                             if((ZMNc->magnitude == ZMNp->magnitude) &&
                                                   (ZMNp->Aowner1 == ZMNc->Aowner1) && (ZMNp->Lowner2 == ZMNc->Lowner2))
                                                {
                                                if((ZMNc->x[0] == ZMNp->x[0]) && (ZMNc->y[0] == ZMNp->y[0]) && (ZMNc->z[0] == ZMNp->z[0]))
                                                   {
                                                   if((ZMNc->x[1] == ZMNp->x[1]) && (ZMNc->y[1] == ZMNp->y[1]) && (ZMNc->z[1] == ZMNp->z[1]))
                                                      {
                                                      keepit = 0;
                                                      break;
                                                      }
                                                   }
                                                }
                                             ZMNp = ZMNp->next;
                                             }
                                          if(keepit > 0)
                                             {
                                             ZMNc->next = ZMNroot;
                                             ZMNroot = ZMNc;
                                             }
                                          else
                                             {
                                             free(ZMNc);
                                             }
                                          }
                                       }
                                    } /*** have a z mismatch this node ***/
                                 }
                              }
                           }
                        rln = rln->next;
                        }

                     ran = Aroot;
                     while(ran != NULL)
                        {
                        Config2 = SCCtable[ran->Sindex].C;
                        Strat2 = SCCtable[ran->Sindex].S;
                        Domain2 = SCCtable[ran->Sindex].D;
                        if((rac != ran) && (CombinedCheckApplies(ran->idn,checkinstance,CNODE_ZBUST,
                           ran->Lindex,ran->Sindex,Config2,Strat2,Domain2,&part1,&part2,&part3) > 0))
                           {
                           if(part2 > 0)
                              {
                              bestmatch = -1;
                              closest = tolerance1 * 100.0;
                              if(ran->RB_Tree_Edgelist != NULL)
                                 {
                                 LastEdge = NULL;
                                 LastJ = -1;
                                 j = GetNextArealIndex(ran, LastJ, 1, &LastEdge, cindex, &UsedTree);
                                 LastJ = j;
                                 }
                              else
                                 j = 0;
                              while(j >= 0)
                                 {
                                 if((IsSentinelZvalue(ran->z[j],UseNUNANPO) == 0) &&
                                       (ran->x[j] >= minx) && (ran->x[j] <= maxx) && (ran->y[j] >= miny) && (ran->y[j] <= maxy))
                                    {
/**** then have a possible match with end node of rac ***/
                                    ptpdist1 = Distance(rac->x[i],rac->y[i],ran->x[j],ran->y[j]);

                                    if((bestmatch < 0) || (ptpdist1 < closest))
                                       {
                                       bestmatch = j;
                                       closest = ptpdist1;
                                       }
                                    }
                                 if(ran->RB_Tree_Edgelist != NULL)
                                    {
                                    j = GetNextArealIndex(ran, LastJ, 1, &LastEdge, cindex, &UsedTree);
                                    LastJ = j;
                                    }
                                 else
                                    {
                                    ++j;
                                    if(j >= ran->numverts)
                                       j = -1;
                                    }
                                 } /*** while j >= 0 ***/
                              if(closest < tolerance1) /** consider the two nodes as matching in 2D ***/
                                 {
                                 if(rac->z[i] > ran->z[bestmatch])
                                    ptpdist2 = rac->z[i] - ran->z[bestmatch];
                                 else
                                    ptpdist2 = ran->z[bestmatch] - rac->z[i];

                                 if(ptpdist2 >= tolerance2)
                                    {
                                    if((ptpdist2 >= ActiveChecks[checkinstance].sensitivity3) &&
                                         (ptpdist2 <= ActiveChecks[checkinstance].sensitivity4))
                                       {
                                       keepit = 0;
                                       }
                                    else
                                       {
                                       keepit = CNODE_ZBUST_Exception(rac->x[i], rac->y[i],
                                              checkinstance,NULL,NULL,rac,ran,NULL,NULL,
                                              Lroot, Aroot, Proot);
                                       }

                                    if(keepit > 0)
                                       {
                                       ZMNc = (struct ZmismatchNodes *) (malloc(SzZMN));
                                       if(ZMNc == NULL)
                                          {
                                          printf("available memory has been exhausted during analysis of Z-mismatch linear end nodes\n");
                                          exit(-1);
                                          }
                                       ZMNc->x[0] = rac->x[i];
                                       ZMNc->y[0] = rac->y[i];
                                       ZMNc->z[0] = rac->z[i];
                                       ZMNc->x[1] = ran->x[bestmatch];
                                       ZMNc->y[1] = ran->y[bestmatch];
                                       ZMNc->z[1] = ran->z[bestmatch];
                                       ZMNc->IDN1 = rac->idn;
                                       ZMNc->IDN2 = ran->idn;
                                       ZMNc->magnitude = ptpdist2;
                                       ZMNc->Lowner1 = NULL;
                                       ZMNc->Lowner2 = NULL;
                                       ZMNc->Aowner1 = rac;
                                       ZMNc->Aowner2 = ran;
                                       ZMNc->Powner1 = NULL;
                                       ZMNc->Powner2 = NULL;
                                       ZMNc->Sindex1 = rac->Sindex;
                                       ZMNc->Sindex2 = ran->Sindex;
                                       ZMNc->keyval = CNODE_ZBUST;
                                       ZMNc->Cnumber = Make_Correct(CNODE_ZBUST,checkinstance);
                                       if(ZMNroot == NULL)
                                          {
                                          ZMNc->next = NULL;
                                          ZMNroot = ZMNc;
                                          }
                                       else
                                          {
                                          keepit = 1;
                                          ZMNp = ZMNroot;
                                          while(ZMNp != NULL)
                                             {
                                             if((ZMNc->magnitude == ZMNp->magnitude) &&
                                                   (ZMNp->Aowner1 == ZMNc->Aowner1) && (ZMNp->Aowner2 == ZMNc->Aowner2))
                                                {
                                                if((ZMNc->x[0] == ZMNp->x[0]) && (ZMNc->y[0] == ZMNp->y[0]) && (ZMNc->z[0] == ZMNp->z[0]))
                                                   {
                                                   if((ZMNc->x[1] == ZMNp->x[1]) && (ZMNc->y[1] == ZMNp->y[1]) && (ZMNc->z[1] == ZMNp->z[1]))
                                                      {
                                                      keepit = 0;
                                                      break;
                                                      }
                                                   }
                                                }
                                             else if((ZMNc->magnitude == ZMNp->magnitude) &&
                                                   (ZMNp->Aowner1 == ZMNc->Aowner2) && (ZMNp->Aowner1 == ZMNc->Aowner2))
                                                {
                                                if((ZMNc->x[0] == ZMNp->x[0]) && (ZMNc->y[0] == ZMNp->y[0]) && (ZMNc->z[0] == ZMNp->z[0]))
                                                   {
                                                   if((ZMNc->x[1] == ZMNp->x[1]) && (ZMNc->y[1] == ZMNp->y[1]) && (ZMNc->z[1] == ZMNp->z[1]))
                                                      {
                                                      keepit = 0;
                                                      break;
                                                      }
                                                   }
                                                }
                                             ZMNp = ZMNp->next;
                                             }
                                          if(keepit > 0)
                                             {
                                             ZMNc->next = ZMNroot;
                                             ZMNroot = ZMNc;
                                             }
                                          else
                                             {
                                             free(ZMNc);
                                             }
                                          }
                                       }
                                    }
                                 }
                              }
                           }
                        ran = ran->next;
                        }

                     rpc = Proot;
                     while(rpc != NULL)
                        {
                        if(rpc->numverts == -1)
                           {
                        Config2 = SCCtable[rpc->Sindex].C;
                        Strat2 = SCCtable[rpc->Sindex].S;
                        Domain2 = SCCtable[rpc->Sindex].D;
                        if(CombinedCheckApplies(rpc->idn,checkinstance,CNODE_ZBUST,
                              rpc->Lindex,rpc->Sindex,Config2,Strat2,Domain2,&part1,&part2,&part3) > 0)
                           {
                           if(part2 > 0)
                              {
                              j = 0;
                              if((IsSentinelZvalue(rpc->z[j],UseNUNANPO) == 0) &&
                                (rpc->x[j] >= minx) && (rpc->x[j] <= maxx) && (rpc->y[j] >= miny) && (rpc->y[j] <= maxy))
                                    {
                                    ptpdist1 = Distance(rac->x[i],rac->y[i],rpc->x[j],rpc->y[j]);
                                    if(ptpdist1 < tolerance1) /** consider the two nodes as matching in 2D ***/
                                       {
                                       if(rac->z[i] > rpc->z[j])
                                          ptpdist2 = rac->z[i] - rpc->z[j];
                                       else
                                          ptpdist2 = rpc->z[j] - rac->z[i];

                                       if(ptpdist2 >= tolerance2)
                                          {
                                          if((ptpdist2 >= ActiveChecks[checkinstance].sensitivity3) &&
                                               (ptpdist2 <= ActiveChecks[checkinstance].sensitivity4))
                                             {
                                             keepit = 0;
                                             }
                                          else
                                             {
                                             keepit = CNODE_ZBUST_Exception(rac->x[i], rac->y[i],
                                                    checkinstance,NULL,NULL,rac,NULL,rpc,NULL,
                                                    Lroot, Aroot, Proot);
                                             }

                                          if(keepit > 0)
                                             {
                                          /** then we should have 2 end nodes that match in (x,y) but are off in Z as specified **/
                                             ZMNc = (struct ZmismatchNodes *) (malloc(SzZMN));
                                             if(ZMNc == NULL)
                                                {
                                                printf("available memory has been exhausted during analysis of Z-mismatch linear end nodes\n");
                                                exit(-1);
                                                }
                                             ZMNc->x[0] = rac->x[i];
                                             ZMNc->y[0] = rac->y[i];
                                             ZMNc->z[0] = rac->z[i];
                                             ZMNc->x[1] = rpc->x[j];
                                             ZMNc->y[1] = rpc->y[j];
                                             ZMNc->z[1] = rpc->z[j];
                                             ZMNc->IDN1 = rac->idn;
                                             ZMNc->IDN2 = rpc->idn;
                                             ZMNc->magnitude = ptpdist2;
                                             ZMNc->Lowner1 = NULL;
                                             ZMNc->Lowner2 = NULL;
                                             ZMNc->Aowner1 = rac;
                                             ZMNc->Aowner2 = NULL;
                                             ZMNc->Powner1 = NULL;
                                             ZMNc->Powner2 = rpc;
                                             ZMNc->Sindex1 = rac->Sindex;
                                             ZMNc->Sindex2 = rpc->Sindex;
                                             ZMNc->keyval = CNODE_ZBUST;
                                             ZMNc->Cnumber = Make_Correct(CNODE_ZBUST,checkinstance);
                                             if(ZMNroot == NULL)
                                                {
                                                ZMNc->next = NULL;
                                                ZMNroot = ZMNc;
                                                }
                                             else
                                                {
                                                keepit = 1;
                                                ZMNp = ZMNroot;
                                                while(ZMNp != NULL)
                                                   {
                                                   if((ZMNc->magnitude == ZMNp->magnitude) &&
                                                         (ZMNp->Aowner1 == ZMNc->Aowner1) && (ZMNp->Powner2 == ZMNc->Powner2))
                                                      {
                                                      if((ZMNc->x[0] == ZMNp->x[0]) && (ZMNc->y[0] == ZMNp->y[0]) && (ZMNc->z[0] == ZMNp->z[0]))
                                                         {
                                                         if((ZMNc->x[1] == ZMNp->x[1]) && (ZMNc->y[1] == ZMNp->y[1]) && (ZMNc->z[1] == ZMNp->z[1]))
                                                            {
                                                            keepit = 0;
                                                            break;
                                                            }
                                                         }
                                                      }
                                                   ZMNp = ZMNp->next;
                                                   }
                                                if(keepit > 0)
                                                   {
                                                   ZMNc->next = ZMNroot;
                                                   ZMNroot = ZMNc;
                                                   }
                                                else
                                                   {
                                                   free(ZMNc);
                                                   }
                                                }
                                             }
                                          }
                                       }
                                    }
                                 j += 1;
                                 }
                              }
                           }
                        rpc = rpc->next;
                        }



                     }
                  if(rac->RB_Tree_Edgelist != NULL)
                     {
                     i = GetNextArealIndex(rac, LastI, 1, &Last_I_Edge, cindex, &UsedTree);
                     LastI = i;
                     }
                  else
                     {
                     ++i;
                     if(i >= rac->numverts)
                        i = -1;
                     }
                  } /*** while i >= 0 ***/
               }
             } /*** end CNODE_ZBUST check for area primary****/


         } /*** end checkinstance ****/

      rac = rac->next;
      }



   rpc = Proot;
   while(rpc != NULL)
      {
      for(checkinstance = 0; checkinstance < TtlActiveChecks; checkinstance++)
         {
         if(CombinedCheckApplies(rpc->idn,checkinstance,CNODE_ZBUST,rpc->Lindex,rpc->Sindex,
               SCCtable[rpc->Sindex].C, SCCtable[rpc->Sindex].S, SCCtable[rpc->Sindex].D,&part1,&part2,&part3) > 0)
            {
            if(part1 > 0)
               {
               tolerance1 = FindRelevantSensitivity(CNODE_ZBUST,checkinstance,&tolerance2);
               i = 0;
               if(rpc->numverts == -1)
                  {
                  if((IsSentinelZvalue(rpc->z[i],UseNUNANPO) == 0) &&
                      (rpc->x[i] >= minx) && (rpc->x[i] <= maxx) &&
                         (rpc->y[i] >= miny) && (rpc->y[i] <= maxy))
                     {
                     rln = Lroot;
                     while(rln != NULL)
                        {
                        Config2 = SCCtable[rln->Sindex].C;
                        Strat2 = SCCtable[rln->Sindex].S;
                        Domain2 = SCCtable[rln->Sindex].D;
                        if(CombinedCheckApplies(rln->idn,checkinstance,CNODE_ZBUST,rln->Lindex,rln->Sindex,
                              Config2,Strat2,Domain2,&part1,&part2,&part3) > 0)
                           {
                           if(part2 > 0)
                              {
                              j = 0;
                              bestmatch = -1;
                              closest = tolerance1 * 100.0;
                              while(j < rln->numnodes)
                                 {
                                 if((IsSentinelZvalue(rln->z[j],UseNUNANPO) == 0) &&
                                         (rln->x[j] >= minx) && (rln->x[j] <= maxx) &&
                                           (rln->y[j] >= miny) && (rln->y[j] <= maxy))
                                    {
                                    ptpdist1 = Distance(rpc->x[i],rpc->y[i],rln->x[j],rln->y[j]);
                                    if((bestmatch < 0) || (ptpdist1 < closest))
                                       {
                                       bestmatch = j;
                                       closest = ptpdist1;
                                       }
                                    }
                                 j += 1;
                                 } /** end while j ***/
                              if(closest < tolerance1) /** consider the two nodes as matching in 2D ***/
                                 {
                                 if(rpc->z[i] > rln->z[bestmatch])
                                    ptpdist2 = rpc->z[i] - rln->z[bestmatch];
                                 else
                                    ptpdist2 = rln->z[bestmatch] - rpc->z[i];

                                 if(ptpdist2 >= tolerance2)
                                    {
                                    if((ptpdist2 >= ActiveChecks[checkinstance].sensitivity3) &&
                                         (ptpdist2 <= ActiveChecks[checkinstance].sensitivity4))
                                       {
                                       keepit = 0;
                                       }
                                    else
                                       {
                                       keepit = CNODE_ZBUST_Exception(rpc->x[i], rpc->y[i],
                                              checkinstance,NULL,rln,NULL,NULL,rpc,NULL,
                                              Lroot, Aroot, Proot);
                                       }

                                    if(keepit > 0)
                                       {
                                    /** then we should have 2 nodes that match in (x,y) but are off in Z as specified **/
                                       ZMNc = (struct ZmismatchNodes *) (malloc(SzZMN));
                                       if(ZMNc == NULL)
                                          {
                                          printf("available memory has been exhausted during analysis of Z-mismatch linear end nodes\n");
                                          exit(-1);
                                          }
                                       ZMNc->x[0] = rpc->x[i];
                                       ZMNc->y[0] = rpc->y[i];
                                       ZMNc->z[0] = rpc->z[i];
                                       ZMNc->x[1] = rln->x[bestmatch];
                                       ZMNc->y[1] = rln->y[bestmatch];
                                       ZMNc->z[1] = rln->z[bestmatch];
                                       ZMNc->IDN1 = rpc->idn;
                                       ZMNc->IDN2 = rln->idn;
                                       ZMNc->magnitude = ptpdist2;
                                       ZMNc->Lowner1 = NULL;
                                       ZMNc->Lowner2 = rln;
                                       ZMNc->Aowner1 = NULL;
                                       ZMNc->Aowner2 = NULL;
                                       ZMNc->Powner1 = rpc;
                                       ZMNc->Powner2 = NULL;
                                       ZMNc->Sindex1 = rpc->Sindex;
                                       ZMNc->Sindex2 = rln->Sindex;
                                       ZMNc->keyval = CNODE_ZBUST;
                                       ZMNc->Cnumber = Make_Correct(CNODE_ZBUST,checkinstance);
                                       if(ZMNroot == NULL)
                                          {
                                          ZMNc->next = NULL;
                                          ZMNroot = ZMNc;
                                          }
                                       else
                                          {
                                          keepit = 1;
                                          ZMNp = ZMNroot;
                                          while(ZMNp != NULL)
                                             {
                                             if((ZMNc->magnitude == ZMNp->magnitude) &&
                                                   (ZMNp->Aowner1 == ZMNc->Aowner1) && (ZMNp->Lowner2 == ZMNc->Lowner2))
                                                {
                                                if((ZMNc->x[0] == ZMNp->x[0]) && (ZMNc->y[0] == ZMNp->y[0]) && (ZMNc->z[0] == ZMNp->z[0]))
                                                   {
                                                   if((ZMNc->x[1] == ZMNp->x[1]) && (ZMNc->y[1] == ZMNp->y[1]) && (ZMNc->z[1] == ZMNp->z[1]))
                                                      {
                                                      keepit = 0;
                                                      break;
                                                      }
                                                   }
                                                }
                                             ZMNp = ZMNp->next;
                                             }
                                          if(keepit > 0)
                                             {
                                             ZMNc->next = ZMNroot;
                                             ZMNroot = ZMNc;
                                             }
                                          else
                                             {
                                             free(ZMNc);
                                             }
                                          }
                                       }
                                    } /*** have a z mismatch this node ***/
                                 }
                              }
                           }
                        rln = rln->next;
                        }

                     ran = Aroot;
                     while(ran != NULL)
                        {
                        Config2 = SCCtable[ran->Sindex].C;
                        Strat2 = SCCtable[ran->Sindex].S;
                        Domain2 = SCCtable[ran->Sindex].D;
                        if(CombinedCheckApplies(ran->idn,checkinstance,CNODE_ZBUST,
                           ran->Lindex,ran->Sindex,Config2,Strat2,Domain2,&part1,&part2,&part3) > 0)
                           {
                           if(part2 > 0)
                              {
                              bestmatch = -1;
                              closest = tolerance1 * 100.0;
                              if(ran->RB_Tree_Edgelist != NULL)
                                 {
                                 LastEdge = NULL;
                                 LastJ = -1;
                                 j = GetNextArealIndex(ran, LastJ, 1, &LastEdge, cindex, &UsedTree);
                                 LastJ = j;
                                 }
                              else
                                 j = 0;
                              while(j >= 0)
                                 {
                                 if((IsSentinelZvalue(ran->z[j],UseNUNANPO) == 0) &&
                                       (ran->x[j] >= minx) && (ran->x[j] <= maxx) && (ran->y[j] >= miny) && (ran->y[j] <= maxy))
                                    {
                                    ptpdist1 = Distance(rpc->x[i],rpc->y[i],ran->x[j],ran->y[j]);

                                    if((bestmatch < 0) || (ptpdist1 < closest))
                                       {
                                       bestmatch = j;
                                       closest = ptpdist1;
                                       }
                                    }
                                 if(ran->RB_Tree_Edgelist != NULL)
                                    {
                                    j = GetNextArealIndex(ran, LastJ, 1, &LastEdge, cindex, &UsedTree);
                                    LastJ = j;
                                    }
                                 else
                                    {
                                    ++j;
                                    if(j >= ran->numverts)
                                       j = -1;
                                    }
                                 } /*** while j >= 0 ***/
                              if(closest < tolerance1) /** consider the two nodes as matching in 2D ***/
                                 {
                                 if(rpc->z[i] > ran->z[bestmatch])
                                    ptpdist2 = rpc->z[i] - ran->z[bestmatch];
                                 else
                                    ptpdist2 = ran->z[bestmatch] - rpc->z[i];

                                 if(ptpdist2 >= tolerance2)
                                    {
                                    if((ptpdist2 >= ActiveChecks[checkinstance].sensitivity3) &&
                                         (ptpdist2 <= ActiveChecks[checkinstance].sensitivity4))
                                       {
                                       keepit = 0;
                                       }
                                    else
                                       {
                                       keepit = CNODE_ZBUST_Exception(rpc->x[i], rpc->y[i],
                                              checkinstance,NULL,NULL,NULL,ran,rpc,NULL,
                                              Lroot, Aroot, Proot);
                                       }

                                    if(keepit > 0)
                                       {
                  /** then we should have 2 end nodes that match in (x,y) but are off in Z as specified **/
                                       ZMNc = (struct ZmismatchNodes *) (malloc(SzZMN));
                                       if(ZMNc == NULL)
                                          {
                                          printf("available memory has been exhausted during analysis of Z-mismatch linear end nodes\n");
                                          exit(-1);
                                          }
                                       ZMNc->x[0] = rpc->x[i];
                                       ZMNc->y[0] = rpc->y[i];
                                       ZMNc->z[0] = rpc->z[i];
                                       ZMNc->x[1] = ran->x[bestmatch];
                                       ZMNc->y[1] = ran->y[bestmatch];
                                       ZMNc->z[1] = ran->z[bestmatch];
                                       ZMNc->IDN1 = rpc->idn;
                                       ZMNc->IDN2 = ran->idn;
                                       ZMNc->magnitude = ptpdist2;
                                       ZMNc->Lowner1 = NULL;
                                       ZMNc->Lowner2 = NULL;
                                       ZMNc->Aowner1 = NULL;
                                       ZMNc->Aowner2 = ran;
                                       ZMNc->Powner1 = rpc;
                                       ZMNc->Powner2 = NULL;
                                       ZMNc->Sindex1 = rpc->Sindex;
                                       ZMNc->Sindex2 = ran->Sindex;
                                       ZMNc->keyval = CNODE_ZBUST;
                                       ZMNc->Cnumber = Make_Correct(CNODE_ZBUST,checkinstance);
                                       if(ZMNroot == NULL)
                                          {
                                          ZMNc->next = NULL;
                                          ZMNroot = ZMNc;
                                          }
                                       else
                                          {
                                          keepit = 1;
                                          ZMNp = ZMNroot;
                                          while(ZMNp != NULL)
                                             {
                                             if((ZMNc->magnitude == ZMNp->magnitude) &&
                                                   (ZMNp->Aowner1 == ZMNc->Aowner1) && (ZMNp->Aowner2 == ZMNc->Aowner2))
                                                {
                                                if((ZMNc->x[0] == ZMNp->x[0]) && (ZMNc->y[0] == ZMNp->y[0]) && (ZMNc->z[0] == ZMNp->z[0]))
                                                   {
                                                   if((ZMNc->x[1] == ZMNp->x[1]) && (ZMNc->y[1] == ZMNp->y[1]) && (ZMNc->z[1] == ZMNp->z[1]))
                                                      {
                                                      keepit = 0;
                                                      break;
                                                      }
                                                   }
                                                }
                                             ZMNp = ZMNp->next;
                                             }
                                          if(keepit > 0)
                                             {
                                             ZMNc->next = ZMNroot;
                                             ZMNroot = ZMNc;
                                             }
                                          else
                                             {
                                             free(ZMNc);
                                             }
                                          }
                                       }
                                    }
                                 }
                              }
                           }
                        ran = ran->next;
                        }

                     rpn = Proot;
                     while(rpn != NULL)
                        {
                        if(rpn->numverts == -1)
                           {
                           Config2 = SCCtable[rpn->Sindex].C;
                           Strat2 = SCCtable[rpn->Sindex].S;
                           Domain2 = SCCtable[rpn->Sindex].D;
                           if((rpc != rpn) && (CombinedCheckApplies(rpn->idn,checkinstance,CNODE_ZBUST,
                              rpn->Lindex,rpn->Sindex,Config2,Strat2,Domain2,&part1,&part2,&part3) > 0))
                              {
                              if(part2 > 0)
                                 {
                                 j = 0;
                                 if((IsSentinelZvalue(rpn->z[j],UseNUNANPO) == 0) &&
                                   (rpn->x[j] >= minx) && (rpn->x[j] <= maxx) && (rpn->y[j] >= miny) && (rpn->y[j] <= maxy))
                                    {
                                    ptpdist1 = Distance(rpc->x[i],rpc->y[i],rpn->x[j],rpn->y[j]);
                                    if(ptpdist1 < tolerance1) /** consider the two nodes as matching in 2D ***/
                                       {
                                       if(rpc->z[i] > rpn->z[j])
                                          ptpdist2 = rpc->z[i] - rpn->z[j];
                                       else
                                          ptpdist2 = rpn->z[j] - rpc->z[i];

                                       if(ptpdist2 >= tolerance2)
                                          {
                                          if((ptpdist2 >= ActiveChecks[checkinstance].sensitivity3) && 
                                               (ptpdist2 <= ActiveChecks[checkinstance].sensitivity4))
                                             {
                                             keepit = 0;
                                             }
                                          else
                                             {
                                             keepit = CNODE_ZBUST_Exception(rpc->x[i], rpc->y[i],
                                                    checkinstance,NULL,NULL,NULL,NULL,rpc,rpn,
                                                    Lroot, Aroot, Proot);
                                             }

                                          if(keepit > 0)
                                             {
                                          /** then we should have 2 point nodes that match in (x,y) but are off in Z as specified **/
                                             ZMNc = (struct ZmismatchNodes *) (malloc(SzZMN));
                                             if(ZMNc == NULL)
                                                {
                                                printf("available memory has been exhausted during analysis of Z-mismatch linear end nodes\n");
                                                exit(-1);
                                                }
                                             ZMNc->x[0] = rpc->x[i];
                                             ZMNc->y[0] = rpc->y[i];
                                             ZMNc->z[0] = rpc->z[i];
                                             ZMNc->x[1] = rpn->x[j];
                                             ZMNc->y[1] = rpn->y[j];
                                             ZMNc->z[1] = rpn->z[j];
                                             ZMNc->IDN1 = rpc->idn;
                                             ZMNc->IDN2 = rpn->idn;
                                             ZMNc->magnitude = ptpdist2;
                                             ZMNc->Lowner1 = NULL;
                                             ZMNc->Lowner2 = NULL;
                                             ZMNc->Aowner1 = NULL;
                                             ZMNc->Aowner2 = NULL;
                                             ZMNc->Powner1 = rpc;
                                             ZMNc->Powner2 = rpn;
                                             ZMNc->Sindex1 = rpc->Sindex;
                                             ZMNc->Sindex2 = rpn->Sindex;
                                             ZMNc->keyval = CNODE_ZBUST;
                                             ZMNc->Cnumber = Make_Correct(CNODE_ZBUST,checkinstance);
                                             if(ZMNroot == NULL)
                                                {
                                                ZMNc->next = NULL;
                                                ZMNroot = ZMNc;
                                                }
                                             else
                                                {
                                                keepit = 1;
                                                ZMNp = ZMNroot;
                                                while(ZMNp != NULL)
                                                while(ZMNp != NULL)
                                                   {
                                                   if((ZMNc->magnitude == ZMNp->magnitude) &&
                                                         (ZMNp->Aowner1 == ZMNc->Aowner1) && (ZMNp->Powner2 == ZMNc->Powner2))
                                                      {
                                                      if((ZMNc->x[0] == ZMNp->x[0]) && (ZMNc->y[0] == ZMNp->y[0]) && (ZMNc->z[0] == ZMNp->z[0]))
                                                         {
                                                         if((ZMNc->x[1] == ZMNp->x[1]) && (ZMNc->y[1] == ZMNp->y[1]) && (ZMNc->z[1] == ZMNp->z[1]))
                                                            {
                                                            keepit = 0;
                                                            break;
                                                            }
                                                         }
                                                      }
                                                   ZMNp = ZMNp->next;
                                                   }
                                                if(keepit > 0)
                                                   {
                                                   ZMNc->next = ZMNroot;
                                                   ZMNroot = ZMNc;
                                                   }
                                                else
                                                   {
                                                   free(ZMNc);
                                                   }
                                                }
                                             }
                                          }
                                       }
                                    }
                                 j += 1;
                                 }
                              }
                           }
                        rpn = rpn->next;
                        }

                     }
                  } /*** end if(rpc->numverts == -1) ***/
               }
             } /*** end CNODE_ZBUST check for area primary****/


         } /*** end checkinstance ****/

      rpc = rpc->next;
      }



   ZMNc = ZMNroot;
   while(ZMNc != NULL)
      {
      switch(ZMNc->keyval)
         {
         case CNODE_ZBUST:
            if(ZMNc->Lowner1 != NULL)
               {
               if(ZMNc->Lowner2 != NULL)
                  {
                  FwriteMagnitudeAndTwoObjects(ZMNc->keyval,ZMNc->Cnumber,ZMNc->magnitude,
                        ZMNc->Sindex1,G_LINE,ZMNc->Lowner1->Lindex,
                        ZMNc->Lowner1->localID,ZMNc->Lowner1->idn,10.0,-1.0,&ZMNc->x[0],&ZMNc->y[0],&ZMNc->z[0],1,
                        ZMNc->Sindex2,G_LINE,ZMNc->Lowner2->Lindex,
                        ZMNc->Lowner2->localID,ZMNc->Lowner2->idn,10.0,-1.0,&ZMNc->x[1],&ZMNc->y[1],&ZMNc->z[1],1);
                  }
               else if(ZMNc->Aowner2 != NULL)
                  {
                  FwriteMagnitudeAndTwoObjects(ZMNc->keyval,ZMNc->Cnumber,ZMNc->magnitude,
                        ZMNc->Sindex1,G_LINE,ZMNc->Lowner1->Lindex,
                        ZMNc->Lowner1->localID,ZMNc->Lowner1->idn,10.0,-1.0,&ZMNc->x[0],&ZMNc->y[0],&ZMNc->z[0],1,
                        ZMNc->Sindex2,G_AREAL,ZMNc->Aowner2->Lindex,
                        ZMNc->Aowner2->localID,ZMNc->Aowner2->idn,10.0,-1.0,&ZMNc->x[1],&ZMNc->y[1],&ZMNc->z[1],1);
                  }
               else if(ZMNc->Powner2 != NULL)
                  {
                  FwriteMagnitudeAndTwoObjects(ZMNc->keyval,ZMNc->Cnumber,ZMNc->magnitude,
                        ZMNc->Sindex1,G_LINE,ZMNc->Lowner1->Lindex,
                        ZMNc->Lowner1->localID,ZMNc->Lowner1->idn,10.0,-1.0,&ZMNc->x[0],&ZMNc->y[0],&ZMNc->z[0],1,
                        ZMNc->Sindex2,G_POINT,ZMNc->Powner2->Lindex,
                        ZMNc->Powner2->localID,ZMNc->Powner2->idn,10.0,-1.0,&ZMNc->x[1],&ZMNc->y[1],&ZMNc->z[1],1);
                  }
               }
            else if(ZMNc->Aowner1 != NULL)
               {
               if(ZMNc->Lowner2 != NULL)
                  {
                  FwriteMagnitudeAndTwoObjects(ZMNc->keyval,ZMNc->Cnumber,ZMNc->magnitude,
                        ZMNc->Sindex1,G_AREAL,ZMNc->Aowner1->Lindex,
                        ZMNc->Aowner1->localID,ZMNc->Aowner1->idn,10.0,-1.0,&ZMNc->x[0],&ZMNc->y[0],&ZMNc->z[0],1,
                        ZMNc->Sindex2,G_LINE,ZMNc->Lowner2->Lindex,
                        ZMNc->Lowner2->localID,ZMNc->Lowner2->idn,10.0,-1.0,&ZMNc->x[1],&ZMNc->y[1],&ZMNc->z[1],1);
                  }
               else if(ZMNc->Aowner2 != NULL)
                  {
                  FwriteMagnitudeAndTwoObjects(ZMNc->keyval,ZMNc->Cnumber,ZMNc->magnitude,
                        ZMNc->Sindex1,G_AREAL,ZMNc->Aowner1->Lindex,
                        ZMNc->Aowner1->localID,ZMNc->Aowner1->idn,10.0,-1.0,&ZMNc->x[0],&ZMNc->y[0],&ZMNc->z[0],1,
                        ZMNc->Sindex2,G_AREAL,ZMNc->Aowner2->Lindex,
                        ZMNc->Aowner2->localID,ZMNc->Aowner2->idn,10.0,-1.0,&ZMNc->x[1],&ZMNc->y[1],&ZMNc->z[1],1);
                  }
               else if(ZMNc->Powner2 != NULL)
                  {
                  FwriteMagnitudeAndTwoObjects(ZMNc->keyval,ZMNc->Cnumber,ZMNc->magnitude,
                        ZMNc->Sindex1,G_AREAL,ZMNc->Aowner1->Lindex,
                        ZMNc->Aowner1->localID,ZMNc->Aowner1->idn,10.0,-1.0,&ZMNc->x[0],&ZMNc->y[0],&ZMNc->z[0],1,
                        ZMNc->Sindex2,G_POINT,ZMNc->Powner2->Lindex,
                        ZMNc->Powner2->localID,ZMNc->Powner2->idn,10.0,-1.0,&ZMNc->x[1],&ZMNc->y[1],&ZMNc->z[1],1);
                  }
               }
            else if(ZMNc->Powner1 != NULL)
               {
               if(ZMNc->Lowner2 != NULL)
                  {
                  FwriteMagnitudeAndTwoObjects(ZMNc->keyval,ZMNc->Cnumber,ZMNc->magnitude,
                        ZMNc->Sindex1,G_POINT,ZMNc->Powner1->Lindex,
                        ZMNc->Powner1->localID,ZMNc->Powner1->idn,10.0,-1.0,&ZMNc->x[0],&ZMNc->y[0],&ZMNc->z[0],1,
                        ZMNc->Sindex2,G_LINE,ZMNc->Lowner2->Lindex,
                        ZMNc->Lowner2->localID,ZMNc->Lowner2->idn,10.0,-1.0,&ZMNc->x[1],&ZMNc->y[1],&ZMNc->z[1],1);
                  }
               else if(ZMNc->Aowner2 != NULL)
                  {
                  FwriteMagnitudeAndTwoObjects(ZMNc->keyval,ZMNc->Cnumber,ZMNc->magnitude,
                        ZMNc->Sindex1,G_POINT,ZMNc->Powner1->Lindex,
                        ZMNc->Powner1->localID,ZMNc->Powner1->idn,10.0,-1.0,&ZMNc->x[0],&ZMNc->y[0],&ZMNc->z[0],1,
                        ZMNc->Sindex2,G_AREAL,ZMNc->Aowner2->Lindex,
                        ZMNc->Aowner2->localID,ZMNc->Aowner2->idn,10.0,-1.0,&ZMNc->x[1],&ZMNc->y[1],&ZMNc->z[1],1);
                  }
               else if(ZMNc->Powner2 != NULL)
                  {
                  FwriteMagnitudeAndTwoObjects(ZMNc->keyval,ZMNc->Cnumber,ZMNc->magnitude,
                        ZMNc->Sindex1,G_POINT,ZMNc->Powner1->Lindex,
                        ZMNc->Powner1->localID,ZMNc->Powner1->idn,10.0,-1.0,&ZMNc->x[0],&ZMNc->y[0],&ZMNc->z[0],1,
                        ZMNc->Sindex2,G_POINT,ZMNc->Powner2->Lindex,
                        ZMNc->Powner2->localID,ZMNc->Powner2->idn,10.0,-1.0,&ZMNc->x[1],&ZMNc->y[1],&ZMNc->z[1],1);
                  }
               }
            break;
         }
      ZMNp = ZMNc;
      ZMNc = ZMNc->next;
      free(ZMNp);
      }
   return;
}



int LineSegIntLargeAreal(int tgtindex, double x1, double y1, double x2, double y2,
             struct RawAreal * A, int *OnEdge, double *xi, double *yi, int MallocSize)
{
int i,ci1, ci2;
int ii;
double xint, yint;
int answer;
int cindex1, cindex2;
int MYI;
int onedge;
int LastI, UsedTree;
struct RB_Edgelist * LastEdge1;
struct PointAndID *pre_pic;


   answer = 0;
   MYI = MaxYindex + 1;
   onedge = 0;

  if(A->RB_Tree_Edgelist != NULL)
      {
      LastEdge1 = NULL;
      LastI = -1;

      if(tgtindex < 0)
         {
         ci1 = (int) (x1 / RegionSize);
         ci2 = (int) (y1 / RegionSize);

         cindex1 = (ci1 * MYI) + ci2;

         ci1 = (int) (x2 / RegionSize);
         ci2 = (int) (y2 / RegionSize);

         cindex2 = (ci1 * MYI) + ci2;

         if(cindex2 < cindex1)
            {
            ci1 = cindex2;
            cindex2 = cindex1;
            cindex1 = ci1;
            }
         }
      else
         {
         cindex1 = cindex2 = tgtindex;
         }

      LastEdge1 = NULL;
      LastI = -1;
      for(ci1=cindex1; ci1<=cindex2; ci1++)
         {
         i = GetNextArealIndex(A, LastI, 1, &LastEdge1, ci1, &UsedTree);
         LastI = i;

         while(i >= 0)
            {
            if(i == 0)
               ii = A->numverts - 1;
            else
               ii = i - 1;

            if(LineSegmentsIntersect(x1,y1, x2,y2, A->x[ii], A->y[ii], A->x[i], A->y[i], &xint, &yint) > 0)
               {
               answer += 1;
               onedge = EdgesIntersectAtVertex(x1,y1,x2,y2, A->x[ii], A->y[ii], A->x[i], A->y[i]);
               if(MallocSize == 0) /**** then only want to find any one intersection ***/
                  {
                  *OnEdge = onedge;
                  *xi = xint;
                  *yi = yint;
                  break; /**** breaks from while i >= 0 ***/
                  }
               else /*** want to find all intersections with this segment and put them on a list ***/
                  {
                  pic = (struct PointAndID *) (malloc(MallocSize));
                  if(pic == NULL)
                     {
                     printf("available memory has been exhausted during analysis of line segment - large area intersections\n");
                     printf("terminating process\n");
                     exit(-1);
                     }
                  pic->x = xint;
                  pic->y = yint;
                  pic->index1 = ii;
                  pic->index2 = i;
                  pic->ID = onedge;
                  if(LSLICEroot == NULL)
                     {
                     pic->next = NULL;
                     LSLICEroot = pic;
                     }
                  else
                     {
                     if(pic->index2 < LSLICEroot->index2)
                        {
                        pic->next = LSLICEroot;
                        LSLICEroot = pic;
                        }
                     else
                        {
                        pre_pic = pic2 = LSLICEroot;
                        while(pic->index2 >= pic2->index2)
                           {
                           if(pic->index2 == pic2->index2) /*** discard this one ***/
                              {
                              pic2 = NULL;
                              free(pic);
                              break;
                              }
                           if(pic2->next == NULL)
                              {
                              pic2->next = pic;
                              pic->next = NULL;
                              pic2 = NULL;
                              break;
                              }
                           pre_pic = pic2;
                           pic2 = pic2->next;
                           }
                        if(pic2 != NULL)
                           {
                           pre_pic->next = pic;
                           pic->next = pic2;
                           }
                        }
                     }


                  }
               }

            i = GetNextArealIndex(A, LastI, 1, &LastEdge1, ci1, &UsedTree);

            if((LastI >= 0) && (i < 0))
               {
               ii = LastI + 1;
               if(ii == A->numverts)
                  ii = 0;
               if(LineSegmentsIntersect(x1,y1, x2,y2, A->x[ii], A->y[ii], A->x[LastI], A->y[LastI], &xint, &yint) > 0)
                  {
                  answer += 1;
                  onedge = EdgesIntersectAtVertex(x1,y1,x2,y2, A->x[ii], A->y[ii], A->x[LastI], A->y[LastI]);
                  if(MallocSize == 0) /**** then only want to find any one intersection ***/
                     {
                     *OnEdge = onedge;
                     *xi = xint;
                     *yi = yint;
                     break; /**** breaks from while i >= 0 ***/
                     }
                  else /*** want to find all intersections with this segment and put them on a list ***/
                     {
                     pic = (struct PointAndID *) (malloc(MallocSize));
                     if(pic == NULL)
                        {
                        printf("available memory has been exhausted during analysis of line segment - large area intersections\n");
                        printf("terminating process\n");
                        exit(-1);
                        }
                     pic->x = xint;
                     pic->y = yint;
                     pic->index1 = ii;
                     pic->index2 = LastI;
                     pic->ID = onedge;
                     if(LSLICEroot == NULL)
                        {
                        pic->next = NULL;
                        LSLICEroot = pic;
                        }
                     else
                        {
                        if(pic->index2 < LSLICEroot->index2)
                           {
                           pic->next = LSLICEroot;
                           LSLICEroot = pic;
                           }
                        else
                           {
                           pre_pic = pic2 = LSLICEroot;
                           while(pic->index2 >= pic2->index2)
                              {
                              if(pic->index2 == pic2->index2) /** throw it away **/
                                 {
                                 pic2 = NULL;
                                 free(pic);
                                 break;
                                 }
                              if(pic2->next == NULL)
                                 {
                                 pic2->next = pic;
                                 pic->next = NULL;
                                 pic2 = NULL;
                                 break;
                                 }
                              pre_pic = pic2;
                              pic2 = pic2->next;
                              }
                           if(pic2 != NULL)
                              {
                              pre_pic->next = pic;
                              pic->next = pic2;
                              }
                           }
                        }

                     }
                  }
               }

            LastI = i;
            }  /** end while i >= 0 ***/
         if((MallocSize == 0) && (answer > 0))
            break;  /** break from for(ci1 loop ***/
         LastEdge1 = NULL;
         LastI = -1;
         } /*** end for(ci1=cindex1; ci1<=cindex2; ci1++) ***/
      }
   return(answer);
}


void FindMinMax(double v1, double v2, double *maxv, double *minv)
{
   if(v1 < v2)
      {
      *minv = v1;
      *maxv = v2;
      }
   else
      {
      *minv = v2;
      *maxv = v1;
      }
   return;
}





int Line_ILA_WithTolerance(struct RawLinear *inside, struct RawAreal *outside,double tolerance)
{
int answer = 1;
int i,ii,j,jj,k,kk,vertexinside,vertexshared, insidevertex;
double unuseddbl;
int unusedint;
int TheyDoIntersect;
double xi, yi, xi2, yi2;

   vertexinside = vertexshared = insidevertex = 0;
   for(i=0; i<inside->numnodes; i++)
      {
      if(outside->RB_Tree_Edgelist == NULL)
         {
         if((PointWithinToleranceOfVertex(inside->x[i],inside->y[i],outside->x,outside->y,outside->x,
                    outside->numverts,&unuseddbl,tolerance) == 0) &&
            (PointWithinToleranceOfEdge(inside->x[i],inside->y[i],outside->x,outside->y,outside->x,outside->numverts,
                  &unuseddbl,&unusedint, tolerance) == 0) &&
            (PointIsInside(inside->x[i],inside->y[i],outside->x,outside->y,outside->x,outside->numverts,
                     C_AREA,&unuseddbl) > 0))
            {
            ++vertexinside;
            ++insidevertex;
            }
         if(insidevertex <= i)
            {
            answer = 0;
            break;
            }
         }
      else
         {
         if((PointWithinToleranceOfLargeArealVertex(inside->x[i],inside->y[i],
                  outside,&unuseddbl,tolerance) == 0) &&
            (PointWithinToleranceOfLargeArealEdge(inside->x[i],inside->y[i],
                  outside,&unuseddbl, &unusedint, tolerance) == 0) &&
            (PointInsideLargeAreal(inside->x[i],inside->y[i],outside,&ii) > 0))
            {
            ++vertexinside;
            ++insidevertex;
            }
         if(insidevertex <= i)
            {
            answer = 0;
            break;
            }
         }
      }

   if(answer == 1)
      {
      TheyDoIntersect = 0;

      for(i=1; i<inside->numnodes; i++)
         {
         ii = i - 1;
         TheyDoIntersect = 0;
         for(j=0; j<outside->numverts; j++)
            {
            jj = j + 1;
            if(jj == outside->numverts)
               jj = 0;
            kk = PointOnLineSegment(inside->x[ii],inside->y[ii],
                                  outside->x[j],outside->y[j],outside->x[jj],outside->y[jj], tolerance);
            if(kk > 0)
              kk = PointOnLineSegment(inside->x[i],inside->y[i],
                                  outside->x[j],outside->y[j],outside->x[jj],outside->y[jj], tolerance);
            if(kk == 0)
               {
               if(LineSegmentsOverlap(inside->x[i],inside->y[i],inside->x[ii],inside->y[ii],
                                                 outside->x[j],outside->y[j],outside->x[jj],outside->y[jj],
                                                 &xi, &yi, &xi2, &yi2, tolerance) == 0)
                  {
                  TheyDoIntersect = LineSegmentsIntersect(inside->x[i],inside->y[i],inside->x[ii],inside->y[ii],
                                                 outside->x[j],outside->y[j],outside->x[jj],outside->y[jj],&xi,&yi);
                  if(TheyDoIntersect > 0)
                     {
                     for(k=0; k<inside->numnodes; ++k)
                        {
                        unuseddbl = Distance(inside->x[k],inside->y[k],xi,yi);
                        if(unuseddbl <= tolerance)
                           break;
                        }
                     if(k >= inside->numnodes)
                        {

                        answer = 0;
                        break;
                        }
                     }
                  }
               }
            }
         }
      }

   return(answer);
}





void PerformLinearRelatedChecks(char * prompt, int cindex,struct RawLinear *root,double minx,double miny,double maxx,double maxy, double multiplier,
    int NorthCount, int SouthCount, int EastCount, int WestCount,
    struct RawAreal *Aroot, struct RawBridge *Broot, struct RawPoint *Proot, struct ListOfEdges *PEroot, struct ListOfEdges *VPEroot,
    struct RawLinear *NLroot, struct RawAreal *NAroot, struct ThePolys * Polyroot, int SzPC, int SzPW, int IndexLimit)
{
FILE *attrfileptr;
struct RawLinear *rlc, *rln, *rln2, *rln3temp, *rlnsave, *pairedrl1, *rlc_partialcopy;
struct RawAreal *rac, *ran, *ran2, *rah, *raunused;
struct RawBridge *rbc;
struct RawPoint *rpc;
struct ThePolys *tpc, *tpc2;
struct ListOfEdges *ec;
struct ConditionCollection *RB_cond;
struct RB_Edgelist *LastEdge;
struct CodesAndValue *CVrlc, *CVrln;
struct EdgeIntervals *FTc, *FTp, *FTa;
struct RB_Edgelist * LastEdge1, *LastEdge2;
extern int NumberPF;
extern int *PF_Lindex;
extern int *PF_Iindex;
int Vcover[2];
int i,j, k, i2,i3, ii, iii, jj, jj2, kk, kk2, ii2, ii3, ii4, ii5, jj4, jj5, i_partner, j_partner;
int inside1, inside2,closeEdge1, closeEdge2,i_minus,i_plus, FirstJ, FirstK;
int spikewritten, adchwritten,openwritten,closedwritten,gtwritten,ltwritten;
int keepit,bothmatch,onedge,checkit,checkit2, checkit3, thiskey;
int HasSentinel,HasActual,LOCvalue1, LOCvalue2;
int maxXindex, minXindex, maxYindex, minYindex;
int LCIanswer, FoundCondition;
int nodeindex,IsCutout;
int nindex, AreaIndex;
int VerticalsUsed;
int checkinstance;
int NoIntCount, LF_NoIntCount;
int IntersectResult,CTLPmaxindex;
int unusedint, found_one, found_two,isclose, foundobject;
int LastI;
int LastK, LastJ, UsedTree;
int startnodecovered, finalnodecovered;
double x1,y1,x2,y2,x3,y3,x4,y4;
double z1, z2, z3, z4, zdiff;
double xi,yi,zi,t1,t2;
double xi1, yi1, xi2, yi2;
double X[4], Y[4], Z[4];
double Xvert[1000], Yvert[1000];
double Xold, Yold, Yorig;
double ptldist, numconnections;
double ptadist1, ptadist2, ptadist3;
double numlikeconnections;
double ptpdist1, ptldist1;
double ptpdist2;
double slopeangle1, slopeangle2,Tangle;
double basedist, segdist, segdist2;
double LenToCover; 
double CoveredSoFar, Coverdiff;
double MatchLen;
double minxPadded, maxxPadded, minyPadded, maxyPadded;
double minLx,maxLx,minLy,maxLy;
double minvx,maxvx,minvy,maxvy;
double unuseddbl, unuseddbl2, unuseddbl3, unuseddbl4, tolerancepad;
double mindist;
double tempsensitivity,tempsensitivity2;
double LA2, LB2,LC2;
double X0, Y0, F, G;
double SentinelValue;
double temp, temp1, temp2, temp3, temp4;
double fromx, fromy;
double segmentslope;
char Tstring[500];
int vtxcnt;
int uphill;
int part1, part2, part3;
int part1s, part2s, part3s;
int part1a, part1b, part1c, part1d, part1e;
int foundpair;
int inregion1;
int Config1, Strat1, Domain1, Config2, Strat2, Domain2;
int Config3, Strat3, Domain3;
int SzCV = sizeof(struct CodesAndValue);
int SzCVl = sizeof(struct CandVlist);
unsigned char clipflag;
struct collection
   {
   int keyval;
   int Cnumber;
   double x[5];
   double y[5];
   double z[5];
   double magnitude;
   int IDN;
   unsigned int Sindex;
   int vertexindex1, vertexindex2;
   struct RawAreal *aa;
   struct RawBridge *bb;
   struct RawPoint *pp;
   struct ListOfEdges *le;
   struct RawLinear *ll1,*ll2;
   struct ThePolys *poly;
   struct collection * next;
   } *ERroot, *ERc, *ERn, *ERsave;
struct LineElevations
   {
   double dist;
   double x,y,z;
   unsigned int Sindex;
   struct RawLinear *parent;
   struct LineElevations * next;
   } *LEroot, *LEc, *LEp, *LEn, *LEroot2, *LEfree, *LEp2;
struct ZmismatchNodes
   {
   double x[2];
   double y[2];
   double z[2];
   double mismatchdist;
   int keyval, Cnumber;
   int IDN1, IDN2;
   struct RawLinear *owner1, *owner2;
   unsigned int Sindex1, Sindex2;
   struct ZmismatchNodes * next;
   } *ZMNroot, *ZMNc, *ZMNp;
struct IntersectionList
   {
   double x;
   double y;
   double dist;
   struct IntersectionList *next;
   } *IntRoot, *IRn, *IRc, *IRp;

int SzLE = sizeof(struct LineElevations);
int SzC = sizeof(struct collection);
int SzCC = sizeof(struct ConditionCollection);
int SzZMN = sizeof(struct ZmismatchNodes);
int SzPID = sizeof(struct PointAndID);
int SzIL = sizeof(struct IntersectionList);


   ERroot = NULL;
   ZMNroot = NULL;
   rlc = root;

   sprintf(MessageLine,"%scodesfull.bin",indirectory);
   attrfileptr = fopen(MessageLine,"rb");
   if(attrfileptr == NULL)
      {
      printf("could not find required file %s\n",MessageLine);
      exit(-1);
      }

   rlc_partialcopy = NULL;

   rln3temp = (struct RawLinear *) (malloc(sizeof(struct RawLinear)));
   rln3temp->x = (double *) malloc(SzD * 2);
   rln3temp->y = (double *) malloc(SzD * 2);
   rln3temp->z = (double *) malloc(SzD * 2);
   if(rln3temp->z == NULL)
     {
     printf("all available memory has been consumed during preparation for SHARESEG inspection - cannot continue!\n");
     exit(-1);
     }
   rln3temp->numnodes = 2;


   while(rlc != NULL)
     {
     if(rlc->IsMulti > 0)
        {
        unuseddbl = rlc->x[0];
        for(j=1; j<rlc->numnodes; j++)
           {
           if(rlc->x[j] > unuseddbl)
              unuseddbl = rlc->x[j];
           }
        CTLPmaxindex = (int) ((unuseddbl / RegionSize) + 0.5);
        }
     else
        CTLPmaxindex = IndexLimit;


       Config1 = SCCtable[rlc->Sindex].C;
       Strat1 = SCCtable[rlc->Sindex].S;
       Domain1 = SCCtable[rlc->Sindex].D;



       NoIntCount = 0;
       LF_NoIntCount = 0;

       spikewritten = adchwritten = openwritten = closedwritten = gtwritten = ltwritten = 0;

       checkinstance = -1;
       j = CombinedCheckApplies(rlc->idn,checkinstance,ELEVGT,rlc->Lindex,rlc->Sindex,Config1,Strat1,Domain1,&part1a,&part2,&part3);
       j += CombinedCheckApplies(rlc->idn,checkinstance,ELEVLT,rlc->Lindex,rlc->Sindex,Config1,Strat1,Domain1,&part1b,&part2,&part3);
       j += CombinedCheckApplies(rlc->idn,checkinstance,ELEVEQ,rlc->Lindex,rlc->Sindex,Config1,Strat1,Domain1,&part1c,&part2,&part3);
       j += CombinedCheckApplies(rlc->idn,checkinstance,ELEVEQOPEN,rlc->Lindex,rlc->Sindex,Config1,Strat1,Domain1,&part1c,&part2,&part3);
       j += CombinedCheckApplies(rlc->idn,checkinstance,ELEVADJCHANGE,rlc->Lindex,rlc->Sindex,Config1,Strat1,Domain1,&part1d,&part2,&part3);
       j += CombinedCheckApplies(rlc->idn,checkinstance,FEATSPIKE,rlc->Lindex,rlc->Sindex,Config1,Strat1,Domain1,&part1e,&part2,&part3);
       
       if(j > 0)
	 {
	   IgnoreDrawingSettings = 1;
	   part1 = part1a + part1b + part1c + part1d + part1e;

	   if((part1 > 0) && (rlc->numnodes > 1) && (rlc->firstencounter == 1))
	     {
for(checkinstance = 0; checkinstance < TtlActiveChecks; checkinstance++)
                  {
                  if((gtwritten > 0) && (ltwritten > 0))
continue;
for(j=0; j<rlc->numnodes; j++)
                     {
                     if((gtwritten == 0) && (CombinedCheckApplies(rlc->idn,checkinstance,ELEVGT,rlc->Lindex,rlc->Sindex,
                                           Config1,Strat1,Domain1,&part1,&part2,&part3) > 0) && (part1 > 0))
                        {
                        if(SensitivityCheck(GT, ELEVGT, checkinstance, rlc->z[j]) > 0)
                           {
                           //gtwritten = 1;
                           ERc = (struct collection *) (malloc(SzC));
                           if(ERc == NULL)
                              {
                              printf("allocation memory exhausted during linear feature condition analysis\n");
                              printf("processing cannot continue\n");
                              exit(-1);
                              }
                           ERc->magnitude = rlc->z[j];
                           ERc->keyval = ELEVGT;
                           ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                           ERc->Sindex = rlc->Sindex;
                           ERc->ll1 = rlc;
                           ERc->next = NULL;
                           ERc->x[0] = rlc->x[j];
                           ERc->y[0] = rlc->y[j];
                           ERc->z[0] = rlc->z[j];

                           if(ERroot == NULL)
                             {
                             ERroot = ERc;
                             }
                           else
                              {
                              ERn = ERroot;
                              while(ERn != NULL)
                                 {
                                 if((ERn->Cnumber == ERc->Cnumber) && (ERn->keyval == ERc->keyval) &&
                                    (ERn->ll1 == ERc->ll1) && (ERn->x[0] == ERc->x[0]) && (ERc->magnitude == ERn->magnitude) &&
                                    (ERn->y[0] == ERc->y[0]) && (ERn->Sindex == ERc->Sindex))
                                    break;
                                 ERn = ERn->next;
                                 }
                              if(ERn == NULL)
                                 {
                                 ERc->next = ERroot;
                                 ERroot = ERc;
                                 }
                              else
                                 free(ERc);
                              }
                           } /*** end is not a sentinel value ****/
                        } /*** end ELEVGT applies ***/

                    if((ltwritten == 0) && (CombinedCheckApplies(rlc->idn,checkinstance,ELEVLT,rlc->Lindex,rlc->Sindex,
                                           Config1,Strat1,Domain1,&part1,&part2,&part3) > 0) && (part1 > 0))
                        {
                        if(SensitivityCheck(LT, ELEVLT, checkinstance, rlc->z[j]) > 0)
                           {
                           ltwritten = 1;
                           ERc = (struct collection *) (malloc(SzC));
                           if(ERc == NULL)
                              {
                              printf("allocation memory exhausted during linear feature condition analysis\n");
                              printf("processing cannot continue\n");
                              exit(-1);
                              }
                           ERc->magnitude = rlc->z[j];
                           ERc->keyval = ELEVLT;
                           ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                           ERc->Sindex = rlc->Sindex;
                           ERc->ll1 = rlc;
                           ERc->next = NULL;
                           ERc->x[0] = rlc->x[j];
                           ERc->y[0] = rlc->y[j];
                           ERc->z[0] = rlc->z[j];

                           if(ERroot == NULL)
                             {
                             ERroot = ERc;
                             }
                           else
                              {
                              ERn = ERroot;
                              while(ERn != NULL)
                                 {
                                 if((ERn->Cnumber == ERc->Cnumber) && (ERn->keyval == ERc->keyval) &&
                                    (ERn->ll1 == ERc->ll1) && (ERn->x[0] == ERc->x[0]) && (ERc->magnitude == ERn->magnitude) &&
                                    (ERn->y[0] == ERc->y[0]) && (ERn->Sindex == ERc->Sindex))
                                    break;
                                 ERn = ERn->next;
                                 }
                              if(ERn == NULL)
                                 {
                                 ERc->next = ERroot;
                                 ERroot = ERc;
                                 }
                              else
                                 free(ERc);
                              }
                           } /*** end is not a sentinel value ****/
                        } /*** end ELEVLT applies ***/


                     }  /*** end for checkininstance ***/
                  } /*** end for j ****/




	       for(j=1; j<rlc->numnodes; j++)
		 {
                       checkit = checkit2 = 0;

                       z1 = rlc->z[j-1];
                       z2 = rlc->z[j];

                       if(IsSentinelZvalue(z1,UseNUNANPO) == 0) 
                          checkit = 1;
                       if(IsSentinelZvalue(z2,UseNUNANPO) == 0)
                          checkit2 = 1;
                          
                          
		       for(checkinstance = 0; checkinstance < TtlActiveChecks; checkinstance++)
			 {
		       
                     if((closedwritten == 0) &&
                        (CombinedCheckApplies(rlc->idn,checkinstance,ELEVEQ,rlc->Lindex,rlc->Sindex,Config1,Strat1,Domain1,&part1,&part2,&part3) > 0) &&
                                 (part1 > 0))
                        {
                        keepit = 0;
                        if((SensitivityCheck(CLOSEDINT, ELEVEQ, checkinstance, z1) > 0) || (SensitivityCheck(CLOSEDINT, ELEVEQ, checkinstance, z2) > 0))
                           {
                           keepit = 1;
                           }
                        if(keepit > 0)
                           {
                           closedwritten = 1;
                           ERc = (struct collection *) (malloc(SzC));
                           if(ERc == NULL)
                              {
                              printf("allocation memory exhausted during linear feature condition analysis\n");
                              printf("processing cannot continue\n");
                           exit(-1);
                              }
                           if(SensitivityCheck(CLOSEDINT, ELEVEQ, checkinstance, z1) > 0)
                              ERc->magnitude = z1;
                           else
                              ERc->magnitude = z2;
                           ERc->keyval = ELEVEQ;
                           ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                           ERc->Sindex = rlc->Sindex;
                           ERc->ll1 = rlc;
                           ERc->next = NULL;
                           ERc->x[0] = rlc->x[j-1];
                           ERc->y[0] = rlc->y[j-1];
                           ERc->z[0] = z1;
                           ERc->x[1] = rlc->x[j];
                           ERc->y[1] = rlc->y[j];
                           ERc->z[1] = z2;
                           if(ERroot == NULL)
                              {
                              ERroot = ERc;
                              }
                           else
                              {
                              ERn = ERroot;
                              while(ERn != NULL)
                                 {
                                 if(
				    (ERn->Cnumber    == ERc->Cnumber)    &&
				    (ERn->keyval    == ERc->keyval)    && 
				    (ERn->x[1]      == ERc->x[1])      &&
				    (ERn->magnitude == ERc->magnitude) &&
				    (ERn->y[1]      == ERc->y[1])      && 
				    (ERn->ll1    == ERc->ll1))
                                    break;
                                 ERn = ERn->next;
                                 }
                              if(ERn == NULL)
                                 {
                                 ERc->next = ERroot;
                                 ERroot = ERc;
                                 }
                              else
                                 free(ERc);
                              }
                           }
                        }

                     if((openwritten == 0) && 
                        (CombinedCheckApplies(rlc->idn,checkinstance,ELEVEQOPEN,rlc->Lindex,rlc->Sindex,Config1,Strat1,Domain1,&part1,&part2,&part3) > 0) &&
                                 (part1 > 0))
                        {
                        keepit = 0;
                        if((SensitivityCheck(OPENINT, ELEVEQOPEN, checkinstance, z1) > 0) ||(SensitivityCheck(OPENINT, ELEVEQOPEN, checkinstance, z2) > 0))
                           {
                           keepit = 1;
                           }
                        if(keepit > 0)
                           {
                           openwritten = 1;
                           ERc = (struct collection *) (malloc(SzC));
                           if(ERc == NULL)
                              {
                              printf("allocation memory exhausted during linear feature condition analysis\n");
                              printf("processing cannot continue\n");
                           exit(-1);
                              }
                           if(SensitivityCheck(OPENINT, ELEVEQOPEN, checkinstance, z1) > 0)
                              ERc->magnitude = z1;
                           else
                              ERc->magnitude = z2;
                           ERc->keyval = ELEVEQOPEN;
                           ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                           ERc->Sindex = rlc->Sindex;
                           ERc->ll1 = rlc;
                           ERc->next = NULL;
                           ERc->x[0] = rlc->x[j-1];
                           ERc->y[0] = rlc->y[j-1];
                           ERc->z[0] = z1;
                           ERc->x[1] = rlc->x[j];
                           ERc->y[1] = rlc->y[j];
                           ERc->z[1] = z2;
                           if(ERroot == NULL)
                              {
                              ERroot = ERc;
                              }
                           else
                              {
                              ERn = ERroot;
                              while(ERn != NULL)
                                 {
                                 if(
                                    (ERn->Cnumber    == ERc->Cnumber)    &&
                                    (ERn->keyval    == ERc->keyval)    &&
                                    (ERn->x[1]      == ERc->x[1])      &&
                                    (ERn->magnitude == ERc->magnitude) &&
                                    (ERn->y[1]      == ERc->y[1])      &&
                                    (ERn->ll1    == ERc->ll1))
                                    break;
                                 ERn = ERn->next;
                                 }
                              if(ERn == NULL)
                                 {
                                 ERc->next = ERroot;
                                 ERroot = ERc;
                                 }
                              else
                                 free(ERc);
                              }
                           }
                        }



                     if((checkit > 0) && (checkit2 > 0) && (adchwritten >= 0) &&
                                        (CombinedCheckApplies(rlc->idn,checkinstance,ELEVADJCHANGE,rlc->Lindex,rlc->Sindex,Config1,Strat1,Domain1,
                                             &part1,&part2,&part3) > 0) && (part1 > 0))
                        {
                        if(rlc->z[j] > rlc->z[j-1])
                           zdiff = rlc->z[j] - rlc->z[j-1];
                        else
                           zdiff = rlc->z[j-1] - rlc->z[j];
                        if(SensitivityCheck(GTEQ, ELEVADJCHANGE, checkinstance, zdiff) > 0)
                           {
                           adchwritten = 1;
                           ERc = (struct collection *) (malloc(SzC));
                           if(ERc == NULL)
                              {
                              printf("allocation memory exhausted during linear feature condition analysis\n");
                              printf("processing cannot continue\n");
                              exit(-1);
                              }
                           ERc->magnitude = zdiff;
                           ERc->keyval = ELEVADJCHANGE;
                           ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                           ERc->Sindex = rlc->Sindex;
                           ERc->ll1 = rlc;
                           ERc->next = NULL;
                           ERc->x[0] = rlc->x[j-1];
                           ERc->y[0] = rlc->y[j-1];
                           ERc->z[0] = rlc->z[j-1];
                           ERc->x[1] = rlc->x[j];
                           ERc->y[1] = rlc->y[j];
                           ERc->z[1] = rlc->z[j];
                           if(ERroot == NULL)
                              {
                              ERroot = ERc;
                              }
                           else
                              {
                              ERn = ERroot;
                              while(ERn != NULL)
                                 {
                                 if(
				    (ERn->Cnumber    == ERc->Cnumber)    &&
				    (ERn->keyval    == ERc->keyval)    && 
				    (ERn->x[1]      == ERc->x[1])      &&
				    (ERn->magnitude == ERc->magnitude) && 
				    (ERn->y[1]      == ERc->y[1])      && 
				    (ERn->Sindex    == ERc->Sindex)
				    )
                                    break;
                                 ERn = ERn->next;
                                 }
                              if(ERn == NULL)
                                 {
                                 ERc->next = ERroot;
                                 ERroot = ERc;
                                 }
                              else
                                 free(ERc);
                              }
                           }
                        } /** end ELEVADJCHANGE check ***/


                     if((checkit > 0) && (checkit2 > 0) && (spikewritten >= 0) &&
                                      (CombinedCheckApplies(rlc->idn,checkinstance,FEATSPIKE,rlc->Lindex,rlc->Sindex,Config1,Strat1,Domain1,
                                             &part1,&part2,&part3) > 0) && (part1 > 0))
                        {
                        if(rlc->z[j] > rlc->z[j-1])
                           zdiff = rlc->z[j] - rlc->z[j-1];
                        else
                           zdiff = rlc->z[j-1] - rlc->z[j];


                        segdist = Distance(rlc->x[j-1],rlc->y[j-1],rlc->x[j],rlc->y[j]);
                        slopeangle1 = atan(zdiff / segdist);
                        slopeangle1 = RadiansToDegrees(slopeangle1);

                        if((SensitivityCheck(GTEQ, FEATSPIKE, checkinstance, slopeangle1) > 0) &&
                            (segdist  > ActiveChecks[checkinstance].sensitivity2))
                           {
                           spikewritten = 1;
                           ERc = (struct collection *) (malloc(SzC));
                           if(ERc == NULL)
                              {
                              printf("allocation memory exhausted during linear feature condition analysis\n");
                              printf("processing cannot continue\n");
                              exit(-1);
                              }
                           ERc->magnitude = slopeangle1;
                           ERc->keyval = FEATSPIKE;
                           ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                           ERc->Sindex = rlc->Sindex;
                           ERc->ll1 = rlc;
                           ERc->next = NULL;
                           ERc->x[0] = rlc->x[j-1];
                           ERc->y[0] = rlc->y[j-1];
                           ERc->z[0] = rlc->z[j-1];
                           ERc->x[1] = rlc->x[j];
                           ERc->y[1] = rlc->y[j];
                           ERc->z[1] = rlc->z[j];
                           if(ERroot == NULL)
                              {
                              ERroot = ERc;
                              }
                           else
                              {
                              ERn = ERroot;
                              while(ERn != NULL)
                                 {
                                 if(
                                    (ERn->Cnumber    == ERc->Cnumber)    &&
                                    (ERn->keyval    == ERc->keyval)    &&
                                    (ERn->x[1]      == ERc->x[1])      &&
                                    (ERn->magnitude == ERc->magnitude) &&
                                    (ERn->y[1]      == ERc->y[1])      &&
                                    (ERn->Sindex    == ERc->Sindex)
                                    )
                                    break;
                                 ERn = ERn->next;
                                 }
                              if(ERn == NULL)
                                 {
                                 ERc->next = ERroot;
                                 ERroot = ERc;
                                 }
                              else
                                 free(ERc);
                              }
                           }
                        } /*** end FEATSPIKE check for line features ***/

                     } /*** end for(checkinstance = 0; checkinstance < TtlActiveChecks; checkinstance++) ***/

	
		} /** end for j = ****/
            }  /** end if((part1 > 0) && (rlc->numnodes > 1)) ***/
         IgnoreDrawingSettings = 0;
         }  /** end if j > 0 ***/

      for(checkinstance = 0; checkinstance < TtlActiveChecks; checkinstance++)
         {
         if(rlc->firstencounter == 1) 
            {


            if((CombinedCheckApplies(rlc->idn,checkinstance,PORTRAYF,rlc->Lindex,rlc->Sindex,
                                    Config1,Strat1,Domain1,
                                    &part1,&part2,&part3)) && (part1 > 0))
              {
              for(jj = 0; jj < NumberPF; jj++)
                 {
                 if(rlc->Lindex == PF_Lindex[jj])
                    {
                    if((PF_Iindex[jj] < 0) || (rlc->idn == PF_Iindex[jj]))
                       {
                       FwriteObject(PORTRAYF, Make_Correct(PORTRAYF,checkinstance), rlc->Lindex,
                          rlc->Sindex,G_LINE,rlc->localID,rlc->idn,10.0, -1.0,rlc->x,rlc->y,rlc->z,2, 1);
                       break;
                       }
                    }
                 }
              }

            if((CombinedCheckApplies(rlc->idn,checkinstance,TPORTRAYF,rlc->Lindex,rlc->Sindex,
                                    Config1,Strat1,Domain1,
                                    &part1,&part2,&part3)) && (part1 > 0))
              {
              for(jj = 0; jj < NumberPF; jj++)
                 {
                 if(rlc->Lindex == PF_Lindex[jj])
                    {
                    if((PF_Iindex[jj] < 0) || (rlc->idn == PF_Iindex[jj]))
                       {
                       FwriteObject(TPORTRAYF, Make_Correct(TPORTRAYF,checkinstance), rlc->Lindex,
                          rlc->Sindex,G_LINE,rlc->localID,rlc->idn,10.0, -1.0,rlc->x,rlc->y,rlc->z,2, 1);
                       break;
                       }
                    }
                 }
              }

            if((CombinedCheckApplies(rlc->idn,checkinstance,PC_SLOPE,rlc->Lindex,rlc->Sindex,Config1,Strat1,Domain1,
                                              &part1,&part2,&part3) > 0) && (part1 > 0))
               {
               i = 0;
               for(j=1; j<rlc->numnodes; j++)
                  {
                  if((tempis2D(rlc->z[i]) == 0) && (tempis2D(rlc->z[j]) == 0))
                     {
                     jj = IsSentinelZvalue(rlc->z[j],UseNUNANPO);
                     if(jj == 0)
                        jj = IsSentinelZvalue(rlc->z[i],UseNUNANPO);
                     if(jj == 0)
                        {
                        segdist = Distance(rlc->x[i],rlc->y[i],rlc->x[j],rlc->y[j]);
                        if(segdist > ActiveChecks[checkinstance].sensitivity2)
                           {
                           if(rlc->z[i] > rlc->z[j])
                              temp = rlc->z[i] - rlc->z[j];
                           else
                              temp = rlc->z[j] - rlc->z[i];

                           temp1 = temp / segdist;
                           temp1 = temp1 * 100.0;

                           if(SensitivityCheck(GTEQ, PC_SLOPE, checkinstance, temp1) > 0)
                              {
                              FwriteObjectAndMagnitude(PC_SLOPE,Make_Correct(PC_SLOPE,checkinstance),
                                       rlc->idn,
                                       rlc->Sindex,G_LINE,rlc->Lindex,rlc->localID,-1.0,-1.0,temp1,
                                       &rlc->x[i], &rlc->y[i],&rlc->z[i],2, 1);

                              }  /*** end the percent slope is above specified threshold ****/
                           } /** segment length is sufficient ***/
                        } /*** end both vertices i and j have non-sentinel z values assigned ****/
                     } /*** end both vertices i and j have 3D z values assigned ****/
                  i = j;
                  } /** end for j ***/
               } /*** end PC_SLOPE applies to this 'first-time-encountered' line feature ****/


            if((CombinedCheckApplies(rlc->idn,checkinstance,HIGHLIGHTED,rlc->Lindex,rlc->Sindex,Config1,Strat1,Domain1,
                                              &part1,&part2,&part3) > 0) && (part1 > 0))
               {
               k = AssignDrawingColor(rlc->idn, (unsigned char)Domain1, rlc->Lindex);
               if(k == HighLightColor)
                  {
                  ERc = (struct collection *) (malloc(SzC));
                  if(ERc == NULL)
                     {
                     printf("allocation memory exhausted during linear feature condition analysis\n");
                     printf("processing cannot continue\n");
                     exit(-1);
                     }
                  ERc->keyval = HIGHLIGHTED;
                  ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                  ERc->Sindex = rlc->Sindex;
                  ERc->ll1 = rlc;
                  ERc->magnitude = 0;
                  ERc->next = NULL;

                  ERn = ERroot;
                  while(ERn != NULL)
                     {
                       if(
                          (ERn->Cnumber    == ERc->Cnumber)    &&
                          (ERn->keyval    == ERc->keyval)    &&
                          (ERn->ll1 == ERc->ll1)
                          )
                        break;
                     ERn = ERn->next;
                     }
                  if(ERn == NULL)
                     {
                     ERc->next = ERroot;
                     ERroot = ERc;
                     }
                  else
                     free(ERc);
                  }
               }

            if((rlc->numnodes > 2) &&
                  (CombinedCheckApplies(rlc->idn,checkinstance,P_O_LOOP,rlc->Lindex,rlc->Sindex,Config1,Strat1,Domain1,
                                              &part1,&part2,&part3) > 0) && (part1 > 0))
               {
               k = rlc->numnodes - 1;
               while((k > 0) && (rlc->x[k] == rlc->x[k-1]) && (rlc->y[k] == rlc->y[k-1]))
                  --k;
               kk2 = k;

               j = 0;
               while((j < k) && (rlc->x[j] == rlc->x[j+1]) && (rlc->y[j] == rlc->y[j+1]))
                  ++j;
               jj2 = j;

               i = k - j;
               if(i > 2)
                  {
                  for(jj=j+1; jj<=k; jj++)
                     {
                     if((rlc->x[jj] != rlc->x[jj-1]) || (rlc->y[jj] != rlc->y[jj-1]))
                        {
                        for(kk=jj+2; kk<=k; kk++)
                           {
                           if((rlc->x[kk] != rlc->x[kk-1]) || (rlc->y[kk] != rlc->y[kk-1]))
                              {
                              keepit = 0;
                              if(LineSegmentsIntersect(rlc->x[jj],rlc->y[jj],rlc->x[jj-1],rlc->y[jj-1],
                                     rlc->x[kk],rlc->y[kk],rlc->x[kk-1],rlc->y[kk-1],&xi1,&yi1) > 0)
                                 {
                                 keepit = 1;
                                 }
                              else if((jj == jj2) && (ApproxPointToLineDist2D(rlc->x[jj],rlc->y[jj],rlc->x[kk],rlc->y[kk],rlc->x[kk-1],rlc->y[kk-1]) < 0.00001))
                                 {
                                 keepit = 1;
                                 xi1 = rlc->x[jj];
                                 yi1 = rlc->y[jj];
                                 }
                              else if((kk == kk2) && (ApproxPointToLineDist2D(rlc->x[kk],rlc->y[kk],rlc->x[jj],rlc->y[jj],rlc->x[jj-1],rlc->y[jj-1]) < 0.00001))
                                 {
                                 keepit = 1;
                                 xi1 = rlc->x[kk];
                                 yi1 = rlc->y[kk];
                                 }
                              if(keepit > 0)
                                 {
                                 ERc = (struct collection *) (malloc(SzC));
                                 if(ERc == NULL)
                                    {
                                    printf("allocation memory exhausted during area feature condition analysis\n");
                                    printf("processing cannot continue\n");
                                    exit(-1);
                                    }
                                 ERc->x[0] = xi1;
                                 ERc->y[0] = yi1;
                                 ERc->z[0] =  InterpLinearElev(rlc->x[jj],rlc->y[jj],rlc->z[jj],
                                                                      rlc->x[jj-1],rlc->y[jj-1],rlc->z[jj-1],xi1,yi1);
                                 ERc->x[1] = rlc->x[jj-1];
                                 ERc->y[1] = rlc->y[jj-1];
                                 ERc->z[1] = rlc->z[jj-1];
                                 ERc->x[2] = rlc->x[jj];
                                 ERc->y[2] = rlc->y[jj];
                                 ERc->z[2] = rlc->z[jj];
                                 ERc->x[3] = rlc->x[kk-1];
                                 ERc->y[3] = rlc->y[kk-1];
                                 ERc->z[3] = rlc->z[kk-1];
                                 ERc->x[4] = rlc->x[kk];
                                 ERc->y[4] = rlc->y[kk];
                                 ERc->z[4] = rlc->z[kk];
                                 ERc->magnitude = 0;
                                 ERc->keyval = P_O_LOOP;
                                 ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                                 ERc->Sindex = rlc->Sindex;
                                 ERc->ll1 = rlc;
                                 ERc->ll2 = NULL;
                                 ERc->next = NULL;
                                 if(ERroot == NULL)
                                    {
                                    ERroot = ERc;
                                    }
                                 else
                                    {
                                    ERn = ERroot;
                                    while(ERn != NULL)
                                       {
                                       if((ERn->Cnumber == ERc->Cnumber) && (ERn->keyval == ERc->keyval) &&
                                          (ERn->ll1 == ERc->ll1) && (ERn->x[0] == ERc->x[0]) && (ERn->y[0] == ERc->y[0]))
                                          break;
                                       ERn = ERn->next;
                                       }
                                    if(ERn == NULL)
                                       {
                                       ERc->next = ERroot;
                                       ERroot = ERc;
                                       }
                                    else
                                       free(ERc);
                                    }

                                 }
                              }
                           }
                        }
                     }
                  }
               }

            if((CombinedCheckApplies(rlc->idn,checkinstance,MULTIDFEAT,rlc->Lindex,rlc->Sindex,Config1,Strat1,Domain1,
                                              &part1,&part2,&part3) > 0) && (part1 > 0))
               {
               HasSentinel = HasActual = 0;
               i = IsSentinelZvalue(rlc->z[0],UseNUNANPO);
               if(i > 0)
                  HasSentinel = 1;
               else
                  HasActual = 1;

               for(j=1; j<rlc->numnodes; j++)
                  {
                  jj = IsSentinelZvalue(rlc->z[j],UseNUNANPO);
                  if(jj > 0)
                     HasSentinel = 1;
                  else
                     HasActual = 1;

                  if((HasSentinel > 0) && (HasActual > 0))
                     {
                     ERc = (struct collection *) (malloc(SzC));
                     if(ERc == NULL)
                        {
                        printf("allocation memory exhausted during area feature condition analysis\n");
                        printf("processing cannot continue\n");
                        exit(-1);
                        }
                     ERc->x[0] = rlc->x[j-1];
                     ERc->y[0] = rlc->y[j-1];
                     ERc->z[0] = rlc->z[j-1];
                     ERc->x[1] = rlc->x[j];
                     ERc->y[1] = rlc->y[j];
                     ERc->z[1] = rlc->z[j];
                     ERc->magnitude = 0;
                     ERc->keyval = MULTIDFEAT;
                     ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                     ERc->Sindex = rlc->Sindex;
                     ERc->ll1 = rlc;
                     ERc->ll2 = NULL;
                     ERc->next = NULL;
                     if(ERroot == NULL)
                        {
                        ERroot = ERc;
                        }
                     else
                        {
                        ERn = ERroot;
                        while(ERn != NULL)
                           {
                           if(
                              (ERn->Cnumber    == ERc->Cnumber)    &&
                              (ERn->keyval    == ERc->keyval)    &&
                              (ERn->ll1 == ERc->ll1)
                              )
                              break;
                           ERn = ERn->next;
                           }
                        if(ERn == NULL)
                           {
                           ERc->next = ERroot;
                           ERroot = ERc;
                           }
                        else
                           free(ERc);
                        }
                     break;
                     }
                  }
               }



            if((CombinedCheckApplies(rlc->idn,checkinstance,MULTISENTINEL,rlc->Lindex,rlc->Sindex,Config1,Strat1,Domain1,
                                              &part1,&part2,&part3) > 0) && (part1 > 0))
               {
               HasSentinel = 0;
               for(j=0; j<rlc->numnodes; j++)
                  {
                  jj = IsSentinelZvalue(rlc->z[j],UseNUNANPO);
                  if(jj > 0)
                     {
                     if(HasSentinel> 0)
                        {
                        if(rlc->z[j] != SentinelValue)
                           {
                           ERc = (struct collection *) (malloc(SzC));
                           if(ERc == NULL)
                              {
                              printf("allocation memory exhausted during area feature condition analysis\n");
                              printf("processing cannot continue\n");
                              exit(-1);
                              }
                           ERc->x[0] = rlc->x[j-1];
                           ERc->y[0] = rlc->y[j-1];
                           ERc->z[0] = rlc->z[j-1];
                           ERc->x[1] = rlc->x[j];
                           ERc->y[1] = rlc->y[j];
                           ERc->z[1] = rlc->z[j];
                           ERc->magnitude = 0;
                           ERc->keyval = MULTISENTINEL;
                           ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                           ERc->Sindex = rlc->Sindex;
                           ERc->ll1 = rlc;
                           ERc->ll2 = NULL;
                           ERc->next = NULL;
                           if(ERroot == NULL)
                              {
                              ERroot = ERc;
                              }
                           else
                              {
                              ERn = ERroot;
                              while(ERn != NULL)
                                 {
                                 if(
                                    (ERn->Cnumber    == ERc->Cnumber)    &&
                                    (ERn->keyval    == ERc->keyval)    &&
                                    (ERn->ll1 == ERc->ll1)
                                    )
                                    break;
                                 ERn = ERn->next;
                                 }
                              if(ERn == NULL)
                                 {
                                 ERc->next = ERroot;
                                 ERroot = ERc;
                                 }
                              else
                                 free(ERc);
                              }
                           break;
                           }
                        }
                     else
                        {
                        HasSentinel = 1;
                        SentinelValue = rlc->z[j];
                        }
                     }
                  }
               }




            if((rlc->numnodes > 2) &&
              (CombinedCheckApplies(rlc->idn,checkinstance,SLOPEDIRCH,rlc->Lindex,rlc->Sindex,Config1,Strat1,Domain1,&part1,&part2,&part3) > 0))
               {
               IgnoreDrawingSettings = 1; /** do this to force elevation find, whether polys being drawn or not **/
               if(part1 > 0)
                  {
                  ii = j = rlc->numnodes;
                  for(i=0; i< rlc->numnodes; i++)
                     {
                     if(IsSentinelZvalue(rlc->z[i],UseNUNANPO) == 0)
                        {
                        ii = i;
                        break;
                        }
                     }
                  for(i=ii+1; i<rlc->numnodes; i++)
                     {
                     if(IsSentinelZvalue(rlc->z[i],UseNUNANPO) == 0)
                        {
                        j = i;
                        break;
                        }
                     }
                  for(i=j+1; i < rlc->numnodes; i++)
                     {
                     kk = 0;
                     ii3 = 0;
                     if(IsSentinelZvalue(rlc->z[i],UseNUNANPO) == 0)
                        {
                        ii3 = 1;
                        kk = 0;
                        if((rlc->z[ii] > rlc->z[j]) && (rlc->z[i] > rlc->z[j]))
                           kk = 1; /** may have a condition ***/
                        else if((rlc->z[ii] < rlc->z[j]) && (rlc->z[i] < rlc->z[j]))
                           kk = 1; /** may have a condition ***/
                        }
                     if(kk > 0)
                        {
                        basedist = Distance(rlc->x[ii],rlc->y[ii],rlc->x[j],rlc->y[j]);
                        segdist = Distance(rlc->x[i],rlc->y[i],rlc->x[j],rlc->y[j]);
                        z4 = rlc->z[j] - rlc->z[ii];
                        z3 = rlc->z[i] - rlc->z[j];
   
                        slopeangle1 = atan(z3 / segdist);
                        slopeangle2 = atan(z4 / basedist);
   
                        if(slopeangle2 > slopeangle1)
                           temp = slopeangle2 - slopeangle1;
                        else
                           temp = slopeangle1 - slopeangle2;
   
                        temp = RadiansToDegrees(temp);
   
                        if(SensitivityCheck(GTEQ, SLOPEDIRCH, checkinstance, temp) > 0) 
                           {
                           ERc = (struct collection *) (malloc(SzC));
                           if(ERc == NULL)
                              {
                              printf("allocation memory exhausted during linear feature condition analysis\n");
                              printf("processing cannot continue\n");
                              exit(-1);
                              }
                           ERc->x[0] = rlc->x[ii];
                           ERc->y[0] = rlc->y[ii];
                           ERc->z[0] = rlc->z[ii];
                           ERc->magnitude = temp;
                           ERc->keyval = SLOPEDIRCH;
                           ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                           ERc->ll1 = rlc;
                           ERc->Sindex = rlc->Sindex;
                           ERc->ll2 = NULL;
                           ERc->next = NULL;
                           if(ERroot == NULL)
                              {
                              ERc->x[1] = rlc->x[j];
                              ERc->y[1] = rlc->y[j];
                              ERc->z[1] = rlc->z[j];
                              ERc->x[2] = rlc->x[i];
                              ERc->y[2] = rlc->y[i];
                              ERc->z[2] = rlc->z[i];
                              ERroot = ERc;
                              }
                           else
                              {
                              ERn = ERroot;
                              while(ERn != NULL)
                                 {
                                 if((ERn->Cnumber == ERc->Cnumber) && (ERn->keyval == ERc->keyval) &&
                                     (ERn->magnitude == ERc->magnitude) && (ERn->ll1 == ERc->ll1))
                                    break;
/*****/
                                 ERn = ERn->next;
                                 }
                              if(ERn == NULL)
                                 {
                                 ERc->x[1] = rlc->x[j];
                                 ERc->y[1] = rlc->y[j];
                                 ERc->z[1] = rlc->z[j];
                                 ERc->x[2] = rlc->x[i];
                                 ERc->y[2] = rlc->y[i];
                                 ERc->z[2] = rlc->z[i];
                                 ERc->next = ERroot;
                                 ERroot = ERc;
                                 }
                              else
                                 free(ERc);
                              }
                           }
                        }
                     if(ii3 > 0)
                        {
                        ii = j;
                        j = i;
                        }
                     }
                  }
               }  /*** end SLOPEDIRCH procedure for line features ***/



            if((CombinedCheckApplies(rlc->idn,checkinstance,ATTR_PAIR,rlc->Lindex,rlc->Sindex,Config1,Strat1,Domain1,
                                             &part1,&part2,&part3) > 0) && (part1 > 0))
               {
               if(CrsWlk[rlc->Lindex].AttrErr >= 0)
                  {
                  if(AttrErr[CrsWlk[rlc->Lindex].AttrErr].description[0] == '0') /*** then this is a ATTR_PAIR error **/
                     {
                     FwriteObjectAndMessage(ATTR_PAIR,Make_Correct(ATTR_PAIR,checkinstance),
                          rlc->idn, G_LINE,rlc->Lindex,rlc->localID, rlc->Sindex,-1.0,-1.0,
                          rlc->x, rlc->y, rlc->z,2,&AttrErr[CrsWlk[rlc->Lindex].AttrErr].description[1]);
                     }
                  if(CrsWlk[rlc->Lindex].MAE != NULL)
                     {
                     MAEc = CrsWlk[rlc->Lindex].MAE;
                     while(MAEc != NULL)
                        {
                        if(AttrErr[MAEc->index].description[0] == '0') /*** then this is a ATTR_PAIR error **/
                           {
                           FwriteObjectAndMessage(ATTR_PAIR,Make_Correct(ATTR_PAIR,checkinstance),
                                rlc->idn, G_LINE,rlc->Lindex,rlc->localID, rlc->Sindex,-1.0,-1.0,
                                rlc->x, rlc->y, rlc->z,2,&AttrErr[MAEc->index].description[1]);
                           }
                        MAEc = MAEc->next;
                        }
                     }
                  }
               }

            if((CombinedCheckApplies(rlc->idn,checkinstance,RPTD_ATTR,rlc->Lindex,rlc->Sindex,Config1,Strat1,Domain1,
                                             &part1,&part2,&part3) > 0) && (part1 > 0))
               {
               if(CrsWlk[rlc->Lindex].AttrErr >= 0)
                  {
                  checkit = 0;
                  if(ActiveChecks[checkinstance].clonenumber >= 0)
                     {
                     if(CloneErrorLookup[ActiveChecks[checkinstance].clonenumber].Annotation != NULL)
                        {
                        strcpy(Tstring,CloneErrorLookup[ActiveChecks[checkinstance].clonenumber].Annotation);
                        checkit = 1;
                        }
                     }
                  else
                     {
                     if(ErrorLookup[ActiveChecks[checkinstance].number].Annotation != NULL)
                        {
                        strcpy(Tstring,ErrorLookup[ActiveChecks[checkinstance].number].Annotation);
                        checkit = 1;
                        }
                     }
                  if(checkit > 0)
                     {
                     if(strstr(AttrErr[CrsWlk[rlc->Lindex].AttrErr].description, Tstring) != NULL)
                     /****if(AttrErr[CrsWlk[rlc->Lindex].AttrErr].description[0] == '1') *** then this is a RPTD_ATTR error **/
                        {
                        FwriteObjectAndMessage(RPTD_ATTR,Make_Correct(RPTD_ATTR,checkinstance),
                             rlc->idn, G_LINE,rlc->Lindex,rlc->localID, rlc->Sindex,-1.0,-1.0,
                             rlc->x, rlc->y, rlc->z,2,&AttrErr[CrsWlk[rlc->Lindex].AttrErr].description[1]);
                        }
                     if(CrsWlk[rlc->Lindex].MAE != NULL)
                        {
                        MAEc = CrsWlk[rlc->Lindex].MAE;
                        while(MAEc != NULL)
                           {
                           if(strstr(AttrErr[MAEc->index].description, Tstring) != NULL)
                           /**if(AttrErr[MAEc->index].description[0] == '1') *** then this is a RPTD_ATTR error **/
                              {
                              FwriteObjectAndMessage(RPTD_ATTR,Make_Correct(RPTD_ATTR,checkinstance),
                                   rlc->idn, G_LINE,rlc->Lindex,rlc->localID, rlc->Sindex,-1.0,-1.0,
                                   rlc->x, rlc->y, rlc->z,2,&AttrErr[MAEc->index].description[1]);
                              }
                           MAEc = MAEc->next;
                           }
                        }
                     }
                  }
               }


            if((CombinedCheckApplies(rlc->idn,checkinstance,ATTR_UNEXP,rlc->Lindex,rlc->Sindex,Config1,Strat1,Domain1,
                                             &part1,&part2,&part3) > 0) && (part1 > 0))
               {
               if(CrsWlk[rlc->Lindex].AttrErr >= 0)
                  {
                  if(AttrErr[CrsWlk[rlc->Lindex].AttrErr].description[0] == '1') /*** then this is a ATTR_UNEXP error **/
                     {
                     FwriteObjectAndMessage(ATTR_UNEXP,Make_Correct(ATTR_UNEXP,checkinstance),
                          rlc->idn, G_LINE,rlc->Lindex,rlc->localID, rlc->Sindex,-1.0,-1.0,
                          rlc->x, rlc->y, rlc->z,2,&AttrErr[CrsWlk[rlc->Lindex].AttrErr].description[1]);
                     }
                  if(CrsWlk[rlc->Lindex].MAE != NULL)
                     {
                     MAEc = CrsWlk[rlc->Lindex].MAE;
                     while(MAEc != NULL)
                        {
                        if(AttrErr[MAEc->index].description[0] == '1') /*** then this is a ATTR_UNEXP error **/
                           {
                           FwriteObjectAndMessage(ATTR_UNEXP,Make_Correct(ATTR_UNEXP,checkinstance),
                                rlc->idn, G_LINE,rlc->Lindex,rlc->localID, rlc->Sindex,-1.0,-1.0,
                                rlc->x, rlc->y, rlc->z,2,&AttrErr[MAEc->index].description[1]);
                           }
                        MAEc = MAEc->next;
                        }
                     }
                  }
               }


            if((CombinedCheckApplies(rlc->idn,checkinstance,ATTR_VVT,rlc->Lindex,rlc->Sindex,Config1,Strat1,Domain1,
                                             &part1,&part2,&part3) > 0) && (part1 > 0))
               {
               if(CrsWlk[rlc->Lindex].AttrErr >= 0)
                  {
                  if(AttrErr[CrsWlk[rlc->Lindex].AttrErr].description[0] == 'y') /*** then this is a ATTR_VVT error **/
                     {
                     FwriteObjectAndMessage(ATTR_VVT,Make_Correct(ATTR_VVT,checkinstance),
                          rlc->idn, G_LINE,rlc->Lindex,rlc->localID, rlc->Sindex,-1.0,-1.0,
                          rlc->x, rlc->y, rlc->z,2,&AttrErr[CrsWlk[rlc->Lindex].AttrErr].description[1]);
                     }
                  if(CrsWlk[rlc->Lindex].MAE != NULL)
                     {
                     MAEc = CrsWlk[rlc->Lindex].MAE;
                     while(MAEc != NULL)
                        {
                        if(AttrErr[MAEc->index].description[0] == 'y') /*** then this is a ATTR_VVT error **/
                           {
                           FwriteObjectAndMessage(ATTR_VVT,Make_Correct(ATTR_VVT,checkinstance),
                                rlc->idn, G_LINE,rlc->Lindex,rlc->localID, rlc->Sindex,-1.0,-1.0,
                                rlc->x, rlc->y, rlc->z,2,&AttrErr[MAEc->index].description[1]);
                           }
                        MAEc = MAEc->next;
                        }
                     }
                  if(AttrErr[CrsWlk[rlc->Lindex].AttrErr].description[0] == 'x') /*** then this is a ATTR_VVT error **/
                     {
                     FwriteObjectAndMessage(ATTR_VVT,Make_Correct(ATTR_VVT,checkinstance),
                          rlc->idn, G_LINE,rlc->Lindex,rlc->localID, rlc->Sindex,-1.0,-1.0,
                          rlc->x, rlc->y, rlc->z,2,&AttrErr[CrsWlk[rlc->Lindex].AttrErr].description[1]);
                     }
                  if(CrsWlk[rlc->Lindex].MAE != NULL)
                     {
                     MAEc = CrsWlk[rlc->Lindex].MAE;
                     while(MAEc != NULL)
                        {
                        if(AttrErr[MAEc->index].description[0] == 'x') /*** then this is a ATTR_VVT error **/
                           {
                           FwriteObjectAndMessage(ATTR_VVT,Make_Correct(ATTR_VVT,checkinstance),
                                rlc->idn, G_LINE,rlc->Lindex,rlc->localID, rlc->Sindex,-1.0,-1.0,
                                rlc->x, rlc->y, rlc->z,2,&AttrErr[MAEc->index].description[1]);
                           }
                        MAEc = MAEc->next;
                        }
                     }
                  }
               }

            if((CombinedCheckApplies(rlc->idn,checkinstance,ATTR_RNULL,rlc->Lindex,rlc->Sindex,Config1,Strat1,Domain1,
                                             &part1,&part2,&part3) > 0) && (part1 > 0))
               {
               if(CrsWlk[rlc->Lindex].AttrErr >= 0)
                  {
                  if(AttrErr[CrsWlk[rlc->Lindex].AttrErr].description[0] == '2') /*** then this is a ATTR_RNULL error **/
                     {
                     FwriteObjectAndMessage(ATTR_RNULL,Make_Correct(ATTR_RNULL,checkinstance),
                          rlc->idn, G_LINE,rlc->Lindex,rlc->localID, rlc->Sindex,-1.0,-1.0,
                          rlc->x, rlc->y, rlc->z,2,&AttrErr[CrsWlk[rlc->Lindex].AttrErr].description[1]);
                     }
                  if(CrsWlk[rlc->Lindex].MAE != NULL)
                     {
                     MAEc = CrsWlk[rlc->Lindex].MAE;
                     while(MAEc != NULL)
                        {
                        if(AttrErr[MAEc->index].description[0] == '2') /*** then this is a ATTR_RNULL error **/
                           {
                           FwriteObjectAndMessage(ATTR_RNULL,Make_Correct(ATTR_RNULL,checkinstance),
                                rlc->idn, G_LINE,rlc->Lindex,rlc->localID, rlc->Sindex,-1.0,-1.0,
                                rlc->x, rlc->y, rlc->z,2,&AttrErr[MAEc->index].description[1]);
                           }
                        MAEc = MAEc->next;
                        }
                     }
                  }
               }



            if((CombinedCheckApplies(rlc->idn,checkinstance,ATTR_MISSING,rlc->Lindex,rlc->Sindex,Config1,Strat1,Domain1,
                                             &part1,&part2,&part3) > 0) && (part1 > 0))
               {
               if(CrsWlk[rlc->Lindex].AttrErr >= 0)
                  {
                  if(AttrErr[CrsWlk[rlc->Lindex].AttrErr].description[0] == 'z') /*** then this is a ATTR_MISSING error **/
                     {
                     FwriteObjectAndMessage(ATTR_MISSING,Make_Correct(ATTR_MISSING,checkinstance),
                          rlc->idn, G_LINE,rlc->Lindex,rlc->localID, rlc->Sindex,-1.0,-1.0,
                          rlc->x, rlc->y, rlc->z,2,&AttrErr[CrsWlk[rlc->Lindex].AttrErr].description[1]);
                     }
                  if(CrsWlk[rlc->Lindex].MAE != NULL)
                     {
                     MAEc = CrsWlk[rlc->Lindex].MAE;
                     while(MAEc != NULL)
                        {
                        if(AttrErr[MAEc->index].description[0] == 'z') /*** then this is a ATTR_MISSING error **/
                           {
                           FwriteObjectAndMessage(ATTR_MISSING,Make_Correct(ATTR_MISSING,checkinstance),
                                rlc->idn, G_LINE,rlc->Lindex,rlc->localID, rlc->Sindex,-1.0,-1.0,
                                rlc->x, rlc->y, rlc->z,2,&AttrErr[MAEc->index].description[1]);
                           }
                        MAEc = MAEc->next;
                        }
                     }
                  }
               }

            if((CombinedCheckApplies(rlc->idn,checkinstance,ATTR_DT,rlc->Lindex,rlc->Sindex,Config1,Strat1,Domain1,
                                             &part1,&part2,&part3) > 0) && (part1 > 0))
               {
               if(CrsWlk[rlc->Lindex].AttrErr >= 0)
                  {
                  if(AttrErr[CrsWlk[rlc->Lindex].AttrErr].description[0] == '2') /*** then this is a ATTR_DT error **/
                     {
                     FwriteObjectAndMessage(ATTR_DT,Make_Correct(ATTR_DT,checkinstance),
                          rlc->idn, G_LINE,rlc->Lindex,rlc->localID, rlc->Sindex,-1.0,-1.0,
                          rlc->x, rlc->y, rlc->z,2,&AttrErr[CrsWlk[rlc->Lindex].AttrErr].description[1]);
                     }
                  if(CrsWlk[rlc->Lindex].MAE != NULL)
                     {
                     MAEc = CrsWlk[rlc->Lindex].MAE;
                     while(MAEc != NULL)
                        {
                        if(AttrErr[MAEc->index].description[0] == '2') /*** then this is a ATTR_DT error **/
                           {
                           FwriteObjectAndMessage(ATTR_DT,Make_Correct(ATTR_DT,checkinstance),
                                rlc->idn, G_LINE,rlc->Lindex,rlc->localID, rlc->Sindex,-1.0,-1.0,
                                rlc->x, rlc->y, rlc->z,2,&AttrErr[MAEc->index].description[1]);
                           }
                        MAEc = MAEc->next;
                        }
                     }
                  }
               }
            
            if((CombinedCheckApplies(rlc->idn,checkinstance,ATTR_RNG,rlc->Lindex,rlc->Sindex,Config1,Strat1,Domain1,
                                             &part1,&part2,&part3) > 0) && (part1 > 0))
               {
               if(CrsWlk[rlc->Lindex].AttrErr >= 0)
                  {
                  if(AttrErr[CrsWlk[rlc->Lindex].AttrErr].description[0] == '3') /*** then this is a ATTR_RNG error **/
                     {
                     FwriteObjectAndMessage(ATTR_RNG,Make_Correct(ATTR_RNG,checkinstance),
                          rlc->idn, G_LINE,rlc->Lindex,rlc->localID, rlc->Sindex,-1.0,-1.0,
                          rlc->x, rlc->y, rlc->z,2,&AttrErr[CrsWlk[rlc->Lindex].AttrErr].description[1]);
                     }
                  if(CrsWlk[rlc->Lindex].MAE != NULL)
                     {
                     MAEc = CrsWlk[rlc->Lindex].MAE;
                     while(MAEc != NULL)
                        {
                        if(AttrErr[MAEc->index].description[0] == '3') /*** then this is a ATTR_RNG error **/
                           {
                           FwriteObjectAndMessage(ATTR_RNG,Make_Correct(ATTR_RNG,checkinstance),
                                rlc->idn, G_LINE,rlc->Lindex,rlc->localID, rlc->Sindex,-1.0,-1.0,
                                rlc->x, rlc->y, rlc->z,2,&AttrErr[MAEc->index].description[1]);
                           }
                        MAEc = MAEc->next;
                        }
                     }
                  }
               }

            if((CombinedCheckApplies(rlc->idn,checkinstance,ATTR_PICK,rlc->Lindex,rlc->Sindex,Config1,Strat1,Domain1,
                                             &part1,&part2,&part3) > 0) && (part1 > 0))
               {
               if(CrsWlk[rlc->Lindex].AttrErr >= 0)
                  {
                  if(AttrErr[CrsWlk[rlc->Lindex].AttrErr].description[0] == '4') /*** then this is a ATTR_PICK error **/
                     {
                     FwriteObjectAndMessage(ATTR_PICK,Make_Correct(ATTR_PICK,checkinstance),
                          rlc->idn, G_LINE,rlc->Lindex,rlc->localID, rlc->Sindex,-1.0,-1.0,
                          rlc->x, rlc->y, rlc->z,2,&AttrErr[CrsWlk[rlc->Lindex].AttrErr].description[1]);
                     }
                  if(CrsWlk[rlc->Lindex].MAE != NULL)
                     {
                     MAEc = CrsWlk[rlc->Lindex].MAE;
                     while(MAEc != NULL)
                        {
                        if(AttrErr[MAEc->index].description[0] == '4') /*** then this is a ATTR_PICK error **/
                           {
                           FwriteObjectAndMessage(ATTR_PICK,Make_Correct(ATTR_PICK,checkinstance),
                                rlc->idn, G_LINE,rlc->Lindex,rlc->localID, rlc->Sindex,-1.0,-1.0,
                                rlc->x, rlc->y, rlc->z,2,&AttrErr[MAEc->index].description[1]);
                           }
                        MAEc = MAEc->next;
                        }
                     }
                  }
               }

            if((CombinedCheckApplies(rlc->idn,checkinstance,ATTR_META,rlc->Lindex,rlc->Sindex,Config1,Strat1,Domain1,
                                             &part1,&part2,&part3) > 0) && (part1 > 0))
               {
               if(CrsWlk[rlc->Lindex].AttrErr >= 0)
                  {
                  if(AttrErr[CrsWlk[rlc->Lindex].AttrErr].description[0] == ' ') /*** then this is a ATTR_META error **/
                     {
                     FwriteObjectAndMessage(ATTR_META,Make_Correct(ATTR_META,checkinstance),
                          rlc->idn, G_LINE,rlc->Lindex,rlc->localID, rlc->Sindex,-1.0,-1.0,
                          rlc->x, rlc->y, rlc->z,2,&AttrErr[CrsWlk[rlc->Lindex].AttrErr].description[1]);
                     }
                  if(CrsWlk[rlc->Lindex].MAE != NULL)
                     {
                     MAEc = CrsWlk[rlc->Lindex].MAE;
                     while(MAEc != NULL)
                        {
                        if(AttrErr[MAEc->index].description[0] == ' ') /*** then this is a ATTR_META error **/
                           {
                           FwriteObjectAndMessage(ATTR_META,Make_Correct(ATTR_META,checkinstance),
                                rlc->idn, G_LINE,rlc->Lindex,rlc->localID, rlc->Sindex,-1.0,-1.0,
                                rlc->x, rlc->y, rlc->z,2,&AttrErr[MAEc->index].description[1]);
                           }
                        MAEc = MAEc->next;
                        }
                     }
                  }
               }
            } /*** end if any attr errors should be written out for rlc **/

         if((rlc->firstencounter == 1) && 
          (CombinedCheckApplies(rlc->idn,checkinstance,VVTERR1WAY,rlc->Lindex,rlc->Sindex,Config1,Strat1,Domain1,&part1,&part2,&part3) > 0) &&
               (part1 > 0))
            {
            ERc = (struct collection *) (malloc(SzC));
            if(ERc == NULL)
               {
               printf("allocation memory exhausted during linear feature condition analysis\n");
               printf("processing cannot continue\n");
               exit(-1);
               }
            ERc->keyval = VVTERR1WAY;
            ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
            ERc->Sindex = rlc->Sindex;
            ERc->ll1 = rlc;
            ERc->next = NULL;

            ERn = ERroot;
            while(ERn != NULL)
               {
                 if((ERn->Cnumber == ERc->Cnumber) && (ERn->keyval == ERc->keyval) && (ERn->ll1 == ERc->ll1))
                  break;
               ERn = ERn->next;
               }
            if(ERn == NULL)
               {
               ERc->next = ERroot;
               ERroot = ERc;
               }
            else
               free(ERc);
            } /*** end VVTERR1WAY check ***/

         
         if((rlc->firstencounter == 1) &&
          (CombinedCheckApplies(rlc->idn,checkinstance,VVTERR2WAY,rlc->Lindex,rlc->Sindex,Config1,Strat1,Domain1,&part1,&part2,&part3) > 0) &&
               (part1 > 0) && (part2 > 0))
            {
            ERc = (struct collection *) (malloc(SzC));
            if(ERc == NULL) 
               {
               printf("allocation memory exhausted during linear feature condition analysis\n");
               printf("processing cannot continue\n");
               exit(-1);
               }
            ERc->keyval = VVTERR2WAY;
            ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
            ERc->Sindex = rlc->Sindex;
            ERc->ll1 = rlc;
            ERc->next = NULL;

            ERn = ERroot;
            while(ERn != NULL) 
               {
                 if((ERn->Cnumber == ERc->Cnumber) && (ERn->keyval == ERc->keyval) && (ERn->ll1 == ERc->ll1))
                  break;
               ERn = ERn->next;
               }
            if(ERn == NULL) 
               {
               ERc->next = ERroot;
               ERroot = ERc;
               }
            else
               free(ERc);
            } /*** end VVTERR2WAY check ***/


         if((rlc->firstencounter == 1) &&
          (CombinedCheckApplies(rlc->idn,checkinstance,VVTERR3WAY,rlc->Lindex,rlc->Sindex,Config1,Strat1,Domain1,&part1,&part2,&part3) > 0) &&
               (part1 > 0) && (part2 > 0) && (part3 > 0))
            {
            ERc = (struct collection *) (malloc(SzC));
            if(ERc == NULL)
               {
               printf("allocation memory exhausted during linear feature condition analysis\n");
               printf("processing cannot continue\n");
               exit(-1);
               }
            ERc->keyval = VVTERR3WAY;
            ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
            ERc->Sindex = rlc->Sindex;
            ERc->ll1 = rlc;
            ERc->next = NULL;
   
            ERn = ERroot;
            while(ERn != NULL)
               {
                 if((ERn->Cnumber == ERc->Cnumber) && (ERn->keyval == ERc->keyval) && (ERn->ll1 == ERc->ll1))
                  break;
               ERn = ERn->next;
               }
            if(ERn == NULL)
               {
               ERc->next = ERroot;
               ERroot = ERc;
               }
            else
               free(ERc);
            } /*** end VVTERR3WAY check ***/



         if((NGA_TYPE > 0) && 
               (CombinedCheckApplies(rlc->idn,checkinstance,KICKBACK,rlc->Lindex,rlc->Sindex,Config1,Strat1,Domain1,&part1,&part2,&part3) > 0) &&
               (part1 > 0))
            {
            if((rlc->firstencounter == 1) && (rlc->numnodes > 2))
               {
               for(j=2; j<=rlc->numnodes; j++)
                  {
                  k = j - 2;
                  i = j - 1;
                  if(j < rlc->numnodes)
                     {
                     temp = TurnAngle(rlc->x[k],rlc->y[k],rlc->x[i],rlc->y[i],rlc->x[j],rlc->y[j]);

                     if(temp >= PI)
                        {
                        ERc = (struct collection *) (malloc(SzC));
                        if(ERc == NULL)
                           {
                           printf("allocation memory exhausted during linear feature condition analysis\n");
                           printf("processing cannot continue\n");
                           exit(-1);
                           } 
                        ERc->x[1] = rlc->x[i];
                        ERc->y[1] = rlc->y[i];
                        ERc->magnitude = temp;
                        ERc->keyval = KICKBACK;
                        ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                        ERc->Sindex = rlc->Sindex;
                        ERc->ll1 = rlc;
                        ERc->next = NULL;

                        ERn = ERroot;
                        while(ERn != NULL)
                           {
                             if(
                                (ERn->Cnumber    == ERc->Cnumber)    &&
                                (ERn->keyval    == ERc->keyval)    &&
                                (ERn->x[1]      == ERc->x[1])      &&
                                (ERn->y[1]      == ERc->y[1])      &&
                                (ERn->Sindex    == ERc->Sindex)
                                )
                              break;
                           ERn = ERn->next;
                           }
                        if(ERn == NULL)
                           {
                           ERc->z[1] = rlc->z[i];
                           ERc->x[0] = rlc->x[k];
                           ERc->y[0] = rlc->y[k];
                           ERc->z[0] = rlc->z[k];
                           ERc->x[2] = rlc->x[j];
                           ERc->y[2] = rlc->y[j];
                           ERc->z[2] = rlc->z[j];
                           ERc->next = ERroot;
                           ERroot = ERc;
                           }
                        else
                           free(ERc);
                        } /*** end if sensitivity check ***/
                     }
                  }
               }
            }



         if(NGA_TYPE > 0)
            {
            if(CombinedCheckApplies(rlc->idn,checkinstance,SEGLEN,rlc->Lindex,rlc->Sindex,
                                     Config1,Strat1,Domain1, &part1,&part2,&part3))
               {
               if((part1 > 0) && (rlc->numnodes > 1))
                  {
                  for(jj=1; jj<rlc->numnodes; jj++)
                     {
                     if(((rlc->x[jj] >= minx) && (rlc->x[jj] <= maxx) && (rlc->y[jj] >= miny) &&(rlc->y[jj] <= maxy)) ||
                          ((rlc->x[jj-1] >= minx) && (rlc->x[jj-1] <= maxx) && (rlc->y[jj-1] >= miny) &&(rlc->y[jj-1] <= maxy)))
                        {
                        if((rlc->x[jj] != rlc->x[jj-1]) ||
                            (rlc->y[jj] != rlc->y[jj-1]) ||
                            (rlc->z[jj] != rlc->z[jj-1]))
                           {
                           ptpdist1 = Distance3D(rlc->x[jj-1],rlc->y[jj-1],rlc->z[jj-1],
                                             rlc->x[jj],rlc->y[jj],rlc->z[jj]);
                           if(SensitivityCheck(LTEQ, SEGLEN, checkinstance, ptpdist1) > 0)
                              {
                              j = ConditionOnDataEdge(rlc->x[jj-1],rlc->y[jj-1],rlc->x[jj],rlc->y[jj],Aroot,Proot,root,
                                                   NULL, NULL, rlc,
                                                   NorthCount,SouthCount,EastCount,WestCount,checkinstance);

                              if(j > 0)
                                 FwriteObjectAndMagnitude(SEGLEN,Make_Correct(SEGLEN,checkinstance),
                                       rlc->idn,
                                       rlc->Sindex,G_LINE,rlc->Lindex,rlc->localID,-1.0,-1.0,ptpdist1,
                                       &rlc->x[jj-1], &rlc->y[jj-1],&rlc->z[jj-1],2, 1);
                              }
                           }
                        }
                     }
                  }
               }


        if(CombinedCheckApplies(rlc->idn,checkinstance,PERIMLEN,rlc->Lindex,rlc->Sindex,
                                Config1,Strat1,Domain1, &part1,&part2,&part3))
           {
           if(part1 > 0)
              {
              if(SensitivityCheck(LTEQ, PERIMLEN, checkinstance, rlc->length) > 0)
                 {
                 checkit = 1;
                 if((NorthCount <= 0) || (SouthCount <= 0) || (EastCount <= 0) || (WestCount <= 0))
                    {
                    maxXindex = minXindex = maxYindex = minYindex = -1;
                    for(i=0; i<rlc->numnodes; i++)
                       {
                       if((rlc->x[i] >= minx) && (rlc->x[i] <= maxx) && (rlc->y[i] >= miny) && (rlc->y[i] <= maxy))
                          {
                          if((maxXindex < 0) || (rlc->x[i] > rlc->x[maxXindex]))
                             maxXindex = i;
                          if((minXindex < 0) || (rlc->x[i] < rlc->x[minXindex]))
                             minXindex = i;
                          if((maxYindex < 0) || (rlc->y[i] > rlc->y[maxYindex]))
                             maxYindex = i;
                          if((minYindex < 0) || (rlc->y[i] < rlc->y[minYindex]))
                             minYindex = i;
                          }
                       }
                    checkit = 1;
                    if((maxXindex >= 0) && (EastCount <= 0))
                       {
                       if(maxXindex == 0)
                          i = 1;
                       else
                          i = maxXindex - 1;
                       checkit = ConditionOnDataEdge(rlc->x[i],rlc->y[i],rlc->x[maxXindex],rlc->y[maxXindex],Aroot,Proot,root,
                                                  NULL, NULL, rlc,100,100,EastCount,100,checkinstance);
                       }
                    if((minXindex >= 0) && (checkit > 0) && (WestCount <= 0))
                       {
                       if(minXindex == 0)
                          i = 1;
                       else
                          i = minXindex - 1;
                       checkit = ConditionOnDataEdge(rlc->x[i],rlc->y[i],rlc->x[minXindex],rlc->y[minXindex],Aroot,Proot,root,
                                                  NULL, NULL, rlc,100,100,100,WestCount,checkinstance);
                       }
                    if((minYindex >= 0) && (checkit > 0) && (SouthCount <= 0))
                       {
                       if(minYindex == 0)
                          i = 1;
                       else
                          i = minYindex - 1;
                       checkit = ConditionOnDataEdge(rlc->x[i],rlc->y[i],rlc->x[minYindex],rlc->y[minYindex],Aroot,Proot,root,
                                                  NULL, NULL, rlc,100,SouthCount,100,100,checkinstance);
                       }
                    if((maxYindex >= 0) && (checkit > 0) && (NorthCount <= 0))
                       {
                       if(maxYindex == 0)
                          i = 1;
                       else
                          i = maxYindex - 1;
                       checkit = ConditionOnDataEdge(rlc->x[i],rlc->y[i],rlc->x[maxYindex],rlc->y[maxYindex],Aroot,Proot,root,
                                                  NULL, NULL, rlc, NorthCount,100,100,100,checkinstance);
                       }
                    }
                 if(checkit > 0)
/*** about to write a condition - is this line connected to a specified point or area feture? ***/
                    {
                    unuseddbl = FindRelevantSensitivity(PERIMLEN,checkinstance,&tolerancepad);
                    jj = 0;
                    while((jj < rlc->numnodes) && (checkit > 0))
                       {
                       rpc = Proot;
                       while(rpc != NULL)
                          {
                          if((rpc->numverts == -1) && /** rpc is a pure point ***/
                             (CombinedCheckApplies(rpc->idn,checkinstance,PERIMLEN,rpc->Lindex,rpc->Sindex,
                               SCCtable[rpc->Sindex].C,SCCtable[rpc->Sindex].S,SCCtable[rpc->Sindex].D, &part1,&part2,&part3) > 0) &&
                              (part2 > 0))
                             {
                             if((rpc->x[0] >= minx) && (rpc->x[0] <= maxx) && (rpc->y[0] >= miny) && (rpc->y[0] <= maxy))
                                {
                                ptldist1 = Distance3D(rlc->x[jj],rlc->y[jj],rlc->z[jj],rpc->x[0],rpc->y[0],rpc->z[0]);
                                if((ptpdist1 >= 0.0) && (ptpdist1 < tolerancepad))
                                   {
                                   checkit = 0;
                                   break; /*** from for kk2 ... **/
                                   }
                                }
                             }
                          rpc = rpc->next;
                          }

                       if(checkit > 0)
                          {
                          rln = root;
                          while(rln != NULL)
                            {
                            if((rln != rlc) &&
                                 (CombinedCheckApplies(rln->idn,checkinstance,PERIMLEN,rln->Lindex,rln->Sindex,SCCtable[rln->Sindex].C,
                                    SCCtable[rln->Sindex].S,SCCtable[rln->Sindex].D,&part1,&part2,&part3) > 0) &&
                                 (part2 > 0))
                               {
                               for(kk2=1; kk2<rln->numnodes; kk2++)
                                  {
                                  ptpdist1 = PointToLineDist(rlc->x[jj],rlc->y[jj],rlc->z[jj],
                                                       rln->x[kk2-1],rln->y[kk2-1],rln->z[kk2-1] ,rln->x[kk2],rln->y[kk2],rln->z[kk2]);
                                  if((ptpdist1 >= 0.0) && (ptpdist1 < tolerancepad))
                                     {
                                     checkit = 0;
                                     break; /*** from for kk2 ... **/
                                     }
                                  }
                               if(checkit == 0)
                                  break;
                               }
                            rln = rln->next;
                            }
                         }

                      if(checkit > 0)
                         {
                         rac = Aroot;
                         while(rac != NULL)
                            {
                            if((CombinedCheckApplies(rac->idn,checkinstance,PERIMLEN,rac->Lindex,rac->Sindex,
                               SCCtable[rac->Sindex].C,SCCtable[rac->Sindex].S,SCCtable[rac->Sindex].D,&part1,&part2,&part3) > 0) &&
                                          (part2 > 0))
                               {
                               if(rac->RB_Tree_Edgelist == NULL)
                                  ptpdist1 = PointToSmallArealDist2D(rlc->x[jj], rlc->y[jj],rac,&unusedint,&unuseddbl);
                               else
                                  ptpdist1 = PointToLargeArealDist2D(rlc->x[jj], rlc->y[jj],rac,&unusedint,&unuseddbl);
   
                               if((ptpdist1 >= 0.0) && (ptpdist1 < tolerancepad)) /** seems we have found the condition ***/
                                  {
                                  checkit = 0;
                                  break; /*** jumps out of the while rac != NULL loop ***/
                                  }
                                }
                             rac = rac->next;
                             }
                          if(checkit == 0)
                             break; /*** jumps out of the while jj loop ***/
                          jj = jj + rlc->numnodes - 1;
                          }
                       }
                    }


                 if((checkit > 0) && (rlc->IsMulti == 0))
                    {
                    X[0] = rlc->x[0];
                    Y[0] = rlc->y[0];
                    Z[0] = rlc->z[0];
                    X[1] = rlc->x[1];
                    Y[1] = rlc->y[1];
                    Z[1] = rlc->z[1];
                    FwriteObjectAndMagnitude(PERIMLEN,Make_Correct(PERIMLEN,checkinstance), rlc->idn,
                             rlc->Sindex,G_LINE,rlc->Lindex,rlc->localID,-1.0,-1.0,rlc->length,
                             &X[0], &Y[0],&Z[0],2, 1);
                    }
                 else if(rlc->IsMulti > 0)
                    {
                    RB_newKey2 = rlc->idn + (checkinstance * 0.0001);
                    if(( RB_newNode = RBExactQuery(Check_RB_Tree,&RB_newKey2)))
                       {
                       RB_cond = (struct ConditionCollection *) RB_newNode->info;
                       RB_cond->counter += 1;
                       if(checkit == 0)
                          RB_cond->magnitude = -100.0;
                       }
                    else
                       {
                       RB_cond = (struct ConditionCollection *) (malloc(SzCC));
                       if(RB_cond == NULL)
                          {
                          printf("memory has been exhausted during RB-Tree information alloction for PERIMLEN analysis\n");
                          exit(-1);
                          }
                       RB_cond->keyval = PERIMLEN;
                       RB_cond->Cnumber =  Make_Correct(PERIMLEN,checkinstance);
                       RB_cond->index_from_to = NULL;
                       RB_cond->gform = G_LINE;
                       RB_cond->featureidn = rlc->featureid;
                       RB_cond->localID = rlc->localID;
                       RB_cond->counter = 1;
                       RB_cond->radius = -1;
                       RB_cond->height = -1;
                       if(checkit > 0)
                          RB_cond->magnitude = rlc->length;
                       else
                          RB_cond->magnitude = -100.0;
                       RB_cond->IDN = rlc->idn;
                       RB_cond->Sindex = rlc->Sindex;
                       RB_cond->Lindex = rlc->Lindex;

                       RB_cond->numnodes = rlc->numnodes;
                       RB_cond->x = (double *) (malloc(RB_cond->numnodes * SzD));
                       RB_cond->y = (double *) (malloc(RB_cond->numnodes * SzD));
                       RB_cond->z = (double *) (malloc(RB_cond->numnodes * SzD));
                       if(RB_cond->z == NULL)
                          {
                          printf("memory has been exhausted during RB-Tree element vertex alloction for PERIMLEN analysis\n");
                          exit(-1);
                          }
                       for(jj=0; jj< rlc->numnodes; jj++)
                          {
                          RB_cond->x[jj] = rlc->x[jj];
                          RB_cond->y[jj] = rlc->y[jj];
                          RB_cond->z[jj] = rlc->z[jj];
                          }

                       RB_newDbl = (double *) (malloc(SzD));
                       if(RB_newDbl == NULL)
                          {
                          printf("memory has been exhausted during RB-Tree alloction for PERIMLEN analysis\n");
                          exit(-1);
                          }
                       *RB_newDbl = RB_newKey2; /**rlc->localID; **/
                       RBTreeInsert(Check_RB_Tree,RB_newDbl, RB_cond);
                       }

                    }
                 }
              }
           }


            }


         if((NGA_TYPE > 0) && 
               (CombinedCheckApplies(rlc->idn,checkinstance,ISOTURN,rlc->Lindex,rlc->Sindex,Config1,Strat1,Domain1,&part1,&part2,&part3) > 0) &&
               (part1 > 0))
            {
            if(rlc->numnodes > 2)
               {
               for(j=2; j<=rlc->numnodes; j++)
                  {
                  k = j - 2;
                  i = j - 1;
/*** this part checks along the length of the line itself, as an individual feature ***/
/*** thus the requirement that the line have at least 3 vertices (o/w can't form an angle) ***/
                  if((rlc->x[i] >= minx) && (rlc->x[i] <= maxx) && (rlc->y[i] >= miny) && (rlc->y[i] <= maxy) &&
                      (j < rlc->numnodes))
                     {
                     keepit = 0;
                     temp = TurnAngle(rlc->x[k],rlc->y[k],rlc->x[i],rlc->y[i],rlc->x[j],rlc->y[j]);

                     if(temp < PI)
                        temp = RadiansToDegrees(temp);
                     else
                        temp = 180.0;

                     if((temp < 180.0) && (SensitivityCheck(GTEQ, ISOTURN, checkinstance, temp) > 0))
                        {
                        keepit = RemoveByContainmentOrCoincidence(rlc->x[i], rlc->y[i], root, checkinstance,
                                       ISOTURN, minx, miny, maxx, maxy, ActiveChecks[checkinstance].sensitivity2,
                                       Aroot, Proot);
                        }
                     if(keepit > 0)
                        {
                        ERc = (struct collection *) (malloc(SzC));
                        if(ERc == NULL)
                           {
                           printf("allocation memory exhausted during linear feature condition analysis\n");
                           printf("processing cannot continue\n");
                           exit(-1);
                           }
                        ERc->x[1] = rlc->x[i];
                        ERc->y[1] = rlc->y[i];
                        ERc->magnitude = temp;
                        ERc->keyval = ISOTURN;
                        ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                        ERc->Sindex = rlc->Sindex;
                        ERc->ll1 = rlc;
                        ERc->next = NULL;

                        ERn = ERroot;
                        while(ERn != NULL)
                           {
                             if(
                                (ERn->Cnumber    == ERc->Cnumber)    &&
                                (ERn->keyval    == ERc->keyval)    &&
                                (ERn->x[1]      == ERc->x[1])      &&
                                (ERn->magnitude == ERc->magnitude) &&
                                (ERn->y[1]      == ERc->y[1])      &&
                                (ERn->Sindex    == ERc->Sindex)
                                )
                              break;
                           ERn = ERn->next;
                           }
                        if(ERn == NULL)
                           {
                           ERc->z[1] = rlc->z[i];
                           ERc->x[0] = rlc->x[k];
                           ERc->y[0] = rlc->y[k];
                           ERc->z[0] = rlc->z[k];
                           ERc->x[2] = rlc->x[j];
                           ERc->y[2] = rlc->y[j];
                           ERc->z[2] = rlc->z[j];
                           ERc->next = ERroot;
                           ERroot = ERc;
                           }
                        else
                           free(ERc);
                        } /*** end if sensitivity check ***/
                     }
                  }
               }
            j = 0;
            while(j < rlc->numnodes)
               {
                if((rlc->x[j] >= minx) && (rlc->x[j] <= maxx) && (rlc->y[j] >= miny) &&(rlc->y[j] <= maxy))
                   {
                   if(j == 0)
                      k = 1;
                   else
                      k = j - 1;
                   rln = rlc->next;
                   while(rln != NULL)
                      {
                      if((rln != rlc) &&
                              (CombinedCheckApplies(rln->idn,checkinstance,ISOTURN,rln->Lindex,rln->Sindex,SCCtable[rln->Sindex].C,
                                 SCCtable[rln->Sindex].S,SCCtable[rln->Sindex].D,&part1,&part2,&part3) > 0) &&
                              (part2 > 0))
                         {
                         for(i=0; i<rln->numnodes; i++)
                            {
                            if((rln->x[i] >= minx) && (rln->x[i] <= maxx) && (rln->y[i] >= miny) &&(rln->y[i] <= maxy))
                               {
                               keepit = 0;
                               ptpdist1 = Distance3D(rlc->x[j],rlc->y[j],rlc->z[j],rln->x[i],rln->y[i],rln->z[i]);
                               if(ptpdist1 < ActiveChecks[checkinstance].sensitivity2) /** found a rlc end node to rln node match ***/
                                  {
                                  if(i == 0)
                                     {
                                     temp = TurnAngle(rlc->x[k],rlc->y[k],rlc->x[j],rlc->y[j],rln->x[i+1],rln->y[i+1]);
                                     ii2 = i+1;
                                     }
                                  else if(i == (rln->numnodes - 1))
                                     {
                                     temp = TurnAngle(rlc->x[k],rlc->y[k],rlc->x[j],rlc->y[j],rln->x[i-1],rln->y[i-1]);
                                     ii2 = i-1;
                                     }
                                  else
                                     {
                                     temp = TurnAngle(rlc->x[k],rlc->y[k],rlc->x[j],rlc->y[j],rln->x[i+1],rln->y[i+1]);
                                     temp2 = TurnAngle(rlc->x[k],rlc->y[k],rlc->x[j],rlc->y[j],rln->x[i-1],rln->y[i-1]);
                                     ii2 = i + 1;
                                     if(temp2 < temp)
                                        {
                                        temp = temp2;
                                        ii2 = i - 1;
                                        }
                                     }
                                  if(temp < PI)
                                     temp = RadiansToDegrees(temp);
                                  else
                                     temp = 180.0;

                                  if((temp < 180.0) && (SensitivityCheck(GTEQ, ISOTURN, checkinstance, temp) > 0))
                                     {
                                     keepit = RemoveByContainmentOrCoincidence(rlc->x[j], rlc->y[j], root, checkinstance,
                                                    ISOTURN, minx, miny, maxx, maxy, ActiveChecks[checkinstance].sensitivity2,
                                                    Aroot, Proot);
                                     }
                                  if(keepit > 0)
                                     {
                                     ERc = (struct collection *) (malloc(SzC));
                                     if(ERc == NULL)
                                        {
                                        printf("allocation memory exhausted during linear feature condition analysis\n");
                                        printf("processing cannot continue\n");
                                        exit(-1);
                                        }
                                     ERc->x[1] = rlc->x[j];
                                     ERc->y[1] = rlc->y[j];
                                     ERc->magnitude = temp;
                                     ERc->keyval = ISOTURN;
                                     ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                                     ERc->Sindex = rlc->Sindex;
                                     ERc->ll1 = rlc;
                                     ERc->next = NULL;

                                     ERn = ERroot;
                                     while(ERn != NULL)
                                        {
                                          if(
                                             (ERn->Cnumber    == ERc->Cnumber)    &&
                                             (ERn->keyval    == ERc->keyval)    &&
                                             (ERn->x[1]      == ERc->x[1])      &&
                                             (ERn->magnitude == ERc->magnitude) &&
                                             (ERn->y[1]      == ERc->y[1])  /***    &&
                                             (ERn->Sindex    == ERc->Sindex) ***/
                                             )
                                           break;
                                        ERn = ERn->next;
                                        }
                                     if(ERn == NULL)
                                        {
                                        ERc->z[1] = rlc->z[j];
                                        ERc->x[0] = rlc->x[k];
                                        ERc->y[0] = rlc->y[k];
                                        ERc->z[0] = rlc->z[k];
                                        ERc->x[2] = rln->x[ii2];
                                        ERc->y[2] = rln->y[ii2];
                                        ERc->z[2] = rln->z[ii2];
                                        ERc->next = ERroot;
                                        ERroot = ERc;
                                        }
                                     else
                                        free(ERc);
                                     } /*** end if sensitivity check ***/
                                  }
                               }
                            }
                         }
                      rln = rln->next;
                      }
                   }
               j += rlc->numnodes - 1;
               }
            }




         if((NGA_TYPE > 0) && 
               (CombinedCheckApplies(rlc->idn,checkinstance,KINK,rlc->Lindex,rlc->Sindex,Config1,Strat1,Domain1,&part1,&part2,&part3) > 0) &&
               (part1 > 0))
            {
            if((rlc->firstencounter == 1) && (rlc->numnodes > 2))
               {
               for(j=2; j<=rlc->numnodes; j++)
                  {
                  k = j - 2;
                  i = j - 1;
                  if(j < rlc->numnodes)
                     {
                     temp = TurnAngle(rlc->x[k],rlc->y[k],rlc->x[i],rlc->y[i],rlc->x[j],rlc->y[j]);

                     if(temp < PI)
                        temp = RadiansToDegrees(temp);
                     else
                        temp = 180.0;

                     if((temp < 180.0) && (SensitivityCheck(GTEQ, KINK, checkinstance, temp) > 0))
                        {
                        ERc = (struct collection *) (malloc(SzC));
                        if(ERc == NULL)
                           {
                           printf("allocation memory exhausted during linear feature condition analysis\n");
                           printf("processing cannot continue\n");
                           exit(-1);
                           }
                        ERc->x[1] = rlc->x[i];
                        ERc->y[1] = rlc->y[i];
                        ERc->magnitude = temp;
                        ERc->keyval = KINK;
                        ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                        ERc->Sindex = rlc->Sindex;
                        ERc->ll1 = rlc;
                        ERc->next = NULL;

                        ERn = ERroot;
                        while(ERn != NULL)
                           {
                             if(
                                (ERn->Cnumber    == ERc->Cnumber)    &&
                                (ERn->keyval    == ERc->keyval)    &&
                                (ERn->x[1]      == ERc->x[1])      &&
                                (ERn->magnitude == ERc->magnitude) &&
                                (ERn->y[1]      == ERc->y[1])      &&
                                (ERn->Sindex    == ERc->Sindex)
                                )
                              break;
                           ERn = ERn->next;
                           }
                        if(ERn == NULL)
                           {
                           ERc->z[1] = rlc->z[i];
                           ERc->x[0] = rlc->x[k];
                           ERc->y[0] = rlc->y[k];
                           ERc->z[0] = rlc->z[k];
                           ERc->x[2] = rlc->x[j];
                           ERc->y[2] = rlc->y[j];
                           ERc->z[2] = rlc->z[j];
                           ERc->next = ERroot;
                           ERroot = ERc;
                           }
                        else
                           free(ERc);
                        } /*** end if sensitivity check ***/
                     }
                  }
               }
            j = 0;
            while(j < rlc->numnodes)
               {
                if((rlc->x[j] >= minx) && (rlc->x[j] <= maxx) && (rlc->y[j] >= miny) &&(rlc->y[j] <= maxy))
                   {
                   if(j == 0)
                      k = 1;
                   else
                      k = j - 1;
                   rln = rlc->next;
                   while(rln != NULL)
                      {
                      if((rln != rlc) && 
                              (CombinedCheckApplies(rln->idn,checkinstance,KINK,rln->Lindex,rln->Sindex,SCCtable[rln->Sindex].C,
                                 SCCtable[rln->Sindex].S,SCCtable[rln->Sindex].D,&part1,&part2,&part3) > 0) &&
                              (part1 > 0))
                         {
                         for(i=0; i<rln->numnodes; i++)
                            {
                            if((rln->x[i] >= minx) && (rln->x[i] <= maxx) && (rln->y[i] >= miny) &&(rln->y[i] <= maxy))
                               {
                               ptpdist1 = Distance3D(rlc->x[j],rlc->y[j],rlc->z[j],rln->x[i],rln->y[i],rln->z[i]); 
                               if(ptpdist1 < 0.001) /** found a rlc end node to rln node match ***/
                                  {
                                  if(i == 0)
                                     {
                                     temp = TurnAngle(rlc->x[k],rlc->y[k],rlc->x[j],rlc->y[j],rln->x[i+1],rln->y[i+1]);
                                     ii2 = i+1;
                                     }
                                  else if(i == (rln->numnodes - 1))
                                     {
                                     temp = TurnAngle(rlc->x[k],rlc->y[k],rlc->x[j],rlc->y[j],rln->x[i-1],rln->y[i-1]);
                                     ii2 = i-1;
                                     }
                                  else
                                     {
                                     temp = TurnAngle(rlc->x[k],rlc->y[k],rlc->x[j],rlc->y[j],rln->x[i+1],rln->y[i+1]);
                                     temp2 = TurnAngle(rlc->x[k],rlc->y[k],rlc->x[j],rlc->y[j],rln->x[i-1],rln->y[i-1]);
                                     ii2 = i + 1;
                                     if(temp2 < temp)
                                        {
                                        temp = temp2;
                                        ii2 = i - 1;
                                        }
                                     }

                                  if(temp < PI)
                                     temp = RadiansToDegrees(temp);
                                  else
                                     temp = 180.0;
   
                                  if((temp < 180.0) && (SensitivityCheck(GTEQ, KINK, checkinstance, temp) > 0))

                                     {
                                     ERc = (struct collection *) (malloc(SzC));
                                     if(ERc == NULL)
                                        {
                                        printf("allocation memory exhausted during linear feature condition analysis\n");
                                        printf("processing cannot continue\n");
                                        exit(-1);
                                        }
                                     ERc->x[1] = rlc->x[j];
                                     ERc->y[1] = rlc->y[j];
                                     ERc->magnitude = temp;
                                     ERc->keyval = KINK;
                                     ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                                     ERc->Sindex = rlc->Sindex;
                                     ERc->ll1 = rlc;
                                     ERc->next = NULL;
          
                                     ERn = ERroot;
                                     while(ERn != NULL)
                                        {
                                          if(
                                             (ERn->Cnumber    == ERc->Cnumber)    &&
                                             (ERn->keyval    == ERc->keyval)    &&
                                             (ERn->x[1]      == ERc->x[1])      &&
                                             (ERn->magnitude == ERc->magnitude) &&
                                             (ERn->y[1]      == ERc->y[1])  /***    &&
                                             (ERn->Sindex    == ERc->Sindex) ***/
                                             )  
                                           break;
                                        ERn = ERn->next;
                                        }
                                     if(ERn == NULL)
                                        {
                                        ERc->z[1] = rlc->z[j];
                                        ERc->x[0] = rlc->x[k];
                                        ERc->y[0] = rlc->y[k];
                                        ERc->z[0] = rlc->z[k];
                                        ERc->x[2] = rln->x[ii2];
                                        ERc->y[2] = rln->y[ii2];
                                        ERc->z[2] = rln->z[ii2];
                                        ERc->next = ERroot;
                                        ERroot = ERc;
                                        }
                                     else
                                        free(ERc);
                                     } /*** end if sensitivity check ***/
                                  }
                               }
                            }
                         }
                      rln = rln->next;
                      }
                   }
               j += rlc->numnodes - 1;
               }
            }



         if((CombinedCheckApplies(rlc->idn,checkinstance,Z_KINK,rlc->Lindex,rlc->Sindex,Config1,Strat1,Domain1,&part1,&part2,&part3) > 0) &&
               (part1 > 0))
            {
            if(rlc->numnodes > 3)
               {
               for(j=2; j<=rlc->numnodes; j++)
                  {
                  k = j - 2;
                  i = j - 1;
                  if(j < rlc->numnodes)
                     { 
                     temp = TurnAngle(rlc->x[k],rlc->y[k],rlc->x[i],rlc->y[i],rlc->x[j],rlc->y[j]);

                     if(temp < PI)
                        temp = RadiansToDegrees(temp);
                     else
                        temp = 180.0;

                     if((temp < 180.0) && (SensitivityCheck(GTCLOSED, Z_KINK, checkinstance, temp) > 0))
                        {
                        kk = j + 1;
                        if(kk < rlc->numnodes)
                           {
                           temp2 = TurnAngle(rlc->x[i],rlc->y[i],rlc->x[j],rlc->y[j],rlc->x[kk],rlc->y[kk]);
                           if(temp2 < PI)
                              temp2 = RadiansToDegrees(temp2);
                           else
                              temp2 = 180.0;
      
                           if((temp2 < 180.0) && (SensitivityCheck(GTCLOSED, Z_KINK, checkinstance, temp2) > 0))
                              {
                              ERc = (struct collection *) (malloc(SzC));
                              if(ERc == NULL)
                                 {
                                 printf("allocation memory exhausted during linear feature condition analysis\n");
                                 printf("processing cannot continue\n");
                                 exit(-1);
                                 }
                              if(temp > temp2)
                                 {
                                 ERc->x[1] = rlc->x[i];
                                 ERc->y[1] = rlc->y[i];
                                 ERc->z[1] = rlc->z[i];
                                 ERc->x[2] = rlc->x[j];
                                 ERc->y[2] = rlc->y[j];
                                 ERc->z[2] = rlc->z[j];
                                 ERc->magnitude = temp;
                                 }
                              else
                                 {
                                 ERc->x[2] = rlc->x[i];
                                 ERc->y[2] = rlc->y[i];
                                 ERc->z[2] = rlc->z[i];
                                 ERc->x[1] = rlc->x[j];
                                 ERc->y[1] = rlc->y[j];
                                 ERc->z[1] = rlc->z[j];
                                 ERc->magnitude = temp2;
                                 }

                              ERc->keyval = Z_KINK;
                              ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                              ERc->Sindex = rlc->Sindex;
                              ERc->ll1 = rlc;
                              ERc->next = NULL;

                              ERn = ERroot;
                              while(ERn != NULL)
                                 {
                                   if(
                                      (ERn->Cnumber    == ERc->Cnumber)    &&
                                      (ERn->keyval    == ERc->keyval)    &&
                                      (ERn->Sindex    == ERc->Sindex)    &&
                                      (ERn->x[1]      == ERc->x[1])      &&
                                      (ERn->magnitude == ERc->magnitude) &&
                                      (ERn->y[1]      == ERc->y[1])      &&
                                      (ERn->Sindex    == ERc->Sindex)    &&
                                      (ERn->x[2]      == ERc->x[2])      &&  (ERn->y[2]      == ERc->y[2])
                                      )
                                    break;
                                 ERn = ERn->next;
                                 }
                              if(ERn == NULL)
                                 {
                                 if(temp > temp2)
                                    {
                                    ERc->x[0] = rlc->x[k];
                                    ERc->y[0] = rlc->y[k];
                                    ERc->z[0] = rlc->z[k];
                                    ERc->x[3] = rlc->x[kk];
                                    ERc->y[3] = rlc->y[kk];
                                    ERc->z[3] = rlc->z[kk];
                                    }
                                 else
                                    {
                                    ERc->x[3] = rlc->x[k];
                                    ERc->y[3] = rlc->y[k];
                                    ERc->z[3] = rlc->z[k];
                                    ERc->x[0] = rlc->x[kk];
                                    ERc->y[0] = rlc->y[kk];
                                    ERc->z[0] = rlc->z[kk];
                                    }
                                 ERc->next = ERroot;
                                 ERroot = ERc;
                                 }
                              else
                                 free(ERc);
                              } /*** end if second sensitivity check on temp2***/
                           } /** end kk < rlc->numnodes ***/
                        } /*** end if sensitivity check ***/
                     }
                  }
               }
           if(rlc->numnodes > 2)
              j = 0;
           else
              {
              j = rlc->numnodes + 3;
              }
            while(j < rlc->numnodes)
               {
                if((rlc->x[j] >= minx) && (rlc->x[j] <= maxx) && (rlc->y[j] >= miny) &&(rlc->y[j] <= maxy))
                   {

                   if(j == 0)
                      {
                      k = 1;
                      kk = 2;
                      }
                   else
                      {
                      k = j - 1;
                      kk = j - 2;
                      }
                   temp3 = TurnAngle(rlc->x[kk],rlc->y[kk],rlc->x[k],rlc->y[k],rlc->x[j],rlc->y[j]);
                   if(temp3 < PI) 
                      temp3 = RadiansToDegrees(temp3);
                   else
                      temp3 = 180.0;

                   if((temp3 < 180.0) && (SensitivityCheck(GTCLOSED, Z_KINK, checkinstance, temp3) > 0))
                      {
                      rln = root; //rlc->next;
                      while(rln != NULL)
                         {
                         if((rln != rlc) &&
                              (CombinedCheckApplies(rln->idn,checkinstance,Z_KINK,rln->Lindex,rln->Sindex,SCCtable[rln->Sindex].C,
                                 SCCtable[rln->Sindex].S,SCCtable[rln->Sindex].D,&part1,&part2,&part3) > 0) &&
                              (part1 > 0))
                            {
                            for(i=0; i<rln->numnodes; i++)
                               {
                               if((rln->x[i] >= minx) && (rln->x[i] <= maxx) && (rln->y[i] >= miny) &&(rln->y[i] <= maxy))
                                  {
                                  ptpdist1 = Distance3D(rlc->x[j],rlc->y[j],rlc->z[j],rln->x[i],rln->y[i],rln->z[i]);
                                  if(ptpdist1 < 0.001) /** found a rlc end node to rln node match ***/
                                     {
                                     if(i == 0)
                                        {
                                        temp = TurnAngle(rlc->x[k],rlc->y[k],rlc->x[j],rlc->y[j],rln->x[i+1],rln->y[i+1]);
                                        ii2 = i+1;
                                        }
                                     else if(i == (rln->numnodes - 1))
                                        {
                                        temp = TurnAngle(rlc->x[k],rlc->y[k],rlc->x[j],rlc->y[j],rln->x[i-1],rln->y[i-1]);
                                        ii2 = i-1;
                                        }
                                     else
                                        {
                                        temp = TurnAngle(rlc->x[k],rlc->y[k],rlc->x[j],rlc->y[j],rln->x[i+1],rln->y[i+1]);
                                        temp2 = TurnAngle(rlc->x[k],rlc->y[k],rlc->x[j],rlc->y[j],rln->x[i-1],rln->y[i-1]);
                                        ii2 = i + 1;
                                        if(temp2 < temp)
                                           {
                                           temp = temp2;
                                           ii2 = i - 1;
                                           }
                                        }
                                     if(temp < PI)
                                        temp = RadiansToDegrees(temp);
                                     else
                                        temp = 180.0;
                                     if((temp < 180.0) && (SensitivityCheck(GTCLOSED, Z_KINK, checkinstance, temp) > 0))
                                        {
                                        ERc = (struct collection *) (malloc(SzC));
                                        if(ERc == NULL)
                                           {
                                           printf("allocation memory exhausted during linear feature condition analysis\n");
                                           printf("processing cannot continue\n");
                                           exit(-1);
                                           }
                                        if(temp3 > temp)
                                           {
                                           ERc->x[2] = rlc->x[j];
                                           ERc->y[2] = rlc->y[j];
                                           ERc->z[2] = rlc->z[j];
                                           ERc->x[1] = rlc->x[k];
                                           ERc->y[1] = rlc->y[k];
                                           ERc->z[1] = rlc->z[k];
                                           ERc->magnitude = temp3;
                                           }
                                        else
                                           {
                                           ERc->x[1] = rlc->x[j];
                                           ERc->y[1] = rlc->y[j];
                                           ERc->z[1] = rlc->z[j];
                                           ERc->x[2] = rlc->x[k];
                                           ERc->y[2] = rlc->y[k];
                                           ERc->z[2] = rlc->z[k];
                                           ERc->magnitude = temp;
                                           }
                                        ERc->keyval = Z_KINK;
                                        ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                                        ERc->Sindex = rlc->Sindex;
                                        ERc->ll1 = rlc;
                                        ERc->next = NULL;

                                        ERn = ERroot;
                                        while(ERn != NULL)
                                           {
                                             if(
                                                (ERn->Cnumber    == ERc->Cnumber)    &&
                                                (ERn->keyval    == ERc->keyval)    &&
                                                (ERn->x[1]      == ERc->x[1])      &&
                                                (ERn->Sindex    == ERc->Sindex)    &&
                                                (ERn->magnitude == ERc->magnitude) &&
                                                (ERn->y[1]      == ERc->y[1])     &&
                                                (ERn->x[2]      == ERc->x[2])     &&   (ERn->y[2]      == ERc->y[2])
                                                )
                                              break;
                                           ERn = ERn->next;
                                           }
                                        if(ERn == NULL)
                                           {
                                           if(temp3 > temp)
                                              {
                                              ERc->x[0] = rlc->x[kk];
                                              ERc->y[0] = rlc->y[kk];
                                              ERc->z[0] = rlc->z[kk];
                                              ERc->x[3] = rln->x[ii2];
                                              ERc->y[3] = rln->y[ii2];
                                              ERc->z[3] = rln->z[ii2];
                                              }
                                           else
                                              {
                                              ERc->x[3] = rlc->x[kk];
                                              ERc->y[3] = rlc->y[kk];
                                              ERc->z[3] = rlc->z[kk];
                                              ERc->x[0] = rln->x[ii2];
                                              ERc->y[0] = rln->y[ii2];
                                              ERc->z[0] = rln->z[ii2];
                                              }
                                           ERc->next = ERroot;
                                           ERroot = ERc;
                                           }
                                        else
                                           free(ERc);
                                        } /*** end if sensitivity check ***/
                                     }
                                  }
                               }
                            }
                         rln = rln->next;
                         }
                      } /*** end temp3 sensitivity check ***/
                   }
               j += rlc->numnodes - 1;
               } /*** end neighbor line checking ***/
            } /**** end Z_KINK check ***/




         if((CombinedCheckApplies(rlc->idn,checkinstance,L_A_KINK,rlc->Lindex,rlc->Sindex,Config1,Strat1,Domain1,&part1,&part2,&part3) > 0) &&
               (part1 > 0))
            {
            j = rlc->numnodes - 1;
            k = rlc->numnodes - 2;
            rac = Aroot;
            while(rac != NULL)
               {
               keepit = 0;
               Config2 = SCCtable[rac->Sindex].C;
               Strat2 = SCCtable[rac->Sindex].S;
               Domain2 = SCCtable[rac->Sindex].D;
               if((CombinedCheckApplies(rac->idn,checkinstance,L_A_KINK,rac->Lindex,rac->Sindex,
                            Config2,Strat2,Domain2,&part1,&part2,&part3) > 0) && (part2 > 0))
                  {
                  if(rac->RB_Tree_Edgelist == NULL)
                     {
                     temp = Line_SmallArealAngle(rlc->x[k],rlc->y[k],rlc->x[j],rlc->y[j],rac,&nindex);
                     if(SensitivityCheck(GTEQ, L_A_KINK, checkinstance, temp) > 0)
                        {
                        jj = j;
                        kk = k;
                        keepit = 1;
                        }
                     else
                        {
                        temp = Line_SmallArealAngle(rlc->x[1],rlc->y[1],rlc->x[0],rlc->y[0],rac,&nindex);
                        if(SensitivityCheck(GTEQ, L_A_KINK, checkinstance, temp) > 0)
                           {
                           jj = 0;
                           kk = 1;
                           keepit = 1;
                           }
                        }
                     }
                  else
                     {
                     temp = Line_LargeArealAngle(rlc->x[k],rlc->y[k],rlc->x[j],rlc->y[j],rac,&nindex);
                     if(SensitivityCheck(GTEQ, L_A_KINK, checkinstance, temp) > 0)
                        {
                        jj = j;
                        kk = k;
                        keepit = 1;
                        }
                     else
                        {
                        temp = Line_LargeArealAngle(rlc->x[1],rlc->y[1],rlc->x[0],rlc->y[0],rac,&nindex);
                        if(SensitivityCheck(GTEQ, L_A_KINK, checkinstance, temp) > 0)
                           {
                           jj = 0;
                           kk = 1;
                           keepit = 1;
                           }
                        }
                     }
                  }
               if(keepit > 0)
                  {
                  ERc = (struct collection *) (malloc(SzC));
                  if(ERc == NULL)
                     {
                     printf("allocation memory exhausted during linear feature condition analysis\n");
                     printf("processing cannot continue\n");
                     exit(-1);
                     }
                  ERc->x[1] = rlc->x[jj];
                  ERc->y[1] = rlc->y[jj];
                  ERc->z[1] = rlc->z[jj];
                  ERc->magnitude = temp;
                  ERc->keyval = L_A_KINK;
                  ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                  ERc->Sindex = rlc->Sindex;
                  ERc->ll1 = rlc;
                  ERc->next = NULL;

                  ERn = ERroot;
                  while(ERn != NULL)
                     {
                       if(
                          (ERn->Cnumber    == ERc->Cnumber)    &&
                          (ERn->keyval    == ERc->keyval)    &&
                          (ERn->x[1]      == ERc->x[1])      &&
                          (ERn->magnitude == ERc->magnitude) &&
                          (ERn->y[1]      == ERc->y[1])      &&
                          (ERn->Sindex    == ERc->Sindex)
                          )
                        break;
                     ERn = ERn->next;
                     }
                  if(ERn == NULL)
                     {
                     ERc->x[0] = rlc->x[kk];
                     ERc->y[0] = rlc->y[kk];
                     ERc->z[0] = rlc->z[kk];
                     ERc->x[2] = rac->x[nindex];
                     ERc->y[2] = rac->y[nindex];
                     ERc->z[2] = rac->z[nindex];
                     ERc->next = ERroot;
                     ERroot = ERc;
                     }
                  else
                     free(ERc);
                  }
               rac = rac->next;
               }
            } /** end L_A_KINK check applies ****/




         if((rlc->firstencounter == 1) && (NGA_TYPE > 0) && 
               (CombinedCheckApplies(rlc->idn,checkinstance,INTERNALKINK,rlc->Lindex,rlc->Sindex,Config1,Strat1,Domain1,&part1,&part2,&part3) > 0) &&
               (part1 > 0))
            {
            if(rlc->numnodes > 2)
               {
               for(j=2; j<=rlc->numnodes; j++)
                  {
                  k = j - 2;
                  i = j - 1;
                  if(j < rlc->numnodes)
                     {
                     temp = TurnAngle(rlc->x[k],rlc->y[k],rlc->x[i],rlc->y[i],rlc->x[j],rlc->y[j]);

                     temp = RadiansToDegrees(temp);
                     if(SensitivityCheck(GTCLOSED, INTERNALKINK, checkinstance, temp) > 0)
                        {
                        ERc = (struct collection *) (malloc(SzC));
                        if(ERc == NULL)
                           {
                           printf("allocation memory exhausted during linear feature condition analysis\n");
                           printf("processing cannot continue\n");
                           exit(-1);
                           }
                        ERc->x[1] = rlc->x[i];
                        ERc->y[1] = rlc->y[i];
                        ERc->magnitude = temp;
                        ERc->keyval = INTERNALKINK;
                        ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                        ERc->Sindex = rlc->Sindex;
                        ERc->ll1 = rlc;
                        ERc->next = NULL;

                        ERn = ERroot;
                        while(ERn != NULL)
                           {
                             if(
                                (ERn->Cnumber    == ERc->Cnumber)    &&
                                (ERn->keyval    == ERc->keyval)    &&
                                (ERn->x[1]      == ERc->x[1])      &&
                                (ERn->magnitude == ERc->magnitude) &&
                                (ERn->y[1]      == ERc->y[1])      &&
                                (ERn->Sindex    == ERc->Sindex)
                                )
                              break;
                           ERn = ERn->next;
                           }
                        if(ERn == NULL)
                           {
                           ERc->z[1] = rlc->z[i];
                           ERc->x[0] = rlc->x[k];
                           ERc->y[0] = rlc->y[k];
                           ERc->z[0] = rlc->z[k];
                           ERc->x[2] = rlc->x[j];
                           ERc->y[2] = rlc->y[j];
                           ERc->z[2] = rlc->z[j];
                           ERc->next = ERroot;
                           ERroot = ERc;
                           }
                        else
                           free(ERc);
                        } /*** end if sensitivity check ***/
                     }
                  }
               }
            }


         if((CombinedCheckApplies(rlc->idn,checkinstance,CONTEXT_KINK,rlc->Lindex,rlc->Sindex,Config1,Strat1,Domain1,&part1,&part2,&part3) > 0) &&
               (part1 > 0))
            {
            tempsensitivity = FindRelevantSensitivity(CONTEXT_KINK,checkinstance,&tempsensitivity2);
            if(rlc->numnodes > 2)
              j = 0;
            else
              {
              j = rlc->numnodes + 3;
              }
            while(j < rlc->numnodes)
               {
                if((rlc->x[j] >= minx) && (rlc->x[j] <= maxx) && (rlc->y[j] >= miny) &&(rlc->y[j] <= maxy))
                   {

                   if(j == 0)
                      {
                      k = 1;
                      kk = 2;
                      }
                   else
                      {
                      k = j - 1;
                      kk = j - 2;
                      }
                   temp3 = TurnAngle(rlc->x[kk],rlc->y[kk],rlc->x[k],rlc->y[k],rlc->x[j],rlc->y[j]);
                   if(temp3 < PI)
                      temp3 = RadiansToDegrees(temp3);
                   else
                      temp3 = 180.0;

                   if((temp3 < tempsensitivity2) && (temp3 > 19))
                      {
                      rln = root; //rlc->next;
                      while(rln != NULL)
                         {
                         if((rln != rlc) &&
                              (CombinedCheckApplies(rln->idn,checkinstance,CONTEXT_KINK,rln->Lindex,rln->Sindex,SCCtable[rln->Sindex].C,
                                 SCCtable[rln->Sindex].S,SCCtable[rln->Sindex].D,&part1,&part2,&part3) > 0) &&
                              (part1 > 0))
                            {
                            for(i=0; i<rln->numnodes; i++)
                               {
                               if((rln->x[i] >= minx) && (rln->x[i] <= maxx) && (rln->y[i] >= miny) &&(rln->y[i] <= maxy))
                                  {
                                  ptpdist1 = Distance3D(rlc->x[j],rlc->y[j],rlc->z[j],rln->x[i],rln->y[i],rln->z[i]);
                                  if(ptpdist1 < 0.001) /** found a rlc end node to rln node match ***/
                                     {
                                     if(i == 0)
                                        {
                                        ii2 = i + 1;
                                        temp = TurnAngle(rlc->x[k],rlc->y[k],rlc->x[j],rlc->y[j],rln->x[ii2],rln->y[ii2]);
                                        if(temp3 < 45.0)
                                           {
                                              ptldist = PointToLineDist2D(rlc->x[k],rlc->y[k],rln->x[i],rln->y[i],rln->x[ii2],rln->y[ii2]);
                                           }
                                        else
                                           ptldist = 2000.0;
                                        }
                                     else if(i == (rln->numnodes - 1))
                                        {
                                        ii2 = i - 1;
                                        temp = TurnAngle(rlc->x[k],rlc->y[k],rlc->x[j],rlc->y[j],rln->x[ii2],rln->y[ii2]);
                                        if(temp3 < 45.0)
                                           {
                                              ptldist = PointToLineDist2D(rlc->x[k],rlc->y[k],rln->x[i],rln->y[i],rln->x[ii2],rln->y[ii2]);
                                           }
                                        else
                                           ptldist = 2000.0;
                                        }
                                     else
                                        {
                                        temp = TurnAngle(rlc->x[k],rlc->y[k],rlc->x[j],rlc->y[j],rln->x[i+1],rln->y[i+1]);
                                        temp2 = TurnAngle(rlc->x[k],rlc->y[k],rlc->x[j],rlc->y[j],rln->x[i-1],rln->y[i-1]);
                                        ii2 = i + 1;
                                        if(temp2 < temp)
                                           {
                                           temp = temp2;
                                           ii2 = i - 1;
                                           }
                                        if(temp3 < 45.0)
                                           {
                                              ptldist = PointToLineDist2D(rlc->x[k],rlc->y[k],rln->x[i],rln->y[i],rln->x[ii2],rln->y[ii2]);
                                           }
                                        else
                                           ptldist = 2000.0;
                                        }
                                     if(temp < PI)
                                        temp = RadiansToDegrees(temp);
                                     else
                                        temp = 180.0;
                                     if((temp < tempsensitivity2) && ((temp3 > 45.0) || (ptldist < 1.0))) 
                                        {
                                        if(SensitivityCheck(GTCLOSED, CONTEXT_KINK, checkinstance, temp) > 0)
                                           {
                                           ERc = (struct collection *) (malloc(SzC));
                                           if(ERc == NULL)
                                              {
                                              printf("allocation memory exhausted during linear feature condition analysis\n");
                                              printf("processing cannot continue\n");
                                              exit(-1);
                                              }
                                           ERc->x[2] = rlc->x[j];
                                           ERc->y[2] = rlc->y[j];
                                           ERc->z[2] = rlc->z[j];
                                           ERc->x[1] = rlc->x[k];
                                           ERc->y[1] = rlc->y[k];
                                           ERc->z[1] = rlc->z[k];
                                           ERc->magnitude = temp;
                                           ERc->keyval = CONTEXT_KINK;
                                           ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                                           ERc->Sindex = rlc->Sindex;
                                           ERc->ll1 = rlc;
                                           ERc->ll2 = rln;
                                           ERc->next = NULL;

                                           ERn = ERroot;
                                           while(ERn != NULL)
                                              {
                                               if(
                                                   (ERn->Cnumber    == ERc->Cnumber)    &&
                                                   (ERn->keyval    == ERc->keyval)    &&
                                                   (ERn->x[1]      == ERc->x[1])      &&
                                                   (ERn->Sindex    == ERc->Sindex)    &&
                                                   (ERn->magnitude == ERc->magnitude) &&
                                                   (ERn->y[1]      == ERc->y[1])     &&
                                                   (ERn->x[2]      == ERc->x[2])     &&   (ERn->y[2]      == ERc->y[2])
                                                   )
                                                 break;
                                              ERn = ERn->next;
                                              }
                                           if(ERn == NULL)
                                              {
                                              ERc->x[0] = rlc->x[kk];
                                              ERc->y[0] = rlc->y[kk];
                                              ERc->z[0] = rlc->z[kk];
                                              ERc->x[3] = rln->x[ii2];
                                              ERc->y[3] = rln->y[ii2];
                                              ERc->z[3] = rln->z[ii2];
                                              ERc->next = ERroot;
                                              ERroot = ERc;
                                              }
                                           else
                                              free(ERc);
}
                                        } /*** end if sensitivity check ***/
                                     }
                                  }
                               }
                            }
                         rln = rln->next;
                         }
                      } /*** end temp3 sensitivity check ***/
                   }
               j += rlc->numnodes - 1;
               } /*** end neighbor line checking ***/
            } /**** end CONTEXT_KINK check ***/




         if((NGA_TYPE == 0) &&
               (CombinedCheckApplies(rlc->idn,checkinstance,KINK,rlc->Lindex,rlc->Sindex,Config1,Strat1,Domain1,&part1,&part2,&part3) > 0) &&
               (part1 > 0))
            {
            if((part1 > 0) && (rlc->numnodes >= 2))
               {
               for(j=2; j<=rlc->numnodes; j++)
                  {
                  k = j - 2;
                  i = j - 1;

                  if(j < rlc->numnodes)
                     {
                     x1 = rlc->x[j];
                     y1 = rlc->y[j];
                     z1 = rlc->z[j];
temp = TurnAngle(rlc->x[k],rlc->y[k],rlc->x[i],rlc->y[i],x1,y1);
                     }
                  else
                     {
                     rln = root;
                     while(rln != NULL)
                        {
                        ptpdist1 = 1000.0;
                        if((rln != rlc) && (rln->numnodes >= 2) &&
                                (CombinedCheckApplies(rln->idn,checkinstance,KINK,rln->Lindex,rln->Sindex,SCCtable[rln->Sindex].C,
                                   SCCtable[rln->Sindex].S,SCCtable[rln->Sindex].D,&part1,&part2,&part3) > 0) &&
                                (part1 > 0))
                           {
                           ptpdist1 = Distance3D(rlc->x[i],rlc->y[i],rlc->z[i],rln->x[0],rln->y[0],rln->z[0]);
                           if(ptpdist1 < 0.001)
                              {
                              x1 = rln->x[1];
                              y1 = rln->y[1];
                              z1 = rln->z[1];
                              }
                           else
                              {
                              kk = rln->numnodes - 1;
                              ptpdist1 = Distance3D(rlc->x[i],rlc->y[i],rlc->z[i],rln->x[kk],rln->y[kk],rln->z[kk]);
                              if(ptpdist1 < 0.001)
                                 {
                                 x1 = rln->x[kk-1];
                                 y1 = rln->y[kk-1];
                                 z1 = rln->z[kk-1];
                                 }
                              }
                           }
                        if((ptpdist1 < 0.001) && (rlc->x[i] >= minx) && (rlc->x[i] <= maxx) && (rlc->y[i] >= miny) &&(rlc->y[i] <= maxy))
                           {
                           temp = TurnAngle(rlc->x[k],rlc->y[k],rlc->x[i],rlc->y[i],x1,y1);

                           temp = RadiansToDegrees(temp);

                           if((SensitivityCheck(GTEQ, KINK, checkinstance, temp) > 0) &&
                                   (ActiveChecks[checkinstance].number == KINK) &&  (ActiveChecks[checkinstance].Config2[C_POLY]  == 1))
                              {
                              tpc = Polyroot;
                              while(tpc != NULL)
                                 {
                                 if((CombinedCheckApplies(tpc->idn,checkinstance,KINK,tpc->SACindex,tpc->SCCindex,tpc->config,
                                             tpc->stratum, tpc->domain,&part1,&part2,&part3) > 0) &&
                                            (part2 > 0))
                                    {
                                    if((tpc->numverts == 3) && (PointInsideTriangle(rlc->x[i],rlc->y[i], tpc->x[0], tpc->y[0],
                                               tpc->x[1], tpc->y[1], tpc->x[2], tpc->y[2]) > 0))
                                       {
                                       break;
                                       }
                                    else if((tpc->numverts > 3) && (PointInsidePoly(rlc->x[i],rlc->y[i], tpc->x, tpc->y, tpc->numverts) > 0))
                                       {
                                       break;
                                       }
                                    }
                                 tpc = tpc->next;
                                 }
                              if(tpc == NULL)
                                 temp = 0;
                              }
                           if(SensitivityCheck(GTEQ, KINK, checkinstance, temp) > 0)
                              {
                              ERc = (struct collection *) (malloc(SzC));
                              if(ERc == NULL)
                                 {
                                 printf("allocation memory exhausted during linear feature condition analysis\n");
                                 printf("processing cannot continue\n");
                                 exit(-1);
                                 }
                              ERc->x[1] = rlc->x[i];
                              ERc->y[1] = rlc->y[i];
                              ERc->magnitude = temp;
                              ERc->keyval = KINK;
                              ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                              ERc->Sindex = rlc->Sindex;
                              ERc->ll1 = rlc;
                              ERc->next = NULL;
      
                              if(ERroot == NULL)
                                 {
                                 ERc->z[1] = rlc->z[i];
                                 ERc->x[0] = rlc->x[k];
                                 ERc->y[0] = rlc->y[k];
                                 ERc->z[0] = rlc->z[k];
                                 ERc->x[2] = x1;
                                 ERc->y[2] = y1;
                                 ERc->z[2] = z1;
                                 ERroot = ERc;
                                 }
                              else
                                 {
                                 ERn = ERroot;
                                 while(ERn != NULL)
                                    {
                                      if(
                                         (ERn->Cnumber    == ERc->Cnumber)    &&
                                         (ERn->keyval    == ERc->keyval)    &&
                                         (ERn->x[1]      == ERc->x[1])      &&
                                         (ERn->magnitude == ERc->magnitude) &&
                                         (ERn->y[1]      == ERc->y[1])      &&
                                         (ERn->Sindex    == ERc->Sindex)
                                         )
                                       break;
                                    ERn = ERn->next;
                                    }
                                 if(ERn == NULL)
                                    {
                                    ERc->z[1] = rlc->z[i];
                                    ERc->x[0] = rlc->x[k];
                                    ERc->y[0] = rlc->y[k];
                                    ERc->z[0] = rlc->z[k];
                                    ERc->x[2] = x1;
                                    ERc->y[2] = y1;
                                    ERc->z[2] = z1;
                                    ERc->next = ERroot;
                                    ERroot = ERc;
                                    }
                                 else
                                    free(ERc);
                                 }
                              }
                           }
                        rln = rln->next;
                        }
                     }
                  }
               }
            }



          if((CombinedCheckApplies(rlc->idn,checkinstance,COINCIDEFAIL,rlc->Lindex,rlc->Sindex,
                Config1,Strat1,Domain1, &part1,&part2,&part3) > 0) &&
              (part1 > 0))
            {
            foundobject = 0;
            found_one = 0;
            for(i=0; i<rlc->numnodes; i++)
               {
               if(i == 0)
                  j = rlc->numnodes - 1;
               else
                  j = i - 1;


               found_two = 0;
               checkit = 0;
               if(rlc->IsMulti == 0)
                  checkit = 1;
               else if((rlc->x[j] < rlc->x[i]) && (rlc->x[j] <= maxx) && (rlc->x[i] >= minx))
                  {
                  if((rlc->y[j] < rlc->y[i]) && (rlc->y[j] <= maxy) && (rlc->y[i] >= miny))
                     checkit = 1;
                  else if((rlc->y[i] <= maxy) && (rlc->y[j] >= miny))
                     checkit = 1;
                  }
               else if((rlc->x[i] <= maxx) && (rlc->x[j] >= minx))
                  {
                  if((rlc->y[j] < rlc->y[i]) && (rlc->y[j] <= maxy) && (rlc->y[i] >= miny))
                     checkit = 1;
                  else if((rlc->y[i] <= maxy) && (rlc->y[j] >= miny))
                     checkit = 1;
                  }
               if(checkit > 0)
                  {
                  rln = root;
                  while(rln != NULL)
                     {
                     if((CombinedCheckApplies(rln->idn,checkinstance,COINCIDEFAIL,rln->Lindex,rln->Sindex,
                             SCCtable[rln->Sindex].C,SCCtable[rln->Sindex].S,SCCtable[rln->Sindex].D,
                               &part1,&part2,&part3) > 0) && (part2 > 0))
                        {
                        if((rln->x[0] >= minx) && (rln->x[0] <= maxx) && (rln->y[0] >= miny) && (rln->y[0] <= maxy))
                           {
                           ptldist1 = PointToLineDist2D(rln->x[0],rln->y[0],rlc->x[j],rlc->y[j],rlc->x[i],rlc->y[i]);
                           if(SensitivityCheck(LTEQ, COINCIDEFAIL, checkinstance, ptldist1) > 0)
                              found_two += 1;
                           else if((rln->x[rln->numnodes-1] >= minx) && (rln->x[rln->numnodes-1] <= maxx) &&
                                       (rln->y[rln->numnodes-1] >= miny) && (rln->y[rln->numnodes-1] <= maxy))
                              {
                              ptldist1 = PointToLineDist2D(rln->x[rln->numnodes-1],rln->y[rln->numnodes-1],rlc->x[j],rlc->y[j],rlc->x[i],rlc->y[i]);
                              if(SensitivityCheck(LTEQ, COINCIDEFAIL, checkinstance, ptldist1) > 0)
                                 found_two += 1;
                              }
                           }
                        else if((rln->x[rln->numnodes-1] >= minx) && (rln->x[rln->numnodes-1] <= maxx) &&
                                       (rln->y[rln->numnodes-1] >= miny) && (rln->y[rln->numnodes-1] <= maxy))
                           {
                           ptldist1 = PointToLineDist2D(rln->x[rln->numnodes-1],rln->y[rln->numnodes-1],rlc->x[j],rlc->y[j],rlc->x[i],rlc->y[i]);
                           if(SensitivityCheck(LTEQ, COINCIDEFAIL, checkinstance, ptldist1) > 0)
                              found_two += 1;
                           }
                        if(found_two > 1)
                           {
                           found_one = 1;
                           break;
                           }
                        }
                     rln = rln->next;
                     }

/*** try matching segments with area features if haven't already resolved the requirement ***/
                  if(found_two < 2)
                     {
                     ran = Aroot;
                     while(ran != NULL)
                        { 
                        if((CombinedCheckApplies(ran->idn,checkinstance,COINCIDEFAIL,ran->Lindex,ran->Sindex,
                             SCCtable[ran->Sindex].C,SCCtable[ran->Sindex].S,SCCtable[ran->Sindex].D,
                               &part1,&part2,&part3) > 0) && (part2 > 0))
                           { 
                           if(ran->RB_Tree_Edgelist == NULL)
                              {
                              for(ii=0; ii<ran->numverts; ii++)
                                 {
                                 if(ii == 0) 
                                    jj = ran->numverts - 1;
                                 else
                                    jj = ii - 1;
                                 checkit2 = 0;
                                 if(ran->ismulti == 0)
                                    checkit2 = 1;
                                 else if((ran->x[jj] < ran->x[ii]) && (ran->x[jj] <= maxx) && (ran->x[ii] >= minx))
                                    {
                                    if((ran->y[jj] < ran->y[ii]) && (ran->y[jj] <= maxy) && (ran->y[ii] >= miny))
                                       checkit2 = 1;
                                    else if((ran->y[ii] <= maxy) && (ran->y[jj] >= miny))
                                       checkit2 = 1;
                                    }
                                 else if((ran->x[ii] <= maxx) && (ran->x[jj] >= minx))
                                    { 
                                    if((ran->y[jj] < ran->y[ii]) && (ran->y[jj] <= maxy) && (ran->y[ii] >= miny))
                                       checkit2 = 1;
                                    else if((ran->y[ii] <= maxy) && (ran->y[jj] >= miny))
                                       checkit2 = 1;
                                    }
                                 if(checkit2 > 0)
                                    {
                                    if(LineSegmentsOverlap(rlc->x[j],rlc->y[j],rlc->x[i],rlc->y[i],
                                                 ran->x[jj],ran->y[jj],ran->x[ii],ran->y[ii],
                                                 &xi, &yi, &xi2, &yi2, ActiveChecks[checkinstance].sensitivity) > 0)
                                       {
                                       found_two += 1;
                                       break; /*** breaks from the for ii loop ***/
                                       }
                                    }
                                 }
                              }
                           else /**** a rb-tree, large areal ***/
                              {
                              LastEdge = NULL;
                              LastI = -1;
                              ii = GetNextArealIndex(ran, LastI, 1, &LastEdge, cindex, &unusedint);
                              LastI = ii;
                              while(ii >= 0)
                                 {
                                 if(ii == 0)
                                    jj = ran->numverts - 1;
                                 else
                                    jj = ii - 1;
                                 checkit2 = 0;
                                 if(ran->ismulti == 0)
                                    checkit2 = 1;
                                 else if((ran->x[jj] < ran->x[ii]) && (ran->x[jj] <= maxx) && (ran->x[ii] >= minx))
                                    {
                                    if((ran->y[jj] < ran->y[ii]) && (ran->y[jj] <= maxy) && (ran->y[ii] >= miny))
                                       checkit2 = 1;
                                    else if((ran->y[ii] <= maxy) && (ran->y[jj] >= miny))
                                       checkit2 = 1;
                                    }
                                 else if((ran->x[ii] <= maxx) && (ran->x[jj] >= minx))
                                    {
                                    if((ran->y[jj] < ran->y[ii]) && (ran->y[jj] <= maxy) && (ran->y[ii] >= miny))
                                       checkit2 = 1;
                                    else if((ran->y[ii] <= maxy) && (ran->y[jj] >= miny))
                                       checkit2 = 1;
                                    }
                                 if(checkit2 > 0)
                                    {
                                    if(LineSegmentsOverlap(rlc->x[j],rlc->y[j],rlc->x[i],rlc->y[i],
                                                 ran->x[jj],ran->y[jj],ran->x[ii],ran->y[ii],
                                                 &xi, &yi, &xi2, &yi2, ActiveChecks[checkinstance].sensitivity) > 0)
                                       {
                                       found_two += 1;
                                       break; /*** breaks from the while ii loop ***/
                                       }
                                    }
                                 ii = GetNextArealIndex(ran, LastI, 1, &LastEdge, cindex, &unusedint);
                                 LastI = ii;
                                 }
                              }
                           }
                        if(found_two > 1)
                           {
                           found_one = 1;
                           break;
                           }
                        ran = ran->next;
                        }
                     }
                  }  /*** end if segment is in this lm  (checkit > 0) ***/
               if(found_two > 1)
                  break;
               } /*** end for(i=0; i<rlc->numverts; i++) ***/

            if(rlc->IsMulti == 0) /** if is a single region feature, know everything required now ... ***/
               {
               if(found_two < 2) /** couldn't find specified point or line object in this area feature **/
                  {
                  ERc = (struct collection *) (malloc(SzC));
                  if(ERc == NULL)
                     {
                     printf("allocation memory exhausted during area feature condition analysis\n");
                     printf("processing cannot continue\n");
                     exit(-1);
                     }
                  ERc->magnitude = 0;
                  ERc->keyval = COINCIDEFAIL; 
                  ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                  ERc->Sindex = rlc->Sindex;
                  ERc->ll1 = rlc;
                  ERc->next = NULL;
                  if(ERroot == NULL)
                     {
                     ERroot = ERc;
                     }
                  else
                     {
                     ERn = ERroot;
                     while(ERn != NULL)
                        {
                        if((ERn->Cnumber == ERc->Cnumber) && (ERn->keyval == ERc->keyval) && (ERn->ll1 == ERc->ll1))
                           break;
                        ERn = ERn->next;
                        }
                     if(ERn == NULL)
                        {
                        ERc->next = ERroot;
                        ERroot = ERc;
                        }
                     else
                        free(ERc);
                     }
                  }
               }
            else /*** must be a multi-region line feature ... ****/
               {
               RB_newKey2 = rlc->localID + checkinstance * 0.0001;
               if(( RB_newNode = RBExactQuery(Check_RB_Tree,&RB_newKey2)))
                  {
                  RB_cond = (struct ConditionCollection *) RB_newNode->info;
                  if(RB_cond->counter < 2)
                     RB_cond->counter += found_two;
                  }
               else
                  {
                  RB_cond = (struct ConditionCollection *) (malloc(SzCC));
                  if(RB_cond == NULL)
                     {
                     printf("memory has been exhausted during RB-Tree information alloction for COINCIDEFAIL analysis\n");
                     exit(-1);
                     }
                  RB_cond->keyval = COINCIDEFAIL;
                  RB_cond->Cnumber =  Make_Correct(COINCIDEFAIL,checkinstance);
                  RB_cond->index_from_to = NULL;
                  RB_cond->gform = G_LINE;
                  RB_cond->featureidn = rlc->featureid;
                  RB_cond->localID = rlc->localID;
                  RB_cond->counter = found_two;
                  RB_cond->radius = -1;
                  RB_cond->height = -1;
                  RB_cond->magnitude = 0.0;
                  RB_cond->IDN = rlc->idn;
                  RB_cond->Sindex = rlc->Sindex;
                  RB_cond->Lindex = rlc->Lindex;

                  RB_cond->numnodes = rlc->numnodes;
                  RB_cond->x = (double *) (malloc(RB_cond->numnodes * SzD));
                  RB_cond->y = (double *) (malloc(RB_cond->numnodes * SzD));
                  RB_cond->z = (double *) (malloc(RB_cond->numnodes * SzD));
                  if(RB_cond->z == NULL)
                     {
                     printf("memory has been exhausted during RB-Tree element vertex alloction for COINCIDEFAIL analysis\n");
                     exit(-1);
                     }
                  for(jj=0; jj< rlc->numnodes; jj++)
                     {
                     RB_cond->x[jj] = rlc->x[jj];
                     RB_cond->y[jj] = rlc->y[jj];
                     RB_cond->z[jj] = rlc->z[jj];
                     }

                  RB_newDbl = (double *) (malloc(SzD));
                  if(RB_newDbl == NULL)
                     {
                     printf("memory has been exhausted during RB-Tree alloction for COINCIDEFAIL analysis\n");
                     exit(-1);
                     }
                  *RB_newDbl = RB_newKey2; /**rac->localID; **/
                  RBTreeInsert(Check_RB_Tree,RB_newDbl, RB_cond);
                  } /*** end treating multi-region area for COINCIDEFAIL ***/
               }
            } /*** end COINCIDEFAIL check for line features **/





         if((CombinedCheckApplies(rlc->idn,checkinstance,CONNECTFAIL,rlc->Lindex,rlc->Sindex,Config1,Strat1,Domain1,&part1,&part2,&part3) > 0) &&
                     (part1 > 0))
            {
            mindist = 100000.0;
            if(rlc->IsMulti >= 1) /** a multi-region line - may have checked before ***/
               {
               RB_newKey2 = rlc->idn + (checkinstance * 0.0001);
               if(( RB_newNode = RBExactQuery(Check_RB_Tree,&RB_newKey2)))
                  {
                  RB_cond = (struct ConditionCollection *) RB_newNode->info;
                  if((RB_cond->radius > 0) && (RB_cond->height > 0))
                     {
                     isclose = RB_cond->counter;
                     mindist = 0.0;
                     Vcover[0] = Vcover[1] = 1;
                     }
                  }
               }
            if(mindist > 10) /*** then did not find it as already solved ***/
               {
               Vcover[0] = Vcover[1] = 0;
               isclose = 0;
               ii = 0;
               while(ii < rlc->numnodes)
                  {
                  if((rlc->x[ii] >= minx) && (rlc->x[ii] <= maxx) && (rlc->y[ii] >= miny) && (rlc->y[ii] <= maxy))
                     {
                     rpc = Proot;
                     while(rpc != NULL)
                        {
                        Config2 = SCCtable[rpc->Sindex].C;
                        Strat2 = SCCtable[rpc->Sindex].S;
                        Domain2 = SCCtable[rpc->Sindex].D;
                        if((rpc->numverts == -1) && /** rpc is a pure point ***/
                          (CombinedCheckApplies(rpc->idn,checkinstance,CONNECTFAIL,rpc->Lindex,rpc->Sindex,Config2,Strat2,Domain2,&part1,&part2,&part3) > 0) &&
                              (part2 > 0))
                           {
                           if((rpc->x[0] >= minx) && (rpc->x[0] <= maxx) && (rpc->y[0] >= miny) && (rpc->y[0] <= maxy))
                              {
                              ptldist = Distance(rlc->x[ii],rlc->y[ii],rpc->x[0],rpc->y[0]);
                              if(SensitivityCheck(LTEQ, CONNECTFAIL, checkinstance, ptldist) > 0)
                                 {
                                 if(ii == 0)
                                    Vcover[0] = 1;
                                 else
                                    Vcover[1] = 1;
                                 isclose += 1;
                                 break;
                                 }
                              }
                           }
                        rpc = rpc->next;
                        } /*** end while looking at points ***/

                     if(((ii == 0) && (Vcover[0] < 1)) || ((ii > 0) && (Vcover[1] < 1)))
                        {
                        rln = root;
                        while(rln != NULL)
                           {
                           Config2 = SCCtable[rln->Sindex].C;
                           Strat2 = SCCtable[rln->Sindex].S;
                           Domain2 = SCCtable[rln->Sindex].D;
                           if((rln != rlc) && 
                                 (CombinedCheckApplies(rln->idn,checkinstance,CONNECTFAIL,rln->Lindex,rln->Sindex,Config2,Strat2,Domain2,&part1,&part2,&part3) > 0))
                              {
                              if(part2 > 0)
                                 {
                                 for(j=0; j<rln->numnodes; j++)
                                    {
                                    if((rln->x[j] >= minx) && (rln->x[j] <= maxx) && (rln->y[j] >= miny) && (rln->y[j] <= maxy))
                                       {
                                       ptldist = Distance(rlc->x[ii], rlc->y[ii], rln->x[j], rln->y[j]);
                                       if(SensitivityCheck(LTEQ, CONNECTFAIL, checkinstance, ptldist) > 0)
                                          {
                                          isclose += 1;
                                          if(ii == 0)
                                             Vcover[0] = 1;
                                          else
                                             Vcover[1] = 1;
                                          if((ii == 0) && (Vcover[0] > 0))
                                             break;
                                          else if((ii > 0) && (Vcover[1] > 0))
                                             break;
                                          } /**** end if(SensitivityCheck****/
                                       }
                                    } /*** end for(j=1; j<rln->numnodes; j++) ***/
                                 if((ii == 0) && (Vcover[0] > 0))
                                    break;
                                 else if((ii > 0) && (Vcover[1] > 0))
                                    break;
                                 }
                              }
                           rln = rln->next;
                           }
                        }

                     if(((ii == 0) && (Vcover[0] < 1)) || ((ii > 0) && (Vcover[1] < 1)))
                        {
                        rac = Aroot;
                        while((rac != NULL) && (isclose < 2))
                           {
                           Config2 = SCCtable[rac->Sindex].C;
                           Strat2 = SCCtable[rac->Sindex].S;
                           Domain2 = SCCtable[rac->Sindex].D;
                           if((CombinedCheckApplies(rac->idn,checkinstance,CONNECTFAIL,rac->Lindex,rac->Sindex,Config2,Strat2,Domain2,&part1,&part2,&part3) > 0)
                                && (part2 > 0))
                              {
                              for(j=0; j<rac->numverts; j++)
                                 {
                                 if((rac->x[j] >= minx) && (rac->x[j] <= maxx) && (rac->y[j] >= miny) && (rac->y[j] <= maxy))
                                    {
                                    ptldist = Distance(rlc->x[ii], rlc->y[ii], rac->x[j],rac->y[j]);
                                    if(SensitivityCheck(LTEQ, CONNECTFAIL, checkinstance, ptldist) > 0) 
                                       {
                                       isclose += 1;
                                       if(ii == 0)
                                          Vcover[0] = 1;
                                       else
                                          Vcover[1] = 1;
                                       if((ii == 0) && (Vcover[0] > 0))
                                          break;
                                       else if((ii > 0) && (Vcover[1] > 0))
                                          break;
                                       }
                                    }
                                 }
                              }
                           if((ii == 0) && (Vcover[0] > 0))
                              break;
                           else if((ii > 0) && (Vcover[1] > 0))
                              break;
                           rac = rac->next;
                           }
                        }
                     } /** end if((rlc->x[ii] >= minx) && ....   ***/
                  ii += rlc->numnodes - 1;
                  } /** end (ii=0; **/

               if((rlc->IsMulti == 0) && ((Vcover[0] < 1) || (Vcover[1] < 1)))
                  {
                  ERc = (struct collection *) (malloc(SzC));
                  if(ERc == NULL)
                     {
                     printf("allocation memory exhausted during line feature condition analysis\n");
                     printf("processing cannot continue\n");
                     exit(-1);
                     }
                  if(Vcover[0] < 1)
                     {
                     ERc->x[0] = rlc->x[0];
                     ERc->y[0] = rlc->y[0];
                     ERc->z[0] = rlc->z[0];
                     ERc->x[1] = rlc->x[1];
                     ERc->y[1] = rlc->y[1];
                     ERc->z[1] = rlc->z[1];
                     }
                  else
                     {
                     ERc->x[0] = rlc->x[rlc->numnodes-1];
                     ERc->y[0] = rlc->y[rlc->numnodes-1];
                     ERc->z[0] = rlc->z[rlc->numnodes-1];
                     ERc->x[1] = rlc->x[rlc->numnodes-2];
                     ERc->y[1] = rlc->y[rlc->numnodes-2];
                     ERc->z[1] = rlc->z[rlc->numnodes-2];
                     }
                  ERc->magnitude = 0;
                  ERc->keyval = CONNECTFAIL;
                  ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                  ERc->Sindex = rlc->Sindex;
                  ERc->ll1 = rlc;
                  ERc->next = NULL;
                  if(ERroot == NULL)
                     {
                     ERroot = ERc;
                     }
                  else
                    {
                      ERn = ERroot;
                      while(ERn != NULL)
                        {
                          if((ERn->ll1 == ERc->ll1) && (ERn->Cnumber  == ERc->Cnumber)  && (ERn->keyval  == ERc->keyval))
                             {
                             if((ERn->x[0]   == ERc->x[0])   && (ERn->y[0]   == ERc->y[0])   &&
                                        (ERn->Sindex == ERc->Sindex))
                               {
                                  break;
                               }
                            }
                          ERn = ERn->next;
                        }
                     if(ERn == NULL)
                        {
                        ERc->next = ERroot;
                        ERroot = ERc;
                        }
                     else
                        {
                        free(ERc);
                        } 
                     }
                  }
               else if(rlc->IsMulti > 0)
                  {
                  RB_newKey2 = rlc->idn + (checkinstance * 0.0001);
                  if(( RB_newNode = RBExactQuery(Check_RB_Tree,&RB_newKey2)))
                     {
                     RB_cond = (struct ConditionCollection *) RB_newNode->info;
                     if(Vcover[0] > 0)
                        RB_cond->radius += 1;
                     if(Vcover[1] > 0)
                        RB_cond->height += 1;
   
                     RB_cond->counter += isclose;
                     }
                  else
                     {
                     RB_cond = (struct ConditionCollection *) (malloc(SzCC));
                     if(RB_cond == NULL)
                        {
                        printf("memory has been exhausted during RB-Tree information alloction for CONNECTFAIL analysis\n");
                        exit(-1);
                        }
                     RB_cond->keyval = CONNECTFAIL;
                     RB_cond->Cnumber =  Make_Correct(CONNECTFAIL,checkinstance);
                     RB_cond->index_from_to = NULL;
                     RB_cond->gform = G_LINE;
                     RB_cond->featureidn = rlc->featureid;
                     RB_cond->localID = rlc->localID;
                     RB_cond->counter = isclose;
                     if(Vcover[0] > 0)
                        RB_cond->radius = 1;
                     else
                        RB_cond->radius = 0;
                     if(Vcover[1] > 0)
                        RB_cond->height = 1;
                     else
                        RB_cond->height = 0;
                     RB_cond->magnitude = 0.0;
                     RB_cond->IDN = rlc->idn;
                     RB_cond->Sindex = rlc->Sindex;
                     RB_cond->Lindex = rlc->Lindex;

                     RB_cond->numnodes = 4;
                     RB_cond->x = (double *) (malloc(4 * SzD));
                     RB_cond->y = (double *) (malloc(4 * SzD));
                     RB_cond->z = (double *) (malloc(4 * SzD));
                     if(RB_cond->z == NULL)
                        {
                        printf("memory has been exhausted during RB-Tree element vertex alloction for CONNECTFAIL analysis\n");
                        exit(-1);
                        }
                     for(jj=0; jj< 2; jj++)
                        {
                        RB_cond->x[jj] = rlc->x[jj];
                        RB_cond->y[jj] = rlc->y[jj];
                        RB_cond->z[jj] = rlc->z[jj];
                        }
                     RB_cond->x[2] = rlc->x[rlc->numnodes-1];
                     RB_cond->y[2] = rlc->y[rlc->numnodes-1];
                     RB_cond->z[2] = rlc->z[rlc->numnodes-1];
                     RB_cond->x[3] = rlc->x[rlc->numnodes-2];
                     RB_cond->y[3] = rlc->y[rlc->numnodes-2];
                     RB_cond->z[3] = rlc->z[rlc->numnodes-2];

                  RB_newDbl = (double *) (malloc(SzD));
                  if(RB_newDbl == NULL)
                     {
                     printf("memory has been exhausted during RB-Tree alloction for CONNECTFAIL analysis\n");
                     exit(-1);
                     }
                  *RB_newDbl = RB_newKey2; /**rac->localID; **/
                  RBTreeInsert(Check_RB_Tree,RB_newDbl, RB_cond);
                     }
                  }

               } /** end if(mindist > ... ***/

            } /** end CONNECTFAIL check for primary line feature ***/




         if(CombinedCheckApplies(rlc->idn,checkinstance,NONODEOVLP,rlc->Lindex,rlc->Sindex,Config1,Strat1,Domain1,&part1,&part2,&part3) > 0)
            {
            if(part1 > 0)
               {
               /**rln = root; ***/
               tempsensitivity = FindRelevantSensitivity(NONODEOVLP,checkinstance,&unuseddbl);
               rln = root; /***rlc->next;***/
               while(rln != NULL)
                  {
                  if(rln == rlc)
                     {
                     if(rlc->next == NULL)
                        break;
                     else
                        rln = rlc->next;
                     }
                  Config2 = SCCtable[rln->Sindex].C;
                  Strat2 = SCCtable[rln->Sindex].S;
                  Domain2 = SCCtable[rln->Sindex].D;
                  if(CombinedCheckApplies(rln->idn,checkinstance,NONODEOVLP,rln->Lindex,rln->Sindex,Config2,Strat2,Domain2,&part1,&part2,&part3) > 0)
                     {
                     if(part2 > 0)
                        {
                        for(i=1; i<rlc->numnodes; i++)
                           {
                           ii = i - 1;
                           if(rlc->x[i] < rlc->x[ii])
                              {
                              minLx = rlc->x[i];
                              maxLx = rlc->x[ii];
                              }
                           else
                              {
                              minLx = rlc->x[ii];
                              maxLx = rlc->x[i];
                              }
                           if(rlc->y[i] < rlc->y[ii])
                              {
                              minLy = rlc->y[i];
                              maxLy = rlc->y[ii];
                              }
                           else
                              {
                              minLy = rlc->y[ii];
                              maxLy = rlc->y[i];
                              }
                           x1 = rlc->x[ii];
                           y1 = rlc->y[ii];
                           z1 = rlc->z[ii];
                           x2 = rlc->x[i];
                           y2 = rlc->y[i];
                           z2 = rlc->z[i];
                           if(ClipLineToRegion(minx,miny,maxx,maxy,&x1,&y1,&z1,&x2,&y2,&z2,&clipflag,multiplier) > 0)
                              {
                              for(j=1; j<rln->numnodes; j++)
                                 {
                                 jj = j - 1;
                                 x3 = rln->x[jj];
                                 y3 = rln->y[jj];
                                 z3 = rln->z[jj];
                                 x4 = rln->x[j];
                                 y4 = rln->y[j];
                                 z4 = rln->z[j];
                                 if(ClipLineToRegion(minx,miny,maxx,maxy,&x3,&y3,&z3,&x4,&y4,&z4,&clipflag,multiplier) > 0)
                                    {
                                    keepit = 0;
                                    if(rln->x[j] < rln->x[jj])
                                       {
                                       x1 = rln->x[j];
                                       x2 = rln->x[jj];
                                       }
                                    else
                                       {
                                       x1 = rln->x[jj];
                                       x2 = rln->x[j];
                                       }
                                    if(rln->y[j] < rln->y[jj])
                                       {
                                       y1 = rln->y[j];
                                       y2 = rln->y[jj];
                                       }
                                    else
                                       {
                                       y1 = rln->y[jj];
                                       y2 = rln->y[j];
                                       }

                                    if(((StrictlyBetween(rlc->x[ii],rlc->y[ii],rln->x[jj], rln->y[jj], rln->x[j],rln->y[j]) > 0) ||
                                            (StrictlyBetween(rlc->x[i],rlc->y[i],rln->x[jj], rln->y[jj], rln->x[j],rln->y[j]) > 0)) &&
                                       (MergeSeg_LineSegmentsOverlap(rlc->x[ii],rlc->y[ii],rlc->x[i],rlc->y[i],
                                               rln->x[jj], rln->y[jj], rln->x[j],rln->y[j], minLx, maxLx, minLy, maxLy,
                                               &xi1, &yi1, &xi, &yi, tempsensitivity) > 0))
                                       {
                                       keepit = 1;
                                       if((EqualWithinTolerance(minLx,minLy,x1,y1,tempsensitivity) > 0) &&
                                             (EqualWithinTolerance(maxLx,maxLy,x2,y2,tempsensitivity) > 0))
                                             keepit = 0;
                                       }

                                    if(keepit > 0)
                                       {
                                       ERc = (struct collection *) (malloc(SzC));
                                       if(ERc == NULL)
                                          {
                                          printf("allocation memory exhausted during linear feature condition analysis\n");
                                          printf("processing cannot continue\n");
                                          exit(-1);
                                          }
                                       if(StrictlyBetween(rlc->x[ii],rlc->y[ii],rln->x[jj], rln->y[jj], rln->x[j],rln->y[j]) > 0)
                                          {
                                          ERc->x[0] = rlc->x[ii];
                                          ERc->y[0] = rlc->y[ii];
                                          }
                                       else
                                          {
                                          ERc->x[0] = rlc->x[i];
                                          ERc->y[0] = rlc->y[i];
                                          }
                                       /**ERc->x[0] = xi;
                                       ERc->y[0] = yi;**/
                                       ERc->magnitude = 0.0;
                                       ERc->keyval = NONODEOVLP;
                                       ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                                       ERc->IDN = rlc->idn;
                                       ERc->Sindex = rlc->Sindex;
                                       ERc->ll1 = rlc;
                                       ERc->vertexindex1 = ii;
                                       ERc->vertexindex1 = ii;
                                       ERc->ll2 = rln;
                                       ERc->vertexindex2 = jj;
                                       ERc->pp = NULL;
                                       ERc->aa = NULL;
                                       ERc->next = NULL;
                                       if(ERroot == NULL)
                                          {
                                          ERc->z[0] = InterpLinearElev(x1,y1,z1,x2,y2,z2,xi,yi);
                                          ERroot = ERc;
                                          }
                                       else
                                          {
                                          ERn = ERroot;
                                          while(ERn != NULL)
                                             {
                                               if((ERn->Cnumber == ERc->Cnumber) && (ERn->keyval == ERc->keyval) &&
                                                  (ERn->x[0] == ERc->x[0]) && (ERn->y[0] == ERc->y[0]) &&
                                                  (( (ERn->ll1 == ERc->ll1) && (ERn->ll2 == ERc->ll2)) ||
                                                   ((ERn->ll1 == ERc->ll2) && (ERn->ll2 == ERc->ll1))))
                                                break;

                                             ERn = ERn->next;
                                             }
                                          if(ERn == NULL)
                                             {
                                             ERc->z[0] = InterpLinearElev(x1,y1,z1,x2,y2,z2,xi,yi);
                                             ERc->next = ERroot;
                                             ERroot = ERc;
                                             }
                                          else
                                            free(ERc);
                                         }
                                       }

                                    }
                                 }
                              }
                           }
                        }
                     }
                  rln = rln->next;
                  }

               rac = Aroot;
               while(rac != NULL)
                  {
                  Config2 = SCCtable[rac->Sindex].C;
                  Strat2 = SCCtable[rac->Sindex].S;
                  Domain2 = SCCtable[rac->Sindex].D;
                  if(CombinedCheckApplies(rac->idn,checkinstance,NONODEOVLP,rac->Lindex,rac->Sindex,Config2,Strat2,Domain2,&part1,&part2,&part3) > 0)
                     {
                     if(part2 > 0)
                        {
                        if(rac->RB_Tree_Edgelist == NULL)
                           {
                           for(i=1; i<rlc->numnodes; i++)
                              {
                              ii = i - 1;
                              if(rlc->x[i] < rlc->x[ii])
                                 {
                                 minLx = rlc->x[i];
                                 maxLx = rlc->x[ii];
                                 }
                              else
                                 {
                                 minLx = rlc->x[ii];
                                 maxLx = rlc->x[i];
                                 }
                              if(rlc->y[i] < rlc->y[ii])
                                 {
                                 minLy = rlc->y[i];
                                 maxLy = rlc->y[ii];
                                 }
                              else
                                 {
                                 minLy = rlc->y[ii];
                                 maxLy = rlc->y[i];
                                 }

                              x1 = rlc->x[ii];
                              y1 = rlc->y[ii];
                              z1 = rlc->z[ii];
                              x2 = rlc->x[i];
                              y2 = rlc->y[i];
                              z2 = rlc->z[i];
                              if(ClipLineToRegion(minx,miny,maxx,maxy,&x1,&y1,&z1,&x2,&y2,&z2,&clipflag,multiplier) > 0)
                                 {
                                 for(j=1; j<rac->numverts; j++)
                                    {
                                    jj = j - 1;
                                    x3 = rac->x[jj];
                                    y3 = rac->y[jj];
                                    z3 = rac->z[jj];
                                    x4 = rac->x[j];
                                    y4 = rac->y[j];
                                    z4 = rac->z[j];
                                    if(ClipLineToRegion(minx,miny,maxx,maxy,&x3,&y3,&z3,&x4,&y4,&z4,&clipflag,multiplier) > 0)
                                       {
                                       keepit = 0;
                                       if(((StrictlyBetween(rlc->x[ii],rlc->y[ii],rac->x[jj], rac->y[jj], rac->x[j],rac->y[j]) > 0) ||
                                            (StrictlyBetween(rlc->x[i],rlc->y[i],rac->x[jj], rac->y[jj], rac->x[j],rac->y[j]) > 0)) &&
                                          (MergeSeg_LineSegmentsOverlap(rlc->x[ii],rlc->y[ii],rlc->x[i],rlc->y[i],
                                               rac->x[jj], rac->y[jj], rac->x[j],rac->y[j], minLx, maxLx, minLy, maxLy,
                                               &xi1, &yi1, &xi, &yi, tempsensitivity) > 0))
                                          {
                                          keepit = 1;
                                          if(rac->x[j] < rac->x[jj])
                                             {
                                             x1 = rac->x[j];
                                             x2 = rac->x[jj];
                                             }
                                          else
                                             {
                                             x1 = rac->x[jj];
                                             x2 = rac->x[j];
                                             }
                                          if(rac->y[j] < rac->y[jj])
                                             {
                                             y1 = rac->y[j];
                                             y2 = rac->y[jj];
                                             }
                                          else
                                             {
                                             y1 = rac->y[jj];
                                             y2 = rac->y[j];
                                             }
                                          if((EqualWithinTolerance(minLx,minLy,x1,y1,tempsensitivity) > 0) &&
                                                (EqualWithinTolerance(maxLx,maxLy,x2,y2,tempsensitivity) > 0))
                                                keepit = 0;

                                             
                                          if(keepit > 0)
                                             {
                                             ERc = (struct collection *) (malloc(SzC));
                                             if(ERc == NULL)
                                                {
                                                printf("allocation memory exhausted during linear feature condition analysis\n");
                                                printf("processing cannot continue\n");
                                                exit(-1);
                                                }

                                             if(StrictlyBetween(rlc->x[ii],rlc->y[ii],rac->x[jj], rac->y[jj], rac->x[j],rac->y[j]) > 0)
                                                {
                                                ERc->x[0] = rlc->x[ii];
                                                ERc->y[0] = rlc->y[ii];
                                                }
                                             else
                                                {
                                                ERc->x[0] = rlc->x[i];
                                                ERc->y[0] = rlc->y[i];
                                                }
                                             if(jj == rac->numverts - 1)
                                                {
                                                ERc->x[2] = rac->x[0];
                                                ERc->y[2] = rac->y[0];
                                                ERc->z[2] = rac->z[0];
                                                ERc->x[3] = rac->x[rac->numverts - 1];
                                                ERc->y[3] = rac->y[rac->numverts - 1];
                                                ERc->z[3] = rac->z[rac->numverts - 1];
                                                }
                                             else
                                                {
                                                ERc->x[2] = rac->x[jj];
                                                ERc->y[2] = rac->y[jj];
                                                ERc->z[2] = rac->z[jj];
                                                ERc->x[3] = rac->x[jj + 1];
                                                ERc->y[3] = rac->y[jj + 1];
                                                ERc->z[3] = rac->z[jj + 1];
                                                }

                                             ERc->magnitude = 0.0;
                                             ERc->keyval = NONODEOVLP;
                                             ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                                             ERc->IDN = rlc->idn;
                                             ERc->Sindex = rlc->Sindex;
                                             ERc->ll1 = rlc;
                                             ERc->vertexindex1 = ii;
                                             ERc->ll2 = NULL;
                                             ERc->pp = NULL;
                                             ERc->aa = rac;
                                             ERc->vertexindex2 = jj;
                                             ERc->next = NULL;
                                             if(ERroot == NULL)
                                                {
                                                ERc->z[0] = InterpLinearElev(x1,y1,z1,x2,y2,z2,xi,yi);
                                                ERroot = ERc;
                                                }
                                             else
                                                {
                                                ERn = ERroot;
                                                while(ERn != NULL)
                                                   {
                                                     if((ERn->Cnumber == ERc->Cnumber) && (ERn->keyval == ERc->keyval) &&
                                                        (ERn->x[0] == ERc->x[0]) && (ERn->y[0] == ERc->y[0]) &&
                                                            (ERn->ll1 == ERc->ll1) && (ERn->aa == ERc->aa))
                                                      break;

                                                   ERn = ERn->next;
                                                   }
                                                if(ERn == NULL)
                                                   {
                                                   ERc->z[0] = InterpLinearElev(x1,y1,z1,x2,y2,z2,xi,yi);
                                                   ERc->next = ERroot;
                                                   ERroot = ERc;
                                                   }
                                                else
                                                  free(ERc);
                                               }
                                             }
                                          }
                                       }
                                    }
                                 }
                              }
                           } /**** end if(rac->RB_Tree_Edgelist == NULL) ****/
                        else /**** a rb-tree, large areal ***/
                           {
                           LastEdge = NULL;
                           LastI = -1;
                           j = GetNextArealIndex(rac, LastI, 1, &LastEdge, cindex, &unusedint);
                           LastI = j;
                           while(j >= 0)
                              {
                              if(j == 0)
                                 jj = rac->numverts - 1;
                              else
                                 jj = j - 1;
                              for(i=1; i<rlc->numnodes; i++)
                                 {
                                 ii = i - 1;
                                 if(rlc->x[i] < rlc->x[ii])
                                    {
                                    minLx = rlc->x[i];
                                    maxLx = rlc->x[ii];
                                    }
                                 else
                                    {
                                    minLx = rlc->x[ii];
                                    maxLx = rlc->x[i];
                                    }
                                 if(rlc->y[i] < rlc->y[ii])
                                    {
                                    minLy = rlc->y[i];
                                    maxLy = rlc->y[ii];
                                    }
                                 else
                                    {
                                    minLy = rlc->y[ii];
                                    maxLy = rlc->y[i];
                                    }

                                 x1 = rlc->x[ii];
                                 y1 = rlc->y[ii];
                                 z1 = rlc->z[ii];
                                 x2 = rlc->x[i];
                                 y2 = rlc->y[i];
                                 z2 = rlc->z[i];
                                 if(ClipLineToRegion(minx,miny,maxx,maxy,&x1,&y1,&z1,&x2,&y2,&z2,&clipflag,multiplier) > 0)
                                    {
                                    if(j > 0)
                                      jj = j - 1;
                                    else
                                      jj = rac->numverts - 1;
                                    x3 = rac->x[jj];
                                    y3 = rac->y[jj];
                                    z3 = rac->z[jj];
                                    x4 = rac->x[j];
                                    y4 = rac->y[j];
                                    z4 = rac->z[j];
                                    if(ClipLineToRegion(minx,miny,maxx,maxy,&x3,&y3,&z3,&x4,&y4,&z4,&clipflag,multiplier) > 0)
                                       {
                                       keepit = 0;
                                       if(((StrictlyBetween(rlc->x[ii],rlc->y[ii],rac->x[jj], rac->y[jj], rac->x[j],rac->y[j]) > 0) ||
                                            (StrictlyBetween(rlc->x[i],rlc->y[i],rac->x[jj], rac->y[jj], rac->x[j],rac->y[j]) > 0)) &&
                                          (MergeSeg_LineSegmentsOverlap(rlc->x[ii],rlc->y[ii],rlc->x[i],rlc->y[i],
                                               rac->x[jj], rac->y[jj], rac->x[j],rac->y[j], minLx, maxLx, minLy, maxLy,
                                               &xi1, &yi1, &xi, &yi, tempsensitivity) > 0))
                                          {
                                          keepit = 1;
                                          if(rac->x[j] < rac->x[jj])
                                             {
                                             x1 = rac->x[j];
                                             x2 = rac->x[jj];
                                             }
                                          else
                                             {
                                             x1 = rac->x[jj];
                                             x2 = rac->x[j];
                                             }
                                          if(rac->y[j] < rac->y[jj])
                                             {
                                             y1 = rac->y[j];
                                             y2 = rac->y[jj];
                                             }
                                          else
                                             {
                                             y1 = rac->y[jj];
                                             y2 = rac->y[j];
                                             }
                                          if((EqualWithinTolerance(minLx,minLy,x1,y1,tempsensitivity) > 0) &&
                                                (EqualWithinTolerance(maxLx,maxLy,x2,y2,tempsensitivity) > 0))
                                                keepit = 0;


                                          if(keepit > 0)
                                             {
                                             ERc = (struct collection *) (malloc(SzC));
                                             if(ERc == NULL)
                                                {
                                                printf("allocation memory exhausted during linear feature condition analysis\n");
                                                printf("processing cannot continue\n");
                                                exit(-1);
                                                }
                                             if(StrictlyBetween(rlc->x[ii],rlc->y[ii],rac->x[jj], rac->y[jj], rac->x[j],rac->y[j]) > 0)
                                                {
                                                ERc->x[0] = rlc->x[ii];
                                                ERc->y[0] = rlc->y[ii];
                                                }
                                             else
                                                {
                                                ERc->x[0] = rlc->x[i];
                                                ERc->y[0] = rlc->y[i];
                                                }
                                             if(jj == rac->numverts - 1)
                                                {
                                                ERc->x[2] = rac->x[0];
                                                ERc->y[2] = rac->y[0];
                                                ERc->z[2] = rac->z[0];
                                                ERc->x[3] = rac->x[rac->numverts - 1];
                                                ERc->y[3] = rac->y[rac->numverts - 1];
                                                ERc->z[3] = rac->z[rac->numverts - 1];
                                                }
                                             else
                                                {
                                                ERc->x[2] = rac->x[jj];
                                                ERc->y[2] = rac->y[jj];
                                                ERc->z[2] = rac->z[jj];
                                                ERc->x[3] = rac->x[jj + 1];
                                                ERc->y[3] = rac->y[jj + 1];
                                                ERc->z[3] = rac->z[jj + 1];
                                                }
                                             ERc->magnitude = 0.0;
                                             ERc->keyval = NONODEOVLP;
                                             ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                                             ERc->IDN = rlc->idn;
                                             ERc->Sindex = rlc->Sindex;
                                             ERc->ll1 = rlc;
                                             ERc->vertexindex1 = ii;
                                             ERc->vertexindex1 = ii;
                                             ERc->ll2 = NULL;
                                             ERc->pp = NULL;
                                             ERc->aa = rac;
                                             ERc->vertexindex2 = jj;
                                             ERc->next = NULL;
                                             if(ERroot == NULL)
                                                {
                                                ERc->z[0] = InterpLinearElev(x1,y1,z1,x2,y2,z2,xi,yi);
                                                ERroot = ERc;
                                                }
                                             else
                                                {
                                                ERn = ERroot;
                                                while(ERn != NULL)
                                                   {
                                                     if((ERn->Cnumber == ERc->Cnumber) && (ERn->keyval == ERc->keyval) &&
                                                        (ERn->x[0] == ERc->x[0]) && (ERn->y[0] == ERc->y[0]) &&
                                                        (ERn->ll1 == ERc->ll1) && (ERn->aa == ERc->aa))
                                                      break;
   
                                                   ERn = ERn->next;
                                                   }
                                                if(ERn == NULL)
                                                   {
                                                   ERc->z[0] = InterpLinearElev(x1,y1,z1,x2,y2,z2,xi,yi);
                                                   ERc->next = ERroot;
                                                   ERroot = ERc;
                                                   }
                                                else
                                                  free(ERc);
                                               }
                                             } /*** end need to record a condition ***/
                                          } /*** end line segments do overlap ***/
                                       } /*** end clip area feature segments to LM boundaries ***/
                                    } /*** end clip line feature segments to LM boundaries ***/
                                 } /*** end for i ...   ***/
                              j = GetNextArealIndex(rac, LastI, 1, &LastEdge, cindex, &unusedint);
                              LastI = j;
                              } /*** end have another large area segment to get ***/
                           }
                        }
                     }
                  rac = rac->next;
                  }


               } /*** end if check applies to rlc as part1 ***/
            }



         if(CombinedCheckApplies(rlc->idn,checkinstance,LLNONODEINT,rlc->Lindex,rlc->Sindex,Config1,Strat1,Domain1,&part1,&part2,&part3) > 0)
            {
            if(part1 > 0)
               {
               tempsensitivity = FindRelevantSensitivity(LLNONODEINT,checkinstance,&unuseddbl);
               rln = root; 
               while(rln != NULL)
                  {
                  if(rln == rlc)
                     {
                     if(rlc->next == NULL)
                        break;
                     else
                        rln = rlc->next;
                     }
                  Config2 = SCCtable[rln->Sindex].C;
                  Strat2 = SCCtable[rln->Sindex].S;
                  Domain2 = SCCtable[rln->Sindex].D;
                  if(CombinedCheckApplies(rln->idn,checkinstance,LLNONODEINT,rln->Lindex,rln->Sindex,
                         Config2,Strat2,Domain2,&part1,&part2,&part3) > 0)
                     {
                     if(part2 > 0)
                        {
                        for(i=1; i<rlc->numnodes; i++)
                           {
                           ii = i - 1;
                           if(rlc->x[i] < rlc->x[ii])
                              {
                              minLx = rlc->x[i];
                              maxLx = rlc->x[ii];
                              }
                           else
                              {
                              minLx = rlc->x[ii];
                              maxLx = rlc->x[i];
                              }
                           if(rlc->y[i] < rlc->y[ii])
                              {
                              minLy = rlc->y[i];
                              maxLy = rlc->y[ii];
                              }
                           else
                              {
                              minLy = rlc->y[ii];
                              maxLy = rlc->y[i];
                              }

                           if((minLx <= maxx) && (maxLx >= minx) && (minLy <= maxy) && (maxLy >= miny))
                              {
                              for(j=1; j<rln->numnodes; j++)
                                 {
                                 jj = j - 1;

                                 checkit = checkit2 = 0;
                                 if(rln->x[j] > rln->x[jj])
                                    {
                                    if((rln->x[j] >= minLx) && (rln->x[jj] <= maxLx))
                                       checkit = 1;
                                    }
                                 else
                                    {
                                    if((rln->x[jj] >= minLx) && (rln->x[j] <= maxLx))
                                       checkit = 2;
                                    }
                                 if(checkit > 0)
                                    {
                                    if(rln->y[j] > rln->y[jj])
                                       {
                                       if((rln->y[j] >= minLy) && (rln->y[jj] <= maxLy))
                                          checkit2 = 1;
                                       }
                                    else
                                       {
                                       if((rln->y[jj] >= minLy) && (rln->y[j] <= maxLy))
                                          checkit2 = 2;
                                       }
                                    if(checkit2 > 0)
                                       {
                                       if(checkit == 1)
                                          {
                                          if(checkit2 == 1) 
                                             {
                                             if((EqualWithinTolerance(rln->x[j],rln->y[j],
                                                                   maxLx,maxLy, tempsensitivity) > 0) && 
                                                (EqualWithinTolerance(rln->x[jj],rln->y[jj],
                                                                   minLx,minLy, tempsensitivity) > 0))
                                                {
                                                checkit2 = 0;
                                                }
                                              }
                                          else if((EqualWithinTolerance(rln->x[j],rln->y[j],
                                                                   maxLx,minLy, tempsensitivity) > 0) &&
                                                (EqualWithinTolerance(rln->x[jj],rln->y[jj],
                                                                   minLx,maxLy, tempsensitivity) > 0))
                                             {
                                             checkit2 = 0;
                                             }
                                          }
                                       else
                                          {
                                          if(checkit2 == 1)
                                             {
                                             if((EqualWithinTolerance(rln->x[j],rln->y[j],
                                                                   minLx,maxLy, tempsensitivity) > 0) &&
                                                (EqualWithinTolerance(rln->x[jj],rln->y[jj],
                                                                   maxLx,minLy, tempsensitivity) > 0))
                                                {
                                                checkit2 = 0;
                                                }
                                              }
                                          else if((EqualWithinTolerance(rln->x[j],rln->y[j],
                                                                   minLx,minLy, tempsensitivity) > 0) &&
                                                (EqualWithinTolerance(rln->x[jj],rln->y[jj],
                                                                   maxLx,maxLy, tempsensitivity) > 0))
                                             {
                                             checkit2 = 0;
                                             }
                                          }
                                       }
                                    if(checkit2 > 0)
                                       {
                                       keepit = 0;

                                       if(PointOnLineSegment(rlc->x[i],rlc->y[i],
                                                       rln->x[j],rln->y[j],rln->x[jj],rln->y[jj], 0.001) > 0)
                                          {
                                          if((EqualWithinTolerance(rlc->x[i],rlc->y[i],
                                                 rln->x[j],rln->y[j],tempsensitivity) == 0) &&
                                            (EqualWithinTolerance(rlc->x[i],rlc->y[i],
                                                 rln->x[jj],rln->y[jj],tempsensitivity) == 0))
                                             {
                                             xi = rlc->x[i];
                                             yi = rlc->y[i];
                                             keepit = 1;
                                             }
                                          }
                                       if((keepit == 0) &&
                                          (PointOnLineSegment(rlc->x[ii],rlc->y[ii],
                                                             rln->x[j],rln->y[j],rln->x[jj],rln->y[jj], 0.001) > 0))
                                          {
                                          if((EqualWithinTolerance(rlc->x[ii],rlc->y[ii],
                                                 rln->x[j],rln->y[j],tempsensitivity) == 0) &&
                                            (EqualWithinTolerance(rlc->x[ii],rlc->y[ii],
                                                  rln->x[jj],rln->y[jj],tempsensitivity) == 0))
                                             {
                                             xi = rlc->x[ii];
                                             yi = rlc->y[ii];
                                             keepit = 1;
                                             }
                                          }
                                       if((keepit == 0) &&
                                          (PointOnLineSegment(rln->x[j],rln->y[j],
                                                             rlc->x[i],rlc->y[i],rlc->x[ii],rlc->y[ii], 0.001) > 0))
                                          {
                                          if((EqualWithinTolerance(rlc->x[ii],rlc->y[ii],
                                                 rln->x[j],rln->y[j],tempsensitivity) == 0) &&
                                            (EqualWithinTolerance(rlc->x[i],rlc->y[i],
                                                   rln->x[j],rln->y[j],tempsensitivity) == 0))
                                             {
                                             xi = rln->x[j];
                                             yi = rln->y[j];
                                             keepit = 1;
                                             }
                                          }
                                       if((keepit == 0) &&
                                          (PointOnLineSegment(rln->x[jj],rln->y[jj],
                                                             rlc->x[i],rlc->y[i],rlc->x[ii],rlc->y[ii], 0.001) > 0))
                                          {
                                          if((EqualWithinTolerance(rlc->x[ii],rlc->y[ii],
                                                 rln->x[jj],rln->y[jj],tempsensitivity) == 0) &&
                                            (EqualWithinTolerance(rlc->x[i],rlc->y[i],
                                                    rln->x[jj],rln->y[jj],tempsensitivity) == 0))
                                             {
                                             xi = rln->x[jj];
                                             yi = rln->y[jj];
                                             keepit = 1;
                                             }
                                          }

                                       if((keepit == 0) &&
                                           (LineSegmentsIntersect(rlc->x[i],rlc->y[i],rlc->x[ii],rlc->y[ii],
                                                rln->x[jj],rln->y[jj],rln->x[j],rln->y[j], &xi, &yi) > 0))
                                          {

                                          keepit = 1;
                                          if(EqualWithinTolerance(rlc->x[ii],rlc->y[ii],xi,yi,tempsensitivity) > 0)
                                             {
                                             if(EqualWithinTolerance(rln->x[jj],rln->y[jj],xi,yi,tempsensitivity) > 0)
                                                keepit = 0;
                                             else if(EqualWithinTolerance(rln->x[j],rln->y[j],xi,yi,tempsensitivity) > 0)
                                                keepit = 0;
                                             }
                                          else if(EqualWithinTolerance(rlc->x[i],rlc->y[i],xi,yi,tempsensitivity) > 0)
                                             {
                                             if(EqualWithinTolerance(rln->x[jj],rln->y[jj],xi,yi,tempsensitivity) > 0)
                                                keepit = 0;
                                             else if(EqualWithinTolerance(rln->x[j],rln->y[j],xi,yi,tempsensitivity) > 0)
                                                keepit = 0;
                                             }
                                          }
                                       if(keepit > 0)
                                          {
                                          keepit = RemoveByContainmentOrCoincidence(xi, yi, root, checkinstance,
                                                 LLNONODEINT, minx, miny, maxx, maxy, tempsensitivity,
                                                 Aroot, Proot);
                                          }
                                       if(keepit > 0)
                                          {
                                          keepit = ConditionOnDataEdge(rlc->x[i],rlc->y[i],rlc->x[ii],rlc->y[ii],Aroot,Proot,root,
                                                NULL, NULL, rlc,
                                                NorthCount,SouthCount,EastCount,WestCount,checkinstance);

                                          }
                                       if(keepit > 0)
                                          {
                                          if((xi < minx) || (xi > maxx) || (yi < miny) || (yi > maxy))
                                             keepit = 0;
                                          }

                                       if(keepit > 0)
                                          {

                                          ERc = (struct collection *) (malloc(SzC));
                                          if(ERc == NULL)
                                             {
                                             printf("allocation memory exhausted during linear feature condition analysis\n");
                                             printf("processing cannot continue\n");
                                             exit(-1);
                                             }
                                          ERc->x[0] = xi;
                                          ERc->y[0] = yi;
                                          ERc->magnitude = 0.0;
                                          ERc->keyval = LLNONODEINT;
                                          ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                                          ERc->IDN = rlc->idn;
                                          ERc->Sindex = rlc->Sindex;
                                          ERc->ll1 = rlc;
                                          ERc->vertexindex1 = ii;
                                          ERc->vertexindex1 = ii;
                                          ERc->ll2 = rln;
                                          ERc->vertexindex2 = jj;
                                          ERc->pp = NULL;
                                          ERc->aa = NULL;
                                          ERc->next = NULL;
                                          if(ERroot == NULL)
                                             {
                                             ERc->z[0] = InterpLinearElev(rlc->x[ii],rlc->y[ii],rlc->z[ii],
                                                                            rlc->x[ii],rlc->y[ii],rlc->z[ii],xi,yi);
                                             ERroot = ERc;
                                             }
                                          else
                                             {
                                             ERn = ERroot;
                                             while(ERn != NULL)
                                                {
                                                if((ERn->Cnumber == ERc->Cnumber) && (ERn->keyval == ERc->keyval) &&
                                                   (EqualWithinTolerance(ERn->x[0],ERn->y[0],ERc->x[0],ERc->y[0],0.000001) > 0) &&
                                                     (( (ERn->ll1 == ERc->ll1) && (ERn->ll2 == ERc->ll2)) ||
                                                      ((ERn->ll1 == ERc->ll2) && (ERn->ll2 == ERc->ll1))))
                                                   break;

                                                ERn = ERn->next;
                                                }
                                             if(ERn == NULL)
                                                {
                                                ERc->z[0] = InterpLinearElev(rlc->x[ii],rlc->y[ii],rlc->z[ii],
                                                                            rlc->x[ii],rlc->y[ii],rlc->z[ii],xi,yi);
                                                ERc->next = ERroot;
                                                ERroot = ERc;
                                                }
                                             else
                                               free(ERc);
                                            }
                                          }
                                       }
                                       
                                    }
                                 }
                              }
                           }
                        }
                     }
                  rln = rln->next;
                  }

               rpc = Proot;
               while(rpc != NULL)
                  {
                  Config2 = SCCtable[rpc->Sindex].C;
                  Strat2 = SCCtable[rpc->Sindex].S;
                  Domain2 = SCCtable[rpc->Sindex].D;
                  if((rpc->numverts == -1) &&
                   (CombinedCheckApplies(rpc->idn,checkinstance,LLNONODEINT,rpc->Lindex,rpc->Sindex,Config2,Strat2,Domain2,&part1,&part2,&part3) > 0))
                     {
                     if(part2 > 0)
                        {
                        for(i=1; i<rlc->numnodes; i++)
                           {
                           ii = i - 1;
                           if(rlc->x[i] < rlc->x[ii])
                              {
                              minLx = rlc->x[i];
                              maxLx = rlc->x[ii];
                              }
                           else
                              {
                              minLx = rlc->x[ii];
                              maxLx = rlc->x[i];
                              }
                           if(rlc->y[i] < rlc->y[ii])
                              {
                              minLy = rlc->y[i];
                              maxLy = rlc->y[ii];
                              }
                           else
                              {
                              minLy = rlc->y[ii];
                              maxLy = rlc->y[i];
                              }

                           if((minLx <= maxx) && (maxLx >= minx) && (minLy <= maxy) && (maxLy >= miny))
                              {
                              ptldist = tempsensitivity + 10;
                              if((rpc->x[0] >= minLx) && (rpc->x[0] <= maxLx) && (rpc->y[0] >= minLy) && (rpc->y[0] <= maxLy))
                                 ptldist = PointToLineDist2D(rpc->x[0],rpc->y[0],rlc->x[ii],rlc->y[ii],rlc->x[i],rlc->y[i]);
                              if(ptldist <= tempsensitivity)
                                 {
                                 keepit = 1;
                                 if(EqualWithinTolerance(rpc->x[0],rpc->y[0],rlc->x[i],rlc->y[i],tempsensitivity) > 0)
                                    {
                                    keepit = 0;
                                    }
                                 else if(EqualWithinTolerance(rpc->x[0],rpc->y[0],rlc->x[ii],rlc->y[ii],tempsensitivity) > 0)
                                    {
                                    keepit = 0;
                                    }


                                 if(keepit > 0)
                                    {
                                    keepit = RemoveByContainmentOrCoincidence(rpc->x[0], rpc->y[0], root, checkinstance,
                                                 LLNONODEINT, minx, miny, maxx, maxy, tempsensitivity,
                                                 Aroot, Proot);
                                    } 
                                 if(keepit > 0)
                                    {
                                    keepit = ConditionOnDataEdge(rlc->x[i],rlc->y[i],rlc->x[ii],rlc->y[ii],Aroot,Proot,root,
                                                NULL, NULL, rlc,
                                                NorthCount,SouthCount,EastCount,WestCount,checkinstance);
                                    }

                                 if(keepit > 0)
                                    {

                                    ERc = (struct collection *) (malloc(SzC));
                                    if(ERc == NULL)
                                       {
                                       printf("allocation memory exhausted during linear feature condition analysis\n");
                                       printf("processing cannot continue\n");
                                       exit(-1);
                                       }
                                    ERc->x[0] = rpc->x[0];
                                    ERc->y[0] = rpc->y[0];
                                    ERc->magnitude = 0.0;
                                    ERc->keyval = LLNONODEINT;
                                    ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                                    ERc->IDN = rlc->idn;
                                    ERc->Sindex = rlc->Sindex;
                                    ERc->ll1 = rlc;
                                    ERc->ll2 = NULL;
                                    ERc->aa = NULL;
                                    ERc->vertexindex1 = ii;
                                    ERc->pp = rpc;
                                    ERc->vertexindex2 = -1;
                                    ERc->next = NULL;
                                    if(ERroot == NULL)
                                       {
                                       ERc->z[0] = InterpLinearElev(rlc->x[ii],rlc->y[ii],rlc->z[ii],
                                                                      rlc->x[i],rlc->y[i],rlc->z[i],rpc->x[0],rpc->y[0]);
                                       ERroot = ERc;
                                       }
                                    else
                                       {
                                       ERn = ERroot;
                                       while(ERn != NULL)
                                          {
                                            if((ERn->Cnumber == ERc->Cnumber) && (ERn->keyval == ERc->keyval) &&
                                               (ERn->x[0] == ERc->x[0]) && (ERn->y[0] == ERc->y[0]) &&
                                               ((ERn->ll1 == ERc->ll1) && (ERn->pp == ERc->pp)))
                                             break;

                                          ERn = ERn->next;
                                          }
                                       if(ERn == NULL)
                                          {
                                          ERc->z[0] = InterpLinearElev(rlc->x[ii],rlc->y[ii],rlc->z[ii],
                                                                      rlc->x[i],rlc->y[i],rlc->z[i],rpc->x[0],rpc->y[0]);
                                          ERc->next = ERroot;
                                          ERroot = ERc;
                                          }
                                       else
                                         free(ERc);
                                      }
                                    }
                                 }
                              }
                           }
                        }
                     }
                  rpc = rpc->next;
                  }

               rac = Aroot;
               while(rac != NULL)
                  {
                  Config2 = SCCtable[rac->Sindex].C;
                  Strat2 = SCCtable[rac->Sindex].S;
                  Domain2 = SCCtable[rac->Sindex].D;
                  if(CombinedCheckApplies(rac->idn,checkinstance,LLNONODEINT,rac->Lindex,rac->Sindex,Config2,Strat2,Domain2,&part1,&part2,&part3) > 0)
                     {
                     if(part2 > 0)
                        {
                        if(rac->RB_Tree_Edgelist == NULL)
                           {
                           for(i=1; i<rlc->numnodes; i++)
                              {
                              keepit = 0;
                              ii = i - 1;

                              if(rlc->x[i] < rlc->x[ii])
                                 {
                                 minLx = rlc->x[i];
                                 maxLx = rlc->x[ii];
                                 }
                              else
                                 {
                                 minLx = rlc->x[ii];
                                 maxLx = rlc->x[i];
                                 }
                              if(rlc->y[i] < rlc->y[ii])
                                 {
                                 minLy = rlc->y[i];
                                 maxLy = rlc->y[ii];
                                 }
                              else
                                 {
                                 minLy = rlc->y[ii];
                                 maxLy = rlc->y[i];
                                 }
                              if((minLx <= maxx) && (maxLx >= minx) && (minLy <= maxy) && (maxLy >= miny))
                                 {
                                 for(j=1; j<rac->numverts; j++)
                                    {
                                    keepit = 0;
                                    jj = j - 1;
                                    checkit = checkit2 = 0;
                                    if(rac->x[j] > rac->x[jj])
                                       {
                                       if((rac->x[j] >= minLx) && (rac->x[jj] <= maxLx))
                                          checkit = 1;
                                       }
                                    else
                                       {
                                       if((rac->x[jj] >= minLx) && (rac->x[j] <= maxLx))
                                          checkit = 2;
                                       }
                                    if(checkit > 0)
                                       {
                                       if(rac->y[j] > rac->y[jj])
                                          {
                                          if((rac->y[j] >= minLy) && (rac->y[jj] <= maxLy))
                                             checkit2 = 1;
                                          }
                                       else
                                          {
                                          if((rac->y[jj] >= minLy) && (rac->y[j] <= maxLy))
                                             checkit2 = 2;
                                          }
                                    if(checkit2 > 0)
                                       {
                                       if(checkit == 1)
                                          {
                                          if(checkit2 == 1)
                                             {
                                             if((EqualWithinTolerance(rac->x[j],rac->y[j],
                                                                   maxLx,maxLy, tempsensitivity) > 0) &&
                                                (EqualWithinTolerance(rac->x[jj],rac->y[jj],
                                                                   minLx,minLy, tempsensitivity) > 0))
                                                {
                                                checkit2 = 0;
                                                }
                                              }
                                          else if((EqualWithinTolerance(rac->x[j],rac->y[j],
                                                                   maxLx,minLy, tempsensitivity) > 0) &&
                                                (EqualWithinTolerance(rac->x[jj],rac->y[jj],
                                                                   minLx,maxLy, tempsensitivity) > 0))
                                             {
                                             checkit2 = 0;
                                             }
                                          }
                                       else
                                          {
                                          if(checkit2 == 1)
                                             {
                                             if((EqualWithinTolerance(rac->x[j],rac->y[j],
                                                                   minLx,maxLy, tempsensitivity) > 0) &&
                                                (EqualWithinTolerance(rac->x[jj],rac->y[jj],
                                                                   maxLx,minLy, tempsensitivity) > 0))
                                                {
                                                checkit2 = 0;
                                                }
                                              }
                                          else if((EqualWithinTolerance(rac->x[j],rac->y[j],
                                                                   minLx,minLy, tempsensitivity) > 0) &&
                                                (EqualWithinTolerance(rac->x[jj],rac->y[jj],
                                                                   maxLx,maxLy, tempsensitivity) > 0))
                                             {
                                             checkit2 = 0;
                                             }
                                          }
                                       }

                                       if(checkit2 > 0)
                                          {
                                             keepit = 0;
                                             if(PointOnLineSegment(rlc->x[i],rlc->y[i],
                                                             rac->x[j],rac->y[j],rac->x[jj],rac->y[jj], 0.001) > 0)
                                                {
                                                if((EqualWithinTolerance(rlc->x[i],rlc->y[i],
                                                       rac->x[j],rac->y[j],tempsensitivity) == 0) &&
                                                  (EqualWithinTolerance(rlc->x[i],rlc->y[i],
                                                       rac->x[jj],rac->y[jj],tempsensitivity) == 0))
                                                   {
                                                   xi = rlc->x[i];
                                                   yi = rlc->y[i];
                                                   keepit = 1;
                                                   }
                                                }
                                             if((keepit == 0) &&
                                                (PointOnLineSegment(rlc->x[ii],rlc->y[ii],
                                                                   rac->x[j],rac->y[j],rac->x[jj],rac->y[jj], 0.001) > 0))
                                                {
                                                if((EqualWithinTolerance(rlc->x[ii],rlc->y[ii],
                                                       rac->x[j],rac->y[j],tempsensitivity) == 0) &&
                                                  (EqualWithinTolerance(rlc->x[ii],rlc->y[ii],
                                                        rac->x[jj],rac->y[jj],tempsensitivity) == 0))
                                                   {
                                                   xi = rlc->x[ii];
                                                   yi = rlc->y[ii];
                                                   keepit = 1;
                                                   }
                                                }
                                             if((keepit == 0) &&
                                                (PointOnLineSegment(rac->x[j],rac->y[j],
                                                             rlc->x[i],rlc->y[i],rlc->x[ii],rlc->y[ii], 0.001) > 0))
                                                {
                                                if((EqualWithinTolerance(rlc->x[ii],rlc->y[ii],
                                                       rac->x[j],rac->y[j],tempsensitivity) == 0) &&
                                                  (EqualWithinTolerance(rlc->x[i],rlc->y[i],
                                                         rac->x[j],rac->y[j],tempsensitivity) == 0))
                                                   {
                                                   xi = rac->x[j];
                                                   yi = rac->y[j];
                                                   keepit = 1;
                                                   }
                                                }
                                             if((keepit == 0) &&
                                                (PointOnLineSegment(rac->x[jj],rac->y[jj],
                                                                   rlc->x[i],rlc->y[i],rlc->x[ii],rlc->y[ii], 0.001) > 0))
                                                {
                                                if((EqualWithinTolerance(rlc->x[ii],rlc->y[ii],
                                                       rac->x[jj],rac->y[jj],tempsensitivity) == 0) &&
                                                  (EqualWithinTolerance(rlc->x[i],rlc->y[i],
                                                          rac->x[jj],rac->y[jj],tempsensitivity) == 0))
                                                   {
                                                   xi = rac->x[jj];
                                                   yi = rac->y[jj];
                                                   keepit = 1;
                                                   }
                                                }


                                             if((keepit > 0) || (LineSegmentsIntersect(rlc->x[i],rlc->y[i],rlc->x[ii],rlc->y[ii],
                                                                                  rac->x[jj],rac->y[jj],rac->x[j],rac->y[j], &xi, &yi) > 0))
                                                {
                                                if(keepit == 0)
                                                   {
                                                   keepit = 1;
                                                   if(EqualWithinTolerance(rlc->x[ii],rlc->y[ii],xi,yi,tempsensitivity) > 0)
                                                      {
                                                      if(EqualWithinTolerance(rac->x[jj],rac->y[jj],xi,yi,tempsensitivity) > 0)
                                                         keepit = 0;
                                                      else if(EqualWithinTolerance(rac->x[j],rac->y[j],xi,yi,tempsensitivity) > 0)
                                                         keepit = 0;
                                                      }
                                                   else if(EqualWithinTolerance(rlc->x[i],rlc->y[i],xi,yi,tempsensitivity) > 0)
                                                      {
                                                      if(EqualWithinTolerance(rac->x[jj],rac->y[jj],xi,yi,tempsensitivity) > 0)
                                                         keepit = 0;
                                                      else if(EqualWithinTolerance(rac->x[j],rac->y[j],xi,yi,tempsensitivity) > 0)
                                                         keepit = 0;
                                                      }
                                                   }

                                                if(keepit > 0)
                                                   {
                                                   keepit = RemoveByContainmentOrCoincidence(xi, yi, root, checkinstance,
                                                          LLNONODEINT, minx, miny, maxx, maxy, tempsensitivity,
                                                          Aroot, Proot);
                                                   }
                                                if(keepit > 0)
                                                   {
                                                   keepit = ConditionOnDataEdge(rlc->x[i],rlc->y[i],rlc->x[ii],rlc->y[ii],Aroot,Proot,root,
                                                         NULL, NULL, rlc,
                                                         NorthCount,SouthCount,EastCount,WestCount,checkinstance);
                                                   }
                                                if(keepit > 0)
                                                   {


                                                   ERc = (struct collection *) (malloc(SzC));
                                                   if(ERc == NULL)
                                                      {
                                                      printf("allocation memory exhausted during linear feature condition analysis\n");
                                                      printf("processing cannot continue\n");
                                                      exit(-1);
                                                      }
                                                   ERc->x[0] = xi;
                                                   ERc->y[0] = yi;
                                                   if(jj == rac->numverts - 1)
                                                      {
                                                      ERc->x[2] = rac->x[0];
                                                      ERc->y[2] = rac->y[0];
                                                      ERc->z[2] = rac->z[0];
                                                      ERc->x[3] = rac->x[rac->numverts - 1];
                                                      ERc->y[3] = rac->y[rac->numverts - 1];
                                                      ERc->z[3] = rac->z[rac->numverts - 1];
                                                      }
                                                   else
                                                      {
                                                      ERc->x[2] = rac->x[jj];
                                                      ERc->y[2] = rac->y[jj];
                                                      ERc->z[2] = rac->z[jj];
                                                      ERc->x[3] = rac->x[jj + 1];
                                                      ERc->y[3] = rac->y[jj + 1];
                                                      ERc->z[3] = rac->z[jj + 1];
                                                      }
      
                                                   ERc->magnitude = 0.0;
                                                   ERc->keyval = LLNONODEINT;
                                                   ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                                                   ERc->IDN = rlc->idn;
                                                   ERc->Sindex = rlc->Sindex;
                                                   ERc->ll1 = rlc;
                                                   ERc->vertexindex1 = ii;
                                                   ERc->ll2 = NULL;
                                                   ERc->pp = NULL;
                                                   ERc->aa = rac;
                                                   ERc->vertexindex2 = jj;
                                                   ERc->next = NULL;
                                                   if(ERroot == NULL)
                                                      {
                                                      ERc->z[0] = InterpLinearElev(rlc->x[ii],rlc->y[ii],rlc->z[ii],rlc->x[i],rlc->y[i],rlc->z[i],xi,yi);
                                                      ERroot = ERc;
                                                      }
                                                   else
                                                      {
                                                      ERn = ERroot;
                                                      while(ERn != NULL)
                                                         {
                                                           if((ERn->Cnumber == ERc->Cnumber) && (ERn->keyval == ERc->keyval) &&
                                                              (ERn->x[0] == ERc->x[0]) && (ERn->y[0] == ERc->y[0]) &&
                                                                  (ERn->ll1 == ERc->ll1) && (ERn->aa == ERc->aa))
                                                            break;
         
                                                         ERn = ERn->next;
                                                         }
                                                      if(ERn == NULL)
                                                         {
                                                         ERc->z[0] = InterpLinearElev(rlc->x[ii],rlc->y[ii],rlc->z[ii],rlc->x[i],rlc->y[i],rlc->z[i],xi,yi);
                                                         ERc->next = ERroot;
                                                         ERroot = ERc;
                                                         }
                                                      else
                                                        free(ERc);
                                                     }
                                                  }
                                                }
                                          }
                                       }
                                    }
                                 }
                              }
                           } /**** end if(rac->RB_Tree_Edgelist == NULL) ****/
                        else /**** a rb-tree, large areal ***/
                           {
                           LastEdge = NULL;
                           LastI = -1;
                           j = GetNextArealIndex(rac, LastI, 1, &LastEdge, cindex, &unusedint);
                           LastI = j;
                           while(j >= 0)
                              {
                              if(j == 0)
                                 jj = rac->numverts - 1;
                              else
                                 jj = j - 1;
                              for(i=1; i<rlc->numnodes; i++)
                                 {
                                 ii = i - 1;

                                 if(rlc->x[i] < rlc->x[ii])
                                    {
                                    minLx = rlc->x[i];
                                    maxLx = rlc->x[ii];
                                    }
                                 else
                                    {
                                    minLx = rlc->x[ii];
                                    maxLx = rlc->x[i];
                                    }
                                 if(rlc->y[i] < rlc->y[ii])
                                    {
                                    minLy = rlc->y[i];
                                    maxLy = rlc->y[ii];
                                    }
                                 else
                                    {
                                    minLy = rlc->y[ii];
                                    maxLy = rlc->y[i];
                                    }
                                 if((minLx <= maxx) && (maxLx >= minx) && (minLy <= maxy) && (maxLy >= miny))
                                    {
                                    checkit = checkit2 = 0;
                                    if(rac->x[j] > rac->x[jj])
                                       {
                                       if((rac->x[j] >= minLx) && (rac->x[jj] <= maxLx))
                                          checkit = 1;
                                       }
                                    else
                                       {
                                       if((rac->x[jj] >= minLx) && (rac->x[j] <= maxLx))
                                          checkit = 2;
                                       }
                                    if(checkit > 0)
                                       {
                                       if(rac->y[j] > rac->y[jj])
                                          {
                                          if((rac->y[j] >= minLy) && (rac->y[jj] <= maxLy))
                                             checkit2 = 1;
                                          }
                                       else
                                          {
                                          if((rac->y[jj] >= minLy) && (rac->y[j] <= maxLy))
                                             checkit2 = 2;
                                          }
                                    if(checkit2 > 0)
                                       {
                                       if(checkit == 1)
                                          {
                                          if(checkit2 == 1)
                                             {
                                             if((EqualWithinTolerance(rac->x[j],rac->y[j],
                                                                   maxLx,maxLy, tempsensitivity) > 0) &&
                                                (EqualWithinTolerance(rac->x[jj],rac->y[jj],
                                                                   minLx,minLy, tempsensitivity) > 0))
                                                {
                                                checkit2 = 0;
                                                }
                                              }
                                          else if((EqualWithinTolerance(rac->x[j],rac->y[j],
                                                                   maxLx,minLy, tempsensitivity) > 0) &&
                                                (EqualWithinTolerance(rac->x[jj],rac->y[jj],
                                                                   minLx,maxLy, tempsensitivity) > 0))
                                             {
                                             checkit2 = 0;
                                             }
                                          }
                                       else
                                          {
                                          if(checkit2 == 1)
                                             {
                                             if((EqualWithinTolerance(rac->x[j],rac->y[j],
                                                                   minLx,maxLy, tempsensitivity) > 0) &&
                                                (EqualWithinTolerance(rac->x[jj],rac->y[jj],
                                                                   maxLx,minLy, tempsensitivity) > 0))
                                                {
                                                checkit2 = 0;
                                                }
                                              }
                                          else if((EqualWithinTolerance(rac->x[j],rac->y[j],
                                                                   minLx,minLy, tempsensitivity) > 0) &&
                                                (EqualWithinTolerance(rac->x[jj],rac->y[jj],
                                                                   maxLx,maxLy, tempsensitivity) > 0))
                                             {
                                             checkit2 = 0;
                                             }
                                          }
                                       }

                                       if(checkit2 > 0)
                                          {

                                          keepit = 0;
                                          if(PointOnLineSegment(rlc->x[i],rlc->y[i],
                                                             rac->x[j],rac->y[j],rac->x[jj],rac->y[jj], 0.001) > 0)
                                             {
                                             if((EqualWithinTolerance(rlc->x[i],rlc->y[i],
                                                 rac->x[j],rac->y[j],tempsensitivity) == 0) &&
                                               (EqualWithinTolerance(rlc->x[i],rlc->y[i],
                                                    rac->x[jj],rac->y[jj],tempsensitivity) == 0))
                                                {
                                                xi = rlc->x[i];
                                                yi = rlc->y[i];
                                                keepit = 1;
                                                }
                                             }
                                          if((keepit == 0) &&
                                             (PointOnLineSegment(rlc->x[ii],rlc->y[ii],
                                                             rac->x[j],rac->y[j],rac->x[jj],rac->y[jj], 0.001) > 0))
                                             {
                                             if((EqualWithinTolerance(rlc->x[ii],rlc->y[ii],
                                                    rac->x[j],rac->y[j],tempsensitivity) == 0) &&
                                               (EqualWithinTolerance(rlc->x[ii],rlc->y[ii],
                                                     rac->x[jj],rac->y[jj],tempsensitivity) == 0))
                                                {
                                                xi = rlc->x[ii];
                                                yi = rlc->y[ii];
                                                keepit = 1;
                                                }
                                             }
                                          if((keepit == 0) &&
                                             (PointOnLineSegment(rac->x[j],rac->y[j],
                                                             rlc->x[i],rlc->y[i],rlc->x[ii],rlc->y[ii], 0.001) > 0))
                                             {
                                             if((EqualWithinTolerance(rlc->x[ii],rlc->y[ii],
                                                    rac->x[j],rac->y[j],tempsensitivity) == 0) &&
                                               (EqualWithinTolerance(rlc->x[i],rlc->y[i],
                                                      rac->x[j],rac->y[j],tempsensitivity) == 0))
                                                {
                                                xi = rac->x[j];
                                                yi = rac->y[j];
                                                keepit = 1;
                                                }
                                             }
                                          if((keepit == 0) &&
                                             (PointOnLineSegment(rac->x[jj],rac->y[jj],
                                                             rlc->x[i],rlc->y[i],rlc->x[ii],rlc->y[ii], 0.001) > 0))
                                             {
                                             if((EqualWithinTolerance(rlc->x[ii],rlc->y[ii],
                                                 rac->x[jj],rac->y[jj],tempsensitivity) == 0) &&
                                               (EqualWithinTolerance(rlc->x[i],rlc->y[i],
                                                    rac->x[jj],rac->y[jj],tempsensitivity) == 0))
                                                {
                                                xi = rac->x[jj];
                                                yi = rac->y[jj];
                                                keepit = 1;
                                                }
                                             }


                                          if((keepit > 0) ||
                                            (LineSegmentsIntersect(rlc->x[ii],rlc->y[ii],rlc->x[i],rlc->y[i],rac->x[jj],rac->y[jj],rac->x[j],rac->y[j], &xi, &yi) > 0))
                                             {
                                             if(keepit == 0)
                                                {
                                                keepit = 1;
                                                if(EqualWithinTolerance(rlc->x[ii],rlc->y[ii],xi,yi,tempsensitivity) > 0)
                                                   {
                                                   if(EqualWithinTolerance(rac->x[jj],rac->y[jj],xi,yi,tempsensitivity) > 0)
                                                      keepit = 0;
                                                   else if(EqualWithinTolerance(rac->x[j],rac->y[j],xi,yi,tempsensitivity) > 0)
                                                      keepit = 0;
                                                   }
                                                else if(EqualWithinTolerance(rlc->x[i],rlc->y[i],xi,yi,tempsensitivity) > 0)
                                                   {
                                                   if(EqualWithinTolerance(rac->x[jj],rac->y[jj],xi,yi,tempsensitivity) > 0)
                                                      keepit = 0;
                                                   else if(EqualWithinTolerance(rac->x[j],rac->y[j],xi,yi,tempsensitivity) > 0)
                                                      keepit = 0;
                                                   }
                                                }

                                             if(keepit > 0)
                                                {
                                                keepit = RemoveByContainmentOrCoincidence(xi, yi, root, checkinstance,
                                                    LLNONODEINT, minx, miny, maxx, maxy, tempsensitivity,
                                                    Aroot, Proot);
                                                }
                                             if(keepit > 0)
                                                {
                                                keepit = ConditionOnDataEdge(rlc->x[i],rlc->y[i],rlc->x[ii],rlc->y[ii],Aroot,Proot,root,
                                                      NULL, NULL, rlc,
                                                      NorthCount,SouthCount,EastCount,WestCount,checkinstance);
                                                }
                                             if(keepit > 0)
                                                {

                                                ERc = (struct collection *) (malloc(SzC));
                                                if(ERc == NULL)
                                                   {
                                                   printf("allocation memory exhausted during linear feature condition analysis\n");
                                                   printf("processing cannot continue\n");
                                                   exit(-1);
                                                   }
                                                ERc->x[0] = xi;
                                                ERc->y[0] = yi;
                                                if(jj == rac->numverts - 1)
                                                   {
                                                   ERc->x[2] = rac->x[0];
                                                   ERc->y[2] = rac->y[0];
                                                   ERc->z[2] = rac->z[0];
                                                   ERc->x[3] = rac->x[rac->numverts - 1];
                                                   ERc->y[3] = rac->y[rac->numverts - 1];
                                                   ERc->z[3] = rac->z[rac->numverts - 1];
                                                   }
                                                else
                                                   {
                                                   ERc->x[2] = rac->x[jj];
                                                   ERc->y[2] = rac->y[jj];
                                                   ERc->z[2] = rac->z[jj];
                                                   ERc->x[3] = rac->x[jj + 1];
                                                   ERc->y[3] = rac->y[jj + 1];
                                                   ERc->z[3] = rac->z[jj + 1];
                                                   }
                                                ERc->magnitude = 0.0;
                                                ERc->keyval = LLNONODEINT;
                                                ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                                                ERc->IDN = rlc->idn;
                                                ERc->Sindex = rlc->Sindex;
                                                ERc->ll1 = rlc;
                                                ERc->vertexindex1 = ii;
                                                ERc->vertexindex1 = ii;
                                                ERc->ll2 = NULL;
                                                ERc->pp = NULL;
                                                ERc->aa = rac;
                                                ERc->vertexindex2 = jj;
                                                ERc->next = NULL;
                                                if(ERroot == NULL)
                                                   {
                                                   ERc->z[0] = InterpLinearElev(rlc->x[ii],rlc->y[ii],rlc->z[ii],rlc->x[i],rlc->y[i],rlc->z[i],xi,yi);
                                                   ERroot = ERc;
                                                   }
                                                else
                                                   {
                                                   ERn = ERroot;
                                                   while(ERn != NULL)
                                                      {
                                                        if((ERn->Cnumber == ERc->Cnumber) && (ERn->keyval == ERc->keyval) &&
                                                           (ERn->x[0] == ERc->x[0]) && (ERn->y[0] == ERc->y[0]) &&
                                                           (ERn->ll1 == ERc->ll1) && (ERn->aa == ERc->aa))
                                                         break;
         
                                                      ERn = ERn->next;
                                                      }
                                                   if(ERn == NULL)
                                                      {
                                                      ERc->z[0] = InterpLinearElev(rlc->x[ii],rlc->y[ii],rlc->z[ii],rlc->x[i],rlc->y[i],rlc->z[i],xi,yi);
                                                      ERc->next = ERroot;
                                                      ERroot = ERc;
                                                      }
                                                   else
                                                     free(ERc);

                                                   }
                                                }
                                            }
                                          } /*** end need to record a condition ***/
                                       } /*** end line segments do intersect ***/
                                    
                                    } /*** end clip line feature segments to LM boundaries ***/ 
                                 } /*** end for i ...   ***/
                              j = GetNextArealIndex(rac, LastI, 1, &LastEdge, cindex, &unusedint);
                              LastI = j;
                              } /*** end have another large area segment to get ***/
                           }
                        }
                     }
                  rac = rac->next;
                  }


               } /*** end if check applies to rlc as part1 ***/
            }




         if(CombinedCheckApplies(rlc->idn,checkinstance,LLINTAWAY,rlc->Lindex,rlc->Sindex,Config1,Strat1,Domain1,&part1,&part2,&part3) > 0)
            {
            if(part1 > 0)
               {
               rln = root;
               while(rln != NULL)
                  {
                  if(rln == rlc)
                     {
                     if(rlc->next == NULL)
                        break;
                     else
                        rln = rlc->next;
                     }
                  Config2 = SCCtable[rln->Sindex].C;
                  Strat2 = SCCtable[rln->Sindex].S;
                  Domain2 = SCCtable[rln->Sindex].D;
                  if(CombinedCheckApplies(rln->idn,checkinstance,LLINTAWAY,rln->Lindex,rln->Sindex,Config2,Strat2,Domain2,&part1,&part2,&part3) > 0)
                     {
                     if(part2 > 0)
                        {
                        keepit = 0;
                        for(i=1; i<rlc->numnodes; i++)
                           {
                           ii = i - 1;
                           x1 = rlc->x[ii];
                           y1 = rlc->y[ii];
                           z1 = rlc->z[ii];
                           x2 = rlc->x[i];
                           y2 = rlc->y[i];
                           z2 = rlc->z[i];
                           if(ClipLineToRegion(minx,miny,maxx,maxy,&x1,&y1,&z1,&x2,&y2,&z2,&clipflag,multiplier) > 0)
                              {
                              for(j=1; j<rln->numnodes; j++)
                                 {
                                 jj = j - 1;
                                 x3 = rln->x[jj];
                                 y3 = rln->y[jj];
                                 z3 = rln->z[jj];
                                 x4 = rln->x[j];
                                 y4 = rln->y[j];
                                 z4 = rln->z[j];
                                 if(ClipLineToRegion(minx,miny,maxx,maxy,&x3,&y3,&z3,&x4,&y4,&z4,&clipflag,multiplier) > 0)
                                    {
                                    foundpair = AllCaseLineSegmentsIntersect(rlc->x[ii],rlc->y[ii],rlc->x[i],rlc->y[i],
                                                         rln->x[jj],rln->y[jj],rln->x[j],rln->y[j],0.001,&xi,&yi);
                                    
                                    switch(foundpair)
                                       {
                                       case 0: /** no intersection of any flavor ***/
                                          keepit = 0; break;
                                       case 1: /** an intersection at (xi,yi), away from any vertex of either feature ***/
                                          keepit = 1; break;
                                       case 2: /** (rlc->x[ii],rlc->y[ii]) and (rln->x[jj],rln->y[jj]) are connecting nodes **/
                                          if(ii == 0)
                                             {
                                             jj2 = jj - 1;
                                             keepit = ReCheckAtJoin(root,LLINTAWAY,checkinstance,rlc,ii,i,rln,jj2,jj,j);
                                             }
                                          else
                                             {
                                             ii2 = ii - 1;
                                             jj2 = jj - 1;
                                             keepit = 0;
                                             if(IntersectAcrossConnectingNode(rlc->x[ii2],rlc->y[ii2],
                                                         rlc->x[ii],rlc->y[ii],rlc->x[i],rlc->y[i],
                                                         rln->x[jj2],rln->y[jj2],rln->x[jj],rln->y[jj],rln->x[j],rln->y[j]) > 0)
                                                keepit = 1;
                                             }
                                          break;
                                       case 3: /** (rlc->x[ii],rlc->y[ii]) and (rln->x[j],rln->y[j]) are connecting nodes **/
                                          if(ii == 0)
                                             {
                                             jj2 = j + 1;
                                             keepit = ReCheckAtJoin(root,LLINTAWAY,checkinstance,rlc,ii,i,rln,jj,j,jj2);
                                             } 

                                          else
                                             {
                                             ii2 = ii - 1;
                                             jj2 = j + 1;
                                             keepit = 0;
                                             if(IntersectAcrossConnectingNode(rlc->x[ii2],rlc->y[ii2],
                                                         rlc->x[ii],rlc->y[ii],rlc->x[i],rlc->y[i],
                                                         rln->x[jj],rln->y[jj],rln->x[j],rln->y[j],rln->x[jj2],rln->y[jj2]) > 0)
                                                keepit = 1;
                                             }
                                          break;
                                       case 4: /** (rlc->x[i],rlc->y[i]) and (rln->x[jj],rln->y[jj]) are connecting nodes **/
                                          if(i == (rlc->numnodes -1))
                                             {
                                             jj2 = jj - 1;
                                             keepit = ReCheckAtJoin(root,LLINTAWAY,checkinstance,rlc,i,ii,rln,jj2,jj,j);
                                             } 

                                          else
                                             {
                                             ii2 = i + 1;
                                             jj2 = jj - 1;
                                             keepit = 0;
                                             if(IntersectAcrossConnectingNode(rlc->x[ii],rlc->y[ii],
                                                         rlc->x[i],rlc->y[i],rlc->x[ii2],rlc->y[ii2],
                                                         rln->x[jj2],rln->y[jj2],rln->x[jj],rln->y[jj],rln->x[j],rln->y[j]) > 0)
                                                keepit = 1;
                                             }
                                          break;
                                       case 5: /** (rlc->x[i],rlc->y[i]) and (rln->x[j],rln->y[j]) are connecting nodes **/
                                          if(i == (rlc->numnodes -1))
                                             {
                                             jj2 = j + 1;
                                             keepit = ReCheckAtJoin(root,LLINTAWAY,checkinstance,rlc,i,ii,rln,jj,j,jj2);
                                             }

                                          else
                                             {
                                             ii2 = i + 1;
                                             jj2 = j + 1;
                                             keepit = 0;
                                             if(IntersectAcrossConnectingNode(rlc->x[ii],rlc->y[ii],
                                                         rlc->x[i],rlc->y[i],rlc->x[ii2],rlc->y[ii2],
                                                         rln->x[jj],rln->y[jj],rln->x[j],rln->y[j],rln->x[jj2],rln->y[jj2]) > 0)
                                                keepit = 1;
                                             }
                                          break;
                                       case 6: /** (rlc->x[ii],rlc->y[ii]) is on rln, no connecting node **/
                                          if(ii == 0)
                                             keepit = 0;
                                          else
                                             {
                                             ii2 = ii - 1;
                                             i2 = 1;
                                             if(PointOnLineSegment(rlc->x[ii2],rlc->y[ii2],
                                                      rln->x[jj],rln->y[jj],rln->x[j],rln->y[j], 0.001) == 0)
                                                {
                                                i2 = TwoPointsOnSameSideOfLine(rlc->x[ii2],rlc->y[ii2],rlc->x[i],rlc->y[i],
                                                             rln->x[jj],rln->y[jj],rln->x[j],rln->y[j]);
                                                }
                                             if(i2 == 0)
                                                keepit = 1;
                                             else
                                                keepit = 0;
                                             }
                                          break;
                                       case 7: /** (rlc->x[i],rlc->y[i]) is on rln, no connecting node **/
                                          if(i == (rlc->numnodes - 1))
                                             keepit = 0;
                                          else
                                             {
                                             ii2 = i + 1;
                                             i2 = 1;
                                             if(PointOnLineSegment(rlc->x[ii2],rlc->y[ii2],
                                                      rln->x[jj],rln->y[jj],rln->x[j],rln->y[j], 0.001) == 0)
                                                {
                                                i2 = TwoPointsOnSameSideOfLine(rlc->x[ii2],rlc->y[ii2],rlc->x[ii],rlc->y[ii],
                                                             rln->x[jj],rln->y[jj],rln->x[j],rln->y[j]);
                                                }
                                             if(i2 == 0)
                                                keepit = 1;
                                             else
                                                keepit = 0;
                                             }
                                          break;
                                       case 8: /** (rln->x[jj],rln->y[jj]) is on rlc, no connecting node **/
                                          break;
                                       case 9: /** (rln->x[j],rln->y[j]) is on rlc, no connecting node **/
                                          break;
                                       }
                                    if(keepit > 0)
                                       {
                                       keepit = 0;
                                       ERc = (struct collection *) (malloc(SzC));
                                       if(ERc == NULL)
                                          {
                                          printf("allocation memory exhausted during linear feature condition analysis\n");
                                          printf("processing cannot continue\n");
                                          exit(-1);
                                          }
                                       ERc->x[0] = xi;
                                       ERc->y[0] = yi;
                                       ERc->magnitude = 0.0;
                                       ERc->keyval = LLINTAWAY;
                                       ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                                       ERc->IDN = rlc->idn;
                                       ERc->Sindex = rlc->Sindex;
                                       ERc->ll1 = rlc;
                                       ERc->vertexindex1 = ii;
                                       ERc->ll2 = rln;
                                       ERc->vertexindex2 = jj;
                                       ERc->next = NULL;
                                       if(ERroot == NULL)
                                          {
                                          ERc->z[0] = InterpLinearElev(x1,y1,z1,x2,y2,z2,xi,yi);
                                          ERroot = ERc;
                                          }
                                       else
                                          {
                                          ERn = ERroot;
                                          while(ERn != NULL)
                                             {
                                               if((ERn->Cnumber == ERc->Cnumber) && (ERn->keyval == ERc->keyval) &&
                                                  (ERn->x[0] == ERc->x[0]) && (ERn->y[0] == ERc->y[0]) &&
                                                  (( (ERn->ll1 == ERc->ll1) && (ERn->ll2 == ERc->ll2)) ||
                                                   ((ERn->ll1 == ERc->ll2) && (ERn->ll2 == ERc->ll1))))
                                                break;

                                             ERn = ERn->next;
                                             }
                                          if(ERn == NULL)
                                             {
                                             ERc->z[0] = InterpLinearElev(x1,y1,z1,x2,y2,z2,xi,yi);
                                             ERc->next = ERroot;
                                             ERroot = ERc;
                                             }
                                          else
                                            free(ERc);
                                         }
                                       break;
                                       }
                                    }
                                 }
                              }
                           }
                        }
                     }
                  rln = rln->next;
                  }
               }
            }  /*** end LLINTAWAY check ***/





         if(CombinedCheckApplies(rlc->idn,checkinstance,LLNOENDINT,rlc->Lindex,rlc->Sindex,Config1,Strat1,Domain1,&part1,&part2,&part3) > 0)
            {
            if(part1 > 0)
               {
               rln = root;
               while(rln != NULL)
                  {
                  if(rln == rlc)
                     {
                     if(rlc->next == NULL)
                        break;
                     else
                        rln = rlc->next;
                     }
                  Config2 = SCCtable[rln->Sindex].C;
                  Strat2 = SCCtable[rln->Sindex].S;
                  Domain2 = SCCtable[rln->Sindex].D;
                  if(CombinedCheckApplies(rln->idn,checkinstance,LLNOENDINT,rln->Lindex,rln->Sindex,Config2,Strat2,Domain2,&part1,&part2,&part3) > 0)
                     {
                     if(part2 > 0)
                        {
                        for(i=1; i<rlc->numnodes; i++)
                           {
                           ii = i - 1;
                           x1 = rlc->x[ii];
                           y1 = rlc->y[ii];
                           z1 = rlc->z[ii];
                           x2 = rlc->x[i];
                           y2 = rlc->y[i];
                           z2 = rlc->z[i];
                           if(ClipLineToRegion(minx,miny,maxx,maxy,&x1,&y1,&z1,&x2,&y2,&z2,&clipflag,multiplier) > 0)
                              {
                              for(j=1; j<rln->numnodes; j++)
                                 {
                                 jj = j - 1;
                                 x3 = rln->x[jj];
                                 y3 = rln->y[jj];
                                 z3 = rln->z[jj];
                                 x4 = rln->x[j];
                                 y4 = rln->y[j];
                                 z4 = rln->z[j];
                                 if(ClipLineToRegion(minx,miny,maxx,maxy,&x3,&y3,&z3,&x4,&y4,&z4,&clipflag,multiplier) > 0)
                                    {
                                    if(LineSegmentsIntersect(x1,y1,x2,y2,x3,y3,x4,y4, &xi, &yi) > 0)
                                       {
                                       keepit = 1;
                                       if((xi == rlc->x[0]) && (yi == rlc->y[0]))
                                          {
                                          if((xi == rln->x[0]) && (yi == rln->y[0]))
                                             keepit = 0;
                                          else if((xi == rln->x[rln->numnodes-1]) && (yi == rln->y[rln->numnodes-1]))
                                             keepit = 0;
                                          }
                                       else if((xi == rlc->x[rlc->numnodes-1]) && (yi == rlc->y[rlc->numnodes-1]))
                                          {
                                          if((xi == rln->x[0]) && (yi == rln->y[0]))
                                             keepit = 0;
                                          else if((xi == rln->x[rln->numnodes-1]) && (yi == rln->y[rln->numnodes-1]))
                                             keepit = 0;
                                          }
                                       if(keepit > 0)
                                          {
                                          ERc = (struct collection *) (malloc(SzC));
                                          if(ERc == NULL)
                                             {
                                             printf("allocation memory exhausted during linear feature condition analysis\n");
                                             printf("processing cannot continue\n");
                                             exit(-1);
                                             }
                                          ERc->x[0] = xi;
                                          ERc->y[0] = yi;
                                          ERc->magnitude = 0.0;
                                          ERc->keyval = LLNOENDINT;
                                          ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                                          ERc->IDN = rlc->idn;
                                          ERc->Sindex = rlc->Sindex;
                                          ERc->ll1 = rlc;
                                          ERc->vertexindex1 = ii;
                                          ERc->vertexindex1 = ii;
                                          ERc->ll2 = rln;
                                          ERc->vertexindex2 = jj;
                                          ERc->next = NULL;
                                          if(ERroot == NULL)
                                             {
                                             ERc->z[0] = InterpLinearElev(x1,y1,z1,x2,y2,z2,xi,yi);
                                             ERroot = ERc;
                                             }
                                          else
                                             {
                                             ERn = ERroot;
                                             while(ERn != NULL)
                                                {
                                                  if((ERn->Cnumber == ERc->Cnumber) && (ERn->keyval == ERc->keyval) &&
                                                     (ERn->x[0] == ERc->x[0]) && (ERn->y[0] == ERc->y[0]) &&
                                                     (( (ERn->ll1 == ERc->ll1) && (ERn->ll2 == ERc->ll2)) ||
                                                      ((ERn->ll1 == ERc->ll2) && (ERn->ll2 == ERc->ll1))))
                                                   break;

                                                ERn = ERn->next;
                                                }
                                             if(ERn == NULL)
                                                {
                                                ERc->z[0] = InterpLinearElev(x1,y1,z1,x2,y2,z2,xi,yi);
                                                ERc->next = ERroot;
                                                ERroot = ERc;
                                                }
                                             else
                                               free(ERc);
                                            }
                                          }
                                       }
                                    }
                                 }
                              }
                           }
                        }
                     }
                  rln = rln->next;
                  }
               }
            }  /*** end LLNOENDINT check ***/




         if(CombinedCheckApplies(rlc->idn,checkinstance,LLINT,rlc->Lindex,rlc->Sindex,Config1,Strat1,Domain1,&part1,&part2,&part3) > 0)
            {
            if(part1 > 0)
               {
               rln = root;
               while(rln != NULL)
                  {
                  if(rln == rlc)
                     {
                     if(rlc->next == NULL)
                        break;
                     else
                        rln = rlc->next;
                     }
                  Config2 = SCCtable[rln->Sindex].C;
                  Strat2 = SCCtable[rln->Sindex].S;
                  Domain2 = SCCtable[rln->Sindex].D;
                  if(CombinedCheckApplies(rln->idn,checkinstance,LLINT,rln->Lindex,rln->Sindex,Config2,Strat2,Domain2,&part1,&part2,&part3) > 0)
                     {
                     if(part2 > 0)
                        {
                        for(i=1; i<rlc->numnodes; i++)
                           {
                           ii = i - 1;
                           x1 = rlc->x[ii];
                           y1 = rlc->y[ii];
                           z1 = rlc->z[ii];
                           x2 = rlc->x[i];
                           y2 = rlc->y[i];
                           z2 = rlc->z[i];
                           if(ClipLineToRegion(minx,miny,maxx,maxy,&x1,&y1,&z1,&x2,&y2,&z2,&clipflag,multiplier) > 0)
                              {
                              for(j=1; j<rln->numnodes; j++)
                                 {
                                 jj = j - 1;
                                 x3 = rln->x[jj];
                                 y3 = rln->y[jj];
                                 z3 = rln->z[jj];
                                 x4 = rln->x[j];
                                 y4 = rln->y[j];
                                 z4 = rln->z[j];
                                 if(ClipLineToRegion(minx,miny,maxx,maxy,&x3,&y3,&z3,&x4,&y4,&z4,&clipflag,multiplier) > 0)
                                    {
                                    if(LineSegmentsIntersect(x1,y1,x2,y2,x3,y3,x4,y4, &xi, &yi) > 0)
                                       {
                                       ERc = (struct collection *) (malloc(SzC));
                                       if(ERc == NULL)
                                          {
                                          printf("allocation memory exhausted during linear feature condition analysis\n");
                                          printf("processing cannot continue\n");
                                          exit(-1);
                                          }
                                       ERc->x[0] = xi;
                                       ERc->y[0] = yi;
                                       ERc->magnitude = 0.0;
                                       ERc->keyval = LLINT;
                                       ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                                       ERc->IDN = rlc->idn;
                                       ERc->Sindex = rlc->Sindex;
                                       ERc->ll1 = rlc;
                                       ERc->vertexindex1 = ii;
                                       ERc->ll2 = rln;
                                       ERc->vertexindex2 = jj;
                                       ERc->next = NULL;
                                       if(ERroot == NULL)
                                          {
                                          ERc->z[0] = InterpLinearElev(x1,y1,z1,x2,y2,z2,xi,yi);
                                          ERroot = ERc;
                                          }
                                       else
                                          {
                                          ERn = ERroot;
                                          while(ERn != NULL)
                                             {
					       if(
						  (ERn->Cnumber == ERc->Cnumber) &&
						  (ERn->keyval == ERc->keyval) && 
						  (ERn->x[0]   == ERc->x[0])   &&
						  (ERn->y[0]   == ERc->y[0])   && 
						  (
						   (
						    (ERn->ll1    == ERc->ll1)    &&   /* this is Clause A */
						    (ERn->ll2    == ERc->ll2)
						    )
						   ||
						   (
						    (ERn->ll1    == ERc->ll2)    &&   /* this is Clause B */
						    (ERn->ll2    == ERc->ll1)
						    )
						   )
						  )
                                                break;

                                             ERn = ERn->next;
                                             }
                                          if(ERn == NULL)
                                             {
                                             ERc->z[0] = InterpLinearElev(x1,y1,z1,x2,y2,z2,xi,yi);
                                             ERc->next = ERroot;
                                             ERroot = ERc;
					     }
                                          else
					    free(ERc);
                                          }
                                       }
                                    }
                                 }
                              }
                           }
                        }
                     }
                  rln = rln->next;
                  }
               }
            }




         if(CombinedCheckApplies(rlc->idn,checkinstance,BADFEATCUT,rlc->Lindex,rlc->Sindex,Config1,Strat1,Domain1,&part1,&part2,&part3) > 0)
            {
            if(part1 > 0)
               {
               i = 0;
               while(i < rlc->numnodes)
                  {
                  found_one = 0;
                  if((rlc->x[i] >= minx) && (rlc->x[i] <= maxx) && (rlc->y[i] >= miny) && (rlc->y[i] <= maxy))
                     {
                     found_one = 1;
                     rln = root;
                     while(rln != NULL)
                        {
                        if(rln != rlc)
                           {
                           Config2 = SCCtable[rln->Sindex].C;
                           Strat2 = SCCtable[rln->Sindex].S;
                           Domain2 = SCCtable[rln->Sindex].D;
                           if(CombinedCheckApplies(rln->idn,checkinstance,BADFEATCUT,rln->Lindex,rln->Sindex,
                                                    Config2,Strat2,Domain2,&part1,&part2,&part3) > 0)
                              {
                              if(part2 > 0)
                                 {
                                 j = 0;
                                 while(j < rln->numnodes)
                                    {
                                    if((rln->x[j] >= minx) && (rln->x[j] <= maxx) && (rln->y[j] >= miny) && (rln->y[j] <= maxy))
                                       {
                                       ptpdist1 = Distance(rlc->x[i],rlc->y[i],rln->x[j],rln->y[j]);
                                       if(SensitivityCheck(LTEQ,BADFEATCUT,checkinstance,ptpdist1) > 0)
                                          {
                                          found_one = 2;
                                          break;
                                          }
                                       }
                                    j += (rln->numnodes - 1);
                                    }
                                 }
                              }
                           }
                        if(found_one > 1)
                           { /*** means we have found an end node to end node connection between part1 and part2 features ***/
                           found_one = 0;
                           rln2 = root;
                           while(rln2 != NULL)
                              {
                              if((rln2 != rlc) && (rln2 != rln))
                                 {
                                 if((CombinedCheckApplies(rln2->idn,checkinstance,BADFEATCUT,rln2->Lindex,rln2->Sindex,
                                     SCCtable[rln2->Sindex].C,SCCtable[rln2->Sindex].S,SCCtable[rln2->Sindex].D,&part1,&part2,&part3) > 0) &&
                                       (part3 > 0))
                                    {

                                    for(k=1; k < rln2->numnodes; k++)
                                       {
                                       ptldist = PointToLineDist2D(rlc->x[i],rlc->y[i],rln2->x[k],rln2->y[k],rln2->x[k-1],rln2->y[k-1]);
                                       if((SensitivityCheck(LTEQ,BADFEATCUT,checkinstance,ptldist) > 0))
                                          {
                                          for(jj = 1; jj < rln->numnodes; jj++)
                                             {
                                             if(LineSegmentsOverlap(rln->x[jj],rln->y[jj],rln->x[jj-1],rln->y[jj-1],
                                                 rln2->x[k],rln2->y[k],rln2->x[k-1],rln2->y[k-1],
                                                 &xi, &yi, &xi2, &yi2, ActiveChecks[checkinstance].sensitivity) > 0)
                                                {
                                                found_one = 3;
                                                break;
                                                }
                                             }
                                          }
                                       if(found_one > 2)
                                          break;
                                       } /************/
                                    }
                                 }
                              if(found_one > 2)
                                break;
                              rln2 = rln2->next;
                              }
                           }
                        if(found_one > 2)
                           break;
                        rln = rln->next;
                        } /*** end while rln ***/
                     } /*** end is in this load module ***/

                  if(found_one == 3)
                     {
                     keepit = 0;
                     rln2 = root;
                     while(rln2 != NULL)
                        {
                        if(rln2 != rlc)
                           {
                           Config2 = SCCtable[rln2->Sindex].C;
                           Strat2 = SCCtable[rln2->Sindex].S;
                           Domain2 = SCCtable[rln2->Sindex].D;
                           if(CombinedCheckApplies(rln2->idn,checkinstance,BADFEATCUT,rln2->Lindex,rln2->Sindex,
                                                    Config2,Strat2,Domain2,&part1,&part2,&part3) > 0)
                              {
                              if(part1 > 0)
                                 {
                                 jj = 0;
                                 while(jj < rln2->numnodes)
                                    {
                                    if((rln2->x[jj] >= minx) && (rln2->x[jj] <= maxx) && (rln2->y[jj] >= miny) && (rln2->y[jj] <= maxy))                                       {
                                       ptpdist1 = Distance(rlc->x[i],rlc->y[i],rln2->x[jj],rln2->y[jj]);
                                       if(SensitivityCheck(LTEQ,BADFEATCUT,checkinstance,ptpdist1) > 0)
                                          {
                                          keepit += 1;
                                          if(keepit > 1)
                                             break;
                                          }
                                       }
                                    jj += (rln2->numnodes - 1);
                                    }
                                 }
                              }
                           }
                        if(keepit > 1)
                           break;
                        rln2 = rln2->next;
                        }
                     }

                  if((found_one == 3) && (keepit == 1))
                     {
                     ERc = (struct collection *) (malloc(SzC));
                     if(ERc == NULL)
                        {
                        printf("allocation memory exhausted during linear feature condition analysis\n");
                        printf("processing cannot continue\n");
                        exit(-1);
                        }
                     ERc->x[0] = rlc->x[i];
                     ERc->y[0] = rlc->y[i];
                     ERc->z[0] = rlc->z[i];
                     if(i == 0)
                        {
                        ERc->x[1] = rlc->x[1];
                        ERc->y[1] = rlc->y[1];
                        ERc->z[1] = rlc->z[1];
                        }
                     else
                        {
                        ERc->x[1] = rlc->x[i-1];
                        ERc->y[1] = rlc->y[i-1];
                        ERc->z[1] = rlc->z[i-1];
                        }

                     ERc->x[2] = rln->x[j];
                     ERc->y[2] = rln->y[j];
                     ERc->z[2] = rln->z[j];
                     if(j == 0)
                        {
                        ERc->x[3] = rln->x[1];
                        ERc->y[3] = rln->y[1];
                        ERc->z[3] = rln->z[1];
                        }
                     else
                        {
                        ERc->x[3] = rln->x[j-1];
                        ERc->y[3] = rln->y[j-1];
                        ERc->z[3] = rln->z[j-1];
                        }

                     ERc->keyval = BADFEATCUT;
                     ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                     ERc->ll1 = rlc;
                     ERc->ll2 = rln;
                     ERc->Sindex = rln->Sindex;
                     ERc->next = NULL;
                     if(ERroot == NULL)
                        {
                        ERroot = ERc;
                        }
                     else
                        {
                        ERn = ERroot;
                        while(ERn != NULL)
                           {
                           if((ERn->Cnumber == ERc->Cnumber) && (ERn->keyval == ERc->keyval))
                              {
                              if((ERn->ll1 == ERc->ll1) && (ERn->ll2 == ERc->ll2))
                                 break;
                              else if((ERn->ll1 == ERc->ll2) && (ERn->ll2 == ERc->ll1))
                                 break;
                              }
                           ERn = ERn->next;
                           }
                        if(ERn == NULL)
                           {
                           ERc->next = ERroot;
                           ERroot = ERc;
                           }
                        else
                           {
                           free(ERc);
                           }
                        }

                     }
                  i += (rlc->numnodes - 1);
                  } /*** end while i < rlc->numnodes ***/
               }
            }



         if(CombinedCheckApplies(rlc->idn,checkinstance,LLMULTINT,rlc->Lindex,rlc->Sindex,Config1,Strat1,Domain1,&part1,&part2,&part3) > 0)
            {
            if(part1 > 0)
               {
               rln = root;
               while(rln != NULL)
                  {
                  if(rln == rlc)
                     {
                     if(rlc->next == NULL)
                        break;
                     else
                        rln = rlc->next;
                     }
                  Config2 = SCCtable[rln->Sindex].C;
                  Strat2 = SCCtable[rln->Sindex].S;
                  Domain2 = SCCtable[rln->Sindex].D;
                  if(CombinedCheckApplies(rln->idn,checkinstance,LLMULTINT,rln->Lindex,rln->Sindex,Config2,Strat2,Domain2,&part1,&part2,&part3) > 0)
                     {
                     if((rlc->IsMulti == 0) || (rln->IsMulti == 0)  ||
                       (CheckThisLinePair(checkinstance,CTLPmaxindex,
                       SzPC,SzPW,rlc->localID,rln->localID,rlc->firstencounter,rln->firstencounter,rlc->length,rln->length) > 0))
                        {
                        if(part2 > 0)
                           {
                           temp = 0.0;
                           ii3 = 0;
                           for(i=1; i<rlc->numnodes; i++)
                              {
                              ii = i - 1;
                              if(rlc->x[ii] < rlc->x[i])
                                 {
                                 minLx = rlc->x[ii];
                                 maxLx = rlc->x[i];
                                 }
                              else
                                 {
                                 minLx = rlc->x[i];
                                 maxLx = rlc->x[ii];
                                 }
                              if(rlc->y[ii] < rlc->y[i])
                                 {
                                 minLy = rlc->y[ii];
                                 maxLy = rlc->y[i];
                                 }
                              else
                                 {
                                 minLy = rlc->y[i];
                                 maxLy = rlc->y[ii];
                                 }
                              for(j=1; j<rln->numnodes; j++)
                                 {
                                 jj = j - 1;
                                 keepit = 1;
if(rln->x[j] > rln->x[jj])
   {
   minvx = rln->x[jj] - 0.5;
   maxvx = rln->x[j] + 0.5;
   }
else
   {
   minvx = rln->x[j] - 0.5;
   maxvx = rln->x[jj] + 0.5;
   }
if(rln->y[j] > rln->y[jj])
   {
   minvy = rln->y[jj] - 0.5;
   maxvy = rln->y[j] + 0.5;
   }
else
   {
   minvy = rln->y[j] - 0.5;
   maxvy = rln->y[jj] + 0.5;
   }
if((minLx < maxvx) && (maxLx > minvx) && (minLy < maxvy) && (maxLy > minvy))
   {
                                 if(MergeSeg_LineSegmentsOverlap(rlc->x[i],rlc->y[i],rlc->x[ii],rlc->y[ii],
                                           rln->x[j],rln->y[j],rln->x[jj],rln->y[jj],minLx,maxLx,minLy,maxLy,
                                           &xi, &yi, &xi2, &yi2, 0.01 ) > 0)
                                    {
                                    keepit = 0;
                                    }
                                 else /***if((rlc->x[ii] == rln->x[jj]) && (rlc->y[ii] == rln->y[jj])) ***/
                                 if((NearlyEqual(rlc->x[ii], rln->x[jj]) > 0) && (NearlyEqual(rlc->y[ii], rln->y[jj]) > 0))
                                    {
                                    keepit = 0;
                                    if(rlc->z[ii] > rln->z[jj])
                                       z1 = rlc->z[ii] - rln->z[jj];
                                    else
                                       z1 = rln->z[jj] - rlc->z[ii];
        
                                    if((z1 < 0.9) && (ii > 0) && (jj > 0))
                                       {
                                       ii2 = ii - 1;
                                       jj2 = jj - 1;
                                       if(LineSegmentsOverlap(rlc->x[i],rlc->y[i],rlc->x[ii2],rlc->y[ii2],
                                                             rln->x[j],rln->y[j],rln->x[jj2],rln->y[jj2],
                                                             &unuseddbl,&unuseddbl2,&unuseddbl3,&unuseddbl4, 0.01) < 1)
                                          {
                                          if(LineSegmentsIntersect(rlc->x[ii2], rlc->y[ii2], rlc->x[i], rlc->y[i],
                                                    rln->x[jj2],rln->y[jj2],rln->x[j],rln->y[j], &xi, &yi) > 0)
                                             {
                                             temp += 1;
                                             }
                                          }
                                       }
                                    }
                                 else if((NearlyEqual(rlc->x[ii], rln->x[j]) > 0) && (NearlyEqual(rlc->y[ii], rln->y[j]) > 0))
                                    {
                                    keepit = 0;
                                    }
                                 else if((NearlyEqual(rlc->x[i], rln->x[jj]) > 0) && (NearlyEqual(rlc->y[i], rln->y[jj]) > 0))
                                    {
                                    keepit = 0;
                                    }
                                 else if((NearlyEqual(rlc->x[i], rln->x[j]) > 0) && (NearlyEqual(rlc->y[i], rln->y[j]) > 0))
                                    {
                                    keepit = 0;
                                    } 
                                 if((keepit > 0)&&
                                      (LineSegmentsIntersect(rlc->x[ii], rlc->y[ii], rlc->x[i], rlc->y[i],
                                                          rln->x[jj],rln->y[jj],rln->x[j],rln->y[j], &xi, &yi) > 0))
                                    {
                                    if((tempis2D(rlc->z[i]) == 1) || (tempis2D(rlc->z[ii]) == 1) || (tempis2D(rln->z[j]) == 1) || (tempis2D(rln->z[jj]) == 1))
                                       {
                                       temp = temp + 1.0;
                                       }
                                    else
                                       {
                                       z1 = InterpLinearElev(rlc->x[ii], rlc->y[ii], rlc->z[ii], rlc->x[i], rlc->y[i], rlc->z[i], xi, yi);
                                       z2 = InterpLinearElev(rln->x[jj], rln->y[jj], rln->z[jj], rln->x[j], rln->y[j], rln->z[j], xi, yi);
                                       if(z1 > z2)
                                          z3 = z1 - z2;
                                       else
                                          z3 = z2 - z1;
                                       if((z3 <= ActiveChecks[checkinstance].sensitivity2) ||
                                         (z3 >= ActiveChecks[checkinstance].sensitivity3))
                                          {
                                          temp = temp + 1.0;
                                          }

                                       }
                              
                                    }
   } /*** end intersection is possible based on min - max vertex values ****/
                                 } /** end for j **/
                              } /*** end for i ***/
                           if(SensitivityCheck(GTEQ, LLMULTINT, checkinstance, temp) > 0)
                              {
                              ERc = (struct collection *) (malloc(SzC));
                              if(ERc == NULL)
                                 {
                                 printf("allocation memory exhausted during linear feature condition analysis\n");
                                 printf("processing cannot continue\n");
                                 exit(-1);
                                 }
                              ERc->magnitude = temp;
                              ERc->keyval = LLMULTINT;
                              ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                              ERc->IDN = rlc->idn;
                              ERc->Sindex = rlc->Sindex;
                              ERc->ll1 = rlc;
                              ERc->ll2 = rln;
                              ERc->next = NULL;
                              if(ERroot == NULL)
                                 {
                                 ERroot = ERc;
                                 }
                              else
                                 {
                                 ERn = ERroot;
                                 while(ERn != NULL)
                                    {
                                      if((ERn->Cnumber == ERc->Cnumber) && (ERn->keyval == ERc->keyval) &&
                                            (((ERn->ll1 == ERc->ll1) && (ERn->ll2 == ERc->ll2)) ||
                                                    ((ERn->ll1 == ERc->ll2) && (ERn->ll2 == ERc->ll1))))
                                       break;

                                    ERn = ERn->next;
                                    }
                                 if(ERn == NULL)
                                    {
                                    ERc->next = ERroot;
                                    ERroot = ERc;
                                    }
                                 else
                                   {
                                   free(ERc);
                                   }
                                 }
                              } /** end  if(SensitivityCheck(GTEQ ***/
                           } /** end if part 2 ***/
                        } /** end if(CombinedCheckApplies( .. ***/
                     } /** end first encounter condition ***/
                  rln = rln->next;
                  }
               }
            }


         if(CombinedCheckApplies(rlc->idn,checkinstance,LOC_MULTINT,
                  rlc->Lindex,rlc->Sindex,Config1,Strat1,Domain1,&part1,&part2,&part3) > 0)
            {
            if(part1 > 0)
               {
               checkit = Get_LOC_AttrValues(rlc->Lindex, rlc->idn, attrfileptr, &LOCvalue1);
               rln = root;
               /***rln = rlc->next;***/
               while(rln != NULL)
                  {
                  if(rln == rlc)
                     {
                     if(rlc->next == NULL)
                        break;
                     else
                        rln = rlc->next;
                     }
                  Config2 = SCCtable[rln->Sindex].C;
                  Strat2 = SCCtable[rln->Sindex].S;
                  Domain2 = SCCtable[rln->Sindex].D;
                  if(CombinedCheckApplies(rln->idn,checkinstance,LOC_MULTINT,rln->Lindex,rln->Sindex,
                                   Config2,Strat2,Domain2,&part1,&part2,&part3) > 0)
                     {
                     if((rlc->IsMulti == 0) || (rln->IsMulti == 0)  ||
                         (CheckThisLinePair(checkinstance,CTLPmaxindex,
                                SzPC,SzPW,rlc->localID,rln->localID,rlc->firstencounter,
                                     rln->firstencounter,rlc->length,rln->length) > 0))
                        {
                        if(part2 > 0)
                           {
                           checkit3 = 1;
                           if((checkit > 0) && (LOCvalue1 > 0))
                              {
                              checkit2 = Get_LOC_AttrValues(rln->Lindex, rln->idn, attrfileptr, &LOCvalue2);
                              checkit3 = 1;
                              if(checkit2 > 0) /*** both features have the LOC attribute ***/
                                 {
                                 if(LOCvalue2 > 0) /*** both have a meaningful value ***/
                                    {
                                    if(LOCvalue1 != LOCvalue2)
                                       {
                                       checkit3 = 0;
                                       }
                                    }
                                 }
                              }
                           if(checkit3 > 0)
                              {
                              temp = 0.0;
                              ii3 = 0;
                              for(i=1; i<rlc->numnodes; i++)
                                 {
                                 ii = i - 1;
                                 if(rlc->x[ii] < rlc->x[i])
                                    {
                                    minLx = rlc->x[ii];
                                    maxLx = rlc->x[i];
                                    }
                                 else
                                    {
                                    minLx = rlc->x[i];
                                    maxLx = rlc->x[ii];
                                    }
                                 if(rlc->y[ii] < rlc->y[i])
                                    {
                                    minLy = rlc->y[ii];
                                    maxLy = rlc->y[i];
                                    }
                                 else
                                    {
                                    minLy = rlc->y[i];
                                    maxLy = rlc->y[ii];                                  }
                                 for(j=1; j<rln->numnodes; j++)
                                    {
                                    jj = j - 1;
                                    keepit = 1;
if(rln->x[j] > rln->x[jj])
   {
   minvx = rln->x[jj] - 0.5;
   maxvx = rln->x[j] + 0.5;
   }
else
   {
   minvx = rln->x[j] - 0.5;
   maxvx = rln->x[jj] + 0.5;
   }
if(rln->y[j] > rln->y[jj])
   {
   minvy = rln->y[jj] - 0.5;
   maxvy = rln->y[j] + 0.5;
   }
else
   {
   minvy = rln->y[j] - 0.5;
   maxvy = rln->y[jj] + 0.5;
   }
if((minLx < maxvx) && (maxLx > minvx) && (minLy < maxvy) && (maxLy > minvy))
   {
                                    if(MergeSeg_LineSegmentsOverlap(rlc->x[i],rlc->y[i],rlc->x[ii],rlc->y[ii],
                                           rln->x[j],rln->y[j],rln->x[jj],rln->y[jj],minLx,maxLx,minLy,maxLy,
                                           &xi, &yi, &xi2, &yi2, 0.01 ) > 0)
                                       {
                                       keepit = 0;
                                       }
                                    else /***if((rlc->x[ii] == rln->x[jj]) && (rlc->y[ii] == rln->y[jj])) ***/
                                    if((NearlyEqual(rlc->x[ii], rln->x[jj]) > 0) && (NearlyEqual(rlc->y[ii], rln->y[jj]) > 0))
                                       {
                                       keepit = 0;
                                       if(rlc->z[ii] > rln->z[jj])
                                          z1 = rlc->z[ii] - rln->z[jj];
                                       else
                                          z1 = rln->z[jj] - rlc->z[ii];
   
                                       if((z1 < 0.9) && (ii > 0) && (jj > 0))
                                          {
                                          ii2 = ii - 1;
                                          jj2 = jj - 1;
                                          if(LineSegmentsOverlap(rlc->x[i],rlc->y[i],rlc->x[ii2],rlc->y[ii2],
                                                             rln->x[j],rln->y[j],rln->x[jj2],rln->y[jj2],
                                                             &unuseddbl,&unuseddbl2,&unuseddbl3,&unuseddbl4, 0.01) < 1)
                                             {
                                             if(LineSegmentsIntersect(rlc->x[ii2], rlc->y[ii2], rlc->x[i], rlc->y[i],
                                                       rln->x[jj2],rln->y[jj2],rln->x[j],rln->y[j], &xi, &yi) > 0)
                                                {
                                                temp += 1;
                                                }
                                             }
                                          }
                                       }
                                    else if((NearlyEqual(rlc->x[ii], rln->x[j]) > 0) && (NearlyEqual(rlc->y[ii], rln->y[j]) > 0))
                                       {
                                       keepit = 0;
                                       }
                                    else if((NearlyEqual(rlc->x[i], rln->x[jj]) > 0) && (NearlyEqual(rlc->y[i], rln->y[jj]) > 0))
                                       {
                                       keepit = 0;
                                        }
                                    else if((NearlyEqual(rlc->x[i], rln->x[j]) > 0) && (NearlyEqual(rlc->y[i], rln->y[j]) > 0))
                                       {
                                       keepit = 0;
                                       }
                                    if((keepit > 0)&&
                                      (LineSegmentsIntersect(rlc->x[ii], rlc->y[ii], rlc->x[i], rlc->y[i],
                                                          rln->x[jj],rln->y[jj],rln->x[j],rln->y[j], &xi, &yi) > 0))
                                       {
                                       if((tempis2D(rlc->z[i]) == 1) || (tempis2D(rlc->z[ii]) == 1) ||
                                                          (tempis2D(rln->z[j]) == 1) || (tempis2D(rln->z[jj]) == 1))
                                          {
                                          temp = temp + 1.0;
                                          }
                                       else
                                          {
                                          z1 = InterpLinearElev(rlc->x[ii], rlc->y[ii], rlc->z[ii], rlc->x[i], rlc->y[i], rlc->z[i], xi, yi);
                                          z2 = InterpLinearElev(rln->x[jj], rln->y[jj], rln->z[jj], rln->x[j], rln->y[j], rln->z[j], xi, yi);
                                          if(z1 > z2)
                                             z3 = z1 - z2;
                                          else
                                             z3 = z2 - z1;
                                          if((z3 <= ActiveChecks[checkinstance].sensitivity2) ||
                                            (z3 >= ActiveChecks[checkinstance].sensitivity3))
                                             {
                                             temp = temp + 1.0;
                                             }

                                          }
   
                                       }
   } /*** end intersection is possible based on min - max vertex values ****/
                                    } /** end for j **/
                                 } /*** end for i ***/
                              if(SensitivityCheck(GTEQ, LOC_MULTINT, checkinstance, temp) > 0)
                                 {
                                 ERc = (struct collection *) (malloc(SzC));
                                 if(ERc == NULL)                                  {
                                    printf("allocation memory exhausted during linear feature condition analysis\n");
                                    printf("processing cannot continue\n");
                                    exit(-1);                                  }
                                 ERc->magnitude = temp;
                                 ERc->keyval = LOC_MULTINT;
                                 ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                                 ERc->IDN = rlc->idn;
                                 ERc->Sindex = rlc->Sindex;
                                 ERc->ll1 = rlc;
                                 ERc->ll2 = rln;
                                 ERc->next = NULL;
                                 if(ERroot == NULL)
                                    {
                                    ERroot = ERc;
                                    }
                                 else
                                    {
                                    ERn = ERroot;
                                    while(ERn != NULL)
                                       {
                                         if((ERn->Cnumber == ERc->Cnumber) && (ERn->keyval == ERc->keyval) &&
                                               (((ERn->ll1 == ERc->ll1) && (ERn->ll2 == ERc->ll2)) ||
                                                       ((ERn->ll1 == ERc->ll2) && (ERn->ll2 == ERc->ll1))))
                                          break;
   
                                       ERn = ERn->next;
                                       }
                                    if(ERn == NULL)
                                       {
                                       ERc->next = ERroot;
                                       ERroot = ERc;
                                       }
                                    else
                                      {
                                      free(ERc);
                                      }
                                    }
                                 } /** end  if(SensitivityCheck(GTEQ ***/
                              } /*** end if checkit3, so LOC values match ****/
                           } /** end if part 2 ***/
                        } /** end if(CombinedCheckApplies( .. ***/
                     } /** end first encounter condition ***/
                  rln = rln->next;
                  }
               }
            }




         if(CombinedCheckApplies(rlc->idn,checkinstance,LVPROX,rlc->Lindex,rlc->Sindex,Config1,Strat1,Domain1,&part1,&part2,&part3) > 0)
            {
            if(part1 > 0)
               {
               tempsensitivity2 = FindRelevantSensitivity(LVPROX,checkinstance,&tempsensitivity);
               rln = root;
               while(rln != NULL)
                  {
                  if(rln == rlc)
                     {
                     if(rlc->next == NULL)
                        break;
                     else
                        rln = rlc->next;
                     }
                  Config2 = SCCtable[rln->Sindex].C;
                  Strat2 = SCCtable[rln->Sindex].S;
                  Domain2 = SCCtable[rln->Sindex].D;
                  if(CombinedCheckApplies(rln->idn,checkinstance,LVPROX,rln->Lindex,rln->Sindex,Config2,Strat2,Domain2,&part1,&part2,&part3) > 0)
                     {
                     if(part2 > 0)
                        {
                        for(i=0; i<rlc->numnodes; i++)
                           {
                           if((rlc->x[i] >= minx) && (rlc->x[i] <= maxx) && (rlc->y[i] >= miny) && (rlc->y[i] <= maxy))
                              {
                              for(j=1; j<rln->numnodes; j++)
                                 {
                                 jj = j - 1;
                                 x3 = rln->x[jj];
                                 y3 = rln->y[jj];
                                 z3 = rln->z[jj];
                                 x4 = rln->x[j];
                                 y4 = rln->y[j];
                                 z4 = rln->z[j];
                                 if(ClipLineToRegion(minx,miny,maxx,maxy,&x3,&y3,&z3,&x4,&y4,&z4,&clipflag,multiplier) > 0)
                                    {
                                    ptldist = PointToLineDist(rlc->x[i], rlc->y[i], rlc->z[i], x3, y3, z3, x4, y4, z4);
                                    if((ptldist > tempsensitivity2) && (SensitivityCheck(OPENINT, LVPROX, checkinstance, ptldist) > 0))
                                       {
                                       ERc = (struct collection *) (malloc(SzC));
                                       if(ERc == NULL)
                                          {
                                          printf("allocation memory exhausted during linear feature condition analysis\n");
                                          printf("processing cannot continue\n");
                                          exit(-1);
                                          }
                                       ERc->x[0] = rlc->x[i];
                                       ERc->y[0] = rlc->y[i];
                                       ERc->z[0] = rlc->z[i];
                                       ERc->magnitude = ptldist;
                                       ERc->keyval = LVPROX;
                                       ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                                       ERc->Sindex = rlc->Sindex;
                                       ERc->ll1 = rlc;
                                       ERc->ll2 = rln;
                                       ERc->next = NULL;
                                       if(ERroot == NULL)
                                          {
                                          ERc->x[1] = rln->x[jj];
                                          ERc->y[1] = rln->y[jj];
                                          ERc->z[1] = rln->z[jj];
                                          ERc->x[2] = rln->x[j];
                                          ERc->y[2] = rln->y[j];
                                          ERc->z[2] = rln->z[j];
                                          ERroot = ERc;
                                          }
                                       else
                                          {
                                          ERn = ERroot;
                                          ERc->x[1] = rln->x[jj];
                                          ERc->y[1] = rln->y[jj];
                                          ERc->z[1] = rln->z[jj];
                                          ERc->x[2] = rln->x[j];
                                          ERc->y[2] = rln->y[j];
                                          ERc->z[2] = rln->z[j];
                                          while(ERn != NULL)
                                             {
                                             if(
						(ERn->Cnumber == ERc->Cnumber) &&
						(ERn->keyval == ERc->keyval) && 
						(ERn->x[0]   == ERc->x[0])   &&
						(ERn->y[0]   == ERc->y[0])   && 
						(ERn->Sindex == ERc->Sindex)
						)
                                                {
                                                if((ERn->x[1] == ERc->x[1]) && (ERn->y[1] == ERc->y[1]) &&
                                                      (ERn->x[2] == ERc->x[2]) && (ERn->y[2] == ERc->y[2]))
                                                   break;
                                                if((ERn->x[2] == ERc->x[1]) && (ERn->y[2] == ERc->y[1]) &&
                                                      (ERn->x[1] == ERc->x[2]) && (ERn->y[1] == ERc->y[2]))
                                                   break;
                                                }
                                             ERn = ERn->next;
                                             }
                                          if(ERn == NULL)
                                             {
                                             ERc->next = ERroot;
                                             ERroot = ERc;
                                             }
                                          else
                                             free(ERc);
                                          }
                                       }
                                    }
                                 }
                              }
                           }
                        }
                     }
                  rln = rln->next;
                  }
               }
            }


         if(CombinedCheckApplies(rlc->idn,checkinstance,ISOLINE,rlc->Lindex,rlc->Sindex,Config1,Strat1,Domain1,&part1,&part2,&part3) > 0)
            {
            keepit = 1;
            if((part1 > 0) && (rlc->numnodes > 0))
               {
               for(i = 0; i < rlc->numnodes; i++)
                  {
                  if((rlc->x[i] >= minx) && (rlc->x[i] <= maxx) && (rlc->y[i] >= miny) && (rlc->y[i] <= maxy))
                     {
                     rln = root;
                     if(rln == rlc)
                        rln = rln->next;
                     while(rln != NULL)
                        {
                        if((CombinedCheckApplies(rln->idn,checkinstance,ISOLINE,rln->Lindex,rln->Sindex,
                             SCCtable[rln->Sindex].C,SCCtable[rln->Sindex].S,SCCtable[rln->Sindex].D,
                                &part1s,&part2s,&part3s) > 0) && (part3s > 0))
                           {
                           for(j=0; j < rln->numnodes; j++)
                              {
                              if((rln->x[j] >= minx) && (rln->x[j] <= maxx) && (rln->y[j] >= miny) && (rln->y[j] <= maxy))
                                 {
                                 if(Distance(rlc->x[i],rlc->y[i],rln->x[j],rln->y[j]) <= ActiveChecks[checkinstance].sensitivity)
                                    {
                                    keepit = 0;
                                    j = 0;
                                    rac = NULL;
                                    break;
                                    }
                                 }
                              }
                           }
                        if(keepit < 1)
                           break;
                        rln = rln->next;
                        if(rln == rlc)
                           rln = rln->next;
                        }
                     if(keepit > 0)
                        {
                        rpc = Proot;
                        while(rpc != NULL)
                           {
                           if((CombinedCheckApplies(rpc->idn,checkinstance,ISOLINE,rpc->Lindex,rpc->Sindex,
                             SCCtable[rpc->Sindex].C,SCCtable[rpc->Sindex].S,SCCtable[rpc->Sindex].D,
                                &part1s,&part2s,&part3s) > 0) && (part3s > 0))
                              {
                              if(Distance(rlc->x[i],rlc->y[i],rpc->x[0],rpc->y[0]) <= ActiveChecks[checkinstance].sensitivity)
                                 {
                                 keepit = 0;
                                 j = 0;
                                 rac = NULL;
                                 break;
                                 }
                              }
                           rpc = rpc->next;
                           }
                        }
                     if(keepit > 0)
                        {
                        ran2 = Aroot;
                        while(ran2 != NULL)
                           {
                           if((CombinedCheckApplies(ran2->idn,checkinstance,ISOLINE,ran2->Lindex,ran2->Sindex,
                                  SCCtable[ran2->Sindex].C,SCCtable[ran2->Sindex].S,SCCtable[ran2->Sindex].D,
                                        &part1s,&part2s,&part3s) > 0) && (part3s > 0))
                              {
                              if(ran2->RB_Tree_Edgelist == NULL)
                                 ptadist3 = PointToSmallArealDist2D(rlc->x[i], rlc->y[i],ran2,&unusedint,&unuseddbl);
                              else
                                 ptadist3 = PointToLargeArealDist2D(rlc->x[i], rlc->y[i],ran2,&unusedint,&unuseddbl);
                              if(ptadist3 <= ActiveChecks[checkinstance].sensitivity)
                                 {
                                 keepit = 0;
                                 j = 0;
                                 rac = NULL;
                                 break;
                                 }
                              }
                           ran2 = ran2->next;
                           }
                        }
                     }
                  if(keepit < 1)
                     break;
                  }
               }
            if((part1 > 0) && (keepit > 0) && (rlc->numnodes > 0) && (rlc->firstencounter == 1))
               {
               i = j = 0;
               rac = Aroot;
               rah = NULL;
               while(rac != NULL)
                  {
                  Config2 = SCCtable[rac->Sindex].C;
                  Strat2 = SCCtable[rac->Sindex].S;
                  Domain2 = SCCtable[rac->Sindex].D;
                  
                  j = 0;
                  rah = NULL;

                  if((rac->ishole <= 0) && (CombinedCheckApplies(rac->idn,checkinstance,ISOLINE,rac->Lindex,rac->Sindex,
                            Config2,Strat2,Domain2,&part1s,&part2s,&part3s) > 0))
                     {
                     if(part2s > 0)
                        {
                        j = Line_ILA_WithTolerance(rlc,rac,ActiveChecks[checkinstance].sensitivity);
                        
                        if(j > 0)
                           {
                           rah = Aroot;
                           while(rah != NULL)
                              {
                              if((rah->ishole > 0) && (rah->idn == rac->idn))
                                 {
                                 k = LinePartOrAllInsideArea(rlc, rah, &i2, &i3,
                                            ActiveChecks[checkinstance].sensitivity, 99.9);
                                 if(k == 1)
                                    {
                                    j = 0;
                                    break;
                                    }
                                 else
                                    {
                                    for(i2 = 0; i2 < rlc->numnodes; i2++)
                                       {
                                       if(rah->RB_Tree_Edgelist == NULL)
                                          {
                                          if((PointIsVertex(rlc->x[i2],rlc->y[i2],
                                                     rah->x,rah->y,rah->x,rah->numverts,&unuseddbl) > 0) ||
                                             (PointOnEdge(rlc->x[i2],rlc->y[i2],
                                                 rah->x,rah->y,rah->x,rah->numverts,&unuseddbl,&unusedint) > 0))
                                             {
                                             j = 0;
                                             break;
                                             }
                                          }
                                       else
                                          {
                                          if((PointIsLargeArealVertex(rlc->x[i2],rlc->y[i2],rah,&unuseddbl) > 0) ||
                                             (PointOnLargeArealEdge(rlc->x[i2],rlc->y[i2],rah,&unuseddbl,&unusedint) > 0))
                                             {
                                             j = 0; 
                                             break;
                                             }
                                          }

                                       }
                                    }
                                 }
                              if(j == 0)
                                 break;
                              rah = rah->next;
                              }
                           if(j> 0)
                              break;
                           }
                        }
                     }
                  rac = rac->next;
                  }
               if((keepit > 0) && (j > 0) && (rac != NULL) && (rah == NULL))/*** have found an instance of the condition ***/
                  {
                  if(rlc->IsMulti == 0) /** can write now **/
                     {
                     ERc = (struct collection *) (malloc(SzC));
                     if(ERc == NULL)
                        {
                        printf("allocation memory exhausted during linear feature condition analysis\n");
                        printf("processing cannot continue\n");
                        exit(-1);
                        }
                     ERc->x[0] = rlc->x[1];
                     ERc->y[0] = rlc->y[1];
                     ERc->z[0] = rlc->z[1];
                     ERc->x[1] = rlc->x[0];
                     ERc->y[1] = rlc->y[0];
                     ERc->z[1] = rlc->z[0];
                     ERc->magnitude = 0.0;
                     ERc->keyval = ISOLINE;
                     ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                     ERc->IDN = rlc->idn;
                     ERc->Sindex = rlc->Sindex;
                     ERc->ll1 = rlc;
                     ERc->vertexindex1 = 0;
                     ERc->ll2 = NULL;
                     ERc->aa = rac;
                     ERc->vertexindex2 = 0;
                     ERc->next = NULL;
                     if(ERroot == NULL)
                        {
                        ERroot = ERc;
                        }
                     else
                        {
                        ERn = ERroot;
                        while(ERn != NULL)
                           {
                           if((ERn->Cnumber == ERc->Cnumber) && (ERn->keyval == ERc->keyval) && (ERn->ll1 == ERc->ll1) &&
                              (ERn->ll1->localID == ERc->ll1->localID) && (ERc->aa == ERn->aa))
                              break;
   
                           ERn = ERn->next;
                           }
                        if(ERn == NULL)
                           {
                           ERc->next = ERroot;
                           ERroot = ERc;
                           }
                        else
                          free(ERc);
                        }
                     } /** end is a single =-LM line feature ***/
                  else /** is multi LM line, so need to check other LM for line interaction with holes of rac ***/
                     {
                     RB_newKey2 = rlc->idn + (checkinstance * 0.0001);
                     if(( RB_newNode = RBExactQuery(Check_RB_Tree,&RB_newKey2)) == 0)
                        {
                        RB_cond = (struct ConditionCollection *) (malloc(SzCC));
                        if(RB_cond == NULL)
                           {
                           printf("memory has been exhausted during RB-Tree information alloction for ISOLINE analysis\n");
                           exit(-1);
                           }
                        RB_cond->keyval = ISOLINE;
                        RB_cond->Cnumber =  Make_Correct(ISOLINE,checkinstance);
                        RB_cond->index_from_to = NULL;
                        RB_cond->gform = G_LINE;
                        RB_cond->localID = rlc->localID;
                        RB_cond->counter = 1; /** consider it to be a condition right now ***/
                        RB_cond->height = -1;
                        RB_cond->IDN = rlc->idn;
                        RB_cond->Lindex = rlc->Lindex;

                        RB_cond->featureidn = rac->idn;
                        RB_cond->magnitude = rac->localID;
                        RB_cond->Sindex = rac->Lindex;

                        unuseddbl = rlc->x[0];
                        for(jj=1; jj< rlc->numnodes; jj++)
                           {
                           if(rlc->x[jj] > unuseddbl)
                              unuseddbl = rlc->x[jj];
                           }
                        ii5 = (int) (unuseddbl / RegionSize) + 1; /** will be pruning the tree based on LM columns ***/
                                                            /** see function PruneAndWriteRBCheckTree in TT.c ***/

                        RB_cond->radius = ii5; /** storing last LM column this feature appears in unused 'radius' field ***/

                        RB_cond->numnodes = 4;
                        RB_cond->x = (double *) (malloc(RB_cond->numnodes * SzD));
                        RB_cond->y = (double *) (malloc(RB_cond->numnodes * SzD));
                        RB_cond->z = (double *) (malloc(RB_cond->numnodes * SzD));
                        if(RB_cond->z == NULL)
                           {
                           printf("memory has been exhausted during RB-Tree element vertex alloction for LFNOINT analysis\n");                                          exit(-1);
                           }

                        for(jj=0; jj< 2; jj++)
                           {
                           RB_cond->x[jj] = rlc->x[jj];
                           RB_cond->y[jj] = rlc->y[jj];
                           RB_cond->z[jj] = rlc->z[jj];
                           RB_cond->x[jj+2] = rac->x[jj];
                           RB_cond->y[jj+2] = rac->y[jj];
                           RB_cond->z[jj+2] = rac->z[jj];
                           }

                        RB_newDbl = (double *) (malloc(SzD));
                        if(RB_newDbl == NULL)
                           {
                           printf("memory has been exhausted during RB-Tree alloction for LFNOINT analysis\n");
                           exit(-1);
                           }
                        *RB_newDbl = RB_newKey2; /**rac->localID; **/
                        RBTreeInsert(Check_RB_Tree,RB_newDbl, RB_cond);
                        }
                     }
                  } /** end found a condition ***/
               } /*** end is the first time seeing this line ***/
            else if((part1 > 0) && (rlc->numnodes > 0) && (rlc->firstencounter == 0)) /** seen this line before ***/
               {
               RB_newKey2 = rlc->idn + (checkinstance * 0.0001);
               if(( RB_newNode = RBExactQuery(Check_RB_Tree,&RB_newKey2)))
                  { /** then we have an entry for this line ***/
                  RB_cond = (struct ConditionCollection *) RB_newNode->info;
                  if(RB_cond->counter > 0)
                     {
                     bothmatch = RB_cond->featureidn;
                     keepit = 1;

                     for(ii = 0; ii < rlc->numnodes; ii++)
                        {
                        if((rlc->x[ii] >= minx) && (rlc->x[ii] <= maxx) && (rlc->y[ii] >= miny) && (rlc->y[ii] <= maxy))
                           {
                           rln = root;
                           if(rln->idn == bothmatch)
                              rln = rln->next;
                           while(rln != NULL)
                              {
                              if((CombinedCheckApplies(rln->idn,checkinstance,ISOLINE,rln->Lindex,rln->Sindex,
                                   SCCtable[rln->Sindex].C,SCCtable[rln->Sindex].S,SCCtable[rln->Sindex].D,
                                      &part1s,&part2s,&part3s) > 0) && (part3s > 0))
                                 {
                                 for(jj=0; jj < rln->numnodes; jj++)
                                    {
                                    if((rln->x[jj] >= minx) && (rln->x[jj] <= maxx) && (rln->y[jj] >= miny) && (rln->y[jj] <= maxy))
                                       {
                                       if(Distance(rlc->x[ii],rlc->y[ii],rln->x[jj],rln->y[jj]) <= ActiveChecks[checkinstance].sensitivity)
                                          {
                                          keepit = 0;
                                          j = 0;
                                          rac = NULL;
                                          break;
                                          }
                                       }
                                    }
                                 }
                              if(keepit < 1)
                                 break;
                              rln = rln->next;
                              if((rln != NULL) && (rln->idn == bothmatch))
                                 rln = rln->next;
                              }
                           if(keepit > 0)
                              { 
                              rpc = Proot;
                              while(rpc != NULL)
                                 {
                                 if((CombinedCheckApplies(rpc->idn,checkinstance,ISOLINE,rpc->Lindex,rpc->Sindex,
                                   SCCtable[rpc->Sindex].C,SCCtable[rpc->Sindex].S,SCCtable[rpc->Sindex].D,
                                   &part1s,&part2s,&part3s) > 0) && (part3s > 0))
                                    {
                                    if(Distance(rlc->x[ii],rlc->y[ii],rpc->x[0],rpc->y[0]) <= ActiveChecks[checkinstance].sensitivity)
                                       {
                                       keepit = 0;
                                       j = 0;
                                       rac = NULL;
                                       break;
                                       }
                                    }
                                 rpc = rpc->next;
                                 }
                              }

                           if(keepit > 0)
                              {
                              ran2 = Aroot;
                              while(ran2 != NULL)
                                 {
                                 if((CombinedCheckApplies(ran2->idn,checkinstance,ISOLINE,ran2->Lindex,ran2->Sindex,
                                   SCCtable[ran2->Sindex].C,SCCtable[ran2->Sindex].S,SCCtable[ran2->Sindex].D,
                                   &part1s,&part2s,&part3s) > 0) && (part3s > 0))
                                    {
                                    if(ran2->RB_Tree_Edgelist == NULL)
                                       ptadist3 = PointToSmallArealDist2D(rlc->x[ii], rlc->y[ii],ran2,&unusedint,&unuseddbl);
                                    else
                                       ptadist3 = PointToLargeArealDist2D(rlc->x[ii], rlc->y[ii],ran2,&unusedint,&unuseddbl);
                                    if(ptadist3 <= ActiveChecks[checkinstance].sensitivity)
                                       {
                                       keepit = 0;
                                       j = 0;
                                       rac = NULL;
                                       break;
                                       }
                                    }
                                 ran2 = ran2->next;
                                 }
                              }
                           }
                        if(keepit < 1)
                           break;
                        }
   
                     if(keepit > 0)
                        {
                        j = 1; /** assume stil have a condition ***/
                        rah = Aroot;
                        }
                     else
                        {
                        j = 0;
                        rah = NULL;
                        }
                     while(rah != NULL)
                        {
                        if((rah->ishole > 0) && (rah->idn == bothmatch))
                           {
                           k = LinePartOrAllInsideArea(rlc, rah, &i2, &i3,
                                      ActiveChecks[checkinstance].sensitivity, 99.9);
                           if(k == 1)
                              {
                              j = 0;
                              break;
                              }
                           else
                              {
                              for(i2 = 0; i2 < rlc->numnodes; i2++)
                                 {
                                 if(rah->RB_Tree_Edgelist == NULL)
                                    {
                                    if((PointIsVertex(rlc->x[i2],rlc->y[i2],
                                               rah->x,rah->y,rah->x,rah->numverts,&unuseddbl) > 0) ||
                                       (PointOnEdge(rlc->x[i2],rlc->y[i2],
                                           rah->x,rah->y,rah->x,rah->numverts,&unuseddbl,&unusedint) > 0))
                                       {
                                       j = 0;
                                       break;
                                       }
                                    }
                                 else
                                    {
                                    if((PointIsLargeArealVertex(rlc->x[i2],rlc->y[i2],rah,&unuseddbl) > 0) ||
                                       (PointOnLargeArealEdge(rlc->x[i2],rlc->y[i2],rah,&unuseddbl,&unusedint) > 0))
                                       {
                                       j = 0;
                                       break;
                                       }
                                    }
                                 }
                              }
                           }
                        if(j == 0)
                           break;
                        rah = rah->next;
                        }
                     if(j == 0) /*** a condition is no longer possible **/
                        RB_cond->counter = 0; /** should be a flag to prune now without writing **/
                     } /** entry's counter had not already been set to zero ***/
                  } /** end had an RB tree entry already ***/
               } /** seen this line before ***/
            }  /*** end ISOLINE check ***/


         if(CombinedCheckApplies(rlc->idn,checkinstance,LINSIDEA,rlc->Lindex,rlc->Sindex,Config1,Strat1,Domain1,&part1,&part2,&part3) > 0)
            {
            if((part1 > 0) && (rlc->numnodes > 0))
               {
               if(rlc_partialcopy == NULL)
                  {
                  rlc_partialcopy = (struct RawLinear *) (malloc(sizeof(struct RawLinear)));
                  rlc_partialcopy->next = NULL;
                  rlc_partialcopy->areastr = NULL;
                  rlc_partialcopy->hgtstr = NULL;
                  rlc_partialcopy->zv2str = NULL;
                  rlc_partialcopy->lenstr = NULL;
                  rlc_partialcopy->namstr = NULL;

                  rlc_partialcopy->x = (double *) (malloc(SzD * 2));
                  rlc_partialcopy->y = (double *) (malloc(SzD * 2));
                  rlc_partialcopy->z = (double *) (malloc(SzD * 2));
                  rlc_partialcopy->numnodes = 2;
                  }
               rlc_partialcopy->featureid = rlc->featureid;
               rlc_partialcopy->Lindex = rlc->Lindex;
               rlc_partialcopy->Sindex = rlc->Sindex;
               rlc_partialcopy->IsMulti = rlc->IsMulti;
               rlc_partialcopy->idn = rlc->idn;
               i = 0;
               rac = Aroot;
               while(rac != NULL)
                  {
                  Config2 = SCCtable[rac->Sindex].C;
                  Strat2 = SCCtable[rac->Sindex].S;
                  Domain2 = SCCtable[rac->Sindex].D;
                  if((rac->ishole <= 0) && (CombinedCheckApplies(rac->idn,checkinstance,LINSIDEA,rac->Lindex,rac->Sindex,
                            Config2,Strat2,Domain2,&part1,&part2,&part3) > 0))
                     {
                     if(part2 > 0)
                        {
                        for(kk =1; kk < rlc->numnodes; kk++)
                           {
                           kk2 = kk - 1;
                           x1 = rlc->x[kk2];
                           y1 = rlc->y[kk2];
                           z1 = rlc->z[kk2];
                           x2 = rlc->x[kk];
                           y2 = rlc->y[kk];
                           z2 = rlc->z[kk];

                           if(ClipLineToRegion(minx,miny,maxx,maxy,&x1,&y1,&z1,&x2,&y2,&z2,&clipflag,multiplier) > 0)
                              {
                              rlc_partialcopy->x[0] = rlc->x[kk2];
                              rlc_partialcopy->y[0] = rlc->y[kk2];
                              rlc_partialcopy->z[0] = rlc->z[kk2];
                              rlc_partialcopy->x[1] = rlc->x[kk];
                              rlc_partialcopy->y[1] = rlc->y[kk];
                              rlc_partialcopy->z[1] = rlc->z[kk];
                              i = LinePartOrAllInsideArea(rlc_partialcopy, rac, &i2, &i3, ActiveChecks[checkinstance].sensitivity,
                                    ActiveChecks[checkinstance].sensitivity2);
                              if((i > 0) && (rac->ishole < 0))
                                 {
                                 rah = Aroot;
                                 while(rah != NULL)
                                    {
                                    if((rah->ishole > 0) && (rah->idn == rac->idn))
                                       {
                                       j = LineAllInsideArea(rlc_partialcopy,rah,ActiveChecks[checkinstance].sensitivity);
                                       if(j > 0)
                                          {
                                          i = 0;
                                          break;
                                          }
                                       }
                                    rah = rah->next;
                                    }
                                 }

                              if(i > 0) /**ready to report a condition - should this be cancelled by a tertiary participant? ***/
                                 {
                                 minLx = rlc->x[kk];
                                 maxLx = rlc->x[kk2];
                                 if(rlc->x[kk2] < rlc->x[kk])
                                    {
                                    minLx = rlc->x[kk2];
                                    maxLx = rlc->x[kk];
                                    }
                                 minLy = rlc->y[kk];
                                 maxLy = rlc->y[kk2];
                                 if(rlc->y[kk2] < rlc->y[kk])
                                    {
                                    minLy = rlc->y[kk2];
                                    maxLy = rlc->y[kk];
                                    }
                                 rln = root;

                                 while(rln != NULL)
                                    {
                                    if(rln != rlc)
                                       {
                                       Config2 = SCCtable[rln->Sindex].C;
                                       Strat2 = SCCtable[rln->Sindex].S;
                                       Domain2 = SCCtable[rln->Sindex].D;
                                       if((CombinedCheckApplies(rln->idn,checkinstance,LINSIDEA,rln->Lindex,rln->Sindex,
                                           Config2,Strat2,Domain2,&part1,&part2,&part3) > 0) && (part3 > 0))
                                          {
                                          ii4 = 0;
                                          for(ii5 = 1; ii5 < rln->numnodes; ii5++)
                                             {
                                             if(MergeSeg_LineSegmentsOverlap(rlc->x[kk],rlc->y[kk],rlc->x[kk2],rlc->y[kk2],
                                                             rln->x[ii4],rln->y[ii4],rln->x[ii5],rln->y[ii5],
                                                              minLx,maxLx,minLy,maxLy, &unuseddbl,&unuseddbl2,&unuseddbl3,&unuseddbl4,
                                                               ActiveChecks[checkinstance].sensitivity) > 0)
                                                {
                                                i = -1;
                                                break;
                                                }
                                             ii4 = ii5;
                                             }
                                          }
                                       }
                                    if(i < 1)
                                       break;
                                    rln = rln->next;
                                    }
                                 if(i > 0)  /** now check area tertiary participants, if necessary ***/
                                    {
                                    ran = Aroot;
                                    ii5 = ii4 = 0;
                                    while(ran != NULL)
                                       {
                                       Config2 = SCCtable[ran->Sindex].C;
                                       Strat2 = SCCtable[ran->Sindex].S;
                                       Domain2 = SCCtable[ran->Sindex].D;
                                       if((ran->ishole <= 0) && (CombinedCheckApplies(ran->idn,checkinstance,LINSIDEA,ran->Lindex,ran->Sindex,
                                              Config2,Strat2,Domain2,&part1,&part2,&part3) > 0))
                                          {
                                          if(part3 > 0)
                                             {
                                             ii5 = LineAllInsideArea(rlc,ran,ActiveChecks[checkinstance].sensitivity);
                                             if(ii5 > 0)
                                                {
                                                rah = Aroot;
                                                ii4 = 0;
                                                while(rah != NULL)
                                                   {
                                                   if((rah->ishole > 0) && (rah->idn == ran->idn))
                                                      {
                                                      ii4 = LineAllInsideArea(rlc_partialcopy,rah,ActiveChecks[checkinstance].sensitivity);
                                                      if(ii4 > 0)
                                                         {
                                                         break;
                                                         }
                                                      }
                                                   rah = rah->next;
                                                   }
                                                break;
                                                }
                                             if((ii5 > 0) && (ii4 == 0))
                                                {
                                                i = -1;
                                                break;
                                                }
                                             }
                                          }
                                       ran = ran->next;
                                       }
                                    }
                                 }
                              if(i < 0)
                                 break;
                              if(i > 0)
                                 {
                                 ERc = (struct collection *) (malloc(SzC));
                                 if(ERc == NULL)
                                    {
                                    printf("allocation memory exhausted during linear feature condition analysis\n");
                                    printf("processing cannot continue\n");
                                    exit(-1);
                                    }
                                 ERc->x[0] = rlc->x[kk];
                                 ERc->y[0] = rlc->y[kk];
                                 ERc->z[0] = rlc->z[kk];
                                 
                                 ERc->x[1] = rlc->x[kk2];
                                 ERc->y[1] = rlc->y[kk2];
                                 ERc->z[1] = rlc->z[kk2];
                                 ERc->magnitude = 0.0;
                                 ERc->keyval = LINSIDEA;
                                 ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                                 ERc->IDN = rlc->idn;
                                 ERc->Sindex = rlc->Sindex;
                                 ERc->ll1 = rlc;
                                 ERc->vertexindex1 = kk;
                                 ERc->ll2 = NULL;
                                 ERc->aa = rac;
                                 ERc->vertexindex2 = kk2;
                                 ERc->next = NULL;
                                 if(ERroot == NULL)
                                    {
                                    ERroot = ERc;
                                    }
                                 else
                                    {
                                    ERn = ERroot;
                                    while(ERn != NULL)
                                       {
                                       if((ERn->Cnumber == ERc->Cnumber) && (ERn->keyval == ERc->keyval) && (ERn->ll1 == ERc->ll1) &&
                                             (ERn->aa == ERc->aa) &&
                                          (((ERc->vertexindex1 == ERn->vertexindex1) && (ERc->vertexindex2 == ERn->vertexindex2)) ||
                                             ((ERc->vertexindex1 == ERn->vertexindex2) && (ERc->vertexindex2 == ERn->vertexindex1))) &&
                                          (ERn->ll1->localID == ERc->ll1->localID))
                                          break;
               
                                       ERn = ERn->next;
                                       }
                                    if(ERn == NULL)
                                       {
                                       ERc->next = ERroot;
                                       ERroot = ERc;
                                       }
                                    else
                                      free(ERc);
                                    }
                                 break;   
                                 }
                              } /*** end if clip line to region ... ***/
                           } /** end for kk **/
                        } /** end if part2 ***/
                     } /*** end check applies to the area feature ***/
                  rac = rac->next;
                  } /*** end while rac != NULL ***/
               } /** end check applies to line feature ***/
            }  /*** end LINSIDEA check ***/



         if(CombinedCheckApplies(rlc->idn,checkinstance,LSEGCOVERA,rlc->Lindex,rlc->Sindex,Config1,Strat1,Domain1,&part1,&part2,&part3) > 0)
            {
            if(part1 > 0)
               {
               found_one = 0;
               tempsensitivity = ActiveChecks[checkinstance].sensitivity;
               if(tempsensitivity < 0.001)
                  tempsensitivity = 0.001;
               for(i=1; i<rlc->numnodes; i++)
                  {
                  ii = i - 1;

                  x1 = rlc->x[ii];
                  y1 = rlc->y[ii];
                  z1 = rlc->z[ii];
                  x2 = rlc->x[i];
                  y2 = rlc->y[i];
                  z2 = rlc->z[i];
                  if(ClipLineToRegion(minx,miny,maxx,maxy,&x1,&y1,&z1,&x2,&y2,&z2,&clipflag,multiplier) > 0)
                     {
                     rac = Aroot;
                     while(rac != NULL)
                        {
                        Config2 = SCCtable[rac->Sindex].C;
                        Strat2 = SCCtable[rac->Sindex].S;
                        Domain2 = SCCtable[rac->Sindex].D;
                        if(CombinedCheckApplies(rac->idn,checkinstance,LSEGCOVERA,rac->Lindex,rac->Sindex,
                                  Config2,Strat2,Domain2,&part1,&part2,&part3) > 0)
                           {
                           if(part2 > 0)
                              {
                              for(j=1; j<rac->numverts; j++)
                                 {
                                 if(MatchLinearSegment2D(x1,y1,x2,y2,
                                                         rac->x[j-1],rac->y[j-1],rac->x[j],rac->y[j],&MatchLen,
                                                         ActiveChecks[checkinstance].sensitivity) > 0)
                                    {
                                    if(MatchLen >= tempsensitivity)
                                       {
                                       found_one = 1;
                                       kk = j - 1;
                                       kk2 = j;
                                       break;
                                       }
                                    }
                                 }
                              if(j == rac->numverts) /*** check last edge of area feature ***/
                                 {
                                 if(MatchLinearSegment2D(x1,y1,x2,y2,
                                                      rac->x[0],rac->y[0],rac->x[j-1],rac->y[j-1],&MatchLen,
                                                         ActiveChecks[checkinstance].sensitivity) > 0)
                                    {
                                    if(MatchLen >= tempsensitivity)
                                       {
                                       found_one = 1;
                                       kk = 0;
                                       kk2 = j - 1;
                                       }
                                    }
                                 }
                              if(found_one > 0)
                                 {
                                 found_one = 0;
                              ERc = (struct collection *) (malloc(SzC));
                              if(ERc == NULL)
                                 {
                                 printf("allocation memory exhausted during linear feature condition analysis\n");
                                 printf("processing cannot continue\n");
                                 exit(-1);
                                 }
                              ERc->x[0] = rlc->x[i];
                              ERc->y[0] = rlc->y[i];
                              ERc->z[0] = rlc->z[i];

                              ERc->x[1] = rlc->x[ii];
                              ERc->y[1] = rlc->y[ii];
                              ERc->z[1] = rlc->z[ii];

                              ERc->x[2] = rac->x[kk];
                              ERc->y[2] = rac->y[kk];
                              ERc->z[2] = rac->z[kk];
                              ERc->x[3] = rac->x[kk2];
                              ERc->y[3] = rac->y[kk2];
                              ERc->z[3] = rac->z[kk2]; 

                              ERc->magnitude = 0.0;
                              ERc->keyval = LSEGCOVERA;
                              ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                              ERc->IDN = rlc->idn;
                              ERc->Sindex = rlc->Sindex;
                              ERc->ll1 = rlc;
                              ERc->vertexindex1 = i;
                              ERc->ll2 = NULL;
                              ERc->aa = rac;
                              ERc->vertexindex2 = ii;
                              ERc->next = NULL;
                              if(ERroot == NULL)
                                 {
                                 ERroot = ERc;
                                 }
                              else
                                 {
                                 ERn = ERroot;
                                 while(ERn != NULL)
                                    {
                                    if((ERn->Cnumber == ERc->Cnumber) && (ERn->keyval == ERc->keyval) && (ERn->ll1 == ERc->ll1) &&
                                       (ERn->ll1->localID == ERc->ll1->localID))
                                       break;

                                    ERn = ERn->next;
                                    }
                                 if(ERn == NULL)
                                    {
                                    ERc->next = ERroot;
                                    ERroot = ERc;
                                    }
                                 else
                                   free(ERc);
                                 }

                                 }
                              } /**** end part2 > 0 ****/
                           } /**** end LSEGCOVERA check applies to rac ***/
                        rac = rac->next;
                        } /*** end while rac ****/
                     } /*** end clip line to region ****/
                  } /*** end for i = ... ****/
               }   /*** end part1 > 0 ****/
           } /*** end LSEGCOVERA check applies to rlc ****/




         if(CombinedCheckApplies(rlc->idn,checkinstance,LEAON_NOTIN,rlc->Lindex,rlc->Sindex,Config1,Strat1,Domain1,&part1,&part2,&part3) > 0)
            {
            if((part1 > 0) && (rlc->numnodes > 0))
               {
               j = 0;
               while(j < rlc->numnodes)
                  {
                  checkit = 0;
                  rln = root;
                  while(rln != NULL)
                     {
                     if((rln != rlc) && (CombinedCheckApplies(rln->idn,checkinstance,LEAON_NOTIN,rln->Lindex,rln->Sindex,SCCtable[rln->Sindex].C,
                                SCCtable[rln->Sindex].S,SCCtable[rln->Sindex].D,&part1,&part2,&part3) > 0) &&
                                (part1 > 0))
                        {
                        for(i=0; i<rln->numnodes; i++)
                           {
                           ptpdist1 = Distance3D(rlc->x[j],rlc->y[j],rlc->z[j],rln->x[i],rln->y[i],rln->z[i]);
                           if(ptpdist1 <= ActiveChecks[checkinstance].sensitivity)
                              {
                              checkit = 1;
                              break;
                              }
                           }
                        }
                     if(checkit > 0)
                        break;
                     rln = rln->next;
                     }
                  i = 0;
                  if(checkit == 0)
                     {
                     rac = Aroot;
                     while(rac != NULL)
                        {
                        i = 0;
                        Config2 = SCCtable[rac->Sindex].C;
                        Strat2 = SCCtable[rac->Sindex].S;
                        Domain2 = SCCtable[rac->Sindex].D;
                        if(CombinedCheckApplies(rac->idn,checkinstance,LEAON_NOTIN,rac->Lindex,rac->Sindex,
                               Config2,Strat2,Domain2,&part1,&part2,&part3) > 0)
                           {
                           if(part2 > 0)
                              {
                              i = 0;
                              if((rlc->x[j] >= minx) && (rlc->x[j] <= maxx) &&
                                  (rlc->y[j] >= miny) && (rlc->y[j] <= maxy))
                                 {
                                 if(rac->RB_Tree_Edgelist == NULL)
                                    ptadist1 = PointToSmallArealDist2D(rlc->x[j], rlc->y[j],rac,&AreaIndex,&unuseddbl);
                                 else
                                    ptadist1 = PointToLargeArealDist2D(rlc->x[j], rlc->y[j],rac,&AreaIndex,&unuseddbl);

                                 if((ptadist1 >= 0) && (ptadist1 <= ActiveChecks[checkinstance].sensitivity))
                                    {
                                    if(AreaIndex == 0)
                                      kk2 = rac->numverts - 1;
                                    else
                                      kk2 = AreaIndex - 1;

                                    if(j == 0)
                                       jj2 = 1;
                                    else
                                       jj2 = j - 1;
                                    if(LineSegmentsOverlap(rlc->x[j],rlc->y[j],rlc->x[jj2],rlc->y[jj2],
                                                             rac->x[AreaIndex],rac->y[AreaIndex],rac->x[kk2],rac->y[kk2],
                                                             &unuseddbl,&unuseddbl2,&unuseddbl3,&unuseddbl4,
                                                               ActiveChecks[checkinstance].sensitivity) > 0)
                                       {
                                       if(AreaIndex == (rac->numverts - 1))
                                          AreaIndex -= 1;
                                       i = 4;
                                       }
                                    if(i == 0)
                                       {
                                       if(AreaIndex >= (rac->numverts -1 ))
                                         kk2 = 0;
                                       else
                                         kk2 = AreaIndex + 1;
                                       if(LineSegmentsOverlap(rlc->x[j],rlc->y[j],rlc->x[jj2],rlc->y[jj2],
                                                             rac->x[AreaIndex],rac->y[AreaIndex],rac->x[kk2],rac->y[kk2],
                                                             &unuseddbl,&unuseddbl2,&unuseddbl3,&unuseddbl4,
                                                               ActiveChecks[checkinstance].sensitivity) > 0)
                                          {
                                       if(AreaIndex == (rac->numverts - 1))
                                          AreaIndex -= 1;
                                          i = 5;
                                          }
                                       }

                                    if(i == 0)
                                       {
                                    if(AreaIndex == (rac->numverts - 1))
                                       AreaIndex -= 1;
                                    if(j == 0)
                                       ii3 = j + 1;
                                    else
                                       ii3 = rlc->numnodes - 2;
                                    while((rlc->x[j] == rlc->x[ii3]) && (rlc->y[j] == rlc->y[ii3]))
                                       {
                                       if(j == 0)
                                          ii3 += 1;
                                       else
                                          ii3 -= 1;
                                       if((ii3 < 0) || (ii3 >= rlc->numnodes))
                                          {
                                          ii3 = -10;
                                          i = 0;
                                          break;
                                          }
                                       }
                                    if(ii3 >= 0)
                                       {
                                       segdist = Distance(rlc->x[j],rlc->y[j],rlc->x[ii3],rlc->y[ii3]);
                                       FindAzimuthInteriorPoint(rlc->x[j],rlc->y[j],rlc->x[ii3],rlc->y[ii3],segdist,0.1,&xi2,&yi2);
                                       if(rac->RB_Tree_Edgelist == NULL)
                                          {
                                          i = 1;
                                          if(PointIsInside(xi2,yi2,rac->x,rac->y,rac->x,rac->numverts,C_AREA,&unuseddbl))
                                             {
                                             i = 0;
                                             }
                                          }
                                       else
                                          {
                                          i = 1;
                                          if(PointInsideLargeAreal(xi2,yi2,rac,&unusedint) > 0)
                                             {
                                             i = 0;
                                             }
                                          }
                                       }
                                    }
                                 }
                                 }

                              if(i > 0)
                                 {
                                 ERc = (struct collection *) (malloc(SzC));
                                 if(ERc == NULL)
                                    {
                                    printf("allocation memory exhausted during linear feature condition analysis\n");
                                    printf("processing cannot continue\n");
                                    exit(-1);
                                    }
                                 if(j == 0)
                                    {
                                    ERc->x[0] = rlc->x[0];
                                    ERc->y[0] = rlc->y[0];
                                    ERc->z[0] = rlc->z[0];

                                    ERc->x[1] = rlc->x[1];
                                    ERc->y[1] = rlc->y[1];
                                    ERc->z[1] = rlc->z[1];
                                    }
                                 else
                                    {
                                    ERc->x[0] = rlc->x[rlc->numnodes - 1];
                                    ERc->y[0] = rlc->y[rlc->numnodes - 1];
                                    ERc->z[0] = rlc->z[rlc->numnodes - 1];

                                    ERc->x[1] = rlc->x[rlc->numnodes - 2];
                                    ERc->y[1] = rlc->y[rlc->numnodes - 2];
                                    ERc->z[1] = rlc->z[rlc->numnodes - 2];
                                    }

                                 ERc->magnitude = 0.0;
                                 ERc->keyval = LEAON_NOTIN;
                                 ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                                 ERc->IDN = rlc->idn;
                                 ERc->Sindex = rlc->Sindex;
                                 ERc->ll1 = rlc;
                                 ERc->aa = rac;
                                 ERc->vertexindex1 = AreaIndex;
                                 ERc->ll2 = NULL;
                                 ERc->next = NULL;
                                 if(ERroot == NULL)
                                    {
                                    ERroot = ERc;
                                    }
                                 else
                                    {
                                    ERn = ERroot;
                                    while(ERn != NULL)
                                       {
                                       if((ERn->Cnumber == ERc->Cnumber) && (ERn->keyval == ERc->keyval) && (ERn->ll1 == ERc->ll1) &&
                                          (ERn->ll1->localID == ERc->ll1->localID) && (ERn->aa == ERc->aa) && (ERn->x[0] == ERc->x[0]) &&
                                              (ERn->y[0] == ERc->y[0]) && (ERn->z[0] == ERc->z[0]))
                                          break;

                                       ERn = ERn->next;
                                       }
                                    if(ERn == NULL)
                                       {
                                       ERc->next = ERroot;
                                       ERroot = ERc;
                                       }
                                    else
                                      free(ERc);
                                    }
                                 }
                              } /** end if part2 ***/
                           } /*** end check applies to the area feature ***/
                        /**if(i > 0)
                           break;**/
                        rac = rac->next;
                        } /*** end while rac != NULL ***/
                     } /** end checkit against area features ***/
                  j = j + rlc->numnodes - 1;
                  } /*** end j < rlc->numnodes ... ***/
               } /** end check applies to line feature ***/
            }  /*** end LEAON_NOTIN check ***/




         if(CombinedCheckApplies(rlc->idn,checkinstance,LEINSIDEA,rlc->Lindex,rlc->Sindex,Config1,Strat1,Domain1,&part1,&part2,&part3) > 0)
            {
            if((part1 > 0) && (rlc->numnodes > 0))
               {
               j = 0;
               while(j < rlc->numnodes)
                  {
                  checkit = 0;
                  rln = root;
                  while(rln != NULL)
                     {
                     if((rln != rlc) && (CombinedCheckApplies(rln->idn,checkinstance,LEINSIDEA,rln->Lindex,rln->Sindex,SCCtable[rln->Sindex].C,
                                SCCtable[rln->Sindex].S,SCCtable[rln->Sindex].D,&part1,&part2,&part3) > 0) &&
                                (part1 > 0))
                        {
                        for(i=0; i<rln->numnodes; i++)
                           {
                           ptpdist1 = Distance3D(rlc->x[j],rlc->y[j],rlc->z[j],rln->x[i],rln->y[i],rln->z[i]);
                           if(ptpdist1 <= ActiveChecks[checkinstance].sensitivity)
                              {
                              checkit = 1;
                              break;
                              }
                           }
                        }
                     if(checkit > 0)
                        break;
                     rln = rln->next;
                     }
                  i = 0;
                  if(checkit == 0)
                     {
                     rac = Aroot;
                     while(rac != NULL)
                        {
                        i = 0;
                        Config2 = SCCtable[rac->Sindex].C;
                        Strat2 = SCCtable[rac->Sindex].S;
                        Domain2 = SCCtable[rac->Sindex].D;
                        if(CombinedCheckApplies(rac->idn,checkinstance,LEINSIDEA,rac->Lindex,rac->Sindex,
                               Config2,Strat2,Domain2,&part1,&part2,&part3) > 0)
                           {
                           if(part2 > 0)
                              {
                              i = 0;
                              if((rlc->x[j] >= minx) && (rlc->x[j] <= maxx) &&
                                  (rlc->y[j] >= miny) && (rlc->y[j] <= maxy))
                                 {
                                 if(rac->RB_Tree_Edgelist == NULL)
                                    {
                                    if(PointIsVertex(rlc->x[j],rlc->y[j],rac->x,rac->y,rac->x,rac->numverts,&unuseddbl) <= 0)
                                       {
                                       if(PointOnEdge(rlc->x[j],rlc->y[j],rac->x,rac->y,rac->x,rac->numverts,&unuseddbl,&unusedint) <= 0)
                                          {
                                          if(PointIsInside(rlc->x[j],rlc->y[j],rac->x,rac->y,rac->x,rac->numverts,C_AREA,&unuseddbl) > 0)
                                             i = 1;
                                          }
                                       }
                                    }
                                 else
                                    {
                                    if(PointIsLargeArealVertex(rlc->x[j],rlc->y[j],rac,&unuseddbl) <= 0)
                                       {
                                       if(PointOnLargeArealEdge(rlc->x[j],rlc->y[j],rac,&unuseddbl,&unusedint) <= 0)
                                          {
                                          if(PointInsideLargeAreal(rlc->x[j],rlc->y[j],rac,&unusedint) > 0)
                                             i = 1;
                                          }
                                       }
                                    }
                                 }
   
                              if(i > 0)
                                 {
                                 ERc = (struct collection *) (malloc(SzC));
                                 if(ERc == NULL)
                                    {
                                    printf("allocation memory exhausted during linear feature condition analysis\n");
                                    printf("processing cannot continue\n");
                                    exit(-1);
                                    }
                                 if(j == 0)
                                    {
                                    ERc->x[0] = rlc->x[0];
                                    ERc->y[0] = rlc->y[0];
                                    ERc->z[0] = rlc->z[0];
   
                                    ERc->x[1] = rlc->x[1];
                                    ERc->y[1] = rlc->y[1];
                                    ERc->z[1] = rlc->z[1];
                                    }
                                 else
                                    {
                                    ERc->x[0] = rlc->x[rlc->numnodes - 1];
                                    ERc->y[0] = rlc->y[rlc->numnodes - 1];
                                    ERc->z[0] = rlc->z[rlc->numnodes - 1];
                                    
                                    ERc->x[1] = rlc->x[rlc->numnodes - 2];
                                    ERc->y[1] = rlc->y[rlc->numnodes - 2];
                                    ERc->z[1] = rlc->z[rlc->numnodes - 2];
                                    }

                                 ERc->magnitude = 0.0;
                                 ERc->keyval = LEINSIDEA;
                                 ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                                 ERc->IDN = rlc->idn;
                                 ERc->Sindex = rlc->Sindex;
                                 ERc->ll1 = rlc;
                                 if(j == 0)
                                    {
                                    ERc->vertexindex1 = 0;
                                    ERc->vertexindex2 = 1;
                                    }
                                 else
                                    {
                                    ERc->vertexindex1 = rlc->numnodes - 1;
                                    ERc->vertexindex2 = rlc->numnodes - 2;
                                    }
                                 ERc->ll2 = NULL;
                                 ERc->next = NULL;
                                 if(ERroot == NULL)
                                    {
                                    ERroot = ERc;
                                    }
                                 else
                                    {
                                    ERn = ERroot;
                                    while(ERn != NULL)
                                       {
                                       if((ERn->Cnumber == ERc->Cnumber) && (ERn->keyval == ERc->keyval) && (ERn->ll1 == ERc->ll1) &&
                                          (((ERc->vertexindex1 == ERn->vertexindex1) && (ERc->vertexindex2 == ERn->vertexindex2)) ||
                                             ((ERc->vertexindex1 == ERn->vertexindex2) && (ERc->vertexindex2 == ERn->vertexindex1))) &&
                                          (ERn->ll1->localID == ERc->ll1->localID))
                                          break;
   
                                       ERn = ERn->next;
                                       }
                                    if(ERn == NULL)
                                       {
                                       ERc->next = ERroot;
                                       ERroot = ERc;
                                       }
                                    else
                                      free(ERc);
                                    }
                                 }
                              } /** end if part2 ***/
                           } /*** end check applies to the area feature ***/
                        if(i > 0)
                           break;
                        rac = rac->next;
                        } /*** end while rac != NULL ***/
                     } /** end checkit against area features ***/
                  j = j + rlc->numnodes - 1;
                  } /*** end j < rlc->numnodes ... ***/
               } /** end check applies to line feature ***/
            }  /*** end LEINSIDEA check ***/



         if(CombinedCheckApplies(rlc->idn,checkinstance,LSPANFAIL,
                 rlc->Lindex,rlc->Sindex,Config1,Strat1,Domain1,&part1,&part2,&part3) > 0)
            {
            if(part1 > 0)
               {
               found_one = 0;
               ii2 = ii3 = -99;  /*** holds indices of verts of consecutive uncovered edges ***/
               finalnodecovered = startnodecovered = -1;
               for(i=1; i<rlc->numnodes; i++)
                  {
                  ii = i - 1;

                  x1 = rlc->x[ii];
                  y1 = rlc->y[ii];
                  z1 = rlc->z[ii];
                  x2 = rlc->x[i];
                  y2 = rlc->y[i];
                  z2 = rlc->z[i];
                  if(ClipLineToRegion(minx,miny,maxx,maxy,&x1,&y1,&z1,&x2,&y2,&z2,&clipflag,multiplier) > 0)
                     {
                     LenToCover = Distance(x1,y1,x2,y2);
                     //LenToCover *= 0.99;
                     LenToCover -= 0.1;
                     CoveredSoFar = 0.0;

                     if(CoveredSoFar < LenToCover) /*** check to see if an area feature face will cover the linear ***/
                        {
                        rac = Aroot;
                        while(rac != NULL)
                           {
                           if(rac->ishole <= 0)
                              IsCutout = 0;
                           else
                              IsCutout = 1;
                           if(1)
                              {
                              Config2 = SCCtable[rac->Sindex].C;
                              Strat2 = SCCtable[rac->Sindex].S;
                              Domain2 = SCCtable[rac->Sindex].D;
                              if(CombinedCheckApplies(rac->idn,checkinstance,LSPANFAIL,rac->Lindex,rac->Sindex,
                                     Config2,Strat2,Domain2,&part1,&part2,&part3) > 0)
                                 {
                                 if(part2 > 0)
                                    {
                                    if((i == 1) || (i == (rlc->numnodes - 1)))
                                       {
                                       if(rac->RB_Tree_Edgelist == NULL)
                                          {
                                          ptpdist1 = PointToSmallArealDist2D(rlc->x[0], rlc->y[0],rac,&unusedint,&unuseddbl);
                                          ptpdist2 = PointToSmallArealDist2D(rlc->x[rlc->numnodes-1], rlc->y[rlc->numnodes-1],
                                               rac, &unusedint,&unuseddbl);
                                          }
                                       else
                                          {
                                          ptpdist1 = PointToLargeArealDist2D(rlc->x[0], rlc->y[0],rac,&unusedint,&unuseddbl);
                                          ptpdist2 = PointToSmallArealDist2D(rlc->x[rlc->numnodes-1], rlc->y[rlc->numnodes-1],
                                               rac, &unusedint,&unuseddbl);
                                          }
                                       if((ptpdist1 >= 0) && (ptpdist1 <= ActiveChecks[checkinstance].sensitivity))
                                          {
                                          startnodecovered = 1;
                                          }
                                       if((ptpdist2 >= 0) && (ptpdist2 <= ActiveChecks[checkinstance].sensitivity))
                                          {
                                          finalnodecovered = 1;
                                          }
                                       }
                                    inside1 = inside2 = 0;
                                    closeEdge1 = closeEdge2 = -100;
                                    inside1 = PointInsidePoly(x1,y1,rac->x, rac->y, rac->numverts);
                                    if(inside1 == 0)
                                       {
                                       if(PointToSmallArealDist2D(x1, y1,rac,&closeEdge1,&unuseddbl) <
                                                       ActiveChecks[checkinstance].sensitivity)
                                          inside1 = 1;
                                       }
                                    inside2 = PointInsidePoly(x2,y2,rac->x, rac->y, rac->numverts);
                                    if(inside2 == 0)
                                       {
                                       if(PointToSmallArealDist2D(x2, y2,rac,&closeEdge2,&unuseddbl) <
                                                       ActiveChecks[checkinstance].sensitivity)
                                          inside2 = 1;
                                       }
                                    if((inside1 == 1) && (inside2 == 1) && (closeEdge1 == closeEdge2))
                                       {
                                       minLx = x2;
                                       maxLx = x1;
                                       if(x1 < x2)
                                          {
                                          minLx = x1;
                                          maxLx = x2;
                                          }
                                       minLy = y2;
                                       maxLy = y1;
                                       if(x1 < x2)
                                          {
                                          minLy = y1;
                                          maxLy = y2;
                                          }
                                       jj = rac->numverts - 1;
                                       for(j = 0; j < rac->numverts; j++)
                                          {
                                          if(MergeSeg_LineSegmentsOverlap(x1,y1,x2,y2,rac->x[jj],rac->y[jj],rac->x[j],rac->y[j],
                                                                       minLx,maxLx,minLy,maxLy,&temp1,&temp2,&temp3,&temp4,
                                                                       ActiveChecks[checkinstance].sensitivity) > 0)
                                             {
                                             inside1 = inside2 = 0;
                                             break;
                                             }
                                          }
                                       if(j < rac->numverts)
                                          {
                                          rac = rac->next;
                                          continue;
                                          }
                                       }


                                    IntRoot = NULL;
                                    jj = rac->numverts - 1;
                                    for(j=0; j<rac->numverts; j++)
                                       {
                                       if((LineSegmentsIntersect(x1,y1,x2,y2,
                                                 rac->x[jj],rac->y[jj],rac->x[j],rac->y[j], &xi, &yi) > 0)&&
                                           (EqualWithinTolerance(x1,y1,xi,yi,ActiveChecks[checkinstance].sensitivity) <= 0) &&
                                           (EqualWithinTolerance(x2,y2,xi,yi,ActiveChecks[checkinstance].sensitivity) <= 0)) 
                                          {
                                          
                                          IRn = (struct IntersectionList *) (malloc(SzIL));
                                          IRn->x = xi;
                                          IRn->y = yi;
                                          IRn->dist = ((xi - x1) * (xi - x1)) + ((yi - y1) * (yi - y1));
                                          if(IntRoot == NULL)
                                             {
                                             IntRoot = IRn;
                                             IRn->next = NULL;
                                             }
                                          else
                                             {
                                             IRc = IRp = IntRoot;
                                             while(IRc != NULL)
                                                {
                                                if(IRn->dist < IRc->dist)
                                                   break;
                                                IRp = IRc;
                                                IRc = IRc->next;
                                                }
                                             if(IRc == NULL)
                                                {
                                                IRp->next = IRn;
                                                IRn->next = NULL;
                                                }
                                             else if(IRc == IntRoot)
                                                {
                                                IRn->next = IntRoot;
                                                IntRoot = IRn;
                                                }
                                             else
                                                {
                                                IRn->next = IRc;
                                                IRp->next = IRn;
                                                }
                                             }
                                          }

                                       jj = j;
                                       }
                                    if((inside1 > 0) && (inside2 > 0) && (IntRoot == NULL))/*** whole segment is inside this poly ***/
                                       {
                                       if(IsCutout == 0)
                                          CoveredSoFar += LenToCover;
                                       else
                                          CoveredSoFar -= LenToCover;
                                       }
                                    else if(IntRoot != NULL)  /*** must be some intersections - what parts are inside? ****/
                                       {
                                       fromx = x1;
                                       fromy = y1;
                                       IRc = IntRoot;
                                       if(inside1 > 0)
                                          {
                                          jj = 1;
                                          }
                                       else
                                          {
                                          jj = 0;
                                          }
                                       while(IRc != NULL)
                                          {
                                          if(jj == 1) /** add in the distance here ***/
                                             {
                                             if(IsCutout == 0)
                                                CoveredSoFar += Distance(fromx,fromy,IRc->x,IRc->y);
                                             else
                                                CoveredSoFar -= Distance(fromx,fromy,IRc->x,IRc->y);
                                             jj = 0;
                                             }
                                          else
                                             jj = 1;
                                          fromx = IRc->x;
                                          fromy = IRc->y;
                                          IRc = IRc->next;
                                          }
                                       if(jj > 0)
                                          {
                                          if(IsCutout == 0)
                                             CoveredSoFar += Distance(fromx,fromy,x2,y2);
                                          else
                                             CoveredSoFar -= Distance(fromx,fromy,x2,y2);
                                          }
                                       IRc = IntRoot;
                                       while(IRc != NULL)
                                          {
                                          IRp = IRc;
                                          IRc = IRc->next;
                                          free(IRp);
                                          }
                                       IntRoot = NULL;
                                       }
                                    } /**** end if(part3 > 0) ****/
                                 } /*** end combined check applies as tertiary for the area feature **/
                              }  /** end ishole indicates rac is an outer edge ***/

                           else if((i == 1) && 
                                    (CombinedCheckApplies(rac->idn,checkinstance,LSPANFAIL,rac->Lindex,rac->Sindex,
                                     SCCtable[rac->Sindex].C,SCCtable[rac->Sindex].S,SCCtable[rac->Sindex].D,
                                     &part1,&part2,&part3) > 0) && (part2 > 0))
                              {
                              if(rac->RB_Tree_Edgelist == NULL)
                                 {
                                 ptpdist1 = PointToSmallArealDist2D(rlc->x[0], rlc->y[0],rac,&unusedint,&unuseddbl);
                                 ptpdist2 = PointToSmallArealDist2D(rlc->x[rlc->numnodes - 1], rlc->y[rlc->numnodes - 1],rac,
                                      &unusedint,&unuseddbl);
                                 }
                              else
                                 {
                                 ptpdist1 = PointToLargeArealDist2D(rlc->x[0], rlc->y[0],rac,&unusedint,&unuseddbl);
                                 ptpdist2 = PointToSmallArealDist2D(rlc->x[rlc->numnodes-1], rlc->y[rlc->numnodes-1],rac,
                                      &unusedint,&unuseddbl);
                                 }
                              if((ptpdist1 >= 0) && (ptpdist1 <= ActiveChecks[checkinstance].sensitivity))
                                 {
                                 startnodecovered = 1;
                                 }
                              if((ptpdist2 >= 0) && (ptpdist2 <= ActiveChecks[checkinstance].sensitivity))
                                 {
                                 finalnodecovered = 1;
                                 }
                              }
                           rac = rac->next;
                           } /** end while rac ...   ***/
                        } /** end covered so far is not enough ***/


                     if(rlc->IsMulti >= 1)
                        {
                        RB_newKey2 = rlc->localID + (checkinstance * 0.0001);
                        if(( RB_newNode = RBExactQuery(Check_RB_Tree,&RB_newKey2)))
                           {
                           RB_cond = (struct ConditionCollection *) RB_newNode->info;
                           if(RB_cond->radius < 1)
                              RB_cond->radius = startnodecovered;
                           if(RB_cond->height < 1)
                              RB_cond->height = finalnodecovered;
                           RB_cond->magnitude += LenToCover - CoveredSoFar;
                           FTc = RB_cond->index_from_to;
                           FTp = FTc;
if(CoveredSoFar < LenToCover)
{
                           while(FTc != NULL)
                              {
                              if(FTc->start == i)
                                 {
                                 FTc->start = i - 1;
                                 break;
                                 }
                              else if(FTc->stop == (i - 1))
                                 {
                                 FTc->stop = i;
                                 break;
                                 }
                              else if((FTc->start <= i) && (FTc->stop >= i))
                                 break;  /** this can happen as cross region boundaries and check same edge again ***/
                              FTp = FTc;
                              FTc = FTc->next;
                              }
                           if(FTc == NULL)
                              {
                              FTc = (struct EdgeIntervals *) (malloc(sizeof(struct EdgeIntervals)));
                              if(FTc == NULL)
                                 {
                                 printf("memory has been exhausted during RB-Tree alloction for LSPANFAIL (edges1) analysis\n");
                                 exit(-1);
                                 }
                              FTc->start = i - 1;
                              FTc->stop = i;
                              FTc->next = NULL;
if(RB_cond->index_from_to == NULL)
   RB_cond->index_from_to = FTc;
else
                              FTp->next = FTc;
                              }
                           else
                              {
                              FTa = RB_cond->index_from_to;
                              while(FTa != NULL)
                                 {
                                 if(FTa->start == FTc->stop)
                                    {
                                    FTa->start = FTc->start;
                                    if(FTc == RB_cond->index_from_to)
                                       RB_cond->index_from_to = FTc->next;
                                    else
                                       FTp->next = FTc->next;
                                    free(FTc);
                                    break;
                                    }
                                 else if(FTa->stop == FTc->start)
                                    {
                                    FTa->stop = FTc->stop;
                                    if(FTc == RB_cond->index_from_to)
                                       RB_cond->index_from_to = FTc->next;
                                    else
                                       FTp->next = FTc->next;
                                    free(FTc);
                                    break;
                                    }
                                 FTa = FTa->next;
                                 }
                              }
}
                           }
                        else /*** must not have found any uncovered edges for this line feature before now ***/
                           {
                           RB_cond = (struct ConditionCollection *) (malloc(SzCC));
                           if(RB_cond == NULL)
                              {
                              printf("memory has been exhausted during RB-Tree information alloction for LSPANFAIL analysis\n");
                              exit(-1);
                              }
                           RB_cond->keyval = LSPANFAIL;
if(CoveredSoFar < LenToCover)
{
                           FTc = (struct EdgeIntervals *) (malloc(sizeof(struct EdgeIntervals)));
                           if(FTc == NULL)
                              {
                              printf("memory has been exhausted during RB-Tree alloction for LSPANFAIL (edges2) analysis\n");
                              exit(-1);
                              }

                           FTc->start = i - 1;
                           FTc->stop = i;
                           FTc->next = NULL;
                           RB_cond->index_from_to = FTc;
}
else
RB_cond->index_from_to = NULL;
                           RB_cond->Cnumber =  Make_Correct(LSPANFAIL,checkinstance);
                           RB_cond->gform = G_LINE;
                           RB_cond->featureidn = rlc->featureid;
                           RB_cond->localID = rlc->localID;
                           RB_cond->counter = 2;
                           RB_cond->radius = startnodecovered;
                           RB_cond->height = finalnodecovered;
                           RB_cond->magnitude = LenToCover - CoveredSoFar;
                           RB_cond->IDN = rlc->idn;
                           RB_cond->Sindex = rlc->Sindex;
                           RB_cond->Lindex = rlc->Lindex;

                           RB_cond->numnodes = rlc->numnodes;
                           RB_cond->x = (double *) (malloc(RB_cond->numnodes * SzD));
                           RB_cond->y = (double *) (malloc(RB_cond->numnodes * SzD));
                           RB_cond->z = (double *) (malloc(RB_cond->numnodes * SzD));
                           if(RB_cond->z == NULL)
                              {
                              printf("memory has been exhausted during RB-Tree element vertex alloction for NOCOINCIDE analysis\n");
                              exit(-1);
                              }
                           for(jj=0; jj< rlc->numnodes; jj++)
                              {
                              RB_cond->x[jj] = rlc->x[jj];
                              RB_cond->y[jj] = rlc->y[jj];
                              RB_cond->z[jj] = rlc->z[jj];
                              }

                           RB_newDbl = (double *) (malloc(SzD));
                           if(RB_newDbl == NULL)
                              {
                              printf("memory has been exhausted during RB-Tree alloction for NOCOINCIDE analysis\n");
                              exit(-1);
                              }
                           *RB_newDbl = RB_newKey2;
                           RBTreeInsert(Check_RB_Tree,RB_newDbl, RB_cond);
                           } /*** end add a new tree node ***/
                        } /*** end multi-region process ***/

                     else if(rlc->IsMulti < 1)
                        {
                        if(((LenToCover - CoveredSoFar) > 0.1) || (startnodecovered < 1) || (finalnodecovered < 1))
                           {
                           ++found_one;
                           if(ii2 < 0)
                              {
                              ii2 = i - 1;
                              ii3 = i;
                              }
                           else
                              {
                              ii3 = i;
                              }
                           if(found_one == 1)
                              {
                              ERc = (struct collection *) (malloc(SzC));
                              if(ERc == NULL)
                                 {
                                 printf("allocation memory exhausted during linear feature condition analysis\n");
                                 printf("processing cannot continue\n");
                                 exit(-1);
                                 }
                              ERc->x[0] = rlc->x[i-1];
                              ERc->y[0] = rlc->y[i-1];
                              ERc->z[0] = rlc->z[i-1];
                              ERc->x[1] = rlc->x[i];
                              ERc->y[1] = rlc->y[i];
                              ERc->z[1] = rlc->z[i];
                              ERc->magnitude = 0.0;
                              ERc->keyval = LSPANFAIL;
                              ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                              ERc->IDN = rlc->idn;
                              ERc->Sindex = rlc->Sindex;
                              ERc->ll1 = rlc;
                              ERc->vertexindex1 = i-1;
                              ERc->ll2 = NULL;
                              ERc->vertexindex2 = i;
                              ERc->next = NULL;
                              if(ERroot == NULL)
                                 {
                                 ERroot = ERc;
                                 }
                              else
                                 {
                                 ERn = ERroot;
                                 while(ERn != NULL)
                                    {
                                    if((ERn->Cnumber == ERc->Cnumber) && (ERn->keyval == ERc->keyval) && (ERn->ll1 == ERc->ll1) &&
                                       (ERn->x[0] == ERc->x[0]) && (ERn->y[0] == ERc->y[0]) &&
                                         (ERn->x[1] == ERc->x[1]) && (ERn->y[1] == ERc->y[1]))
                                       break;

                                    ERn = ERn->next;
                                    }
                                 if(ERn == NULL)
                                    {
                                    ERc->next = ERroot;
                                    ERroot = ERc;
                                    }
                                 else
                                   free(ERc);
                                 }
                              }
                           else
                              {
                              ERn = ERroot;
                              while(ERn != NULL)
                                 {
                                 if((ERn->Cnumber == ERc->Cnumber) && (ERn->keyval == ERc->keyval) && (ERn->ll1 == ERc->ll1) &&
                                   (ERn->vertexindex1 == ii2) && (ERn->vertexindex2 < ii3))
                                    {
                                    ERn->vertexindex2 = ii3;
                                    break;
                                    }
                                 ERn = ERn->next;
                                 }
                              if(ERn == NULL)
                                 {
                                 printf("could not find LSPANFAIL failure for second segment\n");
                                 exit(-1);
                                 }
                              }
                           }
                        else
                           {
                           ii2 = ii3 = -99;  /**reset the vertex number pointers ***/
                           found_one = 0;
                           }
                        }
                     }
                  }
               }
            }




         if(CombinedCheckApplies(rlc->idn,checkinstance,LNOCOVERLA,
                      rlc->Lindex,rlc->Sindex,Config1,Strat1,Domain1,&part1,&part2,&part3) > 0)
            {
            if(part1 > 0)
               {
               found_one = 0;
               ii2 = ii3 = -99;  /*** holds indices of verts of consecutive uncovered edges ***/
               for(i=1; i<rlc->numnodes; i++)
                  {
                  ii = i - 1;

                  x1 = rlc->x[ii];
                  y1 = rlc->y[ii];
                  z1 = rlc->z[ii];
                  x2 = rlc->x[i];
                  y2 = rlc->y[i];
                  z2 = rlc->z[i];
                  if(ClipLineToRegion(minx,miny,maxx,maxy,&x1,&y1,&z1,&x2,&y2,&z2,&clipflag,multiplier) > 0)
                     {
                     LenToCover = Distance(x1,y1,x2,y2);
                     if((x1 == rlc->x[ii]) && (y1 == rlc->y[ii]) && (x2 == rlc->x[i]) && (y2 == rlc->y[i])) /** no clipping **/
                        LenToCover *= 0.99;
                     else
                        LenToCover -= ActiveChecks[checkinstance].sensitivity;
                     CoveredSoFar = 0.0;
                     rln = root;
                     while((rln != NULL) && (CoveredSoFar < LenToCover))
                        {
                        if(rln != rlc)
                           {
                           Config2 = SCCtable[rln->Sindex].C;
                           Strat2 = SCCtable[rln->Sindex].S;
                           Domain2 = SCCtable[rln->Sindex].D;
                           if(CombinedCheckApplies(rln->idn,checkinstance,LNOCOVERLA,rln->Lindex,rln->Sindex,
                                     Config2,Strat2,Domain2,&part1,&part2,&part3) > 0)
                              {
                              if(part2 > 0)
                                 {
                                 for(j=1; j<rln->numnodes; j++)
                                    {
                                    if(MatchLinearSegment2D(x1,y1,x2,y2,
                                                            rln->x[j-1],rln->y[j-1],rln->x[j],rln->y[j],&MatchLen,
                                                            ActiveChecks[checkinstance].sensitivity) > 0)
                                       {
if(MatchLen > LenToCover)
  MatchLen = LenToCover;

                                       CoveredSoFar += MatchLen;
                                       if(CoveredSoFar >= LenToCover)
                                          break;
                                       }
                                    }
                                 }
                              }
                           }
                        rln = rln->next;
                        }
                     if(CoveredSoFar < LenToCover) /*** checktosee if an area feature edge will cover the linear ***/
                        {
                        rac = Aroot;
                        while((rac != NULL) && (CoveredSoFar < LenToCover))
                           {
                           Config2 = SCCtable[rac->Sindex].C;
                           Strat2 = SCCtable[rac->Sindex].S;
                           Domain2 = SCCtable[rac->Sindex].D;
                           if(CombinedCheckApplies(rac->idn,checkinstance,LNOCOVERLA,rac->Lindex,rac->Sindex,
                                     Config2,Strat2,Domain2,&part1,&part2,&part3) > 0)
                              {
                              if(part2 > 0)
                                 {
                                 for(j=1; j<rac->numverts; j++)
                                    {
                                    if(MatchLinearSegment2D(x1,y1,x2,y2,
                                                            rac->x[j-1],rac->y[j-1],rac->x[j],rac->y[j],&MatchLen,
                                                            1.09 * ActiveChecks[checkinstance].sensitivity) > 0)
                                       {
                                       CoveredSoFar += MatchLen;
                                       if(CoveredSoFar >= LenToCover)
                                             break;
                                       }
                                    }
                                 if(j == rac->numverts) /*** check last edge of area feature ***/
                                    {
                                    if(MatchLinearSegment2D(x1,y1,x2,y2,
                                                         rac->x[0],rac->y[0],rac->x[j-1],rac->y[j-1],&MatchLen,
                                                            1.09 * ActiveChecks[checkinstance].sensitivity) > 0)
                                       {
                                       CoveredSoFar += MatchLen;
                                       }
                                    }
                                 }
                              }
                           rac = rac->next;
                           }
                        }


                     if(CoveredSoFar < LenToCover) /*** check to see if an area feature face will cover the linear ***/
                        {
                        rac = Aroot;
                        while(rac != NULL)
                           {
                           if(rac->ishole <= 0)
                              IsCutout = 0;
                           else
                              IsCutout = 1;
                           if(1)
                              {
                              Config2 = SCCtable[rac->Sindex].C;
                              Strat2 = SCCtable[rac->Sindex].S;
                              Domain2 = SCCtable[rac->Sindex].D;
                              if(CombinedCheckApplies(rac->idn,checkinstance,LNOCOVERLA,rac->Lindex,rac->Sindex,
                                     Config2,Strat2,Domain2,&part1,&part2,&part3) > 0)
                                 {
                                 if(part3 > 0)
                                    {
if((rac->RB_Tree_Edgelist == NULL) || (rac->RB_Tree_Edgelist != NULL))
                                       {
                                       inside1 = inside2 = 0;
                                       closeEdge1 = closeEdge2 = -100;
                                       inside1 = PointInsidePoly(x1,y1,rac->x, rac->y, rac->numverts);
                                       if(inside1 == 0)
                                          {
                                          if(PointToSmallArealDist2D(x1, y1,rac,&closeEdge1,&unuseddbl) <
                                                   ActiveChecks[checkinstance].sensitivity)
                                             inside1 = 1;
                                          }
                                       inside2 = PointInsidePoly(x2,y2,rac->x, rac->y, rac->numverts);
                                       if(inside2 == 0)
                                          {
                                          if(PointToSmallArealDist2D(x2, y2,rac,&closeEdge2,&unuseddbl) <
                                                   ActiveChecks[checkinstance].sensitivity)
                                             inside2 = 1;
                                          }
                                       IntRoot = NULL;
                                       jj = rac->numverts - 1;
                                       for(j=0; j<rac->numverts; j++)
                                          {
                                       if((LineSegmentsIntersect(x1,y1,x2,y2,
                                                 rac->x[jj],rac->y[jj],rac->x[j],rac->y[j], &xi, &yi) > 0) &&
                                           (EqualWithinTolerance(x1,y1,xi,yi,ActiveChecks[checkinstance].sensitivity) <= 0) &&
                                           (EqualWithinTolerance(x2,y2,xi,yi,ActiveChecks[checkinstance].sensitivity) <= 0))
                                             {
                                             IRn = (struct IntersectionList *) (malloc(SzIL));
                                             IRn->x = xi;
                                             IRn->y = yi;
                                             IRn->dist = ((xi - x1) * (xi - x1)) + ((yi - y1) * (yi - y1));
                                             if(IntRoot == NULL)
                                                {
                                                IntRoot = IRn;
                                                IRn->next = NULL;
                                                }
                                             else
                                                {
                                                IRc = IRp = IntRoot;
                                                while(IRc != NULL)
                                                   {
                                                   if(IRn->dist < IRc->dist)
                                                      break;
                                                   IRp = IRc;
                                                   IRc = IRc->next;
                                                   }
                                                if(IRc == NULL)
                                                   {
                                                   IRp->next = IRn;
                                                   IRn->next = NULL;
                                                   }
                                                else if(IRc == IntRoot)
                                                   {
                                                   IRn->next = IntRoot;
                                                   IntRoot = IRn;
                                                   }
                                                else
                                                   {
                                                   IRn->next = IRc;
                                                   IRp->next = IRn;
                                                   }
                                                }
                                             }
                                          jj = j;
                                          }

                                       if((inside1 > 0) && (inside2 > 0) && (IntRoot == NULL))
                                          {
CalculateMidPoint(x1,y1,x2,y2,&xi,&yi);
if(PointInsidePoly(xi,yi,rac->x, rac->y, rac->numverts) > 0)
{
                                          if(IsCutout == 0)
                                             CoveredSoFar += LenToCover;
                                          else
                                             CoveredSoFar -= LenToCover;
}
else
{
inside1 = inside2 = 0;
}
                                          }
                                       else if(IntRoot != NULL)  /*** must be some intersections - what parts are inside? ****/
                                          {
                                          fromx = x1;
                                          fromy = y1;
                                          IRc = IntRoot;
                                          if(inside1 > 0)
                                             {
                                             jj = 1;
                                             }
                                          else
                                             {
                                             jj = 0;
                                             }
                                          while(IRc != NULL)
                                             {
                                             if(jj == 1) /** add in the distance here ***/
                                                {
                                                if(IsCutout == 0)
                                                   CoveredSoFar += Distance(fromx,fromy,IRc->x,IRc->y);
                                                else
                                                   CoveredSoFar -= Distance(fromx,fromy,IRc->x,IRc->y);
                                                jj = 0;
                                                }
                                             else
                                                jj = 1;
                                             fromx = IRc->x;
                                             fromy = IRc->y;
                                             IRc = IRc->next;
                                             }
                                          if(jj > 0)
                                             {
                                             //CoveredSoFar += Distance(fromx,fromy,x2,y2);
                                             if(IsCutout == 0)
                                                CoveredSoFar += Distance(fromx,fromy,x2,y2);
                                             else
                                                CoveredSoFar -= Distance(fromx,fromy,x2,y2);
                                             }
                                          IRc = IntRoot;
                                          while(IRc != NULL)
                                             {
                                             IRp = IRc;
                                             IRc = IRc->next;
                                             free(IRp);
                                             }
                                          IntRoot = NULL;
                                          }

                                       }  /**** end is a small area feature ***/

                                    } /**** end if(part3 > 0) ****/
                                 } /*** end combined check applies as tertiary for the area feature **/
                              }  /** end ishole indicates rac is an outer edge ***/
                           rac = rac->next;
                           } /** end while rac ...   ***/
                        } /** end covered so far is not enough ***/




                     if((LenToCover > 0) && (LenToCover < 10.0))
                        Coverdiff = CoveredSoFar / LenToCover;
                     else
                        Coverdiff = 1.0;
                     
                     if((rlc->IsMulti >= 1) && ((LenToCover - CoveredSoFar) > 0))
                        {
                        RB_newKey2 = rlc->localID + (checkinstance * 0.0001);
                        if(( RB_newNode = RBExactQuery(Check_RB_Tree,&RB_newKey2)))
                           {
                           RB_cond = (struct ConditionCollection *) RB_newNode->info;
                           RB_cond->magnitude += LenToCover - CoveredSoFar; /** this requires handshake with condition
                                                                           writing test in TT.c  ***/
                           FTc = RB_cond->index_from_to;
                           FTp = FTc;
                           while(FTc != NULL)
                              {
                              if(FTc->start == i)
                                 {
                                 FTc->start = i - 1;
                                 break;
                                 }
                              else if(FTc->stop == (i - 1))
                                 {
                                 FTc->stop = i;
                                 break;
                                 }
                              else if((FTc->start <= i) && (FTc->stop >= i))
                                 break; 
                              FTp = FTc;
                              FTc = FTc->next;
                              }
                           if(FTc == NULL)
                              {
                              FTc = (struct EdgeIntervals *) (malloc(sizeof(struct EdgeIntervals)));
                              if(FTc == NULL)
                                 {
                                 printf("memory has been exhausted during RB-Tree alloction for LNOCOVERLA (edges1) analysis\n");
                                 exit(-1);
                                 }
                              FTc->start = i - 1;
                              FTc->stop = i;
                              FTc->next = NULL;
                              FTp->next = FTc;
                              }
                           else
                              {
                              FTa = RB_cond->index_from_to;
                              while(FTa != NULL)
                                 {
                                 if(FTa->start == FTc->stop)
                                    {
                                    FTa->start = FTc->start;
                                    if(FTc == RB_cond->index_from_to)
                                       RB_cond->index_from_to = FTc->next;
                                    else
                                       FTp->next = FTc->next;
                                    free(FTc);
                                    break;
                                    }
                                 else if(FTa->stop == FTc->start)
                                    {
                                    FTa->stop = FTc->stop;
                                    if(FTc == RB_cond->index_from_to)
                                       RB_cond->index_from_to = FTc->next;
                                    else
                                       FTp->next = FTc->next;
                                    free(FTc);
                                    break;
                                    }
                                 FTa = FTa->next;
                                 }
                              }
                           }
                        else /*** must not have found any uncovered edges for this line feature before now ***/
                           {
                           RB_cond = (struct ConditionCollection *) (malloc(SzCC));
                           if(RB_cond == NULL)
                              {
                              printf("memory has been exhausted during RB-Tree information alloction for LNOCOVERLA analysis\n");
                              exit(-1);
                              }
                           RB_cond->keyval = LNOCOVERLA;
                           FTc = (struct EdgeIntervals *) (malloc(sizeof(struct EdgeIntervals)));
                           if(FTc == NULL)
                              {
                              printf("memory has been exhausted during RB-Tree alloction for LNOCOVERLA (edges2) analysis\n");
                              exit(-1);
                              }

                           FTc->start = i - 1;
                           FTc->stop = i;
                           FTc->next = NULL;
                           RB_cond->index_from_to = FTc;
                           RB_cond->Cnumber =  Make_Correct(LNOCOVERLA,checkinstance);
                           RB_cond->gform = G_LINE;
                           RB_cond->featureidn = rlc->featureid;
                           RB_cond->localID = rlc->localID;
                           RB_cond->counter = 2;
                           RB_cond->radius = -1;
                           RB_cond->height = -1;
                           RB_cond->magnitude = LenToCover - CoveredSoFar;// 0.0;
                           RB_cond->IDN = rlc->idn;
                           RB_cond->Sindex = rlc->Sindex;
                           RB_cond->Lindex = rlc->Lindex;

                           RB_cond->numnodes = rlc->numnodes;
                           RB_cond->x = (double *) (malloc(RB_cond->numnodes * SzD));
                           RB_cond->y = (double *) (malloc(RB_cond->numnodes * SzD));
                           RB_cond->z = (double *) (malloc(RB_cond->numnodes * SzD));
                           if(RB_cond->z == NULL)
                              {
                              printf("memory has been exhausted during RB-Tree element vertex alloction for NOCOINCIDE analysis\n");
                              exit(-1);
                              }
                           for(jj=0; jj< rlc->numnodes; jj++)
                              {
                              RB_cond->x[jj] = rlc->x[jj];
                              RB_cond->y[jj] = rlc->y[jj];
                              RB_cond->z[jj] = rlc->z[jj];
                              }

                           RB_newDbl = (double *) (malloc(SzD));
                           if(RB_newDbl == NULL)
                              {
                              printf("memory has been exhausted during RB-Tree alloction for NOCOINCIDE analysis\n");
                              exit(-1);
                              }
                           *RB_newDbl = RB_newKey2;
                           RBTreeInsert(Check_RB_Tree,RB_newDbl, RB_cond);
                           } /*** end add a new tree node ***/
                        } /*** end multi-region process ***/

                     else if((rlc->IsMulti < 1) && (((LenToCover - CoveredSoFar) > 0.1) || (Coverdiff < 0.99)))
                        {
                        ++found_one;
                        if(ii2 < 0)
                           {
                           ii2 = i - 1;
                           ii3 = i;
                           }
                        else
                           {
                           ii3 = i;
                           }
                        if(found_one == 1)
                           {
                           ERc = (struct collection *) (malloc(SzC));
                           if(ERc == NULL)
                              {
                              printf("allocation memory exhausted during linear feature condition analysis\n");
                              printf("processing cannot continue\n");
                              exit(-1);
                              }
                           ERc->x[0] = rlc->x[i-1];
                           ERc->y[0] = rlc->y[i-1];
                           ERc->z[0] = rlc->z[i-1];
                           ERc->x[1] = rlc->x[i];
                           ERc->y[1] = rlc->y[i];
                           ERc->z[1] = rlc->z[i];
                           ERc->magnitude = 0.0;
                           ERc->keyval = LNOCOVERLA;
                           ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                           ERc->IDN = rlc->idn;
                           ERc->Sindex = rlc->Sindex;
                           ERc->ll1 = rlc;
                           ERc->vertexindex1 = i-1;
                           ERc->ll2 = NULL;
                           ERc->vertexindex2 = i;
                           ERc->next = NULL;
                           if(ERroot == NULL)
                              {
                              ERroot = ERc;
                              }
                           else
                              {
                              ERn = ERroot;
                              while(ERn != NULL)
                                 {
                                 if((ERn->Cnumber == ERc->Cnumber) && (ERn->keyval == ERc->keyval) && (ERn->ll1 == ERc->ll1) &&
                                    (ERn->x[0] == ERc->x[0]) && (ERn->y[0] == ERc->y[0]) && 
                                      (ERn->x[1] == ERc->x[1]) && (ERn->y[1] == ERc->y[1]))
                                    break;
      
                                 ERn = ERn->next;
                                 }
                              if(ERn == NULL)
                                 {
                                 ERc->next = ERroot;
                                 ERroot = ERc;
                                 }
                              else
                                free(ERc);
                              }
                           }
                        else
                           {
                           ERn = ERroot;
                           while(ERn != NULL)
                              {
                              if((ERn->Cnumber == ERc->Cnumber) && (ERn->keyval == ERc->keyval) && (ERn->ll1 == ERc->ll1) &&
                                (ERn->vertexindex1 == ii2) && (ERn->vertexindex2 < ii3))
                                 {
                                 ERn->vertexindex2 = ii3;
                                 break;
                                 }
                              ERn = ERn->next;
                              }
                           if(ERn == NULL)
                              {
                              printf("could not find LNOCOVERLA failure for second segment\n");
                              exit(-1);
                              }
                           }
                        }
                     else
                        {
                        ii2 = ii3 = -99;  /**reset the vertex number pointers ***/
                        found_one = 0;
                        }
                     }
                  }
               }
            }



         if(CombinedCheckApplies(rlc->idn,checkinstance,LNOCOV2A,rlc->Lindex,rlc->Sindex,Config1,Strat1,Domain1,&part1,&part2,&part3) > 0)
            {
            if(part1 > 0)
               {
               for(i=1; i<rlc->numnodes; i++)
                  {
                  ii = i - 1;
                  x1 = rlc->x[ii];
                  y1 = rlc->y[ii];
                  z1 = rlc->z[ii];
                  x2 = rlc->x[i];
                  y2 = rlc->y[i];
                  z2 = rlc->z[i];
                  if(ClipLineToRegion(minx,miny,maxx,maxy,&x1,&y1,&z1,&x2,&y2,&z2,&clipflag,multiplier) > 0)
                     {
                     LenToCover = Distance(x1,y1,x2,y2);
                     LenToCover *= 1.99999;

                     CoveredSoFar = 0.0;
                     rac = Aroot;
                     while((rac != NULL) && (CoveredSoFar < LenToCover))
                        {
                        Config2 = SCCtable[rac->Sindex].C;
                        Strat2 = SCCtable[rac->Sindex].S;
                        Domain2 = SCCtable[rac->Sindex].D;
                        if(CombinedCheckApplies(rac->idn,checkinstance,LNOCOV2A,rac->Lindex,rac->Sindex,
                                  Config2,Strat2,Domain2,&part1,&part2,&part3) > 0)
                           {
                           if(part2 > 0)
                              {
                              for(j=1; j<rac->numverts; j++)
                                 {
                                 if(MatchLinearSegment2D(x1,y1,x2,y2,
                                                         rac->x[j-1],rac->y[j-1],rac->x[j],rac->y[j],&MatchLen,
                                                         ActiveChecks[checkinstance].sensitivity) > 0)
                                    {
                                    CoveredSoFar += MatchLen;
                                    if(CoveredSoFar >= LenToCover)
                                          break;
                                    }
                                 }
                              if(j == rac->numverts) /*** check last edge of area feature ***/
                                 {
                                 if(MatchLinearSegment2D(x1,y1,x2,y2,
                                                      rac->x[0],rac->y[0],rac->x[j-1],rac->y[j-1],&MatchLen,
                                                         ActiveChecks[checkinstance].sensitivity) > 0)
                                    {
                                    CoveredSoFar += MatchLen;
                                    }
                                 }
                              }
                           }
                        rac = rac->next;
                        }
                     if(CoveredSoFar < LenToCover)
                        {
                        ERc = (struct collection *) (malloc(SzC));
                        if(ERc == NULL)
                           {
                           printf("allocation memory exhausted during linear feature condition analysis\n");
                           printf("processing cannot continue\n");
                           exit(-1);
                           }
                        ERc->x[0] = rlc->x[i-1];
                        ERc->y[0] = rlc->y[i-1];
                        ERc->z[0] = rlc->z[i-1];
                        ERc->x[1] = rlc->x[i];
                        ERc->y[1] = rlc->y[i];
                        ERc->z[1] = rlc->z[i];
                        ERc->magnitude = 0.0;
                        ERc->keyval = LNOCOV2A;
                        ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                        ERc->IDN = rlc->idn;
                        ERc->Sindex = rlc->Sindex;
                        ERc->ll1 = rlc;
                        ERc->vertexindex1 = 0;
                        ERc->ll2 = NULL;
                        ERc->vertexindex2 = 0;
                        ERc->next = NULL;
                        if(ERroot == NULL)
                           {
                           ERroot = ERc;
                           }
                        else
                           {
                           ERn = ERroot;
                           while(ERn != NULL)
                              {
                              if((ERn->Cnumber == ERc->Cnumber) && (ERn->keyval == ERc->keyval) && (ERn->ll1 == ERc->ll1) &&
                                 (ERn->x[0] == ERc->x[0]) && (ERn->y[0] == ERc->y[0]) &&
                                   (ERn->x[1] == ERc->x[1]) && (ERn->y[1] == ERc->y[1]))
                                 break;

                              ERn = ERn->next;
                              }
                           if(ERn == NULL)
                              {
                              ERc->next = ERroot;
                              ERroot = ERc;
                              }
                           else
                             free(ERc);

                           }
                        break;
                        }
                     } /**** end if clip line to region ***/
                  } /*** end for i = ***/
               } /** end if part 2 ***/
            } /*** end if LNOCOV2A check applies to line ***/




         if(CombinedCheckApplies(rlc->idn,checkinstance,LAIEX,rlc->Lindex,rlc->Sindex,
                     Config1,Strat1,Domain1,&part1,&part2,&part3) > 0)
            {
            if(part1 > 0)
               {
               if(rlc_partialcopy == NULL)
                  {
                  rlc_partialcopy = (struct RawLinear *) (malloc(sizeof(struct RawLinear)));
                  rlc_partialcopy->next = NULL;
                  rlc_partialcopy->areastr = NULL;
                  rlc_partialcopy->hgtstr = NULL;
                  rlc_partialcopy->zv2str = NULL;
                  rlc_partialcopy->lenstr = NULL;
                  rlc_partialcopy->namstr = NULL;

                  rlc_partialcopy->x = (double *) (malloc(SzD * 2));
                  rlc_partialcopy->y = (double *) (malloc(SzD * 2));
                  rlc_partialcopy->z = (double *) (malloc(SzD * 2));
                  rlc_partialcopy->numnodes = 2;
                  }
               rlc_partialcopy->featureid = rlc->featureid;
               rlc_partialcopy->Lindex = rlc->Lindex;
               rlc_partialcopy->Sindex = rlc->Sindex;
               rlc_partialcopy->IsMulti = rlc->IsMulti;
               rlc_partialcopy->idn = rlc->idn;
               FoundCondition = 0;
               ran = Aroot;
               while((ran != NULL) && (FoundCondition == 0))
                  {
                  Config2 = SCCtable[ran->Sindex].C;
                  Strat2 = SCCtable[ran->Sindex].S;
                  Domain2 = SCCtable[ran->Sindex].D;
                  if(CombinedCheckApplies(ran->idn,checkinstance,LAIEX,ran->Lindex,ran->Sindex,
                              Config2,Strat2,Domain2,&part1,&part2,&part3) > 0)
                     {
                     if(part2 > 0)
                        {
                        for(i=1; i<rlc->numnodes; i++)
                           {
                           ii = i - 1;
                           x1 = rlc->x[ii];
                           y1 = rlc->y[ii];
                           z1 = rlc->z[ii];
                           x2 = rlc->x[i];
                           y2 = rlc->y[i];
                           z2 = rlc->z[i];

                           if(ClipLineToRegion(minx,miny,maxx,maxy,&x1,&y1,&z1,&x2,&y2,&z2,&clipflag,multiplier) > 0)
                              {
                              rlc_partialcopy->x[0] = rlc->x[ii];
                              rlc_partialcopy->y[0] = rlc->y[ii];
                              rlc_partialcopy->z[0] = rlc->z[ii];
                              rlc_partialcopy->x[1] = rlc->x[i];
                              rlc_partialcopy->y[1] = rlc->y[i];
                              rlc_partialcopy->z[1] = rlc->z[i];

                              inside1 = LinePartOrAllInsideArea(rlc_partialcopy, ran, &checkit, &checkit2, 0.00001,200.0) > 0;
                              if(inside1 > 0)
                                 {
                                 rah = Aroot;
                                 while(rah != NULL)
                                    {
                                    if((rah->ishole > 0) && (rah->idn == ran->idn))
                                       {
                                       inside2 = LinePartOrAllInsideArea(rlc_partialcopy,rah, &kk,
                                                       &kk2, ActiveChecks[checkinstance].sensitivity,200.0);
                                       if(inside2 > 0)
                                          {
                                          inside1 = 0;
                                          break;
                                          }
                                       }
                                    rah = rah->next;
                                    }
                                 }
                              if(inside1 > 0)
                                 {
                                 if(PointInAreal(x2, y2, ran->x,ran->y,ran->numverts, &iii) > 0)
                                    {
                                    xi = x2;
                                    yi = y2;
                                    }
                                 else
                                    {
                                    xi = x1;
                                    yi = y1;
                                    }
                                 raunused = FindEdgeClosestToPoint(xi, yi, NULL, NULL, ran, &jj);
                                 if(jj < 0)
                                    {
                                    X[0] = ran->x[ran->numverts-1];
                                    Y[0] = ran->y[ran->numverts-1];
                                    Z[0] = ran->z[ran->numverts-1];
                                    X[1] = ran->x[0];
                                    Y[1] = ran->y[0];
                                    Z[1] = ran->z[0];
                                    }
                                 else
                                    {
                                    X[0] = ran->x[jj-1];
                                    Y[0] = ran->y[jj-1];
                                    Z[0] = ran->z[jj-1];
                                    X[1] = ran->x[jj];
                                    Y[1] = ran->y[jj];
                                    Z[1] = ran->z[jj];
                                    }
                              
                                 FoundCondition = 1;
                                 }
                              }
                           if(FoundCondition > 0)
                              break;
                           } /*** end for i = rlc->numnodes ***/
                        }
                     }
                  if(FoundCondition > 0)
                     {
                     break;
                     }
                  ran = ran->next;
                  }


               if(FoundCondition > 0)
                  {
                  ERc = (struct collection *) (malloc(SzC));
                  if(ERc == NULL)
                     {
                     printf("allocation memory exhausted during linear feature condition analysis\n");
                     printf("processing cannot continue\n");
                     exit(-1);
                     }
                  ERc->x[0] = xi;
                  ERc->y[0] = yi;
                  ERc->magnitude = 0.0;
                  ERc->keyval = LAIEX;
                  ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                  ERc->IDN = rlc->idn;
                  ERc->Sindex = rlc->Sindex;
                  ERc->ll1 = rlc;
                  ERc->vertexindex1 = ii;
                  ERc->aa = ran;
                  ERc->vertexindex2 = jj;
                  ERc->next = NULL;
                  ERc->x[1] = X[0];
                  ERc->y[1] = Y[0];
                  ERc->z[1] = Z[0];
                  ERc->x[2] = X[1];
                  ERc->y[2] = Y[1];
                  ERc->z[2] = Z[1];

                  ERn = ERroot;
                  while(ERn != NULL)
                     {
                     if((ERn->Cnumber == ERc->Cnumber) && (ERn->keyval == ERc->keyval) && (ERn->x[0]   == ERc->x[0])   &&
                          (ERn->y[0]   == ERc->y[0])   && (ERn->ll1    == ERc->ll1) && (ERn->aa    == ERc->aa)) 
                         break;

                     ERn = ERn->next;
                     }
                  if(ERn == NULL)
                     {
                     inregion1 = 0;
                     if((ActiveChecks[checkinstance].number == LAIEX) &&
                          ((ActiveChecks[checkinstance].Config3[C_AREA] > 0) ||
                                  (ActiveChecks[checkinstance].Config3[C_FMAF] > 0)))
                        {
                        rac = Aroot;
                        while((rac != NULL) && (inregion1 == 0))
                           {
                           Config3 = SCCtable[rac->Sindex].C;
                           Strat3 = SCCtable[rac->Sindex].S;
                           Domain3 = SCCtable[rac->Sindex].D;
                           if(CombinedCheckApplies(rac->idn,checkinstance,LAIEX,rac->Lindex,rac->Sindex,
                                    Config3,Strat3,Domain3,&part1,&part2,&part3) > 0)
                              {
                              if(part3 > 0)
                                 {
                                 if(PointInsidePoly(xi,yi,rac->x,rac->y,rac->numverts) > 0)
                                    inregion1 = 1;
                                 }
                              }
                           rac = rac->next;
                           }
                        }

                     if((inregion1 == 0) && /****  look at the points **/
                        (ActiveChecks[checkinstance].number == LAIEX) &&
                            ((ActiveChecks[checkinstance].Config3[C_POFE] > 0) ||
                               (ActiveChecks[checkinstance].Config3[C_FMPF] > 0)))
                        {
                        rpc = Proot;
                        while((rpc != NULL) && (inregion1 == 0))
                           {
                           if(rpc->numverts == -1)
                              {
                              Config3 = SCCtable[rpc->Sindex].C;
                              Strat3 = SCCtable[rpc->Sindex].S;
                              Domain3 = SCCtable[rpc->Sindex].D;
                              if(CombinedCheckApplies(rpc->idn,checkinstance,LAIEX,
                                       rpc->Lindex,rpc->Sindex,Config3,Strat3,Domain3,&part1,&part2,&part3) > 0)
                                 {
                                 if(part3 > 0)
                                    {
                                    ptpdist1 = Distance(xi,yi,rpc->x[0],rpc->y[0]);
                                    if(SensitivityCheck(LTEQ,LAIEX,checkinstance,ptpdist1) > 0)
                                       {
                                       inregion1 = 1;
                                       break;
                                       }
                                    }
                                 }
                              }
                           rpc = rpc->next;
                           }
                        }

                     if((inregion1 == 0) && /****  look at the lines **/
                        (ActiveChecks[checkinstance].number == LAIEX) &&
                            ((ActiveChecks[checkinstance].Config3[C_LINE] > 0) ||
                                  (ActiveChecks[checkinstance].Config3[C_DILI] > 0)))
                        {
                        pairedrl1 = root;
                        while((pairedrl1 != NULL) && (inregion1 == 0))
                           {
                           if(pairedrl1 != rlc)
                              {
                              Config3 = SCCtable[pairedrl1->Sindex].C;
                              Strat3 = SCCtable[pairedrl1->Sindex].S;
                              Domain3 = SCCtable[pairedrl1->Sindex].D;
                              if(CombinedCheckApplies(pairedrl1->idn,checkinstance,LAIEX,
                                       pairedrl1->Lindex,pairedrl1->Sindex,Config3,Strat3,Domain3,&part1,&part2,&part3) > 0)
                                 {
                                 if(part3 > 0)
                                    {
                                    for(k=1; k<pairedrl1->numnodes; k++)
                                       {
                                       ptpdist1 = PointToLineDist2D(xi,yi,pairedrl1->x[k-1],pairedrl1->y[k-1],
                                                                   pairedrl1->x[k],pairedrl1->y[k]);
                                       if(SensitivityCheck(LTEQ,LAIEX,checkinstance,ptpdist1) > 0)
                                          {
                                          inregion1 = 1;
                                          break;
                                          }
                                       }
                                    }
                                 }
                              }
                           pairedrl1 = pairedrl1->next;
                           }
                        }

                     if(inregion1 == 0)
                        {
                        ERc->z[0] = InterpLinearElev(x1,y1,z1,x2,y2,z2,xi,yi);
                        ERc->next = ERroot;
                        ERroot = ERc;
                        }                                           else
                        free(ERc);
                     }
                  else
                     free(ERc);
                  } /*** end is FoundCondition > 0) ***/
               } /*** end part1 satisfied ***/
            } /*** end LAIEX check applies ****/





   
         if(CombinedCheckApplies(rlc->idn,checkinstance,LLIEX,rlc->Lindex,rlc->Sindex,Config1,Strat1,Domain1,&part1,&part2,&part3) > 0)
            {
            if(part1 > 0)
               {
               rln = root;
               while(rln != NULL)
                  {
                  if(rln == rlc)
                     {
                     if(rlc->next == NULL)
                        break;
                     else
                        rln = rlc->next;
                     }
                  Config2 = SCCtable[rln->Sindex].C;
                  Strat2 = SCCtable[rln->Sindex].S;
                  Domain2 = SCCtable[rln->Sindex].D;
                  if(CombinedCheckApplies(rln->idn,checkinstance,LLIEX,rln->Lindex,rln->Sindex,Config2,Strat2,Domain2,&part1,&part2,&part3) > 0)
                     {
                     if(part2 > 0)
                        {
                        for(i=1; i<rlc->numnodes; i++)
                           {
                           ii = i - 1;
                           x1 = rlc->x[ii];
                           y1 = rlc->y[ii];
                           z1 = rlc->z[ii];
                           x2 = rlc->x[i];
                           y2 = rlc->y[i];
                           z2 = rlc->z[i];

                           if(ClipLineToRegion(minx,miny,maxx,maxy,&x1,&y1,&z1,&x2,&y2,&z2,&clipflag,multiplier) > 0)
                              {
                              for(j=1; j<rln->numnodes; j++)
                                 {
                                 jj = j - 1;
                                 x3 = rln->x[jj];
                                 y3 = rln->y[jj];
                                 z3 = rln->z[jj];
                                 x4 = rln->x[j];
                                 y4 = rln->y[j];
                                 z4 = rln->z[j];
                                 if(ClipLineToRegion(minx,miny,maxx,maxy,&x3,&y3,&z3,&x4,&y4,&z4,&clipflag,multiplier) > 0)
                                    {
                                    if((LineSegmentsIntersect(x1,y1,x2,y2,x3,y3,x4,y4, &xi, &yi) > 0) &&
                                             (SegOverlapsLine(rlc->x[i],rlc->y[i],rlc->x[ii],rlc->y[ii],rln,jj,j) == 0))
                                       {
                                       ERc = (struct collection *) (malloc(SzC));
                                       if(ERc == NULL)
                                          {
                                          printf("allocation memory exhausted during linear feature condition analysis\n");
                                          printf("processing cannot continue\n");
                                          exit(-1);
                                          }
                                       ERc->x[0] = xi;
                                       ERc->y[0] = yi;
                                       ERc->magnitude = 0.0;
                                       ERc->keyval = LLIEX;
                                       ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                                       ERc->IDN = rlc->idn;
                                       ERc->Sindex = rlc->Sindex;
                                       ERc->ll1 = rlc;
                                       ERc->vertexindex1 = ii;
                                       ERc->ll2 = rln;
                                       ERc->vertexindex2 = jj;
                                       ERc->next = NULL;
   
                                       ERn = ERroot;
                                       while(ERn != NULL)
                                          {
                                          if((ERn->Cnumber == ERc->Cnumber) && (ERn->keyval == ERc->keyval) && (ERn->x[0]   == ERc->x[0])   &&
					       (ERn->y[0]   == ERc->y[0])   && ( ( (ERn->ll1    == ERc->ll1)    &&   /* this is Clause A */
						 (ERn->ll2    == ERc->ll2)) ||
						( (ERn->ll1    == ERc->ll2)    &&   /* this is Clause B */
						 (ERn->ll2    == ERc->ll1))))
					      break;

                                          ERn = ERn->next;
                                          }
                                       if(ERn == NULL)
                                          {
                                          inregion1 = 0;
                                          if((ActiveChecks[checkinstance].number == LLIEX) && 
                                               ((ActiveChecks[checkinstance].Config3[C_AREA] > 0) || (ActiveChecks[checkinstance].Config3[C_FMAF] > 0)))
                                             {
                                             rac = Aroot;
                                             while((rac != NULL) && (inregion1 == 0))
                                                {
                                                Config3 = SCCtable[rac->Sindex].C;
                                                Strat3 = SCCtable[rac->Sindex].S;
                                                Domain3 = SCCtable[rac->Sindex].D;
                                                if(CombinedCheckApplies(rac->idn,checkinstance,LLIEX,rac->Lindex,rac->Sindex,Config3,Strat3,Domain3,&part1,&part2,&part3) > 0)
                                                   {
                                                   if(part3 > 0)
                                                      {
                                                      if(PointInsidePoly(xi,yi,rac->x,rac->y,rac->numverts) > 0)
                                                         inregion1 = 1;
                                                      else 
                                                         {
                                                         if(rac->RB_Tree_Edgelist == NULL)
                                                            {
                                                            ptpdist1 = PointToSmallArealDist2D(xi,yi,rac,
                                                                     &unusedint,&unuseddbl);
                                                            }
                                                         else
                                                            {
                                                            ptpdist1 = PointToLargeArealDist2D(xi,yi,rac,
                                                               &unusedint,&unuseddbl);
                                                            }
                                                         if(SensitivityCheck(LTEQ,LLIEX,checkinstance,ptpdist1) > 0)
                                                            inregion1 = 1;
                                                         }
                                                      }
                                                   }
                                                rac = rac->next;
                                                }
                                             }

                                          if((inregion1 == 0) && /****  look at the points **/
                                             (ActiveChecks[checkinstance].number == LLIEX) &&
                                                 ((ActiveChecks[checkinstance].Config3[C_POFE] > 0) || (ActiveChecks[checkinstance].Config3[C_FMPF] > 0)))
                                             {
                                             rpc = Proot;
                                             while((rpc != NULL) && (inregion1 == 0))
                                                {
                                                if(rpc->numverts == -1)
                                                   {
                                                   Config3 = SCCtable[rpc->Sindex].C;
                                                   Strat3 = SCCtable[rpc->Sindex].S;
                                                   Domain3 = SCCtable[rpc->Sindex].D;
                                                   if(CombinedCheckApplies(rpc->idn,checkinstance,LLIEX,
                                                            rpc->Lindex,rpc->Sindex,Config3,Strat3,Domain3,&part1,&part2,&part3) > 0)
                                                      {
                                                      if(part3 > 0)
                                                         {
                                                         ptpdist1 = Distance(xi,yi,rpc->x[0],rpc->y[0]);
                                                         /**if(ptpdist1 < 0.001) **/
                                                         if(SensitivityCheck(LTEQ,LLIEX,checkinstance,ptpdist1) > 0)
                                                            {
                                                            inregion1 = 1;
                                                            break;
                                                            }
                                                         }
                                                      }
                                                   }
                                                rpc = rpc->next;
                                                }
                                             }

                                          if((inregion1 == 0) && /****  look at the lines **/
                                             (ActiveChecks[checkinstance].number == LLIEX) &&
                                                 ((ActiveChecks[checkinstance].Config3[C_LINE] > 0) || (ActiveChecks[checkinstance].Config3[C_DILI] > 0)))
                                             {
                                             pairedrl1 = root;
                                             while((pairedrl1 != NULL) && (inregion1 == 0))
                                                {
                                                if((pairedrl1 != rlc) && (pairedrl1 != rln))
                                                   {
                                                   Config3 = SCCtable[pairedrl1->Sindex].C;
                                                   Strat3 = SCCtable[pairedrl1->Sindex].S;
                                                   Domain3 = SCCtable[pairedrl1->Sindex].D;
                                                   if(CombinedCheckApplies(pairedrl1->idn,checkinstance,LLIEX,
                                                            pairedrl1->Lindex,pairedrl1->Sindex,Config3,Strat3,Domain3,&part1,&part2,&part3) > 0)
                                                      {
                                                      if(part3 > 0)
                                                         {
                                                         for(k=1; k<pairedrl1->numnodes; k++)
                                                            {
                                                            ptpdist1 = PointToLineDist2D(xi,yi,pairedrl1->x[k-1],pairedrl1->y[k-1],pairedrl1->x[k],pairedrl1->y[k]);
                                                            if(SensitivityCheck(LTEQ,LLIEX,checkinstance,ptpdist1) > 0)
                                                               {
                                                               inregion1 = 1;
                                                               break;
                                                               }
                                                            }
                                                         }
                                                      }
                                                   }
                                                pairedrl1 = pairedrl1->next;
                                                }
                                             }

                                          if((inregion1 == 0) &&
                                               (ActiveChecks[checkinstance].number == LLIEX) && (ActiveChecks[checkinstance].Config3[C_FOMO] > 0))
                                             {
                                             rbc = Broot;
                                             while((rbc != NULL) && (inregion1 == 0))
                                                {
                                                Config3 = SCCtable[rbc->Sindex].C;
                                                Strat3 = SCCtable[rbc->Sindex].S;
                                                Domain3 = SCCtable[rbc->Sindex].D;
                                                if(CombinedCheckApplies(rbc->idn,checkinstance,LLIEX,
                                                           rbc->Lindex,rbc->Sindex,Config3,Strat3,Domain3,&part1,&part2,&part3) > 0)
                                                   {
                                                   if(part3 > 0)
                                                      {
                                                      if((rbc->numverts == 3) && (PointInsideTriangle(xi,yi,rbc->x[0],rbc->y[0],
                                                                      rbc->x[1],rbc->y[1],rbc->x[2],rbc->y[2]) > 0))
                                                         {
                                                         inregion1 = 1;
                                                         }
                                                      if(PointInsidePoly(xi,yi,rbc->x,rbc->y,rbc->numverts) > 0)
                                                         {
                                                         inregion1 = 1;
                                                         }
                                                      }
                                                   }
                                                rbc = rbc->next;
                                                }
                                             if(inregion1 == 0)
                                                {
                                                rpc = Proot;
                                                while((rpc != NULL) && (inregion1 == 0))
                                                   {
                                                   if(rpc->numverts > 2)
                                                      {
                                                      Config3 = SCCtable[rpc->Sindex].C;
                                                      Strat3 = SCCtable[rpc->Sindex].S;
                                                      Domain3 = SCCtable[rpc->Sindex].D;
                                                      if(CombinedCheckApplies(rpc->idn,checkinstance,LLIEX,
                                                             rpc->Lindex,rpc->Sindex,Config3,Strat3,Domain3,&part1,&part2,&part3) > 0)
                                                         {
                                                         if(part3 > 0)
                                                            {
                                                            if((rpc->numverts == 3) && (PointInsideTriangle(xi,yi,rpc->x[0],rpc->y[0],
                                                                                  rpc->x[1],rpc->y[1],rpc->x[2],rpc->y[2]) > 0))
                                                               {
                                                               inregion1 = 1;
                                                               }
                                                            else if(PointInsidePoly(xi,yi,rpc->x,rpc->y,rpc->numverts) > 0)
                                                               {
                                                               inregion1 = 1;
                                                               }
                                                            }
                                                         }
                                                      }
                                                   rpc = rpc->next;
                                                   }
                                                }
                                             }
                                          if((inregion1 == 0) &&
                                             (ActiveChecks[checkinstance].number == LLIEX) && 
                                                 ((ActiveChecks[checkinstance].Config3[C_POLY] > 0) || (ActiveChecks[checkinstance].Config3[C_MOLI] > 0)))
                                             {
                                             tpc = Polyroot;
                                             while((tpc != NULL) && (inregion1 == 0))
                                                {
                                                Config3 = SCCtable[tpc->SCCindex].C;
                                                Strat3 = SCCtable[tpc->SCCindex].S;
                                                Domain3 = SCCtable[tpc->SCCindex].D;
                                                if(CombinedCheckApplies(tpc->idn,checkinstance,LLIEX,
                                                         tpc->SACindex,tpc->SCCindex,Config3,Strat3,Domain3,&part1,&part2,&part3) > 0)
                                                   {
                                                   if(part3 > 0) 
                                                      {
                                                      if((tpc->numverts == 3) && (PointInsideTriangle(xi,yi,tpc->x[0],tpc->y[0],
                                                                                  tpc->x[1],tpc->y[1],tpc->x[2],tpc->y[2]) > 0))
                                                         {
                                                         inregion1 = 1;
                                                         break;
                                                         }
                                                      else if((tpc->numverts > 3) && (PointInsidePoly(xi,yi,tpc->x,tpc->y,tpc->numverts) > 0))
                                                         {
                                                         inregion1 = 1;
                                                         break;
                                                         }
                                                      }
                                                   }
                                                tpc = tpc->next;
                                                }
                                             }
                                          if(inregion1 == 0)
                                             {
                                             ERc->z[0] = InterpLinearElev(x1,y1,z1,x2,y2,z2,xi,yi);
                                             ERc->next = ERroot;
                                             ERroot = ERc;
                                             }
                                          else
                                             free(ERc);
                                          }
                                       else
                                          free(ERc);
   
                                       }
                                    }
                                 }
                              }
                           }
                        }
                     }
                  rln = rln->next;
                  }
               }
            }
         


         if((rlc->length > 0.00025) && (CombinedCheckApplies(rlc->idn,checkinstance,LLI_ANGLE,rlc->Lindex,rlc->Sindex,Config1,Strat1,Domain1,&part1,&part2,&part3) > 0))
            {
            if(part1 > 0)
               {
               tempsensitivity = FindRelevantSensitivity(LLI_ANGLE,checkinstance,&tempsensitivity2);
               rln = root;
               while(rln != NULL)
                  {
                  if(rln == rlc)
                     {
                     if(rlc->next == NULL)
                        break;
                     else
                        rln = rlc->next;
                     }
                  Config2 = SCCtable[rln->Sindex].C;
                  Strat2 = SCCtable[rln->Sindex].S;
                  Domain2 = SCCtable[rln->Sindex].D;
                  if(CombinedCheckApplies(rln->idn,checkinstance,LLI_ANGLE,rln->Lindex,rln->Sindex,Config2,Strat2,Domain2,&part1,&part2,&part3) > 0)
                     {
                     if(part2 > 0)
                        {
                        for(i=1; i<rlc->numnodes; i++)
                           {
                           ii = i - 1;
                           kk = i + 1;
                           if(kk < rlc->numnodes)
                              {
                              temp3 = TurnAngle(rlc->x[ii],rlc->y[ii],
                                                  rlc->x[i],rlc->y[i],
                                                    rlc->x[kk],rlc->y[kk]);
                              if(temp3 < PI)
                                 temp3 = RadiansToDegrees(temp3);
                              else
                                 temp3 = 180;
                              if(temp3 <= tempsensitivity)
                                 continue;
                              }
                           x1 = rlc->x[ii];
                           y1 = rlc->y[ii];
                           z1 = rlc->z[ii];
                           x2 = rlc->x[i];
                           y2 = rlc->y[i];
                           z2 = rlc->z[i];

                           if(ClipLineToRegion(minx,miny,maxx,maxy,&x1,&y1,&z1,&x2,&y2,&z2,&clipflag,multiplier) > 0)
                              {
                              for(j=1; j<rln->numnodes; j++)
                                 {
                                 jj = j - 1;
                                 x3 = rln->x[jj];
                                 y3 = rln->y[jj];
                                 z3 = rln->z[jj];
                                 x4 = rln->x[j];
                                 y4 = rln->y[j];
                                 z4 = rln->z[j];
                                 if(ClipLineToRegion(minx,miny,maxx,maxy,&x3,&y3,&z3,&x4,&y4,&z4,&clipflag,multiplier) > 0)
                                    {
                                    if((LineSegmentsIntersect(x1,y1,x2,y2,x3,y3,x4,y4, &xi, &yi) > 0) &&
                                               (SegOverlapsLine(rlc->x[i],rlc->y[i],rlc->x[ii],rlc->y[ii],rln,jj,j) == 0))
                                       {
                                       if((NearlyEqual(x1,x3) > 0) && (NearlyEqual(y1,y3) > 0))
                                          {
                                          kk2 = j - 2;
                                          if(kk2 >= 0)
                                             {
                                             temp1 = TurnAngle(x2,y2,x1,y1,x4,y4);
                                             temp2 = TurnAngle(x2,y2,x1,y1,rln->x[kk2],rln->y[kk2]);
                                             if(temp1 < temp2)
                                                Tangle = temp1;
                                             else
                                                Tangle = temp2;
                                             }
                                          else
                                             {
                                             kk2 = i - 2;
                                             if(kk2 >= 0)
                                                {
                                                temp1 = TurnAngle(x2,y2,x1,y1,x4,y4);
                                                temp2 = TurnAngle(x4,y4,x1,y1,rlc->x[kk2],rlc->y[kk2]);
                                                if(temp1 < temp2)
                                                   Tangle = temp1;
                                                else
                                                   Tangle = temp2;
                                                }
                                             else
                                                Tangle = TurnAngle(x2,y2,x3,y3,x4,y4);
                                             }
                                          }
                                       else if((NearlyEqual(x1,x4) > 0) && (NearlyEqual(y1,y4) > 0))
                                          {
                                          kk2 = j + 1;
                                          if(kk2 < rln->numnodes)
                                             {
                                             temp1 = TurnAngle(x2,y2,x1,y1,x3,y3);
                                             temp2 = TurnAngle(x2,y2,x1,y1,rln->x[kk2],rln->y[kk2]);
                                             if(temp1 < temp2)
                                                Tangle = temp1;
                                             else
                                                Tangle = temp2;
                                             }
                                          else
                                             {
                                             kk2 = i + 1;
                                             if(kk2 < rlc->numnodes)
                                                {
                                                temp1 = TurnAngle(x2,y2,x1,y1,x3,y3);
                                                temp2 = TurnAngle(x3,y3,x1,y1,rlc->x[kk2],rlc->y[kk2]);
                                                if(temp1 < temp2)
                                                   Tangle = temp1;
                                                else
                                                   Tangle = temp2;
                                                }
                                             else
                                                Tangle = TurnAngle(x2,y2,x1,y1,x3,y3);
                                             }
                                          }
                                       else if((NearlyEqual(x2,x3) > 0) && (NearlyEqual(y2,y3) > 0))
                                          {
                                          kk2 = j - 2;
                                          if(kk2 >= 0)
                                             {
                                             temp1 = TurnAngle(x1,y1,x2,y2,x4,y4);
                                             temp2 = TurnAngle(x1,y1,x2,y2,rln->x[kk2],rln->y[kk2]);
                                             if(temp1 < temp2)
                                                Tangle = temp1;
                                             else
                                                Tangle = temp2;
                                             }
                                          else
                                             {
                                             kk2 = i - 2;
                                             if(kk2 >= 0)
                                                {
                                                temp1 = TurnAngle(x1,y1,x2,y2,x4,y4);
                                                temp2 = TurnAngle(x4,y4,x2,y2,rlc->x[kk2],rlc->y[kk2]);
                                                if(temp1 < temp2)
                                                   Tangle = temp1;
                                                else
                                                   Tangle = temp2;
                                                }
                                             else
                                                Tangle = TurnAngle(x1,y1,x2,y2,x4,y4);
                                             }
                                          }
                                       else if((NearlyEqual(x2,x4) > 0) && (NearlyEqual(y2,y4) > 0))
                                          {
                                          kk2 = j + 1;
                                          if(kk2 < rln->numnodes)
                                             {
                                             temp1 = TurnAngle(x1,y1,x2,y2,x3,y3);
                                             temp2 = TurnAngle(x1,y1,x2,y2,rln->x[kk2],rln->y[kk2]);
                                             if(temp1 < temp2)
                                                Tangle = temp1;
                                             else
                                                Tangle = temp2;
                                             }
                                          else
                                             {
                                             kk2 = i + 1;
                                             if(kk2 < rlc->numnodes)
                                                {
                                                temp1 = TurnAngle(x1,y1,x2,y2,x3,y3);
                                                temp2 = TurnAngle(x3,y3,x2,y2,rlc->x[kk2],rlc->y[kk2]);
                                                if(temp1 < temp2)
                                                   Tangle = temp1;
                                                else
                                                   Tangle = temp2;
                                                }
                                             else
                                                Tangle = TurnAngle(x1,y1,x2,y2,x3,y3);
                                             }
                                          }
                                       else
                                          {
                                          if((NearlyEqual(xi,x1) > 0)  && (NearlyEqual(yi,y1) > 0))
                                             {
                                             temp1 = TurnAngle(x2,y2,x1,y1,x3,y3);
                                             temp2 = TurnAngle(x2,y2,x1,y1,x4,y4);
                                             if(temp1 < temp2)
                                                Tangle = temp1;
                                             else
                                                Tangle = temp2;
                                             }
                                          else if((NearlyEqual(xi,x2) > 0)  && (NearlyEqual(yi,y2) > 0))
                                             {
                                             temp1 = TurnAngle(x1,y1,x2,y2,x3,y3);
                                             temp2 = TurnAngle(x1,y1,x2,y2,x4,y4);
                                             if(temp1 < temp2)
                                                Tangle = temp1;
                                             else
                                                Tangle = temp2;
                                             }
                                          else if((NearlyEqual(xi,x3) > 0)  && (NearlyEqual(yi,y3) > 0))
                                             {
                                             temp1 = TurnAngle(x4,y4,x3,y3,x1,y1);
                                             temp2 = TurnAngle(x4,y4,x3,y3,x2,y2);
                                             if(temp1 < temp2)
                                                Tangle = temp1;
                                             else
                                                Tangle = temp2;
                                             }
                                          else if((NearlyEqual(xi,x4) > 0)  && (NearlyEqual(yi,y4) > 0))
                                             {
                                             temp1 = TurnAngle(x3,y3,x4,y4,x1,y1);
                                             temp2 = TurnAngle(x3,y3,x4,y4,x2,y2);
                                             if(temp1 < temp2)
                                                Tangle = temp1;
                                             else
                                                Tangle = temp2;
                                             }
                                          else
                                             {
                                             temp1 = TurnAngle(x1,y1,xi,yi,x3,y3);
                                             temp2 = TurnAngle(x1,y1,xi,yi,x4,y4);
                                             if(temp1 < temp2)
                                                Tangle = temp1;
                                             else
                                                Tangle = temp2;
                                             temp1 = TurnAngle(x2,y2,xi,yi,x3,y3);
                                             temp2 = TurnAngle(x2,y2,xi,yi,x4,y4);
                                             if(temp1 < Tangle)
                                                Tangle = temp1;
                                             if(temp2 < Tangle) 
                                                Tangle = temp2;
                                             }
                                          }

                                       if(Tangle < PI)
                                          Tangle = RadiansToDegrees(Tangle);
                                       else
                                          Tangle = 180;
                                       if(Tangle > tempsensitivity)
                                          {
                                          rln2 = root;
                                          temp3 = Tangle;
                                          while((rln2 != NULL) && (temp3 > tempsensitivity))
                                             {
                                             if((rln2 != rln) && (rln2 != rlc))
                                                {
                                                if((CombinedCheckApplies(rln2->idn,checkinstance,LLI_ANGLE,rln2->Lindex,rln2->Sindex,
                                                      SCCtable[rln->Sindex].C,SCCtable[rln->Sindex].S,SCCtable[rln->Sindex].D,
                                                         &part1,&part2,&part3) > 0) && (part2 > 0))
                                                   {
                                                   kk2 = 0;
                                                   for(kk=1; kk<rln2->numnodes; kk++)
                                                      {
                                                      checkit2 = 0;
                                                      if(EqualWithinTolerance(rln2->x[kk],rln2->y[kk], xi,yi, 0.1) > 0)
                                                         {
                                                         xi2 = rln2->x[kk];
                                                         yi2 = rln2->y[kk];
                                                         checkit2 = 1;
                                                         }
                                                      else if(EqualWithinTolerance(rln2->x[kk2],rln2->y[kk2], xi,yi, 0.1) > 0)
                                                         {
                                                         xi2 = rln2->x[kk2];
                                                         yi2 = rln2->y[kk2];
                                                         checkit2 = 1;
                                                         }
                                                      else if((LineSegmentsIntersect(x1,y1,x2,y2,
                                                                  rln2->x[kk],rln2->y[kk],rln2->x[kk2],rln2->y[kk2],&xi2, &yi2) > 0) &&
                                                                     (EqualWithinTolerance(xi2,yi2, xi,yi, 0.1) > 0))
                                                         {
                                                         checkit2 = 1;
                                                         }

                                                      if(checkit2 > 0)
                                                         {
                                                         if((x1 == rln2->x[kk]) && (y1 == rln2->y[kk]))
                                                            temp3 = TurnAngle(x2,y2,x1,y1,rln2->x[kk2],rln2->y[kk2]);
                                                         else if((x1 == rln2->x[kk2]) && (y1 == rln2->y[kk2]))
                                                            temp3 = TurnAngle(x2,y2,x1,y1,rln2->x[kk],rln2->y[kk]);
                                                         else if((x2 == rln2->x[kk]) && (y2 == rln2->y[kk]))
                                                            temp3 = TurnAngle(x1,y1,x2,y2,rln2->x[kk2],rln2->y[kk2]);
                                                         else if((x2 == rln2->x[kk2]) && (y2 == rln2->y[kk2]))
                                                            temp3 = TurnAngle(x1,y1,x2,y2,rln2->x[kk],rln2->y[kk]);
                                                         else
                                                            {
                                                            if((NearlyEqual(xi,x1) > 0)  && (NearlyEqual(yi,y1) > 0))
                                                               {
                                                               temp1 = TurnAngle(x2,y2,x1,y1,rln2->x[kk],rln2->y[kk]);
                                                               temp2 = TurnAngle(x2,y2,x1,y1,rln2->x[kk2],rln2->y[kk2]);
                                                               if(temp1 < temp2)
                                                                  temp3 = temp1;
                                                               else
                                                                  temp3 = temp2;
                                                               }
                                                            else if((NearlyEqual(xi,x2) > 0)  && (NearlyEqual(yi,y2) > 0))
                                                               {
                                                               temp1 = TurnAngle(x1,y1,x2,y2,rln2->x[kk],rln2->y[kk]);
                                                               temp2 = TurnAngle(x1,y1,x2,y2,rln2->x[kk2],rln2->y[kk2]);
                                                               if(temp1 < temp2)
                                                                  temp3 = temp1;
                                                               else
                                                                  temp3 = temp2;
                                                               }
                                                            else if((NearlyEqual(xi,rln2->x[kk]) > 0)  && (NearlyEqual(yi,rln2->y[kk]) > 0))
                                                               {
                                                               temp1 = TurnAngle(x1,y1,rln2->x[kk],rln2->y[kk],rln2->x[kk2],rln2->y[kk2]);
                                                               temp2 = TurnAngle(x2,y2,rln2->x[kk],rln2->y[kk],rln2->x[kk2],rln2->y[kk2]);
                                                               if(temp1 < temp2)
                                                                  temp3 = temp1;
                                                               else
                                                                  temp3 = temp2;
                                                               }
                                                            else if((NearlyEqual(xi,rln2->x[kk2]) > 0)  && (NearlyEqual(yi,rln2->y[kk2]) > 0))
                                                               {
                                                               temp1 = TurnAngle(x1,y1,rln2->x[kk2],rln2->y[kk2],rln2->x[kk],rln2->y[kk]);
                                                               temp2 = TurnAngle(x2,y2,rln2->x[kk2],rln2->y[kk2],rln2->x[kk],rln2->y[kk]);
                                                               if(temp1 < temp2)
                                                                  temp3 = temp1;
                                                               else
                                                                  temp3 = temp2;
                                                               }
                                                            else
                                                               {
                                                               temp1 = TurnAngle(x1,y1,xi,yi,rln2->x[kk],rln2->y[kk]);
                                                               temp2 = TurnAngle(x1,y1,xi,yi,rln2->x[kk2],rln2->y[kk2]);
                                                               if(temp1 < temp2)
                                                                  temp3 = temp1;
                                                               else
                                                                  temp3 = temp2;
                                                               temp1 = TurnAngle(x2,y2,xi,yi,rln2->x[kk],rln2->y[kk]);
                                                               temp2 = TurnAngle(x2,y2,xi,yi,rln2->x[kk2],rln2->y[kk2]);
                                                               if(temp1 < temp3)
                                                                  temp3 = temp1;
                                                               if(temp2 < temp3)
                                                                  temp3 = temp2;
                                                               }
                                                            }
                                                         if(temp3 < PI)
                                                            temp3 = RadiansToDegrees(temp3);
                                                         else
                                                            temp3 = 180;
                                                         if(temp3 < Tangle)
                                                            {
                                                            Tangle = (tempsensitivity * 0.1);  //temp3;
                                                            break;
                                                            }
                                                         
                                                         }
                                                      kk2 = kk;
                                                      }
                                                   }
                                                }
                                             if(Tangle <= tempsensitivity)
                                                break;
                                             rln2 = rln2->next;
                                             }
                                          }
                                       if(Tangle > tempsensitivity)
                                          {
                                          ERc = (struct collection *) (malloc(SzC));
                                          if(ERc == NULL)
                                             {
                                             printf("allocation memory exhausted during linear feature condition analysis\n");
                                             printf("processing cannot continue\n");
                                             exit(-1);
                                             }
                                          ERc->x[0] = xi;
                                          ERc->y[0] = yi;
                                          ERc->magnitude = Tangle;
                                          ERc->keyval = LLI_ANGLE;
                                          ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                                          ERc->IDN = rlc->idn;
                                          ERc->Sindex = rlc->Sindex;
                                          ERc->ll1 = rlc;
                                          ERc->vertexindex1 = ii;
                                          ERc->ll2 = rln;
                                          ERc->vertexindex2 = jj;
                                          ERc->next = NULL;

                                          ERn = ERroot;
                                          while(ERn != NULL)
                                             {
                                             if((ERn->Cnumber == ERc->Cnumber) && (ERn->keyval == ERc->keyval) &&
                                                  (ERn->x[0]   == ERc->x[0])   && (ERn->y[0]   == ERc->y[0])   &&
                                                  ( ( (ERn->ll1    == ERc->ll1)    &&   /* this is Clause A */
                                                    (ERn->ll2    == ERc->ll2)) ||
                                                   ( (ERn->ll1    == ERc->ll2)    &&   /* this is Clause B */
                                                    (ERn->ll2    == ERc->ll1))))
                                                {
                                                break;
                                                }
                                             ERn = ERn->next;
                                             }

                                          if(ERn == NULL)
                                             {
                                             inregion1 = 0;
                                             if((ActiveChecks[checkinstance].number == LLI_ANGLE) && /*** look at area features ***/
                                                  ((ActiveChecks[checkinstance].Config3[C_AREA] > 0) || (ActiveChecks[checkinstance].Config3[C_FMAF] > 0)))
                                                {
                                                rac = Aroot;
                                                while((rac != NULL) && (inregion1 == 0))
                                                   {
                                                   Config3 = SCCtable[rac->Sindex].C;
                                                   Strat3 = SCCtable[rac->Sindex].S;
                                                   Domain3 = SCCtable[rac->Sindex].D;
                                                   if(CombinedCheckApplies(rac->idn,checkinstance,LLI_ANGLE,rac->Lindex,rac->Sindex,
                                                        Config3,Strat3,Domain3,&part1,&part2,&part3) > 0)
                                                      {
                                                      if(part3 > 0)
                                                         {
                                                         if(PointInsidePoly(xi,yi,rac->x,rac->y,rac->numverts) > 0)
                                                            inregion1 = 1;
                                                         }
                                                      }
                                                   rac = rac->next;
                                                   }
                                                }

                                             if((inregion1 == 0) && /****  look at the points **/
                                                (ActiveChecks[checkinstance].number == LLI_ANGLE) &&
                                                    ((ActiveChecks[checkinstance].Config3[C_POFE] > 0) || (ActiveChecks[checkinstance].Config3[C_FMPF] > 0)))
                                                {
                                                rpc = Proot;
                                                while((rpc != NULL) && (inregion1 == 0))
                                                   {
                                                   if(rpc->numverts == -1)
                                                      {
                                                      Config3 = SCCtable[rpc->Sindex].C;
                                                      Strat3 = SCCtable[rpc->Sindex].S;
                                                      Domain3 = SCCtable[rpc->Sindex].D;
                                                      if(CombinedCheckApplies(rpc->idn,checkinstance,LLI_ANGLE,
                                                               rpc->Lindex,rpc->Sindex,Config3,Strat3,Domain3,&part1,&part2,&part3) > 0)
                                                         {
                                                         if(part3 > 0)
                                                            {
                                                            ptpdist1 = Distance(xi,yi,rpc->x[0],rpc->y[0]);
                                                            if(ptpdist1 <= tempsensitivity2)
                                                               {
                                                               inregion1 = 1;
                                                               break;
                                                               }
                                                            }
                                                         }
                                                      }
                                                   rpc = rpc->next;
                                                   }
                                                }

                                             if((inregion1 == 0) && /****  look at the lines **/
                                                (ActiveChecks[checkinstance].number == LLI_ANGLE) &&
                                                    ((ActiveChecks[checkinstance].Config3[C_LINE] > 0) || (ActiveChecks[checkinstance].Config3[C_DILI] > 0)))
                                                {
                                                pairedrl1 = root;
                                                while((pairedrl1 != NULL) && (inregion1 == 0))
                                                   {
                                                   if((pairedrl1 != rlc) && (pairedrl1 != rln))
                                                      {
                                                      Config3 = SCCtable[pairedrl1->Sindex].C;
                                                      Strat3 = SCCtable[pairedrl1->Sindex].S;
                                                      Domain3 = SCCtable[pairedrl1->Sindex].D;
                                                      if(CombinedCheckApplies(pairedrl1->idn,checkinstance,LLI_ANGLE,
                                                               pairedrl1->Lindex,pairedrl1->Sindex,Config3,Strat3,Domain3,&part1,&part2,&part3) > 0)
                                                         {
                                                         if(part3 > 0)
                                                            {
                                                            for(k=1; k<pairedrl1->numnodes; k++)
                                                               {
                                                               ptpdist1 = PointToLineDist2D(xi,yi,pairedrl1->x[k-1],pairedrl1->y[k-1],pairedrl1->x[k],pairedrl1->y[k]);
                                                               if(ptpdist1 <= tempsensitivity2)
                                                                  {
                                                                  inregion1 = 1;
                                                                  break;
                                                                  }
                                                               }
                                                            }
                                                         }
                                                      }
                                                   pairedrl1 = pairedrl1->next;
                                                   }
                                                }

                                             if((NGA_TYPE == 0) && (inregion1 == 0) && /**** look in the models **/
                                                  (ActiveChecks[checkinstance].number == LLI_ANGLE) && (ActiveChecks[checkinstance].Config3[C_FOMO] > 0))
                                                {
                                                rbc = Broot;
                                                while((rbc != NULL) && (inregion1 == 0))
                                                   {
                                                   Config3 = SCCtable[rbc->Sindex].C;
                                                   Strat3 = SCCtable[rbc->Sindex].S;
                                                   Domain3 = SCCtable[rbc->Sindex].D;
                                                   if(CombinedCheckApplies(rbc->idn,checkinstance,LLI_ANGLE,
                                                              rbc->Lindex,rbc->Sindex,Config3,Strat3,Domain3,&part1,&part2,&part3) > 0)
                                                      {
                                                      if(part3 > 0)
                                                         {
                                                         if((rbc->numverts == 3) && (PointInsideTriangle(xi,yi,rbc->x[0],rbc->y[0],
                                                                         rbc->x[1],rbc->y[1],rbc->x[2],rbc->y[2]) > 0))
                                                            {
                                                            inregion1 = 1;
                                                            }
                                                         if(PointInsidePoly(xi,yi,rbc->x,rbc->y,rbc->numverts) > 0)
                                                            {
                                                            inregion1 = 1;
                                                            }
                                                         }
                                                      }
                                                   rbc = rbc->next;
                                                   }
                                                if(inregion1 == 0)
                                                   {
                                                   rpc = Proot;
                                                   while((rpc != NULL) && (inregion1 == 0))
                                                      {
                                                      if(rpc->numverts > 2)
                                                         {
                                                         Config3 = SCCtable[rpc->Sindex].C;
                                                         Strat3 = SCCtable[rpc->Sindex].S;
                                                         Domain3 = SCCtable[rpc->Sindex].D;
                                                         if(CombinedCheckApplies(rpc->idn,checkinstance,LLI_ANGLE,
                                                                rpc->Lindex,rpc->Sindex,Config3,Strat3,Domain3,&part1,&part2,&part3) > 0)
                                                            {
                                                            if(part3 > 0)
                                                               {
                                                               if((rpc->numverts == 3) && (PointInsideTriangle(xi,yi,rpc->x[0],rpc->y[0],
                                                                                     rpc->x[1],rpc->y[1],rpc->x[2],rpc->y[2]) > 0))
                                                                  {
                                                                  inregion1 = 1;
                                                                  }
                                                               else if(PointInsidePoly(xi,yi,rpc->x,rpc->y,rpc->numverts) > 0)
                                                                  {
                                                                  inregion1 = 1;
                                                                  }
                                                               }
                                                            }
                                                         }
                                                      rpc = rpc->next;
                                                      }
                                                   }
                                                }
                                             if((NGA_TYPE == 0) && (inregion1 == 0) && /**** look in the polys **/
                                                (ActiveChecks[checkinstance].number == LLI_ANGLE) &&
                                                    ((ActiveChecks[checkinstance].Config3[C_POLY] > 0) || (ActiveChecks[checkinstance].Config3[C_MOLI] > 0)))
                                                {
                                                tpc = Polyroot;
                                                while((tpc != NULL) && (inregion1 == 0))
                                                   {
                                                   Config3 = SCCtable[tpc->SCCindex].C;
                                                   Strat3 = SCCtable[tpc->SCCindex].S;
                                                   Domain3 = SCCtable[tpc->SCCindex].D;
                                                   if(CombinedCheckApplies(tpc->idn,checkinstance,LLI_ANGLE,
                                                            tpc->SACindex,tpc->SCCindex,Config3,Strat3,Domain3,&part1,&part2,&part3) > 0)
                                                      {
                                                      if(part3 > 0)
                                                         {
                                                         if((tpc->numverts == 3) && (PointInsideTriangle(xi,yi,tpc->x[0],tpc->y[0],
                                                                                     tpc->x[1],tpc->y[1],tpc->x[2],tpc->y[2]) > 0))
                                                            {
                                                            inregion1 = 1;
                                                            break;
                                                            }
                                                         else if((tpc->numverts > 3) && (PointInsidePoly(xi,yi,tpc->x,tpc->y,tpc->numverts) > 0))
                                                            {
                                                            inregion1 = 1;
                                                            break;
                                                            }
                                                         }
                                                      }
                                                   tpc = tpc->next;
                                                   }
                                                }
                                             if(inregion1 == 0)
                                                {
                                                ERc->z[0] = InterpLinearElev(x1,y1,z1,x2,y2,z2,xi,yi);
                                                   ERc->next = ERroot;
                                                ERroot = ERc;
                                                }
                                             else
                                                free(ERc);
                                             }
                                          else
                                             free(ERc);

                                          }
                                       }
                                    }
                                 }
                              }
                           }
                        }
                     }
                  rln = rln->next;
                  }
               }
            }





         if((LF_NoIntCount == 0) &&
                (CombinedCheckApplies(rlc->idn,checkinstance,LFNOINT,rlc->Lindex,rlc->Sindex,Config1,Strat1,Domain1,&part1,&part2,&part3) > 0))
            {
            if(part1 > 0)
               {
               LF_NoIntCount = 0;
               nodeindex = 0;
               while((LF_NoIntCount == 0) && (nodeindex < rlc->numnodes))
                  {
                  LF_NoIntCount = PointOnQuarterDegreeBoundary(rlc->x[nodeindex], rlc->y[nodeindex], 0.1);
                  nodeindex += rlc->numnodes - 1;
                  }

               rpc = Proot;
               while((LF_NoIntCount == 0) && (rpc != NULL))
                  {
                  if(CombinedCheckApplies(rpc->idn,checkinstance,LFNOINT,rpc->Lindex,rpc->Sindex,SCCtable[rpc->Sindex].C,SCCtable[rpc->Sindex].D,
                           SCCtable[rpc->Sindex].S,&part1,&part2,&part3) > 0)
                     {
                     if(part2 > 0)
                        {
                        for(i=1; i<rlc->numnodes; i++)
                           {
                           ii = i - 1;
                           x1 = rlc->x[ii];
                           y1 = rlc->y[ii];
                           z1 = rlc->z[ii];
                           x2 = rlc->x[i];
                           y2 = rlc->y[i];
                           z2 = rlc->z[i];
                           if(ClipLineToRegion(minx,miny,maxx,maxy,&x1,&y1,&z1,&x2,&y2,&z2,&clipflag,multiplier) > 0)
                              {
                              IntersectResult = PointOnLineSegment(rpc->x[0],rpc->y[0],rlc->x[ii],rlc->y[ii],rlc->x[i],rlc->y[i], 0.1);
                              if(IntersectResult > 0)
                                 {
                                 ++LF_NoIntCount;
                                 if(rlc->IsMulti >= 1)
                                    {
                                    RB_newKey2 = rlc->idn + (checkinstance * 0.0001);
                                    if(( RB_newNode = RBExactQuery(Check_RB_Tree,&RB_newKey2)))
                                       {
                                       RB_cond = (struct ConditionCollection *) RB_newNode->info;
                                       RB_cond->counter += 1;
                                       }
                                    else
                                       {
                                       RB_cond = (struct ConditionCollection *) (malloc(SzCC));
                                       if(RB_cond == NULL)
                                          {
                                          printf("memory has been exhausted during RB-Tree information alloction for LFNOINT analysis\n");
                                          exit(-1);
                                          }
                                       RB_cond->keyval = LFNOINT;
                                       RB_cond->Cnumber =  Make_Correct(LFNOINT,checkinstance);
                                       RB_cond->index_from_to = NULL;
                                       RB_cond->gform = G_LINE;
                                       RB_cond->featureidn = rlc->featureid;
                                       RB_cond->localID = rlc->localID;
                                       RB_cond->counter = 1;
                                       RB_cond->radius = -1;
                                       RB_cond->height = -1;
                                       RB_cond->magnitude = 0.0;
                                       RB_cond->IDN = rlc->idn;
                                       RB_cond->Sindex = rlc->Sindex;
                                       RB_cond->Lindex = rlc->Lindex;

                                       RB_cond->numnodes = rlc->numnodes;
                                       RB_cond->x = (double *) (malloc(RB_cond->numnodes * SzD));
                                       RB_cond->y = (double *) (malloc(RB_cond->numnodes * SzD));
                                       RB_cond->z = (double *) (malloc(RB_cond->numnodes * SzD));
                                       if(RB_cond->z == NULL)
                                          {
                                          printf("memory has been exhausted during RB-Tree element vertex alloction for LFNOINT analysis\n");                                          exit(-1);
                                          }
                                       for(jj=0; jj< rlc->numnodes; jj++)
                                          {
                                          RB_cond->x[jj] = rlc->x[jj];
                                          RB_cond->y[jj] = rlc->y[jj];
                                          RB_cond->z[jj] = rlc->z[jj];
                                          }

                                       RB_newDbl = (double *) (malloc(SzD));
                                       if(RB_newDbl == NULL)
                                          {
                                          printf("memory has been exhausted during RB-Tree alloction for LFNOINT analysis\n");
                                          exit(-1);
                                          }
                                       *RB_newDbl = RB_newKey2; /**rac->localID; **/
                                       RBTreeInsert(Check_RB_Tree,RB_newDbl, RB_cond);
                                       }
                                    }
                                 }
                              }
                           if(LF_NoIntCount > 0)
                              break;
                           }  /** end for i = 1 ... ****/
                        }
                     }
                  rpc = rpc->next;
                  }
               rln = root;
               while((LF_NoIntCount == 0) && (rln != NULL))
                  {
                  if(rln == rlc)
                     {
                     if(rlc->next == NULL)
                        break;
                     else
                        rln = rlc->next;
                     }
                  Config2 = SCCtable[rln->Sindex].C;
                  Strat2 = SCCtable[rln->Sindex].S;
                  Domain2 = SCCtable[rln->Sindex].D;
                  if(CombinedCheckApplies(rln->idn,checkinstance,LFNOINT,rln->Lindex,rln->Sindex,Config2,Strat2,Domain2,&part1,&part2,&part3) > 0)
                     {
                     if(part2 > 0)
                        {
                        for(i=1; i<rlc->numnodes; i++)
                           {
                           ii = i - 1;
                           x1 = rlc->x[ii];
                           y1 = rlc->y[ii];
                           z1 = rlc->z[ii];
                           x2 = rlc->x[i];
                           y2 = rlc->y[i];
                           z2 = rlc->z[i];
                           if(ClipLineToRegion(minx,miny,maxx,maxy,&x1,&y1,&z1,&x2,&y2,&z2,&clipflag,multiplier) > 0)
                              {
                              for(j=1; j<rln->numnodes; j++)
                                 {
                                 jj = j - 1;
                                 x3 = rln->x[jj];
                                 y3 = rln->y[jj];
                                 z3 = rln->z[jj];
                                 x4 = rln->x[j];
                                 y4 = rln->y[j];
                                 z4 = rln->z[j];
                                 if(ClipLineToRegion(minx,miny,maxx,maxy,&x3,&y3,&z3,&x4,&y4,&z4,&clipflag,multiplier) > 0)
                                    {
                                    IntersectResult = LineSegmentsIntersect(x1,y1,x2,y2,x3,y3,x4,y4, &xi, &yi);
                                    if(IntersectResult < 1)
                                       IntersectResult = PointOnLineSegment(rlc->x[0],rlc->y[0],rln->x[jj],rln->y[jj],rln->x[j],rln->y[j], 0.01);
                                    if(IntersectResult < 1)
                                       IntersectResult = PointOnLineSegment(rlc->x[rlc->numnodes-1],rlc->y[rlc->numnodes-1],
                                                               rln->x[jj],rln->y[jj],rln->x[j],rln->y[j], 0.01);
                                    if(IntersectResult > 0)
                                      break;
                                    }
                                 }
                              if((IntersectResult == 0) && (rln->x[0] >= minx) && (rln->x[0] <= maxx) && (rln->y[0] >= miny) && (rln->y[0] <= maxy))
                                 IntersectResult = PointOnLineSegment(rln->x[0],rln->y[0],x1,y1,x2,y2, 0.01);
                              j = rln->numnodes - 1;
                              if((IntersectResult == 0) && (rln->x[j] >= minx) && (rln->x[j] <= maxx) && (rln->y[j] >= miny) && (rln->y[j] <= maxy))
                                 IntersectResult = PointOnLineSegment(rln->x[j],rln->y[j],x1,y1,x2,y2, 0.01);
                              if(IntersectResult > 0)
                                 {
                                 ++LF_NoIntCount;
                                 if(rlc->IsMulti >= 1)
                                    {
                                    RB_newKey2 = rlc->idn + (checkinstance * 0.0001);
                                    if(( RB_newNode = RBExactQuery(Check_RB_Tree,&RB_newKey2)))
                                       {
                                       RB_cond = (struct ConditionCollection *) RB_newNode->info;
                                       RB_cond->counter += 1;
                                       }
                                    else
                                       {
                                       RB_cond = (struct ConditionCollection *) (malloc(SzCC));
                                       if(RB_cond == NULL)
                                          {
                                          printf("memory has been exhausted during RB-Tree information alloction for LFNOINT analysis\n");
                                          exit(-1);
                                          }
                                       RB_cond->keyval = LFNOINT;
                                       RB_cond->Cnumber =  Make_Correct(LFNOINT,checkinstance);
                                       RB_cond->index_from_to = NULL;
                                       RB_cond->gform = G_LINE;
                                       RB_cond->featureidn = rlc->featureid;
                                       RB_cond->localID = rlc->localID;
                                       RB_cond->counter = 1;
                                       RB_cond->radius = -1;
                                       RB_cond->height = -1;
                                       RB_cond->magnitude = 0.0;
                                       RB_cond->IDN = rlc->idn;
                                       RB_cond->Sindex = rlc->Sindex;
                                       RB_cond->Lindex = rlc->Lindex;

                                       RB_cond->numnodes = rlc->numnodes;
                                       RB_cond->x = (double *) (malloc(RB_cond->numnodes * SzD));
                                       RB_cond->y = (double *) (malloc(RB_cond->numnodes * SzD));
                                       RB_cond->z = (double *) (malloc(RB_cond->numnodes * SzD));                                        if(RB_cond->z == NULL)
                                          {
                                          printf("memory has been exhausted during RB-Tree element vertex alloction for LFNOINT analysis\n");                                          exit(-1);
                                          }
                                       for(jj=0; jj< rlc->numnodes; jj++)
                                          {
                                          RB_cond->x[jj] = rlc->x[jj];
                                          RB_cond->y[jj] = rlc->y[jj];                                           RB_cond->z[jj] = rlc->z[jj];
                                          }

                                       RB_newDbl = (double *) (malloc(SzD));                                        if(RB_newDbl == NULL)
                                          {
                                          printf("memory has been exhausted during RB-Tree alloction for LFNOINT analysis\n");
                                          exit(-1);
                                          }
                                       *RB_newDbl = RB_newKey2; /**rac->localID; **/
                                       RBTreeInsert(Check_RB_Tree,RB_newDbl, RB_cond);
                                       }
                                    }
                                 }
                              }
                           if(LF_NoIntCount > 0)
                              break;
                           } /*** end for i = 1 ... ****/
                        }
                     }
                  rln = rln->next;
                  }
               if(LF_NoIntCount == 0)
                  {
                  rac = Aroot;
                  while((LF_NoIntCount == 0) && (rac != NULL))
                     {
                     Config3 = SCCtable[rac->Sindex].C;
                     Strat3 = SCCtable[rac->Sindex].S;
                     Domain3 = SCCtable[rac->Sindex].D;
                     if(CombinedCheckApplies(rac->idn,checkinstance,LFNOINT,rac->Lindex,rac->Sindex,Config3,Strat3,Domain3,&part1,&part2,&part3) > 0)
                        {
                        if(part2 > 0)
                           {
                           for(i=1; i<rlc->numnodes; i++)
                              {
                              ii = i - 1;
                              x1 = rlc->x[ii];
                              y1 = rlc->y[ii];
                              z1 = rlc->z[ii];
                              x2 = rlc->x[i];
                              y2 = rlc->y[i];
                              z2 = rlc->z[i];
                              if(ClipLineToRegion(minx,miny,maxx,maxy,&x1,&y1,&z1,&x2,&y2,&z2,&clipflag,multiplier) > 0)
                                 {
                                 for(j=0; j<rac->numverts; j++)
                                    {
                                    if(j > 0)
                                       jj = j - 1;
                                    else
                                       jj = rac->numverts - 1;

                                    x3 = rac->x[jj];
                                    y3 = rac->y[jj];
                                    z3 = rac->z[jj];
                                    x4 = rac->x[j];
                                    y4 = rac->y[j];
                                    z4 = rac->z[j];
                                    if(ClipLineToRegion(minx,miny,maxx,maxy,&x3,&y3,&z3,&x4,&y4,&z4,&clipflag,multiplier) > 0)
                                       {
                                       IntersectResult = PointOnLineSegment(rlc->x[0],rlc->y[0],rac->x[jj],rac->y[jj],rac->x[j],rac->y[j], 0.01);
                                       if(IntersectResult < 1)
                                          IntersectResult = PointOnLineSegment(rlc->x[rlc->numnodes-1],rlc->y[rlc->numnodes-1],
                                                           rac->x[jj],rac->y[jj],rac->x[j],rac->y[j], 0.01);
                                       if(IntersectResult < 1)
                                          IntersectResult = LineSegmentsIntersect(x1,y1,x2,y2,x3,y3,x4,y4, &xi, &yi);
                                       if(IntersectResult > 0)
                                          {
                                          ++LF_NoIntCount;
                                          if(rlc->IsMulti >= 1)
                                             {
                                             RB_newKey2 = rlc->idn + (checkinstance * 0.0001);
                                             if(( RB_newNode = RBExactQuery(Check_RB_Tree,&RB_newKey2)))
                                                {
                                                RB_cond = (struct ConditionCollection *) RB_newNode->info;
                                                RB_cond->counter += 1;
                                                }
                                             else                                                 {
                                                RB_cond = (struct ConditionCollection *) (malloc(SzCC));
                                                if(RB_cond == NULL)
                                                   {
                                                   printf("memory has been exhausted during RB-Tree information alloction for LFNOINT analysis\n");
                                                   exit(-1);
                                                   }
                                                RB_cond->keyval = LFNOINT;
                                                RB_cond->Cnumber =  Make_Correct(LFNOINT,checkinstance);
                                                RB_cond->index_from_to = NULL;
                                                RB_cond->gform = G_LINE;
                                                RB_cond->featureidn = rlc->featureid;
                                                RB_cond->localID = rlc->localID;
                                                RB_cond->counter = 1;
                                                RB_cond->radius = -1;
                                                RB_cond->height = -1;
                                                RB_cond->magnitude = 0.0;
                                                RB_cond->IDN = rlc->idn;
                                                RB_cond->Sindex = rlc->Sindex;
                                                RB_cond->Lindex = rlc->Lindex;

                                                RB_cond->numnodes = rlc->numnodes;
                                                RB_cond->x = (double *) (malloc(RB_cond->numnodes * SzD));
                                                RB_cond->y = (double *) (malloc(RB_cond->numnodes * SzD));
                                                RB_cond->z = (double *) (malloc(RB_cond->numnodes * SzD));
                                                if(RB_cond->z == NULL)
                                                   {
                                                   printf("memory has been exhausted during RB-Tree element vertex alloction for LFNOINT analysis\n");
                                                   exit(-1);
                                                   }
                                                for(jj=0; jj< rlc->numnodes; jj++)
                                                   {
                                                   RB_cond->x[jj] = rlc->x[jj];
                                                   RB_cond->y[jj] = rlc->y[jj];
                                                   RB_cond->z[jj] = rlc->z[jj];
                                                   }

                                                RB_newDbl = (double *) (malloc(SzD));
                                                if(RB_newDbl == NULL)
                                                   {
                                                   printf("memory has been exhausted during RB-Tree alloction for LFNOINT analysis\n");
                                                   exit(-1);
                                                   }
                                                *RB_newDbl = RB_newKey2; /**rac->localID; **/
                                                RBTreeInsert(Check_RB_Tree,RB_newDbl, RB_cond);
                                                }
                                             }
                                          break; /*** should break from the while rac != NULL loop ****/
                                          }
                                       }
                                    }
                                 }
                              if(LF_NoIntCount > 0)
                                 break;
                              } /*** end for i = 1 .... ****/
                           }
                        }
                     rac = rac->next;
                     }
                  }
               if(LF_NoIntCount == 0)
                  {
                  if(rlc->IsMulti == 0)  /** a single region linear feature ****/
                     {
                     ERc = (struct collection *) (malloc(SzC));
                     if(ERc == NULL)
                        {
                        printf("allocation memory exhausted during linear feature condition analysis\n");
                        printf("processing cannot continue\n");
                        exit(-1);
                        }
                     ERc->x[0] = 0.0;
                     ERc->y[0] = 0.0;
                     ERc->z[0] = 0.0;
                     ERc->magnitude = 0.0;
                     ERc->keyval = LFNOINT;
                     ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                     ERc->IDN = rlc->idn;
                     ERc->Sindex = rlc->Sindex;
                     ERc->ll1 = rlc;
                     ERc->vertexindex1 = 0;
                     ERc->ll2 = NULL;
                     ERc->vertexindex2 = 0;
                     ERc->next = NULL;
                     if(ERroot == NULL)
                        {
                        ERroot = ERc;
                        }
                     else
                        {
                        ERn = ERroot;
                        while(ERn != NULL)
                           {
                           if((ERn->Cnumber == ERc->Cnumber) && (ERn->keyval == ERc->keyval) && (ERn->ll1 == ERc->ll1))
                              break;

                           ERn = ERn->next;
                           }
                        if(ERn == NULL)
                           {
                           ERc->next = ERroot;
                           ERroot = ERc;
                           }
                        else
                          free(ERc);
                        }
                     } /*** end is single region linear ***/
                  else if(rlc->IsMulti >= 1)
                     {
                     RB_newKey2 = rlc->idn + (checkinstance * 0.0001);
                     if(( RB_newNode = RBExactQuery(Check_RB_Tree,&RB_newKey2)) == 0)
                        {
                        RB_cond = (struct ConditionCollection *) (malloc(SzCC));

                        if(RB_cond == NULL)
                           {
                           printf("memory has been exhausted during RB-Tree information alloction for LFNOINT analysis\n");
                           exit(-1);
                           }
                        RB_cond->keyval = LFNOINT;
                        RB_cond->Cnumber =  Make_Correct(LFNOINT,checkinstance);
                        RB_cond->index_from_to = NULL;
                        RB_cond->gform = G_LINE;
                        RB_cond->featureidn = rlc->featureid;
                        RB_cond->counter = 0;
                        RB_cond->radius = -1;
                        RB_cond->height = -1;
                        RB_cond->magnitude = 0.0;
                        RB_cond->IDN = rlc->idn;
                        RB_cond->localID = rlc->localID;
                        RB_cond->Sindex = rlc->Sindex;
                        RB_cond->Lindex = rlc->Lindex;

                        RB_cond->numnodes = rlc->numnodes;
                        RB_cond->x = (double *) (malloc(RB_cond->numnodes * SzD));
                        RB_cond->y = (double *) (malloc(RB_cond->numnodes * SzD));
                        RB_cond->z = (double *) (malloc(RB_cond->numnodes * SzD));
                        if(RB_cond->z == NULL)
                           {
                           printf("memory has been exhausted during RB-Tree element vertex alloction for LFNOINT analysis\n");
                           exit(-1);
                           }
                        for(jj=0; jj< rlc->numnodes; jj++)
                           {
                           RB_cond->x[jj] = rlc->x[jj];
                           RB_cond->y[jj] = rlc->y[jj];
                           RB_cond->z[jj] = rlc->z[jj];
                           }

                        RB_newDbl = (double *) (malloc(SzD));
                        if(RB_newDbl == NULL)
                           {
                           printf("memory has been exhausted during RB-Tree alloction for LFNOINT analysis\n");
                           exit(-1);
                           }
                        *RB_newDbl = RB_newKey2; /**rac->localID; **/
                        RBTreeInsert(Check_RB_Tree,RB_newDbl, RB_cond);
                        }
                     }
                  }
               }
            }



         if((NoIntCount == 0) &&
                (CombinedCheckApplies(rlc->idn,checkinstance,LLNOINT,rlc->Lindex,rlc->Sindex,Config1,Strat1,Domain1,&part1,&part2,&part3) > 0))
            {
            if(part1 > 0)
               {
               tempsensitivity = FindRelevantSensitivity(LLNOINT,checkinstance,&unuseddbl);
               NoIntCount = 0;
               rln = root;
               checkit2 = 0;
               while(rln != NULL)
                  {
                  if(rln == rlc)
                     {
                     if(rlc->next == NULL)
                        break;
                     else
                        rln = rlc->next;
                     }
                  Config2 = SCCtable[rln->Sindex].C;
                  Strat2 = SCCtable[rln->Sindex].S;
                  Domain2 = SCCtable[rln->Sindex].D;
                  isclose = 0;
                  if(CombinedCheckApplies(rln->idn,checkinstance,LLNOINT,rln->Lindex,rln->Sindex,Config2,Strat2,Domain2,&part1,&part2,&part3) > 0)
                     {
                     if(part2 > 0)
                        {
                        for(i=1; i<rlc->numnodes; i++)
                           {
                           ii = i - 1;
                           x1 = rlc->x[ii];
                           y1 = rlc->y[ii];
                           z1 = rlc->z[ii];
                           x2 = rlc->x[i];
                           y2 = rlc->y[i];
                           z2 = rlc->z[i];
                           if(((x2 - minx) <= tempsensitivity) || ((maxx - x2) <= tempsensitivity))
                              isclose = 1;
                           else if(((y2 - miny) <= tempsensitivity) || ((maxy - y2) <= tempsensitivity))
                              isclose = 1;
                           if(ClipLineToRegion(minx,miny,maxx,maxy,&x1,&y1,&z1,&x2,&y2,&z2,&clipflag,multiplier) > 0)
                              {
                              for(j=1; j<rln->numnodes; j++)
                                 {
                                 jj = j - 1;
                                 x3 = rln->x[jj];
                                 y3 = rln->y[jj];
                                 z3 = rln->z[jj];
                                 x4 = rln->x[j];
                                 y4 = rln->y[j];
                                 z4 = rln->z[j];
                                 if(ClipLineToRegion(minx,miny,maxx,maxy,&x3,&y3,&z3,&x4,&y4,&z4,&clipflag,multiplier) > 0)
                                    {
                                    IntersectResult = LineSegmentsIntersect(x1,y1,x2,y2,x3,y3,x4,y4, &xi, &yi);
                                    if(IntersectResult < 1)
                                       IntersectResult = PointOnLineSegment(rlc->x[0],rlc->y[0],rln->x[jj],rln->y[jj],rln->x[j],rln->y[j], tempsensitivity);
                                    if(IntersectResult < 1)
                                       IntersectResult = PointOnLineSegment(rlc->x[rlc->numnodes-1],rlc->y[rlc->numnodes-1],
                                                               rln->x[jj],rln->y[jj],rln->x[j],rln->y[j], tempsensitivity);
                                    if(IntersectResult > 0)
                                      break;
                                    }
                                 }
                              if((IntersectResult == 0) && (rln->x[0] >= minx) && (rln->x[0] <= maxx) && (rln->y[0] >= miny) && (rln->y[0] <= maxy))
                                 IntersectResult = PointOnLineSegment(rln->x[0],rln->y[0],x1,y1,x2,y2, tempsensitivity);
                              j = rln->numnodes - 1;
                              if((IntersectResult == 0) && (rln->x[j] >= minx) && (rln->x[j] <= maxx) && (rln->y[j] >= miny) && (rln->y[j] <= maxy))
                                 IntersectResult = PointOnLineSegment(rln->x[j],rln->y[j],x1,y1,x2,y2, tempsensitivity);
                              if(IntersectResult > 0)
                                 {
                                 ++NoIntCount;
                                 if(rlc->IsMulti >= 1)
                                    {
                                    RB_newKey2 = rlc->idn + (checkinstance * 0.0001);
                                    if(( RB_newNode = RBExactQuery(Check_RB_Tree,&RB_newKey2)))
                                       {
                                       RB_cond = (struct ConditionCollection *) RB_newNode->info;
                                       RB_cond->counter += 1;
                                       }
                                    else
                                       {
                                       RB_cond = (struct ConditionCollection *) (malloc(SzCC));
                                       if(RB_cond == NULL)
                                          {
                                          printf("memory has been exhausted during RB-Tree information alloction for LLNOINT analysis\n");
                                          exit(-1);
                                          }
                                       RB_cond->keyval = LLNOINT;
                                       RB_cond->Cnumber =  Make_Correct(LLNOINT,checkinstance);
                                       RB_cond->index_from_to = NULL;
                                       RB_cond->gform = G_LINE;
                                       RB_cond->featureidn = rlc->featureid;
                                       RB_cond->localID = rlc->localID;
                                       RB_cond->counter = 1;
                                       RB_cond->radius = -1;
                                       RB_cond->height = -1;
                                       RB_cond->magnitude = 0.0;
                                       RB_cond->IDN = rlc->idn;
                                       RB_cond->Sindex = rlc->Sindex;
                                       RB_cond->Lindex = rlc->Lindex;

                                       RB_cond->numnodes = 2; /**rlc->numnodes;**/
                                       RB_cond->x = (double *) (malloc(RB_cond->numnodes * SzD));
                                       RB_cond->y = (double *) (malloc(RB_cond->numnodes * SzD));
                                       RB_cond->z = (double *) (malloc(RB_cond->numnodes * SzD));
                                       if(RB_cond->z == NULL)
                                          {
                                          printf("memory has been exhausted during RB-Tree element vertex alloction for LLNOINT analysis\n");
                                          exit(-1);
                                          }
                                       for(jj=0; jj< RB_cond->numnodes; jj++)
                                          {
                                          RB_cond->x[jj] = rlc->x[jj];
                                          RB_cond->y[jj] = rlc->y[jj];
                                          RB_cond->z[jj] = rlc->z[jj];
                                          }

                                       RB_newDbl = (double *) (malloc(SzD));
                                       if(RB_newDbl == NULL)
                                          {
                                          printf("memory has been exhausted during RB-Tree alloction for LLNOINT analysis\n");
                                          exit(-1);
                                          }
                                       *RB_newDbl = RB_newKey2; /**rac->localID; **/
                                       RBTreeInsert(Check_RB_Tree,RB_newDbl, RB_cond);
                                       }
                                    }
                                 }
                              }
                           }
                        }
                     }
                  rln = rln->next;
                  if(rln == NULL)
                     ++checkit2;
                  if((NoIntCount == 0) && (rln == NULL) && (rlc->IsMulti == 0) && (isclose > 0) && (checkit2 == 1))
                     {
                     rln = NLroot;
                     }
                  } /** end while rln != NULL ***/
               if(NoIntCount == 0)
                  {
                  rac = Aroot;
                  checkit2 = 0;
                  while(rac != NULL)
                     {
                     Config3 = SCCtable[rac->Sindex].C;
                     Strat3 = SCCtable[rac->Sindex].S;
                     Domain3 = SCCtable[rac->Sindex].D;
                     isclose = 0;
                     if(CombinedCheckApplies(rac->idn,checkinstance,LLNOINT,rac->Lindex,rac->Sindex,Config3,Strat3,Domain3,&part1,&part2,&part3) > 0)
                        {
                        if(part2 > 0)
                           {
                           for(i=1; i<rlc->numnodes; i++)
                              {
                              ii = i - 1;
                              x1 = rlc->x[ii];
                              y1 = rlc->y[ii];
                              z1 = rlc->z[ii];
                              x2 = rlc->x[i];
                              y2 = rlc->y[i];
                              z2 = rlc->z[i];
                              if(((x2 - minx) <= tempsensitivity) || ((maxx - x2) <= tempsensitivity))
                                 isclose = 1;
                              else if(((y2 - miny) <= tempsensitivity) || ((maxy - y2) <= tempsensitivity))
                                 isclose = 1;
                              if(ClipLineToRegion(minx,miny,maxx,maxy,&x1,&y1,&z1,&x2,&y2,&z2,&clipflag,multiplier) > 0)
                                 {
                                 for(j=0; j<rac->numverts; j++)
                                    {
                                    if(j > 0)
                                       jj = j - 1;
                                    else
                                       jj = rac->numverts - 1;

                                    x3 = rac->x[jj];
                                    y3 = rac->y[jj];
                                    z3 = rac->z[jj];
                                    x4 = rac->x[j];
                                    y4 = rac->y[j];
                                    z4 = rac->z[j];
                                    if(ClipLineToRegion(minx,miny,maxx,maxy,&x3,&y3,&z3,&x4,&y4,&z4,&clipflag,multiplier) > 0)
                                       {
                                       IntersectResult = PointOnLineSegment(rlc->x[0],rlc->y[0],rac->x[jj],rac->y[jj],rac->x[j],rac->y[j], tempsensitivity);
                                       if(IntersectResult < 1)
                                          IntersectResult = PointOnLineSegment(rlc->x[rlc->numnodes-1],rlc->y[rlc->numnodes-1],
                                                           rac->x[jj],rac->y[jj],rac->x[j],rac->y[j], tempsensitivity);
                                       if(IntersectResult < 1)
                                          IntersectResult = LineSegmentsIntersect(x1,y1,x2,y2,x3,y3,x4,y4, &xi, &yi);
                                       if(IntersectResult > 0)
                                          {
                                          ++NoIntCount;
                                          if(rlc->IsMulti >= 1)
                                             {
                                             RB_newKey2 = rlc->idn + (checkinstance * 0.0001);
                                             if(( RB_newNode = RBExactQuery(Check_RB_Tree,&RB_newKey2)))
                                                {
                                                RB_cond = (struct ConditionCollection *) RB_newNode->info;
                                                RB_cond->counter += 1; 
                                                }
                                             else
                                                {
                                                RB_cond = (struct ConditionCollection *) (malloc(SzCC));
                                                if(RB_cond == NULL)
                                                   {
                                                   printf("memory has been exhausted during RB-Tree information alloction for LLNOINT analysis\n");
                                                   exit(-1);
                                                   }
                                                RB_cond->keyval = LLNOINT;
                                                RB_cond->Cnumber =  Make_Correct(LLNOINT,checkinstance);
                                                RB_cond->index_from_to = NULL;
                                                RB_cond->gform = G_LINE;
                                                RB_cond->featureidn = rlc->featureid;
                                                RB_cond->localID = rlc->localID;
                                                RB_cond->counter = 1;
                                                RB_cond->radius = -1;
                                                RB_cond->height = -1;
                                                RB_cond->magnitude = 0.0;
                                                RB_cond->IDN = rlc->idn;
                                                RB_cond->Sindex = rlc->Sindex;
                                                RB_cond->Lindex = rlc->Lindex;

                                                RB_cond->numnodes = 2; /**rlc->numnodes;**/
                                                RB_cond->x = (double *) (malloc(RB_cond->numnodes * SzD));
                                                RB_cond->y = (double *) (malloc(RB_cond->numnodes * SzD));
                                                RB_cond->z = (double *) (malloc(RB_cond->numnodes * SzD));
                                                if(RB_cond->z == NULL)
                                                   {
                                                   printf("memory has been exhausted during RB-Tree element vertex alloction for LLNOINT analysis\n");
                                                   exit(-1);
                                                   }
                                                for(jj=0; jj< RB_cond->numnodes; jj++)
                                                   {
                                                   RB_cond->x[jj] = rlc->x[jj];
                                                   RB_cond->y[jj] = rlc->y[jj];
                                                   RB_cond->z[jj] = rlc->z[jj];
                                                   }

                                                RB_newDbl = (double *) (malloc(SzD));
                                                if(RB_newDbl == NULL)
                                                   {
                                                   printf("memory has been exhausted during RB-Tree alloction for LLNOINT analysis\n");
                                                   exit(-1);
                                                   }
                                                *RB_newDbl = RB_newKey2; /**rac->localID; **/
                                                RBTreeInsert(Check_RB_Tree,RB_newDbl, RB_cond);
                                                } 
                                             }
                                          break; /*** should break from the while rac != NULL loop ****/
                                          }
                                       }
                                    }
                                 }
                              }
                           }
                        }
                     rac = rac->next;
                     if(rac == NULL)
                        ++checkit2;
                     if((NoIntCount == 0) && (rac == NULL) && (rlc->IsMulti == 0) && (isclose > 0) && (checkit2 == 1))
                        {
                        rac = NAroot;
                        }
                     }
                  }
               if(NoIntCount == 0)
                  {
                  checkit = 1;
                  if(ActiveChecks[checkinstance].UseBorderConds == 0)
                     {
                     if((NorthCount <= 0) || (SouthCount <= 0) || (EastCount <= 0) || (WestCount <= 0))
                        {
                        checkit = ConditionOnDataEdge(rlc->x[0],rlc->y[0],rlc->x[0],rlc->y[0],Aroot,Proot,root,
                                 NULL, NULL, rlc,
                                 NorthCount,SouthCount,EastCount,WestCount,checkinstance);
                        if(checkit > 0)
                            {
                            i = rlc->numnodes - 1;
                            checkit = ConditionOnDataEdge(rlc->x[i],rlc->y[i],rlc->x[i],rlc->y[i],Aroot,Proot,root,
                                 NULL, NULL, rlc,
                                 NorthCount,SouthCount,EastCount,WestCount,checkinstance);
                            }
                        }
                     }

                  if((checkit > 0) && (rlc->IsMulti == 0))  /** a single region linear feature ****/
                     {
                     ERc = (struct collection *) (malloc(SzC));
                     if(ERc == NULL)
                        {
                        printf("allocation memory exhausted during linear feature condition analysis\n");
                        printf("processing cannot continue\n");
                        exit(-1);
                        }
                     ERc->x[0] = 0.0;
                     ERc->y[0] = 0.0;
                     ERc->z[0] = 0.0;
                     ERc->magnitude = 0.0;
                     ERc->keyval = LLNOINT;
                     ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                     ERc->IDN = rlc->idn;
                     ERc->Sindex = rlc->Sindex;
                     ERc->ll1 = rlc;
                     ERc->vertexindex1 = 0;
                     ERc->ll2 = NULL;
                     ERc->vertexindex2 = 0;
                     ERc->next = NULL;
                     if(ERroot == NULL)
                        {
                        ERroot = ERc;
                        }
                     else
                        {
                        ERn = ERroot;
                        while(ERn != NULL)
                           {
                           if((ERn->Cnumber == ERc->Cnumber) && (ERn->keyval == ERc->keyval) && (ERn->ll1 == ERc->ll1))
                              break;

                           ERn = ERn->next;
                           }
                        if(ERn == NULL)
                           {
                           ERc->next = ERroot;
                           ERroot = ERc;
                           }
                        else
                          free(ERc);
                        }
                     } /*** end is single region linear ***/
                  else if(rlc->IsMulti >= 1) 
                     {
                     RB_newKey2 = rlc->idn + (checkinstance * 0.0001);
                     if(( RB_newNode = RBExactQuery(Check_RB_Tree,&RB_newKey2)) == 0)
                        {
                        RB_cond = (struct ConditionCollection *) (malloc(SzCC));

                        if(RB_cond == NULL)
                           {
                           printf("memory has been exhausted during RB-Tree information alloction for LLNOINT analysis\n");
                           exit(-1);
                           }
                        RB_cond->keyval = LLNOINT;
                        RB_cond->Cnumber =  Make_Correct(LLNOINT,checkinstance);
                        RB_cond->index_from_to = NULL;
                        RB_cond->gform = G_LINE;
                        RB_cond->featureidn = rlc->featureid;
                        if(checkit < 1)
                           RB_cond->counter = 1;
                        else
                           RB_cond->counter = 0;
                        RB_cond->radius = -1;
                        RB_cond->height = -1;
                        RB_cond->magnitude = 0.0;
                        RB_cond->IDN = rlc->idn;
                        RB_cond->localID = rlc->localID;
                        RB_cond->Sindex = rlc->Sindex;
                        RB_cond->Lindex = rlc->Lindex;
                        
                        RB_cond->numnodes = 2; /**rlc->numnodes;***/
                        RB_cond->x = (double *) (malloc(RB_cond->numnodes * SzD));
                        RB_cond->y = (double *) (malloc(RB_cond->numnodes * SzD));
                        RB_cond->z = (double *) (malloc(RB_cond->numnodes * SzD));
                        if(RB_cond->z == NULL)
                           {
                           printf("memory has been exhausted during RB-Tree element vertex alloction for LLNOINT analysis\n");
                           exit(-1);
                           }
                        for(jj=0; jj< RB_cond->numnodes; jj++)
                           {
                           RB_cond->x[jj] = rlc->x[jj];
                           RB_cond->y[jj] = rlc->y[jj];
                           RB_cond->z[jj] = rlc->z[jj];
                           }

                        RB_newDbl = (double *) (malloc(SzD));
                        if(RB_newDbl == NULL)
                           {
                           printf("memory has been exhausted during RB-Tree alloction for LLNOINT analysis\n");
                           exit(-1);
                           }
                        *RB_newDbl = RB_newKey2; /**rac->localID; **/
                        RBTreeInsert(Check_RB_Tree,RB_newDbl, RB_cond);
                        }
                     else if(checkit < 1) /*** so need to remove a condition on the boundary ***/
                        {
                        RB_cond = (struct ConditionCollection *) RB_newNode->info;
                        if(RB_cond != NULL)
                           {
                           RB_cond->counter += 1;
                           }
                        }

                     }
                  }

               }
            }


         if(CombinedCheckApplies(rlc->idn,checkinstance,FEATNOTCUT,rlc->Lindex,rlc->Sindex,Config1,Strat1,Domain1,&part1,&part2,&part3) > 0)
            {
            if(part2 > 0)
               {
               i = 0;
               while(i < rlc->numnodes)
                  {
                  found_one = 0; 
                  if((rlc->x[i] >= minx) && (rlc->x[i] <= maxx) && (rlc->y[i] >= miny) && (rlc->y[i] <= maxy))
                     {
                     found_one = 1;
                     if(i == 0)
                       ii = 1;
                     else
                       ii = i - 1;
                     rln = root;
                     while(rln != NULL)
                        {
                        if(rln != rlc)
                           {
                           Config2 = SCCtable[rln->Sindex].C;
                           Strat2 = SCCtable[rln->Sindex].S;
                           Domain2 = SCCtable[rln->Sindex].D;
                           if(CombinedCheckApplies(rln->idn,checkinstance,FEATNOTCUT,rln->Lindex,rln->Sindex,
                                                    Config2,Strat2,Domain2,&part1,&part2,&part3) > 0)
                              {
                              if(part2 > 0)
                                 {
                                 j = 0;
                                 while(j < rln->numnodes)
                                    {
                                    if((rln->x[j] >= minx) && (rln->x[j] <= maxx) && (rln->y[j] >= miny) && (rln->y[j] <= maxy))
                                       {
ptpdist1 = Distance(rlc->x[i],rlc->y[i],rln->x[j],rln->y[j]);
                                       if(SensitivityCheck(LTEQ,FEATNOTCUT,checkinstance,ptpdist1) > 0)
                                          {
                                          found_one = 2;
                                          break;
                                          }
                                       }
                                    j++;  /** note that connection to any rln vertex will suffice (not just an end node) **/ 
                                    }
                                 }
                              }
                           }
                        if(found_one > 1)
                           break;
                        rln = rln->next;
                        } /*** end while rln ***/
                     } /*** end is in this load module ***/
                  if(found_one == 1)
                     {
                     rln = root;
                     while(rln != NULL)
                        {
                        found_one = 1;
                        if(rln != rlc)
                           {
                           Config2 = SCCtable[rln->Sindex].C;
                           Strat2 = SCCtable[rln->Sindex].S;
                           Domain2 = SCCtable[rln->Sindex].D;
                           if(CombinedCheckApplies(rln->idn,checkinstance,FEATNOTCUT,rln->Lindex,rln->Sindex,
                                                    Config2,Strat2,Domain2,&part1,&part2,&part3) > 0)
                              {
                              if(part1 > 0) /*** now see if a part1 type line is here too ***/
                                 {
                                 j = 0;
                                 while(j < rln->numnodes)
                                    {
                                    if((rln->x[j] >= minx) && (rln->x[j] <= maxx) && (rln->y[j] >= miny) && (rln->y[j] <= maxy))
                                       {
ptpdist1 = Distance(rlc->x[i],rlc->y[i],rln->x[j],rln->y[j]);
                                       if(SensitivityCheck(LTEQ,FEATNOTCUT,checkinstance,ptpdist1) > 0)
                                          {
                                          found_one = 2;
                                          break;
                                          }
                                       }
                                    j += (rln->numnodes - 1);
                                    }
                                 if(found_one == 1)
                                    {
                                    for(j=1; j < rln->numnodes; j++)
                                       {
                                       ptldist = PointToLineDist2D(rlc->x[i],rlc->y[i],
                                                                 rln->x[j],rln->y[j],rln->x[j-1],rln->y[j-1]);
if(ptldist < ActiveChecks[checkinstance].sensitivity)
                                             {
                                             if(i == 0)
                                                {
                                                if(LineSegmentsOverlap(rlc->x[1],rlc->y[1],rlc->x[0],rlc->y[0],
                                                 rln->x[j],rln->y[j],rln->x[j-1],rln->y[j-1],
&xi, &yi, &xi2, &yi2, ActiveChecks[checkinstance].sensitivity) > 0)
                                                 //&xi, &yi, &xi2, &yi2, 0.01) > 0)
                                                    {
                                                    found_one = 3;
                                                    break;
                                                    }
                                                }
                                             else
                                                {
                                                if(LineSegmentsOverlap(rlc->x[i-1],rlc->y[i-1],rlc->x[i],rlc->y[i],
                                                 rln->x[j],rln->y[j],rln->x[j-1],rln->y[j-1],
&xi, &yi, &xi2, &yi2, ActiveChecks[checkinstance].sensitivity) > 0)
                                                    {
segdist = 10;
if(segdist > 0.1)
                                                       {
if(segdist > 0.1)
                                                          {
                                                          found_one = 3;

                                                          break;
                                                          }
                                                       }
                                                    }
                                                }
                                             }

                                       }
                                    } /*** end if found_one == 1 ***/
                                 }
                              }
                           }
                        if(found_one > 2)
                           break;
                        rln = rln->next;
                        } /*** end while rln ***/
                     if(found_one == 3)
                        {
                        if(EqualWithinTolerance(rlc->x[i],rlc->y[i],rln->x[0],rln->y[0],ActiveChecks[checkinstance].sensitivity) > 0)
                           found_one = 0;
                        else if(EqualWithinTolerance(rlc->x[i],rlc->y[i],
                                  rln->x[rln->numnodes-1],rln->y[rln->numnodes-1],ActiveChecks[checkinstance].sensitivity) > 0)
                           found_one = 0;
                        }
                     if(found_one == 3)
                        {
                        ERc = (struct collection *) (malloc(SzC));
                        if(ERc == NULL)
                           {
                           printf("allocation memory exhausted during linear feature condition analysis\n");
                           printf("processing cannot continue\n");
                           exit(-1);
                           }
                        ERc->x[0] = rlc->x[i];
                        ERc->y[0] = rlc->y[i];
                        ERc->z[0] = rlc->z[i];

                        ERc->x[1] = rln->x[j];
                        ERc->y[1] = rln->y[j];
                        ERc->z[1] = rln->z[j];
   
                        ERc->x[2] = rln->x[j-1];
                        ERc->y[2] = rln->y[j-1];
                        ERc->z[2] = rln->z[j-1];
   
                        ERc->keyval = FEATNOTCUT;
                        ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                        ERc->ll1 = rln;
                        ERc->ll2 = rlc;
                        ERc->Sindex = rln->Sindex;
                        ERc->next = NULL;
                        if(ERroot == NULL)
                           {
                           ERroot = ERc;
                           }
                        else
                           {
                           ERn = ERroot;
                           while(ERn != NULL)
                              {
                              if((ERn->Cnumber == ERc->Cnumber) && (ERn->keyval == ERc->keyval) && (ERn->ll1 == ERc->ll1) &&
                                 (ERn->x[0] == ERc->x[0]) && (ERn->y[0] == ERc->y[0]) && (ERn->Sindex == ERc->Sindex) &&
                                 (ERn->z[0] == ERc->z[0]))
                                 break;
                              ERn = ERn->next;
                              }
                           if(ERn == NULL)
                              {
                              ERc->next = ERroot;
                              ERroot = ERc;
                              }
                           else
                              {
                              free(ERc);
                              }
                           }
                        }
                     }
                  i += (rlc->numnodes - 1);
                  } /*** end while i < rlc->numnodews ***/
               }
            }




         if(CombinedCheckApplies(rlc->idn,checkinstance,FEATBRIDGE,rlc->Lindex,rlc->Sindex,Config1,Strat1,Domain1,&part1,&part2,&part3) > 0)
            {
            if(part1 > 0)
               {
               keepit = 1;
               i = 1;
               basedist = 0;
               while(i < rlc->numnodes)
                  {
                  basedist = basedist + Distance(rlc->x[i],rlc->y[i],rlc->x[i-1],rlc->y[i-1]);
                  ++i;
                  }
               if(SensitivityCheck(LTEQ, FEATBRIDGE, checkinstance, basedist) > 0)
                  {
                  jj2 = kk2 = part1a = part1b = part1c = part1d = 0; /*** use these ints to store # of connects each end of rlc, by type  **/
                  nodeindex = 0;
                  while(nodeindex < rlc->numnodes)
                     {
                     if((rlc->x[nodeindex] >= minx) && (rlc->x[nodeindex] <= maxx) && (rlc->y[nodeindex] >= miny) && (rlc->y[nodeindex] <= maxy))
                        {
                        rln = root;
                        while(rln != NULL)
                           {
                           if(rln != rlc)
                              {
                              i = 0;
                              while(i < rln->numnodes)
                                 {
                                 if((rln->x[i] >= minx) && (rln->x[i] <= maxx) && (rln->y[i] >= miny) && (rln->y[i] <= maxy))
                                    {
                                    ptpdist1 = Distance(rlc->x[nodeindex],rlc->y[nodeindex],rln->x[i],rln->y[i]);
                                    if(ptpdist1 < 0.01) /*** consider this a connection ***/
                                       {
                                       if(nodeindex == 0)
                                          {
                                          Config2 = SCCtable[rln->Sindex].C;
                                          Strat2 = SCCtable[rln->Sindex].S;
                                          Domain2 = SCCtable[rln->Sindex].D;
                                          part1 = part2 = part3 = 0;
                                          ii3 = CombinedCheckApplies(rln->idn,checkinstance,FEATBRIDGE,rln->Lindex,rln->Sindex,Config2,Strat2,Domain2,&part1,&part2,&part3);
                                          if((ii3 > 0) && ((part2 > 0) || (part3 > 0)))
                                             {
                                             for(nindex=0; nindex < rln->numnodes; nindex++)
                                                {
                                                ptpdist2 = Distance(rlc->x[rlc->numnodes-1],rlc->y[rlc->numnodes-1],rln->x[nindex],rln->y[nindex]);
                                                if(ptpdist2 < 0.01) /*** consider this a connection to other end, so rlc is not the only bridge ***/
                                                   {
                                                   keepit = 0;
                                                   ii3 = 0;
                                                   break;
                                                   }
                                                else if((nindex > 0) && (LineSegmentsOverlap(rlc->x[rlc->numnodes-1],rlc->y[rlc->numnodes-1],
                                                                             rlc->x[rlc->numnodes-2],rlc->y[rlc->numnodes-2],
                                                                           rln->x[nindex],rln->y[nindex],rln->x[nindex-1],rln->y[nindex-1],
                                                                           &xi1, &yi1, &xi2, &yi2, 0.01) > 0))
                                                   {
                                                   keepit = 0;
                                                   ii3 = 0;
                                                   break;
                                                   }
                                                else if((nindex == 0) && (LineSegmentsOverlap(rlc->x[1],rlc->y[1],rlc->x[0],rlc->y[0],
                                                                           rln->x[nindex],rln->y[nindex],rln->x[nindex+1],rln->y[nindex+1],
                                                                           &xi1, &yi1, &xi2, &yi2, 0.01) > 0))
                                                   {
                                                   keepit = 0;
                                                   ii3 = 0;
                                                   break;
                                                   }

                                                }
                                             }
                                          if(ii3 > 0)
                                             {
                                             if(part2 > 0)
                                                part1a += 1;
                                             if(part3 > 0)
                                                part1b += 1;
if(part1 > 0)
jj2 += 1;
                                             }
                                          }
                                       else
                                          {
                                          Config2 = SCCtable[rln->Sindex].C;
                                          Strat2 = SCCtable[rln->Sindex].S;
                                          Domain2 = SCCtable[rln->Sindex].D;
                                          part1 = part2 = part3 = 0;
                                          ii3 = CombinedCheckApplies(rln->idn,checkinstance,FEATBRIDGE,rln->Lindex,rln->Sindex,Config2,Strat2,Domain2,&part1,&part2,&part3);
                                          if((ii3 > 0) && ((part2 > 0) || (part3 > 0)))
                                             {
                                             for(nindex=0; nindex < rln->numnodes; nindex++)
                                                {
                                                ptpdist2 = Distance(rlc->x[0],rlc->y[0],rln->x[nindex],rln->y[nindex]);
                                                if(ptpdist2 < 0.01) /*** consider this a connection to other end, so rlc is not the only bridge ***/
                                                   {
                                                   keepit = 0;
                                                   ii3 = 0;
                                                   break;
                                                   }
                                                else if((nindex > 0) && (LineSegmentsOverlap(rlc->x[1],rlc->y[1],rlc->x[0],rlc->y[0],
                                                                           rln->x[nindex],rln->y[nindex],rln->x[nindex-1],rln->y[nindex-1],
                                                                           &xi1, &yi1, &xi2, &yi2, 0.01) > 0))
                                                   {
                                                   keepit = 0;
                                                   ii3 = 0;
                                                   break;
                                                   }
                                                else if((nindex == 0) && (LineSegmentsOverlap(rlc->x[1],rlc->y[1],rlc->x[0],rlc->y[0],
                                                                           rln->x[nindex],rln->y[nindex],rln->x[nindex+1],rln->y[nindex+1],
                                                                           &xi1, &yi1, &xi2, &yi2, 0.01) > 0))
                                                   {
                                                   keepit = 0;
                                                   ii3 = 0;
                                                   break;
                                                   }
                                                }
                                             }
                                          if(ii3 > 0)
                                             {
                                             if(part2 > 0)
                                                part1c += 1;
                                             if(part3 > 0)
                                                part1d += 1;
if(part1 > 0)
kk2 += 1;
                                             }
                                          }
                                       }
                                    }
                                 if(keepit < 1)
                                    break;
                                 i += rln->numnodes - 1;
                                 }
                              }
                           if(keepit < 1)
                              break;
                           rln = rln->next;
                           } /*** end while rln ***/
                        } /*** end if end node is in region ***/
                     else if(keepit > 0)
                        {
                        rln = NLroot;
                        while(rln != NULL)
                           {
                           if(rln != rlc)
                              {
                              i = 0;
                              while(i < rln->numnodes)
                                 {
                                 ptpdist1 = Distance(rlc->x[nodeindex],rlc->y[nodeindex],rln->x[i],rln->y[i]);
                                 if(ptpdist1 < 0.01) /*** consider this a connection ***/
                                    {
                                    if(nodeindex == 0)
                                       {
                                       Config2 = SCCtable[rln->Sindex].C;
                                       Strat2 = SCCtable[rln->Sindex].S;
                                       Domain2 = SCCtable[rln->Sindex].D;
                                       part1 = part2 = part3 = 0;
                                       ii3 = CombinedCheckApplies(rln->idn,checkinstance,FEATBRIDGE,rln->Lindex,rln->Sindex,Config2,Strat2,Domain2,&part1,&part2,&part3);
                                       if((ii3 > 0) && ((part2 > 0) || (part3 > 0)))
                                          {
                                          for(nindex=0; nindex < rln->numnodes; nindex++)
                                             {
                                             ptpdist2 = Distance(rlc->x[rlc->numnodes-1],rlc->y[rlc->numnodes-1],rln->x[nindex],rln->y[nindex]);
                                             if(ptpdist2 < 0.01) /*** consider this a connection to the other end, so rlc is not the only bridge ***/
                                                {
                                                keepit = 0;
                                                ii3 = 0;
                                                break;
                                                }
                                             else if((nindex > 0) && (LineSegmentsOverlap(rlc->x[rlc->numnodes-1],rlc->y[rlc->numnodes-1],
                                                                          rlc->x[rlc->numnodes-2],rlc->y[rlc->numnodes-2],
                                                                        rln->x[nindex],rln->y[nindex],rln->x[nindex-1],rln->y[nindex-1],
                                                                        &xi1, &yi1, &xi2, &yi2, 0.0) > 0))
                                                {
                                                keepit = 0;
                                                ii3 = 0;
                                                break;
                                                }
                                             else if((nindex == 0) && (LineSegmentsOverlap(rlc->x[rlc->numnodes-1],rlc->y[rlc->numnodes-1],
                                                                          rlc->x[rlc->numnodes-2],rlc->y[rlc->numnodes-2],
                                                                        rln->x[nindex],rln->y[nindex],rln->x[nindex+1],rln->y[nindex+1],
                                                                        &xi1, &yi1, &xi2, &yi2, 0.0) > 0))
                                                {
                                                keepit = 0;
                                                ii3 = 0;
                                                break;
                                                }
                                             }
                                          }
                                       if(ii3 > 0)
                                          {
                                          if(part2 > 0)
                                             part1a += 1;
                                          if(part3 > 0)
                                             part1b += 1;
if(part1 > 0)
jj2 += 1;
                                          /**if((part2 == 0) && (part3 == 0))
                                             jj2 += 1;**/
                                          }
                                       }
                                    else
                                       {
                                       Config2 = SCCtable[rln->Sindex].C;
                                       Strat2 = SCCtable[rln->Sindex].S;
                                       Domain2 = SCCtable[rln->Sindex].D;
                                       part1 = part2 = part3 = 0;
                                       ii3 = CombinedCheckApplies(rln->idn,checkinstance,FEATBRIDGE,rln->Lindex,rln->Sindex,Config2,Strat2,Domain2,&part1,&part2,&part3);
                                       if((ii3 > 0) && ((part2 > 0) || (part3 > 0)))
                                          {
                                          for(nindex=0; nindex < rln->numnodes; nindex++)
                                             {
                                             ptpdist2 = Distance(rlc->x[0],rlc->y[0],rln->x[nindex],rln->y[nindex]);
                                             if(ptpdist2 < 0.01) /*** consider this a connection to other end, so rlc is not the only bridge ***/
                                                {
                                                keepit = 0;
                                                ii3 = 0;
                                                break;
                                                }
                                             else if((nindex > 0) && (LineSegmentsOverlap(rlc->x[1],rlc->y[1],rlc->x[0],rlc->y[0],
                                                                        rln->x[nindex],rln->y[nindex],rln->x[nindex-1],rln->y[nindex-1],
                                                                        &xi1, &yi1, &xi2, &yi2, 0.01) > 0))
                                                {
                                                keepit = 0;
                                                ii3 = 0;
                                                break;
                                                }
                                             else if((nindex == 0) && (LineSegmentsOverlap(rlc->x[1],rlc->y[1],rlc->x[0],rlc->y[0],
                                                                        rln->x[nindex],rln->y[nindex],rln->x[nindex+1],rln->y[nindex+1],
                                                                        &xi1, &yi1, &xi2, &yi2, 0.01) > 0))
                                                {
                                                keepit = 0;
                                                ii3 = 0;
                                                break;
                                                }
                                             }
                                          }
                                       if(ii3 > 0)
                                          {
                                          if(part2 > 0)
                                             part1c += 1;
                                          if(part3 > 0)
                                             part1d += 1;
if(part1 > 0)
kk2 += 1;
                                          /**if((part2 == 0) && (part3 == 0))
                                             kk2 += 1;**/
                                          }
                                       }
                                    }
                                 if(keepit < 1)
                                    break;
                                 i += rln->numnodes - 1;
                                 }
                              }
                           if(keepit < 1)
                              break;
                           rln = rln->next;
                           } /*** end while rln ***/
                        } /*** end if end node is in neighbor region ***/
                     if(keepit < 1)
                        break;
                     nodeindex += (rlc->numnodes - 1);
                     }
if((keepit > 0) && (((part1a >= 1) && (part1d >= 1)) || ((part1b >= 1) && (part1c >= 1))) )
                     {
                     ERc = (struct collection *) (malloc(SzC));
                     if(ERc == NULL)
                        {
                        printf("allocation memory exhausted during linear feature condition analysis\n");
                        printf("processing cannot continue\n");
                        exit(-1);
                        }
                     ERc->x[0] = rlc->x[rlc->numnodes - 1];
                     ERc->y[0] = rlc->y[rlc->numnodes - 1];
                     ERc->z[0] = rlc->z[rlc->numnodes - 1];
   
                     ERc->x[1] = rlc->x[0];
                     ERc->y[1] = rlc->y[0];
                     ERc->z[1] = rlc->z[0];
   
                     ERc->x[2] = rlc->x[1];
                     ERc->y[2] = rlc->y[1];
                     ERc->z[2] = rlc->z[1];


                     ERc->magnitude = basedist;
                     ERc->keyval = FEATBRIDGE;
                     ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                     ERc->ll1 = rlc;
                     ERc->ll2 = rlc;
                     ERc->Sindex = rlc->Sindex;
                     ERc->next = NULL;
                     if(ERroot == NULL)
                        {
                        ERroot = ERc;
                        }
                     else
                        {
                        ERn = ERroot;
                        while(ERn != NULL)
                           {
                           if(
                              (ERn->Cnumber    == ERc->Cnumber)    &&
                              (ERn->keyval    == ERc->keyval)    &&
                              (ERn->ll1       == ERc->ll1)       &&
                              (ERn->x[0]      == ERc->x[0])      &&
                              (ERn->magnitude == ERc->magnitude) &&
                              (ERn->y[0]      == ERc->y[0])      &&
                              (ERn->Sindex    == ERc->Sindex)    &&
                              (ERn->z[0]      == ERc->z[0])
                              )
                              break;
                           ERn = ERn->next;
                           }
                        if(ERn == NULL)
                           {
                           ERc->next = ERroot;
                           ERroot = ERc;
                           }
                        else
                           free(ERc);
                        }
                     }
                  } /*** end if end node is in region ***/
               } /** end part1 ok **/
            } /** end FEATBRIDGE check ***/



         if(CombinedCheckApplies(rlc->idn,checkinstance,ENCONNECT,rlc->Lindex,rlc->Sindex,Config1,Strat1,Domain1,&part1,&part2,&part3) > 0)
            {
            if(part1 > 0)
               {
               nodeindex = 0;
               while(nodeindex < rlc->numnodes)
                  {
                  if((rlc->x[nodeindex] >= minx) && (rlc->x[nodeindex] <= maxx) && (rlc->y[nodeindex] >= miny) && (rlc->y[nodeindex] <= maxy))
                     {
                     numlikeconnections = numconnections = 0.0;

                     rln = root;
                     while(rln != NULL)
                        {
                        if(rln != rlc)
                           {
                           Config2 = SCCtable[rln->Sindex].C;
                           Strat2 = SCCtable[rln->Sindex].S;
                           Domain2 = SCCtable[rln->Sindex].D;
                           if(CombinedCheckApplies(rln->idn,checkinstance,ENCONNECT,rln->Lindex,rln->Sindex,Config2,Strat2,Domain2,&part1,&part2,&part3) > 0)
                              {
                              if(part2 > 0)
                                 {
                                 nindex = 0;
                                 while(nindex < rln->numnodes)
                                    {
                                    keepit = 0;
                                    if((IsSentinelZvalue(rlc->z[nodeindex],UseNUNANPO) > 0) || (IsSentinelZvalue(rln->z[nindex],UseNUNANPO) > 0))
                                       {
                                       if((rlc->x[nodeindex] == rln->x[nindex]) && (rlc->y[nodeindex] == rln->y[nindex]))
                                          keepit = 1;
                                       }
                                    else if((rlc->x[nodeindex] == rln->x[nindex]) && (rlc->y[nodeindex] == rln->y[nindex]) &&
                                           (rlc->z[nodeindex] == rln->z[nindex]))
                                       {
                                       keepit = 1;
                                       }
                                    if(keepit > 0)
                                       {
                                       numconnections += 1.0;
if((rln->Lindex == rlc->Lindex) && (rln->areaattr == rlc->areaattr) &&
  (rln->hgtattr == rlc->hgtattr) && (rln->zv2attr == rlc->zv2attr))
numlikeconnections += 1.0;
                                       }
                                    nindex += (rln->numnodes - 1);
                                    }
                                 }
                              }
                           }
                        rln = rln->next;
                        } /*** end while rln ***/
                     if(SensitivityCheck(CLOSEDINT, ENCONNECT, checkinstance, numconnections) > 0)
                        {
                        ERc = (struct collection *) (malloc(SzC));
                        if(ERc == NULL)
                           {
                           printf("allocation memory exhausted during linear feature condition analysis\n");
                           printf("processing cannot continue\n");
                           exit(-1);
                           }
                        ERc->x[0] = rlc->x[nodeindex];
                        ERc->y[0] = rlc->y[nodeindex];
                        ERc->z[0] = rlc->z[nodeindex];

                        ERc->x[1] = rlc->x[nodeindex];
                        ERc->y[1] = rlc->y[nodeindex];
                        ERc->z[1] = rlc->z[nodeindex];

                        if(nodeindex == 0)
                           {
                           ERc->x[2] = rlc->x[1];
                           ERc->y[2] = rlc->y[1];
                           ERc->z[2] = rlc->z[1];
                           }
                        else
                           {
                           ERc->x[2] = rlc->x[nodeindex-1];
                           ERc->y[2] = rlc->y[nodeindex-1];
                           ERc->z[2] = rlc->z[nodeindex-1];
                           }


                        ERc->magnitude = numconnections;
                        ERc->keyval = ENCONNECT;
                        ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                        ERc->ll1 = rlc;
                        ERc->ll2 = rlc;
                        ERc->Sindex = rlc->Sindex;
                        ERc->next = NULL;
                        if(ERroot == NULL)
                           {
                           ERroot = ERc;
                           }
                        else 
                           {
                           ERn = ERroot;
                           while(ERn != NULL)
                              {
                              if(
                                 (ERn->Cnumber    == ERc->Cnumber)    &&
                                 (ERn->keyval    == ERc->keyval)    &&
                                 (ERn->ll1       == ERc->ll1)       &&
                                 (ERn->x[0]      == ERc->x[0])      &&
                                 (ERn->magnitude == ERc->magnitude) &&
                                 (ERn->y[0]      == ERc->y[0])      &&
                                 (ERn->Sindex    == ERc->Sindex)    &&
                                 (ERn->z[0]      == ERc->z[0])
                                 )
                                 break;
                              ERn = ERn->next;
                              }
                           if(ERn == NULL) 
                              {
                              ERc->next = ERroot;
                              ERroot = ERc;
                              }
                           else
                              free(ERc);
                           }
                        }
                     } /*** end if end node is in region ***/
                  nodeindex += (rlc->numnodes - 1);
                  }
               } /** end part1 ok **/
            } /** end ENCONNECT check ***/



         if(CombinedCheckApplies(rlc->idn,checkinstance,BADENCON,rlc->Lindex,rlc->Sindex,Config1,Strat1,Domain1,&part1,&part2,&part3) > 0)
            {
            if(part1 > 0)
               {
               numlikeconnections = numconnections = 0.0;
               nodeindex = 0;
               while(nodeindex < rlc->numnodes)
                  {
                  if((rlc->x[nodeindex] >= minx) && (rlc->x[nodeindex] <= maxx) && (rlc->y[nodeindex] >= miny) && (rlc->y[nodeindex] <= maxy))
                     {

                     rln = root;
                     while(rln != NULL)
                        {
                        if(rln != rlc)
                           {
                           Config2 = SCCtable[rln->Sindex].C;
                           Strat2 = SCCtable[rln->Sindex].S;
                           Domain2 = SCCtable[rln->Sindex].D;
                           if(CombinedCheckApplies(rln->idn,checkinstance,BADENCON,rln->Lindex,rln->Sindex,Config2,Strat2,Domain2,&part1,&part2,&part3) > 0)
                              {
                              if(part2 > 0)
                                 {
                                 nindex = 0;
                                 while(nindex < rln->numnodes)
                                    {
                                    ptpdist1 = Distance3D(rlc->x[nodeindex],rlc->y[nodeindex],rlc->z[nodeindex],
                                                 rln->x[nindex],rln->y[nindex],rln->z[nindex]);
                                    if(ptpdist1 <= ActiveChecks[checkinstance].sensitivity)
                                       {
                                       ++numconnections;
                                       if((nodeindex == 0) && (nindex == 0))
                                          ++numlikeconnections;
                                       else if((nodeindex > 0) && (nindex > 0))
                                          ++numlikeconnections;
                                       }
                                    nindex += rln->numnodes - 1;
                                    }
                                 }
                              }
                           }
                        rln = rln->next;
                        } /*** end while rln ***/
                     if((numconnections == 1) && (numlikeconnections == 1))
                        {
                        ERc = (struct collection *) (malloc(SzC));
                        if(ERc == NULL)
                           {
                           printf("allocation memory exhausted during linear feature condition analysis\n");
                           printf("processing cannot continue\n");
                           exit(-1);
                           }
                        ERc->x[0] = rlc->x[nodeindex];
                        ERc->y[0] = rlc->y[nodeindex];
                        ERc->z[0] = rlc->z[nodeindex];

                        ERc->x[1] = rlc->x[nodeindex];
                        ERc->y[1] = rlc->y[nodeindex];
                        ERc->z[1] = rlc->z[nodeindex];

                        if(nodeindex == 0)
                           {
                           ERc->x[2] = rlc->x[1];
                           ERc->y[2] = rlc->y[1];
                           ERc->z[2] = rlc->z[1];
                           }
                        else
                           {
                           ERc->x[2] = rlc->x[nodeindex-1];
                           ERc->y[2] = rlc->y[nodeindex-1];
                           ERc->z[2] = rlc->z[nodeindex-1];
                           }


                        ERc->magnitude = ptpdist1;
                        ERc->keyval = BADENCON;
                        ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                        ERc->ll1 = rlc;
                        ERc->ll2 = rlc;
                        ERc->Sindex = rlc->Sindex;
                        ERc->next = NULL;
                        if(ERroot == NULL)
                           {
                           ERroot = ERc;
                           }
                        else
                           {
                           ERn = ERroot;
                           while(ERn != NULL)
                              {
                              if(
                                 (ERn->Cnumber    == ERc->Cnumber)    &&
                                 (ERn->keyval    == ERc->keyval)    &&
                                 (ERn->ll1       == ERc->ll1)       &&
                                 (ERn->x[0]      == ERc->x[0])      &&
                                 (ERn->magnitude == ERc->magnitude) &&
                                 (ERn->y[0]      == ERc->y[0])      &&
                                 (ERn->Sindex    == ERc->Sindex)    &&
                                 (ERn->z[0]      == ERc->z[0])
                                 )
                                 break;
                              ERn = ERn->next;
                              }
                           if(ERn == NULL)
                              {
                              ERc->next = ERroot;
                              ERroot = ERc;
                              }
                           else
                              free(ERc);
                           }
                        }
                     } /*** end if end node is in region ***/
                  nodeindex += (rlc->numnodes - 1);
                  }
               } /** end part1 ok **/
            } /** end BADENCON check ***/




         if(CombinedCheckApplies(rlc->idn,checkinstance,FAILMERGEL,rlc->Lindex,rlc->Sindex,Config1,Strat1,Domain1,&part1,&part2,&part3) > 0)
            {
            if(part1 > 0)
               {
               CVrlc = NULL;
               CVrlc = GetAttrCodesAndValues(rlc->Lindex, rlc->idn, attrfileptr,SzCV,SzCVl,1);

               nodeindex = 0;
               while(nodeindex < rlc->numnodes)
                  {
                  if((rlc->x[nodeindex] >= minx) && (rlc->x[nodeindex] <= maxx) && (rlc->y[nodeindex] >= miny) && (rlc->y[nodeindex] <= maxy))
                     {
                     if((tempis2D(rlc->z[nodeindex])) && (tempis2D(rlc->z[rlc->numnodes - 1])))
                        {
                        ptpdist1 = Distance(rlc->x[0],rlc->y[0],
                                            rlc->x[rlc->numnodes - 1],rlc->y[rlc->numnodes - 1]);
                        }
                     else
                        {
                        ptpdist1 = Distance3D(rlc->x[0],rlc->y[0],rlc->z[0],
                                              rlc->x[rlc->numnodes - 1],rlc->y[rlc->numnodes - 1],rlc->z[rlc->numnodes - 1]);
                        }
                     if(ptpdist1 <= ActiveChecks[checkinstance].sensitivity)
                        {
                        numlikeconnections = 2.0;
                        numconnections = 0.0;
                        }
                     else
                        {
                        numlikeconnections = 1.0;
                        numconnections = 0.0;
                        }
                     rln = root;
                     rlnsave = NULL;
                     while(rln != NULL)
                        {
                        if(rln != rlc)
                           {
                           Config2 = SCCtable[rln->Sindex].C;
                           Strat2 = SCCtable[rln->Sindex].S;
                           Domain2 = SCCtable[rln->Sindex].D;
                           if((rln->Lindex == rlc->Lindex) &&
                                (CombinedCheckApplies(rln->idn,checkinstance,FAILMERGEL,rln->Lindex,rln->Sindex,
                                     Config2,Strat2,Domain2,&part1,&part2,&part3) > 0) &&
                                         (part1 > 0))
                              {
                              nindex = 0;
                              while(nindex < rln->numnodes)
                                 {
                                 if((tempis2D(rlc->z[nodeindex])) && (tempis2D(rln->z[nindex])))
                                    ptpdist1 = Distance(rlc->x[nodeindex],rlc->y[nodeindex],rln->x[nindex],rln->y[nindex]);
                                 else
                                    ptpdist1 = Distance3D(rlc->x[nodeindex],rlc->y[nodeindex],rlc->z[nodeindex],
                                                         rln->x[nindex],rln->y[nindex],rln->z[nindex]);
                                 if(ptpdist1 <= ActiveChecks[checkinstance].sensitivity)
                                    {
                                    found_one = 0;
                                    if(CVrlc != NULL)
                                       {
                                       CVrln = GetAttrCodesAndValues(rln->Lindex, rln->idn, attrfileptr,SzCV,SzCVl,1);
                                       if(CVrln != NULL)
                                          {
                                          found_one = SameAttrAndVals(CVrlc,CVrln,1);
                                          for(ii3=0; ii3<CVrln->numttl; ii3++)
                                             {
                                             if(CVrln->cv[ii3].strval != NULL)
                                                free(CVrln->cv[ii3].strval);
                                             }
                                          free(CVrln->cv);
                                          free(CVrln);
                                          CVrln = NULL;
                                          }
                                       }
                                    if(found_one > 0)
                                       {
                                       rlnsave = rln;
                                       keepit = nindex;
                                       numlikeconnections += 1.0;
                                       }
                                    }
                                 nindex += (rln->numnodes - 1);
                                 }
                              }
                           }
                        if(numlikeconnections > ActiveChecks[checkinstance].sensitivity2)
                           break;
                        rln = rln->next;
                        } /*** end while rln ***/




                     if((numlikeconnections <= ActiveChecks[checkinstance].sensitivity2) &&
                           (numconnections == 0) && (rlnsave != NULL))
                        {
                        rln = root;
                        while(rln != NULL)
                           {
                           if((rln != rlc) && (rln != rlnsave))
                              {
                              Config2 = SCCtable[rln->Sindex].C;
                              Strat2 = SCCtable[rln->Sindex].S;
                              Domain2 = SCCtable[rln->Sindex].D;
                              if((CombinedCheckApplies(rln->idn,checkinstance,FAILMERGEL,rln->Lindex,rln->Sindex,
                                     Config2,Strat2,Domain2,&part1,&part2,&part3) > 0) &&
                                         (part2 > 0))
                                 {
                                 nindex = 1;
                                 while(nindex < rln->numnodes)
                                    {
                                    if((tempis2D(rlc->z[nodeindex])) && (tempis2D(rln->z[nindex])))
                                       ptpdist1 = PointToLineDist2D(rlc->x[nodeindex],rlc->y[nodeindex],
                                                    rln->x[nindex-1],rln->y[nindex-1] ,rln->x[nindex],rln->y[nindex]);
                                    else
                                       ptpdist1 = PointToLineDist(rlc->x[nodeindex],rlc->y[nodeindex],rlc->z[nodeindex],
                                                    rln->x[nindex-1],rln->y[nindex-1],rln->z[nindex-1] ,rln->x[nindex],rln->y[nindex],rln->z[nindex]);
                                    if(ptpdist1 <= ActiveChecks[checkinstance].sensitivity)
                                       {
numconnections += 1.0;
                                       break;
                                       }

                                    nindex += 1;
                                    }
                                 } /** end if part 2 of check applies ***/
                              } /** end rln != rlc ***/
                           if(numconnections > 0)
                              break;
                           rln = rln->next;
                           }
                        }

                     if((numlikeconnections <= ActiveChecks[checkinstance].sensitivity2) && (numconnections == 0) && (rlnsave != NULL))
                        {
                        rpc = Proot;
                        while(rpc != NULL)
                           {
                           Config2 = SCCtable[rpc->Sindex].C;
                           Strat2 = SCCtable[rpc->Sindex].S;
                           Domain2 = SCCtable[rpc->Sindex].D;
                           if((rpc->numverts == -1) && /** rpc is a pure point ***/
                             (CombinedCheckApplies(rpc->idn,checkinstance,FAILMERGEL,rpc->Lindex,rpc->Sindex,
                                   Config2,Strat2,Domain2,&part1,&part2,&part3) > 0) &&
                                         (part2 > 0))
                              {
                              if((tempis2D(rlc->z[nodeindex])) && (tempis2D(rpc->z[0])))
                                 ptpdist1 = Distance(rlc->x[nodeindex],rlc->y[nodeindex],rpc->x[0],rpc->y[0]);
                              else
                                 ptpdist1 = Distance3D(rlc->x[nodeindex],rlc->y[nodeindex],rlc->z[nodeindex],
                                                      rpc->x[0],rpc->y[0],rpc->z[0]);
                              if(ptpdist1 <= ActiveChecks[checkinstance].sensitivity)
                                 {
                                 numconnections += 1.0;
                                 break;
                                 }
                              }
                           rpc = rpc->next;
                           }
                        }


                     if((numconnections < 1) && (numlikeconnections <= ActiveChecks[checkinstance].sensitivity2) && (rlnsave != NULL))
                        {
                        rac = Aroot;
                        while(rac != NULL)
                           {
                           Config2 = SCCtable[rac->Sindex].C;
                           Strat2 = SCCtable[rac->Sindex].S;
                           Domain2 = SCCtable[rac->Sindex].D;
                           if( (CombinedCheckApplies(rac->idn,checkinstance,FAILMERGEL,rac->Lindex,rac->Sindex,
                                     Config2,Strat2,Domain2,&part1,&part2,&part3) > 0) &&
                                         (part2 > 0))
                              {
                              if(rac->RB_Tree_Edgelist == NULL)
                                 {
                                 ptpdist1 = PointToSmallArealDist2D(rlc->x[nodeindex], rlc->y[nodeindex],rac,&unusedint,&unuseddbl);
                                 }
                              else
                                 {
                                 ptpdist1 = PointToLargeArealDist2D(rlc->x[nodeindex], rlc->y[nodeindex],rac,&unusedint,&unuseddbl);
                                 }
                              if((ptpdist1 >= 0) && (ptpdist1 <= ActiveChecks[checkinstance].sensitivity))
                                 {
                                 numconnections += 1.0;
                                 break;
                                 }
                              }
                           if(numconnections > 0)
                              break;
                           rac = rac->next;
                           }
                        }


                     if((numconnections < 1) && (numlikeconnections <= ActiveChecks[checkinstance].sensitivity2) && (rlnsave != NULL) &&
                           (SCCtable[rlc->Sindex].ECC == SCCtable[rlnsave->Sindex].ECC))
                        {
                        for(ii5 = 0; ii5 < rlc->numnodes; ii5++)
                           {
                           if(ii5 != nodeindex)
                              {
                              for(jj5 = 0; jj5 < rlnsave->numnodes; jj5++)
                                 {
                                 if(jj5 != keepit)
                                    {
                                    if((NearlyEqual(rlc->x[ii5],rlnsave->x[jj5]) > 0) &&
                                         (NearlyEqual(rlc->y[ii5],rlnsave->y[jj5]) > 0))
                                       {
                                       numconnections += 100;
                                       break;
                                       }
                                    }
                                 if(numconnections > 99)
                                    break;
                                 }
                              if(numconnections > 99)
                                 break;
                              }
                           }

                        if(numconnections < 99)
                           {
                           ERc = (struct collection *) (malloc(SzC));
                           if(ERc == NULL)
                              {
                              printf("allocation memory exhausted during linear feature condition analysis\n");
                              printf("processing cannot continue\n");
                              exit(-1);
                              }
                           if(rlc->length < rlnsave->length)
                              ERc->magnitude = rlc->length;
                           else
                              ERc->magnitude = rlnsave->length;

                           ERc->x[0] = rlc->x[nodeindex];
                           ERc->y[0] = rlc->y[nodeindex];
                           ERc->z[0] = rlc->z[nodeindex];

                           if(nodeindex == 0)
                              {
                              ERc->vertexindex1 = nodeindex;
                              ERc->x[1] = rlc->x[nodeindex + 1];
                              ERc->y[1] = rlc->y[nodeindex + 1];
                              ERc->z[1] = rlc->z[nodeindex + 1];
                              }
                           else
                              {
                              ERc->vertexindex1 = nodeindex - 1;
                              ERc->x[1] = rlc->x[nodeindex - 1];
                              ERc->y[1] = rlc->y[nodeindex - 1];
                              ERc->z[1] = rlc->z[nodeindex - 1];
                              }
   
                           if(keepit == 0)
                              {
                              ERc->vertexindex2 = keepit;
                              ERc->x[2] = rlnsave->x[keepit + 1];
                              ERc->y[2] = rlnsave->y[keepit + 1];
                              ERc->z[2] = rlnsave->z[keepit + 1];
                              ERc->x[3] = rlnsave->x[keepit];
                              ERc->y[3] = rlnsave->y[keepit];
                              ERc->z[3] = rlnsave->z[keepit];
                              }
                           else
                              {
                              ERc->vertexindex2 = keepit - 1;
                              ERc->x[2] = rlnsave->x[keepit - 1];
                              ERc->y[2] = rlnsave->y[keepit - 1];
                              ERc->z[2] = rlnsave->z[keepit - 1];
                              ERc->x[3] = rlnsave->x[keepit];
                              ERc->y[3] = rlnsave->y[keepit];
                              ERc->z[3] = rlnsave->z[keepit];
                              }


                        /***ERc->magnitude = numconnections;****/
                           ERc->keyval = FAILMERGEL;
                           ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                           ERc->ll1 = rlc;
                           ERc->ll2 = rlnsave;
                           ERc->Sindex = rlc->Sindex;
                           ERc->next = NULL;
                           if(ERroot == NULL)
                              {
                              ERroot = ERc;
                              }
                           else
                              {
                              ERn = ERroot;
                              while(ERn != NULL)
                                 {
   if((ERn->Cnumber == ERc->Cnumber) && (ERn->keyval == ERc->keyval))
                                    {
                                    if((ERn->ll1 == ERc->ll1) && (ERn->ll2 == ERc->ll2))
                                       break;
                                    if((ERn->ll2 == ERc->ll1) && (ERn->ll1 == ERc->ll2))
                                       break;
                                    }
                                 ERn = ERn->next;
                                 }
                              if(ERn == NULL)
                                 {
                                 ERc->next = ERroot;
                                 ERroot = ERc;
                                 }
                              else
                                 free(ERc);
                              }
                           }
                        } /*** end make this condition ***/
                     } /*** end if end node is in region ***/
                  nodeindex += (rlc->numnodes - 1);
                  }
               if(CVrlc != NULL)
                  {
                  for(ii3=0; ii3<CVrlc->numttl; ii3++)
                     {
                     if(CVrlc->cv[ii3].strval != NULL)
                        free(CVrlc->cv[ii3].strval);
                     }
                  free(CVrlc->cv);
                  free(CVrlc);
                  CVrlc = NULL;
                  }
               } /** end part1 ok **/
            } /** end FAILMERGEL check ***/




        if(CombinedCheckApplies(rlc->idn,checkinstance,FAILMERGEL2,rlc->Lindex,rlc->Sindex,Config1,Strat1,Domain1,&part1,&part2,&part3) > 0)
            {
            if(part1 > 0)
               {
               CVrlc = NULL;
               CVrlc = GetAttrCodesAndValues(rlc->Lindex, rlc->idn, attrfileptr,SzCV,SzCVl,1);

               nodeindex = 0;
               while(nodeindex < rlc->numnodes)
                  {
                  if((rlc->x[nodeindex] >= minx) && (rlc->x[nodeindex] <= maxx) && (rlc->y[nodeindex] >= miny) && (rlc->y[nodeindex] <= maxy))
                     {
                     keepit = PointOnQuarterDegreeBoundary(rlc->x[nodeindex], rlc->y[nodeindex], 0.1);
                     if(keepit == 1)
                        keepit = 0;
                     else
                        keepit = 1;
                     if(keepit > 0)
                     {
                     if((tempis2D(rlc->z[nodeindex])) && (tempis2D(rlc->z[rlc->numnodes - 1])))
                        {
                        ptpdist1 = Distance(rlc->x[0],rlc->y[0],
                                            rlc->x[rlc->numnodes - 1],rlc->y[rlc->numnodes - 1]);
                        }
                     else
                        {
                        ptpdist1 = Distance3D(rlc->x[0],rlc->y[0],rlc->z[0],
                                              rlc->x[rlc->numnodes - 1],rlc->y[rlc->numnodes - 1],rlc->z[rlc->numnodes - 1]);
                        }
                     if(ptpdist1 <= ActiveChecks[checkinstance].sensitivity)
                        {
                        numlikeconnections = 2.0;
                        numconnections = 0.0;
                        }
                     else
                        {
                        numlikeconnections = 1.0;
                        numconnections = 0.0;
                        }
                     rln = root;
                     rlnsave = NULL;
                     while(rln != NULL)
                        {
                        if(rln != rlc)
                           {
                           Config2 = SCCtable[rln->Sindex].C;
                           Strat2 = SCCtable[rln->Sindex].S;
                           Domain2 = SCCtable[rln->Sindex].D;
                           if((rln->Lindex == rlc->Lindex) &&
                                (CombinedCheckApplies(rln->idn,checkinstance,FAILMERGEL2,rln->Lindex,rln->Sindex,
                                     Config2,Strat2,Domain2,&part1,&part2,&part3) > 0) &&
                                         (part1 > 0))
                              {
                              nindex = 0;
                              while(nindex < rln->numnodes)
                                 {
                                 if((tempis2D(rlc->z[nodeindex])) && (tempis2D(rln->z[nindex])))
                                    ptpdist1 = Distance(rlc->x[nodeindex],rlc->y[nodeindex],rln->x[nindex],rln->y[nindex]);
                                 else
                                    ptpdist1 = Distance3D(rlc->x[nodeindex],rlc->y[nodeindex],rlc->z[nodeindex],
                                                         rln->x[nindex],rln->y[nindex],rln->z[nindex]);
                                 if(ptpdist1 <= ActiveChecks[checkinstance].sensitivity)
                                    {
                                    found_one = 0;
                                    if(CVrlc != NULL)
                                       {
                                       /** below function call, the last '1' argument says disregard length attr ***/
                                       CVrln = GetAttrCodesAndValues(rln->Lindex, rln->idn, attrfileptr,SzCV,SzCVl,1);
                                       if(CVrln != NULL)
                                          {
                                          found_one = SameAttrAndVals(CVrlc,CVrln,1);  /*** the 1 argument says do care about metadata ***/
                                          for(ii3=0; ii3<CVrln->numttl; ii3++)
                                             {
                                             if(CVrln->cv[ii3].strval != NULL)
                                                free(CVrln->cv[ii3].strval);
                                             }
                                          free(CVrln->cv);
                                          free(CVrln);
                                          CVrln = NULL;
                                          }
                                       }
                                    if(found_one > 0)
                                       {
                                       rlnsave = rln;
                                       keepit = nindex;
                                       numlikeconnections += 1.0;
                                       }
                                    }
                                 nindex += (rln->numnodes - 1);
                                 }
                              }
                           }
                        if(numlikeconnections > ActiveChecks[checkinstance].sensitivity2)
                           break;
                        rln = rln->next;
                        } /*** end while rln ***/

                     if((numlikeconnections <= ActiveChecks[checkinstance].sensitivity2) && (rlnsave != NULL))
                        {
                        ii4 = 0;
                        for(ii5 = 1; ii5 < rlc->numnodes; ii5++)
                           {
                           if((ii4 != nodeindex) && (ii5 != nodeindex))
                              {
                              jj4 = 0;
                              for(jj5 = 1; jj5 < rlnsave->numnodes; jj5++)
                                 {
                                 if((jj4 != nindex) && (jj5 != nindex))
                                    {
                                    if(LineSegmentsIntersect(rlc->x[ii4],rlc->y[ii4],rlc->x[ii5],rlc->y[ii5],
                                                              rlnsave->x[jj4],rlnsave->y[jj4],rlnsave->x[jj5],rlnsave->y[jj5],
                                                                 &xi, &yi) > 0)
                                       {
                                       numconnections += 100;
                                       }
                                    }
                                 }
                              }
                           }
                        }



                     if((numlikeconnections <= ActiveChecks[checkinstance].sensitivity2) &&
                          (numconnections == 0) &&  (rlnsave != NULL))
                        {
                        rln = root;
                        while(rln != NULL)
                           {
                           if((rln != rlc) && (rln != rlnsave))
                              {
                              Config2 = SCCtable[rln->Sindex].C;
                              Strat2 = SCCtable[rln->Sindex].S;
                              Domain2 = SCCtable[rln->Sindex].D;
                              if((CombinedCheckApplies(rln->idn,checkinstance,FAILMERGEL2,rln->Lindex,rln->Sindex,
                                     Config2,Strat2,Domain2,&part1,&part2,&part3) > 0) &&
                                         (part2 > 0))
                                 {
                                 nindex = 1;
                                 while(nindex < rln->numnodes)
                                    {
                                    if((tempis2D(rlc->z[nodeindex])) && (tempis2D(rln->z[nindex])))
                                       ptpdist1 = PointToLineDist2D(rlc->x[nodeindex],rlc->y[nodeindex],
                                                    rln->x[nindex-1],rln->y[nindex-1] ,rln->x[nindex],rln->y[nindex]);
                                    else
                                       ptpdist1 = PointToLineDist(rlc->x[nodeindex],rlc->y[nodeindex],rlc->z[nodeindex],
                                                    rln->x[nindex-1],rln->y[nindex-1],rln->z[nindex-1] ,rln->x[nindex],rln->y[nindex],rln->z[nindex]);
                                    if(ptpdist1 <= ActiveChecks[checkinstance].sensitivity)
                                       {
                                       numconnections += 1.0;
                                       break;
                                       }

                                    nindex += 1;
                                    }
                                 } /** end if part 2 of check applies ***/
                              } /** end rln != rlc ***/
                           if(numconnections > 0)
                              break;
                           rln = rln->next;
                           }
                        }

                     if((numlikeconnections <= ActiveChecks[checkinstance].sensitivity2) && (numconnections == 0) && (rlnsave != NULL))
                        {
                        rpc = Proot;
                        while(rpc != NULL)
                           {
                           Config2 = SCCtable[rpc->Sindex].C;
                           Strat2 = SCCtable[rpc->Sindex].S;
                           Domain2 = SCCtable[rpc->Sindex].D;
                           if((rpc->numverts == -1) && /** rpc is a pure point ***/
                             (CombinedCheckApplies(rpc->idn,checkinstance,FAILMERGEL2,rpc->Lindex,rpc->Sindex,
                                   Config2,Strat2,Domain2,&part1,&part2,&part3) > 0) &&
                                         (part2 > 0))
                              {
                              if((tempis2D(rlc->z[nodeindex])) && (tempis2D(rpc->z[0])))
                                 ptpdist1 = Distance(rlc->x[nodeindex],rlc->y[nodeindex],rpc->x[0],rpc->y[0]);
                              else
                                 ptpdist1 = Distance3D(rlc->x[nodeindex],rlc->y[nodeindex],rlc->z[nodeindex],
                                                      rpc->x[0],rpc->y[0],rpc->z[0]);
                              if(ptpdist1 <= ActiveChecks[checkinstance].sensitivity)
                                 {
                                 numconnections += 1.0;
                                 break;
                                 }
                              }
                           rpc = rpc->next;
                           }
                        }


                     if((numconnections < 1) && (numlikeconnections <= ActiveChecks[checkinstance].sensitivity2) && (rlnsave != NULL))
                        {
                        rac = Aroot;
                        while(rac != NULL)
                           {
                           Config2 = SCCtable[rac->Sindex].C;
                           Strat2 = SCCtable[rac->Sindex].S;
                           Domain2 = SCCtable[rac->Sindex].D;
                           if( (CombinedCheckApplies(rac->idn,checkinstance,FAILMERGEL2,rac->Lindex,rac->Sindex,
                                     Config2,Strat2,Domain2,&part1,&part2,&part3) > 0) &&
                                         (part2 > 0))
                              {
                              if(rac->RB_Tree_Edgelist == NULL)
                                 {
                                 ptpdist1 = PointToSmallArealDist2D(rlc->x[nodeindex], rlc->y[nodeindex],rac,&unusedint,&unuseddbl);
                                 }
                              else
                                 {
                                 ptpdist1 = PointToLargeArealDist2D(rlc->x[nodeindex], rlc->y[nodeindex],rac,&unusedint,&unuseddbl);
                                 }
                              if((ptpdist1 >= 0) && (ptpdist1 <= ActiveChecks[checkinstance].sensitivity))
                                 {
                                 numconnections += 1.0;
                                 break;
                                 }
                              }
                           if(numconnections > 0)
                              break;
                           rac = rac->next;
                           }
                        }


                     if((numconnections < 1) && (numlikeconnections <= ActiveChecks[checkinstance].sensitivity2) && (rlnsave != NULL) &&
                           (SCCtable[rlc->Sindex].ECC == SCCtable[rlnsave->Sindex].ECC))
                        {
                        ERc = (struct collection *) (malloc(SzC));
                        if(ERc == NULL)
                           {
                           printf("allocation memory exhausted during linear feature condition analysis\n");
                           printf("processing cannot continue\n");
                           exit(-1);
                           }
                        if(rlc->length < rlnsave->length)
                           ERc->magnitude = rlc->length;
                        else
                           ERc->magnitude = rlnsave->length;

                        ERc->x[0] = rlc->x[nodeindex];
                        ERc->y[0] = rlc->y[nodeindex];
                        ERc->z[0] = rlc->z[nodeindex];

                        if(nodeindex == 0)
                           {
                           ERc->vertexindex1 = nodeindex;
                           ERc->x[1] = rlc->x[nodeindex + 1];
                           ERc->y[1] = rlc->y[nodeindex + 1];
                           ERc->z[1] = rlc->z[nodeindex + 1];
                           }
                        else
                           {
                           ERc->vertexindex1 = nodeindex - 1;
                           ERc->x[1] = rlc->x[nodeindex - 1];
                           ERc->y[1] = rlc->y[nodeindex - 1];
                           ERc->z[1] = rlc->z[nodeindex - 1];
                           }

                        if(keepit == 0)
                           {
                           ERc->vertexindex2 = keepit;
                           ERc->x[2] = rlnsave->x[keepit + 1];
                           ERc->y[2] = rlnsave->y[keepit + 1];
                           ERc->z[2] = rlnsave->z[keepit + 1];
                           ERc->x[3] = rlnsave->x[keepit];
                           ERc->y[3] = rlnsave->y[keepit];
                           ERc->z[3] = rlnsave->z[keepit];
                           }
                        else
                           {
                           ERc->vertexindex2 = keepit - 1;
                           ERc->x[2] = rlnsave->x[keepit - 1];
                           ERc->y[2] = rlnsave->y[keepit - 1];
                           ERc->z[2] = rlnsave->z[keepit - 1];
                           ERc->x[3] = rlnsave->x[keepit];
                           ERc->y[3] = rlnsave->y[keepit];
                           ERc->z[3] = rlnsave->z[keepit];
                           }


                        ERc->keyval = FAILMERGEL2;
                        ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                        ERc->ll1 = rlc;
                        ERc->ll2 = rlnsave;
                        ERc->Sindex = rlc->Sindex;
                        ERc->next = NULL;
                        if(ERroot == NULL)
                           {
                           ERroot = ERc;
                           }
                        else
                           {
                           ERn = ERroot;
                           while(ERn != NULL)
                              {
if((ERn->Cnumber == ERc->Cnumber) && (ERn->keyval == ERc->keyval))
                                 {
                                 if((ERn->ll1 == ERc->ll1) && (ERn->ll2 == ERc->ll2))
                                    break;
                                 if((ERn->ll2 == ERc->ll1) && (ERn->ll1 == ERc->ll2))
                                    break;
                                 }
                              ERn = ERn->next;
                              }
                           if(ERn == NULL)
                              {
                              ERc->next = ERroot;
                              ERroot = ERc;
                              }
                           else
                              free(ERc);
                           }
                        } /*** end make this condition ***/
                     }  /** end if not on quarter cell boundary ***/
                     } /*** end if end node is in region ***/
                  nodeindex += (rlc->numnodes - 1);
                  }
               if(CVrlc != NULL)
                  {
                  for(ii3=0; ii3<CVrlc->numttl; ii3++)
                     {
                     if(CVrlc->cv[ii3].strval != NULL)
                        free(CVrlc->cv[ii3].strval);
                     }
                  free(CVrlc->cv);
                  free(CVrlc);
                  CVrlc = NULL;
                  }
               } /** end part1 ok **/
            } /** end FAILMERGEL2 check ***/






          if((CombinedCheckApplies(rlc->idn,checkinstance,LLAINT,rlc->Lindex,rlc->Sindex,Config1,Strat1,Domain1,&part1,&part2,&part3) > 0) &&
                      (part1 > 0))
             {
             j = 0;
             jj = 1;
             while(j < rlc->numnodes)
                {
                if((rlc->x[j] >= minx) && (rlc->x[j] <= maxx) && (rlc->y[j] >= miny) && (rlc->y[j] <= maxy))
                   {
                   tolerancepad = FindRelevantSensitivity(LLAINT,checkinstance,&unuseddbl);

                   rln = root;
                   checkit = 0;
                   while(rln != NULL)
                      {
                      if((rln != rlc) &&
                           (CombinedCheckApplies(rln->idn,checkinstance,LLAINT,rln->Lindex,rln->Sindex,
                                SCCtable[rln->Sindex].C,SCCtable[rln->Sindex].S,SCCtable[rln->Sindex].D,&part1,&part2,&part3) > 0) &&
                                          (part2 > 0))
                         {
                         for(k=1; k<rln->numnodes; k++)
                            {
                            kk = k - 1;
                            ptldist = PointToLineDist2D(rlc->x[j], rlc->y[j], rln->x[kk], rln->y[kk], rln->x[k], rln->y[k]);
                            if(ptldist <= tolerancepad)
                               {
                               checkit = 1;
                               break;
                               }
                            }
                         }
                      if(checkit > 0)
                         break;
                      rln = rln->next;
                      } /** end while rln ***/

                   if(rln != NULL) /** then found an applicable end node to end node connection at point (rlc->x[j], rlc->y[j]0 ***/
                      {
                      rac = Aroot;
                      while(rac != NULL)
                         {
                         if((CombinedCheckApplies(rac->idn,checkinstance,LLAINT,rac->Lindex,rac->Sindex,
                               SCCtable[rac->Sindex].C,SCCtable[rac->Sindex].S,SCCtable[rac->Sindex].D,&part1,&part2,&part3) > 0) &&
                                          (part3 > 0))
                            {
                            if(rac->RB_Tree_Edgelist == NULL)
                               ptpdist1 = PointToSmallArealDist2D(rlc->x[j], rlc->y[j],rac,&unusedint,&unuseddbl);
                            else
                               ptpdist1 = PointToLargeArealDist2D(rlc->x[j], rlc->y[j],rac,&unusedint,&unuseddbl);

                            if((ptpdist1 >= 0.0) && (ptpdist1 < tolerancepad)) /** seems we have found the condition ***/
                               {
                               ERc = (struct collection *) (malloc(SzC));
                               if(ERc == NULL)
                                  {
                                  printf("allocation memory exhausted during linear feature condition analysis\n");
                                  printf("processing cannot continue\n");
                                  exit(-1);
                                  }
                               ERc->x[0] = rlc->x[j];
                               ERc->y[0] = rlc->y[j];
                               ERc->z[0] = rlc->z[j];

                               ERc->x[1] = rlc->x[jj];
                               ERc->y[1] = rlc->y[jj];
                               ERc->z[1] = rlc->z[jj];
                               ERc->keyval = LLAINT;
                               ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                               ERc->ll1 = rlc;
                               ERc->ll2 = rlc;
                               ERc->Sindex = rlc->Sindex;
                               ERc->next = NULL;
                               if(ERroot == NULL)
                                  {
                                  ERroot = ERc;
                                  }
                               else
                                  {
                                  ERn = ERroot;
                                  while(ERn != NULL)
                                     {
                                     if((ERn->Cnumber == ERc->Cnumber) && (ERn->keyval == ERc->keyval) &&
                                        (ERn->ll1 == ERc->ll1) && (ERn->Sindex == ERc->Sindex) &&
                                        (ERn->x[0] == ERc->x[0]) && (ERn->y[0] == ERc->y[0]) && (ERn->z[0] == ERc->z[0]))
                                        {
                                        break;
                                        }
                                     ERn = ERn->next;
                                     }
                                  if(ERn == NULL)
                                     {
                                     ERc->next = ERroot;
                                     ERroot = ERc;
                                     }
                                  else
                                     free(ERc);
                                  }
                               break; /** from the while rac loop ***/
                               } /*** end founf the condition ***/
                            } /*** end check applies to this area feature ***/
                         rac = rac->next;
                         } /** end whiel rac != NULL ***/
                      } /*** end found the right type of end node match ***/
                   }  /** end rlc endpoint is in the current load module ***/
                j += rlc->numnodes - 1;
                jj = j - 1;
                } /*** end while j < rlc->numnodes ***/
             } /*** end LLAINT check applies ***/

         if(CombinedCheckApplies(rlc->idn,checkinstance,LAINTNOEND,rlc->Lindex,rlc->Sindex,
                                 Config1,Strat1,Domain1,&part1,&part2,&part3) > 0)
            {
            if(part1 > 0)
               {
               rac = Aroot;
               while(rac != NULL)
                  {
                  keepit = 0;
                  Config2 = SCCtable[rac->Sindex].C;
                  Strat2 = SCCtable[rac->Sindex].S;
                  Domain2 = SCCtable[rac->Sindex].D;
                  if((rac->ishole <= 0)&& (CombinedCheckApplies(rac->idn,checkinstance,LAINTNOEND,
                                rac->Lindex,rac->Sindex,Config2,Strat2,Domain2,&part1,&part2,&part3) > 0))
                     {
                     if(part2 > 0)
                        {
                           keepit = 0;
                           if(rac->RB_Tree_Edgelist == NULL)
                              ptadist1 = PointToSmallArealDist2D(rlc->x[0], rlc->y[0],rac,&unusedint,&unuseddbl);
                           else
                              ptadist1 = PointToLargeArealDist2D(rlc->x[0], rlc->y[0],rac,&unusedint,&unuseddbl);

                           if((ptadist1 < -99.0) || (ptadist1 > 0.001))
                              {
                              if(rac->RB_Tree_Edgelist == NULL)
                                 ptadist2 = PointToSmallArealDist2D(rlc->x[rlc->numnodes-1], rlc->y[rlc->numnodes-1],rac,&unusedint,&unuseddbl);
                              else
                                 ptadist2 = PointToLargeArealDist2D(rlc->x[rlc->numnodes-1], rlc->y[rlc->numnodes-1],rac,&unusedint,&unuseddbl);
                               if((ptadist2 < -99.0) || (ptadist2 > 0.001))
                                  {
                                  keepit = 1;
                                  }
                               }
                           if(keepit > 0)
                              {
                              keepit = 0;
                              for(i=1; i<rlc->numnodes; i++)
                                 {
                                 ii = i - 1;
                                 x1 = rlc->x[ii];
                                 y1 = rlc->y[ii];
                                 z1 = rlc->z[ii];
                                 x2 = rlc->x[i];
                                 y2 = rlc->y[i];
                                 z2 = rlc->z[i];
                                    
                                 if(x1 < x2)
                                    {
                                    minLx = x1;
                                    maxLx = x2;
                                    }
                                 else
                                    {
                                    minLx = x2;
                                    maxLx = x1;
                                    }
                                 if(y1 < y2)
                                    {
                                    minLy = y1;
                                    maxLy = y2;
                                    }
                                 else
                                    {
                                    minLy = y2;
                                    maxLy = y1;
                                    }
                                 for(j=0; j<rac->numverts; j++)
                                    {
                                    jj = (j + 1) % rac->numverts;
                                    x3 = rac->x[jj];
                                    y3 = rac->y[jj];
                                    z3 = rac->z[jj];
                                    x4 = rac->x[j];
                                    y4 = rac->y[j];
                                    z4 = rac->z[j];
                                    checkit = 0;
                                    if((x3 < x4) && (x3 <= maxLx) && (x4 >= minLx))
                                       {
                                       if((y3 < y4) && (y3 <= maxLy)  && (y4 >= minLy))
                                          checkit = 1;
                                       else if((y4 <= y3) && (y4 <= maxLy) && (y3 >= minLy))
                                          checkit = 1;
                                       }
                                    else if((x4 <= x3) && (x4 <= maxLx) && (x3 >= minLx))
                                       {
                                       if((y3 < y4) && (y3 <= maxLy)  && (y4 >= minLy))
                                          checkit = 1;
                                       else if((y4 <= y3) && (y4 <= maxLy) && (y3 >= minLy))
                                          checkit = 1;
                                       }
                                    if((checkit > 0) && (LineSegmentsIntersect(x1,y1,x2,y2,x3,y3,x4,y4, &xi, &yi) > 0))
                                       {
                                       onedge = EdgesOverlap(x1,y1,x2,y2,x3,y3,x4,y4, &temp, &temp1, &temp2, &temp3, &bothmatch,PTLTOLERANCE);
                                       if(onedge < 2)
                                          {
                                          ptpdist1 = Distance(rlc->x[0],rlc->y[0],xi,yi);
                                          ptpdist2 = Distance(rlc->x[rlc->numnodes-1],rlc->y[rlc->numnodes-1],xi,yi);
                                          if((ptpdist1 > 0.0001) && (ptpdist2 > 0.0001))
                                             {
                                             if(ptpdist2 < ptpdist1)
                                                ptpdist1 = ptpdist2;
                                             if(SensitivityCheck(GT, LAINTNOEND, checkinstance, ptpdist1) > 0)
                                                {
                                                keepit = 1;
                                                ERc = (struct collection *) (malloc(SzC));
                                                if(ERc == NULL)
                                                   {
                                                   printf("allocation memory exhausted during linear feature condition analysis\n");
                                                   printf("processing cannot continue\n");
                                                   exit(-1);
                                                   }
                                                ERc->x[0] = xi;
                                                ERc->y[0] = yi;
                                                ERc->z[0] = InterpLinearElev(rlc->x[ii],rlc->y[ii],rlc->z[ii], rlc->x[i], rlc->y[i],rlc->z[i],xi,yi);
                                                /***ERc->z[0] = 0.0; ***/
                                                ERc->x[1] = rlc->x[ii];
                                                ERc->y[1] = rlc->y[ii];
                                                ERc->z[1] = rlc->z[ii];
                                                ERc->x[2] = rlc->x[i];
                                                ERc->y[2] = rlc->y[i];
                                                ERc->z[2] = rlc->z[i];
                                                ERc->x[3] = rac->x[jj];
                                                ERc->y[3] = rac->y[jj];
                                                ERc->z[3] = rac->z[jj];
                                                ERc->x[4] = rac->x[j];
                                                ERc->y[4] = rac->y[j];
                                                ERc->z[4] = rac->z[j];

                                                ERc->magnitude = ptpdist1;
                                                ERc->keyval = LAINTNOEND;
                                                ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                                                ERc->aa = rac;
                                                ERc->ll1 = rlc;
                                                ERc->Sindex = rlc->Sindex;
                                                ERc->next = NULL;

                                                ERn = ERroot;
                                                while(ERn != NULL)
                                                   {
                                                     if(
                                                        (ERn->Cnumber == ERc->Cnumber) &&
                                                        (ERn->keyval  == ERc->keyval) &&
                                                        (ERn->x[0]    == ERc->x[0])   &&
                                                        (ERn->y[0]    == ERc->y[0])   &&
                                                        (ERn->ll1  == ERc->ll1) &&
                                                        (ERn->aa   == ERc->aa)
                                                        )
                                                       break;
                                                     ERn = ERn->next;
                                                   }
                                                if(ERn == NULL)
                                                   {
                                                   ERc->next = ERroot;
                                                   ERroot = ERc;
                                                   }
                                                else
                                                   free(ERc); 
                                                }
                                             }
                                          }
                                       }
                                    if(keepit > 0)
                                       break;
                                    }
                                 if(keepit > 0)
                                    break;
                                 }
                              }
                           
                        } /** end for non-RB-tree areals ***/
                     if(keepit > 0)
                        {
                        keepit = 0;
                        } /*** end keepit, so record a condition ***/
                     } /*** end not an areal hole and check applies ***/
                  rac = rac->next;
                  } /*** end list of areals ***/
               } /** end part1 for line feature is OK ***/
            } /** end LAINTNOEND ***/




          if((CombinedCheckApplies(rlc->idn,checkinstance,L_NOTL_AINT,rlc->Lindex,rlc->Sindex,Config1,Strat1,Domain1,&part1,&part2,&part3) > 0) &&
                      (part1 > 0))
             {
             j = 0;
             jj = 1;
             while(j < rlc->numnodes)
                {
                if((rlc->x[j] >= minx) && (rlc->x[j] <= maxx) && (rlc->y[j] >= miny) && (rlc->y[j] <= maxy))
                   {
                   tolerancepad = ActiveChecks[checkinstance].sensitivity;
                   minxPadded = rlc->x[j] - tolerancepad;
                   maxxPadded = rlc->x[j] + tolerancepad;
                   minyPadded = rlc->y[j] - tolerancepad;
                   maxyPadded = rlc->y[j] + tolerancepad;

                   rln = root;
                   while(rln != NULL)
                      {
                      k = rln->numnodes + 10;
                      if(rln != rlc)
                         {
                         if((CombinedCheckApplies(rln->idn,checkinstance,L_NOTL_AINT,rln->Lindex,rln->Sindex,
                                SCCtable[rln->Sindex].C,SCCtable[rln->Sindex].S,SCCtable[rln->Sindex].D,&part1,&part2,&part3) > 0) &&
                                          (part2 > 0))
                            {
                            k = 0;
                            while(k < rln->numnodes)
                               {
                               if((rln->x[k] >= minxPadded) && (rln->x[k] <= maxxPadded) &&
                                            (rln->y[k] >= minyPadded) && (rln->y[k] <= maxyPadded))
                                  {
                                  break; /** from while rln loop ***/
                                  }
                               k += rln->numnodes - 1;
                               }
                            }
                         } /* end rln != rlc ***/
                      if(k < rln->numnodes)
                         break; /*** from the while rln != NULL loop ***/
                      rln = rln->next;
                      } /** end while rln ***/
                   checkit2 = 0;
                   if(rln == NULL)
                      {
                      checkit2 = 1;
                      }
                   if(checkit2 > 0)
                      {
                      rac = Aroot;
                      while(rac != NULL)
                         {
                         if((CombinedCheckApplies(rac->idn,checkinstance,L_NOTL_AINT,rac->Lindex,rac->Sindex,
                               SCCtable[rac->Sindex].C,SCCtable[rac->Sindex].S,SCCtable[rac->Sindex].D,&part1,&part2,&part3) > 0) &&
                                          (part2 > 0))
                            {
                            if(rac->RB_Tree_Edgelist == NULL)
                               ptpdist1 = PointToSmallArealDist2D(rlc->x[j], rlc->y[j],rac,&unusedint,&unuseddbl);
                            else
                               ptpdist1 = PointToLargeArealDist2D(rlc->x[j], rlc->y[j],rac,&unusedint,&unuseddbl);
      
                            if((ptpdist1 >= 0.0) && (ptpdist1 <= tolerancepad)) /** seems we have found the condition ***/
                               {
                               checkit2 = 0;
                               break;
                               }
                            }
                         rac = rac->next;
                         }
                      }
                   if(checkit2 > 0)
                      {
                      rac = Aroot;
                      while(rac != NULL)
                         {
                         if((CombinedCheckApplies(rac->idn,checkinstance,L_NOTL_AINT,rac->Lindex,rac->Sindex,
                               SCCtable[rac->Sindex].C,SCCtable[rac->Sindex].S,SCCtable[rac->Sindex].D,&part1,&part2,&part3) > 0) &&
                                          (part3 > 0))
                            {
                            if(rac->RB_Tree_Edgelist == NULL)
                               ptpdist1 = PointToSmallArealDist2D(rlc->x[j], rlc->y[j],rac,&unusedint,&unuseddbl);
                            else
                               ptpdist1 = PointToLargeArealDist2D(rlc->x[j], rlc->y[j],rac,&unusedint,&unuseddbl);

                            if((ptpdist1 >= 0.0) && (ptpdist1 <= tolerancepad)) /** seems we have found the condition ***/
                               {
                               ERc = (struct collection *) (malloc(SzC));
                               if(ERc == NULL)
                                  {
                                  printf("allocation memory exhausted during linear feature condition analysis\n");
                                  printf("processing cannot continue\n");
                                  exit(-1);
                                  }
                               ERc->x[0] = rlc->x[j];
                               ERc->y[0] = rlc->y[j];
                               ERc->z[0] = rlc->z[j];

                               ERc->x[1] = rlc->x[jj];
                               ERc->y[1] = rlc->y[jj];
                               ERc->z[1] = rlc->z[jj];
                               ERc->keyval = L_NOTL_AINT;
                               ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                               ERc->ll1 = rlc;
                               ERc->ll2 = rlc;
                               ERc->Sindex = rlc->Sindex;
                               ERc->next = NULL;
                               if(ERroot == NULL)
                                  {
                                  ERroot = ERc;
                                  }
                               else
                                  {
                                  ERn = ERroot;
                                  while(ERn != NULL)
                                     {
                                     if((ERn->Cnumber == ERc->Cnumber) && (ERn->keyval == ERc->keyval) &&
                                        (ERn->ll1 == ERc->ll1) && (ERn->Sindex == ERc->Sindex) &&
                                        (ERn->x[0] == ERc->x[0]) && (ERn->y[0] == ERc->y[0]) && (ERn->z[0] == ERc->z[0]))
                                        {
                                        break;
                                        }
                                     ERn = ERn->next;
                                     }
                                  if(ERn == NULL)
                                     {
                                     ERc->next = ERroot;
                                     ERroot = ERc;
                                     }
                                  else
                                     free(ERc);
                                  }
                               break; /** from the while rac loop ***/
                               } /*** end founf the condition ***/
                            } /*** end check applies to this area feature ***/
                         rac = rac->next;
                         } /** end whiel rac != NULL ***/
                      } /*** end found the right type of end node match ***/
                   }  /** end rlc endpoint is in the current load module ***/
                j += rlc->numnodes - 1;
                jj = j - 1;
                } /*** end while j < rlc->numnodes ***/
             } /*** end L_NOTL_AINT check applies ***/



         if(CombinedCheckApplies(rlc->idn,checkinstance,BOTHENDCON,rlc->Lindex,rlc->Sindex,
             Config1,Strat1,Domain1,&part1,&part2,&part3) > 0)
            {
            if(part1 > 0)
               {
               foundobject = 0;
               i = 0;
               while(i < rlc->numnodes)
                  {
                  k = 0;
                  if((rlc->x[i] >= minx) && (rlc->x[i] <= maxx) && (rlc->y[i] >= miny) && (rlc->y[i] <= maxy))
                     k = 1;
                  
                  if(k > 0)
                     {
                     rpc = Proot;
                     while(rpc != NULL)
                        {
                        if(CombinedCheckApplies(rpc->idn,checkinstance,BOTHENDCON,rpc->Lindex,rpc->Sindex,
                                 SCCtable[rpc->Sindex].C, SCCtable[rpc->Sindex].S, SCCtable[rpc->Sindex].D,
                                 &part1,&part2,&part3) > 0)
                           {
                           if(part2 > 0)
                              {
                              ptpdist1 = Distance3D(rlc->x[i],rlc->y[i],rlc->z[i],rpc->x[0],rpc->y[0],rpc->z[0]);
                              if(SensitivityCheck(LTEQ,BOTHENDCON,checkinstance,ptpdist1) > 0)
                                 {
                                 foundobject += 1;
                                 break;
                                 }
                              }
                           }
                        rpc = rpc->next;
                        }
                     } /** end k > 0 **/
                  i = i + (rlc->numnodes - 1);
                  } /** end while i < rlc->numnodes ***/


               if((rlc->IsMulti == 0) && (foundobject == 2))  /*** need to write a condition   ****/
                  {
                  ERc = (struct collection *) (malloc(SzC));
                  if(ERc == NULL)
                     {
                     printf("allocation memory exhausted during linear feature condition analysis\n");
                     printf("processing cannot continue\n");
                     exit(-1);
                     }
                  ERc->x[0] = rlc->x[0];
                  ERc->y[0] = rlc->y[0];
                  ERc->z[0] = rlc->z[0];

                  ERc->x[1] = rlc->x[rlc->numnodes - 2];
                  ERc->y[1] = rlc->y[rlc->numnodes - 2];
                  ERc->z[1] = rlc->z[rlc->numnodes - 2];

                  ERc->x[2] = rlc->x[rlc->numnodes - 1];
                  ERc->y[2] = rlc->y[rlc->numnodes - 1];
                  ERc->z[2] = rlc->z[rlc->numnodes - 1];

                  ERc->keyval = BOTHENDCON;
                  ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                  ERc->ll1 = rlc;
                  ERc->ll2 = NULL;
                  ERc->Sindex = rlc->Sindex;
                  ERc->next = NULL;
                  if(ERroot == NULL)
                     {
                     ERroot = ERc;
                     }
                  else
                     {
                     ERn = ERroot;
                     while(ERn != NULL)
                        {
                        if((ERn->Cnumber == ERc->Cnumber) && (ERn->keyval == ERc->keyval) && (ERn->ll1 == ERc->ll1) &&
                           (ERn->x[0] == ERc->x[0]) && (ERn->y[0] == ERc->y[0]) && (ERn->Sindex == ERc->Sindex) &&
                           (ERn->z[0] == ERc->z[0]))
                           break;
                        ERn = ERn->next;
                        }
                     if(ERn == NULL)
                        {
                        ERc->next = ERroot;
                        ERroot = ERc;
                        }
                     else
                        free(ERc);
                     }
                  } /** end saving condition for single region line feature ***/
               else if((rlc->IsMulti > 0) && (foundobject > 0))
                  {
                  RB_newKey2 = rlc->idn + (checkinstance * 0.0001);
                  if(( RB_newNode = RBExactQuery(Check_RB_Tree,&RB_newKey2)) == 0)
                     {
                     RB_cond = (struct ConditionCollection *) (malloc(SzCC));
   
                     if(RB_cond == NULL)
                        {
                        printf("memory has been exhausted during RB-Tree information alloction for BOTHENDCON analysis\n");
                        exit(-1);
                        }
                     RB_cond->keyval = BOTHENDCON;
                     RB_cond->Cnumber =  Make_Correct(BOTHENDCON,checkinstance);
                     RB_cond->index_from_to = NULL;
                     RB_cond->gform = G_LINE;
                     RB_cond->featureidn = rlc->featureid;
                     RB_cond->counter = foundobject;
                     RB_cond->radius = -1;
                     RB_cond->height = -1;
                     RB_cond->magnitude = 0.0;
                     RB_cond->IDN = rlc->idn;
                     RB_cond->localID = rlc->localID;
                     RB_cond->Sindex = rlc->Sindex;
                     RB_cond->Lindex = rlc->Lindex;
                     RB_cond->numnodes = 3;
                     RB_cond->x = (double *) (malloc(3 * SzD));
                     RB_cond->y = (double *) (malloc(3 * SzD));
                     RB_cond->z = (double *) (malloc(3 * SzD));
                     RB_cond->x[0] = rlc->x[0];
                     RB_cond->y[0] = rlc->y[0];
                     RB_cond->z[0] = rlc->z[0];
                     RB_cond->x[1] = rlc->x[rlc->numnodes-2];
                     RB_cond->y[1] = rlc->y[rlc->numnodes-2];
                     RB_cond->z[1] = rlc->z[rlc->numnodes-2];
                     RB_cond->x[2] = rlc->x[rlc->numnodes-1];
                     RB_cond->y[2] = rlc->y[rlc->numnodes-1];
                     RB_cond->z[2] = rlc->z[rlc->numnodes-1];

                     jj = rlc->numnodes - 1;
                     if(rlc->x[0] > rlc->x[jj])
                        unuseddbl = rlc->x[0];
                     else
                        unuseddbl = rlc->x[jj];

                     ii5 = (int) (unuseddbl / RegionSize) + 1;

                     RB_cond->radius = ii5; /** storing last LM column where this feature appears in 'radius' field ***/

                     RB_newDbl = (double *) (malloc(SzD));
                     if(RB_newDbl == NULL)
                        {
                        printf("memory has been exhausted during RB-Tree alloction for BOTHENDCON analysis\n");
                        exit(-1);
                        }
                     *RB_newDbl = RB_newKey2; /**rac->localID; **/
                     RBTreeInsert(Check_RB_Tree,RB_newDbl, RB_cond);
                     } /** end making initial entry in Check_RB_Tree ***/
                  else
                     {
                     RB_cond = (struct ConditionCollection *) RB_newNode->info;
                     if((RB_cond != NULL) && (foundobject == 1))
                        {
                        RB_cond->counter += foundobject;
                        }
                     } /** end updating entry in Check_RB_Tree ***/

                  } /** making new or update entry in Check_RB_Tree ***/

               } /** end if part1 ***/
            } /** end BOTHENDCON applies to rlc ***/



         if(CombinedCheckApplies(rlc->idn,checkinstance,NOENDCON,rlc->Lindex,rlc->Sindex,Config1,Strat1,Domain1,&part1,&part2,&part3) > 0)
            {
            checkit = 0;
            if(part1 > 0)
               {
               checkit = 1;
               RB_newKey2 = rlc->idn + (checkinstance * 0.0001);
               RB_cond = NULL;
               if(( RB_newNode = RBExactQuery(Check_RB_Tree,&RB_newKey2)) != 0)
                  RB_cond = (struct ConditionCollection *) RB_newNode->info;
               if((RB_cond != NULL) && (RB_cond->counter > 0))
                  {
                  checkit = 0;
                  }
               }

            if(checkit > 0)
               {
               mindist = ActiveChecks[checkinstance].sensitivity * ActiveChecks[checkinstance].sensitivity;
               foundobject = 0;
               for(i=1; i<rlc->numnodes; i++)
                  {
                  ii = i - 1;
                  k = 1;
                  if(k > 0)
                     {
                     rpc = Proot;
                     while(rpc != NULL)
                        {
                        if(CombinedCheckApplies(rpc->idn,checkinstance,NOENDCON,rpc->Lindex,rpc->Sindex,
                                 SCCtable[rpc->Sindex].C, SCCtable[rpc->Sindex].S, SCCtable[rpc->Sindex].D,
                                 &part1,&part2,&part3) > 0)
                           {
                           if(part2 > 0)
                              {
                              ptpdist1 = PointToLineDist(rpc->x[0],rpc->y[0],rpc->z[0],
                                      rlc->x[ii], rlc->y[ii], rlc->z[ii], rlc->x[i], rlc->y[i], rlc->z[i]);
                              if(SensitivityCheck(LTEQ,NOENDCON,checkinstance,ptpdist1) > 0)
                                 {
                                 foundobject = 1;
                                 break;
                                 }
                              }
                           }
                        rpc = rpc->next;
                        }

                     if(foundobject == 0)
                        {
                        rln = root;
                        while(rln != NULL)
                           {
                           if(rln == rlc)
                              {
                              if(rlc->next == NULL)
                                 break;
                              else
                                 rln = rlc->next;
                              }
                           if((CombinedCheckApplies(rln->idn,checkinstance,NOENDCON,rln->Lindex,rln->Sindex,
                                 SCCtable[rln->Sindex].C, SCCtable[rln->Sindex].S, SCCtable[rln->Sindex].D,
                                 &part1,&part2,&part3) > 0) && (part2 > 0))
                              {
                              ptpdist1 = ApproxPointToLineDist2D(rln->x[0],rln->y[0],rlc->x[i],rlc->y[i],rlc->x[ii], rlc->y[ii]);
                              k = 0;
                              if((ActiveChecks[checkinstance].sensitivity < 1.0) && (ptpdist1 < 1.0))
                                 k = 1;
                              else if(ptpdist1 < mindist)
                                 k = 1;
                              if(k > 0)
                                 {
                                 ptpdist1 = PointToLineDist(rln->x[0],rln->y[0],rln->z[0],
                                   rlc->x[i],rlc->y[i],rlc->z[i],rlc->x[ii], rlc->y[ii],rlc->z[ii]);
                                 if(SensitivityCheck(LTEQ,NOENDCON,checkinstance,ptpdist1) > 0)
                                    {
                                    foundobject = 1;
                                    }
                                 }

                              for(j = 1; j<rln->numnodes; j++)
                                 {
                                 if(foundobject > 0)
                                    break;
                                 jj = j - 1;
                                 ptpdist1 = ApproxPointToLineDist2D(rln->x[j],rln->y[j],rlc->x[i],rlc->y[i],rlc->x[ii], rlc->y[ii]);
                                 k = 0;
                                 if((ActiveChecks[checkinstance].sensitivity < 1.0) && (ptpdist1 < 1.0))
                                    k = 1;
                                 else if(ptpdist1 < mindist)
                                    k = 1;
                                 if(k > 0)
                                    {
                                    ptpdist1 = PointToLineDist(rln->x[j],rln->y[j],rln->z[j],
                                      rlc->x[i],rlc->y[i],rlc->z[i],rlc->x[ii], rlc->y[ii],rlc->z[ii]);
                                    if(SensitivityCheck(LTEQ,NOENDCON,checkinstance,ptpdist1) > 0)
                                       {
                                       foundobject = 1;
                                       break;
                                       }
                                    }

                                 ptpdist1 = ApproxPointToLineDist2D(rlc->x[i],rlc->y[i],rln->x[jj], rln->y[jj],rln->x[j], rln->y[j]);
                                 k = 0;
                                 if((ActiveChecks[checkinstance].sensitivity < 1.0) && (ptpdist1 < 1.0))
                                    k = 1;
                                 else if(ptpdist1 < mindist)
                                    k = 1;
                                 if(k > 0)
                                    {
                                    ptpdist1 = PointToLineDist(rlc->x[i],rlc->y[i],rlc->z[i],
                                      rln->x[jj], rln->y[jj], rln->z[jj], rln->x[j], rln->y[j], rln->z[j]);
                                    if(SensitivityCheck(LTEQ,NOENDCON,checkinstance,ptpdist1) > 0)
                                       {
                                       foundobject = 1;
                                       break;
                                       }
                                    }

                                 ptpdist1 = ApproxPointToLineDist2D(rlc->x[ii],rlc->y[ii],rln->x[jj], rln->y[jj],rln->x[j], rln->y[j]);
                                 k = 0;
                                 if((ActiveChecks[checkinstance].sensitivity < 1.0) && (ptpdist1 < 1.0))
                                    k = 1;
                                 else if(ptpdist1 < mindist)
                                    k = 1;
                                 if(k > 0)
                                    {
                                    ptpdist1 = PointToLineDist(rlc->x[ii],rlc->y[ii],rlc->z[ii],
                                      rln->x[jj], rln->y[jj], rln->z[jj], rln->x[j], rln->y[j], rln->z[j]);
                                    if(SensitivityCheck(LTEQ,NOENDCON,checkinstance,ptpdist1) > 0)
                                       {
                                       foundobject = 1;
                                       break;
                                       }
                                    }

                                 k = 1;
                                 if(k > 0)
                                    {
                                    if(LineSegmentsIntersect(rlc->x[ii],rlc->y[ii],rlc->x[i],rlc->y[i],
                                              rln->x[jj],rln->y[jj], rln->x[j],rln->y[j], &xi, &yi) > 0)
                                       {
                                       foundobject = 1;
                                       break;
                                       }
                                    }
                                 }
                              }
                           if(foundobject > 0)
                              break;
                           rln = rln->next;
                           }
                        }
                     if(foundobject == 0)
                        {
                        rac = Aroot;
                        while(rac != NULL)
                           {
                           if((rac->ishole <= 0) &&
                                 (CombinedCheckApplies(rac->idn,checkinstance,NOENDCON,rac->Lindex,rac->Sindex,
                                                SCCtable[rac->Sindex].C, SCCtable[rac->Sindex].S, SCCtable[rac->Sindex].D,
                                                &part1,&part2,&part3) > 0) && (part2 > 0))
                              {
                              k = 0;
                              if(rac->RB_Tree_Edgelist == NULL)
                                 {
                                 k = PointIsInside(rlc->x[i],rlc->y[i],rac->x,rac->y,rac->z,rac->numverts,C_AREA,&unuseddbl);
                                 }
                              else
                                 {
                                 k = PointInsideLargeAreal(rlc->x[i], rlc->y[i], rac,&unusedint);
                                 }
                              if(k > 0)
                                 {
                                 rah = Aroot;
                                 while(rah != NULL)
                                    {
                                    if((rah->ishole > 0) && (rah->idn == rac->idn))
                                       {
                                       inside2 = LinePartOrAllInsideArea(rlc,rah, &kk,
                                                       &kk2, ActiveChecks[checkinstance].sensitivity,200.0);
                                       if(inside2 > 0)
                                          {
                                          ptpdist1 = ActiveChecks[checkinstance].sensitivity + 100;
                                          for(ii4=0; ii4<rlc->numnodes; ii4++)
                                             {
                                             if(rah->RB_Tree_Edgelist == NULL)
                                                ptpdist1 = PointToSmallArealDist2D(rlc->x[ii4], rlc->y[ii4],rah,&ii5,&unuseddbl);
                                             else
                                                ptpdist1 = PointToLargeArealDist2D(rlc->x[ii4], rlc->y[ii4],rah,&ii5,&unuseddbl);
                                             if(ptpdist1 <= ActiveChecks[checkinstance].sensitivity)
                                                break;
                                             }
                                          if(ptpdist1 > ActiveChecks[checkinstance].sensitivity)
                                             k = 0;
                                          break;
                                          }
                                       }
                                    rah = rah->next;
                                    }
                                 }
                              if(k > 0)
                                 {
                                 foundobject = 1;
                                 break;
                                 }
                              else if(ii == 0)
                                 {
                                 if(rac->RB_Tree_Edgelist == NULL)
                                    {
                                    k = PointIsInside(rlc->x[0],rlc->y[0],rac->x,rac->y,rac->z,rac->numverts,C_AREA,&unuseddbl);
                                    }
                                 else
                                    {
                                    k = PointInsideLargeAreal(rlc->x[0], rlc->y[0], rac,&unusedint);
                                    }
                                 if(k > 0)
                                    {
                                    rah = Aroot;
                                    while(rah != NULL)
                                       {
                                       if((rah->ishole > 0) && (rah->idn == rac->idn))
                                          {
                                          inside2 = LinePartOrAllInsideArea(rlc,rah, &kk,
                                                       &kk2, ActiveChecks[checkinstance].sensitivity,200.0);
                                          if(inside2 > 0)
                                             {
                                             ptpdist1 = ActiveChecks[checkinstance].sensitivity + 100;
                                             for(ii4=0; ii4<rlc->numnodes; ii4++)
                                                {
                                                if(rah->RB_Tree_Edgelist == NULL)
                                                   ptpdist1 = PointToSmallArealDist2D(rlc->x[ii4], rlc->y[ii4],rah,&ii5,&unuseddbl);
                                                else
                                                   ptpdist1 = PointToLargeArealDist2D(rlc->x[ii4], rlc->y[ii4],rah,&ii5,&unuseddbl);
                                                if(ptpdist1 <= ActiveChecks[checkinstance].sensitivity)
                                                   break;
                                                }
                                             if(ptpdist1 > ActiveChecks[checkinstance].sensitivity)
                                                k = 0;
                                             break;
                                             }
                                          }
                                       rah = rah->next;
                                       }
                                    }

                                 if(k > 0)
                                    {
                                    foundobject = 1;
                                    break;
                                    }
                                 }


                              ptpdist1 = ApproxPointToLineDist2D(rac->x[0],rac->y[0],rlc->x[i],rlc->y[i],rlc->x[ii], rlc->y[ii]);
                              k = 0;
                              if((ActiveChecks[checkinstance].sensitivity < 1.0) && (ptpdist1 < 1.0))
                                 k = 1;
                              else if(ptpdist1 < mindist)
                                 k = 1;
                              if(k > 0)
                                 {
                                 ptpdist1 = PointToLineDist(rac->x[0],rac->y[0],rac->z[0],
                                   rlc->x[i],rlc->y[i],rlc->z[i],rlc->x[ii],rlc->y[ii],rlc->z[ii]);
                                 if(SensitivityCheck(LTEQ,NOENDCON,checkinstance,ptpdist1) > 0)
                                    {
                                    foundobject = 1;
                                    }
                                 }

                              jj = rac->numverts - 1;
                              for(j = 0; j<rac->numverts; j++)
                                 {
                                 if(foundobject > 0)
                                    break;

                                 if(j > 0)
                                    jj = j - 1;

                                 ptpdist1 = ApproxPointToLineDist2D(rac->x[j],rac->y[j],rlc->x[i],rlc->y[i],rlc->x[ii], rlc->y[ii]);
                                 k = 0;
                                 if((ActiveChecks[checkinstance].sensitivity < 1.0) && (ptpdist1 < 1.0))
                                    k = 1;
                                 else if(ptpdist1 < mindist)
                                    k = 1;
                                 if(k > 0)
                                    {
                                    ptpdist1 = PointToLineDist(rac->x[j],rac->y[j],rac->z[j],
                                      rlc->x[i],rlc->y[i],rlc->z[i],rlc->x[ii],rlc->y[ii],rlc->z[ii]);
                                    if(SensitivityCheck(LTEQ,NOENDCON,checkinstance,ptpdist1) > 0)
                                       {
                                       foundobject = 1;
                                       break;
                                       }
                                    }


                                 ptpdist1 = ApproxPointToLineDist2D(rlc->x[i],rlc->y[i],rac->x[jj], rac->y[jj],rac->x[j], rac->y[j]);
                                 k = 0;
                                 if((ActiveChecks[checkinstance].sensitivity < 1.0) && (ptpdist1 < 1.0))
                                    k = 1;
                                 else if(ptpdist1 < mindist)
                                    k = 1;
                                 if(k > 0)
                                    {
                                    ptpdist1 = PointToLineDist(rlc->x[i],rlc->y[i],rlc->z[i],
                                      rac->x[jj], rac->y[jj], rac->z[jj], rac->x[j], rac->y[j], rac->z[j]);
                                    if(SensitivityCheck(LTEQ,NOENDCON,checkinstance,ptpdist1) > 0)
                                       {
                                       foundobject = 1;
                                       break;
                                       }
                                    }

                                 ptpdist1 = ApproxPointToLineDist2D(rlc->x[ii],rlc->y[ii],rac->x[jj], rac->y[jj],rac->x[j], rac->y[j]);
                                 k = 0;
                                 if((ActiveChecks[checkinstance].sensitivity < 1.0) && (ptpdist1 < 1.0))
                                    k = 1;
                                 else if(ptpdist1 < mindist)
                                    k = 1;
                                 if(k > 0)
                                    {
                                    ptpdist1 = PointToLineDist(rlc->x[ii],rlc->y[ii],rlc->z[ii],
                                      rac->x[jj], rac->y[jj], rac->z[jj], rac->x[j], rac->y[j], rac->z[j]);
                                    if(SensitivityCheck(LTEQ,NOENDCON,checkinstance,ptpdist1) > 0)
                                       {
                                       foundobject = 1;
                                       break;
                                       }
                                    }

                                 k = 1;

                                 if(k > 0)
                                    {
                                    if(LineSegmentsIntersect(rlc->x[ii],rlc->y[ii],rlc->x[i],rlc->y[i],
                                              rac->x[jj],rac->y[jj], rac->x[j],rac->y[j], &xi, &yi) > 0)
                                       {
                                       foundobject = 1;
                                       break;
                                       }
                                    }
                                 }
                              }
                           if(foundobject > 0)
                              break;
                           rac = rac->next;
                           }
                        }
               
                     }
                  if(foundobject > 0)
                     break;
                  }

               RB_newKey2 = rlc->idn + (checkinstance * 0.0001);
               if(( RB_newNode = RBExactQuery(Check_RB_Tree,&RB_newKey2)) == 0)
                  {
                  RB_cond = (struct ConditionCollection *) (malloc(SzCC));
               
                  if(RB_cond == NULL)
                     {
                     printf("memory has been exhausted during RB-Tree information alloction for NOENDCON analysis\n");
                     exit(-1);
                     }
                  RB_cond->keyval = NOENDCON;
                  RB_cond->Cnumber =  Make_Correct(NOENDCON,checkinstance);
                  RB_cond->index_from_to = NULL;
                  RB_cond->gform = G_LINE;
                  RB_cond->featureidn = rlc->featureid;
                  if(foundobject == 0)
                     RB_cond->counter = 0;
                  else
                     RB_cond->counter = 1;
                  RB_cond->radius = -1;
                  RB_cond->height = -1;
                  RB_cond->magnitude = 0.0;
                  RB_cond->IDN = rlc->idn;
                  RB_cond->localID = rlc->localID;
                  RB_cond->Sindex = rlc->Sindex;
                  RB_cond->Lindex = rlc->Lindex;
               
                  RB_cond->numnodes = 3;
                  RB_cond->x = (double *) (malloc(3 * SzD));
                  RB_cond->y = (double *) (malloc(3 * SzD));
                  RB_cond->z = (double *) (malloc(3 * SzD));
                  RB_cond->x[0] = rlc->x[0];
                  RB_cond->y[0] = rlc->y[0];
                  RB_cond->z[0] = rlc->z[0];
                  RB_cond->x[1] = rlc->x[rlc->numnodes-2];
                  RB_cond->y[1] = rlc->y[rlc->numnodes-2];
                  RB_cond->z[1] = rlc->z[rlc->numnodes-2];
                  RB_cond->x[2] = rlc->x[rlc->numnodes-1];
                  RB_cond->y[2] = rlc->y[rlc->numnodes-1];
                  RB_cond->z[2] = rlc->z[rlc->numnodes-1];

                  if(RB_cond->z == NULL)
                     {
                     printf("memory has been exhausted during RB-Tree element vertex alloction for NOENDCON analysis\n");
                     exit(-1);
                     }
                  unuseddbl = rlc->x[0];
                  for(jj=0; jj< rlc->numnodes; jj++)
                     {
                     if(rlc->x[jj] > unuseddbl)
                        unuseddbl = rlc->x[jj];
                     }
                  ii5 = (int) (unuseddbl / RegionSize) + 1;

                  RB_cond->radius = ii5;
                  
               
                  RB_newDbl = (double *) (malloc(SzD));
                  if(RB_newDbl == NULL)
                     {
                     printf("memory has been exhausted during RB-Tree alloction for NOENDCON analysis\n");
                     exit(-1);
                     }
                  *RB_newDbl = RB_newKey2; /**rac->localID; **/
                  RBTreeInsert(Check_RB_Tree,RB_newDbl, RB_cond);
                  }
               else
                  {
                  RB_cond = (struct ConditionCollection *) RB_newNode->info;
                  if((RB_cond != NULL) && (foundobject == 1))
                     {
                     RB_cond->counter = 1;
                     }
                  }

               i = 0;
               found_one = 0; 
               while((foundobject == 0) && (i < rlc->numnodes))
                  {
                  found_one = 0;
                  if((rlc->x[i] >= minx) && (rlc->x[i] <= maxx) && (rlc->y[i] >= miny) && (rlc->y[i] <= maxy))
                     {
                     found_one = 1;
                     if(i == 0)
                        {
                        j = ConditionOnDataEdge(rlc->x[1],rlc->y[1],rlc->x[0],rlc->y[0],Aroot,Proot,root,
                                       NULL, NULL, rlc,
                                       NorthCount,SouthCount,EastCount,WestCount,checkinstance);

                        if(j <= 0)
                           found_one = 3;
                        }
                     else
                        {
                        j = ConditionOnDataEdge(rlc->x[i],rlc->y[i],rlc->x[i-1],rlc->y[i-1],Aroot,Proot,root,
                                       NULL, NULL, rlc,
                                       NorthCount,SouthCount,EastCount,WestCount,checkinstance);

                        if(j <= 0)
                           found_one = 3;
                        }

                     rln = root;
                     while((rln != NULL) && (found_one < 2))
                        {
                        if(rln != rlc)
                           {
                           Config2 = SCCtable[rln->Sindex].C;
                           Strat2 = SCCtable[rln->Sindex].S;
                           Domain2 = SCCtable[rln->Sindex].D;
                           if(CombinedCheckApplies(rln->idn,checkinstance,NOENDCON,rln->Lindex,rln->Sindex,
                                                    Config2,Strat2,Domain2,&part1,&part2,&part3) > 0)
                              {
                              if(part3 > 0)
                                 {
                                 jj = 0;
                                 j = 1;
                                 while(j < rln->numnodes)
                                    {
                                    if((jj == 0) && (rln->x[jj] >= minx) && (rln->x[jj] <= maxx) &&
                                           (rln->y[jj] >= miny) && (rln->y[jj] <= maxy))
                                       {
                                       ptpdist1 = PointToLineDist(rlc->x[i], rlc->y[i], rlc->z[i],
                                               rln->x[jj], rln->y[jj], rln->z[jj], rln->x[j], rln->y[j], rln->z[j]);
                                       if(SensitivityCheck(LTEQ,NOENDCON,checkinstance,ptpdist1) > 0)
                                          {
                                          found_one = 2;
                                          break;
                                          }
                                       }

                                    if((rln->x[j] >= minx) && (rln->x[j] <= maxx) &&
                                               (rln->y[j] >= miny) && (rln->y[j] <= maxy))
                                       {
                                       ptpdist1 = PointToLineDist(rlc->x[i], rlc->y[i], rlc->z[i],
                                                rln->x[jj], rln->y[jj], rln->z[jj], rln->x[j], rln->y[j], rln->z[j]);
                                       if(SensitivityCheck(LTEQ,NOENDCON,checkinstance,ptpdist1) > 0)
                                          {
                                          found_one = 2;
                                          break;
                                          }
                                       }
                                    jj = j;
                                    j += 1;
                                    }
                                 }
                              }
                           }
                        if(found_one > 1)
                           break;
                        rln = rln->next;
                        } /*** end while rln ***/
                     if(found_one < 2)
                        {
                        rpc = Proot;
                        while(rpc != NULL)
                           {
                           if(CombinedCheckApplies(rpc->idn,checkinstance,NOENDCON,rpc->Lindex,rpc->Sindex,
                                                   SCCtable[rpc->Sindex].C, SCCtable[rpc->Sindex].S, SCCtable[rpc->Sindex].D,
                                                   &part1,&part2,&part3) > 0)
                              {
                              if(part3 > 0)
                                 {
                                 ptpdist1 = Distance3D(rlc->x[i],rlc->y[i],rlc->z[i],rpc->x[0],rpc->y[0],rpc->z[0]);
                                 if(SensitivityCheck(LTEQ,NOENDCON,checkinstance,ptpdist1) > 0)
                                    {
                                    found_one = 2;
                                    break;
                                    }
                                 }
                              }
                           rpc = rpc->next;
                           }
                        } /** end checking for dist to point since no connect to another line ***/

                     if(found_one < 2)
                        {
                        rac = Aroot;
                        while(rac != NULL)
                           {
                           if(CombinedCheckApplies(rac->idn,checkinstance,NOENDCON,rac->Lindex,rac->Sindex,
                                                   SCCtable[rac->Sindex].C, SCCtable[rac->Sindex].S, SCCtable[rac->Sindex].D,
                                                   &part1,&part2,&part3) > 0)
                              {
                              if(part3 > 0)
                                 {
                                 ptpdist1 = PointToArealEdgeDist2D(rlc->x[i], rlc->y[i], rac, &kk);
                                 if(SensitivityCheck(LTEQ,NOENDCON,checkinstance,ptpdist1) > 0)
                                    {
                                    found_one = 2;
                                    break;
                                    }
                                 }
                              }
                           rac = rac->next;
                           }
                        } /** end checking for dist to area edge since no connect to another line or point ***/
                     } /*** end is in this load module ***/
                  if(found_one >= 1) /*** end node is in this LM***/
                     {
                     RB_newKey2 = rlc->idn + (checkinstance * 0.0001);
                     if(( RB_newNode = RBExactQuery(Check_RB_Tree,&RB_newKey2)) == 0)
                        {
                        printf("failed to find the RB-tree for NOENDCON - fatal error\n");
                        exit(-1);
                        }
                     RB_cond = (struct ConditionCollection *) RB_newNode->info;
                     if((RB_cond != NULL) && (RB_cond->counter == 0) && (found_one > 1))
                        {
                        RB_cond->counter = 1;
                        }
                        
                     }
                  i += (rlc->numnodes - 1);
                  } /*** end while i < rlc->numnodews ***/
               }
            } /*** end NOENDCON check ***/




         if(CombinedCheckApplies(rlc->idn,checkinstance,ENCONFAIL,rlc->Lindex,rlc->Sindex,Config1,Strat1,Domain1,&part1,&part2,&part3) > 0)
            {
            if(part1 > 0)
               {
               i = 0;
               found_one = 1;
               while(i < rlc->numnodes)
                  {
                  found_one = 1;
                  if((rlc->x[i] >= minx) && (rlc->x[i] <= maxx) && (rlc->y[i] >= miny) && (rlc->y[i] <= maxy))
                     {
                     found_one = 0;
                     rln = root;
                     while(rln != NULL)
                        {
                        if(rln != rlc)
                           {
                           Config2 = SCCtable[rln->Sindex].C;
                           Strat2 = SCCtable[rln->Sindex].S;
                           Domain2 = SCCtable[rln->Sindex].D;
                           if(CombinedCheckApplies(rln->idn,checkinstance,ENCONFAIL,rln->Lindex,rln->Sindex,
                                                    Config2,Strat2,Domain2,&part1,&part2,&part3) > 0)
                              {
                              if(part2 > 0)
                                 {
                                 j = 0;
                                 while(j < rln->numnodes)
                                    {
                                    if((rln->x[j] >= minx) && (rln->x[j] <= maxx) && (rln->y[j] >= miny) && (rln->y[j] <= maxy))
                                       {
                                       ptpdist1 = Distance3D(rlc->x[i],rlc->y[i],rlc->z[i],rln->x[j],rln->y[j],rln->z[j]);
                                       if(SensitivityCheck(LTEQ,ENCONFAIL,checkinstance,ptpdist1) > 0)
                                          {
                                          found_one = 1;
                                          break;
                                          }
                                       }
                                    j += (rln->numnodes - 1);
                                    }
                                 }
                              }
                           }
                        if(found_one > 0)
                           break;
                        rln = rln->next;
                        } /*** end while rln ***/
                     } /*** end is in this load module ***/
                  if(found_one == 0)
                     {
                     j = ConditionOnDataEdge(rlc->x[i],rlc->y[i],rlc->x[i],rlc->y[i],Aroot,Proot,root,
                        NULL, NULL, rlc,
                        NorthCount,SouthCount,EastCount,WestCount,checkinstance);
                     if(j <= 0)
                       ++found_one;
                     }
                  if(found_one == 0) /*** could not find the requisite end node match ***/
                     {
                     ERc = (struct collection *) (malloc(SzC));
                     if(ERc == NULL)
                        {
                        printf("allocation memory exhausted during linear feature condition analysis\n");
                        printf("processing cannot continue\n");
                        exit(-1);
                        }
                     ERc->x[0] = rlc->x[i];
                     ERc->y[0] = rlc->y[i];
                     ERc->z[0] = rlc->z[i];
   
                     ERc->x[1] = rlc->x[i];
                     ERc->y[1] = rlc->y[i];
                     ERc->z[1] = rlc->z[i];

                     if(i == 0)
                        {
                        ERc->x[2] = rlc->x[1];
                        ERc->y[2] = rlc->y[1];
                        ERc->z[2] = rlc->z[1];
                        }
                     else
                        {
                        ERc->x[2] = rlc->x[i-1];
                        ERc->y[2] = rlc->y[i-1];
                        ERc->z[2] = rlc->z[i-1];
                        }

                     ERc->keyval = ENCONFAIL;
                     ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                     ERc->ll1 = rlc;
                     ERc->ll2 = rlc;
                     ERc->Sindex = rlc->Sindex;
                     ERc->next = NULL;
                     if(ERroot == NULL)
                        {
                        ERroot = ERc;
                        }
                     else
                        {
                        ERn = ERroot;
                        while(ERn != NULL)
                           {
                           if((ERn->Cnumber == ERc->Cnumber) && (ERn->keyval == ERc->keyval) && (ERn->ll1 == ERc->ll1) &&
                              (ERn->x[0] == ERc->x[0]) && (ERn->y[0] == ERc->y[0]) && (ERn->Sindex == ERc->Sindex) &&
                              (ERn->z[0] == ERc->z[0]))
                              break;
                           ERn = ERn->next;
                           }
                        if(ERn == NULL)
                           {
                           ERc->next = ERroot;
                           ERroot = ERc;
                           }
                        else
                           free(ERc);
                        }
                     }
                  i += (rlc->numnodes - 1);
                  } /*** end while i < rlc->numnodews ***/
               }
            }




         if(CombinedCheckApplies(rlc->idn,checkinstance,LENOCOVERL,rlc->Lindex,rlc->Sindex,Config1,Strat1,Domain1,&part1,&part2,&part3) > 0)
            {
            if(part1 > 0)
               {
               i = 0;
               while(i < rlc->numnodes)
                  {
                  mindist = 1000000.0;
                  isclose = 0;
                  j = ConditionOnDataEdge(rlc->x[i],rlc->y[i],rlc->x[i],rlc->y[i],Aroot,Proot,root,
                        NULL, NULL, rlc,
                        NorthCount,SouthCount,EastCount,WestCount,checkinstance);

                  if((j > 0) && (rlc->x[i] >= minx) && (rlc->x[i] <= maxx) && (rlc->y[i] >= miny) && (rlc->y[i] <= maxy))
                     {
                     rln = root;
                     while(rln != NULL)
                        {
                        if(rln != rlc)
                           {
                           if((CombinedCheckApplies(rln->idn,checkinstance,LENOCOVERL,rln->Lindex,rln->Sindex,
                                 SCCtable[rln->Sindex].C,SCCtable[rln->Sindex].S,SCCtable[rln->Sindex].D,&part1,&part2,&part3) > 0) &&
                                     (part2 > 0))
                              {
                              jj = 0;
                              for(j=1; j<rln->numnodes; j++)
                                 {
                                 ptldist = PointToLineDist(rlc->x[i], rlc->y[i], rlc->z[i], rln->x[jj], rln->y[jj], rln->z[jj], rln->x[j], rln->y[j], rln->z[j]);
                                 jj = j;
                                 if(ptldist < mindist)
                                    {
                                    mindist = ptldist;
                                    isclose = SensitivityCheck(LTEQ, LENOCOVERL, checkinstance, mindist);
                                    if(isclose > 0)
                                       break;
                                    }
                                 }
                              }

                           else if(part3 > 0)
                              {
                              jj = rln->numnodes - 1;
                              for(j=1; j<jj; j++)
                                 {
                                 ptldist = Distance3D(rlc->x[i],rlc->y[i],rlc->z[i],rln->x[j],rln->y[j],rln->z[j]);
                                 if(ptldist < mindist)
                                    {
                                    mindist = ptldist;
                                    isclose = SensitivityCheck(LTEQ, LENOCOVERL, checkinstance, mindist);
                                    if(isclose > 0)
                                       break;
                                    }
                                 }
                              }
                           }
                           
                        if(isclose > 0)
                           break;
                        rln = rln->next;
                        } /*** end while rln != NULL ***/
                     if(SensitivityCheck(GT, LENOCOVERL, checkinstance, mindist) > 0) /** record a condition ***/
                        {
                        ERc = (struct collection *) (malloc(SzC));
                        if(ERc == NULL)
                           {
                           printf("allocation memory exhausted during linear feature condition analysis\n");
                           printf("processing cannot continue\n");
                           exit(-1);
                           }
                        ERc->x[0] = rlc->x[i];
                        ERc->y[0] = rlc->y[i];
                        ERc->z[0] = rlc->z[i];
                        ERc->x[1] = rlc->x[i];
                        ERc->y[1] = rlc->y[i];
                        ERc->z[1] = rlc->z[i];

                        if(i == 0)
                           {
                           ERc->x[2] = rlc->x[1];
                           ERc->y[2] = rlc->y[1];
                           ERc->z[2] = rlc->z[1];
                           }
                        else
                           {
                           ERc->x[2] = rlc->x[i-1];
                           ERc->y[2] = rlc->y[i-1];
                           ERc->z[2] = rlc->z[i-1];
                           }

                        ERc->magnitude = mindist;
                        ERc->keyval = LENOCOVERL;
                        ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                        ERc->Sindex = rlc->Sindex;
                        ERc->ll1 = rlc;
                        ERc->ll2 = NULL;
                        ERc->next = NULL;
                        if(ERroot == NULL)
                           {
                           ERroot = ERc;
                           }
                        else
                           {
                           ERn = ERroot;
                           while(ERn != NULL)
                              {
                              if((ERn->Cnumber == ERc->Cnumber) && (ERn->keyval == ERc->keyval) && (ERn->ll1 == ERc->ll1) &&
                                 (ERn->x[0] == ERc->x[0]) && (ERn->y[0] == ERc->y[0]) && (ERn->Sindex == ERc->Sindex))
                                 {
                                 break;
                                 }
                              ERn = ERn->next;
                              }
                           if(ERn == NULL)
                              {
                              ERc->next = ERroot;
                              ERroot = ERc;
                              }
                           else
                              free(ERc);
                           }
                        } /** end record a condition ***/
                     } /*** end rlc end node is in LM ***/
                  i += rlc->numnodes - 1;
                  }
               } /*** end check applies to rlc as primary participant ***/
            } /*** end LENOCOVERL check applies to rlc ***/



        if(CombinedCheckApplies(rlc->idn,checkinstance,NOLCOVLE,rlc->Lindex,rlc->Sindex,Config1,Strat1,Domain1,&part1,&part2,&part3) > 0)
            {
            if(part1 > 0)
               {
               i = 0;
               while(i < rlc->numnodes)
                  {
                  mindist = 1000000.0;
                  isclose = 0;
                  j = ConditionOnDataEdge(rlc->x[i],rlc->y[i],rlc->x[i],rlc->y[i],Aroot,Proot,root,
                        NULL, NULL, rlc,
                        NorthCount,SouthCount,EastCount,WestCount,checkinstance);

                  if((j > 0) && (rlc->x[i] >= minx) && (rlc->x[i] <= maxx) && (rlc->y[i] >= miny) && (rlc->y[i] <= maxy))
                     {
                     rln = root;
                     while(rln != NULL)
                        {
                        if(rln != rlc)
                           {
                           if((CombinedCheckApplies(rln->idn,checkinstance,NOLCOVLE,rln->Lindex,rln->Sindex,
                                 SCCtable[rln->Sindex].C,SCCtable[rln->Sindex].S,SCCtable[rln->Sindex].D,&part1,&part2,&part3) > 0) &&
                                     (part2 > 0))
                              {
                              jj = 0;
                              for(j=1; j<rln->numnodes; j++)
                                 {
                                 ptldist = PointToLineDist(rlc->x[i], rlc->y[i], rlc->z[i], rln->x[jj], rln->y[jj], rln->z[jj], rln->x[j], rln->y[j], rln->z[j]);
                                 jj = j;
                                 if(ptldist < mindist)
                                    {
                                    mindist = ptldist;
                                    isclose = SensitivityCheck(LTEQ, NOLCOVLE, checkinstance, mindist);
                                    if(isclose > 0)
                                       break;
                                    }
                                 }
                              }
                           }
                        else if(rlc->numnodes > 2) /** so checking rlc against itself, rln = rlc ***/
                           {
                           if(i == 0)
                              {
                              jj = 1;
                              for(j=2; j<rln->numnodes; j++)
                                 {
                                 ptldist = PointToLineDist(rlc->x[i], rlc->y[i], rlc->z[i], rln->x[jj], rln->y[jj], rln->z[jj], rln->x[j], rln->y[j], rln->z[j]);
                                 jj = j;
                                 if(ptldist < mindist)
                                    {
                                    mindist = ptldist;
                                    isclose = SensitivityCheck(LTEQ, NOLCOVLE, checkinstance, mindist);
                                    if(isclose > 0)
                                       break;
                                    }
                                 }
                              }
                           else
                              {
                              jj = 0;
                              for(j=1; j<(rln->numnodes - 1); j++)
                                 {
                                 ptldist = PointToLineDist(rlc->x[i], rlc->y[i], rlc->z[i], rln->x[jj], rln->y[jj], rln->z[jj], rln->x[j], rln->y[j], rln->z[j]);
                                 jj = j;
                                 if(ptldist < mindist)
                                    {                                     mindist = ptldist;
                                    isclose = SensitivityCheck(LTEQ, NOLCOVLE, checkinstance, mindist);
                                    if(isclose > 0)
                                       break;
                                    }
                                 }
                              }
                           }
                        if(isclose > 0)
                           break;
                        rln = rln->next;
                        } /*** end while rln != NULL ***/
                     if(SensitivityCheck(GT, NOLCOVLE, checkinstance, mindist) > 0) /** record a condition ***/
                        {
                        ERc = (struct collection *) (malloc(SzC));
                        if(ERc == NULL)
                           {
                           printf("allocation memory exhausted during linear feature condition analysis\n");
                           printf("processing cannot continue\n");
                           exit(-1);                            }
                        ERc->x[0] = rlc->x[i];
                        ERc->y[0] = rlc->y[i];
                        ERc->z[0] = rlc->z[i];
                        ERc->x[1] = rlc->x[i];
                        ERc->y[1] = rlc->y[i];
                        ERc->z[1] = rlc->z[i];

                        if(i == 0)
                           {
                           ERc->x[2] = rlc->x[1];
                           ERc->y[2] = rlc->y[1];
                           ERc->z[2] = rlc->z[1];
                           }
                        else
                           {
                           ERc->x[2] = rlc->x[i-1];
                           ERc->y[2] = rlc->y[i-1];
                           ERc->z[2] = rlc->z[i-1];
                           }

                        ERc->magnitude = mindist;
                        ERc->keyval = NOLCOVLE;
                        ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                        ERc->Sindex = rlc->Sindex;
                        ERc->ll1 = rlc;
                        ERc->ll2 = NULL;
                        ERc->next = NULL;
                        if(ERroot == NULL)
                           {
                           ERroot = ERc;
                           }
                        else
                           {
                           ERn = ERroot;
                           while(ERn != NULL)
                              {
                              if((ERn->Cnumber == ERc->Cnumber) && (ERn->keyval == ERc->keyval) && (ERn->ll1 == ERc->ll1) &&
                                 (ERn->x[0] == ERc->x[0]) && (ERn->y[0] == ERc->y[0]) && (ERn->Sindex == ERc->Sindex))
                                 {
                                 break;
                                 }
                              ERn = ERn->next;
                              }
                           if(ERn == NULL)
                              {
                              ERc->next = ERroot;
                              ERroot = ERc;
                              }
                           else
                              free(ERc);
                           }
                        } /** end record a condition ***/
                     } /*** end rlc end node is in LM ***/
                  i += rlc->numnodes - 1;
                  }
               } /*** end check applies to rlc as primary participant ***/
            } /*** end NOLCOVLE check applies to rlc ***/




         if(CombinedCheckApplies(rlc->idn,checkinstance,LENOCOVERP,rlc->Lindex,rlc->Sindex,Config1,Strat1,Domain1,&part1,&part2,&part3) > 0)
            {
            if(part1 > 0)
               {
               i = 0;
               while(i < rlc->numnodes)
                  {
                  j = ConditionOnDataEdge(rlc->x[i],rlc->y[i],rlc->x[i],rlc->y[i],Aroot,Proot,root,
                        NULL, NULL, rlc,
                        NorthCount,SouthCount,EastCount,WestCount,checkinstance);

                  if((j > 0) && (rlc->x[i] >= minx) && (rlc->x[i] <= maxx) && (rlc->y[i] >= miny) && (rlc->y[i] <= maxy))
                     {
                     ptpdist1 =  ActiveChecks[checkinstance].sensitivity * 10.0;
                     rpc = Proot;
                     while(rpc != NULL)
                        {
                        if(rpc->numverts == -1)
                           {
                           Config2 = SCCtable[rpc->Sindex].C;
                           Strat2 = SCCtable[rpc->Sindex].S;
                           Domain2 = SCCtable[rpc->Sindex].D;
                           if(CombinedCheckApplies(rpc->idn,checkinstance,LENOCOVERP,rpc->Lindex,rpc->Sindex,Config2,Strat2,Domain2,&part1,&part2,&part3) > 0)
                              {
                              if(part2 > 0)
                                 {
                                 ptpdist1 = Distance3D(rlc->x[i],rlc->y[i],rlc->z[i],rpc->x[0],rpc->y[0],rpc->z[0]);
                                 if(SensitivityCheck(LTEQ,LENOCOVERP,checkinstance,ptpdist1) > 0)
                                    break;  /** should break from the while rpc loop with rpc != NULL ***/
                                 }
                              }
                           }
                        rpc = rpc->next;
                        }
                     if(rpc == NULL) /** could not find an associated point ***/
                        {
                        ERc = (struct collection *) (malloc(SzC));
                        if(ERc == NULL)
                           {
                           printf("allocation memory exhausted during linear feature condition analysis\n");
                           printf("processing cannot continue\n");
                           exit(-1);
                           }
                        ERc->x[0] = rlc->x[i];
                        ERc->y[0] = rlc->y[i];
                        ERc->z[0] = rlc->z[i];

                        ERc->x[1] = rlc->x[i];
                        ERc->y[1] = rlc->y[i];
                        ERc->z[1] = rlc->z[i];

                        if(i == 0)
                           {
                           ERc->x[2] = rlc->x[1];
                           ERc->y[2] = rlc->y[1];
                           ERc->z[2] = rlc->z[1];
                           }
                        else
                           {
                           ERc->x[2] = rlc->x[i-1];
                           ERc->y[2] = rlc->y[i-1];
                           ERc->z[2] = rlc->z[i-1];
                           }

                        ERc->keyval = LENOCOVERP;
                        ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                        ERc->ll1 = rlc;
                        ERc->ll2 = rlc;
                        ERc->Sindex = rlc->Sindex;
                        ERc->next = NULL;
                        if(ERroot == NULL)
                           {
                           ERroot = ERc;
                           }
                        else
                           {
                           ERn = ERroot;
                           while(ERn != NULL)
                              {
                              if(
                                 (ERn->Cnumber    == ERc->Cnumber)    &&
                                 (ERn->keyval    == ERc->keyval)    &&
                                 (ERn->ll1       == ERc->ll1)       &&
                                 (ERn->Sindex    == ERc->Sindex)    &&
                                 (ERn->x[0]      == ERc->x[0])      &&
                                 (ERn->y[0]      == ERc->y[0])      &&
                                 (ERn->z[0]      == ERc->z[0])
                                 )
                                 break;
                              ERn = ERn->next;
                              }
                           if(ERn == NULL)
                              {
                              ERc->next = ERroot;
                              ERroot = ERc;
                              }
                           else
                              free(ERc);
                           }
                        }
                     }
                  i += (rlc->numnodes - 1);
                  }
               }
            }





         if(CombinedCheckApplies(rlc->idn,checkinstance,L2D_L3D_MATCH,rlc->Lindex,rlc->Sindex,Config1,Strat1,Domain1,&part1,&part2,&part3) > 0)
            {
            if(part1 > 0)
               {
               nodeindex = 0;
               while(nodeindex < rlc->numnodes)
                  {
                  if((rlc->x[nodeindex] >= minx) && (rlc->x[nodeindex] <= maxx) && (rlc->y[nodeindex] >= miny) && (rlc->y[nodeindex] <= maxy))
                     {
                     rln = root;
                     while(rln != NULL)
                        {
                        Config2 = SCCtable[rln->Sindex].C;
                        Strat2 = SCCtable[rln->Sindex].S;
                        Domain2 = SCCtable[rln->Sindex].D;
                        if((rln != rlc) && (CombinedCheckApplies(rln->idn,checkinstance,L2D_L3D_MATCH,rln->Lindex,rln->Sindex,Config2,Strat2,Domain2,&part1,&part2,&part3) > 0))
                           {
                           if(part2 > 0)
                              {
                              j = 0; /** check against first end node of rln ***/
                              while(j < rln->numnodes)
                                 {
                                 if((rln->x[j] >= minx) && (rln->x[j] <= maxx) && (rln->y[j] >= miny) && (rln->y[j] <= maxy))
                                    {
                                    ptpdist1 = Distance(rlc->x[nodeindex],rlc->y[nodeindex],rln->x[j],rln->y[j]);
                                    if(ptpdist1 < 0.00001) /** consider the two nodes as matching in 2D ***/
                                       {
                                       part3 = 0;
                                       if(tempis2D(rlc->z[nodeindex]) > 0)
                                          {
                                          part3 = 1;
                                          }
                                       else if(IsSentinelZvalue(rlc->z[nodeindex],UseNUNANPO) > 0)
                                          {
                                          part3 = -200; /*** force a non-use of this value ***/
                                          }
                                       else
                                          {
                                          ptpdist2 = rlc->z[nodeindex];
                                          }
                                       if(tempis2D(rln->z[j]) > 0)
                                          {
                                          ++part3;
                                          }
                                       else if(IsSentinelZvalue(rln->z[j],UseNUNANPO) > 0)
                                          {
                                          part3 = -200; /*** force a non-use of this value ***/
                                          }
                                       else
                                          {
                                          ptpdist2 = rln->z[j]; 
                                          }
 
                                       if(part3 == 1) /** should be one is 2D, one is 3D ***/
                                          {
                                          ZMNc = (struct ZmismatchNodes *) (malloc(SzZMN));
                                          if(ZMNc == NULL)
                                             {
                                             printf("available memory has been exhausted during analysis of Z-mismatch linear end nodes\n");
                                             exit(-1);
                                             }
                                          ZMNc->x[0] = rlc->x[nodeindex];
                                          ZMNc->y[0] = rlc->y[nodeindex];
                                          ZMNc->z[0] = rlc->z[nodeindex];
                                          ZMNc->x[1] = rln->x[j];
                                          ZMNc->y[1] = rln->y[j];
                                          ZMNc->z[1] = rln->z[j];
                                          ZMNc->IDN1 = rlc->idn;
                                          ZMNc->IDN2 = rln->idn;
                                          ZMNc->mismatchdist = ptpdist2;
                                          ZMNc->owner1 = rlc;
                                          ZMNc->owner2 = rln;
                                          ZMNc->Sindex1 = rlc->Sindex;
                                          ZMNc->Sindex2 = rln->Sindex;
                                          ZMNc->keyval = L2D_L3D_MATCH;
                                          ZMNc->Cnumber = Make_Correct(L2D_L3D_MATCH,checkinstance);
                                          if(ZMNroot == NULL)
                                             {
                                             ZMNc->next = NULL;
                                             ZMNroot = ZMNc;
                                             }
                                          else
                                             {
                                             keepit = 1;
                                             ZMNp = ZMNroot;
                                             while(ZMNp != NULL)
                                                {
                                                if((ZMNc->mismatchdist == ZMNp->mismatchdist) &&
                                                      (ZMNp->owner1 == ZMNc->owner1) && (ZMNp->owner2 == ZMNc->owner2))
                                                   {
                                                   if((ZMNc->x[0] == ZMNp->x[0]) && (ZMNc->y[0] == ZMNp->y[0]) && (ZMNc->z[0] == ZMNp->z[0]))
                                                      {
                                                      if((ZMNc->x[1] == ZMNp->x[1]) && (ZMNc->y[1] == ZMNp->y[1]) && (ZMNc->z[1] == ZMNp->z[1]))
                                                         {
                                                         keepit = 0;
                                                         break;
                                                         }
                                                      }
                                                   }
                                                else if((ZMNc->mismatchdist == ZMNp->mismatchdist) &&
                                                      (ZMNp->owner1 == ZMNc->owner2) && (ZMNp->owner2 == ZMNc->owner1))
                                                   {
                                                   if((ZMNc->x[1] == ZMNp->x[0]) && (ZMNc->y[1] == ZMNp->y[0]) && (ZMNc->z[1] == ZMNp->z[0]))
                                                      {
                                                      if((ZMNc->x[0] == ZMNp->x[1]) && (ZMNc->y[0] == ZMNp->y[1]) && (ZMNc->z[0] == ZMNp->z[1]))
                                                         {
                                                         keepit = 0;
                                                         break;
                                                         }
                                                      }
                                                   }
                                                ZMNp = ZMNp->next;
                                                }
                                             if(keepit > 0)
                                                {
                                                ZMNc->next = ZMNroot;
                                                ZMNroot = ZMNc;
                                                }
                                             else
                                                {
                                                free(ZMNc);
                                                }
                                             }
                                          }
                                       }
                                    }
                                 j += (rln->numnodes - 1);
                                 }
                              }
                           }
                        rln = rln->next;
                        }
                     }
                  nodeindex += (rlc->numnodes - 1);
                  }
               }
            }



         if(CombinedCheckApplies(rlc->idn,checkinstance,LEZ_PROX_3D,rlc->Lindex,rlc->Sindex,Config1,Strat1,Domain1,&part1,&part2,&part3) > 0)
            {
            if(part1 > 0)
               {
               nodeindex = 0;
               i_partner = 1;
               foundpair = 0;
               rlnsave = NULL;
               while(nodeindex < rlc->numnodes)
                  {
                  if((IsSentinelZvalue(rlc->z[nodeindex],UseNUNANPO) == 0) &&
                      (rlc->x[nodeindex] >= minx) && (rlc->x[nodeindex] <= maxx) && (rlc->y[nodeindex] >= miny) && (rlc->y[nodeindex] <= maxy))
                     {
                     rln = root; 
                     while(rln != NULL)
                        {
                        if(rln == rlc)
                           {
                           rln = rln->next;
                           if(rln == NULL)
                              break;
                           }
                        Config2 = SCCtable[rln->Sindex].C;
                        Strat2 = SCCtable[rln->Sindex].S;
                        Domain2 = SCCtable[rln->Sindex].D;
                        minLx = rlc->x[nodeindex] - 10.0;
                        maxLx = rlc->x[nodeindex] + 10.0;
                        minLy = rlc->y[nodeindex] - 10.0;
                        maxLy = rlc->y[nodeindex] + 10.0;
                        if((rln != rlc) && (CombinedCheckApplies(rln->idn,checkinstance,LEZ_PROX_3D,rln->Lindex,rln->Sindex,Config2,Strat2,Domain2,&part1,&part2,&part3) > 0))
                           {
                           if(part2 > 0)
                              {
                              j = 0; /** check against first end node of rln ***/
                              j_partner = 1;
                              while(j < rln->numnodes)
                                 {
                                 if((IsSentinelZvalue(rln->z[j],UseNUNANPO) == 0) &&
                                      (rln->x[j] >= minLx) && (rln->x[j] <= maxLx) && (rln->y[j] >= minLy) && (rln->y[j] <= maxLy))
                                    {
                                    ptpdist1 = Distance(rlc->x[nodeindex],rlc->y[nodeindex],rln->x[j],rln->y[j]);
                                    if(ptpdist1 < 0.00001) /** consider the two nodes as matching in 2D ***/
                                       {
                                       if(rlc->z[nodeindex] > rln->z[j])
                                          ptpdist2 = rlc->z[nodeindex] - rln->z[j];
                                       else
                                          ptpdist2 = rln->z[j] - rlc->z[nodeindex];
                                   
                                       if((SensitivityCheck(GT, LEZ_PROX_3D, checkinstance, ptpdist2) > 0) &&
                                          ((ptpdist2 < ActiveChecks[checkinstance].sensitivity2) || 
                                                                              (ptpdist2 > ActiveChecks[checkinstance].sensitivity3)))
                                          {



                  ZMNc = (struct ZmismatchNodes *) (malloc(SzZMN));
                  if(ZMNc == NULL)
                     {
                     printf("available memory has been exhausted during analysis of Z-mismatch linear end nodes\n");
                     exit(-1);
                     }
                  ZMNc->x[0] = rlc->x[nodeindex];
                  ZMNc->y[0] = rlc->y[nodeindex];
                  ZMNc->z[0] = rlc->z[nodeindex];
                  ZMNc->x[1] = rln->x[j];
                  ZMNc->y[1] = rln->y[j];
                  ZMNc->z[1] = rln->z[j];
                  ZMNc->IDN1 = rlc->idn;
                  ZMNc->IDN2 = rln->idn;
                  ZMNc->mismatchdist = ptpdist2;
                  ZMNc->owner1 = rlc;
                  ZMNc->owner2 = rln;
                  ZMNc->Sindex1 = rlc->Sindex;
                  ZMNc->Sindex2 = rln->Sindex;
                  ZMNc->keyval = LEZ_PROX_3D;
                  ZMNc->Cnumber = Make_Correct(LEZ_PROX_3D,checkinstance);
                  if(ZMNroot == NULL)
                     {
                     ZMNc->next = NULL;
                     ZMNroot = ZMNc;
                     }
                  else
                     {
                     keepit = 1;
                     ZMNp = ZMNroot;
                     while(ZMNp != NULL)
                        {
                        if((ZMNc->mismatchdist == ZMNp->mismatchdist) &&
                              (ZMNp->owner1 == ZMNc->owner1) && (ZMNp->owner2 == ZMNc->owner2))
                           {
                           if((ZMNc->x[0] == ZMNp->x[0]) && (ZMNc->y[0] == ZMNp->y[0]) && (ZMNc->z[0] == ZMNp->z[0]))
                              {
                              if((ZMNc->x[1] == ZMNp->x[1]) && (ZMNc->y[1] == ZMNp->y[1]) && (ZMNc->z[1] == ZMNp->z[1]))
                                 {
                                 keepit = 0;
                                 break;
                                 }
                              }
                           }
                        else if((ZMNc->mismatchdist == ZMNp->mismatchdist) &&
                              (ZMNp->owner1 == ZMNc->owner2) && (ZMNp->owner2 == ZMNc->owner1))
                           {
                           if((ZMNc->x[1] == ZMNp->x[0]) && (ZMNc->y[1] == ZMNp->y[0]) && (ZMNc->z[1] == ZMNp->z[0]))
                              {
                              if((ZMNc->x[0] == ZMNp->x[1]) && (ZMNc->y[0] == ZMNp->y[1]) && (ZMNc->z[0] == ZMNp->z[1]))
                                 {
                                 keepit = 0;
                                 break;
                                 }
                              }
                           }
                        ZMNp = ZMNp->next;
                        }
                     if(keepit > 0)
                        {
                        ZMNc->next = ZMNroot;
                        ZMNroot = ZMNc;
                        }
                     else
                        {
                        free(ZMNc);
                        }
                     }

                                          }
                                          
                                       }
                                    }
                                 j += (rln->numnodes - 1);
                                 j_partner = j - 1;
                                 }
                              }
                           }
                        rln = rln->next;
                        }
                     }
                  nodeindex += (rlc->numnodes - 1);
                  i_partner = nodeindex - 1;
                  }
               }
            }


         if(CombinedCheckApplies(rlc->idn,checkinstance,LMINT,rlc->Lindex,rlc->Sindex,Config1,Strat1,Domain1,&part1,&part2,&part3) > 0)
            {
            if(part1 > 0)
               {
               rpc = Proot;
               while(rpc != NULL)
                  {
                  if((rpc->numverts >= 0) || /** excludes the domensionless point features & collision volumes **/
                      (rpc->numverts == -2) || /*** a spherical collision volume - has one point and radius **/
                      (rpc->numverts < -3)) /** number of points in parallelpiped collision volume ***/
                     {
                     Config2 = SCCtable[rpc->Sindex].C;
                     Strat2 = SCCtable[rpc->Sindex].S;
                     Domain2 = SCCtable[rpc->Sindex].D;
                     if(CombinedCheckApplies(rpc->idn,checkinstance,LMINT,rpc->Lindex,rpc->Sindex,Config2,Strat2,Domain2,&part1,&part2,&part3) > 0)
                        {
                        if((part2 > 0) && ((rpc->numverts > 1)  || /** only footprint models **/
                                          (rpc->numverts < -3))) /** ppiped coll volume ***/
                           {
                           for(i=1; i<rlc->numnodes; i++)
                              {
                              ii = i - 1;
                              x1 = rlc->x[ii];
                              y1 = rlc->y[ii];
                              z1 = rlc->z[ii];
                              x2 = rlc->x[i];
                              y2 = rlc->y[i];
                              z2 = rlc->z[i];
                              if(ClipLineToRegion(minx,miny,maxx,maxy,&x1,&y1,&z1,&x2,&y2,&z2,&clipflag,multiplier) > 0)
                                 {
                                 if(rpc->numverts < 0)
                                    vtxcnt = 0 - rpc->numverts;
                                 else
                                    vtxcnt = rpc->numverts;
                                 for(j=0; j<vtxcnt; j++)
                                    {
                                    jj = (j + 1) % vtxcnt;
                                    x3 = rpc->x[jj];
                                    y3 = rpc->y[jj];
                                    z3 = rpc->z[jj];
                                    x4 = rpc->x[j];
                                    y4 = rpc->y[j];
                                    z4 = rpc->z[j];
                                    if(LineSegmentsIntersect(x1,y1,x2,y2,x3,y3,x4,y4, &xi, &yi) > 0)
                                       {
                                       ERc = (struct collection *) (malloc(SzC));
                                       if(ERc == NULL)
                                          {
                                          printf("allocation memory exhausted during linear feature condition analysis\n");
                                          printf("processing cannot continue\n");
                                          exit(-1);
                                          }
                                       ERc->x[0] = xi;
                                       ERc->y[0] = yi;
                                       ERc->IDN = rlc->idn;
                                       ERc->magnitude = 0.0;
                                       ERc->keyval = LMINT;
                                       ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                                       ERc->Sindex = rlc->Sindex;
                                       ERc->ll1 = rlc;
                                       ERc->vertexindex1 = ii;
                                       ERc->pp = rpc;
                                       ERc->next = NULL;
                                       if(ERroot == NULL)
                                          {
                                          ERc->z[0] = InterpLinearElev(x1,y1,z1,x2,y2,z2,xi,yi);
                                          ERroot = ERc;
                                          }
                                       else
                                          {
                                          ERn = ERroot;
                                          while(ERn != NULL)
                                             {
                                             if(
						(ERn->Cnumber == ERc->Cnumber) &&
						(ERn->keyval == ERc->keyval) && 
						(ERn->x[0]   == ERc->x[0])   &&
						(ERn->y[0]   == ERc->y[0])   && 
						(ERn->Sindex == ERc->Sindex)
						)
                                                break;
                                             ERn = ERn->next;
                                             }
                                          if(ERn == NULL)
                                             {
                                             ERc->z[0] = InterpLinearElev(x1,y1,z1,x2,y2,z2,xi,yi);
                                             ERc->next = ERroot;
                                             ERroot = ERc;
                                             }
                                          else
                                             free(ERc);
                                          }
                                       }
                                    }
                                 }
                              }
                           }
                        else if((part2 > 0) && ((rpc->numverts == 0) ||  /** only stamp models **/
                                                  (rpc->numverts == -2))) /** spherical col vols **/
                           {
                           for(i=1; i<rlc->numnodes; i++)
                              {
                              ii = i - 1;
                              x1 = rlc->x[ii];
                              y1 = rlc->y[ii];
                              z1 = rlc->z[ii];
                              x2 = rlc->x[i];
                              y2 = rlc->y[i];
                              z2 = rlc->z[i];
                              if(ClipLineToRegion(minx,miny,maxx,maxy,&x1,&y1,&z1,&x2,&y2,&z2,&clipflag,multiplier) > 0)
                                 {
                                 ptldist = PointToLineDist2D(rpc->x[0],rpc->y[0],x1,y1,x2,y2);
                                 if(ptldist < (rpc->rad + 0.1))
                                    {
                                    LineEquation(rlc->x[ii],rlc->y[ii],rlc->x[i],rlc->y[i],&LA2,&LB2,&LC2);
                                    ImplicitLineToParametric(LA2, LB2, LC2, &X0, &Y0, &F, &G);
                                    LCIanswer = LineCircleIntersection(rpc->x[0],rpc->y[0],rpc->rad,X0,Y0,F,G,&xi,&yi,&xi2,&yi2);
                                    if(LCIanswer > 0)
                                       {
                                       if(Between(xi,yi,rlc->x[ii],rlc->y[ii],rlc->x[i],rlc->y[i]) > 0)
                                          {
                                          ERc = (struct collection *) (malloc(SzC));
                                          if(ERc == NULL)
                                             {
                                             printf("allocation memory exhausted during linear feature condition analysis\n");
                                             printf("processing cannot continue\n");
                                             exit(-1);
                                             }
                                          ERc->x[0] = xi;
                                          ERc->y[0] = yi;
                                          ERc->magnitude = 0.0;
                                          ERc->keyval = LMINT;
                                          ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                                          ERc->Sindex = rlc->Sindex;
                                          ERc->IDN = rlc->idn;
                                          ERc->ll1 = rlc;
                                          ERc->vertexindex1 = ii;
                                          ERc->pp = rpc;
                                          ERc->next = NULL;
                                          if(ERroot == NULL)
                                             {
                                             ERc->z[0] = InterpLinearElev(x1,y1,z1,x2,y2,z2,xi,yi);
                                             ERroot = ERc;
                                             }
                                          else
                                             {
                                             ERn = ERroot;
                                             while(ERn != NULL)
                                                {
                                                if(
                                                   (ERn->Cnumber == ERc->Cnumber) &&
                                                   (ERn->keyval == ERc->keyval) && 
                                                   (ERn->x[0]   == ERc->x[0])   &&
                                                   (ERn->y[0]   == ERc->y[0])   && 
                                                   (ERn->Sindex == ERc->Sindex)
                                                   )
                                                   break;
                                                ERn = ERn->next;
                                                }
                                             if(ERn == NULL)
                                                {
                                                ERc->z[0] = InterpLinearElev(x1,y1,z1,x2,y2,z2,xi,yi);
                                                ERc->next = ERroot;
                                                ERroot = ERc;
                                                }
                                             else
                                                free(ERc);
                                             }
                                          }
                                       if(Between(xi2,yi2,rlc->x[ii],rlc->y[ii],rlc->x[i],rlc->y[i]) > 0)
                                          {
                                          ERc = (struct collection *) (malloc(SzC));
                                          if(ERc == NULL)
                                             {
                                             printf("allocation memory exhausted during linear feature condition analysis\n");
                                             printf("processing cannot continue\n");
                                             exit(-1);
                                             }
                                          ERc->x[0] = xi2;
                                          ERc->y[0] = yi2;
                                          ERc->magnitude = 0.0;
                                          ERc->keyval = LMINT;
                                          ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                                          ERc->Sindex = rlc->Sindex;
                                          ERc->IDN = rlc->idn;
                                          ERc->ll1 = rlc;
                                          ERc->vertexindex1 = ii;
                                          ERc->pp = rpc;
                                          ERc->next = NULL;
                                          if(ERroot == NULL)
                                             {
                                             ERc->z[0] = InterpLinearElev(rlc->x[ii],rlc->y[ii],rlc->z[ii],rlc->x[i],rlc->y[i],rlc->z[i],xi2,yi2);
                                             ERroot = ERc;
                                             }
                                          else
                                             {
                                             ERn = ERroot;
                                             while(ERn != NULL)
                                                {
                                                if(
                                                   (ERn->Cnumber == ERc->Cnumber) &&
                                                   (ERn->keyval == ERc->keyval) &&
                                                   (ERn->x[0]   == ERc->x[0])   &&
                                                   (ERn->y[0]   == ERc->y[0])   &&
                                                   (ERn->Sindex == ERc->Sindex)
                                                   )
                                                   break;
                                                ERn = ERn->next;
                                                }
                                             if(ERn == NULL)
                                                {
                                                ERc->z[0] = InterpLinearElev(rlc->x[ii],rlc->y[ii],rlc->z[ii],rlc->x[i],rlc->y[i],rlc->z[i],xi2,yi2);
                                                ERc->next = ERroot;
                                                ERroot = ERc;
                                                }
                                             else
                                                free(ERc);
                                             }
                                          }
                                       } /*** end if LCIanswer ***/
                                    }
                                 }
                              }
                           }
                        }
                     }
                  rpc = rpc->next;
                  }
               }
            } /** end check LMINT #1 **/
   
         if(CombinedCheckApplies(rlc->idn,checkinstance,LMINT,rlc->Lindex,rlc->Sindex,Config1,Strat1,Domain1,&part1,&part2,&part3) > 0)
            {
            if(part1 > 0)
               {
               ec = PEroot;
               while(ec != NULL)
                  {
                  tpc = (struct ThePolys *) ec->owner;
                  Config2 = SCCtable[tpc->SCCindex].C;
                  Strat2 = SCCtable[tpc->SCCindex].S;
                  Domain2 = SCCtable[tpc->SCCindex].D;
                  if(CombinedCheckApplies(tpc->idn,checkinstance,LMINT,tpc->SACindex,tpc->SCCindex,Config2,Strat2,Domain2,&part1,&part2,&part3) > 0)
                     {
                     if((part2 > 0) && (rlc->numnodes > 1))
                        {
                        for(i=1; i<rlc->numnodes; i++)
                           {
                           ii = i - 1;
                           x1 = rlc->x[ii];
                           y1 = rlc->y[ii];
                           z1 = rlc->z[ii];
                           x2 = rlc->x[i];
                           y2 = rlc->y[i];
                           z2 = rlc->z[i];
                           if(ClipLineToRegion(minx,miny,maxx,maxy,&x1,&y1,&z1,&x2,&y2,&z2,&clipflag,multiplier) > 0)
                              {
                              if(LineSegmentsIntersect(x1,y1,x2,y2,ec->x1,ec->y1,ec->x2,ec->y2, &xi, &yi) > 0)
                                 {
                                 ERc = (struct collection *) (malloc(SzC));
                                 if(ERc == NULL)
                                    {
                                    printf("allocation memory exhausted during linear feature condition analysis\n");
                                    printf("processing cannot continue\n");
                                    exit(-1);
                                    }
                                 ERc->x[0] = xi;
                                 ERc->y[0] = yi;
                                 ERc->pp = NULL;
                                 ERc->magnitude = 0.0;
                                 ERc->keyval = LMINT;
                                 ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                                 ERc->Sindex = rlc->Sindex;
   
                                 ERc->poly = tpc;
                                 ERc->IDN = rlc->idn;
                                 ERc->ll1 = rlc;
                                 ERc->vertexindex1 = ii;
   
                                 ERc->next = NULL;
                                 if(ERroot == NULL)
                                    {
                                    ERc->z[0] = InterpLinearElev(x1,y1,z1,x2,y2,z2,xi,yi);
                                    ERc->x[1] = ec->x1;
                                    ERc->y[1] = ec->y1;
                                    ERc->z[1] = ec->z1;
                                    ERc->x[2] = ec->x2;
                                    ERc->y[2] = ec->y2;
                                    ERc->z[2] = ec->z2;
                                    ERroot = ERc;
                                    }
                                 else
                                    {
                                    ERn = ERroot;
                                    while(ERn != NULL)
                                       {
                                       if(
					  (ERn->Cnumber == ERc->Cnumber) &&
					  (ERn->keyval == ERc->keyval) && 
					  (ERn->x[0]   == ERc->x[0])   &&
					  (ERn->y[0]   == ERc->y[0])   && 
					  (ERn->IDN    == ERc->IDN)    && 
					  (ERn->ll1    == ERc->ll1)
					  )
                                          break;
                                       ERn = ERn->next;
                                       }
                                    if(ERn == NULL)
                                       {
                                       ERc->z[0] = InterpLinearElev(x1,y1,z1,x2,y2,z2,xi,yi);
                                       ERc->x[1] = ec->x1;
                                       ERc->y[1] = ec->y1;
                                       ERc->z[1] = ec->z1;
                                       ERc->x[2] = ec->x2;
                                       ERc->y[2] = ec->y2;
                                       ERc->z[2] = ec->z2;
                                       ERc->next = ERroot;
                                       ERroot = ERc;
                                       }
                                    else
                                       free(ERc);
                                    }
                                 }
                              }
                           }
                        }
                     }
                  ec = ec->next;
                  }
               }
            } /** end check LMINT #2 **/
   
   
   
         LEroot = NULL;
         if(CombinedCheckApplies(rlc->idn,checkinstance,LJOINSLOPEDC,rlc->Lindex,rlc->Sindex,Config1,Strat1,Domain1,&part1,&part2,&part3) > 0)
            {
            IgnoreDrawingSettings = 1;
            if(part1 > 0)
               {
               LEroot = NULL;
               basedist = 0.0;
               for(i=1; i<rlc->numnodes; i++)
                  {
                  ii = i - 1;
                  x1 = rlc->x[ii];
                  y1 = rlc->y[ii];
                  z1 = rlc->z[ii];
                  x2 = rlc->x[i];
                  y2 = rlc->y[i];
                  z2 = rlc->z[i];
                     LEn = (struct LineElevations *) (malloc(SzLE));
                     if(LEn == NULL)
                        {
                        printf("free memory available for allocation has been exhausted\n");
                        printf("processing cannot continue\n");
                        exit(-1);
                        }
                     if(LEroot == NULL)
                        {
                        LEc = (struct LineElevations *) (malloc(SzLE));
                        if(LEc == NULL)
                           {
                           printf("free memory available for allocation has been exhausted\n");
                           printf("processing cannot continue\n");
                           exit(-1);
                           }
                        LEc->dist = basedist;
                        LEc->x = x1;
                        LEc->y = y1;
                        if((NGA_TYPE == 0) && (CLAMPFEATURES > 0) && (GetPointElevation(x1,y1,&temp) > 0))
                           LEc->z = temp;
                        else /****if(CLAMPFEATURES == 0) ***/
                           LEc->z = z1;

                        LEc->parent = rlc;
                   
                        LEroot = LEc;
                        LEp = LEc;
                        LEc->next = LEn;
                        }
                     LEn->x = x2;
                     LEn->y = y2;
                     LEn->dist = LEp->dist + Distance(LEp->x,LEp->y,LEn->x,LEn->y);
                     if((NGA_TYPE == 0) && (CLAMPFEATURES > 0) && (GetPointElevation(x2,y2,&temp) > 0))
                        LEn->z = temp;
                     else /***if(CLAMPFEATURES == 0) ****/
                        LEn->z = z2;

                     LEn->parent = rlc;
                     LEn->next = NULL;
                        LEp->next = LEn;
                     LEp = LEn;
                  }
               LEroot2 = NULL;
               if((LEroot != NULL) && (LEp->x >= minx) && (LEp->x <= maxx) &&
                   (LEp->y >= miny) && (LEp->y <= maxy))
                  {
                  rln = root;
                  while(rln != NULL)
                     {
                     if(rln != rlc)
                        {
                        if((CombinedCheckApplies(rln->idn,checkinstance,LJOINSLOPEDC,rln->Lindex,rln->Sindex,
                               SCCtable[rln->Sindex].C, SCCtable[rln->Sindex].S, SCCtable[rln->Sindex].D,&part1,&part2,&part3) > 0) &&
                                (part2 > 0))
                           {
                           if((rln->x[0] == LEp->x) && (rln->y[0] == LEp->y) && (rln->z[0] == LEp->z))
                              {
                              LEn = (struct LineElevations *) (malloc(SzLE));
                              if(LEn == NULL)
                                 {
                                 printf("free memory available for allocation has been exhausted\n");
                                 printf("processing cannot continue\n");
                                 exit(-1);
                                 }
                              LEn->x = rln->x[1];
                              LEn->y = rln->y[1];
                              LEn->parent = rln;
                              LEn->dist = LEp->dist + Distance(LEp->x,LEp->y,LEn->x,LEn->y);
                              if((NGA_TYPE == 0) && (CLAMPFEATURES > 0) && (GetPointElevation(rln->x[1],rln->y[1],&temp) > 0))
                                 LEn->z = temp;
                              else /***if(CLAMPFEATURES == 0) ****/
                                 LEn->z = rln->z[1];
                              LEn->next = LEroot2;
                              LEroot2 = LEn;
                              }
                           else if((rln->x[rln->numnodes-1] == LEp->x) && (rln->y[rln->numnodes-1] == LEp->y) && (rln->z[rln->numnodes-1] == LEp->z))
                              {
                              LEn = (struct LineElevations *) (malloc(SzLE));
                              if(LEn == NULL)
                                 {
                                 printf("free memory available for allocation has been exhausted\n");
                                 printf("processing cannot continue\n");
                                 exit(-1);
                                 }
                              LEn->x = rln->x[rln->numnodes-2];
                              LEn->y = rln->y[rln->numnodes-2];
                              LEn->dist = LEp->dist + Distance(LEp->x,LEp->y,LEn->x,LEn->y);
                              LEn->parent = rln;
                              if((NGA_TYPE == 0) && (CLAMPFEATURES > 0) && (GetPointElevation( rln->x[rln->numnodes-2], rln->y[rln->numnodes-2],&temp) > 0))
                                 LEn->z = temp;
                              else 
                                 LEn->z =  rln->z[rln->numnodes-2];
                              LEn->next = LEroot2;
                              LEroot2 = LEn;
                              }
                           }
                        }
                     rln = rln->next;
                     }
                  if(LEroot2 != NULL) /** then found at least one joining node ***/
                     {
                     if(LEroot2->next == NULL) /*** then found only one joining node, so use it ***/
                        {
                        LEp->next = LEroot2;
                        }
                     else 
                        {
                        LEc = LEroot;
                        while(LEc->next != LEp)
                           {
                           LEc = LEc->next;
                           }
                        if(LEc->z > LEp->z)
                           uphill = 0;
                        else
                           uphill = 1;
                        LEn = LEc = LEroot2;
                        while(LEn != NULL)
                           {
                           if((uphill > 0) && (LEn->z > LEc->z))
                              LEc = LEn;
                           else if((uphill < 1) && (LEn->z < LEc->z))
                              LEc = LEn;
                           LEn = LEn->next;
                           }
                        LEn = LEroot2;
                        while(LEn != NULL)
                           {
                           if(LEn != LEc)
                              {
                              LEfree = LEn;
                              LEn = LEn->next;
                              free(LEfree);
                              }
                           else
                              LEn = LEn->next;
                           }
                        LEp->next = LEc;
                        LEc->next = NULL;
                        }
                     LEroot2 = NULL;
                     }
                  }

               if((LEroot != NULL) && (LEroot->x >= minx) && (LEroot->x <= maxx) &&
                   (LEroot->y >= miny) && (LEroot->y <= maxy))
                  {
                  LEroot2 = NULL;
                  rln = root;
                  while(rln != NULL)
                     {
                     if(rln != rlc) 
                        {
                        if((CombinedCheckApplies(rln->idn,checkinstance,LJOINSLOPEDC,rln->Lindex,rln->Sindex,
                               SCCtable[rln->Sindex].C, SCCtable[rln->Sindex].S, SCCtable[rln->Sindex].D,&part1,&part2,&part3) > 0) &&
                                (part2 > 0))
                           {
                           if((rln->x[0] == LEroot->x) && (rln->y[0] == LEroot->y) && (rln->z[0] == LEroot->z))
                              {
                              LEn = (struct LineElevations *) (malloc(SzLE));
                              if(LEn == NULL)
                                 {
                                 printf("free memory available for allocation has been exhausted\n");
                                 printf("processing cannot continue\n");
                                 exit(-1);
                                 }
                              LEn->x = rln->x[1];
                              LEn->y = rln->y[1];
                              LEn->dist = 0.0;
                              LEn->parent = rln;

                              if((NGA_TYPE == 0) && (CLAMPFEATURES > 0) && (GetPointElevation(rln->x[1],rln->y[1],&temp) > 0))
                                 LEn->z = temp;
                              else 
                                 LEn->z = rln->z[1];
                                 
                              LEn->next = LEroot2;
                              LEroot2 = LEn;
                              }
                           else if((rln->x[rln->numnodes-1] == LEroot->x) && (rln->y[rln->numnodes-1] == LEroot->y)
                                        && (rln->z[rln->numnodes-1] == LEroot->z))
                              {
                              LEn = (struct LineElevations *) (malloc(SzLE));
                              if(LEn == NULL)
                                 {
                                 printf("free memory available for allocation has been exhausted\n");
                                 printf("processing cannot continue\n");
                                 exit(-1);
                                 }
                              LEn->x = rln->x[rln->numnodes-2];
                              LEn->y = rln->y[rln->numnodes-2];
                              LEn->dist = 0.0;
                              LEn->parent = rln;
                              /**LEc = LEroot; **/
                             
                              if((NGA_TYPE == 0) && (CLAMPFEATURES > 0) && (GetPointElevation( rln->x[rln->numnodes-2], rln->y[rln->numnodes-2],&temp) > 0))
                                 LEn->z = temp;
                              else 
                                 LEn->z =  rln->z[rln->numnodes-2];
                                 
                              LEn->next = LEroot2;
                              LEroot2 = LEn;
                              }
                           }
                        }
                     rln = rln->next;
                     }
                  if(LEroot2 != NULL) /** then found at least one joining node ***/
                     {
                     if(LEroot2->next == NULL) /*** then found only one joining node, so use it ***/
                        {
                        LEroot2->next = LEroot;
                        LEroot = LEroot2;

                        temp = Distance(LEroot->x,LEroot->y,LEroot->next->x,LEroot->next->y);
                        LEroot->dist = 0.0;
                        LEc = LEroot->next;
                        while(LEc != NULL)
                           {
                           LEc->dist += temp;
                           LEc = LEc->next;
                           }
                        }
                     else
                        {
                        if(LEroot->z > LEroot->next->z)
                           uphill = 0;
                        else
                           uphill = 1;
                        LEn = LEc = LEroot2;
                        while(LEn != NULL)
                           {
                           if((uphill > 0) && (LEn->z < LEc->z))
                              LEc = LEn;
                           else if((uphill < 1) && (LEn->z > LEc->z))
                              LEc = LEn;
                           LEn = LEn->next;
                           }
                        LEn = LEroot2;
                        while(LEn != NULL)
                           {
                           if(LEn != LEc)
                              {
                              LEfree = LEn;
                              LEn = LEn->next;
                              free(LEfree);
                              }
                           else
                              LEn = LEn->next;
                           }
                        LEc->next = LEroot;
                        LEroot = LEc;

                        temp = Distance(LEroot->x,LEroot->y,LEroot->next->x,LEroot->next->y);
                        LEroot->dist = 0.0;
                        LEc = LEroot->next;
                        while(LEc != NULL) 
                           {
                           LEc->dist += temp; 
                           LEc = LEc->next;
                           }
                        }
                     LEroot2 = NULL;
                     }
                  }

               segdist = 0;
   
               LEc = LEroot;
               if(LEc != NULL)
                  {
                  LEn = LEc->next;
                  if(LEn != NULL)
                     {
                     z4 = LEn->z - LEc->z;
                     basedist = LEn->dist - LEc->dist;
                     xi = LEc->x;
                     yi = LEc->y;
                     zi = LEc->z;
                     LEp2 = LEc;

                     LEc = LEn;
                     LEn = LEn->next;
                     }
                  while(LEn != NULL)
                     {
                     z3 = LEn->z - LEc->z;
                     temp = z3 * z4;
                     segdist = LEn->dist - LEc->dist;
                     if((temp < 0) && (LEc->x >= minx) && (LEc->x <= maxx) && (LEc->y >= miny) && (LEc->y <= maxy))
                        {
                        if((segdist > 0) && (basedist > 0))
                           {
                           slopeangle1 = atan(z3 / segdist);
                           slopeangle2 = atan(z4 / basedist);
                           if(slopeangle2 > slopeangle1)
                              temp = slopeangle2 - slopeangle1;
                           else
                              temp = slopeangle1 - slopeangle2;

                           temp = RadiansToDegrees(temp);
                      
                           if((SensitivityCheck(GTEQ, LJOINSLOPEDC, checkinstance, temp) > 0) &&
                                          (LEp2->parent != LEn->parent))
                              {
                              ERc = (struct collection *) (malloc(SzC));
                              if(ERc == NULL)
                                 {
                                 printf("allocation memory exhausted during linear feature condition analysis\n");
                                 printf("processing cannot continue\n");
                                 exit(-1);
                                 }
                              ERc->x[0] = xi;
                              ERc->y[0] = yi;
                              ERc->z[0] = zi;
                              ERc->magnitude = temp;
                              ERc->keyval = LJOINSLOPEDC;
                              ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                              ERc->ll1 = LEp2->parent;
                              ERc->Sindex = LEp2->parent->Sindex;
                              ERc->ll2 = LEn->parent;
                              ERc->next = NULL;
                              if(ERroot == NULL)
                                 {
                                 ERc->x[1] = LEc->x;
                                 ERc->y[1] = LEc->y;
                                 ERc->z[1] = LEc->z;
                                 ERc->x[2] = LEn->x;
                                 ERc->y[2] = LEn->y;
                                 ERc->z[2] = LEn->z;
                                 ERroot = ERc;
                                 }
                              else
                                 {
                                 ERn = ERroot;
                                 while(ERn != NULL)
                                    {
                                    if(ERn->x[1] > LEc->x)
                                       t1 = ERn->x[1] - LEc->x;
                                    else
                                       t1 = LEc->x - ERn->x[1];

                                    if(ERn->y[1] > LEc->y)
                                       t2 = ERn->y[1] - LEc->y;
                                    else
                                       t2 = LEc->y - ERn->y[1];
                                    if(
				       (ERn->Cnumber    == ERc->Cnumber)    &&
				       (ERn->keyval    == ERc->keyval)    && 
				       (ERn->magnitude == ERc->magnitude) && 
                                       (t1 < 0.0001) && (t2 < 0.0001)
				       )
                                       break;
                                    ERn = ERn->next;
                                    }
                                 if(ERn == NULL)
                                    {
                                    ERc->x[1] = LEc->x;
                                    ERc->y[1] = LEc->y;
                                    ERc->z[1] = LEc->z;
                                    ERc->x[2] = LEn->x;
                                    ERc->y[2] = LEn->y;
                                    ERc->z[2] = LEn->z;
                                    ERc->next = ERroot;
                                    ERroot = ERc;
                                    }
                                 else
                                    free(ERc);
                                 }
                              }
                           }
                        }
   
                     if(segdist > 0)
                        {
                        z4 = z3;
                        basedist = LEn->dist - LEc->dist;
                        xi = LEc->x;
                        yi = LEc->y;
                        zi = LEc->z;
                        }
   
                     LEp2 = LEc;
                     LEc = LEn;
                     LEn = LEn->next;
                     }
                  }
   
               LEc = LEroot;
               while(LEc != NULL)
                  {
                  LEp = LEc;
                  LEc = LEc->next;
                  free(LEp);
                  }
               LEroot = NULL;
               }
   
            IgnoreDrawingSettings = 0;
            } /** end check LJOINSLOPEDC **/
   
   
         if(CombinedCheckApplies(rlc->idn,checkinstance,LSPINT,rlc->Lindex,rlc->Sindex,Config1,Strat1,Domain1,&part1,&part2,&part3) > 0)
            {
            if(part1 > 0)
               {
               if(PEroot == NULL)
                  ec = VPEroot;
               else
                  ec = PEroot;
   
               VerticalsUsed = 0;
           
               while(ec != NULL)
                  {
                  tpc = (struct ThePolys *) ec->owner;
                  Config2 = SCCtable[tpc->SCCindex].C;
                  Strat2 = SCCtable[tpc->SCCindex].S;
                  Domain2 = SCCtable[tpc->SCCindex].D;
                  if(CombinedCheckApplies(tpc->idn,checkinstance,LSPINT,tpc->SACindex,tpc->SCCindex,Config2,Strat2,Domain2,&part1,&part2,&part3) > 0)
                     {
                     temp = RadiansToDegrees(tpc->slope);
                     if((part2 > 0) && (tpc->slope < 2) && 
                              (SensitivityCheck(GTEQ, LSPINT, checkinstance, temp) > 0))
                        {
                        for(i=1; i<rlc->numnodes; i++)
                           {
                           ii = i - 1;
                           x1 = rlc->x[ii];
                           y1 = rlc->y[ii];
                           z1 = rlc->z[ii];
                           x2 = rlc->x[i];
                           y2 = rlc->y[i];
                           z2 = rlc->z[i];
                           if(ClipLineToRegion(minx,miny,maxx,maxy,&x1,&y1,&z1,&x2,&y2,&z2,&clipflag,multiplier) > 0)
                              {
                              
                              if(LineSegmentsIntersect(x1,y1,x2,y2,ec->x1,ec->y1,ec->x2,ec->y2, &xi, &yi) > 0)
                                 {
                                 ERc = (struct collection *) (malloc(SzC));
                                 if(ERc == NULL)
                                    {
                                    printf("allocation memory exhausted during linear feature condition analysis\n");
                                    printf("processing cannot continue\n");
                                    exit(-1);
                                    }
                                 ERc->x[0] = xi;
                                 ERc->y[0] = yi;
                                 ERc->magnitude = temp;
                                 ERc->keyval = LSPINT;
                                 ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                                 ERc->Sindex = rlc->Sindex;
   
                                 ERc->poly = tpc;
                                 ERc->IDN = rlc->idn;
                                 ERc->ll1 = rlc;
                                 ERc->vertexindex1 = ii;
   
                                 ERc->next = NULL;
                                 if(ERroot == NULL)
                                    {
                                    ERc->z[0] = InterpLinearElev(x1,y1,z1,x2,y2,z2,xi,yi);
                                    ERc->x[1] = x1;
                                    ERc->y[1] = y1;
                                    ERc->z[1] = z1;
                                    ERc->x[2] = x2;
                                    ERc->y[2] = y2;
                                    ERc->z[2] = z2;
                                    ERroot = ERc;
                                    }
                                 else
                                    {
                                    ERn = ERroot;
                                    while(ERn != NULL)
                                       {
					 if(
					    (ERn->Cnumber    == ERc->Cnumber)    &&
					    (ERn->keyval    == ERc->keyval)    && 
					    (ERn->poly      == ERc->poly)      && 
					    (ERn->ll1       == ERc->ll1)       &&
					    (ERn->magnitude == ERc->magnitude) && 
					    (ERn->Sindex    == ERc->Sindex)
					    )
					   break;
                                       ERn = ERn->next;
                                       }
                                    if(ERn == NULL)
                                       {
                                       ERc->z[0] = InterpLinearElev(x1,y1,z1,x2,y2,z2,xi,yi);
                                       ERc->x[1] = x1;
                                       ERc->y[1] = y1;
                                       ERc->z[1] = z1;
                                       ERc->x[2] = x2;
                                       ERc->y[2] = y2;
                                       ERc->z[2] = z2;
                                       ERc->next = ERroot;
                                       ERroot = ERc;
                                       }
                                    else
                                       free(ERc);
                                    }
                                 }
                              }
                           }
                        }
                     }
                  ec = ec->next;
                  if((VerticalsUsed == 0) && (ec == NULL))
                     {
                     VerticalsUsed = 1;
                     ec = VPEroot;
                     }
                  } /*** end while(ec != NULL) ***/
               }
            } /** end check LSPINT **/
   
         if(CombinedCheckApplies(rlc->idn,checkinstance,LSPIEXP,rlc->Lindex,rlc->Sindex,Config1,Strat1,Domain1,&part1,&part2,&part3) > 0)
            {
            if(part1 > 0)
               {
               ec = PEroot;
               while(ec != NULL)
                  {
                  tpc = (struct ThePolys *) ec->owner;
                  Config2 = SCCtable[tpc->SCCindex].C;
                  Strat2 = SCCtable[tpc->SCCindex].S;
                  Domain2 = SCCtable[tpc->SCCindex].D;
                  if(CombinedCheckApplies(tpc->idn,checkinstance,LSPIEXP,tpc->SACindex,tpc->SCCindex,Config2,Strat2,Domain2,&part1,&part2,&part3) > 0)
                     {
                     temp = RadiansToDegrees(tpc->slope);
                     if((part2 > 0) && (tpc->slope < 2) && 
                              (SensitivityCheck(GTEQ, LSPIEXP, checkinstance, temp) > 0))
                        {
                        for(i=1; i<rlc->numnodes; i++)
                           {
                           ii = i - 1;
                           x1 = rlc->x[ii];
                           y1 = rlc->y[ii];
                           z1 = rlc->z[ii];
                           x2 = rlc->x[i];
                           y2 = rlc->y[i];
                           z2 = rlc->z[i];
                           if(ClipLineToRegion(minx,miny,maxx,maxy,&x1,&y1,&z1,&x2,&y2,&z2,&clipflag,multiplier) > 0)
                              {
   
                              if(LineSegmentsIntersect(x1,y1,x2,y2,ec->x1,ec->y1,ec->x2,ec->y2, &xi, &yi) > 0)
                                 {
                                 ERc = (struct collection *) (malloc(SzC));
                                 if(ERc == NULL)
                                    {
                                    printf("allocation memory exhausted during linear feature condition analysis\n");
                                    printf("processing cannot continue\n");
                                    exit(-1);
                                    }
                                 ERc->x[0] = xi;
                                 ERc->y[0] = yi;
                                 ERc->magnitude = temp;
                                 ERc->keyval = LSPIEXP;
                                 ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                                 ERc->Sindex = rlc->Sindex;
   
                                 ERc->poly = tpc;
                                 ERc->IDN = rlc->idn;
                                 ERc->ll1 = rlc;
                                 ERc->vertexindex1 = ii;
   
                                 ERc->next = NULL;
   
                                 ERn = ERroot;
                                 while(ERn != NULL)
                                    {
                                    if(
				       (ERn->Cnumber    == ERc->Cnumber)    &&
				       (ERn->keyval    == ERc->keyval)    && 
				       (ERn->poly      == ERc->poly)      && 
				       (ERn->ll1       == ERc->ll1)       &&
				       (ERn->magnitude == ERc->magnitude) && 
				       (ERn->Sindex    == ERc->Sindex)
				       )
                                       break;
                                    ERn = ERn->next;
                                    }
                                 if(ERn == NULL)
                                    {
                                    inregion1 = 0;
                                    if((ActiveChecks[checkinstance].number == LSPIEXP) && (ActiveChecks[checkinstance].Config3[C_AREA] > 0))
                                       {
                                       rac = Aroot;
                                       while((rac != NULL) && (inregion1 == 0))
                                          {
                                          Config3 = SCCtable[rac->Sindex].C;
                                          Strat3 = SCCtable[rac->Sindex].S;
                                          Domain3 = SCCtable[rac->Sindex].D;
                                          if(CombinedCheckApplies(rac->idn,checkinstance,LSPIEXP,
                                                         rac->Lindex,rac->Sindex,Config3,Strat3,Domain3,&part1,&part2,&part3) > 0)
                                             {
                                             if(part3 > 0)
                                                {
                                                if(PointInsidePoly(xi,yi,rac->x,rac->y,rac->numverts) > 0)
                                                   inregion1 = 1;
                                                }
                                             }
                                          rac = rac->next;
                                          }
                                       }
                                    if((inregion1 == 0) &&
                                          (ActiveChecks[checkinstance].number == LSPIEXP) && (ActiveChecks[checkinstance].Config3[C_FOMO] > 0))
                                       {
                                       rbc = Broot;
                                       while((rbc != NULL) && (inregion1 == 0))
                                          {
                                          Config3 = SCCtable[rbc->Sindex].C;
                                          Strat3 = SCCtable[rbc->Sindex].S;
                                          Domain3 = SCCtable[rbc->Sindex].D;
                                          if(CombinedCheckApplies(rbc->idn,checkinstance,LSPIEXP,
                                                  rbc->Lindex,rbc->Sindex,Config3,Strat3,Domain3,&part1,&part2,&part3) > 0)
                                             {
                                             if(part3 > 0)
                                                {
                                                if((rbc->numverts == 3) && (PointInsideTriangle(xi,yi,rbc->x[0],rbc->y[0],
                                                                      rbc->x[1],rbc->y[1],rbc->x[2],rbc->y[2]) > 0))
                                                   {
                                                   inregion1 = 1;
                                                   }
                                                else if(PointInsidePoly(xi,yi,rbc->x,rbc->y,rbc->numverts) > 0)
                                                   {
                                                   inregion1 = 1;
                                                   }
                                                }
                                             }
                                          rbc = rbc->next;
                                          }
                                       if(inregion1 == 0)
                                          {
                                          rpc = Proot;
                                          while((rpc != NULL) && (inregion1 == 0))
                                             {
                                             if(rpc->numverts > 2)
                                                {
                                                Config3 = SCCtable[rpc->Sindex].C;
                                                Strat3 = SCCtable[rpc->Sindex].S;
                                                Domain3 = SCCtable[rpc->Sindex].D;
                                                if(CombinedCheckApplies(rpc->idn,checkinstance,LSPIEXP,
                                                         rpc->Lindex,rpc->Sindex,Config3,Strat3,Domain3,&part1,&part2,&part3) > 0)
                                                   {
                                                   if(part3 > 0)
                                                      {
                                                      if((rpc->numverts == 3) && (PointInsideTriangle(xi,yi,rpc->x[0],rpc->y[0],
                                                                            rpc->x[1],rpc->y[1],rpc->x[2],rpc->y[2]) > 0))
                                                         {
                                                         inregion1 = 1;
                                                         }
                                                      else if(PointInsidePoly(xi,yi,rpc->x,rpc->y,rpc->numverts) > 0)
                                                         {
                                                         inregion1 = 1;
                                                         }
                                                      }
                                                   }
                                                }
                                             rpc = rpc->next;
                                             }
                                          }
                                       }
   
                                    if((inregion1 == 0) &&
                                         (ActiveChecks[checkinstance].number == LSPIEXP) && (ActiveChecks[checkinstance].Config3[C_POLY] > 0))
                                       {
                                       tpc2 = Polyroot;
                                       while((tpc2 != NULL) && (inregion1 == 0))
                                          {
                                          Config3 = SCCtable[tpc2->SCCindex].C;
                                          Strat3 = SCCtable[tpc2->SCCindex].S;
                                          Domain3 = SCCtable[tpc2->SCCindex].D;
                                          if(CombinedCheckApplies(tpc2->idn,checkinstance,LSPIEXP,
                                                tpc2->SACindex,tpc2->SCCindex,Config3,Strat3,Domain3,&part1,&part2,&part3) > 0)
                                             {
                                             if(part3 > 0) 
                                                {
                                                if((tpc2->numverts == 3) && (PointInsideTriangle(xi,yi,tpc2->x[0],tpc2->y[0],
                                                                            tpc2->x[1],tpc2->y[1],tpc2->x[2],tpc2->y[2]) > 0))
                                                   {
                                                   inregion1 = 1;
                                                   break;
                                                   }
                                                else if((tpc2->numverts > 3) && (PointInsidePoly(xi,yi,tpc2->x,tpc2->y,tpc2->numverts) > 0))
                                                   {
                                                   inregion1 = 1;
                                                   break;
                                                   }
                                                }
                                             }
                                          tpc2 = tpc2->next;
                                          }
                                       }
   
                                    if(inregion1 == 0)
                                       {
                                       ERc->z[0] = InterpLinearElev(x1,y1,z1,x2,y2,z2,xi,yi);
                                       ERc->x[1] = x1;
                                       ERc->y[1] = y1;
                                       ERc->z[1] = z1;
                                       ERc->x[2] = x2;
                                       ERc->y[2] = y2;
                                       ERc->z[2] = z2;
                                       ERc->next = ERroot;
                                       ERroot = ERc;
                                       }
                                    else
                                       {
                                       free(ERc);
                                       }
                                    }
                                 else
                                    {
                                    free(ERc);
                                    }
                                 }
                              }
                           }
                        }
                     }
                  ec = ec->next;
                  }
               }
            } /** end check LSPIEXP **/
   
   
   

   /** check for Line - Areal intersections **/
         if(CombinedCheckApplies(rlc->idn,checkinstance,LAINT,rlc->Lindex,rlc->Sindex,
				 Config1,Strat1,Domain1,&part1,&part2,&part3) > 0)
            {

            if(part1 > 0)
               {
               for(i=1; i<rlc->numnodes; i++)
                  {
                  ii = i - 1;
                  x1 = rlc->x[ii];
                  y1 = rlc->y[ii];
                  z1 = rlc->z[ii];
                  x2 = rlc->x[i];
                  y2 = rlc->y[i];
                  z2 = rlc->z[i];
                  if(ClipLineToRegion(minx,miny,maxx,maxy,&x1,&y1,&z1,&x2,&y2,&z2,&clipflag,multiplier) > 0)
                     {
                     x1 = rlc->x[ii];
                     y1 = rlc->y[ii];
                     z1 = rlc->z[ii];
                     x2 = rlc->x[i];
                     y2 = rlc->y[i];
                     z2 = rlc->z[i];
                     rac = Aroot;
                     while(rac != NULL)
                        {
                        Config2 = SCCtable[rac->Sindex].C;
                        Strat2 = SCCtable[rac->Sindex].S;
                        Domain2 = SCCtable[rac->Sindex].D;
                        if(CombinedCheckApplies(rac->idn,checkinstance,LAINT,
                                rac->Lindex,rac->Sindex,Config2,Strat2,Domain2,&part1,&part2,&part3) > 0)
                           {
                           if((part2 > 0) && (rac->RB_Tree_Edgelist == NULL)) 
                              {
                              for(j=0; j<rac->numverts; j++)
                                 {
                                 jj = (j + 1) % rac->numverts;
                                 x3 = rac->x[jj];
                                 y3 = rac->y[jj];
                                 z3 = rac->z[jj];
                                 x4 = rac->x[j];
                                 y4 = rac->y[j];
                                 z4 = rac->z[j];
                                 if(ClipLineToRegion(minx,miny,maxx,maxy,&x3,&y3,&z3,&x4,&y4,&z4,&clipflag,multiplier) > 0)
                                    {
                                    x3 = rac->x[jj];
                                    y3 = rac->y[jj];
                                    z3 = rac->z[jj];
                                    x4 = rac->x[j];
                                    y4 = rac->y[j];
                                    z4 = rac->z[j];
                                    if(LineSegmentsIntersect(x1,y1,x2,y2,x3,y3,x4,y4, &xi, &yi) > 0)
                                       {
                                       if((xi >= minx) && (xi < maxx) && (yi >= miny) && (yi < maxy))
                                          {
                                          if(LineSegmentsOverlap(x1,y1,x2,y2,x3,y3,x4,y4,
                                                 &xi1, &yi1, &xi2, &yi2, 0.01) <= 0)
                                             {
                                             ERc = (struct collection *) (malloc(SzC));
                                             if(ERc == NULL)
                                                {
                                                printf("allocation memory exhausted during linear feature condition analysis\n");
                                                printf("processing cannot continue\n");
                                                exit(-1);
                                                }
                                             ERc->x[0] = xi;
                                             ERc->y[0] = yi;
                                             ERc->z[0] = InterpLinearElev(rlc->x[ii],rlc->y[ii],rlc->z[ii],rlc->x[i],rlc->y[i],rlc->z[i],xi,yi);

                                             ERc->x[1] = rlc->x[ii];
                                             ERc->y[1] = rlc->y[ii];
                                             ERc->z[1] = rlc->z[ii];
                                             ERc->x[2] = rlc->x[i];
                                             ERc->y[2] = rlc->y[i];
                                             ERc->z[2] = rlc->z[i];

                                             ERc->x[3] = rac->x[jj];
                                             ERc->y[3] = rac->y[jj];
                                             ERc->z[3] = rac->z[jj];
                                             ERc->x[4] = rac->x[j];
                                             ERc->y[4] = rac->y[j];
                                             ERc->z[4] = rac->z[j];

                                             ERc->magnitude = 0.0;
                                             ERc->keyval = LAINT;
                                             ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                                             ERc->aa = rac;
                                             ERc->ll1 = rlc;
                                             ERc->Sindex = rlc->Sindex;
                                             ERc->next = NULL;
      
                                             ERn = ERroot;
                                             while(ERn != NULL)
                                                {
					          if(
					             (ERn->Cnumber == ERc->Cnumber) &&
					             (ERn->keyval  == ERc->keyval) && 
					             (ERn->x[0]    == ERc->x[0])   &&
					             (ERn->y[0]    == ERc->y[0])   && 
					             (ERn->ll1  == ERc->ll1) &&
                                                     (ERn->aa   == ERc->aa)
					             )
					            break;
					          ERn = ERn->next;
                                                }
                                             if(ERn == NULL)
                                                {
                                                ERc->next = ERroot;
                                                ERroot = ERc;
                                                }
                                             else
                                                free(ERc);
                                             }
                                          }
                                       }
                                    }
                                 }
                              }
                           else if((part2 > 0) && (rac->RB_Tree_Edgelist != NULL)) 
                              {
                              LAINTroot = NULL;
                              j = LineSegmentIntersectsLargeAreal(cindex,x1,y1,x2,y2,rac, &jj, &xi, &yi, SzPID);
                              if(j > 0)
                                 {

                                 pic = LAINTroot;
                                 while(pic != NULL)
                                    {
                                    if((pic->x >= minx) && (pic->x < maxx) && (pic->y >= miny) && (pic->y < maxy))
                                       {
                                       ERc = (struct collection *) (malloc(SzC));
                                       if(ERc == NULL)
                                          {
                                          printf("allocation memory exhausted during linear feature condition analysis\n");
                                          printf("processing cannot continue\n");
                                          exit(-1);
                                          }
                                       ERc->x[0] = pic->x;
                                       ERc->y[0] = pic->y;
                                       ERc->z[0] = InterpLinearElev(rlc->x[ii],rlc->y[ii],rlc->z[ii],rlc->x[i],rlc->y[i],rlc->z[i],pic->x,pic->y);
                                       ERc->x[1] = rlc->x[ii];
                                       ERc->y[1] = rlc->y[ii];
                                       ERc->z[1] = rlc->z[ii];
                                       ERc->x[2] = rlc->x[i];
                                       ERc->y[2] = rlc->y[i];
                                       ERc->z[2] = rlc->z[i];

                                       ERc->x[3] = rac->x[pic->index1];
                                       ERc->y[3] = rac->y[pic->index1];
                                       ERc->z[3] = rac->z[pic->index1];
                                       ERc->x[4] = rac->x[pic->index2];
                                       ERc->y[4] = rac->y[pic->index2];
                                       ERc->z[4] = rac->z[pic->index2];
   
                                       ERc->magnitude = 0.0;
                                       ERc->keyval = LAINT;
                                       ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                                       ERc->aa = rac;
                                       ERc->ll1 = rlc;
                                       ERc->Sindex = rlc->Sindex;
                                       ERc->next = NULL;
   
                                       ERn = ERroot;
                                       while(ERn != NULL)
                                          {
                                            if(
                                               (ERn->Cnumber == ERc->Cnumber) &&
                                               (ERn->keyval  == ERc->keyval) &&
                                               (ERn->x[0]    == ERc->x[0])   &&
                                               (ERn->y[0]    == ERc->y[0])   &&
                                               (ERn->ll1  == ERc->ll1) &&
                                               (ERn->aa   == ERc->aa)
                                               )
                                              break;
                                            ERn = ERn->next;
                                          }
                                       if(ERn == NULL)
                                          {
                                          ERc->next = ERroot;
                                          ERroot = ERc;
                                          }
                                       else
                                          free(ERc);
                                       }

                                    LAINTroot = LAINTroot->next;
                                    free(pic);
                                    pic = LAINTroot;
                                    }
                                 }
                              }
                           }
                        rac = rac->next;
                        }
                     }
                  }
   
               }
            }  /** end check for LAINT ***/


         if(CombinedCheckApplies(rlc->idn,checkinstance,LSLICEA,rlc->Lindex,rlc->Sindex,
                                 Config1,Strat1,Domain1,&part1,&part2,&part3) > 0)
            {

            if(part1 > 0)
               {
               rac = Aroot;
               while(rac != NULL)
                  {
                  if((CombinedCheckApplies(rac->idn,checkinstance,LSLICEA,
                                rac->Lindex,rac->Sindex,SCCtable[rac->Sindex].C
                                  ,SCCtable[rac->Sindex].S,SCCtable[rac->Sindex].D,&part1,&part2,&part3) > 0) &&
                            (part2 > 0))
                     {
                     if((rlc->IsMulti == 0) || (rac->ismulti == 0) ||
                        (CheckThisLinePair(checkinstance,CTLPmaxindex, /** was IndexLimit,***/
                                     SzPC,SzPW,rlc->localID,rac->localID,
                                        rlc->firstencounter,0,rlc->length,rac->area) > 0))
                        {
                        NoIntCount = 0;
                        ii = 0;
                        for(i=1; i<rlc->numnodes; i++)
                           {
isclose = 0;
ERsave = NULL;
NoIntCount = 0;
                           if(rlc->y[ii] != rlc->y[i])
                              segmentslope = (rlc->x[ii] - rlc->x[i]) / (rlc->y[ii] - rlc->y[i]);
                           else
                              segmentslope = (rlc->x[ii] - rlc->x[i]) / 0.00001;
                           segmentslope = atan(segmentslope);
                           segmentslope = RadiansToDegrees(segmentslope);

                           if(rac->RB_Tree_Edgelist == NULL)
                              {
                              jj = rac->numverts -1;
                              for(j =0; j<rac->numverts; j++)
                                 {
                                 if(rac->y[jj] != rac->y[j])
                                    unuseddbl = (rac->x[jj] - rac->x[j]) / (rac->y[jj] - rac->y[j]);
                                 else
                                    unuseddbl = (rac->x[jj] - rac->x[j]) / 0.00001;
                                 unuseddbl = atan(unuseddbl);
                                 unuseddbl = RadiansToDegrees(unuseddbl);

                                 if(segmentslope > unuseddbl)
                                    unuseddbl = segmentslope - unuseddbl;
                                 else
                                    unuseddbl = unuseddbl - segmentslope;

                                 if((unuseddbl > -2.0) && (unuseddbl < 2.0))
                                    {
                                    if(LineSegmentsOverlap(rlc->x[i],rlc->y[i],rlc->x[ii],rlc->y[ii],
                                       rac->x[j],rac->y[j],rac->x[jj],rac->y[jj],
                                           &unuseddbl, &unuseddbl2, &unuseddbl3, &unuseddbl4, 0.1) > 0)
                                       {
                                       isclose = 1;
                                       break;
                                       }
                                    }

                                 if(((unuseddbl < -10.0) || (unuseddbl > 10.0)) &&
                                    (LineSegmentsIntersect(rlc->x[i],rlc->y[i],rlc->x[ii],rlc->y[ii],
                                       rac->x[j],rac->y[j],rac->x[jj],rac->y[jj], &xi, &yi) > 0))
                                    {
                                    keepit = 0;
                                    if(NoIntCount == 0)
                                       {
                                       NoIntCount = 1;
                                       xi1 = xi;
                                       yi1 = yi;
                                       k = j;
                                       }
                                    else if((xi != xi1) && (yi != yi1) && (NoIntCount == 1))
                                       {
                                       NoIntCount = 0;
keepit = 1;
                                    t1 = xi + ((xi1 - xi) / 2.0);
                                    t2 = yi + ((yi1 - yi) / 2.0);
                                    if(rac->RB_Tree_Edgelist == NULL)
                                       {
                                       keepit = PointIsInside(t1,t2,rac->x,rac->y,rac->z,rac->numverts,C_AREA,&unuseddbl);
                                       }
                                    else
                                       {
                                       keepit = PointInsideLargeAreal(t1, t2, rac,&unusedint);
                                       }
                                       }

                                    if(keepit > 0)
                                       {
                                       NoIntCount = 0;
                                       Xvert[0] = xi1;
                                       Yvert[0] = yi1;
                                       ii3 = 0;
                                       kk = j - k;
                                       kk2 = rac->numverts - j + k;

                                       if((kk < 900) && (kk < kk2))
                                          {
                                          temp = 0.0;
                                          kk = k - 1;
                                          while(kk != j)
                                             {
                                             ++kk;
                                             if((rac->x[kk] != Xvert[ii3]) || (rac->y[kk] != Yvert[ii3]))
                                                {
                                                ++ii3;
                                                Xvert[ii3] = rac->x[kk];
                                                Yvert[ii3] = rac->y[kk];
                                                }
                                          //++kk;
                                             if(kk >= rac->numverts)
                                                kk = 0;
                                             }
                                          }
                                       else if((kk2 < 900) && (kk2 < kk))
                                          {
                                          temp = 0.0;
                                          for(kk = j; kk < rac->numverts; kk++)
                                             {
                                             if((rac->x[kk] != Xvert[ii3]) || (rac->y[kk] != Yvert[ii3]))
                                                {
                                                ++ii3;
                                                Xvert[ii3] = rac->x[kk];
                                                Yvert[ii3] = rac->y[kk];
                                                }
                                             }
                                          for(kk = 0; kk <= k; kk++)
                                             {
                                             if((rac->x[kk] != Xvert[ii3]) || (rac->y[kk] != Yvert[ii3]))
                                                {
                                                ++ii3;
                                                Xvert[ii3] = rac->x[kk];
                                                Yvert[ii3] = rac->y[kk];
                                                }
                                             }
                                          }
                                       else
                                          {
                                          temp2 = temp = ActiveChecks[checkinstance].sensitivity * 100;
                                          }
                                       if(temp < ActiveChecks[checkinstance].sensitivity)
                                          {
                                          ++ii3;
                                          Xvert[ii3] = xi;
                                          Yvert[ii3] = yi;
                                          temp = 0;
                                          Xold = Xvert[ii3];
                                          Yorig = Yvert[ii3];
                                          Yold = 0.0;
                                          for(kk = 0; kk<=ii3; kk++)
                                             {
                                             temp = temp + (Xold - Xvert[kk]) * (Yold + (Yvert[kk] - Yorig));
                                             Xold = Xvert[kk];
                                             Yold = Yvert[kk] - Yorig;
                                             }
   
                                          temp = temp * 0.5;
                                          if(temp < 0)
                                             temp = 0 - temp;
                                          temp2 = rac->area - temp;
                                          }
                                       if((temp > 0.001) && (temp < ActiveChecks[checkinstance].sensitivity))
                                          {
   
                                          ERc = (struct collection *) (malloc(SzC));
                                          if(ERc == NULL)
                                            {
                                            printf("allocation memory exhausted during linear feature condition analysis (Z-shear analysis)\n");
                                            printf("processing cannot continue\n");
                                            exit(-1);
                                            }
                                          ERc->magnitude = temp;
                                          ERc->x[0] = rlc->x[i];
                                          ERc->y[0] = rlc->y[i];
                                          ERc->z[0] = rlc->z[i];
                                          ERc->x[1] = rlc->x[ii];
                                          ERc->y[1] = rlc->y[ii];
                                          ERc->z[1] = rlc->z[ii];
                                          ERc->x[2] = rac->x[j];
                                          ERc->y[2] = rac->y[j];
                                          ERc->z[2] = rac->z[j];
                                          ERc->x[3] = rac->x[jj];
                                          ERc->y[3] = rac->y[jj];
                                          ERc->z[3] = rac->z[jj];
   
                                          ERc->IDN = rlc->idn;
                                          ERc->Sindex = rlc->Sindex;
                                          ERc->aa = rac; /** RawAreal **/
                                          ERc->bb = NULL; /** RawBridge **/
                                          ERc->pp = NULL; /** RawPoint **/
                                          ERc->le = NULL; /** ListOfEdges **/
                                          ERc->poly = NULL; /** ThePolys **/
                                          ERc->ll1 = rlc;
                                          ERc->ll2 = NULL;
                                          ERc->keyval = LSLICEA;
                                          ERc->Cnumber = Make_Correct(LSLICEA,checkinstance);

                                          if(ERroot == NULL)
                                             {
                                             ERroot = ERc;
                                             ERroot->next = NULL;
if(ERsave == NULL)
ERsave = ERc;
                                             }
                                          else
                                             {
                                             ERn = ERroot;
                                             while(ERn != NULL)
                                                {
                                                if((ERn->keyval == ERc->keyval) && (ERc->Cnumber == ERn->Cnumber))
                                                   {
                                                   if((ERn->ll1 == ERc->ll1) && (ERn->aa == ERc->aa) && (ERc->magnitude == ERn->magnitude))
                                                      {
                                                      break;
                                                      }
                                                   }
                                                ERn = ERn->next;
                                                }
                                             if(ERn == NULL)
                                                {
                                                ERc->next = ERroot;
                                                ERroot = ERc;
if(ERsave == NULL)
ERsave = ERc;
                                                }
                                             else
                                                {
                                                free(ERc);
                                                }
                                             }
                                          } /*** end temp1 qualifies as a condition ***/

                                       if((temp2 > 0.001) && (temp2 < ActiveChecks[checkinstance].sensitivity))
                                          {
                                          ERc = (struct collection *) (malloc(SzC));
                                          if(ERc == NULL)
                                            {
                                            printf("allocation memory exhausted during linear feature condition analysis (Z-shear analysis)\n");
                                            printf("processing cannot continue\n");
                                            exit(-1);
                                            }
                                          ERc->magnitude = temp2;
                                          ERc->x[0] = rlc->x[i];
                                          ERc->y[0] = rlc->y[i];
                                          ERc->z[0] = rlc->z[i];
                                          ERc->x[1] = rlc->x[ii];
                                          ERc->y[1] = rlc->y[ii];
                                          ERc->z[1] = rlc->z[ii];
                                          ERc->x[2] = rac->x[j];
                                          ERc->y[2] = rac->y[j];
                                          ERc->z[2] = rac->z[j];
                                          ERc->x[3] = rac->x[jj];
                                          ERc->y[3] = rac->y[jj];
                                          ERc->z[3] = rac->z[jj];

                                          ERc->IDN = rlc->idn;
                                          ERc->Sindex = rlc->Sindex;
                                          ERc->aa = rac; /** RawAreal **/
                                          ERc->bb = NULL; /** RawBridge **/
                                          ERc->pp = NULL; /** RawPoint **/
                                          ERc->le = NULL; /** ListOfEdges **/
                                          ERc->poly = NULL; /** ThePolys **/
                                          ERc->ll1 = rlc;
                                          ERc->ll2 = NULL;
                                          ERc->keyval = LSLICEA;
                                          ERc->Cnumber = Make_Correct(LSLICEA,checkinstance);
   
                                          if(ERroot == NULL)
                                             {
                                             ERroot = ERc;
                                             ERroot->next = NULL;
if(ERsave == NULL)
ERsave = ERc;
                                             }
                                          else
                                             {
                                             ERn = ERroot;
                                             while(ERn != NULL)
                                                {
                                                if((ERn->keyval == ERc->keyval) && (ERc->Cnumber == ERn->Cnumber))
                                                   {
                                                   if((ERn->ll1 == ERc->ll1) && (ERn->aa == ERc->aa) && (ERc->magnitude == ERn->magnitude))
                                                      {
                                                      break;
                                                      }
                                                   }
                                                ERn = ERn->next;
                                                }
                                             if(ERn == NULL)
                                                {
                                                ERc->next = ERroot;
                                                ERroot = ERc;
if(ERsave == NULL)
ERsave = ERc;
                                                }
                                             else
                                                {
                                                free(ERc);
                                                }
                                             }
                                          } /*** end temp2 qualifies as a condition ***/
                                       } /*** end found the second intersection ****/
                                    } /*** end have an intersection ***/
                                 jj = j;
                                 } /** end for(j =0; j<rac->numverts; j++) ***/
                              if(isclose > 0) /*** found that rlc edge from ii to i is overlapping an rac edge - remove any assoc conditions ***/
                                 {
                                 if(ERsave != NULL)
                                    {
                                    ERn = ERroot;
                                    ERroot = ERsave->next;
                                    ERsave->next = NULL;
                                    while(ERn != NULL)
                                       {
                                       ERc = ERn;
                                       ERn = ERn->next;
                                       free(ERc);
                                       }
                                    }
                                 /**isclose = 0;
                                 ERsave = NULL;**/
                                 }

                              } /*** end area feature has NULL RB_Tree_Edgelist ****/
                           else  /*** have a large vertex count, multi region area feature ****/
                              {
                              LSLICEroot = NULL;

                              LineSegIntLargeAreal(-1,rlc->x[i],rlc->y[i],rlc->x[ii],rlc->y[ii], rac,
                                        &iii, &unuseddbl, &unuseddbl2, sizeof(struct PointAndID));
                                 
                              if(LSLICEroot != NULL)
                                 {
                                 NoIntCount = 0;
                                 pic = LSLICEroot;
                                 while(pic != NULL)
                                    {
                                    jj = pic->index2;
                                    j = pic->index1;
                                    xi = pic->x;
                                    yi = pic->y;

                                    if(rac->y[jj] != rac->y[j])
                                       unuseddbl = (rac->x[jj] - rac->x[j]) / (rac->y[jj] - rac->y[j]);
                                    else
                                       unuseddbl = (rac->x[jj] - rac->x[j]) / 0.00001;
                                    unuseddbl = atan(unuseddbl);
                                    unuseddbl = RadiansToDegrees(unuseddbl);

                                    if(segmentslope > unuseddbl)
                                       unuseddbl = segmentslope - unuseddbl;
                                    else
                                       unuseddbl = unuseddbl - segmentslope;

                                    if((unuseddbl > -2.0) && (unuseddbl < 2.0))
                                       {
                                       if(LineSegmentsOverlap(rlc->x[i],rlc->y[i],rlc->x[ii],rlc->y[ii],
                                          rac->x[j],rac->y[j],rac->x[jj],rac->y[jj],
                                              &unuseddbl, &unuseddbl2, &unuseddbl3, &unuseddbl4, 0.1) > 0)
                                          {
                                          isclose = 1;
                                          break;
                                          }
                                       }


                                    if(((unuseddbl < -10.0) || (unuseddbl > 10.0)))
                                       {
                                       keepit = 0;
                                       if(NoIntCount == 0)
                                          {
                                          NoIntCount = 1;
                                          xi1 = xi;
                                          yi1 = yi;
                                          k = j;
                                          }
                                       else if((xi != xi1) && (yi != yi1) && (NoIntCount == 1))
                                          {
                                          NoIntCount = 0;
keepit = 1;
                                    t1 = xi + ((xi1 - xi) / 2.0);
                                    t2 = yi + ((yi1 - yi) / 2.0);
                                    if(rac->RB_Tree_Edgelist == NULL)
                                       {
                                       keepit = PointIsInside(t1,t2,rac->x,rac->y,rac->z,rac->numverts,C_AREA,&unuseddbl);
                                       }
                                    else
                                       {
                                       keepit = PointInsideLargeAreal(t1, t2, rac,&unusedint);
                                       }
                                       }

                                       if(keepit > 0)
                                          {
                                          if(k > j)
                                             {
                                             ii3 = j;
                                             j = k;
                                             k = ii3;
                                             unuseddbl = xi1;
                                             xi1 = xi;
                                             xi = unuseddbl;
                                             unuseddbl = yi1;
                                             yi1 = yi;
                                             yi = unuseddbl;
                                             }

                                          NoIntCount = 0;
                                          Xvert[0] = xi1;
                                          Yvert[0] = yi1;
                                             ii3 = 0;
                                          kk = j - k;
                                          kk2 = rac->numverts - j + k;

                                          if((kk < 900) && (kk < kk2))
                                             {
                                             temp = 0.0;
                                             kk = k - 1;
                                             while(kk != j)
                                                {
                                                ++kk;
                                                if((rac->x[kk] != Xvert[ii3]) || (rac->y[kk] != Yvert[ii3]))
                                                   {
                                                   ++ii3;
                                                   Xvert[ii3] = rac->x[kk];
                                                   Yvert[ii3] = rac->y[kk];
                                                   }
                                                if(kk >= rac->numverts)
                                                   kk = 0;
                                                }
                                             }
                                          else if((kk2 < 900) && (kk2 < kk))
                                             {
                                             temp = 0.0;
                                             for(kk = j; kk < rac->numverts; kk++)
                                                {
                                                if((rac->x[kk] != Xvert[ii3]) || (rac->y[kk] != Yvert[ii3]))
                                                   {
                                                   ++ii3;
                                                   Xvert[ii3] = rac->x[kk];
                                                   Yvert[ii3] = rac->y[kk];
                                                   }
                                                }
                                             for(kk = 0; kk <= k; kk++)
                                                {
                                                if((rac->x[kk] != Xvert[ii3]) || (rac->y[kk] != Yvert[ii3]))
                                                   {
                                                   ++ii3;
                                                   Xvert[ii3] = rac->x[kk];
                                                   Yvert[ii3] = rac->y[kk];
                                                   }
                                                }
                                             }
                                          else
                                             {
                                             temp2 = temp = ActiveChecks[checkinstance].sensitivity * 100;
                                             }
                                          if(temp < ActiveChecks[checkinstance].sensitivity)
                                             {
                                             ++ii3;
                                             Xvert[ii3] = xi;
                                             Yvert[ii3] = yi;
                                             temp = 0;
                                             Xold = Xvert[ii3];
                                             Yorig = Yvert[ii3];
                                             Yold = 0.0;
                                             for(kk = 0; kk<=ii3; kk++)
                                                {
                                                temp = temp + (Xold - Xvert[kk]) * (Yold + (Yvert[kk] - Yorig));
                                                Xold = Xvert[kk];
                                                Yold = Yvert[kk] - Yorig;
                                                }

                                             temp = temp * 0.5;
                                             if(temp < 0)
                                                temp = 0 - temp;
                                             temp2 = rac->area - temp;
                                             }
                                          if((temp > 0.001) && (temp < ActiveChecks[checkinstance].sensitivity))
                                             {
                                             ERc = (struct collection *) (malloc(SzC));
                                             if(ERc == NULL)
                                               {
                                               printf("allocation memory exhausted during linear feature condition analysis (Z-shear analysis)\n");
                                               printf("processing cannot continue\n");
                                               exit(-1);
                                               }
                                             ERc->magnitude = temp;
                                             ERc->x[0] = rlc->x[i];
                                             ERc->y[0] = rlc->y[i];
                                             ERc->z[0] = rlc->z[i];
                                             ERc->x[1] = rlc->x[ii];
                                             ERc->y[1] = rlc->y[ii];
                                             ERc->z[1] = rlc->z[ii];
                                             ERc->x[2] = rac->x[j];
                                             ERc->y[2] = rac->y[j];
                                             ERc->z[2] = rac->z[j];
                                             ERc->x[3] = rac->x[jj];
                                             ERc->y[3] = rac->y[jj];
                                             ERc->z[3] = rac->z[jj];

                                             ERc->IDN = rlc->idn;
                                             ERc->Sindex = rlc->Sindex;
                                             ERc->aa = rac; /** RawAreal **/
                                             ERc->bb = NULL; /** RawBridge **/
                                             ERc->pp = NULL; /** RawPoint **/
                                             ERc->le = NULL; /** ListOfEdges **/
                                             ERc->poly = NULL; /** ThePolys **/
                                             ERc->ll1 = rlc;
                                             ERc->ll2 = NULL;
                                             ERc->keyval = LSLICEA;
                                             ERc->Cnumber = Make_Correct(LSLICEA,checkinstance);

                                             if(ERroot == NULL)
                                                {
                                                ERroot = ERc;
                                                ERroot->next = NULL;
if(ERsave == NULL)
ERsave = ERc;
                                                }
                                             else
                                                {
                                                ERn = ERroot;
                                                while(ERn != NULL)
                                                   {
                                                   if((ERn->keyval == ERc->keyval) && (ERc->Cnumber == ERn->Cnumber))
                                                      {
                                                      if((ERn->ll1 == ERc->ll1) && (ERn->aa == ERc->aa) && (ERc->magnitude == ERn->magnitude))
                                                         {
                                                         break;
                                                         }
                                                      }
                                                   ERn = ERn->next;
                                                   }
                                                if(ERn == NULL)
                                                   {
                                                   ERc->next = ERroot;
                                                   ERroot = ERc;
if(ERsave == NULL)
ERsave = ERc;
                                                   }
                                                else
                                                   {
                                                   free(ERc);
                                                   }
                                                }
                                             } /*** end temp1 qualifies as a condition ***/

                                          if((temp2 > 0.001) && (temp2 < ActiveChecks[checkinstance].sensitivity))
                                             {
                                             ERc = (struct collection *) (malloc(SzC));
                                             if(ERc == NULL)
                                               {
                                               printf("allocation memory exhausted during linear feature condition analysis (Z-shear analysis)\n");
                                               printf("processing cannot continue\n");
                                               exit(-1);
                                               }
                                             ERc->magnitude = temp2;
                                             ERc->x[0] = rlc->x[i];
                                             ERc->y[0] = rlc->y[i];
                                             ERc->z[0] = rlc->z[i];
                                             ERc->x[1] = rlc->x[ii];
                                             ERc->y[1] = rlc->y[ii];
                                             ERc->z[1] = rlc->z[ii];
                                             ERc->x[2] = rac->x[j];
                                             ERc->y[2] = rac->y[j];
                                             ERc->z[2] = rac->z[j];
                                             ERc->x[3] = rac->x[jj];
                                             ERc->y[3] = rac->y[jj];
                                             ERc->z[3] = rac->z[jj];

                                             ERc->IDN = rlc->idn;
                                                ERc->Sindex = rlc->Sindex;
                                             ERc->aa = rac; /** RawAreal **/
                                             ERc->bb = NULL; /** RawBridge **/
                                             ERc->pp = NULL; /** RawPoint **/
                                             ERc->le = NULL; /** ListOfEdges **/
                                             ERc->poly = NULL; /** ThePolys **/
                                             ERc->ll1 = rlc;
                                             ERc->ll2 = NULL;
                                             ERc->keyval = LSLICEA;
                                             ERc->Cnumber = Make_Correct(LSLICEA,checkinstance);
   
                                             if(ERroot == NULL)
                                                {
                                                ERroot = ERc;
                                                ERroot->next = NULL;
if(ERsave == NULL)
ERsave = ERc;
                                                }
                                             else
                                                {
                                                ERn = ERroot;
                                                while(ERn != NULL)
                                                   {
                                                   if((ERn->keyval == ERc->keyval) && (ERc->Cnumber == ERn->Cnumber))
                                                      {
                                                      if((ERn->ll1 == ERc->ll1) && (ERn->aa == ERc->aa) && (ERc->magnitude == ERn->magnitude))
                                                         {
                                                         break;
                                                         }
                                                      }
                                                   ERn = ERn->next;
                                                   }
                                                if(ERn == NULL)
                                                   {
                                                   ERc->next = ERroot;
                                                   ERroot = ERc;
if(ERsave == NULL)
ERsave = ERc;
                                                   }
                                                else
                                                   {
                                                   free(ERc);
                                                   }
                                                }
                                             } /*** end temp2 qualifies as a condition ***/
                                          } /*** end found the second intersection ****/
                                       } /*** end have an intersection without overlapping edges ***/
                                    pic = pic->next;
                                    } /*** end while pic != NULL ***/

                                 if(isclose > 0) /*** found that rlc edge from ii to i overlapps an rac edge - remove any assoc conditions ***/
                                    {
                                    if(ERsave != NULL)
                                       {
                                       ERn = ERroot;
                                       ERroot = ERsave->next;
                                       ERsave->next = NULL;
                                       while(ERn != NULL)
                                          {
                                          ERc = ERn;
                                          ERn = ERn->next;
                                          free(ERc);
                                          }
                                       }
                                    /**isclose = 0;
                                    ERsave = NULL;**/
                                    }
                                 } /*** end LSLICEroot != NULL ****/


                              if(LSLICEroot != NULL)
                                 {
                                 pic = LSLICEroot;
                                 while(pic != NULL)
                                    {
                                    pic2 = pic;
                                    pic = pic->next;
                                    free(pic2);
                                    }
                                 LSLICEroot = NULL;
                                 }
                              }
                           ++ii;
                           } /** end for(i=1; i<rlc->numnodes; i++) ***/
                        } /*** end need to check this line and area pair ***/
                     } /*** end check applies to rac ***/
                  rac = rac->next;
                  } /*** end while rac ***/
               } /*** end part1 is true for rlc ***/
            }  /** end check for LSLICEA ***/






         if((CombinedCheckApplies(rlc->idn,checkinstance,LENOCOVERA,rlc->Lindex,rlc->Sindex,Config1,Strat1,Domain1,&part1,&part2,&part3) > 0) &&
               (part1 > 0))
            {
            checkit = 1;
            thiskey = LENOCOVERA;
            }
         else if((CombinedCheckApplies(rlc->idn,checkinstance,OVERUNDER,rlc->Lindex,rlc->Sindex,Config1,Strat1,Domain1,&part1,&part2,&part3) > 0) &&
               (part1 > 0))
            {
            checkit = 1;
            thiskey = OVERUNDER;
            }
         else
            checkit = 0;
         if(checkit > 0)
            {
            rac = Aroot;
            while(rac != NULL)
               {
               Config2 = SCCtable[rac->Sindex].C;
               Strat2 = SCCtable[rac->Sindex].S;
               Domain2 = SCCtable[rac->Sindex].D;
               if((CombinedCheckApplies(rac->idn,checkinstance,thiskey,rac->Lindex,rac->Sindex,
                            Config2,Strat2,Domain2,&part1,&part2,&part3) > 0) && (part2 > 0))
                  {
                  j = 0;
                  while(j < rlc->numnodes)
                     {
                     keepit = 0;

                     if((rlc->x[j] >= minx) && (rlc->x[j] <= maxx) && (rlc->y[j] >= miny) && (rlc->y[j] <= maxy))
                        {
                        temp = PointToArealEdgeDist2D(rlc->x[j], rlc->y[j], rac, &kk);
                        if(SensitivityCheck(OPENINT,thiskey,checkinstance, temp) > 0)
                           keepit = 1;
                        }

                     if((keepit > 0) && (thiskey == OVERUNDER))
                        {
                        if(rac->RB_Tree_Edgelist == NULL)
                           {
                           if(PointInsidePoly(rlc->x[j],rlc->y[j],rac->x, rac->y, rac->numverts) < 1)
                              {
                              keepit = 0;
                              }
                           }
                        else if((PointInsideLargeAreal(rlc->x[j], rlc->y[j] ,rac, &onedge)   < 1) &&
                           (onedge == 0))
                           {
                           keepit = 0;
                           }
                        }
                  
                     if(keepit > 0)
                        {
                        ERc = (struct collection *) (malloc(SzC));
                        if(ERc == NULL)
                           {
                           printf("allocation memory exhausted during linear feature condition analysis\n");
                           printf("processing cannot continue\n");
                           exit(-1);
                           }
                        ERc->x[0] = rlc->x[j];
                        ERc->y[0] = rlc->y[j];
                        ERc->z[0] = rlc->z[j];
                        ERc->x[1] = rac->x[kk];
                        ERc->y[1] = rac->y[kk];
                        ERc->z[1] = rac->z[kk];
                        if(kk == 0)
                           {
                           ERc->x[2] = rac->x[rac->numverts-1];
                           ERc->y[2] = rac->y[rac->numverts-1];
                           ERc->z[2] = rac->z[rac->numverts-1];
                           }
                        else
                           {
                           ERc->x[2] = rac->x[kk-1];
                           ERc->y[2] = rac->y[kk-1];
                           ERc->z[2] = rac->z[kk-1];
                           }
                        ERc->magnitude = temp;
                        ERc->keyval = thiskey;
                        ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                        ERc->Sindex = rlc->Sindex;
                        ERc->ll1 = rlc;
                        ERc->aa = rac;
                        ERc->next = NULL;

                        ERn = ERroot;
                        while(ERn != NULL)
                           {
                           if((ERn->Cnumber == ERc->Cnumber) && (ERn->keyval == ERc->keyval) && (ERn->ll1 == ERc->ll1) &&
                                (ERn->aa == ERc->aa) && (ERn->x[0] == ERc->x[0]) && (ERn->magnitude == ERc->magnitude) &&
                                (ERn->y[0] == ERc->y[0]) && (ERn->Sindex    == ERc->Sindex))
                              break;
                           ERn = ERn->next;
                           }
                        if(ERn == NULL) 
                           {
                           ERc->next = ERroot;
                           ERroot = ERc;
                           }
                        else
                           free(ERc);
                        }
                     j = j + rlc->numnodes - 1;
                     } /*** end while j < rlc->numnodes ***/
                  }
               rac = rac->next;
               }
            } /** end LENOCOVERA  and / or OVERUNDER check applies ****/




         if(CombinedCheckApplies(rlc->idn,checkinstance,SHARE3SEG,rlc->Lindex,rlc->Sindex,Config1,Strat1,Domain1,&part1,&part2,&part3) > 0)
            {
            if(part1 > 0)
               {
               tempsensitivity = FindRelevantSensitivity(SHARE3SEG,checkinstance,&tempsensitivity2);
               ii = 0;
               for(i=1; i<rlc->numnodes; i++)
                  {
                  checkit = 0;
                  found_one = 0;
                  found_two = 0;
                  x1 = rlc->x[ii];
                  y1 = rlc->y[ii];
                  z1 = rlc->z[ii];
                  x2 = rlc->x[i];
                  y2 = rlc->y[i];
                  z2 = rlc->z[i];
                  if(ClipLineToRegion(minx,miny,maxx,maxy,&x1,&y1,&z1,&x2,&y2,&z2,&clipflag,multiplier) > 0)
                     {
                     checkit = 1;
                     }

                  if(checkit > 0)
                     {
                     if(rlc->x[ii] < rlc->x[i])
                        {
                        minLx = rlc->x[ii];
                        maxLx = rlc->x[i];
                        }
                     else
                        {
                        minLx = rlc->x[i];
                        maxLx = rlc->x[ii];
                        }
                     if(rlc->y[ii] < rlc->y[i])
                        {
                        minLy = rlc->y[ii];
                        maxLy = rlc->y[i];
                        }
                     else
                        {
                        minLy = rlc->y[i];
                        maxLy = rlc->y[ii];
                        }


                     rln = root;
                     while(rln != NULL)
                        {
                        if((rln != rlc) &&
                         (CombinedCheckApplies(rln->idn,checkinstance,SHARE3SEG,rln->Lindex,rln->Sindex,
                                SCCtable[rln->Sindex].C,SCCtable[rln->Sindex].S,SCCtable[rln->Sindex].D,&part1,&part2,&part3) > 0))
                           {
                           if(part2 > 0)
                              {
                              jj = 0;
                              for(j=1; j<rln->numnodes; j++)
                                 {
                                 checkit2 = 0;
                                 if(rln->x[jj] > rln->x[j])
                                    {
                                    if((rln->x[jj] >= minLx) && (rln->x[j] <= maxLx))
                                       {
                                       if(rln->y[jj] > rln->y[j])
                                          {
                                          if((rln->y[jj] >= minLy) && (rln->y[j] <= maxLy))
                                             checkit2 = 1;
                                          }
                                       else if((rln->y[j] >= minLy) && (rln->y[jj] <= maxLy))
                                             checkit2 = 1;
                                       }
                                    }
                                 else
                                    {
                                    if((rln->x[j] >= minLx) && (rln->x[jj] <= maxLx))
                                       {
                                       if(rln->y[jj] > rln->y[j])
                                          {
                                          if((rln->y[jj] >= minLy) && (rln->y[j] <= maxLy))
                                             checkit2 = 1;
                                          }
                                       else if((rln->y[j] >= minLy) && (rln->y[jj] <= maxLy))
                                             checkit2 = 1;
                                       }
                                    }

                                 if(checkit2 > 0)
                                    {
                                    if(MergeSeg_LineSegmentsOverlap(rlc->x[i],rlc->y[i],rlc->x[ii],rlc->y[ii],
                                        rln->x[j],rln->y[j],rln->x[jj],rln->y[jj],minLx,maxLx,minLy,maxLy,
                                        &xi, &yi, &xi2, &yi2, tempsensitivity ) > 0)
                                       {
                                       segdist = Distance(xi,yi,xi2,yi2);
                                       if(segdist > tempsensitivity2)
                                          {
                                          rln2 = root;
                                          while(rln2 != NULL)
                                             {
                                             if((rln2 != rlc) && (rln2 != rln) &&
                                              (CombinedCheckApplies(rln2->idn,checkinstance,SHARE3SEG,rln2->Lindex,rln2->Sindex,
                                                     SCCtable[rln2->Sindex].C,SCCtable[rln2->Sindex].S,SCCtable[rln2->Sindex].D,&part1,&part2,&part3) > 0))
                                                {
                                                if(part3 > 0)
                                                   {
                                                   kk = 0;
                                                   for(k=1; k<rln2->numnodes; k++)
                                                      {
                                                      checkit3 = 0;
                                                      if(rln2->x[kk] > rln2->x[k])
                                                         {
                                                         if((rln2->x[kk] >= minLx) && (rln2->x[k] <= maxLx))
                                                            {
                                                            if(rln2->y[kk] > rln2->y[k])
                                                               {
                                                               if((rln2->y[kk] >= minLy) && (rln2->y[k] <= maxLy))
                                                                  checkit3 = 1;
                                                               }
                                                            else if((rln2->y[k] >= minLy) && (rln2->y[kk] <= maxLy))
                                                                  checkit3 = 1;
                                                            }
                                                         }
                                                      else
                                                         {
                                                         if((rln2->x[k] >= minLx) && (rln2->x[kk] <= maxLx))
                                                            {
                                                            if(rln2->y[kk] > rln2->y[k])
                                                               {
                                                               if((rln2->y[kk] >= minLy) && (rln2->y[k] <= maxLy))
                                                                  checkit3 = 1;
                                                               }
                                                            else if((rln2->y[k] >= minLy) && (rln2->y[kk] <= maxLy))
                                                                  checkit3 = 1;
                                                            }
                                                         }
                  
                                                      if(checkit3 > 0)
                                                         {
                                                         if(MergeSeg_LineSegmentsOverlap(rlc->x[i],rlc->y[i],rlc->x[ii],rlc->y[ii],
                                                             rln2->x[k],rln2->y[k],rln2->x[kk],rln2->y[kk],minLx,maxLx,minLy,maxLy,
                                                             &xi, &yi, &xi2, &yi2, tempsensitivity ) > 0)
                                                            {
                                                            segdist2 = Distance(xi,yi,xi2,yi2);
                                                            if(segdist2 > tempsensitivity2)
                                                               {
                                                               if(MergeSeg_LineSegmentsOverlap(rln->x[j],rln->y[j],rln->x[jj],rln->y[jj],
                                                                   rln2->x[k],rln2->y[k],rln2->x[kk],rln2->y[kk],minLx,maxLx,minLy,maxLy,
                                                                      &xi, &yi, &xi2, &yi2, tempsensitivity ) > 0)
                                                                  {
                                                                  temp4 = Distance(xi,yi,xi2,yi2);
                                                                  if(temp4 > tempsensitivity2)
                                                                     {
                                                                     found_one = 1;
                                                                     if(segdist2 < segdist)
                                                                        segdist = segdist2;
                                                                     if(temp4 < segdist)
                                                                        segdist = temp4;

                                                                     break; /*** should break from the for k loop ***/
                                                                     }
                                                                  } /*** end rln and rln2 also overlap ***/
                                                               } /*** end segdist2 is big enough ***/
                                                            } /*** end rlc and rln2 also overlap ***/
                                                         } /*** end checkit3 test passes ***/
                                                      kk = k;
                                                      } /*** end for k ***/
                                                   } /** end rln2 qualifies as part3 ***/
                                                } /*** end rln2 has some potential ***/
                                             if(found_one > 0)
                                                break;
                                             rln2 = rln2->next;
                                             } /** end while rln2 ***/


                                          if(found_one == 0) /** could not find 3 overlapping lines - try an area edge as tertiary ***/
                                             {
                                             ran = Aroot;
                                             while(ran != NULL)
                                                {
                                                if(CombinedCheckApplies(ran->idn,checkinstance,SHARE3SEG,
                                                           ran->Lindex,ran->Sindex,
                                                               SCCtable[ran->Sindex].C,SCCtable[ran->Sindex].S,SCCtable[ran->Sindex].D,
                                                                  &part1,&part2,&part3) > 0)
                                                   {
                                                   if(part3 > 0)
                                                      {
                                                      if(ran->RB_Tree_Edgelist != NULL)
                                                         {
                                                         FirstK = 1;
                                                         LastEdge2 = NULL;
                                                         LastK = -1;
                                                         k = GetNextArealIndex(ran, LastK, 1, &LastEdge2, cindex, &UsedTree);
                                                         LastK = k;
                                                         }
                                                      else
                                                         {
                                                         FirstK = 0;
                                                         k = 0;
                                                         }
                                                      while(k >= 0)
                                                         {
                                                         kk = k + 1;
                                                         if(kk == ran->numverts)
                                                            kk = 0;
                                                         checkit3 = 0;
                                                         if(ran->x[kk] > ran->x[k])
                                                            {
                                                            if((ran->x[kk] >= minLx) && (ran->x[k] <= maxLx))
                                                               {
                                                               if(ran->y[kk] > ran->y[k])
                                                                  {
                                                                  if((ran->y[kk] >= minLy) && (ran->y[k] <= maxLy))
                                                                     checkit3 = 1;
                                                                  }
                                                               else if((ran->y[k] >= minLy) && (ran->y[kk] <= maxLy))
                                                                     checkit3 = 1;
                                                               }
                                                            }
                                                         else
                                                            {
                                                            if((ran->x[k] >= minLx) && (ran->x[kk] <= maxLx))
                                                               {
                                                               if(ran->y[kk] > ran->y[k])
                                                                  {
                                                                  if((ran->y[kk] >= minLy) && (ran->y[k] <= maxLy))
                                                                     checkit3 = 1;
                                                                  }
                                                               else if((ran->y[k] >= minLy) && (ran->y[kk] <= maxLy))
                                                                     checkit3 = 1;
                                                               }
                                                            }
                     
                                                         if(checkit3 > 0)
                                                            {
                                                            if(MergeSeg_LineSegmentsOverlap(rlc->x[i],rlc->y[i],rlc->x[ii],rlc->y[ii],
                                                                ran->x[k],ran->y[k],ran->x[kk],ran->y[kk],minLx,maxLx,minLy,maxLy,
                                                                &xi, &yi, &xi2, &yi2, tempsensitivity ) > 0)
                                                               {
                                                               segdist2 = Distance(xi,yi,xi2,yi2);
                                                               if(segdist2 > tempsensitivity2)
                                                                  {
                                                                  if(MergeSeg_LineSegmentsOverlap(rln->x[j],rln->y[j],rln->x[jj],rln->y[jj],
                                                                      ran->x[k],ran->y[k],ran->x[kk],ran->y[kk],minLx,maxLx,minLy,maxLy,
                                                                         &xi, &yi, &xi2, &yi2, tempsensitivity ) > 0)
                                                                     {
                                                                     temp4 = Distance(xi,yi,xi2,yi2);
                                                                     if(temp4 > tempsensitivity2)
                                                                        {
                                                                        found_one = 1;
                                                                        if(segdist2 < segdist)
                                                                           segdist = segdist2;
                                                                        if(temp4 < segdist)
                                                                           segdist = temp4;
   
                                                                        break; /*** should break from the while k loop ***/
                                                                        }
                                                                     } /*** end rln and ran also overlap ***/
                                                                  } /*** end segdist2 is big enough ***/
                                                               } /*** end rlc and ran also overlap ***/
                                                            } /*** end checkit3 test passes ***/
   
                                                         if(ran->RB_Tree_Edgelist != NULL)
                                                            {
                                                            if(FirstK == 1)
                                                               {
                                                               k = k - 1;
                                                               if(k < 0)
                                                                  k = ran->numverts - 1;
                                                               FirstK = 0;
                                                               }
                                                            else
                                                               {
                                                               k = GetNextArealIndex(ran, LastK, 1, &LastEdge2, cindex, &UsedTree);
                                                               LastK = k;
                                                               }
                                                            }
                                                         else
                                                            {
                                                            ++k;
                                                            if(k >= ran->numverts)
                                                               k = -1;
                                                            }
                                                         } /*** end while looping thru edges of ran ***/
                                                      } /*** end ran qualifies as part3 ***/
                                                   } /*** end check applies to ran ***/
                                                if(found_one > 0) 
                                                   break;
                                                ran = ran->next;
                                                } /** end while ran ***/
                                             } /** end need to try area features as tertiary ***/

                                          } /** end overlap of rlc and rln is large enough **/
                                       } /*** end rlc and rln overlap ***/
                                    } /** end checkit2 ***/
                                 if(found_one > 0)
                                    break;
                                 jj = j;
                                 } /** end for j ***/
                              } /*** end rln qualifies as part2 **/
                           } /*** end check applies to rln ***/
                        if(found_one > 0)
                           break;
                        rln = rln->next;
                        } /** end while rln ***/

                     if(found_one == 0) /*** did not find overlap of this segment with a secondary line and tertiary line or area - try secondary area ***/
                        {
                        rac = Aroot;
                        while(rac != NULL)
                           {
                           if(CombinedCheckApplies(rac->idn,checkinstance,SHARE3SEG,
                                      rac->Lindex,rac->Sindex,
                                           SCCtable[rac->Sindex].C,SCCtable[rac->Sindex].S,SCCtable[rac->Sindex].D,
                                            &part1,&part2,&part3) > 0)
                              {
                              if(part2 > 0)
                                 {
                                 if(rac->RB_Tree_Edgelist != NULL)
                                    {
                                    FirstJ = 1;
                                    LastEdge1 = NULL;
                                    LastJ = -1;
                                    j = GetNextArealIndex(rac, LastJ, 1, &LastEdge1, cindex, &UsedTree);
                                    LastJ = j;
                                    }
                                 else
                                    {
                                    FirstJ = 0;
                                    j = 0;
                                    }
                                 while(j >= 0)
                                    {
                                    jj = j + 1;
                                    if(jj == rac->numverts)
                                       jj = 0;
                                    checkit2 = 0;
                                    if(rac->x[jj] > rac->x[j])
                                       {
                                       if((rac->x[jj] >= minLx) && (rac->x[j] <= maxLx))
                                          {
                                          if(rac->y[jj] > rac->y[j])
                                             {
                                             if((rac->y[jj] >= minLy) && (rac->y[j] <= maxLy))
                                                checkit2 = 1;
                                             }
                                          else if((rac->y[j] >= minLy) && (rac->y[jj] <= maxLy))
                                                checkit2 = 1;
                                          }
                                       }
                                    else
                                       {
                                       if((rac->x[j] >= minLx) && (rac->x[jj] <= maxLx))
                                          {
                                          if(rac->y[jj] > rac->y[j])
                                             {
                                             if((rac->y[jj] >= minLy) && (rac->y[j] <= maxLy))
                                                checkit2 = 1;
                                             }
                                          else if((rac->y[j] >= minLy) && (rac->y[jj] <= maxLy))
                                                checkit2 = 1;
                                          }
                                       }
   
                                    if(checkit2 > 0)
                                       {
                                       if(MergeSeg_LineSegmentsOverlap(rlc->x[i],rlc->y[i],rlc->x[ii],rlc->y[ii],
                                           rac->x[j],rac->y[j],rac->x[jj],rac->y[jj],minLx,maxLx,minLy,maxLy,
                                           &xi, &yi, &xi2, &yi2, tempsensitivity ) > 0)
                                          {
                                          segdist = Distance(xi,yi,xi2,yi2);
                                          if(segdist > tempsensitivity2)
                                             {
                                             rln2 = root;
                                             while(rln2 != NULL)
                                                {
                                                if((rln2 != rlc) && 
                                                 (CombinedCheckApplies(rln2->idn,checkinstance,SHARE3SEG,rln2->Lindex,rln2->Sindex,
                                                        SCCtable[rln2->Sindex].C,SCCtable[rln2->Sindex].S,SCCtable[rln2->Sindex].D,&part1,&part2,&part3) > 0))
                                                   {
                                                   if(part3 > 0)
                                                      {
                                                      kk = 0;
                                                      for(k=1; k<rln2->numnodes; k++)
                                                         {
                                                         checkit3 = 0;
                                                         if(rln2->x[kk] > rln2->x[k])
                                                            {
                                                            if((rln2->x[kk] >= minLx) && (rln2->x[k] <= maxLx))
                                                               {
                                                               if(rln2->y[kk] > rln2->y[k])
                                                                  {
                                                                  if((rln2->y[kk] >= minLy) && (rln2->y[k] <= maxLy))
                                                                     checkit3 = 1;
                                                                  }
                                                               else if((rln2->y[k] >= minLy) && (rln2->y[kk] <= maxLy))
                                                                     checkit3 = 1;
                                                               }
                                                            }
                                                         else
                                                            {
                                                            if((rln2->x[k] >= minLx) && (rln2->x[kk] <= maxLx))
                                                               {
                                                               if(rln2->y[kk] > rln2->y[k])
                                                                  {
                                                                  if((rln2->y[kk] >= minLy) && (rln2->y[k] <= maxLy))
                                                                     checkit3 = 1;
                                                                  }
                                                               else if((rln2->y[k] >= minLy) && (rln2->y[kk] <= maxLy))
                                                                     checkit3 = 1;
                                                               }
                                                            }
   
                                                         if(checkit3 > 0)
                                                            {
                                                            if(MergeSeg_LineSegmentsOverlap(rlc->x[i],rlc->y[i],rlc->x[ii],rlc->y[ii],
                                                                rln2->x[k],rln2->y[k],rln2->x[kk],rln2->y[kk],minLx,maxLx,minLy,maxLy,
                                                                &xi, &yi, &xi2, &yi2, tempsensitivity ) > 0)
                                                               {
                                                               segdist2 = Distance(xi,yi,xi2,yi2);
                                                               if(segdist2 > tempsensitivity2)
                                                                  {
                                                                  if(MergeSeg_LineSegmentsOverlap(rac->x[j],rac->y[j],rac->x[jj],rac->y[jj],
                                                                      rln2->x[k],rln2->y[k],rln2->x[kk],rln2->y[kk],minLx,maxLx,minLy,maxLy,
                                                                         &xi, &yi, &xi2, &yi2, tempsensitivity ) > 0)
                                                                     {
                                                                     temp4 = Distance(xi,yi,xi2,yi2);
                                                                     if(temp4 > tempsensitivity2)
                                                                        {
                                                                        found_one = 1;
                                                                        if(segdist2 < segdist)
                                                                           segdist = segdist2;
                                                                        if(temp4 < segdist)
                                                                           segdist = temp4;

                                                                        break; /*** should break from the for k loop ***/
                                                                        }
                                                                     } /*** end rac and rln2 also overlap ***/
                                                                  } /*** end segdist2 is big enough ***/
                                                               } /*** end rlc and rln2 also overlap ***/
                                                            } /*** end checkit3 test passes ***/
                                                         kk = k;
                                                         } /*** end for k ***/
                                                      } /** end rln2 qualifies as part3 ***/
                                                   } /*** end rln2 has some potential ***/
                                                if(found_one > 0)
                                                   break;
                                                rln2 = rln2->next;
                                                } /** end while rln2 ***/

                                             if(found_one == 0) /** could not find 3 overlapping features - try an area edge as tertiary ***/
                                                {
                                                ran = Aroot;
                                                while(ran != NULL)
                                                   {
                                                   if((ran != rac) && 
                                                         (CombinedCheckApplies(ran->idn,checkinstance,SHARE3SEG,
                                                              ran->Lindex,ran->Sindex,
                                                               SCCtable[ran->Sindex].C,SCCtable[ran->Sindex].S,SCCtable[ran->Sindex].D,
                                                                    &part1,&part2,&part3) > 0))
                                                      {
                                                      if(part3 > 0)
                                                         {
                                                         if(ran->RB_Tree_Edgelist != NULL)
                                                            {
                                                            FirstK = 1;
                                                            LastEdge2 = NULL;
                                                            LastK = -1;
                                                            k = GetNextArealIndex(ran, LastK, 1, &LastEdge2, cindex, &UsedTree);
                                                            LastK = k;
                                                            }
                                                         else
                                                            {
                                                            FirstK = 0;
                                                            k = 0;
                                                            }
                                                         while(k >= 0)
                                                            {
                                                            kk = k + 1;
                                                            if(kk == ran->numverts)
                                                               kk = 0;
                                                            checkit3 = 0;
                                                            if(ran->x[kk] > ran->x[k])
                                                               {
                                                               if((ran->x[kk] >= minLx) && (ran->x[k] <= maxLx))
                                                                  {
                                                                  if(ran->y[kk] > ran->y[k])
                                                                     {
                                                                     if((ran->y[kk] >= minLy) && (ran->y[k] <= maxLy))
                                                                        checkit3 = 1;
                                                                     }
                                                                  else if((ran->y[k] >= minLy) && (ran->y[kk] <= maxLy))
                                                                        checkit3 = 1;
                                                                  }
                                                               }
                                                            else
                                                               {
                                                               if((ran->x[k] >= minLx) && (ran->x[kk] <= maxLx))
                                                                  {
                                                                  if(ran->y[kk] > ran->y[k])
                                                                     {
                                                                     if((ran->y[kk] >= minLy) && (ran->y[k] <= maxLy))
                                                                        checkit3 = 1;
                                                                     }
                                                                  else if((ran->y[k] >= minLy) && (ran->y[kk] <= maxLy))
                                                                        checkit3 = 1;
                                                                  }
                                                               }

                                                            if(checkit3 > 0)
                                                               {
                                                               if(MergeSeg_LineSegmentsOverlap(rlc->x[i],rlc->y[i],rlc->x[ii],rlc->y[ii],
                                                                   ran->x[k],ran->y[k],ran->x[kk],ran->y[kk],minLx,maxLx,minLy,maxLy,
                                                                   &xi, &yi, &xi2, &yi2, tempsensitivity ) > 0)
                                                                  {
                                                                  segdist2 = Distance(xi,yi,xi2,yi2);
                                                                  if(segdist2 > tempsensitivity2)
                                                                     {
                                                                     if(MergeSeg_LineSegmentsOverlap(rac->x[j],rac->y[j],rac->x[jj],rac->y[jj],
                                                                         ran->x[k],ran->y[k],ran->x[kk],ran->y[kk],minLx,maxLx,minLy,maxLy,
                                                                            &xi, &yi, &xi2, &yi2, tempsensitivity ) > 0)
                                                                        {
                                                                        temp4 = Distance(xi,yi,xi2,yi2);
                                                                        if(temp4 > tempsensitivity2)
                                                                           {

                                                                           found_one = 1;
                                                                           if(segdist2 < segdist)
                                                                              segdist = segdist2;
                                                                           if(temp4 < segdist)
                                                                              segdist = temp4;

                                                                           break; /*** should break from the while k loop ***/
                                                                           }
                                                                        } /*** end rac and ran also overlap ***/
                                                                     } /*** end segdist2 is big enough ***/
                                                                  } /*** end rlc and ran also overlap ***/
                                                               } /*** end checkit3 test passes ***/
   
                                                            if(found_one > 0)
                                                               break;
                                                            if(ran->RB_Tree_Edgelist != NULL)
                                                               {
                                                               if(FirstK == 1)
                                                                  {
                                                                  k = k - 1;
                                                                  if(k < 0)
                                                                     k = ran->numverts - 1;
                                                                  FirstK = 0;
                                                                  }
                                                               else
                                                                  {
                                                                  k = GetNextArealIndex(ran, LastK, 1, &LastEdge2, cindex, &UsedTree);
                                                                  LastK = k;
                                                                  }
                                                               }
                                                            else
                                                               {
                                                               ++k;
                                                               if(k >= ran->numverts)
                                                                  k = -1;
                                                               }
                                                            } /*** end while looping thru edges of ran ***/
                                                         } /*** end ran qualifies as part3 ***/
                                                      } /*** end check applies to ran ***/
                                                   if(found_one > 0)
                                                      break;
                                                   ran = ran->next;
                                                   } /** end while ran ***/
                                                } /** end need to try area features as tertiary ***/
                                             }
                                          }
                                       }

                                    if(found_one > 0)
                                       break;

                                    if(rac->RB_Tree_Edgelist != NULL)
                                       {
                                       if(FirstJ == 1)
                                          {
                                          j = j - 1;
                                          if(j < 0)
                                             j = rac->numverts - 1;
                                          FirstJ = 0;
                                          }
                                       else
                                          {
                                          j = GetNextArealIndex(rac, LastJ, 1, &LastEdge1, cindex, &UsedTree);
                                          LastJ = j;
                                          }
                                       }
                                    else
                                       {
                                       ++j;
                                       if(j >= rac->numverts)
                                          j = -1;
                                       }
                                    } /*** end while j >= 0  *******/
                                 } /*** end if part2 applies ***/
                              }  /*** end SHARE3SEG applies ***/

                           if(found_one > 0)
                              break;
                           rac = rac->next;
                           } /*** end while rac != NULL ***/

                        }  /*** end trying an area edge as the secondary ***/
                     if(found_one > 0) /*** then there is a condition to report ***/
                        {
                        ERc = (struct collection *) (malloc(SzC));
                        if(ERc == NULL)
                           {
                           printf("allocation memory exhausted during linear feature condition analysis\n");
                           printf("processing cannot continue\n");
                           exit(-1);
                           }
                        ERc->magnitude = segdist;
                        ERc->keyval = SHARE3SEG;
                        ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                        ERc->IDN = rlc->idn;
                        ERc->Sindex = rlc->Sindex;
                        ERc->ll1 = rlc;
                        ERc->ll2 = NULL;
                        if(ii < i)
                           {
                           ERc->vertexindex2 = i;
                           ERc->vertexindex1 = ii;
                           }
                        else
                           {
                           ERc->vertexindex2 = ii;
                           ERc->vertexindex1 = i;
                           }
                        ERc->x[0] = rlc->x[ii];
                        ERc->y[0] = rlc->y[ii];
                        ERc->z[0] = rlc->z[ii];
                        ERc->x[1] = rlc->x[i];
                        ERc->y[1] = rlc->y[i];
                        ERc->z[1] = rlc->z[i];

                        ERc->next = NULL;
                        if(ERroot == NULL)
                           {
                           ERroot = ERc;
                           }
                        else
                           {
                           ERn = ERroot;
                           while(ERn != NULL)
                              {
                                if((ERn->Cnumber == ERc->Cnumber) && (ERn->keyval == ERc->keyval) &&
                                   (ERn->ll1 == ERc->ll1) && 
                                    (ERn->vertexindex1 == ERc->vertexindex1) && (ERn->vertexindex2 == ERc->vertexindex2))
                                 break;
                              ERn = ERn->next;
                              }
                           if(ERn == NULL)
                              {
                              ERc->next = ERroot;
                              ERroot = ERc;
                              }
                           else
                             free(ERc);
                           }
                        } /** end recording a condition ***/
                     } /** end this segment of rlc is in the LM window so checkit **/
                  ii = i;
                  } /*** end for i & rlc->numnodes ***/
               } /** end rlc qualifies as part1 ***/
            } /*** end SHARE3SEG applies to rlc ***/






         if(CombinedCheckApplies(rlc->idn,checkinstance,SHARESEG,rlc->Lindex,rlc->Sindex,Config1,Strat1,Domain1,&part1,&part2,&part3) > 0)
            {
            if(part1 > 0)
               {
               tolerancepad = FindRelevantSensitivity(SHARESEG,checkinstance,&tempsensitivity);
if(tempsensitivity < 0.00000009)
   tempsensitivity = 0.00000009;

               rln = root;
               while(rln != NULL)
                  {
                  found_one = 0;
                  if((rln != rlc) &&
                   (CombinedCheckApplies(rln->idn,checkinstance,SHARESEG,rln->Lindex,rln->Sindex,
                          SCCtable[rln->Sindex].C,SCCtable[rln->Sindex].S,SCCtable[rln->Sindex].D,&part1,&part2,&part3) > 0))
                     {
                     if((part2 > 0) &&
                         ((rlc->IsMulti == 0) || (rln->IsMulti == 0) ||
                            (CheckThisLinePair(checkinstance,CTLPmaxindex, SzPC,SzPW,rlc->localID,rln->localID,
                                     rlc->firstencounter,rln->firstencounter,rlc->length,rln->length) > 0)))
                        {

                        found_one = 0;
                        ii = 0;
                        for(i=1; i<rlc->numnodes; i++)
                           {
                           checkit = 1;
                           if(checkit > 0)
                              {
                              if(rlc->x[ii] < rlc->x[i])
                                 {
                                 minLx = rlc->x[ii];
                                 maxLx = rlc->x[i];
                                 }
                              else
                                 {
                                 minLx = rlc->x[i];
                                 maxLx = rlc->x[ii];
                                 }
                              if(rlc->y[ii] < rlc->y[i])
                                 {
                                 minLy = rlc->y[ii];
                                 maxLy = rlc->y[i];
                                 }
                              else
                                 {
                                 minLy = rlc->y[i];
                                 maxLy = rlc->y[ii];
                                 }
                              jj = 0;
                              for(j=1; j<rln->numnodes; j++)
                                 {
if(rln->x[j] > rln->x[jj])
   {
   minvx = rln->x[jj] - 0.5;
   maxvx = rln->x[j] + 0.5;
   }
else
   {
   minvx = rln->x[j] - 0.5;
   maxvx = rln->x[jj] + 0.5;
   }
if(rln->y[j] > rln->y[jj])
   {
   minvy = rln->y[jj] - 0.5;
   maxvy = rln->y[j] + 0.5;
   }
else
   {
   minvy = rln->y[j] - 0.5;
   maxvy = rln->y[jj] + 0.5;
   }
if((minLx < maxvx) && (maxLx > minvx) && (minLy < maxvy) && (maxLy > minvy))
   {
                                 if((ActiveChecks[checkinstance].sensitivity3 < 0) ||
                                     (IsSentinelZvalue(rlc->z[i],UseNUNANPO) > 0) ||
                                      (IsSentinelZvalue(rlc->z[ii],UseNUNANPO) > 0) ||
                                      (IsSentinelZvalue(rln->z[j],UseNUNANPO) > 0) ||
                                        (IsSentinelZvalue(rln->z[j],UseNUNANPO) > 0))
                                    {
                                    zdiff = ActiveChecks[checkinstance].sensitivity3 - 100;
                                    }
                                 else
                                    {
                                    t1 = InterpLinearElev(rlc->x[i],rlc->y[i],rlc->z[i],rlc->x[ii],rlc->y[ii],rlc->z[ii],
                                           rln->x[j],rln->y[j]);
                                    if(t1 > rln->z[j])
                                       t1 = t1 - rln->z[j];
                                    else
                                       t1 = rln->z[j] - t1;

                                    t2 = InterpLinearElev(rlc->x[i],rlc->y[i],rlc->z[i],rlc->x[ii],rlc->y[ii],rlc->z[ii],
                                           rln->x[jj],rln->y[jj]);
                                    if(t2 > rln->z[jj])
                                       t2 = t2 - rln->z[jj];
                                    else
                                       t2 = rln->z[jj] - t2;
                                    if(t2 > t1)
                                       zdiff = t2;
                                    else
                                       zdiff = t1;
                                    }

                                 if((zdiff <= ActiveChecks[checkinstance].sensitivity3) &&
                                     (MergeSeg_LineSegmentsOverlap(rlc->x[i],rlc->y[i],rlc->x[ii],rlc->y[ii],
                                           rln->x[j],rln->y[j],rln->x[jj],rln->y[jj],minLx,maxLx,minLy,maxLy,
                                           &xi, &yi, &xi2, &yi2, tolerancepad ) > 0))/***/
                                    {
                                    segdist = Distance(xi,yi,xi2,yi2);
                                    if(segdist >= tempsensitivity)
                                       {
                                       rln2 = root;
                                       while(rln2 != NULL)
                                          {
                                          CoveredSoFar = 0;
                                          found_one = 0;
                                          if((rln2 != rlc) && (rln2 != rln) &&
                                           (CombinedCheckApplies(rln2->idn,checkinstance,SHARESEG,rln2->Lindex,rln2->Sindex,
                                               SCCtable[rln2->Sindex].C,SCCtable[rln2->Sindex].S,SCCtable[rln2->Sindex].D,
                                                     &part1,&part2,&part3) > 0))
                                             {
                                             if(part3 > 0)
                                                {
                                                CoveredSoFar = 0;
                                                kk = 0;
                                                for(k=1; k<rln2->numnodes; k++)
                                                   {
                                                   if(MergeSeg_LineSegmentsOverlap(rlc->x[i],rlc->y[i],rlc->x[ii],rlc->y[ii],
                                                                rln2->x[k],rln2->y[k],rln2->x[kk],rln2->y[kk],minLx,maxLx,minLy,maxLy,
                                                                &xi, &yi, &xi2, &yi2, tolerancepad ) > 0)
                                                      {
                                                      CoveredSoFar =  CoveredSoFar + Distance(xi,yi,xi2,yi2);
                                                      if(CoveredSoFar >= segdist)
                                                         {
                                                         break;
                                                         }
                                                      }
                                                   kk = k;
                                                   }
                                                }
                                             }
                                          if(CoveredSoFar >= segdist)
                                             {
                                             break;
                                             }
                                          rln2 = rln2->next;
                                          }
                                       if(rln2 == NULL) /** did not find a third covering line segment - check for covering area feature ***/
                                          {
                                          rln3temp->x[0] = rlc->x[i];
                                          rln3temp->y[0] = rlc->y[i];
                                          rln3temp->z[0] = rlc->z[i];
                                          rln3temp->x[1] = rlc->x[ii];
                                          rln3temp->y[1] = rlc->y[ii];
                                          rln3temp->z[1] = rlc->z[ii];
               
                                          rac = Aroot;
                                          while(rac != NULL)
                                             {
                                             if((rac->ishole <= 0) && 
                                              (CombinedCheckApplies(rac->idn,checkinstance,SHARESEG,rac->Lindex,rac->Sindex,
                                                SCCtable[rac->Sindex].C,SCCtable[rac->Sindex].S,SCCtable[rac->Sindex].D,
                                                      &part1,&part2,&part3) > 0))
                                                {
                                                if(part3 > 0)
                                                   {
                                                   
                                                   inside1 = LineAllInsideArea(rln3temp,rac,ActiveChecks[checkinstance].sensitivity);
                                                   if((inside1 > 0) && (rac->ishole < 0))
                                                      {
                                                      rah = Aroot;
                                                      while(rah != NULL)
                                                         {
                                                         if((rah->ishole > 0) && (rah->idn == rac->idn))
                                                            {
                                                            inside2 = LinePartOrAllInsideArea(rln3temp,rah, &kk,
                                                                            &kk2, ActiveChecks[checkinstance].sensitivity,200.0);
                                                            if(inside2 > 0)
                                                               {
                                                               inside1 = 0;
                                                               break;
                                                               }
                                                            }
                                                         rah = rah->next;
                                                         }
                                                      }
   
                                                   if(inside1 > 0)  /** then is inside the area ***/
                                                      {
                                                      CoveredSoFar = segdist * 2;
                                                      break;
                                                      }
                                                   }
                                                }
                                             rac = rac->next;
                                             }
                                          }
                                       if(CoveredSoFar < segdist)
                                          {
                                          ++found_one;
                                          break;
                                          }
                                       }
                                    }
} /** end sharing is possible based on min and max vertex values ***/

                                 jj = j;
                                 }
                              if(found_one > 0)
                                 {
                                 found_one = 0;
                                 ERc = (struct collection *) (malloc(SzC));
                                 if(ERc == NULL)
                                    {
                                    printf("allocation memory exhausted during linear feature condition analysis\n");
                                    printf("processing cannot continue\n");
                                    exit(-1);
                                    }
                                 ERc->magnitude = segdist;
                                 ERc->keyval = SHARESEG;
                                 ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                                 ERc->IDN = rlc->idn;
                                 ERc->Sindex = rlc->Sindex;
                                 ERc->ll1 = rlc;
                                 ERc->ll2 = rln;
                                 if(ii < i)
                                    {
                                    ERc->vertexindex2 = i;
                                    ERc->vertexindex1 = ii;
                                    }
                                 else
                                    {
                                    ERc->vertexindex2 = ii;
                                    ERc->vertexindex1 = i;
                                    }
                                 ERc->x[0] = rlc->x[ii];
                                 ERc->y[0] = rlc->y[ii];
                                 ERc->z[0] = rlc->z[ii];
                                 ERc->x[1] = rlc->x[i];
                                 ERc->y[1] = rlc->y[i];
                                 ERc->z[1] = rlc->z[i];
                                 ERc->x[2] = rln->x[jj];
                                 ERc->y[2] = rln->y[jj];
                                 ERc->z[2] = rln->z[jj];
                                 ERc->x[3] = rln->x[j];
                                 ERc->y[3] = rln->y[j];
                                 ERc->z[3] = rln->z[j];

                                 ERc->next = NULL;

                                 checkit = 1;
                                 ERn = ERroot;
                                 while(ERn != NULL)
                                    {
                                    if((ERn->Cnumber == ERc->Cnumber) && (ERn->keyval == ERc->keyval) &&
                                          (ERn->ll1 == ERc->ll1) && (ERn->ll2 == ERc->ll2))
                                       {
                                       if(ERn->vertexindex2 == ERc->vertexindex1)
                                          {
                                          checkit = 0;
                                          ERn->vertexindex2 = ERc->vertexindex2;
                                          ERn->magnitude += ERc->magnitude;
                                          free(ERc);
                                          break;
                                          }
                                       else if(ERn->vertexindex1 == ERc->vertexindex2)
                                          {
                                          checkit = 0;
                                          ERn->vertexindex1 = ERc->vertexindex1;
                                          ERn->magnitude += ERc->magnitude;
                                          free(ERc);
                                          break;
                                          }
                                       }
                                    ERn = ERn->next;

                                    }

                                 if(ERroot == NULL)
                                    {
                                    ERroot = ERc;
                                    }
                                 else if(checkit > 0)
                                    {
                                    ERn = ERroot;
                                    while(ERn != NULL)
                                       {
                                         if((ERn->Cnumber == ERc->Cnumber) && (ERn->keyval == ERc->keyval) &&
                                               (ERn->magnitude == ERc->magnitude))
                                            {
                                            if((ERn->ll1 == ERc->ll1) && (ERn->ll2 == ERc->ll2))
                                               break;
                                            else if((ERn->ll2 == ERc->ll1) && (ERn->ll1 == ERc->ll2))
                                               break;
                                            }
                                       ERn = ERn->next;
                                       }
                                    if(ERn == NULL)
                                       {
                                       ERc->next = ERroot;
                                       ERroot = ERc;
                                       }
                                    else
                                      {
                                      free(ERc);
                                      }
                                    }
                                 }
                        
                              } /*** end check rlc vertex since it is in the LM ***/
                           ii = i;
                           } /*** end for i ***/
                        } /*** end need to check this pair ***/
                     }
                  rln = rln->next;
                  }
               } /**** end SHARESEG check applies to rlc as part 1***/
            } /**** end SHARESEG  ***/


         if(CombinedCheckApplies(rlc->idn,checkinstance,DUPLICATESEG,rlc->Lindex,rlc->Sindex,Config1,Strat1,Domain1,&part1,&part2,&part3) > 0)
            {
            if(part1 > 0)
               {
               rln = root;
               ii3 = -1;
               while(rln != NULL)
                  {
                  Config2 = SCCtable[rln->Sindex].C;
                  Strat2 = SCCtable[rln->Sindex].S;
                  Domain2 = SCCtable[rln->Sindex].D;
                  if((rln != rlc) &&
                      (CombinedCheckApplies(rln->idn,checkinstance,DUPLICATESEG,rln->Lindex,rln->Sindex,Config2,Strat2,Domain2,&part1,&part2,&part3) > 0))
                     {
                     if(part2 > 0)
                        {
                        foundpair = 0;
                        for(i=1; i<rlc->numnodes; i++)
                           {
                           for(j=1; j<rln->numnodes; j++)
                              {

                              if((rlc->x[i] == rln->x[j]) && (rlc->y[i] == rln->y[j]))
                                 {
                                 if((rlc->x[i-1] == rln->x[j-1]) && (rlc->y[i-1] == rln->y[j-1]))
                                    {
                                    if(ii3 < 0)
                                       ii3 = i;
                                    ++foundpair;
                                    }
                                 }
                              else if((rlc->x[i] == rln->x[j-1]) && (rlc->y[i] == rln->y[j-1]))
                                 {
                                 if((rlc->x[i-1] == rln->x[j]) && (rlc->y[i-1] == rln->y[j]))
                                    {
                                    if(ii3 < 0)
                                       ii3 = i;
                                    ++foundpair;
                                    }
                                 }
                              }
                           } /*** end for i ***/

                        if(SensitivityCheck(GT, DUPLICATESEG, checkinstance, (double) foundpair) > 0)
                           {
                           ERc = (struct collection *) (malloc(SzC));
                           if(ERc == NULL)
                              {
                              printf("allocation memory exhausted during linear feature condition analysis\n");
                              printf("processing cannot continue\n");
                              exit(-1);
                              }
                           ERc->magnitude = (double) foundpair;
                           ERc->keyval = DUPLICATESEG;
                           ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                           ERc->IDN = rlc->idn;
                           ERc->Sindex = rlc->Sindex;
                           ERc->vertexindex1 = ii3;
                           ERc->ll1 = rlc;
                           ERc->ll2 = rln;
                           ERc->next = NULL;
                           if(ERroot == NULL)
                              {
                              ERroot = ERc;
                              }
                           else
                              {
                              ERn = ERroot;
                              while(ERn != NULL)
                                 {
                                   if((ERn->Cnumber == ERc->Cnumber) && (ERn->keyval == ERc->keyval) &&
                                      ( ( (ERn->ll1    == ERc->ll1)    && (ERn->ll2    == ERc->ll2)) ||
                                       ( (ERn->ll1    == ERc->ll2)    && (ERn->ll2    == ERc->ll1))))
                                    break;

                                 ERn = ERn->next;
                                 }
                              if(ERn == NULL)
                                 {
                                 ERc->next = ERroot;
                                 ERroot = ERc;
                                 }
                              else
                                free(ERc);
                              }
                           }
                        } /*** end if part 2 ***/
                     }
                  rln = rln->next;
                  } /*** end while rln ***/
               }
            }



   /** check for Line falling anywhere outside proscribed Areal by type **/
         if((CombinedCheckApplies(rlc->idn,checkinstance,LOUTSIDEA,rlc->Lindex,rlc->Sindex,Config1,Strat1,Domain1,
               &part1,&part2,&part3) > 0) && (part1 > 0))
            {
            checkit = 1;
            thiskey = LOUTSIDEA;
            }
         else if((CombinedCheckApplies(rlc->idn,checkinstance,OVERUNDER,rlc->Lindex,rlc->Sindex,Config1,Strat1,Domain1,
               &part1,&part2,&part3) > 0) && (part1 > 0))
            {
            checkit = 1;
            thiskey = OVERUNDER;
            }
         else
            checkit = 0;
         if(checkit > 0)
            {
            for(i=0; i<rlc->numnodes; i++)
               {
               xi = rlc->x[i];
               yi = rlc->y[i];
               if((xi >= minx) && (xi <= maxx) && (yi >= miny) && (yi <= maxy))
                  {
                  inregion1 = 0;
                  rac = Aroot;
                  while((inregion1 == 0) && (rac != NULL))
                     {
                     Config2 = SCCtable[rac->Sindex].C;
                     Strat2 = SCCtable[rac->Sindex].S;
                     Domain2 = SCCtable[rac->Sindex].D;
                     if(CombinedCheckApplies(rac->idn,checkinstance,thiskey,rac->Lindex,rac->Sindex,Config2,Strat2,Domain2,&part1,&part2,&part3) > 0)
                        {
                        if(part2 > 0)
                           {
                           if(PointOnEdge(xi,yi,rac->x,rac->y,rac->z,rac->numverts,&z4,&jj) > 0)
                              {
                              inregion1 = 1;
                              break;
                              }
                           else if(PointInsidePoly(xi,yi,rac->x,rac->y,rac->numverts) > 0)
                              {
                              inregion1 = 1;
                              break;
                              }
                           }
                        }
                     rac = rac->next;
                     }
                  if(inregion1 == 0) /** then did not find a containing area feature of correct type **/
                     {
                     ERc = (struct collection *) (malloc(SzC));
                     if(ERc == NULL)
                        {
                        printf("allocation memory exhausted during linear feature condition analysis\n");
                        printf("processing cannot continue\n");
                        exit(-1);
                        }
                     ERc->x[0] = xi;
                     ERc->y[0] = yi;
                     ERc->z[0] = rlc->z[i];
                     ERc->magnitude = 0.0;
                     ERc->IDN = rlc->idn;
                     ERc->ll1 = rlc;
                     ERc->keyval = thiskey;
                     ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                     ERc->Sindex = rlc->Sindex;
                     ERc->next = NULL;

                     ERn = ERroot;
                     while(ERn != NULL)
                        {
                        if(
			      (ERn->Cnumber  == ERc->Cnumber) &&
			      (ERn->keyval  == ERc->keyval) && 
			      (ERn->x[0]    == ERc->x[0])   &&
			      (ERn->y[0]    == ERc->y[0])   && 
			      (ERn->Sindex  == ERc->Sindex)
			      )
                           break;
                        ERn = ERn->next;
                        }
                     if(ERn == NULL)
                        {
                        ERc->next = ERroot;
                        ERroot = ERc;
                        }
                     else
                        free(ERc);
                     }
                  }
               }
            }  /** end check for LOUTSIDEA and / or OVERUNDER ***/


         if((CombinedCheckApplies(rlc->idn,checkinstance,LATTRCHNG,rlc->Lindex,rlc->Sindex,Config1,Strat1,Domain1,&part1,&part2,&part3) > 0) &&
               (part1 > 0))
            {
            j = 0;
            while(j < rlc->numnodes)
               {
                if((rlc->x[j] >= minx) && (rlc->x[j] <= maxx) && (rlc->y[j] >= miny) &&(rlc->y[j] <= maxy))
                   {
                   if(j == 0)
                      k = 1;
                   else
                      k = j - 1;
                   rln = root;
                   rlnsave = NULL;
                   keepit = 1;
                   while(rln != NULL)
                      {
                      if((rln != rlc) && 
                           (SCCtable[rlc->Sindex].ECC == SCCtable[rln->Sindex].ECC)) /** two features have same fcode **/
                         {
                         for(i=0; i<rln->numnodes; i++)
                            {
                            if((rln->x[i] >= minx) && (rln->x[i] <= maxx) && (rln->y[i] >= miny) &&(rln->y[i] <= maxy))
                               {
                               ptpdist1 = Distance3D(rlc->x[j],rlc->y[j],rlc->z[j],rln->x[i],rln->y[i],rln->z[i]);

                               if(ptpdist1 < 0.001) /** found a rlc end node to rln node match ***/
                                  {
                                  if((rln->Lindex == rlc->Lindex) && (rln->areaattr == rlc->areaattr) &&
                                        (rln->hgtattr == rlc->hgtattr) && (rln->zv2attr == rlc->zv2attr))
                                     {
                                     keepit = 0;
                                     break; /** breaks from the for(i loop ***/
                                     }
                                  else
                                     rlnsave = rln;
                                  }
                               }
                            } /** end for i **/
                         } /** end if ECC are equal ***/
                      if(keepit == 0)
                         break;
                      rln = rln->next;
                      }  /** end while rln ***/
                   if((rln == NULL) && (rlnsave != NULL) && (keepit > 0))
                      {
                      ERc = (struct collection *) (malloc(SzC));
                      if(ERc == NULL)
                         {
                         printf("allocation memory exhausted during linear feature condition analysis\n");
                         printf("processing cannot continue\n");
                         exit(-1);
                         }
                      ERc->x[0] = rlc->x[j];
                      ERc->y[0] = rlc->y[j];
                      ERc->z[0] = rlc->z[j];
                      ERc->magnitude = 0.0;
                      ERc->keyval = LATTRCHNG;
                      ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                      ERc->Sindex = rlc->Sindex;
                      ERc->ll1 = rlc;
                      ERc->next = NULL;

                      ERn = ERroot;
                      while(ERn != NULL)
                         {
                           if(
                              (ERn->Cnumber    == ERc->Cnumber)    &&
                              (ERn->keyval    == ERc->keyval)    &&
                              (ERn->ll1  == ERc->ll1) &&
                              (ERn->x[0]      == ERc->x[0])      &&
                              (ERn->y[0]      == ERc->y[0])  /***    &&
                              (ERn->Sindex    == ERc->Sindex) ***/
                              )
                            break;
                         ERn = ERn->next;
                         }
                      if(ERn == NULL)
                         {
                         ERc->x[1] = rlc->x[k];
                         ERc->y[1] = rlc->y[k];
                         ERc->z[1] = rlc->z[k];
                         ERc->next = ERroot;
                         ERroot = ERc;
                         }
                      else
                         free(ERc);
                      } /*** end found a condition ***/
                   } /*** end if((rlc->x[j] >= minx) && (rlc->x[j] <= maxx) && etc. ***/
               j += rlc->numnodes - 1;
               }
            }  /*** end LATTRCHNG check ***/



         if((CombinedCheckApplies(rlc->idn,checkinstance,COLINEAR,rlc->Lindex,rlc->Sindex,
            Config1,Strat1,Domain1,&part1,&part2,&part3) > 0) &&
               (part1 > 0))
            {
            j = rlc->numnodes - 1;
            for(i=1; i<j; i++)
               {
               keepit = 0;
               if((rlc->x[i] >= minx) && (rlc->x[i] <= maxx) && (rlc->y[i] >= miny) && (rlc->y[i] <= maxy))  /** vert in the LM **/
                  {
                  i_minus = i - 1;
                  i_plus = i + 1;
                  ptldist = PointToLineDist2D(rlc->x[i],rlc->y[i], rlc->x[i_minus],rlc->y[i_minus],rlc->x[i_plus],rlc->y[i_plus]);
                  if(ptldist <= ActiveChecks[checkinstance].sensitivity)
                     keepit = 1;
                  else
                     keepit = 0;
                  if(keepit > 0)
                     {
                     ptldist = Distance(rlc->x[i_minus],rlc->y[i_minus],rlc->x[i_plus],rlc->y[i_plus]);
                     if(ptldist > ActiveChecks[checkinstance].sensitivity3)
                        keepit = 0;
                     }
                  if(keepit > 0)
                     {
                     rac = Aroot;
                     while((keepit == 1) && (rac != NULL))
                        {
                        Config2 = SCCtable[rac->Sindex].C;
                        Strat2 = SCCtable[rac->Sindex].S;
                        Domain2 = SCCtable[rac->Sindex].D;
                        if( (CombinedCheckApplies(rac->idn,checkinstance,COLINEAR,
                                rac->Lindex,rac->Sindex,Config2,Strat2,Domain2,&part1,&part2,&part3) > 0) &&
                              (part2 > 0))
                           {
                           if(rac->RB_Tree_Edgelist != NULL)
                              {
                              LastEdge = NULL;
                              LastI = -1;
                              jj = GetNextArealIndex(rac, LastI, 1, &LastEdge, cindex, &unusedint);
                              LastI = jj;
                              while(jj >= 0)
                                 {
                                 mindist = Distance3D(rlc->x[i],rlc->y[i],rlc->z[i],rac->x[jj],rac->y[jj],rac->z[jj]);
                                 if(mindist <= ActiveChecks[checkinstance].sensitivity2)
                                    {
                                    keepit = 0;
                                    break;
                                    }
                                 jj = GetNextArealIndex(rac, LastI, 1, &LastEdge, cindex, &unusedint);
                                 LastI = jj;
                                 }
                              }
                           else
                              {
                              for(jj=0; jj<rac->numverts; jj++)
                                 {
                                 if((rac->x[jj] >= minx) && (rac->x[jj] <= maxx) &&
                                            (rac->y[jj] >= miny) && (rac->y[jj] <= maxy))
                                    {
                                    mindist = Distance3D(rlc->x[i],rlc->y[i],rlc->z[i],rac->x[jj],rac->y[jj],rac->z[jj]);
                                    if(mindist <= ActiveChecks[checkinstance].sensitivity2)
                                    /** call this a connecting node and discard condition ***/
                                       {
                                       keepit = 0;
                                       break;
                                       }
                                    }
                                 }
                              }
                           if(keepit == 0)
                              break;
                           }
                        rac = rac->next;
                        }  /** end checking the area features for connecting node status ****/


                     if(keepit > 0)
                        {
                        rln = root;
                        while(rln != NULL)
                           {
                           Config2 = SCCtable[rln->Sindex].C;
                           Strat2 = SCCtable[rln->Sindex].S;
                           Domain2 = SCCtable[rln->Sindex].D;
                           if((rln != rlc) &&  (CombinedCheckApplies(rln->idn,checkinstance,COLINEAR,
                                rln->Lindex,rln->Sindex,Config2,Strat2,Domain2,&part1,&part2,&part3) > 0) &&
                              (part2 > 0))
                              {
                              for(jj = 0; jj < rln->numnodes; jj++)
                                 {
                                 if((rln->x[jj] >= minx) && (rln->x[jj] <= maxx) &&
                                         (rln->y[jj] >= miny) && (rln->y[jj] <= maxy))
                                    {
                                    mindist = Distance3D(rlc->x[i],rlc->y[i],rlc->z[i],rln->x[jj],rln->y[jj],rln->z[jj]);
                                    if(mindist <= ActiveChecks[checkinstance].sensitivity2)
                                       {
                                       keepit = 0;
                                       break;
                                       }
                                    }
                                 }
                              if(keepit == 0)
                                 break;
                              }
                           rln = rln->next;
                           }
                        }

                     if(keepit > 0)
                        {
                        rpc = Proot;
                        while(rpc != NULL)
                           {
                           Config2 = SCCtable[rpc->Sindex].C;
                           Strat2 = SCCtable[rpc->Sindex].S;
                           Domain2 = SCCtable[rpc->Sindex].D;
                           if((rpc->numverts == -1) && /** rpc is a pure point ***/
                               (CombinedCheckApplies(rpc->idn,checkinstance,COLINEAR,
                                rpc->Lindex,rpc->Sindex,Config2,Strat2,Domain2,&part1,&part2,&part3) > 0) &&
                              (part2 > 0))
                              {
                              mindist = Distance3D(rlc->x[i],rlc->y[i],rlc->z[i],rpc->x[0],rpc->y[0],rpc->z[0]);
                              if(mindist <= ActiveChecks[checkinstance].sensitivity2)
                              /** call this a connecting node and discard condition ***/
                                 {
                                 keepit = 0;
                                 break;
                                 }
                              }
                           rpc = rpc->next;
                           }
                        }

                     if(keepit > 0)
                        {
                        ERc = (struct collection *) (malloc(SzC));
                        if(ERc == NULL)
                           {
                           printf("allocation memory exhausted during linear feature condition analysis\n");
                           printf("processing cannot continue\n");
                           exit(-1);
                           }
                        ERc->x[0] = rlc->x[i_minus];
                        ERc->y[0] = rlc->y[i_minus];
                        ERc->z[0] = rlc->z[i_minus];
                        ERc->x[1] = rlc->x[i];
                        ERc->y[1] = rlc->y[i];
                        ERc->z[1] = rlc->z[i];
                        ERc->x[2] = rlc->x[i_plus];
                        ERc->y[2] = rlc->y[i_plus];
                        ERc->z[2] = rlc->z[i_plus];
                        
                        ERc->magnitude = 0.0;
                        ERc->keyval = COLINEAR;
                        ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                        ERc->Sindex = rlc->Sindex;
                        ERc->ll1 = rlc;
                        ERc->aa = NULL;
                        ERc->next = NULL;

                        ERn = ERroot;
                        while(ERn != NULL)
                           {
                           if((ERn->Cnumber == ERc->Cnumber) && (ERn->keyval == ERc->keyval) && (ERn->ll1 == ERc->ll1) &&
                                (ERn->x[1] == ERc->x[1]) && (ERn->y[1] == ERc->y[1]) && (ERn->Sindex == ERc->Sindex))
                              break;
                           ERn = ERn->next;
                           }
                        if(ERn == NULL)
                           {
                           ERc->next = ERroot;
                           ERroot = ERc;
                           }
                        else
                           free(ERc);
                        }

                     }  /*** end found 3 colinear points  ***/

                  } /*** end rln vertex is in the LM ***/
               } /** end looping thru rlc vertices ****/
            } /*** end COLINEAR applies to rlc ****/



         }  /**** for(checkinstance = 0; checkinstance < TtlActiveChecks; checkinstance++) ****/

      rlc = rlc->next;
      }  /*** end while rlc != NULL ****/


   if(rln3temp != NULL)
      {
      if(rln3temp->x != NULL)
         free(rln3temp->x);
      if(rln3temp->y != NULL)
         free(rln3temp->y);
      if(rln3temp->z != NULL)
         free(rln3temp->z);
      free(rln3temp);
      rln3temp = NULL;
      }


   fclose(attrfileptr);

   if(rlc_partialcopy != NULL)
      {
      FreeLinearsList(rlc_partialcopy);
      }

   if(ZMNroot != NULL)
      {
      ZMNc = ZMNroot;
      while(ZMNc != NULL)
         {
         ERc = (struct collection *) (malloc(SzC));
         if(ERc == NULL)
           {
           printf("allocation memory exhausted during linear feature condition analysis (Z-shear analysis)\n");
           printf("processing cannot continue\n");
           exit(-1);
           }
         ERc->magnitude = ZMNc->mismatchdist;

         ERc->x[0] = ZMNc->x[0];
         ERc->y[0] = ZMNc->y[0];
         ERc->z[0] = ZMNc->z[0];
         ERc->x[1] = ZMNc->x[1];
         ERc->y[1] = ZMNc->y[1];
         ERc->z[1] = ZMNc->z[1];

         ERc->IDN = ZMNc->IDN1;
         ERc->Sindex = ZMNc->Sindex1;
         ERc->aa = NULL; /** RawAreal **/
         ERc->bb = NULL; /** RawBridge **/
         ERc->pp = NULL; /** RawPoint **/
         ERc->le = NULL; /** ListOfEdges **/
         ERc->poly = NULL; /** ThePolys **/
         ERc->ll1 = ZMNc->owner1;
         ERc->ll2 = ZMNc->owner2;
         ERc->keyval = ZMNc->keyval;
         ERc->Cnumber = ZMNc->Cnumber;

         if(ERroot == NULL)
            {
            ERroot = ERc;
            ERroot->next = NULL;
            }
         else
            {
            ERc->next = ERroot;
            ERroot = ERc;
            }

         ZMNp = ZMNc;
         ZMNc = ZMNc->next;
         free(ZMNp);
         }
      }




   ERc = ERroot;
   while(ERc != NULL)
      {
      switch(ERc->keyval)
         {
         case LLINT:
         case LLIEX:
         case LLNOENDINT:
         case LLINTAWAY:
         /***case FAILMERGEL:
         case FAILMERGEL2:***/
            FwritePointAndTwoObjects(ERc->keyval,ERc->Cnumber,ERc->x[0],ERc->y[0],ERc->z[0],
                               ERc->ll1->Sindex,G_LINE,ERc->ll1->Lindex,ERc->ll1->localID,
                               ERc->ll1->idn,-1.0,-1.0,&ERc->ll1->x[ERc->vertexindex1],
                               &ERc->ll1->y[ERc->vertexindex1],&ERc->ll1->z[ERc->vertexindex1],2,
                               ERc->ll2->Sindex,G_LINE,ERc->ll2->Lindex,ERc->ll2->localID,
                               ERc->ll2->idn,-1.0,-1.0,&ERc->ll2->x[ERc->vertexindex2],
                               &ERc->ll2->y[ERc->vertexindex2],&ERc->ll2->z[ERc->vertexindex2],2);
            break;

         case LAIEX:
            FwritePointAndTwoObjects(ERc->keyval,ERc->Cnumber,ERc->x[0],ERc->y[0],ERc->z[0],
                               ERc->ll1->Sindex,G_LINE,ERc->ll1->Lindex,ERc->ll1->localID,
                               ERc->ll1->idn,-1.0,-1.0,&ERc->ll1->x[ERc->vertexindex1],
                               &ERc->ll1->y[ERc->vertexindex1],&ERc->ll1->z[ERc->vertexindex1],2,
                               ERc->aa->Sindex,G_AREAL,ERc->aa->Lindex,ERc->aa->localID,
                               ERc->aa->idn,-1.0,-1.0, &ERc->x[1], &ERc->y[1],&ERc->z[1],2);
            break;



         case BADFEATCUT:
            FwritePointAndTwoObjects(ERc->keyval,ERc->Cnumber,ERc->x[0],ERc->y[0],ERc->z[0],
                               ERc->ll1->Sindex,G_LINE,ERc->ll1->Lindex,ERc->ll1->localID,
                               ERc->ll1->idn,-1.0,-1.0,&ERc->x[0],&ERc->y[0],&ERc->z[0],2,
                               ERc->ll2->Sindex,G_LINE,ERc->ll2->Lindex,ERc->ll2->localID,
                               ERc->ll2->idn,-1.0,-1.0,&ERc->x[2],&ERc->y[2],&ERc->z[2],2);
            break;


         case LLNONODEINT:
         case NONODEOVLP:
            if(ERc->ll2 != NULL)
               {
               FwritePointAndTwoObjects(ERc->keyval,ERc->Cnumber,ERc->x[0],ERc->y[0],ERc->z[0],
                               ERc->ll1->Sindex,G_LINE,ERc->ll1->Lindex,ERc->ll1->localID,
                               ERc->ll1->idn,-1.0,-1.0,&ERc->ll1->x[ERc->vertexindex1],
                               &ERc->ll1->y[ERc->vertexindex1],&ERc->ll1->z[ERc->vertexindex1],2,
                               ERc->ll2->Sindex,G_LINE,ERc->ll2->Lindex,ERc->ll2->localID,
                               ERc->ll2->idn,-1.0,-1.0,&ERc->ll2->x[ERc->vertexindex2],
                               &ERc->ll2->y[ERc->vertexindex2],&ERc->ll2->z[ERc->vertexindex2],2);
               }
            else if(ERc->pp != NULL)
               {
               FwritePointAndTwoObjects(ERc->keyval,ERc->Cnumber,ERc->x[0],ERc->y[0],ERc->z[0],
                               ERc->ll1->Sindex,G_LINE,ERc->ll1->Lindex,ERc->ll1->localID,
                               ERc->ll1->idn,-1.0,-1.0,&ERc->ll1->x[ERc->vertexindex1],
                               &ERc->ll1->y[ERc->vertexindex1],&ERc->ll1->z[ERc->vertexindex1],2,
                               ERc->pp->Sindex,G_POINT,ERc->pp->Lindex,ERc->pp->localID,
                               ERc->pp->idn,-1.0,-1.0,&ERc->pp->x[0],
                               &ERc->pp->y[0],&ERc->pp->z[0],1);
               }
            else if(ERc->aa != NULL)
               {
               if(ERc->keyval == NONODEOVLP)
                  {
                  FwritePointAndTwoObjects(ERc->keyval,ERc->Cnumber,ERc->x[0],ERc->y[0],ERc->z[0],
                               ERc->ll1->Sindex,G_LINE,ERc->ll1->Lindex,ERc->ll1->localID,
                               ERc->ll1->idn,-1.0,-1.0,&ERc->ll1->x[ERc->vertexindex1],
                               &ERc->ll1->y[ERc->vertexindex1],&ERc->ll1->z[ERc->vertexindex1],2,
                               ERc->aa->Sindex,G_AREAL,ERc->aa->Lindex,ERc->aa->localID,
                               ERc->aa->idn,-1.0,-1.0,&ERc->x[2],&ERc->y[2],&ERc->z[2],2);
                  }
               else if(ERc->keyval == LLNONODEINT)
                  {
                  FwritePointAndTwoObjects(ERc->keyval,ERc->Cnumber,ERc->x[0],ERc->y[0],ERc->z[0],
                                            ERc->aa->Sindex,G_AREAL,ERc->aa->Lindex,ERc->aa->localID, 
                                            ERc->aa->idn,-1.0,-1.0,&ERc->x[2],&ERc->y[2],&ERc->z[2],2,
                                            ERc->ll1->Sindex,G_LINE,ERc->ll1->Lindex,ERc->ll1->localID,
                                            ERc->ll1->idn,-1.0,-1.0,&ERc->ll1->x[ERc->vertexindex1],
                                             &ERc->ll1->y[ERc->vertexindex1],&ERc->ll1->z[ERc->vertexindex1],2);
                  }
               }
            break;

         case P_O_LOOP:
            FwritePointAndTwoObjects(ERc->keyval,ERc->Cnumber,ERc->x[0],ERc->y[0],ERc->z[0],
                               ERc->ll1->Sindex,G_LINE,ERc->ll1->Lindex,ERc->ll1->localID,
                               ERc->ll1->idn,-1.0,-1.0,&ERc->x[1], &ERc->y[1],&ERc->z[1],2,
                               ERc->ll1->Sindex,G_LINE,ERc->ll1->Lindex,ERc->ll1->localID,
                               ERc->ll1->idn,-1.0,-1.0,&ERc->x[3],&ERc->y[3],&ERc->z[3],2);
            break;

         case LMINT:
            if(ERc->pp == NULL) /** intersection between model library polygon and line ***/
               {
               FwritePointAndTwoObjects(ERc->keyval,ERc->Cnumber,ERc->x[0],ERc->y[0],ERc->z[0],
                               ERc->ll1->Sindex,G_LINE,ERc->ll1->Lindex,ERc->ll1->localID,
                               ERc->ll1->idn,-1.0,-1.0,&ERc->ll1->x[ERc->vertexindex1],
                               &ERc->ll1->y[ERc->vertexindex1],&ERc->ll1->z[ERc->vertexindex1],2,
                               ERc->poly->SCCindex,G_POLYGON,ERc->poly->SACindex,ERc->poly->localID,
                               ERc->poly->idn,-1.0,-1.0,ERc->poly->x,ERc->poly->y,ERc->poly->z,ERc->poly->numverts);
               }
            else if(ERc->pp->numverts == 0)  /** intersection with a stamp model ***/
               {
               FwritePointAndTwoObjects(ERc->keyval,ERc->Cnumber,ERc->x[0],ERc->y[0],ERc->z[0],
                               ERc->ll1->Sindex,G_LINE,ERc->ll1->Lindex,ERc->ll1->localID,
                               ERc->ll1->idn,-1.0,-1.0,&ERc->ll1->x[ERc->vertexindex1],
                               &ERc->ll1->y[ERc->vertexindex1],&ERc->ll1->z[ERc->vertexindex1],2,
                               ERc->pp->Sindex,G_CYLINDER,ERc->pp->Lindex,ERc->pp->localID,
                               ERc->pp->idn,ERc->pp->rad,ERc->pp->h[0],ERc->pp->x,ERc->pp->y,ERc->pp->z,1);
               }
            else if(ERc->pp->numverts == -2)  /** intersection with a spherical collision volume ***/
               {
               FwritePointAndTwoObjects(ERc->keyval,ERc->Cnumber,ERc->x[0],ERc->y[0],ERc->z[0],
                               ERc->ll1->Sindex,G_LINE,ERc->ll1->Lindex,ERc->ll1->localID,
                               ERc->ll1->idn,-1.0,-1.0,&ERc->ll1->x[ERc->vertexindex1],
                               &ERc->ll1->y[ERc->vertexindex1],&ERc->ll1->z[ERc->vertexindex1],2,
                               ERc->pp->Sindex,G_SPHERE,ERc->pp->Lindex,ERc->pp->localID,
                               ERc->pp->idn,ERc->pp->rad,ERc->pp->h[0],ERc->pp->x,ERc->pp->y,ERc->pp->z,1);
               }
            else if(ERc->pp->numverts <= -3)  /** intersection with a parallelpiped collision volume ***/
               {		 
               FwritePointAndTwoObjects(ERc->keyval,ERc->Cnumber,ERc->x[0],ERc->y[0],ERc->z[0],
                               ERc->ll1->Sindex,G_LINE,ERc->ll1->Lindex,ERc->ll1->localID,
                               ERc->ll1->idn,-1.0,-1.0,&ERc->ll1->x[ERc->vertexindex1],
                               &ERc->ll1->y[ERc->vertexindex1],&ERc->ll1->z[ERc->vertexindex1],2,
                               ERc->pp->Sindex,G_PIPED,ERc->pp->Lindex,ERc->pp->localID,
                               ERc->pp->idn,ERc->pp->rad,ERc->pp->h[0],ERc->pp->x,ERc->pp->y,ERc->pp->z,0-ERc->pp->numverts);
               }
            else /** must be intersection with a footprint model ***/
               {
               FwritePointAndTwoObjects(ERc->keyval,ERc->Cnumber,ERc->x[0],ERc->y[0],ERc->z[0],
                               ERc->ll1->Sindex,G_LINE,ERc->ll1->Lindex,ERc->ll1->localID,
                               ERc->ll1->idn,-1.0,-1.0,&ERc->ll1->x[ERc->vertexindex1],
                               &ERc->ll1->y[ERc->vertexindex1],&ERc->ll1->z[ERc->vertexindex1],2,
                               ERc->pp->Sindex,G_POLYGON,ERc->pp->Lindex,ERc->pp->localID,
                               ERc->pp->idn,ERc->pp->rad,ERc->pp->h[0],ERc->pp->x,ERc->pp->y,ERc->pp->z,ERc->pp->numverts);
               }
            break;
         case LSPINT:
         case LSPIEXP:
            FwriteMagnitudeAndTwoObjects(ERc->keyval,ERc->Cnumber,ERc->magnitude,
                        ERc->ll1->Sindex,G_LINE,ERc->ll1->Lindex,
                        ERc->ll1->localID,ERc->ll1->idn,-1.0,-1.0,&ERc->x[1],&ERc->y[1],&ERc->z[1],2,
                        ERc->poly->SCCindex,G_POLYGON,ERc->poly->SACindex,ERc->poly->localID,ERc->poly->idn,-1.0,-1.0,
                        &ERc->poly->x[0],&ERc->poly->y[0],&ERc->poly->z[0],ERc->poly->numverts);
            break;
         case LAINT:
         case LAINTNOEND:
               FwritePointAndTwoObjects(ERc->keyval,ERc->Cnumber,ERc->x[0],ERc->y[0],ERc->z[0],
                               ERc->ll1->Sindex,G_LINE,ERc->ll1->Lindex,
                               ERc->ll1->localID,ERc->ll1->idn,-1.0,-1.0,&ERc->x[1],&ERc->y[1],&ERc->z[1],2,
                               ERc->aa->Sindex,G_AREAL,ERc->aa->Lindex,ERc->aa->localID,
                               ERc->aa->idn,-1.0,-1.0,&ERc->x[3],&ERc->y[3],&ERc->z[3],2);
            break;

         case LLAINT:
         case L_NOTL_AINT:
            FwritePointAndObject(ERc->keyval,ERc->Cnumber,ERc->x[0],ERc->y[0],ERc->z[0], -1,
                       ERc->Sindex, G_LINE, ERc->ll1->Lindex,ERc->ll1->localID,
                          ERc->ll1->idn,10.0, 0.0,ERc->x, ERc->y, ERc->z, 2);
            break;

         case OVERUNDER:
            FwriteObject(ERc->keyval,ERc->Cnumber, ERc->ll1->Lindex, ERc->Sindex, G_LINE,ERc->ll1->localID,
                          ERc->ll1->idn, 10.0, 0.0,
                          &ERc->x[0],&ERc->y[0],&ERc->z[0], 1, 1);
            break;

         case LOUTSIDEA:
            FwritePointAndObject(ERc->keyval,ERc->Cnumber,ERc->x[0],ERc->y[0],ERc->z[0], -1,
                       ERc->Sindex, G_LINE, ERc->ll1->Lindex,ERc->ll1->localID,
                          ERc->ll1->idn,10.0, 0.0,ERc->ll1->x, ERc->ll1->y, ERc->ll1->z, ERc->ll1->numnodes);
            break;

         case LENOCOVERP:
         case ENCONFAIL:
         case NOLCOVLE:  /*** line end node not within tolerance distance to another line, including itself on a diff segment ***/
         case LENOCOVERL:
         case BOTHENDCON:
            FwritePointAndObject(ERc->keyval,ERc->Cnumber,ERc->x[0],ERc->y[0],ERc->z[0], -1,
                       ERc->Sindex, G_LINE, ERc->ll1->Lindex,ERc->ll1->localID,
                          ERc->ll1->idn,10.0, 0.0,&ERc->x[1], &ERc->y[1], &ERc->z[1], 2);
            break;

         case FEATNOTCUT:
            FwriteTwoObjects(ERc->keyval,ERc->Cnumber,
                    ERc->ll1->idn,G_LINE,ERc->ll1->Lindex,ERc->ll1->localID,ERc->ll1->Sindex,-1.0,-1.0,
                    2,&ERc->x[1],&ERc->y[1],&ERc->z[1],
                    ERc->ll2->idn,G_LINE,ERc->ll2->Lindex,ERc->ll2->localID,ERc->ll2->Sindex,-1.0,-1.0,
                    1,&ERc->x[0],&ERc->y[0],&ERc->z[0]);
            break;

         case LATTRCHNG:
            FwritePointAndObject(ERc->keyval,ERc->Cnumber,ERc->x[0],ERc->y[0],ERc->z[0], -1,
                       ERc->Sindex, G_LINE, ERc->ll1->Lindex,ERc->ll1->localID,
                          ERc->ll1->idn,10.0, 0.0,&ERc->x[0], &ERc->y[0], &ERc->z[0], 2);
            break;

         case KICKBACK:
            FwritePointAndObject(ERc->keyval,ERc->Cnumber,ERc->x[1],ERc->y[1],ERc->z[1], -1,
                       ERc->Sindex, G_LINE, ERc->ll1->Lindex,ERc->ll1->localID,
                          ERc->ll1->idn,10.0, 0.0,&ERc->x[0], &ERc->y[0], &ERc->z[0], 3);
            break;

         case LVPROX:
         case ENCONNECT:
         case BADENCON:
         case FEATBRIDGE:
            FwritePointEdgeAndMagnitude(ERc->keyval,ERc->Cnumber,ERc->magnitude,
                      ERc->ll1->idn,G_LINE,ERc->ll1->Lindex,ERc->ll1->localID,ERc->ll1->Sindex,ERc->x[0],ERc->y[0],ERc->z[0],
                      ERc->ll2->Sindex,ERc->ll2->idn,G_LINE,ERc->ll2->Lindex,ERc->ll2->localID,
                      ERc->x[1],ERc->y[1],ERc->z[1],ERc->x[2],ERc->y[2],ERc->z[2],ERc->x,ERc->y, ERc->z);
            break;

         case LENOCOVERA:
            FwritePointEdgeAndMagnitude(ERc->keyval,ERc->Cnumber,ERc->magnitude,
                      ERc->ll1->idn,G_LINE,ERc->ll1->Lindex,ERc->ll1->localID,ERc->ll1->Sindex,ERc->x[0],ERc->y[0],ERc->z[0],
                      ERc->aa->Sindex,ERc->aa->idn,G_AREAL,ERc->aa->Lindex,ERc->aa->localID,
                      ERc->x[1],ERc->y[1],ERc->z[1],ERc->x[2],ERc->y[2],ERc->z[2],ERc->x,ERc->y, ERc->z);
            break;

         case SHARE3SEG:
               FwriteObjectAndMagnitude(ERc->keyval,ERc->Cnumber,
                        ERc->ll1->idn, ERc->Sindex,G_LINE,ERc->ll1->Lindex,ERc->ll1->localID,-1.0,-1.0,ERc->magnitude,
                        ERc->x, ERc->y, ERc->z, 2, 1);
              break;

         case SHARESEG:
                   FwriteMagnitudeAndTwoObjects(ERc->keyval,ERc->Cnumber,ERc->magnitude,
                        ERc->ll1->Sindex,G_LINE,ERc->ll1->Lindex,
                        ERc->ll1->localID,ERc->ll1->idn,10.0,-1.0,
                        &ERc->ll1->x[ERc->vertexindex1],&ERc->ll1->y[ERc->vertexindex1],&ERc->ll1->z[ERc->vertexindex1],
                        ERc->vertexindex2 - ERc->vertexindex1 + 1,
                        ERc->ll2->Sindex,G_LINE,ERc->ll2->Lindex,
                        ERc->ll2->localID,ERc->ll2->idn,10.0,-1.0,&ERc->x[2],&ERc->y[2],&ERc->z[2],1);
               break;

         case LLI_ANGLE:
               FwriteMagnitudeAndTwoObjects(ERc->keyval,ERc->Cnumber,ERc->magnitude,
                        ERc->ll1->Sindex,G_LINE,ERc->ll1->Lindex,
                        ERc->ll1->localID,ERc->ll1->idn,10.0,-1.0,
                        &ERc->ll1->x[ERc->vertexindex1],&ERc->ll1->y[ERc->vertexindex1],&ERc->ll1->z[ERc->vertexindex1],2,
                        ERc->ll2->Sindex,G_LINE,ERc->ll2->Lindex,
                        ERc->ll2->localID,ERc->ll2->idn,10.0,-1.0,
                        &ERc->ll2->x[ERc->vertexindex2],&ERc->ll2->y[ERc->vertexindex2],&ERc->ll2->z[ERc->vertexindex2],2);
               break;


         case L2D_L3D_MATCH:
         case LEZ_PROX_3D:
	       FwriteMagnitudeAndTwoObjects(ERc->keyval,ERc->Cnumber,ERc->magnitude,
                        ERc->ll1->Sindex,G_LINE,ERc->ll1->Lindex,
                        ERc->ll1->localID,ERc->ll1->idn,10.0,-1.0,&ERc->x[0],&ERc->y[0],&ERc->z[0],1,
                        ERc->ll2->Sindex,G_LINE,ERc->ll2->Lindex,
                        ERc->ll2->localID,ERc->ll2->idn,10.0,-1.0,&ERc->x[1],&ERc->y[1],&ERc->z[1],1);
            break;

         case LSLICEA:
               FwriteMagnitudeAndTwoObjects(ERc->keyval,ERc->Cnumber,ERc->magnitude,
                    ERc->ll1->Sindex,G_LINE,ERc->ll1->Lindex,
                    ERc->ll1->localID,ERc->ll1->idn,10.0,-1.0,&ERc->x[0], &ERc->y[0], &ERc->z[0],2,
                    ERc->aa->Sindex,G_AREAL,ERc->aa->Lindex,
                    ERc->aa->localID,ERc->aa->idn,10.0,-1.0,&ERc->x[2], &ERc->y[2], &ERc->z[2],2);
               break;

         case LOC_MULTINT:
         case LLMULTINT:
               FwriteMagnitudeAndTwoObjects(ERc->keyval,ERc->Cnumber,ERc->magnitude,
                    ERc->ll1->Sindex,G_LINE,ERc->ll1->Lindex,
                    ERc->ll1->localID,ERc->ll1->idn,10.0,-1.0,ERc->ll1->x, ERc->ll1->y, ERc->ll1->z,ERc->ll1->numnodes,
                    ERc->ll2->Sindex,G_LINE,ERc->ll2->Lindex,
                    ERc->ll2->localID,ERc->ll2->idn,10.0,-1.0,ERc->ll2->x, ERc->ll2->y, ERc->ll2->z,ERc->ll2->numnodes);
            break;

         case DUPLICATESEG:
/**** using vertexindex1 field and parameter 'radius' to shoehorn in the index of one of the shared segments ***/
            FwriteMagnitudeAndTwoObjects(ERc->keyval,ERc->Cnumber,ERc->magnitude,
                 ERc->ll1->Sindex,G_LINE,ERc->ll1->Lindex,
                 ERc->ll1->localID,ERc->ll1->idn,(double) ERc->vertexindex1,-1.0,&ERc->ll1->x[0],&ERc->ll1->y[0],&ERc->ll1->z[0],ERc->ll1->numnodes,
                 ERc->ll2->Sindex,G_LINE,ERc->ll2->Lindex,
                 ERc->ll2->localID,ERc->ll2->idn,10.0,-1.0,&ERc->ll2->x[0],&ERc->ll2->y[0],&ERc->ll2->z[0],ERc->ll2->numnodes);
            break;


         case ELEVGT:
         case ELEVLT:
            FwriteDynamicInfo(ERc->keyval,ERc->Cnumber,0,1,1,NULL,
              ERc->magnitude, -1.0, -1.0, -1.0,
              ERc->Sindex,G_LINE,ERc->ll1->Lindex,ERc->ll1->localID,ERc->ll1->idn,-1.0,-1.0,
              ERc->x, ERc->y, ERc->z, 1,
              ERc->Sindex,G_LINE,ERc->ll1->Lindex,ERc->ll1->localID,ERc->ll1->idn,-1.0,-1.0,
              ERc->x, ERc->y, ERc->z, 1);
            break;

         case ELEVADJCHANGE:
         case FEATSPIKE:
            X[0] = ERc->x[0];
            Y[0] = ERc->y[0];
            Z[0] = ERc->z[0];
            X[1] = ERc->x[1];
            Y[1] = ERc->y[1];
            Z[1] = ERc->z[1];
            FwriteObjectAndMagnitude(ERc->keyval,ERc->Cnumber,
                        ERc->ll1->idn, ERc->Sindex,G_LINE,ERc->ll1->Lindex,ERc->ll1->localID,-1.0,-1.0,ERc->magnitude,X,Y,Z,2, 1);
            break;
         case ELEVEQ:
         case ELEVEQOPEN:
            X[0] = ERc->x[0];
            Y[0] = ERc->y[0];
            Z[0] = ERc->z[0];
            X[1] = ERc->x[1];
            Y[1] = ERc->y[1];
            Z[1] = ERc->z[1];
            FwriteDynamicInfo(ERc->keyval,ERc->Cnumber,0,1,1,NULL,
              ERc->magnitude, -1.0, -1.0, -1.0,
              ERc->Sindex,G_LINE,ERc->ll1->Lindex,ERc->ll1->localID,ERc->ll1->idn,-1.0,-1.0,
              X, Y, Z, 2,
              ERc->Sindex,G_LINE,ERc->ll1->Lindex,ERc->ll1->localID,ERc->ll1->idn,-1.0,-1.0,
              X, Y, Z, 2);
            break;
         case ISOTURN:
         case KINK:
         case L_A_KINK:
         case INTERNALKINK:
         case SLOPEDIRCH: 
            X[0] = ERc->x[0];
            Y[0] = ERc->y[0];
            Z[0] = ERc->z[0];
            X[1] = ERc->x[1];
            Y[1] = ERc->y[1];
            Z[1] = ERc->z[1];
            X[2] = ERc->x[2];
            Y[2] = ERc->y[2];
            Z[2] = ERc->z[2];
            FwriteObjectAndMagnitude(ERc->keyval,ERc->Cnumber,
                        ERc->ll1->idn, ERc->Sindex,G_LINE,ERc->ll1->Lindex,ERc->ll1->localID,-1.0,-1.0,ERc->magnitude,X,Y,Z,3, 1);
            break;

         case Z_KINK:
            FwriteObjectAndMagnitude(ERc->keyval,ERc->Cnumber,
                        ERc->ll1->idn, ERc->Sindex,G_LINE,ERc->ll1->Lindex,ERc->ll1->localID,-1.0,-1.0,
                        ERc->magnitude,ERc->x, ERc->y, ERc->z,4, 1);
            break;

         case CONTEXT_KINK:
            FwriteMagnitudeAndTwoObjects(ERc->keyval,ERc->Cnumber,ERc->magnitude,
                 ERc->ll1->Sindex,G_LINE,ERc->ll1->Lindex,
                 ERc->ll1->localID,ERc->ll1->idn,10.0,-1.0,ERc->x, ERc->y, ERc->z,3,
                 ERc->ll2->Sindex,G_LINE,ERc->ll2->Lindex,
                 ERc->ll2->localID,ERc->ll2->idn,10.0,-1.0,&ERc->x[2], &ERc->y[2], &ERc->z[2],2);
            break;

         case FAILMERGEL:
         case FAILMERGEL2:
            FwriteMagnitudeAndTwoObjects(ERc->keyval,ERc->Cnumber,ERc->magnitude,
                 ERc->ll1->Sindex,G_LINE,ERc->ll1->Lindex,
                 ERc->ll1->localID,ERc->ll1->idn,10.0,-1.0,ERc->x, ERc->y, ERc->z,2,
                 ERc->ll2->Sindex,G_LINE,ERc->ll2->Lindex,
                 ERc->ll2->localID,ERc->ll2->idn,10.0,-1.0,&ERc->x[2], &ERc->y[2], &ERc->z[2],2);
            break;

         case LJOINSLOPEDC:
            FwriteMagnitudeAndTwoObjects(ERc->keyval,ERc->Cnumber,ERc->magnitude,
                 ERc->ll1->Sindex,G_LINE,ERc->ll1->Lindex,
                 ERc->ll1->localID,ERc->ll1->idn,10.0,-1.0,ERc->x, ERc->y, ERc->z,2,
                 ERc->ll2->Sindex,G_LINE,ERc->ll2->Lindex,
                 ERc->ll2->localID,ERc->ll2->idn,10.0,-1.0,&ERc->x[1], &ERc->y[1], &ERc->z[1],2);
            break;

         case ISOLINE:
         case LINSIDEA:
           unuseddbl = PointToArealEdgeDist2D(ERc->x[0], ERc->y[0],ERc->aa,&ii);
           if(ii == 0)
               jj = ERc->aa->numverts - 1;
            else
               jj = ii - 1;
            ERc->x[2] = ERc->aa->x[jj];
            ERc->y[2] = ERc->aa->y[jj];
            ERc->z[2] = ERc->aa->z[jj];
            ERc->x[3] = ERc->aa->x[ii];
            ERc->y[3] = ERc->aa->y[ii];
            ERc->z[3] = ERc->aa->z[ii];
            FwriteTwoObjects(ERc->keyval,ERc->Cnumber, 
                    ERc->ll1->idn,G_LINE,ERc->ll1->Lindex,ERc->ll1->localID,ERc->ll1->Sindex,-1.0,-1.0,
                    2,&ERc->x[0],&ERc->y[0],&ERc->z[0],
                    ERc->aa->idn,G_AREAL,ERc->aa->Lindex,ERc->aa->localID,ERc->aa->Sindex,-1.0,-1.0,
                    2,&ERc->x[2],&ERc->y[2],&ERc->z[2]);
            break;

         case LSEGCOVERA:
            FwriteTwoObjects(ERc->keyval,ERc->Cnumber,
                    ERc->ll1->idn,G_LINE,ERc->ll1->Lindex,ERc->ll1->localID,ERc->ll1->Sindex,-1.0,-1.0,
                    2,&ERc->x[0],&ERc->y[0],&ERc->z[0],
                    ERc->aa->idn,G_AREAL,ERc->aa->Lindex,ERc->aa->localID,ERc->aa->Sindex,-1.0,-1.0,
                    2,&ERc->x[2],&ERc->y[2],&ERc->z[2]);
            break;

         case LNOCOVERLA:
         case LSPANFAIL:
            FwriteObject(ERc->keyval,ERc->Cnumber, ERc->ll1->Lindex, ERc->Sindex, G_LINE,ERc->ll1->localID,
                          ERc->ll1->idn, (double) ERc->vertexindex1, (double) ERc->vertexindex2, 
                          &ERc->ll1->x[ERc->vertexindex1],&ERc->ll1->y[ERc->vertexindex1],&ERc->ll1->z[ERc->vertexindex1],
                          (ERc->vertexindex2 - ERc->vertexindex1 + 1),1);
            break;

         case LNOCOV2A:
         case MULTIDFEAT:
         case MULTISENTINEL:
         case CONNECTFAIL:
            X[0] = ERc->x[0];
            Y[0] = ERc->y[0];
            Z[0] = ERc->z[0];
            X[1] = ERc->x[1];
            Y[1] = ERc->y[1];
            Z[1] = ERc->z[1];
            X[2] = 0.0;
            FwriteObject(ERc->keyval,ERc->Cnumber, ERc->ll1->Lindex, ERc->Sindex, G_LINE,ERc->ll1->localID,
                          ERc->ll1->idn, -1.0, -1.0, X,Y,Z,2, 1);
            break;

         case COLINEAR:
            FwritePointAndObject(ERc->keyval,ERc->Cnumber,ERc->x[1],ERc->y[1],ERc->z[1], -1,
                       ERc->Sindex, G_LINE, ERc->ll1->Lindex,ERc->ll1->localID,
                          ERc->ll1->idn,10.0, 0.0,ERc->x, ERc->y, ERc->z, 3);
            break;


         case LEINSIDEA:
            FwriteObject(ERc->keyval,ERc->Cnumber, ERc->ll1->Lindex, ERc->Sindex, G_LINE,ERc->ll1->localID,
                          ERc->ll1->idn, -1.0, -1.0, ERc->x, ERc->y, ERc->z,1, 1);
            break;

         case LEAON_NOTIN:
            nindex = ERc->vertexindex1;
            FwritePointAndTwoObjects(ERc->keyval,ERc->Cnumber,ERc->x[0],ERc->y[0],ERc->z[0],
                               ERc->ll1->Sindex,G_LINE,ERc->ll1->Lindex,
                               ERc->ll1->localID,ERc->ll1->idn,-1.0,-1.0,&ERc->x[0],&ERc->y[0],&ERc->z[0],2,
                               ERc->aa->Sindex,G_AREAL,ERc->aa->Lindex,ERc->aa->localID,
                               ERc->aa->idn,-1.0,-1.0,&ERc->aa->x[nindex],&ERc->aa->y[nindex],&ERc->aa->z[nindex],2);
            break; 

         case HIGHLIGHTED:
         case COINCIDEFAIL:
            FwriteObject(ERc->keyval,ERc->Cnumber, ERc->ll1->Lindex, ERc->Sindex, G_LINE,ERc->ll1->localID,
                          ERc->ll1->idn, -1.0, -1.0, ERc->ll1->x, ERc->ll1->y, ERc->ll1->z,2, 1);
            break;
         case LLNOINT:
         case LFNOINT:
            FwriteObject(ERc->keyval,ERc->Cnumber, ERc->ll1->Lindex, ERc->Sindex, G_LINE,ERc->ll1->localID,
                          ERc->ll1->idn, -1.0, -1.0, ERc->ll1->x, ERc->ll1->y, ERc->ll1->z, 2 /*ERc->ll1->numnodes*/, 1);
            break;

         case VVTERR1WAY:
         case VVTERR2WAY:
         case VVTERR3WAY:
            FwriteObjectAndMessage(ERc->keyval,ERc->Cnumber,
              ERc->ll1->idn, G_LINE,ERc->ll1->Lindex,ERc->ll1->localID, ERc->Sindex,-1.0,-1.0,
              ERc->ll1->x, ERc->ll1->y, ERc->ll1->z,2,"feature meeting specifications");
            break;

         default:
            printf("unrecognized key condition flag received during linear feature analysis\n");
            break;
         }
      ERn = ERc;
      ERc = ERc->next;
      free(ERn);
      }
   return;
} /*** end PerformLinearRelatedChecks ***/






int SameEdge(double x11, double y11, double z11, double x12, double y12, double z12,
             double x21, double y21, double z21, double x22, double y22, double z22)
{
int answer = 0;

   if((x11 == x21) && (y11 == y21) && (z11 == z21) && 
        (x12 == x22) && (y12 == y22) && (z12 == z22))
      {
      answer = 1;
      }
   else if((x12 == x21) && (y12 == y21) && (z12 == z21) &&
        (x11 == x22) && (y11 == y22) && (z11 == z22))
      {
      answer = 1;
      }
   return(answer);
}







int EdgesIntersectAtVertex(double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4)
{
double d;
int answer;

   answer = 0;
   d = PointToLineDist2D(x1,y1, x3,y3,x4,y4);
   if(d > 0.001)
      {
      d = PointToLineDist2D(x2,y2, x3,y3,x4,y4);
      if(d > 0.001)
         {
         d = PointToLineDist2D(x3,y3, x1,y1,x2,y2);
         if(d > 0.001)
            {
            d = PointToLineDist2D(x4,y4, x1,y1,x2,y2);
            if(d <= 0.001)
               {
               answer = 1;
               }
            }
         else
            {
            answer = 1;
            }
         }
      else
         {
         answer = 1;
         }
      }
   else
      {
      answer = 1;
      }

   return(answer);
}



int LineSegmentIntersectsLargeAreal(int tgtindex, double x1, double y1, double x2, double y2,
             struct RawAreal * A, int *OnEdge, double *xi, double *yi, int MallocSize)
{
int i,ci1, ci2;
int ii;
double xint, yint;
int answer;
int cindex1, cindex2;
int MYI;
int onedge;
int LastI, UsedTree;
struct RB_Edgelist * LastEdge1;


   answer = 0;
   MYI = MaxYindex + 1;
   onedge = 0;

  if(A->RB_Tree_Edgelist != NULL)
      {
      LastEdge1 = NULL;
      LastI = -1;

      if(tgtindex < 0)
         {
         ci1 = (int) (x1 / RegionSize);
         ci2 = (int) (y1 / RegionSize);
   
         cindex1 = (ci1 * MYI) + ci2;
   
         ci1 = (int) (x2 / RegionSize);
         ci2 = (int) (y2 / RegionSize);
   
         cindex2 = (ci1 * MYI) + ci2;
   
         if(cindex2 < cindex1)
            {
            ci1 = cindex2;
            cindex2 = cindex1;
            cindex1 = ci1;
            }
         }
      else
         {
         cindex1 = cindex2 = tgtindex;
         }

      LastEdge1 = NULL;
      LastI = -1;
      for(ci1=cindex1; ci1<=cindex2; ci1++)
         {
         i = GetNextArealIndex(A, LastI, 1, &LastEdge1, ci1, &UsedTree);
         LastI = i;

         while(i >= 0)
            {
            if(i == 0)
               ii = A->numverts - 1;
            else
               ii = i - 1;

            if(LineSegmentsIntersect(x1,y1, x2,y2, A->x[ii], A->y[ii], A->x[i], A->y[i], &xint, &yint) > 0)
               {
               answer += 1;
               onedge = EdgesIntersectAtVertex(x1,y1,x2,y2, A->x[ii], A->y[ii], A->x[i], A->y[i]);
               if(MallocSize == 0) /**** then only want to find any one intersection ***/
                  {
                  *OnEdge = onedge;
                  *xi = xint;
                  *yi = yint;
                  break; /**** breaks from while i >= 0 ***/
                  }
               else /*** want to find all intersections with this segment and put them on a list ***/
                  {
                  pic = (struct PointAndID *) (malloc(MallocSize));
                  if(pic == NULL)
                     {
                     printf("available memory has been exhausted during analysis of line segment - large area intersections\n");
                     printf("terminating process\n");
                     exit(-1);
                     }
                  pic->x = xint;
                  pic->y = yint;
                  pic->index1 = ii;
                  pic->index2 = i;
                  pic->ID = onedge;
                  pic->next = LAINTroot;
                  LAINTroot = pic;
                  }
               }

            i = GetNextArealIndex(A, LastI, 1, &LastEdge1, ci1, &UsedTree);

            if((LastI >= 0) && (i < 0)) /** can check one more edge ... **/
               {
               ii = LastI + 1;
               if(ii == A->numverts)
                  ii = 0;
               if(LineSegmentsIntersect(x1,y1, x2,y2, A->x[ii], A->y[ii], A->x[LastI], A->y[LastI], &xint, &yint) > 0)
                  {
                  answer += 1;
                  onedge = EdgesIntersectAtVertex(x1,y1,x2,y2, A->x[ii], A->y[ii], A->x[LastI], A->y[LastI]);
                  if(MallocSize == 0) /**** then only want to find any one intersection ***/
                     {
                     *OnEdge = onedge;
                     *xi = xint;
                     *yi = yint;
                     break; /**** breaks from while i >= 0 ***/
                     }
                  else /*** want to find all intersections with this segment and put them on a list ***/
                     {
                     pic = (struct PointAndID *) (malloc(MallocSize));
                     if(pic == NULL)
                        {
                        printf("available memory has been exhausted during analysis of line segment - large area intersections\n");
                        printf("terminating process\n");
                        exit(-1);
                        }
                     pic->x = xint;
                     pic->y = yint;
                     pic->index1 = ii;
                     pic->index2 = LastI;
                     pic->ID = onedge;
                     pic->next = LAINTroot;
                     LAINTroot = pic;
                     }
                  }
               }

            LastI = i;
            }  /** end while i >= 0 ***/
         if((MallocSize == 0) && (answer > 0))
            break;  /** break from for(ci1 loop ***/
         LastEdge1 = NULL;
         LastI = -1;
         } /*** end for(ci1=cindex1; ci1<=cindex2; ci1++) ***/
      }
   return(answer);
}



void CreatePointInsideAreal(struct RawAreal *A, double *px, double *py)
{
int I,J;
int FirstUnset, SecondUnset, PossibleReset;
double mx, my, my2,maxy;
double avgy, xi1, xi2;
double xi;

   mx = A->x[0];
   maxy = my = my2 = A->y[0];
   for(I=1; I<A->numverts; I++)
      {
      if(A->x[I] < mx)
         mx = A->x[I];

      if(A->y[I] < my)
         {
         my2 = my;
         my = A->y[I];
         }
      else if(A->y[I] < my2)
         {
         my2 = A->y[I];
         }
      if(A->y[I] > maxy)
         maxy = A->y[I];
      }

   if(my2 == my)
      {
      my2 = maxy;
      for(I=0; I<A->numverts; I++)
         {
         if((A->y[I] > my) && (A->y[I] < my2))
            my2 = A->y[I];
         }
      }

   avgy = my + (my2 - my) / 2;
   mx -= 1.0;

   FirstUnset = SecondUnset = 1;
   xi1 = xi2 = -1.0;
   for(I=0; I<A->numverts; I++)
      {
      xi = -1;
      PossibleReset = 0;
      if(I == 0)
         J = A->numverts - 1;
      else
         J = I - 1;
      if((A->y[I] == avgy) && (A->x[I] > mx))
         {
         xi = A->x[I];
         PossibleReset = 1;
         }
      else if((A->y[J] == avgy) && (A->x[J] > mx))
         {
         xi = A->x[J];
         PossibleReset = 1;
         }
      else if((A->y[I] < avgy) && (A->y[J] > avgy))
         {
         if((A->x[I] > mx) || (A->x[J] > mx))
            xi = FindXatYonSegment(avgy, A->x[I],A->y[I],A->x[J],A->y[J]);
         PossibleReset = 1;
         }
      else if((A->y[I] > avgy) && (A->y[J] < avgy))
         {
         if((A->x[I] > mx) || (A->x[J] > mx))
            xi = FindXatYonSegment(avgy, A->x[I],A->y[I],A->x[J],A->y[J]);
         PossibleReset = 1;
         }
      if(PossibleReset > 0)
         {
         if(FirstUnset > 0)
            {
            FirstUnset = 0;
            xi1 = xi;
            }
         else if((SecondUnset > 0) && (xi != xi1))
            {
            SecondUnset = 0;
            if(xi < xi1)
               {
               xi2 = xi1;
               xi1 = xi;
               }
            else
               xi2 = xi;
            }
         else if(xi < xi1)
            {
            if(xi1 < xi2)
               xi2 = xi1;
            xi1 = xi;
            }
         else if((xi > xi1) && (xi < xi2))
            {
            if(xi2 < xi1)
               xi1 = xi2;
            xi2 = xi;
            }
         }
      }
   if(xi1 < xi2)
      mx = xi1 + (xi2 - xi1) / 2.0;
   else
      mx = xi2 + (xi1 - xi2) / 2.0;

   *px = mx;
   *py = avgy;
   return;
}





int AreaInsideArea(struct RawAreal *inside, struct RawAreal *outside, double *px, double *py)
{
int answer = 0;
int i,ii,j,jj,vertexinside,Vout;
double unuseddbl;
double testx, testy;
double maxx,minx,maxy,miny;
double maxx2,minx2,maxy2,miny2;
int onedge;
int unusedint;
int TheyDoIntersect;
double xi, yi, xi2, yi2;




   Vout = 0;
   vertexinside = 0;
   for(i=0; i<inside->numverts; i++)
      {
      if(outside->RB_Tree_Edgelist == NULL)
         {
         if(PointIsAlmostVertex(inside->x[i],inside->y[i],outside->x,outside->y,outside->x,outside->numverts,&unuseddbl))
            {
            ++vertexinside;
            }
         else if(PointOnEdge(inside->x[i],inside->y[i],outside->x,outside->y,outside->x,outside->numverts,&unuseddbl,&unusedint))
            {
            ++vertexinside;
            }
         else if(PointIsInside(inside->x[i],inside->y[i],outside->x,outside->y,outside->x,outside->numverts,C_AREA,&unuseddbl))
            {
            ++vertexinside;
            }
         else if(vertexinside > 0) //((vertexinside > 0) && (vertexinside < i))
            { 
            Vout = i;
            break;
            }
         }
      else
         {
         if(PointIsAlmostLargeArealVertex(inside->x[i],inside->y[i],outside,&unuseddbl) > 0)
            {
            ++vertexinside;
            }
         else if(PointOnLargeArealEdge(inside->x[i],inside->y[i],outside,&unuseddbl, &unusedint) > 0)
            {
            ++vertexinside;
            }
         else if(PointInsideLargeAreal(inside->x[i],inside->y[i],outside,&ii) > 0)
            {
            ++vertexinside;
            }
         else if(vertexinside > 0)
            {
            Vout = i;
            break;
            }
         }
      }

   if(vertexinside >= inside->numverts)
      {
      answer = 2;
      TheyDoIntersect = 0;

      for(i=0; i<inside->numverts; i++)
         {
         ii = i + 1;
         if(ii == inside->numverts)
            ii = 0;
         if(inside->x[i] > inside->x[ii])
            {
            maxx = inside->x[i];
            minx = inside->x[ii];
            }
         else
            {
            maxx = inside->x[ii];
            minx = inside->x[i];
            }
         if(inside->y[i] > inside->y[ii])
            {
            maxy = inside->y[i];
            miny = inside->y[ii];
            }
         else
            {
            maxy = inside->y[ii];
            miny = inside->y[i];
            }
         maxx += 1.0;
         minx -= 1.0;
         maxy += 1.0;
         miny -= 1.0;

         TheyDoIntersect = 0;
         for(j=0; j<outside->numverts; j++)
            {
            jj = j + 1;
            if(jj == outside->numverts)
               jj = 0;
         if(outside->x[j] > outside->x[jj])
            {
            maxx2 = outside->x[j];
            minx2 = outside->x[jj];
            }
         else
            {
            maxx2 = outside->x[jj];
            minx2 = outside->x[j];
            }
         if(outside->y[j] > outside->y[jj])
            {
            maxy2 = outside->y[j];
            miny2 = outside->y[jj];
            }
         else
            {
            maxy2 = outside->y[jj];
            miny2 = outside->y[j];
            }
            if((maxx2 > minx) && (minx2 < maxx) && (maxy2 > miny) && (miny2 < maxy) /***&& 
              (CheapLineSegmentsConnect(inside->x[i],inside->y[i],inside->x[ii],inside->y[ii],
                                                 outside->x[j],outside->y[j],outside->x[jj],outside->y[jj],0.0001) == 0) ***/)
               {

               if(LineSegmentsOverlap(inside->x[i],inside->y[i],inside->x[ii],inside->y[ii],
                                                 outside->x[j],outside->y[j],outside->x[jj],outside->y[jj],
                                                 &xi, &yi, &xi2, &yi2, 0.01) == 0) 
                  {
                  TheyDoIntersect = LineSegmentsIntersect(inside->x[i],inside->y[i],inside->x[ii],inside->y[ii],
                                                 outside->x[j],outside->y[j],outside->x[jj],outside->y[jj],&xi,&yi);
                  if(TheyDoIntersect > 0)
                     {
                     unuseddbl = Distance(inside->x[i],inside->y[i],xi,yi);
                     if(unuseddbl > 0.001)
                        {
                        unuseddbl = Distance(inside->x[ii],inside->y[ii],xi,yi);
                        if(unuseddbl > 0.001)
                           {
                           unuseddbl = Distance(outside->x[j],outside->y[j],xi,yi);
                           if(unuseddbl > 0.0001)
                              {
                              unuseddbl = Distance(outside->x[jj],outside->y[jj],xi,yi);
                              if(unuseddbl > 0.0001)
                                 {
                                 *px = xi;
                                 *py = yi;
                                 answer = 1;
                                 break;
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
         if(answer < 2)
            break;
         }
      }
   else if(vertexinside > 0)
      {
      *px = inside->x[Vout];
      *py = inside->y[Vout];
      answer = 1; /** must be partially inside if at least 1 vertex is inside, but not all are inside **/
      }

   if(answer == 2) /** should indicate that the area feature is FULLY inside ***/
      {
      CreatePointInsideAreal(inside, &testx, &testy); 
      if(outside->RB_Tree_Edgelist == NULL)
         {
         if(PointInsidePoly(testx,testy,outside->x, outside->y, outside->numverts) < 1)
            {
            *px = testx;
            *py = testy;
            answer = 1;
            }
         }

      else if((PointInsideLargeAreal(testx, testy ,outside, &onedge) < 1) &&
         (onedge == 0))
         {
         *px = testx;
         *py = testy;
         answer = 1;
         }
      }

   return(answer);
}




void PerformRangeLimitedEdgeMatchChecks(char * prompt, int cindex,
    struct RawLinear *Lroot,double minx,double miny,double maxx,double maxy, double multiplier,
    int NorthCount, int SouthCount, int EastCount, int WestCount,
    struct RawAreal *Aroot, struct RawBridge *Broot, struct RawPoint *Proot, struct ListOfEdges *PEroot, struct ListOfEdges *VPEroot,
    struct RawLinear *NLroot, struct ThePolys * Polyroot)
{
struct RawLinear *rlc, *rln, *rln3;
struct RawAreal *rac, *ran, *rap;
struct RB_Edgelist *LastEdge1, *LastEdge2, *LastEdge3;
unsigned char clipflag;
int i,j,k,ii, jj, kk, checkinstance, vindex,vindex2;
int E1, E2, B1, B2,B3,B4, on0, on1, on2, on3, unusedint;
/**int end1, end2; ***/
int part1, part2, part3;
int direction,direction2, dir1, dir2, timesthruloop;
int FoundCondition, LastI, LastJ, LastK, UsedTree;
int fndpr, candidate, checkit,checkit2, checkit3;
int Config1, Strat1, Domain1;
int bothends, DirHasBeenSet;
int racAbove, ranAbove, racLeft, ranLeft;
double xinside1, yinside1;
double minxPadded, maxxPadded;
double minyPadded, maxyPadded;
double minxLimit, maxxLimit;
double minyLimit, maxyLimit;
double angle, angle2;
double x1, y1, x2, y2, z1, z2;
double xt1,yt1,xt2,yt2,z3,z4,bx1,by1,bx2,by2,bx3,by3,bx4,by4;
double LenToCover, CoveredSoFar, MatchLen;
double LatLonBase, LatLonIncrement, LowerTolerance, UpperTolerance;
double unuseddbl, tolerance4;
double tempdbl,tempdist,tempdist2;
double LocalMinX, LocalMaxX, LocalMinY, LocalMaxY;
struct UnMatched
   {
   double x1, y1, x2, y2;
   struct UnMatched * next;
   } *UMroot, *UMn, *UMc, *UMp;
struct MatchedEdges
   {
   int ind1;
   int ind2;
   int covered;
   double x[2];
   double y[2];
   struct RawAreal *a;
   struct MatchedEdges *next;
   } *MEroot, *MEn, *MEc, *TEroot, *TEc, *TEn;
struct collection
   {
   int keyval;
   int Cnumber;
   int numpoints;
   double x[6];
   double y[6];
   double z[6];
   double magnitude;
   int IDN;
   unsigned int Sindex;
   int vertexindex1, vertexindex2;
   struct RawAreal *aa,*aa2;
   struct RawBridge *bb;
   struct RawPoint *pp;
   struct ListOfEdges *le;
   struct RawLinear *ll1,*ll2;
   struct ThePolys *poly;
   struct collection * next;
   } *ERroot, *ERc, *ERn;
int SzC = sizeof(struct collection);
int SzME = sizeof(struct MatchedEdges);
int SzUM = sizeof(struct UnMatched);
extern int SzARU;
extern struct ARangeUNM *LatRoot;
extern struct ARangeUNM *LonRoot;
extern struct ARangeUNM *ARUc, *ARUn;

   ERroot = NULL;


   rlc = Lroot;

   while(rlc != NULL)
      {
       Config1 = SCCtable[rlc->Sindex].C;
       Strat1 = SCCtable[rlc->Sindex].S;
       Domain1 = SCCtable[rlc->Sindex].D;

       for(checkinstance = 0; checkinstance < TtlActiveChecks; checkinstance++)
          {


          if((CombinedCheckApplies(rlc->idn,checkinstance,LRNGE_UNM_LAT,rlc->Lindex,rlc->Sindex,Config1,Strat1,Domain1,&part1,&part2,&part3) > 0) &&
                   (part1 > 0))
             {
             candidate = FoundCondition = 0;

             i = Ctype();
             if(i == 1) /** geodetic **/
                {
                LocalMinY = miny / 100000.0 + Ytranslation;
                LocalMaxY = maxy / 100000.0 + Ytranslation;

                LatLonBase = 0.0;
                LowerTolerance = FindRelevantSensitivity(LRNGE_UNM_LAT,checkinstance,&UpperTolerance);
                if(FindSpecificSensitivity(3,LRNGE_UNM_LAT,checkinstance,&LatLonIncrement) < 1)
                   LatLonIncrement = 1.0;


                k = (int) ((LocalMinY - LatLonBase) / LatLonIncrement);

                LatLonBase += (double) k * LatLonIncrement;

                if(LatLonBase < LocalMinY)
                   LatLonBase += LatLonIncrement;

                if(LatLonBase <= LocalMaxY)
                   {
                   LatLonIncrement *= 100000.0;
                   LatLonBase = (LatLonBase - Ytranslation) * 100000.0;
                   LocalMinY = LatLonBase - UpperTolerance;
                   LocalMaxY = LatLonBase + UpperTolerance;
                   }
                else
                   {
                   LatLonBase = maxy * 2.0; /** effectively says check will not be applied ***/
                   }
                }
             else if(i == 2)
                {
                LatLonBase = maxy * 2.0; /** effectively says check will not be applied ***/
                }
             if(rlc->length <= UpperTolerance)
                {
                bothends = 0;
                tempdbl = fabs(rlc->y[0] - LatLonBase);
                unuseddbl = fabs(rlc->y[rlc->numnodes -1] - LatLonBase);
                if(tempdbl < unuseddbl)
                   j = 0;
                else
                   j = rlc->numnodes - 1;
                }
             else
                {
                bothends = 1;
                j = 0;
                }

             while((LatLonBase > MinYcoord) && (LatLonBase < MaxYcoord) && (LatLonBase >= miny) && (LatLonBase <= maxy))
                {
                while(j < rlc->numnodes)
                   {
                   fndpr = 0;
                   candidate = 0;
                   FoundCondition = 0;
                   checkit = 1;
                   if(NorthCount <= 0)
                      checkit = ConditionOnDataEdge(rlc->x[j],rlc->y[j],rlc->x[j],rlc->y[j],Aroot,Proot,Lroot,
                                               NULL, NULL, rlc, NorthCount, 100,100,100,checkinstance);
                   if((checkit > 0) && (SouthCount <= 0))
                      checkit = ConditionOnDataEdge(rlc->x[j],rlc->y[j],rlc->x[j],rlc->y[j],Aroot,Proot,Lroot,
                                               NULL, NULL, rlc, 100, SouthCount, 100,100,checkinstance);
                   if(checkit > 0)
                      {
                      checkit = 0;
                      if((rlc->x[j] >= minx) && (rlc->x[j] <= maxx) && (rlc->y[j] >= LocalMinY) && (rlc->y[j] <= LocalMaxY))
                         {
                         tempdist = Distance(rlc->x[j],rlc->y[j],rlc->x[j],LatLonBase);
                         if(tempdist <= ActiveChecks[checkinstance].sensitivity4)
                            checkit = 1;
                         }
                      }
                   if(checkit > 0)
                      {
                      minyPadded = rlc->y[j] - LowerTolerance;
                      minxPadded = rlc->x[j] - LowerTolerance;

                      maxxPadded = rlc->x[j] + LowerTolerance;
                      maxyPadded = rlc->y[j] + LowerTolerance;

                      minyLimit = rlc->y[j] - UpperTolerance;
                      minxLimit = rlc->x[j] - UpperTolerance;

                      maxxLimit = rlc->x[j] + UpperTolerance;
                      maxyLimit = rlc->y[j] + UpperTolerance;

                      direction = 0;
                      dir1 = dir2 = 0;
                      for(i = 0; i< rlc->numnodes; i++)
                         {
                         if(rlc->y[i] > LatLonBase)
                            ++dir1;
                         else  if(rlc->y[i] < LatLonBase)
                            ++dir2;
                         }
                      if(dir1 == dir2)
                         {
                         tempdbl = rlc->y[0] + ((rlc->y[1] - rlc->y[0]) / 2);
                         if(tempdbl > LatLonBase)
                            ++dir1;
                         else
                            ++dir2;
                         }
                      if(dir1 > dir2)
                         ++direction;
                      else
                         --direction;

                      rln = Lroot;
                      rln3 = NULL;
                      fndpr = 0;
                      timesthruloop = 0;
                      while(rln != NULL)
                         {
                         if(rln != rlc) /*** try to match the rlc end node up with a node of ANY other type line ***/
                            {
                            if((CombinedCheckApplies(rln->idn,checkinstance,LRNGE_UNM_LAT,rln->Lindex,rln->Sindex,
                                 SCCtable[rln->Sindex].C,SCCtable[rln->Sindex].S,SCCtable[rln->Sindex].D,&part1,&part2,&part3) > 0) &&
                                  ((part2 > 0) || (part3 > 0)))
                               {
                               DirHasBeenSet = 0;
                               for(i=0; i<rln->numnodes; i++)
                                  {
                                  if((rln->x[i] >= minxLimit) && (rln->x[i] <= maxxLimit) &&
                                       (rln->y[i] >= minyLimit) && (rln->y[i] <= maxyLimit))
                                     {
                                     if(DirHasBeenSet == 0)
                                        {
                                        DirHasBeenSet = 1;
                                        direction2 = 0;
                                        dir1 = dir2 = 0;
                                        for(k = 0; k< rln->numnodes; k++)
                                           {
                                           if(rln->y[k] > LatLonBase)
                                              ++dir1;
                                           else  if(rln->y[k] < LatLonBase)
                                              ++dir2;
                                           }
                                        if(dir1 == dir2)
                                           {
                                           tempdbl = rln->y[0] + ((rln->y[1] - rln->y[0]) / 2);
                                           if(tempdbl > LatLonBase)
                                              ++dir1;
                                           else
                                              ++dir2;
                                           }
                                        if(dir1 > dir2)
                                           ++direction2;
                                        else
                                           --direction2;
                                        }

                                     k = direction * direction2;
                                     if(k <= 0)
                                        {
                                        if(part3 > 0)
                                           {
                                           candidate = 1;
                                           rln3 = rln;
                                           vindex = i;
                                           }
                                        if((part2 > 0) && (rln->x[i] >= minxPadded) && (rln->x[i] <= maxxPadded) &&
                                               (rln->y[i] >= minyPadded) && (rln->y[i] <= maxyPadded))
                                           {
                                           fndpr = 1;
                                           break;
                                           }
                                        }
                                     else /** it may have joined a line on same side of LatLonBase - does that line get closer to LatLonBase ?? **/
                                        {
                                        if((rln->x[i] >= minxPadded) && (rln->x[i] <= maxxPadded) &&
                                               (rln->y[i] >= minyPadded) && (rln->y[i] <= maxyPadded))
                                           {
                                           if(i == 0)
                                              {
                                              tempdbl = fabs(rln->y[1] - LatLonBase);
                                              unuseddbl = fabs(rlc->y[j] - LatLonBase);
                                              if(unuseddbl > tempdbl) /** rlc is further from LatLonBase ***/
                                                 {
                                                 fndpr = 1;
                                                 break;
                                                 }
                                              }
                                           else if(i == (rln->numnodes - 1))
                                              {
                                              tempdbl = fabs(rln->y[rln->numnodes - 2] - LatLonBase);
                                              unuseddbl = fabs(rlc->y[j] - LatLonBase);
                                              if(unuseddbl > tempdbl) /** rlc is further from LatLonBase ***/
                                                 {
                                                 fndpr = 1;
                                                 break;
                                                 }
                                              }
                                           else
                                              {
                                              tempdbl = fabs(rln->y[i - 1] - LatLonBase);
                                              unuseddbl = fabs(rln->y[i + 1] - LatLonBase);
                                              if(unuseddbl < tempdbl)
                                                 tempdbl = unuseddbl;
                                              unuseddbl = fabs(rlc->y[j] - LatLonBase);
                                              if(unuseddbl > tempdbl) /** rlc is further from LatLonBase ***/
                                                 {
                                                 fndpr = 1;
                                                 break;
                                                 }
                                              }
                                           }
                                        }
                                     }
                                  } /** end for i ... ***/
                               } /*** end have same FCODE ***/
                            else if((CombinedCheckApplies(rln->idn,checkinstance,LRNGE_UNM_LAT,rln->Lindex,rln->Sindex,
                                 SCCtable[rln->Sindex].C,SCCtable[rln->Sindex].S,SCCtable[rln->Sindex].D,&part1,&part2,&part3) > 0) &&
                                  (part3 > 0))
                               {
                               for(i=0; i<rln->numnodes; i++)
                                  {
                                  if((rln->x[i] >= minxLimit) && (rln->x[i] <= maxxLimit) &&
                                       (rln->y[i] >= minyLimit) && (rln->y[i] <= maxyLimit))
                                     {
                                     direction2 = 0;
                                     dir1 = dir2 = 0;
                                     for(k = 0; k< rln->numnodes; k++)
                                        {
                                        if(rln->y[k] > LatLonBase)
                                           ++dir1;
                                        else if(rln->y[k] < LatLonBase)
                                           ++dir2;
                                        }
                                     if(dir1 == dir2)
                                        {
                                        tempdbl = rln->y[0] + ((rln->y[1] - rln->y[0]) / 2);
                                        if(tempdbl > LatLonBase)
                                           ++dir1;
                                        else
                                           ++dir2;
                                        }
                                     if(dir1 > dir2)
                                        ++direction2;
                                     else
                                        --direction2;

                                     k = direction * direction2;
                                     if(k <= 0)
                                        {
                                        candidate = 1;
                                        rln3 = rln;
                                        vindex = i;
                                        }
                                     }
                                  } /** end for i ... ***/
                               }
                            }
                         if(fndpr > 0)
                            break;
                         rln = rln->next;
                         if((rln == NULL) && (timesthruloop == 0))
                            {
                            timesthruloop = 1;
                            rln = NLroot;
                            }
                         }

                      if((fndpr == 0) && (candidate > 0))
                         {
                         tempdbl = Distance(rlc->x[j],rlc->y[j], rlc->x[j], LatLonBase);
                         if(tempdbl <= UpperTolerance)
                            FoundCondition = 1;
                         else
                            FoundCondition = 0;
                         }
                      else
                         {
                         FoundCondition = 0;
                         }

                      } /** end if endpoint[j] is in the load module  ***/
                   if(FoundCondition > 0) /** need to add a condition to the list ***/
                      {
                      rln = Lroot;
                      tempdist = Distance(rlc->x[j],rlc->y[j],rln3->x[vindex],rln3->y[vindex]);
                      while(rln != NULL)
                         {
                         if(rln != rlc)
                            {
                            if((CombinedCheckApplies(rln->idn,checkinstance,LRNGE_UNM_LAT,rln->Lindex,rln->Sindex,
                                 SCCtable[rln->Sindex].C,SCCtable[rln->Sindex].S,SCCtable[rln->Sindex].D,&part1,&part2,&part3) > 0) &&
                                  (part3 > 0))
                               {
                               direction2 = 0;
                               dir1 = dir2 = 0;
                               for(k = 0; k< rln->numnodes; k++)
                                  {
                                  if(rln->y[k] > LatLonBase)
                                     ++dir1;
                                  else if(rln->y[k] < LatLonBase)
                                     ++dir2;
                                  }
                               if(dir1 == dir2)
                                  {
                                  tempdbl = rln->y[0] + ((rln->y[1] - rln->y[0]) / 2);
                                  if(tempdbl > LatLonBase)
                                     ++dir1;
                                  else
                                     ++dir2;
                                  }
                               if(dir1 > dir2)
                                  ++direction2;
                               else
                                  --direction2;

                               k = direction * direction2;
                               if(k <= 0)
                                  {
                                  for(i=0; i<rln->numnodes; i++)
                                     {
                                     unuseddbl = Distance(rlc->x[j],rlc->y[j],rln->x[i],rln->y[i]);
                                     if(unuseddbl < tempdist)
                                        {
                                        tempdist = unuseddbl;
                                        rln3 = rln;
                                        vindex = i;
                                        }
                                     }
                                  }
                               }
                            }
                         rln = rln->next;
                         }

                      FoundCondition = 0;
                      if(tempdist <= ActiveChecks[checkinstance].sensitivity2)
                         {
                         ERc = (struct collection *) (malloc(SzC));
                         if(ERc == NULL)
                           {
                           printf("allocation memory exhausted during linear feature condition analysis (boundary match analysis)\n");
                           printf("processing cannot continue\n");
                           exit(-1);
                           }
                         ERc->x[0] = rlc->x[j];
                         ERc->y[0] = rlc->y[j];
                         ERc->z[0] = rlc->z[j];
                         if(j == 0)
                            {
                            ERc->x[1] = rlc->x[1];
                            ERc->y[1] = rlc->y[1];
                            ERc->z[1] = rlc->z[1];
                            }
                         else
                            {
                            ERc->x[1] = rlc->x[j-1];
                            ERc->y[1] = rlc->y[j-1];
                            ERc->z[1] = rlc->z[j-1];
                            }
                         ERc->IDN = rlc->idn;
                         ERc->Sindex = rlc->Sindex;
                         ERc->aa = NULL; /** RawAreal **/
                         ERc->bb = NULL; /** RawBridge **/
                         ERc->pp = NULL; /** RawPoint **/
                         ERc->le = NULL; /** ListOfEdges **/
                         ERc->poly = NULL; /** ThePolys **/
                         ERc->ll1 = rlc;
                         ERc->ll2 = rln3;
                         if(vindex == (rln3->numnodes -1))
                            ERc->vertexindex2 = vindex - 1;
                         else
                            ERc->vertexindex2 = vindex;
                         ERc->keyval = LRNGE_UNM_LAT;
                         ERc->Cnumber = Make_Correct(LRNGE_UNM_LAT,checkinstance);
                         ERc->magnitude = tempdist;
   
                         if(ERroot == NULL)
                            {
                            ERroot = ERc;
                            ERroot->next = NULL;
                            }
                         else
                            {
                            ERn = ERroot;
                            while(ERn != NULL)
                               {
                               if((ERn->keyval == ERc->keyval) && (ERc->Cnumber == ERn->Cnumber))
                                  {
                                  if(ERn->ll1 == ERc->ll1)
                                     {
                                     if((ERc->x[0] == ERn->x[0]) && (ERc->y[0] == ERn->y[0]) && (ERc->z[0] == ERn->z[0]))
                                        {
                                        break;
                                        }
                                     }
                                  }
                               ERn = ERn->next;
                               }
                            if(ERn == NULL)
                               {
                               ERc->next = ERroot;
                               ERroot = ERc;
                               }
                            else
                               {
                               free(ERc);
                               }
                            }
                         } /** end double check magnitude ***/
                      } /*** end FoundCondition ***/
                   j += rlc->numnodes - 1;
                   if((fndpr > 0) || (bothends < 1))
                      break;
                   } /*** while j < rlc->numnodes ***/
                LatLonBase = LatLonBase + LatLonIncrement;
                }  /*** end while LatLonBase in miny, maxy range **/
             } /*** end LRNGE_UNM_LAT check applies ***/





          if((CombinedCheckApplies(rlc->idn,checkinstance,LRNGE_UNM_LON,rlc->Lindex,rlc->Sindex,Config1,Strat1,Domain1,&part1,&part2,&part3) > 0) &&
                   (part1 > 0))
             {
             candidate = FoundCondition = 0;
             i = Ctype();
             if(i == 1) /** geodetic **/
                {
                LocalMinX = minx / 100000.0 + Xtranslation;
                LocalMaxX = maxx / 100000.0 + Xtranslation;

                LatLonBase = 0.0;
                LowerTolerance = FindRelevantSensitivity(LRNGE_UNM_LON,checkinstance,&UpperTolerance);
                if(FindSpecificSensitivity(3,LRNGE_UNM_LON,checkinstance,&LatLonIncrement) < 1)
                   LatLonIncrement = 1.0;

                k = (int) ((LocalMinX - LatLonBase) / LatLonIncrement);

                LatLonBase += (double) k * LatLonIncrement;
                if(LatLonBase < LocalMinX) /** could be that we have exact multiple - if not need to add one increment ***/
                   LatLonBase += LatLonIncrement;

                if(LatLonBase <= LocalMaxX)
                   {
                   LatLonIncrement *= 100000.0;
                   LatLonBase = (LatLonBase - Xtranslation) * 100000.0;
                   LocalMinX = LatLonBase - UpperTolerance;
                   LocalMaxX = LatLonBase + UpperTolerance;
                   }
                else
                   {
                   LatLonBase = maxx * 2.0; /** effectively says check will not be applied ***/
                   }
                }
             else if(i == 2)
                {
                LatLonBase = maxx * 2.0; /** effectively says check will not be applied ***/
                }

             if(rlc->length <= UpperTolerance)
                {
                bothends = 0;
                tempdbl = fabs(rlc->x[0] - LatLonBase);
                unuseddbl = fabs(rlc->x[rlc->numnodes -1] - LatLonBase);
                if(tempdbl < unuseddbl)
                   j = 0;
                else
                   j = rlc->numnodes - 1;
                }
             else
                {
                bothends = 1;
                j = 0;
                }
             while((LatLonBase > MinXcoord) && (LatLonBase < MaxXcoord) && (LatLonBase >= minx) && (LatLonBase <= maxx))
                {
                while(j < rlc->numnodes)
                   {
                   fndpr = 0;
                   FoundCondition = 0;
                   checkit = 1;
                   if(EastCount <= 0)
                      checkit = ConditionOnDataEdge(rlc->x[j],rlc->y[j],rlc->x[j],rlc->y[j],Aroot,Proot,Lroot,
                                               NULL, NULL, rlc, 100, 100,EastCount,100,checkinstance);
                   if((checkit > 0) && (WestCount <= 0))
                      checkit = ConditionOnDataEdge(rlc->x[j],rlc->y[j],rlc->x[j],rlc->y[j],Aroot,Proot,Lroot,
                                               NULL, NULL, rlc, 100, 100, 100,WestCount,checkinstance);
                   if(checkit > 0)
                      {
                      checkit = 0;
                      if((rlc->x[j] >= LocalMinX) && (rlc->x[j] <= LocalMaxX) && (rlc->y[j] >= miny) && (rlc->y[j] <= maxy))
                         {
                         tempdist = Distance(rlc->x[j],rlc->y[j],LatLonBase,rlc->y[j]);
                         if(tempdist <= ActiveChecks[checkinstance].sensitivity4)
                            checkit = 1;
                         }
                      }
                   if(checkit > 0)
                      {
                      minyPadded = rlc->y[j] - LowerTolerance;
                      minxPadded = rlc->x[j] - LowerTolerance;

                      maxxPadded = rlc->x[j] + LowerTolerance;
                      maxyPadded = rlc->y[j] + LowerTolerance;

                      minyLimit = rlc->y[j] - UpperTolerance;
                      minxLimit = rlc->x[j] - UpperTolerance;

                      maxxLimit = rlc->x[j] + UpperTolerance;
                      maxyLimit = rlc->y[j] + UpperTolerance;

                      direction = 0;
                      dir1 = dir2 = 0;
                      for(i = 0; i< rlc->numnodes; i++)
                         {
                         if(rlc->x[i] > LatLonBase)
                            ++dir1;
                         else if(rlc->x[i] < LatLonBase)
                            ++dir2;
                         }
                      if(dir1 == dir2)
                         {
                         tempdbl = rlc->x[0] + ((rlc->x[1] - rlc->x[0]) / 2);
                         if(tempdbl > LatLonBase)
                            ++dir1;
                         else
                            ++dir2;
                         }
                      if(dir1 > dir2)
                         ++direction;
                      else
                         --direction;

                      rln = Lroot;
                      rln3 = NULL;
                      fndpr = 0;
                      candidate = 0;
                      timesthruloop = 0;
                      while(rln != NULL)
                         {
                         if(rln != rlc) /*** try to match the rlc end node up with a node of ANY other type line ***/
                            {
                            if((CombinedCheckApplies(rln->idn,checkinstance,LRNGE_UNM_LON,rln->Lindex,rln->Sindex,
                                 SCCtable[rln->Sindex].C,SCCtable[rln->Sindex].S,SCCtable[rln->Sindex].D,&part1,&part2,&part3) > 0) &&
                                  ((part2 > 0) || (part3 > 0)))
                               {
                               DirHasBeenSet = 0;
                               for(i=0; i<rln->numnodes; i++)
                                  {
                                  if((rln->x[i] >= minxLimit) && (rln->x[i] <= maxxLimit) &&
                                       (rln->y[i] >= minyLimit) && (rln->y[i] <= maxyLimit))
                                     {
                                     if(DirHasBeenSet == 0)
                                        {
                                        DirHasBeenSet = 1;
                                        direction2 = 0;
                                        dir1 = dir2 = 0;
                                        for(k = 0; k< rln->numnodes; k++)
                                           {
                                           if(rln->x[k] > LatLonBase)
                                              ++dir1;
                                           else if(rln->x[k] < LatLonBase)
                                              ++dir2;
                                           }
                                        if(dir1 == dir2)
                                           {
                                           tempdbl = rln->x[0] + ((rln->x[1] - rln->x[0]) / 2);
                                           if(tempdbl > LatLonBase)
                                              ++dir1;
                                           else
                                              ++dir2;
                                           }
                                        if(dir1 > dir2)
                                           ++direction2;
                                        else
                                           --direction2;
                                        }
                                     k = direction * direction2;
                                     if(k <= 0)
                                        {
                                        if(part3 > 0)
                                           {
                                           candidate = 1;
                                           rln3 = rln;
                                           vindex = i;
                                           }
                                        if((part2 > 0) && (rln->x[i] >= minxPadded) && (rln->x[i] <= maxxPadded) &&
                                               (rln->y[i] >= minyPadded) && (rln->y[i] <= maxyPadded))
                                           {
                                           fndpr = 1;
                                           break;
                                           }
                                        }
                                     else /** it may have joined a line on same side of LatLonBase - does that line get closer to LatLonBase ?? **/
                                        {
                                        if((rln->x[i] >= minxPadded) && (rln->x[i] <= maxxPadded) &&
                                               (rln->y[i] >= minyPadded) && (rln->y[i] <= maxyPadded))
                                           {
                                           if(i == 0)
                                              {
                                              tempdbl = fabs(rln->x[1] - LatLonBase);
                                              unuseddbl = fabs(rlc->x[j] - LatLonBase);
                                              if(unuseddbl > tempdbl) /** rlc is further from LatLonBase ***/
                                                 {
                                                 fndpr = 1;
                                                 break;
                                                 }
                                              }
                                           else if(i == (rln->numnodes - 1))
                                              {
                                              tempdbl = fabs(rln->x[rln->numnodes - 2] - LatLonBase);
                                              unuseddbl = fabs(rlc->x[j] - LatLonBase);
                                              if(unuseddbl > tempdbl) /** rlc is further from LatLonBase ***/
                                                 {
                                                 fndpr = 1;
                                                 break;
                                                 }
                                              }
                                           else
                                              {
                                              tempdbl = fabs(rln->x[i - 1] - LatLonBase);
                                              unuseddbl = fabs(rln->x[i + 1] - LatLonBase);
                                              if(unuseddbl < tempdbl)
                                                 tempdbl = unuseddbl;
                                              unuseddbl = fabs(rlc->x[j] - LatLonBase);
                                              if(unuseddbl > tempdbl) /** rlc is further from LatLonBase ***/
                                                 {
                                                 fndpr = 1;
                                                 break;
                                                 }
                                              }
                                           }
                                        }

/***/
                                     }
                                  } /*** end for i ... ***/
                               } /*** end have same FCODE ***/
                            else if((CombinedCheckApplies(rln->idn,checkinstance,LRNGE_UNM_LON,rln->Lindex,rln->Sindex,
                                 SCCtable[rln->Sindex].C,SCCtable[rln->Sindex].S,SCCtable[rln->Sindex].D,&part1,&part2,&part3) > 0) &&
                                  (part3 > 0))
                               {
                               for(i=0; i<rln->numnodes; i++)
                                  {
                                  if((rln->x[i] >= minxLimit) && (rln->x[i] <= maxxLimit) &&
                                       (rln->y[i] >= minyLimit) && (rln->y[i] <= maxyLimit))
                                     {
                                     direction2 = 0;
                                     dir1 = dir2 = 0;
                                     for(k = 0; k< rln->numnodes; k++)
                                        {
                                        if(rln->x[k] > LatLonBase)
                                           ++dir1;
                                        else if(rln->x[k] < LatLonBase)
                                           ++dir2;
                                        }
                                     if(dir1 == dir2)
                                        {
                                        tempdbl = rln->x[0] + ((rln->x[1] - rln->x[0]) / 2);
                                        if(tempdbl > LatLonBase)
                                           ++dir1;
                                        else
                                           ++dir2;
                                        }

                                     if(dir1 > dir2)
                                        ++direction2;
                                     else
                                        --direction2;
                                     k = direction * direction2;
                                     if(k <= 0)
                                        {
                                        candidate = 1;
                                        rln3 = rln;
                                        vindex = i;
                                        }
                                     }
                                  } /*** end for i ... ***/
                               }
                            }
                         if(fndpr > 0)
                            break;
                         rln = rln->next;
                         if((rln == NULL) && (timesthruloop == 0))
                            {
                            timesthruloop = 1;
                            rln = NLroot;
                            }
                         }

                      if((fndpr == 0) && (candidate > 0))
                         {
                         tempdbl = Distance(rlc->x[j],rlc->y[j], LatLonBase, rlc->y[j]);
                         if(tempdbl <= UpperTolerance)
                            FoundCondition = 1;
                         else
                            FoundCondition = 0;
                         }
                      else
                         {
                         FoundCondition = 0;
                         }

                      } /** end if endpoint[j] is in the load module  ***/
                   if(FoundCondition > 0) /** need to add a condition to the list ***/
                      {
                      rln = Lroot;
                      tempdist = Distance(rlc->x[j],rlc->y[j],rln3->x[vindex],rln3->y[vindex]);
                      while(rln != NULL)
                         {
                         if(rln != rlc)
                            {
                            if((CombinedCheckApplies(rln->idn,checkinstance,LRNGE_UNM_LON,rln->Lindex,rln->Sindex,
                                 SCCtable[rln->Sindex].C,SCCtable[rln->Sindex].S,SCCtable[rln->Sindex].D,&part1,&part2,&part3) > 0) &&
                                  (part3 > 0))
                               {
                               direction2 = 0;
                               dir1 = dir2 = 0;
                               for(k = 0; k< rln->numnodes; k++)
                                  {
                                  if(rln->x[k] > LatLonBase)
                                     ++dir1;
                                  else if(rln->x[k] < LatLonBase)
                                     ++dir2;
                                  }
                               if(dir1 == dir2)
                                  {
                                  tempdbl = rln->x[0] + ((rln->x[1] - rln->x[0]) / 2);
                                  if(tempdbl > LatLonBase)
                                     ++dir1;
                                  else
                                     ++dir2;
                                  }
                               if(dir1 > dir2)
                                  ++direction2;
                               else
                                  --direction2;
                               
                               k = direction * direction2;
                               if(k <= 0)
                                  {
                                  for(i=0; i<rln->numnodes; i++)
                                     {
                                     unuseddbl = Distance(rlc->x[j],rlc->y[j],rln->x[i],rln->y[i]);
                                     if(unuseddbl < tempdist)
                                        {
                                        tempdist = unuseddbl;
                                        rln3 = rln;
                                        vindex = i;
                                        }
                                     }
                                  }
                               }
                            }
                         rln = rln->next;
                         }
                      FoundCondition = 0;
                      if(tempdist <= ActiveChecks[checkinstance].sensitivity2)
                         {
                         ERc = (struct collection *) (malloc(SzC));
                         if(ERc == NULL)
                           {
                           printf("allocation memory exhausted during linear feature condition analysis (boundary match analysis)\n");
                           printf("processing cannot continue\n");
                           exit(-1);
                           }
                         ERc->x[0] = rlc->x[j];
                         ERc->y[0] = rlc->y[j];
                         ERc->z[0] = rlc->z[j];
                         if(j == 0)
                            {
                            ERc->x[1] = rlc->x[1];
                            ERc->y[1] = rlc->y[1];
                            ERc->z[1] = rlc->z[1];
                            }
                         else
                            {
                            ERc->x[1] = rlc->x[j-1];
                            ERc->y[1] = rlc->y[j-1];
                            ERc->z[1] = rlc->z[j-1];
                            }
                         ERc->IDN = rlc->idn;
                         ERc->Sindex = rlc->Sindex;
                         ERc->aa = NULL; /** RawAreal **/
                         ERc->bb = NULL; /** RawBridge **/
                         ERc->pp = NULL; /** RawPoint **/
                         ERc->le = NULL; /** ListOfEdges **/
                         ERc->poly = NULL; /** ThePolys **/
                         ERc->ll1 = rlc;
                         ERc->ll2 = rln3;
                         if(vindex == (rln3->numnodes -1))
                            ERc->vertexindex2 = vindex - 1;
                         else
                            ERc->vertexindex2 = vindex;
                         ERc->keyval = LRNGE_UNM_LON;
                         ERc->Cnumber = Make_Correct(LRNGE_UNM_LON,checkinstance);
                         ERc->magnitude = tempdist;

                         if(ERroot == NULL)
                            {
                            ERroot = ERc;
                            ERroot->next = NULL;
                            }
                         else
                            {
                            ERn = ERroot;
                            while(ERn != NULL)
                               {
                               if((ERn->keyval == ERc->keyval) && (ERc->Cnumber == ERn->Cnumber))
                                  {
                                  if(ERn->ll1 == ERc->ll1)
                                     {
                                     if((ERc->x[0] == ERn->x[0]) && (ERc->y[0] == ERn->y[0]) && (ERc->z[0] == ERn->z[0]))
                                        {
                                        break;
                                        }
                                     }
                                  }
                               ERn = ERn->next;
                               }
                            if(ERn == NULL)
                               {
                               ERc->next = ERroot;
                               ERroot = ERc;
                               }
                            else
                               {
                               free(ERc);
                               }
                            }
                         } /** end double check magnitude ***/
                      } /*** end FoundCondition ***/
                   if((fndpr > 0) || (bothends < 1))
                      break;
                   j += rlc->numnodes - 1;
                   } /*** while j < rlc->numnodes ***/
                LatLonBase = LatLonBase + LatLonIncrement;
                }  /*** end while LatLonBase in miny, maxy range **/
             } /*** end LRNGE_UNM_LON check applies ***/





          if((CombinedCheckApplies(rlc->idn,checkinstance,LE_A_UNM_LON,rlc->Lindex,rlc->Sindex,Config1,Strat1,Domain1,&part1,&part2,&part3) > 0) &&
                   (part1 > 0))
             {
             FoundCondition = 0;
             i = Ctype();
             if(i == 1) /** geodetic **/
                {
                LocalMinX = minx / 100000.0 + Xtranslation;
                LocalMaxX = maxx / 100000.0 + Xtranslation;

                LatLonBase = 0.0;
                LowerTolerance = FindRelevantSensitivity(LE_A_UNM_LON,checkinstance,&LatLonIncrement);
                if(FindSpecificSensitivity(3,LE_A_UNM_LON,checkinstance,&UpperTolerance) < 1)
                   LatLonIncrement = 1.0;

                k = (int) ((LocalMinX - LatLonBase) / LatLonIncrement);

                LatLonBase += (double) k * LatLonIncrement;
                if(LatLonBase < LocalMinX) /** could be that we have exact multiple - if not need to add one increment ***/
                   LatLonBase += LatLonIncrement;

                if(LatLonBase <= LocalMaxX)
                   {
                   LatLonIncrement *= 100000.0;
                   LatLonBase = (LatLonBase - Xtranslation) * 100000.0;
                   LocalMinX = LatLonBase - UpperTolerance;
                   LocalMaxX = LatLonBase + UpperTolerance;
                   }
                else
                   {
                   LatLonBase = maxx * 2.0; /** effectively says check will not be applied ***/
                   }
                }
             else if(i == 2)
                {
                LatLonBase = maxx * 2.0; /** effectively says check will not be applied ***/
                }

             if(rlc->length <= UpperTolerance)
                {
                bothends = 0;
                tempdbl = fabs(rlc->x[0] - LatLonBase);
                unuseddbl = fabs(rlc->x[rlc->numnodes -1] - LatLonBase);
                if(tempdbl < unuseddbl)
                   j = 0;
                else
                   j = rlc->numnodes - 1;
                }
             else
                {
                bothends = 1;
                j = 0;
                }
             while((LatLonBase > MinXcoord) && (LatLonBase < MaxXcoord) && (LatLonBase >= minx) && (LatLonBase <= maxx))
                {
                while(j < rlc->numnodes)
                   {
                   fndpr = 0;
                   FoundCondition = 0;
                   checkit = 1;
                   if(EastCount <= 0)
                      checkit = ConditionOnDataEdge(rlc->x[j],rlc->y[j],rlc->x[j],rlc->y[j],Aroot,Proot,Lroot,
                                               NULL, NULL, rlc, 100, 100,EastCount,100,checkinstance);
                   if((checkit > 0) && (WestCount <= 0))
                      checkit = ConditionOnDataEdge(rlc->x[j],rlc->y[j],rlc->x[j],rlc->y[j],Aroot,Proot,Lroot,
                                               NULL, NULL, rlc, 100, 100, 100,WestCount,checkinstance);
                   if(checkit > 0)
                      {
                      checkit = 0;
                      if((rlc->x[j] >= LocalMinX) && (rlc->x[j] <= LocalMaxX) && (rlc->y[j] >= miny) && (rlc->y[j] <= maxy))
                         {
                         tempdist = Distance(rlc->x[j],rlc->y[j],LatLonBase,rlc->y[j]);
                         if(tempdist <= ActiveChecks[checkinstance].sensitivity3)
                            checkit = 1;
                         }
                      }
                   if(checkit > 0)
                      {
                      minyPadded = rlc->y[j] - LowerTolerance;
                      minxPadded = rlc->x[j] - LowerTolerance;

                      maxxPadded = rlc->x[j] + LowerTolerance;
                      maxyPadded = rlc->y[j] + LowerTolerance;

                      minyLimit = rlc->y[j] - UpperTolerance;
                      minxLimit = rlc->x[j] - UpperTolerance;

                      maxxLimit = rlc->x[j] + UpperTolerance;
                      maxyLimit = rlc->y[j] + UpperTolerance;

                      direction = 0;
                      dir1 = dir2 = 0;

                      for(i = 0; i< rlc->numnodes; i++)
                         {
                         if(rlc->x[i] > LatLonBase)
                            ++dir1;
                         else if(rlc->x[i] < LatLonBase)
                            ++dir2;
                         }
                      if(dir1 == dir2)
                         {
                         tempdbl = rlc->x[0] + ((rlc->x[1] - rlc->x[0]) / 2);
                         if(tempdbl > LatLonBase)
                            ++dir1;
                         else
                            ++dir2;
                         }
                      if(dir1 > dir2)
                         ++direction;
                      else
                         --direction;

                      rac = Aroot;
                      fndpr = 0;
                      while(rac != NULL)
                         {
                         if((CombinedCheckApplies(rac->idn,checkinstance,LE_A_UNM_LON,rac->Lindex,rac->Sindex,
                                 SCCtable[rac->Sindex].C,SCCtable[rac->Sindex].S,SCCtable[rac->Sindex].D,&part1,&part2,&part3) > 0) &&
                                  (part2 > 0))
                            {
                            DirHasBeenSet = 0;
                            for(i=0; i<rac->numverts; i++)
                               {
                               if((rac->x[i] >= minxLimit) && (rac->x[i] <= maxxLimit) &&
                                    (rac->y[i] >= minyLimit) && (rac->y[i] <= maxyLimit))
                                  {
                                  if(DirHasBeenSet == 0)
                                     {
                                     DirHasBeenSet = 1;
                                     direction2 = 0;
                                     dir1 = dir2 = 0;
                                     for(k = 0; k< rac->numverts; k++)
                                        {
                                        if(rac->x[k] > LatLonBase)
                                           ++dir1;
                                        else if(rac->x[k] < LatLonBase)
                                           ++dir2;
                                        }
                                     if(dir1 == dir2)
                                        {
                                        tempdbl = rac->x[0] + ((rac->x[1] - rac->x[0]) / 2);
                                        if(tempdbl > LatLonBase)
                                           ++dir1;
                                        else
                                           ++dir2;
                                        }
                                     if(dir1 > dir2)
                                        ++direction2;
                                     else
                                        --direction2;
                                     }
                                  k = direction * direction2;
                                  if(k <= 0)
                                     {
                                     if((part2 > 0) && (rac->x[i] >= minxPadded) && (rac->x[i] <= maxxPadded) &&
                                            (rac->y[i] >= minyPadded) && (rac->y[i] <= maxyPadded))
                                        {
                                        fndpr = 1;
                                        break;
                                        }
                                     }

                                  else // it may have joined an area on same side of LatLonBase - does that area get closer to LatLonBase ?? 
                                     {
                                     if((rac->x[i] >= minxPadded) && (rac->x[i] <= maxxPadded) &&
                                            (rac->y[i] >= minyPadded) && (rac->y[i] <= maxyPadded))
                                        {
                                        if(i == 0)
                                           {
                                           tempdbl = fabs(rac->x[1] - LatLonBase);
                                           unuseddbl = fabs(rlc->x[j] - LatLonBase);
                                           if(unuseddbl > tempdbl) // rlc is further from LatLonBase 
                                              {
                                              fndpr = 1;
                                              break;
                                              }
                                           }
                                        else if(i == (rac->numverts - 1))
                                           {
                                           tempdbl = fabs(rac->x[rac->numverts - 2] - LatLonBase);
                                           unuseddbl = fabs(rlc->x[j] - LatLonBase);
                                           if(unuseddbl > tempdbl) // rlc is further from LatLonBase 
                                              {
                                              fndpr = 1;
                                              break;
                                              }
                                           }
                                        else
                                           {
                                           tempdbl = fabs(rac->x[i - 1] - LatLonBase);
                                           unuseddbl = fabs(rac->x[i + 1] - LatLonBase);
                                           if(unuseddbl < tempdbl)
                                              tempdbl = unuseddbl;
                                           unuseddbl = fabs(rlc->x[j] - LatLonBase);
                                           if(unuseddbl > tempdbl) // rlc is further from LatLonBase 
                                              {
                                              fndpr = 1;
                                              break;
                                              }
                                           }
                                        }
                                     }
                                   }
                               } /*** end for i ... ***/
                            } /*** check applies to rac ***/


                         if(fndpr > 0)
                            break;
                         rac = rac->next;
                         }

                      if(fndpr == 0)
                         {
                         tempdbl = Distance(rlc->x[j],rlc->y[j], LatLonBase, rlc->y[j]);
                         if(tempdbl <= UpperTolerance)
                            FoundCondition = 1;
                         else
                            FoundCondition = 0;
                         }
                      else
                         {
                         FoundCondition = 0;
                         }

                      } /** end if endpoint[j] is in the load module  ***/
                   if(FoundCondition > 0) /** need to add a condition to the list ***/
                      {
                      FoundCondition = 0;
                      if(tempdist <= ActiveChecks[checkinstance].sensitivity2)
                         {
                         ERc = (struct collection *) (malloc(SzC));
                         if(ERc == NULL)
                           {
                           printf("allocation memory exhausted during linear feature condition analysis (boundary match analysis)\n");
                           printf("processing cannot continue\n");
                           exit(-1);
                           }
                         ERc->x[0] = rlc->x[j];
                         ERc->y[0] = rlc->y[j];
                         ERc->z[0] = rlc->z[j];
                         if(j == 0)
                            {
                            ERc->x[1] = rlc->x[1];
                            ERc->y[1] = rlc->y[1];
                            ERc->z[1] = rlc->z[1];
                            }
                         else
                            {
                            ERc->x[1] = rlc->x[j-1];
                            ERc->y[1] = rlc->y[j-1];
                            ERc->z[1] = rlc->z[j-1];
                            }
                         ERc->IDN = rlc->idn;
                         ERc->Sindex = rlc->Sindex;
                         ERc->aa = NULL; /** RawAreal **/
                         ERc->bb = NULL; /** RawBridge **/
                         ERc->pp = NULL; /** RawPoint **/
                         ERc->le = NULL; /** ListOfEdges **/
                         ERc->poly = NULL; /** ThePolys **/
                         ERc->ll1 = rlc;
                         ERc->ll2 = NULL;
                         ERc->keyval = LE_A_UNM_LON;
                         ERc->Cnumber = Make_Correct(LE_A_UNM_LON,checkinstance);
                         ERc->magnitude = 0;

                         if(ERroot == NULL)
                            {
                            ERroot = ERc;
                            ERroot->next = NULL;
                            }
                         else
                            {
                            ERn = ERroot;
                            while(ERn != NULL)
                               {
                               if((ERn->keyval == ERc->keyval) && (ERc->Cnumber == ERn->Cnumber))
                                  {
                                  if(ERn->ll1 == ERc->ll1)
                                     {
                                     if((ERc->x[0] == ERn->x[0]) && (ERc->y[0] == ERn->y[0]) && (ERc->z[0] == ERn->z[0]))
                                        {
                                        break;
                                        }
                                  /****else if((ERc->x[0] == ERn->x[1]) && (ERc->y[0] == ERn->y[1]) && (ERc->z[0] == ERn->z[1]))
                                     {
                                     break;
                                     }*****/
                                  }
                               }
                               ERn = ERn->next;
                               }
                            if(ERn == NULL)
                               {
                               ERc->next = ERroot;
                               ERroot = ERc;
                               }
                            else
                               {
                               free(ERc);
                               }
                            }
                         } /** end double check magnitude ***/
                      } /*** end FoundCondition ***/
                   if((fndpr > 0) || (bothends < 1))
                      break;
                   j += rlc->numnodes - 1;
                   } /*** while j < rlc->numnodes ***/
                LatLonBase = LatLonBase + LatLonIncrement;
                }  /*** end while LatLonBase in miny, maxy range **/
             } /*** end LE_A_UNM_LON check applies ***/




          if((CombinedCheckApplies(rlc->idn,checkinstance,LE_A_UNM_LAT,rlc->Lindex,rlc->Sindex,Config1,Strat1,Domain1,&part1,&part2,&part3) > 0) &&
                   (part1 > 0))
             {
             FoundCondition = 0;
             i = Ctype();
             if(i == 1) /** geodetic **/
                {
                LocalMinY = miny / 100000.0 + Ytranslation;
                LocalMaxY = maxy / 100000.0 + Ytranslation;

                LatLonBase = 0.0;
                LowerTolerance = FindRelevantSensitivity(LE_A_UNM_LAT,checkinstance,&LatLonIncrement);
                if(FindSpecificSensitivity(3,LE_A_UNM_LAT,checkinstance,&UpperTolerance) < 1)
                   LatLonIncrement = 1.0;

                k = (int) ((LocalMinY - LatLonBase) / LatLonIncrement);

                LatLonBase += (double) k * LatLonIncrement;
                if(LatLonBase < LocalMinY) /** could be that we have exact multiple - if not need to add one increment ***/
                   LatLonBase += LatLonIncrement;

                if(LatLonBase <= LocalMaxY)
                   {
                   LatLonIncrement *= 100000.0;
                   LatLonBase = (LatLonBase - Ytranslation) * 100000.0;
                   LocalMinY = LatLonBase - UpperTolerance;
                   LocalMaxY = LatLonBase + UpperTolerance;
                   }
                else
                   {
                   LatLonBase = maxy * 2.0; /** effectively says check will not be applied ***/
                   }
                }
             else if(i == 2)
                {
                LatLonBase = maxy * 2.0; /** effectively says check will not be applied ***/
                }

             if(rlc->length <= UpperTolerance)
                {
                bothends = 0;
                tempdbl = fabs(rlc->y[0] - LatLonBase);
                unuseddbl = fabs(rlc->y[rlc->numnodes -1] - LatLonBase);
                if(tempdbl < unuseddbl)
                   j = 0;
                else
                   j = rlc->numnodes - 1;
                }
             else
                {
                bothends = 1;
                j = 0;
                }
             while((LatLonBase > MinYcoord) && (LatLonBase < MaxYcoord) && (LatLonBase >= miny) && (LatLonBase <= maxy))
                {
                while(j < rlc->numnodes)
                   {
                   fndpr = 0;
                   FoundCondition = 0;
                   checkit = 1;
                   if(NorthCount <= 0)
                      checkit = ConditionOnDataEdge(rlc->x[j],rlc->y[j],rlc->x[j],rlc->y[j],Aroot,Proot,Lroot,
                                               NULL, NULL, rlc, NorthCount, 100, 100,100,checkinstance);
                   if((checkit > 0) && (SouthCount <= 0))
                      checkit = ConditionOnDataEdge(rlc->x[j],rlc->y[j],rlc->x[j],rlc->y[j],Aroot,Proot,Lroot,
                                               NULL, NULL, rlc, 100, SouthCount, 100, 100,checkinstance);
                   if(checkit > 0)
                      {
                      checkit = 0;
                      if((rlc->x[j] >= minx) && (rlc->x[j] <= maxx) && (rlc->y[j] >= LocalMinY) && (rlc->y[j] <= LocalMaxY))
                         {
                         tempdist = Distance(rlc->x[j],rlc->y[j],rlc->x[j],LatLonBase);
                         if(tempdist <= ActiveChecks[checkinstance].sensitivity3)
                            checkit = 1;
                         }
                      }
                   if(checkit > 0)
                      {
                      minyPadded = rlc->y[j] - LowerTolerance;
                      minxPadded = rlc->x[j] - LowerTolerance;

                      maxxPadded = rlc->x[j] + LowerTolerance;
                      maxyPadded = rlc->y[j] + LowerTolerance;

                      minyLimit = rlc->y[j] - UpperTolerance;
                      minxLimit = rlc->x[j] - UpperTolerance;

                      maxxLimit = rlc->x[j] + UpperTolerance;
                      maxyLimit = rlc->y[j] + UpperTolerance;

                      direction = 0;
                      dir1 = dir2 = 0;

                      for(i = 0; i< rlc->numnodes; i++)
                         {
                         if(rlc->y[i] > LatLonBase)
                            ++dir1;
                         else if(rlc->y[i] < LatLonBase)
                            ++dir2;
                         }
                      if(dir1 == dir2)
                         {
                         tempdbl = rlc->y[0] + ((rlc->y[1] - rlc->y[0]) / 2);
                         if(tempdbl > LatLonBase)
                            ++dir1;
                         else
                            ++dir2;
                         }
                      if(dir1 > dir2)
                         ++direction;
                      else
                         --direction;

                      rac = Aroot;
                      fndpr = 0;
                      while(rac != NULL)
                         {
                         if((CombinedCheckApplies(rac->idn,checkinstance,LE_A_UNM_LAT,rac->Lindex,rac->Sindex,
                                 SCCtable[rac->Sindex].C,SCCtable[rac->Sindex].S,SCCtable[rac->Sindex].D,&part1,&part2,&part3) > 0) &&
                                  (part2 > 0))
                            {
                            DirHasBeenSet = 0;
                            for(i=0; i<rac->numverts; i++)
                               {
                               if((rac->x[i] >= minxLimit) && (rac->x[i] <= maxxLimit) &&
                                    (rac->y[i] >= minyLimit) && (rac->y[i] <= maxyLimit))
                                  {
                                  if(DirHasBeenSet == 0)
                                     {
                                     DirHasBeenSet = 1;
                                     direction2 = 0;
                                     dir1 = dir2 = 0;
                                     for(k = 0; k< rac->numverts; k++)
                                        {
                                        if(rac->y[k] > LatLonBase)
                                           ++dir1;
                                        else if(rac->y[k] < LatLonBase)
                                           ++dir2;
                                        }
                                     if(dir1 == dir2)
                                        {
                                        tempdbl = rac->y[0] + ((rac->y[1] - rac->y[0]) / 2);
                                        if(tempdbl > LatLonBase)
                                           ++dir1;
                                        else
                                           ++dir2;
                                        }
                                     if(dir1 > dir2)
                                        ++direction2;
                                     else
                                        --direction2;
                                     }
                                  k = direction * direction2;
                                  if(k <= 0)
                                     {
                                     if((part2 > 0) && (rac->x[i] >= minxPadded) && (rac->x[i] <= maxxPadded) &&
                                            (rac->y[i] >= minyPadded) && (rac->y[i] <= maxyPadded))
                                        {
                                        fndpr = 1;
printf("found a match with area %d\n",rac->featureid);
                                        break;
                                        }
                                     }

                                  else // it may have joined an area on same side of LatLonBase - does that area get closer to LatLonBase ??
                                     {
                                     if((rac->x[i] >= minxPadded) && (rac->x[i] <= maxxPadded) &&
                                            (rac->y[i] >= minyPadded) && (rac->y[i] <= maxyPadded))
                                        {
                                        if(i == 0)
                                           {
                                           tempdbl = fabs(rac->y[1] - LatLonBase);
                                           unuseddbl = fabs(rlc->y[j] - LatLonBase);
                                           if(unuseddbl > tempdbl) // rlc is further from LatLonBase
                                              {
                                              fndpr = 1;
                                              break;
                                              }
                                           }
                                        else if(i == (rac->numverts - 1))
                                           {
                                           tempdbl = fabs(rac->y[rac->numverts - 2] - LatLonBase);
                                           unuseddbl = fabs(rlc->y[j] - LatLonBase);
                                           if(unuseddbl > tempdbl) // rlc is further from LatLonBase
                                              {
                                              fndpr = 1;
                                              break;
                                              }
                                           }
                                        else
                                           {
                                           tempdbl = fabs(rac->y[i - 1] - LatLonBase);
                                           unuseddbl = fabs(rac->y[i + 1] - LatLonBase);
                                           if(unuseddbl < tempdbl)
                                              tempdbl = unuseddbl;
                                           unuseddbl = fabs(rlc->y[j] - LatLonBase);
                                           if(unuseddbl > tempdbl) // rlc is further from LatLonBase
                                              {
                                              fndpr = 1;
                                              break;
                                              }
                                           }
                                        }
                                     }
                                   }
                               } /*** end for i ... ***/
                            } /*** check applies to rac ***/


                         if(fndpr > 0)
                            break;
                         rac = rac->next;
                         }

                      if(fndpr == 0)
                         {
                         tempdbl = Distance(rlc->x[j],rlc->y[j], rlc->x[j], LatLonBase);
                         if(tempdbl <= UpperTolerance)
                            FoundCondition = 1;
                         else
                            FoundCondition = 0;
                         }
                      else
                         {
                         FoundCondition = 0;
                         }

                      } /** end if endpoint[j] is in the load module  ***/
                   if(FoundCondition > 0) /** need to add a condition to the list ***/
                      {
                      FoundCondition = 0;
                      if(tempdist <= ActiveChecks[checkinstance].sensitivity2)
                         {
                         ERc = (struct collection *) (malloc(SzC));
                         if(ERc == NULL)
                           {
                           printf("allocation memory exhausted during linear feature condition analysis (boundary match analysis)\n");
                           printf("processing cannot continue\n");
                           exit(-1);
                           }
                         ERc->x[0] = rlc->x[j];
                         ERc->y[0] = rlc->y[j];
                         ERc->z[0] = rlc->z[j];
                         if(j == 0)
                            {
                            ERc->x[1] = rlc->x[1];
                            ERc->y[1] = rlc->y[1];
                            ERc->z[1] = rlc->z[1];
                            }
                         else
                            {
                            ERc->x[1] = rlc->x[j-1];
                            ERc->y[1] = rlc->y[j-1];
                            ERc->z[1] = rlc->z[j-1];
                            }
                         ERc->IDN = rlc->idn;
                         ERc->Sindex = rlc->Sindex;
                         ERc->aa = NULL; /** RawAreal **/
                         ERc->bb = NULL; /** RawBridge **/
                         ERc->pp = NULL; /** RawPoint **/
                         ERc->le = NULL; /** ListOfEdges **/
                         ERc->poly = NULL; /** ThePolys **/
                         ERc->ll1 = rlc;
                         ERc->ll2 = NULL;
                         ERc->keyval = LE_A_UNM_LAT;
                         ERc->Cnumber = Make_Correct(LE_A_UNM_LAT,checkinstance);
                         ERc->magnitude = 0;

                         if(ERroot == NULL)
                            {
                            ERroot = ERc;
                            ERroot->next = NULL;
                            }
                         else
                            {
                            ERn = ERroot;
                            while(ERn != NULL)
                               {
                               if((ERn->keyval == ERc->keyval) && (ERc->Cnumber == ERn->Cnumber))
                                  {
                                  if(ERn->ll1 == ERc->ll1)
                                     {
                                     if((ERc->x[0] == ERn->x[0]) && (ERc->y[0] == ERn->y[0]) && (ERc->z[0] == ERn->z[0]))
                                        {
                                        break;
                                        }
                                     }
                                  }
                               ERn = ERn->next;
                               }
                            if(ERn == NULL)
                               {
                               ERc->next = ERroot;
                               ERroot = ERc;
                               }
                            else
                               {
                               free(ERc);
                               }
                            }
                         } /** end double check magnitude ***/
                      } /*** end FoundCondition ***/
                   if((fndpr > 0) || (bothends < 1))
                      break;
                   j += rlc->numnodes - 1;
                   } /*** while j < rlc->numnodes ***/
                LatLonBase = LatLonBase + LatLonIncrement;
                }  /*** end while LatLonBase in miny, maxy range **/
             } /*** end LE_A_UNM_LAT check applies ***/






          if((CombinedCheckApplies(rlc->idn,checkinstance,LHANG_LAT,rlc->Lindex,rlc->Sindex,Config1,Strat1,Domain1,&part1,&part2,&part3) > 0) &&
                   (part1 > 0))
             {
             candidate = 0;

             i = Ctype();
             if(i == 1) /** geodetic **/
                {
                LocalMinY = miny / 100000.0 + Ytranslation;
                LocalMaxY = maxy / 100000.0 + Ytranslation;

                LatLonBase = 0.0;
                LowerTolerance = FindRelevantSensitivity(LHANG_LAT,checkinstance,&UpperTolerance);
                if(FindSpecificSensitivity(3,LHANG_LAT,checkinstance,&LatLonIncrement) < 1)
                   LatLonIncrement = 1.0;
                if(FindSpecificSensitivity(4,LHANG_LAT,checkinstance,&tolerance4) < 1)
                   tolerance4 = 10.0;


                k = (int) ((LocalMinY - LatLonBase) / LatLonIncrement);

                LatLonBase += (double) k * LatLonIncrement;

                if(LatLonBase < (LocalMinY - 0.01))
                   LatLonBase += LatLonIncrement;

                if(LatLonBase <= (LocalMaxY + 0.01))
                   {
                   LatLonIncrement *= 100000.0;
                   LatLonBase = (LatLonBase - Ytranslation) * 100000.0;
                   LocalMinY = LatLonBase - tolerance4; //UpperTolerance;
                   LocalMaxY = LatLonBase + tolerance4; //UpperTolerance;
                   }
                else
                   {
                   LatLonBase = maxy * 2.0; /** effectively says check will not be applied ***/
                   }
                }
             else if(i == 2)
                {
                LatLonBase = maxy * 2.0; /** effectively says check will not be applied ***/
                }
             if(rlc->length <= UpperTolerance)
                {
                bothends = 0;
                tempdbl = fabs(rlc->y[0] - LatLonBase);
                unuseddbl = fabs(rlc->y[rlc->numnodes -1] - LatLonBase);
                if(tempdbl < unuseddbl)
                   j = 0;
                else
                   j = rlc->numnodes - 1;
                }
             else
                {
                bothends = 1;
                j = 0;
                }

             while((LatLonBase >= MinYcoord) && (LatLonBase <= MaxYcoord) &&
                        (LatLonBase >= (miny - tolerance4)) && (LatLonBase <= (maxy + tolerance4)))
                {
                while((j < rlc->numnodes) && (candidate == 0))
                   {
                   checkit = 1;
                   if(NorthCount <= 0)
                      checkit = ConditionOnDataEdge(rlc->x[j],rlc->y[j],rlc->x[j],rlc->y[j],Aroot,Proot,Lroot,
                                               NULL, NULL, rlc, NorthCount, 100,100,100,checkinstance);
                   if((checkit > 0) && (SouthCount <= 0))
                      checkit = ConditionOnDataEdge(rlc->x[j],rlc->y[j],rlc->x[j],rlc->y[j],Aroot,Proot,Lroot,
                                               NULL, NULL, rlc, 100, SouthCount, 100,100,checkinstance);
                   fndpr = 0;
                   if((checkit > 0) && (rlc->y[j] > (MinYcoord + tolerance4)) && (rlc->y[j] < (MaxYcoord - tolerance4)))
                      {
                      FoundCondition = 0;
                      if((rlc->x[j] >= minx) && (rlc->x[j] <= maxx) && (rlc->y[j] >= LocalMinY) && (rlc->y[j] <= LocalMaxY))
                         {
                         minyPadded = rlc->y[j] - LowerTolerance;
                         minxPadded = rlc->x[j] - LowerTolerance;

                         maxxPadded = rlc->x[j] + LowerTolerance;
                         maxyPadded = rlc->y[j] + LowerTolerance;

                         minyLimit = rlc->y[j] - UpperTolerance;
                         minxLimit = rlc->x[j] - UpperTolerance;

                         maxxLimit = rlc->x[j] + UpperTolerance;
                         maxyLimit = rlc->y[j] + UpperTolerance;

                         direction = 0;
                         dir1 = dir2 = 0;
                         for(i = 1; i< (rlc->numnodes-1); i++)
                            {
                            if(rlc->y[i] > LatLonBase)
                               ++dir1;
                            else  if(rlc->y[i] < LatLonBase)
                               ++dir2;
                            }
                         if(dir1 == dir2)
                            {
                            tempdbl = rlc->y[0] + ((rlc->y[1] - rlc->y[0]) / 2);
                            if(tempdbl > LatLonBase)
                               ++dir1;
                            else
                               ++dir2;
                            }
                         if(dir1 > dir2)
                            ++direction;
                         else
                            --direction;

                         rln = Lroot;
                         rln3 = NULL;
                         fndpr = 0;
                         timesthruloop = 0;
                         while((rln != NULL) && (fndpr == 0) && (candidate == 0))
                            {
                            if(rln != rlc) /*** try to match the rlc end node up with a node of ANY other type line ***/
                               {
                               if((CombinedCheckApplies(rln->idn,checkinstance,LHANG_LAT,rln->Lindex,rln->Sindex,
                                    SCCtable[rln->Sindex].C,SCCtable[rln->Sindex].S,SCCtable[rln->Sindex].D,&part1,&part2,&part3) > 0) &&
                                     ((part2 > 0) || (part3 > 0)))
                                  {
                                  DirHasBeenSet = 0;
                                  for(i=0; i<rln->numnodes; i++)
                                     {
                                     if((rln->x[i] >= minxLimit) && (rln->x[i] <= maxxLimit) &&
                                          (rln->y[i] >= minyLimit) && (rln->y[i] <= maxyLimit))
                                        {
                                        if(DirHasBeenSet == 0)
                                           {
                                           DirHasBeenSet = 1;
                                           direction2 = 0;
                                           dir1 = dir2 = 0;
                                           for(k = 1; k< (rln->numnodes-1); k++)
                                              {
                                              if(rln->y[k] > LatLonBase)
                                                 ++dir1;
                                              else  if(rln->y[k] < LatLonBase)
                                                 ++dir2;
                                              }
                                           if(dir1 == dir2)
                                              {
                                              tempdbl = rln->y[0] + ((rln->y[1] - rln->y[0]) / 2);
                                              if(tempdbl > LatLonBase)
                                                 ++dir1;
                                              else
                                                 ++dir2;
                                              }
                                           if(dir1 > dir2)
                                              ++direction2;
                                           else
                                              --direction2;
                                           }

                                        k = direction * direction2;
                                        if(k <= 0)
                                           {
                                           if(part3 > 0)
                                              {
                                              candidate = 1;
                                              break;
                                              }
                                           if((part2 > 0) && (rln->x[i] >= minxPadded) && (rln->x[i] <= maxxPadded) &&
                                                  (rln->y[i] >= minyPadded) && (rln->y[i] <= maxyPadded))
                                              {
                                              fndpr = 1;
                                              break;
                                              }
                                           }
                                        else /** it may have joined a line on same side of LatLonBase - does that line get closer to LatLonBase ?? **/
                                           {
                                           if((rln->x[i] >= minxPadded) && (rln->x[i] <= maxxPadded) &&
                                                  (rln->y[i] >= minyPadded) && (rln->y[i] <= maxyPadded))
                                              {
                                              if(i == 0)
                                                 {
                                                 tempdbl = fabs(rln->y[1] - LatLonBase);
                                                 unuseddbl = fabs(rlc->y[j] - LatLonBase);
                                                 if(unuseddbl > tempdbl) /** rlc is further from LatLonBase ***/
                                                    {
                                                    fndpr = 1;
                                                    break;
                                                    }
                                                 }
                                              else if(i == (rln->numnodes - 1))
                                                 {
                                                 tempdbl = fabs(rln->y[rln->numnodes - 2] - LatLonBase);
                                                 unuseddbl = fabs(rlc->y[j] - LatLonBase);
                                                 if(unuseddbl > tempdbl) /** rlc is further from LatLonBase ***/
                                                    {
                                                    fndpr = 1;
                                                    break;
                                                    }
                                                 }
                                              else
                                                 {
                                                 tempdbl = fabs(rln->y[i - 1] - LatLonBase);
                                                 unuseddbl = fabs(rln->y[i + 1] - LatLonBase);
                                                 if(unuseddbl < tempdbl)
                                                    tempdbl = unuseddbl;
                                                 unuseddbl = fabs(rlc->y[j] - LatLonBase);
                                                 if(unuseddbl > tempdbl) /** rlc is further from LatLonBase ***/
                                                    {
                                                    fndpr = 1;
                                                    break;
                                                    }
                                                 }
                                              }
                                           }
                                        }
                                     } /** end for i ... ***/
                                  } /*** end have same FCODE ***/
                               else if((CombinedCheckApplies(rln->idn,checkinstance,LHANG_LAT,rln->Lindex,rln->Sindex,
                                    SCCtable[rln->Sindex].C,SCCtable[rln->Sindex].S,SCCtable[rln->Sindex].D,&part1,&part2,&part3) > 0) &&
                                     (part3 > 0))
                                  {
                                  for(i=0; i<rln->numnodes; i++)
                                     {
                                     if((rln->x[i] >= minxLimit) && (rln->x[i] <= maxxLimit) &&
                                          (rln->y[i] >= minyLimit) && (rln->y[i] <= maxyLimit))
                                        {
                                        direction2 = 0;
                                        dir1 = dir2 = 0;
                                        for(k = 1; k< (rln->numnodes-1); k++)
                                           {
                                           if(rln->y[k] > LatLonBase)
                                              ++dir1;
                                           else if(rln->y[k] < LatLonBase)
                                              ++dir2;
                                           }
                                        if(dir1 == dir2)
                                           {
                                           tempdbl = rln->y[0] + ((rln->y[1] - rln->y[0]) / 2);
                                           if(tempdbl > LatLonBase)
                                              ++dir1;
                                           else
                                              ++dir2;
                                           }
                                        if(dir1 > dir2)
                                           ++direction2;
                                        else
                                           --direction2;
   
                                        k = direction * direction2;
                                        if(k <= 0)
                                           {
                                           candidate = 1;
                                           break;
                                           }
                                        }
                                     } /** end for i ... ***/
                                  }
                               }
                            if((fndpr > 0) || (candidate > 0))
                               break;
                            rln = rln->next;
                            if((rln == NULL) && (timesthruloop == 0))
                               {
                               timesthruloop = 1;
                               rln = NLroot;
                               }
                            }
   
                         if((fndpr == 0) && (candidate == 0))
                            {
                            tempdbl = Distance(rlc->x[j],rlc->y[j], rlc->x[j], LatLonBase);
                            if(tempdbl <= UpperTolerance)
                               FoundCondition = 1;
                            else
                               FoundCondition = 0;
                            }
                         else
                            {
                            FoundCondition = 0;
                            }
   
                         } /** end if endpoint[j] is in the load module  ***/
                      if(FoundCondition > 0) /** need to add a condition to the list ***/
                         {
                         FoundCondition = 0;
                         ERc = (struct collection *) (malloc(SzC));
                         if(ERc == NULL)
                           {
                           printf("allocation memory exhausted during linear feature condition analysis (boundary match analysis)\n");
                           printf("processing cannot continue\n");
                           exit(-1);
                           }
                         ERc->x[0] = rlc->x[j];
                         ERc->y[0] = rlc->y[j];
                         ERc->z[0] = rlc->z[j];
                         if(j == 0)
                            {
                            ERc->x[1] = rlc->x[1];
                            ERc->y[1] = rlc->y[1];
                            ERc->z[1] = rlc->z[1];
                            }
                         else
                            {
                            ERc->x[1] = rlc->x[j-1];
                            ERc->y[1] = rlc->y[j-1];
                            ERc->z[1] = rlc->z[j-1];
                            }
                         ERc->IDN = rlc->idn;
                         ERc->Sindex = rlc->Sindex;
                         ERc->aa = NULL; /** RawAreal **/
                         ERc->bb = NULL; /** RawBridge **/
                         ERc->pp = NULL; /** RawPoint **/
                         ERc->le = NULL; /** ListOfEdges **/
                         ERc->poly = NULL; /** ThePolys **/
                         ERc->ll1 = rlc;
                         ERc->ll2 = NULL;
                         ERc->keyval = LHANG_LAT;
                         ERc->Cnumber = Make_Correct(LHANG_LAT,checkinstance);

                         if(ERroot == NULL)
                            {
                            ERroot = ERc;
                            ERroot->next = NULL;
                            }
                         else
                            {
                            ERn = ERroot;
                            while(ERn != NULL)
                               {
                               if((ERn->keyval == ERc->keyval) && (ERc->Cnumber == ERn->Cnumber))
                                  {
                                  if(ERn->ll1 == ERc->ll1)
                                     {
                                     if((ERc->x[0] == ERn->x[0]) && (ERc->y[0] == ERn->y[0]) && (ERc->z[0] == ERn->z[0]))
                                        {
                                        break;
                                        }
                                     }
                                  }
                               ERn = ERn->next;
                               }
                            if(ERn == NULL)
                               {
                               ERc->next = ERroot;
                               ERroot = ERc;
                               }
                            else
                               {
                               free(ERc);
                               }
                            }
                         } /*** end FoundCondition ***/
                      }
                   j += rlc->numnodes - 1;
                   if((fndpr > 0) || (bothends < 1))
                      break;
                   } /*** while j < rlc->numnodes and candidate not found ***/
                LatLonBase = LatLonBase + LatLonIncrement;
                }  /*** end while LatLonBase in miny, maxy range **/
             } /*** end LHANG_LAT check applies ***/





          if((CombinedCheckApplies(rlc->idn,checkinstance,LHANG_LON,rlc->Lindex,rlc->Sindex,Config1,Strat1,Domain1,&part1,&part2,&part3) > 0) &&
                   (part1 > 0))
             {
             candidate = 0;
             i = Ctype();
             if(i == 1) /** geodetic **/
                {
                LocalMinX = minx / 100000.0 + Xtranslation;
                LocalMaxX = maxx / 100000.0 + Xtranslation;

                LatLonBase = 0.0;
                LowerTolerance = FindRelevantSensitivity(LHANG_LON,checkinstance,&UpperTolerance);
                if(FindSpecificSensitivity(3,LHANG_LON,checkinstance,&LatLonIncrement) < 1)
                   LatLonIncrement = 1.0;
                if(FindSpecificSensitivity(4,LHANG_LON,checkinstance,&tolerance4) < 1)
                   tolerance4 = 10.0;

                k = (int) ((LocalMinX - LatLonBase) / LatLonIncrement);

                LatLonBase += (double) k * LatLonIncrement;
                if(LatLonBase < (LocalMinX - 0.01)) /** could be that we have exact multiple - if not need to add one increment ***/
                   LatLonBase += LatLonIncrement;

                if(LatLonBase <= (LocalMaxX + 0.01))
                   {
                   LatLonIncrement *= 100000.0;
                   LatLonBase = (LatLonBase - Xtranslation) * 100000.0;
                   LocalMinX = LatLonBase - tolerance4; //UpperTolerance;
                   LocalMaxX = LatLonBase + tolerance4; //UpperTolerance;
                   }
                else
                   {
                   LatLonBase = maxx * 2.0; /** effectively says check will not be applied ***/
                   }
                }
             else if(i == 2)
                {
                LatLonBase = maxx * 2.0; /** effectively says check will not be applied ***/
                }

             if(rlc->length <= UpperTolerance)
                {
                bothends = 0;
                tempdbl = fabs(rlc->x[0] - LatLonBase);
                unuseddbl = fabs(rlc->x[rlc->numnodes -1] - LatLonBase);
                if(tempdbl < unuseddbl)
                   j = 0;
                else
                   j = rlc->numnodes - 1;
                }
             else
                {
                bothends = 1;
                j = 0;
                }
             
             while((LatLonBase >= MinXcoord) && (LatLonBase <= MaxXcoord) &&
                    (LatLonBase >= (minx - tolerance4)) && (LatLonBase <= (maxx + tolerance4)))
                {
                while((j < rlc->numnodes) && (candidate == 0))
                   {
                   checkit = 1;
                   if(EastCount <= 0)
                      checkit = ConditionOnDataEdge(rlc->x[j],rlc->y[j],rlc->x[j],rlc->y[j],Aroot,Proot,Lroot,
                                               NULL, NULL, rlc, 100, 100,EastCount,100,checkinstance);
                   if((checkit > 0) && (WestCount <= 0))
                      checkit = ConditionOnDataEdge(rlc->x[j],rlc->y[j],rlc->x[j],rlc->y[j],Aroot,Proot,Lroot,
                                               NULL, NULL, rlc, 100, 100, 100,WestCount,checkinstance);
                   if((checkit > 0) && (rlc->x[j] > (MinXcoord + tolerance4)) && (rlc->x[j] < (MaxXcoord - tolerance4)))
                      {
                      fndpr = 0;
                      FoundCondition = 0;
                      if((rlc->x[j] >= LocalMinX) && (rlc->x[j] <= LocalMaxX) && (rlc->y[j] >= miny) && (rlc->y[j] <= maxy))
                         {
                         minyPadded = rlc->y[j] - LowerTolerance;
                         minxPadded = rlc->x[j] - LowerTolerance;

                         maxxPadded = rlc->x[j] + LowerTolerance;
                         maxyPadded = rlc->y[j] + LowerTolerance;

                         minyLimit = rlc->y[j] - UpperTolerance;
                         minxLimit = rlc->x[j] - UpperTolerance;

                         maxxLimit = rlc->x[j] + UpperTolerance;
                         maxyLimit = rlc->y[j] + UpperTolerance;

                         direction = 0;
                         dir1 = dir2 = 0;
                         for(i = 1; i< (rlc->numnodes-1); i++)
                            {
                            if(rlc->x[i] > LatLonBase)
                               ++dir1;
                            else if(rlc->x[i] < LatLonBase)
                               ++dir2;
                            }
                         if(dir1 == dir2)
                            {
                            tempdbl = rlc->x[0] + ((rlc->x[1] - rlc->x[0]) / 2);
                            if(tempdbl > LatLonBase)
                               ++dir1;
                            else
                               ++dir2;
                            }
                         if(dir1 > dir2)
                            ++direction;
                         else
                            --direction;

                         rln = Lroot;
                         fndpr = 0;
                         timesthruloop = 0;
                         while((rln != NULL) && (fndpr == 0) && (candidate == 0))
                            {
                            if(rln != rlc) /*** try to match the rlc end node up with a node of ANY other type line ***/
                               {
                               if((CombinedCheckApplies(rln->idn,checkinstance,LHANG_LON,rln->Lindex,rln->Sindex,
                                    SCCtable[rln->Sindex].C,SCCtable[rln->Sindex].S,SCCtable[rln->Sindex].D,&part1,&part2,&part3) > 0) &&
                                     ((part2 > 0) || (part3 > 0)))
                                  {
                                  DirHasBeenSet = 0;
                                  for(i=0; i<rln->numnodes; i++)
                                     {
                                     if((rln->x[i] >= minxLimit) && (rln->x[i] <= maxxLimit) &&
                                       (rln->y[i] >= minyLimit) && (rln->y[i] <= maxyLimit))
                                        {
                                        if(DirHasBeenSet == 0)
                                           {
                                           DirHasBeenSet = 1;
                                           direction2 = 0;
                                           dir1 = dir2 = 0;
                                           for(k = 1; k< (rln->numnodes-1); k++)
                                              {
                                              if(rln->x[k] > LatLonBase)
                                                 ++dir1;
                                              else if(rln->x[k] < LatLonBase)
                                                 ++dir2;
                                              }
                                           if(dir1 == dir2)
                                              {
                                              tempdbl = rln->x[0] + ((rln->x[1] - rln->x[0]) / 2);
                                              if(tempdbl > LatLonBase)
                                                 ++dir1;
                                              else
                                                 ++dir2;
                                              }
                                           if(dir1 > dir2)
                                              ++direction2;
                                           else
                                              --direction2;
                                           }
                                        k = direction * direction2;
                                        if(k <= 0)
                                           {
                                           if(part3 > 0)
                                              {
                                              candidate = 1;
                                              break;
                                              }
                                           if((part2 > 0) && (rln->x[i] >= minxPadded) && (rln->x[i] <= maxxPadded) &&
                                                  (rln->y[i] >= minyPadded) && (rln->y[i] <= maxyPadded))
                                              {
                                              fndpr = 1;
                                              break;
                                              }
                                           }
                                        else /** it may have joined a line on same side of LatLonBase - does that line get closer to LatLonBase ?? **/
                                           {
                                           if((rln->x[i] >= minxPadded) && (rln->x[i] <= maxxPadded) &&
                                                  (rln->y[i] >= minyPadded) && (rln->y[i] <= maxyPadded))
                                              {
                                              if(i == 0)
                                                 {
                                                 tempdbl = fabs(rln->x[1] - LatLonBase);
                                                 unuseddbl = fabs(rlc->x[j] - LatLonBase);
                                                 if(unuseddbl > tempdbl) /** rlc is further from LatLonBase ***/
                                                    {
                                                    fndpr = 1;
                                                    break;
                                                    }
                                                 }
                                              else if(i == (rln->numnodes - 1))
                                                 {
                                                 tempdbl = fabs(rln->x[rln->numnodes - 2] - LatLonBase);
                                                 unuseddbl = fabs(rlc->x[j] - LatLonBase);
                                                 if(unuseddbl > tempdbl) /** rlc is further from LatLonBase ***/
                                                    {
                                                    fndpr = 1;
                                                    break;
                                                    }
                                                 }
                                              else
                                                 {
                                                 tempdbl = fabs(rln->x[i - 1] - LatLonBase);
                                                 unuseddbl = fabs(rln->x[i + 1] - LatLonBase);
                                                 if(unuseddbl < tempdbl)
                                                    tempdbl = unuseddbl;
                                                 unuseddbl = fabs(rlc->x[j] - LatLonBase);
                                                 if(unuseddbl > tempdbl) /** rlc is further from LatLonBase ***/
                                                    {
                                                    fndpr = 1;
                                                    break;
                                                    }
                                                 }
                                              }
                                           }

                                        }
                                     } /*** end for i ... ***/
                                  } /*** end have same FCODE ***/
                               else if((CombinedCheckApplies(rln->idn,checkinstance,LHANG_LON,rln->Lindex,rln->Sindex,
                                    SCCtable[rln->Sindex].C,SCCtable[rln->Sindex].S,SCCtable[rln->Sindex].D,&part1,&part2,&part3) > 0) &&
                                     (part3 > 0))
                                  {
                                  for(i=0; i<rln->numnodes; i++)
                                     {
                                     if((rln->x[i] >= minxLimit) && (rln->x[i] <= maxxLimit) &&
                                          (rln->y[i] >= minyLimit) && (rln->y[i] <= maxyLimit))
                                        {
                                        direction2 = 0;
                                        dir1 = dir2 = 0;
                                        for(k = 1; k< (rln->numnodes-1); k++)
                                           {
                                           if(rln->x[k] > LatLonBase)
                                              ++dir1;
                                           else if(rln->x[k] < LatLonBase)
                                              ++dir2;
                                           }
                                        if(dir1 == dir2)
                                           {
                                           tempdbl = rln->x[0] + ((rln->x[1] - rln->x[0]) / 2);
                                           if(tempdbl > LatLonBase)
                                              ++dir1;
                                           else
                                              ++dir2;
                                           }

                                        if(dir1 > dir2)
                                           ++direction2;
                                        else
                                           --direction2;
                                        k = direction * direction2;
/***fndpr = 1;
break;
***/
                                        if(k <= 0)
                                              {
                                           candidate = 1;
                                           break;
                                           }
/***/
                                        }
                                     } /*** end for i ... ***/
                                  }
                               }
                            if(fndpr > 0)
                               break;
                            rln = rln->next;
                            if((rln == NULL) && (timesthruloop == 0))
                               {
                               timesthruloop = 1;
                               rln = NLroot;
                               }
                            }
   
                         if((fndpr == 0) && (candidate == 0))
                            {
                            tempdbl = Distance(rlc->x[j],rlc->y[j], LatLonBase, rlc->y[j]);
                            if(tempdbl <= UpperTolerance)
                               FoundCondition = 1;
                            else
                               FoundCondition = 0;
                            }
                         else
                            {
                            FoundCondition = 0;
                            }

                         } /** end if endpoint[j] is in the load module  ***/
                      if(FoundCondition > 0) /** need to add a condition to the list ***/
                         {
                         FoundCondition = 0;
                         ERc = (struct collection *) (malloc(SzC));
                         if(ERc == NULL)
                           {
                           printf("allocation memory exhausted during linear feature condition analysis (boundary match analysis)\n");
                           printf("processing cannot continue\n");
                           exit(-1);
                           }
                         ERc->x[0] = rlc->x[j];
                         ERc->y[0] = rlc->y[j];
                         ERc->z[0] = rlc->z[j];
                         if(j == 0)
                            {
                            ERc->x[1] = rlc->x[1];
                            ERc->y[1] = rlc->y[1];
                            ERc->z[1] = rlc->z[1];
                            }
                         else
                            {
                            ERc->x[1] = rlc->x[j-1];
                            ERc->y[1] = rlc->y[j-1];
                            ERc->z[1] = rlc->z[j-1];
                            }
                         ERc->IDN = rlc->idn;
                         ERc->Sindex = rlc->Sindex;
                         ERc->aa = NULL; /** RawAreal **/
                         ERc->bb = NULL; /** RawBridge **/
                         ERc->pp = NULL; /** RawPoint **/
                         ERc->le = NULL; /** ListOfEdges **/
                         ERc->poly = NULL; /** ThePolys **/
                         ERc->ll1 = rlc;
                         ERc->ll2 = NULL;
                         ERc->keyval = LHANG_LON;
                         ERc->Cnumber = Make_Correct(LHANG_LON,checkinstance);

                         if(ERroot == NULL)
                            {
                            ERroot = ERc;
                            ERroot->next = NULL;
                            }
                         else
                            {
                            ERn = ERroot;
                            while(ERn != NULL)
                               {
                               if((ERn->keyval == ERc->keyval) && (ERc->Cnumber == ERn->Cnumber))
                                  {
                                  if(ERn->ll1 == ERc->ll1)
                                     {
                                     if((ERc->x[0] == ERn->x[0]) && (ERc->y[0] == ERn->y[0]) && (ERc->z[0] == ERn->z[0]))
                                        {
                                        break;
                                        }
                                     }
                                  }
                               ERn = ERn->next;
                               }
                            if(ERn == NULL)
                               {
                               ERc->next = ERroot;
                               ERroot = ERc;
                               }
                            else
                               {
                               free(ERc);
                               }
                            }
                         } /*** end FoundCondition ***/
                      if((fndpr > 0) || (bothends < 1))
                         break;
                      }
                   j += rlc->numnodes - 1;
                   } /*** while j < rlc->numnodes ***/
                LatLonBase = LatLonBase + LatLonIncrement;
                }  /*** end while LatLonBase in miny, maxy range **/
             } /*** end LHANG_LON check applies ***/




          }  /*** end for(checkinstance = 0; ...   ***/
       rlc = rlc->next;
       }


   rac = Aroot;
   while(rac != NULL)
      {
       Config1 = SCCtable[rac->Sindex].C;
       Strat1 = SCCtable[rac->Sindex].S;
       Domain1 = SCCtable[rac->Sindex].D;

       for(checkinstance = 0; checkinstance < TtlActiveChecks; checkinstance++)
          {


         if((CombinedCheckApplies(rac->idn,checkinstance,ARNGE_UNM_LAT,rac->Lindex,rac->Sindex,Config1,Strat1,Domain1,&part1,&part2,&part3) > 0) &&
                 (part1 > 0))
             {
             MEroot = NULL;
             TEroot = NULL;
             candidate = 0;
             i = Ctype();
             if(i == 1) /** geodetic **/
                {
                LocalMinY = miny / 100000.0 + Ytranslation;
                LocalMaxY = maxy / 100000.0 + Ytranslation;
                LatLonBase = 0.0;
                LatLonIncrement = 1.0;
                LowerTolerance = FindRelevantSensitivity(ARNGE_UNM_LAT,checkinstance,&UpperTolerance);
                if(FindSpecificSensitivity(3,ARNGE_UNM_LAT,checkinstance,&LatLonIncrement) < 1)
                   LatLonIncrement = 1.0;

                k = (int) ((LocalMinY - LatLonBase) / LatLonIncrement);

                LatLonBase += (double) k * LatLonIncrement;
                if(LatLonBase < LocalMinY)
                   LatLonBase += LatLonIncrement;

                if(LatLonBase <= LocalMaxY)
                   {
                   LatLonIncrement *= 100000.0;
                   LatLonBase = (LatLonBase - Ytranslation) * 100000.0;
                   LocalMinY = LatLonBase - 10.0;
                   LocalMaxY = LatLonBase + 10.0;
                   }
                else
                   {
                   LatLonBase = maxy * 2.0; /** effectively says check will not be applied ***/
                   }
                }
             else if(i == 2)
                {
                LatLonBase = maxy * 2.0; /** effectively says check will not be applied ***/
                }

             while((LatLonBase > MinYcoord) && (LatLonBase < MaxYcoord) && (LatLonBase >= miny) && (LatLonBase <= maxy))
                {
                CreatePointInsideAreal(rac, &xinside1, &yinside1);
                if(yinside1 < LatLonBase)
                   {
                   racAbove = 0;
                   }
                else
                   {
                   racAbove = 1;
                   }

                MEroot = TEroot = NULL;
                if(rac->RB_Tree_Edgelist != NULL)
                   {
                   LastEdge1 = NULL;
                   LastI = -1;
                   i = GetNextArealIndex(rac, LastI, 1, &LastEdge1, cindex, &UsedTree);
                   LastI = i;
                   }
                else
                   i = 0;
                while(i >= 0)
                   {
                   if(i == 0)
                      ii = rac->numverts - 1;
                   else
                      ii = i - 1;
                   checkit = 0;
                   if((rac->y[i] > (MinYcoord + 10)) && (rac->y[i] < (MaxYcoord - 10)) &&
                             (rac->y[ii] > (MinYcoord + 10)) && (rac->y[ii] < (MaxYcoord - 10)))
                      {
                      if(rac->x[i] < rac->x[ii])
                         {
                         if((rac->x[i] <= maxx) && (rac->x[ii] >= minx))
                            checkit = 1;
                         }
                      else
                         {
                         if((rac->x[ii] <= maxx) && (rac->x[i] >= minx))
                            checkit = 1;
                         }
                      }
                   if(checkit > 0)
                      {
                      if(NorthCount <= 0)
                         checkit = ConditionOnDataEdge(rac->x[i],rac->y[i],rac->x[ii],rac->y[ii],Aroot,Proot,Lroot,
                                               rac, NULL, NULL, NorthCount, 100,100,100,checkinstance);
                      if((checkit > 0) && (SouthCount <= 0))
                         checkit = ConditionOnDataEdge(rac->x[i],rac->y[i],rac->x[ii],rac->y[ii],Aroot,Proot,Lroot,
                                               rac, NULL, NULL, 100, SouthCount, 100,100,checkinstance);
                      }
                   if(checkit > 0)
                      {
                      checkit = 0;
                      tempdist = Distance(rac->x[i],rac->y[i],rac->x[i],LatLonBase);
                      if(tempdist <= ActiveChecks[checkinstance].sensitivity4)
                         {
                         tempdist = Distance(rac->x[ii],rac->y[ii],rac->x[ii],LatLonBase);
                         if(tempdist <= ActiveChecks[checkinstance].sensitivity4)
                            checkit = 1;
                         }
                      }

                   if(checkit > 0)
                      {
                      if(rac->y[i] == rac->y[ii])
                         j = 1;
                      else
                         {
                         j = 0;
                         angle = AngleWithXaxis(rac->x[i],rac->y[i],rac->x[ii],rac->y[ii]);
                         if(angle <= 0.105) /** less than 10 degrees, radian measure ***/
                            {
                            j = 1;
                            }
                         }

                      if(j > 0)
                         {
                         if(racAbove <= 0)
                            {
                            unuseddbl = LatLonBase - rac->y[ii];
                            unuseddbl += (LatLonBase - rac->y[i]);
                            if(ii == 0)
                               jj = rac->numverts - 1;
                            else
                               jj = ii - 1;
                            tempdbl = (LatLonBase - rac->y[jj]) + (LatLonBase - rac->y[ii]);
                            if(tempdbl < unuseddbl)
                               j = 0;
                            else
                               {
                               jj = i + 1;
                               if(jj >= rac->numverts)
                                  jj = 0;
                               tempdbl = (LatLonBase - rac->y[jj]) + (LatLonBase - rac->y[i]);
                               if(tempdbl < unuseddbl)
                                  j = 0;
                               }
                            }
                         else
                            {
                            unuseddbl = rac->y[ii] - LatLonBase;
                            unuseddbl += (rac->y[i] - LatLonBase);
                            if(ii == 0)
                               jj = rac->numverts - 1;
                            else
                               jj = ii - 1;
                            tempdbl = (rac->y[jj] - LatLonBase) + (rac->y[ii] - LatLonBase);
                            if(tempdbl < unuseddbl)
                               j = 0;
                            else
                               {
                               jj = i + 1;
                               if(jj >= rac->numverts)
                                  jj = 0;
                               tempdbl = (rac->y[jj] - LatLonBase) + (rac->y[i] - LatLonBase);
                               if(tempdbl < unuseddbl)
                                  j = 0;
                               }
                            }
                         }

                      if(j > 0)
                         {
                         unuseddbl = rac->x[i] + ((rac->x[ii] - rac->x[i]) / 2);
                         if(racAbove > 0)
                            {
                            if(rac->y[i] < rac->y[ii])
                               tempdbl = rac->y[i] - 1.0;
                            else
                               tempdbl = rac->y[ii] - 1.0;
                            if(PointInsidePoly(unuseddbl,tempdbl,rac->x, rac->y, rac->numverts) > 0)
                               j = 0;
                            else
                               j = 1;
                            }
                         else
                            {
                            if(rac->y[i] > rac->y[ii])
                               tempdbl = rac->y[i] + 1.0;
                            else
                               tempdbl = rac->y[ii] + 1.0;
                            if(PointInsidePoly(unuseddbl,tempdbl,rac->x, rac->y, rac->numverts) > 0)
                               j = 0;
                            else
                               j = 1;
                            }
                         }
                      if(j > 0)
                         {
                         jj = 0;
                         if((racAbove > 0) && (tempdbl > LatLonBase)) /*** both pts on same side of test degree line ***/
                            jj = 1;
                         else if((racAbove == 0) && (tempdbl < LatLonBase))
                            jj = 1;
                         if(jj > 0)
                            {
                            ran = Aroot;
                            while(ran != NULL)
                               {
                               if(ran != rac)
                                  {
                                  if(PointInsidePoly(unuseddbl,tempdbl,ran->x,ran->y,ran->numverts) > 0)
                                     {
                                     j=0;
                                     break;
                                     }
                                  }
                               ran = ran->next;
                               }
                            }
                         }


                      if(j > 0)
                         {
                         if(rac->x[i] > rac->x[ii])
                            {
                            if(rac->x[ii] > maxx)
                               j = 0;
                            else if(rac->x[i] < minx)
                               j = 0;
                            }
                         else
                            {
                            if(rac->x[i] > maxx)
                               j = 0;
                            else if(rac->x[ii] < minx)
                               j = 0;
                            }
                         }

                      if((j > 0) && (rac->y[i] >= LocalMinY) && (rac->y[i] <= LocalMaxY) &&
                            (rac->y[ii] >= LocalMinY) && (rac->y[ii] <= LocalMaxY))
                         {
                         x1 = rac->x[ii];
                         y1 = rac->y[ii];
                         z1 = rac->z[ii];
                         x2 = rac->x[i];
                         y2 = rac->y[i];
                         z2 = rac->z[i];
                         candidate = 0;
                         if(ClipLineToRegion(minx,miny,maxx,maxy,&x1,&y1,&z1,&x2,&y2,&z2,&clipflag,multiplier) > 0)
                            {
                            LenToCover = Distance(x1,y1,x2,y2);
                            CoveredSoFar = 0.0;
                            }
                         else
                            {
                            LenToCover = 0.0;
                            CoveredSoFar = 1.0;
                            }

                         ran = Aroot;
                         while((ran != NULL) && (CoveredSoFar < LenToCover))
                            {
                            checkit3 = 1;
                            if(ran == rac)
                               checkit3 = 0;
                            if((checkit3 > 0) && 
                               (CombinedCheckApplies(ran->idn,checkinstance,ARNGE_UNM_LAT,ran->Lindex,ran->Sindex,
                                  SCCtable[ran->Sindex].C,SCCtable[ran->Sindex].S,SCCtable[ran->Sindex].D,
                                     &part1,&part2,&part3) > 0) &&
                                             ((part2 > 0) || (part3 > 0)))
                               {
                               CreatePointInsideAreal(ran, &xinside1, &yinside1);
                               if(yinside1 < LatLonBase)
                                  {
                                  ranAbove = 0;
                                  }
                               else
                                  {
                                  ranAbove = 1;
                                  }
                               if(racAbove != ranAbove) /*** features on different side of latitude ****/
                                  {
                                  if(part2 == 0)
                                     checkit3 = 0;
                                  }

                               if(ran->RB_Tree_Edgelist != NULL)
                                  {
                                  LastEdge2 = NULL;
                                  LastJ = -1;
                                  j = GetNextArealIndex(ran, LastJ, 1, &LastEdge2, cindex, &UsedTree);
                                  LastJ = j;
                                  }
                               else
                                  j = 0;

                               while(j >= 0)
                                  {
                                  if(j == 0)
                                     jj = ran->numverts - 1;
                                  else
                                     jj = j - 1;

                                  angle2 = AngleWithXaxis(ran->x[j],ran->y[j],ran->x[jj],ran->y[jj]);

                                  if((racAbove != ranAbove) && (angle2 < 0.105) && (part3 > 0))
                                     {
                                     tempdbl = PointToLineDist2D(x1,y1, ran->x[j],ran->y[j], ran->x[jj], ran->y[jj]);
                                     if(tempdbl <= UpperTolerance)
                                        {
                                        candidate = 1;
                                        vindex = jj;
                                        vindex2 = j;
                                        }
                                     else
                                        {
                                        tempdbl = PointToLineDist2D(x2,y2, ran->x[j],ran->y[j], ran->x[jj], ran->y[jj]);
                                        if(tempdbl <= UpperTolerance)
                                           {
                                           candidate = 1;
                                           vindex = jj;
                                           vindex2 = j;
                                           }
                                        else
                                           {
                                           tempdbl = PointToLineDist2D(ran->x[j],ran->y[j], x1,y1,x2,y2);
                                           if(tempdbl <= UpperTolerance)
                                              {
                                              candidate = 1;
                                              vindex = jj;
                                              vindex2 = j;
                                              }
                                           else
                                              {
                                              tempdbl = PointToLineDist2D(ran->x[jj],ran->y[jj], x1,y1,x2,y2);
                                              if(tempdbl <= UpperTolerance)
                                                 {
                                                 candidate = 1;
                                                 vindex = jj;
                                                 vindex2 = j;
                                                 }
                                              }
                                           }
                                        }
                                     }

                                  checkit2 = 0;

                                  xt1 = ran->x[jj];
                                  yt1 = ran->y[jj];
                                  z3 = ran->z[jj];
                                  xt2 = ran->x[j];
                                  yt2 = ran->y[j];
                                  z4 = ran->z[j];
                                  if(ClipLineToRegion(minx,miny,maxx,maxy,&xt1,&yt1,&z3,&xt2,&yt2,&z4,&clipflag,multiplier) > 0)
                                     checkit2 = 1;
                                  if((racAbove != ranAbove) && (angle2 < 0.105) && (part2 > 0) && (checkit2 > 0))
                                     {
                                     if(MatchLinearSegment2D(x1,y1,x2,y2,xt1,yt1,xt2,yt2, &MatchLen,LowerTolerance) > 0)
                                        {
                                        CoveredSoFar += MatchLen;
                                        if((CoveredSoFar < LenToCover) && (MatchLen > 0.099))
                                           {
                                           MEn = (struct MatchedEdges *) (malloc(SzME));
                                           if(MEn == NULL)
                                              {
                                              printf("All available memory has been consumed during edge matching - terminating now!\n");
                                              exit(-1);
                                              }
                                           MEn->ind1 = jj;
                                           MEn->ind2 = j;
                                           MEn->covered = 0;
                                           MEn->x[0] = xt1; //ran->x[jj];//xt1;
                                           MEn->x[1] = xt2; //ran->x[j];//xt2;
                                           MEn->y[0] = FindXatYonSegment(xt1,y1,x1,y2,x2); //ran->y[jj];//yt1;
                                           MEn->y[1] = FindXatYonSegment(xt2,y1,x1,y2,x2); //ran->y[j];//yt2;
                                           MEn->a = ran;
                                           MEn->next = MEroot;
                                           MEroot = MEn;
                                           }
                                        if(CoveredSoFar >= LenToCover)
                                          break;
                                        }
                                     } /*** end if checkit2 ***/

                                  if(ran->RB_Tree_Edgelist != NULL)
                                     {
                                     j = GetNextArealIndex(ran, LastJ, 1, &LastEdge2, cindex, &UsedTree);
                                     LastJ = j;
                                     }
                                  else
                                     {
                                     ++j;
                                     if(j >= ran->numverts)
                                        j = -1;
                                     }
                                  }
                               }
                            ran = ran->next;
                            }

                         if((candidate > 0) &&
                             (CoveredSoFar < LenToCover) &&
                                   ((LenToCover - CoveredSoFar) > LowerTolerance)) /** need to add a condition to the list ***/
                            {
                            TEroot = NULL;
                            TEn = (struct MatchedEdges *) (malloc(SzME));
                            if(TEn == NULL)
                               {
                               printf("All available memory has been consumed during edge matching - terminating now!\n");
                               exit(-1);
                               }
                            TEn->ind1 = ii;
                            TEn->ind2 = i;
                            TEn->x[0] = x1;//rac->x[ii];
                            TEn->x[1] = x2;//rac->x[i];
                            TEn->y[0] = y1;//rac->y[ii];
                            TEn->y[1] = y2;//rac->y[i];
                            TEn->a = rac;
                            TEn->covered = 0;
                            TEn->next = TEroot;
                            TEroot = TEn;

                            MEc = MEroot;
                            while(MEc != NULL)
                               {
                               TEc = TEroot;
                               while(TEc != NULL)
                                  {
                                  E1 = E2 = 0;
                                  if((NearlyEqual(MEc->x[0],TEc->x[0]) > 0) && (NearlyEqual(MEc->y[0],TEc->y[0]) > 0))
                                     {
                                     B1 = 0;
                                     E1 = 1;
                                     }
                                  else if((NearlyEqual(MEc->x[0],TEc->x[1]) > 0) && (NearlyEqual(MEc->y[0],TEc->y[1]) > 0))
                                     {
                                     B1 = 0;
                                     E1 = 2;
                                     }
                                  else
                                     B1 = StrictlyBetween(MEc->x[0],MEc->y[0],TEc->x[0],TEc->y[0],TEc->x[1],TEc->y[1]);

                                  if((NearlyEqual(MEc->x[1],TEc->x[0]) > 0) && (NearlyEqual(MEc->y[1],TEc->y[0]) > 0))
                                     {
                                     B2 = 0;
                                     E2 = 1;
                                     }
                                  else if((NearlyEqual(MEc->x[1],TEc->x[1]) > 0) && (NearlyEqual(MEc->y[1],TEc->y[1]) > 0))
                                     {
                                     B2 = 0;
                                     E2 = 2;
                                     }
                                  else
                                     B2 = StrictlyBetween(MEc->x[1],MEc->y[1],TEc->x[0],TEc->y[0],TEc->x[1],TEc->y[1]);
                                  B3 = StrictlyBetween(TEc->x[0],TEc->y[0],MEc->x[0],MEc->y[0],MEc->x[1],MEc->y[1]);
                                  B4 = StrictlyBetween(TEc->x[1],TEc->y[1],MEc->x[0],MEc->y[0],MEc->x[1],MEc->y[1]);
                                  if(E1 > 0)
                                     {
                                     if(E2 > 0)
                                        TEc->covered = 1;
                                     else if(E1 == 1)
                                        {
                                        if(B4 > 0)
                                           TEc->covered = 1;
                                        else if(B2 > 0)
                                           {
                                           TEc->x[0] = MEc->x[1];
                                           TEc->y[0] = MEc->y[1];
                                           }
                                        else
                                           {
                                           }
                                        }
                                     else if(E1 == 2)
                                        {
                                        if(B3 > 0)
                                           TEc->covered = 1;
                                        else if(B2 > 0)
                                           {
                                           TEc->x[1] = MEc->x[1];
                                           TEc->y[1] = MEc->y[1];
                                           }
                                        else
                                           {
                                           }
                                        }
                                     }
                                  else if(E2 > 0)
                                     {
                                     if(E1 > 0)
                                        TEc->covered = 1;
                                     else if(E2 == 1)
                                        {
                                        if(B4 > 0)
                                           TEc->covered = 1;
                                        else if(B1 > 0)
                                           {
                                           TEc->x[0] = MEc->x[0];
                                           TEc->y[0] = MEc->y[0];
                                           }
                                        else
                                           {
                                           }
                                        }
                                     else if(E2 == 2)
                                        {
                                        if(B3 > 0)
                                           TEc->covered = 1;
                                        else if(B1 > 0)
                                           {
                                           TEc->x[1] = MEc->x[0];
                                           TEc->y[1] = MEc->y[0];
                                           }
                                        else
                                           {
                                           }
                                        }
                                     }
                                  else if((B1 <= 0) && (B2 <= 0) && (B3 > 0) && (B4 > 0))
                                     {
                                     TEc->covered = 1;
                                     }
                                  else if((B1 > 0) && (B2 <= 0) && (B3 <= 0) && (B4 > 0))
                                     {
                                     TEc->x[1] = MEc->x[0];
                                     TEc->y[1] = MEc->y[0];
                                     }
                                  else if((B1 > 0) && (B2 <= 0) && (B3 > 0) && (B4 <= 0))
                                     {
                                     TEc->x[0] = MEc->x[0];
                                     TEc->y[0] = MEc->y[0];
                                     }
                                  else if((B1 <= 0) && (B2 > 0) && (B3 <= 0) && (B4 > 0))
                                     {
                                     TEc->x[1] = MEc->x[1];
                                     TEc->y[1] = MEc->y[1];
                                     }
                                  else if((B1 <= 0) && (B2 > 0) && (B3 > 0) && (B4 <= 0))
                                     {
                                     TEc->x[0] = MEc->x[1];
                                     TEc->y[0] = MEc->y[1];
                                     }
                                  else if((B1 > 0) && (B2 > 0) && (B3 <= 0) && (B4 <= 0))
                                     {
                                     TEn = (struct MatchedEdges *) (malloc(SzME));
                                     if(TEn == NULL)
                                        {
                                        printf("All available memory has been consumed during edge matching - terminating now!\n");
                                        exit(-1);
                                        }
                                     TEn->ind1 = TEc->ind1;
                                     TEn->ind2 = TEc->ind2;
                                     TEn->x[0] = TEc->x[0];
                                     TEn->x[1] = TEc->x[1];
                                     TEn->y[0] = TEc->y[0];
                                     TEn->y[1] = TEc->y[1];
                                     TEn->a = rac;
                                     TEn->covered = 0;
                                     TEn->next = TEc->next;
                                     TEc->next = TEn;

                                     tempdist = Distance(TEc->x[0],TEc->y[0],MEc->x[0],MEc->y[0]);
                                     tempdist2 = Distance(TEc->x[0],TEc->y[0],MEc->x[1],MEc->y[1]);
                                     if(tempdist < tempdist2)
                                        {
                                        TEc->x[1] = MEc->x[0];
                                        TEc->y[1] = MEc->y[0];
                                        TEn->x[0] = MEc->x[1];
                                        TEn->y[0] = MEc->y[1];
                                        }
                                     else
                                        {
                                        TEc->x[0] = MEc->x[0];
                                        TEc->y[0] = MEc->y[0];
                                        TEn->x[1] = MEc->x[1];
                                        TEn->y[1] = MEc->y[1];
                                        }
                                     }
                                  TEc = TEc->next;
                                  }
                               MEc = MEc->next;
                               }


                            FoundCondition = 0;
                            TEc = TEroot;
                            while(TEc != NULL)
                               {
                               if(TEc->covered != 1)
                                  {
                                  ARUc = LatRoot;
                                  vindex = Make_Correct(ARNGE_UNM_LAT,checkinstance);
                                  if(TEc->ind1 < TEc->ind2)
                                     vindex2 = TEc->ind1;
                                  else
                                     vindex2 = TEc->ind2;
                                  while(ARUc != NULL)
                                     {
                                     if((ARUc->Cnumber == vindex) && (ARUc->parentid == rac->localID))
                                        {
                                        if(ARUc->lowerindex == vindex2)
                                           {
                                           if((NearlyEqual(ARUc->x[0], TEc->x[0]) > 0) && (NearlyEqual(ARUc->y[0], TEc->y[0]) > 0))
                                              {
                                              ARUc->x[0] = TEc->x[1];
                                              ARUc->y[0] = TEc->y[1];
                                              break;
                                              }
                                           else if((NearlyEqual(ARUc->x[0], TEc->x[1]) > 0) && (NearlyEqual(ARUc->y[0], TEc->y[1]) > 0))
                                              {
                                              ARUc->x[0] = TEc->x[0];
                                              ARUc->y[0] = TEc->y[0];
                                              break;
                                              }
                                           else if((NearlyEqual(ARUc->x[1], TEc->x[0]) > 0) && (NearlyEqual(ARUc->y[1], TEc->y[0]) > 0))
                                              {
                                              ARUc->x[1] = TEc->x[1];
                                              ARUc->y[1] = TEc->y[1];
                                              break;
                                              }
                                           else if((NearlyEqual(ARUc->x[1], TEc->x[1]) > 0) && (NearlyEqual(ARUc->y[1], TEc->y[1]) > 0))
                                              {
                                              ARUc->x[1] = TEc->x[0];
                                              ARUc->y[1] = TEc->y[0];
                                              break;
                                              }
                                           }
                                        }
   
                                     ARUc = ARUc->next;
                                     }
                                  if(ARUc == NULL)
                                     {
                                     ARUn = (struct ARangeUNM *) (malloc(SzARU));
                                     ARUn->keyval = ARNGE_UNM_LAT;
                                     ARUn->Cnumber = Make_Correct(ARNGE_UNM_LAT,checkinstance);
                                     ARUn->parentid = rac->localID;
                                     ARUn->Sindex = rac->Sindex;
                                     ARUn->Lindex = rac->Lindex;
                                     ARUn->idn = rac->idn;
                                     if(TEc->ind1 < TEc->ind2)
                                        ARUn->lowerindex = TEc->ind1;
                                     else
                                        ARUn->lowerindex = TEc->ind2;
                                     ARUn->x[0] = TEc->x[0];
                                     ARUn->y[0] = TEc->y[0];
                                     ARUn->x[1] = TEc->x[1];
                                     ARUn->y[1] = TEc->y[1];
                                     ARUn->z[0] = rac->z[i];
                                     ARUn->z[1] = rac->z[ii];
                                     ARUn->next = LatRoot;
                                     LatRoot = ARUn;
                                     }
                                  }
                               TEc = TEc->next;
                               }
                            } /*** end need to record a condition ***/
                         TEc = TEroot;
                         while(TEc != NULL)
                            {
                            TEn = TEc;
                            TEc = TEc->next;
                            free(TEn);
                            }
                         TEroot = NULL;
                         MEc = MEroot;
                         while(MEc != NULL)
                            {
                            MEn = MEc;
                            MEc = MEc->next;
                            free(MEn);
                            }
                         MEroot = NULL;
                         } /** end if endpoint[j] is in the load module  ***/
                      } /*** end if checkit ***/
                   if(rac->RB_Tree_Edgelist != NULL)
                      {
                      i = GetNextArealIndex(rac, LastI, 1, &LastEdge1, cindex, &UsedTree);
                      LastI = i;
                      }
                   else
                      {
                      ++i;
                      if(i >= rac->numverts)
                         i = -1;
                      }
                   } /*** while i >= 0 ***/
                LatLonBase = LatLonBase + LatLonIncrement;
                }  /*** end while LatLonBase in miny, maxy range **/
             } /*** end ARNGE_UNM_LAT check applies ***/

          if((CombinedCheckApplies(rac->idn,checkinstance,ARNGE_UNM_LON,rac->Lindex,rac->Sindex,Config1,Strat1,Domain1,&part1,&part2,&part3) > 0) && (part1 > 0))
             {
             MEroot = NULL;
             TEroot = NULL;
             candidate = 0;
             i = Ctype();
             if(i == 1) /** geodetic **/
                {
                LocalMinX = minx / 100000.0 + Xtranslation;
                LocalMaxX = maxx / 100000.0 + Xtranslation;
                LatLonBase = 0.0;
                LowerTolerance = FindRelevantSensitivity(ARNGE_UNM_LON,checkinstance,&UpperTolerance);
                if(FindSpecificSensitivity(3,ARNGE_UNM_LON,checkinstance,&LatLonIncrement) < 1)
                   LatLonIncrement = 1.0;



                k = (int) ((LocalMinX - LatLonBase) / LatLonIncrement);

                LatLonBase += (double) k * LatLonIncrement;
                if(LatLonBase < LocalMinX)
                   LatLonBase += LatLonIncrement;
                if(LatLonBase <= LocalMaxX)
                   {
                   LatLonIncrement *= 100000.0;
                   LatLonBase = (LatLonBase - Xtranslation) * 100000.0;
                   LocalMinX = LatLonBase - 10.0;
                   LocalMaxX = LatLonBase + 10.0;
                   }
                else
                   {
                   LatLonBase = maxx * 2.0; /** effectively says check will not be applied ***/
                   }
                }
             else if(i == 2)
                {
                LatLonBase = maxx * 2.0; /** effectively says check will not be applied ***/
                }

             while((LatLonBase > MinXcoord) && (LatLonBase < MaxXcoord) && (LatLonBase >= minx) && (LatLonBase <= maxx))
                {
                CreatePointInsideAreal(rac, &xinside1, &yinside1);
                if(xinside1 > LatLonBase)
                   {
                   racLeft = 0;
                   }
                else
                   {
                   racLeft = 1;
                   }

                MEroot = TEroot = NULL;
                if(rac->RB_Tree_Edgelist != NULL)
                   {
                   LastEdge1 = NULL;
                   LastI = -1;
                   i = GetNextArealIndex(rac, LastI, 1, &LastEdge1, cindex, &UsedTree);
                   LastI = i;
                   }
                else
                   i = 0;
                while(i >= 0)
                   {
                   if(i == 0)
                      ii = rac->numverts - 1;
                   else
                      ii = i - 1;
                   checkit = 0;
                   if((rac->x[i] > (MinXcoord + 10)) && (rac->x[i] < (MaxXcoord - 10)) &&
                              (rac->x[ii] > (MinXcoord + 10)) && (rac->x[ii] < (MaxXcoord - 10)))
                      {
                      if(rac->y[i] < rac->y[ii])
                         {
                         if((rac->y[i] <= maxy) && (rac->y[ii] >= miny))
                            checkit = 1;
                         }
                      else
                         {
                         if((rac->y[ii] <= maxy) && (rac->y[i] >= miny))
                            checkit = 1;
                         }
                      }
                   if(checkit > 0)
                      {
                      if(EastCount <= 0)
                         checkit = ConditionOnDataEdge(rac->x[i],rac->y[i],rac->x[ii],rac->y[ii],Aroot,Proot,Lroot,
                                               rac, NULL, NULL, 100, 100,EastCount,100,checkinstance);
                      if((checkit > 0) && (WestCount <= 0))
                         checkit = ConditionOnDataEdge(rac->x[i],rac->y[i],rac->x[ii],rac->y[ii],Aroot,Proot,Lroot,
                                               rac, NULL, NULL, 100, 100, 100,WestCount,checkinstance);
                      }

                   if(checkit > 0)
                      {
                      checkit = 0;
                      tempdist = Distance(rac->x[i],rac->y[i],LatLonBase, rac->y[i]);
                      if(tempdist <= ActiveChecks[checkinstance].sensitivity4)
                         {
                         tempdist = Distance(rac->x[ii],rac->y[ii],LatLonBase,rac->y[ii]);
                         if(tempdist <= ActiveChecks[checkinstance].sensitivity4)
                            checkit = 1;
                         }
                      }

                   if(checkit > 0)
                      {
                      if(rac->x[i] == rac->x[ii])
                         {
                         j = 1;
                         }
                      else
                         {
                         j = 0;
                         angle = AngleWithYaxis(rac->x[i],rac->y[i],rac->x[ii],rac->y[ii]);
                         if(angle <= 0.105) /** less than 10 degrees, radian measure ***/
                            {
                            j = 1;
                            }
                         }

                      if(j > 0)
                         {
                         if(racLeft > 0)
                            {
                            unuseddbl = LatLonBase - rac->x[ii];
                            unuseddbl += (LatLonBase - rac->x[i]);
                            if(ii == 0)
                               jj = rac->numverts - 1;
                            else
                               jj = ii - 1;
                            tempdbl = (LatLonBase - rac->x[jj]) + (LatLonBase - rac->x[ii]);
                            if(tempdbl < unuseddbl)
                               j = 0;
                            else
                               {
                               jj = i + 1;
                               if(jj >= rac->numverts)
                                  jj = 0;
                               tempdbl = (LatLonBase - rac->x[jj]) + (LatLonBase - rac->x[i]);
                               if(tempdbl < unuseddbl)
                                  j = 0;
                               }
                            }
                         else
                            {
                            unuseddbl = rac->x[ii] - LatLonBase;
                            unuseddbl += (rac->x[i] - LatLonBase);
                            if(ii == 0)
                               jj = rac->numverts - 1;
                            else
                               jj = ii - 1;
                            tempdbl = (rac->x[jj] - LatLonBase) + (rac->x[ii] - LatLonBase);
                            if(tempdbl < unuseddbl)
                               j = 0;
                            else
                               {
                               jj = i + 1;
                               if(jj >= rac->numverts)
                                  jj = 0;
                               tempdbl = (rac->x[jj] - LatLonBase) + (rac->x[i] - LatLonBase);
                               if(tempdbl < unuseddbl)
                                  j = 0;
                               }
                            }
                         }

                      if(j > 0)
                         {
                         tempdbl = rac->y[i] + ((rac->y[ii] - rac->y[i]) / 2);
                         if(racLeft > 0)
                            {
                            if(rac->x[i] > rac->x[ii])
                               unuseddbl = rac->x[i] + 1.0;
                            else
                               unuseddbl = rac->x[ii] + 1.0;
                            if(PointInsidePoly(unuseddbl,tempdbl,rac->x, rac->y, rac->numverts) > 0)
                               j = 0;
                            }
                         else
                            {
                            if(rac->x[i] < rac->x[ii])
                               unuseddbl = rac->x[i] - 1.0;
                            else
                               unuseddbl = rac->x[ii] - 1.0;
                            if(PointInsidePoly(unuseddbl,tempdbl,rac->x, rac->y, rac->numverts) > 0)
                               j = 0;
                            }
                         }
                      if(j > 0)
                         {
                         jj = 0;
                         if((racLeft > 0) && (unuseddbl < LatLonBase)) /*** both pts on same side of test degree line ***/
                            jj = 1;
                         else if((racLeft == 0) && (unuseddbl > LatLonBase))
                            jj = 1;
                         if(jj > 0)
                            {
                            ran = Aroot;
                            while(ran != NULL)
                               {
                               if(ran != rac)
                                  {
                                  if(PointInsidePoly(unuseddbl,tempdbl,ran->x,ran->y,ran->numverts) > 0)
                                     {
                                     j = 0;
                                     break;
                                     }
                                  }
                               ran = ran->next;
                               }
                            }
                         }
                      if(j > 0)
                         {
                         if(rac->y[i] > rac->y[ii])
                            {
                            if(rac->y[ii] > maxy)
                               j = 0;
                            else if(rac->y[i] < miny)
                               j = 0;
                            }
                         }

                      if((j > 0) && (rac->x[i] >= LocalMinX) && (rac->x[i] <= LocalMaxX) &&
                            (rac->x[ii] >= LocalMinX) && (rac->x[ii] <= LocalMaxX))
                         {
                         x1 = rac->x[ii];
                         y1 = rac->y[ii];
                         z1 = rac->z[ii];
                         x2 = rac->x[i];
                         y2 = rac->y[i];
                         z2 = rac->z[i];
                         if(ClipLineToRegion(minx,miny,maxx,maxy,&x1,&y1,&z1,&x2,&y2,&z2,&clipflag,multiplier) > 0)
                            {
                            LenToCover = Distance(x1,y1,x2,y2);
                            CoveredSoFar = 0.0;
                            }
                         else
                            {
                            LenToCover = 0.0;
                            CoveredSoFar = 1.0;
                            }

                         ran = Aroot;
                         candidate = 0;
                         while((ran != NULL) && (CoveredSoFar < LenToCover))
                            {
                            checkit3 = 1;
                            if(ran == rac)
                               checkit3 = 0;
                            if((checkit3 > 0) &&
                               (CombinedCheckApplies(ran->idn,checkinstance,ARNGE_UNM_LON,ran->Lindex,ran->Sindex,
                                  SCCtable[ran->Sindex].C,SCCtable[ran->Sindex].S,SCCtable[ran->Sindex].D,
                                     &part1,&part2,&part3) > 0) &&
                                             ((part2 > 0) || (part3 > 0)))
                               {
                               CreatePointInsideAreal(ran, &xinside1, &yinside1);
                               if(xinside1 > LatLonBase)
                                  {
                                  ranLeft = 0;
                                  }
                               else
                                  {
                                  ranLeft = 1;
                                  }
                               if(racLeft != ranLeft) /*** features on different side of latitude ****/
                                  {
                                  if(part2 == 0)
                                     checkit3 = 0;
                                  }
                               if(ran->RB_Tree_Edgelist != NULL)
                                  {
                                  LastEdge2 = NULL;
                                  LastJ = -1;
                                  j = GetNextArealIndex(ran, LastJ, 1, &LastEdge2, cindex, &UsedTree);
                                  LastJ = j;
                                  }
                               else
                                  j = 0;

                               while(j >= 0)
                                  {
                                  if(j == 0)
                                     jj = ran->numverts - 1;
                                  else
                                     jj = j - 1;

                                  angle2 = AngleWithYaxis(ran->x[j],ran->y[j],ran->x[jj],ran->y[jj]);
                                  if((racLeft != ranLeft) && (angle2 < 0.105) && (part3 > 0))
                                     {
                                     tempdbl = PointToLineDist2D(x1,y1, ran->x[j],ran->y[j], ran->x[jj], ran->y[jj]);
                                     if(tempdbl <= UpperTolerance)
                                        {
                                        candidate = 1;
                                        vindex = j;
                                        vindex2 = jj;
                                        }
                                     else
                                        {
                                        tempdbl = PointToLineDist2D(x2,y2, ran->x[j],ran->y[j], ran->x[jj], ran->y[jj]);
                                        if(tempdbl <= UpperTolerance)
                                           {
                                           candidate = 1;
                                           vindex = j;
                                           vindex2 = jj;
                                           }
                                        else
                                           {
                                           tempdbl = PointToLineDist2D(ran->x[j],ran->y[j], x1,y1,x2,y2);
                                           if(tempdbl <= UpperTolerance)
                                              {
                                              candidate = 1;
                                              vindex = jj;
                                              vindex2 = j;
                                              }
                                           else
                                              {
                                              tempdbl = PointToLineDist2D(ran->x[jj],ran->y[jj], x1,y1,x2,y2);
                                              if(tempdbl <= UpperTolerance)
                                                 {
                                                 candidate = 1;
                                                 vindex = jj;
                                                 vindex2 = j;
                                                 }
                                              }
                                           }
                                        }
                                     }

                                  checkit2 = 0;

                                  xt1 = ran->x[jj];
                                  yt1 = ran->y[jj];
                                  z3 = ran->z[jj];
                                  xt2 = ran->x[j];
                                  yt2 = ran->y[j];
                                  z4 = ran->z[j];
                                  if(ClipLineToRegion(minx,miny,maxx,maxy,&xt1,&yt1,&z3,&xt2,&yt2,&z4,&clipflag,multiplier) > 0)
                                     checkit2 = 1;
                                  if((racLeft != ranLeft) && (angle2 < 0.105) && (part2 > 0) && (checkit2 > 0))
                                     {
                                     if(MatchLinearSegment2D(x1,y1,x2,y2,xt1,yt1,xt2,yt2, &MatchLen,LowerTolerance) > 0)
                                        {
                                        CoveredSoFar += MatchLen;

                                        if((CoveredSoFar < LenToCover) && (MatchLen > 0.099))
                                           {
                                           MEn = (struct MatchedEdges *) (malloc(SzME));
                                           if(MEn == NULL)
                                              {
                                              printf("All available memory has been consumed during edge matching - terminating now!\n");
                                              exit(-1);
                                              }
                                           MEn->ind1 = jj;
                                           MEn->ind2 = j;
                                           MEn->covered = 0;
                                           MEn->y[0] = yt1; 
                                           MEn->y[1] = yt2; 
                                           MEn->x[0] = FindXatYonSegment(yt1,x1,y1,x2,y2); 
                                           MEn->x[1] = FindXatYonSegment(yt2,x1,y1,x2,y2);
                                           MEn->a = ran;
                                           MEn->next = MEroot;
                                           MEroot = MEn;
                                           }

                                        if(CoveredSoFar >= LenToCover)
                                          break;
                                        }
                                     } /*** end if checkit2 ***/

                                  if(ran->RB_Tree_Edgelist != NULL)
                                     {
                                     j = GetNextArealIndex(ran, LastJ, 1, &LastEdge2, cindex, &UsedTree);
                                     LastJ = j;
                                     }
                                  else
                                     {
                                     ++j;
                                     if(j >= ran->numverts)
                                        j = -1;
                                     }
                                  }
                               }
                            ran = ran->next;
                            }

                         if((candidate > 0) &&
                               (CoveredSoFar < LenToCover) &&
                                     ((LenToCover - CoveredSoFar) > LowerTolerance)) /** need to add a condition to the list ***/
                            {
                            TEroot = NULL;
                            TEn = (struct MatchedEdges *) (malloc(SzME));
                            if(TEn == NULL)
                               {
                               printf("All available memory has been consumed during edge matching - terminating now!\n");
                               exit(-1);
                               }
                            TEn->ind1 = ii;
                            TEn->ind2 = i;
                            TEn->x[0] = x1;//rac->x[ii];
                            TEn->x[1] = x2;//rac->x[i];
                            TEn->y[0] = y1;//rac->y[ii];
                            TEn->y[1] = y2;//rac->y[i];
                            TEn->a = rac;
                            TEn->covered = 0;
                            TEn->next = TEroot;
                            TEroot = TEn;

                            MEc = MEroot;
                            while(MEc != NULL)
                               {
                               TEc = TEroot;
                               while(TEc != NULL)
                                  {
                                  E1 = E2 = 0;
                                  if((NearlyEqual(MEc->x[0],TEc->x[0]) > 0) && (NearlyEqual(MEc->y[0],TEc->y[0]) > 0))
                                     {
                                     B1 = 0;
                                     E1 = 1;
                                     }
                                  else if((NearlyEqual(MEc->x[0],TEc->x[1]) > 0) && (NearlyEqual(MEc->y[0],TEc->y[1]) > 0))
                                     {
                                     B1 = 0;
                                     E1 = 2;
                                     }
                                  else
                                     B1 = StrictlyBetween(MEc->x[0],MEc->y[0],TEc->x[0],TEc->y[0],TEc->x[1],TEc->y[1]);

                                  if((NearlyEqual(MEc->x[1],TEc->x[0]) > 0) && (NearlyEqual(MEc->y[1],TEc->y[0]) > 0))
                                     {
                                     B2 = 0;
                                     E2 = 1;
                                     }
                                  else if((NearlyEqual(MEc->x[1],TEc->x[1]) > 0) && (NearlyEqual(MEc->y[1],TEc->y[1]) > 0))
                                     {
                                     B2 = 0;
                                     E2 = 2;
                                     }
                                  else
                                     B2 = StrictlyBetween(MEc->x[1],MEc->y[1],TEc->x[0],TEc->y[0],TEc->x[1],TEc->y[1]);
                                  B3 = StrictlyBetween(TEc->x[0],TEc->y[0],MEc->x[0],MEc->y[0],MEc->x[1],MEc->y[1]);
                                  B4 = StrictlyBetween(TEc->x[1],TEc->y[1],MEc->x[0],MEc->y[0],MEc->x[1],MEc->y[1]);
                                  if(E1 > 0)
                                     {
                                     if(E2 > 0)
                                        TEc->covered = 1;
                                     else if(E1 == 1)
                                        {
                                        if(B4 > 0)
                                           TEc->covered = 1;
                                        else if(B2 > 0)
                                           {
                                           TEc->x[0] = MEc->x[1];
                                           TEc->y[0] = MEc->y[1];
                                           }
                                        else
                                           {
                                           }
                                        }
                                     else if(E1 == 2)
                                        {
                                        if(B3 > 0)
                                           TEc->covered = 1;
                                        else if(B2 > 0)
                                           {
                                           TEc->x[1] = MEc->x[1];
                                           TEc->y[1] = MEc->y[1];
                                           }
                                        else
                                           {
                                           }
                                        }
                                     }
                                  else if(E2 > 0)
                                     {
                                     if(E1 > 0)
                                        TEc->covered = 1;
                                     else if(E2 == 1)
                                        {
                                        if(B4 > 0)
                                           TEc->covered = 1;
                                        else if(B1 > 0)
                                           {
                                           TEc->x[0] = MEc->x[0];
                                           TEc->y[0] = MEc->y[0];
                                           }
                                        else
                                           {
                                           }
                                        }
                                     else if(E2 == 2)
                                        {
                                        if(B3 > 0)
                                           TEc->covered = 1;
                                        else if(B1 > 0)
                                           {
                                           TEc->x[1] = MEc->x[0];
                                           TEc->y[1] = MEc->y[0];
                                           }
                                        else
                                           {
                                           }
                                        }
                                     }
                                  else if((B1 <= 0) && (B2 <= 0) && (B3 > 0) && (B4 > 0))
                                     {
                                     TEc->covered = 1;
                                     }
                                  else if((B1 > 0) && (B2 <= 0) && (B3 <= 0) && (B4 > 0))
                                     {
                                     TEc->x[1] = MEc->x[0];
                                     TEc->y[1] = MEc->y[0];
                                     }
                                  else if((B1 > 0) && (B2 <= 0) && (B3 > 0) && (B4 <= 0))
                                     {
                                     TEc->x[0] = MEc->x[0];
                                     TEc->y[0] = MEc->y[0];
                                     }
                                  else if((B1 <= 0) && (B2 > 0) && (B3 <= 0) && (B4 > 0))
                                     {
                                     TEc->x[1] = MEc->x[1];
                                     TEc->y[1] = MEc->y[1];
                                     }
                                  else if((B1 <= 0) && (B2 > 0) && (B3 > 0) && (B4 <= 0))
                                     {
                                     TEc->x[0] = MEc->x[1];
                                     TEc->y[0] = MEc->y[1];
                                     }
                                  else if((B1 > 0) && (B2 > 0) && (B3 <= 0) && (B4 <= 0))
                                     {
                                     TEn = (struct MatchedEdges *) (malloc(SzME));
                                     if(TEn == NULL)
                                        {
                                        printf("All available memory has been consumed during edge matching - terminating now!\n");
                                        exit(-1);
                                        }
                                     TEn->ind1 = TEc->ind1;
                                     TEn->ind2 = TEc->ind2;
                                     TEn->x[0] = TEc->x[0];
                                     TEn->x[1] = TEc->x[1];
                                     TEn->y[0] = TEc->y[0];
                                     TEn->y[1] = TEc->y[1];
                                     TEn->a = rac;
                                     TEn->covered = 0;
                                     TEn->next = TEc->next;
                                     TEc->next = TEn;

                                     tempdist = Distance(TEc->x[0],TEc->y[0],MEc->x[0],MEc->y[0]);
                                     tempdist2 = Distance(TEc->x[0],TEc->y[0],MEc->x[1],MEc->y[1]);
                                     if(tempdist < tempdist2)
                                        {
                                        TEc->x[1] = MEc->x[0];
                                        TEc->y[1] = MEc->y[0];
                                        TEn->x[0] = MEc->x[1];
                                        TEn->y[0] = MEc->y[1];
                                        }
                                     else
                                        {
                                        TEc->x[0] = MEc->x[0];
                                        TEc->y[0] = MEc->y[0];
                                        TEn->x[1] = MEc->x[1];
                                        TEn->y[1] = MEc->y[1];
                                        }
                                     }
                                  TEc = TEc->next;
                                  }
                               MEc = MEc->next;
                               }

                            FoundCondition = 0;
                            TEc = TEroot;
                            while(TEc != NULL)
                               {
                               if(TEc->covered != 1)
                                  {
                                  ARUc = LonRoot;
                                  vindex = Make_Correct(ARNGE_UNM_LON,checkinstance);
                                  if(TEc->ind1 < TEc->ind2)
                                     vindex2 = TEc->ind1;
                                  else
                                     vindex2 = TEc->ind2;
                                  while(ARUc != NULL)
                                     {
                                     if((ARUc->Cnumber == vindex) && (ARUc->parentid == rac->localID))
                                        {
                                        if(ARUc->lowerindex == vindex2)
                                           {
                                           if((NearlyEqual(ARUc->x[0], TEc->x[0]) > 0) && (NearlyEqual(ARUc->y[0], TEc->y[0]) > 0))
                                              {
                                              ARUc->x[0] = TEc->x[1];
                                              ARUc->y[0] = TEc->y[1];
                                              break;
                                              }
                                           else if((NearlyEqual(ARUc->x[0], TEc->x[1]) > 0) && (NearlyEqual(ARUc->y[0], TEc->y[1]) > 0))
                                              {
                                              ARUc->x[0] = TEc->x[0];
                                              ARUc->y[0] = TEc->y[0];
                                              break;
                                              }
                                           else if((NearlyEqual(ARUc->x[1], TEc->x[0]) > 0) && (NearlyEqual(ARUc->y[1], TEc->y[0]) > 0))
                                              {
                                              ARUc->x[1] = TEc->x[1];
                                              ARUc->y[1] = TEc->y[1];
                                              break;
                                              }
                                           else if((NearlyEqual(ARUc->x[1], TEc->x[1]) > 0) && (NearlyEqual(ARUc->y[1], TEc->y[1]) > 0))
                                              {
                                              ARUc->x[1] = TEc->x[0];
                                              ARUc->y[1] = TEc->y[0];
                                              break;
                                              }
                                           }
                                        }

                                     ARUc = ARUc->next;
                                     }
                                  if(ARUc == NULL)
                                     {
                                     ARUn = (struct ARangeUNM *) (malloc(SzARU));
                                     ARUn->keyval = ARNGE_UNM_LON;
                                     ARUn->Cnumber = Make_Correct(ARNGE_UNM_LON,checkinstance);
                                     ARUn->parentid = rac->localID;
                                     ARUn->Sindex = rac->Sindex;
                                     ARUn->Lindex = rac->Lindex;
                                     ARUn->idn = rac->idn;
                                     if(TEc->ind1 < TEc->ind2)
                                        ARUn->lowerindex = TEc->ind1;
                                     else
                                        ARUn->lowerindex = TEc->ind2;
                                     ARUn->x[0] = TEc->x[0];
                                     ARUn->y[0] = TEc->y[0];
                                     ARUn->x[1] = TEc->x[1];
                                     ARUn->y[1] = TEc->y[1];
                                     ARUn->z[0] = rac->z[i];
                                     ARUn->z[1] = rac->z[ii];
                                     ARUn->next = LonRoot;
                                     LonRoot = ARUn;
                                     }

                                  }
                               TEc = TEc->next;
                              }

                            } /*** end need to record a condition ***/
                         TEc = TEroot;
                         while(TEc != NULL)
                            {
                            TEn = TEc;
                            TEc = TEc->next;
                            free(TEn);
                            }
                         TEroot = NULL;
                         MEc = MEroot;
                         while(MEc != NULL)
                            {
                            MEn = MEc;
                            MEc = MEc->next;
                            free(MEn);
                            }
                         MEroot = NULL;
                         } /** end if endpoint[j] is in the load module  ***/
                      } /*** end if checkit ***/
                   if(rac->RB_Tree_Edgelist != NULL)
                      {
                      i = GetNextArealIndex(rac, LastI, 1, &LastEdge1, cindex, &UsedTree);
                      LastI = i;
                      }
                   else
                      {
                      ++i;
                      if(i >= rac->numverts)
                         i = -1;
                      }
                   } /*** while i >= 0 ***/
                LatLonBase = LatLonBase + LatLonIncrement;
                }  /*** end while LatLonBase in miny, maxy range **/
             } /*** end ARNGE_UNM_LON check applies ***/

         if((CombinedCheckApplies(rac->idn,checkinstance,AHANG_LAT,rac->Lindex,rac->Sindex,Config1,Strat1,Domain1,&part1,&part2,&part3) > 0) &&
                 (part1 > 0))
             {
             candidate = 0;
             i = Ctype();
             if(i == 1) /** geodetic **/
                {
                LocalMinY = miny / 100000.0 + Ytranslation;
                LocalMaxY = maxy / 100000.0 + Ytranslation;
                LatLonBase = 0.0;
                LowerTolerance = FindRelevantSensitivity(AHANG_LAT,checkinstance,&UpperTolerance);
                if(FindSpecificSensitivity(3,AHANG_LAT,checkinstance,&LatLonIncrement) < 1)
                   LatLonIncrement = 1.0;
                if(FindSpecificSensitivity(4,AHANG_LAT,checkinstance,&tolerance4) < 1)
                   tolerance4 = 10.0;

                k = (int) ((LocalMinY - LatLonBase) / LatLonIncrement);

                LatLonBase += (double) k * LatLonIncrement;
                if(LatLonBase < (LocalMinY - 0.01))
                   LatLonBase += LatLonIncrement;

                if(LatLonBase <= (LocalMaxY + 0.01))
                   {
                   LatLonIncrement *= 100000.0;
                   LatLonBase = (LatLonBase - Ytranslation) * 100000.0;
                   LocalMinY = LatLonBase - tolerance4;
                   LocalMaxY = LatLonBase + tolerance4;
                   }
                else
                   {
                   LatLonBase = maxy * 2.0; /** effectively says check will not be applied ***/
                   }
                }
             else if(i == 2)
                {
                LatLonBase = maxy * 2.0; /** effectively says check will not be applied ***/
                }

             while((LatLonBase >= MinYcoord) && (LatLonBase <= MaxYcoord) &&
                        (LatLonBase >= (miny - tolerance4)) && (LatLonBase <= (maxy + tolerance4)))
                {
                CreatePointInsideAreal(rac, &xinside1, &yinside1);
                if(yinside1 < LatLonBase)
                   {
                   racAbove = 0;
                   }
                else
                   {
                   racAbove = 1;
                   }

                if(rac->RB_Tree_Edgelist != NULL)
                   {
                   LastEdge1 = NULL;
                   LastI = -1;
                   i = GetNextArealIndex(rac, LastI, 1, &LastEdge1, cindex, &UsedTree);
                   LastI = i;
                   }
                else
                   i = 0;
                while(i >= 0)
                   {
                   if(i == 0)
                      ii = rac->numverts - 1;
                   else
                      ii = i - 1;
                   checkit = 0;
                   if(rac->x[i] < rac->x[ii])
                      {
                      if((rac->x[i] <= maxx) && (rac->x[ii] >= minx))
                         checkit = 1;
                      }
                   else
                      {
                      if((rac->x[ii] <= maxx) && (rac->x[i] >= minx))
                         checkit = 1;
                      }
                   if(checkit > 0)
                      {
                      if(NorthCount <= 0)
                         checkit = ConditionOnDataEdge(rac->x[i],rac->y[i],rac->x[ii],rac->y[ii],Aroot,Proot,Lroot,
                                               rac, NULL, NULL, NorthCount, 100,100,100,checkinstance);
                      if((checkit > 0) && (SouthCount <= 0))
                         checkit = ConditionOnDataEdge(rac->x[i],rac->y[i],rac->x[ii],rac->y[ii],Aroot,Proot,Lroot,
                                               rac, NULL, NULL, 100, SouthCount, 100,100,checkinstance);
                      }
                   if(checkit > 0)
                      {
                      j = 0;
                      angle = AngleWithXaxis(rac->x[i],rac->y[i],rac->x[ii],rac->y[ii]);
                      if(angle <= 0.105) /** less than 10 degrees in radians ***/
                         j = 1;

                      if(j > 0)
                         {
                         if(rac->x[i] > rac->x[ii])
                            {
                            if(rac->x[ii] > maxx)
                               j = 0;
                            else if(rac->x[i] < minx)
                               j = 0;
                            }
                         else
                            {
                            if(rac->x[i] > maxx)
                               j = 0;
                            else if(rac->x[ii] < minx)
                               j = 0;
                            }
                         }

                      if((rac->y[i] <= (MinYcoord + tolerance4)) || (rac->y[i] >= (MaxYcoord - tolerance4)))
                         j = 0;
                      if((rac->y[ii] <= (MinYcoord + tolerance4)) || (rac->y[ii] >= (MaxYcoord - tolerance4)))
                         j = 0;
                      if((j > 0) && (rac->y[i] >= LocalMinY) && (rac->y[i] <= LocalMaxY) &&
                            (rac->y[ii] >= LocalMinY) && (rac->y[ii] <= LocalMaxY))
                         {
                         x1 = rac->x[ii];
                         y1 = rac->y[ii];
                         z1 = rac->z[ii];
                         x2 = rac->x[i];
                         y2 = rac->y[i];
                         z2 = rac->z[i];
                         candidate = 0;
                         if(ClipLineToRegion(minx,miny,maxx,maxy,&x1,&y1,&z1,&x2,&y2,&z2,&clipflag,multiplier) > 0)
                            {
                            LenToCover = Distance(x1,y1,x2,y2);
                            CoveredSoFar = 0.0;
                            }
                         else
                            {
                            LenToCover = 0.0;
                            CoveredSoFar = 1.0;
                            }

                         ran = Aroot;
                         while((ran != NULL) && (CoveredSoFar < LenToCover))
                            {
                            checkit3 = 1;
                            if(ran == rac)
                               checkit3 = 0;
                            if((checkit3 > 0) &&
                               (CombinedCheckApplies(ran->idn,checkinstance,AHANG_LAT,ran->Lindex,ran->Sindex,
                                  SCCtable[ran->Sindex].C,SCCtable[ran->Sindex].S,SCCtable[ran->Sindex].D,
                                     &part1,&part2,&part3) > 0) &&
                                             ((part2 > 0) || (part3 > 0)))
                               {
                               CreatePointInsideAreal(ran, &xinside1, &yinside1);
                               if(yinside1 < LatLonBase)
                                  {
                                  ranAbove = 0;
                                  }
                               else
                                  {
                                  ranAbove = 1;
                                  }
                               if(racAbove != ranAbove) /*** features on different side of latitude ****/
                                  {
                                  if(part2 == 0)
                                     checkit3 = 0;
                                  }

                               if(ran->RB_Tree_Edgelist != NULL)
                                  {
                                  LastEdge2 = NULL;
                                  LastJ = -1;
                                  j = GetNextArealIndex(ran, LastJ, 1, &LastEdge2, cindex, &UsedTree);
                                  LastJ = j;
                                  }
                               else
                                  j = 0;

                               while(j >= 0)
                                  {
                                  if(j == 0)
                                     jj = ran->numverts - 1;
                                  else
                                     jj = j - 1;

                                  if(part3 > 0)
                                     {
                                     tempdbl = PointToLineDist2D(rac->x[i],rac->y[i], ran->x[j],ran->y[j], ran->x[jj], ran->y[jj]);
                                     if(tempdbl <= UpperTolerance)
                                        {
                                        candidate = 1;
                                        vindex = j;
                                        }
                                     else
                                        {
                                        tempdbl = PointToLineDist2D(rac->x[ii],rac->y[ii], ran->x[j],ran->y[j], ran->x[jj], ran->y[jj]);
                                        if(tempdbl <= UpperTolerance)
                                           {
                                           candidate = 1;
                                           vindex = j;
                                           }
                                        }
                                     }

                                  checkit2 = 0;

                                  xt1 = ran->x[jj];
                                  yt1 = ran->y[jj];
                                  z3 = ran->z[jj];
                                  xt2 = ran->x[j];
                                  yt2 = ran->y[j];
                                  z4 = ran->z[j];
                                  if(ClipLineToRegion(minx,miny,maxx,maxy,&xt1,&yt1,&z3,&xt2,&yt2,&z4,&clipflag,multiplier) > 0)
                                     checkit2 = 1;
                                  if((part2 > 0) && (checkit2 > 0))
                                     {
                                     if(MatchLinearSegment2D(x1,y1,x2,y2,xt1,yt1,xt2,yt2, &MatchLen,LowerTolerance) > 0)
                                        {
                                        CoveredSoFar += MatchLen;
                                        if(CoveredSoFar >= LenToCover)
                                          break;
                                        }
                                     } /*** end if checkit2 ***/

                                  if(ran->RB_Tree_Edgelist != NULL)
                                     {
                                     j = GetNextArealIndex(ran, LastJ, 1, &LastEdge2, cindex, &UsedTree);
                                     LastJ = j;
                                     }
                                  else
                                     {
                                     ++j;
                                     if(j >= ran->numverts)
                                        j = -1;
                                     }
                                  }
                               }
                            ran = ran->next;
                            }

                         if((candidate == 0) &&
                             (CoveredSoFar < LenToCover) &&
                                   ((LenToCover - CoveredSoFar) > LowerTolerance)) /** need to add a condition to the list ***/
                            {
                            FoundCondition = 0;
                            ERc = (struct collection *) (malloc(SzC));
                            if(ERc == NULL)
                              {
                              printf("allocation memory exhausted during linear feature condition analysis (boundary match analysis)\n");
                              printf("processing cannot continue\n");
                              exit(-1);
                              }
                            ERc->x[0] = rac->x[i];
                            ERc->y[0] = rac->y[i];
                            ERc->z[0] = rac->z[i];
                            ERc->x[1] = rac->x[ii];
                            ERc->y[1] = rac->y[ii];
                            ERc->z[1] = rac->z[ii];
                            ERc->IDN = rac->idn;
                            ERc->Sindex = rac->Sindex;
                            ERc->aa = rac; /** RawAreal **/
                            ERc->aa2 = NULL;
                            ERc->bb = NULL; /** RawBridge **/
                            ERc->pp = NULL; /** RawPoint **/
                            ERc->le = NULL; /** ListOfEdges **/
                            ERc->poly = NULL; /** ThePolys **/
                            ERc->keyval = AHANG_LAT;
                            ERc->Cnumber = Make_Correct(AHANG_LAT,checkinstance);

                            if(ERroot == NULL)
                               {
                               ERroot = ERc;
                               ERroot->next = NULL;
                               }
                            else
                               {
                               ERn = ERroot;
                               while(ERn != NULL)
                                  {
                                  if((ERn->keyval == ERc->keyval) && (ERc->Cnumber == ERn->Cnumber))
                                     {
                                     if(ERn->aa == ERc->aa)
                                        {
                                        if((ERc->x[0] == ERn->x[0]) && (ERc->y[0] == ERn->y[0]) && (ERc->z[0] == ERn->z[0]))
                                           {
                                           if((ERc->x[1] == ERn->x[1]) && (ERc->y[1] == ERn->y[1]) && (ERc->z[1] == ERn->z[1]))
                                              break;
                                           }
                                        else if((ERc->x[0] == ERn->x[1]) && (ERc->y[0] == ERn->y[1]) && (ERc->z[0] == ERn->z[1]))
                                           {
                                           if((ERc->x[1] == ERn->x[0]) && (ERc->y[1] == ERn->y[0]) && (ERc->z[1] == ERn->z[0]))
                                              break;
                                           }
                                        }
                                     }
                                  ERn = ERn->next;
                                  }
                               if(ERn == NULL)
                                  {
                                  ERc->next = ERroot;
                                  ERroot = ERc;
                                  }
                               else
                                  {
                                  free(ERc);
                                  }
                               }
                            } /*** end need to record a condition ***/
                         } /** end if endpoint[j] is in the load module  ***/
                      } /*** end if checkit ***/
                   if(rac->RB_Tree_Edgelist != NULL)
                      {
                      i = GetNextArealIndex(rac, LastI, 1, &LastEdge1, cindex, &UsedTree);
                      LastI = i;
                      }
                   else
                      {
                      ++i;
                      if(i >= rac->numverts)
                         i = -1;
                      }
                   } /*** while i >= 0 ***/
                LatLonBase = LatLonBase + LatLonIncrement;
                }  /*** end while LatLonBase in miny, maxy range **/
             } /*** end AHANG_LAT check applies ***/

          if((CombinedCheckApplies(rac->idn,checkinstance,AHANG_LON,rac->Lindex,rac->Sindex,Config1,Strat1,Domain1,&part1,&part2,&part3) > 0) && (part1 > 0))
             {
             candidate = 0;
             i = Ctype();
             if(i == 1) /** geodetic **/
                {
                LocalMinX = minx / 100000.0 + Xtranslation;
                LocalMaxX = maxx / 100000.0 + Xtranslation;
                LatLonBase = 0.0;
                LowerTolerance = FindRelevantSensitivity(AHANG_LON,checkinstance,&UpperTolerance);
                if(FindSpecificSensitivity(3,AHANG_LON,checkinstance,&LatLonIncrement) < 1)
                   LatLonIncrement = 1.0;
                if(FindSpecificSensitivity(4,AHANG_LON,checkinstance,&tolerance4) < 1)
                   tolerance4 = 10.0;



                k = (int) ((LocalMinX - LatLonBase) / LatLonIncrement);

                LatLonBase += (double) k * LatLonIncrement;
                if(LatLonBase < (LocalMinX - 0.01))
                   LatLonBase += LatLonIncrement;
                if(LatLonBase <= (LocalMaxX + 0.01))
                   {
                   LatLonIncrement *= 100000.0;
                   LatLonBase = (LatLonBase - Xtranslation) * 100000.0;
                   LocalMinX = LatLonBase - tolerance4;
                   LocalMaxX = LatLonBase + tolerance4;
                   }
                else
                   {
                   LatLonBase = maxx * 2.0; /** effectively says check will not be applied ***/
                   }
                }
             else if(i == 2)
                {
                LatLonBase = maxx * 2.0; /** effectively says check will not be applied ***/
                }

             while((LatLonBase >= MinXcoord) && (LatLonBase <= MaxXcoord) &&
                       (LatLonBase >= (minx - tolerance4)) && (LatLonBase <= (maxx + tolerance4)))
                {
                CreatePointInsideAreal(rac, &xinside1, &yinside1);
                if(xinside1 > LatLonBase)
                   {
                   racLeft = 0;
                   }
                else
                   {
                   racLeft = 1;
                   }

                if(rac->RB_Tree_Edgelist != NULL)
                   {
                   LastEdge1 = NULL;
                   LastI = -1;
                   i = GetNextArealIndex(rac, LastI, 1, &LastEdge1, cindex, &UsedTree);
                   LastI = i;
                   }
                else
                   i = 0;
                while(i >= 0)
                   {
                   if(i == 0)
                      ii = rac->numverts - 1;
                   else
                      ii = i - 1;
                   checkit = 0;
                   if(rac->y[i] < rac->y[ii])
                      {
                      if((rac->y[i] <= maxy) && (rac->y[ii] >= miny))
                         checkit = 1;
                      }
                   else
                      {
                      if((rac->y[ii] <= maxy) && (rac->y[i] >= miny))
                         checkit = 1;
                      }
                   if(checkit > 0)
                      {
                      if(EastCount <= 0)
                         checkit = ConditionOnDataEdge(rac->x[i],rac->y[i],rac->x[ii],rac->y[ii],Aroot,Proot,Lroot,
                                               rac, NULL, NULL, 100, 100,EastCount,100,checkinstance);
                      if((checkit > 0) && (WestCount <= 0))
                         checkit = ConditionOnDataEdge(rac->x[i],rac->y[i],rac->x[ii],rac->y[ii],Aroot,Proot,Lroot,
                                               rac, NULL, NULL, 100, 100, 100,WestCount,checkinstance);
                      }
                   if(checkit > 0)
                      {
                      if(rac->x[i] == rac->x[ii])
                         {
                         j = 1;
                         }
                      else
                         {
                         j = 0;
                         angle = AngleWithYaxis(rac->x[i],rac->y[i],rac->x[ii],rac->y[ii]);
                         if(angle <= 0.105) /** less than 10 degrees, radian measure ***/
                            j = 1;
                         }
                      if(j > 0)
                         {
                         if(rac->y[i] > rac->y[ii])
                            {
                            if(rac->y[ii] > maxy)
                               j = 0;
                            else if(rac->y[i] < miny)
                               j = 0;
                            }
                         }
                      if((rac->x[i] <= (MinXcoord + tolerance4)) || (rac->x[i] >= (MaxXcoord - tolerance4)))
                         j = 0;
                      if((rac->x[ii] <= (MinXcoord + tolerance4)) || (rac->x[ii] >= (MaxXcoord - tolerance4)))
                         j = 0;

                      if((j > 0) && (rac->x[i] >= LocalMinX) && (rac->x[i] <= LocalMaxX) &&
                            (rac->x[ii] >= LocalMinX) && (rac->x[ii] <= LocalMaxX))
                         {
                         x1 = rac->x[ii];
                         y1 = rac->y[ii];
                         z1 = rac->z[ii];
                         x2 = rac->x[i];
                         y2 = rac->y[i];
                         z2 = rac->z[i];
                         if(ClipLineToRegion(minx,miny,maxx,maxy,&x1,&y1,&z1,&x2,&y2,&z2,&clipflag,multiplier) > 0)
                            {
                            LenToCover = Distance(x1,y1,x2,y2);
                            CoveredSoFar = 0.0;
                            }
                         else
                            {
                            LenToCover = 0.0;
                            CoveredSoFar = 1.0;
                            }

                         ran = Aroot;
                         candidate = 0;
                         while((ran != NULL) && (CoveredSoFar < LenToCover))
                            {
                            checkit3 = 1;
                            if(ran == rac)
                               checkit3 = 0;
                            if((checkit3 > 0) &&
                               (CombinedCheckApplies(ran->idn,checkinstance,AHANG_LON,ran->Lindex,ran->Sindex,
                                  SCCtable[ran->Sindex].C,SCCtable[ran->Sindex].S,SCCtable[ran->Sindex].D,
                                     &part1,&part2,&part3) > 0) &&
                                             ((part2 > 0) || (part3 > 0)))
                               {
                               CreatePointInsideAreal(ran, &xinside1, &yinside1);
                               if(xinside1 > LatLonBase)
                                  {
                                  ranLeft = 0;
                                  }
                               else
                                  {
                                  ranLeft = 1;
                                  }
                               if(racLeft != ranLeft) /*** features on different side of latitude ****/
                                  {
                                  if(part2 == 0)
                                     checkit3 = 0;
                                  }
                               if(ran->RB_Tree_Edgelist != NULL)
                                  {
                                  LastEdge2 = NULL;
                                  LastJ = -1;
                                  j = GetNextArealIndex(ran, LastJ, 1, &LastEdge2, cindex, &UsedTree);
                                  LastJ = j;
                                  }
                               else
                                  j = 0;

                               while(j >= 0)
                                  {
                                  if(j == 0)
                                     jj = ran->numverts - 1;
                                  else
                                     jj = j - 1;

                                  if(part3 > 0)
                                     {
                                     tempdbl = PointToLineDist2D(rac->x[i],rac->y[i], ran->x[j],ran->y[j], ran->x[jj], ran->y[jj]);
                                     if(tempdbl <= UpperTolerance)
                                        {
                                        candidate = 1;
                                        vindex = j;
                                        }
                                     else
                                        {
                                        tempdbl = PointToLineDist2D(rac->x[ii],rac->y[ii], ran->x[j],ran->y[j], ran->x[jj], ran->y[jj]);
                                        if(tempdbl <= UpperTolerance)
                                           {
                                           candidate = 1;
                                           vindex = j;
                                           }
                                        }
                                     }

                                  checkit2 = 0;

                                  xt1 = ran->x[jj];
                                  yt1 = ran->y[jj];
                                  z3 = ran->z[jj];
                                  xt2 = ran->x[j];
                                  yt2 = ran->y[j];
                                  z4 = ran->z[j];
                                  if(ClipLineToRegion(minx,miny,maxx,maxy,&xt1,&yt1,&z3,&xt2,&yt2,&z4,&clipflag,multiplier) > 0)
                                     checkit2 = 1;
                                  if((part2 > 0) && (checkit2 > 0))
                                     {
                                     if(MatchLinearSegment2D(x1,y1,x2,y2,xt1,yt1,xt2,yt2, &MatchLen,LowerTolerance) > 0)
                                        {
                                        CoveredSoFar += MatchLen;
                                        if(CoveredSoFar >= LenToCover)
                                          break;
                                        }
                                     } /*** end if checkit2 ***/

                                  if(ran->RB_Tree_Edgelist != NULL)
                                     {
                                     j = GetNextArealIndex(ran, LastJ, 1, &LastEdge2, cindex, &UsedTree);
                                     LastJ = j;
                                     }
                                  else
                                     {
                                     ++j;
                                     if(j >= ran->numverts)
                                        j = -1;
                                     }
                                  }
                               }
                            ran = ran->next;
                            }

                         if((candidate == 0) &&
                               (CoveredSoFar < LenToCover) &&
                                     ((LenToCover - CoveredSoFar) > LowerTolerance)) /** need to add a condition to the list ***/
                            {
                            FoundCondition = 0;
                            ERc = (struct collection *) (malloc(SzC));
                            if(ERc == NULL)
                              {
                              printf("allocation memory exhausted during linear feature condition analysis (boundary match analysis)\n");
                              printf("processing cannot continue\n");
                              exit(-1);
                              }
                            ERc->x[0] = rac->x[i];
                            ERc->y[0] = rac->y[i];
                            ERc->z[0] = rac->z[i];
                            ERc->x[1] = rac->x[ii];
                            ERc->y[1] = rac->y[ii];
                            ERc->z[1] = rac->z[ii];
                            ERc->IDN = rac->idn;
                            ERc->Sindex = rac->Sindex;
                            ERc->aa = rac; /** RawAreal **/
                            ERc->aa2 = NULL;
                            ERc->bb = NULL; /** RawBridge **/
                            ERc->pp = NULL; /** RawPoint **/
                            ERc->le = NULL; /** ListOfEdges **/
                            ERc->poly = NULL; /** ThePolys **/
                            ERc->keyval = AHANG_LON;
                            ERc->Cnumber = Make_Correct(AHANG_LON,checkinstance);

                            if(ERroot == NULL)
                               {
                               ERroot = ERc;
                               ERroot->next = NULL;
                               }
                            else
                               {
                               ERn = ERroot;
                               while(ERn != NULL)
                                  {
                                  if((ERn->keyval == ERc->keyval) && (ERc->Cnumber == ERn->Cnumber))
                                     {
                                     if(ERn->aa == ERc->aa)
                                        {
                                        if((ERc->x[0] == ERn->x[0]) && (ERc->y[0] == ERn->y[0]) && (ERc->z[0] == ERn->z[0]))
                                           {
                                           if((ERc->x[1] == ERn->x[1]) && (ERc->y[1] == ERn->y[1]) && (ERc->z[1] == ERn->z[1]))
                                              break;
                                           }
                                        else if((ERc->x[0] == ERn->x[1]) && (ERc->y[0] == ERn->y[1]) && (ERc->z[0] == ERn->z[1]))
                                           {
                                           if((ERc->x[1] == ERn->x[0]) && (ERc->y[1] == ERn->y[0]) && (ERc->z[1] == ERn->z[0]))
                                              break;
                                           }
                                        }
                                     }
                                  ERn = ERn->next;
                                  }
                               if(ERn == NULL)
                                  {
                                  ERc->next = ERroot;
                                  ERroot = ERc;
                                  }
                               else
                                  {
                                  free(ERc);
                                  }
                               }
                            } /*** end need to record a condition ***/
                         } /** end if endpoint[j] is in the load module  ***/
                      } /*** end if checkit ***/
                   if(rac->RB_Tree_Edgelist != NULL)
                      {
                      i = GetNextArealIndex(rac, LastI, 1, &LastEdge1, cindex, &UsedTree);
                      LastI = i;
                      }
                   else
                      {
                      ++i;
                      if(i >= rac->numverts)
                         i = -1;
                      }
                   } /*** while i >= 0 ***/
                LatLonBase = LatLonBase + LatLonIncrement;
                }  /*** end while LatLonBase in miny, maxy range **/
             } /*** end AHANG_LON check applies ***/




          if((CombinedCheckApplies(rac->idn,checkinstance,AUNM_ACRS_A,rac->Lindex,rac->Sindex,Config1,Strat1,Domain1,&part1,&part2,&part3) > 0) &&
                 (part1 > 0))
             {
             CreatePointInsideAreal(rac, &xinside1, &yinside1);

             LowerTolerance = FindRelevantSensitivity(AUNM_ACRS_A,checkinstance,&UpperTolerance);

             if(rac->RB_Tree_Edgelist != NULL)
                {
                LastEdge1 = NULL;
                LastI = -1;
                i = GetNextArealIndex(rac, LastI, 1, &LastEdge1, cindex, &UsedTree);
                LastI = i;
                }
             else
                i = 0;
             while(i >= 0)
                {
                if(i == 0)
                   ii = rac->numverts - 1;
                else
                   ii = i - 1;
                checkit = 0;
                if(rac->x[i] < rac->x[ii])
                   {
                   if((rac->x[i] <= maxx) && (rac->x[ii] >= minx))
                      checkit = 1;
                   }
                else
                   {
                   if((rac->x[ii] <= maxx) && (rac->x[i] >= minx))
                      checkit = 1;
                   }
                if(checkit > 0)
                   {
                   x1 = rac->x[ii];
                   y1 = rac->y[ii];
                   z1 = rac->z[ii];
                   x2 = rac->x[i];
                   y2 = rac->y[i];
                   z2 = rac->z[i];
                   if(ClipLineToRegion(minx,miny,maxx,maxy,&x1,&y1,&z1,&x2,&y2,&z2,&clipflag,multiplier) <= 0)
                      {
                      checkit = 0;
                      }

                   }
                if(checkit > 0)
                   {
                   if(NorthCount <= 0)
                      checkit = ConditionOnDataEdge(rac->x[i],rac->y[i],rac->x[ii],rac->y[ii],Aroot,Proot,Lroot,
                                            rac, NULL, NULL, NorthCount, 100,100,100,checkinstance);
                   if((checkit > 0) && (SouthCount <= 0))
                      checkit = ConditionOnDataEdge(rac->x[i],rac->y[i],rac->x[ii],rac->y[ii],Aroot,Proot,Lroot,
                                            rac, NULL, NULL, 100, SouthCount, 100,100,checkinstance);
                   }
                if(checkit > 0)
                   {
                   UMroot = NULL;
                   ran = Aroot;
                   while(ran != NULL)
                      {
                      if((ran != rac) &&
                         (CombinedCheckApplies(ran->idn,checkinstance,AUNM_ACRS_A,ran->Lindex,ran->Sindex,
                            SCCtable[ran->Sindex].C,SCCtable[ran->Sindex].S,SCCtable[ran->Sindex].D,
                              &part1,&part2,&part3) > 0) &&
                           (part3 > 0))
                         {
                         if(ran->RB_Tree_Edgelist != NULL)
                            {
                            LastEdge2 = NULL;
                            LastJ = -1;
                            j = GetNextArealIndex(ran, LastJ, 1, &LastEdge2, cindex, &UsedTree);
                            LastJ = j;
                            }
                         else
                            j = 0;
                         while(j >= 0)
                            {
                            if(j == 0)
                               jj = ran->numverts - 1;
                            else
                               jj = j - 1;
                            xt1 = ran->x[jj];
                            yt1 = ran->y[jj];
                            z3 = ran->z[jj];
                            xt2 = ran->x[j];
                            yt2 = ran->y[j];
                            z4 = ran->z[j];
                            checkit = 1;
                            if(ClipLineToRegion(minx,miny,maxx,maxy,&xt1,&yt1,&z3,&xt2,&yt2,&z4,&clipflag,multiplier) <= 0)
                               checkit = 0;

                            LenToCover = 0.0;
                            CoveredSoFar = 1.0;
                            if((checkit > 0) && (MatchAndModifyLinearSegment(x1, y1, x2, y2, xt1, yt1, xt2, yt2,
                                   &MatchLen, &bx1, &by1,&bx2, &by2, &on0, &on1, &on2, &on3, UpperTolerance) > 0) &&
                                      (MatchLen > 0.0001))
                               {
                               UMn = (struct UnMatched *) (malloc((SzUM)));
                               UMn->x1 = bx1; UMn->y1 = by1;
                               UMn->x2 = bx2; UMn->y2 = by2;
                               UMn->next = NULL;
                               UMroot = UMn;
                               LenToCover = Distance(bx1,by1,bx2,by2);
                               LenToCover = LenToCover - 0.001;
                               CoveredSoFar = 0.0;
                       
                               rap = Aroot;
                               while(rap != NULL)
                                  {
                                  if((rap != rac) && (rap != ran) && 
                                     (CombinedCheckApplies(rap->idn,checkinstance,AUNM_ACRS_A,rap->Lindex,rap->Sindex,
                                        SCCtable[rap->Sindex].C,SCCtable[rap->Sindex].S,SCCtable[rap->Sindex].D,
                                          &part1,&part2,&part3) > 0) &&
                                       (part2 > 0))
                                     {
                                     if(rap->RB_Tree_Edgelist != NULL)
                                        {
                                        LastEdge3 = NULL;
                                        LastK = -1;
                                        k = GetNextArealIndex(rap, LastK, 1, &LastEdge3, cindex, &UsedTree);
                                        LastK = k;
                                        }
                                     else
                                        k = 0;
                                     while(k >= 0)
                                        {
                                        if(k == 0)
                                           kk = rap->numverts - 1;
                                        else
                                           kk = k - 1;
                                        xt1 = rap->x[kk];
                                        yt1 = rap->y[kk];
                                        z3 = rap->z[kk];
                                        xt2 = rap->x[k];
                                        yt2 = rap->y[k];
                                        z4 = rap->z[k];
                                        checkit = 1;
                                        if(ClipLineToRegion(minx,miny,maxx,maxy,
                                                &xt1,&yt1,&z3,&xt2,&yt2,&z4,&clipflag,multiplier) <= 0)
                                           checkit = 0;
            
                                        if(checkit > 0)
                                           {
                                           UMp = UMc = UMroot;
                                           while(UMc != NULL)
                                              {
                                              if(MatchAndModifyLinearSegment(UMc->x1, UMc->y1, UMc->x2, UMc->y2, xt1, yt1, xt2, yt2,
                                                   &MatchLen, &bx3, &by3,&bx4, &by4, &on0, &on1, &on2, &on3, LowerTolerance) > 0)
                                                 {
                                                 CoveredSoFar += MatchLen;
                                                 if(CoveredSoFar >= LenToCover)
                                                    break;
                                                 else
                                                    {
                                                    unusedint = on0 + on1 + on2 + on3;
                                                    if(unusedint == 3)
                                                       {
                                                       if(on0 == 0) /** then UMc->(x1,y1) is not on the rap segment **/
                                                          {
                                                          if(xt1 > UMc->x2)
                                                             bx1 = xt1 - UMc->x2;
                                                          else
                                                             bx1 = UMc->x2 - xt1;
                                                          if(yt1 > UMc->y2)
                                                             bx1 = bx1 + (yt1 - UMc->y2);
                                                          else
                                                             bx1 = bx1 + (UMc->y2 - yt1);
                                                          if(bx1 == 0)  /*** then (UMc->(x2,y2) == (xt1,yt1) ***/
                                                             {
                                                             UMc->x2 = xt2;
                                                             UMc->y2 = yt2;
                                                             }
                                                          else
                                                             {
                                                             if(xt2 > UMc->x2)
                                                                bx2 = xt2 - UMc->x2;
                                                             else
                                                                bx2 = UMc->x2 - xt2;
                                                             if(yt2 > UMc->y2)
                                                                bx2 = bx2 + (yt2 - UMc->y2);
                                                             else
                                                                bx2 = bx2 + (UMc->y2 - yt2);
                                                             if(bx1 < bx2)
                                                                {
                                                                UMc->x2 = xt2;
                                                                UMc->y2 = yt2;
                                                                }
                                                             else
                                                                {
                                                                UMc->x2 = xt1;
                                                                UMc->y2 = yt1;
                                                                }
                                                             }
                                                          }
                                                       else if(on1 == 0) /** then UMc->(x2,y2) is not on the rap segment **/
                                                          {
                                                          if(xt1 > UMc->x1)
                                                             bx1 = xt1 - UMc->x1;
                                                          else
                                                             bx1 = UMc->x1 - xt1;
                                                          if(yt1 > UMc->y1)
                                                             bx1 = bx1 + (yt1 - UMc->y1);
                                                          else
                                                             bx1 = bx1 + (UMc->y1 - yt1);
                                                          if(bx1 == 0)  /*** then (UMc->(x2,y2) == (xt1,yt1) ***/
                                                             {
                                                             UMc->x1 = xt2;
                                                             UMc->y1 = yt2;
                                                             }
                                                          else
                                                             {
                                                             if(xt2 > UMc->x1)
                                                                bx2 = xt2 - UMc->x1;
                                                             else
                                                                bx2 = UMc->x1 - xt2;
                                                             if(yt2 > UMc->y1)
                                                                bx2 = bx2 + (yt2 - UMc->y1);
                                                             else
                                                                bx2 = bx2 + (UMc->y1 - yt2);
                                                             if(bx1 < bx2)
                                                                {
                                                                UMc->x1 = xt2;
                                                                UMc->y1 = yt2;
                                                                }
                                                             else
                                                                {
                                                                UMc->x1 = xt1;
                                                                UMc->y1 = yt1;
                                                                }
                                                             }
                                                          }
                                                       }
                                                    else if(unusedint == 2)
                                                       {
                                                       if(xt1 > UMc->x1)
                                                          bx1 = xt1 - UMc->x1;
                                                       else
                                                          bx1 = UMc->x1 - xt1;
                                                       if(yt1 > UMc->y1)
                                                          bx1 = bx1 + (yt1 - UMc->y1);
                                                       else
                                                          bx1 = bx1 + (UMc->y1 - yt1);
                                                       if(xt2 > UMc->x1)
                                                          bx2 = xt2 - UMc->x1;
                                                       else
                                                          bx2 = UMc->x1 - xt2;
                                                       if(yt2 > UMc->y1)
                                                          bx2 = bx2 + (yt2 - UMc->y1);
                                                       else
                                                          bx2 = bx2 + (UMc->y1 - yt2);
                                                       if((on0 == 0) && (on1 == 0)) /** UMc->segment in middle of (xt,yt) segment **/
                                                          {
                                                          UMn = (struct UnMatched *) (malloc((SzUM)));
                                                          UMn->next = UMc->next;
                                                          UMc->next = UMn;
                                                          if(bx1 < bx2) /** the UMc->(x1,y1) is closer to (xt1,yt1) ***/
                                                             {
                                                             UMn->x1 = UMc->x2;
                                                             UMn->y1 = UMc->y2;
                                                             UMn->x2 = xt2;
                                                             UMn->y2 = yt2;
                                                             UMc->x2 = xt1;
                                                             UMc->y2 = yt1;
                                                             }
                                                          else
                                                             {
                                                             UMn->x1 = UMc->x2;
                                                             UMn->y1 = UMc->y2;
                                                             UMn->x2 = xt1;
                                                             UMn->y2 = yt1;
                                                             UMc->x2 = xt2;
                                                             UMc->y2 = yt2;
                                                             }
                                                          UMc = UMn;
                                                          }
                                                       else if((on0 == 1) && (on2 == 1)) /** overlap from ->(x1,y1) to (xt1,yt1) **/
                                                          {
                                                          UMc->x1 = xt1; UMc->y1 = yt1;
                                                          }
                                                       else if((on0 == 1) && (on3 == 1)) /** overlap from ->(x1,y1) to (xt2,yt2) **/
                                                          {
                                                          UMc->x1 = xt2; UMc->y1 = yt2;
                                                          }
                                                       else if((on1 == 1) && (on2 == 1)) /** overlap from ->(x2,y2) to (xt1,yt1) **/
                                                          {
                                                          UMc->x2 = xt1; UMc->y2 = yt1;
                                                          }
                                                       else if((on1 == 1) && (on3 == 1)) /** overlap from ->(x2,y2) to (xt2,yt2) **/
                                                          {
                                                          UMc->x2 = xt2; UMc->y2 = yt2;
                                                          }
                                                       }
                                                    }
                                                 }
                                              UMp = UMc;
                                              UMc = UMc->next;
                                              }
                                           }
                                        if(rap->RB_Tree_Edgelist != NULL)
                                           {
                                           k = GetNextArealIndex(rap, LastK, 1, &LastEdge3, cindex, &UsedTree);
                                           LastK = k;
                                           }
                                        else
                                           {
                                           ++k;
                                           if(k >= rap->numverts)
                                              k = -1;
                                           }
                                        } /** end looping thru k edges of rap ***/
                                     } /*** end found a part 2 feature ***/
                                  rap = rap->next;
                                  } /*** end while rap ***/
                               } /** end found bx1, by1, bx2, by2 that needs coverage ***/
                            if((CoveredSoFar < LenToCover) &&
                              ((LenToCover - CoveredSoFar) > LowerTolerance)) /** need to add a condition to the list ***/
                               {
                               UMc = UMroot;
                               while(UMc != NULL)
                                  {
                                  ERc = (struct collection *) (malloc(SzC));
                                  if(ERc == NULL)
                                    {
                                    printf("allocation memory exhausted during area feature boundary match analysis\n");
                                    printf("processing cannot continue\n");
                                    exit(-1);
                                    }
                                  ERc->x[0] = UMc->x1;
                                  ERc->y[0] = UMc->y1;
                                  ERc->z[0] = InterpLinearElev(rac->x[i], rac->y[i], rac->z[i],
                                            rac->x[ii], rac->y[ii], rac->z[ii],UMc->x1,UMc->y1);
                                  ERc->x[1] = UMc->x2;
                                  ERc->y[1] = UMc->y2;
                                  ERc->z[1] = InterpLinearElev(rac->x[i], rac->y[i], rac->z[i],
                                            rac->x[ii], rac->y[ii], rac->z[ii],UMc->x2,UMc->y2);
                                  ERc->IDN = rac->idn;
                                  ERc->Sindex = rac->Sindex;
                                  ERc->aa = rac; /** RawAreal **/
                                  ERc->aa2 = NULL;
                                  ERc->bb = NULL; /** RawBridge **/
                                  ERc->pp = NULL; /** RawPoint **/
                                  ERc->le = NULL; /** ListOfEdges **/
                                  ERc->poly = NULL; /** ThePolys **/
                                  ERc->keyval = AUNM_ACRS_A;
                                  ERc->Cnumber = Make_Correct(AUNM_ACRS_A,checkinstance);

                                  if(ERroot == NULL)
                                     {
                                     ERroot = ERc;
                                     ERroot->next = NULL;
                                     }
                                  else
                                     {
                                     ERn = ERroot;
                                     while(ERn != NULL)
                                        {
                                        if((ERn->keyval == ERc->keyval) && (ERc->Cnumber == ERn->Cnumber))
                                           {
                                           if(ERn->aa == ERc->aa)
                                              {
                                              if((ERc->x[0] == ERn->x[0]) && (ERc->y[0] == ERn->y[0]) &&
                                                            (ERc->z[0] == ERn->z[0]))
                                                 {
                                                 if((ERc->x[1] == ERn->x[1]) && (ERc->y[1] == ERn->y[1]) &&
                                                      (ERc->z[1] == ERn->z[1]))
                                                    break;
                                                 }
                                              else if((ERc->x[0] == ERn->x[1]) && (ERc->y[0] == ERn->y[1]) &&
                                                            (ERc->z[0] == ERn->z[1]))
                                                 {
                                                 if((ERc->x[1] == ERn->x[0]) && (ERc->y[1] == ERn->y[0]) &&
                                                            (ERc->z[1] == ERn->z[0]))
                                                    break;
                                                 }
                                              }
                                           }
                                        ERn = ERn->next;
                                        }
                                     if(ERn == NULL)
                                        {
                                        ERc->next = ERroot;
                                        ERroot = ERc;
                                        }
                                     else
                                        {
                                        free(ERc);
                                        }
                                     }
                                  UMp = UMc;
                                  UMc = UMc->next;
                                  free(UMp);
                                  }  /** end while UMc != NULL ***/
                               UMroot = NULL;
                               }
                            else
                               {
                               UMc = UMroot;
                               while(UMc != NULL)
                                  {
                                  UMp = UMc;
                                  UMc = UMc->next;
                                  free(UMp);
                                  }  /** end while UMc != NULL ***/
                               UMroot = NULL;
                               }
                               
                            if(ran->RB_Tree_Edgelist != NULL)
                               {
                               j = GetNextArealIndex(ran, LastJ, 1, &LastEdge2, cindex, &UsedTree);
                               LastJ = j;
                               }
                            else
                               {
                               ++j;
                               if(j >= ran->numverts)
                                  j = -1;
                               }
                            }


                         } /** end found a part3 feature  ***/
                      //if(CoveredSoFar >= LenToCover)
                         //break;
                      ran = ran->next;
                      } /*** while ran != NULL ***/
                   } /** end if checking rac->edge[i] ****/
                if(rac->RB_Tree_Edgelist != NULL)
                   {
                   i = GetNextArealIndex(rac, LastI, 1, &LastEdge1, cindex, &UsedTree);
                   LastI = i;
                   }
                else
                   {
                   ++i;
                   if(i >= rac->numverts)
                      i = -1;
                   }
                } /*** while i >= 0 ***/
             } /*** end AUNM_ACRS_A check applies  to rac ***/




         } /*** end for checkinstance with area features ***/
      rac = rac->next;
      }

   ERc = ERroot;
   while(ERc != NULL)
      {
      switch(ERc->keyval)
         {
         case LRNGE_UNM_LAT:
         case LRNGE_UNM_LON:
               FwriteMagnitudeAndTwoObjects(ERc->keyval, ERc->Cnumber,ERc->magnitude,
                      ERc->Sindex, G_LINE, ERc->ll1->Lindex,ERc->ll1->localID,
                      ERc->ll1->idn,10.0,-1.0,&ERc->x[0],&ERc->y[0],&ERc->z[0],2,
                      ERc->ll2->Sindex,G_LINE,ERc->ll2->Lindex,ERc->ll2->localID,
                               ERc->ll2->idn,10.0,-1.0,&ERc->ll2->x[ERc->vertexindex2],
                               &ERc->ll2->y[ERc->vertexindex2],&ERc->ll2->z[ERc->vertexindex2],2);
            break;

         case LE_A_UNM_LAT:
         case LE_A_UNM_LON:
         case LHANG_LAT:
         case LHANG_LON:
            FwritePointAndObject(ERc->keyval,ERc->Cnumber,ERc->x[0],ERc->y[0],ERc->z[0], -1,
                       ERc->Sindex, G_LINE, ERc->ll1->Lindex,ERc->ll1->localID,
                          ERc->ll1->idn,10.0, 0.0,ERc->x, ERc->y, ERc->z, 2);
            break;

         case AUNM_ACRS_A:
         case AHANG_LAT:
         case AHANG_LON:
            FwriteObject(ERc->keyval,ERc->Cnumber, ERc->aa->Lindex, ERc->Sindex, G_AREAL, ERc->aa->localID,
                          ERc->aa->idn, -1.0, -1.0, &ERc->x[0], &ERc->y[0], &ERc->z[0] ,2, 1);
            break;

         case ARNGE_UNM_LAT:
         case ARNGE_UNM_LON:
            break;

         default:
            printf("unrecognized key condition flag received during linear feature analysis\n");
            break;
         }
      ERn = ERc;
      ERc = ERc->next;
      free(ERn);
      }


}

int EdgesOverlap(double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4,
                     double *cx1, double *cy1, double *cx2, double *cy2, int *bothmatch, double ptltolerance)
{
double ptldist;
int answer;
int i;
double minx12,maxx12,miny12,maxy12;
double minx34,maxx34,miny34,maxy34;

   answer = 0;
   *bothmatch = 0;

   if((x1 == x3) && (y1 == y3) && (x2 == x4) && (y2 == y4))
      {
      answer = 2;
      *bothmatch = 1;
      *cx1 = x1;
      *cy1 = y1;
      *cx2 = x2;
      *cy2 = y2;
      }
   else if((x2 == x3) && (y2 == y3) && (x1 == x4) && (y1 == y4))
      {
      answer = 2;
      *bothmatch = 1;
      *cx1 = x1;
      *cy1 = y1;
      *cx2 = x2;
      *cy2 = y2;
      }
   else if((x1 == x3) && (y1 == y3))
      {
      ++answer;
      *cx1 = x1;
      *cy1 = y1;
      ptldist = ApproxPointToLineDist2D(x2,y2, x3,y3,x4,y4);
      if(ptldist < ptltolerance)
         {
         ++answer;
         *cx2 = x2;
         *cy2 = y2;
         }
      else
         {
         ptldist = ApproxPointToLineDist2D(x4,y4, x1,y1,x2,y2);
         if(ptldist < ptltolerance)
            {
            ++answer;
            *cx2 = x4;
            *cy2 = y4;
            }
         }
      }
   else if((x1 == x4) && (y1 == y4))
      {
      ++answer;
      *cx1 = x1;
      *cy1 = y1;
      ptldist = ApproxPointToLineDist2D(x2,y2, x3,y3,x4,y4);
      if(ptldist < ptltolerance)
         {
         ++answer;
         *cx2 = x2;
         *cy2 = y2;
         }
      else
         {
         ptldist = ApproxPointToLineDist2D(x3,y3, x1,y1,x2,y2);
         if(ptldist < ptltolerance)
            {
            ++answer;
            *cx2 = x3;
            *cy2 = y3;
            }
         }
      }
   else if((x2 == x4) && (y2 == y4))
      {
      ++answer;
      *cx1 = x2;
      *cy1 = y2;
      ptldist = ApproxPointToLineDist2D(x1,y1, x3,y3,x4,y4);
      if(ptldist < ptltolerance)
         {
         ++answer;
         *cx2 = x1;
         *cy2 = y1;
         }
      else
         {
         ptldist = ApproxPointToLineDist2D(x3,y3, x1,y1,x2,y2);
         if(ptldist < ptltolerance)
            {
            ++answer;
            *cx2 = x3;
            *cy2 = y3;
            }
         }
      }
   else if((x2 == x3) && (y2 == y3))
      {
      ++answer;
      *cx1 = x2;
      *cy1 = y2;
      ptldist = ApproxPointToLineDist2D(x1,y1, x3,y3,x4,y4);
      if(ptldist < ptltolerance)
         {
         ++answer;
         *cx2 = x1;
         *cy2 = y1;
         }
      else
         {
         ptldist = ApproxPointToLineDist2D(x4,y4, x1,y1,x2,y2);
         if(ptldist < ptltolerance)
            {
            ++answer;
            *cx2 = x4;
            *cy2 = y4;
            }
         }
      }
   else
      {
      i = 0;
      if(x1 < x2)
         {
         minx12 = x1;
         maxx12 = x2;
         }
      else
         {
         minx12 = x2;
         maxx12 = x1;
         }
      if(y1 < y2)
         {
         miny12 = y1;
         maxy12 = y2;
         }
      else
         {
         miny12 = y2;
         maxy12 = y1;
         }

      if(x3 < x4)
         {
         minx34 = x3;
         maxx34 = x4;
         }
      else
         {
         minx34 = x4;
         maxx34 = x3;
         }
      if(y3 < y4)
         {
         miny34 = y3;
         maxy34 = y4;
         }
      else
         {
         miny34 = y4;
         maxy34 = y3;
         }

      minx12 -= ptltolerance;
      minx34 -= ptltolerance;
      miny12 -= ptltolerance;
      miny34 -= ptltolerance;
      maxx12 += ptltolerance;
      maxx34 += ptltolerance;
      maxy12 += ptltolerance;
      maxy34 += ptltolerance;

      if((x4 >= minx12) && (x4 <= maxx12) && (y4 >= miny12) && (y4 <= maxy12))
         {
         ptldist = ApproxPointToLineDist2D(x4,y4, x1,y1,x2,y2);
         if(ptldist < ptltolerance)
            {
            ++answer;
            *cx1 = x4;
            *cy1 = y4;
            ++i;
            }
         }

      if((x3 >= minx12) && (x3 <= maxx12) && (y3 >= miny12) && (y3 <= maxy12))
         {
         ptldist = ApproxPointToLineDist2D(x3,y3, x1,y1,x2,y2);
         if(ptldist < ptltolerance)
            {
            ++answer;
            if(i == 0)
               {
               *cx1 = x3;
               *cy1 = y3;
               }
            else
               {
               *cx2 = x3;
               *cy2 = y3;
               }
            ++i;
            }
         }

      if(i < 2)
         {
         if((x1 >= minx34) && (x1 <= maxx34) && (y1 >= miny34) && (y1 <= maxy34))
            {
            ptldist = ApproxPointToLineDist2D(x1,y1, x3,y3,x4,y4);
            if(ptldist < ptltolerance)
               {
               ++answer;
               if(i == 0)
                  {
                  *cx1 = x1;
                  *cy1 = y1;
                  }
               else
                  {
                  *cx2 = x1;
                  *cy2 = y1;
                  }
               ++i;
               }
            }
         if( i < 2)
            {
            if((x2 >= minx34) && (x2 <= maxx34) && (y2 >= miny34) && (y2 <= maxy34))
               {
               ptldist = ApproxPointToLineDist2D(x2,y2, x3,y3,x4,y4);
               if(ptldist < ptltolerance)
                  {
                  ++answer;
                  if(i == 0)
                     {
                     *cx1 = x2;
                     *cy1 = y2;
                     }
                  else
                     {
                     *cx2 = x2;
                     *cy2 = y2;
                     }
                  ++i;
                  }
               }
            }

         }
      }

   return(answer);
}




int TwoArealsIntersect(struct RawAreal *A, struct RawAreal *B,
                               double *xi, double *yi, int *Aindex, int *Bindex, int *ArealsTouch)
{
int i,j,k, ci1, ci2;
int ii,jj;
int kk, kkminus, kkplus;
/***int ti1,ti2,tj1,tj2;***/
double xint;
double yint;
double xi1,yi1;
double xi2,yi2;
double minx,maxx,miny,maxy;
double unuseddbl;
int answer;
int bothmatch;
int MYI;
int share_edge, share_vertex;
int numattempts, numsuccess;
int onedge, onedge2;
int DoTheTest;
struct RB_Edgelist * LastEdge1;
struct RB_Edgelist * LastEdge2;
int cindex1, cindex2;
int LastI, LastJ, UsedTree, unusedint;

   answer = 0;
   MYI = MaxYindex + 1;
   numattempts = 0;
   numsuccess = 0;
   onedge = 0;

   share_edge = share_vertex = 0;

   for(i=0; i<A->numverts; i++)
      {
      Areal1ForIntersections[i] = 0;
      Areal1Shared[i] = -1;
      }

   for(i=0; i<B->numverts; i++)
      {
      Areal2ForIntersections[i] = 0;
      Areal2Shared[i] = -1;
      }

   if((A->RB_Tree_Edgelist == NULL) && (B->RB_Tree_Edgelist == NULL)) /* two non-large areals **/
      {
/***** new GAIT22 here ***/
      for(i=0; i<A->numverts; i++)
         {
         if(i == 0)
            ii = A->numverts - 1;
         else
            ii = i - 1;

         for(j=0; j<B->numverts; j++)
            {
            if(j == 0)
               jj = B->numverts - 1;
            else
               jj = j - 1;

            if((A->x[i] == B->x[j]) && (A->y[i] == B->y[j]))
               {
               Areal1Shared[i] = j;
               Areal2Shared[j] = i;
               }
            else if((A->x[i] == B->x[jj]) && (A->y[i] == B->y[jj]))
               {
               Areal1Shared[i] = jj;
               Areal2Shared[jj] = i;
               }
            else if((A->x[ii] == B->x[j]) && (A->y[ii] == B->y[j]))
               {
               Areal1Shared[ii] = j;
               Areal2Shared[j] = ii;
               }
            }
         }

      for(i=0; i<A->numverts; i++)
         {
         if(i == 0)
            ii = A->numverts - 1;
         else
            ii = i - 1;

         if(A->x[i] < A->x[ii])
            {
            minx = A->x[i];
            maxx = A->x[ii];
            }
         else
            {
            minx = A->x[ii];
            maxx = A->x[i];
            }
         if(A->y[i] < A->y[ii])
            {
            miny = A->y[i];
            maxy = A->y[ii];
            }
         else
            {
            miny = A->y[ii];
            maxy = A->y[i];
            }

         ++numattempts;

         for(j=0; j<B->numverts; j++)
            {
            if(j == 0)
               jj = B->numverts - 1;
            else
               jj = j - 1;

            DoTheTest = 0;
            if(B->x[j] < B->x[jj])
               {
               if((B->x[j] <= maxx) && (B->x[jj] >= minx))
                   {
                   if(B->y[j] < B->y[jj])
                      {
                      if((B->y[j] <= maxy) && (B->y[jj] >= miny))
                         DoTheTest = 1;
                      }
                   else if((B->y[jj] <= maxy) && (B->y[j] >= miny))
                      {
                      DoTheTest = 1;
                      }
                   }
               }
            else if((B->x[jj] <= maxx) && (B->x[j] >= minx))
                {
                if(B->y[j] < B->y[jj])
                   {
                   if((B->y[j] <= maxy) && (B->y[jj] >= miny))
                      DoTheTest = 1;
                   }
                else if((B->y[jj] <= maxy) && (B->y[j] >= miny))
                   {
                   DoTheTest = 1;
                   }
                }

            if(DoTheTest > 0)
               {
               onedge = EdgesOverlap(A->x[ii], A->y[ii], A->x[i], A->y[i],
                                B->x[jj],B->y[jj],B->x[j],B->y[j], &xi1, &yi1, &xi2, &yi2, &bothmatch, PTLTOLERANCE);
               numsuccess += onedge;

               if((onedge == 2) && (bothmatch < 1))
                  {
                  if((Areal1Shared[ii] < 0) && (xi1 == A->x[ii]) && (yi1 == A->y[ii]))
                     {
                     Areal1Shared[ii] = B->numverts + 2;
                     }
                  if((Areal1Shared[i] < 0) && (xi1 == A->x[i]) && (yi1 == A->y[i]))
                     {
                     Areal1Shared[i] = B->numverts + 2;
                     }

                  if((Areal1Shared[ii] < 0) && (xi2 == A->x[ii]) && (yi2 == A->y[ii]))
                     {
                     Areal1Shared[ii] = B->numverts + 2;
                     }
                  if((Areal1Shared[i] < 0) && (xi2 == A->x[i]) && (yi2 == A->y[i]))
                     {
                     Areal1Shared[i] = B->numverts + 2;
                     }


                  if((Areal2Shared[jj] < 0) && (xi1 == B->x[jj]) && (yi1 == B->y[jj]))
                     {
                     Areal2Shared[jj] = A->numverts + 2;
                     }
                  if((Areal2Shared[j] < 0) && (xi1 == B->x[j]) && (yi1 == B->y[j]))
                     {
                     Areal2Shared[j] = A->numverts + 2;
                     }

                  if((Areal2Shared[jj] < 0) && (xi2 == B->x[jj]) && (yi2 == B->y[jj]))
                     {
                     Areal2Shared[jj] = A->numverts + 2;
                     }
                  if((Areal2Shared[j] < 0) && (xi2 == B->x[j]) && (yi2 == B->y[j]))
                     {
                     Areal2Shared[j] = A->numverts + 2;
                     }
                  }

               if(onedge == 0)
                  {
                  if(LineSegmentsIntersect(A->x[ii], A->y[ii], A->x[i], A->y[i],
                                B->x[jj],B->y[jj],B->x[j],B->y[j], &xint, &yint) > 0)
                     {
                     *Aindex = i;
                     *Bindex = j;
                     *xi = xint;
                     *yi = yint;
                     answer = 1;
                     break;
                     }
                  }
               else if(onedge == 2)
                  {
                  ++share_edge;
                  if((xi1 == A->x[ii]) && (yi1 == A->y[ii]))
                     {
                     if((xi2 == A->x[i]) && (yi2 == A->y[i]))
                        Areal1ForIntersections[i] = 2;
                     else if(Areal1ForIntersections[i] != 2)
                        Areal1ForIntersections[i] = 3 + j;
                     }
                  else if((xi1 == A->x[i]) && (yi1 == A->y[i]))
                     {
                     if((xi2 == A->x[ii]) && (yi2 == A->y[ii]))
                        Areal1ForIntersections[i] = 2;
                     else if(Areal1ForIntersections[i] != 2)
                        Areal1ForIntersections[i] = 3 + j;
                     }

                  if((xi1 == B->x[jj]) && (yi1 == B->y[jj]))
                     {
                     if((xi2 == B->x[j]) && (yi2 == B->y[j]))
                        Areal2ForIntersections[j] = 2;
                     else if(Areal2ForIntersections[j] != 2)
                        Areal2ForIntersections[j] = 3 + i;
                     }
                  else if((xi1 == B->x[j]) && (yi1 == B->y[j]))
                     {
                     if((xi2 == B->x[jj]) && (yi2 == B->y[jj]))
                        Areal2ForIntersections[j] = 2;
                     else if(Areal2ForIntersections[j] != 2)
                        Areal2ForIntersections[j] = 3 + i;
                     }
                  }
               else if(onedge == 1)
                  {
                  if((Areal1ForIntersections[i] == 0) && (xi1 == A->x[i]) && (yi1 == A->y[i]))
                     {
                     Areal1ForIntersections[i] = 1;
                     }
                  if((Areal2ForIntersections[j] == 0) && (xi1 == B->x[j]) && (yi1 == B->y[j]))
                     {
                     Areal2ForIntersections[j] = 1;
                     }
                  }
               }
            }
         if(answer > 0)
            break;
         else
            {
            for(kk = 0; kk < B->numverts; kk++)
               {
               if((Areal2ForIntersections[kk] == 1) && (Areal2Shared[kk] <= 0))
                  {
                  if(kk == 0)
                     kkminus = B->numverts - 1;
                  else
                     kkminus = kk -1;
      
                  if((Areal2ForIntersections[kkminus] == 0) && (Areal2Shared[kkminus] <= 0))
                     {
                     kkplus = kk + 1;
                     if(kkplus >= B->numverts)
                        kkplus = 0;
                     if((Areal2ForIntersections[kkplus] == 0) && (Areal2Shared[kkplus] <= 0))
                        {
                        if(TwoPointsOnSameSideOfLineSegment(B->x[kkminus],B->y[kkminus],B->x[kkplus],B->y[kkplus],
                                 A->x[ii],A->y[ii],A->x[i],A->y[i]) == 0)
                           {
                           *Aindex = i;
                           *Bindex = kk;
                           *xi = B->x[kk];
                           *yi = B->y[kk];
                           answer = 1;
                           break;
                           }
                        }
                     }
                  }
               }
            }

         }
      }  /*** end if have two non-large areals **/

   else if((A->RB_Tree_Edgelist != NULL) && (B->RB_Tree_Edgelist == NULL))
      {
      LastEdge1 = NULL;
      LastI = -1;

      for(j=0; j<B->numverts; j++)
         {
         if(j == 0)
            jj = B->numverts - 1;
         else
            jj = j - 1;

         if(B->x[j] < B->x[jj])
            {
            minx = B->x[j];
            maxx = B->x[jj];
            }
         else
            {
            minx = B->x[jj];
            maxx = B->x[j];
            }
         if(B->y[j] < B->y[jj])
            {
            miny = B->y[j];
            maxy = B->y[jj];
            }
         else
            {
            miny = B->y[jj];
            maxy = B->y[j];
            }

         ++numattempts;

         ci1 = (int) (B->x[j] / RegionSize);
         ci2 = (int) (B->y[j] / RegionSize);

         cindex1 = (ci1 * MYI) + ci2;

         ci1 = (int) (B->x[jj] / RegionSize);
         ci2 = (int) (B->y[jj] / RegionSize);

         cindex2 = (ci1 * MYI) + ci2;

         if(cindex2 < cindex1)
            {
            ci1 = cindex2;
            cindex2 = cindex1;
            cindex1 = ci1;
            }

         LastEdge1 = NULL;
         LastI = -1;
         for(ci1=cindex1; ci1<=cindex2; ci1++)
            {
            i = GetNextArealIndex(A, LastI, 1, &LastEdge1, ci1, &UsedTree);
            LastI = i;

            while(i >= 0)
               {
               if(i == 0)
                  ii = A->numverts - 1;
               else
                  ii = i - 1;
               if((A->x[i] == B->x[j]) && (A->y[i] == B->y[j]))
                  {
                  Areal1Shared[i] = j;
                  Areal2Shared[j] = i;
                  }
               else if((A->x[i] == B->x[jj]) && (A->y[i] == B->y[jj]))
                  {
                  Areal1Shared[i] = jj;
                  Areal2Shared[jj] = i;
                  }
               else if((A->x[ii] == B->x[j]) && (A->y[ii] == B->y[j]))
                  {
                  Areal1Shared[ii] = j;
                  Areal2Shared[j] = ii;
                  }


               DoTheTest = 0;
               if(A->x[i] < A->x[ii])
                  {
                  if((A->x[i] <= maxx) && (A->x[ii] >= minx))
                      {
                      if(A->y[i] < A->y[ii])
                         {
                         if((A->y[i] <= maxy) && (A->y[ii] >= miny))
                            DoTheTest = 1;
                         }
                      else if((A->y[ii] <= maxy) && (A->y[i] >= miny))
                         {
                         DoTheTest = 1;
                         }
                      }
                  }
               else if((A->x[ii] <= maxx) && (A->x[i] >= minx))
                   {
                   if(A->y[i] < A->y[ii])
                      {
                      if((A->y[i] <= maxy) && (A->y[ii] >= miny))
                         DoTheTest = 1;
                      }
                   else if((A->y[ii] <= maxy) && (A->y[i] >= miny))
                      {
                      DoTheTest = 1;
                      }
                   }

               if(DoTheTest > 0)
                  {
                  onedge = EdgesOverlap(A->x[ii], A->y[ii], A->x[i], A->y[i],
                                B->x[jj],B->y[jj],B->x[j],B->y[j], &xi1, &yi1, &xi2, &yi2, &bothmatch, PTLTOLERANCE);
                  numsuccess += onedge;

                  if((onedge == 2) && (bothmatch < 1))
                     {
                     if((Areal1Shared[ii] < 0) && (xi1 == A->x[ii]) && (yi1 == A->y[ii]))
                        {
                        Areal1Shared[ii] = B->numverts + 2;
                        }
                     if((Areal1Shared[i] < 0) && (xi1 == A->x[i]) && (yi1 == A->y[i]))
                        {
                        Areal1Shared[i] = B->numverts + 2;
                        }

                     if((Areal1Shared[ii] < 0) && (xi2 == A->x[ii]) && (yi2 == A->y[ii]))
                        {
                        Areal1Shared[ii] = B->numverts + 2;
                        }
                     if((Areal1Shared[i] < 0) && (xi2 == A->x[i]) && (yi2 == A->y[i]))
                        {
                        Areal1Shared[i] = B->numverts + 2;
                        }


                     if((Areal2Shared[jj] < 0) && (xi1 == B->x[jj]) && (yi1 == B->y[jj]))
                        {
                        Areal2Shared[jj] = A->numverts + 2;
                        }
                     if((Areal2Shared[j] < 0) && (xi1 == B->x[j]) && (yi1 == B->y[j]))
                        {
                        Areal2Shared[j] = A->numverts + 2;
                        }

                     if((Areal2Shared[jj] < 0) && (xi2 == B->x[jj]) && (yi2 == B->y[jj]))
                        {
                        Areal2Shared[jj] = A->numverts + 2;
                        }
                     if((Areal2Shared[j] < 0) && (xi2 == B->x[j]) && (yi2 == B->y[j]))
                        {
                        Areal2Shared[j] = A->numverts + 2;
                        }
                     }


                  if(onedge == 0)
                     {
                     if(LineSegmentsIntersect(A->x[ii], A->y[ii], A->x[i], A->y[i],
                                   B->x[jj],B->y[jj],B->x[j],B->y[j], &xint, &yint) > 0)
                        {
                        *Aindex = i;
                        *Bindex = j;
                        *xi = xint;
                        *yi = yint;
                        answer = 1;
                        break;
                        }
                     }
                  else if(onedge == 2)
                     {
                     ++share_edge;
                     if((xi1 == A->x[ii]) && (yi1 == A->y[ii]))
                        {
                        if((xi2 == A->x[i]) && (yi2 == A->y[i]))
                           Areal1ForIntersections[i] = 2;
                        else if(Areal1ForIntersections[i] != 2)
                           Areal1ForIntersections[i] = 3 + j;
                        }
                     else if((xi1 == A->x[i]) && (yi1 == A->y[i]))
                        {
                        if((xi2 == A->x[ii]) && (yi2 == A->y[ii]))
                           Areal1ForIntersections[i] = 2;
                        else if(Areal1ForIntersections[i] != 2)
                           Areal1ForIntersections[i] = 3 + j;
                        }

                     if((xi1 == B->x[jj]) && (yi1 == B->y[jj]))
                        {
                        if((xi2 == B->x[j]) && (yi2 == B->y[j]))
                           Areal2ForIntersections[j] = 2;
                        else if(Areal2ForIntersections[j] != 2)
                           Areal2ForIntersections[j] = 3 + i;
                        }
                     else if((xi1 == B->x[j]) && (yi1 == B->y[j]))
                        {
                        if((xi2 == B->x[jj]) && (yi2 == B->y[jj]))
                           Areal2ForIntersections[j] = 2;
                        else if(Areal2ForIntersections[j] != 2)
                           Areal2ForIntersections[j] = 3 + i;
                        }
                     }
                  else if(onedge == 1)
                     {
                     if((Areal1ForIntersections[i] == 0) && (xi1 == A->x[i]) && (yi1 == A->y[i]))
                        {
                        Areal1ForIntersections[i] = 1;
                        Areal1Shared[i] = j;
                        }
                     if((Areal2ForIntersections[j] == 0) && (xi1 == B->x[j]) && (yi1 == B->y[j]))
                        {
                        Areal2ForIntersections[j] = 1;
                        Areal2Shared[j] = i;
                        }
                     }
                  }  /*** end if(DoTheTest > 0) ****/
               if(answer > 0)
                  break;
               i = GetNextArealIndex(A, LastI, 1, &LastEdge1, ci1, &UsedTree);
               LastI = i;
               } /*** end while(i >= 0) ***/
            }  /**** end for(ci1=cindex1; ci1<=cindex2; ci1++) ***/
         if(answer > 0)
            break;
         }  /**** for(j=0; j<B->numverts; j++) ****/
      }  /*** end if A is large and B is not **/

   else if((B->RB_Tree_Edgelist != NULL) && (A->RB_Tree_Edgelist == NULL))
      {
      LastEdge1 = NULL;
      LastI = -1;
      
      for(j=0; j<A->numverts; j++)
         {
         if(j == 0)
            jj = A->numverts - 1;
         else
            jj = j - 1;

         if(A->x[j] < A->x[jj])
            {
            minx = A->x[j];
            maxx = A->x[jj];
            }
         else
            {
            minx = A->x[jj];
            maxx = A->x[j];
            }
         if(A->y[j] < A->y[jj])
            {
            miny = A->y[j];
            maxy = A->y[jj];
            }
         else
            {
            miny = A->y[jj];
            maxy = A->y[j];
            }

         ++numattempts;

         ci1 = (int) (A->x[j] / RegionSize);
         ci2 = (int) (A->y[j] / RegionSize);

         cindex1 = (ci1 * MYI) + ci2;

         ci1 = (int) (A->x[jj] / RegionSize);
         ci2 = (int) (A->y[jj] / RegionSize);

         cindex2 = (ci1 * MYI) + ci2;

         if(cindex2 < cindex1)
            {
            ci1 = cindex2;
            cindex2 = cindex1;
            cindex1 = ci1;
            }

         LastEdge1 = NULL;
         LastI = -1;
         for(ci1=cindex1; ci1<=cindex2; ci1++)
            {
            i = GetNextArealIndex(B, LastI, 1, &LastEdge1, ci1, &UsedTree);
            LastI = i;

            while(i >= 0)
               {
               if(i == 0)
                  ii = B->numverts - 1;
               else
                  ii = i - 1;

               if((A->x[j] == B->x[i]) && (A->y[j] == B->y[i]))
                  {
                  Areal1Shared[j] = i;
                  Areal2Shared[i] = j;
                  }
               else if((A->x[j] == B->x[ii]) && (A->y[j] == B->y[ii]))
                  {
                  Areal1Shared[j] = ii;
                  Areal2Shared[ii] = j;
                  }
               else if((A->x[jj] == B->x[i]) && (A->y[jj] == B->y[i]))
                  {
                  Areal1Shared[jj] = i;
                  Areal2Shared[i] = jj;
                  }


               DoTheTest = 0;
               if(B->x[i] < B->x[ii])
                  {
                  if((B->x[i] <= maxx) && (B->x[ii] >= minx))
                      {
                      if(B->y[i] < B->y[ii])
                         {
                         if((B->y[i] <= maxy) && (B->y[ii] >= miny))
                            DoTheTest = 1;
                         }
                      else if((B->y[ii] <= maxy) && (B->y[i] >= miny))
                         {
                         DoTheTest = 1;
                         }
                      }
                  }
               else if((B->x[ii] <= maxx) && (B->x[i] >= minx))
                   {
                   if(B->y[i] < B->y[ii])
                      {
                      if((B->y[i] <= maxy) && (B->y[ii] >= miny))
                         DoTheTest = 1;
                      }
                   else if((B->y[ii] <= maxy) && (B->y[i] >= miny))
                      {
                      DoTheTest = 1;
                      }
                   }

               if(DoTheTest > 0)
                  {
                  onedge = EdgesOverlap(B->x[ii], B->y[ii], B->x[i], B->y[i],
                                A->x[jj],A->y[jj],A->x[j],A->y[j], &xi1, &yi1, &xi2, &yi2, &bothmatch, PTLTOLERANCE);
                  numsuccess += onedge;

                  if((onedge == 2) && (bothmatch < 1))
                     {
                     if((Areal1Shared[jj] < 0) && (xi1 == A->x[jj]) && (yi1 == A->y[jj]))
                        {
                        Areal1Shared[jj] = B->numverts + 2;
                        }
                     if((Areal1Shared[j] < 0) && (xi1 == A->x[j]) && (yi1 == A->y[j]))
                        {
                        Areal1Shared[j] = B->numverts + 2;
                        }

                     if((Areal1Shared[jj] < 0) && (xi2 == A->x[jj]) && (yi2 == A->y[jj]))
                        {
                        Areal1Shared[jj] = B->numverts + 2;
                        }
                     if((Areal1Shared[j] < 0) && (xi2 == A->x[j]) && (yi2 == A->y[j]))
                        {
                        Areal1Shared[j] = B->numverts + 2;
                        }


                     if((Areal2Shared[ii] < 0) && (xi1 == B->x[ii]) && (yi1 == B->y[ii]))
                        {
                        Areal2Shared[ii] = A->numverts + 2;
                        }
                     if((Areal2Shared[i] < 0) && (xi1 == B->x[i]) && (yi1 == B->y[i]))
                        {
                        Areal2Shared[i] = A->numverts + 2;
                        }

                     if((Areal2Shared[ii] < 0) && (xi2 == B->x[ii]) && (yi2 == B->y[ii]))
                        {
                        Areal2Shared[ii] = A->numverts + 2;
                        }
                     if((Areal2Shared[i] < 0) && (xi2 == B->x[i]) && (yi2 == B->y[i]))
                        {
                        Areal2Shared[i] = A->numverts + 2;
                        }
                     }


                  if(onedge == 0)
                     {
                     if(LineSegmentsIntersect(B->x[ii], B->y[ii], B->x[i], B->y[i],
                                   A->x[jj],A->y[jj],A->x[j],A->y[j], &xint, &yint) > 0)
                        {
                        *Bindex = i;
                        *Aindex = j;
                        *xi = xint;
                        *yi = yint;
                        answer = 1;
                        break;
                        }
                     }
                  else if(onedge == 2)
                     {
                     ++share_edge;
                     if((xi1 == B->x[ii]) && (yi1 == B->y[ii]))
                        {
                        if((xi2 == B->x[i]) && (yi2 == B->y[i]))
                           Areal2ForIntersections[i] = 2;
                        else if(Areal2ForIntersections[i] != 2)
                           Areal2ForIntersections[i] = 3 + j;
                        }
                     else if((xi1 == B->x[i]) && (yi1 == B->y[i]))
                        {
                        if((xi2 == B->x[ii]) && (yi2 == B->y[ii]))
                           Areal2ForIntersections[i] = 2;
                        else if(Areal2ForIntersections[i] != 2)
                           Areal2ForIntersections[i] = 3 + j;
                        }

                     if((xi1 == A->x[jj]) && (yi1 == A->y[jj]))
                        {
                        if((xi2 == A->x[j]) && (yi2 == A->y[j]))
                           Areal1ForIntersections[j] = 2;
                        else if(Areal1ForIntersections[j] != 2)
                           Areal1ForIntersections[j] = 3 + i;
                        }
                     else if((xi1 == A->x[j]) && (yi1 == A->y[j]))
                        {
                        if((xi2 == A->x[jj]) && (yi2 == A->y[jj]))
                           Areal1ForIntersections[j] = 2;
                        else if(Areal1ForIntersections[j] != 2)
                           Areal1ForIntersections[j] = 3 + i;
                        }
                     }
                  else if(onedge == 1)
                     {
                     if((Areal2ForIntersections[i] == 0) && (xi1 == B->x[i]) && (yi1 == B->y[i]))
                        {
                        Areal2ForIntersections[i] = 1;
                        Areal2Shared[i] = j;
                        }
                     if((Areal1ForIntersections[j] == 0) && (xi1 == A->x[j]) && (yi1 == A->y[j]))
                        {
                        Areal1ForIntersections[j] = 1;
                        Areal1Shared[j] = i;
                        }
                     }
                  }  /*** end if(DoTheTest > 0) ****/
               if(answer > 0)
                  break;
               i = GetNextArealIndex(B, LastI, 1, &LastEdge1, ci1, &UsedTree);
               LastI = i;
               } /*** end while(i >= 0) ***/
            }  /**** end for(ci1=cindex1; ci1<=cindex2; ci1++) ***/
         if(answer > 0)
            break;
         }  /**** for(j=0; j<A->numverts; j++) ****/
      }  /*** end if B is large and A is not **/


   else if((A->RB_Tree_Edgelist != NULL) && (B->RB_Tree_Edgelist != NULL))
      {
      numattempts = numsuccess = 0;

      if(A->firstindex > B->firstindex)
         cindex1 = A->firstindex;
      else
         cindex1 = B->firstindex;

      if((A->ismulti <= 0) && (B->ismulti <= 0))
         {
         printf("attempt to intersect two single region area features with large area feature logic\n");
         printf("forced exit\n");
         exit(-1);
         }
      if(A->ismulti < B->ismulti)
         cindex2 = A->ismulti;
      else
         cindex2 = B->ismulti;

      for(ci1=cindex1; ci1 <=cindex2; ci1++)
         {
         LastJ = -1;
         LastEdge2 = NULL;
         j = GetNextArealIndex(A, LastJ, 1, &LastEdge2, ci1, &UsedTree);
         LastJ = j;
         while(j >= 0)
            {
            if(j == 0)
               jj = A->numverts - 1;
            else
               jj = j - 1;

            if(A->x[j] < A->x[jj])
               {
               minx = A->x[j];
               maxx = A->x[jj];
               }
            else
               {
               minx = A->x[jj];
               maxx = A->x[j];
               }
            if(A->y[j] < A->y[jj])
               {
               miny = A->y[j];
               maxy = A->y[jj];
               }
            else
               {
               miny = A->y[jj];
               maxy = A->y[j];
               }

            ++numattempts;

            LastEdge1 = NULL;
            LastI = -1;
            i = GetNextArealIndex(B, LastI, 1, &LastEdge1, ci1, &UsedTree);
            LastI = i;

            while(i >= 0)
               {
               /**if((A->x[j] == B->x[i]) && (A->y[j] == B->y[i]))
                  {
                  Areal1Shared[j] = i;
                  Areal2Shared[i] = j;
                  }**/

               if(i == 0)
                  ii = B->numverts - 1;
               else
                  ii = i - 1;

               if((A->x[j] == B->x[i]) && (A->y[j] == B->y[i]))
                  {
                  Areal1Shared[j] = i;
                  Areal2Shared[i] = j;
                  }
               else if((A->x[j] == B->x[ii]) && (A->y[j] == B->y[ii]))
                  {
                  Areal1Shared[j] = ii;
                  Areal2Shared[ii] = j;
                  }
               else if((A->x[jj] == B->x[i]) && (A->y[jj] == B->y[i]))
                  {
                  Areal1Shared[jj] = i;
                  Areal2Shared[i] = jj;
                  }


               DoTheTest = 0;
               if(B->x[i] < B->x[ii])
                  {
                  if((B->x[i] <= maxx) && (B->x[ii] >= minx))
                      {
                      if(B->y[i] < B->y[ii])
                         {
                         if((B->y[i] <= maxy) && (B->y[ii] >= miny))
                            DoTheTest = 1;
                         }
                      else if((B->y[ii] <= maxy) && (B->y[i] >= miny))
                         {
                         DoTheTest = 1;
                         }
                      }
                  }
               else if((B->x[ii] <= maxx) && (B->x[i] >= minx))
                   {
                   if(B->y[i] < B->y[ii])
                      {
                      if((B->y[i] <= maxy) && (B->y[ii] >= miny))
                         DoTheTest = 1;
                      }
                   else if((B->y[ii] <= maxy) && (B->y[i] >= miny))
                      {
                      DoTheTest = 1;
                      }
                   }

               if(DoTheTest > 0)
                  {
                  onedge = EdgesOverlap(B->x[ii], B->y[ii], B->x[i], B->y[i],
                                A->x[jj],A->y[jj],A->x[j],A->y[j], &xi1, &yi1, &xi2, &yi2, &bothmatch, PTLTOLERANCE);
                  numsuccess += onedge;


                  if((onedge == 2) && (bothmatch < 1))
                     {
                     if((Areal1Shared[jj] < 0) && (xi1 == A->x[jj]) && (yi1 == A->y[jj]))
                        {
                        Areal1Shared[jj] = B->numverts + 2;
                        }
                     if((Areal1Shared[j] < 0) && (xi1 == A->x[j]) && (yi1 == A->y[j]))
                        {
                        Areal1Shared[j] = B->numverts + 2;
                        }

                     if((Areal1Shared[jj] < 0) && (xi2 == A->x[jj]) && (yi2 == A->y[jj]))
                        {
                        Areal1Shared[jj] = B->numverts + 2;
                        }
                     if((Areal1Shared[j] < 0) && (xi2 == A->x[j]) && (yi2 == A->y[j]))
                        {
                        Areal1Shared[j] = B->numverts + 2;
                        }


                     if((Areal2Shared[ii] < 0) && (xi1 == B->x[ii]) && (yi1 == B->y[ii]))
                        {
                        Areal2Shared[ii] = A->numverts + 2;
                        }
                     if((Areal2Shared[i] < 0) && (xi1 == B->x[i]) && (yi1 == B->y[i]))
                        {
                        Areal2Shared[i] = A->numverts + 2;
                        }

                     if((Areal2Shared[ii] < 0) && (xi2 == B->x[ii]) && (yi2 == B->y[ii]))
                        {
                        Areal2Shared[ii] = A->numverts + 2;
                        }
                     if((Areal2Shared[i] < 0) && (xi2 == B->x[i]) && (yi2 == B->y[i]))
                        {
                        Areal2Shared[i] = A->numverts + 2;
                        }
                     }

                  if(onedge == 0)
                     {
                     if(LineSegmentsIntersect(B->x[ii], B->y[ii], B->x[i], B->y[i],
                                   A->x[jj],A->y[jj],A->x[j],A->y[j], &xint, &yint) > 0)
                        {

                        *Bindex = i;
                        *Aindex = j;
                        *xi = xint;
                        *yi = yint;
                        answer = 1;
                        break;
                        }
                     }
                  else if(onedge == 2)
                     {
                     ++share_edge;
                     if((xi1 == B->x[ii]) && (yi1 == B->y[ii]))
                        {
                        if((xi2 == B->x[i]) && (yi2 == B->y[i]))
                           Areal2ForIntersections[i] = 2;
                        else if(Areal2ForIntersections[i] != 2)
                           Areal2ForIntersections[i] = 3 + j;
                        }
                     else if((xi1 == B->x[i]) && (yi1 == B->y[i]))
                        {
                        if((xi2 == B->x[ii]) && (yi2 == B->y[ii]))
                           Areal2ForIntersections[i] = 2;
                        else if(Areal2ForIntersections[i] != 2)
                           Areal2ForIntersections[i] = 3 + j;
                        }

                     if((xi1 == A->x[jj]) && (yi1 == A->y[jj]))
                        {
                        if((xi2 == A->x[j]) && (yi2 == A->y[j]))
                           Areal1ForIntersections[j] = 2;
                        else if(Areal1ForIntersections[j] != 2)
                           Areal1ForIntersections[j] = 3 + i;
                        }
                     else if((xi1 == A->x[j]) && (yi1 == A->y[j]))
                        {
                        if((xi2 == A->x[jj]) && (yi2 == A->y[jj]))
                           Areal1ForIntersections[j] = 2;
                        else if(Areal1ForIntersections[j] != 2)
                           Areal1ForIntersections[j] = 3 + i;
                        }
                     }
                  else if(onedge == 1)
                     {
                     if((Areal2ForIntersections[i] == 0) && (xi1 == B->x[i]) && (yi1 == B->y[i]))
                        {
                        Areal2ForIntersections[i] = 1;
                        Areal2Shared[i] = j;
                        }
                     if((Areal1ForIntersections[j] == 0) && (xi1 == A->x[j]) && (yi1 == A->y[j]))
                        {
                        Areal1ForIntersections[j] = 1;
                        Areal1Shared[j] = i;
                        }
                     }
                  }  /*** end if(DoTheTest > 0) ****/
               if(answer > 0)
                  break;
               i = GetNextArealIndex(B, LastI, 1, &LastEdge1, ci1, &UsedTree);
               LastI = i;
               } /*** end while(i >= 0) ***/
            if(answer > 0)
              break;
            j = GetNextArealIndex(A, LastJ, 1, &LastEdge2, ci1, &UsedTree);
            LastJ = j;
            } /*** end while j > 0 **/
         if(answer > 0)
            break;
         }  /**** for(ci1=cindex1; ci1 <=cindex2; ci1++) ****/
      }  /*** end if both A and B are large **/

   if(answer == 0)
      {
      for(i=0; i<A->numverts; i++)
         {
         if((Areal1Shared[i] > 0) && (Areal1ForIntersections[i] == 0))
            Areal1ForIntersections[i] = 1;
         }

      for(i=0; i<B->numverts; i++)
         {
         if((Areal2Shared[i] > 0) && (Areal2ForIntersections[i] == 0))
            Areal2ForIntersections[i] = 1;
         }
      j = 0;
      for(i=0; i<A->numverts; i++)
         {
         if(Areal1Shared[i] >= 0)
            ++j;
         }
      for(i=0; i<B->numverts; i++)
         {
         if(Areal2Shared[i] >= 0)
            ++share_vertex;
         }
      if(j > share_vertex)
         share_vertex = j;
      if((B->numverts < A->numverts) && (share_vertex >= B->numverts))
         {
         CreatePointInsideAreal(B, &xint, &yint);

         if(A->RB_Tree_Edgelist == NULL)
            {
            if(PointInsidePoly(xint,yint,A->x, A->y, A->numverts) > 0)
               {
               *Aindex = 0;
               *Bindex = 0;
               *xi = xint;
               *yi = yint;
               answer = 2;
               }
            }

         else if((PointInsideLargeAreal(xint, yint ,A, &onedge2) > 0) &&
            (onedge2 == 0))
            {
            *Aindex = 0;
            *Bindex = 0;
            *xi = xint;
            *yi = yint;
            answer = 2;
            }
         }
      else if((A->numverts < B->numverts) && (share_vertex >= A->numverts))
         {
         CreatePointInsideAreal(A, &xint, &yint);

         if(B->RB_Tree_Edgelist == NULL)
            {
            if(PointInsidePoly(xint,yint,B->x, B->y, B->numverts) > 0)
               {
               *Aindex = 0;
               *Bindex = 0;
               *xi = xint;
               *yi = yint;
               answer = 2;
               }
            }

         else if((PointInsideLargeAreal(xint, yint ,B, &onedge2) > 0) &&
            (onedge2 == 0))
            {
            *Aindex = 0;
            *Bindex = 0;
            *xi = xint;
            *yi = yint;
            answer = 2;
            }
         }

      if((answer == 0) && (share_vertex > 0)) /*** some vertices in common ***/
         {
            i = 0;
            while(i < B->numverts)
               {
               if(i == 0)
                  j = B->numverts - 1;
               else
                  j = i - 1;

               if(Areal2ForIntersections[j] == 1)
                  {
                  if(Areal2ForIntersections[i] == 0) /** [j] is shared vertex, [i] does not touch area A)***/
                     {
                     if(A->RB_Tree_Edgelist == NULL)
                        {
                        if(PointInsidePoly(B->x[i],B->y[i],A->x, A->y, A->numverts) > 0)
                           {
                           for(jj=0; jj<A->numverts; jj++)
                              {
                              if((A->x[jj] == B->x[j]) && (A->y[jj] == B->y[j]))
                                 break;
                              }
                           if(jj >= A->numverts)
                              {
                              *Aindex = 0;
                              *Bindex = 0;
                              *xi = B->x[i];
                              *yi = B->y[i];
                              answer = 2;
                              }
                           else
                              {
                              *Aindex = jj;
                              *Bindex = j;
                              *xi = B->x[j];
                              *yi = B->y[j];
                              answer = 1;
                              }
                           break;
                           }
                        }
                     else if((PointInsideLargeAreal(B->x[i], B->y[i] ,A, &onedge2) > 0) &&
                        (onedge2 == 0))
                        {
                        for(jj=0; jj<A->numverts; jj++)
                           {
                           if((A->x[jj] == B->x[j]) && (A->y[jj] == B->y[j]))
                              break;
                           }
                        if(jj >= A->numverts)
                           {
                           *Aindex = 0;
                           *Bindex = 0;
                           *xi = B->x[i];
                           *yi = B->y[i];
                           answer = 2;
                           }
                        else
                           {
                           *Aindex = jj;
                           *Bindex = j;
                           *xi = B->x[j];
                           *yi = B->y[j];
                           answer = 1;
                           }
                        break;
                        }
                     } /** end found a transition from 1 to 0 ***/
                  else if(Areal2ForIntersections[i] == 1) /** consecutive shared vertices, no common edge ***/
                     {
                     xint = B->x[j] + ((B->x[i] - B->x[j]) / 2);
                     yint = B->y[j] + ((B->y[i] - B->y[j]) / 2);
                     if(A->RB_Tree_Edgelist == NULL)
                        {
                        if((PointOnEdge(xint,yint,A->x,A->y,A->x,A->numverts,&unuseddbl,&unusedint) == 0) &&
                                 (PointInsidePoly(xint, yint, A->x, A->y, A->numverts) > 0))
                           {
                           for(jj=0; jj<A->numverts; jj++)
                              {
                              if((A->x[jj] == B->x[j]) && (A->y[jj] == B->y[j]))
                                 break;
                              }
                           if(jj >= A->numverts)
                              {
                              *Aindex = 0;
                              *Bindex = 0;
                              *xi = B->x[i];
                              *yi = B->y[i];
                              answer = 2;
                              }
                           else
                              {
                              *Aindex = jj;
                              *Bindex = j;
                              *xi = B->x[j];
                              *yi = B->y[j];
                              answer = 1;
                              }
                           break;
                           }
                        }
                     else if((PointOnLargeArealEdge(xint, yint,A,&unuseddbl, &unusedint) == 0) &&
                        (PointInsideLargeAreal(xint, yint, A, &onedge2) > 0) && (onedge2 == 0))
                        {
                        for(jj=0; jj<A->numverts; jj++)
                           {
                           if((A->x[jj] == B->x[j]) && (A->y[jj] == B->y[j]))
                              break;
                           }
                        if(jj >= A->numverts)
                           {
                           *Aindex = 0;
                           *Bindex = 0;
                           *xi = B->x[i];
                           *yi = B->y[i];
                           answer = 2;
                           }
                        else
                           {
                           *Aindex = jj;
                           *Bindex = j;
                           *xi = B->x[j];
                           *yi = B->y[j];
                           answer = 1;
                           }
                        break;
                        }
                     } /*** end consecutive shared verts ***/
                  }

               if(i == (B->numverts -1))
                  j = 0;
               else
                  j = i + 1;

               if((answer == 0) && (Areal2ForIntersections[j] == 1))
                  {
                  if(Areal2ForIntersections[i] == 0) /** [j] is shared vertex, [i] does not touch area A)***/
                     {
                     if(A->RB_Tree_Edgelist == NULL)
                        {
                        if(PointInsidePoly(B->x[i],B->y[i],A->x, A->y, A->numverts) > 0)
                           {
                           for(jj=0; jj<A->numverts; jj++)
                              {
                              if((A->x[jj] == B->x[j]) && (A->y[jj] == B->y[j]))
                                 break;
                              }
                           if(jj >= A->numverts)
                              {
                              *Aindex = 0;
                              *Bindex = 0;
                              *xi = B->x[i];
                              *yi = B->y[i];
                              answer = 2;
                              }
                           else
                              {
                              *Aindex = jj;
                              *Bindex = j;
                              *xi = B->x[j];
                              *yi = B->y[j];
                              answer = 1;
                              }
                           break;
                           }
                        }
                     else if((PointInsideLargeAreal(B->x[i], B->y[i] ,A, &onedge2) > 0) &&
                        (onedge2 == 0))
                        {
                        for(jj=0; jj<A->numverts; jj++)
                           {
                           if((A->x[jj] == B->x[j]) && (A->y[jj] == B->y[j]))
                              break;
                           }
                        if(jj >= A->numverts)
                           {
                           *Aindex = 0;
                           *Bindex = 0;
                           *xi = B->x[i];
                           *yi = B->y[i];
                           answer = 2;
                           }
                        else
                           {
                           *Aindex = jj;
                           *Bindex = j;
                           *xi = B->x[j];
                           *yi = B->y[j];
                           answer = 1;
                           }
                        break;
                        }
                     } /** end found a transition from 1 to 0 ***/
                  else if(Areal2ForIntersections[i] == 1) /** consecutive shared vertices, no common edge ***/
                     {
                     xint = B->x[j] + ((B->x[i] - B->x[j]) / 2);
                     yint = B->y[j] + ((B->y[i] - B->y[j]) / 2);
                        if(A->RB_Tree_Edgelist == NULL)
                        {
                        if((PointOnEdge(xint,yint,A->x,A->y,A->x,A->numverts,&unuseddbl,&unusedint) == 0) &&
                                 (PointInsidePoly(xint, yint, A->x, A->y, A->numverts) > 0))
                           {
                           for(jj=0; jj<A->numverts; jj++)
                              {
                              if((A->x[jj] == B->x[j]) && (A->y[jj] == B->y[j]))
                                 break;
                              }
                           if(jj >= A->numverts)
                              {
                              *Aindex = 0;
                              *Bindex = 0;
                              *xi = B->x[i];
                              *yi = B->y[i];
                              answer = 2;
                              }
                           else
                              {
                              *Aindex = jj;
                              *Bindex = j;
                              *xi = B->x[j];
                              *yi = B->y[j];
                              answer = 1;
                              }
                           break;
                           }
                        }
                     else if((PointOnLargeArealEdge(xint, yint,A,&unuseddbl, &unusedint) == 0) &&
                        (PointInsideLargeAreal(xint, yint, A, &onedge2) > 0) && (onedge2 == 0))
                        {
                        for(jj=0; jj<A->numverts; jj++)
                           {
                           if((A->x[jj] == B->x[j]) && (A->y[jj] == B->y[j]))
                              break;
                           }
                        if(jj >= A->numverts)
                           {
                           *Aindex = 0;
                           *Bindex = 0;
                           *xi = B->x[i];
                           *yi = B->y[i];
                           answer = 2;
                           }
                        else
                           {
                           *Aindex = jj;
                           *Bindex = j;
                           *xi = B->x[j];
                           *yi = B->y[j];
                           answer = 1;
                           }
                        break;
                        }
                     } /*** end  other direction consecutive shared verts ***/
                  }
               if(answer > 0)
                  break;
               ++i;
               } /** end while i ***/
         }  /**** end else if some vertices in common, but no edges ***/

      if((answer == 0) && (share_edge > 0))  /** some edges in common ***/
         {
         if(share_edge >= B->numverts) /** all edges of B might be shared ***/
            {
            i = 0;
            while(i < B->numverts)
               {
               if(Areal2ForIntersections[i] != 2)
                  break;
               ++i;
               }
            if(i >= B->numverts)  /*** all B edges are shared ***/
               {
               CreatePointInsideAreal(B, &xint, &yint);

               if(A->RB_Tree_Edgelist == NULL)
                  {
                  if(PointInsidePoly(xint,yint,A->x, A->y, A->numverts) > 0)
                     {
                     *Aindex = 0;
                     *Bindex = 0;
                     *xi = xint;
                     *yi = yint;
                     answer = 2;
                     }
                  }

               else if((PointInsideLargeAreal(xint, yint ,A, &onedge2) > 0) &&
                  (onedge2 == 0))
                  {
                  *Aindex = 0;
                  *Bindex = 0;
                  *xi = xint;
                  *yi = yint;
                  answer = 2;
                  }
               }
            }
         if((answer == 0) && (share_edge > 0))
            {
            i = 0;
            while(i < B->numverts)
               {
               if(i == 0)
                  j = B->numverts - 1;
               else
                  j = i - 1;

               if(Areal2ForIntersections[j] > 0)
                  {
                  if(Areal2ForIntersections[i] == 0) /** [j] is on an edge, [i] does not touch area A)***/
                     {
                     if(A->RB_Tree_Edgelist == NULL)
                        {
                        if(PointInsidePoly(B->x[i],B->y[i],A->x, A->y, A->numverts) > 0)
                           {
                           *Aindex = 0;
                           *Bindex = 0;
                           *xi = B->x[i];
                           *yi = B->y[i];
                           answer = 2;
                           break;
                           }
                        }
                     else if((PointInsideLargeAreal(B->x[i], B->y[i] ,A, &onedge2) > 0) &&
                        (onedge2 == 0))
                        {
                        *Aindex = 0;
                        *Bindex = 0;
                        *xi = B->x[i];
                        *yi = B->y[i];
                        answer = 2;
                        break;
                        }
                     } /** end found a transition from 2 to 0 ***/
                  else if(Areal2ForIntersections[i] == 1)
                     {
                     xint = B->x[j] + ((B->x[i] - B->x[j]) / 2);
                     yint = B->y[j] + ((B->y[i] - B->y[j]) / 2);
                     if(A->RB_Tree_Edgelist == NULL)
                        {
                        if((PointOnEdge(xint,yint,A->x,A->y,A->x,A->numverts,&unuseddbl,&unusedint) == 0) &&
                                 (PointInsidePoly(xint, yint, A->x, A->y, A->numverts) > 0))
                           {
                           *Aindex = 0;
                           *Bindex = 0;
                           *xi = xint;
                           *yi = yint;
                           answer = 2;
                           break;
                           }
                        }
                     else if((PointOnLargeArealEdge(xint, yint,A,&unuseddbl, &unusedint) == 0) &&
                        (PointInsideLargeAreal(xint, yint, A, &onedge2) > 0) && (onedge2 == 0))
                        {
                        *Aindex = 0;
                        *Bindex = 0;
                        *xi = xint;
                        *yi = yint;
                        answer = 2;
                        break;
                        }
                     }
                  else if(Areal2ForIntersections[i] >= 3)
                     {
                     xint = B->x[i] + ((A->x[Areal2ForIntersections[i]-3] - B->x[i]) / 2);
                     yint = B->y[i] + ((A->y[Areal2ForIntersections[i]-3] - B->y[i]) / 2);
                     if(A->RB_Tree_Edgelist == NULL)
                        {
                        if((PointOnEdge(xint,yint,A->x,A->y,A->x,A->numverts,&unuseddbl,&unusedint) == 0) &&
                                 (PointInsidePoly(xint, yint, A->x, A->y, A->numverts) > 0))
                           {
                           k = 0;
                           if(B->RB_Tree_Edgelist == NULL)
                              k = PointInsidePoly(xint, yint, B->x, B->y, B->numverts);
                           else
                              {
                              k = PointInsideLargeAreal(xint, yint, B, &onedge2);
                              if(onedge2 != 0)
                                 k = 0;
                              }
                           if(k > 0)
                              {
                           *Aindex = 0;
                           *Bindex = 0;
                           *xi = xint;
                           *yi = yint;
                           answer = 2;
                           break;
                              }
                           }
                        }
                     else if((PointOnLargeArealEdge(xint, yint,A,&unuseddbl, &unusedint) == 0) &&
                        (PointInsideLargeAreal(xint, yint, A, &onedge2) > 0) && (onedge2 == 0))
                        {
                           k = 0;
                           if(B->RB_Tree_Edgelist == NULL)
                              k = PointInsidePoly(xint, yint, B->x, B->y, B->numverts);
                           else
                              {
                              k = PointInsideLargeAreal(xint, yint, B, &onedge2);
                              if(onedge2 != 0)
                                 k = 0;
                              }
                           if(k > 0)
                              {

                        *Aindex = 0;
                        *Bindex = 0;
                        *xi = xint;
                        *yi = yint;
                        answer = 2;
                        break;
                           }
                        }
                     }
                  }
               if(answer > 0)
                  break;
               ++i;
               }
            }
         }  /*** end (share_edge > 0) so some edges in common ***/

      }  /** end if answer == 0 ****/

   *ArealsTouch = share_vertex;
   return(answer);
}




void PruneLandCoverErrorList(double xmin, double xmax, double ymin, double ymax)
{
struct ListOfArealEdges *Lp, *Lc;

   if(LAEroot == NULL)
      return;

   Lp = Lc = LAEroot;
   while(Lc != NULL) 
      {
      if(Lc->minx > xmax)
         break;

      if((Lc->maxx < xmin) || ((Lc->maxx == xmin) && (Lc->maxy < ymin)))
         {
         if(Lc == LAEroot)
            {
            LAEroot = LAEroot->next;
            Lc->next = KnownRoot;
            KnownRoot = Lc;

            Lp = Lc = LAEroot;
            }
         else
            {
            Lp->next = Lc->next;
            Lc->next = KnownRoot;
            KnownRoot = Lc;

            Lc = Lp->next;
            }
         }

      else if(Lc != NULL)
         {
         Lp = Lc;
         Lc = Lc->next;
         }
      }
}






void AddEdgeSegment(double x1, double y1, double z1, double x2, double y2, double z2,
                                      double UID, int cnumb,int idn,int Sindex,int Lindex, double BndryProximity)
{
struct ListOfArealEdges *Lp, *Lc;
double testlength;
double d1, d2;

   testlength = (x1 - x2) * (x1 - x2);
   testlength += (y1 - y2) * (y1 - y2);
   if(testlength < 0.001)
      return;


   d1 = CF_LAEmaxx - x1;
   d2 = CF_LAEmaxx - x2;
   if(d1 < 0)
      d1 = 0 - d1;
   if(d2 < 0)
      d2 = 0 - d2;
   if((d1 > BndryProximity) || (d2 > BndryProximity))
      {
      d1 = x1 - CF_LAEminx;
      d2 = x2 - CF_LAEminx;
      if(d1 < 0)
         d1 = 0 - d1;
      if(d2 < 0)
         d2 = 0 - d2;
      if((d1 > BndryProximity) || (d2 > BndryProximity))
         {
         d1 = CF_LAEmaxy - y1;
         d2 = CF_LAEmaxy - y2;
         if(d1 < 0)
            d1 = 0 - d1;
         if(d2 < 0)
            d2 = 0 - d2;
         if((d1 > BndryProximity) || (d2 > BndryProximity))
            {
            d1 = y1 - CF_LAEminy;
            d2 = y2 - CF_LAEminy;
            if(d1 < 0)
               d1 = 0 - d1;
            if(d2 < 0)
               d2 = 0 - d2;
            if((d1 <= BndryProximity) && (d2 <= BndryProximity))
               return;
            }
         else
            return;
         }
      else
         return;
      }
   else
      return;


   LAEn = (struct ListOfArealEdges *) (malloc(SzLAE));
   if(LAEn == NULL)
      {
      printf("all available memeory has been consumed - exiting now\n");
      exit(-1);
      }
   LAEn->x1 = x1;
   LAEn->y1 = y1;
   LAEn->z1 = z1;
   LAEn->x2 = x2;
   LAEn->y2 = y2;
   LAEn->z2 = z2;
   LAEn->UID = UID;
 
   LAEn->cnumb = cnumb;
   LAEn->idn = idn;
   LAEn->Sindex = Sindex;
   LAEn->Lindex = Lindex;

   if(x1 < x2)
      {
      LAEn->minx = x1;
      LAEn->maxx = x2;
      }
   else
      {
      LAEn->minx = x2;
      LAEn->maxx = x1;
      }

   if(y1 < y2)
      {
      LAEn->miny = y1;
      LAEn->maxy = y2;
      }
   else
      {
      LAEn->miny = y2;
      LAEn->maxy = y1;
      }

   if(LAEroot == NULL)
      {
      LAEn->next = NULL;
      LAEroot = LAEn;
      }
   else
      {
      Lp = Lc = LAEroot;
      while(Lc != NULL)
         {
         if(Lc->minx < LAEn->minx)
            {
            Lp = Lc;
            Lc = Lc->next;
            }
         else if(Lc->minx == LAEn->minx)
            {
            while((Lc->minx == LAEn->minx) && (Lc->miny < LAEn->miny))
               {
               Lp = Lc;
               Lc = Lc->next;
               if(Lc == NULL)
                  break;
               }
            break;
            }
         else
            {
            break;
            }
         }
      
      if(Lc == NULL)
         {
         Lp->next = LAEn;
         LAEn->next = NULL;
         }
      else if(Lc == LAEroot)
         {
         LAEn->next = LAEroot;
         LAEroot = LAEn;
         }
      else
         {
         Lp->next = LAEn;
         LAEn->next = Lc;
         }
      }
}




void MergeEdgeSegmentLists(void)
{
struct ListOfArealEdges *Lp, *Lc, *Lm, *Ln;

   if(LAEroot == NULL)
      {
      LAEroot = ProcessRoot;
      return;
      }

   Lp = Lm = LAEroot;
   Ln = ProcessRoot;
   
   while(Ln != NULL)
      {
      if(Lm == NULL)
         {
         Lp->next = Ln;
         return;
         }
      if(Lm->minx < Ln->minx)
         {
         Lp = Lm;
         Lm = Lm->next;
         }
      else if(Lm->minx == Ln->minx)
         {
         while((Lm->minx == Ln->minx) && (Lm->miny < Ln->miny))
            {
            Lp = Lm;
            Lm = Lm->next;
            if(Lm == NULL)
               {
               Lp->next = Ln;
               return;
               }
            }
         if(Lm == LAEroot)
            {
            Lc = Ln->next;
            Ln->next = LAEroot;
            LAEroot = Ln;
            Lp = LAEroot;
            Lm = Lp->next;
            Ln = Lc;
            }
         else
            {
            Lc = Ln->next;
            Lp->next = Ln;
            Ln->next = Lm;
            Ln = Lc;
            Lm = Lp->next;
            }
         }
      else
         {
         if(Lm == LAEroot)
            {
            Lc = Ln->next;
            Ln->next = LAEroot;
            LAEroot = Ln;
            Lp = LAEroot;
            Lm = Lp->next;
            Ln = Lc;
            }
         else
            {
            Lp->next = Ln;
            Lc = Ln->next;
            Ln->next = Lm;
            Ln = Lc;
            Lm = Lp->next;
            }
         }
      }
}




int MatchAreaEdge(double x1, double y1, double z1, double x2, double y2, double z2,
                         double UniqueID, int cnumb, int idn, int Sindex, int Lindex, double BndryProx)
{
double PTLdist;
double xlk,ylk,xnm,ynm,det; 
double x3,y3,z3,x4,y4,z4;
double mix,max,miy,may;
double D1, D2;
int bump_ptr;
int B1, B2, B3, B4, FoundMatch;
double SQ_DT = 0.0;

   SQ_DT = SqDistTolerance;

   FoundMatch = 0;
   LAEp = LAEc = LAEroot;

   if(x1 < x2)
      {
      mix = x1 - 1.0;
      max = x2 + 1.0;
      }
   else
      {
      mix = x2 - 1.0;
      max = x1 + 1.0;
      }
   if(y1 < y2)
      {
      miy = y1 - 1.0;
      may = y2 + 1.0;
      }
   else
      {
      miy = y2 - 1.0;
      may = y1 + 1.0;
      }

   while(LAEc != NULL)
      {
      bump_ptr = 1;

      if(max < LAEc->minx)
         {
         LAEc = NULL;
         break;
         }

      if((LAEc->UID != UniqueID) && (LAEc->cnumb == cnumb) && (LAEc->idn != idn) && 
               (mix <= LAEc->maxx) && (max >= LAEc->minx) && (miy <= LAEc->maxy) && (may >= LAEc->miny))
         {
         if((NearlyEqual(x1,LAEc->x1) > 0) && (NearlyEqual(y1,LAEc->y1) > 0))
            {
            if((NearlyEqual(x2,LAEc->x2) > 0) && (NearlyEqual(y2,LAEc->y2) > 0))
               {
               FoundMatch = 1; /*** can remove LAEc from the list of unmatched edges ***/
               if(LAEc == LAEroot)
                  {
                  bump_ptr = 0;
                  LAEroot = LAEroot ->next;
                  LAEn = LAEc;
                  LAEc = LAEp = LAEroot;
                  }
               else
                  {
                  LAEp->next = LAEc->next;
                  bump_ptr = 0;
                  LAEn = LAEc;
                  LAEc = LAEc->next;
                  }
               free(LAEn);
               
               }
            else /*** still have x1 == LAEc->x1 and y1 == LAEc->y1  ***/
               {
               /*** is part of the segment shared? ***/
               PTLdist = ApproxPointToLineDist2D(x2,y2,LAEc->x1,LAEc->y1,LAEc->x2,LAEc->y2);
               if(PTLdist <= SQ_DT) /** then (x1,y1) to (x2,y2) is fully covered by LAEc, so discard (x1,y1) to (x2,y2) and mod LAEc ***/
                  {
                  FoundMatch = 1; /*** replace point (x1,y1,z1) on LAEc with (x2,y2,z2) and consider input edge to be covered ****/
                  LAEc->x1 = x2;
                  LAEc->y1 = y2;
                  LAEc->z1 = z2; /*** added 21 Nov 08 ***/
                  }
               else
                  {
                  PTLdist = ApproxPointToLineDist2D(LAEc->x2,LAEc->y2, x1, y1, x2, y2);
                  if(PTLdist <= SQ_DT) /** then LAEc fully covered by (x1,y1)-(x2,y2) so discard LAEc and modify (x1,y1)-(x2,y2) ***/
                     {
                     FoundMatch = 1;
                     if(LAEc == LAEroot)
                        {
                        bump_ptr = 0;
                        LAEroot = LAEroot ->next;
                        LAEn = LAEc;
                        LAEc = LAEp = LAEroot;
                        }
                     else
                        {
                        LAEp->next = LAEc->next;
                        bump_ptr = 0;
                        LAEn = LAEc;
                        LAEc = LAEc->next;
                        }
                     x1 = LAEn->x2;
                     y1 = LAEn->y2;
                     z1 = LAEn->z2;
                     free(LAEn);
                     MatchAreaEdge(x1,y1,z1,x2,y2,z2,UniqueID, cnumb,idn,Sindex,Lindex, BndryProx);
                     }
                  }
               }
            }

         if((FoundMatch == 0) && (NearlyEqual(x1,LAEc->x2) > 0) && (NearlyEqual(y1,LAEc->y2) > 0))
            {
            if((NearlyEqual(x2,LAEc->x1) > 0) && (NearlyEqual(y2,LAEc->y1) > 0))
               {
               FoundMatch = 1; /*** can remove LAEc from the list of unmatched edges ***/
               if(LAEc == LAEroot)
                  {
                  bump_ptr = 0;
                  LAEroot = LAEroot ->next;
                  LAEn = LAEc;
                  LAEc = LAEp = LAEroot;
                  }
               else
                  {
                  LAEp->next = LAEc->next;
                  bump_ptr = 0;
                  LAEn = LAEc;
                  LAEc = LAEc->next;
                  }
               free(LAEn);
               }
            else /*** still have x1 == LAEc->x2 and y1 == LAEc->y2  ***/
               {
               /*** is part of the segment shared? ***/
               PTLdist = ApproxPointToLineDist2D(x2,y2,LAEc->x1,LAEc->y1,LAEc->x2,LAEc->y2);
               if(PTLdist <= SQ_DT) /** then (x1,y1) to (x2,y2) is fully covered by LAEc, so discard (x1,y1) to (x2,y2) and mod LAEc ***/
                  {
                  FoundMatch = 1; /*** replace point (x1,y1,z1) on LAEc with (x2,y2,z2) and consider input edge to be covered ****/
                  LAEc->x2 = x2;
                  LAEc->y2 = y2;
                  LAEc->z2 = z2; /*** added 21 Nov 08 ***/
                  }
               else
                  {
                  PTLdist = ApproxPointToLineDist2D(LAEc->x1,LAEc->y1, x1, y1, x2, y2);
                  if(PTLdist <= SQ_DT) /** then LAEc fully covered by (x1,y1)-(x2,y2) so discard LAEc and modify (x1,y1)-(x2,y2) ***/
                     {
                     FoundMatch = 1;
                     if(LAEc == LAEroot)
                        {
                        bump_ptr = 0;
                        LAEroot = LAEroot ->next;
                        LAEn = LAEc;
                        LAEc = LAEp = LAEroot;
                        }
                     else
                        {
                        LAEp->next = LAEc->next;
                        bump_ptr = 0;
                        LAEn = LAEc;
                        LAEc = LAEc->next;
                        }
                     x1 = LAEn->x1;
                     y1 = LAEn->y1;
                     z1 = LAEn->z1;
                     free(LAEn);
                     MatchAreaEdge(x1,y1,z1,x2,y2,z2,UniqueID, cnumb,idn,Sindex,Lindex, BndryProx);
                     }
                  }
               }
            }

         if((FoundMatch == 0) && (NearlyEqual(x2,LAEc->x1) > 0) && (NearlyEqual(y2,LAEc->y1) > 0))
            {
               /*** is part of the segment shared? ***/
               PTLdist = ApproxPointToLineDist2D(x1,y1,LAEc->x1,LAEc->y1,LAEc->x2,LAEc->y2);
               if(PTLdist <= SQ_DT) /** then (x1,y1) to (x2,y2) is fully covered by LAEc, so discard (x1,y1) to (x2,y2) and mod LAEc ***/
                  {
                  FoundMatch = 1; /*** replace point (x1,y1,z1) on LAEc with (x2,y2,z2) and consider input edge to be covered ****/
                  LAEc->x1 = x1;
                  LAEc->y1 = y1;
                  LAEc->z1 = z1; /*** added 21 Nov 08 ***/
                  }
               else
                  {
                  PTLdist = ApproxPointToLineDist2D(LAEc->x2,LAEc->y2, x2, y2, x1, y1);
                  if(PTLdist <= SQ_DT) /** then LAEc fully covered by (x1,y1)-(x2,y2) so discard LAEc and modify (x1,y1)-(x2,y2) ***/
                     {
                     FoundMatch = 1;
                     if(LAEc == LAEroot)
                        {
                        bump_ptr = 0;
                        LAEroot = LAEroot ->next;
                        LAEn = LAEc;
                        LAEc = LAEp = LAEroot;
                        }
                     else
                        {
                        LAEp->next = LAEc->next;
                        bump_ptr = 0;
                        LAEn = LAEc;
                        LAEc = LAEc->next;
                        }
                     x2 = LAEn->x2;
                     y2 = LAEn->y2;
                     z2 = LAEn->z2;
                     free(LAEn);
//printf("   discarded LAEn, set x2, y2 to %lf %lf\n",x2,y2);
                     MatchAreaEdge(x1,y1,z1,x2,y2,z2,UniqueID, cnumb,idn,Sindex,Lindex, BndryProx);
                     }
                  }
            }

         if((FoundMatch == 0) && (NearlyEqual(x2,LAEc->x2) > 0) && (NearlyEqual(y2,LAEc->y2) > 0))
            {
               /*** is part of the segment shared? ***/
               PTLdist = ApproxPointToLineDist2D(x1,y1,LAEc->x1,LAEc->y1,LAEc->x2,LAEc->y2);
               if(PTLdist <= SQ_DT) /** then (x1,y1) to (x2,y2) is fully covered by LAEc, so discard (x1,y1) to (x2,y2) and mod LAEc ***/
                  {
                  FoundMatch = 1; /*** replace point (x1,y1,z1) on LAEc with (x2,y2,z2) and consider input edge to be covered ****/
                  LAEc->x2 = x1;
                  LAEc->y2 = y1;
                  LAEc->z2 = z1; /*** added 21 Nov 08 ***/
                  }
               else
                  {
                  PTLdist = ApproxPointToLineDist2D(LAEc->x1,LAEc->y1, x2, y2, x1, y1);
                  if(PTLdist <= SQ_DT) /** then LAEc fully covered by (x1,y1)-(x2,y2) so discard LAEc and modify (x1,y1)-(x2,y2) ***/
                     {
                     FoundMatch = 1;
                     if(LAEc == LAEroot)
                        {
                        bump_ptr = 0;
                        LAEroot = LAEroot ->next;
                        LAEn = LAEc;
                        LAEc = LAEp = LAEroot;
                        }
                     else
                        {
                        LAEp->next = LAEc->next;
                        bump_ptr = 0;
                        LAEn = LAEc;
                        LAEc = LAEc->next;
                        }
                     x2 = LAEn->x1;
                     y2 = LAEn->y1;
                     z2 = LAEn->z1;
                     free(LAEn);
                     MatchAreaEdge(x1,y1,z1,x2,y2,z2,UniqueID, cnumb,idn,Sindex,Lindex, BndryProx);
                     }
                  }
            }
   
         else if(FoundMatch == 0)
            {
            xlk = x1 - x2;
            ylk = y1 - y2;
            xnm = LAEc->x1 - LAEc->x2;
            ynm = LAEc->y1 - LAEc->y2;
   
            det = (xnm * ylk) - (ynm * xlk);
            if((-0.015 < det) && (det < 0.015))  /** approx parallel lines **/
               {
               B1 = StrictlyBetween(x1,y1,LAEc->x1,LAEc->y1,LAEc->x2,LAEc->y2);
               B2 = StrictlyBetween(x2,y2,LAEc->x1,LAEc->y1,LAEc->x2,LAEc->y2);
               B3 = StrictlyBetween(LAEc->x1, LAEc->y1,x1,y1,x2,y2);
               B4 = StrictlyBetween(LAEc->x2, LAEc->y2,x1,y1,x2,y2);
               if((B1 > 0) && (B2 > 0)) /** then maybe (x1,y1) - (x2,y2) is fully on LAEc, so refine LAEC and are finished with (x1,y1) - (x2,y2) ***/
                  {
                  PTLdist = ApproxPointToLineDist2D(x1, y1, LAEc->x1, LAEc->y1, LAEc->x2, LAEc->y2);
                  if(PTLdist <= SQ_DT)
                     {
                     PTLdist = ApproxPointToLineDist2D(x2, y2, LAEc->x1, LAEc->y1, LAEc->x2, LAEc->y2);
                     if(PTLdist <= SQ_DT)
                        {
                        FoundMatch = 1;
                        D1 = (x1 - LAEc->x1) * (x1 - LAEc->x1);
                        D1 += (y1 - LAEc->y1) * (y1 - LAEc->y1);

                        D2  = (x2 - LAEc->x1) * (x2 - LAEc->x1);
                        D2 += (y2 - LAEc->y1) * (y2 - LAEc->y1);

                        if(D1 < D2)
                           {
                           AddEdgeSegment(x2,y2,z2,LAEc->x2,LAEc->y2,LAEc->z2,LAEc->UID, cnumb,
                                          LAEc->idn,LAEc->Sindex,LAEc->Lindex,BndryProx);
                           LAEc->x2 = x1;
                           LAEc->y2 = y1;
                           LAEc->z2 = z1; /*** added 21 Nov 08 ***/
                           }
                        else
                           {
                           AddEdgeSegment(x1,y1,z1,LAEc->x2,LAEc->y2,LAEc->z2,LAEc->UID, cnumb,LAEc->idn,LAEc->Sindex,LAEc->Lindex, BndryProx);
                           LAEc->x2 = x2;
                           LAEc->y2 = y2;
                           LAEc->z2 = z2; /*** added 21 Nov 08 ***/
                           }
                        }
                     }
                  }
               else if((B3 > 0) && (B4 > 0)) /*** then maybe LAEC is fully covered by (x1,y1)-(x2,y2), so remove LAEC, recurs with pieces of (x1,y1)-(x2,y2) ***/
                  {
                  PTLdist = ApproxPointToLineDist2D(LAEc->x1, LAEc->y1, x1, y1, x2, y2);
                  if(PTLdist <= SQ_DT)
                     {
                     PTLdist = ApproxPointToLineDist2D(LAEc->x2, LAEc->y2, x1,y1,x2,y2);
                     if(PTLdist <= SQ_DT)
                        {
                        FoundMatch = 1;
                        D1 = (x1 - LAEc->x1) * (x1 - LAEc->x1);
                        D1 += (y1 - LAEc->y1) * (y1 - LAEc->y1);

                        D2  = (x1 - LAEc->x2) * (x1 - LAEc->x2);
                        D2 += (y1 - LAEc->y2) * (y1 - LAEc->y2);

                        if(D1 < D2)
                           {
                           x3 = LAEc->x1;
                           y3 = LAEc->y1;
                           z3 = LAEc->z1;
                           x4 = LAEc->x2;
                           y4 = LAEc->y2;
                           z4 = LAEc->z2;
                           }
                        else
                           {
                           x4 = LAEc->x1;
                           y4 = LAEc->y1;
                           z4 = LAEc->z1;
                           x3 = LAEc->x2;
                           y3 = LAEc->y2;
                           z3 = LAEc->z2;
                           }
                        if(LAEc == LAEroot)
                           {
                           bump_ptr = 0;
                           LAEroot = LAEroot ->next;
                           LAEn = LAEc;
                           LAEc = LAEp = LAEroot;
                           }
                        else
                           {
                           LAEp->next = LAEc->next;
                           bump_ptr = 0;
                           LAEn = LAEc;
                           LAEc = LAEc->next;
                           }
                        free(LAEn);

                        MatchAreaEdge(x1,y1,z1,x3,y3,z3,UniqueID, cnumb,idn,Sindex,Lindex, BndryProx);
                        MatchAreaEdge(x2,y2,z2,x4,y4,z4,UniqueID, cnumb,idn,Sindex,Lindex, BndryProx);
                        }
                     }
                  }
   
               else if((B1 > 0) && (B3 > 0))
                  {
                  PTLdist = ApproxPointToLineDist2D(LAEc->x1, LAEc->y1, x1, y1, x2, y2);
                  if(PTLdist <= SQ_DT)
                     {
                     PTLdist = ApproxPointToLineDist2D(x1,y1,LAEc->x1, LAEc->y1,LAEc->x2,LAEc->y2);
                     if(PTLdist <= SQ_DT)
                        {
                        FoundMatch = 1;
                        x4 = LAEc->x1;
                        y4 = LAEc->y1;
                        z4 = LAEc->z1;
                        LAEc->x1 = x1;
                        LAEc->y1 = y1;
                        LAEc->z1 = z1;
                        MatchAreaEdge(x2,y2,z2,x4,y4,z4,UniqueID, cnumb,idn,Sindex,Lindex, BndryProx);
                        }
                     }
                  }
   
               else if((B1 > 0) && (B4 > 0))
                  {
                  PTLdist = ApproxPointToLineDist2D(LAEc->x2, LAEc->y2, x1, y1, x2, y2);
                  if(PTLdist <= SQ_DT)
                     {
                     PTLdist = ApproxPointToLineDist2D(x1,y1,LAEc->x1, LAEc->y1,LAEc->x2,LAEc->y2);
                     if(PTLdist <= SQ_DT)
                        {
                        FoundMatch = 1;
                        x4 = LAEc->x2;
                        y4 = LAEc->y2;
                        z4 = LAEc->z2;
                        LAEc->x2 = x1;
                        LAEc->y2 = y1;
                        LAEc->z2 = z1;
                        MatchAreaEdge(x2,y2,z2,x4,y4,z4,UniqueID, cnumb,idn,Sindex,Lindex, BndryProx);
                        }
                     }
                  }

               else if((B2 > 0) && (B3 > 0))
                  {
                  PTLdist = ApproxPointToLineDist2D(LAEc->x1, LAEc->y1, x1, y1, x2, y2);
                  if(PTLdist <= SQ_DT)
                     {
                     PTLdist = ApproxPointToLineDist2D(x2,y2,LAEc->x1, LAEc->y1,LAEc->x2,LAEc->y2);
                     if(PTLdist <= SQ_DT)
                        {
                        FoundMatch = 1;
                        x3 = LAEc->x1;
                        y3 = LAEc->y1;
                        z3 = LAEc->z1;
                        LAEc->x1 = x2;
                        LAEc->y1 = y2;
                        LAEc->z1 = z2;
                        MatchAreaEdge(x1,y1,z1,x3,y3,z3,UniqueID, cnumb,idn,Sindex,Lindex, BndryProx);
                        }
                     }
                  }

               else if((B2 > 0) && (B4 > 0))
                  {
                  PTLdist = ApproxPointToLineDist2D(LAEc->x2, LAEc->y2, x1, y1, x2, y2);
                  if(PTLdist <= SQ_DT)
                     {
                     PTLdist = ApproxPointToLineDist2D(x2,y2,LAEc->x1, LAEc->y1,LAEc->x2,LAEc->y2);
                     if(PTLdist <= SQ_DT)
                        {
                        FoundMatch = 1;
                        x3 = LAEc->x2;
                        y3 = LAEc->y2;
                        z3 = LAEc->z2;
                        LAEc->x2 = x2;
                        LAEc->y2 = y2;
                        LAEc->z2 = z2;
                        MatchAreaEdge(x1,y1,z1,x3,y3,z3,UniqueID, cnumb,idn,Sindex,Lindex, BndryProx);
                        }
                     }
                  }
               } /**** end approx so try piecemeal match parallel lines ***/
            } /*** end no individ points in common ***/

         if(FoundMatch > 0)
            break;
         } /*** end mins and max's allow attempt to match ***/

      if(bump_ptr > 0)
         {
         LAEp = LAEc;
         LAEc = LAEc->next;
         }
      }

   if((LAEc == NULL) && (FoundMatch == 0))
      AddEdgeSegment(x1,y1,z1,x2,y2,z2,UniqueID, cnumb,idn,Sindex,Lindex, BndryProx);
   return(FoundMatch);
}




         
int TwoArealsShareEdge(struct RawAreal *A, struct RawAreal *B, int *Aindex, int *Bindex, double tolerance)
{
int i,j,ii,jj, ci1, ci2, MYI, onedge;
double xi1,yi1;
double xi2,yi2;
struct RB_Edgelist * LastEdge1;
struct RB_Edgelist * LastEdge2;
int cindex1, cindex2, bothmatch;
int LastI, LastJ, UsedTree;

   MYI = MaxYindex + 1;
   if((A->RB_Tree_Edgelist == NULL) && (B->RB_Tree_Edgelist == NULL)) /* two non-large areals **/
      {
      for(i=0; i<A->numverts; i++)
         {
         if(i == 0)
            ii = A->numverts - 1;
         else
            ii = i - 1;
         for(j=0; j<B->numverts; j++)
            {
            if(j == 0)
               jj = B->numverts - 1;
            else
               jj = j - 1;

            onedge = EdgesOverlap(A->x[ii], A->y[ii], A->x[i], A->y[i],
                                B->x[jj],B->y[jj],B->x[j],B->y[j], &xi1, &yi1, &xi2, &yi2, &bothmatch, tolerance);

            if(onedge == 2)
               {
               *Aindex = i;
               *Bindex = j;
               return(1);
               }
            } /*** end for j ***/
         } /** end for i ***/
      } /*** end two non-large areals ***/
   else if((A->RB_Tree_Edgelist != NULL) && (B->RB_Tree_Edgelist == NULL))
      {

      for(j=0; j<B->numverts; j++)
         {
         if(j == 0)
            jj = B->numverts - 1;
         else
            jj = j - 1;

         ci1 = (int) (B->x[j] / RegionSize);
         ci2 = (int) (B->y[j] / RegionSize);

         cindex1 = (ci1 * MYI) + ci2;

         ci1 = (int) (B->x[jj] / RegionSize);
         ci2 = (int) (B->y[jj] / RegionSize);

         cindex2 = (ci1 * MYI) + ci2;

         if(cindex2 < cindex1)
            {
            ci1 = cindex2;
            cindex2 = cindex1;
            cindex1 = ci1;
            }

         LastEdge1 = NULL;
         LastI = -1;
         for(ci1=cindex1; ci1<=cindex2; ci1++)
            {
            i = GetNextArealIndex(A, LastI, 1, &LastEdge1, ci1, &UsedTree);
            LastI = i;
            while(i >= 0)
               {
               if(i == 0)
                  ii = A->numverts - 1;
               else
                  ii = i - 1;
               onedge = EdgesOverlap(A->x[ii], A->y[ii], A->x[i], A->y[i],
                                B->x[jj],B->y[jj],B->x[j],B->y[j], &xi1, &yi1, &xi2, &yi2, &bothmatch, tolerance);

               if(onedge == 2)
                  {
                  *Aindex = i;
                  *Bindex = j;
                  return(1);
                  }
               i = GetNextArealIndex(A, LastI, 1, &LastEdge1, ci1, &UsedTree);
               LastI = i;
               } /*** end while i ***/
            } /*** end for ci1 ***/
         } /** end for j ***/
      } /*** end else B large, A small ***/
   else if((A->RB_Tree_Edgelist == NULL) && (B->RB_Tree_Edgelist != NULL))
      {
      for(j=0; j<A->numverts; j++)
         {
         if(j == 0)
            jj = A->numverts - 1;
         else
            jj = j - 1;

         ci1 = (int) (A->x[j] / RegionSize);
         ci2 = (int) (A->y[j] / RegionSize);

         cindex1 = (ci1 * MYI) + ci2;

         ci1 = (int) (A->x[jj] / RegionSize);
         ci2 = (int) (A->y[jj] / RegionSize);

         cindex2 = (ci1 * MYI) + ci2;
              
         if(cindex2 < cindex1)
            { 
            ci1 = cindex2;
            cindex2 = cindex1;
            cindex1 = ci1;
            }

         LastEdge1 = NULL;
         LastI = -1;
         for(ci1=cindex1; ci1<=cindex2; ci1++)
            {
            i = GetNextArealIndex(B, LastI, 1, &LastEdge1, ci1, &UsedTree);
            LastI = i;

            while(i >= 0)
               {
               if(i == 0)
                  ii = B->numverts - 1;
               else
                  ii = i - 1;
               onedge = EdgesOverlap(B->x[ii], B->y[ii], B->x[i], B->y[i],
                                A->x[jj],A->y[jj],A->x[j],A->y[j], &xi1, &yi1, &xi2, &yi2, &bothmatch, tolerance);

               if(onedge == 2)
                  {
                  *Bindex = i;
                  *Aindex = j;
                  return(1);
                  }
               i = GetNextArealIndex(B, LastI, 1, &LastEdge1, ci1, &UsedTree);
               LastI = i;
               } /*** end while i ***/
            } /*** end for ci1 ***/
         } /** end for j ***/
      } /*** end else A large, B small ***/
   else if((A->RB_Tree_Edgelist != NULL) && (B->RB_Tree_Edgelist != NULL))
      {
      if(A->firstindex > B->firstindex)
         cindex1 = A->firstindex;
      else
         cindex1 = B->firstindex;

      if((A->ismulti <= 0) && (B->ismulti <= 0))
         {
         printf("attempt to intersect two single region area features with large area feature logic\n");
         printf("forced exit\n");
         exit(-1);
         }
      if(A->ismulti < B->ismulti)
         cindex2 = A->ismulti;
      else
         cindex2 = B->ismulti;

      for(ci1=cindex1; ci1 <=cindex2; ci1++)
         {
         LastJ = -1;
         LastEdge2 = NULL;
         j = GetNextArealIndex(A, LastJ, 1, &LastEdge2, ci1, &UsedTree);
         LastJ = j;
         while(j >= 0)
            {
            if(j == 0)
               jj = A->numverts - 1;
            else
               jj = j - 1;
            LastEdge1 = NULL;
            LastI = -1;
            i = GetNextArealIndex(B, LastI, 1, &LastEdge1, ci1, &UsedTree);
            LastI = i;

            while(i >= 0)
               {
               if((A->x[j] == B->x[i]) && (A->y[j] == B->y[i]))
                  {
                  Areal1Shared[j] = i;
                  Areal2Shared[i] = j;
                  }

               if(i == 0)
                  ii = B->numverts - 1;
               else
                  ii = i - 1;
               onedge = EdgesOverlap(A->x[jj], A->y[jj], A->x[j], A->y[j],
                                B->x[ii],B->y[ii],B->x[i],B->y[i], &xi1, &yi1, &xi2, &yi2, &bothmatch, tolerance);

               if(onedge == 2)
                  {
                  *Aindex = i;
                  *Bindex = j;
                  return(1);
                  }
               i = GetNextArealIndex(B, LastI, 1, &LastEdge1, ci1, &UsedTree);
               LastI = i;
               } /*** end while i ***/
            j = GetNextArealIndex(A, LastJ, 1, &LastEdge2, ci1, &UsedTree);
            LastJ = j;
            } /*** end while j ***/
         } /** end for ci1 ***/
      } /*** end else both A and B are large ***/

   return(0);
}






int AreaAndLineShareEdgeOrLineEndNode(struct RawAreal *A, struct RawLinear *L, double tolerance)
{
int j,jj,k,kk,unusedint;
double minxPadded, maxxPadded, minyPadded, maxyPadded;
double ptpdist1, unuseddbl;


   if(A->RB_Tree_Edgelist == NULL)
      ptpdist1 = PointToSmallArealDist2D(L->x[0], L->y[0],A,&unusedint,&unuseddbl);
   else
      ptpdist1 = PointToLargeArealDist2D(L->x[0], L->y[0],A,&unusedint,&unuseddbl);

   if((ptpdist1 >= 0.0) && (ptpdist1 <= tolerance)) /** seems we have found the condition ***/
      {
      return(1);
      }

   j = L->numnodes - 1;
   if(A->RB_Tree_Edgelist == NULL)
      ptpdist1 = PointToSmallArealDist2D(L->x[j], L->y[j],A,&unusedint,&unuseddbl);
   else
      ptpdist1 = PointToLargeArealDist2D(L->x[j], L->y[j],A,&unusedint,&unuseddbl);

   if((ptpdist1 >= 0.0) && (ptpdist1 <= tolerance)) /** seems we have found the condition ***/
      {
      return(1);
      }

   for(j=1; j<L->numnodes; j++)
      {
      jj = j - 1;
      if(L->x[j] < L->x[jj])
         {
         minxPadded = L->x[j];
         maxxPadded = L->x[jj];
         }
      else
         {
         minxPadded = L->x[jj];
         maxxPadded = L->x[j];
         }

      if(L->y[j] < L->y[jj])
         {
         minyPadded = L->y[j];
         maxyPadded = L->y[jj];
         }
      else
         {
         minyPadded = L->y[jj];
         maxyPadded = L->y[j];
         }

      minxPadded -= tolerance;
      maxxPadded += tolerance;
      minyPadded -= tolerance;
      maxyPadded += tolerance;

      if(A->RB_Tree_Edgelist == NULL)
         ptpdist1 = AvgSegmentToSmallArealDist2D(L->x[j], L->y[j],L->x[jj],L->y[jj],
                                         minxPadded,minyPadded,maxxPadded,maxyPadded,A,&k,&kk);
      else
         ptpdist1 = AvgSegmentToLargeArealDist2D(L->x[j], L->y[j],L->x[jj],L->y[jj],
                                         minxPadded,minyPadded,maxxPadded,maxyPadded,A,&k,&kk);

      if((ptpdist1 >= 0) && (ptpdist1 <= tolerance))
         return(1);
      }
   return(0);
}





void PruneCheckedAreaPairs(int Limit, int index)
{
   if(AreaPairRoot[index].entry == NULL)
      {
      return;
      }
   APp = APc = AreaPairRoot[index].entry;
   while(APc != NULL)
      {
      if(APc->maxindex < Limit) /*** want to prune this one ***/
         {
         if(APc == AreaPairRoot[index].entry)
            {
            AreaPairRoot[index].entry = AreaPairRoot[index].entry->next;
            PWc = APc->p;
            while(PWc != NULL)
               {
               PWp = PWc;
               PWc = PWc->next;
               free(PWp);
               }
            free(APc);
            APp = APc = AreaPairRoot[index].entry;
            }
         else
            {
            APp->next = APc->next;
            PWc = APc->p;
            while(PWc != NULL)
               {
               PWp = PWc;
               PWc = PWc->next;
               free(PWp);
               }
            free(APc);
            APc = APp->next;
            }
         }
      else
         {
         APp = APc;
         APc = APc->next;
         }
      }
}




void FreeCheckedAreaPairs(int index)
{
   if(AreaPairRoot[index].entry == NULL)
      {
      return;
      }
   APc = AreaPairRoot[index].entry;
   while(APc != NULL)
      {
      PWc = APc->p;
      while(PWc != NULL)
         {
         PWp = PWc;
         PWc = PWc->next;
         free(PWp);
         }
      APp = APc;
      APc = APc->next;
      free(APp);
      }
   AreaPairRoot[index].entry = NULL;
}


void RemoveCheckedAreaPair(int index, double fidA, double fidB, double AreaA, double AreaB)
{
double fid1, fid2;
int foundit;
   foundit = 0;
   if(AreaA > AreaB) /** make the larger area feature serve as the key ... ***/
      {
      fid1 = fidA;
      fid2 = fidB;
      }
   else
      {
      fid1 = fidB;
      fid2 = fidA;
      }
   APp = APc = AreaPairRoot[index].entry;
   while(APc != NULL)
      {
      if(APc->fid == fid1)
         {
         PWp = PWc = APc->p;
         while(PWc != NULL)
            {
            if(PWc->fid == fid2)
               {
               foundit = 1;
               if(PWc == APc->p)
                  {
                  if(APc->p->next == NULL) /** only one on this list ***/
                     {
                     free(PWc);
                     if(APc == AreaPairRoot[index].entry)
                        {
                        if(APc->next == NULL)
                           {
                           free(APc);
                           AreaPairRoot[index].entry = NULL;
                           }
                        else
                           {
                           AreaPairRoot[index].entry = APc->next;
                           free(APc);
                           }
                        }
                     else
                        {
                        APp->next = APc->next;
                        free(APc);
                        }
                     }
                  else
                     {
                     APc->p = PWc->next;
                     free(PWc);
                     }
                  }
               else
                  {
                  PWp = PWc->next;
                  free(PWc);
                  }
               }
            if(foundit > 0)
               break;
            PWp = PWc;
            PWc = PWc->next;
            }
         }
      if(foundit > 0)
         break;
      APp = APc;
      APc = APc->next;
      }
   if(foundit == 0)
      {
      printf("unexpected condition in RemoveCheckedAreaPair()\n");
      exit(1);
      }
   return;
}



int CheckThisAreaPair(int index, int LM_Index, int ColumnIndex, int SzPC, int SzPW, double fidA, double fidB,int firstTime1, int firstTime2, double AreaA, double AreaB)
{
int answer;
double fid1, fid2;

   answer = 0;
   if(AreaA > AreaB) /** make the larger area feature serve as the key ... ***/
      {
      fid1 = fidA;
      fid2 = fidB;
      }
   else
      {
      fid1 = fidB;
      fid2 = fidA;
      }

   APc = AreaPairRoot[index].entry;
   while(APc != NULL)
      {
      if(APc->fid == fid1)
         {
         APc->maxindex = ColumnIndex;
         PWc = APc->p;
         while(PWc != NULL)
            {
            if(PWc->fid == fid2)
               break;
            PWc = PWc->next;
            }
         if(PWc == NULL)
            {
            answer = 1;
            PWn = (struct pairedwith *) (malloc(SzPW));
            if(PWn != NULL)
               {
               PWn->fid = fid2;
               PWn->next = APc->p;
               APc->p = PWn;
               }
            else
               {
               printf("out of memory in pair saving3\n");
               exit(-1);
               }
            }
         break;
         }
      APc = APc->next;
      }
   if(APc == NULL)
      {
      answer = 1;
      APn = (struct PairsChecked *) (malloc(SzPC));
      if(APn != NULL)
         {
         APn->maxindex = ColumnIndex;
         APn->fid = fid1;
         APn->p = NULL;
         PWn = (struct pairedwith *) (malloc(SzPW));
         if(PWn != NULL)
            {
            PWn->fid = fid2;
            PWn->next = NULL;
            APn->p = PWn;
            }
         else
            {
            printf("out of memory in pair saving2\n");
            exit(-1);
            }
         APn->next = AreaPairRoot[index].entry;
         AreaPairRoot[index].entry = APn;
         }
      }
   return(answer);
}




void PrintAndFreeCTC(int cindex)
{
struct Edges *Eroot,*Ep, *Ec, *En, *Elast;
int foundone;
int numedges,k;
double *X, *Y, *Z;

   X = NULL;
   Y = NULL;
   Z = NULL;
   CTCp = CTCc = CTCroot;
   while(CTCc != NULL)
      {
      if((CTCc->maxindex <= cindex) || (cindex < 0))
         {
         numedges = 0;
         while(CTCc->listofedges != NULL)
            {
            Ec = CTCc->listofedges;
            while(Ec != NULL)
               {
               Ep = Ec;
               En = Ec->next;
               while(En != NULL)
                  {
                  if((Ec->x1 == En->x1) && (Ec->y1 == En->y1))
                     {
                     Ep->next = En->next;
                     free(En);
                     En = Ep->next;
                     }
                  else
                     {
                     Ep = En;
                     En = En->next;
                     }
                  }
               Ec = Ec->next;
               }


            numedges = 0;
            if(CTCc->listofedges != NULL)
               numedges = 1;
            Eroot = CTCc->listofedges;
            CTCc->listofedges = CTCc->listofedges->next;
            Eroot->next = NULL;
            Elast = Eroot;
            foundone = 0;
            do
               {
               foundone = 0;
               Ep = Ec = CTCc->listofedges;
               while(Ec != NULL)
                  {
                  if((Eroot->x1 == Ec->x1) && (Eroot->y1 == Ec->y1) && (Eroot->z1 == Ec->z1))
                     {
                     if(Ec == CTCc->listofedges)
                        CTCc->listofedges = CTCc->listofedges->next;
                     else
                        Ep->next = Ec->next;
                     Ec->x1 = Ec->x2;
                     Ec->y1 = Ec->y2;
                     Ec->z1 = Ec->z2;
                     Ec->x2 = Eroot->x1;
                     Ec->y2 = Eroot->y1;
                     Ec->z2 = Eroot->z1;
                     Ec->next = Eroot;
                     Eroot = Ec;
                     foundone = 1;
                     ++numedges;
                     break;
                     }
                  else if((Eroot->x1 == Ec->x2) && (Eroot->y1 == Ec->y2) && (Eroot->z1 == Ec->z2))
                     {
                     if(Ec == CTCc->listofedges)
                        CTCc->listofedges = CTCc->listofedges->next;
                     else
                        Ep->next = Ec->next;
                     Ec->next = Eroot;
                     Eroot = Ec;
                     foundone = 1;
                     ++numedges;
                     break;
                     }
                  else if((Elast->x2 == Ec->x1) && (Elast->y2 == Ec->y1) && (Elast->z2 == Ec->z1))
                     {
                     if(Ec == CTCc->listofedges)
                        CTCc->listofedges = CTCc->listofedges->next;
                     else
                        Ep->next = Ec->next;
                     Ec->next = NULL;
                     Elast->next = Ec;
                     Elast = Ec;
                     foundone = 1;
                     ++numedges;
                     break;
                     }
                  else if((Elast->x2 == Ec->x2) && (Elast->y2 == Ec->y2) && (Elast->z2 == Ec->z2))
                     {
                     if(Ec == CTCc->listofedges)
                        CTCc->listofedges = CTCc->listofedges->next;
                     else
                        Ep->next = Ec->next;
                     Ec->next = NULL;
                     Elast->next = Ec;
                     Elast = Ec;
                     Ec->x2 = Ec->x1;
                     Ec->y2 = Ec->y1;
                     Ec->z2 = Ec->z1;
                     Ec->x1 = Elast->x2;
                     Ec->y1 = Elast->y2;
                     Ec->z1 = Elast->z2;
                     Ec->next = Elast;
                     Elast = Ec;
                     foundone = 1;
                     ++numedges;
                     break;
                     }
                  Ep = Ec;
                  Ec = Ec->next;
                  }
               } while(foundone > 0);

            if(numedges > 0)
               {
               X = (double *) (malloc(SzD * (numedges + 2)));
               Y = (double *) (malloc(SzD * (numedges + 2)));
               Z = (double *) (malloc(SzD * (numedges + 2)));
               X[0] = Eroot->x1;
               Y[0] = Eroot->y1;
               Z[0] = Eroot->z1;
               X[1] = Eroot->x2;
               Y[1] = Eroot->y2;
               Z[1] = Eroot->z2;
               k = 2;
               Ec = Eroot->next;
               free(Eroot);
               Eroot = NULL;
               while(Ec != NULL)
                  {
                  X[k] = Ec->x2;
                  Y[k] = Ec->y2;
                  Z[k] = Ec->z2;
                  ++k;
                  Ep = Ec;
                  Ec = Ec->next;
                  free(Ep);
                  }
               FwriteObject(CTCc->keyval,CTCc->Cnumber, CTCc->Lindex, CTCc->Sindex, G_LINE,/*CTCc->gform,*/ CTCc->localid,
                          CTCc->idn, -1.0, -1.0, X,Y,Z,k, 1);

               if(X != NULL)
                  free(X);
               if(Y != NULL)
                  free(Y);
               if(Z != NULL)
                  free(Z);
               }

            }
         }
      if((CTCc == CTCroot) && (CTCc->listofedges == NULL))
         {
         CTCroot = CTCroot->next;
         free(CTCc);
         CTCp = CTCc = CTCroot;
         }
      else if(CTCc->listofedges == NULL)
         {
         CTCp->next = CTCc->next;
         free(CTCc);
         CTCc = CTCp->next;
         }
      else
         {
         CTCp = CTCc;
         CTCc = CTCc->next;
         }
      }
}




int CheckGridsForContainment(int checktype, /** the define number for the inspection to apply **/
                                    int index, /** is = compositeindex **/
                                     int Cindex,  /*** is the checkinstance ***/
                                      struct RawAreal *A,  /** does the area contain a specific grid point ***/
                                      struct RawAreal *Root,
                                      double minx, double miny, double maxx, double maxy) /** LM bounds in internal coords **/
{
struct RawAreal *H;
int k, kk, LM_index1;
int SI1;
int FoundIt, unusedint;
double XG, YG, ZG;
int grows, gcols;
int part1, part2, part3;
unsigned int LI1;

   FoundIt = 0;
   if((NGT == NULL) || (NGT[index].NumGrids < 1)) /*** No Grids in this Cindex=Region ***/
      return(FoundIt);

   for(LM_index1=0; LM_index1<NGT[index].NumGrids; LM_index1++)
      {
      if((NGT[index].GridIndex != NULL) && (MG[LM_index1].numX > 0) && (MG[LM_index1].numY > 0))
         {
         k = NGT[index].GridIndex[LM_index1];

         LI1 = GridHeader[k].Lindex;
         SI1 = CrsWlk[LI1].LtoSmapping;
         if((CombinedCheckApplies(GridHeader[k].idn,Cindex,checktype,LI1,SI1,
                     SCCtable[SI1].C, SCCtable[SI1].S, SCCtable[SI1].D,
                     &part1,&part2,&part3) >  0) && (part2 > 0)) /*** check applies to this grid ***/
            {

            for(grows = 0; grows < MG[LM_index1].numX; grows++)
               {
               XG = MG[LM_index1].SouthWestX  + ((double) grows * MG[LM_index1].Xspace);
               if((XG >= minx) && (XG <= maxx))
                  {
                  for(gcols = 0; gcols < MG[LM_index1].numY; gcols++)
                     {
                     YG = MG[LM_index1].SouthWestY + ((double) gcols * MG[LM_index1].Yspace);

                     if((YG >= miny) && (YG <= maxy))
                        {

                        kk = (grows * MG[LM_index1].numY) + gcols;
   
                        ZG = MG[LM_index1].Elevs[kk];

                        if((ZG >= ActiveChecks[Cindex].sensitivity) && (ZG <= ActiveChecks[Cindex].sensitivity2))
                           {
                           if(A->RB_Tree_Edgelist == NULL) 
                              {
                              if(PointInAreal(XG,YG, A->x, A->y,A->numverts, &unusedint) > 0)
                                 {
                                 FoundIt = 1;
                                 }
                              }
                           else
                              {
                              if(PointInsideLargeAreal(XG,YG,A,&unusedint) > 0)
                                 {
                                 FoundIt = 1;
                                 }
                              }
                           if(FoundIt > 0)
                              {
                              H = Root;
                              while(H != NULL)
                                 {
                                 if((H != A) && (H->ishole > 0) && (H->idn == A->idn))
                                    {
                                    if(H->RB_Tree_Edgelist == NULL)
                                       {
                                       if(PointInAreal(XG,YG, H->x, H->y,H->numverts, &unusedint) > 0)
                                          {
                                          FoundIt = 0;
                                          break;
                                          }
                                       }
                                    else
                                       {
                                       if(PointInsideLargeAreal(XG,YG,H,&unusedint) > 0)
                                          {
                                          FoundIt = 0;
                                          break;
                                          }
                                       }
                                    }
                                 H = H->next;
                                 }
                              }
                           }
                        }
                     if(FoundIt > 0)
                        break;
                     }
                  }
               if(FoundIt > 0)
                  break;
               }
            }
         }
      if(FoundIt > 0)
         break;
      }
   return(FoundIt);
}



int TwoArealsPartISF(struct RawAreal *A, struct RawAreal *B,
                               double *xi, double *yi, int *Aindex, int *Bindex)
{
int i,j,iminus,iplus,jminus,jplus,outsidei;
int share_vertex, inside, outside;
double xint, yint,dist;
double fudgefactor = 0.09;

   share_vertex = 0;
   inside = outside = 0;

   if(1)
      {
      for(i=0; i<A->numverts; i++)
         {
         Areal1ForIntersections[i] = -1;
         Areal1Shared[i] = -1;
         }

      for(i=0; i<B->numverts; i++)
         {
         Areal2ForIntersections[i] = -1;
         Areal2Shared[i] = -1;
         }

      iminus = A->numverts - 1;
      for(i=0; i<A->numverts; i++)
         {
         jminus = B->numverts - 1;
         for(j=0; j<B->numverts; j++)
            {
            if(EqualWithinTolerance(A->x[i],A->y[i],B->x[j],B->y[j],fudgefactor) > 0)
               {
               Areal1Shared[i] = j;
               Areal2Shared[j] = i;
               ++share_vertex;
               }
            else if(PointOnLineSegment(A->x[i],A->y[i],B->x[jminus],B->y[jminus],B->x[j],B->y[j],fudgefactor) > 0)
               {
               Areal1ForIntersections[i] = j;
               }
             if((Areal2Shared[j] < 0) &&
                   (PointOnLineSegment(B->x[j],B->y[j],A->x[iminus],A->y[iminus],A->x[i],A->y[i],fudgefactor) > 0))
               {
               Areal2ForIntersections[j] = i;
               }
             jminus = j;
            }
         iminus = i;
         }
      iminus = A->numverts - 1;
      iplus = 1;
      inside = outside = 0;
      for(i=0; i<A->numverts; i++)
         {
         if((Areal1ForIntersections[i] >= 0) && (Areal1Shared[i] < 0))
            {
            j = Areal1ForIntersections[i];
            if(j == 0)
               jminus = B->numverts - 1;
            else
               jminus = j -1;
            dist = PointToFullLineDist2D(A->x[iminus],A->y[iminus],B->x[jminus],B->y[jminus],B->x[j],B->y[j]);
            if(dist > fudgefactor)
               {
               dist = PointToFullLineDist2D(A->x[iplus],A->y[iplus],B->x[jminus],B->y[jminus],B->x[j],B->y[j]);
               if(dist > fudgefactor)
                  {
                  if(TwoPointsOnSameSideOfLineSegment(A->x[iminus],A->y[iminus],A->x[iplus],A->y[iplus],
                           B->x[jminus],B->y[jminus],B->x[j],B->y[j]) == 0)
                     {
                     *xi = A->x[i];
                     *yi = A->y[i];
                     *Aindex = i;
                     *Bindex = j;
                     return(1);
                     }
                  }
               }
            }
         else if((Areal1Shared[i] >= 0)  && (Areal1Shared[iminus] < 0) && (Areal1Shared[iplus] < 0) &&
                (Areal1ForIntersections[iminus] < 0) && (Areal1ForIntersections[iplus] < 0))
            {
            j = Areal1Shared[i];
            if(j == 0)
               jminus = B->numverts - 1;
            else
               jminus = j - 1;
            jplus = j + 1;
            if(jplus == B->numverts)
               jplus = 0;
            if((Areal2ForIntersections[jplus] != i) && (Areal2ForIntersections[jplus] != iplus) &&
                (Areal2ForIntersections[j] != i) && (Areal2ForIntersections[j] != iplus) &&
                (TwoPointsOnSameSideOfLineSegment(A->x[iminus],A->y[iminus],A->x[iplus],A->y[iplus],
                           B->x[jminus],B->y[jminus],B->x[j],B->y[j]) == 0)  &&
                (TwoPointsOnSameSideOfLineSegment(A->x[iminus],A->y[iminus],A->x[iplus],A->y[iplus],
                           B->x[j],B->y[j],B->x[jplus],B->y[jplus]) == 0) &&
                 (TwoPointsOnSameSideOfLineSegment(B->x[jminus],B->y[jminus],B->x[jplus],B->y[jplus],
                           A->x[iminus],A->y[iminus],A->x[i],A->y[i]) == 0)  &&
                 (TwoPointsOnSameSideOfLineSegment(B->x[jminus],B->y[jminus],B->x[jplus],B->y[jplus],
                           A->x[i],A->y[i],A->x[iplus],A->y[iplus]) == 0))
               {
               *xi = A->x[i];
               *yi = A->y[i];
               *Aindex = i;
               *Bindex = j;
               return(1);
               }
            }
         else if((Areal1Shared[i] < 0) && (Areal1ForIntersections[i] < 0) &&
                  (Areal1Shared[iminus] < 0) && (Areal1ForIntersections[iminus] < 0)) 
            {
            jminus = B->numverts - 1;
            for(j = 0; j < B->numverts; j++)
               {
               if((LineSegmentsIntersect(A->x[iminus],A->y[iminus],A->x[i],A->y[i],
                          B->x[jminus],B->y[jminus],B->x[j],B->y[j],&xint,&yint) > 0) &&
                     (Distance(xint,yint,B->x[jminus],B->y[jminus]) > fudgefactor) &&
                      (Distance(xint,yint,B->x[j],B->y[j]) > fudgefactor))
                  {
                  *xi = xint;
                  *yi = yint;
                  *Aindex = i;
                  *Bindex = j;
                  return(1);
                  }
               jminus = j;
               }
            }

         if((Areal1Shared[i] < 0) && (Areal1ForIntersections[i] < 0))
            {
            if(PointInsidePoly(A->x[i],A->y[i],B->x,B->y,B->numverts) > 0)
               ++inside;
            else
               {
               ++outside;
               outsidei = i;
               }
            }

         if((inside > 0) && (outside > 0))
            {
            *xi = A->x[outsidei];
            *yi = A->y[outsidei];
            *Aindex = outsidei;
            *Bindex = 0;
            return(1);
            }

         iminus = i;
         ++iplus;
         if(iplus == A->numverts)
            iplus = 0;
         }
      }

   if((outside > 0) && (A->ishole <= 0))
      {
      for(j=0; j<B->numverts; j++)
         {
         if(Areal2Shared[j] < 0)
            {
            if((Areal2ForIntersections[j] < 0) && 
                  (PointInsidePoly(B->x[j],B->y[j],A->x,A->y,A->numverts) > 0))
               {
               *xi = B->x[j];
               *yi = B->y[j];
               *Aindex = 0;
               *Bindex = j;
               return(2);
               }
            break;
            }
         }
      }
   return(0);
}




void PerformArealRelatedChecks(char * prompt, int cindex,struct RawAreal *root,double minx,double miny,double maxx,double maxy, double multiplier,
    int  NorthCount, int SouthCount, int EastCount, int WestCount,
    struct RawLinear *Lroot, struct RawBridge *Broot, struct RawPoint *Proot, struct ListOfEdges *PEroot, struct RawAreal * NeighborARoot, int IndexLimit, int SzPC, int SzPW)
{

struct RawAreal *rac, *ran, *ra2, *rah, *ra_out, *ra_in, *ra_3part, *which_root, *rasave;
struct RawLinear *rlc, *rln, *rlsave;
struct RawPoint *rpc, *rpn, *rpsave;
struct ConditionCollection *RB_cond;
extern int NumberPF;
extern int *PF_Lindex;
extern int *PF_Iindex;
int checkit, checkit2, unusedint, upindex,lowindex, thiskey;
int spikewritten, adchwritten,openwritten,closedwritten,gtwritten,ltwritten;
int i,j,k,i2,i3,i4,kk,ii,iii,ii3,jj,jj2, iix,iiy, AListCount, NeighborJ, HGT_type, ZV2_type, NAM_type;
int savei, saveii, savej, savejj, whichline, I_HGTval, I_ZV2val,I_NAMval, i_minus,i_plus;
double SentinelValue, D_HGTval, D_ZV2val, D_NAMval;
double mindist, ptldist1, ptldist2, ptldist1a, ptldist2a, ptldistavg, minptldist,  chktolerance;
double x1, y1, x2, y2, z1, z2, z3, z4, zdiff,xi,yi, xi2, yi2,unuseddbl;
double xt1, yt1, xt2, xt3, yt3, xt4, yt4, px, py, px2, py2, px3, py3;
double temp, temp2, tempsensitivity,tempsensitivity2,tolerancepad,Tolerance;
double d1,d2,d3,d4;
double X[4], Y[4], Z[4];
double *FSx, *FSy, *FSz;
double xint, yint;
double LenToCover, CoveredSoFar, MatchLen, perim_angle,perimeter_length;
double L1minx, L1miny, L1maxx, L1maxy;
double L2minx, L2miny, L2maxx, L2maxy;
double slopeangle1, slopeangle2;
double basedist, segdist;
double *WidthList;
int part1, part2, part3;
int Part1Save, Part2Save;
int part1a, part1b, part1c, part1d, part1e;
int Config1, Strat1, Domain1;
int Config2, Strat2, Domain2;
int foundpair,FoundCondition;
int PassCond,PassCond2, PassCond3;
int checkinstance;
int foundobject,isclose, AinAresult;
int LastJ, LastI,maxXindex, minXindex, maxYindex, minYindex;
int HasSentinel, HasActual;
int found_one, found_two;
int BasedOnPoint,BasedOnEdges, AOAindex1, AOAindex2, AOAnext1, AOAnext2, AOAprev1, AOAprev2, FinalPointCheck;
int *FrontSide, *BackSide;
unsigned char clipflag;
struct collection
   {
   int keyval;
   int Cnumber;
   double px_int, py_int, pz_int;
   double x[4];
   double y[4];
   double z[4];
   double magnitude;
   int IDN1;
   int IDN2;
   unsigned int Sindex1,Sindex2;
   int vertexindex1, vertexindex2;
   int numverts1, numverts2;
   /***double *x1, *y1, *z1;
   double *x2, *y2, *z2; ***/
   struct RawAreal *aa, *aa2;
   struct RawPoint *pp;
   struct ListOfEdges *le;
   struct RawLinear *ll;
   struct ThePolys *poly;
   struct collection * next;
   } *ERroot, *ERc, *ERn, *ERp;
struct RB_Edgelist * LastEdge, *LastEdge1, *LastEdge2;
struct Edges *edgeC, *edgeN;
struct NeighborEdges
   {
   struct RawAreal *a;
   int edgeindex;
   struct NeighborEdges * next;
   } *NorthE, *SouthE, *EastE, *WestE, *NEc, *NEp;
int SzC = sizeof(struct collection);
int SzCC = sizeof(struct ConditionCollection);
int SzNE = sizeof(struct NeighborEdges);
/***int SzCV = sizeof(struct CodesAndValue);
int SzCVl = sizeof(struct CandVlist);****/
int SzCTC = sizeof(struct CondToCollect);
int SzE = sizeof(struct Edges);
int abortNow = 0;
int AddNorth, AddSouth, AddEast, AddWest;
int UsedTree;
int TouchingAreals;
int MYI;
char S_HGTval[100], S_ZV2val[100], S_NAMval[1000];
char Tstring[500];


extern int LONG_ATTR_CHECK_HGT;
extern int LONG_ATTR_CHECK_ZV2;
extern int LONG_ATTR_CHECK_NAM;
extern int C_TYPE;
extern int D_TYPE;
extern int I_TYPE;
extern int GetLongAttrVal(int type,int uniqueid,int *Ival,double *Dval,char *Cval);


   NorthE = SouthE = WestE = EastE = NULL;

   ERroot = NULL;
   rac = root;

   MYI = MaxYindex + 1;

   while(rac != NULL)
      {
      Config1 = SCCtable[rac->Sindex].C;
      Strat1 = SCCtable[rac->Sindex].S;
      Domain1 = SCCtable[rac->Sindex].D;

      
      spikewritten = adchwritten = openwritten = closedwritten = gtwritten = ltwritten = 0;

     checkinstance = -1;
     j = 0;
     if(rac->firstindex == cindex)
        {
        j = CombinedCheckApplies(rac->idn,checkinstance,ELEVGT,rac->Lindex,rac->Sindex,Config1,Strat1,Domain1,&part1a,&part2,&part3);
        j += CombinedCheckApplies(rac->idn,checkinstance,ELEVLT,rac->Lindex,rac->Sindex,Config1,Strat1,Domain1,&part1b,&part2,&part3);
        j += CombinedCheckApplies(rac->idn,checkinstance,ELEVEQ,rac->Lindex,rac->Sindex,Config1,Strat1,Domain1,&part1c,&part2,&part3);
        j += CombinedCheckApplies(rac->idn,checkinstance,ELEVEQOPEN,rac->Lindex,rac->Sindex,Config1,Strat1,Domain1,&part1c,&part2,&part3);
        j += CombinedCheckApplies(rac->idn,checkinstance,ELEVADJCHANGE,rac->Lindex,rac->Sindex,Config1,Strat1,Domain1,&part1d,&part2,&part3);
        j += CombinedCheckApplies(rac->idn,checkinstance,FEATSPIKE,rac->Lindex,rac->Sindex,Config1,Strat1,Domain1,&part1e,&part2,&part3);
        }

     if(j > 0)
         {
         LastEdge = NULL;
         LastJ = -1;

         IgnoreDrawingSettings = 1;
         part1 = part1a + part1b + part1c + part1d + part1e;
         if((part1 > 0) && (rac->numverts > 1))
            {
/***/
            for(checkinstance = 0; checkinstance < TtlActiveChecks; checkinstance++)
               {
spikewritten = adchwritten = openwritten = closedwritten = gtwritten = ltwritten = 0;
               if(rac->RB_Tree_Edgelist == NULL)
                  {
                  j = 0;
                  UsedTree = 0;
                  }
               else
                  {
                  j = GetNextArealIndex(rac, LastJ, 1, &LastEdge, cindex, &UsedTree);
                  LastJ = j;
                  }
               while(j >= 0)
                  {
                  if(j == 0)
                     {
                     z1 = rac->z[rac->numverts - 1];
                     z2 = rac->z[j];
                     x1 = rac->x[rac->numverts - 1];
                     x2 = rac->x[j];
                     y1 = rac->y[rac->numverts - 1];
                     y2 = rac->y[j];
                     }
                  else
                     {
                     z1 = rac->z[j - 1];
                     z2 = rac->z[j];
                     x1 = rac->x[j - 1];
                     x2 = rac->x[j];
                     y1 = rac->y[j - 1];
                     y2 = rac->y[j];
                     }
                  if(UsedTree == 0)
                     {
                     PassCond = 0;
                     PassCond = ClipLineToRegion(minx,miny,maxx,maxy,&x1,&y1,&z1,
                                         &x2,&y2,&z2,&clipflag,multiplier);
                     if(clipflag > 0) /** then restore original z values ***/
                        {
                        if(j == 0)
                           {
                           z1 = rac->z[rac->numverts - 1];
                           z2 = rac->z[j];
                           x1 = rac->x[rac->numverts - 1];
                           x2 = rac->x[j];
                           y1 = rac->y[rac->numverts - 1];
                           y2 = rac->y[j];
                           }
                        else
                           {
                           z1 = rac->z[j - 1];
                           z2 = rac->z[j];
                           x1 = rac->x[j - 1];
                           x2 = rac->x[j];
                           y1 = rac->y[j - 1];
                           y2 = rac->y[j];
                           }
                        }
                     }
                  else
                     {
                     PassCond = 1;
                     }
                  if(PassCond > 0)
                     {
                     checkit = checkit2 = 0;
                     if(IsSentinelZvalue(z1,UseNUNANPO) == 0)
                        checkit = 1;
                     if(IsSentinelZvalue(z2,UseNUNANPO) == 0)
                        checkit2 = 1;

                  if((gtwritten == 0) && 
                    (CombinedCheckApplies(rac->idn,checkinstance,ELEVGT,rac->Lindex,rac->Sindex,Config1,Strat1,Domain1,&part1,&part2,&part3) > 0) &&
                      (part1 > 0))
                        {
                        if(SensitivityCheck(GT, ELEVGT, checkinstance, z2) > 0)
                           {
                           gtwritten = 1;
                           ERc = (struct collection *) (malloc(SzC));
                           if(ERc == NULL)
                              {
                              printf("allocation memory exhausted during area feature condition analysis\n");
                              printf("processing cannot continue\n");
                              exit(-1);
                              }
                           ERc->magnitude = z2;
                           ERc->keyval = ELEVGT;
                           ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                           ERc->Sindex1 = rac->Sindex;
                           ERc->aa = rac;
                           ERc->next = NULL;
                           ERc->x[0] = x2;
                           ERc->y[0] = y2;
                           ERc->z[0] = z2;
                           if(ERroot == NULL)
                              {
                              ERroot = ERc;
                              }
                           else
                              {
                              ERn = ERroot;
                              while(ERn != NULL)
                                 {
                                 if(
				    (ERn->Cnumber    == ERc->Cnumber)    &&				    
				    (ERn->keyval    == ERc->keyval)    && 
				    (ERn->x[0]      == ERc->x[0])      &&
				    (ERn->magnitude == ERc->magnitude) && 
				    (ERn->y[0]      == ERc->y[0])      && 
				    (ERn->aa   == ERc->aa)
				    )
                                    break;
                                 ERn = ERn->next;
                                 }
                              if(ERn == NULL)
                                 {
                                 ERc->next = ERroot;
                                 ERroot = ERc;
                                 }
                              else
                                 free(ERc);
                              }
                           }
                        }
                     if((ltwritten == 0) && 
                         (CombinedCheckApplies(rac->idn,checkinstance,ELEVLT,rac->Lindex,rac->Sindex,Config1,Strat1,Domain1,&part1,&part2,&part3) > 0) &&
                             (part1 > 0))
                        {
                        if(SensitivityCheck(LT, ELEVLT, checkinstance, z2) > 0)
                           {
                           ltwritten = 1;
                           ERc = (struct collection *) (malloc(SzC));
                           if(ERc == NULL)
                              {
                              printf("allocation memory exhausted during area feature condition analysis\n");
                              printf("processing cannot continue\n");
                              exit(-1);
                              }
                           ERc->magnitude = z2;
                           ERc->keyval = ELEVLT;
                           ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                           ERc->Sindex1 = rac->Sindex;
                           ERc->aa = rac;
                           ERc->next = NULL;
                           ERc->x[0] = x2;
                           ERc->y[0] = y2;
                           ERc->z[0] = z2;
                           if(ERroot == NULL)
                              {
                              ERroot = ERc;
                              }
                           else
                              {
                              ERn = ERroot;
                              while(ERn != NULL)
                                 {
                                 if(
				    (ERn->Cnumber    == ERc->Cnumber)    &&
				    (ERn->keyval    == ERc->keyval)    && 
				    (ERn->x[0]      == ERc->x[0])      &&
				    (ERn->magnitude == ERc->magnitude) && 
				    (ERn->y[0]      == ERc->y[0])      && 
				    (ERn->aa   == ERc->aa)
				    )
                                    break;
                                 ERn = ERn->next;
                                 }
                              if(ERn == NULL)
                                 {
                                 ERc->next = ERroot;
                                 ERroot = ERc;
                                 }
                              else
                                 free(ERc);
                              }
                           }
                        }

                     if((closedwritten == 0) && 
                        (CombinedCheckApplies(rac->idn,checkinstance,ELEVEQ,rac->Lindex,rac->Sindex,Config1,Strat1,Domain1,&part1,&part2,&part3) > 0) &&
                          (part1 > 0))
                        {
                        if(((checkit > 0) && (SensitivityCheck(CLOSEDINT, ELEVEQ, checkinstance, z1) > 0)) ||
                             ((checkit2 > 0) && (SensitivityCheck(CLOSEDINT, ELEVEQ, checkinstance, z2) > 0)))
                           {
                           closedwritten = 1;
                           ERc = (struct collection *) (malloc(SzC));
                           if(ERc == NULL)
                              {
                              printf("allocation memory exhausted during area feature condition analysis\n");
                              printf("processing cannot continue\n");
                              exit(-1);
                              }
                           if((checkit > 0) && (SensitivityCheck(CLOSEDINT, ELEVEQ, checkinstance, z1) > 0))
                              ERc->magnitude = z1;
                           else
                              ERc->magnitude = z2;
                           ERc->keyval = ELEVEQ;
                           ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                           ERc->Sindex1 = rac->Sindex;
                           ERc->aa = rac;
                           ERc->next = NULL;
                           ERc->x[0] = x1;
                           ERc->y[0] = y1;
                           ERc->z[0] = z1;
                           ERc->x[1] = x2;
                           ERc->y[1] = y2;
                           ERc->z[1] = z2;
                           if(ERroot == NULL)
                              {
                              ERroot = ERc;
                              }
                           else
                              {
                              ERn = ERroot;
                              while(ERn != NULL)
                                 {
                                 if(
				    (ERn->Cnumber    == ERc->Cnumber)    &&
				    (ERn->keyval    == ERc->keyval)    && 
				    (ERn->x[1]      == ERc->x[1])      &&
				    (ERn->magnitude == ERc->magnitude) && 
				    (ERn->y[1]      == ERc->y[1])      && 
				    (ERn->Sindex1   == ERc->Sindex1)
				    )
                                    break;
                                 ERn = ERn->next;
                                 }
                              if(ERn == NULL)
                                 {
                                 ERc->next = ERroot;
                                 ERroot = ERc;
                                 }
                              else
                                 free(ERc);
                              }
                           }
                        }


                     if((openwritten == 0) &&
                        (CombinedCheckApplies(rac->idn,checkinstance,ELEVEQOPEN,rac->Lindex,rac->Sindex,Config1,Strat1,Domain1,&part1,&part2,&part3) > 0) &&
                          (part1 > 0))
                        {
                        if(((checkit > 0) && (SensitivityCheck(OPENINT, ELEVEQOPEN, checkinstance, z1) > 0)) ||
                             ((checkit2 > 0) && (SensitivityCheck(OPENINT, ELEVEQOPEN, checkinstance, z2) > 0)))
                           {
                           openwritten = 1;
                           ERc = (struct collection *) (malloc(SzC));
                           if(ERc == NULL)
                              {
                              printf("allocation memory exhausted during area feature condition analysis\n");
                              printf("processing cannot continue\n");
                              exit(-1);
                              }
                           if((checkit > 0) && (SensitivityCheck(OPENINT, ELEVEQOPEN, checkinstance, z1) > 0))
                              ERc->magnitude = z1;
                           else
                              ERc->magnitude = z2;
                           ERc->keyval = ELEVEQOPEN;
                           ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                           ERc->Sindex1 = rac->Sindex;
                           ERc->aa = rac;
                           ERc->next = NULL;
                           ERc->x[0] = x1;
                           ERc->y[0] = y1;
                           ERc->z[0] = z1;
                           ERc->x[1] = x2;
                           ERc->y[1] = y2;
                           ERc->z[1] = z2;
                           if(ERroot == NULL)
                              {
                              ERroot = ERc;
                              }
                           else
                              {
                              ERn = ERroot;
                              while(ERn != NULL)
                                 {
                                 if(
                                    (ERn->Cnumber    == ERc->Cnumber)    &&
                                    (ERn->keyval    == ERc->keyval)    &&
                                    (ERn->x[1]      == ERc->x[1])      &&
                                    (ERn->magnitude == ERc->magnitude) &&
                                    (ERn->y[1]      == ERc->y[1])      &&
                                    (ERn->Sindex1   == ERc->Sindex1)
                                    )
                                    break;
                                 ERn = ERn->next;
                                 }
                              if(ERn == NULL)
                                 {
                                 ERc->next = ERroot;
                                 ERroot = ERc;
                                 }
                              else
                                 free(ERc);
                              }
                           }
                        }

   
                     if((checkit > 0) && (checkit2 > 0) && (adchwritten >= 0) &&
                       (CombinedCheckApplies(rac->idn,checkinstance,ELEVADJCHANGE,rac->Lindex,rac->Sindex,Config1,Strat1,Domain1,&part1,&part2,&part3) > 0) &&
                          (part1 > 0))
                        {
                        if(z1 > z2)
                           zdiff = z1 - z2;
                        else
                           zdiff = z2 - z1;
                        if(SensitivityCheck(GTEQ, ELEVADJCHANGE, checkinstance, zdiff) > 0) 
                           {
                           adchwritten = 1;
                           ERc = (struct collection *) (malloc(SzC));
                           if(ERc == NULL)
                              {
                              printf("allocation memory exhausted during area feature condition analysis\n");
                              printf("processing cannot continue\n");
                              exit(-1);
                              }
                           ERc->magnitude = zdiff;
                           ERc->keyval = ELEVADJCHANGE;
                           ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                           ERc->Sindex1 = rac->Sindex;
                           ERc->aa = rac;
                           ERc->next = NULL;
                           ERc->x[0] = x1;
                           ERc->y[0] = y1;
                           ERc->z[0] = z1;
                           ERc->x[1] = x2;
                           ERc->y[1] = y2;
                           ERc->z[1] = z2;
                           if(ERroot == NULL)
                              {
                              ERroot = ERc;
                              }
                           else
                              {
                              ERn = ERroot;
                              while(ERn != NULL)
                                 {
				   if(
				      (ERn->Cnumber    == ERc->Cnumber)               &&
				      (ERn->keyval    == ERc->keyval)               &&
				      (ERc->magnitude == ERn->magnitude)            && 
				      (ERn->Sindex1   == ERc->Sindex1)              &&
				      (SameEdge(ERc->x[0], ERc->y[0], ERc->z[0], 
						ERc->x[1], ERc->y[1], ERc->z[1],
						ERn->x[0], ERn->y[0], ERn->z[0], 
						ERn->x[1], ERn->y[1], ERn->z[1]) > 0)
				      )
				     break;
                                 ERn = ERn->next;
                                 }
                              if(ERn == NULL)
                                 {
                                 ERc->next = ERroot;
                                 ERroot = ERc;
                                 }
                              else
                                 free(ERc);
                              }
                           }
                        } /** end ELEVADJCHANGE for area features ***/



                     if((checkit > 0) && (checkit2 > 0) && (spikewritten >= 0) &&
                       (CombinedCheckApplies(rac->idn,checkinstance,FEATSPIKE,rac->Lindex,rac->Sindex,Config1,Strat1,Domain1,&part1,&part2,&part3) > 0) &&
                          (part1 > 0))
                        {
                        if(z1 > z2)
                           zdiff = z1 - z2;
                        else
                           zdiff = z2 - z1;
                        segdist = Distance(x1,y1,x2,y2);
                        slopeangle1 = atan(zdiff / segdist);
                        slopeangle1 = RadiansToDegrees(slopeangle1);

                        if((SensitivityCheck(GTEQ, FEATSPIKE, checkinstance, slopeangle1) > 0) &&
                             (segdist > ActiveChecks[checkinstance].sensitivity2))
                           {
                           spikewritten = 1;
                           ERc = (struct collection *) (malloc(SzC));
                           if(ERc == NULL)
                              {
                              printf("allocation memory exhausted during area feature condition analysis\n");
                              printf("processing cannot continue\n");
                              exit(-1);
                              }
                           ERc->magnitude = slopeangle1;
                           ERc->keyval = FEATSPIKE;
                           ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                           ERc->Sindex1 = rac->Sindex;
                           ERc->aa = rac;
                           ERc->next = NULL;
                           ERc->x[0] = x1;
                           ERc->y[0] = y1;
                           ERc->z[0] = z1;
                           ERc->x[1] = x2;
                           ERc->y[1] = y2;
                           ERc->z[1] = z2;
                           if(ERroot == NULL)
                              {
                              ERroot = ERc;
                              }
                           else
                              {
                              ERn = ERroot;
                              while(ERn != NULL)
                                 {
                                   if(
                                      (ERn->Cnumber    == ERc->Cnumber)               &&
                                      (ERn->keyval    == ERc->keyval)               &&
                                      (ERc->magnitude == ERn->magnitude)            &&
                                      (ERn->Sindex1   == ERc->Sindex1)              &&
                                      (SameEdge(ERc->x[0], ERc->y[0], ERc->z[0],
                                                ERc->x[1], ERc->y[1], ERc->z[1],
                                                ERn->x[0], ERn->y[0], ERn->z[0],
                                                ERn->x[1], ERn->y[1], ERn->z[1]) > 0)
                                      )
                                     break;
                                 ERn = ERn->next;
                                 }
                              if(ERn == NULL)
                                 {
                                 ERc->next = ERroot;
                                 ERroot = ERc;
                                 }
                              else
                                 free(ERc);
                              }
                           }
                        } /** end FEATSPIKE check for area features ***/

                     } /**** for(checkinstance = 0; checkinstance < TtlActiveChecks; checkinstance++) ***/

                  if(rac->RB_Tree_Edgelist == NULL)
                     {
                     ++j;
                     if(j >= rac->numverts)
                        break;
                     }
                  else
                     {
                     j = GetNextArealIndex(rac, LastJ, 1, &LastEdge, cindex, &UsedTree);
                     LastJ = j;
                     }
                  }
               }
            }
         IgnoreDrawingSettings = 0;
         }   
      if(abortNow > 0)
         break;


      if((ErrorLookup[AUNDERSHTA].anyactive > 0) && (NeighborARoot != NULL))
         {
         chktolerance = FindMaxSensitivities(AUNDERSHTA, &unuseddbl);
         chktolerance = chktolerance * 1.25;
         L1minx = minx - chktolerance;
         L1maxx = maxx + chktolerance;
         L1miny = miny - chktolerance;
         L1maxy = maxy + chktolerance;

         ran = NeighborARoot;
         while(ran != NULL)
            {
            for(i=0; i<ran->numverts; i++)
               {
               AddEast = AddWest = AddNorth = AddSouth = 0;

               j = (i + 1) % ran->numverts;

               if((ran->x[i] >= maxx) && (ran->x[j] <= L1maxx))
                  AddEast = 1;
               else if((ran->x[j] >= maxx) && (ran->x[i] <= L1maxx))
                  AddEast = 1;

               if((ran->x[i] >= L1minx) && (ran->x[j] <= minx))
                  AddWest = 1;
               else if((ran->x[j] >= L1minx) && (ran->x[i] <= minx))
                  AddWest = 1;

               if((ran->y[i] >= maxy) && (ran->y[j] <= L1maxy))
                  AddNorth = 1;
               else if((ran->y[j] >= maxy) && (ran->y[i] <= L1maxy))
                  AddNorth = 1;

               if((ran->y[i] >= L1miny) && (ran->y[j] <= miny))
                  AddSouth = 1;
               else if((ran->y[j] >= L1miny) && (ran->y[i] <= miny))
                  AddSouth = 1;

               if(AddEast > 0)
                  {
                  NEc = (struct NeighborEdges *) (malloc(SzNE));
                  if(NEc == NULL)
                     {
                     printf("memory has been exhausted during preparation for area feature undershoot / overshoot analysis\n");
                     printf("execution must terminate\n");
                     exit(-1);
                     }
                  NEc->a = ran;
                  NEc->edgeindex = i;
                  NEc->next = EastE;
                  EastE = NEc;
                  }
               if(AddWest > 0)
                  {
                  NEc = (struct NeighborEdges *) (malloc(SzNE));
                  if(NEc == NULL)
                     {
                     printf("memory has been exhausted during preparation for area feature undershoot / overshoot analysis\n");
                     printf("execution must terminate\n");
                     exit(-1);
                     }
                  NEc->a = ran;
                  NEc->edgeindex = i;
                  NEc->next = WestE;
                  WestE = NEc;
                  }
               if(AddNorth > 0)
                  {
                  NEc = (struct NeighborEdges *) (malloc(SzNE));
                  if(NEc == NULL)
                     {
                     printf("memory has been exhausted during preparation for area feature undershoot / overshoot analysis\n");
                     printf("execution must terminate\n");
                     exit(-1);
                     }
                  NEc->a = ran;
                  NEc->edgeindex = i;
                  NEc->next = NorthE;
                  NorthE = NEc;
                  }
               if(AddSouth > 0)
                  {
                  NEc = (struct NeighborEdges *) (malloc(SzNE));
                  if(NEc == NULL)
                     {
                     printf("memory has been exhausted during preparation for area feature undershoot / overshoot analysis\n");
                     printf("execution must terminate\n");
                     exit(-1);
                     }
                  NEc->a = ran;
                  NEc->edgeindex = i;
                  NEc->next = SouthE;
                  SouthE = NEc;
                  }
               }

            ran = ran->next;
            }
         }

      for(checkinstance = 0; checkinstance < TtlActiveChecks; checkinstance++)
         {
         if((rac->firstindex == cindex) || (rac->ishole > 0))
            {

            if((CombinedCheckApplies(rac->idn,checkinstance,FACESIZE,rac->Lindex,rac->Sindex,Config1,Strat1,Domain1,
                                             &part1,&part2,&part3) > 0) && (part1 > 0))
               {
               PassCond = 0;
               PassCond3 = 0;
               if(rac->area > ActiveChecks[checkinstance].sensitivity2)
                  {
                  perimeter_length = 0;
                  ii = rac->numverts - 1;
                  for(i=0; i < rac->numverts; i++)
                     {
                     perimeter_length += Distance(rac->x[ii],rac->y[ii],rac->x[i],rac->y[i]);
                     ii = i;
                     if(perimeter_length > ActiveChecks[checkinstance].sensitivity3)
                        {
                        PassCond = 1;
                        break;
                        }
                     }

                  FoundCondition = 0;
                  tempsensitivity = FindRelevantSensitivity(FACESIZE,checkinstance,&unuseddbl);
                  }
               if(PassCond > 0)
                  {
                  L1minx = minx - (1.5 * tempsensitivity);
                  L1maxx = maxx + (1.5 * tempsensitivity);
                  L1miny = miny - (1.5 * tempsensitivity);
                  L1maxy = maxy + (1.5 * tempsensitivity);
                  PassCond3 = 0;
                  found_one = 1;
                  FrontSide = (int *) (malloc(SzI * rac->numverts));
                  BackSide = (int *) (malloc(SzI * rac->numverts));
                  WidthList = (double *) (malloc(SzD * rac->numverts));
                  for(j=0; j<rac->numverts; j++)
                     {
                     FrontSide[j] = 0;
                     BackSide[j] = 0;
                     WidthList[j] = tempsensitivity + 10.0;
                     }

                  found_one = 1; /*** using this as the condition 'group' ****/
                  for(j=0; j<rac->numverts; j++)
                     {
                     if((rac->x[j] >= minx) && (rac->x[j] <= maxx) && (rac->y[j] >= miny) && (rac->y[j] <= maxy))
                        {
                        if(found_two == 0)
                           ++found_one;
                        found_two = 0;

                        if(rac->numverts > 3000)
                           {
                           if((j % 500) == 0)
                              periodic_checking_redraw(1,"Inspection Progress",prompt);
                           }
                        if((BackSide[j] == 0) && (FrontSide[j] == 0))
                           {
                           basedist = 0;
                           k = j;
                           upindex = 0;
                           while((basedist == 0) || (k != j))
                              {
                              ++upindex;
                              basedist += Distance(rac->x[j],rac->y[j],rac->x[k],rac->y[k]);
                              if(basedist > ActiveChecks[checkinstance].sensitivity3)
                                 break;
                              ++k;
                              if(k >= rac->numverts)
                                 k = 0;
                              }
                           basedist = 0;
                           kk = j;
                           lowindex = rac->numverts - 1;
                           while((basedist == 0) || (kk != j))
                              {
                              --lowindex;
                              basedist += Distance(rac->x[j],rac->y[j],rac->x[kk],rac->y[kk]);
                              if(basedist > ActiveChecks[checkinstance].sensitivity3)
                                 break;
                              --kk;
                              if(kk < 0)
                                 kk = rac->numverts-1;
                              }

                           i = j + 1;
                           kk = 0;
                           while(i != j)
                              {
                              ++kk;
                              ii = i - 1;
                              if(i >= rac->numverts)
                                 {
                                 i = 0;
                                 ii = rac->numverts - 1;
                                 }
                              checkit2 = 0;
                              if((rac->x[i] >= L1minx) && (rac->x[i] <= L1maxx) && (rac->y[i] >= L1miny) && (rac->y[i] <= L1maxy))
                                 checkit2 = 1;
                              else if ((rac->x[ii] >= L1minx) && (rac->x[ii] <= L1maxx) && (rac->y[ii] >= L1miny) && (rac->y[ii] <= L1maxy))
                                 checkit2 = 1;
                              if((checkit2 > 0) && (i != j) && (ii != j) && (ii != j + 1))
                                 {
                                 if((kk > upindex) && (kk < lowindex))
                                    {
                                    mindist = PointToLineDist2DwithFlag(rac->x[j],rac->y[j],
                                                rac->x[ii],rac->y[ii],rac->x[i],rac->y[i],&d4);
                                    if(mindist > tempsensitivity)
                                       FoundCondition = 0;
                                    else
                                       {
                                       FoundCondition = 1;
                                       if(d4 < 0)
                                          {
                                          xi = rac->x[ii];
                                          yi = rac->y[ii];
                                          xi2 = rac->x[ii];
                                          yi2 = rac->y[ii];
                                          }
                                       else if(d4 > 1)
                                          {
                                          xi = rac->x[i];
                                          yi = rac->y[i];
                                          xi2 = rac->x[i];
                                          yi2 = rac->y[i];
                                          }
                                       else
                                          {
                                          xi = rac->x[i];
                                          yi = rac->y[i];
                                          xi2 = rac->x[ii];
                                          yi2 = rac->y[ii];
                                          }
                                       }
                                    if(FoundCondition > 0)
                                       {
                                       jj2 = ConditionOnDataEdge(rac->x[i],rac->y[i],rac->x[ii],rac->y[ii],root,Proot,Lroot,
                                                     rac, NULL, NULL,
                                                     NorthCount,SouthCount,EastCount,WestCount,checkinstance);
                                       if(jj2 == 0)
                                          FoundCondition = 0;
                                       }

                                    if(FoundCondition > 0) /** is this small face area inside rac ?  ***/
                                       {

                                       CalculateMidPoint(xi,yi,xi2,yi2,&px,&py);
                                       CalculateMidPoint(rac->x[j],rac->y[j],px,py,&px2,&py2);
                                       checkit = 0;
                                       checkit = PointInAreal(px2, py2, rac->x,rac->y,rac->numverts, &iii);
if((rac->ishole <= 0) && (checkit < 1))
   FoundCondition = 0;
else if((rac->ishole > 0) && (checkit > 0))
   FoundCondition = 0;
                                       else
                                          {
                                          i2 = j + 1;
                                          if(i2 >= rac->numverts)
                                             i2 =0;
                                          i3 = i2 + 1;
                                          if(i3 >= rac->numverts)
                                             i3 = 0;
                                          do
                                             {
                                             if((i2 == i) && (i3 == ii))
                                                 ;
                                             else if((i2 == ii) && (i3 == i))
                                                 ;
                                             else if(LineSegmentsIntersect(rac->x[j],rac->y[j],PTL_Dist_Xi,PTL_Dist_Yi,
                                                      rac->x[i2],rac->y[i2],rac->x[i3],rac->y[i3],&px3,&py3) > 0)
                                                {
                                                FoundCondition = 0;
                                                break;
                                                }
                                             ++i2;
                                             if(i2 >= rac->numverts)
                                                i2 =0;
                                             i3 = i2 + 1;
                                             if(i3 >= rac->numverts)
                                                i3 = 0;
                                             } while(i3 != j);
                                          if(rac->ishole > 0)
                                             {
                                             if(FoundCondition == 0)
                                                FoundCondition = 1;
                                             else
                                                FoundCondition = 0;
                                             }
                                          }
                                       }

                                    if(FoundCondition > 0) /*** should we ignore it due to proximity to a second feature?  ***/
                                       {

                                          rlc = Lroot;
                                          while(rlc != NULL)
                                             {
                                             if((CombinedCheckApplies(rlc->idn,checkinstance,FACESIZE,rlc->Lindex,rlc->Sindex,
                                                SCCtable[rlc->Sindex].C, SCCtable[rlc->Sindex].S, SCCtable[rlc->Sindex].D,
                                                &part1,&part2,&part3) > 0) && (part2 > 0))
                                                {
                                                i3 = 0;
                                                for(i2=1; i2<rlc->numnodes; i2++)
                                                   {
                                                   temp2 = PointToLineDist2D(rac->x[j],rac->y[j], rlc->x[i2],rlc->y[i2], rlc->x[i3],rlc->y[i3]);
                                                   if(temp2 < ActiveChecks[checkinstance].sensitivity4)
                                                      {
                                                      FoundCondition = 0;
                                                      break;
                                                      }
                                                   temp2 = PointToLineDist2D(rac->x[i],rac->y[i], rlc->x[i2],rlc->y[i2], rlc->x[i3],rlc->y[i3]);
                                                   if(temp2 < ActiveChecks[checkinstance].sensitivity4)
                                                      {
                                                      FoundCondition = 0;
                                                      break;
                                                      }
                                                   temp2 = PointToLineDist2D(rac->x[ii],rac->y[ii], rlc->x[i2],rlc->y[i2], rlc->x[i3],rlc->y[i3]);
                                                   if(temp2 < ActiveChecks[checkinstance].sensitivity4)
                                                      {
                                                      FoundCondition = 0;
                                                      break;
                                                      }
                                                   i3 = i2;
                                                   }
                                                }
                                             if(FoundCondition == 0)
                                                break;
                                             rlc = rlc->next;
                                             }
                                          }
                  
                                    if((FoundCondition > 0) && ((BackSide[i] == 0) || (BackSide[i] == found_one)) &&
                                          ((BackSide[ii] == 0) || (BackSide[ii] == found_one)))
                                       {
                                       FrontSide[j] = found_one; /*** note that j belongs to condition group # found_one ****/
                                       WidthList[j] = mindist;
                                       if(d4 > 0)
                                         BackSide[i] = found_one;
                                       if(d4 < 1)
                                          BackSide[ii] = found_one; /** same with i and ii, but they are on the back side ***/
                                       found_two = 1;
                                       ++PassCond3;
                                       }
                                    } /*** end if((kk > upindex) && (kk < lowindex)) ***/
                                 } /**** end if((i != j) && (ii != j) && (ii != j + 1)) ***/
                              if(i == j)
                                 break;
                              ++i;
                              } /*** end while(i != j) ***/
                           } /*** end haven't already set this as a backside ***/
                        } /*** end point is in LM ***/
                     } /*** end for j < rac->numverts ***/
                  if(PassCond3 > 0) /*** found at least one condition to report ***/
                     {
                     FSx = (double *) (malloc(SzD * rac->numverts));
                     FSy = (double *) (malloc(SzD * rac->numverts));
                     FSz = (double *) (malloc(SzD * rac->numverts));
                     i = 0;
                     while(i < rac->numverts)
                        {
                        if(FrontSide[i] > 0)
                           {
                           mindist = WidthList[i];
                           ii = FrontSide[i];
                           j = 0;
                           while(FrontSide[i] == ii)
                              {
                              if(WidthList[i] < mindist)
                                 mindist = WidthList[i];
                              FSx[j] = rac->x[i];
                              FSy[j] = rac->y[i];
                              FSz[j] = rac->z[i];
                              ++j;
                              ++i;
                              if(i >= rac->numverts)
                                 break;
                              }
                           k = i + 1;
                           if(k >= rac->numverts)
                              k = 0;
                           while(k != i)
                              {
                              if(BackSide[k] == ii)
                                 {
                                 FSx[j] = rac->x[k];
                                 FSy[j] = rac->y[k];
                                 FSz[j] = rac->z[k];
                                 ++j;
                                 }
                              k += 1;
                              if(k == i)
                                 break;
                              if(k >= rac->numverts)
                                 k = 0;
                              }
                              FwriteObjectAndMagnitude(FACESIZE,Make_Correct(FACESIZE,checkinstance),
                                   rac->idn, rac->Sindex,G_AREAL,rac->Lindex,rac->localID,-1.0,-1.0,
                                   mindist,FSx,FSy,FSz,j, 1);
                           }
                        else
                           ++i;
                        } /** end while i < rac->numverts ***/
                     free(FSx);
                     free(FSy);
                     free(FSz);
                     }

                  free(FrontSide);
                  free(BackSide);
                  free(WidthList);
                  } /*** end if the check should be applied ***/
               } /*** end FACESIZE check ***/

            if((NGA_TYPE == 1) &&
               (CombinedCheckApplies(rac->idn,checkinstance,SLIVER,rac->Lindex,rac->Sindex,Config1,Strat1,Domain1,
                                              &part1,&part2,&part3) > 0) &&
                                                      (part1 > 0))
               {
               d1 = rac->area / rac->perimlength; /*** d1 should be the NGA sliver ratio ***/
               if(SensitivityCheck(LT, SLIVER, checkinstance, d1) > 0)
                  {
                  checkit = 1;
                  if(ActiveChecks[checkinstance].UseBorderConds == 0) /** do we need to remove condition on project boundary? ***/
                     {
                     if((NorthCount <= 0) || (SouthCount <= 0) || (EastCount <= 0) || (WestCount <= 0))
                        {
                        maxXindex = minXindex = maxYindex = minYindex = 0;
                        for(i=1; i<rac->numverts; i++)
                           {
                           if(rac->x[i] > rac->x[maxXindex])
                              maxXindex = i;
                           if(rac->x[i] < rac->x[minXindex])
                              minXindex = i;
                           if(rac->y[i] > rac->y[maxYindex])
                              maxYindex = i;
                           if(rac->y[i] < rac->y[minYindex])
                              minYindex = i;
                           }
                        if(EastCount <= 0)
                           {
                           if(maxXindex == 0)
                              {
                              i = 1;
                              j = rac->numverts - 1;
                              }
                           else
                              {
                              i = maxXindex - 1;
                              j = i + 1;
                              if(j >= rac->numverts)
                                 j = 0;
                              }
                           checkit = ConditionOnDataEdge(rac->x[i],rac->y[i],rac->x[maxXindex],rac->y[maxXindex],root,Proot,Lroot,
                                                 rac, NULL, NULL,100,100,EastCount,100,checkinstance);
                           if(checkit > 0)
                              checkit = ConditionOnDataEdge(rac->x[j],rac->y[j],rac->x[maxXindex],rac->y[maxXindex],root,Proot,Lroot,
                                                 rac, NULL, NULL,100,100,EastCount,100,checkinstance);
                           }
                        if((checkit > 0) && (WestCount <= 0))
                           {
                           if(minXindex == 0)
                              {
                              i = 1;
                              j = rac->numverts - 1;
                              }
                           else
                              {
                              i = minXindex - 1;
                              j = i + 1;
                              if(j >= rac->numverts)
                                 j = 0;
                              }
                           checkit = ConditionOnDataEdge(rac->x[i],rac->y[i],rac->x[minXindex],rac->y[minXindex],root,Proot,Lroot,
                                                 rac, NULL, NULL,100,100,100,WestCount,checkinstance);
                           if(checkit > 0)
                              checkit = ConditionOnDataEdge(rac->x[j],rac->y[j],rac->x[minXindex],rac->y[minXindex],root,Proot,Lroot,
                                                 rac, NULL, NULL,100,100,100,WestCount,checkinstance);
                           }
   
                        if((checkit > 0) && (SouthCount <= 0))
                           {
                           if(minYindex == 0)
                              {
                              i = 1;
                              j = rac->numverts - 1;
                              }
                           else
                              {
                              i = minYindex - 1;
                              j = i + 1;
                              if(j >= rac->numverts)
                                 j = 0;
                              }
                           checkit = ConditionOnDataEdge(rac->x[i],rac->y[i],rac->x[minYindex],rac->y[minYindex],root,Proot,Lroot,
                                                 rac, NULL, NULL,100,SouthCount,100,100,checkinstance);
                           if(checkit > 0)
                              checkit = ConditionOnDataEdge(rac->x[j],rac->y[j],rac->x[minYindex],rac->y[minYindex],root,Proot,Lroot,
                                                 rac, NULL, NULL,100,SouthCount,100,100,checkinstance);
                           }
                        if((checkit > 0) && (NorthCount <= 0))
                           {
                           if(maxYindex == 0)
                              {
                              i = 1;
                              j = rac->numverts - 1;
                              }
                           else
                              {
                              i = maxYindex - 1;
                              j = i + 1;
                              if(j >= rac->numverts)
                                 j = 0;
                              }
                           checkit = ConditionOnDataEdge(rac->x[i],rac->y[i],rac->x[maxYindex],rac->y[maxYindex],root,Proot,Lroot,
                                                 rac, NULL, NULL,NorthCount,100,100,100,checkinstance);
                           if(checkit > 0)
                              checkit = ConditionOnDataEdge(rac->x[j],rac->y[j],rac->x[maxYindex],rac->y[maxYindex],root,Proot,Lroot,
                                                 rac, NULL, NULL,NorthCount,100,100,100,checkinstance);
                           }
                        }
                     }
                  if(checkit > 0)
                     {
                     FwriteObjectAndMagnitude(SLIVER,Make_Correct(SLIVER,checkinstance),
                              rac->idn,rac->Sindex,G_AREAL,rac->Lindex,rac->localID,-1.0,-1.0,
                              d1,rac->x, rac->y, rac->z,2, 1);
                     }
                  }
               }

            if((rac->firstindex == cindex) && (rac->ishole <= 0) &&
               (CombinedCheckApplies(rac->idn,checkinstance,PORTRAYF,rac->Lindex,rac->Sindex,
                                     Config1,Strat1,Domain1,&part1,&part2,&part3)) &&
                     (part1 > 0))
               {
               for(jj = 0; jj < NumberPF; jj++)
                  {
                  if(rac->Lindex == PF_Lindex[jj])
                     {
                     if((PF_Iindex[jj] < 0) || (rac->idn == PF_Iindex[jj]))
                        {
                        FwriteObject(PORTRAYF, Make_Correct(PORTRAYF,checkinstance), rac->Lindex,
                           rac->Sindex,G_AREAL,rac->localID,rac->idn,10.0, -1.0,rac->x,rac->y,rac->z,2, 1);
                        break;
                        }
                     }
                  }
               }
            if((rac->firstindex == cindex) && (rac->ishole <= 0) &&
               (CombinedCheckApplies(rac->idn,checkinstance,TPORTRAYF,rac->Lindex,rac->Sindex,
                                     Config1,Strat1,Domain1,&part1,&part2,&part3)) &&
                     (part1 > 0))
               {
               for(jj = 0; jj < NumberPF; jj++)
                  {
                  if(rac->Lindex == PF_Lindex[jj])
                     {
                     if((PF_Iindex[jj] < 0) || (rac->idn == PF_Iindex[jj]))
                        {
                        FwriteObject(TPORTRAYF, Make_Correct(TPORTRAYF,checkinstance), rac->Lindex,
                           rac->Sindex,G_AREAL,rac->localID,rac->idn,10.0, -1.0,rac->x,rac->y,rac->z,2, 1);
                        break;
                        }
                     }
                  }
               }


            if((rac->firstindex == cindex) &&
                (CombinedCheckApplies(rac->idn,checkinstance,HIGHLIGHTED,rac->Lindex,rac->Sindex,Config1,Strat1,Domain1,
                                              &part1,&part2,&part3) > 0) &&
                                                      (part1 > 0))
               {
               k = AssignDrawingColor(rac->idn, (unsigned char)Domain1, rac->Lindex);
               if(k == HighLightColor)
                  {
                  ERc = (struct collection *) (malloc(SzC));
                  if(ERc == NULL)
                     {
                     printf("allocation memory exhausted during area feature condition analysis\n");
                     printf("processing cannot continue\n");
                     exit(-1);
                     }
                  ERc->keyval = HIGHLIGHTED;
                  ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                  ERc->Sindex1 = rac->Sindex;
                  ERc->aa = rac;
                  ERc->next = NULL;
                  if(ERroot == NULL)
                     {
                     ERroot = ERc;
                     }
                  else
                     {
                     ERn = ERroot;
                     while(ERn != NULL)
                        {
                        if((ERn->Cnumber == ERc->Cnumber) && (ERn->keyval == ERc->keyval) && (ERn->aa == ERc->aa))
                           break;
                        ERn = ERn->next;
                        }
                     if(ERn == NULL)
                        {
                        ERc->next = ERroot;
                        ERroot = ERc;
                        }
                     else
                        free(ERc);
                     }

                  }
               }




            if((rac->ishole < 1) && (rac->firstindex == cindex) &&
                       (CombinedCheckApplies(rac->idn,checkinstance,VVTERR1WAY,rac->Lindex,rac->Sindex,Config1,Strat1,Domain1,
                                             &part1,&part2,&part3) > 0) && (part1 > 0))
               {
                  ERc = (struct collection *) (malloc(SzC));
                  if(ERc == NULL)
                     {
                     printf("allocation memory exhausted during area feature condition analysis\n");
                     printf("processing cannot continue\n");
                     exit(-1);
                     }
                  ERc->keyval = VVTERR1WAY;
                  ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                  ERc->Sindex1 = rac->Sindex;
                  ERc->aa = rac;
                  ERc->next = NULL;
                  if(ERroot == NULL)
                     {
                     ERroot = ERc;
                     }
                  else
                     {
                     ERn = ERroot;
                     while(ERn != NULL)
                        {
                        if((ERn->Cnumber == ERc->Cnumber) && (ERn->keyval == ERc->keyval) && (ERn->aa == ERc->aa))
                           break;
                        ERn = ERn->next;
                        }
                     if(ERn == NULL)
                        {
                        ERc->next = ERroot;
                        ERroot = ERc;
                        }
                     else
                        free(ERc);
                     }
                  }



            if((rac->ishole < 1) && (rac->firstindex == cindex) && 
              (CombinedCheckApplies(rac->idn,checkinstance,VVTERR2WAY,rac->Lindex,rac->Sindex,Config1,Strat1,Domain1,
                                             &part1,&part2,&part3) > 0) && (part1 > 0) && (part2 > 0))
               {
                  ERc = (struct collection *) (malloc(SzC));
                  if(ERc == NULL)
                     {
                     printf("allocation memory exhausted during area feature condition analysis\n");
                     printf("processing cannot continue\n");
                     exit(-1);
                     }
                  ERc->keyval = VVTERR2WAY;
                  ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                  ERc->Sindex1 = rac->Sindex;
                  ERc->aa = rac;
                  ERc->next = NULL;  
                  if(ERroot == NULL)
                     {
                     ERroot = ERc;
                     }
                  else
                     {
                     ERn = ERroot;
                     while(ERn != NULL)
                        {
                        if((ERn->Cnumber == ERc->Cnumber) && (ERn->keyval == ERc->keyval) && (ERn->aa == ERc->aa))
                           break;
                        ERn = ERn->next;
                        }
                     if(ERn == NULL)
                        {
                        ERc->next = ERroot;
                        ERroot = ERc;
                        } 
                     else
                        free(ERc);
                     }
                  }

            if((rac->ishole < 1) && (rac->firstindex == cindex) &&
               (CombinedCheckApplies(rac->idn,checkinstance,VVTERR3WAY,rac->Lindex,rac->Sindex,Config1,Strat1,Domain1,
                  &part1,&part2,&part3) > 0) && (part1 > 0) && (part2 > 0) && (part3 > 0))
               {
                  ERc = (struct collection *) (malloc(SzC));
                  if(ERc == NULL)
                     {
                     printf("allocation memory exhausted during area feature condition analysis\n");
                     printf("processing cannot continue\n");
                     exit(-1);
                     }
                  ERc->keyval = VVTERR3WAY;
                  ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                  ERc->Sindex1 = rac->Sindex;
                  ERc->aa = rac;
                  ERc->next = NULL;  
                  if(ERroot == NULL)
                     {
                     ERroot = ERc;
                     }
                  else
                     {
                     ERn = ERroot;
                     while(ERn != NULL)
                        {
                        if((ERn->Cnumber == ERc->Cnumber) && (ERn->keyval == ERc->keyval) && (ERn->aa == ERc->aa))
                           break;
                        ERn = ERn->next;
                        }
                     if(ERn == NULL)
                        {
                        ERc->next = ERroot;
                        ERroot = ERc;
                        } 
                     else
                        free(ERc);
                     }
                  }



            if((CombinedCheckApplies(rac->idn,checkinstance,MULTIDFEAT,rac->Lindex,rac->Sindex,Config1,Strat1,Domain1,
                                              &part1,&part2,&part3) > 0) && (part1 > 0))
               {
               HasSentinel = HasActual = 0;
               i = IsSentinelZvalue(rac->z[0],UseNUNANPO);
               if(i > 0)
                  HasSentinel = 1;
               else
                  HasActual = 1;

               for(j=1; j<rac->numverts; j++)
                  {
                  jj = IsSentinelZvalue(rac->z[j],UseNUNANPO);
                  if(jj > 0)
                     HasSentinel = 1;
                  else
                     HasActual = 1;

                  if((HasSentinel > 0) && (HasActual > 0))
                     {
                     ERc = (struct collection *) (malloc(SzC));
                     if(ERc == NULL)
                        {
                        printf("allocation memory exhausted during area feature condition analysis\n");
                        printf("processing cannot continue\n");
                        exit(-1);
                        }
                     ERc->magnitude = 0;
                     ERc->keyval = MULTIDFEAT;
                     ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                     ERc->Sindex1 = rac->Sindex;
                     ERc->vertexindex1 = j - 1;
                     ERc->aa = rac;
                     ERc->next = NULL;
                     if(ERroot == NULL)
                        {
                        ERroot = ERc;
                        }
                     else
                        {
                        ERn = ERroot;
                        while(ERn != NULL)
                           {
                           if(
                              (ERn->Cnumber    == ERc->Cnumber)    &&
                              (ERn->keyval    == ERc->keyval)    &&
                              (ERn->aa == ERc->aa)
                              )
                              break;
                           ERn = ERn->next;
                           }
                        if(ERn == NULL)
                           {
                           ERc->next = ERroot;
                           ERroot = ERc;
                           }
                        else
                           free(ERc);
                        }
                     break;
                     }
                  }
               }


            if(CombinedCheckApplies(rac->idn,checkinstance,MULTISENTINEL,rac->Lindex,rac->Sindex,Config1,Strat1,Domain1,
                                              &part1,&part2,&part3) > 0) 
               {
               if(part1 > 0)
                  {
                  HasSentinel = 0;
                  for(j=0; j<rac->numverts; j++)
                     {
                     jj = IsSentinelZvalue(rac->z[j],UseNUNANPO);
                     if(jj > 0)
                        {
                        if(HasSentinel> 0)
                           {
                           if(rac->z[j] != SentinelValue)
                              {
                              ERc = (struct collection *) (malloc(SzC));
                              if(ERc == NULL)
                                 {
                                 printf("allocation memory exhausted during area feature condition analysis\n");
                                 printf("processing cannot continue\n");
                                 exit(-1);
                                 }
                              ERc->magnitude = 0;
                              ERc->keyval = MULTISENTINEL;
                              ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                              ERc->Sindex1 = rac->Sindex;
                              ERc->vertexindex1 = j - 1;
                              ERc->aa = rac;
                              ERc->next = NULL;
                              if(ERroot == NULL)
                                 {
                                 ERroot = ERc;
                                 }
                              else
                                 {
                                 ERn = ERroot;
                                 while(ERn != NULL)
                                    {
                                    if(
                                       (ERn->Cnumber    == ERc->Cnumber)    &&
                                       (ERn->keyval    == ERc->keyval)    &&
                                       (ERn->aa == ERc->aa)
                                       )
                                       break;
                                    ERn = ERn->next;
                                    }
                                 if(ERn == NULL)
                                    {
                                    ERc->next = ERroot;
                                    ERroot = ERc;
                                    }
                                 else
                                    free(ERc);
                                 }
                              break;
                              }
                           }
                        else
                           {
                           HasSentinel = 1;
                           SentinelValue = rac->z[j];
                           }
                        }
                     }
                  }
               }



            if(rac->ishole <= 0)
               {
               if((CombinedCheckApplies(rac->idn,checkinstance,ATTR_PAIR,rac->Lindex,rac->Sindex,Config1,Strat1,Domain1,
                                             &part1,&part2,&part3) > 0) && (part1 > 0))
                  {
                  if(CrsWlk[rac->Lindex].AttrErr >= 0)
                     {
                     if(AttrErr[CrsWlk[rac->Lindex].AttrErr].description[0] == '0') /*** then this is a ATTR_PAIR error **/
                        {
                        FwriteObjectAndMessage(ATTR_PAIR,Make_Correct(ATTR_PAIR,checkinstance),
                             rac->idn, G_AREAL,rac->Lindex,rac->localID, rac->Sindex,-1.0,-1.0,
                             rac->x, rac->y, rac->z,2,&AttrErr[CrsWlk[rac->Lindex].AttrErr].description[1]);
                        }
                     if(CrsWlk[rac->Lindex].MAE != NULL)
                        {
                        MAEc = CrsWlk[rac->Lindex].MAE;
                        while(MAEc != NULL)
                           {
                           if(AttrErr[MAEc->index].description[0] == '0') /*** then this is a ATTR_PAIR error **/
                              {
                              FwriteObjectAndMessage(ATTR_PAIR,Make_Correct(ATTR_PAIR,checkinstance),
                                   rac->idn, G_AREAL,rac->Lindex,rac->localID, rac->Sindex,-1.0,-1.0,
                                   rac->x, rac->y, rac->z,2,&AttrErr[MAEc->index].description[1]);
                              }
                           MAEc = MAEc->next;
                           }
                        }
                     }
                  }

               if((CombinedCheckApplies(rac->idn,checkinstance,RPTD_ATTR,rac->Lindex,rac->Sindex,Config1,Strat1,Domain1,
                                             &part1,&part2,&part3) > 0) && (part1 > 0))
                  {
                  if(CrsWlk[rac->Lindex].AttrErr >= 0)
                     {
                     checkit = 0;
                     if(ActiveChecks[checkinstance].clonenumber >= 0)
                        {
                        if(CloneErrorLookup[ActiveChecks[checkinstance].clonenumber].Annotation != NULL)
                           {
                           strcpy(Tstring,CloneErrorLookup[ActiveChecks[checkinstance].clonenumber].Annotation);
                           checkit = 1;
                           }
                        }
                     else
                        {
                        if(ErrorLookup[ActiveChecks[checkinstance].number].Annotation != NULL)
                           {
                           strcpy(Tstring,ErrorLookup[ActiveChecks[checkinstance].number].Annotation);
                           checkit = 1;
                           }
                        }
                     if(checkit > 0)
                        {
                        if(strstr(AttrErr[CrsWlk[rac->Lindex].AttrErr].description, Tstring) != NULL)
                           {
                           FwriteObjectAndMessage(RPTD_ATTR,Make_Correct(RPTD_ATTR,checkinstance),
                                rac->idn, G_AREAL,rac->Lindex,rac->localID, rac->Sindex,-1.0,-1.0,
                                rac->x, rac->y, rac->z,2,&AttrErr[CrsWlk[rac->Lindex].AttrErr].description[1]);
                           }
                        if(CrsWlk[rac->Lindex].MAE != NULL)
                           {
                           MAEc = CrsWlk[rac->Lindex].MAE;
                           while(MAEc != NULL)
                              {
                              if(strstr(AttrErr[MAEc->index].description, Tstring) != NULL)
                                 {
                                 FwriteObjectAndMessage(RPTD_ATTR,Make_Correct(RPTD_ATTR,checkinstance),
                                      rac->idn, G_AREAL,rac->Lindex,rac->localID, rac->Sindex,-1.0,-1.0,
                                      rac->x, rac->y, rac->z,2,&AttrErr[MAEc->index].description[1]);
                                 }
                              MAEc = MAEc->next;
                              }
                           }
                        }
                     }
                  }

   
               if((CombinedCheckApplies(rac->idn,checkinstance,ATTR_UNEXP,rac->Lindex,rac->Sindex,Config1,Strat1,Domain1,
                                             &part1,&part2,&part3) > 0) && (part1 > 0))
                  {
                  if(CrsWlk[rac->Lindex].AttrErr >= 0)
                     {
                     if(AttrErr[CrsWlk[rac->Lindex].AttrErr].description[0] == '1') /*** then this is a ATTR_UNEXP error **/
                        {
                        FwriteObjectAndMessage(ATTR_UNEXP,Make_Correct(ATTR_UNEXP,checkinstance),
                             rac->idn, G_AREAL,rac->Lindex,rac->localID, rac->Sindex,-1.0,-1.0,
                             rac->x, rac->y, rac->z,2,&AttrErr[CrsWlk[rac->Lindex].AttrErr].description[1]);
                        }
                     if(CrsWlk[rac->Lindex].MAE != NULL)
                        {
                        MAEc = CrsWlk[rac->Lindex].MAE;
                        while(MAEc != NULL)
                           {
                           if(AttrErr[MAEc->index].description[0] == '1') /*** then this is a ATTR_UNEXP error **/
                              {
                              FwriteObjectAndMessage(ATTR_UNEXP,Make_Correct(ATTR_UNEXP,checkinstance),
                                   rac->idn, G_AREAL,rac->Lindex,rac->localID, rac->Sindex,-1.0,-1.0,
                                   rac->x, rac->y, rac->z,2,&AttrErr[MAEc->index].description[1]);
                              }
                           MAEc = MAEc->next;
                           }
                        }
                     }
                  }


               if((CombinedCheckApplies(rac->idn,checkinstance,ATTR_VVT,rac->Lindex,rac->Sindex,Config1,Strat1,Domain1,
                                             &part1,&part2,&part3) > 0) && (part1 > 0))
                  {
                  if(CrsWlk[rac->Lindex].AttrErr >= 0)
                     {
                     if(AttrErr[CrsWlk[rac->Lindex].AttrErr].description[0] == 'y') /*** then this is a ATTR_VVT error **/
                        {
                        FwriteObjectAndMessage(ATTR_VVT,Make_Correct(ATTR_VVT,checkinstance),
                             rac->idn, G_AREAL,rac->Lindex,rac->localID, rac->Sindex,-1.0,-1.0,
                             rac->x, rac->y, rac->z,2,&AttrErr[CrsWlk[rac->Lindex].AttrErr].description[1]);
                        }
                     if(CrsWlk[rac->Lindex].MAE != NULL)
                        {
                        MAEc = CrsWlk[rac->Lindex].MAE;
                        while(MAEc != NULL)
                           {
                           if(AttrErr[MAEc->index].description[0] == 'y') /*** then this is a ATTR_VVT error **/
                              {
                              FwriteObjectAndMessage(ATTR_VVT,Make_Correct(ATTR_VVT,checkinstance),
                                   rac->idn, G_AREAL,rac->Lindex,rac->localID, rac->Sindex,-1.0,-1.0,
                                   rac->x, rac->y, rac->z,2,&AttrErr[MAEc->index].description[1]);
                              }
                           MAEc = MAEc->next;
                           }
                        }
                     if(AttrErr[CrsWlk[rac->Lindex].AttrErr].description[0] == 'x') /*** then this is a ATTR_VVT error **/
                        {
                        FwriteObjectAndMessage(ATTR_VVT,Make_Correct(ATTR_VVT,checkinstance),
                             rac->idn, G_AREAL,rac->Lindex,rac->localID, rac->Sindex,-1.0,-1.0,
                             rac->x, rac->y, rac->z,2,&AttrErr[CrsWlk[rac->Lindex].AttrErr].description[1]);
                        }
                     if(CrsWlk[rac->Lindex].MAE != NULL)
                        {
                        MAEc = CrsWlk[rac->Lindex].MAE;
                        while(MAEc != NULL)
                           {
                           if(AttrErr[MAEc->index].description[0] == 'x') /*** then this is a ATTR_VVT error **/
                              {
                              FwriteObjectAndMessage(ATTR_VVT,Make_Correct(ATTR_VVT,checkinstance),
                                   rac->idn, G_AREAL,rac->Lindex,rac->localID, rac->Sindex,-1.0,-1.0,
                                   rac->x, rac->y, rac->z,2,&AttrErr[MAEc->index].description[1]);
                              }
                           MAEc = MAEc->next;
                           }
                        }
                     }
                  }


               if((CombinedCheckApplies(rac->idn,checkinstance,ATTR_RNULL,rac->Lindex,rac->Sindex,Config1,Strat1,Domain1,
                                             &part1,&part2,&part3) > 0) && (part1 > 0))
                  {
                  if(CrsWlk[rac->Lindex].AttrErr >= 0)
                     {
                     if(AttrErr[CrsWlk[rac->Lindex].AttrErr].description[0] == '2') /*** then this is a ATTR_RNULL error **/
                        {
                        FwriteObjectAndMessage(ATTR_RNULL,Make_Correct(ATTR_RNULL,checkinstance),
                             rac->idn, G_AREAL,rac->Lindex,rac->localID, rac->Sindex,-1.0,-1.0,
                             rac->x, rac->y, rac->z,2,&AttrErr[CrsWlk[rac->Lindex].AttrErr].description[1]);
                        }
                     if(CrsWlk[rac->Lindex].MAE != NULL)
                        {
                        MAEc = CrsWlk[rac->Lindex].MAE;
                        while(MAEc != NULL)
                           {
                           if(AttrErr[MAEc->index].description[0] == '2') /*** then this is a ATTR_RNULL error **/
                              {
                              FwriteObjectAndMessage(ATTR_RNULL,Make_Correct(ATTR_RNULL,checkinstance),
                                   rac->idn, G_AREAL,rac->Lindex,rac->localID, rac->Sindex,-1.0,-1.0,
                                   rac->x, rac->y, rac->z,2,&AttrErr[MAEc->index].description[1]);
                              }
                           MAEc = MAEc->next;
                           }
                        }
                     }
                  }




               if((CombinedCheckApplies(rac->idn,checkinstance,ATTR_MISSING,rac->Lindex,rac->Sindex,Config1,Strat1,Domain1,
                                                &part1,&part2,&part3) > 0) && (part1 > 0))
                  {
                  if(CrsWlk[rac->Lindex].AttrErr >= 0)
                     {
                     if(AttrErr[CrsWlk[rac->Lindex].AttrErr].description[0] == 'z') /*** then this is a ATTR_MISSING error **/
                        {
                        FwriteObjectAndMessage(ATTR_MISSING,Make_Correct(ATTR_MISSING,checkinstance),
                             rac->idn, G_AREAL,rac->Lindex,rac->localID, rac->Sindex,-1.0,-1.0,
                             rac->x, rac->y, rac->z,2,&AttrErr[CrsWlk[rac->Lindex].AttrErr].description[1]);
                        }
                     if(CrsWlk[rac->Lindex].MAE != NULL)
                        {
                        MAEc = CrsWlk[rac->Lindex].MAE;
                        while(MAEc != NULL)
                           {
                           if(AttrErr[MAEc->index].description[0] == 'z') /*** then this is a ATTR_MISSING error **/
                              {
                              FwriteObjectAndMessage(ATTR_MISSING,Make_Correct(ATTR_MISSING,checkinstance),
                                   rac->idn, G_AREAL,rac->Lindex,rac->localID, rac->Sindex,-1.0,-1.0,
                                   rac->x, rac->y, rac->z,2,&AttrErr[MAEc->index].description[1]);
                              }
                           MAEc = MAEc->next;
                           }
                        }
                     }
                  }


               if((CombinedCheckApplies(rac->idn,checkinstance,ATTR_DT,rac->Lindex,rac->Sindex,Config1,Strat1,Domain1,
                                                &part1,&part2,&part3) > 0) && (part1 > 0))
                  {
                  if(CrsWlk[rac->Lindex].AttrErr >= 0)
                     {
                     if(AttrErr[CrsWlk[rac->Lindex].AttrErr].description[0] == '2') /*** then this is a ATTR_DT error **/
                        {
                        FwriteObjectAndMessage(ATTR_DT,Make_Correct(ATTR_DT,checkinstance),
                             rac->idn, G_AREAL,rac->Lindex,rac->localID, rac->Sindex,-1.0,-1.0,
                             rac->x, rac->y, rac->z,2,&AttrErr[CrsWlk[rac->Lindex].AttrErr].description[1]);
                        }
                     if(CrsWlk[rac->Lindex].MAE != NULL)
                        {
                        MAEc = CrsWlk[rac->Lindex].MAE;
                        while(MAEc != NULL)
                           {
                           if(AttrErr[MAEc->index].description[0] == '2') /*** then this is a ATTR_DT error **/
                              {
                              FwriteObjectAndMessage(ATTR_DT,Make_Correct(ATTR_DT,checkinstance),
                                   rac->idn, G_AREAL,rac->Lindex,rac->localID, rac->Sindex,-1.0,-1.0,
                                   rac->x, rac->y, rac->z,2,&AttrErr[MAEc->index].description[1]);
                              }
                           MAEc = MAEc->next;
                           }
                        }
                     }
                  }
   
               if((CombinedCheckApplies(rac->idn,checkinstance,ATTR_RNG,rac->Lindex,rac->Sindex,Config1,Strat1,Domain1,
                                                &part1,&part2,&part3) > 0) && (part1 > 0))
                  {
                  if(CrsWlk[rac->Lindex].AttrErr >= 0)
                     {
                     if(AttrErr[CrsWlk[rac->Lindex].AttrErr].description[0] == '3') /*** then this is a ATTR_RNG error **/
                        {
                        FwriteObjectAndMessage(ATTR_RNG,Make_Correct(ATTR_RNG,checkinstance),
                             rac->idn, G_AREAL,rac->Lindex,rac->localID, rac->Sindex,-1.0,-1.0,
                             rac->x, rac->y, rac->z,2,&AttrErr[CrsWlk[rac->Lindex].AttrErr].description[1]);
                        }
                     if(CrsWlk[rac->Lindex].MAE != NULL)
                        {
                        MAEc = CrsWlk[rac->Lindex].MAE;
                        while(MAEc != NULL)
                           {
                           if(AttrErr[MAEc->index].description[0] == '3') /*** then this is a ATTR_RNG error **/
                              {
                              FwriteObjectAndMessage(ATTR_RNG,Make_Correct(ATTR_RNG,checkinstance),
                                   rac->idn, G_AREAL,rac->Lindex,rac->localID, rac->Sindex,-1.0,-1.0,
                                   rac->x, rac->y, rac->z,2,&AttrErr[MAEc->index].description[1]);
                              }
                           MAEc = MAEc->next;
                           }
                        }
                     }
                  }

               if((CombinedCheckApplies(rac->idn,checkinstance,ATTR_PICK,rac->Lindex,rac->Sindex,Config1,Strat1,Domain1,
                                                &part1,&part2,&part3) > 0) && (part1 > 0))
                  {
                  if(CrsWlk[rac->Lindex].AttrErr >= 0)
                     {
                     if(AttrErr[CrsWlk[rac->Lindex].AttrErr].description[0] == '4') /*** then this is a ATTR_PICK error **/
                        {
                        FwriteObjectAndMessage(ATTR_PICK,Make_Correct(ATTR_PICK,checkinstance),
                             rac->idn, G_AREAL,rac->Lindex,rac->localID, rac->Sindex,-1.0,-1.0,
                             rac->x, rac->y, rac->z,2,&AttrErr[CrsWlk[rac->Lindex].AttrErr].description[1]);
                        }
                     if(CrsWlk[rac->Lindex].MAE != NULL)
                        {
                        MAEc = CrsWlk[rac->Lindex].MAE;
                        while(MAEc != NULL)
                           {
                           if(AttrErr[MAEc->index].description[0] == '4') /*** then this is a ATTR_PICK error **/
                              {
                              FwriteObjectAndMessage(ATTR_PICK,Make_Correct(ATTR_PICK,checkinstance),
                                   rac->idn, G_AREAL,rac->Lindex,rac->localID, rac->Sindex,-1.0,-1.0,
                                   rac->x, rac->y, rac->z,2,&AttrErr[MAEc->index].description[1]);
                              }
                           MAEc = MAEc->next;
                           }
                        }
                     }
                  }

               if((CombinedCheckApplies(rac->idn,checkinstance,ATTR_META,rac->Lindex,rac->Sindex,Config1,Strat1,Domain1,
                                                &part1,&part2,&part3) > 0) && (part1 > 0))
                  {
                  if(CrsWlk[rac->Lindex].AttrErr >= 0)
                     {
                     if(AttrErr[CrsWlk[rac->Lindex].AttrErr].description[0] == ' ') /*** then this is a ATTR_META error **/
                        {
                        FwriteObjectAndMessage(ATTR_META,Make_Correct(ATTR_META,checkinstance),
                             rac->idn, G_AREAL,rac->Lindex,rac->localID, rac->Sindex,-1.0,-1.0,
                             rac->x, rac->y, rac->z,2,&AttrErr[CrsWlk[rac->Lindex].AttrErr].description[1]);
                        }
                     if(CrsWlk[rac->Lindex].MAE != NULL)
                        {
                        MAEc = CrsWlk[rac->Lindex].MAE;
                        while(MAEc != NULL)
                           {
                           if(AttrErr[MAEc->index].description[0] == ' ') /*** then this is a ATTR_META error **/
                              {
                              FwriteObjectAndMessage(ATTR_META,Make_Correct(ATTR_META,checkinstance),
                                   rac->idn, G_AREAL,rac->Lindex,rac->localID, rac->Sindex,-1.0,-1.0,
                                   rac->x, rac->y, rac->z,2,&AttrErr[MAEc->index].description[1]);
                              }
                           MAEc = MAEc->next;
                           }
                        }
                     }
                  }
               } /** end is not an areal cut-out, so check the attribute problems ***/
            } /*** end if any attr errors should be written out for rac **/


          if((TtlCoverFailures < MAXCOVERFAILURES) &&
             (CombinedCheckApplies(rac->idn,checkinstance,COVERFAIL,rac->Lindex,rac->Sindex,Config1,Strat1,Domain1,&part1,&part2,&part3) > 0))
             {
             if(part1 > 0)
                {
                tempsensitivity = FindRelevantSensitivity(COVERFAIL,checkinstance,&tempsensitivity2);
                if(tempsensitivity != 1.0)
                   {
                   CF_LAEminx = RoundToNearestPartialDegree(1,MinXcoord,tempsensitivity);
                   CF_LAEminy = RoundToNearestPartialDegree(1,MinYcoord,tempsensitivity);
                   CF_LAEmaxx = RoundToNearestPartialDegree(2,MaxXcoord,tempsensitivity);
                   CF_LAEmaxy = RoundToNearestPartialDegree(2,MaxYcoord,tempsensitivity);
                   }
                if(rac->RB_Tree_Edgelist == NULL)
                   {
                   if(rac->firstindex == cindex)
                      {
                      ii = Make_Correct(COVERFAIL,checkinstance);
                      j = rac->numverts - 1;
                      for(i=0; i<rac->numverts; i++)
                         {
                         MatchAreaEdge(rac->x[j],rac->y[j],rac->z[j],rac->x[i],rac->y[i],rac->z[i],
                                    rac->localID, ii, rac->idn,rac->Sindex,rac->Lindex,tempsensitivity2);
                         j = i;
                         }
                      }
                   }
                else if(rac->RB_Tree_Edgelist != NULL)
                   {
                   ii = Make_Correct(COVERFAIL,checkinstance);
                   LastEdge1 = NULL;
                   LastI = -1;
                   i = GetNextArealIndex(rac, LastI, 1, &LastEdge1, cindex, &UsedTree);
                   LastI = i;
 
                   while(i >= 0)
                      {
                      if(i == 0)
                         j = rac->numverts - 1;
                      else
                         j = i - 1;
                      if(rac->x[i] < rac->x[j])
                         kk = i;
                      else if(rac->x[i] == rac->x[j])
                         {
                         if(rac->y[i] < rac->y[j])
                            kk = i;
                         else
                            kk = j;
                         }
                      else
                         kk = j;
                         
                      if((rac->x[kk] >= minx) && (rac->x[kk] <= maxx) && (rac->y[kk] >= miny) && (rac->y[kk] <= maxy))
                         {
                         MatchAreaEdge(rac->x[j],rac->y[j],rac->z[j],rac->x[i],rac->y[i],rac->z[i],
                                    rac->localID, ii, rac->idn,rac->Sindex,rac->Lindex,tempsensitivity2);
                         }
                        
                      i = GetNextArealIndex(rac, LastI, 1, &LastEdge1, cindex, &UsedTree);
                      LastI = i;
                      }
                   }

                }
             } /*** end COVERFAIL check ***/

        if(CombinedCheckApplies(rac->idn,checkinstance,SEGLEN,rac->Lindex,rac->Sindex,
                                Config1,Strat1,Domain1, &part1,&part2,&part3))
           {
           if((part1 > 0) && (rac->numverts > 1))
              {
              if(rac->RB_Tree_Edgelist != NULL)
                 {
                 LastEdge1 = NULL;
                 LastI = -1;
                 i = GetNextArealIndex(rac, LastI, 1, &LastEdge1, cindex, &UsedTree);
                 LastI = i;
                 }
              else
                 i = 0;
              while(i >= 0)
                 {
                 if(i == 0)
                    ii = rac->numverts-1;
                 else
                    ii = i - 1;
                 if((rac->x[i] != rac->x[ii]) || (rac->y[i] != rac->y[ii]) ||
                     (rac->z[i] != rac->z[ii]))
                    {
                    if(((rac->x[i] >= minx) && (rac->x[i] <= maxx) && (rac->y[i] >= miny) && (rac->y[i] <= maxy)) ||
                              ((rac->x[ii] >= minx) && (rac->x[ii] <= maxx) && (rac->y[ii] >= miny) && (rac->y[ii] <= maxy)))
                       { 
                       segdist = Distance3D(rac->x[ii],rac->y[ii],rac->z[ii],
                                            rac->x[i],rac->y[i],rac->z[i]);
                       if(SensitivityCheck(LTEQ, SEGLEN, checkinstance, segdist) > 0)
                          {
                          j = ConditionOnDataEdge(rac->x[i],rac->y[i],rac->x[ii],rac->y[ii],root,Proot,Lroot,
                                                  rac, NULL, NULL,
                                                  NorthCount,SouthCount,EastCount,WestCount,checkinstance);
                          if(j > 0) /** then write out the condition ***/
                             {
                             X[0] = rac->x[ii];
                             Y[0] = rac->y[ii];
                             Z[0] = rac->z[ii];
                             X[1] = rac->x[i];
                             Y[1] = rac->y[i];
                             Z[1] = rac->z[i];
                             FwriteObjectAndMagnitude(SEGLEN,Make_Correct(SEGLEN,checkinstance),
                                      rac->idn,
                                      rac->Sindex,G_AREAL,rac->Lindex,rac->localID,-1.0,-1.0,segdist,
                                      &X[0], &Y[0],&Z[0],2, 1);
                             }
                          }
                       }
                    }
                 if(rac->RB_Tree_Edgelist != NULL)
                    {
                    i = GetNextArealIndex(rac, LastI, 1, &LastEdge1, cindex, &UsedTree);
                    LastI = i;
                    }
                 else
                    {
                    ++i;
                    if(i >= rac->numverts)
                       i = -1;
                    }
                 }
              }
           }

        if(CombinedCheckApplies(rac->idn,checkinstance,PERIMLEN,rac->Lindex,rac->Sindex,
                                Config1,Strat1,Domain1, &part1,&part2,&part3))
           {
           if(part1 > 0)
              {
              basedist = 0;
              for(i=1; i<rac->numverts; i++)
                 {
                 basedist += Distance3D(rac->x[i-1],rac->y[i-1],rac->z[i-1],
                             rac->x[i],rac->y[i],rac->z[i]);
                 if(SensitivityCheck(GT, PERIMLEN, checkinstance, basedist) > 0)
                    break;
                 }

              if(i >= rac->numverts)
                 {
                 basedist += Distance3D(rac->x[rac->numverts-1],rac->y[rac->numverts-1],rac->z[rac->numverts-1],
                        rac->x[0],rac->y[0],rac->z[0]);
                 }
              if(SensitivityCheck(LTEQ, PERIMLEN, checkinstance, basedist) > 0)
                 {
                 checkit = 1;
                 if((NorthCount <= 0) || (SouthCount <= 0) || (EastCount <= 0) || (WestCount <= 0))
                    {
                    maxXindex = minXindex = maxYindex = minYindex = -1;
                    for(i=0; i<rac->numverts; i++)
                       {
                       if((rac->x[i] >= minx) && (rac->x[i] <= maxx) && (rac->y[i] >= miny) && (rac->y[i] <= maxy))
                          {
                          if((maxXindex < 0) || (rac->x[i] > rac->x[maxXindex]))
                             maxXindex = i;
                          if((minXindex < 0) || (rac->x[i] < rac->x[minXindex]))
                             minXindex = i;
                          if((maxYindex < 0) || (rac->y[i] > rac->y[maxYindex]))
                             maxYindex = i;
                          if((minYindex < 0) || (rac->y[i] < rac->y[minYindex]))
                             minYindex = i;
                          }
                       }
                    checkit = 1;

                    if((maxXindex >= 0) && (EastCount <= 0))
                       {
                       if(maxXindex == 0)
                          i = 1;
                       else
                          i = maxXindex - 1;
                       checkit = ConditionOnDataEdge(rac->x[i],rac->y[i],rac->x[maxXindex],rac->y[maxXindex],root,Proot,Lroot,
                                                  rac, NULL, NULL,100,100,EastCount,100,checkinstance);
                       }
                    if((minXindex >= 0) && (checkit > 0) && (WestCount <= 0))
                       {
                       if(minXindex == 0)
                          i = 1;
                       else
                          i = minXindex - 1;
                       checkit = ConditionOnDataEdge(rac->x[i],rac->y[i],rac->x[minXindex],rac->y[minXindex],root,Proot,Lroot,
                                                  rac, NULL, NULL,100,100,100,WestCount,checkinstance);
                       }
                    if((minYindex >= 0) && (checkit > 0) && (SouthCount <= 0))
                       {
                       if(minYindex == 0)
                          i = 1;
                       else
                          i = minYindex - 1;
                       checkit = ConditionOnDataEdge(rac->x[i],rac->y[i],rac->x[minYindex],rac->y[minYindex],root,Proot,Lroot,
                                                  rac, NULL, NULL,100,SouthCount,100,100,checkinstance);
                       }
                    if((maxYindex >= 0) && (checkit > 0) && (NorthCount <= 0))
                       {
                       if(maxYindex == 0)
                          i = 1;
                       else
                          i = maxYindex - 1;
                       checkit = ConditionOnDataEdge(rac->x[i],rac->y[i],rac->x[maxYindex],rac->y[maxYindex],root,Proot,Lroot,
                                                  rac, NULL, NULL, NorthCount,100,100,100,checkinstance); 
                       }
                    }

                 if((checkit > 0) && (rac->ismulti == 0)) /** did not find a vertex on project edge and is single region, so know all we need now ***/
                    {
                    X[0] = rac->x[0];
                    Y[0] = rac->y[0];
                    Z[0] = rac->z[0];
                    X[1] = rac->x[1];
                    Y[1] = rac->y[1];
                    Z[1] = rac->z[1];
                    FwriteObjectAndMagnitude(PERIMLEN,Make_Correct(PERIMLEN,checkinstance), rac->idn,
                             rac->Sindex,G_AREAL,rac->Lindex,rac->localID,-1.0,-1.0,basedist,
                             &X[0], &Y[0],&Z[0],2, 1);
                    }
                 else if(rac->ismulti > 0)
                    {
                    RB_newKey2 = rac->localID + (checkinstance * 0.0001); 
                    if(( RB_newNode = RBExactQuery(Check_RB_Tree,&RB_newKey2)))
                       {
                       RB_cond = (struct ConditionCollection *) RB_newNode->info;
                       RB_cond->counter += 1;
                       if(checkit == 0)
                          RB_cond->magnitude = -100.0;
                       }
                    else
                       {
                       RB_cond = (struct ConditionCollection *) (malloc(SzCC));
                       if(RB_cond == NULL)
                          {
                          printf("memory has been exhausted during RB-Tree information alloction for PERIMLEN analysis\n");
                          exit(-1);
                          }
                       RB_cond->keyval = PERIMLEN;
                       RB_cond->index_from_to = NULL;
                       RB_cond->Cnumber =  Make_Correct(PERIMLEN,checkinstance);
                       RB_cond->index_from_to = NULL;
                       RB_cond->gform = G_AREAL;
                       RB_cond->featureidn = rac->featureid;
                       RB_cond->localID = rac->localID;
                       RB_cond->counter = 1;
                       RB_cond->radius = -1;
                       RB_cond->height = -1;
                       if(checkit > 0)
                          RB_cond->magnitude = basedist;
                       else
                          RB_cond->magnitude = -100.0;
                       RB_cond->IDN = rac->idn;
                       RB_cond->Sindex = rac->Sindex;
                       RB_cond->Lindex = rac->Lindex;
     
                       RB_cond->numnodes = rac->numverts;
                       RB_cond->x = (double *) (malloc(RB_cond->numnodes * SzD));
                       RB_cond->y = (double *) (malloc(RB_cond->numnodes * SzD));
                       RB_cond->z = (double *) (malloc(RB_cond->numnodes * SzD));
                       if(RB_cond->z == NULL)
                          {
                          printf("memory has been exhausted during RB-Tree element vertex alloction for PERIMLEN analysis\n");
                          exit(-1);
                          }
                       for(jj=0; jj< rac->numverts; jj++)
                          {
                          RB_cond->x[jj] = rac->x[jj];
                          RB_cond->y[jj] = rac->y[jj];
                          RB_cond->z[jj] = rac->z[jj];
                          }

                       RB_newDbl = (double *) (malloc(SzD));
                       if(RB_newDbl == NULL)
                          {
                          printf("memory has been exhausted during RB-Tree alloction for PERIMLEN analysis\n");
                          exit(-1);
                          }
                       *RB_newDbl = RB_newKey2; /**rac->localID; **/
                       RBTreeInsert(Check_RB_Tree,RB_newDbl, RB_cond);
                       }

                    }
                 }
              }
           }



        if((rac->ishole <= 0) && (CombinedCheckApplies(rac->idn,checkinstance,SMALLAREA,rac->Lindex,rac->Sindex,
                                Config1,Strat1,Domain1, &part1,&part2,&part3)))
           {
           if(part1 > 0)
              {
              if(SensitivityCheck(LTEQ, SMALLAREA, checkinstance, rac->area) > 0)
                 {
                 checkit = 1;
                 if((NorthCount <= 0) || (SouthCount <= 0) || (EastCount <= 0) || (WestCount <= 0))
                    {
                    maxXindex = minXindex = maxYindex = minYindex = -1;
                    for(i=0; i<rac->numverts; i++)
                       {
                       if((rac->x[i] >= minx) && (rac->x[i] <= maxx) && (rac->y[i] >= miny) && (rac->y[i] <= maxy))
                          {
                          if((maxXindex < 0) || (rac->x[i] > rac->x[maxXindex]))
                             maxXindex = i;
                          if((minXindex < 0) || (rac->x[i] < rac->x[minXindex]))
                             minXindex = i;
                          if((maxYindex < 0) || (rac->y[i] > rac->y[maxYindex]))
                             maxYindex = i;
                          if((minYindex < 0) || (rac->y[i] < rac->y[minYindex]))
                             minYindex = i;
                          }
                       }
                    checkit = 1;

                    if((maxXindex >= 0) && (EastCount <= 0))
                       {
                       if(maxXindex == 0)
                          i = 1;
                       else
                          i = maxXindex - 1;
                       checkit = ConditionOnDataEdge(rac->x[i],rac->y[i],rac->x[maxXindex],rac->y[maxXindex],root,Proot,Lroot,
                                                  rac, NULL, NULL,100,100,EastCount,100,checkinstance);
                       }
                    if((minXindex >= 0) && (checkit > 0) && (WestCount <= 0))
                       {
                       if(minXindex == 0)
                          i = 1;
                       else
                          i = minXindex - 1;
                       checkit = ConditionOnDataEdge(rac->x[i],rac->y[i],rac->x[minXindex],rac->y[minXindex],root,Proot,Lroot,
                                                  rac, NULL, NULL,100,100,100,WestCount,checkinstance);
                       }
                    if((minYindex >= 0) && (checkit > 0) && (SouthCount <= 0))
                       {
                       if(minYindex == 0)
                          i = 1;
                       else
                          i = minYindex - 1;
                       checkit = ConditionOnDataEdge(rac->x[i],rac->y[i],rac->x[minYindex],rac->y[minYindex],root,Proot,Lroot,
                                                  rac, NULL, NULL,100,SouthCount,100,100,checkinstance);
                       }
                    if((maxYindex >= 0) && (checkit > 0) && (NorthCount <= 0))
                       {
                       if(maxYindex == 0)
                          i = 1;
                       else
                          i = maxYindex - 1;
                       checkit = ConditionOnDataEdge(rac->x[i],rac->y[i],rac->x[maxYindex],rac->y[maxYindex],root,Proot,Lroot,
                                                  rac, NULL, NULL, NorthCount,100,100,100,checkinstance);
                       }
                    }

                 if((checkit > 0) && (rac->ismulti == 0)) /** did not find a vertex on project edge and is single region, so know all we need now ***/
                    {
                    X[0] = rac->x[0];
                    Y[0] = rac->y[0];
                    Z[0] = rac->z[0];
                    X[1] = rac->x[1];
                    Y[1] = rac->y[1];
                    Z[1] = rac->z[1];
                    FwriteObjectAndMagnitude(SMALLAREA,Make_Correct(SMALLAREA,checkinstance), rac->idn,
                             rac->Sindex,G_AREAL,rac->Lindex,rac->localID,-1.0,-1.0,rac->area,
                             &X[0], &Y[0],&Z[0],2, 1);
                    }
                 else if(rac->ismulti > 0)
                    {
                    RB_newKey2 = rac->localID + (checkinstance * 0.0001);
                    if(( RB_newNode = RBExactQuery(Check_RB_Tree,&RB_newKey2)))
                       {
                       RB_cond = (struct ConditionCollection *) RB_newNode->info;
                       RB_cond->counter += 1;
                       if(checkit == 0)
                          RB_cond->magnitude = -100.0;
                       }
                    else
                       {
                       RB_cond = (struct ConditionCollection *) (malloc(SzCC));
                       if(RB_cond == NULL)
                          {
                          printf("memory has been exhausted during RB-Tree information alloction for SMALLAREA analysis\n");
                          exit(-1);
                          }
                       RB_cond->keyval = SMALLAREA;
                       RB_cond->index_from_to = NULL;
                       RB_cond->Cnumber =  Make_Correct(SMALLAREA,checkinstance);
                       RB_cond->index_from_to = NULL;
                       RB_cond->gform = G_AREAL;
                       RB_cond->featureidn = rac->featureid;
                       RB_cond->localID = rac->localID;
                       RB_cond->counter = 1;
                       RB_cond->radius = -1;
                       RB_cond->height = -1;
                       if(checkit > 0)
                          RB_cond->magnitude = rac->area;
                       else
                          RB_cond->magnitude = -100.0;
                       RB_cond->IDN = rac->idn;
                       RB_cond->Sindex = rac->Sindex;
                       RB_cond->Lindex = rac->Lindex;

                       RB_cond->numnodes = rac->numverts;
                       RB_cond->x = (double *) (malloc(RB_cond->numnodes * SzD));
                       RB_cond->y = (double *) (malloc(RB_cond->numnodes * SzD));
                       RB_cond->z = (double *) (malloc(RB_cond->numnodes * SzD));
                       if(RB_cond->z == NULL)
                          {
                          printf("memory has been exhausted during RB-Tree element vertex alloction for SMALLAREA analysis\n");
                          exit(-1);
                          }
                       for(jj=0; jj< rac->numverts; jj++)
                          {
                          RB_cond->x[jj] = rac->x[jj];
                          RB_cond->y[jj] = rac->y[jj];
                          RB_cond->z[jj] = rac->z[jj];
                          }

                       RB_newDbl = (double *) (malloc(SzD));
                       if(RB_newDbl == NULL)
                          {
                          printf("memory has been exhausted during RB-Tree alloction for SMALLAREA analysis\n");
                          exit(-1);
                          }
                       *RB_newDbl = RB_newKey2; /**rac->localID; **/
                       RBTreeInsert(Check_RB_Tree,RB_newDbl, RB_cond);
                       }

                    }
                 }
              }
           }



        if((rac->ishole > 0) && (CombinedCheckApplies(rac->idn,checkinstance,SMLCUTOUT,rac->Lindex,rac->Sindex,
                                Config1,Strat1,Domain1, &part1,&part2,&part3)))
           {
           if(part1 > 0)
              {
              if(SensitivityCheck(LTEQ, SMLCUTOUT, checkinstance, rac->area) > 0)
                 {
                 checkit = 1;
                 if((NorthCount <= 0) || (SouthCount <= 0) || (EastCount <= 0) || (WestCount <= 0))
                    {
                    maxXindex = minXindex = maxYindex = minYindex = -1;
                    for(i=0; i<rac->numverts; i++)
                       {
                       if((rac->x[i] >= minx) && (rac->x[i] <= maxx) && (rac->y[i] >= miny) && (rac->y[i] <= maxy))
                          {
                          if((maxXindex < 0) || (rac->x[i] > rac->x[maxXindex]))
                             maxXindex = i;
                          if((minXindex < 0) || (rac->x[i] < rac->x[minXindex]))
                             minXindex = i;
                          if((maxYindex < 0) || (rac->y[i] > rac->y[maxYindex]))
                             maxYindex = i;
                          if((minYindex < 0) || (rac->y[i] < rac->y[minYindex]))
                             minYindex = i;
                          }
                       }
                    checkit = 1;

                    if((maxXindex >= 0) && (EastCount <= 0))
                       {
                       if(maxXindex == 0)
                          i = 1;
                       else
                          i = maxXindex - 1;
                       checkit = ConditionOnDataEdge(rac->x[i],rac->y[i],rac->x[maxXindex],rac->y[maxXindex],root,Proot,Lroot,
                                                  rac, NULL, NULL,100,100,EastCount,100,checkinstance);
                       }
                    if((minXindex >= 0) && (checkit > 0) && (WestCount <= 0))
                       {
                       if(minXindex == 0)
                          i = 1;
                       else
                          i = minXindex - 1;
                       checkit = ConditionOnDataEdge(rac->x[i],rac->y[i],rac->x[minXindex],rac->y[minXindex],root,Proot,Lroot,
                                                  rac, NULL, NULL,100,100,100,WestCount,checkinstance);
                       }
                    if((minYindex >= 0) && (checkit > 0) && (SouthCount <= 0))
                       {
                       if(minYindex == 0)
                          i = 1;
                       else
                          i = minYindex - 1;
                       checkit = ConditionOnDataEdge(rac->x[i],rac->y[i],rac->x[minYindex],rac->y[minYindex],root,Proot,Lroot,
                                                  rac, NULL, NULL,100,SouthCount,100,100,checkinstance);
                       }
                    if((maxYindex >= 0) && (checkit > 0) && (NorthCount <= 0))
                       {
                       if(maxYindex == 0)
                          i = 1;
                       else
                          i = maxYindex - 1;
                       checkit = ConditionOnDataEdge(rac->x[i],rac->y[i],rac->x[maxYindex],rac->y[maxYindex],root,Proot,Lroot,
                                                  rac, NULL, NULL, NorthCount,100,100,100,checkinstance);
                       }
                    }

                 if((checkit > 0) && (rac->ismulti == 0)) /** did not find a vertex on project edge and is single region, so know all we need now ***/
                    {
                    X[0] = rac->x[0];
                    Y[0] = rac->y[0];
                    Z[0] = rac->z[0];
                    X[1] = rac->x[1];
                    Y[1] = rac->y[1];
                    Z[1] = rac->z[1];
                    FwriteObjectAndMagnitude(SMLCUTOUT,Make_Correct(SMLCUTOUT,checkinstance), rac->idn,
                             rac->Sindex,G_AREAL,rac->Lindex,rac->localID,-1.0,-1.0,rac->area,
                             &X[0], &Y[0],&Z[0],2, 1);
                    }
                 else if(rac->ismulti > 0)                     {
                    RB_newKey2 = rac->localID + (checkinstance * 0.0001);
                    if(( RB_newNode = RBExactQuery(Check_RB_Tree,&RB_newKey2)))
                       {
                       RB_cond = (struct ConditionCollection *) RB_newNode->info;
                       RB_cond->counter += 1;
                       if(checkit == 0)
                          RB_cond->magnitude = -100.0;
                       }
                    else
                       {
                       RB_cond = (struct ConditionCollection *) (malloc(SzCC));
                       if(RB_cond == NULL)
                          {
                          printf("memory has been exhausted during RB-Tree information alloction for SMLCUTOUT analysis\n");
                          exit(-1);
                          }
                       RB_cond->keyval = SMLCUTOUT;
                       RB_cond->index_from_to = NULL;
                       RB_cond->Cnumber =  Make_Correct(SMLCUTOUT,checkinstance);
                       RB_cond->index_from_to = NULL;
                       RB_cond->gform = G_AREAL;
                       RB_cond->featureidn = rac->featureid;
                       RB_cond->localID = rac->localID;
                       RB_cond->counter = 1;
                       RB_cond->radius = -1;
                       RB_cond->height = -1;
                       if(checkit > 0)
                          RB_cond->magnitude = rac->area;
                       else
                          RB_cond->magnitude = -100.0;
                       RB_cond->IDN = rac->idn;
                       RB_cond->Sindex = rac->Sindex;
                       RB_cond->Lindex = rac->Lindex;

                       RB_cond->numnodes = rac->numverts;
                       RB_cond->x = (double *) (malloc(RB_cond->numnodes * SzD));
                       RB_cond->y = (double *) (malloc(RB_cond->numnodes * SzD));
                       RB_cond->z = (double *) (malloc(RB_cond->numnodes * SzD));
                       if(RB_cond->z == NULL)
                          {
                          printf("memory has been exhausted during RB-Tree element vertex alloction for SMLCUTOUT analysis\n");
                          exit(-1);
                          }
                       for(jj=0; jj< rac->numverts; jj++)
                          {
                          RB_cond->x[jj] = rac->x[jj];
                          RB_cond->y[jj] = rac->y[jj];
                          RB_cond->z[jj] = rac->z[jj];
                          }
                        RB_newDbl = (double *) (malloc(SzD));
                       if(RB_newDbl == NULL)
                          {
                          printf("memory has been exhausted during RB-Tree alloction for SMLCUTOUT analysis\n");
                          exit(-1);
                          }
                       *RB_newDbl = RB_newKey2; /**rac->localID; **/
                       RBTreeInsert(Check_RB_Tree,RB_newDbl, RB_cond);
                       }

                    }
                 }
              }
           }



          if((rac->firstindex == cindex) &&
            (CombinedCheckApplies(rac->idn,checkinstance,SLOPEDIRCH,rac->Lindex,rac->Sindex,Config1,Strat1,Domain1,&part1,&part2,&part3) > 0))
             {
             IgnoreDrawingSettings = 1;
             if(part1 > 0)
                {
                ii = j = rac->numverts;
                for(i=0; i< rac->numverts; i++)
                   {
                   if(IsSentinelZvalue(rac->z[i],UseNUNANPO) == 0)
                      {
                      ii = i;
                      break;
                      }
                   }
                for(i=ii+1; i<rac->numverts; i++)
                   {
                   if(IsSentinelZvalue(rac->z[i],UseNUNANPO) == 0)
                      {
                      j = i;
                      break;
                      }
                   }

                for(i=j+1; i < rac->numverts; i++)
                   {
                   kk = 0;
                   ii3 = 0;
                   if(IsSentinelZvalue(rac->z[i],UseNUNANPO) == 0)
                      {
                      ii3 = 1;
                      if((rac->z[ii] > rac->z[j]) && (rac->z[i] > rac->z[j]))
                         kk = 1; /** may have a condition ***/
                      else if((rac->z[ii] < rac->z[j]) && (rac->z[i] < rac->z[j]))
                         kk = 1; /** may have a condition ***/
                      }
                   if(kk > 0)
                      {
                      basedist = Distance(rac->x[ii],rac->y[ii],rac->x[j],rac->y[j]);
                      segdist = Distance(rac->x[i],rac->y[i],rac->x[j],rac->y[j]);
                      z4 = rac->z[j] - rac->z[ii];
                      z3 = rac->z[i] - rac->z[j];

                      slopeangle1 = atan(z3 / segdist);
                      slopeangle2 = atan(z4 / basedist);

                      if(slopeangle2 > slopeangle1)
                         temp = slopeangle2 - slopeangle1;
                      else
                         temp = slopeangle1 - slopeangle2;

                      temp = RadiansToDegrees(temp);

                      if(SensitivityCheck(GTEQ, SLOPEDIRCH, checkinstance, temp) > 0)
                         {
                         ERc = (struct collection *) (malloc(SzC));
                         if(ERc == NULL)
                            {
                            printf("allocation memory exhausted during linear feature condition analysis\n");
                            printf("processing cannot continue\n");
                            exit(-1);
                            }
                         ERc->x[0] = rac->x[ii];
                         ERc->y[0] = rac->y[ii];
                         ERc->z[0] = rac->z[ii];
                         ERc->magnitude = temp;
                         ERc->IDN1 = rac->idn;
                         ERc->keyval = SLOPEDIRCH;
                         ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                         ERc->Sindex1 = rac->Sindex;
                         ERc->aa = rac; /** RawAreal **/
                         ERc->pp = NULL; /** RawPoint **/
                         ERc->le = NULL; /** ListOfEdges **/
                         ERc->poly = NULL; /** ThePolys **/
                         ERc->next = NULL;
                         if(ERroot == NULL)
                            {
                            ERc->x[1] = rac->x[j];
                            ERc->y[1] = rac->y[j];
                            ERc->z[1] = rac->z[j];
                            ERc->x[2] = rac->x[i];
                            ERc->y[2] = rac->y[i];
                            ERc->z[2] = rac->z[i];
                            ERroot = ERc;
                            }
                         else
                            {
                            ERn = ERroot;
                            while(ERn != NULL)
                               {
                               if((ERn->Cnumber == ERc->Cnumber) && (ERn->keyval == ERc->keyval) &&
                                   (ERn->magnitude == ERc->magnitude) && (ERn->IDN1 == ERc->IDN1))
                                  break;

                               ERn = ERn->next;
                               }
                            if(ERn == NULL)
                               {
                               ERc->x[1] = rac->x[j];
                               ERc->y[1] = rac->y[j];
                               ERc->z[1] = rac->z[j];
                               ERc->x[2] = rac->x[i];
                               ERc->y[2] = rac->y[i];
                               ERc->z[2] = rac->z[i];
                               ERc->next = ERroot;
                               ERroot = ERc;
                               }
                            else
                               free(ERc);
                            }
                         }
                      }
                   if(ii3 > 0)
                      {
                      ii = j;
                      j = i;
                      }
                   }
                }
             }  /*** end SLOPEDIRCH procedure for area features ***/



          if((rac->firstindex == cindex) &&
            (CombinedCheckApplies(rac->idn,checkinstance,NOT_FLAT,rac->Lindex,rac->Sindex,Config1,Strat1,Domain1,&part1,&part2,&part3) > 0))
             {
             if(part1 > 0)
                {
                found_one = 0;
                for(kk=0; kk<rac->numverts; kk++)
                   {
                   if(IsSentinelZvalue(rac->z[kk],UseNUNANPO) == 0)
                      {
                      z1 = z2 = rac->z[kk];
                      ii = jj = kk;
                      found_one = 1;
                      break;
                      }
                   }
                for(i=kk+1; i< rac->numverts; i++)
                   {
                   if(IsSentinelZvalue(rac->z[i],UseNUNANPO) == 0)
                      {
                      if(rac->z[i] < z1)
                         {
                         z1 = rac->z[i];  /** use z1 to store min elevation value ***/
                         ii = i;  /*** use ii to store index of coord with min elev value ***/
                         }
                      if(rac->z[i] > z2)
                         {
                         z2 = rac->z[i];  /*** use z2 to store max elevation value ***/
                         jj = i;  /*** use jj to store index of coord with max elev value ***/
                         }
                      }
                   }
                if(found_one > 0)
                   {
                   z3 = z2 - z1;
                   if(SensitivityCheck(GT, NOT_FLAT, checkinstance, z3) > 0)
                      {
                      ERc = (struct collection *) (malloc(SzC));
                      if(ERc == NULL)
                         {
                         printf("allocation memory exhausted during linear feature condition analysis\n");
                         printf("processing cannot continue\n");
                         exit(-1);
                         }
                      ERc->x[0] = rac->x[ii];
                      ERc->y[0] = rac->y[ii];
                      ERc->z[0] = rac->z[ii];
                      ERc->x[1] = rac->x[jj];
                      ERc->y[1] = rac->y[jj];
                      ERc->z[1] = rac->z[jj];
                      ERc->magnitude = z3;
                      ERc->IDN1 = rac->idn;
                      ERc->keyval = NOT_FLAT;
                      ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                      ERc->Sindex1 = rac->Sindex;
                      ERc->aa = rac; /** RawAreal **/
                      ERc->pp = NULL; /** RawPoint **/
                      ERc->le = NULL; /** ListOfEdges **/
                      ERc->poly = NULL; /** ThePolys **/
                      ERc->next = NULL;
                      if(ERroot == NULL)
                         {
                         ERroot = ERc;
                         }
                      else
                         {
                         ERn = ERroot;
                         while(ERn != NULL)
                            {
                            if((ERn->Cnumber == ERc->Cnumber) && (ERn->keyval == ERc->keyval) && (ERn->aa == ERc->aa) &&
                                (ERn->magnitude == ERc->magnitude) && (ERn->IDN1 == ERc->IDN1))
                               break;
   
                            ERn = ERn->next;
                            }
                         if(ERn == NULL)
                           {
                            ERc->next = ERroot;
                            ERroot = ERc;
                            }
                         else
                            free(ERc);
                         }
                      } /*** end if sensitivity check ***/
                   } /** end if found_one ***/
                } /*** end if part1 ***/
             } /*** end NOT_FLAT check ***/


         if(CombinedCheckApplies(rac->idn,checkinstance,LLNONODEINT,rac->Lindex,rac->Sindex,Config1,Strat1,Domain1,&part1,&part2,&part3) > 0)
            {
            if(part1 > 0)
               {
               tempsensitivity = FindRelevantSensitivity(LLNONODEINT,checkinstance,&unuseddbl);
               rlc = Lroot;
               while(rlc != NULL)
                  {
                  Config2 = SCCtable[rlc->Sindex].C;
                  Strat2 = SCCtable[rlc->Sindex].S;
                  Domain2 = SCCtable[rlc->Sindex].D;
                  if(CombinedCheckApplies(rlc->idn,checkinstance,LLNONODEINT,rlc->Lindex,rlc->Sindex,Config2,Strat2,Domain2,&part1,&part2,&part3) > 0)
                     {
                     if(part2 > 0)
                        {
                        if(rac->RB_Tree_Edgelist != NULL)
                           {
                           LastEdge1 = NULL;
                           LastI = -1;
                           i = GetNextArealIndex(rac, LastI, 1, &LastEdge1, cindex, &UsedTree);
                           LastI = i;
                           }
                        else
                           i = 0;
                        while(i >= 0)
                           {
                           if(i > 0)
                              ii = i - 1;
                           else
                              ii = rac->numverts - 1;
                           xt1 = rac->x[ii];
                           yt1 = rac->y[ii];
                           z1 = rac->z[ii];
                           xt2 = rac->x[i];
                           y2 = rac->y[i];
                           z2 = rac->z[i];
                           if(ClipLineToRegion(minx,miny,maxx,maxy,&xt1,&yt1,&z1,&xt2,&y2,&z2,&clipflag,multiplier) > 0)
                              {
                              for(j=1; j<rlc->numnodes; j++)
                                 {
                                 jj = j - 1;
                                 xt3 = rlc->x[jj];
                                 yt3 = rlc->y[jj];
                                 z3 = rlc->z[jj];
                                 xt4 = rlc->x[j];
                                 yt4 = rlc->y[j];
                                 z4 = rlc->z[j];
                                 if(ClipLineToRegion(minx,miny,maxx,maxy,&xt3,&yt3,&z3,&xt4,&yt4,&z4,&clipflag,multiplier) > 0)
                                    {
                                    PassCond = 0;

                                    if(PointOnLineSegment(rac->x[i],rac->y[i],
                                                          rlc->x[j],rlc->y[j],rlc->x[jj],rlc->y[jj], 0.001) > 0)
                                       {
                                       if((EqualWithinTolerance(rac->x[i],rac->y[i],
                                              rlc->x[j],rlc->y[j],tempsensitivity) == 0) &&
                                         (EqualWithinTolerance(rac->x[i],rac->y[i],
                                              rlc->x[jj],rlc->y[jj],tempsensitivity) == 0))
                                          {
                                          xi = rac->x[i];
                                          yi = rac->y[i];
                                          PassCond = 1;
                                          }
                                       }
                                    if((PassCond == 0) &&
                                       (PointOnLineSegment(rac->x[ii],rac->y[ii],
                                                          rlc->x[j],rlc->y[j],rlc->x[jj],rlc->y[jj], 0.001) > 0))
                                       {
                                       if((EqualWithinTolerance(rac->x[ii],rac->y[ii],
                                              rlc->x[j],rlc->y[j],tempsensitivity) == 0) &&
                                         (EqualWithinTolerance(rac->x[ii],rac->y[ii],
                                               rlc->x[jj],rlc->y[jj],tempsensitivity) == 0))
                                          {
                                          xi = rac->x[ii];
                                          yi = rac->y[ii];
                                          PassCond = 1;
                                          }
                                       }
                                    if((PassCond == 0) &&
                                       (PointOnLineSegment(rlc->x[j],rlc->y[j],
                                                          rac->x[i],rac->y[i],rac->x[ii],rac->y[ii], 0.001) > 0))
                                       {
                                       if((EqualWithinTolerance(rac->x[ii],rac->y[ii],
                                              rlc->x[j],rlc->y[j],tempsensitivity) == 0) &&
                                         (EqualWithinTolerance(rac->x[i],rac->y[i],
                                                rlc->x[j],rlc->y[j],tempsensitivity) == 0))
                                          {
                                          xi = rlc->x[j];
                                          yi = rlc->y[j];
                                          PassCond = 1;
                                          }
                                       }
                                    if((PassCond == 0) &&
                                       (PointOnLineSegment(rlc->x[jj],rlc->y[jj],
                                                          rac->x[i],rac->y[i],rac->x[ii],rac->y[ii], 0.001) > 0))
                                       {
                                       if((EqualWithinTolerance(rac->x[ii],rac->y[ii],
                                              rlc->x[jj],rlc->y[jj],tempsensitivity) == 0) &&
                                         (EqualWithinTolerance(rac->x[i],rac->y[i],
                                                 rlc->x[jj],rlc->y[jj],tempsensitivity) == 0))
                                          {
                                          xi = rlc->x[jj];
                                          yi = rlc->y[jj];
                                          PassCond = 1;
                                          }
                                       }

                                    if((PassCond == 0) && (LineSegmentsIntersect(xt1,yt1,xt2,y2,xt3,yt3,xt4,yt4, &xi, &yi) > 0))
                                       {
                                       PassCond = 1;
                                       if(EqualWithinTolerance(xt1,yt1,xi,yi,tempsensitivity) > 0)
                                          {
                                          if(EqualWithinTolerance(xt3,yt3,xi,yi,tempsensitivity) > 0)
                                             PassCond = 0;
                                          else if(EqualWithinTolerance(xt4,yt4,xi,yi,tempsensitivity) > 0)
                                             PassCond = 0;
                                          }
                                       else if(EqualWithinTolerance(xt2,y2,xi,yi,tempsensitivity) > 0)
                                          {
                                          if(EqualWithinTolerance(xt3,yt3,xi,yi,tempsensitivity) > 0)
                                             PassCond = 0;
                                          else if(EqualWithinTolerance(xt4,yt4,xi,yi,tempsensitivity) > 0)
                                             PassCond = 0;
                                          }
                                       }

                                       
                                    if(PassCond > 0)
                                       {
                                       PassCond = RemoveByContainmentOrCoincidence(xi, yi, Lroot, checkinstance,
                                                    LLNONODEINT, minx, miny, maxx, maxy, tempsensitivity,
                                                    root, Proot);
                                       }
                                    if(PassCond > 0)
                                       {
                                       PassCond = ConditionOnDataEdge(rac->x[i],rac->y[i],rac->x[ii],rac->y[ii],root,Proot,Lroot,
                                                   rac, NULL, NULL,
                                                   NorthCount,SouthCount,EastCount,WestCount,checkinstance);
                                       }
                                    if(PassCond > 0)
                                       {

                                       ERc = (struct collection *) (malloc(SzC));
                                       if(ERc == NULL)
                                          {
                                          printf("allocation memory exhausted during linear feature condition analysis\n");
                                          printf("processing cannot continue\n");
                                          exit(-1);
                                          }
                                       ERc->px_int = xi;
                                       ERc->py_int = yi;
                                       if(ii == rac->numverts - 1)
                                          {
                                          ERc->x[0] = rac->x[0];
                                          ERc->y[0] = rac->y[0];
                                          ERc->z[0] = rac->z[0];
                                          ERc->x[1] = rac->x[rac->numverts - 1];
                                          ERc->y[1] = rac->y[rac->numverts - 1];
                                          ERc->z[1] = rac->z[rac->numverts - 1];
                                          }
                                       else
                                          {
                                          ERc->x[0] = rac->x[ii];
                                          ERc->y[0] = rac->y[ii];
                                          ERc->z[0] = rac->z[ii];
                                          ERc->x[1] = rac->x[ii + 1];
                                          ERc->y[1] = rac->y[ii + 1];
                                          ERc->z[1] = rac->z[ii + 1];
                                          }
                                       ERc->magnitude = 0.0;
                                       ERc->keyval = LLNONODEINT;
                                       ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                                       ERc->IDN1 = rac->idn;
                                       ERc->Sindex1 = rac->Sindex;
                                       ERc->aa = rac;
                                       ERc->vertexindex1 = ii;
                                       ERc->ll = rlc;
                                       ERc->vertexindex2 = jj;
                                       ERc->pp = NULL;
                                       ERc->aa2 = NULL;
                                       ERc->next = NULL;
                                       if(ERroot == NULL)
                                          {
                                          ERc->pz_int = InterpLinearElev(xt1,yt1,z1,xt2,y2,z2,xi,yi);
                                          ERroot = ERc;
                                          }
                                       else
                                          {
                                          ERn = ERroot;
                                          while(ERn != NULL)
                                             {
                                             if((ERn->Cnumber == ERc->Cnumber) && (ERn->keyval == ERc->keyval) &&
                                                  (ERn->x[0] == ERc->x[0]) && (ERn->y[0] == ERc->y[0]) &&
                                                  (ERn->aa == ERc->aa) && (ERn->ll == ERc->ll))
                                                {
                                                break;
                                                }

                                             ERn = ERn->next;
                                             }
                                          if(ERn == NULL)
                                             {
                                             ERc->pz_int = InterpLinearElev(xt1,yt1,z1,xt2,y2,z2,xi,yi);
                                             ERc->next = ERroot;
                                             ERroot = ERc;
                                             }
                                          else
                                            free(ERc);
                                         }
                                       }

                                    }
                                 }
                              }
                           if(rac->RB_Tree_Edgelist != NULL)
                              {
                              i = GetNextArealIndex(rac, LastI, 1, &LastEdge1, cindex, &UsedTree);
                              LastI = i;
                              }
                           else
                              {
                              ++i;
                              if(i >= rac->numverts)
                                 i = -1;
                              }
                           }
                        }
                     }
                  rlc = rlc->next;
                  }

               rpc = Proot;
               while(rpc != NULL)
                  {
                  Config2 = SCCtable[rpc->Sindex].C;
                  Strat2 = SCCtable[rpc->Sindex].S;
                  Domain2 = SCCtable[rpc->Sindex].D;
                  if((rpc->numverts == -1) &&
                   (CombinedCheckApplies(rpc->idn,checkinstance,LLNONODEINT,rpc->Lindex,rpc->Sindex,Config2,Strat2,Domain2,&part1,&part2,&part3) > 0))
                     {
                     if(part2 > 0)
                        {
                        if(rac->RB_Tree_Edgelist != NULL)
                           {
                           LastEdge1 = NULL;
                           LastI = -1;
                           i = GetNextArealIndex(rac, LastI, 1, &LastEdge1, cindex, &UsedTree);
                           LastI = i;
                           }
                        else
                           i = 0;
                        while(i >= 0)
                           {
                           LastI = i;
                           if(i > 0)
                              ii = i - 1;
                           else
                              ii = rac->numverts - 1;
                           xt1 = rac->x[ii];
                           yt1 = rac->y[ii];
                           z1 = rac->z[ii];
                           xt2 = rac->x[i];
                           y2 = rac->y[i];
                           z2 = rac->z[i];
                           if(ClipLineToRegion(minx,miny,maxx,maxy,&xt1,&yt1,&z1,&xt2,&y2,&z2,&clipflag,multiplier) > 0)
                              {
                              ptldist1 = PointToLineDist2D(rpc->x[0],rpc->y[0],rac->x[ii],rac->y[ii],rac->x[i],rac->y[i]);
                              if(ptldist1 <= tempsensitivity)
                                 {
                                 PassCond = 1;
                                 if(EqualWithinTolerance(rpc->x[0],rpc->y[0],rac->x[i],rac->y[i],tempsensitivity) > 0)
                                    {
                                    PassCond = 0;
                                    }
                                 else if(EqualWithinTolerance(rpc->x[0],rpc->y[0],rac->x[ii],rac->y[ii],tempsensitivity) > 0)
                                    {
                                    PassCond = 0;
                                    }

                                 if(PassCond > 0)
                                    {
                                    PassCond = RemoveByContainmentOrCoincidence(rpc->x[0], rpc->y[0], Lroot, checkinstance,
                                                 LLNONODEINT, minx, miny, maxx, maxy, tempsensitivity,
                                                 root, Proot);
                                    }
                                 if(PassCond > 0)
                                    {
                                    PassCond = ConditionOnDataEdge(rac->x[i],rac->y[i],rac->x[ii],rac->y[ii],root,Proot,Lroot,
                                                rac, NULL, NULL,
                                                NorthCount,SouthCount,EastCount,WestCount,checkinstance);
                                    }

                                 if(PassCond > 0)
                                    {
                                    ERc = (struct collection *) (malloc(SzC));
                                    if(ERc == NULL)
                                       {
                                       printf("allocation memory exhausted during linear feature condition analysis\n");
                                       printf("processing cannot continue\n");
                                       exit(-1);
                                       }
                                    ERc->px_int = rpc->x[0];
                                    ERc->py_int = rpc->y[0];
                                    if(ii == rac->numverts - 1)
                                       {
                                       ERc->x[0] = rac->x[0];
                                       ERc->y[0] = rac->y[0];
                                       ERc->z[0] = rac->z[0];
                                       ERc->x[1] = rac->x[rac->numverts - 1];
                                       ERc->y[1] = rac->y[rac->numverts - 1];
                                       ERc->z[1] = rac->z[rac->numverts - 1];
                                       }
                                    else
                                       {
                                       ERc->x[0] = rac->x[ii];
                                       ERc->y[0] = rac->y[ii];
                                       ERc->z[0] = rac->z[ii];
                                       ERc->x[1] = rac->x[ii + 1];
                                       ERc->y[1] = rac->y[ii + 1];
                                       ERc->z[1] = rac->z[ii + 1];
                                       }
                                    ERc->magnitude = 0.0;
                                    ERc->keyval = LLNONODEINT;
                                    ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                                    ERc->IDN1 = rac->idn;
                                    ERc->Sindex1 = rac->Sindex;
                                    ERc->aa = rac;
                                    ERc->ll = NULL;
                                    ERc->aa2 = NULL;
                                    ERc->vertexindex1 = ii;
                                    ERc->pp = rpc;
                                    ERc->vertexindex2 = -1;
                                    ERc->next = NULL;
                                    if(ERroot == NULL)
                                       {
                                       ERc->pz_int = InterpLinearElev(xt1,yt1,z1,xt2,y2,z2,rpc->x[0],rpc->y[0]);
                                       ERroot = ERc;
                                       }
                                    else
                                       {
                                       ERn = ERroot;
                                       while(ERn != NULL)
                                          {
                                            if((ERn->Cnumber == ERc->Cnumber) && (ERn->keyval == ERc->keyval) &&
                                               (ERn->x[0] == ERc->x[0]) && (ERn->y[0] == ERc->y[0]) &&
                                               (ERn->aa == ERc->aa) && (ERn->pp == ERc->pp))
                                             break;

                                          ERn = ERn->next;
                                          }
                                       if(ERn == NULL)
                                          {
                                          ERc->pz_int = InterpLinearElev(xt1,yt1,z1,xt2,y2,z2,rpc->x[0],rpc->y[0]);
                                          ERc->next = ERroot;
                                          ERroot = ERc;
                                          }
                                       else
                                         free(ERc);
                                      }
                                    }
                                 }
                              }
                           if(rac->RB_Tree_Edgelist != NULL)
                              {
                              i = GetNextArealIndex(rac, LastI, 1, &LastEdge1, cindex, &UsedTree);
                              LastI = i;
                              }
                           else
                              {
                              ++i;
                              if(i >= rac->numverts)
                                 i = -1;
                              }
                           }
                        }
                     }
                  rpc = rpc->next;
                  }

               ran = rac->next;
               while(ran != NULL)
                  {
                  Config2 = SCCtable[ran->Sindex].C;
                  Strat2 = SCCtable[ran->Sindex].S;
                  Domain2 = SCCtable[ran->Sindex].D;
                  if(CombinedCheckApplies(ran->idn,checkinstance,LLNONODEINT,ran->Lindex,ran->Sindex,Config2,Strat2,Domain2,&part1,&part2,&part3) > 0)
                     {

                     if(part2 > 0)
                        {
                        if(ran->RB_Tree_Edgelist == NULL)
                           {
                           if(rac->RB_Tree_Edgelist != NULL)
                              {
                              LastEdge1 = NULL;
                              LastI = -1;
                              i = GetNextArealIndex(rac, LastI, 1, &LastEdge1, cindex, &UsedTree);
                              LastI = i;
                              }
                           else
                              i = 0;
                           while(i >= 0)
                              {
                              LastI = i;
                              if(i > 0)
                                 ii = i - 1;
                              else
                                 ii = rac->numverts - 1;
                              xt1 = rac->x[ii];
                              yt1 = rac->y[ii];
                              z1 = rac->z[ii];
                              xt2 = rac->x[i];
                              y2 = rac->y[i];
                              z2 = rac->z[i];
                              if(ClipLineToRegion(minx,miny,maxx,maxy,&xt1,&yt1,&z1,&xt2,&y2,&z2,&clipflag,multiplier) > 0)
                                 {
                                 for(j=1; j<ran->numverts; j++)
                                    {
                                    jj = j - 1;
                                    xt3 = ran->x[jj];
                                    yt3 = ran->y[jj];
                                    z3 = ran->z[jj];
                                    xt4 = ran->x[j];
                                    yt4 = ran->y[j];
                                    z4 = ran->z[j];
                                    checkit = 1;
                                    if(EqualWithinTolerance(rac->x[i],rac->y[i],ran->x[j],ran->y[j],tempsensitivity) > 0)
                                       {
                                       if(EqualWithinTolerance(rac->x[ii],rac->y[ii],ran->x[jj],ran->y[jj],tempsensitivity) > 0)
                                          checkit = 0;
                                       }
                                    else if(EqualWithinTolerance(rac->x[ii],rac->y[ii],ran->x[j],ran->y[j],tempsensitivity) > 0)
                                       {
                                       if(EqualWithinTolerance(rac->x[i],rac->y[i],ran->x[jj],ran->y[jj],tempsensitivity) > 0)
                                          checkit = 0;
                                       }
                                    if((checkit > 0) && 
                                         (ClipLineToRegion(minx,miny,maxx,maxy,&xt3,&yt3,&z3,&xt4,&yt4,&z4,&clipflag,multiplier) > 0))
                                       {
                                       PassCond = 0;
                                       if(PointOnLineSegment(rac->x[i],rac->y[i],
                                                             ran->x[j],ran->y[j],ran->x[jj],ran->y[jj], 0.001) > 0)
                                          {
                                          if((EqualWithinTolerance(rac->x[i],rac->y[i],
                                                 ran->x[j],ran->y[j],tempsensitivity) == 0) &&
                                            (EqualWithinTolerance(rac->x[i],rac->y[i],
                                                 ran->x[jj],ran->y[jj],tempsensitivity) == 0))
                                             {
                                             xi = rac->x[i];
                                             yi = rac->y[i];
                                             PassCond = 1;
                                             }
                                          }
                                       if((PassCond == 0) && 
                                          (PointOnLineSegment(rac->x[ii],rac->y[ii],
                                                             ran->x[j],ran->y[j],ran->x[jj],ran->y[jj], 0.001) > 0))
                                          {
                                          if((EqualWithinTolerance(rac->x[ii],rac->y[ii],
                                                 ran->x[j],ran->y[j],tempsensitivity) == 0) &&
                                            (EqualWithinTolerance(rac->x[ii],rac->y[ii],
                                                  ran->x[jj],ran->y[jj],tempsensitivity) == 0))
                                             {
                                             xi = rac->x[ii];
                                             yi = rac->y[ii];
                                             PassCond = 1;
                                             }
                                          }
                                       if((PassCond == 0) &&
                                          (PointOnLineSegment(ran->x[j],ran->y[j],
                                                             rac->x[i],rac->y[i],rac->x[ii],rac->y[ii], 0.001) > 0))
                                          {
                                          if((EqualWithinTolerance(rac->x[ii],rac->y[ii],
                                                 ran->x[j],ran->y[j],tempsensitivity) == 0) &&
                                            (EqualWithinTolerance(rac->x[i],rac->y[i],
                                                   ran->x[j],ran->y[j],tempsensitivity) == 0))
                                             {
                                             xi = ran->x[j];
                                             yi = ran->y[j];
                                             PassCond = 1;
                                             }
                                          }
                                       if((PassCond == 0) &&
                                          (PointOnLineSegment(ran->x[jj],ran->y[jj],
                                                             rac->x[i],rac->y[i],rac->x[ii],rac->y[ii], 0.001) > 0))
                                          {
                                          if((EqualWithinTolerance(rac->x[ii],rac->y[ii],
                                                 ran->x[jj],ran->y[jj],tempsensitivity) == 0) &&
                                            (EqualWithinTolerance(rac->x[i],rac->y[i],
                                                    ran->x[jj],ran->y[jj],tempsensitivity) == 0))
                                             {
                                             xi = ran->x[jj];
                                             yi = ran->y[jj];
                                             PassCond = 1;
                                             }
                                          }
                                       if((PassCond > 0)  || 
                                            (LineSegmentsIntersect(xt1,yt1,xt2,y2,xt3,yt3,xt4,yt4, &xi, &yi) > 0))
                                          {
                                          if(PassCond == 0)
                                             {
                                             PassCond = 1;
                                             if(EqualWithinTolerance(xt1,yt1,xi,yi,tempsensitivity) > 0)
                                                {
                                                if(EqualWithinTolerance(xt3,yt3,xi,yi,tempsensitivity) > 0)
                                                   PassCond = 0;
                                                else if(EqualWithinTolerance(xt4,yt4,xi,yi,tempsensitivity) > 0)
                                                   PassCond = 0;
                                                }
                                             else if(EqualWithinTolerance(xt2,y2,xi,yi,tempsensitivity) > 0)
                                                {
                                                if(EqualWithinTolerance(xt3,yt3,xi,yi,tempsensitivity) > 0)
                                                   PassCond = 0;
                                                else if(EqualWithinTolerance(xt4,yt4,xi,yi,tempsensitivity) > 0)
                                                   PassCond = 0;
                                                }
                                             if(PassCond > 0)
                                                {
                                                if(LineSegmentsOverlap(rac->x[i],rac->y[i],rac->x[ii],rac->y[ii],
                                                    ran->x[j],ran->y[j],ran->x[jj],ran->y[jj],
                                                    &d1, &d2, &d3, &d4, 0.001) > 0)
                                                   {
                                                   PassCond = 0;
                                                   }
                                                }
                                             }

                                          if(PassCond > 0)
                                             {
                                             PassCond = RemoveByContainmentOrCoincidence(xi, yi, Lroot, checkinstance,
                                                    LLNONODEINT, minx, miny, maxx, maxy, tempsensitivity,
                                                    root, Proot);
                                             }
                                          if(PassCond > 0)
                                             {
                                             PassCond = ConditionOnDataEdge(rac->x[i],rac->y[i],rac->x[ii],rac->y[ii],root,Proot,Lroot,
                                                   rac, NULL, NULL,
                                                   NorthCount,SouthCount,EastCount,WestCount,checkinstance);
                                             }
                                          if(PassCond > 0)
                                             {

                                             ERc = (struct collection *) (malloc(SzC));
                                             if(ERc == NULL)
                                                {
                                                printf("allocation memory exhausted during linear feature condition analysis\n");
                                                printf("processing cannot continue\n");
                                                exit(-1);
                                                }
                                             ERc->px_int = xi;
                                             ERc->py_int = yi;
                                             if(ii == rac->numverts - 1)
                                                {
                                                ERc->x[0] = rac->x[0];
                                                ERc->y[0] = rac->y[0];
                                                ERc->z[0] = rac->z[0];
                                                ERc->x[1] = rac->x[rac->numverts - 1];
                                                ERc->y[1] = rac->y[rac->numverts - 1];
                                                ERc->z[1] = rac->z[rac->numverts - 1];
                                                }
                                             else
                                                {
                                                ERc->x[0] = rac->x[ii];
                                                ERc->y[0] = rac->y[ii];
                                                ERc->z[0] = rac->z[ii];
                                                ERc->x[1] = rac->x[ii + 1];
                                                ERc->y[1] = rac->y[ii + 1];
                                                ERc->z[1] = rac->z[ii + 1];
                                                }
                                             if(jj == ran->numverts - 1)
                                                {
                                                ERc->x[2] = ran->x[0];
                                                ERc->y[2] = ran->y[0];
                                                ERc->z[2] = ran->z[0];
                                                ERc->x[3] = ran->x[ran->numverts - 1];
                                                ERc->y[3] = ran->y[ran->numverts - 1];
                                                ERc->z[3] = ran->z[ran->numverts - 1];
                                                }
                                             else
                                                {
                                                ERc->x[2] = ran->x[jj];
                                                ERc->y[2] = ran->y[jj];
                                                ERc->z[2] = ran->z[jj];
                                                ERc->x[3] = ran->x[jj + 1];
                                                ERc->y[3] = ran->y[jj + 1];
                                                ERc->z[3] = ran->z[jj + 1];
                                                }
                                             ERc->magnitude = 0.0;
                                             ERc->keyval = LLNONODEINT;
                                             ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                                             ERc->IDN1 = rac->idn;
                                             ERc->Sindex1 = rac->Sindex;
                                             ERc->aa = rac;
                                             ERc->vertexindex1 = ii;
                                             ERc->ll = NULL;
                                             ERc->pp = NULL;
                                             ERc->aa2 = ran;
                                             ERc->vertexindex2 = jj;
                                             ERc->next = NULL;
                                             if(ERroot == NULL)
                                                {
                                                ERc->pz_int = InterpLinearElev(xt1,yt1,z1,xt2,y2,z2,xi,yi);
                                                ERroot = ERc;
                                                }
                                             else
                                                {
                                                ERn = ERroot;
                                                while(ERn != NULL)
                                                   {
                                                     if((ERn->Cnumber == ERc->Cnumber) && (ERn->keyval == ERc->keyval) &&
                                                        (ERn->x[0] == ERc->x[0]) && (ERn->y[0] == ERc->y[0]) &&
                                                            (ERn->aa == ERc->aa) && (ERn->aa2 == ERc->aa2))
                                                      break;

                                                   ERn = ERn->next;
                                                   }
                                                if(ERn == NULL)
                                                   {
                                                   ERc->pz_int = InterpLinearElev(xt1,yt1,z1,xt2,y2,z2,xi,yi);
                                                   ERc->next = ERroot;
                                                   ERroot = ERc;
                                                   }
                                                else
                                                  free(ERc);
                                               }
                                             }
                                          }
                                       }
                                    }
                                 }
                              if(rac->RB_Tree_Edgelist != NULL)
                                 {
                                 i = GetNextArealIndex(rac, LastI, 1, &LastEdge1, cindex, &UsedTree);
                                 LastI = i;
                                 }
                              else
                                 {
                                 ++i;
                                 if(i >= rac->numverts)
                                    i = -1;
                                 }
                              }
                           } /**** end if(ran->RB_Tree_Edgelist == NULL) ****/
                        else /**** a rb-tree, large areal ***/
                           {
                           LastEdge2 = NULL;
                           LastJ = -1;
                           j = GetNextArealIndex(ran, LastJ, 1, &LastEdge2, cindex, &unusedint);
                           LastJ = j;
                           while(j >= 0)
                              {
                              if(j == 0)
                                 jj = ran->numverts - 1;
                              else
                                 jj = j - 1;
                              if(rac->RB_Tree_Edgelist != NULL)
                                 {
                                 LastEdge1 = NULL;
                                 LastI = -1;
                                 i = GetNextArealIndex(rac, LastI, 1, &LastEdge1, cindex, &UsedTree);
                                 LastI = i;
                                 }
                              else
                                 i = 0;
                              while(i >= 0)
                                 {
                                 LastI = i;
                                 if(i > 0)
                                    ii = i - 1;
                                 else
                                    ii = rac->numverts - 1;
                                 xt1 = rac->x[ii];
                                 yt1 = rac->y[ii];
                                 z1 = rac->z[ii];
                                 xt2 = rac->x[i];
                                 y2 = rac->y[i];
                                 z2 = rac->z[i];
                                 checkit = 1;
                                 if(EqualWithinTolerance(rac->x[i],rac->y[i],ran->x[j],ran->y[j],tempsensitivity) > 0)
                                    {
                                    if(EqualWithinTolerance(rac->x[ii],rac->y[ii],ran->x[jj],ran->y[jj],tempsensitivity) > 0)
                                       checkit = 0;
                                    }
                                 else if(EqualWithinTolerance(rac->x[ii],rac->y[ii],ran->x[j],ran->y[j],tempsensitivity) > 0)
                                    {
                                    if(EqualWithinTolerance(rac->x[i],rac->y[i],ran->x[jj],ran->y[jj],tempsensitivity) > 0)
                                       checkit = 0;
                                    }
                                 if((checkit > 0) &&
                                       (ClipLineToRegion(minx,miny,maxx,maxy,&xt1,&yt1,&z1,&xt2,&y2,&z2,&clipflag,multiplier) > 0))
                                    {
                                    PassCond = 0;
                                    if(PointOnLineSegment(rac->x[i],rac->y[i],
                                                          ran->x[j],ran->y[j],ran->x[jj],ran->y[jj], 0.001) > 0)
                                       {
                                       if((EqualWithinTolerance(rac->x[i],rac->y[i],
                                              ran->x[j],ran->y[j],tempsensitivity) == 0) &&
                                         (EqualWithinTolerance(rac->x[i],rac->y[i],
                                              ran->x[jj],ran->y[jj],tempsensitivity) == 0))
                                          {
                                          xi = rac->x[i];
                                          yi = rac->y[i];
                                          PassCond = 1;
                                          }
                                       }
                                    if((PassCond == 0) &&
                                       (PointOnLineSegment(rac->x[ii],rac->y[ii],
                                                          ran->x[j],ran->y[j],ran->x[jj],ran->y[jj], 0.001) > 0))
                                       {
                                       if((EqualWithinTolerance(rac->x[ii],rac->y[ii],
                                              ran->x[j],ran->y[j],tempsensitivity) == 0) &&
                                         (EqualWithinTolerance(rac->x[ii],rac->y[ii],
                                               ran->x[jj],ran->y[jj],tempsensitivity) == 0))
                                          {
                                          xi = rac->x[ii];
                                          yi = rac->y[ii];
                                          PassCond = 1;
                                          }
                                       }
                                    if((PassCond == 0) &&
                                       (PointOnLineSegment(ran->x[j],ran->y[j],
                                                          rac->x[i],rac->y[i],rac->x[ii],rac->y[ii], 0.001) > 0))
                                       {
                                       if((EqualWithinTolerance(rac->x[ii],rac->y[ii],
                                              ran->x[j],ran->y[j],tempsensitivity) == 0) &&
                                         (EqualWithinTolerance(rac->x[i],rac->y[i],
                                                ran->x[j],ran->y[j],tempsensitivity) == 0))
                                          {
                                          xi = ran->x[j];
                                          yi = ran->y[j];
                                          PassCond = 1;
                                          }
                                       }
                                    if((PassCond == 0) &&
                                       (PointOnLineSegment(ran->x[jj],ran->y[jj],
                                                          rac->x[i],rac->y[i],rac->x[ii],rac->y[ii], 0.001) > 0))
                                       {
                                       if((EqualWithinTolerance(rac->x[ii],rac->y[ii],
                                              ran->x[jj],ran->y[jj],tempsensitivity) == 0) &&
                                         (EqualWithinTolerance(rac->x[i],rac->y[i],
                                                 ran->x[jj],ran->y[jj],tempsensitivity) == 0))
                                          {
                                          xi = ran->x[jj];
                                          yi = ran->y[jj];
                                          PassCond = 1;
                                          }
                                       }

                                    if((PassCond > 0) ||
                                          (LineSegmentsIntersect(xt1,yt1,xt2,y2,ran->x[jj],ran->y[jj],ran->x[j],ran->y[j], &xi, &yi) > 0))
                                       {
                                       if(PassCond == 0)
                                          {
                                          PassCond = 1;
                                          if(EqualWithinTolerance(xt1,yt1,xi,yi,tempsensitivity) > 0)
                                             {
                                             if(EqualWithinTolerance(ran->x[jj],ran->y[jj],xi,yi,tempsensitivity) > 0)
                                                PassCond = 0;
                                             else if(EqualWithinTolerance(ran->x[j],ran->y[j],xi,yi,tempsensitivity) > 0)
                                                PassCond = 0;
                                             }
                                          else if(EqualWithinTolerance(xt2,y2,xi,yi,tempsensitivity) > 0)
                                             {
                                             if(EqualWithinTolerance(ran->x[jj],ran->y[jj],xi,yi,tempsensitivity) > 0)
                                                PassCond = 0;
                                             else if(EqualWithinTolerance(ran->x[j],ran->y[j],xi,yi,tempsensitivity) > 0)
                                                PassCond = 0;
                                             }
                                          if(PassCond > 0)
                                             {
                                             if(LineSegmentsOverlap(rac->x[i],rac->y[i],rac->x[ii],rac->y[ii],
                                                 ran->x[j],ran->y[j],ran->x[jj],ran->y[jj],
                                                 &d1, &d2, &d3, &d4, 0.001) > 0)
                                                {
                                                PassCond = 0;
                                                }
                                             }
                                          }

                                       if(PassCond > 0)
                                          {
                                          PassCond = RemoveByContainmentOrCoincidence(xi, yi, Lroot, checkinstance,
                                                    LLNONODEINT, minx, miny, maxx, maxy, tempsensitivity,
                                                    root, Proot);
                                          }
                                       if(PassCond > 0)
                                          {
                                          PassCond = ConditionOnDataEdge(rac->x[i],rac->y[i],rac->x[ii],rac->y[ii],root,Proot,Lroot,
                                                   rac, NULL, NULL,
                                                   NorthCount,SouthCount,EastCount,WestCount,checkinstance);
                                          }
                                       if(PassCond > 0)
                                          {

                                          ERc = (struct collection *) (malloc(SzC));
                                          if(ERc == NULL)
                                             {
                                             printf("allocation memory exhausted during linear feature condition analysis\n");
                                             printf("processing cannot continue\n");
                                             exit(-1);
                                             }
                                          ERc->px_int = xi;
                                          ERc->py_int = yi;
                                          if(ii == rac->numverts - 1)
                                             {
                                             ERc->x[0] = rac->x[0];
                                             ERc->y[0] = rac->y[0];
                                             ERc->z[0] = rac->z[0];
                                             ERc->x[1] = rac->x[rac->numverts - 1];
                                             ERc->y[1] = rac->y[rac->numverts - 1];
                                             ERc->z[1] = rac->z[rac->numverts - 1];
                                             }
                                          else
                                             {
                                             ERc->x[0] = rac->x[ii];
                                             ERc->y[0] = rac->y[ii];
                                             ERc->z[0] = rac->z[ii];
                                             ERc->x[1] = rac->x[ii + 1];
                                             ERc->y[1] = rac->y[ii + 1];
                                             ERc->z[1] = rac->z[ii + 1];
                                             }
                                          if(jj == ran->numverts - 1)
                                             {
                                             ERc->x[2] = ran->x[0];
                                             ERc->y[2] = ran->y[0];
                                             ERc->z[2] = ran->z[0];
                                             ERc->x[3] = ran->x[ran->numverts - 1];
                                             ERc->y[3] = ran->y[ran->numverts - 1];
                                             ERc->z[3] = ran->z[ran->numverts - 1];
                                             }
                                          else
                                             {
                                             ERc->x[2] = ran->x[jj];
                                             ERc->y[2] = ran->y[jj];
                                             ERc->z[2] = ran->z[jj];
                                             ERc->x[3] = ran->x[jj + 1];
                                             ERc->y[3] = ran->y[jj + 1];
                                             ERc->z[3] = ran->z[jj + 1];
                                             }
                                          ERc->magnitude = 0.0;
                                          ERc->keyval = LLNONODEINT;
                                          ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                                          ERc->IDN1 = rac->idn;
                                          ERc->Sindex1 = rac->Sindex;
                                          ERc->aa = rac;
                                          ERc->vertexindex1 = ii;
                                          ERc->ll = NULL;
                                          ERc->pp = NULL;
                                          ERc->aa2 = ran;
                                          ERc->vertexindex2 = jj;
                                          ERc->next = NULL;
                                          if(ERroot == NULL)
                                             {
                                             ERc->pz_int = InterpLinearElev(xt1,yt1,z1,xt2,y2,z2,xi,yi);
                                             ERroot = ERc;
                                             }
                                          else
                                             {
                                             ERn = ERroot;
                                             while(ERn != NULL)
                                                {
                                                  if((ERn->Cnumber == ERc->Cnumber) && (ERn->keyval == ERc->keyval) &&
                                                     (ERn->x[0] == ERc->x[0]) && (ERn->y[0] == ERc->y[0]) &&
                                                     (ERn->aa == ERc->aa) && (ERn->aa2 == ERc->aa2))
                                                   break;

                                                ERn = ERn->next;
                                                }
                                             if(ERn == NULL)
                                                {
                                                ERc->pz_int = InterpLinearElev(xt1,yt1,z1,xt2,y2,z2,xi,yi);
                                                ERc->next = ERroot;
                                                ERroot = ERc;
                                                }
                                             else
                                               free(ERc);
                                            }
                                          } /*** end need to record a condition ***/
                                       } /*** end line segments do intersect ***/

                                    } /*** end clip line feature segments to LM boundaries ***/
                                 if(rac->RB_Tree_Edgelist != NULL)
                                    {
                                    i = GetNextArealIndex(rac, LastI, 1, &LastEdge1, cindex, &UsedTree);
                                    LastI = i;
                                    }
                                 else
                                    {
                                    ++i;
                                    if(i >= rac->numverts)
                                       i = -1;
                                    }
                                 /***i = GetNextArealIndex(rac,LastI,0,&LastEdge1, cindex, &UsedTree); ***/
                                 } /*** end for i ...   ***/
                              j = GetNextArealIndex(ran, LastJ, 1, &LastEdge2, cindex, &unusedint);
                              LastJ = j;
                              } /*** end have another large area segment to get ***/
                           }
                        }
                     }
                  ran = ran->next;
                  }


               } /*** end if check applies to rac as part1 ***/
            }  /*** end if LLNONODEINT check applies to rac at all **/



         if(CombinedCheckApplies(rac->idn,checkinstance,NONODEOVLP,rac->Lindex,rac->Sindex,Config1,Strat1,Domain1,&part1,&part2,&part3) > 0)
            {
            if(part1 > 0)
               {
               tempsensitivity = FindRelevantSensitivity(NONODEOVLP,checkinstance,&unuseddbl);
               rlc = Lroot;
               while(rlc != NULL)
                  {
                  Config2 = SCCtable[rlc->Sindex].C;
                  Strat2 = SCCtable[rlc->Sindex].S;
                  Domain2 = SCCtable[rlc->Sindex].D;
                  if(CombinedCheckApplies(rlc->idn,checkinstance,NONODEOVLP,rlc->Lindex,rlc->Sindex,Config2,Strat2,Domain2,&part1,&part2,&part3) > 0)
                     {
                     if(part2 > 0)
                        {
                        LastI = 0;
                        LastEdge1 = NULL;
                        i = GetNextArealIndex(rac,LastI,0,&LastEdge1, cindex, &UsedTree);
                        while(i >= 0)
                           {
                           LastI = i;
                           if(i > 0)
                              ii = i - 1;
                           else
                              ii = rac->numverts - 1;
                           if(rac->x[i] < rac->x[ii])
                              {
                              L2minx = rac->x[i];
                              L2maxx = rac->x[ii];
                              }
                           else
                              {
                              L2minx = rac->x[ii];
                              L2maxx = rac->x[i];
                              }
                           if(rac->y[i] < rac->y[ii])
                              {
                              L2miny = rac->y[i];
                              L2maxy = rac->y[ii];
                              }
                           else
                              {
                              L2miny = rac->y[ii];
                              L2maxy = rac->y[i];
                              }
                           xt1 = rac->x[ii];
                           yt1 = rac->y[ii];
                           z1 = rac->z[ii];
                           xt2 = rac->x[i];
                           y2 = rac->y[i];
                           z2 = rac->z[i];
                           if(ClipLineToRegion(minx,miny,maxx,maxy,&xt1,&yt1,&z1,&xt2,&y2,&z2,&clipflag,multiplier) > 0)
                              {
                              for(j=1; j<rlc->numnodes; j++)
                                 {
                                 jj = j - 1;
                                 xt3 = rlc->x[jj];
                                 yt3 = rlc->y[jj];
                                 z3 = rlc->z[jj];
                                 xt4 = rlc->x[j];
                                 yt4 = rlc->y[j];
                                 z4 = rlc->z[j];
                                 if(ClipLineToRegion(minx,miny,maxx,maxy,&xt3,&yt3,&z3,&xt4,&yt4,&z4,&clipflag,multiplier) > 0)
                                    {
                                    PassCond = 0;
                                    if(((StrictlyBetween(rac->x[ii],rac->y[ii],rlc->x[jj], rlc->y[jj], rlc->x[j],rlc->y[j]) > 0) ||
                                            (StrictlyBetween(rac->x[i],rac->y[i],rlc->x[jj], rlc->y[jj], rlc->x[j],rlc->y[j]) > 0)) &&
                                                  (MergeSeg_LineSegmentsOverlap(rac->x[ii],rac->y[ii],rac->x[i],rac->y[i],
                                               rlc->x[jj], rlc->y[jj], rlc->x[j],rlc->y[j], L2minx, L2maxx, L2miny, L2maxy,
                                               &xi2, &yi2, &xi, &yi, tempsensitivity) > 0))
                                       {
                                       PassCond = 1;
                                       if(rlc->x[j] < rlc->x[jj])
                                          {
                                          xt1 = rlc->x[j];
                                          xt2 = rlc->x[jj];
                                          }
                                       else
                                          {
                                          xt1 = rlc->x[jj];
                                          xt2 = rlc->x[j];
                                          }
                                       if(rlc->y[j] < rlc->y[jj])
                                          {
                                          yt1 = rlc->y[j];
                                          y2 = rlc->y[jj];
                                          }
                                       else
                                          {
                                          yt1 = rlc->y[jj];
                                          y2 = rlc->y[j];
                                          }
                                       if((EqualWithinTolerance(L2minx,L2miny,xt1,yt1,tempsensitivity) > 0) &&
                                             (EqualWithinTolerance(L2maxx,L2maxy,xt2,y2,tempsensitivity) > 0))
                                             PassCond = 0;

                                       if(PassCond > 0)
                                          {
                                          ERc = (struct collection *) (malloc(SzC));
                                          if(ERc == NULL)
                                             {
                                             printf("allocation memory exhausted during linear feature condition analysis\n");
                                             printf("processing cannot continue\n");
                                             exit(-1);
                                             }
                                          if(StrictlyBetween(rac->x[ii],rac->y[ii],rlc->x[jj], rlc->y[jj], rlc->x[j],rlc->y[j]) > 0)
                                             {
                                             ERc->px_int = rac->x[ii];
                                             ERc->py_int = rac->y[ii];
                                             }
                                          else
                                             {
                                             ERc->px_int = rac->x[i];
                                             ERc->py_int = rac->y[i];
                                             }
                                          if(ii == rac->numverts - 1)
                                             {
                                             ERc->x[0] = rac->x[0];
                                             ERc->y[0] = rac->y[0];
                                             ERc->z[0] = rac->z[0];
                                             ERc->x[1] = rac->x[rac->numverts - 1];
                                             ERc->y[1] = rac->y[rac->numverts - 1];
                                             ERc->z[1] = rac->z[rac->numverts - 1];
                                             }
                                          else
                                             {
                                             ERc->x[0] = rac->x[ii];
                                             ERc->y[0] = rac->y[ii];
                                             ERc->z[0] = rac->z[ii];
                                             ERc->x[1] = rac->x[ii + 1];
                                             ERc->y[1] = rac->y[ii + 1];
                                             ERc->z[1] = rac->z[ii + 1];
                                             }
                                          ERc->magnitude = 0.0;
                                          ERc->keyval = NONODEOVLP;
                                          ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                                          ERc->IDN1 = rac->idn;
                                          ERc->Sindex1 = rac->Sindex;
                                          ERc->aa = rac;
                                          ERc->vertexindex1 = ii;
                                          ERc->ll = rlc;
                                          ERc->vertexindex2 = jj;
                                          ERc->pp = NULL;
                                          ERc->aa2 = NULL;
                                          ERc->next = NULL;
                                          if(ERroot == NULL)
                                             {
                                             ERc->pz_int = InterpLinearElev(xt1,yt1,z1,xt2,y2,z2,xi,yi);
                                             ERroot = ERc;
                                             }
                                          else
                                             {
                                             ERn = ERroot;
                                             while(ERn != NULL)
                                                {
                                                  if((ERn->Cnumber == ERc->Cnumber) && (ERn->keyval == ERc->keyval) &&
                                                     (ERn->x[0] == ERc->x[0]) && (ERn->y[0] == ERc->y[0]) &&
                                                     (ERn->aa == ERc->aa))
                                                   break;

                                                ERn = ERn->next;
                                                }
                                             if(ERn == NULL)
                                                {
                                                ERc->pz_int = InterpLinearElev(xt1,yt1,z1,xt2,y2,z2,xi,yi);
                                                ERc->next = ERroot;
                                                ERroot = ERc;
                                                }
                                             else
                                               free(ERc);
                                             }
                                          }
                                       }

                                    }
                                 }
                              }
                           i = GetNextArealIndex(rac,LastI,0,&LastEdge1, cindex, &UsedTree);
                           }
                        }
                     }
                  rlc = rlc->next;
                  }


               ran = root;  /***rac->next;***/
               while(ran != NULL)
                  {
                  Config2 = SCCtable[ran->Sindex].C;
                  Strat2 = SCCtable[ran->Sindex].S;
                  Domain2 = SCCtable[ran->Sindex].D;
                  if((ran != rac) &&
                    (CombinedCheckApplies(ran->idn,checkinstance,NONODEOVLP,ran->Lindex,ran->Sindex,
                             Config2,Strat2,Domain2,&part1,&part2,&part3) > 0))
                     {
                     if(part2 > 0)
                        {
                        if(ran->RB_Tree_Edgelist == NULL)
                           {
                           LastI = 0;
                           LastEdge1 = NULL;
                           i = GetNextArealIndex(rac,LastI,0,&LastEdge1, cindex, &UsedTree);
                           while(i >= 0)
                              {
                              LastI = i;
                              if(i > 0)
                                 ii = i - 1;
                              else
                                 ii = rac->numverts - 1;
                              if(rac->x[i] < rac->x[ii])
                                 {
                                 L2minx = rac->x[i];
                                 L2maxx = rac->x[ii];
                                 }
                              else
                                 {
                                 L2minx = rac->x[ii];
                                 L2maxx = rac->x[i];
                                 }
                              if(rac->y[i] < rac->y[ii])
                                 {
                                 L2miny = rac->y[i];
                                 L2maxy = rac->y[ii];
                                 }
                              else
                                 {
                                 L2miny = rac->y[ii];
                                 L2maxy = rac->y[i];
                                 }

                              xt1 = rac->x[ii];
                              yt1 = rac->y[ii];
                              z1 = rac->z[ii];
                              xt2 = rac->x[i];
                              y2 = rac->y[i];
                              z2 = rac->z[i];
                              if(ClipLineToRegion(minx,miny,maxx,maxy,&xt1,&yt1,&z1,&xt2,&y2,&z2,&clipflag,multiplier) > 0)
                                 {
                                 for(j=1; j<ran->numverts; j++)
                                    {
                                    jj = j - 1;
                                    xt3 = ran->x[jj];
                                    yt3 = ran->y[jj];
                                    z3 = ran->z[jj];
                                    xt4 = ran->x[j];
                                    yt4 = ran->y[j];
                                    z4 = ran->z[j];
                                    if(ClipLineToRegion(minx,miny,maxx,maxy,&xt3,&yt3,&z3,&xt4,&yt4,&z4,&clipflag,multiplier) > 0)
                                       {
                                       if(((StrictlyBetween(rac->x[ii],rac->y[ii],ran->x[jj], ran->y[jj], ran->x[j],ran->y[j]) > 0) ||
                                            (StrictlyBetween(rac->x[i],rac->y[i],ran->x[jj], ran->y[jj], ran->x[j],ran->y[j]) > 0)) &&
                                                (MergeSeg_LineSegmentsOverlap(rac->x[ii],rac->y[ii],rac->x[i],rac->y[i],
                                               ran->x[jj], ran->y[jj], ran->x[j],ran->y[j], L2minx, L2maxx, L2miny, L2maxy,
                                               &xi2, &yi2, &xi, &yi, tempsensitivity) > 0))
                                          {
                                          PassCond = 1;
                                          if(ran->x[j] < ran->x[jj])
                                             {
                                             xt1 = ran->x[j];
                                             xt2 = ran->x[jj];
                                             }
                                          else
                                             {
                                             xt1 = ran->x[jj];
                                             xt2 = ran->x[j];
                                             }
                                          if(ran->y[j] < ran->y[jj])
                                             {
                                             yt1 = ran->y[j];
                                             y2 = ran->y[jj];
                                             }
                                          else
                                             {
                                             yt1 = ran->y[jj];
                                             y2 = ran->y[j];
                                             }
                                          if((EqualWithinTolerance(L2minx,L2miny,xt1,yt1,tempsensitivity) > 0) &&
                                                (EqualWithinTolerance(L2maxx,L2maxy,xt2,y2,tempsensitivity) > 0))
                                                PassCond = 0;

                                          if(PassCond > 0)
                                             {
                                             ERc = (struct collection *) (malloc(SzC));
                                             if(ERc == NULL)
                                                {
                                                printf("allocation memory exhausted during linear feature condition analysis\n");
                                                printf("processing cannot continue\n");
                                                exit(-1);
                                                }
                                             if(StrictlyBetween(rac->x[ii],rac->y[ii],ran->x[jj], ran->y[jj], ran->x[j],ran->y[j]) > 0)
                                                {
                                                ERc->px_int = rac->x[ii];
                                                ERc->py_int = rac->y[ii];
                                                }
                                             else
                                                {
                                                ERc->px_int = rac->x[i];
                                                ERc->py_int = rac->y[i];
                                                }
                                             if(ii == rac->numverts - 1)
                                                {
                                                ERc->x[0] = rac->x[0];
                                                ERc->y[0] = rac->y[0];
                                                ERc->z[0] = rac->z[0];
                                                ERc->x[1] = rac->x[rac->numverts - 1];
                                                ERc->y[1] = rac->y[rac->numverts - 1];
                                                ERc->z[1] = rac->z[rac->numverts - 1];
                                                }
                                             else
                                                {
                                                ERc->x[0] = rac->x[ii];
                                                ERc->y[0] = rac->y[ii];
                                                ERc->z[0] = rac->z[ii];
                                                ERc->x[1] = rac->x[ii + 1];
                                                ERc->y[1] = rac->y[ii + 1];
                                                ERc->z[1] = rac->z[ii + 1];
                                                }
                                             if(jj == ran->numverts - 1)
                                                {
                                                ERc->x[2] = ran->x[0];
                                                ERc->y[2] = ran->y[0];
                                                ERc->z[2] = ran->z[0];
                                                ERc->x[3] = ran->x[ran->numverts - 1];
                                                ERc->y[3] = ran->y[ran->numverts - 1];
                                                ERc->z[3] = ran->z[ran->numverts - 1];
                                                }
                                             else
                                                {
                                                ERc->x[2] = ran->x[jj];
                                                ERc->y[2] = ran->y[jj];
                                                ERc->z[2] = ran->z[jj];
                                                ERc->x[3] = ran->x[jj + 1];
                                                ERc->y[3] = ran->y[jj + 1];
                                                ERc->z[3] = ran->z[jj + 1];
                                                }
                                             ERc->magnitude = 0.0;
                                             ERc->keyval = NONODEOVLP;
                                             ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                                             ERc->IDN1 = rac->idn;
                                             ERc->Sindex1 = rac->Sindex;
                                             ERc->aa = rac;
                                             ERc->vertexindex1 = ii;
                                             ERc->ll = NULL;
                                             ERc->pp = NULL;
                                             ERc->aa2 = ran;
                                             ERc->vertexindex2 = jj;
                                             ERc->next = NULL;
                                             if(ERroot == NULL)
                                                {
                                                ERc->pz_int = InterpLinearElev(xt1,yt1,z1,xt2,y2,z2,xi,yi);
                                                ERroot = ERc;
                                                }
                                             else
                                                {
                                                ERn = ERroot;
                                                while(ERn != NULL)
                                                   {
                                                     if((ERn->Cnumber == ERc->Cnumber) && (ERn->keyval == ERc->keyval) &&
                                                        (ERn->x[0] == ERc->x[0]) && (ERn->y[0] == ERc->y[0]) &&
                                                            (ERn->aa == ERc->aa))
                                                      break;

                                                   ERn = ERn->next;
                                                   }
                                                if(ERn == NULL)
                                                   {
                                                   ERc->pz_int = InterpLinearElev(xt1,yt1,z1,xt2,y2,z2,xi,yi);
                                                   ERc->next = ERroot;
                                                   ERroot = ERc;
                                                   }
                                                else
                                                  free(ERc);
                                               }
                                             }
                                          }
                                       }
                                    }
                                 }
                              i = GetNextArealIndex(rac,LastI,0,&LastEdge1, cindex, &UsedTree);
                              }
                           } /**** end if(ran->RB_Tree_Edgelist == NULL) ****/
                        else /**** a rb-tree, large areal ***/
                           {
                           LastEdge2 = NULL;
                           LastJ = -1;
                           j = GetNextArealIndex(ran, LastJ, 1, &LastEdge2, cindex, &unusedint);
                           LastJ = j;
                           while(j >= 0)
                              {
                              if(j == 0)
                                 jj = ran->numverts - 1;
                              else
                                 jj = j - 1;
                              LastI = 0;
                              LastEdge1 = NULL;
                              i = GetNextArealIndex(rac,LastI,0,&LastEdge1, cindex, &UsedTree);
                              while(i >= 0)
                                 {
                                 LastI = i;
                                 ii = i - 1;
                                 xt1 = rac->x[ii];
                                 yt1 = rac->y[ii];
                                 z1 = rac->z[ii];
                                 xt2 = rac->x[i];
                                 y2 = rac->y[i];
                                 z2 = rac->z[i];
                                 if(ClipLineToRegion(minx,miny,maxx,maxy,&xt1,&yt1,&z1,&xt2,&y2,&z2,&clipflag,multiplier) > 0)
                                    {
                                    if(((StrictlyBetween(rac->x[ii],rac->y[ii],ran->x[jj], ran->y[jj], ran->x[j],ran->y[j]) > 0) ||
                                            (StrictlyBetween(rac->x[i],rac->y[i],ran->x[jj], ran->y[jj], ran->x[j],ran->y[j]) > 0)) &&
                                               (MergeSeg_LineSegmentsOverlap(rac->x[ii],rac->y[ii],rac->x[i],rac->y[i],
                                            ran->x[jj], ran->y[jj], ran->x[j],ran->y[j], L2minx, L2maxx, L2miny, L2maxy,
                                            &xi2, &yi2, &xi, &yi, tempsensitivity) > 0))
                                       {
                                       PassCond = 1;
                                       if(ran->x[j] < ran->x[jj])
                                          {
                                          xt1 = ran->x[j];
                                          xt2 = ran->x[jj];
                                          }
                                       else
                                          {
                                          xt1 = ran->x[jj];
                                          xt2 = ran->x[j];
                                          }
                                       if(ran->y[j] < ran->y[jj])
                                          {
                                          yt1 = ran->y[j];
                                          y2 = ran->y[jj];
                                          }
                                       else
                                          {
                                          yt1 = ran->y[jj];
                                          y2 = ran->y[j];
                                          }
                                       if((EqualWithinTolerance(L2minx,L2miny,xt1,yt1,tempsensitivity) > 0) &&
                                             (EqualWithinTolerance(L2maxx,L2maxy,xt2,y2,tempsensitivity) > 0))
                                             PassCond = 0;

                                       if(PassCond > 0)
                                          {
                                          ERc = (struct collection *) (malloc(SzC));

                                          if(ERc == NULL)
                                             {
                                             printf("allocation memory exhausted during linear feature condition analysis\n");
                                             printf("processing cannot continue\n");
                                             exit(-1);
                                             }
                                          if(StrictlyBetween(rac->x[ii],rac->y[ii],ran->x[jj], ran->y[jj], ran->x[j],ran->y[j]) > 0)
                                             {
                                             ERc->px_int = rac->x[ii];
                                             ERc->py_int = rac->y[ii];
                                             }
                                          else
                                             {
                                             ERc->px_int = rac->x[i];
                                             ERc->py_int = rac->y[i];
                                             }
                                          if(ii == rac->numverts - 1)
                                             {
                                             ERc->x[0] = rac->x[0];
                                             ERc->y[0] = rac->y[0];
                                             ERc->z[0] = rac->z[0];
                                             ERc->x[1] = rac->x[rac->numverts - 1];
                                             ERc->y[1] = rac->y[rac->numverts - 1];
                                             ERc->z[1] = rac->z[rac->numverts - 1];
                                             }
                                          else
                                             {
                                             ERc->x[0] = rac->x[ii];
                                             ERc->y[0] = rac->y[ii];
                                             ERc->z[0] = rac->z[ii];
                                             ERc->x[1] = rac->x[ii + 1];
                                             ERc->y[1] = rac->y[ii + 1];
                                             ERc->z[1] = rac->z[ii + 1];
                                             }
                                          if(jj == ran->numverts - 1)
                                             {
                                             ERc->x[2] = ran->x[0];
                                             ERc->y[2] = ran->y[0];
                                             ERc->z[2] = ran->z[0];
                                             ERc->x[3] = ran->x[ran->numverts - 1];
                                             ERc->y[3] = ran->y[ran->numverts - 1];
                                             ERc->z[3] = ran->z[ran->numverts - 1];
                                             }
                                          else
                                             {
                                             ERc->x[2] = ran->x[jj];
                                             ERc->y[2] = ran->y[jj];
                                             ERc->z[2] = ran->z[jj];
                                             ERc->x[3] = ran->x[jj + 1];
                                             ERc->y[3] = ran->y[jj + 1];
                                             ERc->z[3] = ran->z[jj + 1];
                                             }
                                          ERc->magnitude = 0.0;
                                          ERc->keyval = NONODEOVLP;
                                          ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                                          ERc->IDN1 = rac->idn;
                                          ERc->Sindex1 = rac->Sindex;
                                          ERc->aa = rac;
                                          ERc->vertexindex1 = ii;
                                          ERc->ll = NULL;
                                          ERc->pp = NULL;
                                          ERc->aa2 = ran;
                                          ERc->vertexindex2 = jj;
                                          ERc->next = NULL;
                                          if(ERroot == NULL)
                                             {
                                             ERc->pz_int = InterpLinearElev(xt1,yt1,z1,xt2,y2,z2,xi,yi);
                                             ERroot = ERc;
                                             }
                                          else
                                             {
                                             ERn = ERroot;
                                             while(ERn != NULL)
                                                {
                                                  if((ERn->Cnumber == ERc->Cnumber) && (ERn->keyval == ERc->keyval) &&
                                                     (ERn->x[0] == ERc->x[0]) && (ERn->y[0] == ERc->y[0]) &&
                                                     (ERn->aa == ERc->aa))
                                                   break;

                                                ERn = ERn->next;
                                                }
                                             if(ERn == NULL)
                                                {
                                                ERc->pz_int = InterpLinearElev(xt1,yt1,z1,xt2,y2,z2,xi,yi);
                                                ERc->next = ERroot;
                                                ERroot = ERc;
                                                }
                                             else
                                               free(ERc);
                                            }
                                          } /*** end need to record a condition ***/
                                       } /*** end line segments do intersect ***/

                                    } /*** end clip line feature segments to LM boundaries ***/
                                 i = GetNextArealIndex(rac,LastI,0,&LastEdge1, cindex, &UsedTree);
                                 } /*** end for i ...   ***/
                              j = GetNextArealIndex(ran, LastJ, 1, &LastEdge2, cindex, &unusedint);
                              LastJ = j;
                              } /*** end have another large area segment to get ***/
                           }
                        }
                     }
                  ran = ran->next;
                  }


               } /*** end if check applies to rac as part1 ***/
            }



         if((CombinedCheckApplies(rac->idn,checkinstance,AREAINTAREA,rac->Lindex,rac->Sindex,Config1,
                      Strat1, Domain1,&Part1Save,&Part2Save,&part3) > 0) &&
                      (Part1Save > 0)) 
            {
            ran = root;
            while(ran != NULL)
               {
               PassCond = 0;
               BasedOnPoint = 0;
               BasedOnEdges = 0;
               if(ran != rac)
                  {
                  if((CombinedCheckApplies(ran->idn,checkinstance,AREAINTAREA,ran->Lindex,ran->Sindex,SCCtable[ran->Sindex].C,
                                SCCtable[ran->Sindex].S,SCCtable[ran->Sindex].D,&part1,&part2,&part3) > 0) &&
                            (part2 > 0))
                     {
                     PassCond = 1;
                     }
                  }
               if(PassCond > 0)
                  {
                  PassCond2 = TwoArealsIntersect(rac, ran, &xi, &yi, &AOAindex1, &AOAindex2, &TouchingAreals);

                   if(PassCond2 == 1) /*** means there is an actual edge intersection ***/
                      {
                      ERc = (struct collection *) (malloc(SzC));
                      if(ERc == NULL)
                         {
                         printf("allocation memory exhausted during linear feature condition analysis\n");
                         printf("processing cannot continue\n");
                         exit(-1);
                         }
                      ERc->magnitude = 0.0;
                      ERc->keyval = AREAINTAREA;
                      ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                      ERc->Sindex1 = rac->Sindex;
                      ERc->Sindex2 = ran->Sindex;
                      if((BasedOnPoint > 0) || (BasedOnEdges > 0))
                         {
                         ERc->vertexindex1 = -1;
                         ERc->vertexindex2 = -1;
                         BasedOnPoint = 0;
                         BasedOnEdges = 0;
                         }
                      else
                         {
                         ERc->vertexindex1 = AOAindex1;
                         ERc->vertexindex2 = AOAindex2;
                         }
                      ERc->x[0] = xi;
                      ERc->y[0] = yi;
                      ERc->z[0] = rac->z[0];
                      ERc->aa = rac;
                      ERc->aa2 = ran;
                      ERc->numverts1 = rac->numverts;
                      ERc->numverts2 = ran->numverts;
                      ERc->next = NULL;
                      if(ERroot == NULL)
                         {
                         ERroot = ERc;
                         }
                      else
                         {
                         ERn = ERroot;
                         while(ERn != NULL)
                            {
                            if((ERn->Cnumber == ERc->Cnumber) && (ERn->keyval == ERc->keyval))
                               {
                               if((ERn->aa == ERc->aa) && (ERn->aa2 == ERc->aa2))
                                  break;
                               else if((ERn->aa == ERc->aa2) && (ERn->aa2 == ERc->aa))
                                  break;
                               }
                            ERn = ERn->next;
                            }
                         if(ERn == NULL)
                            {
                            ERc->next = ERroot;
                            ERroot = ERc;
                            }
                         else
                            {
                            free(ERc);
                            }
                         }
                     } /** end if PassCond2 ***/
                  } /**** end if PassCond ***/
               ran = ran->next;
               }
            }  /*** end AREAINTAREA check ***/





         if((rac->firstindex == cindex) && (rac->ishole >= 1) &&
               (CombinedCheckApplies(rac->idn,checkinstance,CUT_INT,rac->Lindex,rac->Sindex,Config1,
                      Strat1, Domain1,&Part1Save,&Part2Save,&part3) > 0) &&
                      (Part1Save > 0))
            {
            ran = root;
            while(ran != NULL)
               {
               PassCond = 0;
               if(ran != rac)
                  {
                  if((ran->ishole < 0) && (ran->idn == rac->idn))
                     {
                     PassCond = 1;
                     }
                  }
               if(PassCond > 0)
                  {
                  PassCond2 = TwoArealsIntersect(rac, ran, &xi, &yi, &AOAindex1, &AOAindex2, &TouchingAreals);

                   if(PassCond2 == 1) /*** means there is an actual edge intersection ***/
                      {
                      ERc = (struct collection *) (malloc(SzC));
                      if(ERc == NULL)
                         {
                         printf("allocation memory exhausted during linear feature condition analysis\n");
                         printf("processing cannot continue\n");
                         exit(-1);
                         }
                      ERc->magnitude = 0.0;
                      ERc->keyval = CUT_INT;
                      ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                      ERc->Sindex1 = rac->Sindex;
                      ERc->Sindex2 = ran->Sindex;
                      ERc->vertexindex2 = AOAindex2;
                      if(AOAindex1 == 0)
                         {
                         ptldist1 = PointToArealDist2D(rac->x[0],rac->y[0],ran);
                         ptldist2 = PointToArealDist2D(rac->x[rac->numverts-1],rac->y[rac->numverts-1],ran);
                         if(ptldist1 < ptldist2)
                            {
                            ERc->x[0] = rac->x[0];
                            ERc->y[0] = rac->y[0];
                            ERc->z[0] = rac->z[0];
                            ERc->vertexindex1 = 0;
                            ERc->x[1] = rac->x[rac->numverts-1];
                            ERc->y[1] = rac->y[rac->numverts-1];
                            ERc->z[1] = rac->z[rac->numverts-1];
                            }
                         else
                            {
                            ERc->x[1] = rac->x[0];
                            ERc->y[1] = rac->y[0];
                            ERc->z[1] = rac->z[0];
                            ERc->vertexindex1 = rac->numverts-1;
                            ERc->x[0] = rac->x[rac->numverts-1];
                            ERc->y[0] = rac->y[rac->numverts-1];
                            ERc->z[0] = rac->z[rac->numverts-1];
                            }
                         }
                      else
                         {
                         ptldist1 = PointToArealDist2D(rac->x[AOAindex1],rac->y[AOAindex1],ran);
                         ptldist2 = PointToArealDist2D(rac->x[AOAindex1-1],rac->y[AOAindex1-1],ran);
                         if(ptldist1 < ptldist2)
                            {
                            ERc->x[0] = rac->x[AOAindex1];
                            ERc->y[0] = rac->y[AOAindex1];
                            ERc->z[0] = rac->z[AOAindex1];
                            ERc->vertexindex1 = AOAindex1;
                            ERc->x[1] = rac->x[AOAindex1-1];
                            ERc->y[1] = rac->y[AOAindex1-1];
                            ERc->z[1] = rac->z[AOAindex1-1];
                            }
                         else
                            {
                            ERc->x[1] = rac->x[AOAindex1];
                            ERc->y[1] = rac->y[AOAindex1];
                            ERc->z[1] = rac->z[AOAindex1];
                            ERc->vertexindex1 = AOAindex1 - 1;
                            ERc->x[0] = rac->x[AOAindex1-1];
                            ERc->y[0] = rac->y[AOAindex1-1];
                            ERc->z[0] = rac->z[AOAindex1-1];
                            }
                         }

                      if(AOAindex2 == 0)
                         {
                         ERc->x[2] = ran->x[0];
                         ERc->y[2] = ran->y[0];
                         ERc->z[2] = ran->z[0];
                         ERc->x[3] = ran->x[ran->numverts-1];
                         ERc->y[3] = ran->y[ran->numverts-1];
                         ERc->z[3] = ran->z[ran->numverts-1];
                         }
                      else
                         {
                         ERc->x[2] = ran->x[AOAindex2];
                         ERc->y[2] = ran->y[AOAindex2];
                         ERc->z[2] = ran->z[AOAindex2];
                         ERc->x[3] = ran->x[AOAindex2-1];
                         ERc->y[3] = ran->y[AOAindex2-1];
                         ERc->z[3] = ran->z[AOAindex2-1];
                         }
                      ERc->aa = rac;
                      ERc->aa2 = ran;
                      ERc->numverts1 = rac->numverts;
                      ERc->numverts2 = ran->numverts;
                      ERc->next = NULL;
                      if(ERroot == NULL)
                         {
                         ERroot = ERc;
                         }
                      else
                         {
                         ERn = ERroot;
                         while(ERn != NULL)
                            {
                            if((ERn->Cnumber == ERc->Cnumber) && (ERn->keyval == ERc->keyval))
                               {
                               if((ERn->aa == ERc->aa) && (ERn->aa2 == ERc->aa2))
                                  break;
                               else if((ERn->aa == ERc->aa2) && (ERn->aa2 == ERc->aa))
                                  break;
                               }
                            ERn = ERn->next;
                            }
                         if(ERn == NULL)
                            {
                            ERc->next = ERroot;
                            ERroot = ERc;
                            }
                         else
                            {
                            free(ERc);
                            }
                         }
                     } /** end if PassCond2 ***/

                  for(i=0; i<rac->numverts; i++)
                     {
                     if(ran->RB_Tree_Edgelist == NULL)
                        temp = PointToSmallArealDist2D(rac->x[i], rac->y[i],ran,&j,&temp2);
                     else
                        temp = PointToLargeArealDist2D(rac->x[i], rac->y[i],ran,&j,&temp2);



                     if((temp >= 0) && (SensitivityCheck(LTEQ, CUT_INT, checkinstance, temp) > 0))
                        {
                        ERc = (struct collection *) (malloc(SzC));
                        if(ERc == NULL)
                           {
                           printf("allocation memory exhausted during linear feature condition analysis\n");
                           printf("processing cannot continue\n");
                           exit(-1);
                           }
                        ERc->magnitude = temp;
                        ERc->keyval = CUT_INT;
                        ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                        ERc->Sindex1 = rac->Sindex;
                        ERc->Sindex2 = ran->Sindex;
                        if(i == (rac->numverts - 1))
                           ERc->vertexindex1 = i - 1;
                        else
                           ERc->vertexindex1 = i;
                        if(j == 0)
                           ERc->vertexindex2 = ran->numverts - 2;
                        else
                           ERc->vertexindex2 = j - 1;
                        ERc->x[0] = rac->x[i];
                        ERc->y[0] = rac->y[i];
                        ERc->z[0] = rac->z[i];
/***/
                        if(i == (rac->numverts - 1))
                           {
                           ERc->x[1] = rac->x[i-1];
                           ERc->y[1] = rac->y[i-1];
                           ERc->z[1] = rac->z[i-1];
                           }
                        else
                           {
                           ERc->x[1] = rac->x[i+1];
                           ERc->y[1] = rac->y[i+1];
                           ERc->z[1] = rac->z[i+1];
                           }
                        if(j == 0)
                           {
                           ERc->x[2] = ran->x[0];
                           ERc->y[2] = ran->y[0];
                           ERc->z[2] = ran->z[0];
                           ERc->x[3] = ran->x[ran->numverts-1];
                           ERc->y[3] = ran->y[ran->numverts-1];
                           ERc->z[3] = ran->z[ran->numverts-1];
                           }
                        else
                           {
                           ERc->x[2] = ran->x[j];
                           ERc->y[2] = ran->y[j];
                           ERc->z[2] = ran->z[j];
                           ERc->x[3] = ran->x[j-1];
                           ERc->y[3] = ran->y[j-1];
                           ERc->z[3] = ran->z[j-1];
                           }
                        ERc->aa = rac;
                        ERc->aa2 = ran;
                        ERc->numverts1 = rac->numverts;
                        ERc->numverts2 = ran->numverts;
                        ERc->next = NULL;
                        if(ERroot == NULL)
                           {
                           ERroot = ERc;
                           }
                        else
                           {
                           ERn = ERroot;
                           while(ERn != NULL)
                              {
                              if((ERn->Cnumber == ERc->Cnumber) && (ERn->keyval == ERc->keyval))
                                 {
                                 if((ERn->x[0] == ERc->x[0]) && (ERn->y[0] == ERc->y[0]))
                                    {
                                    if((ERn->aa == ERc->aa) && (ERn->aa2 == ERc->aa2))
                                       break;
                                    else if((ERn->aa == ERc->aa2) && (ERn->aa2 == ERc->aa))
                                       break;
                                    }
                                 }
                              ERn = ERn->next;
                              }
                           if(ERn == NULL)
                              {
                              ERc->next = ERroot;
                              ERroot = ERc;
                              }
                           else
                              {
                              free(ERc);
                              }
                           }
                        } /*** end if dist <= tolerance ***/
                     } /*** end for i ***/
                  } /**** end if PassCond ***/
               ran = ran->next;
               }
            }  /*** end CUT_INT, part 1 where rac is an inner ring ***/

         if((rac->ishole < 0) && /*** if < 0, is an outer ring that does have inner rings ***/
               (CombinedCheckApplies(rac->idn,checkinstance,CUT_INT,rac->Lindex,rac->Sindex,Config1,
                      Strat1, Domain1,&Part1Save,&Part2Save,&part3) > 0) &&
                      (Part1Save > 0))
            {
            ran = root;
            while(ran != NULL)
               {
               PassCond = 0;
               if(ran != rac)
                  {
                  if((ran->ishole > 0) && (ran->idn == rac->idn))
                     {
                     PassCond = 1;
                     }
                  }
               if(PassCond > 0)
                  {
                  for(i=0; i<rac->numverts; i++)
                     {
                     if((rac->x[i] >= minx) && (rac->x[i] <= maxx) && (rac->y[i] >= miny) && (rac->y[i] <= maxy))
                        {
                        if(ran->RB_Tree_Edgelist == NULL)
                           temp = PointToSmallArealDist2D(rac->x[i], rac->y[i],ran,&j,&temp2);
                        else
                           temp = PointToLargeArealDist2D(rac->x[i], rac->y[i],ran,&j,&temp2);
                        }
                     else
                        temp = -100;


                     if((temp > 0) && (temp2 > 0) && (temp2 < 1) && (SensitivityCheck(LTEQ, CUT_INT, checkinstance, temp) > 0))
                        {
                        ERc = (struct collection *) (malloc(SzC));
                        if(ERc == NULL)
                           {
                           printf("allocation memory exhausted during linear feature condition analysis\n");
                           printf("processing cannot continue\n");
                           exit(-1);
                           }
                        ERc->magnitude = temp;
                        ERc->keyval = CUT_INT;
                        ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                        ERc->Sindex1 = rac->Sindex;
                        ERc->Sindex2 = ran->Sindex;
                        if(i == (rac->numverts - 1))
                           ERc->vertexindex1 = i - 1;
                        else
                           ERc->vertexindex1 = i;
                        if(j == 0)
                           ERc->vertexindex2 = ran->numverts - 2;
                        else
                           ERc->vertexindex2 = j - 1;
                        ERc->x[0] = rac->x[i];
                        ERc->y[0] = rac->y[i];
                        ERc->z[0] = rac->z[i];
                        if(i == (rac->numverts - 1))
                           {
                           ERc->x[1] = rac->x[i-1];
                           ERc->y[1] = rac->y[i-1];
                           ERc->z[1] = rac->z[i-1];
                           }
                        else
                           {
                           ERc->x[1] = rac->x[i+1];
                           ERc->y[1] = rac->y[i+1];
                           ERc->z[1] = rac->z[i+1];
                           }
/***/
                        if(j == 0)
                           {
                           ERc->x[2] = ran->x[0];
                           ERc->y[2] = ran->y[0];
                           ERc->z[2] = ran->z[0];
                           ERc->x[3] = ran->x[ran->numverts-1];
                           ERc->y[3] = ran->y[ran->numverts-1];
                           ERc->z[3] = ran->z[ran->numverts-1];
                           }
                        else
                           {
                           ERc->x[2] = ran->x[j];
                           ERc->y[2] = ran->y[j];
                           ERc->z[2] = ran->z[j];
                           ERc->x[3] = ran->x[j-1];
                           ERc->y[3] = ran->y[j-1];
                           ERc->z[3] = ran->z[j-1];
                           }
                        ERc->aa = rac;
                        ERc->aa2 = ran;
                        ERc->numverts1 = rac->numverts;
                        ERc->numverts2 = ran->numverts;
                        ERc->next = NULL;
                        if(ERroot == NULL)
                           {
                           ERroot = ERc;
                           }
                        else
                           {
                           ERn = ERroot;
                           while(ERn != NULL)
                              {
                              if((ERn->Cnumber == ERc->Cnumber) && (ERn->keyval == ERc->keyval))
                                 {
                                 if((ERn->x[0] == ERc->x[0]) && (ERn->y[0] == ERc->y[0]))
                                    {
                                    if((ERn->aa == ERc->aa) && (ERn->aa2 == ERc->aa2))
                                       break;
                                    else if((ERn->aa == ERc->aa2) && (ERn->aa2 == ERc->aa))
                                       break;
                                    }
                                 }
                              ERn = ERn->next;
                              }
                           if(ERn == NULL)
                              {
                              ERc->next = ERroot;
                              ERroot = ERc;
                              }
                           else
                              {
                              free(ERc);
                              }
                           }
                        } /*** end if dist <= tolerance ***/
                     } /*** end for i ***/
                  } /**** end if PassCond ***/
               ran = ran->next;
               }
            }  /*** end CUT_INT check, part 2, where rac is an outer (parent) ring ***/





         if((CombinedCheckApplies(rac->idn,checkinstance,PART_ISF,rac->Lindex,rac->Sindex,Config1,
                      Strat1, Domain1,&Part1Save,&Part2Save,&part3) > 0) && 
                      (Part1Save > 0))
            {
            ran = root; 
            while(ran != NULL)
               {
               if(ran != rac)
                  {
                  if((CombinedCheckApplies(ran->idn,checkinstance,PART_ISF,ran->Lindex,ran->Sindex,SCCtable[ran->Sindex].C,
                                SCCtable[ran->Sindex].S,SCCtable[ran->Sindex].D,&part1,&part2,&part3) > 0) &&
                            (part2 > 0))
                     {
                        AinAresult = TwoArealsPartISF(rac,ran,&xint,&yint, &AOAindex1, &AOAindex2);
                        if(AinAresult == 2) /** need to check and see if ran is actually inside a hole of rac **/
                           {
                           rah = root;
                           while(rah != NULL)
                              {
                              if((rah->ishole > 0) && (rah->idn == rac->idn)) 
                                 {
                                 if(AreaInsideArea(ran,rah,&xt3,&yt3) > 1) /** says all points are inside if >1, some points are inside if > 0 **/
                                    {
                                    break;
                                    }
                                 }
                              rah = rah->next;
                             }
                           if(rah == NULL)
                             AinAresult = 1;
                           }

                        if(AinAresult == 1) 
                           {
                           ERc = (struct collection *) (malloc(SzC));
                           if(ERc == NULL)
                              {
                              printf("allocation memory exhausted during linear feature condition analysis\n");
                              printf("processing cannot continue\n");
                              exit(-1);
                              }
                           ERc->magnitude = 0.0;
                           ERc->keyval = PART_ISF;
                           ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                           ERc->vertexindex1 = AOAindex1;
                           ERc->vertexindex2 = AOAindex2;
                           BasedOnPoint = 0;
                           BasedOnEdges = 0;
                           ERc->x[0] = xint;
                           ERc->y[0] = yint;
                           ERc->z[0] = rac->z[0];

                           ERc->Sindex1 = rac->Sindex;
                           ERc->Sindex2 = ran->Sindex;
                           ERc->aa = rac;
                           ERc->aa2 = ran;
                           ERc->numverts1 = rac->numverts;
                           ERc->numverts2 = ran->numverts;

                           ERc->next = NULL;
                           if(ERroot == NULL)
                              {
                              ERroot = ERc;
                              }
                           else
                              {
                              ERp = ERn = ERroot;
                              while(ERn != NULL)
                                 {
                                 if((ERn->Cnumber == ERc->Cnumber) && (ERn->keyval == ERc->keyval))
                                    {
                                    if((ERn->aa == ERc->aa) || (ERn->aa->idn == ERc->aa->idn))
                                       {
                                       if((ERn->aa2 == ERc->aa2) || (ERn->aa2->idn == ERc->aa2->idn))
                                          break;
                                       }
                                    }
                                 ERp = ERn;
                                 ERn = ERn->next;
                                 }
                              if(ERn == NULL)
                                 {
                                 ERc->next = ERroot;
                                 ERroot = ERc;
                                 }
                              else
                                 {
                                 if(ERn == ERroot)
                                    {
                                    ERc->next = ERn->next;
                                    ERroot = ERc;
                                    free(ERn);
                                    }
                                 else
                                    {
                                    ERc->next = ERn->next;
                                    ERp->next = ERc;
                                    free(ERn);
                                    }
                                 }
                              }
                           } /** end if PassCond2 so generate a condition ***/
                        /***}  end need to check this pair ***/
                     } /*** end check applies to ran ***/
                  } /** end ran != rac ***/
               ran = ran->next;
               } /*** end while ran != NULL ***/
            } /*** end PART_ISF applies to rac ***/




         if((CombinedCheckApplies(rac->idn,checkinstance,AOVERLAPA,rac->Lindex,rac->Sindex,Config1,
                      Strat1, Domain1,&Part1Save,&Part2Save,&part3) > 0) && (rac->ishole <= 0) &&
                      ((Part1Save > 0) || (Part2Save > 0))) 
            {
Tolerance = 0.001;
            ran = rac->next; /**if using reflexive, can init ran pointer to rac->next, o/w init to root;**/
            AOAindex1 = -1;
            AOAindex2 = -1;
            AOAnext1 = AOAnext2 = -1;
            AOAprev1 = AOAprev2 = -1;
            while(ran != NULL)
               {
               PassCond2 = 0;
               BasedOnPoint = 0;
               BasedOnEdges = 0;
               FinalPointCheck = 0;
               if(ran != rac)
                  {
                  if((CombinedCheckApplies(ran->idn,checkinstance,AOVERLAPA,ran->Lindex,ran->Sindex,SCCtable[ran->Sindex].C,
                                SCCtable[ran->Sindex].S,SCCtable[ran->Sindex].D,&part1,&part2,&part3) > 0) &&
                            ((part2 > 0) || (part1 > 0)))
                     {
                     if(((Part1Save > 0) && (part2 > 0)) || ((Part2Save > 0) && (part1 > 0)))
                        {
                        if((rac->ishole <= 0) && (ran->ishole <= 0))
                           {
                           if((rac->ismulti == 0) || (ran->ismulti == 0)  ||
                                 (CheckThisAreaPair(checkinstance,cindex,IndexLimit, SzPC,SzPW,rac->localID,ran->localID,rac->firstindex,ran->firstindex,rac->area,ran->area) > 0))
                              PassCond2 = 1;
                           }
                        }
                     }
                  }
               if(PassCond2 > 0)
                  {
                  PassCond2 = 0;
                  if(PassCond2 == 0)
                     {
                     if(rac->area > ran->area)
                        {
                        ra_out = rac;
                        ra_in = ran;

                        CreatePointInsideAreal(ran, &xint, &yint);

                        if(rac->RB_Tree_Edgelist == NULL)
                           {
                           PassCond2 = PointInAreal(xint, yint, rac->x,rac->y,rac->numverts, &iii);
                           }
                        else
                           {
                           PassCond2 = PointInsideLargeAreal(xint, yint, rac, &iii);
                           }
                        }
                     else
                        {
                        ra_out = ran;
                        ra_in = rac;

                        CreatePointInsideAreal(rac, &xint, &yint);

                        if(ran->RB_Tree_Edgelist == NULL)
                           {
                           PassCond2 = PointInAreal(xint, yint, ran->x,ran->y,ran->numverts, &iii);
                           }
                        else
                           {
                           PassCond2 = PointInsideLargeAreal(xint, yint, ran, &iii);
                           }

                        }
                      }
                   if(PassCond2 > 0)
                      {
                         PassCond2 = 0;
                         BasedOnPoint = 0;
                         rah = root;
                         xt3 = ra_in->x[0];
                         yt3 = ra_in->y[0];
                         while(rah != NULL)
                            {
                            AinAresult = 0;
                            if((rah->ishole > 0) && (rah->idn == ra_out->idn) && (rah->area >= (ra_in->area * 0.95))) 
                               {
                               if(rah->RB_Tree_Edgelist == NULL)
                                  {
                                  PassCond3 = PointInAreal(xint, yint, rah->x,rah->y,rah->numverts, &iii);
                                  }
                               else
                                  {
                                  PassCond3 = PointInsideLargeAreal(xint, yint, rah, &iii);
                                  }

                               if(PassCond3 > 0)
                                  {
                                     AinAresult = AreaInsideArea(ra_in,rah,&xt3,&yt3);
                                  if(AinAresult > 1) /****  says all points are inside if >1, some points are inside if > 0 **/
                                     {
                                     break;
                                     }
                                  else if(AinAresult > 0) /***  says all points are inside if >1, some points are inside if > 0 **/
                                     {
/**** if some, but not all points are inside, they must have intersecting edges somewhere ***/
                                     unusedint = TwoArealsIntersect(rac, ran, &xi, &yi, &AOAindex1, &AOAindex2, &TouchingAreals);
                                     if(unusedint ==1)
                                        {
                                        xt4 = xi;
                                        yt4 = yi;
                                        break;
                                        }
                                     else
                                        {
                                        xt4 = xt3;
                                        yt4 = yt3;
                                        break;
                                        }
                                     }
                                  }
                               }
                            rah = rah->next;
                            }
                         if((rah == NULL) || (AinAresult == 1))
                            {
                            xi = xt3;
                            yi = yt3;
                            PassCond2 = 1;
                            BasedOnPoint = 1;
                            if(AinAresult == 1)
                               {
                               xint = xt4;
                               yint = yt4;
                               }
                            }
                      else if(AinAresult > 1)
                         {
                         ran = ran->next;
                         continue;
                         }
                      }


                   if(PassCond2 > 0)
                      {
                      ra_3part = root;
                      while(ra_3part != NULL)
                         {
                         if((ra_3part != rac) && (ra_3part != ran) && (ra_3part->ishole <= 0))
                            {
                            if((CombinedCheckApplies(ra_3part->idn,checkinstance,AOVERLAPA,ra_3part->Lindex,ra_3part->Sindex,
                                   SCCtable[ra_3part->Sindex].C, SCCtable[ra_3part->Sindex].S,SCCtable[ra_3part->Sindex].D,
                                    &part1,&part2,&part3) > 0) && 
                                   (part3 > 0))
                               {
             
                               unusedint = 0;
                               if(ra_3part->RB_Tree_Edgelist == NULL)
                                  {
                                  unusedint = PointInAreal(xint, yint, ra_3part->x,ra_3part->y,ra_3part->numverts, &iii);
                                  }
                               else
                                  {
                                  unusedint = PointInsideLargeAreal(xint, yint, ra_3part, &iii);
                                  }
                               if(unusedint > 0)
                                  break;
                               }
                            }
                         ra_3part = ra_3part->next;
                         }
                      if(ra_3part != NULL)
                         PassCond2 = 0;
                      }
if(PassCond2 > 0)
   {
   if((ActiveChecks[checkinstance].participants >= 3) && (ActiveChecks[checkinstance].sensitivity6 > 0))
      {
      if((xint < minx) || (xint > maxx) || (yint < miny) || (yint > maxy))
         {
         RemoveCheckedAreaPair(checkinstance,rac->localID,ran->localID,rac->area,ran->area);
         PassCond2 = 0;
         }
      }
   }
                   if(PassCond2 > 0)
                      {
                      PassCond2 = 0;
                      ERc = (struct collection *) (malloc(SzC));
                      if(ERc == NULL)
                         {
                         printf("allocation memory exhausted during linear feature condition analysis\n");
                         printf("processing cannot continue\n");
                         exit(-1);
                         }
                      ERc->magnitude = 0.0;
                      ERc->keyval = AOVERLAPA;
                      ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                      ERc->vertexindex1 = -1;
                      ERc->vertexindex2 = -1;
                      BasedOnPoint = 0;
                      BasedOnEdges = 0;
                      ERc->x[0] = xint;
                      ERc->y[0] = yint;
                      ERc->z[0] = rac->z[0];

                      if(Part1Save > 0)
                         {
                         ERc->Sindex1 = rac->Sindex;
                         ERc->Sindex2 = ran->Sindex;
                         ERc->aa = rac;
                         ERc->aa2 = ran;
                         ERc->numverts1 = rac->numverts;
                         ERc->numverts2 = ran->numverts;
                         }
                      else
                         {
                         ERc->Sindex1 = ran->Sindex;
                         ERc->Sindex2 = rac->Sindex;
                         ERc->aa = ran;
                         ERc->aa2 = rac;
                         ERc->numverts1 = ran->numverts;
                         ERc->numverts2 = rac->numverts;
                         }

                      ERc->next = NULL;
                      if(ERroot == NULL)
                         {
                         ERroot = ERc;
                         }
                      else
                         {
                         ERn = ERroot;
                         while(ERn != NULL)
                            {
                            if((ERn->Cnumber == ERc->Cnumber) && (ERn->keyval == ERc->keyval))
                               {
                               if((ERn->aa == ERc->aa) && (ERn->aa2 == ERc->aa2))
                                  break;
                               else if((ERn->aa == ERc->aa2) && (ERn->aa2 == ERc->aa))
                                  break;
                               }
                            ERn = ERn->next;
                            }
                         if(ERn == NULL)
                            {
                            ERc->next = ERroot;
                            ERroot = ERc;
                            }
                         else
                            {
                            free(ERc);
                            }
                         }
                      } /** end if PassCond2 so generate a condition ***/
                   else
                      PassCond2 = 1;

                  }

               if(PassCond2 > 0)
                  {
                  BasedOnEdges = 0;
                  TouchingAreals = 0;
                  PassCond2 = TwoArealsIntersect(rac, ran, &xi, &yi, &AOAindex1, &AOAindex2, &TouchingAreals);
                  if(PassCond2 == 2) /** signal that passed from coincident edges **/
                     {
                     PassCond2 = 1;
                     BasedOnEdges = 1;
                     FinalPointCheck = 1;
                      }
                   if(PassCond2 != 1) /** no edge intersects, see if any point is inside ***/
                      {
                      if((PassCond2 == 0) && (TouchingAreals == 0))
                         {
                         if(rac->area > ran->area)
                            {
                            ra_out = rac;
                            ra_in = ran;

                            CreatePointInsideAreal(ran, &xint, &yint);

                            if(rac->RB_Tree_Edgelist == NULL) 
                               {
                               //PassCond2 = PointInAreal(ran->x[0],ran->y[0],rac->x,rac->y,rac->numverts, &iii);
                               PassCond2 = PointInAreal(xint, yint, rac->x,rac->y,rac->numverts, &iii);
                               }
                            else
                               {
                               //PassCond2 = PointInsideLargeAreal(ran->x[0],ran->y[0],rac, &iii);
                               PassCond2 = PointInsideLargeAreal(xint, yint, rac, &iii);
                               }
                            }
                         else
                            {
                            ra_out = ran;
                            ra_in = rac;

                            CreatePointInsideAreal(rac, &xint, &yint);

                            if(ran->RB_Tree_Edgelist == NULL)
                               {
                               PassCond2 = PointInAreal(xint, yint, ran->x,ran->y,ran->numverts, &iii);
                               }
                            else
                               {
                               PassCond2 = PointInsideLargeAreal(xint, yint, ran, &iii);
                               }
                            }
                         }
                      else if(PassCond2 == 2)
                         {
                         if(rac->area > ran->area)
                            {
                            ra_out = rac;
                            ra_in = ran;
                            }
                         else
                            {
                            ra_out = ran;
                            ra_in = rac;
                            }
                         }
                      if(PassCond2 > 0) /** seems to be inside area feature - is it actually in a hole of that areal? ***/
                         {
                         PassCond2 = 0;
                         BasedOnPoint = 0;
                         rah = root;
                         xt3 = ra_in->x[0];
                         yt3 = ra_in->y[0];
                         while(rah != NULL)
                            {
                            if((rah->ishole > 0) && (rah->idn == ra_out->idn))
                               {
                               if(AreaInsideArea(ra_in,rah,&xt3,&yt3) > 1) /** says all points are inside if >1, some points are inside if > 0 **/
                                  {
                                  break;
                                  }
                               }
                            rah = rah->next;
                            }
                         if(rah == NULL)
                            {
                            xi = xt3;
                            yi = yt3;
                            PassCond2 = 1;
                            BasedOnPoint = 1;
                            }
                         }
                      }
                   if(PassCond2 > 0)
                      {
                      if(FinalPointCheck > 0)
                         {
                         temp = PointToArealDist2D(xi,yi,rac);
                         if(temp < Tolerance)
                            temp = PointToArealDist2D(xi,yi,ran);
                         }
                      else
                         temp = 100.0;

/**** if from intersecting edges - check severity of the condition ***/
                      if((FinalPointCheck <= 0) && (BasedOnPoint == 0) && (BasedOnEdges == 0))
                         {
                         AOAnext1 = AOAindex1 + 1;
                         if(AOAnext1 >= rac->numverts)
                            AOAnext1 = 0;
                         if(AOAindex1 == 0)
                            jj = rac->numverts - 1;
                         else
                            jj = AOAindex1 - 1;
                         AOAprev1 = jj - 1;
                         if(AOAprev1 < 0)
                            AOAprev1 = rac->numverts - 1;
 AOAnext2 = AOAindex2 + 1;
 if(AOAnext2 >= ran->numverts)
    AOAnext2 = 0;
 if(AOAindex2 == 0)
    kk = ran->numverts - 1;
 else
    kk = AOAindex2 - 1;
 AOAprev2 = kk - 1;
 if(AOAprev2 < 0)
    AOAprev2 = ran->numverts - 1;
                         temp = AngleBetweenLineSegments(rac->x[jj],rac->y[jj],rac->x[AOAindex1],rac->y[AOAindex1],
                                                           ran->x[kk],ran->y[kk],ran->x[AOAindex2],ran->y[AOAindex2]);
                         if((temp > -0.999999) && (temp < 0.999999))
                            {
                            temp = Distance(rac->x[jj],rac->y[jj],xi,yi);
                            if(temp > Tolerance)
                               {
                               temp = Distance(rac->x[AOAindex1],rac->y[AOAindex1],xi,yi);
                               if(temp > Tolerance)
                                  {
                                  temp = Distance(ran->x[kk],ran->y[kk],xi,yi);
                                  if(temp > Tolerance)
                                     {
                                     temp = Distance(ran->x[AOAindex2],ran->y[AOAindex2],xi,yi);
                                     if(temp > Tolerance)
                                        {
                                        temp = 200;
                                        }
                                     else
                                        {
                                        temp = 0.000001;
                                        }
                                     }
                                  else
                                     {
                                     temp = 0.000001;
                                     }
                                  }
                               else
                                  {
                                  temp = 0.000001;
                                  }
                               }
                            else
                               {
                               temp = 0.000001;
                               }

                            if(temp < 199.0)
                               {
                               if((NearlyEqual(xi,rac->x[jj]) > 0) && (NearlyEqual(yi,rac->y[jj]) > 0))
                                  {
                                  if(PointToArealDist2D(rac->x[AOAindex1],rac->y[AOAindex1],ran) > 0.09)
                                     {
                                     if(ran->RB_Tree_Edgelist == NULL)
                                        PassCond2 = PointInAreal(rac->x[AOAindex1],rac->y[AOAindex1],ran->x,ran->y,ran->numverts, &iii);
                                     else
                                        PassCond2 = PointInsideLargeAreal(rac->x[AOAindex1],rac->y[AOAindex1],ran, &iii);
                                     if(PassCond2 > 0)
                                        {
                                        rah = root;
                                        while(rah != NULL)
                                           {
                                           if((rah != ran) && (rah->ishole > 0) && (rah->idn == ran->idn))
                                              {
                                              if(rah->RB_Tree_Edgelist == NULL)
                                                 {
                                                 if(PointIsInside(rac->x[AOAindex1],rac->y[AOAindex1],
                                                      rah->x,rah->y,rah->x,rah->numverts,C_AREA,&unuseddbl) >0) //<= 0)
                                                    {
                                                    if(PointOnEdge(rac->x[AOAindex1],rac->y[AOAindex1],
                                                          rah->x,rah->y,rah->x,rah->numverts,&unuseddbl,&unusedint) <= 0)
                                                       {
                                                       if(PointIsVertex(rac->x[AOAindex1],rac->y[AOAindex1],
                                                              rah->x,rah->y,rah->x,rah->numverts,&unuseddbl) <= 0)
                                                          {
                                                          break;
                                                          }
                                                       }
                                                    }
                                                 }
                                              else
                                                 {
                                                 if(PointInsideLargeAreal(rac->x[AOAindex1],rac->y[AOAindex1],
                                                      rah,&unusedint) >0) //<= 0)
                                                    {
                                                    if(PointOnLargeArealEdge(rac->x[AOAindex1],rac->y[AOAindex1],
                                                          rah,&unuseddbl,&unusedint) <= 0)
                                                       {
                                                       if(PointIsLargeArealVertex(rac->x[AOAindex1],rac->y[AOAindex1],
                                                              rah,&unuseddbl) <= 0)
                                                          {
                                                          break;
                                                          }
                                                       }
                                                    }
                                                 }

                                              }
                                           rah = rah->next;
                                           }
                                        if(rah == NULL)
                                           {
                                           xi = rac->x[AOAindex1];
                                           yi = rac->y[AOAindex1];
                                           temp = 200.0;
                                           }
                                        }
                                     }
                                  }
                               if((temp < 199) && (NearlyEqual(xi,rac->x[AOAindex1]) > 0) && (NearlyEqual(yi,rac->y[AOAindex1]) > 0))
                                  {
                                  if(PointToArealDist2D(rac->x[jj],rac->y[jj],ran) > 0.09)
                                     {
                                     if(ran->RB_Tree_Edgelist == NULL)
                                        PassCond2 = PointInAreal(rac->x[jj],rac->y[jj],ran->x,ran->y,ran->numverts, &iii);
                                     else
                                        PassCond2 = PointInsideLargeAreal(rac->x[jj],rac->y[jj],ran, &iii);
                                     if(PassCond2 > 0)
                                        {
                                        rah = root;
                                        while(rah != NULL)
                                           {
                                           if((rah != ran) && (rah->ishole > 0) && (rah->idn == ran->idn))
                                              {
                                              if(rah->RB_Tree_Edgelist == NULL)
                                                 {
                                                 if(PointIsInside(rac->x[jj],rac->y[jj],
                                                      rah->x,rah->y,rah->x,rah->numverts,C_AREA,&unuseddbl) >0) //<= 0)
                                                    {
                                                    if(PointOnEdge(rac->x[jj],rac->y[jj],
                                                          rah->x,rah->y,rah->x,rah->numverts,&unuseddbl,&unusedint) <= 0)
                                                       {
                                                       if(PointIsVertex(rac->x[jj],rac->y[jj],
                                                              rah->x,rah->y,rah->x,rah->numverts,&unuseddbl) <= 0)
                                                          {
                                                          break;
                                                          }
                                                       }
                                                    }
                                                 }
                                              else
                                                 {
                                                 if(PointInsideLargeAreal(rac->x[jj],rac->y[jj],
                                                      rah,&unusedint) >0) //<= 0)
                                                    {
                                                    if(PointOnLargeArealEdge(rac->x[jj],rac->y[jj],
                                                          rah,&unuseddbl,&unusedint) <= 0)
                                                       {
                                                       if(PointIsLargeArealVertex(rac->x[jj],rac->y[jj],
                                                              rah,&unuseddbl) <= 0)
                                                          {
                                                          break;
                                                          }
                                                       }
                                                    }
                                                 }
                                              }
                                           rah = rah->next;
                                           }
                                        if(rah == NULL)
                                           {
                                           xi = rac->x[jj];
                                           yi = rac->y[jj];
                                           temp = 200.0;
                                           }
                                        }
                                     }
                                  }
                               if((temp < 199) && (NearlyEqual(xi,ran->x[kk]) > 0) && (NearlyEqual(yi,ran->y[kk]) > 0))
                                  {
                                  if(PointToArealDist2D(ran->x[AOAindex2],ran->y[AOAindex2],rac) > 0.09)
                                     {
                                     if(rac->RB_Tree_Edgelist == NULL)
                                        PassCond2 = PointInAreal(ran->x[AOAindex2],ran->y[AOAindex2],rac->x,rac->y,rac->numverts, &iii);
                                     else
                                        PassCond2 = PointInsideLargeAreal(ran->x[AOAindex2],ran->y[AOAindex2],rac, &iii);
                                     if(PassCond2 > 0)
                                        {
                                        rah = root;
                                        while(rah != NULL)
                                           {
                                           if((rah != rac) && (rah->ishole > 0) && (rah->idn == rac->idn))
                                              {
                                              if(rah->RB_Tree_Edgelist == NULL)
                                                 {
                                                 if(PointIsInside(ran->x[AOAindex2],ran->y[AOAindex2],
                                                      rah->x,rah->y,rah->x,rah->numverts,C_AREA,&unuseddbl) >0) //<= 0)
                                                    {
                                                    if(PointOnEdge(ran->x[AOAindex2],ran->y[AOAindex2],
                                                          rah->x,rah->y,rah->x,rah->numverts,&unuseddbl,&unusedint) <= 0)
                                                       {
                                                       if(PointIsVertex(ran->x[AOAindex2],ran->y[AOAindex2],
                                                              rah->x,rah->y,rah->x,rah->numverts,&unuseddbl) <= 0)
                                                          {
                                                          break;
                                                          }
                                                       }
                                                    }
                                                 }
                                              else
                                                 {
                                                 if(PointInsideLargeAreal(ran->x[AOAindex2],ran->y[AOAindex2],
                                                      rah,&unusedint) >0) //<= 0)
                                                    {
                                                    if(PointOnLargeArealEdge(ran->x[AOAindex2],ran->y[AOAindex2],
                                                          rah,&unuseddbl,&unusedint) <= 0)
                                                       {
                                                       if(PointIsLargeArealVertex(ran->x[AOAindex2],ran->y[AOAindex2],
                                                              rah,&unuseddbl) <= 0)
                                                          {
                                                          break;
                                                          }
                                                       }
                                                    }
                                                 }
                                              }
                                           rah = rah->next;
                                           }
                                        if(rah == NULL)
                                           {
                                           xi = ran->x[AOAindex2];
                                           yi = ran->y[AOAindex2];
                                           temp = 200.0;
                                           }
                                        }
                                     }
                                  }
                               if((temp < 199) && (NearlyEqual(xi,ran->x[AOAindex2]) > 0) && (NearlyEqual(yi,ran->y[AOAindex2]) > 0))
                                  {
                                  if(PointToArealDist2D(ran->x[kk],ran->y[kk],rac) > 0.09)
                                     {
                                     if(rac->RB_Tree_Edgelist == NULL)
                                        PassCond2 = PointInAreal(ran->x[kk],ran->y[kk],rac->x,rac->y,rac->numverts, &iii);
                                     else
                                        PassCond2 = PointInsideLargeAreal(ran->x[kk],ran->y[kk],rac, &iii);
                                     if(PassCond2 > 0)
                                        {
                                        rah = root;
                                        while(rah != NULL)
                                           {
                                           if((rah != rac) && (rah->ishole > 0) && (rah->idn == rac->idn))
                                              {
                                              if(rah->RB_Tree_Edgelist == NULL)
                                                 {
                                                 if(PointIsInside(ran->x[kk],ran->y[kk],
                                                      rah->x,rah->y,rah->x,rah->numverts,C_AREA,&unuseddbl) >0) //<= 0)
                                                    {
                                                    if(PointOnEdge(ran->x[kk],ran->y[kk],
                                                          rah->x,rah->y,rah->x,rah->numverts,&unuseddbl,&unusedint) <= 0)
                                                       {
                                                       if(PointIsVertex(ran->x[kk],ran->y[kk],
                                                              rah->x,rah->y,rah->x,rah->numverts,&unuseddbl) <= 0)
                                                          {
                                                          break;
                                                          }
                                                       }
                                                    }
                                                 }
                                              else
                                                 {
                                                 if(PointInsideLargeAreal(ran->x[kk],ran->y[kk],
                                                      rah,&unusedint) >0) //<= 0)
                                                    {
                                                    if(PointOnLargeArealEdge(ran->x[kk],ran->y[kk],
                                                          rah,&unuseddbl,&unusedint) <= 0)
                                                       {
                                                       if(PointIsLargeArealVertex(ran->x[kk],ran->y[kk],
                                                              rah,&unuseddbl) <= 0)
                                                          {
                                                          break;
                                                          }
                                                       }
                                                    }
                                                 }
                                              }
                                           rah = rah->next;
                                           }
                                        if(rah == NULL)
                                           {
                                           xi = ran->x[kk];
                                           yi = ran->y[kk];
                                           temp = 200.0;
                                           }
                                        }
                                     }
                                  }

if(temp < 199)
   {
   if(EqualWithinTolerance(xi,yi,  ran->x[AOAindex2], ran->y[AOAindex2],  0.000001) > 0)
      {
      if(EqualWithinTolerance(rac->x[AOAindex1],rac->y[AOAindex1],
                 ran->x[AOAindex2], ran->y[AOAindex2],  0.000001) > 0)
         {
         /*** then this intersection is at a connecting node **/
         if(TwoPointsOnSameSideOfLineSegment(rac->x[jj],rac->y[jj],rac->x[AOAnext1],rac->y[AOAnext1],
                          ran->x[kk],ran->y[kk],ran->x[AOAindex2],ran->y[AOAindex2]) == 0)
            {
            if(TwoPointsOnSameSideOfLineSegment(rac->x[jj],rac->y[jj],rac->x[AOAnext1],rac->y[AOAnext1],
                          ran->x[AOAindex2],ran->y[AOAindex2],ran->x[AOAnext2],ran->y[AOAnext2]) == 0)
               {
               if(TwoPointsOnSameSideOfLineSegment(ran->x[kk],ran->y[kk],ran->x[AOAnext2],ran->y[AOAnext2],
                          rac->x[jj],rac->y[jj],rac->x[AOAindex1],rac->y[AOAindex1]) == 0)
                  {
                  if(TwoPointsOnSameSideOfLineSegment(ran->x[kk],ran->y[kk],ran->x[AOAnext2],ran->y[AOAnext2],
                          rac->x[AOAindex1],rac->y[AOAindex1],rac->x[AOAnext1],rac->y[AOAnext1]) == 0)
                     {
            /** then check to see that there are no colinear segments involved - seems less work to check for == nodes, and that is the
                expected case, before checking for point on interior of the segments  ***/
                     if((EqualWithinTolerance(rac->x[jj],rac->y[jj], ran->x[AOAindex2], ran->y[AOAindex2],  Tolerance) == 0) &&
                            (EqualWithinTolerance(rac->x[jj],rac->y[jj], ran->x[kk], ran->y[kk],  Tolerance) == 0) &&
                            (EqualWithinTolerance(rac->x[AOAnext1],rac->y[AOAnext1], ran->x[AOAindex2], ran->y[AOAindex2],  Tolerance) == 0) && 
                               (EqualWithinTolerance(rac->x[AOAnext1],rac->y[AOAnext1], ran->x[kk], ran->y[kk],  Tolerance) == 0))
                        {
                        if((PointToLineDist2D(rac->x[jj],rac->y[jj],ran->x[kk],ran->y[kk],ran->x[AOAindex2],ran->y[AOAindex2]) > 0.01) &&
                            (PointToLineDist2D(rac->x[jj],rac->y[jj],ran->x[AOAindex2],ran->y[AOAindex2],ran->x[AOAnext2],ran->y[AOAnext2]) > 0.01) &&
                            (PointToLineDist2D(rac->x[AOAnext1],rac->y[AOAnext1],ran->x[kk],ran->y[kk],ran->x[AOAindex2],ran->y[AOAindex2]) > 0.01) &&
                            (PointToLineDist2D(rac->x[AOAnext1],rac->y[AOAnext1],ran->x[AOAindex2],ran->y[AOAindex2],ran->x[AOAnext2],ran->y[AOAnext2]) > 0.01))
                           {
                           if((PointToLineDist2D(ran->x[kk],ran->y[kk],rac->x[jj],rac->y[jj],rac->x[AOAindex1],rac->y[AOAindex1]) > 0.01) &&
                             (PointToLineDist2D(ran->x[kk],ran->y[kk],rac->x[AOAindex1],rac->y[AOAindex1],rac->x[AOAnext1],rac->y[AOAnext1]) > 0.01) &&
                             (PointToLineDist2D(ran->x[AOAnext2],ran->y[AOAnext2],rac->x[jj],rac->y[jj],rac->x[AOAindex1],rac->y[AOAindex1]) > 0.01) &&
                             (PointToLineDist2D(ran->x[AOAnext2],ran->y[AOAnext2],rac->x[AOAindex1],rac->y[AOAindex1],rac->x[AOAnext1],rac->y[AOAnext1]) > 0.01))
                              {
                       /** then these lines (extended through connecting node) do intersect and areas must share face ***/
                                        rah = root;
                                        while(rah != NULL)
                                           {
                                           if((rah != ran) && (rah->ishole > 0) && (rah->idn == ran->idn))
                                              {
                                              if(rah->RB_Tree_Edgelist == NULL)
                                                 {
                                                 if(PointIsInside(rac->x[AOAnext1],rac->y[AOAnext1],
                                                      rah->x,rah->y,rah->x,rah->numverts,C_AREA,&unuseddbl) > 0) //<= 0)
                                                    {
                                                    if(PointOnEdge(rac->x[AOAnext1],rac->y[AOAnext1],
                                                          rah->x,rah->y,rah->x,rah->numverts,&unuseddbl,&unusedint) <= 0)
                                                       {
                                                       if(PointIsVertex(rac->x[AOAnext1],rac->y[AOAnext1],
                                                              rah->x,rah->y,rah->x,rah->numverts,&unuseddbl) <= 0)
                                                          {
                                                          break;
                                                          }
                                                       }
                                                    }
                                                 }
                                              else
                                                 {
                                                 if(PointInsideLargeAreal(rac->x[AOAnext1],rac->y[AOAnext1],
                                                      rah,&unusedint) > 0) //<= 0)
                                                    {
                                                    if(PointOnLargeArealEdge(rac->x[AOAnext1],rac->y[AOAnext1],
                                                          rah,&unuseddbl,&unusedint) <= 0)
                                                       {
                                                       if(PointIsLargeArealVertex(rac->x[AOAnext1],rac->y[AOAnext1],
                                                              rah,&unuseddbl) <= 0)
                                                          {
                                                          break;
                                                          }
                                                       }
                                                    }
                                                 }
                                              }
                                           rah = rah->next;
                                           }
                                        if(rah == NULL)
                                           {
                                           temp = 200.0;
                                           }
                              }
                           }
                        }
                     }
                  }

               }
            }
         }
      }
   }

                               if(temp < 199)
                                  {
                                  if((AOAnext1 >= 0) && (PointToArealDist2D(rac->x[AOAnext1],rac->y[AOAnext1],ran) > 0.09))
                                     {
                                     if(ran->RB_Tree_Edgelist == NULL)
                                        PassCond2 = PointInAreal(rac->x[AOAnext1],rac->y[AOAnext1],ran->x,ran->y,ran->numverts, &iii);
                                     else
                                        PassCond2 = PointInsideLargeAreal(rac->x[AOAnext1],rac->y[AOAnext1],ran, &iii);
                                     if(PassCond2 > 0)
                                        {
                                        rah = root;
                                        while(rah != NULL)
                                           {
                                           if((rah != ran) && (rah->ishole > 0) && (rah->idn == ran->idn))
                                              {
                                              if(rah->RB_Tree_Edgelist == NULL)
                                                 {
                                                 if(PointIsInside(rac->x[AOAnext1],rac->y[AOAnext1],
                                                      rah->x,rah->y,rah->x,rah->numverts,C_AREA,&unuseddbl) >0) //<= 0)
                                                    {
                                                    if(PointOnEdge(rac->x[AOAnext1],rac->y[AOAnext1],
                                                          rah->x,rah->y,rah->x,rah->numverts,&unuseddbl,&unusedint) <= 0)
                                                       {
                                                       if(PointIsVertex(rac->x[AOAnext1],rac->y[AOAnext1],
                                                              rah->x,rah->y,rah->x,rah->numverts,&unuseddbl) <= 0)
                                                          {
                                                          break;
                                                          }
                                                       }
                                                    }
                                                 }
                                              else
                                                 {
                                                 if(PointInsideLargeAreal(rac->x[AOAnext1],rac->y[AOAnext1],
                                                      rah,&unusedint) >0) //<= 0)
                                                    {
                                                    if(PointOnLargeArealEdge(rac->x[AOAnext1],rac->y[AOAnext1],
                                                          rah,&unuseddbl,&unusedint) <= 0)
                                                       {
                                                       if(PointIsLargeArealVertex(rac->x[AOAnext1],rac->y[AOAnext1],
                                                              rah,&unuseddbl) <= 0)
                                                          {
                                                          break;
                                                          }
                                                       }
                                                    }
                                                 }
                                              }
                                           rah = rah->next;
                                           }
                                        if(rah == NULL)
                                           {
                                           temp = 200.0;
                                           xi = rac->x[AOAnext1];
                                           yi = rac->y[AOAnext1];
                                           }
                                        }
                                     }


                                  if(temp < 199)
                                     {
                                     if((AOAnext2 >= 0) && (PointToArealDist2D(ran->x[AOAnext2],ran->y[AOAnext2],rac) > 0.09))
                                        {
                                        if(rac->RB_Tree_Edgelist == NULL)
                                           PassCond2 = PointInAreal(ran->x[AOAnext2],ran->y[AOAnext2],rac->x,rac->y,rac->numverts, &iii);
                                        else
                                           PassCond2 = PointInsideLargeAreal(ran->x[AOAnext2],ran->y[AOAnext2],rac, &iii);
                                        if(PassCond2 > 0)
                                           {
                                           rah = root;
                                           while(rah != NULL)
                                              {
                                              if((rah != rac) && (rah->ishole > 0) && (rah->idn == rac->idn))
                                                 {
                                                 if(rah->RB_Tree_Edgelist == NULL)
                                                    {
                                                    if(PointIsInside(ran->x[AOAnext2],ran->y[AOAnext2],
                                                         rah->x,rah->y,rah->x,rah->numverts,C_AREA,&unuseddbl) >0) //<= 0)
                                                       {
                                                       if(PointOnEdge(ran->x[AOAnext2],ran->y[AOAnext2],
                                                             rah->x,rah->y,rah->x,rah->numverts,&unuseddbl,&unusedint) <= 0)
                                                          {
                                                          if(PointIsVertex(ran->x[AOAnext2],ran->y[AOAnext2],
                                                                 rah->x,rah->y,rah->x,rah->numverts,&unuseddbl) <= 0)
                                                             {
                                                             break;
                                                             }
                                                          }
                                                       }
                                                    }
                                                 else
                                                    {
                                                    if(PointInsideLargeAreal(ran->x[AOAnext2],ran->y[AOAnext2],
                                                         rah,&unusedint) >0) //<= 0)
                                                       {
                                                       if(PointOnLargeArealEdge(ran->x[AOAnext2],ran->y[AOAnext2],
                                                             rah,&unuseddbl,&unusedint) <= 0)
                                                          {
                                                          if(PointIsLargeArealVertex(ran->x[AOAnext2],ran->y[AOAnext2],
                                                                 rah,&unuseddbl) <= 0)
                                                                {
                                                             break;
                                                             }
                                                          }
                                                       }
                                                    }
                                                 }
                                              rah = rah->next;
                                              }
                                           if(rah == NULL)
                                              {
                                              temp = 200.0;
                                              xi = ran->x[AOAnext2];
                                              yi = ran->y[AOAnext2];
                                              }
                                           }
                                        }
                                     }



                                  }

                               }
                            }
                         else
                            temp = 0.000001;
                         }


                   if(temp > 0.0001)
                      {
                      ra_3part = root;
                      while(ra_3part != NULL)
                         {
                         if((ra_3part != rac) && (ra_3part != ran) && (ra_3part->ishole <= 0))
                            {
                            if((CombinedCheckApplies(ra_3part->idn,checkinstance,AOVERLAPA,ra_3part->Lindex,ra_3part->Sindex,
                                   SCCtable[ra_3part->Sindex].C, SCCtable[ra_3part->Sindex].S,SCCtable[ra_3part->Sindex].D,
                                    &part1,&part2,&part3) > 0) && 
                                   (part3 > 0))
                               {
                               unusedint = 0;
                               if(ra_3part->RB_Tree_Edgelist == NULL)
                                  {
                                  unusedint = PointIsVertex(xi, yi, ra_3part->x,ra_3part->y,ra_3part->x,ra_3part->numverts, &unuseddbl);
                                  if(unusedint == 0)
                                     unusedint = PointOnEdge(xi, yi, ra_3part->x,ra_3part->y,ra_3part->x,ra_3part->numverts, &unuseddbl, &iii);
                                  if(unusedint == 0)
                                     unusedint = PointInAreal(xi, yi, ra_3part->x,ra_3part->y,ra_3part->numverts, &iii);
                                  }
                               else
                                  {
                                  unusedint = PointIsLargeArealVertex(xi, yi,ra_3part, &unuseddbl);
                                  if(unusedint == 0)
                                     unusedint = PointOnLargeArealEdge(xi, yi,ra_3part, &unuseddbl, &iii);
                                  if(unuseddbl == 0)
                                     unusedint = PointInsideLargeAreal(xi, yi, ra_3part, &iii);
                                  }
                               if(unusedint > 0)
                                  break;
                               }
                            }
                         ra_3part = ra_3part->next;
                         }
                      if(ra_3part != NULL)
                         temp = 0.0;
                      }

if(temp > 0.0001)
   {
   if((ActiveChecks[checkinstance].participants >= 3) && (ActiveChecks[checkinstance].sensitivity6 > 0))
      {
      if((xi < minx) || (xi > maxx) || (yi < miny) || (yi > maxy))
         {
         RemoveCheckedAreaPair(checkinstance,rac->localID,ran->localID,rac->area,ran->area);
         temp = 0;
         }
      }
   }
                      if(temp > 0.0001)
                         {
                         ERc = (struct collection *) (malloc(SzC));
                         if(ERc == NULL)
                            {
                            printf("allocation memory exhausted during linear feature condition analysis\n");
                            printf("processing cannot continue\n");
                            exit(-1);
                            }
                         ERc->magnitude = 0.0;
                         ERc->keyval = AOVERLAPA;
                         ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                         if((BasedOnPoint > 0) || (BasedOnEdges > 0))
                            {
                            ERc->vertexindex1 = -1;
                            ERc->vertexindex2 = -1;
                            BasedOnPoint = 0;
                            BasedOnEdges = 0;
                            }
                         else
                            {
                            if(Part1Save > 0)
                               {
                               ERc->vertexindex1 = AOAindex1;
                               ERc->vertexindex2 = AOAindex2;
                               }
                            else
                               {
                               ERc->vertexindex2 = AOAindex1;
                               ERc->vertexindex1 = AOAindex2;
                               }
                            }
                         ERc->x[0] = xi;
                         ERc->y[0] = yi;
                         ERc->z[0] = rac->z[0];
                         if(Part1Save > 0)
                            {
                            ERc->Sindex1 = rac->Sindex;
                            ERc->Sindex2 = ran->Sindex;
                            ERc->aa = rac;
                            ERc->aa2 = ran;
                            ERc->numverts1 = rac->numverts;
                            ERc->numverts2 = ran->numverts;
                            }
                         else
                            {
                            ERc->Sindex1 = ran->Sindex;
                            ERc->Sindex2 = rac->Sindex;
                            ERc->aa = ran;
                            ERc->aa2 = rac;
                            ERc->numverts1 = ran->numverts;
                            ERc->numverts2 = rac->numverts;
                            }
                         ERc->next = NULL;
                         if(ERroot == NULL)
                            {
                            ERroot = ERc;
                            }
                         else
                            {
                            ERn = ERroot;
                            while(ERn != NULL)
                               {
                               if((ERn->Cnumber == ERc->Cnumber) && (ERn->keyval == ERc->keyval)) 
                                  {
                                  if((ERn->aa == ERc->aa) && (ERn->aa2 == ERc->aa2))
                                     break;
                                  else if((ERn->aa == ERc->aa2) && (ERn->aa2 == ERc->aa))
                                     break;
                                  }
                               ERn = ERn->next;
                               }
                            if(ERn == NULL)
                               {
                               ERc->next = ERroot;
                               ERroot = ERc;
                               }
                            else
                               {
                               free(ERc);
                               }
                            }
                         }
                      } /** end if PassCond2 so generate a condition ***/
                  }
               ran = ran->next;
               }
            }  /*** end AOVERLAPA check ***/





         if((rac->ishole <= 0) && (CombinedCheckApplies(rac->idn,checkinstance,PSHAREFAIL,rac->Lindex,rac->Sindex,
                Config1,Strat1,Domain1, &part1,&part2,&part3) > 0) &&
              (part1 > 0))
            {
            PassCond = 0;
            ran = root;
            while(ran != NULL)
               {
               if(ran != rac)
                  {
                  if((CombinedCheckApplies(ran->idn,checkinstance,PSHAREFAIL,ran->Lindex,ran->Sindex,SCCtable[ran->Sindex].C,
                          SCCtable[ran->Sindex].S,SCCtable[ran->Sindex].D,&part1,&part2,&part3) > 0) &&
                      (part2 > 0))
                     {
                     chktolerance = FindRelevantSensitivity(PSHAREFAIL,checkinstance,&unuseddbl);
                     PassCond = TwoArealsShareEdge(rac, ran, &savei, &savej, chktolerance);
                     }
                  if((PassCond == 0) &&  (ran->ishole <= 0) &&
                    (CombinedCheckApplies(ran->idn,checkinstance,PSHAREFAIL,ran->Lindex,ran->Sindex,SCCtable[ran->Sindex].C,
                          SCCtable[ran->Sindex].S,SCCtable[ran->Sindex].D,&part1,&part2,&part3) > 0) &&
                      (part3 > 0))  /** if they don't share an edge, is it a wedding cake? ***/
                     {
                     if((rac->area < ran->area) &&
                         (AreaInsideArea(rac,ran,&xt3,&yt3) > 1)) /** says all points are inside if >1, some points are inside if > 0 **/
                        {
                        rah = root;
                        while(rah != NULL)
                           {
                           if((rah != ran) && (rah->ishole > 0) && (rah->idn == ran->idn))
                              {
                              if(AreaInsideArea(rac,rah,&xt3,&yt3) > 0)
                                 break;
                              }
                           rah = rah->next;
                           }
                        if(rah == NULL)
                           PassCond = 1;
                        }
                     }
                  } /** end rac != ran ***/
               if(PassCond > 0)
                  break;  /** found 2 that share edge or are stacked on each other, so can stop now ***/

               ran = ran->next;
               } /*** end while ran ***/

            if((PassCond == 0) && (ActiveChecks[checkinstance].UseBorderConds == 0)) /** do we need to remove condition on project boundary? ***/
               {
               checkit2 = 1;
               RB_newKey2 = rac->localID + (checkinstance * 0.0001);
               if(( RB_newNode = RBExactQuery(Check_RB_Tree,&RB_newKey2))) /** if it is already in the tree, maybe don't need to do this again ***/
                  {
                  RB_cond = (struct ConditionCollection *) RB_newNode->info;
                  if(RB_cond->counter > 0)
                     checkit2 = 0;
                  }
               if(checkit2 > 0)
                  {
                  checkit = 1;
                  if((NorthCount <= 0) || (SouthCount <= 0) || (EastCount <= 0) || (WestCount <= 0))
                     {
                     maxXindex = minXindex = maxYindex = minYindex = 0;
                     for(i=1; i<rac->numverts; i++)
                        {
                        if(rac->x[i] > rac->x[maxXindex])
                           maxXindex = i;
                        if(rac->x[i] < rac->x[minXindex])
                           minXindex = i;
                        if(rac->y[i] > rac->y[maxYindex])
                           maxYindex = i;
                        if(rac->y[i] < rac->y[minYindex])
                           minYindex = i;
                        }
                     if(EastCount <= 0)
                        {
                        if(maxXindex == 0)
                           {
                           i = 1;
                           j = rac->numverts - 1;
                           }
                        else
                           {
                           i = maxXindex - 1;
                           j = i + 1;
                           if(j >= rac->numverts)
                              j = 0;
                           }
                        checkit = ConditionOnDataEdge(rac->x[i],rac->y[i],rac->x[maxXindex],rac->y[maxXindex],root,Proot,Lroot,
                                              rac, NULL, NULL,100,100,EastCount,100,checkinstance);
                        if(checkit > 0)
                           checkit = ConditionOnDataEdge(rac->x[j],rac->y[j],rac->x[maxXindex],rac->y[maxXindex],root,Proot,Lroot,
                                              rac, NULL, NULL,100,100,EastCount,100,checkinstance);
                        }
                     if((checkit > 0) && (WestCount <= 0))
                        {
                        if(minXindex == 0)
                           {
                           i = 1;
                           j = rac->numverts - 1;
                           }
                        else
                           {
                           i = minXindex - 1;
                           j = i + 1;
                           if(j >= rac->numverts)
                              j = 0;
                           }
                        checkit = ConditionOnDataEdge(rac->x[i],rac->y[i],rac->x[minXindex],rac->y[minXindex],root,Proot,Lroot,
                                              rac, NULL, NULL,100,100,100,WestCount,checkinstance);
                        if(checkit > 0)
                           checkit = ConditionOnDataEdge(rac->x[j],rac->y[j],rac->x[minXindex],rac->y[minXindex],root,Proot,Lroot,
                                              rac, NULL, NULL,100,100,100,WestCount,checkinstance);
                        }

                     if((checkit > 0) && (SouthCount <= 0))
                        {
                        if(minYindex == 0)
                           {
                           i = 1;
                           j = rac->numverts - 1;
                           }
                        else
                           {
                           i = minYindex - 1;
                           j = i + 1;
                           if(j >= rac->numverts)
                              j = 0;
                           }
                        checkit = ConditionOnDataEdge(rac->x[i],rac->y[i],rac->x[minYindex],rac->y[minYindex],root,Proot,Lroot,
                                              rac, NULL, NULL,100,SouthCount,100,100,checkinstance);
                        if(checkit > 0)
                           checkit = ConditionOnDataEdge(rac->x[j],rac->y[j],rac->x[minYindex],rac->y[minYindex],root,Proot,Lroot,
                                              rac, NULL, NULL,100,SouthCount,100,100,checkinstance);
                        }

                     if((checkit > 0) && (NorthCount <= 0))
                        {
                        if(maxYindex == 0)
                           {
                           i = 1;
                           j = rac->numverts - 1;
                           }
                        else
                           {
                           i = maxYindex - 1;
                           j = i + 1;
                           if(j >= rac->numverts)
                              j = 0;
                           }
                        checkit = ConditionOnDataEdge(rac->x[i],rac->y[i],rac->x[maxYindex],rac->y[maxYindex],root,Proot,Lroot,
                                              rac, NULL, NULL,NorthCount,100,100,100,checkinstance);
                        if(checkit > 0)
                           checkit = ConditionOnDataEdge(rac->x[j],rac->y[j],rac->x[maxYindex],rac->y[maxYindex],root,Proot,Lroot,
                                              rac, NULL, NULL,NorthCount,100,100,100,checkinstance);                        }
                     }
                  if(checkit <= 0)
                     PassCond = 1;
                  }
               }


               RB_newKey2 = rac->idn + (checkinstance * 0.0001); 
               if(( RB_newNode = RBExactQuery(Check_RB_Tree,&RB_newKey2)))
                  {
                  RB_cond = (struct ConditionCollection *) RB_newNode->info;
                  RB_cond->counter += PassCond;
                  }
               else
                  {
                  RB_cond = (struct ConditionCollection *) (malloc(SzCC));
                  if(RB_cond == NULL)
                     {
                     printf("memory has been exhausted during RB-Tree information alloction for PSHAREFAIL analysis\n");
                     exit(-1);
                     }
                  RB_cond->keyval = PSHAREFAIL;
                  RB_cond->index_from_to = NULL;
                  RB_cond->Cnumber =  Make_Correct(PSHAREFAIL,checkinstance);
                  RB_cond->index_from_to = NULL;
                  RB_cond->gform = G_AREAL;
                  RB_cond->featureidn = rac->featureid;
                  RB_cond->localID = rac->localID;
                  RB_cond->counter = PassCond;
                  RB_cond->radius = -1;
                  RB_cond->height = -1;
                  RB_cond->magnitude = 0.0;
                  RB_cond->IDN = rac->idn;
                  RB_cond->Sindex = rac->Sindex;
                  RB_cond->Lindex = rac->Lindex;

                  RB_cond->numnodes = rac->numverts;
                  RB_cond->x = (double *) (malloc(RB_cond->numnodes * SzD));
                  RB_cond->y = (double *) (malloc(RB_cond->numnodes * SzD));
                  RB_cond->z = (double *) (malloc(RB_cond->numnodes * SzD));
                  if(RB_cond->z == NULL)
                     {
                     printf("memory has been exhausted during RB-Tree element vertex alloction for PSHAREFAIL analysis\n");
                     exit(-1);
                     }
                  for(jj=0; jj< rac->numverts; jj++)
                     {
                     RB_cond->x[jj] = rac->x[jj];
                     RB_cond->y[jj] = rac->y[jj];
                     RB_cond->z[jj] = rac->z[jj];
                     }

                  RB_newDbl = (double *) (malloc(SzD));
                  if(RB_newDbl == NULL)
                     {
                     printf("memory has been exhausted during RB-Tree alloction for PSHAREFAIL analysis\n");
                     exit(-1);
                     }
                  *RB_newDbl = RB_newKey2; /**rac->localID; **/
                  RBTreeInsert(Check_RB_Tree,RB_newDbl, RB_cond);
                  } /*** end add a new tree node ***/
            } /** end PSHAREFAIL check applies to rac ***/




         if((rac->ishole <= 0) && (CombinedCheckApplies(rac->idn,checkinstance,NOCOINCIDE,rac->Lindex,rac->Sindex,
                Config1,Strat1,Domain1, &part1,&part2,&part3) > 0) &&
              (part1 > 0))
            {
            PassCond = 0;
            rlc = Lroot;
            chktolerance = FindRelevantSensitivity(NOCOINCIDE,checkinstance,&unuseddbl); 
            while(rlc != NULL)
               {
               if((CombinedCheckApplies(rlc->idn,checkinstance,NOCOINCIDE,rlc->Lindex,rlc->Sindex,SCCtable[rlc->Sindex].C,
                          SCCtable[rlc->Sindex].S,SCCtable[rlc->Sindex].D,&part1,&part2,&part3) > 0) &&
                      (part2 > 0))
                  {
                  PassCond = AreaAndLineShareEdgeOrLineEndNode(rac, rlc, chktolerance);
                  }
               if(PassCond > 0)
                  break;  /** found 2 that shared edge, so can stop now ***/

               rlc = rlc->next;
               } /*** end while ran ***/
            if(rac->ismulti == 0) /** then have checked all possible edge sharing episodes ***/
               {
               if(PassCond == 0) /*** could not match any edge of rac ***/
                  {
                  ERc = (struct collection *) (malloc(SzC));
                  if(ERc == NULL)
                     {
                     printf("allocation memory exhausted during area feature condition analysis\n");
                     printf("processing cannot continue\n");
                     exit(-1);
                     }
                  ERc->magnitude = 0;
                  ERc->keyval = NOCOINCIDE;
                  ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                  ERc->Sindex1 = rac->Sindex;
                  ERc->aa = rac;
                  ERc->next = NULL;
                  if(ERroot == NULL)
                     {
                     ERroot = ERc;
                     }
                  else
                     {
                     ERn = ERroot;
                     while(ERn != NULL)
                        {
                        if(
                           (ERn->Cnumber    == ERc->Cnumber)    &&
                           (ERn->keyval    == ERc->keyval)    &&
                           (ERn->aa == ERc->aa)
                           )
                           break;
                        ERn = ERn->next;
                        }
                     if(ERn == NULL)
                        {
                        ERc->next = ERroot;
                        ERroot = ERc;
                        }
                     else
                        free(ERc);
                     }
                  }
               }
            else /*** must be a multi-region area feature ***/
               {
               RB_newKey2 = rac->localID + (checkinstance * 0.0001);
               if(( RB_newNode = RBExactQuery(Check_RB_Tree,&RB_newKey2)))
                  {
                  RB_cond = (struct ConditionCollection *) RB_newNode->info;
                  RB_cond->counter += PassCond;
                  }
               else
                  {
                  RB_cond = (struct ConditionCollection *) (malloc(SzCC));
                  if(RB_cond == NULL)
                     {
                     printf("memory has been exhausted during RB-Tree information alloction for NOCOINCIDE analysis\n");
                     exit(-1);
                     }
                  RB_cond->keyval = NOCOINCIDE;
                  RB_cond->index_from_to = NULL;
                  RB_cond->Cnumber =  Make_Correct(NOCOINCIDE,checkinstance);
                  RB_cond->index_from_to = NULL;
                  RB_cond->gform = G_AREAL;
                  RB_cond->featureidn = rac->featureid;
                  RB_cond->localID = rac->localID;
                  RB_cond->counter = PassCond;
                  RB_cond->radius = -1;
                  RB_cond->height = -1;
                  RB_cond->magnitude = 0.0;
                  RB_cond->IDN = rac->idn;
                  RB_cond->Sindex = rac->Sindex;
                  RB_cond->Lindex = rac->Lindex;

                  RB_cond->numnodes = rac->numverts;
                  RB_cond->x = (double *) (malloc(RB_cond->numnodes * SzD));
                  RB_cond->y = (double *) (malloc(RB_cond->numnodes * SzD));
                  RB_cond->z = (double *) (malloc(RB_cond->numnodes * SzD));
                  if(RB_cond->z == NULL)
                     {
                     printf("memory has been exhausted during RB-Tree element vertex alloction for NOCOINCIDE analysis\n");
                     exit(-1);
                     }
                  for(jj=0; jj< rac->numverts; jj++)
                     {
                     RB_cond->x[jj] = rac->x[jj];
                     RB_cond->y[jj] = rac->y[jj];
                     RB_cond->z[jj] = rac->z[jj];
                     }

                  RB_newDbl = (double *) (malloc(SzD));
                  if(RB_newDbl == NULL)
                     {
                     printf("memory has been exhausted during RB-Tree alloction for NOCOINCIDE analysis\n");
                     exit(-1);
                     }
                  *RB_newDbl = RB_newKey2; /**rac->localID; **/
                  RBTreeInsert(Check_RB_Tree,RB_newDbl, RB_cond);
                  } /*** end add a new tree node ***/
               } /*** end multi-region process ***/
            } /** end NOCOINCIDE check applies to rac ***/





         if((rac->ishole <= 0) &&     /*****(rac->firstindex == cindex) && ****/
              (CombinedCheckApplies(rac->idn,checkinstance,OBJECTWITHOUT,rac->Lindex,rac->Sindex,
                Config1,Strat1,Domain1, &part1,&part2,&part3) > 0) &&
              (part1 > 0))
            {
            foundobject = 0;
            jj2 = rac->numverts - 1;
            foundobject = 0;
            for(j = 0; j < rac->numverts; j++)
               {
               checkit = ConditionOnDataEdge(rac->x[j],rac->y[j],rac->x[jj2],rac->y[jj2],root,Proot,Lroot,
                             rac, NULL, NULL,
                             NorthCount,SouthCount,EastCount,WestCount,checkinstance);
               if(checkit == 0)
                  {
                  foundobject = 1;
                  break;
                  }
               jj2 = j;
               }
            
            rlc = Lroot;
            while((foundobject == 0) && (rlc != NULL))
               {
               if((CombinedCheckApplies(rlc->idn,checkinstance,OBJECTWITHOUT, 
                         rlc->Lindex,rlc->Sindex,SCCtable[rlc->Sindex].C,SCCtable[rlc->Sindex].S,SCCtable[rlc->Sindex].D,
                   &part1,&part2,&part3) > 0) && (part2 > 0))
                  {
                  for(j=0; j<rlc->numnodes; j++)
                     {
                     unusedint = 0;
                     if(rac->RB_Tree_Edgelist == NULL)
                        {
                        unusedint = PointIsVertex(rlc->x[j],rlc->y[j],rac->x,rac->y,rac->z,rac->numverts,&unuseddbl);
                        if(unusedint == 0)
                           unusedint = PointOnEdge(rlc->x[j],rlc->y[j],rac->x,rac->y,rac->z,rac->numverts,&unuseddbl,&iii);
                        if(unusedint == 0)
                           unusedint = PointIsInside(rlc->x[j],rlc->y[j],rac->x,rac->y,rac->z,rac->numverts,
                                     (unsigned char) Config1,&unuseddbl);
                        }
                     else
                        {
                        unusedint = PointIsLargeArealVertex(rlc->x[j],rlc->y[j],rac,&unuseddbl);
                        if(unusedint == 0)
                           unusedint = PointOnLargeArealEdge(rlc->x[j],rlc->y[j],rac,&unuseddbl, &iii);
                        if(unusedint == 0)
                           unusedint = PointInsideLargeAreal(rlc->x[j], rlc->y[j], rac, &iii);
                        }
                     if(unusedint > 0)
                        {
                        rah = root;
                        PassCond = 0;
                        while(rah != NULL)
                           {
                           if((rah != rac) && (rah->ishole > 0) && (rah->idn == rac->idn))
                              {
                              if(rah->RB_Tree_Edgelist == NULL)
                                 {
                                 if((PointIsVertex(rlc->x[j],rlc->y[j],rah->x,rah->y,rah->z,rah->numverts,&unuseddbl) == 0) &&
                                   (PointOnEdge(rlc->x[j],rlc->y[j],rah->x,rah->y,rah->z,rah->numverts,&unuseddbl,&iii) == 0))
                                    PassCond = PointInAreal(rlc->x[j], rlc->y[j], rah->x,rah->y,rah->numverts, &iii);
                                 }
                              else
                                 {
                                 if((PointIsLargeArealVertex(rlc->x[j],rlc->y[j],rah,&unuseddbl) == 0) &&
                                        (PointOnLargeArealEdge(rlc->x[j],rlc->y[j],rah,&unuseddbl, &iii) == 0))
                                    PassCond = PointInsideLargeAreal(rlc->x[j], rlc->y[j], rah, &iii);
                                 }
                              }
                           if(PassCond > 0)
                              break;
                           rah = rah->next;
                           }
                        if(PassCond == 0)
                           {
                           foundobject = 1;
                           break;
                           }
                        }
                     }

                  if((rlc->numnodes > 1) && (foundobject == 0))
                     {
                     for(j=1; j<rlc->numnodes; j++)
                        {
                        for(i=0; i<rac->numverts; i++)
                           {
                           k = (i + 1) % rac->numverts;
                           if(LineSegmentsIntersect(rlc->x[j-1],rlc->y[j-1],rlc->x[j],rlc->y[j],rac->x[i],rac->y[i],rac->x[k],rac->y[k],
                                    &xint, &yint) > 0)
                              {
                              foundobject = 1;
                              break;
                              }
                           }
                        if(foundobject > 0)
                           break;
                        }
                     if(foundobject == 0)
                        {
                        rah = root;
                        while(rah != NULL)
                           {
                           if((rah != rac) && (rah->ishole > 0) && (rah->idn == rac->idn))
                              {
                              for(j=1; j<rlc->numnodes; j++)
                                 {
                                 for(i=0; i<rah->numverts; i++)
                                    {
                                    if(i == 0)
                                       k = rah->numverts - 1;
                                    else
                                       k = i - 1;
                                    if(LineSegmentsIntersect(rlc->x[j-1],rlc->y[j-1],rlc->x[j],rlc->y[j],
                                         rah->x[i],rah->y[i],rah->x[k],rah->y[k], &xint, &yint) > 0)
                                       {
                                       foundobject = 1;
                                       break;
                                       }
                                    }
                                 }
                              }
                           rah = rah->next;
                           }
                        }
                     }
                  }
               if(foundobject > 0)
                  break;
               rlc = rlc->next;
               }
            if(foundobject == 0) /** see if any point objects satisfy criteria **/
               {
               rpc = Proot;
               while(rpc != NULL)
                  {
                  if((rpc->numverts < 1) && (rpc->numverts > -3) &&
                      (CombinedCheckApplies(rpc->idn,checkinstance,OBJECTWITHOUT,
                             rpc->Lindex,rpc->Sindex,SCCtable[rpc->Sindex].C,SCCtable[rpc->Sindex].S,SCCtable[rpc->Sindex].D,
                      &part1,&part2,&part3) > 0) && (part2 > 0))
                     {
                     unusedint = 0;
                     if(rac->RB_Tree_Edgelist == NULL)
                        {
                        unusedint = PointIsVertex(rpc->x[0],rpc->y[0],rac->x,rac->y,rac->z,rac->numverts,&unuseddbl);
                        if(unusedint == 0)
                           unusedint = PointOnEdge(rpc->x[0],rpc->y[0],rac->x,rac->y,rac->z,rac->numverts,&unuseddbl,&iii);
                        if(unusedint == 0)
                           unusedint = PointIsInside(rpc->x[0],rpc->y[0],rac->x,rac->y,rac->z,rac->numverts,
                                     (unsigned char) Config1,&unuseddbl);
                        }
                     else
                        {
                        unusedint = PointIsLargeArealVertex(rpc->x[0],rpc->y[0],rac,&unuseddbl);
                        if(unusedint == 0)
                           unusedint = PointOnLargeArealEdge(rpc->x[0],rpc->y[0],rac,&unuseddbl, &iii);
                        if(unusedint == 0)
                           unusedint = PointInsideLargeAreal(rpc->x[0], rpc->y[0], rac, &iii);
                        }
                     if(unusedint > 0)
                        {
                        rah = root;
                        PassCond = 0;
                        while(rah != NULL)
                           {
                           if((rah != rac) && (rah->ishole > 0) && (rah->idn == rac->idn))
                              {
                              if(rah->RB_Tree_Edgelist == NULL)
                                 {
                                 if((PointIsVertex(rpc->x[0],rpc->y[0],rah->x,rah->y,rah->z,rah->numverts,&unuseddbl) == 0) &&
                                   (PointOnEdge(rpc->x[0],rpc->y[0],rah->x,rah->y,rah->z,rah->numverts,&unuseddbl,&iii) == 0))
                                    PassCond = PointInAreal(rpc->x[0], rpc->y[0], rah->x,rah->y,rah->numverts, &iii);
                                 }
                              else
                                 {
                                 if((PointIsLargeArealVertex(rpc->x[0],rpc->y[0],rah,&unuseddbl) == 0) &&
                                        (PointOnLargeArealEdge(rpc->x[0],rpc->y[0],rah,&unuseddbl, &iii) == 0))
                                    PassCond = PointInsideLargeAreal(rpc->x[0], rpc->y[0], rah, &iii);
                                 }
                              }
                           rah = rah->next;
                           }
                        if(PassCond == 0)
                           {
                           foundobject = 1;
                           }
                        }
                     }
                  if(foundobject > 0)
                     break;
                  rpc = rpc->next;
                  }
               }

            if(foundobject == 0)
               {
               ran = root;
               while(ran != NULL)
                  {
                  if((ran != rac) && (ran->ishole <= 0))
                     {
                     if((CombinedCheckApplies(ran->idn,checkinstance,OBJECTWITHOUT,
                         ran->Lindex,ran->Sindex,SCCtable[ran->Sindex].C,SCCtable[ran->Sindex].S,SCCtable[ran->Sindex].D,
                         &part1,&part2,&part3) > 0) && (part2 > 0))
                        {
                        for(j=0; j<ran->numverts; j++)
                           {
                           unusedint = 0;
                           if(rac->RB_Tree_Edgelist == NULL)
                              {
                              unusedint = PointIsVertex(ran->x[j],ran->y[j],rac->x,rac->y,rac->z,rac->numverts,&unuseddbl);
                              if(unusedint == 0)
                                 unusedint = PointOnEdge(ran->x[j],ran->y[j],rac->x,rac->y,rac->z,rac->numverts,&unuseddbl,&iii);
                              if(unusedint == 0)
                                 unusedint = PointIsInside(ran->x[j],ran->y[j],rac->x,rac->y,rac->z,rac->numverts,
                                     (unsigned char) Config1,&unuseddbl);
                              }
                           else
                              {
                              unusedint = PointIsLargeArealVertex(ran->x[j],ran->y[j],rac,&unuseddbl);
                              if(unusedint == 0)
                                 unusedint = PointOnLargeArealEdge(ran->x[j],ran->y[j],rac,&unuseddbl, &iii);
                              if(unusedint == 0)
                                 unusedint = PointInsideLargeAreal(ran->x[j], ran->y[j], rac, &iii);
                              }
                           if(unusedint > 0)
                              {
                              rah = root;
                              PassCond = 0;
                              while(rah != NULL)
                                 {
                                 if((rah != rac) && (rah->ishole > 0) && (rah->idn == rac->idn))
                                    {
                                    if(rah->RB_Tree_Edgelist == NULL)
                                       {
                                       if((PointIsVertex(ran->x[j],ran->y[j],rah->x,rah->y,rah->z,rah->numverts,&unuseddbl) == 0) &&
                                         (PointOnEdge(ran->x[j],ran->y[j],rah->x,rah->y,rah->z,rah->numverts,&unuseddbl,&iii) == 0))
                                          PassCond = PointInAreal(ran->x[j], ran->y[j], rah->x,rah->y,rah->numverts, &iii);
                                       }
                                    else
                                       {
                                       if((PointIsLargeArealVertex(ran->x[j],ran->y[j],rah,&unuseddbl) == 0) &&
                                              (PointOnLargeArealEdge(ran->x[j],ran->y[j],rah,&unuseddbl, &iii) == 0))
                                          PassCond = PointInsideLargeAreal(ran->x[j], ran->y[j], rah, &iii);
                                       }
                                    }
                                 if(PassCond > 0)
                                    break;
                                 rah = rah->next;
                                 }
                              if(PassCond == 0)
                                 {
                                 foundobject = 1;
                                 break;
                                 }
                              }
                           }

                        if((ran->numverts > 1) && (foundobject == 0))
                           {
                           for(j=1; j<ran->numverts; j++)
                              {
                              for(i=0; i<rac->numverts; i++)
                                 {
                                 k = (i + 1) % rac->numverts;
                                 if(LineSegmentsIntersect(ran->x[j-1],ran->y[j-1],ran->x[j],ran->y[j],rac->x[i],rac->y[i],rac->x[k],rac->y[k],
                                          &xint, &yint) > 0)
                                    {
                                    foundobject = 1;
                                    break;
                                    }
                                 }
                              if(foundobject > 0)
                                 break;
                              }
                           if(foundobject == 0)
                              {
                              rah = root;
                              while(rah != NULL)
                                 {
                                 if((rah != rac) && (rah->ishole > 0) && (rah->idn == rac->idn))
                                    {
                                    for(j=1; j<ran->numverts; j++)
                                       {
                                       for(i=0; i<rah->numverts; i++)
                                          {
                                          if(i == 0)
                                             k = rah->numverts - 1;
                                          else
                                             k = i - 1;
                                          if(LineSegmentsIntersect(ran->x[j-1],ran->y[j-1],ran->x[j],ran->y[j],
                                               rah->x[i],rah->y[i],rah->x[k],rah->y[k], &xint, &yint) > 0)
                                             {
                                             foundobject = 1;
                                             break;
                                             }
                                          }
                                       }
                                    }
                                 rah = rah->next;
                                 }
                              }
                           }
                        if(foundobject > 0)
                           break;
                        else
                           {
                           j = 0;
                           CreatePointInsideAreal(ran,&px, &py);
                           if(rac->RB_Tree_Edgelist == NULL)
                              j = PointIsInside(px, py, rac->x,rac->y,rac->x,rac->numverts,C_AREA,&unuseddbl);
                           else
                                 j = PointInsideLargeAreal(px, py,rac,&unusedint);
                           if(j > 0) /*** is inside the outer ring -- is it in a hole?  ****/
                              {
                              j = 0;
                              rah = root;
                              while(rah != NULL)
                                 {
                                 if((rah->ishole > 0) && (rah->idn == rac->idn))
                                    {
                                    if(AreaInsideArea(ran,rah,&xt3,&yt3) > 1)
                                       {
                                       break;
                                       }
                                    }
                                 rah = rah->next;
                                 }
                              if(rah == NULL)
                                 {
                                 foundobject = 1;
                                 break;  /*** should break from the while ran loop ***/
                                 }
                              }  /*** end testing to see if ran is in a hole of rac ***/
   
                           if(j == 0) 
                              {
                              CreatePointInsideAreal(rac,&px, &py);
                              if(ran->RB_Tree_Edgelist == NULL)
                                 j = PointIsInside(px, py, ran->x,ran->y,ran->x,ran->numverts,C_AREA,&unuseddbl);
                              else
                                 j = PointInsideLargeAreal(px, py,ran,&unusedint);

                              if(j > 0)
                                 {
                                 j = 0; 
                                 rah = root;
                                 while(rah != NULL)
                                    {
                                    if((rah->ishole > 0) && (rah->idn == ran->idn))
                                       {
                                       if(AreaInsideArea(rac,rah,&xt3,&yt3) > 1)
                                          {
                                          break;
                                          }
                                       }
                                    rah = rah->next;
                                    }
                                 if(rah == NULL)
                                    {
                                    foundobject = 1; 
                                    break;  /*** should break from the while ran loop ***/
                                    }
                                 }  /*** end testing to see if rac is in a hole of ran ***/

                              }
                           }
                        }
                     }

                  ran = ran->next;
                  }
               }


            if(rac->ismulti == 0) /** if is a single region feature, know everything required now ... ***/
               {
               if(foundobject == 0) /** couldn't find specified point or line object in this area feature **/
                  {
                  ERc = (struct collection *) (malloc(SzC));
                  if(ERc == NULL)
                     {
                     printf("allocation memory exhausted during area feature condition analysis\n");
                     printf("processing cannot continue\n");
                     exit(-1);
                     }
                  ERc->magnitude = 0; 
                  ERc->keyval = OBJECTWITHOUT;
                  ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                  ERc->Sindex1 = rac->Sindex;
                  ERc->aa = rac;
                  ERc->next = NULL;
                  if(ERroot == NULL)
                     {
                     ERroot = ERc;
                     }
                  else
                     {
                     ERn = ERroot;
                     while(ERn != NULL)
                        {
                        if(
                           (ERn->Cnumber    == ERc->Cnumber)    &&
                           (ERn->keyval    == ERc->keyval)    &&
                           (ERn->aa == ERc->aa)
                           )
                           break;
                        ERn = ERn->next;
                        }
                     if(ERn == NULL)
                        {
                        ERc->next = ERroot;
                        ERroot = ERc;
                        }
                     else
                        free(ERc);
                     }
                  }
               }
            else  /*** must be a multi-region area feature ... ****/
               {
               PassCond2 = 0;
               RB_newKey2 = rac->localID + (checkinstance * 0.0001);
               if(( RB_newNode = RBExactQuery(Check_RB_Tree,&RB_newKey2)))
                  {
                  RB_cond = (struct ConditionCollection *) RB_newNode->info;
                  RB_cond->counter += foundobject;
                  }
               else
                  {
                  RB_cond = (struct ConditionCollection *) (malloc(SzCC));
                  if(RB_cond == NULL)
                     {
                     printf("memory has been exhausted during RB-Tree information alloction for OBJECTWITHOUT analysis\n");
                     exit(-1);
                     }
                  RB_cond->keyval = OBJECTWITHOUT;
                  RB_cond->Cnumber =  Make_Correct(OBJECTWITHOUT,checkinstance);
                  RB_cond->index_from_to = NULL;
                  RB_cond->gform = G_AREAL;
                  RB_cond->featureidn = rac->featureid;
                  RB_cond->localID = rac->localID;
                  RB_cond->counter = foundobject;
                  RB_cond->radius = -1;
                  RB_cond->height = -1;
                  RB_cond->magnitude = 0.0;
                  RB_cond->IDN = rac->idn;
                  RB_cond->Sindex = rac->Sindex;
                  RB_cond->Lindex = rac->Lindex;

                  RB_cond->numnodes = rac->numverts;
                  RB_cond->x = (double *) (malloc(RB_cond->numnodes * SzD));
                  RB_cond->y = (double *) (malloc(RB_cond->numnodes * SzD));
                  RB_cond->z = (double *) (malloc(RB_cond->numnodes * SzD));
                  if(RB_cond->z == NULL)
                     {
                     printf("memory has been exhausted during RB-Tree element vertex alloction for OBJECTWITHOUT analysis\n");
                     exit(-1);
                     }
                  for(jj=0; jj< rac->numverts; jj++)
                     {
                     RB_cond->x[jj] = rac->x[jj];
                     RB_cond->y[jj] = rac->y[jj];
                     RB_cond->z[jj] = rac->z[jj];
                     }

                  RB_newDbl = (double *) (malloc(SzD));
                  if(RB_newDbl == NULL)
                     {
                     printf("memory has been exhausted during RB-Tree alloction for OBJECTWITHOUT analysis\n");
                     exit(-1);
                     }
                  *RB_newDbl = RB_newKey2; /**rac->localID; **/
                  RBTreeInsert(Check_RB_Tree,RB_newDbl, RB_cond);
                  } /*** end treating multi-region area for OBJECTWITHOUT ***/
               }
            } /*** end OBJECTWITHOUT check for areals  containing points, lines**/




         if((rac->ishole <= 0) &&     /*****(rac->firstindex == cindex) && ****/
              (CombinedCheckApplies(rac->idn,checkinstance,OBJ_WO_TWO,rac->Lindex,rac->Sindex,
                Config1,Strat1,Domain1, &part1,&part2,&part3) > 0) &&
              (part1 > 0))
            {
            jj2 = rac->numverts - 1;
            foundobject = 0;
            found_two = 0;
            rasave = NULL;
            rlsave = NULL;
            rpsave = NULL;
            for(j = 0; j < rac->numverts; j++)
               {
               checkit = ConditionOnDataEdge(rac->x[j],rac->y[j],rac->x[jj2],rac->y[jj2],root,Proot,Lroot,
                             rac, NULL, NULL,
                             NorthCount,SouthCount,EastCount,WestCount,checkinstance);
               if(checkit == 0)
                  {
                  foundobject = 1;
                  break;
                  }
               jj2 = j;
               }

            rlc = Lroot;
            while((foundobject == 0) && (rlc != NULL))
               {
               if((CombinedCheckApplies(rlc->idn,checkinstance,OBJ_WO_TWO,
                         rlc->Lindex,rlc->Sindex,SCCtable[rlc->Sindex].C,SCCtable[rlc->Sindex].S,SCCtable[rlc->Sindex].D,
                   &part1,&part2,&part3) > 0) && (part2 > 0))
                  {
                  for(j=0; j<rlc->numnodes; j++)
                     {
                     unusedint = 0;
                     if(rac->RB_Tree_Edgelist == NULL)
                        {
                        unusedint = PointIsVertex(rlc->x[j],rlc->y[j],rac->x,rac->y,rac->z,rac->numverts,&unuseddbl);
                        if(unusedint == 0)
                           unusedint = PointOnEdge(rlc->x[j],rlc->y[j],rac->x,rac->y,rac->z,rac->numverts,&unuseddbl,&iii);
                        if(unusedint == 0)
                           unusedint = PointIsInside(rlc->x[j],rlc->y[j],rac->x,rac->y,rac->z,rac->numverts,
                                     (unsigned char) Config1,&unuseddbl);
                        }
                     else
                        {
                        unusedint = PointIsLargeArealVertex(rlc->x[j],rlc->y[j],rac,&unuseddbl);
                        if(unusedint == 0)
                           unusedint = PointOnLargeArealEdge(rlc->x[j],rlc->y[j],rac,&unuseddbl, &iii);
                        if(unusedint == 0)
                           unusedint = PointInsideLargeAreal(rlc->x[j], rlc->y[j], rac, &iii);
                        }
                     if(unusedint > 0)
                        {
                        rah = root;
                        PassCond = 0;
                        while(rah != NULL)
                           {
                           if((rah != rac) && (rah->ishole > 0) && (rah->idn == rac->idn))
                              {
                              if(rah->RB_Tree_Edgelist == NULL)
                                 {
                                 if((PointIsVertex(rlc->x[j],rlc->y[j],rah->x,rah->y,rah->z,rah->numverts,&unuseddbl) == 0) &&
                                   (PointOnEdge(rlc->x[j],rlc->y[j],rah->x,rah->y,rah->z,rah->numverts,&unuseddbl,&iii) == 0))
                                    PassCond = PointInAreal(rlc->x[j], rlc->y[j], rah->x,rah->y,rah->numverts, &iii);
                                 }
                              else
                                 {
                                 if((PointIsLargeArealVertex(rlc->x[j],rlc->y[j],rah,&unuseddbl) == 0) &&
                                        (PointOnLargeArealEdge(rlc->x[j],rlc->y[j],rah,&unuseddbl, &iii) == 0))
                                    PassCond = PointInsideLargeAreal(rlc->x[j], rlc->y[j], rah, &iii);
                                 }
                              }
                           if(PassCond > 0)
                              break;
                           rah = rah->next;
                           }
                        if(PassCond == 0)
                           {
                           foundobject = 1;
                           rlsave = rlc;
                           break;
                           }
                        }
                     }

                  if((rlc->numnodes > 1) && (foundobject == 0))
                     {
                     for(j=1; j<rlc->numnodes; j++)
                        {
                        for(i=0; i<rac->numverts; i++)
                           {
                           k = (i + 1) % rac->numverts;
                           if(LineSegmentsIntersect(rlc->x[j-1],rlc->y[j-1],rlc->x[j],rlc->y[j],rac->x[i],rac->y[i],rac->x[k],rac->y[k],
                                    &xint, &yint) > 0)
                              {
                              foundobject = 1;
                              rlsave = rlc;
                              break;
                              }
                           }
                        if(foundobject > 0)
                           break;
                        }
                     if(foundobject == 0)
                        {
                        rah = root;
                        while(rah != NULL)
                           {
                           if((rah != rac) && (rah->ishole > 0) && (rah->idn == rac->idn))
                              {
                              for(j=1; j<rlc->numnodes; j++)
                                 {
                                 for(i=0; i<rah->numverts; i++)
                                    {
                                    if(i == 0)
                                       k = rah->numverts - 1;
                                    else
                                       k = i - 1;
                                    if(LineSegmentsIntersect(rlc->x[j-1],rlc->y[j-1],rlc->x[j],rlc->y[j],
                                         rah->x[i],rah->y[i],rah->x[k],rah->y[k], &xint, &yint) > 0)
                                       {
                                       foundobject = 1;
                                       rlsave = rlc;
                                       break;
                                       }
                                    }
                                 }
                              }
                           rah = rah->next;
                           }
                        }
                     }
                  }
               if(foundobject > 0)
                  break;
               rlc = rlc->next;
               }
            if(foundobject == 0) /** see if any point objects satisfy criteria **/
               {
               rpc = Proot;
               while(rpc != NULL)
                  {
                  if((rpc->numverts < 1) && (rpc->numverts > -3) &&
                      (CombinedCheckApplies(rpc->idn,checkinstance,OBJ_WO_TWO,
                             rpc->Lindex,rpc->Sindex,SCCtable[rpc->Sindex].C,SCCtable[rpc->Sindex].S,SCCtable[rpc->Sindex].D,
                      &part1,&part2,&part3) > 0) && (part2 > 0))
                     {
                     unusedint = 0;
                     if(rac->RB_Tree_Edgelist == NULL)
                        {
                        unusedint = PointIsVertex(rpc->x[0],rpc->y[0],rac->x,rac->y,rac->z,rac->numverts,&unuseddbl);
                        if(unusedint == 0)
                           unusedint = PointOnEdge(rpc->x[0],rpc->y[0],rac->x,rac->y,rac->z,rac->numverts,&unuseddbl,&iii);
                        if(unusedint == 0)
                           unusedint = PointIsInside(rpc->x[0],rpc->y[0],rac->x,rac->y,rac->z,rac->numverts,
                                     (unsigned char) Config1,&unuseddbl);
                        }
                     else
                        {
                        unusedint = PointIsLargeArealVertex(rpc->x[0],rpc->y[0],rac,&unuseddbl);
                        if(unusedint == 0)
                           unusedint = PointOnLargeArealEdge(rpc->x[0],rpc->y[0],rac,&unuseddbl, &iii);
                        if(unusedint == 0)
                           unusedint = PointInsideLargeAreal(rpc->x[0], rpc->y[0], rac, &iii);
                        }
                     if(unusedint > 0)
                        {
                        rah = root;
                        PassCond = 0;
                        while(rah != NULL)
                           {
                           if((rah != rac) && (rah->ishole > 0) && (rah->idn == rac->idn))
                              {
                              if(rah->RB_Tree_Edgelist == NULL)
                                 {
                                 if((PointIsVertex(rpc->x[0],rpc->y[0],rah->x,rah->y,rah->z,rah->numverts,&unuseddbl) == 0) &&
                                   (PointOnEdge(rpc->x[0],rpc->y[0],rah->x,rah->y,rah->z,rah->numverts,&unuseddbl,&iii) == 0))
                                    PassCond = PointInAreal(rpc->x[0], rpc->y[0], rah->x,rah->y,rah->numverts, &iii);
                                 }
                              else
                                 {
                                 if((PointIsLargeArealVertex(rpc->x[0],rpc->y[0],rah,&unuseddbl) == 0) &&
                                        (PointOnLargeArealEdge(rpc->x[0],rpc->y[0],rah,&unuseddbl, &iii) == 0))
                                    PassCond = PointInsideLargeAreal(rpc->x[0], rpc->y[0], rah, &iii);
                                 }
                              }
                           rah = rah->next;
                           }
                        if(PassCond == 0)
                           {
                           foundobject = 1;
                           rpsave = rpc;
                           }
                        }
                     }
                  if(foundobject > 0)
                     break;
                  rpc = rpc->next;
                  }
               }

            if(foundobject == 0)
               {
               ran = root;
               while(ran != NULL)
                  {
                  if((ran != rac) && (ran->ishole <= 0))
                     {
                     if((CombinedCheckApplies(ran->idn,checkinstance,OBJ_WO_TWO,
                         ran->Lindex,ran->Sindex,SCCtable[ran->Sindex].C,SCCtable[ran->Sindex].S,SCCtable[ran->Sindex].D,
                         &part1,&part2,&part3) > 0) && (part2 > 0))
                        {
                        for(j=0; j<ran->numverts; j++)
                           {
                           unusedint = 0;
                           if(rac->RB_Tree_Edgelist == NULL)
                              {
                              unusedint = PointIsVertex(ran->x[j],ran->y[j],rac->x,rac->y,rac->z,rac->numverts,&unuseddbl);
                              if(unusedint == 0)
                                 unusedint = PointOnEdge(ran->x[j],ran->y[j],rac->x,rac->y,rac->z,rac->numverts,&unuseddbl,&iii);
                              if(unusedint == 0)
                                 unusedint = PointIsInside(ran->x[j],ran->y[j],rac->x,rac->y,rac->z,rac->numverts,
                                     (unsigned char) Config1,&unuseddbl);
                              }
                           else
                              {
                              unusedint = PointIsLargeArealVertex(ran->x[j],ran->y[j],rac,&unuseddbl);
                              if(unusedint == 0)
                                 unusedint = PointOnLargeArealEdge(ran->x[j],ran->y[j],rac,&unuseddbl, &iii);
                              if(unusedint == 0)
                                 unusedint = PointInsideLargeAreal(ran->x[j], ran->y[j], rac, &iii);
                              }
                           if(unusedint > 0)
                              {
                              rah = root;
                              PassCond = 0;
                              while(rah != NULL)
                                 {
                                 if((rah != rac) && (rah->ishole > 0) && (rah->idn == rac->idn))
                                    {
                                    if(rah->RB_Tree_Edgelist == NULL)
                                       {
                                       if((PointIsVertex(ran->x[j],ran->y[j],rah->x,rah->y,rah->z,rah->numverts,&unuseddbl) == 0) &&
                                         (PointOnEdge(ran->x[j],ran->y[j],rah->x,rah->y,rah->z,rah->numverts,&unuseddbl,&iii) == 0))
                                          PassCond = PointInAreal(ran->x[j], ran->y[j], rah->x,rah->y,rah->numverts, &iii);
                                       }
                                    else
                                       {
                                       if((PointIsLargeArealVertex(ran->x[j],ran->y[j],rah,&unuseddbl) == 0) &&
                                              (PointOnLargeArealEdge(ran->x[j],ran->y[j],rah,&unuseddbl, &iii) == 0))
                                          PassCond = PointInsideLargeAreal(ran->x[j], ran->y[j], rah, &iii);
                                       }
                                    }
                                 if(PassCond > 0)
                                    break;
                                 rah = rah->next;
                                 }
                              if(PassCond == 0)
                                 {
                                 foundobject = 1;
                                 rasave = ran;
                                 break;
                                 }
                              }
                           }

                        if((ran->numverts > 1) && (foundobject == 0))
                           {
                           for(j=1; j<ran->numverts; j++)
                              {
                              for(i=0; i<rac->numverts; i++)
                                 {
                                 k = (i + 1) % rac->numverts;
                                 if(LineSegmentsIntersect(ran->x[j-1],ran->y[j-1],ran->x[j],ran->y[j],rac->x[i],rac->y[i],rac->x[k],rac->y[k],
                                          &xint, &yint) > 0)
                                    {
                                    foundobject = 1;
                                    rasave = ran;
                                    break;
                                    }
                                 }
                              if(foundobject > 0)
                                 break;
                              }
                           if(foundobject == 0)
                              {
                              rah = root;
                              while(rah != NULL)
                                 {
                                 if((rah != rac) && (rah->ishole > 0) && (rah->idn == rac->idn))
                                    {
                                    for(j=1; j<ran->numverts; j++)
                                       {
                                       for(i=0; i<rah->numverts; i++)
                                          {
                                          if(i == 0)
                                             k = rah->numverts - 1;
                                          else
                                             k = i - 1;
                                          if(LineSegmentsIntersect(ran->x[j-1],ran->y[j-1],ran->x[j],ran->y[j],
                                               rah->x[i],rah->y[i],rah->x[k],rah->y[k], &xint, &yint) > 0)
                                             {
                                             foundobject = 1;
                                             rasave = ran;
                                             break;
                                             }
                                          }
                                       }
                                    }
                                 rah = rah->next;
                                 }
                              }
                           }
                        if(foundobject > 0)
                           break;
                        else
                           {
                           j = 0;
                           CreatePointInsideAreal(ran,&px, &py);
                           if(rac->RB_Tree_Edgelist == NULL)
                              j = PointIsInside(px, py, rac->x,rac->y,rac->x,rac->numverts,C_AREA,&unuseddbl);
                           else
                              j = PointInsideLargeAreal(px, py,rac,&unusedint);
                           if(j > 0) /*** is inside the outer ring -- is it in a hole?  ****/
                              {
                              j = 0;
                              rah = root;
                              while(rah != NULL)
                                 {
                                 if((rah->ishole > 0) && (rah->idn == rac->idn))
                                    {
                                    if(AreaInsideArea(ran,rah,&xt3,&yt3) > 1)
                                       {
                                       break;
                                       }
                                    }
                                 rah = rah->next;
                                 }
                              if(rah == NULL)
                                 {
                                 foundobject = 1;
                                 rasave = ran;
                                 break;  /*** should break from the while ran loop ***/
                                 }
                              }  /*** end testing to see if ran is in a hole of rac ***/
   
                           if(j == 0)
                              {
                              CreatePointInsideAreal(rac,&px, &py);
                              if(ran->RB_Tree_Edgelist == NULL)
                                 j = PointIsInside(px, py, ran->x,ran->y,ran->x,ran->numverts,C_AREA,&unuseddbl);
                              else
                                 j = PointInsideLargeAreal(px, py,ran,&unusedint);
   
                              if(j > 0) /*** is inside the outer ring -- is it in a hole?  ****/
                                 {
                                 j = 0;
                                 rah = root;
                                 while(rah != NULL)
                                    {
                                    if((rah->ishole > 0) && (rah->idn == ran->idn))
                                       {
                                       if(AreaInsideArea(rac,rah,&xt3,&yt3) > 1)
                                          {
                                          break;
                                          }
                                       }
                                    rah = rah->next;
                                    }
                                 if(rah == NULL)
                                    {
                                    foundobject = 1;
                                    rasave = ran;
                                    break;  /*** should break from the while ran loop ***/
                                    }
                                 }  /*** end testing to see if rac is in a hole of ran ***/
                              }
                           }
                        }
                     }

                  ran = ran->next;
                  }
               }

            found_two = 0;
            if((rac->ismulti > 0) || (foundobject == 1)) /*** only need to check for tertiary feature if rac is multi-region ****/
               { /*** or rac is single region and already found a secondary particpant inside the primary ***/

               rln = Lroot;
               while((found_two == 0) && (rln != NULL))
                  {
                  if((rln != rlsave) && (CombinedCheckApplies(rln->idn,checkinstance,OBJ_WO_TWO,
                            rln->Lindex,rln->Sindex,SCCtable[rln->Sindex].C,SCCtable[rln->Sindex].S,SCCtable[rln->Sindex].D,
                      &part1,&part2,&part3) > 0) && (part3 > 0))
                     {
                     for(j=0; j<rln->numnodes; j++)
                        {
                        unusedint = 0;
                        if(rac->RB_Tree_Edgelist == NULL)
                           {
                           unusedint = PointIsVertex(rln->x[j],rln->y[j],rac->x,rac->y,rac->z,rac->numverts,&unuseddbl);
                           if(unusedint == 0)
                              unusedint = PointOnEdge(rln->x[j],rln->y[j],rac->x,rac->y,rac->z,rac->numverts,&unuseddbl,&iii);
                           if(unusedint == 0)
                              unusedint = PointIsInside(rln->x[j],rln->y[j],rac->x,rac->y,rac->z,rac->numverts,
                                     (unsigned char) Config1,&unuseddbl);
                           }
                        else
                           {
                           unusedint = PointIsLargeArealVertex(rln->x[j],rln->y[j],rac,&unuseddbl);
                           if(unusedint == 0)
                              unusedint = PointOnLargeArealEdge(rln->x[j],rln->y[j],rac,&unuseddbl, &iii);
                           if(unusedint == 0)
                              unusedint = PointInsideLargeAreal(rln->x[j], rln->y[j], rac, &iii);
                           }
                        if(unusedint > 0)
                           {
                           rah = root;
                           PassCond = 0;
                           while(rah != NULL)
                              {
                              if((rah != rac) && (rah->ishole > 0) && (rah->idn == rac->idn))
                                 {
                                 if(rah->RB_Tree_Edgelist == NULL)
                                    {
                                    if((PointIsVertex(rln->x[j],rln->y[j],rah->x,rah->y,rah->z,rah->numverts,&unuseddbl) == 0) &&
                                      (PointOnEdge(rln->x[j],rln->y[j],rah->x,rah->y,rah->z,rah->numverts,&unuseddbl,&iii) == 0))
                                       PassCond = PointInAreal(rln->x[j], rln->y[j], rah->x,rah->y,rah->numverts, &iii);
                                    }
                                 else
                                    {
                                    if((PointIsLargeArealVertex(rln->x[j],rln->y[j],rah,&unuseddbl) == 0) &&
                                           (PointOnLargeArealEdge(rln->x[j],rln->y[j],rah,&unuseddbl, &iii) == 0))
                                       PassCond = PointInsideLargeAreal(rln->x[j], rln->y[j], rah, &iii);
                                    }
                                 }
                              if(PassCond > 0)
                                 break;
                              rah = rah->next;
                              }
                           if(PassCond == 0)
                              {
                              found_two = 1;
                              break;
                              }
                           }
                        }

                     if((rln->numnodes > 1) && (found_two == 0))
                        {
                        for(j=1; j<rln->numnodes; j++)
                           {
                           for(i=0; i<rac->numverts; i++)
                              {
                              k = (i + 1) % rac->numverts;
                              if(LineSegmentsIntersect(rln->x[j-1],rln->y[j-1],rln->x[j],rln->y[j],rac->x[i],rac->y[i],rac->x[k],rac->y[k],
                                    &xint, &yint) > 0)
                                 {
                                 found_two = 1;
                                 break;
                                 }
                              }
                           if(found_two > 0)
                              break;
                           }
                        if(found_two == 0)
                           {
                           rah = root;
                           while(rah != NULL)
                              {
                              if((rah != rac) && (rah->ishole > 0) && (rah->idn == rac->idn))
                                 {
                                 for(j=1; j<rln->numnodes; j++)
                                    {
                                    for(i=0; i<rah->numverts; i++)
                                       {
                                       if(i == 0)
                                          k = rah->numverts - 1;
                                       else
                                          k = i - 1;
                                       if(LineSegmentsIntersect(rln->x[j-1],rln->y[j-1],rln->x[j],rln->y[j],
                                            rah->x[i],rah->y[i],rah->x[k],rah->y[k], &xint, &yint) > 0)
                                          {
                                          found_two = 1;
                                          break;
                                          }
                                       }
                                    }
                                 }
                              rah = rah->next;
                              }
                           }
                        }
                     }
                  if(found_two > 0)
                     break;
                  rln = rln->next;
                  }
               if(found_two == 0) /** see if any point objects satisfy criteria **/
                  {
                  rpn = Proot;
                  while(rpn != NULL)
                     {
                     if((rpn != rpsave) && (rpn->numverts < 1) && (rpn->numverts > -3) &&
                         (CombinedCheckApplies(rpn->idn,checkinstance,OBJ_WO_TWO,
                                rpn->Lindex,rpn->Sindex,SCCtable[rpn->Sindex].C,SCCtable[rpn->Sindex].S,SCCtable[rpn->Sindex].D,
                         &part1,&part2,&part3) > 0) && (part3 > 0))
                        {
                        unusedint = 0;
                        if(rac->RB_Tree_Edgelist == NULL)
                           {
                           unusedint = PointIsVertex(rpn->x[0],rpn->y[0],rac->x,rac->y,rac->z,rac->numverts,&unuseddbl);
                           if(unusedint == 0)
                              unusedint = PointOnEdge(rpn->x[0],rpn->y[0],rac->x,rac->y,rac->z,rac->numverts,&unuseddbl,&iii);
                           if(unusedint == 0)
                              unusedint = PointIsInside(rpn->x[0],rpn->y[0],rac->x,rac->y,rac->z,rac->numverts,
                                        (unsigned char) Config1,&unuseddbl);
                           }
                        else
                           {
                           unusedint = PointIsLargeArealVertex(rpn->x[0],rpn->y[0],rac,&unuseddbl);
                           if(unusedint == 0)
                              unusedint = PointOnLargeArealEdge(rpn->x[0],rpn->y[0],rac,&unuseddbl, &iii);
                           if(unusedint == 0)
                              unusedint = PointInsideLargeAreal(rpn->x[0], rpn->y[0], rac, &iii);
                           }
                        if(unusedint > 0)
                           {
                           rah = root;
                           PassCond = 0;
                           while(rah != NULL)
                              {
                              if((rah != rac) && (rah->ishole > 0) && (rah->idn == rac->idn))
                                 {
                                 if(rah->RB_Tree_Edgelist == NULL)
                                    {
                                    if((PointIsVertex(rpn->x[0],rpn->y[0],rah->x,rah->y,rah->z,rah->numverts,&unuseddbl) == 0) &&
                                      (PointOnEdge(rpn->x[0],rpn->y[0],rah->x,rah->y,rah->z,rah->numverts,&unuseddbl,&iii) == 0))
                                       PassCond = PointInAreal(rpn->x[0], rpn->y[0], rah->x,rah->y,rah->numverts, &iii);
                                    }
                                 else
                                    {
                                    if((PointIsLargeArealVertex(rpn->x[0],rpn->y[0],rah,&unuseddbl) == 0) &&
                                           (PointOnLargeArealEdge(rpn->x[0],rpn->y[0],rah,&unuseddbl, &iii) == 0))
                                       PassCond = PointInsideLargeAreal(rpn->x[0], rpn->y[0], rah, &iii);
                                    }
                                 }
                              rah = rah->next;
                              }
                           if(PassCond == 0)
                              {
                              found_two = 1;
                              }
                           }
                        }
                     if(found_two > 0)
                        break;
                     rpn = rpn->next;
                     }
                  }
   
               if(found_two == 0)
                  {
                  ra2 = root;
                  while(ra2 != NULL)
                     {
                     if((ra2 != rac) && (ra2 != rasave) && (ra2->ishole <= 0))
                        {
                        if((CombinedCheckApplies(ra2->idn,checkinstance,OBJ_WO_TWO,
                            ra2->Lindex,ra2->Sindex,SCCtable[ra2->Sindex].C,SCCtable[ra2->Sindex].S,SCCtable[ra2->Sindex].D,
                            &part1,&part2,&part3) > 0) && (part3 > 0))
                           {
                           for(j=0; j<ra2->numverts; j++)
                              {
                              unusedint = 0;
                              if(rac->RB_Tree_Edgelist == NULL)
                                 {
                                 unusedint = PointIsVertex(ra2->x[j],ra2->y[j],rac->x,rac->y,rac->z,rac->numverts,&unuseddbl);
                                 if(unusedint == 0)
                                    unusedint = PointOnEdge(ra2->x[j],ra2->y[j],rac->x,rac->y,rac->z,rac->numverts,&unuseddbl,&iii);
                                 if(unusedint == 0)
                                    unusedint = PointIsInside(ra2->x[j],ra2->y[j],rac->x,rac->y,rac->z,rac->numverts,
                                        (unsigned char) Config1,&unuseddbl);
                                 }
                              else
                                 {
                                 unusedint = PointIsLargeArealVertex(ra2->x[j],ra2->y[j],rac,&unuseddbl);
                                 if(unusedint == 0)
                                    unusedint = PointOnLargeArealEdge(ra2->x[j],ra2->y[j],rac,&unuseddbl, &iii);
                                 if(unusedint == 0)
                                    unusedint = PointInsideLargeAreal(ra2->x[j], ra2->y[j], rac, &iii);
                                 }
                              if(unusedint > 0)
                                 {
                                 rah = root;
                                 PassCond = 0;
                                 while(rah != NULL)
                                    {
                                    if((rah != rac) && (rah->ishole > 0) && (rah->idn == rac->idn))
                                       {
                                       if(rah->RB_Tree_Edgelist == NULL)
                                          {
                                          if((PointIsVertex(ra2->x[j],ra2->y[j],rah->x,rah->y,rah->z,rah->numverts,&unuseddbl) == 0) &&
                                            (PointOnEdge(ra2->x[j],ra2->y[j],rah->x,rah->y,rah->z,rah->numverts,&unuseddbl,&iii) == 0))
                                             PassCond = PointInAreal(ra2->x[j], ra2->y[j], rah->x,rah->y,rah->numverts, &iii);
                                          }
                                       else
                                          {
                                          if((PointIsLargeArealVertex(ra2->x[j],ra2->y[j],rah,&unuseddbl) == 0) &&
                                                 (PointOnLargeArealEdge(ra2->x[j],ra2->y[j],rah,&unuseddbl, &iii) == 0))
                                             PassCond = PointInsideLargeAreal(ra2->x[j], ra2->y[j], rah, &iii);
                                          }
                                       }
                                    if(PassCond > 0)
                                       break;
                                    rah = rah->next;
                                    }
                                 if(PassCond == 0)
                                    {
                                    found_two = 1;
                                    break;
                                    }
                                 }
                              }

                           if((ra2->numverts > 1) && (found_two == 0))
                              {
                              for(j=1; j<ra2->numverts; j++)
                                 {
                                 for(i=0; i<rac->numverts; i++)
                                    {
                                    k = (i + 1) % rac->numverts;
                                    if(LineSegmentsIntersect(ra2->x[j-1],ra2->y[j-1],ra2->x[j],ra2->y[j],rac->x[i],rac->y[i],rac->x[k],rac->y[k],
                                             &xint, &yint) > 0)
                                       {
                                       found_two = 1;
                                       break;
                                       }
                                    }
                                 if(found_two > 0)
                                    break;
                                 }
                              if(found_two == 0)
                                 {
                                 rah = root;
                                 while(rah != NULL)
                                    {
                                    if((rah != rac) && (rah->ishole > 0) && (rah->idn == rac->idn))
                                       {
                                       for(j=1; j<ra2->numverts; j++)
                                          {
                                          for(i=0; i<rah->numverts; i++)
                                             {
                                             if(i == 0)
                                                k = rah->numverts - 1;
                                             else
                                                k = i - 1;
                                             if(LineSegmentsIntersect(ra2->x[j-1],ra2->y[j-1],ra2->x[j],ra2->y[j],
                                                  rah->x[i],rah->y[i],rah->x[k],rah->y[k], &xint, &yint) > 0)
                                                {
                                                found_two = 1;
                                                break;
                                                }
                                             }
                                          }
                                       }
                                    rah = rah->next;
                                    }
                                 }
                              }
                           if(found_two > 0)
                              break;
                           else
                              {
                              j = 0;
                              CreatePointInsideAreal(ra2,&px, &py);
                              if(rac->RB_Tree_Edgelist == NULL)
                                 j = PointIsInside(px, py, rac->x,rac->y,rac->x,rac->numverts,C_AREA,&unuseddbl);
                              else
                                 j = PointInsideLargeAreal(px, py,rac,&unusedint);
                              if(j > 0) /*** is inside the outer ring -- is it in a hole?  ****/
                                 {
                                 j = 0;
                                 rah = root;
                                 while(rah != NULL)
                                    {
                                    if((rah->ishole > 0) && (rah->idn == rac->idn))
                                       {
                                       if(AreaInsideArea(ra2,rah,&xt3,&yt3) > 1)
                                          {
                                          break;
                                          }
                                       }
                                    rah = rah->next;
                                    }
                                 if(rah == NULL)
                                    {
                                    found_two = 1;
                                    break;  /*** should break from the while ra2 loop ***/
                                    }
                                 }  /*** end testing to see if ra2 is in a hole of rac ***/
      
                              if(j == 0)
                                 {
                                 CreatePointInsideAreal(rac,&px, &py);
                                 if(ra2->RB_Tree_Edgelist == NULL)
                                    j = PointIsInside(px, py, ra2->x,ra2->y,ra2->x,ra2->numverts,C_AREA,&unuseddbl);
                                 else
                                    j = PointInsideLargeAreal(px, py,ra2,&unusedint);
   
                                 if(j > 0) /*** is inside the outer ring -- is it in a hole?  ****/
                                    {
                                    j = 0;
                                    rah = root;
                                    while(rah != NULL)
                                       {
                                       if((rah->ishole > 0) && (rah->idn == ra2->idn))
                                          {
                                          if(AreaInsideArea(rac,rah,&xt3,&yt3) > 1)
                                             {
                                             break;
                                             }
                                          }
                                       rah = rah->next;
                                       }
                                    if(rah == NULL)
                                       {
                                       found_two = 1;
                                       break;  /*** should break from the while ra2 loop ***/
                                       }
                                    }  /*** end testing to see if rac is in a hole of ra2 ***/
                                 }
                              } /** end else found_two is 0 **/
                           } /** end check applies to ra2 as part3 ***/
                        } /** end if((ra2 != rac) && (ra2->ishole <= 0)) ***/
   
                     ra2 = ra2->next;
                     } /** end while(ra2 != NULL) **/
                  } /** end if(found_two == 0) **/
               } /** end need to do the check for a part3 feature ***/

            if(rac->ismulti == 0) /** if is a single region feature, know everything required now ... ***/
               {
               if((foundobject == 1) && (found_two == 0))
                  {
                  ERc = (struct collection *) (malloc(SzC));
                  if(ERc == NULL)
                     {
                     printf("allocation memory exhausted during area feature condition analysis\n");
                     printf("processing cannot continue\n");
                     exit(-1);
                     }
                  ERc->magnitude = 0;
                  ERc->keyval = OBJ_WO_TWO;
                  ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                  ERc->Sindex1 = rac->Sindex;
                  ERc->aa = rac;
                  ERc->next = NULL;
                  if(ERroot == NULL)
                     {
                     ERroot = ERc;
                     }
                  else
                     {
                     ERn = ERroot;
                     while(ERn != NULL)
                        {
                        if(
                           (ERn->Cnumber    == ERc->Cnumber)    &&
                           (ERn->keyval    == ERc->keyval)    &&
                           (ERn->aa == ERc->aa)
                           )
                           break;
                        ERn = ERn->next;
                        }
                     if(ERn == NULL)
                        {
                        ERc->next = ERroot;
                        ERroot = ERc;
                        }
                     else
                        free(ERc);
                     }
                  }
               }
            else  /*** must be a multi-region area feature ... ****/
               {
               PassCond2 = 0;
               RB_newKey2 = rac->localID + (checkinstance * 0.0001);
               if(( RB_newNode = RBExactQuery(Check_RB_Tree,&RB_newKey2)))
                  {
                  RB_cond = (struct ConditionCollection *) RB_newNode->info;
                  if(RB_cond->counter != 1)
                     {
                     if((RB_cond->counter == 2) && (found_two > 0)) /** then already found secondary, not tertiary ***/
                        RB_cond->counter = 1;
                     else if((RB_cond->counter == 3) && (foundobject > 0)) /** found tertiary, not secondary ***/
                        RB_cond->counter = 1;
                     else if(RB_cond->counter == 0)
                        {
                        if((foundobject > 0) && (found_two > 0))
                           RB_cond->counter = 1;
                        else if(foundobject > 0)
                           RB_cond->counter = 2;
                        else if(found_two > 0)
                           RB_cond->counter = 3;
                        }
                     }
                  }
               else
                  {
                  RB_cond = (struct ConditionCollection *) (malloc(SzCC));
                  if(RB_cond == NULL)
                     {
                     printf("memory has been exhausted during RB-Tree information alloction for OBJ_WO_TWO analysis\n");
                     exit(-1);
                     }
                  RB_cond->keyval = OBJ_WO_TWO;
                  RB_cond->Cnumber =  Make_Correct(OBJ_WO_TWO,checkinstance);
                  RB_cond->index_from_to = NULL;
                  RB_cond->gform = G_AREAL;
                  RB_cond->featureidn = rac->featureid;
                  RB_cond->localID = rac->localID;
                  if((foundobject > 0) && (found_two > 0))
                     RB_cond->counter = 1;
                  else if(foundobject > 0)
                     RB_cond->counter = 2;
                  else if(found_two > 0)
                     RB_cond->counter = 3;
                  else
                     RB_cond->counter = 0;
                  RB_cond->radius = -1;
                  RB_cond->height = -1;
                  RB_cond->magnitude = 0.0;
                  RB_cond->IDN = rac->idn;
                  RB_cond->Sindex = rac->Sindex;
                  RB_cond->Lindex = rac->Lindex;

                  RB_cond->numnodes = rac->numverts;
                  RB_cond->x = (double *) (malloc(RB_cond->numnodes * SzD));
                  RB_cond->y = (double *) (malloc(RB_cond->numnodes * SzD));
                  RB_cond->z = (double *) (malloc(RB_cond->numnodes * SzD));
                  if(RB_cond->z == NULL)
                     {
                     printf("memory has been exhausted during RB-Tree element vertex alloction for OBJ_WO_TWO analysis\n");
                     exit(-1);
                     }
                  for(jj=0; jj< rac->numverts; jj++)
                     {
                     RB_cond->x[jj] = rac->x[jj];
                     RB_cond->y[jj] = rac->y[jj];
                     RB_cond->z[jj] = rac->z[jj];
                     }

                  RB_newDbl = (double *) (malloc(SzD));
                  if(RB_newDbl == NULL)
                     {
                     printf("memory has been exhausted during RB-Tree alloction for OBJ_WO_TWO analysis\n");
                     exit(-1);
                     }
                  *RB_newDbl = RB_newKey2; /**rac->localID; **/
                  RBTreeInsert(Check_RB_Tree,RB_newDbl, RB_cond);
                  } /*** end treating multi-region area for OBJ_WO_TWO ***/
               }
            } /*** end check applies to rac for OBJ_WO_TWO check for areals  containing points, lines**/








         foundobject = 0;
         if((rac->ishole <= 0) && 
              (CombinedCheckApplies(rac->idn,checkinstance,AWITHOUTA,rac->Lindex,rac->Sindex,
                Config1,Strat1,Domain1, &part1,&part2,&part3) > 0) &&
              (part1 > 0))
            {
            rlc = Lroot;
            while(rlc != NULL)
               {
               if((CombinedCheckApplies(rlc->idn,checkinstance,AWITHOUTA,
                         rlc->Lindex,rlc->Sindex,SCCtable[rlc->Sindex].C,SCCtable[rlc->Sindex].S,SCCtable[rlc->Sindex].D,
                   &part1,&part2,&part3) > 0) && (part2 > 0))
                  {
                  for(j=0; j<rlc->numnodes; j++)
                     {
                     if((rac->numverts == 3) && (PointInsideTriangle(rlc->x[j],rlc->y[j], rac->x[0], rac->y[0],
                                         rac->x[1], rac->y[1], rac->x[2], rac->y[2]) > 0))
                        {
                        rah = root;
                        PassCond = 0;
                        while(rah != NULL)
                           {
                           if((rah != rac) && (rah->ishole > 0) && (rah->idn == rac->idn))
                              {
                              if(rah->RB_Tree_Edgelist == NULL)
                                 {
                                 PassCond = PointInAreal(rlc->x[j], rlc->y[j], rah->x,rah->y,rah->numverts, &iii);
                                 }
                              else
                                 {
                                 PassCond = PointInsideLargeAreal(rlc->x[j], rlc->y[j], rah, &iii);
                                 }
                              }
                           rah = rah->next;
                           }
                        if(PassCond == 1)
                           {
                           break;
                           }
                        }
                     else if(rac->numverts == 3)
                        {
                        break;  /*** if only one point is outside, can break now ***/
                        }
                     else if((rac->numverts > 3) && (PointInsidePoly(rlc->x[j],rlc->y[j], rac->x, rac->y, rac->numverts) > 0))
                        {
                        rah = root;
                        PassCond = 0;
                        while(rah != NULL)
                           {
                           if((rah != rac) && (rah->ishole > 0) && (rah->idn == rac->idn))
                              {
                              if(rah->RB_Tree_Edgelist == NULL)
                                 {
                                 PassCond = PointInAreal(rlc->x[j], rlc->y[j], rah->x,rah->y,rah->numverts, &iii);
                                 }
                              else
                                 {
                                 PassCond = PointInsideLargeAreal(rlc->x[j], rlc->y[j], rah, &iii);
                                 }
                              }
                           rah = rah->next;
                           }
                        if(PassCond == 0)
                           {
                           foundobject = 1;
                           break;
                           }
                        }
                     else if(rac->numverts > 3)
                        {
                        break;
                        }
                     }
                  if(j >= rlc->numnodes) /*** then all the line vertices were inside the area ...   ****/
                     {
                     foundobject = 1;
                     }
                  if((rlc->numnodes > 1) && (foundobject == 1))
                     {
                     for(j=1; j<rlc->numnodes; j++)
                        {
                        for(i=0; i<rac->numverts; i++)
                           {
                           k = (i + 1) % rac->numverts;
                           if(LineSegmentsIntersect(rlc->x[j-1],rlc->y[j-1],rlc->x[j],rlc->y[j],rac->x[i],rac->y[i],rac->x[k],rac->y[k],
                                    &xint, &yint) > 0)
                              {
                              foundobject = 0;
                              break;
                              }
                           }
                        if(foundobject == 0)
                           break;
                        }
                     }
                  }
               if(foundobject > 0)
                  break;
               rlc = rlc->next;
               }
            if(foundobject == 0) /** see if any point objects satisfy criteria **/
               {
               rpc = Proot;
               while(rpc != NULL)
                  {
                  if((rpc->numverts < 1) && (rpc->numverts > -3) &&
                      (CombinedCheckApplies(rpc->idn,checkinstance,AWITHOUTA,
                             rpc->Lindex,rpc->Sindex,SCCtable[rpc->Sindex].C,SCCtable[rpc->Sindex].S,SCCtable[rpc->Sindex].D,
                      &part1,&part2,&part3) > 0) && (part2 > 0))
                     {
                     if((rac->numverts == 3) && (PointInsideTriangle(rpc->x[0],rpc->y[0], rac->x[0], rac->y[0],
                                         rac->x[1], rac->y[1], rac->x[2], rac->y[2]) > 0))
                        {
                        rah = root;
                        PassCond = 0;
                        while(rah != NULL)
                           {
                           if((rah != rac) && (rah->ishole > 0) && (rah->idn == rac->idn))
                              {
                              if(rah->RB_Tree_Edgelist == NULL)
                                 {
                                 PassCond = PointInAreal(rpc->x[0], rpc->y[0], rah->x,rah->y,rah->numverts, &iii);
                                 }
                              else
                                 {
                                 PassCond = PointInsideLargeAreal(rpc->x[0], rpc->y[0], rah, &iii);
                                 }
                              }
                           rah = rah->next;
                           }
                        if(PassCond == 0)
                           {
                           foundobject = 1;
                           }
                        }
                     else if((rac->numverts > 3) && (PointInsidePoly(rpc->x[0],rpc->y[0], rac->x, rac->y, rac->numverts) > 0))
                        {
                        rah = root;
                        PassCond = 0;
                        while(rah != NULL)
                           {
                           if((rah != rac) && (rah->ishole > 0) && (rah->idn == rac->idn))
                              {
                              if(rah->RB_Tree_Edgelist == NULL)
                                 {
                                 PassCond = PointInAreal(rpc->x[0], rpc->y[0], rah->x,rah->y,rah->numverts, &iii);
                                 }
                              else
                                 {
                                 PassCond = PointInsideLargeAreal(rpc->x[0], rpc->y[0], rah, &iii);
                                 }
                              }
                           rah = rah->next;
                           }
                        if(PassCond == 0)
                           {
                           foundobject = 1;
                           }
                        }
                     }
                  if(foundobject > 0)
                     break;
                  rpc = rpc->next;
                  }
               }
            if(foundobject == 0)
               {
               ran = root;
               while(ran != NULL)
                  {
                  if((rac->firstindex == cindex) || (ran->firstindex == cindex))
                     {
                     if((ran != rac) && (ran->ishole <= 0) && (ran->area < (rac->area * 1.01)))
                        {
                        if((CombinedCheckApplies(ran->idn,checkinstance,AWITHOUTA,
                            ran->Lindex,ran->Sindex,SCCtable[ran->Sindex].C,SCCtable[ran->Sindex].S,SCCtable[ran->Sindex].D,
                                  &part1,&part2,&part3) > 0) && (part2 > 0))
                           {
                           j = TwoArealsIntersect(rac, ran,&xi, &yi, &AOAindex2, &AOAindex1, &TouchingAreals);
                           if((j == 0) || (TouchingAreals > 0)) /**** no edge intersections - is one contained in the other?  ***/
                              {
                              CreatePointInsideAreal(ran,&px, &py);
                              if(rac->RB_Tree_Edgelist == NULL)
                                 j = PointIsInside(px, py, rac->x,rac->y,rac->x,rac->numverts,C_AREA,&unuseddbl);
                              else
                                 j = PointInsideLargeAreal(px, py,rac,&unusedint);
                              if(j > 0) /*** is inside the outer ring -- is it in a hole?  ****/
                                 {
                                 j = 0;
                                 rah = root;
                                 while(rah != NULL)
                                    {
                                    if((rah->ishole > 0) && (rah->idn == rac->idn))
                                       {
                                       if(AreaInsideArea(ran,rah,&xt3,&yt3) > 0)
                                          {
                                          break;
                                          }
                                       }
                                    rah = rah->next;
                                    }
                                 if(rah == NULL)
                                    {
                                    foundobject = 1;
                                    break;  /*** should break from the while ran loop ***/
                                    }
                                 }  /*** end testing to see if ran is in a hole of rac ***/
                              }
                           } /*** end check applies to the second area feature ***/
                        }
                     }
                  ran = ran->next;
                  }
               }
            if((foundobject == 0) && (NGT != NULL))
               {
               foundobject = CheckGridsForContainment(AWITHOUTA,cindex,checkinstance,rac,root,minx,miny,maxx,maxy);
               }

            if((foundobject == 0) && (ActiveChecks[checkinstance].UseBorderConds == 0)) /** do we need to remove condition on project boundary? ***/
               {
               checkit2 = 0;
               if(rac->ismulti == 0)
                  checkit2 = 1;
               else  /*** must be a multi-region area feature ... ****/
                  {
                  checkit2 = 1;
                  RB_newKey2 = rac->localID + (checkinstance * 0.0001);
                  if(( RB_newNode = RBExactQuery(Check_RB_Tree,&RB_newKey2))) /** if it is already in the tree, maybe don't need to do this again ***/
                     {
                     RB_cond = (struct ConditionCollection *) RB_newNode->info;
                     if(RB_cond->counter > 0)
                        checkit2 = 0;
                     }
                  }
               if(checkit2 > 0)
                  {
                  checkit = 1;
                  if((NorthCount <= 0) || (SouthCount <= 0) || (EastCount <= 0) || (WestCount <= 0))
                     {
                     maxXindex = minXindex = maxYindex = minYindex = 0;
                     for(i=1; i<rac->numverts; i++)
                        {
                        if(rac->x[i] > rac->x[maxXindex])
                           maxXindex = i;
                        if(rac->x[i] < rac->x[minXindex])
                           minXindex = i;
                        if(rac->y[i] > rac->y[maxYindex])
                           maxYindex = i;
                        if(rac->y[i] < rac->y[minYindex])
                           minYindex = i;
                        }
                     if(EastCount <= 0)
                        {
                        if(maxXindex == 0)
                           {
                           i = 1;
                           j = rac->numverts - 1;
                           }
                        else
                           {
                           i = maxXindex - 1;
                           j = i + 1;
                           if(j >= rac->numverts)
                              j = 0;
                           }
                        checkit = ConditionOnDataEdge(rac->x[i],rac->y[i],rac->x[maxXindex],rac->y[maxXindex],root,Proot,Lroot,
                                              rac, NULL, NULL,100,100,EastCount,100,checkinstance);
                        if(checkit > 0)
                           checkit = ConditionOnDataEdge(rac->x[j],rac->y[j],rac->x[maxXindex],rac->y[maxXindex],root,Proot,Lroot,
                                              rac, NULL, NULL,100,100,EastCount,100,checkinstance);
                        }
                     if((checkit > 0) && (WestCount <= 0))
                        {
                        if(minXindex == 0)
                           {
                           i = 1;
                           j = rac->numverts - 1;
                           }
                        else
                           {
                           i = minXindex - 1;
                           j = i + 1;
                           if(j >= rac->numverts)
                              j = 0;
                           }
                        checkit = ConditionOnDataEdge(rac->x[i],rac->y[i],rac->x[minXindex],rac->y[minXindex],root,Proot,Lroot,
                                              rac, NULL, NULL,100,100,100,WestCount,checkinstance);
                        if(checkit > 0)
                           checkit = ConditionOnDataEdge(rac->x[j],rac->y[j],rac->x[minXindex],rac->y[minXindex],root,Proot,Lroot,
                                              rac, NULL, NULL,100,100,100,WestCount,checkinstance);
                        }

                     if((checkit > 0) && (SouthCount <= 0))
                        {
                        if(minYindex == 0)
                           {
                           i = 1;
                           j = rac->numverts - 1;
                           }
                        else
                           {
                           i = minYindex - 1;
                           j = i + 1;
                           if(j >= rac->numverts)
                              j = 0;
                           }
                        checkit = ConditionOnDataEdge(rac->x[i],rac->y[i],rac->x[minYindex],rac->y[minYindex],root,Proot,Lroot,
                                              rac, NULL, NULL,100,SouthCount,100,100,checkinstance);
                        if(checkit > 0)
                           checkit = ConditionOnDataEdge(rac->x[j],rac->y[j],rac->x[minYindex],rac->y[minYindex],root,Proot,Lroot,
                                              rac, NULL, NULL,100,SouthCount,100,100,checkinstance);
                        }

                     if((checkit > 0) && (NorthCount <= 0))
                        {
                        if(maxYindex == 0)
                           {
                           i = 1;
                           j = rac->numverts - 1;
                           }
                        else
                           {
                           i = maxYindex - 1;
                           j = i + 1;
                           if(j >= rac->numverts)
                              j = 0;
                           }
                        checkit = ConditionOnDataEdge(rac->x[i],rac->y[i],rac->x[maxYindex],rac->y[maxYindex],root,Proot,Lroot,
                                              rac, NULL, NULL,NorthCount,100,100,100,checkinstance);
                        if(checkit > 0)
                           checkit = ConditionOnDataEdge(rac->x[j],rac->y[j],rac->x[maxYindex],rac->y[maxYindex],root,Proot,Lroot,
                                              rac, NULL, NULL,NorthCount,100,100,100,checkinstance);
                        }
                     }
                  if(checkit <= 0)
                     foundobject = 1;
                  }
               }

            if(rac->ismulti == 0) /** if is a single region feature, know everything required now ... ***/
               {
               if(foundobject == 0) /** couldn't find specified point or line object in this area feature **/
                  {
                  ERc = (struct collection *) (malloc(SzC));
                  if(ERc == NULL)
                     {
                     printf("allocation memory exhausted during area feature condition analysis\n");
                     printf("processing cannot continue\n");
                     exit(-1);
                     }
                  ERc->magnitude = 0;
                  ERc->keyval = AWITHOUTA;
                  ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                  ERc->Sindex1 = rac->Sindex;
                  ERc->aa = rac;
                  ERc->next = NULL;
                  if(ERroot == NULL)
                     {
                     ERroot = ERc;
                     }
                  else
                     {
                     ERn = ERroot;
                     while(ERn != NULL)
                        {
                        if(
                           (ERn->Cnumber    == ERc->Cnumber)    &&
                           (ERn->keyval    == ERc->keyval)    &&
                           (ERn->aa == ERc->aa)
                           )
                           break;
                        ERn = ERn->next;
                        }
                     if(ERn == NULL)
                        {
                        ERc->next = ERroot;
                        ERroot = ERc;
                        }
                     else
                        free(ERc);
                     }
                  }
               }
            else  /*** must be a multi-region area feature ... ****/
               {
               PassCond2 = 0;
               RB_newKey2 = rac->localID + (checkinstance * 0.0001);
               if(( RB_newNode = RBExactQuery(Check_RB_Tree,&RB_newKey2)))
                  {
                  RB_cond = (struct ConditionCollection *) RB_newNode->info;
                  RB_cond->counter += foundobject;
                  }
               else
                  {
                  RB_cond = (struct ConditionCollection *) (malloc(SzCC));
                  if(RB_cond == NULL)
                     {
                     printf("memory has been exhausted during RB-Tree information alloction for AWITHOUTA analysis\n");
                     exit(-1);
                     }
                  RB_cond->keyval = AWITHOUTA;
                  RB_cond->Cnumber =  Make_Correct(AWITHOUTA,checkinstance);
                  RB_cond->index_from_to = NULL;
                  RB_cond->gform = G_AREAL;
                  RB_cond->featureidn = rac->featureid;
                  RB_cond->localID = rac->localID;
                  RB_cond->counter = foundobject;
                  RB_cond->radius = -1;
                  RB_cond->height = -1;
                  RB_cond->magnitude = 0.0;
                  RB_cond->IDN = rac->idn;
                  RB_cond->Sindex = rac->Sindex;
                  RB_cond->Lindex = rac->Lindex;

                  RB_cond->numnodes = rac->numverts;
                  RB_cond->x = (double *) (malloc(RB_cond->numnodes * SzD));
                  RB_cond->y = (double *) (malloc(RB_cond->numnodes * SzD));
                  RB_cond->z = (double *) (malloc(RB_cond->numnodes * SzD));
                  if(RB_cond->z == NULL)
                     {
                     printf("memory has been exhausted during RB-Tree element vertex alloction for AWITHOUTA analysis\n");
                     exit(-1);
                     }
                  for(jj=0; jj< rac->numverts; jj++)
                     {
                     RB_cond->x[jj] = rac->x[jj];
                     RB_cond->y[jj] = rac->y[jj];
                     RB_cond->z[jj] = rac->z[jj];
                     }

                  RB_newDbl = (double *) (malloc(SzD));
                  if(RB_newDbl == NULL)
                     {
                     printf("memory has been exhausted during RB-Tree alloction for AWITHOUTA analysis\n");
                     exit(-1);
                     }
                  *RB_newDbl = RB_newKey2; /**rac->localID; **/
                  RBTreeInsert(Check_RB_Tree,RB_newDbl, RB_cond);
                  } /*** end treating multi-region area for AWITHOUTA ***/
               }
            } /*** end AWITHOUTA check for areals  containing points, lines**/




          if((CombinedCheckApplies(rac->idn,checkinstance,COINCIDEFAIL,rac->Lindex,rac->Sindex,
                Config1,Strat1,Domain1, &part1,&part2,&part3) > 0) &&
              (part1 > 0))
            {
            foundobject = 0;
            for(i=0; i<rac->numverts; i++)
               {
               if(i == 0)
                  j = rac->numverts - 1;
               else
                  j = i - 1;

               found_two = 0;
               checkit = 0;
               if(rac->ismulti == 0)
                  checkit = 1;
               else if((rac->x[j] < rac->x[i]) && (rac->x[j] <= maxx) && (rac->x[i] >= minx))
                  {
                  if((rac->y[j] < rac->y[i]) && (rac->y[j] <= maxy) && (rac->y[i] >= miny))
                     checkit = 1;
                  else if((rac->y[i] <= maxy) && (rac->y[j] >= miny))
                     checkit = 1;
                  }
               else if((rac->x[i] <= maxx) && (rac->x[j] >= minx))
                  {
                  if((rac->y[j] < rac->y[i]) && (rac->y[j] <= maxy) && (rac->y[i] >= miny))
                     checkit = 1;
                  else if((rac->y[i] <= maxy) && (rac->y[j] >= miny))
                     checkit = 1;
                  }
               if(checkit > 0)
                  {
                  rlc = Lroot;
                  while(rlc != NULL)
                     {
                     if((CombinedCheckApplies(rlc->idn,checkinstance,COINCIDEFAIL,rlc->Lindex,rlc->Sindex,
                             SCCtable[rlc->Sindex].C,SCCtable[rlc->Sindex].S,SCCtable[rlc->Sindex].D,
                               &part1,&part2,&part3) > 0) && (part2 > 0))
                        {
                        if((rlc->x[0] >= minx) && (rlc->x[0] <= maxx) && (rlc->y[0] >= miny) && (rlc->y[0] <= maxy))
                           {
                           ptldist1 = PointToLineDist2D(rlc->x[0],rlc->y[0],rac->x[j],rac->y[j],rac->x[i],rac->y[i]);
                           if(SensitivityCheck(LTEQ, COINCIDEFAIL, checkinstance, ptldist1) > 0)
                              found_two += 1;
                           else if((rlc->x[rlc->numnodes-1] >= minx) && (rlc->x[rlc->numnodes-1] <= maxx) &&
                                       (rlc->y[rlc->numnodes-1] >= miny) && (rlc->y[rlc->numnodes-1] <= maxy))
                              {
                              ptldist1 = PointToLineDist2D(rlc->x[rlc->numnodes-1],rlc->y[rlc->numnodes-1],rac->x[j],rac->y[j],rac->x[i],rac->y[i]);
                              if(SensitivityCheck(LTEQ, COINCIDEFAIL, checkinstance, ptldist1) > 0)
                                 found_two += 1;
                              }
                           }
                        else if((rlc->x[rlc->numnodes-1] >= minx) && (rlc->x[rlc->numnodes-1] <= maxx) && 
                                       (rlc->y[rlc->numnodes-1] >= miny) && (rlc->y[rlc->numnodes-1] <= maxy))
                           {
                           ptldist1 = PointToLineDist2D(rlc->x[rlc->numnodes-1],rlc->y[rlc->numnodes-1],rac->x[j],rac->y[j],rac->x[i],rac->y[i]);
                           if(SensitivityCheck(LTEQ, COINCIDEFAIL, checkinstance, ptldist1) > 0)
                              found_two += 1;
                           }
                        if(found_two > 1)
                           {
                           found_one = 1;
                           break;
                           }
                        }
                     rlc = rlc->next;
                     }

                  if(found_two < 2)
                     {
                     ran = root;
                     while(ran != NULL) 
                        {
                        if((CombinedCheckApplies(ran->idn,checkinstance,COINCIDEFAIL,ran->Lindex,ran->Sindex,
                             SCCtable[ran->Sindex].C,SCCtable[ran->Sindex].S,SCCtable[ran->Sindex].D,
                               &part1,&part2,&part3) > 0) && (part2 > 0))
                           {
                           if(ran->RB_Tree_Edgelist == NULL)
                              {
                              for(ii=0; ii<ran->numverts; ii++)
                                 {
                                 if(ii == 0)
                                    jj = ran->numverts - 1;
                                 else
                                    jj = ii - 1;
                                 checkit2 = 0;
                                 if(ran->ismulti == 0)
                                    checkit2 = 1;
                                 else if((ran->x[jj] < ran->x[ii]) && (ran->x[jj] <= maxx) && (ran->x[ii] >= minx))
                                    {
                                    if((ran->y[jj] < ran->y[ii]) && (ran->y[jj] <= maxy) && (ran->y[ii] >= miny))
                                       checkit2 = 1;
                                    else if((ran->y[ii] <= maxy) && (ran->y[jj] >= miny))
                                       checkit2 = 1;
                                    }
                                 else if((ran->x[ii] <= maxx) && (ran->x[jj] >= minx))
                                    {
                                    if((ran->y[jj] < ran->y[ii]) && (ran->y[jj] <= maxy) && (ran->y[ii] >= miny))
                                       checkit2 = 1;
                                    else if((ran->y[ii] <= maxy) && (ran->y[jj] >= miny))
                                       checkit2 = 1;
                                    }
                                 if(checkit2 > 0)
                                    {
                                    if(LineSegmentsOverlap(rac->x[j],rac->y[j],rac->x[i],rac->y[i],
                                                 ran->x[jj],ran->y[jj],ran->x[ii],ran->y[ii],
                                                 &xi, &yi, &xi2, &yi2, ActiveChecks[checkinstance].sensitivity) > 0)
                                       {
                                       found_two += 1;
                                       break; /*** breaks from the for ii loop ***/
                                       }
                                    }
                                 }
                              }
                           else /**** a rb-tree, large areal ***/
                              {
                              LastEdge = NULL;
                              LastI = -1;
                              ii = GetNextArealIndex(ran, LastI, 1, &LastEdge, cindex, &unusedint);
                              LastI = ii;
                              while(ii >= 0)
                                 {
                                 if(ii == 0)
                                    jj = ran->numverts - 1;
                                 else
                                    jj = ii - 1;
                                 checkit2 = 0;
                                 if(ran->ismulti == 0)
                                    checkit2 = 1;
                                 else if((ran->x[jj] < ran->x[ii]) && (ran->x[jj] <= maxx) && (ran->x[ii] >= minx))
                                    {
                                    if((ran->y[jj] < ran->y[ii]) && (ran->y[jj] <= maxy) && (ran->y[ii] >= miny))
                                       checkit2 = 1;
                                    else if((ran->y[ii] <= maxy) && (ran->y[jj] >= miny))
                                       checkit2 = 1;
                                    }
                                 else if((ran->x[ii] <= maxx) && (ran->x[jj] >= minx))
                                    {
                                    if((ran->y[jj] < ran->y[ii]) && (ran->y[jj] <= maxy) && (ran->y[ii] >= miny))
                                       checkit2 = 1;
                                    else if((ran->y[ii] <= maxy) && (ran->y[jj] >= miny))
                                       checkit2 = 1;
                                    }
                                 if(checkit2 > 0)
                                    {
                                    if(LineSegmentsOverlap(rac->x[j],rac->y[j],rac->x[i],rac->y[i],
                                                 ran->x[jj],ran->y[jj],ran->x[ii],ran->y[ii],
                                                 &xi, &yi, &xi2, &yi2, ActiveChecks[checkinstance].sensitivity) > 0)
                                       {
                                       found_two += 1;
                                       break; /*** breaks from the while ii loop ***/
                                       }
                                    }
                                 ii = GetNextArealIndex(ran, LastI, 1, &LastEdge, cindex, &unusedint);
                                 LastI = ii;
                                 }
                              }
                           }
                        if(found_two > 1)
                           {
                           found_one = 1;
                           break;
                           }
                        ran = ran->next;
                        }
                     }
                  }  /*** end if segment is in this lm  (checkit > 0) ***/
               if(found_two > 1)
                  break;
               } /*** end for(i=0; i<rac->numverts; i++) ***/
               
            if(rac->ismulti == 0) /** if is a single region feature, know everything required now ... ***/
               {
               if(found_two < 2) /** couldn't find specified point or line object in this area feature **/
                  {
                  ERc = (struct collection *) (malloc(SzC));
                  if(ERc == NULL)
                     {
                     printf("allocation memory exhausted during area feature condition analysis\n");
                     printf("processing cannot continue\n");
                     exit(-1);
                     }
                  ERc->magnitude = 0;
                  ERc->keyval = COINCIDEFAIL;
                  ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                  ERc->Sindex1 = rac->Sindex;
                  ERc->aa = rac;
                  ERc->next = NULL;
                  if(ERroot == NULL)
                     {
                     ERroot = ERc;
                     }
                  else
                     {
                     ERn = ERroot;
                     while(ERn != NULL)
                        {
                        if((ERn->Cnumber == ERc->Cnumber) && (ERn->keyval == ERc->keyval) && (ERn->aa == ERc->aa))
                           break;
                        ERn = ERn->next;
                        }
                     if(ERn == NULL)
                        {
                        ERc->next = ERroot;
                        ERroot = ERc; 
                        }
                     else
                        free(ERc);
                     }
                  }
               }
            else  /*** must be a multi-region area feature ... ****/
               {
               RB_newKey2 = rac->localID + (checkinstance * 0.0001);
               if(( RB_newNode = RBExactQuery(Check_RB_Tree,&RB_newKey2)))
                  {
                  RB_cond = (struct ConditionCollection *) RB_newNode->info;
                  if(RB_cond->counter < 2)
                     RB_cond->counter += found_two;
                  }
               else
                  {
                  RB_cond = (struct ConditionCollection *) (malloc(SzCC));
                  if(RB_cond == NULL)
                     {
                     printf("memory has been exhausted during RB-Tree information alloction for COINCIDEFAIL analysis\n");
                     exit(-1); 
                     }
                  RB_cond->keyval = COINCIDEFAIL;
                  RB_cond->Cnumber =  Make_Correct(COINCIDEFAIL,checkinstance);
                  RB_cond->index_from_to = NULL;
                  RB_cond->gform = G_AREAL;
                  RB_cond->featureidn = rac->featureid;
                  RB_cond->localID = rac->localID;
                  RB_cond->counter = found_two;
                  RB_cond->radius = -1;
                  RB_cond->height = -1;
                  RB_cond->magnitude = 0.0;
                  RB_cond->IDN = rac->idn;
                  RB_cond->Sindex = rac->Sindex;
                  RB_cond->Lindex = rac->Lindex;

                  RB_cond->numnodes = rac->numverts;
                  RB_cond->x = (double *) (malloc(RB_cond->numnodes * SzD));
                  RB_cond->y = (double *) (malloc(RB_cond->numnodes * SzD));
                  RB_cond->z = (double *) (malloc(RB_cond->numnodes * SzD));
                  if(RB_cond->z == NULL)
                     {
                     printf("memory has been exhausted during RB-Tree element vertex alloction for COINCIDEFAIL analysis\n");
                     exit(-1);
                     }
                  for(jj=0; jj< rac->numverts; jj++)
                     {
                     RB_cond->x[jj] = rac->x[jj];
                     RB_cond->y[jj] = rac->y[jj];
                     RB_cond->z[jj] = rac->z[jj];
                     }

                  RB_newDbl = (double *) (malloc(SzD));
                  if(RB_newDbl == NULL)
                     {
                     printf("memory has been exhausted during RB-Tree alloction for COINCIDEFAIL analysis\n");
                     exit(-1);
                     }
                  *RB_newDbl = RB_newKey2; /**rac->localID; **/
                  RBTreeInsert(Check_RB_Tree,RB_newDbl, RB_cond);
                  } /*** end treating multi-region area for COINCIDEFAIL ***/
               }
            } /*** end COINCIDEFAIL check for areals **/




          if((CombinedCheckApplies(rac->idn,checkinstance,ISOLATEDA,rac->Lindex,rac->Sindex,
                Config1,Strat1,Domain1, &part1,&part2,&part3) > 0) && /***(rac->ishole <= 0) && ***/
              (part1 > 0))
            {
            foundobject = 0;
            checkit = 1;
             if((NorthCount <= 0) || (SouthCount <= 0) || (EastCount <= 0) || (WestCount <= 0))
                {
                maxXindex = minXindex = maxYindex = minYindex = -1;
                for(i=0; i<rac->numverts; i++)
                   {
                   if((rac->x[i] >= minx) && (rac->x[i] <= maxx) && (rac->y[i] >= miny) && (rac->y[i] <= maxy))
                      {
                      if((maxXindex < 0) || (rac->x[i] > rac->x[maxXindex]))
                         maxXindex = i;
                      if((minXindex < 0) || (rac->x[i] < rac->x[minXindex]))
                         minXindex = i;
                      if((maxYindex < 0) || (rac->y[i] > rac->y[maxYindex]))
                         maxYindex = i;
                      if((minYindex < 0) || (rac->y[i] < rac->y[minYindex]))
                         minYindex = i;
                      }
                   }
                checkit = 1;

                if((maxXindex >= 0) && (EastCount <= 0))
                   {
                   if(maxXindex == 0)
                      i = 1;
                   else
                      i = maxXindex - 1;
                   checkit = ConditionOnDataEdge(rac->x[i],rac->y[i],rac->x[maxXindex],rac->y[maxXindex],root,Proot,Lroot,
                                              rac, NULL, NULL,100,100,EastCount,100,checkinstance);
                   }
                if((minXindex >= 0) && (checkit > 0) && (WestCount <= 0))
                   {
                   if(minXindex == 0)
                      i = 1;
                   else
                      i = minXindex - 1;
                   checkit = ConditionOnDataEdge(rac->x[i],rac->y[i],rac->x[minXindex],rac->y[minXindex],root,Proot,Lroot,
                                              rac, NULL, NULL,100,100,100,WestCount,checkinstance);
                   }
                if((minYindex >= 0) && (checkit > 0) && (SouthCount <= 0))
                   {
                   if(minYindex == 0)
                      i = 1;
                   else
                      i = minYindex - 1;
                   checkit = ConditionOnDataEdge(rac->x[i],rac->y[i],rac->x[minYindex],rac->y[minYindex],root,Proot,Lroot,
                                              rac, NULL, NULL,100,SouthCount,100,100,checkinstance);
                   }
                if((maxYindex >= 0) && (checkit > 0) && (NorthCount <= 0))
                   {
                   if(maxYindex == 0)
                      i = 1;
                   else
                      i = maxYindex - 1;
                   checkit = ConditionOnDataEdge(rac->x[i],rac->y[i],rac->x[maxYindex],rac->y[maxYindex],root,Proot,Lroot,
                                              rac, NULL, NULL, NorthCount,100,100,100,checkinstance);
                   }
                }

            if(checkit <= 0)
               foundobject = 1;

            if((checkit > 0) && (rac->RB_Tree_Edgelist == NULL))
               {
               for(ii=0; ii<rac->numverts; ii++)
                  {
                  if(ii == 0)
                     jj = rac->numverts - 1;
                  else
                     jj = ii - 1;
                  checkit2 = 0;
                  if(rac->ismulti == 0)
                     checkit2 = 1;
                  else if((rac->x[jj] < rac->x[ii]) && (rac->x[jj] <= maxx) && (rac->x[ii] >= minx))
                     {
                     if((rac->y[jj] < rac->y[ii]) && (rac->y[jj] <= maxy) && (rac->y[ii] >= miny))
                        checkit2 = 1;
                     else if((rac->y[ii] <= maxy) && (rac->y[jj] >= miny))
                        checkit2 = 1;
                     }
                  else if((rac->x[ii] <= maxx) && (rac->x[jj] >= minx))
                     {
                     if((rac->y[jj] < rac->y[ii]) && (rac->y[jj] <= maxy) && (rac->y[ii] >= miny))
                        checkit2 = 1;
                     else if((rac->y[ii] <= maxy) && (rac->y[jj] >= miny))
                        checkit2 = 1;
                     }
                  if(checkit2 > 0)
                     {
                     if(rac->x[jj] < rac->x[ii])
                        {
                        L1minx = rac->x[jj];
                        L1maxx = rac->x[ii];
                        }
                     else
                        {
                        L1maxx = rac->x[jj];
                        L1minx = rac->x[ii];
                        }
                     if(rac->y[jj] < rac->y[ii])
                        {
                        L1miny = rac->y[jj];
                        L1maxy = rac->y[ii];
                        }
                     else
                        {
                        L1maxy = rac->y[jj];
                        L1miny = rac->y[ii];
                        }

                     rlc = Lroot;
                     while(rlc != NULL)
                        {
                        if((CombinedCheckApplies(rlc->idn,checkinstance,ISOLATEDA,
                               rlc->Lindex,rlc->Sindex,SCCtable[rlc->Sindex].C,SCCtable[rlc->Sindex].S,SCCtable[rlc->Sindex].D,
                                &part1,&part2,&part3) > 0) && (part2 > 0))
                           {
                           for(kk=1; kk<rlc->numnodes; kk++)
                              {
                              if(LineSegmentsIntersect(rlc->x[kk-1],rlc->y[kk-1],rlc->x[kk],rlc->y[kk],
                               rac->x[ii],rac->y[ii],rac->x[jj],rac->y[jj], &xint, &yint) > 0)
                                 {
                                 foundobject = 1;
                                 break;
                                 }
                              else if(MergeSeg_LineSegmentsOverlap(rlc->x[kk-1],rlc->y[kk-1],rlc->x[kk],rlc->y[kk],
                                    rac->x[ii],rac->y[ii],rac->x[jj],rac->y[jj], L1minx,L1maxx,L1miny,L1maxy,
                                    &x1, &y1, &x2, &y2, 0.0001) > 0)
                                 {
                                 foundobject = 1;
                                 break;
                                 }
                              else
                                 {
                                 unuseddbl = PointToLineDist(rlc->x[kk-1],rlc->y[kk-1],rlc->z[kk-1],
                                              rac->x[ii],rac->y[ii],rac->z[ii],rac->x[jj],rac->y[jj],rac->z[jj]);
                                ii3 = 99;
                                if(unuseddbl < ActiveChecks[checkinstance].sensitivity)
                                   {
                                   ii3 = PointIsInside(rlc->x[kk],rlc->y[kk],
                                             rac->x,rac->y,rac->x,rac->numverts,C_AREA,&unuseddbl);
                                   if(ii3 == 0)
                                      {
                                      foundobject = 1;
                                      break;
                                      }
                                   }
                                else
                                   {
                                   unuseddbl = PointToLineDist(rlc->x[kk],rlc->y[kk],rlc->z[kk],
                                           rac->x[ii],rac->y[ii],rac->z[ii],rac->x[jj],rac->y[jj],rac->z[jj]);
                                   if(unuseddbl < ActiveChecks[checkinstance].sensitivity)
                                      {
                                      if((ii3 == 0) ||
                                          (PointIsInside(rlc->x[kk-1],rlc->y[kk-1],
                                             rac->x,rac->y,rac->x,rac->numverts,C_AREA,&unuseddbl) == 0))
                                         {
                                         foundobject = 1;
                                         break;
                                         }
                                      }
                                   }
                                 }
                              }
                           }
                        if(foundobject > 0)
                           break;
                        rlc = rlc->next;
                        }
                     }
                  if(foundobject > 0)
                     break;
                  }
               }
            else if(checkit > 0) /**** a rb-tree, large areal ***/
               {
               LastEdge = NULL;
               LastI = -1;
               ii = GetNextArealIndex(rac, LastI, 1, &LastEdge, cindex, &unusedint);
               LastI = ii;
               while(ii >= 0)
                  {
                  if(ii == 0)
                     jj = rac->numverts - 1;
                  else
                     jj = ii - 1;
                  checkit2 = 0;
                  if(rac->ismulti == 0)
                     checkit2 = 1;
                  else if((rac->x[jj] < rac->x[ii]) && (rac->x[jj] <= maxx) && (rac->x[ii] >= minx))
                     {
                     if((rac->y[jj] < rac->y[ii]) && (rac->y[jj] <= maxy) && (rac->y[ii] >= miny))
                        checkit2 = 1;
                     else if((rac->y[ii] <= maxy) && (rac->y[jj] >= miny))
                        checkit2 = 1;
                     }
                  else if((rac->x[ii] <= maxx) && (rac->x[jj] >= minx))
                     {
                     if((rac->y[jj] < rac->y[ii]) && (rac->y[jj] <= maxy) && (rac->y[ii] >= miny))
                        checkit2 = 1;
                     else if((rac->y[ii] <= maxy) && (rac->y[jj] >= miny))
                        checkit2 = 1;
                     }
                  if(checkit2 > 0)
                     {
                     if(rac->x[jj] < rac->x[ii])
                        {
                        L1minx = rac->x[jj];
                        L1maxx = rac->x[ii];
                        }
                     else
                        {
                        L1maxx = rac->x[jj];
                        L1minx = rac->x[ii];
                        }
                     if(rac->y[jj] < rac->y[ii])
                        {
                        L1miny = rac->y[jj];
                        L1maxy = rac->y[ii];
                        }
                     else
                        {
                        L1maxy = rac->y[jj];
                        L1miny = rac->y[ii];
                        }

                     rlc = Lroot;
                     while(rlc != NULL)
                        {
                        if((CombinedCheckApplies(rlc->idn,checkinstance,ISOLATEDA,
                               rlc->Lindex,rlc->Sindex,SCCtable[rlc->Sindex].C,SCCtable[rlc->Sindex].S,SCCtable[rlc->Sindex].D,
                                &part1,&part2,&part3) > 0) && (part2 > 0))
                           {
                           for(kk=1; kk<rlc->numnodes; kk++)
                              {
                              if(LineSegmentsIntersect(rlc->x[kk-1],rlc->y[kk-1],rlc->x[kk],rlc->y[kk],
                               rac->x[ii],rac->y[ii],rac->x[jj],rac->y[jj], &xint, &yint) > 0)
                                 {
                                 foundobject = 1;
                                 break;
                                 }
                              else if(MergeSeg_LineSegmentsOverlap(rlc->x[kk-1],rlc->y[kk-1],rlc->x[kk],rlc->y[kk],
                                    rac->x[ii],rac->y[ii],rac->x[jj],rac->y[jj], L1minx,L1maxx,L1miny,L1maxy,
                                    &x1, &y1, &x2, &y2, 0.0001) > 0)
                                 {
                                 foundobject = 1;
                                 break;
                                 }
                              else
                                 {
                                 unuseddbl = PointToLineDist(rlc->x[kk-1],rlc->y[kk-1],rlc->z[kk-1],
                                              rac->x[ii],rac->y[ii],rac->z[ii],rac->x[jj],rac->y[jj],rac->z[jj]);
                                ii3 = 99;
                                if(unuseddbl < ActiveChecks[checkinstance].sensitivity)
                                   {
                                   ii3 = PointInsideLargeAreal(rlc->x[kk],rlc->y[kk],
                                             rac,&unusedint);
                                   if(ii3 == 0)
                                      {
                                      foundobject = 1;
                                      break;
                                      }
                                   }
                                else
                                   {
                                   unuseddbl = PointToLineDist(rlc->x[kk],rlc->y[kk],rlc->z[kk],
                                           rac->x[ii],rac->y[ii],rac->z[ii],rac->x[jj],rac->y[jj],rac->z[jj]);
                                   if(unuseddbl < ActiveChecks[checkinstance].sensitivity)
                                      {
                                      if((ii3 == 0) ||
                                          (PointInsideLargeAreal(rlc->x[kk-1],rlc->y[kk-1],
                                             rac,&unusedint) == 0))
                                         {
                                         foundobject = 1;
                                         break;
                                         }
                                      }
                                   }
                                 }

                              }
                           }
                        if(foundobject > 0)
                           break;
                        rlc = rlc->next;
                        }
                     }
                  if(foundobject > 0)
                      break;
                  ii = GetNextArealIndex(rac, LastI, 1, &LastEdge, cindex, &unusedint);
                  LastI = ii;
                  }
               }
            if((checkit > 0) && (foundobject < 1))  /*** then see if there is an area - area intersection ***/
               {
               ran = root;
               while(ran != NULL)
                  {
                  PassCond = 0;
                  if(ran != rac)
                     {
                     if((CombinedCheckApplies(ran->idn,checkinstance,ISOLATEDA,ran->Lindex,ran->Sindex,SCCtable[ran->Sindex].C,
                                SCCtable[ran->Sindex].S,SCCtable[ran->Sindex].D,&part1,&part2,&part3) > 0) &&
                            (part2 > 0))
                        {
                        PassCond = 1;
                        }
                     }
                  if(PassCond > 0)
                     {
                     foundobject += TwoArealsIntersect(rac, ran, &xi, &yi, &AOAindex1, &AOAindex2, &TouchingAreals);
foundobject += TouchingAreals;
                     }
                  if(foundobject > 0)
                     break;
                  else if(PassCond > 0) /*** see if edges 'almost' intersect .... ***/
                     {
                     if(rac->RB_Tree_Edgelist == NULL)
                        {
                        for(ii=0; ii<rac->numverts; ii++)
                           {
                           if(ii == 0)
                              jj = rac->numverts - 1;
                           else
                              jj = ii - 1;
                           checkit2 = 0;
                           if(rac->ismulti == 0)
                              checkit2 = 1;
                           else if((rac->x[jj] < rac->x[ii]) && (rac->x[jj] <= maxx) && (rac->x[ii] >= minx))
                              {
                              if((rac->y[jj] < rac->y[ii]) && (rac->y[jj] <= maxy) && (rac->y[ii] >= miny))
                                 checkit2 = 1;
                              else if((rac->y[ii] <= maxy) && (rac->y[jj] >= miny))
                                 checkit2 = 1;
                              }
                           else if((rac->x[ii] <= maxx) && (rac->x[jj] >= minx))
                              {
                              if((rac->y[jj] < rac->y[ii]) && (rac->y[jj] <= maxy) && (rac->y[ii] >= miny))
                                 checkit2 = 1;
                              else if((rac->y[ii] <= maxy) && (rac->y[jj] >= miny))
                                 checkit2 = 1;
                              }
                           if(checkit2 > 0)
                              {
                              if(ran->RB_Tree_Edgelist != NULL)
                                 {
                                 if((PointWithinToleranceOfLargeArealEdge(rac->x[ii],rac->y[ii],ran,&unuseddbl, &unusedint, 
                                                                          ActiveChecks[checkinstance].sensitivity) > 0) &&
                                       (PointInsideLargeAreal(rac->x[ii],rac->y[ii],
                                             ran,&unusedint) == 0))
                                    {
                                    foundobject = 1;
                                    break;
                                    }
                                 else if((PointWithinToleranceOfLargeArealEdge(rac->x[jj],rac->y[jj],ran,&unuseddbl, &unusedint,
                                                                          ActiveChecks[checkinstance].sensitivity) > 0) &&
                                       (PointInsideLargeAreal(rac->x[jj],rac->y[jj],
                                             ran,&unusedint) == 0))
                                    {
                                    foundobject = 1;
                                    break;
                                    }
                                 }
                              else
                                 {
                                 unuseddbl = PointToArealDist2D(rac->x[ii],rac->y[ii],ran);
                                 if((unuseddbl < ActiveChecks[checkinstance].sensitivity) &&
                                       (PointInsidePoly(rac->x[ii],rac->y[ii],
                                             ran->x,ran->y,ran->numverts) == 0))
                                    {
                                    foundobject = 1;
                                    break;
                                    }
                                 else
                                    {
                                    unuseddbl = PointToArealDist2D(rac->x[jj],rac->y[jj],ran);
                                    if((unuseddbl < ActiveChecks[checkinstance].sensitivity) &&
                                          (PointInsidePoly(rac->x[jj],rac->y[jj],
                                             ran->x,ran->y,ran->numverts) == 0))
                                       {
                                       foundobject = 1;
                                       break;
                                       }
                                    }

                                 }
                              }
                           } /*** end for ****/
                        } /*** end non-large area case ***/

                     }
                  ran = ran->next;
                  }
               }

            if((checkit > 0) && (rac->ismulti == 0) && (rac->ishole == 0))
               {
               if(foundobject < 1) /** couldn't find specified area or line feature intersecting this area feature **/
                  {
                  ERc = (struct collection *) (malloc(SzC));
                  if(ERc == NULL)
                     {
                     printf("allocation memory exhausted during area feature condition analysis\n");
                     printf("processing cannot continue\n");
                     exit(-1);
                     }
                  ERc->magnitude = 0;
                  ERc->keyval = ISOLATEDA;
                  ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                  ERc->Sindex1 = rac->Sindex;
                  ERc->aa = rac;
                  ERc->next = NULL;
                  if(ERroot == NULL)
                     {
                     ERroot = ERc;
                     }
                  else
                     {
                     ERn = ERroot;
                     while(ERn != NULL)
                        {
                        if((ERn->Cnumber == ERc->Cnumber) && (ERn->keyval == ERc->keyval) && (ERn->aa == ERc->aa))
                           break;
                        ERn = ERn->next;
                        }
                     if(ERn == NULL)
                        {
                        ERc->next = ERroot;
                        ERroot = ERc;
                        }
                     else
                        free(ERc);
                     }
                  }
               }
            else if((rac->ismulti > 0) || (rac->ishole < 0))
/*** must be a multi-region area feature or one having holes... ****/
               {
               RB_newKey2 = rac->idn + (checkinstance * 0.0001); /*** was  rac->featureid ***/
               if(( RB_newNode = RBExactQuery(Check_RB_Tree,&RB_newKey2)))
                  {
                  RB_cond = (struct ConditionCollection *) RB_newNode->info;
                  if(RB_cond->counter < 2)
                     RB_cond->counter += foundobject;
                  }
               else
                  {
                  RB_cond = (struct ConditionCollection *) (malloc(SzCC));
                  if(RB_cond == NULL)
                     {
                     printf("memory has been exhausted during RB-Tree information alloction for ISOLATEDA analysis\n");
                     exit(-1);
                     }
                  RB_cond->keyval = ISOLATEDA;
                  RB_cond->Cnumber =  Make_Correct(ISOLATEDA,checkinstance);
                  RB_cond->index_from_to = NULL;
                  RB_cond->gform = G_AREAL;
                  RB_cond->featureidn = rac->featureid;
                  RB_cond->localID = rac->localID;
                     RB_cond->counter = foundobject;
                  RB_cond->radius = -1;
                  RB_cond->height = -1;
                  RB_cond->magnitude = 0.0;
                  RB_cond->IDN = rac->idn;
                  RB_cond->Sindex = rac->Sindex;
                  RB_cond->Lindex = rac->Lindex;

                  RB_cond->numnodes = rac->numverts;
                  RB_cond->x = (double *) (malloc(RB_cond->numnodes * SzD));
                  RB_cond->y = (double *) (malloc(RB_cond->numnodes * SzD));
                  RB_cond->z = (double *) (malloc(RB_cond->numnodes * SzD));
                  if(RB_cond->z == NULL)
                     {
                     printf("memory has been exhausted during RB-Tree element vertex alloction for ISOLATEDA analysis\n");
                     exit(-1);
                     }
                  for(jj=0; jj< rac->numverts; jj++)
                     {
                     RB_cond->x[jj] = rac->x[jj];
                     RB_cond->y[jj] = rac->y[jj];
                     RB_cond->z[jj] = rac->z[jj];
                     }

                  RB_newDbl = (double *) (malloc(SzD));
                  if(RB_newDbl == NULL)
                     {
                     printf("memory has been exhausted during RB-Tree alloction for ISOLATEDA analysis\n");
                     exit(-1);
                     }
                  *RB_newDbl = RB_newKey2; /**rac->localID; **/
                  RBTreeInsert(Check_RB_Tree,RB_newDbl, RB_cond);
                  } /*** end treating multi-region area for ISOLATEDA ***/
               }
            } /*** end ISOLATEDA check for areals **/






          if((CombinedCheckApplies(rac->idn,checkinstance,FSFAIL,rac->Lindex,rac->Sindex,
                Config1,Strat1,Domain1, &part1,&part2,&part3) > 0) && (rac->ishole <= 0) &&
              (part1 > 0))
            {
            foundobject = 0;
            ran = root;
            while(ran != NULL) {
               if((ran != rac) && (ran->ishole <= 0))
                  {
                  if((CombinedCheckApplies(ran->idn,checkinstance,FSFAIL,
                      ran->Lindex,ran->Sindex,SCCtable[ran->Sindex].C,SCCtable[ran->Sindex].S,SCCtable[ran->Sindex].D,
                            &part1,&part2,&part3) > 0) && (part2 > 0))
                     {
                     j = TwoArealsIntersect(rac, ran,&xi, &yi, &AOAindex2, &AOAindex1, &TouchingAreals);
                     if(j == 0) /**** no edge intersections - is one contained in the other?  ***/
                        {
                        CreatePointInsideAreal(rac,&px, &py);
                        if(ran->RB_Tree_Edgelist == NULL)
                           j = PointIsInside(px, py, ran->x,ran->y,ran->x,ran->numverts,C_AREA,&unuseddbl);
                        else
                           j = PointInsideLargeAreal(px, py,ran,&unusedint);
                           
                        if(j > 0) /*** is inside the outer ring -- is it in a hole?  ****/
                           {
                           j = 0;
                           rah = root;
                           while(rah != NULL)
                              {
                              if((rah->ishole > 0) && (rah->idn == ran->idn))
                                 {
                                 if(AreaInsideArea(rac,rah,&xt3,&yt3) > 1)
                                    {
                                    break;
                                    }
                                 }
                              rah = rah->next;
                              }
                           if(rah == NULL)
                              {
                              xi = rac->x[0];
                              yi = rac->y[0];
                              j = 1;
                              }
                           }
                        else if(j == 0)  /*** see if maybe ran is fully inside rac?  ***/
                           {
                           CreatePointInsideAreal(ran,&px, &py);
                           if(rac->RB_Tree_Edgelist == NULL)
                              j = PointIsInside(px, py, rac->x,rac->y,rac->x,rac->numverts,C_AREA,&unuseddbl);
                           else
                              j = PointInsideLargeAreal(px, py,rac,&unusedint);
                           if(j > 0) /*** is inside the outer ring -- is it in a hole?  ****/
                              {
                              j = 0;
                              rah = root;
                              while(rah != NULL)
                                 {
                                 if((rah->ishole > 0) && (rah->idn == rac->idn))
                                    { 
                                    if(AreaInsideArea(ran,rah,&xt3,&yt3) > 1)
                                       {
                                       break;
                                       }
                                    }
                                 rah = rah->next;
                                 }
                              if(rah == NULL)
                                 {
                                 xi = rac->x[0];
                                 yi = rac->y[0];
                                 j = 1; 
                                 }
                              }
                           }
                        }

                     if(j > 0)
                        {
                        foundobject = 1;
                        break; /*** should break from the while ran loop ***/
                        }
                     }
                  }
               ran = ran->next;
               }
               
            if(rac->ismulti == 0) /** if is a single region feature, know everything required now ... ***/
               {
               if(foundobject == 0) /** couldn't find specified point or line object in this area feature **/
                  {
                  ERc = (struct collection *) (malloc(SzC));
                  if(ERc == NULL)
                     {
                     printf("allocation memory exhausted during area feature condition analysis\n");
                     printf("processing cannot continue\n");
                     exit(-1);
                     }
                  ERc->magnitude = 0;
                  ERc->keyval = FSFAIL;
                  ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                  ERc->Sindex1 = rac->Sindex;
                  ERc->aa = rac;
                  ERc->next = NULL;
                  if(ERroot == NULL)
                     {
                     ERroot = ERc;
                     }
                  else
                     {
                     ERn = ERroot;
                     while(ERn != NULL)
                        {
                        if(
                           (ERn->Cnumber    == ERc->Cnumber)    &&
                           (ERn->keyval    == ERc->keyval)    &&
                           (ERn->aa == ERc->aa)
                           )
                           break;
                        ERn = ERn->next;
                        }
                     if(ERn == NULL)
                        {
                        ERc->next = ERroot;
                        ERroot = ERc; 
                        }
                     else
                        free(ERc);
                     }
                  }
               }
            else  /*** must be a multi-region area feature ... ****/
               {
               RB_newKey2 = rac->localID + (checkinstance * 0.0001);
               if(( RB_newNode = RBExactQuery(Check_RB_Tree,&RB_newKey2)))
                  {
                  RB_cond = (struct ConditionCollection *) RB_newNode->info;
                  RB_cond->counter += foundobject;
                  }
               else
                  {
                  RB_cond = (struct ConditionCollection *) (malloc(SzCC));
                  if(RB_cond == NULL)
                     {
                     printf("memory has been exhausted during RB-Tree information alloction for FSFAIL analysis\n");
                     exit(-1); 
                     }
                  RB_cond->keyval = FSFAIL;
                  RB_cond->Cnumber =  Make_Correct(FSFAIL,checkinstance);
                  RB_cond->index_from_to = NULL;
                  RB_cond->gform = G_AREAL;
                  RB_cond->featureidn = rac->featureid;
                  RB_cond->localID = rac->localID;
                  RB_cond->counter = foundobject;
                  RB_cond->radius = -1;
                  RB_cond->height = -1;
                  RB_cond->magnitude = 0.0;
                  RB_cond->IDN = rac->idn;
                  RB_cond->Sindex = rac->Sindex;
                  RB_cond->Lindex = rac->Lindex;

                  RB_cond->numnodes = rac->numverts;
                  RB_cond->x = (double *) (malloc(RB_cond->numnodes * SzD));
                  RB_cond->y = (double *) (malloc(RB_cond->numnodes * SzD));
                  RB_cond->z = (double *) (malloc(RB_cond->numnodes * SzD));
                  if(RB_cond->z == NULL)
                     {
                     printf("memory has been exhausted during RB-Tree element vertex alloction for FSFAIL analysis\n");
                     exit(-1);
                     }
                  for(jj=0; jj< rac->numverts; jj++)
                     {
                     RB_cond->x[jj] = rac->x[jj];
                     RB_cond->y[jj] = rac->y[jj];
                     RB_cond->z[jj] = rac->z[jj];
                     }

                  RB_newDbl = (double *) (malloc(SzD));
                  if(RB_newDbl == NULL)
                     {
                     printf("memory has been exhausted during RB-Tree alloction for FSFAIL analysis\n");
                     exit(-1);
                     }
                  *RB_newDbl = RB_newKey2; /**rac->localID; **/
                  RBTreeInsert(Check_RB_Tree,RB_newDbl, RB_cond);
                  } /*** end treating multi-region area for FSFAIL ***/
               }
            } /*** end FSFAIL check for areals **/




         if((CombinedCheckApplies(rac->idn,checkinstance,QUALANOCOVLA,rac->Lindex,rac->Sindex,Config1,Strat1,Domain1,&part1,&part2,&part3) > 0))
            {
            if(part1 > 0)
               {
               if(rac->RB_Tree_Edgelist != NULL)
                  {
                  LastEdge1 = NULL;
                  LastI = -1;
                  i = GetNextArealIndex(rac, LastI, 1, &LastEdge1, cindex, &UsedTree);
                  LastI = i;
                  }
               else
                  {
                  i = 0;
                  }
               while(i >= 0)
                  {
                  ii = i + 1;
                  if(ii == rac->numverts)
                     ii = 0;
                  x1 = rac->x[ii];
                  y1 = rac->y[ii];
                  z1 = rac->z[ii];
                  x2 = rac->x[i];
                  y2 = rac->y[i];
                  z2 = rac->z[i];
                  if(ClipLineToRegion(minx,miny,maxx,maxy,&x1,&y1,&z1,&x2,&y2,&z2,&clipflag,multiplier) > 0)
                     {
                     LenToCover = Distance(x1,y1,x2,y2);
                     CoveredSoFar = 0.0;
                     rlc = Lroot;
                     while((rlc != NULL) && (CoveredSoFar < LenToCover))
                        {
                        Config2 = SCCtable[rlc->Sindex].C;
                        Strat2 = SCCtable[rlc->Sindex].S;
                        Domain2 = SCCtable[rlc->Sindex].D;
                        if(CombinedCheckApplies(rlc->idn,checkinstance,QUALANOCOVLA,rlc->Lindex,rlc->Sindex,
                                     Config2,Strat2,Domain2,&part1,&part2,&part3) > 0)
                           {
                           if(part2 > 0)
                              {
                              for(j=1; j<rlc->numnodes; j++)
                                 {
                                 if(MatchLinearSegment2D(x1,y1,x2,y2,
                                                         rlc->x[j-1],rlc->y[j-1],rlc->x[j],rlc->y[j],&MatchLen,
                                                            ActiveChecks[checkinstance].sensitivity) > 0)
                                    {
                                    CoveredSoFar += MatchLen;
                                    if(CoveredSoFar >= LenToCover)
                                       break;
                                    }
                                 }
                              }
                           }
                        rlc = rlc->next;
                        }
                     if(CoveredSoFar < LenToCover) /*** check to see if another area feature edge will cover this one ***/
                        {
                        ran = root;
                        while((ran != NULL) && (CoveredSoFar < LenToCover))
                           {
                           if(ran != rac)
                              {
                              Config2 = SCCtable[ran->Sindex].C;
                              Strat2 = SCCtable[ran->Sindex].S;
                              Domain2 = SCCtable[ran->Sindex].D;
                              if(CombinedCheckApplies(ran->idn,checkinstance,QUALANOCOVLA,ran->Lindex,ran->Sindex,
                                     Config2,Strat2,Domain2,&part1,&part2,&part3) > 0)
                                 {
                                 if(part2 > 0)
                                    {
                                    if(ran->RB_Tree_Edgelist != NULL)
                                       {
                                       LastEdge2 = NULL;
                                       LastJ = -1;
                                       j = GetNextArealIndex(ran, LastJ, 1, &LastEdge2, cindex, &UsedTree);
                                       LastJ = j;
                                       }
                                    else
                                       {
                                       j = 0;
                                       }
                                    while(j >= 0)
                                       {
                                       if(j == 0)
                                          jj = ran->numverts - 1;
                                       else
                                          jj = j - 1;
                                       if(MatchLinearSegment2D(x1,y1,x2,y2,
                                                            ran->x[jj],ran->y[jj],ran->x[j],ran->y[j],&MatchLen,
                                                            ActiveChecks[checkinstance].sensitivity) > 0)
                                          {
                                          CoveredSoFar += MatchLen;
                                          if(CoveredSoFar >= LenToCover)
                                                break;
                                          }
                                       if(ran->RB_Tree_Edgelist != NULL)
                                          {
                                          j = GetNextArealIndex(ran, LastJ, 1, &LastEdge2, cindex, &UsedTree);
                                          LastJ = j;
                                          }
                                       else
                                          {
                                          ++j;
                                          if(j >= ran->numverts)
                                             j = -1;
                                          }
                                       }
                                    if(j == ran->numverts) /*** check last edge of area feature ***/
                                       {
                                       if(MatchLinearSegment2D(x1,y1,x2,y2,
                                                            ran->x[0],ran->y[0],ran->x[ran->numverts-1],ran->y[ran->numverts-1],&MatchLen,
                                                            ActiveChecks[checkinstance].sensitivity) > 0)
                                          {
                                          CoveredSoFar += MatchLen;
                                          }
                                       }
                                    }
                                 }
                              }
                           ran = ran->next;
                           }
                        }
                     if(CoveredSoFar < LenToCover)
                        {
                        ran = root;
                        PassCond2 = 0;
                        while(ran != NULL)
                           {
                           if((ran->ishole <= 0) &&
                               (CombinedCheckApplies(ran->idn,checkinstance,QUALANOCOVLA,ran->Lindex,ran->Sindex,
                                     SCCtable[ran->Sindex].C,SCCtable[ran->Sindex].S,SCCtable[ran->Sindex].D,&part1,&part2,&part3) > 0) &&
                               (part3 > 0))
                              {
                              PassCond2 = 0;
                              if(ran->RB_Tree_Edgelist == NULL)
                                 {
                                 PassCond2 = PointInAreal(x1, y1, ran->x,ran->y,ran->numverts, &iii);
                                 }
                              else
                                 {
                                 PassCond2 = PointInsideLargeAreal(x1, y1, ran, &iii);
                                 }
                              if(PassCond2 > 0)
                                 {
                                 rah = NULL;
                                 if(ran->ishole < 0)
                                    {
                                    rah = root;
                                    while(rah != NULL)
                                       {
                                       if((rah->ishole > 0) && (rah->featureid == ran->featureid))
                                          {
                                          if(PointInsideLargeAreal(x1, y1, rah, &iii) > 0)
                                             break;
                                          }

                                       rah = rah->next;
                                       }
                                    }
                                 if(rah == NULL)
                                    break;
                                 }
                              }

                           ran = ran->next;
                           }
                        if(ran == NULL)
                           CoveredSoFar = LenToCover * 2;
                        }
                     if(CoveredSoFar < LenToCover)
                        {
                        ERc = (struct collection *) (malloc(SzC));
                        if(ERc == NULL)
                           {
                           printf("allocation memory exhausted during linear feature condition analysis\n");
                           printf("processing cannot continue\n");
                           exit(-1);
                           }
                        ERc->x[0] = rac->x[i];
                        ERc->y[0] = rac->y[i];
                        ERc->z[0] = rac->z[i];
                        ERc->x[1] = rac->x[ii];
                        ERc->y[1] = rac->y[ii];
                        ERc->z[1] = rac->z[ii];
                        ERc->magnitude = 0.0;
                        ERc->keyval = QUALANOCOVLA;
                        ERc->Sindex1 = rac->Sindex;
                        ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                        ERc->aa = rac;
                        ERc->vertexindex1 = 0;
                        ERc->vertexindex2 = 0;
                        ERc->next = NULL;
                        if(ERroot == NULL)
                           {
                           ERroot = ERc;
                           }
                        else
                           {
                           ERn = ERroot;
                           while(ERn != NULL)
                              {
                              if((ERn->Cnumber == ERc->Cnumber) && (ERn->keyval == ERc->keyval) && (ERn->aa == ERc->aa) &&
                                 (ERn->x[0] == ERc->x[0]) && (ERn->y[0] == ERc->y[0]) &&
                                   (ERn->x[1] == ERc->x[1]) && (ERn->y[1] == ERc->y[1]))
                                 break;

                              ERn = ERn->next;
                              }
                           if(ERn == NULL)
                              {
                              ERc->next = ERroot;
                              ERroot = ERc;
                              }
                           else
                             free(ERc);
                           }
                        }
                     }
                  if(rac->RB_Tree_Edgelist != NULL)
                     {
                     i = GetNextArealIndex(rac, LastI, 1, &LastEdge1, cindex, &UsedTree);
                     LastI = i;
                     }
                  else
                     {
                     ++i;
                     if(i >= rac->numverts)
                        i = -1;
                     }
                  } /*** end while i >= 0  *******/
               } /*** end if part 1 ***/
            }  /*** end QUALANOCOVLA applies ***/



         if(/******(rac->firstindex == cindex) && (rac->ishole <= 0) && *****/ /**(rac->RB_Tree_Edgelist == NULL) && **/
              (CombinedCheckApplies(rac->idn,checkinstance,ANOCOVERLA,rac->Lindex,rac->Sindex,Config1,Strat1,Domain1,&part1,&part2,&part3) > 0))
            {
            Part1Save = part1;
            if(rac->ishole > 0)
               Part2Save = part2;
            else
               Part2Save = 0;
            if(Part2Save > 0)
               Part1Save = 0;
            if((Part1Save > 0) || (Part2Save > 0))
               {
               if(rac->RB_Tree_Edgelist != NULL)
                  {
                  LastEdge1 = NULL;
                  LastI = -1;
                  i = GetNextArealIndex(rac, LastI, 1, &LastEdge1, cindex, &UsedTree);
                  LastI = i;
                  }
               else
                  {
                  i = 0;
                  }
               while(i >= 0)
                  {
                  ii = i + 1;
                  if(ii == rac->numverts)
                     ii = 0;
                  x1 = rac->x[ii];
                  y1 = rac->y[ii];
                  z1 = rac->z[ii];
                  x2 = rac->x[i];
                  y2 = rac->y[i];
                  z2 = rac->z[i];

                  if((NorthCount > 0) && (SouthCount > 0) && (EastCount > 0) && (WestCount > 0))
                     j = 1;
                  else
                     {
                     j = 1;
                     if((EastCount <= 0) || (WestCount <= 0)) // make sure segment is near vertical before exclude on boundary 
                        {
                        unuseddbl = rac->y[i] - rac->y[ii];
                        if(unuseddbl != 0)
                           {
                           unuseddbl = (rac->x[i] - rac->x[ii]) / unuseddbl;
                           if((-0.15 < unuseddbl) && (unuseddbl < 0.15))
                              {
                              j = ConditionOnDataEdge(rac->x[i],rac->y[i],rac->x[ii],rac->y[ii],root,Proot,Lroot,
                                                  rac, NULL, NULL, NorthCount,SouthCount,EastCount,WestCount,checkinstance);
                              }
                           }
                        }
                     if((j > 0) &&
                          ((NorthCount <= 0) || (SouthCount <= 0))) // make sure segment is near horizontal before exclude on boundary 
                        {
                        unuseddbl = rac->x[i] - rac->x[ii];
                        if(unuseddbl != 0)
                           {
                           unuseddbl = (rac->y[i] - rac->y[ii]) / unuseddbl;
                           if((-0.15 < unuseddbl) && (unuseddbl < 0.15))
                              {
                              j = ConditionOnDataEdge(rac->x[i],rac->y[i],rac->x[ii],rac->y[ii],root,Proot,Lroot,
                                                  rac, NULL, NULL, NorthCount,SouthCount,EastCount,WestCount,checkinstance);
                              }
                           }
                        }
                     }

                  if((j > 0) && (ClipLineToRegion(minx,miny,maxx,maxy,&x1,&y1,&z1,&x2,&y2,&z2,&clipflag,multiplier) > 0))
                     {
                     LenToCover = Distance(x1,y1,x2,y2);
                     CoveredSoFar = ActiveChecks[checkinstance].sensitivity; //0.0;
                     if(Part1Save > 0)  /*** dont't want to cover cut-out edges with lines ***/
                        {
                        rlc = Lroot;
                        while((rlc != NULL) && (CoveredSoFar < LenToCover))
                           {
                           Config2 = SCCtable[rlc->Sindex].C;
                           Strat2 = SCCtable[rlc->Sindex].S;
                           Domain2 = SCCtable[rlc->Sindex].D;
                           if(CombinedCheckApplies(rlc->idn,checkinstance,ANOCOVERLA,rlc->Lindex,rlc->Sindex,
                                        Config2,Strat2,Domain2,&part1,&part2,&part3) > 0)
                              {
                              if(part3 > 0)
                                 {
                                 for(j=1; j<rlc->numnodes; j++)
                                    {
                                    if(MatchLinearSegment2D(x1,y1,x2,y2,
                                                            rlc->x[j-1],rlc->y[j-1],rlc->x[j],rlc->y[j],&MatchLen,
                                                               ActiveChecks[checkinstance].sensitivity) > 0)
                                       {
                                       CoveredSoFar += MatchLen;
                                       if(CoveredSoFar >= LenToCover)
                                          break;
                                       }
                                    }
                                 }
                           }
                           rlc = rlc->next;
                           }
                        }
                     if(CoveredSoFar < LenToCover) /*** check to see if another area feature edge will cover this one ***/
                        {
                        ran = root;
                        while((ran != NULL) && (CoveredSoFar < LenToCover))
                           {
                           if(ran != rac)
                              {
                              Config2 = SCCtable[ran->Sindex].C;
                              Strat2 = SCCtable[ran->Sindex].S;
                              Domain2 = SCCtable[ran->Sindex].D;
                              if(CombinedCheckApplies(ran->idn,checkinstance,ANOCOVERLA,ran->Lindex,ran->Sindex,
                                     Config2,Strat2,Domain2,&part1,&part2,&part3) > 0)
                                 {
                                 if(part3 > 0)
                                    {
                                    if(ran->RB_Tree_Edgelist != NULL)
                                       {
                                       LastEdge2 = NULL;
                                       LastJ = -1;
                                       j = GetNextArealIndex(ran, LastJ, 1, &LastEdge2, cindex, &UsedTree);
                                       LastJ = j;
                                       }
                                    else
                                       {
                                       j = 0;
                                       }
                                    while(j >= 0)
                                       {
                                       if(j == 0)
                                          jj = ran->numverts - 1;
                                       else
                                          jj = j - 1;
                                       if(MatchLinearSegment2D(x1,y1,x2,y2,
                                                            ran->x[jj],ran->y[jj],ran->x[j],ran->y[j],&MatchLen,
                                                            ActiveChecks[checkinstance].sensitivity) > 0)
                                          {
                                          CoveredSoFar += MatchLen;
                                          if(CoveredSoFar >= LenToCover)
                                                break;
                                          }
                                       if(ran->RB_Tree_Edgelist != NULL)
                                          {
                                          j = GetNextArealIndex(ran, LastJ, 1, &LastEdge2, cindex, &UsedTree);
                                          LastJ = j;
                                          }
                                       else
                                          {
                                          ++j;
                                          if(j >= ran->numverts)
                                             j = -1;
                                          }
                                       }
                                    if(j == ran->numverts) /*** check last edge of area feature ***/
                                       {
                                       if(MatchLinearSegment2D(x1,y1,x2,y2,
                                                            ran->x[0],ran->y[0],ran->x[ran->numverts-1],ran->y[ran->numverts-1],&MatchLen,
                                                            ActiveChecks[checkinstance].sensitivity) > 0)
                                          {
                                          CoveredSoFar += MatchLen;
                                          }
                                       }
                                    }
                                 }
                              }
                           ran = ran->next;
                           }
                        }
                     if(CoveredSoFar < LenToCover)
                        {
                        unusedint = Make_Correct(ANOCOVERLA,checkinstance);
                        CTCc = CTCroot;
                        while(CTCc != NULL)
                           {
                           if((CTCc->keyval == ANOCOVERLA) && (CTCc->Cnumber == unusedint) &&
                               (CTCc->localid == rac->localID) && (CTCc->idn == rac->idn))
                              break;
                           CTCc = CTCc ->next;
                           }
                        if(CTCc != NULL) /*** found this feature in list ***/
                           {
                           edgeC = (struct Edges *) (malloc(SzE));
                           edgeC->x1 = rac->x[i];
                           edgeC->y1 = rac->y[i];
                           edgeC->z1 = rac->z[i];
                           edgeC->x2 = rac->x[ii];
                           edgeC->y2 = rac->y[ii];
                           edgeC->z2 = rac->z[ii];
                           edgeC->next = NULL;
                           if(CTCc->listofedges == NULL)
                              {
                              CTCc->listofedges = edgeC;
                              CTCc->numedges = 1;
                              }
                           else
                              {
                              edgeN = CTCc->listofedges;
                              while(edgeN->next != NULL)
                                 edgeN = edgeN->next;
                              edgeN->next = edgeC;
                              CTCc->numedges += 1;
                              }

                           }
                        else
                           {
                           iix = iiy  = 0;
                           for(kk=1; kk<rac->numverts; ++kk)
                              {
                              if(rac->x[kk] > rac->x[iix])
                                 iix = kk;
                              if(rac->y[kk] > rac->y[iiy])
                                 iiy = kk;
                              }
                           iix = (int) (rac->x[iix] / RegionSize);
                           iiy = (int) (rac->y[iiy] / RegionSize);
                           kk = (iix * MaxYindex) + iix + iiy;
                           CTCc = (struct CondToCollect *) (malloc(SzCTC));
                           CTCc->maxindex = (iix * MaxYindex) + iix + iiy;
                           CTCc->keyval = ANOCOVERLA;
                           CTCc->Cnumber = unusedint;
                           CTCc->Lindex = rac->Lindex;
                           CTCc->Sindex = rac->Sindex;
                           CTCc->gform = G_AREAL;
                           CTCc->localid = rac->localID;
                           CTCc->idn = rac->idn;
                           CTCc->numedges = 1;
                           edgeC = (struct Edges *) (malloc(SzE));
                           edgeC->x1 = rac->x[i];
                           edgeC->y1 = rac->y[i];
                           edgeC->z1 = rac->z[i];
                           edgeC->x2 = rac->x[ii];
                           edgeC->y2 = rac->y[ii];
                           edgeC->z2 = rac->z[ii];
                           edgeC->next = NULL;
                           CTCc->listofedges = edgeC;
                           CTCc->next = CTCroot;
                           CTCroot = CTCc;
                           }
                        }
                     }
                  if(rac->RB_Tree_Edgelist != NULL)
                     {
                     i = GetNextArealIndex(rac, LastI, 1, &LastEdge1, cindex, &UsedTree);
                     LastI = i;
                     }
                  else
                     {
                     ++i;
                     if(i >= rac->numverts)
                        i = -1;
                     }
                  } /*** end while i >= 0  *******/
               } /*** end if part 1 ***/
            }  /*** end ANOCOVERLA applies ***/



         if((0) &&
              (CombinedCheckApplies(rac->idn,checkinstance,ANOCOVERLA,rac->Lindex,rac->Sindex,Config1,Strat1,Domain1,&part1,&part2,&part3) > 0))
            {
CreatePointInsideAreal(rac, &xint, &yint);
            Part1Save = part1;
            if(rac->ishole > 0)
               Part2Save = part2;
            else
               Part2Save = 0;
            if(Part2Save > 0)
               Part1Save = 0;
            if((Part1Save > 0) || (Part2Save > 0))
               {
               if(rac->RB_Tree_Edgelist != NULL)
                  {
                  LastEdge1 = NULL;
                  LastI = -1;
                  i = GetNextArealIndex(rac, LastI, 1, &LastEdge1, cindex, &UsedTree);
                  LastI = i;
                  }
               else
                  {
                  i = 0;
                  }
               while(i >= 0)
                  {
                  ii = i + 1;
                  if(ii == rac->numverts)
                     ii = 0;
                  x1 = rac->x[ii];
                  y1 = rac->y[ii];
                  z1 = rac->z[ii];
                  x2 = rac->x[i];
                  y2 = rac->y[i];
                  z2 = rac->z[i];

                  if((NorthCount > 0) && (SouthCount > 0) && (EastCount > 0) && (WestCount > 0))
                     j = 1;
                  else
                     {
                     j = 1;
                     if((EastCount <= 0) || (WestCount <= 0)) // make sure segment is near vertical before exclude on boundary 
                        {
                        unuseddbl = rac->y[i] - rac->y[ii];
                        if(unuseddbl != 0)
                           {
                           unuseddbl = (rac->x[i] - rac->x[ii]) / unuseddbl;
                           if((-0.15 < unuseddbl) && (unuseddbl < 0.15))
                              {
                              j = ConditionOnDataEdge(rac->x[i],rac->y[i],rac->x[ii],rac->y[ii],root,Proot,Lroot,
                                                  rac, NULL, NULL, NorthCount,SouthCount,EastCount,WestCount,checkinstance);
                              }
                           }
                        }
                     if((j > 0) &&
                          ((NorthCount <= 0) || (SouthCount <= 0))) // make sure segment is near horizontal before exclude on boundary 
                        {
                        unuseddbl = rac->x[i] - rac->x[ii];
                        if(unuseddbl != 0)
                           {
                           unuseddbl = (rac->y[i] - rac->y[ii]) / unuseddbl;
                           if((-0.15 < unuseddbl) && (unuseddbl < 0.15))
                              {
                              j = ConditionOnDataEdge(rac->x[i],rac->y[i],rac->x[ii],rac->y[ii],root,Proot,Lroot,
                                                  rac, NULL, NULL, NorthCount,SouthCount,EastCount,WestCount,checkinstance);
                              }
                           }
                        }
                     }

                  if((j > 0) && (ClipLineToRegion(minx,miny,maxx,maxy,&x1,&y1,&z1,&x2,&y2,&z2,&clipflag,multiplier) > 0))
                     {
                     LenToCover = Distance(x1,y1,x2,y2);
                     CoveredSoFar = ActiveChecks[checkinstance].sensitivity; //0.0;
                     if(Part1Save > 0)  /*** dont't want to cover cut-out edges with lines ***/
                        {
                        rlc = Lroot;
                        while((rlc != NULL) && (CoveredSoFar < LenToCover))
                           {
                           Config2 = SCCtable[rlc->Sindex].C;
                           Strat2 = SCCtable[rlc->Sindex].S;
                           Domain2 = SCCtable[rlc->Sindex].D;
                           if(CombinedCheckApplies(rlc->idn,checkinstance,ANOCOVERLA,rlc->Lindex,rlc->Sindex,
                                        Config2,Strat2,Domain2,&part1,&part2,&part3) > 0)
                              {
                              if(part3 > 0)
                                 {
                                 for(j=1; j<rlc->numnodes; j++)
                                    {
                                    if(MatchLinearSegment2D(x1,y1,x2,y2,
                                                            rlc->x[j-1],rlc->y[j-1],rlc->x[j],rlc->y[j],&MatchLen,
                                                               ActiveChecks[checkinstance].sensitivity) > 0)
                                       {
                                       CoveredSoFar += MatchLen;
                                       if(CoveredSoFar >= LenToCover)
                                          break;
                                       }
                                    }
                                 }
                           }
                           rlc = rlc->next;
                           }
                        }
                     if(CoveredSoFar < LenToCover) /*** check to see if another area feature edge will cover this one ***/
                        {
                        ran = root;
                        while((ran != NULL) && (CoveredSoFar < LenToCover))
                           {
                           if(ran != rac)
                              {
                              unusedint = 0; /** can we use ran - is it inside or outside of rac?  **/
                              Config2 = SCCtable[ran->Sindex].C;
                              Strat2 = SCCtable[ran->Sindex].S;
                              Domain2 = SCCtable[ran->Sindex].D;
                              if(CombinedCheckApplies(ran->idn,checkinstance,ANOCOVERLA,ran->Lindex,ran->Sindex,
                                     Config2,Strat2,Domain2,&part1,&part2,&part3) > 0)
                                 {
                                 if(part3 > 0)
                                    {
CreatePointInsideAreal(ran, &px2, &py2);
                                    if(ran->RB_Tree_Edgelist != NULL)
                                       {
                                       LastEdge2 = NULL;
                                       LastJ = -1;
                                       j = GetNextArealIndex(ran, LastJ, 1, &LastEdge2, cindex, &UsedTree);
                                       LastJ = j;
                                       }
                                    else
                                       {
                                       j = 0;
                                       }
                                    while(j >= 0)
                                    /***for(j=1; j<ran->numverts; j++) ***/
                                       {
                                       if(j == 0)
                                          jj = ran->numverts - 1;
                                       else
                                          jj = j - 1;


                                       if((unusedint >= 0) && (MatchLinearSegment2D(x1,y1,x2,y2,
                                                            ran->x[jj],ran->y[jj],ran->x[j],ran->y[j],&MatchLen, ActiveChecks[checkinstance].sensitivity) > 0))
                                          {
                                          if(unusedint == 0)
                                             {
                                             if(rac->area > ran->area)
                                                {
                                                if(rac->RB_Tree_Edgelist == NULL)
                                                   {
                                                   AinAresult = PointInAreal(px2, py2, rac->x,rac->y,rac->numverts, &iii);
                                                   }
                                                else
                                                   {
                                                   AinAresult = PointInsideLargeAreal(px2, py2, rac, &iii);
                                                   }
                                                }
                                             else
                                                {
                                                if(ran->RB_Tree_Edgelist == NULL)
                                                   {
                                                   AinAresult = PointInAreal(xint, yint, ran->x,ran->y,ran->numverts, &iii);
                                                   }
                                                else
                                                   {
                                                   AinAresult = PointInsideLargeAreal(xint, yint, ran, &iii);
                                                   }
                                                }
                                             if((rac->ishole > 0) || (ran->ishole > 0))
                                                {
                                                if(AinAresult > 0) 
                                                   unusedint = 1;
                                                else
                                                   unusedint = -1;
                                                }
                                             else
                                                {
                                                if(AinAresult > 0)
                                                   unusedint = -1;
                                                else
                                                   unusedint = 1;
                                                }
                                             }
                                          if(unusedint >= 0)
                                             {
                                             CoveredSoFar += MatchLen;
                                             if(CoveredSoFar >= LenToCover)
                                                break;
                                             }
                                          }
                                       if(ran->RB_Tree_Edgelist != NULL)
                                          {
                                          j = GetNextArealIndex(ran, LastJ, 1, &LastEdge2, cindex, &UsedTree);
                                          LastJ = j;
                                          }
                                       else
                                          {
                                          ++j;
                                          if(j >= ran->numverts)
                                             j = -1;
                                          }
                                       }
                                    if((unusedint >= 0) && (j == ran->numverts)) /*** check last edge of area feature ***/
                                       {

                                       if(MatchLinearSegment2D(x1,y1,x2,y2,
                                                            ran->x[0],ran->y[0],ran->x[ran->numverts-1],ran->y[ran->numverts-1],&MatchLen,
                                                            ActiveChecks[checkinstance].sensitivity) > 0)
                                          {
                                          if(unusedint == 0)
                                             {
                                             if(ran->RB_Tree_Edgelist == NULL)
                                                {
                                                AinAresult = PointInAreal(xint, yint, ran->x,ran->y,ran->numverts, &iii);
                                                }
                                             else
                                                {
                                                AinAresult = PointInsideLargeAreal(xint, yint, ran, &iii);
                                                }
                                             if((rac->ishole > 0) || (ran->ishole > 0))
                                                {
                                                if(AinAresult > 0)
                                                   unusedint = 1;
                                                else
                                                   unusedint = -1;
                                                }
                                             else
                                                {
                                                if(AinAresult > 0)
                                                   unusedint = -1;
                                                else
                                                   unusedint = 1;
                                                }
                                             }
                                          if(unusedint >= 0)
                                             CoveredSoFar += MatchLen;
                                          }
                                       }
                                    }
                                 }
                              }
                           ran = ran->next;
                           }
                        }
                     if(CoveredSoFar < LenToCover)
                        {
                        unusedint = Make_Correct(ANOCOVERLA,checkinstance);
                        CTCc = CTCroot;
                        while(CTCc != NULL)
                           {
                           if((CTCc->keyval == ANOCOVERLA) && (CTCc->Cnumber == unusedint) && 
                               (CTCc->localid == rac->localID) && (CTCc->idn == rac->idn))
                              break;
                           CTCc = CTCc ->next;
                           }
                        if(CTCc != NULL) /*** found this feature in list ***/
                           {
                           edgeC = (struct Edges *) (malloc(SzE));
                           edgeC->x1 = rac->x[i];
                           edgeC->y1 = rac->y[i];
                           edgeC->z1 = rac->z[i];
                           edgeC->x2 = rac->x[ii];
                           edgeC->y2 = rac->y[ii];
                           edgeC->z2 = rac->z[ii];
                           edgeC->next = NULL;
                           if(CTCc->listofedges == NULL)
                              {
                              CTCc->listofedges = edgeC;
                              CTCc->numedges = 1;
                              }
                           else
                              {
                              edgeN = CTCc->listofedges;
                              while(edgeN->next != NULL)
                                 edgeN = edgeN->next;
                              edgeN->next = edgeC;
                              CTCc->numedges += 1;
                              }
                           
                           }
                        else
                           {
                           iix = iiy  = 0;
                           for(kk=1; kk<rac->numverts; ++kk)
                              {
                              if(rac->x[kk] > rac->x[iix])
                                 iix = kk;
                              if(rac->y[kk] > rac->y[iiy])
                                 iiy = kk;
                              }
                           iix = (int) (rac->x[iix] / RegionSize);
                           iiy = (int) (rac->y[iiy] / RegionSize);
                           kk = (iix * MaxYindex) + iix + iiy;
                           CTCc = (struct CondToCollect *) (malloc(SzCTC));
                           CTCc->maxindex = (iix * MaxYindex) + iix + iiy;
                           CTCc->keyval = ANOCOVERLA;
                           CTCc->Cnumber = unusedint;
                           CTCc->Lindex = rac->Lindex;
                           CTCc->Sindex = rac->Sindex;
                           CTCc->gform = G_AREAL;
                           CTCc->localid = rac->localID;
                           CTCc->idn = rac->idn;
                           CTCc->numedges = 1;
                           edgeC = (struct Edges *) (malloc(SzE));
                           edgeC->x1 = rac->x[i];
                           edgeC->y1 = rac->y[i];
                           edgeC->z1 = rac->z[i];
                           edgeC->x2 = rac->x[ii];
                           edgeC->y2 = rac->y[ii];
                           edgeC->z2 = rac->z[ii];
                           edgeC->next = NULL;
                           CTCc->listofedges = edgeC;
                           CTCc->next = CTCroot;
                           CTCroot = CTCc;
                           }
                        }
                     }
                  if(rac->RB_Tree_Edgelist != NULL)
                     {
                     i = GetNextArealIndex(rac, LastI, 1, &LastEdge1, cindex, &UsedTree);
                     LastI = i;
                     }
                  else
                     {
                     ++i;
                     if(i >= rac->numverts)
                        i = -1;
                     }
                  } /*** end while i >= 0  *******/
               } /*** end if part 1 ***/
            }  /*** end ANOCOVERLA applies ***/





         if((rac->firstindex == cindex) && (rac->ishole <= 0) &&
                     (CombinedCheckApplies(rac->idn,checkinstance,ACOVERA,rac->Lindex,rac->Sindex,Config1, Strat1, Domain1,&Part1Save,&Part2Save,&part3) > 0) &&
                      (Part1Save > 0))
            {
            chktolerance = FindRelevantSensitivity(ACOVERA,checkinstance,&unuseddbl);
            if(chktolerance > rac->area)
               {
               CreatePointInsideAreal(rac, &xint, &yint);

               ran = root;
               while(ran != NULL)
                  {
                  PassCond = 0;
                  if((ran != rac) && (ran->ishole <= 0))
                     {
                     if((CombinedCheckApplies(ran->idn,checkinstance,ACOVERA,ran->Lindex,ran->Sindex,SCCtable[ran->Sindex].C,
                             SCCtable[ran->Sindex].S,SCCtable[ran->Sindex].D,&part1,&part2,&part3) > 0) &&
                         (part2 > 0))
                        {
                        PassCond2 = 0;
                        if(ran->RB_Tree_Edgelist == NULL)
                           {
                           PassCond2 = PointInAreal(xint, yint, ran->x,ran->y,ran->numverts, &iii);
                           }
                        else
                           {
                           PassCond2 = PointInsideLargeAreal(xint, yint, ran, &iii);
                           }
   
                        if((PassCond2 > 0) && (AreaInsideArea(rac,ran,&xt3,&yt3) > 1))
                           {
                           rah = root;
                           while(rah != NULL)
                              {
                              if((rah->ishole > 0) && (rah->featureid == ran->featureid)) 
                                 {
                                 if(AreaInsideArea(rac,rah,&xt3,&yt3) > 0)
                                    break;
                                 }
                              rah = rah->next;
                              }
                           if(rah == NULL)
                              PassCond = 1;
                           }
                        }
                     }
                  if(PassCond > 0)
                     {
                     ERc = (struct collection *) (malloc(SzC));
                     if(ERc == NULL)
                        {
                        printf("allocation memory exhausted during linear feature condition analysis\n");
                        printf("processing cannot continue\n");
                        exit(-1);
                        }
                     ERc->magnitude = 0.0;
                     ERc->keyval = ACOVERA;
                     ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                     ERc->Sindex1 = rac->Sindex;
                     ERc->Sindex2 = ran->Sindex;
                     ERc->aa = rac;
                     ERc->aa2 = ran;
                     ERc->numverts1 = rac->numverts;
                     ERc->numverts2 = ran->numverts;
                     ERc->next = NULL;
                     if(ERroot == NULL)
                        {
                        ERroot = ERc;
                        }
                     else
                        {
                        ERn = ERroot;
                        while(ERn != NULL)
                           {
                           if(
                              (ERn->Cnumber == ERc->Cnumber) &&
                              (ERn->keyval == ERc->keyval) &&
                              (ERn->aa     == ERc->aa)     &&
                              (ERn->aa2    == ERc->aa2)  &&
                              (ERn->aa->idn == ERc->aa->idn) &&
                              (ERn->aa->featureid == ERc->aa->featureid)
                              )
                              break;
                           ERn = ERn->next;
                           }
                        if(ERn == NULL)
                           {
                           ERc->next = ERroot;
                           ERroot = ERc;
                           }
                        else
                           {
                           free(ERc);
                           }
                        }
                     } /*** end if PassCond > 0) ***/
                  ran = ran->next;
                  }
               }
            }  /*** end ACOVERA check ***/



                                                                                                                                                     
         if((rac->ishole > 0) && (CombinedCheckApplies(rac->idn,checkinstance,CUTOUT,rac->Lindex,rac->Sindex,Config1,
                      Strat1, Domain1,&Part1Save,&Part2Save,&part3) > 0) && (Part1Save > 0))
            {
            ERc = (struct collection *) (malloc(SzC));
            if(ERc == NULL)
               {
               printf("allocation memory exhausted during linear feature condition analysis\n");
               printf("processing cannot continue\n");
               exit(-1);
               }
            ERc->magnitude = 0.0;
            ERc->keyval = CUTOUT;
            ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
            ERc->Sindex1 = rac->Sindex;
            ERc->aa = rac;
            ERc->aa2 = NULL;
            ERc->numverts1 = rac->numverts;
            ERc->numverts2 = 0;
            ERc->next = NULL;
            if(ERroot == NULL)
               {
               ERroot = ERc;
               }
            else
               {
               ERn = ERroot;
               while(ERn != NULL)
                  {
                  if(
                     (ERn->Cnumber == ERc->Cnumber) &&
                     (ERn->keyval == ERc->keyval) &&
                     (ERn->aa     == ERc->aa)     &&
                     (ERn->aa->featureid == ERc->aa->featureid)
                     )
                     break;
                  ERn = ERn->next;
                  }
               if(ERn == NULL)
                  {
                  ERc->next = ERroot;
                  ERroot = ERc;
                  }
               else
                  {
                  free(ERc);
                  }
               }
            } /*** end CUTOUT identification check ***/




         if((rac->ishole > 0) && (CombinedCheckApplies(rac->idn,checkinstance,AINSIDEHOLE,rac->Lindex,rac->Sindex,Config1,
                      Strat1, Domain1,&Part1Save,&Part2Save,&part3) > 0) && (Part1Save > 0))
            {
            ran = root;
            while(ran != NULL)
               {
               PassCond2 = 0;
               BasedOnPoint = 0;
               BasedOnEdges = 0;
               if((ran != rac) && (ran->ishole <= 0))
                  {
                  px3 = rac->area / ran->area;
                  if((px3 > 0.99) && (px3 < 1.01))
                     {
                     if((rac->firstindex == cindex) || (ran->firstindex == cindex))
                        {
                        if((CombinedCheckApplies(ran->idn,checkinstance,AINSIDEHOLE,ran->Lindex,ran->Sindex,SCCtable[ran->Sindex].C,
                                SCCtable[ran->Sindex].S,SCCtable[ran->Sindex].D,&part1,&part2,&part3) > 0) &&
                            (part2 > 0))
                           {
                           PassCond2 = 1;
                           }
                        }
                     }
                  }
               if(PassCond2 > 0)
                  {
                  BasedOnEdges = 0;
                  TouchingAreals = 0;
                  PassCond2 = TwoArealsIntersect(rac, ran, &xi, &yi, &AOAindex1, &AOAindex2, &TouchingAreals);
                  if(PassCond2 == 2) /** signal that passed from coincident edges **/
                     {
                     PassCond2 = 1;
                     BasedOnEdges = 1;
                     }
                   if(PassCond2 > 0)
                     {
                     ERc = (struct collection *) (malloc(SzC));
                     if(ERc == NULL)
                        {
                        printf("allocation memory exhausted during linear feature condition analysis\n");
                        printf("processing cannot continue\n");
                        exit(-1);
                        }
                     ERc->magnitude = 0.0;
                     ERc->keyval = AINSIDEHOLE;
                     ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                     ERc->Sindex1 = rac->Sindex;
                     ERc->Sindex2 = ran->Sindex;
                     ERc->aa = rac;
                     ERc->aa2 = ran;
                     ERc->numverts1 = rac->numverts;
                     ERc->numverts2 = ran->numverts;
                     ERc->next = NULL;
                     if(ERroot == NULL)
                        {
                        ERroot = ERc;
                        }
                     else
                        {
                        ERn = ERroot;
                        while(ERn != NULL)
                           {
                           if(
                              (ERn->Cnumber == ERc->Cnumber) &&
                              (ERn->keyval == ERc->keyval) &&
                              (ERn->aa     == ERc->aa)     &&
                              (ERn->aa2    == ERc->aa2)  &&
                              (ERn->aa->idn == ERc->aa->idn) &&
                              (ERn->aa->featureid == ERc->aa->featureid)
                              )
                              break;
                           ERn = ERn->next;
                           }
                        if(ERn == NULL)
                           {
                           ERc->next = ERroot;
                           ERroot = ERc;
                           }
                        else
                           {
                           free(ERc);
                           }
                        }
                     } /*** end if PassCond2 > 0) ***/
                  } /** end if outer PassCond2 > 0) ***/
               ran = ran->next;
               } /*** end while ran ****/
            }  /*** end AINSIDEHOLE check ***/



         if((rac->firstindex == cindex) && (rac->ishole <= 0) &&
               (CombinedCheckApplies(rac->idn,checkinstance,ANOCOVERA,rac->Lindex,rac->Sindex,Config1,
                      Strat1, Domain1,&Part1Save,&Part2Save,&part3) > 0) &&
                      (Part1Save > 0))
            {
            thiskey = ANOCOVERA;
            checkit = 1;
            }
         else if((rac->firstindex == cindex) && (rac->ishole <= 0) && 
               (CombinedCheckApplies(rac->idn,checkinstance,OVERUNDER,rac->Lindex,rac->Sindex,Config1,
                      Strat1, Domain1,&Part1Save,&Part2Save,&part3) > 0) &&
                      (Part1Save > 0))
            {
            thiskey = OVERUNDER;
            checkit = 1;
            }
         else
            checkit = 0;
         if(checkit > 0)
            {
            savei = 0;
            PassCond = 0;
            ran = root;
            while(ran != NULL)
               {
               if((ran != rac) && (ran->area >= (rac->area - 2)))
                  {
                  if((CombinedCheckApplies(ran->idn,checkinstance,thiskey,ran->Lindex,ran->Sindex,SCCtable[ran->Sindex].C,
                             SCCtable[ran->Sindex].S,SCCtable[ran->Sindex].D,&part1,&part2,&part3) > 0) &&
                         (part2 > 0))
                     {
                     PassCond = TwoArealsIntersect(ran, rac, &xi, &yi, &AOAindex2, &AOAindex1, &TouchingAreals);

                     if(PassCond == 0) /** no edge intersects, see if any point is inside ***/
                        {
                        if(TouchingAreals == 0)
                           {
                           if(ran->RB_Tree_Edgelist == NULL)
                              PassCond = PointInAreal(rac->x[0],rac->y[0],ran->x,ran->y,ran->numverts, &iii);
                           else
                              PassCond = PointInsideLargeAreal(rac->x[0],rac->y[0],ran, &iii);
                           }
                        else  /*** they do touch, but don't intersect ... ***/
                           {
                           CreatePointInsideAreal(rac, &xi, &yi);
                           if(ran->RB_Tree_Edgelist == NULL)
                              PassCond = PointInAreal(xi,yi,ran->x,ran->y,ran->numverts, &iii);
                           else
                              PassCond = PointInsideLargeAreal(xi,yi,ran, &iii);
                           }
                        if(PassCond > 0) /** seems to be inside area feature - is it actually in a hole of that areal? ***/
                           {
                           PassCond = 0;
                           rah = root;
                           while(rah != NULL)
                              {
                              if((rah->ishole > 0) && (rah->idn == ran->idn)) /**** was (rah->featureid == rac->featureid)) ****/
                                 {
                                 if(AreaInsideArea(rac,rah,&xt3,&yt3) > 1) /** says all points are inside if >1, some points are inside if > 0 **/
                                    {
                                    break;
                                    }
                                 }
                              rah = rah->next;
                              }
                           if(rah == NULL)
                              {
                              xi = rac->x[0];
                              yi = rac->y[0];
                              PassCond = 1;
                              }
                           }
                        } /** end if PassCond == 0 ***/
                     else /*** have some edge intersections - can we find a point of rac not in ran?  ****/
                        {
                        for(i=0; i<rac->numverts; i++)
                           {
                           j = PointIsVertex(rac->x[i],rac->y[i],ran->x,ran->y,ran->z,ran->numverts,&unuseddbl);
                           if(j == 0)
                              j = PointOnEdge(rac->x[i],rac->y[i],ran->x,ran->y,ran->z,ran->numverts,&unuseddbl,&i3);
                           if(j == 0)
                              j = PointInAreal(rac->x[i],rac->y[i],ran->x,ran->y,ran->numverts,&i2);
                           if(j == 0) /** says rac->x,y[i] is not inside, not a vertex, and not on the edge of ran ***/
                              {
                              PassCond = 1;
                              savei = i;
                              ran = NULL; /** do this to force a condition write ***/
                              break;
                              }
                           }
                        }

                     }
                  }
               if(PassCond > 0)
                  break;
               ran = ran->next;
               }
            if(ran == NULL)
               {
               ERc = (struct collection *) (malloc(SzC));
               if(ERc == NULL)
                  {
                  printf("allocation memory exhausted during linear feature condition analysis\n");
                  printf("processing cannot continue\n");
                  exit(-1);
                  }
               ERc->magnitude = 0.0;
               ERc->keyval = thiskey;
               ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
               ERc->Sindex1 = rac->Sindex;
               ERc->aa = rac;
               if(savei == (rac->numverts - 1))
                  ERc->vertexindex1 = savei - 1;
               else
                  ERc->vertexindex1 = savei;
               ERc->numverts1 = rac->numverts;
               ERc->next = NULL;
               if(ERroot == NULL)
                  {
                  ERroot = ERc;
                  }
               else
                  {
                  ERn = ERroot;
                  while(ERn != NULL)
                     {
                     if((ERn->Cnumber == ERc->Cnumber) && (ERn->keyval == ERc->keyval) &&
                        (ERn->aa     == ERc->aa))
                        break;
                     ERn = ERn->next;
                     }
                  if(ERn == NULL)
                     {
                     ERc->next = ERroot;
                     ERroot = ERc;
                     }
                  else
                     {
                     free(ERc);
                     }
                  }
               } /*** end if ran == NULL) ***/
            }  /*** end ANOCOVERA  and / or OVERUNDER check ***/



         
         if((CombinedCheckApplies(rac->idn,checkinstance,AREAKINK,rac->Lindex,rac->Sindex,Config1,
                      Strat1, Domain1,&Part1Save,&Part2Save,&part3) > 0) &&
                      (Part1Save > 0))
            {
            for(i=0; i<rac->numverts; i++)
               {
               checkit = 0;
               if((rac->x[i] <= maxx) && (rac->x[i] >= minx) && (rac->y[i] >= miny) && (rac->y[i] <= maxy))
                  checkit = 1;
               if(checkit > 0)
                  {
                  if(i == 0)
                     jj = rac->numverts - 1;
                  else
                     jj = i - 1;

                  ii = i + 1;
                  if(ii == rac->numverts)
                     ii = 0;
                  }
               if(checkit > 0)
                  {
                  if((rac->x[jj] != rac->x[i]) || (rac->y[jj] != rac->y[i]))
                     {
                     if((rac->x[ii] != rac->x[i]) || (rac->y[ii] != rac->y[i]))
                        {
                        perim_angle = TurnAngle(rac->x[jj],rac->y[jj],rac->x[i],rac->y[i],rac->x[ii],rac->y[ii]);
   
                        perim_angle = RadiansToDegrees(perim_angle);
   
                        if(SensitivityCheck(GTEQ, AREAKINK, checkinstance, perim_angle) > 0)
                           {
                           checkit = 1;
                           checkit = ConditionOnDataEdge(rac->x[i],rac->y[i],rac->x[jj],rac->y[jj],root,Proot,Lroot,
                             rac, NULL, NULL,
                             NorthCount,SouthCount,EastCount,WestCount,checkinstance);
                           if(checkit > 0)
                              {
                              checkit = ConditionOnDataEdge(rac->x[i],rac->y[i],rac->x[ii],rac->y[ii],root,Proot,Lroot,
                             rac, NULL, NULL,
                             NorthCount,SouthCount,EastCount,WestCount,checkinstance);
                              }

                           if(checkit > 0)
                              {
                              ERc = (struct collection *) (malloc(SzC));
                              if(ERc == NULL)
                                 {
                                 printf("allocation memory exhausted during linear feature condition analysis\n");
                                 printf("processing cannot continue\n");
                                 exit(-1);
                                 }
                              ERc->x[0] = rac->x[ii];
                              ERc->y[0] = rac->y[ii];
                              ERc->z[0] = rac->z[ii];
   
                              ERc->x[1] = rac->x[i];
                              ERc->y[1] = rac->y[i];
                              ERc->z[1] = rac->z[i];
   
                              ERc->x[2] = rac->x[jj];
                              ERc->y[2] = rac->y[jj];
                              ERc->z[2] = rac->z[jj];
   
                              ERc->magnitude =  perim_angle;
                              ERc->keyval = AREAKINK;
                              ERc->Sindex1 = rac->Sindex;
                              ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                              ERc->aa = rac;
                              if(i < jj)
                                 {
                                 ERc->vertexindex1 = i;
                                 ERc->vertexindex2 = jj;
                                 }
                              else
                                 {
                                 ERc->vertexindex1 = jj;
                                 ERc->vertexindex2 = i;
                                 }
                              ERc->next = NULL;
                              if(ERroot == NULL)
                                 {
                                 ERroot = ERc;
                                 }
                              else
                                 {
                                 ERn = ERroot;
                                 while(ERn != NULL)
                                    {
                                    if((ERn->Cnumber == ERc->Cnumber) && (ERn->keyval == ERc->keyval) && (ERn->aa == ERc->aa) &&
                                      (ERn->x[0] == ERc->x[0]) && (ERn->y[0] == ERc->y[0]))
                                       break;
   
                                    ERn = ERn->next;
                                    }
                                 if(ERn == NULL)
                                    {
                                    ERc->next = ERroot;
                                    ERroot = ERc;
                                    }
                                 else
                                   free(ERc);
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }


                                                                                                                                                     


         if(CombinedCheckApplies(rac->idn,checkinstance,SHAREPERIM,rac->Lindex,rac->Sindex,Config1,Strat1,Domain1,&part1,&part2,&part3) > 0)
            {
            if(part1 > 0)
               {
               ran = rac->next;
               while(ran != NULL)
                  {
                  Config2 = SCCtable[ran->Sindex].C;
                  Strat2 = SCCtable[ran->Sindex].S;
                  Domain2 = SCCtable[ran->Sindex].D;
                  part3 = -1;
                  if((rac->ishole <= 0) && (ran->ishole <= 0))
                     part3 = 1;
                  else if((rac->ishole > 0) && (ran->ishole > 0))
                     part3 = 1;


                  if((part3 > 0) &&
                    (CombinedCheckApplies(ran->idn,checkinstance,SHAREPERIM,ran->Lindex,ran->Sindex,Config2,Strat2,Domain2,&part1,&part2,&part3) > 0))
                     {
                     if(part2 > 0)
                        {
                        foundpair = 0;
                        savei = savej = -1;
                        for(i=0; i<rac->numverts; i++)
                           {
                           ii = i + 1;
                           if(ii >= rac->numverts)
                              ii = 0;

                           for(j=0; j<ran->numverts; j++)
                              {
                              jj = j + 1;
                              if(jj >= ran->numverts)
                                 jj = 0;
                              if(EqualWithinTolerance(rac->x[i],rac->y[i], ran->x[j], ran->y[j],
                                    ActiveChecks[checkinstance].sensitivity2) > 0)
                                 {
                                 if(EqualWithinTolerance(rac->x[ii],rac->y[ii], ran->x[jj], ran->y[jj],
                                     ActiveChecks[checkinstance].sensitivity2) > 0)
                                    {
                                    ++foundpair;
                                    if(foundpair == 1)
                                       {
                                       savei = i;
                                       savej = j;
                                       }
                                    }
                                 }
                              else if(EqualWithinTolerance(rac->x[i],rac->y[i], ran->x[jj], ran->y[jj],
                                    ActiveChecks[checkinstance].sensitivity2) > 0)
                              /***else if((rac->x[i] == ran->x[jj]) && (rac->y[i] == ran->y[jj])) ***/
                                 {
                                 if(EqualWithinTolerance(rac->x[ii],rac->y[ii], ran->x[j], ran->y[j],
                                    ActiveChecks[checkinstance].sensitivity2) > 0)
                                 /**if((rac->x[ii] == ran->x[j]) && (rac->y[ii] == ran->y[j])) **/
                                    {
                                    ++foundpair;
                                    if(foundpair == 1)
                                       {
                                       savei = i;
                                       savej = j;
                                       }
                                    }
                                 }
                              }
                           } /*** end for i ***/

                        if(SensitivityCheck(GT, SHAREPERIM, checkinstance, (double) foundpair) > 0)
                           {
                           ERc = (struct collection *) (malloc(SzC));
                           if(ERc == NULL)
                              {
                              printf("allocation memory exhausted during linear feature condition analysis\n");
                              printf("processing cannot continue\n");
                              exit(-1);
                              }
                           ERc->magnitude = (double) foundpair;
                           ERc->keyval = SHAREPERIM;
                           ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                           ERc->Sindex1 = rac->Sindex;
                           ERc->Sindex2 = ran->Sindex;
                           ii = savei;
                           ERc->x[0] = rac->x[ii];
                           ERc->y[0] = rac->y[ii];
                           ERc->z[0] = rac->z[ii];
                           ii = (savei + 1) % rac->numverts;
                           ERc->x[1] = rac->x[ii];
                           ERc->y[1] = rac->y[ii];
                           ERc->z[1] = rac->z[ii];

                           ii = savej;
                           ERc->x[2] = ran->x[ii];
                           ERc->y[2] = ran->y[ii];
                           ERc->z[2] = ran->z[ii];
                           ii = (savej + 1) % ran->numverts;
                           ERc->x[3] = ran->x[ii];
                           ERc->y[3] = ran->y[ii];
                           ERc->z[3] = ran->z[ii];
                           ERc->aa = rac;
                           ERc->aa2 = ran;
                           ERc->next = NULL;
                           if(ERroot == NULL)
                              {
                              ERroot = ERc;
                              }
                           else
                              {
                              ERn = ERroot;
                              while(ERn != NULL)
                                 {
                                 if((ERn->Cnumber == ERc->Cnumber) && (ERn->keyval == ERc->keyval) &&
                                      (((ERn->aa == ERc->aa) && (ERn->aa2 == ERc->aa2)) ||
                                       ((ERn->aa == ERc->aa2) && (ERn->aa2 == ERc->aa))))
                                    break;

                                 ERn = ERn->next;
                                 }
                              if(ERn == NULL)
                                 {
                                 ERc->next = ERroot;
                                 ERroot = ERc;
                                 }
                              else
                                free(ERc);
                              }
                           }
                        } /*** end if part 2 ***/
                     }
                  ran = ran->next;
                  } /*** end while ran ***/
               }
            } /*** end SHAREPERIM check ***/




         if(CombinedCheckApplies(rac->idn,checkinstance,FAILMERGEA,rac->Lindex,rac->Sindex,Config1,Strat1,Domain1,&part1,&part2,&part3) > 0)
            {
            if(part1 > 0)
               {
               HGT_type = GetLongAttrVal(LONG_ATTR_CHECK_HGT,rac->idn,&I_HGTval,&D_HGTval,&S_HGTval[0]);
               ZV2_type = GetLongAttrVal(LONG_ATTR_CHECK_ZV2,rac->idn,&I_ZV2val,&D_ZV2val,&S_ZV2val[0]);
               NAM_type = GetLongAttrVal(LONG_ATTR_CHECK_NAM,rac->idn,&I_NAMval,&D_NAMval,&S_NAMval[0]); 
               ran = rac->next;
               while(ran != NULL)
                  {
                  part1 = 0;
                  if((ran != rac) && (rac->Lindex == ran->Lindex) && (ran->idn != rac->idn) &&
                     (CombinedCheckApplies(ran->idn,checkinstance,FAILMERGEA,ran->Lindex,ran->Sindex,
                         SCCtable[ran->Sindex].C,SCCtable[ran->Sindex].S,SCCtable[ran->Sindex].D,&part1,&part2,&part3) > 0) &&
                      (part1 > 0))
                     {
                     if(CheckThisAreaPair(checkinstance,cindex,IndexLimit,
                              SzPC,SzPW,rac->localID,ran->localID,rac->firstindex,ran->firstindex,rac->area,ran->area) <= 0)
                        part1 = 0;
                     else
                        {
                        MYI = GetLongAttrVal(LONG_ATTR_CHECK_HGT,ran->idn,&savei,&temp,&MessageLine[0]);
                        if(MYI != HGT_type)
                           part1 = 0;
                        else
                           {
                           if(HGT_type == I_TYPE)
                              {
                              if(I_HGTval != savei)
                                 part1 = 0;
                              }
                           else if(HGT_type == D_TYPE)
                              {
                              if(D_HGTval != temp)
                                 part1 = 0;
                              }
                           else if(HGT_type == C_TYPE)
                              {
                              if(strcmp(S_HGTval,MessageLine) != 0)
                                 part1 = 0;
                              }
                           if(part1 > 0)
                              {
                              MYI = GetLongAttrVal(LONG_ATTR_CHECK_ZV2,ran->idn,&savei,&temp,&MessageLine[0]);
                              if(MYI != ZV2_type)
                                 part1 = 0;
                              else
                                 {
                                 if(ZV2_type == I_TYPE)
                                    {
                                    if(I_ZV2val != savei)
                                       part1 = 0;
                                    }
                                 else if(ZV2_type == D_TYPE)
                                    {
                                    if(D_ZV2val != temp)
                                       part1 = 0;
                                    }
                                 else if(ZV2_type == C_TYPE)
                                    {
                                    if(strcmp(S_ZV2val,MessageLine) != 0)
                                       part1 = 0;
                                    }
                                 }
                              }
                           if(part1 > 0)
                              {
                              MYI = GetLongAttrVal(LONG_ATTR_CHECK_NAM,ran->idn,&savei,&temp,&MessageLine[0]);
                              if(MYI != NAM_type)
                                 part1 = 0;
                              else
                                 {
                                 if(NAM_type == I_TYPE)
                                    {
                                    if(I_NAMval != savei)
                                       part1 = 0;
                                    }
                                 else if(NAM_type == D_TYPE)
                                    {
                                    if(D_NAMval != temp)
                                       part1 = 0;
                                    }
                                 else if(NAM_type == C_TYPE)
                                    {
                                    if(strcmp(S_NAMval,MessageLine) != 0)
                                       part1 = 0;
                                    }
                                 }
                              }
                           }
                        }
                     }
                  if(part1 > 0)
                     {
                     foundpair = 0;
                     savei = savej = -1;
                     for(i=0; i<rac->numverts; i++)
                        {
                        if(i == 0)
                           ii = rac->numverts - 1;
                        else
                           ii = i - 1;

                        if(rac->x[i] < rac->x[ii])
                           {
                           L1minx = rac->x[i];
                           L1maxx = rac->x[ii];
                           }
                        else
                           {
                           L1maxx = rac->x[i];
                           L1minx = rac->x[ii];
                           }
                        if(rac->y[i] < rac->y[ii])
                           {
                           L1miny = rac->y[i];
                           L1maxy = rac->y[ii];
                           }
                        else
                           {
                           L1maxy = rac->y[i];
                           L1miny = rac->y[ii];
                           }

                        if(ran->RB_Tree_Edgelist == NULL)
                           {
                           iii = ii3 = 1;
                           }
                        else
                           {
                           iii = ((int) (rac->x[ii] / RegionSize) * (MaxYindex + 1)) + (int) (rac->y[ii] / RegionSize);
                           ii3 = ((int) (rac->x[i] / RegionSize) * (MaxYindex + 1)) + (int) (rac->y[i] / RegionSize);
                           if(iii > ii3)
                              {
                              kk = ii3;
                              ii3 = iii;
                              iii = kk;
                              }
                           }
                        for(kk=iii; kk<=ii3; kk++)
                           {
                           if(ran->RB_Tree_Edgelist != NULL)
                              {
                              LastEdge2 = NULL;
                              LastJ = -1;
                              j = GetNextArealIndex(ran, LastJ, 1, &LastEdge2, kk, &UsedTree);
                              LastJ = j;
                              }
                           else
                              {
                              j = 0;
                              }

                           while(j >= 0)
                              {
                              if(j == 0)
                                 jj = ran->numverts - 1;
                              else
                                 jj = j - 1;

                              if(MergeSeg_LineSegmentsOverlap(rac->x[i],rac->y[i], rac->x[ii],rac->y[ii], /***A, B, C, ***/
                                                   ran->x[j],ran->y[j],ran->x[jj],ran->y[jj],
                                                   L1minx,L1maxx,L1miny,L1maxy,
                                                   &x1, &y1, &x2, &y2, ActiveChecks[checkinstance].sensitivity) > 0)
                                 {
                                 foundpair = 1;
                                 break; /*** break from the while j loop ***/
                                 }
                              if(ran->RB_Tree_Edgelist != NULL)
                                 {
                                 j = GetNextArealIndex(ran, LastJ, 1, &LastEdge2, kk, &UsedTree);
                                 LastJ = j;
                                 }
                              else
                                 {
                                 ++j;
                                 if(j >= ran->numverts)
                                    j = -1;
                                 }
                              } /*** end for j ***/
                           if(foundpair > 0)
                              {
                              break;
                              }
                           } /*** end for kk ***/
                        if(foundpair > 0)
                           {
                           break; /*** break from the for i loop ***/
                           }
                        } /*** end for i ***/

                     if(foundpair > 0)
                        {
                        foundpair = 0;
                        ERc = (struct collection *) (malloc(SzC));
                        if(ERc == NULL)
                           {
                           printf("allocation memory exhausted during linear feature condition analysis\n");
                           printf("processing cannot continue\n");
                           exit(-1);
                           }
                        ERc->magnitude = (double) foundpair;
                        ERc->keyval = FAILMERGEA;
                        ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                        ERc->Sindex1 = rac->Sindex;
                        ERc->Sindex2 = ran->Sindex;

                        ERc->x[0] = rac->x[ii];
                        ERc->y[0] = rac->y[ii];
                        ERc->z[0] = rac->z[ii];
                        ERc->x[1] = rac->x[i];
                        ERc->y[1] = rac->y[i];
                        ERc->z[1] = rac->z[i];

                        ERc->x[2] = ran->x[j];
                        ERc->y[2] = ran->y[j];
                        ERc->z[2] = ran->z[j];
                        ERc->x[3] = ran->x[jj];
                        ERc->y[3] = ran->y[jj];
                        ERc->z[3] = ran->z[jj];
                        ERc->aa = rac;
                        ERc->aa2 = ran;
                        ERc->next = NULL;
                        if(ERroot == NULL)
                           {
                           ERroot = ERc;
                           }
                        else
                           {
                           ERn = ERroot;
                           while(ERn != NULL)
                              {
                              if((ERn->Cnumber == ERc->Cnumber) && (ERn->keyval == ERc->keyval) &&
                                   (((ERn->aa == ERc->aa) && (ERn->aa2 == ERc->aa2)) ||
                                    ((ERn->aa == ERc->aa2) && (ERn->aa2 == ERc->aa))))
                                 break;

                              ERn = ERn->next;
                              }
                           if(ERn == NULL)
                              {
                              ERc->next = ERroot;
                              ERroot = ERc;
                              }
                           else
                             free(ERc);
                           }
                        }
                     }
                  ran = ran->next;
                  } /*** end while ran ***/
               }
            } /*** end FAILMERGEA check ***/




         if(CombinedCheckApplies(rac->idn,checkinstance,FAILMERGEA2,rac->Lindex,rac->Sindex,Config1,Strat1,Domain1,&part1,&part2,&part3) > 0)
            {
            if(part1 > 0)
               {
               HGT_type = GetLongAttrVal(LONG_ATTR_CHECK_HGT,rac->idn,&I_HGTval,&D_HGTval,&S_HGTval[0]);
               ZV2_type = GetLongAttrVal(LONG_ATTR_CHECK_ZV2,rac->idn,&I_ZV2val,&D_ZV2val,&S_ZV2val[0]);
               NAM_type = GetLongAttrVal(LONG_ATTR_CHECK_NAM,rac->idn,&I_NAMval,&D_NAMval,&S_NAMval[0]);
               ran = rac->next;
               while(ran != NULL)
                  {
                  part1 = 0;
                  if((ran != rac) && (rac->Lindex == ran->Lindex) && (ran->idn != rac->idn) &&
                     (CombinedCheckApplies(ran->idn,checkinstance,FAILMERGEA2,ran->Lindex,ran->Sindex,
                         SCCtable[ran->Sindex].C,SCCtable[ran->Sindex].S,SCCtable[ran->Sindex].D,&part1,&part2,&part3) > 0) &&
                      (part1 > 0))
                     {
                     if(CheckThisAreaPair(checkinstance,cindex,IndexLimit,
                              SzPC,SzPW,rac->localID,ran->localID,rac->firstindex,ran->firstindex,rac->area,ran->area) <= 0)
                        part1 = 0;
                     else
                        {
                        MYI = GetLongAttrVal(LONG_ATTR_CHECK_HGT,ran->idn,&savei,&temp,&MessageLine[0]);
                        if(MYI != HGT_type)
                           part1 = 0;
                        else
                           {
                           if(HGT_type == I_TYPE)
                              {
                              if(I_HGTval != savei)
                                 part1 = 0;
                              }
                           else if(HGT_type == D_TYPE)
                              {
                              if(D_HGTval != temp)
                                 part1 = 0;
                              }
                           else if(HGT_type == C_TYPE)
                              {
                              if(strcmp(S_HGTval,MessageLine) != 0)
                                 part1 = 0;
                              }
                           if(part1 > 0)
                              {
                              MYI = GetLongAttrVal(LONG_ATTR_CHECK_ZV2,ran->idn,&savei,&temp,&MessageLine[0]);
                              if(MYI != ZV2_type)
                                 part1 = 0;
                              else
                                 {
                                 if(ZV2_type == I_TYPE)
                                    {
                                    if(I_ZV2val != savei)
                                       part1 = 0;
                                    }
                                 else if(ZV2_type == D_TYPE)
                                    {
                                    if(D_ZV2val != temp)
                                       part1 = 0;
                                    }
                                 else if(ZV2_type == C_TYPE)
                                    {
                                    if(strcmp(S_ZV2val,MessageLine) != 0)
                                       part1 = 0;
                                    }
                                 }
                              }
                           if(part1 > 0)
                              {
                              MYI = GetLongAttrVal(LONG_ATTR_CHECK_NAM,ran->idn,&savei,&temp,&MessageLine[0]);
                              if(MYI != NAM_type)
                                 part1 = 0;
                              else
                                 {
                                 if(NAM_type == I_TYPE)
                                    {
                                    if(I_NAMval != savei)
                                       part1 = 0;
                                    }
                                 else if(NAM_type == D_TYPE)
                                    {
                                    if(D_NAMval != temp)
                                       part1 = 0;
                                    }
                                 else if(NAM_type == C_TYPE)
                                    {
                                    if(strcmp(S_NAMval,MessageLine) != 0)
                                       part1 = 0;
                                    }
                                 }
                              }
                           }
                        }
                     }
                  if(part1 > 0)
                     {
                     foundpair = 0;
                     savei = savej = -1;
                     for(i=0; i<rac->numverts; i++)
                        {
                        if(i == 0)
                           ii = rac->numverts - 1;
                        else
                           ii = i - 1;

                        checkit = PointOnQuarterDegreeBoundary(rac->x[i], rac->y[i], ActiveChecks[checkinstance].sensitivity2);
                        checkit += PointOnQuarterDegreeBoundary(rac->x[ii], rac->y[ii], ActiveChecks[checkinstance].sensitivity2);

                        if(checkit < 2)
                           {
                           if(rac->x[i] < rac->x[ii])
                              {
                              L1minx = rac->x[i];
                              L1maxx = rac->x[ii];
                              }
                           else
                              {
                              L1maxx = rac->x[i];
                              L1minx = rac->x[ii];
                              }
                           if(rac->y[i] < rac->y[ii])
                              {
                              L1miny = rac->y[i];
                              L1maxy = rac->y[ii];
                              }
                           else
                              {
                              L1maxy = rac->y[i];
                              L1miny = rac->y[ii];
                              }

                           if(ran->RB_Tree_Edgelist == NULL)
                              {
                              iii = ii3 = 1;
                              }
                           else
                              {
                              iii = ((int) (rac->x[ii] / RegionSize) * (MaxYindex + 1)) + (int) (rac->y[ii] / RegionSize);
                              ii3 = ((int) (rac->x[i] / RegionSize) * (MaxYindex + 1)) + (int) (rac->y[i] / RegionSize);
                              if(iii > ii3)
                                 {
                                 kk = ii3;
                                 ii3 = iii;
                                 iii = kk;
                                 }
                              }

                           for(kk=iii; kk<=ii3; kk++)
                              {
                              if(ran->RB_Tree_Edgelist != NULL)
                                 {
                                 LastEdge2 = NULL;
                                 LastJ = -1;
                                 j = GetNextArealIndex(ran, LastJ, 1, &LastEdge2, kk, &UsedTree);
                                 LastJ = j;
                                 }
                              else
                                 {
                                 j = 0;
                                 }

                              while(j >= 0)
                                 {
                                 if(j == 0)
                                    jj = ran->numverts - 1;
                                 else
                                    jj = j - 1;

                                 if(MergeSeg_LineSegmentsOverlap(rac->x[i],rac->y[i], rac->x[ii],rac->y[ii], /***A, B, C, ***/
                                                   ran->x[j],ran->y[j],ran->x[jj],ran->y[jj],
                                                   L1minx,L1maxx,L1miny,L1maxy,
                                                   &x1, &y1, &x2, &y2, ActiveChecks[checkinstance].sensitivity) > 0)
                                    {
                                    foundpair = 1;
                                    break; /*** break from the while j loop ***/
                                    }
                                 if(ran->RB_Tree_Edgelist != NULL)
                                    {
                                    j = GetNextArealIndex(ran, LastJ, 1, &LastEdge2, kk, &UsedTree);
                                    LastJ = j;
                                    }
                                 else
                                    {
                                    ++j;
                                    if(j >= ran->numverts)
                                       j = -1;
                                    }
                                 } /*** end for j ***/
                              if(foundpair > 0)
                                 {
                                 break;
                                 }
                              } /*** end for kk ***/
                           if(foundpair > 0)
                              {
                              break; /*** break from the for i loop ***/
                              }
                           } /*** end checkit == 0 ***/
                        } /*** end for i ***/

                     if(foundpair > 0)
                        {
                        foundpair = 0;
                        ERc = (struct collection *) (malloc(SzC));
                        if(ERc == NULL)
                           {
                           printf("allocation memory exhausted during linear feature condition analysis\n");
                           printf("processing cannot continue\n");
                           exit(-1);
                           }
                        ERc->magnitude = (double) foundpair;
                        ERc->keyval = FAILMERGEA2;
                        ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                        ERc->Sindex1 = rac->Sindex;
                        ERc->Sindex2 = ran->Sindex;

                        ERc->x[0] = rac->x[ii];
                        ERc->y[0] = rac->y[ii];
                        ERc->z[0] = rac->z[ii];
                        ERc->x[1] = rac->x[i];
                        ERc->y[1] = rac->y[i];
                        ERc->z[1] = rac->z[i];

                        ERc->x[2] = ran->x[j];
                        ERc->y[2] = ran->y[j];
                        ERc->z[2] = ran->z[j];
                        ERc->x[3] = ran->x[jj];
                        ERc->y[3] = ran->y[jj];
                        ERc->z[3] = ran->z[jj];
                        ERc->aa = rac;
                        ERc->aa2 = ran;
                        ERc->next = NULL;
                        if(ERroot == NULL)
                           {
                           ERroot = ERc;
                           }
                        else
                           {
                           ERn = ERroot;
                           while(ERn != NULL)
                              {
                              if((ERn->Cnumber == ERc->Cnumber) && (ERn->keyval == ERc->keyval) &&
                                   (((ERn->aa == ERc->aa) && (ERn->aa2 == ERc->aa2)) ||
                                    ((ERn->aa == ERc->aa2) && (ERn->aa2 == ERc->aa))))
                                 break;

                              ERn = ERn->next;
                              }
                           if(ERn == NULL)
                              {
                              ERc->next = ERroot;
                              ERroot = ERc;
                              }
                           else
                             free(ERc);
                           }
                        }
                     }
                  ran = ran->next;
                  } /*** end while ran ***/
               }
            } /*** end FAILMERGEA2 check ***/


         if(CombinedCheckApplies(rac->idn,checkinstance,AUNDERSHTA,rac->Lindex,rac->Sindex,Config1,Strat1,Domain1,&part1,&part2,&part3) > 0)
            {
            if(part1 > 0)
               {
               temp2 = (ActiveChecks[checkinstance].sensitivity3 * PIvalue) / 180.0;
               unuseddbl = FindRelevantSensitivity(AUNDERSHTA,checkinstance,&chktolerance);
               if(rac->RB_Tree_Edgelist != NULL)
                  {
                  LastEdge1 = NULL;
                  LastI = -1;
                  i = GetNextArealIndex(rac, LastI, 1, &LastEdge1, cindex, &UsedTree);
                  LastI = i;
                  }
               else
                  i = 0;

               while(i >= 0)
                  {
                  if(i > 0)
                     ii = i - 1;
                  else
                     ii = rac->numverts - 1;

                  if((rac->x[i] >= minx) && (rac->x[i] <= maxx) && (rac->y[i] >= miny) && (rac->y[i] <= maxy))
                     AListCount = 1;
                  else if((rac->x[ii] >= minx) && (rac->x[ii] <= maxx) && (rac->y[ii] >= miny) && (rac->y[ii] <= maxy))
                     AListCount = 1;
                  else
                     AListCount = 10;

                  if(AListCount == 1)
                     {
                     minptldist = chktolerance * 10.0;

                     if(rac->x[ii] < rac->x[i])
                        {
                        L1minx = rac->x[ii];
                        L1maxx = rac->x[i];
                        xt1 = rac->x[i] - rac->x[ii];
                        yt1 = rac->y[i] - rac->y[ii];
                        }
                     else
                        {
                        L1minx = rac->x[i];
                        L1maxx = rac->x[ii];
                        xt1 = rac->x[ii] - rac->x[i];
                        yt1 = rac->y[ii] - rac->y[i];
                        }
                     if(rac->y[ii] < rac->y[i])
                        {
                        L1miny = rac->y[ii];
                        L1maxy = rac->y[i];
                        }
                     else
                        {
                        L1miny = rac->y[i];
                        L1maxy = rac->y[ii];
                        }

                     AddNorth = AddSouth = AddEast = AddWest = 0;
                     if((maxx - L1maxx) <= chktolerance)
                        {
                        AddEast = 1;
                        }
                     if((maxy - L1maxy) <= chktolerance)
                        {
                        AddNorth = 1;
                        }
                     if((L1minx - minx) <= chktolerance)
                        {
                        AddWest = 1;
                        }
                     if((L1miny - miny) <= chktolerance)
                        {
                        AddSouth = 1;
                        }
                     }

                  while(AListCount < 6)
                     {
                     if(AListCount == 1)
                        {
                        ran = /**rac->next;**/ root;/***/
                        which_root = root;
                        }
                     else if(AListCount == 2)
                        {
                        if(AddNorth > 0)
                           {
                           NEc = NorthE;
                           if(NEc != NULL)
                              {
                              which_root = ran = NEc->a;
                              NeighborJ = NEc->edgeindex;
                              NEc = NEc->next;
                              }
                           else
                              which_root = ran = NULL;
                           }
                        }
                     else if(AListCount == 3)
                        {
                        if(AddSouth > 0)
                           {
                           NEc = SouthE;
                           if(NEc != NULL)
                              {
                              which_root = ran = NEc->a;
                              NeighborJ = NEc->edgeindex;
                              NEc = NEc->next;
                              }
                           else
                              which_root = ran = NULL;
                           }
                        }
                     else if(AListCount == 4)
                        {
                        if(AddEast > 0)
                           {
                           NEc = EastE;
                           if(NEc != NULL)
                              {
                              which_root = ran = NEc->a;
                              NeighborJ = NEc->edgeindex;
                              NEc = NEc->next;
                              }
                           else
                              which_root = ran = NULL;
                           }
                        }
                     else if(AListCount == 5)
                        {
                        if(AddWest > 0)
                           {
                           NEc = WestE;
                           if(NEc != NULL)
                              {
                              which_root = ran = NEc->a;
                              NeighborJ = NEc->edgeindex;
                              NEc = NEc->next;
                              }
                           else
                              which_root = ran = NULL;
                           }
                        }
                     else
                        break;

                  while(ran != NULL)
                     {
                     if(ran == rac)
                        {
                        if(AListCount == 1)
                           {
                           ran = ran->next;
                           if(ran == NULL)
                              continue;
                           }
                        else
                           {
                           if(NEc != NULL)
                              {
                              ran = NEc->a;
                              NeighborJ = NEc->edgeindex;
                              NEc = NEc->next;
                              }
                           else
                              {
                              ran = NULL;
                              continue;
                              }
                           }
                        }
                     Config2 = SCCtable[ran->Sindex].C;
                     Strat2 = SCCtable[ran->Sindex].S;
                     Domain2 = SCCtable[ran->Sindex].D;
                     if(CombinedCheckApplies(ran->idn,checkinstance,AUNDERSHTA,ran->Lindex,ran->Sindex,Config2,Strat2,Domain2,&part1,&part2,&part3) > 0)
                        {
                        if(part2 > 0)
                           {
                           foundpair = 0;
                           found_two = 0;
                           if(AListCount == 1)
                              {
                              if(ran->RB_Tree_Edgelist != NULL)
                                 {
                                 LastEdge2 = NULL;
                                 LastJ = -1;
                                 j = GetNextArealIndex(ran, LastJ, 1, &LastEdge2, cindex, &UsedTree);
                                 LastJ = j;
                                 }
                              else
                                 j = 0;
                              }
                           else
                              j = NeighborJ;

                           while(j >= 0)
                              {
                              if(j > 0)
                                 jj = j - 1;
                              else
                                 jj = ran->numverts - 1;

                              if(AListCount >= 1)
                                 {
                                 PassCond = 0;
                                 if((ran->x[j] <= (L1maxx + chktolerance)) && (ran->x[jj] >= (L1minx - chktolerance)))
                                    {
                                    if((ran->y[j] <= (L1maxy + chktolerance)) && (ran->y[jj] >= (L1miny - chktolerance)))
                                       PassCond = 1;
                                    else if((ran->y[jj] <= (L1maxy + chktolerance)) && (ran->y[j] >= (L1miny - chktolerance)))
                                       PassCond = 1;

                                    }
                                 else if((ran->x[jj] <= (L1maxx + chktolerance)) && (ran->x[j] >= (L1minx - chktolerance)))
                                    {
                                    if((ran->y[j] <= (L1maxy + chktolerance)) && (ran->y[jj] >= (L1miny - chktolerance)))
                                       PassCond = 1;
                                    else if((ran->y[jj] <= (L1maxy + chktolerance)) && (ran->y[j] >= (L1miny - chktolerance)))
                                       PassCond = 1;
                                    }


                                 if(PassCond < 1)
                                    {
                                    if(AListCount == 1)
                                       {
                                       if(ran->RB_Tree_Edgelist != NULL)
                                          {
                                          j = GetNextArealIndex(ran, LastJ, 1, &LastEdge2, cindex, &UsedTree);
                                          LastJ = j;
                                          }
                                       else
                                          {
                                          ++j;
                                          if(j >= ran->numverts)
                                             j = -1;
                                          }
                                       }
                                    else
                                       {
                                       j = -10;
                                       }

                                    continue;
                                    }
                                 }

                              if(LineSegmentsOverlap(rac->x[i],rac->y[i], rac->x[ii],rac->y[ii], ran->x[j],ran->y[j],ran->x[jj],ran->y[jj],
                                                   &x1, &y1, &x2, &y2, ActiveChecks[checkinstance].sensitivity /*0.01*/) > 0)
                                 {
                                 foundpair = 2;
                                 break; /*** break from the while j loop ***/
                                 }

                              ptldist1 = PointToLineDist2D(rac->x[i],rac->y[i], ran->x[j],ran->y[j],ran->x[jj],ran->y[jj]);

                              ptldist2 = PointToLineDist2D(rac->x[ii],rac->y[ii], ran->x[j],ran->y[j],ran->x[jj],ran->y[jj]);

                              ptldist1a = PointToLineDist2D(ran->x[j],ran->y[j], rac->x[i],rac->y[i],rac->x[ii],rac->y[ii]);

                              ptldist2a = PointToLineDist2D(ran->x[jj],ran->y[jj], rac->x[i],rac->y[i],rac->x[ii],rac->y[ii]);

                              whichline = 1;
                              if((ptldist1a + ptldist2a) < (ptldist1 + ptldist2))
                                 {
                                 ptldist1 = ptldist1a;
                                 ptldist2 = ptldist2a;
                                 whichline = 2;
                                 }

                              if((ptldist1 < ActiveChecks[checkinstance].sensitivity) &&
                                     (ptldist2 < ActiveChecks[checkinstance].sensitivity))
                                 {
                                 foundpair = 2;
                                 break; /*** break from the while j loop ***/
                                 }


                              PassCond = 0;
                              if((ptldist1 >= ActiveChecks[checkinstance].sensitivity) ||
                                    (ptldist2 >= ActiveChecks[checkinstance].sensitivity))
                                 {
                                 if(whichline == 1)
                                    ptldist2a = Distance(rac->x[i],rac->y[i],rac->x[ii],rac->y[ii]);
                                 else
                                    ptldist2a = Distance(ran->x[j],ran->y[j],ran->x[jj],ran->y[jj]);
                                 if(ptldist2a > 0)
                                    {
                                    if(ptldist1 < ptldist2)
                                       {
                                       ptldist2a = (ptldist2 - ptldist1) / ptldist2a;
                                       if(ptldist2a < temp2) //0.017)
                                          {
                                          PassCond = 1;
                                          }
                                       }
                                    else
                                       {
                                       /**ptldist2a = (ptldist1 * 0.70);
                                       if(ptldist2a  < ptldist2) ***/
                                       ptldist2a = (ptldist1 - ptldist2) / ptldist2a;
                                       if(ptldist2a < temp2) //0.017)
                                          {
                                          PassCond = 2;
                                          }
                                       }
                                    }

                                 if(PassCond > 0)
                                    {
                                    if(ptldist1 < ptldist2)
                                       {
                                       if((ActiveChecks[checkinstance].sensitivity < ptldist1) &&
                                          (ptldist1 < ActiveChecks[checkinstance].sensitivity2))
                                          {
                                          ptldistavg = ptldist1;
                                          }
                                       else if((ActiveChecks[checkinstance].sensitivity < ptldist2) &&
                                          (ptldist2 < ActiveChecks[checkinstance].sensitivity2))
                                          {
                                          ptldistavg = ptldist2;
                                          }
                                       }
                                    else
                                       {
                                       if((ActiveChecks[checkinstance].sensitivity < ptldist2) &&
                                          (ptldist2 < ActiveChecks[checkinstance].sensitivity2))
                                          {
                                          ptldistavg = ptldist2;
                                          }
                                       else if((ActiveChecks[checkinstance].sensitivity < ptldist1) &&
                                          (ptldist1 < ActiveChecks[checkinstance].sensitivity2))
                                          {
                                          ptldistavg = ptldist1;
                                          }
                                       }
                                     if(
                                         ((SensitivityCheck(OPENINT, AUNDERSHTA, checkinstance, ptldist1) > 0) ||
                                           (SensitivityCheck(OPENINT, AUNDERSHTA, checkinstance, ptldist2) > 0)))
                                       {
                                       PassCond2 = 0;
                                       if(ran->RB_Tree_Edgelist == NULL)
                                          {
                                          PassCond2 = PointInAreal(rac->x[i],rac->y[i],ran->x,ran->y,ran->numverts, &iii);
                                          if(PassCond2 == 0)
                                             PassCond2 = PointInAreal(rac->x[ii],rac->y[ii],ran->x,ran->y,ran->numverts, &iii);
                                          if(ran->ishole > 0)
                                             {
                                             if(PassCond2 == 0)
                                                PassCond2 = 1;
                                             else
                                                PassCond2 = 0;
                                             }
                                          }
                                       else
                                          {
                                          PassCond2 = PointInsideLargeAreal(rac->x[i],rac->y[i],ran, &iii);
                                          if(PassCond2 == 0)
                                             PassCond2 = PointInsideLargeAreal(rac->x[ii],rac->y[ii],ran, &iii);
                                          if(ran->ishole > 0)
                                             {
                                             if(PassCond2 == 0)
                                                PassCond2 = 1;
                                             else
                                                PassCond2 = 0;
                                             }
                                          }

                                       if(PassCond2 == 0)
                                          {
                                          if(rac->RB_Tree_Edgelist == NULL)
                                             {
                                             PassCond2 = PointInAreal(ran->x[j],ran->y[j],rac->x,rac->y,rac->numverts, &iii);
                                             if(PassCond2 == 0)
                                                PassCond2 = PointInAreal(ran->x[jj],ran->y[jj],rac->x,rac->y,rac->numverts, &iii);
                                             if(rac->ishole > 0)
                                                {
                                                if(PassCond2 == 0)
                                                   PassCond2 = 1;
                                                else
                                                   PassCond2 = 0;
                                                }
                                             }
                                          else
                                             {
                                             PassCond2 = PointInsideLargeAreal(ran->x[j],ran->y[j],rac, &iii);
                                             if(PassCond2 == 0)
                                                PassCond2 = PointInsideLargeAreal(ran->x[jj],ran->y[jj],rac, &iii);
                                             if(rac->ishole > 0)
                                                {
                                                if(PassCond2 == 0)
                                                   PassCond2 = 1;
                                                else
                                                   PassCond2 = 0;
                                                }
                                             }
                                          }

                                       if(PassCond2 == 0)
                                          {
                                          foundpair = 1;
                                          savei = i;
                                          saveii = ii;
                                          savej = j;
                                          savejj = jj;
                                          minptldist = ptldistavg;

                                          }
                                       else if(TwoArealsIntersect(rac, ran, &xi, &yi,
                                              &AOAindex1, &AOAindex2, &TouchingAreals) != 1)
                                          {
                                          PassCond2 = 0;
                                          foundpair = 1;
                                          savei = i;
                                          saveii = ii;
                                          savej = j;
                                          savejj = jj;
                                          minptldist = ptldistavg;
                                          }
                                       }
                                    }
                                 }
                              if(ran->RB_Tree_Edgelist != NULL)
                                 {
                                 LastEdge2 = NULL;
                                 j = GetNextArealIndex(ran, LastJ, 1, &LastEdge2, cindex, &UsedTree);
                                 LastJ = j;
                                 }
                              else
                                 {
                                 ++j;
                                 if(j >= ran->numverts)
                                    j = -1;
                                 }
                              } /** end while j >= 0 ***/
                           if(foundpair == 1) /*** now, should we back off on writing a condition based on 3d participant?***/
                              {
                              ra_3part = which_root;
                              while((foundpair == 1) && (ra_3part != NULL))
                                 {
                                 if((CombinedCheckApplies(ra_3part->idn,checkinstance,AUNDERSHTA,ra_3part->Lindex,rac->Sindex,
                                         SCCtable[ra_3part->Sindex].C,SCCtable[ra_3part->Sindex].S,SCCtable[ra_3part->Sindex].D,
                                         &ii3,&unusedint,&part3) > 0) &&
                                    (part3 > 0))
                                    {
                                    i3 = ra_3part->numverts - 1;
                                    for(i4 = 0; i4<ra_3part->numverts; i4++)
                                       {
                                       if(LineSegmentsOverlap(ran->x[savej],ran->y[savej], ran->x[savejj],ran->y[savejj],
                                                       ra_3part->x[i3],ra_3part->y[i3],ra_3part->x[i4],ra_3part->y[i4],
                                                        &x1, &y1, &x2, &y2, ActiveChecks[checkinstance].sensitivity) > 0)
                                          {
                                          foundpair = 9;
                                          break; /*** break from the for loop ***/
                                          }
                                       i3 = i4;
                                       }
                                    }
                                 if(AListCount == 1)
                                    ra_3part = ra_3part->next;
                                 else
                                    {
                                    if(NEc != NULL)
                                       {
                                       ra_3part = NEc->a;
                                       NeighborJ = NEc->edgeindex;
                                       NEc = NEc->next;
                                       }
                                    else
                                       {
                                       ra_3part = NULL;
                                       }
                                    }
                                 }
                              }
                           if(foundpair == 1) 
                              {
                              foundpair = 0;
                              ERc = (struct collection *) (malloc(SzC));
                              if(ERc == NULL)
                                 {
                                 printf("allocation memory exhausted during linear feature condition analysis\n");
                                 printf("processing cannot continue\n");
                                 exit(-1);
                                 }
                              ERc->magnitude = minptldist;
                              ERc->keyval = AUNDERSHTA;
                              ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                              ERc->Sindex1 = rac->Sindex;
                              ERc->Sindex2 = ran->Sindex;
                              ERc->x[0] = rac->x[savei];
                              ERc->y[0] = rac->y[savei];
                              ERc->z[0] = rac->z[savei];
                              ERc->x[1] = rac->x[saveii];
                              ERc->y[1] = rac->y[saveii];
                              ERc->z[1] = rac->z[saveii];

                              ERc->x[2] = ran->x[savej];
                              ERc->y[2] = ran->y[savej];
                              ERc->z[2] = ran->z[savej];
                              ERc->x[3] = ran->x[savejj];
                              ERc->y[3] = ran->y[savejj];
                              ERc->z[3] = ran->z[savejj];

                              ERc->aa = rac;
                              ERc->aa2 = ran;
                              ERc->next = NULL;
                              if(ERroot == NULL)
                                 {
                                 ERroot = ERc;
                                 }
                              else
                                 {
                                 ERn = ERroot;
                                 while(ERn != NULL)
                                    {
                                    if((ERn->Cnumber == ERc->Cnumber) && (ERn->keyval == ERc->keyval))
                                       {
                                       if((ERn->aa == ERc->aa) && (ERn->aa2 == ERc->aa2))
                                          {
                                          if((ERc->x[0] == ERn->x[0]) && (ERc->y[0] == ERn->y[0]) &&
                                            (ERc->x[1] == ERn->x[1]) && (ERc->y[1] == ERn->y[1]))
                                             {
                                             if((ERc->x[2] == ERn->x[2]) && (ERc->y[2] == ERn->y[2]) &&
                                                  (ERc->x[3] == ERn->x[3]) && (ERc->y[3] == ERn->y[3]))
                                                break;
                                             else if((ERc->x[3] == ERn->x[2]) && (ERc->y[3] == ERn->y[2]) &&
                                                  (ERc->x[2] == ERn->x[3]) && (ERc->y[2] == ERn->y[3]))
                                                break;
                                             }
                                          else if((ERc->x[1] == ERn->x[0]) && (ERc->y[1] == ERn->y[0]) &&
                                            (ERc->x[0] == ERn->x[1]) && (ERc->y[0] == ERn->y[1]))
                                             {
                                             if((ERc->x[2] == ERn->x[2]) && (ERc->y[2] == ERn->y[2]) &&
                                                  (ERc->x[3] == ERn->x[3]) && (ERc->y[3] == ERn->y[3]))
                                                break;
                                             else if((ERc->x[3] == ERn->x[2]) && (ERc->y[3] == ERn->y[2]) &&
                                                  (ERc->x[2] == ERn->x[3]) && (ERc->y[2] == ERn->y[3]))
                                                break;
                                             }
                                          }
                                       else if((ERn->aa == ERc->aa2) && (ERn->aa2 == ERc->aa))
                                          {
                                          if((ERc->x[0] == ERn->x[2]) && (ERc->y[0] == ERn->y[2]) &&
                                            (ERc->x[1] == ERn->x[3]) && (ERc->y[1] == ERn->y[3]))
                                             {
                                             if((ERc->x[2] == ERn->x[0]) && (ERc->y[2] == ERn->y[0]) &&
                                                  (ERc->x[3] == ERn->x[1]) && (ERc->y[3] == ERn->y[1]))
                                                break;
                                             else if((ERc->x[2] == ERn->x[1]) && (ERc->y[2] == ERn->y[1]) &&
                                                  (ERc->x[3] == ERn->x[0]) && (ERc->y[3] == ERn->y[0]))
                                                break;
                                             }
                                          else if((ERc->x[1] == ERn->x[2]) && (ERc->y[1] == ERn->y[2]) &&
                                            (ERc->x[0] == ERn->x[3]) && (ERc->y[0] == ERn->y[3]))
                                             {
                                             if((ERc->x[2] == ERn->x[0]) && (ERc->y[2] == ERn->y[0]) &&
                                                  (ERc->x[3] == ERn->x[1]) && (ERc->y[3] == ERn->y[1]))
                                                break;
                                             else if((ERc->x[3] == ERn->x[0]) && (ERc->y[3] == ERn->y[0]) &&
                                                  (ERc->x[2] == ERn->x[1]) && (ERc->y[2] == ERn->y[1]))
                                                break;
                                             }
                                          }
                                       }

                                    ERn = ERn->next;
                                    }
                                 if(ERn == NULL)
                                    {
                                    ERc->next = ERroot;
                                    ERroot = ERc;
                                    }
                                 else
                                   free(ERc);
                                 }
                              } /*** end foundpair so make a condition ***/

                           } /*** end if part 2 ***/
                        } /** end check applies to ran ***/
                     if(AListCount == 1)
                        ran = ran->next;
                     else
                        {
                        if(NEc != NULL)
                           {
                           ran = NEc->a;
                           NeighborJ = NEc->edgeindex;
                           NEc = NEc->next;
                           }
                        else
                           {
                           ran = NULL;
                           break;
                           }
                        }
                     } /*** end while ran ***/

                     AListCount += 1;
                     } /*** end while AListCount < 6 ***/
                  if(rac->RB_Tree_Edgelist != NULL)
                     {
                     i = GetNextArealIndex(rac, LastI, 1, &LastEdge1, cindex, &UsedTree);
                     LastI = i;
                     }
                  else
                     {
                     ++i;
                     if(i >= rac->numverts)
                        i = -1;
                     }

                  } /** end while i >= 0 ***/
               } /*** end if part1 ***/
            }  /**** end AUNDERSHTA inspection  *****/




         if(CombinedCheckApplies(rac->idn,checkinstance,AOVERSHTA,rac->Lindex,rac->Sindex,Config1,Strat1,Domain1,&part1,&part2,&part3) > 0)
            {
            if(part1 > 0)
               {
               temp2 = (ActiveChecks[checkinstance].sensitivity3 * PIvalue) / 180.0;
               unuseddbl = FindRelevantSensitivity(AOVERSHTA,checkinstance,&chktolerance);
               if(rac->RB_Tree_Edgelist != NULL)
                  {
                  LastEdge1 = NULL;
                  LastI = -1;
                  i = GetNextArealIndex(rac, LastI, 1, &LastEdge1, cindex, &UsedTree);
                  LastI = i;
                  }
               else
                  i = 0;

               while(i >= 0)
                  {
                  if(i > 0)
                     ii = i - 1;
                  else
                     ii = rac->numverts - 1;

                  if((rac->x[i] >= minx) && (rac->x[i] <= maxx) && (rac->y[i] >= miny) && (rac->y[i] <= maxy))
                     AListCount = 1;
                  else if((rac->x[ii] >= minx) && (rac->x[ii] <= maxx) && (rac->y[ii] >= miny) && (rac->y[ii] <= maxy))
                     AListCount = 1;
                  else
                     AListCount = 10;

                  if(AListCount == 1)
                     {
                     minptldist = chktolerance * 10.0;

                     if(rac->x[ii] < rac->x[i])
                        {
                        L1minx = rac->x[ii];
                        L1maxx = rac->x[i];
                        xt1 = rac->x[i] - rac->x[ii];
                        yt1 = rac->y[i] - rac->y[ii];
                        }
                     else
                        {
                        L1minx = rac->x[i];
                        L1maxx = rac->x[ii];
                        xt1 = rac->x[ii] - rac->x[i];
                        yt1 = rac->y[ii] - rac->y[i];
                        }
                     if(rac->y[ii] < rac->y[i])
                        {
                        L1miny = rac->y[ii];
                        L1maxy = rac->y[i];
                        }
                     else
                        {
                        L1miny = rac->y[i];
                        L1maxy = rac->y[ii];
                        }
                     }

                     
                  ran = /**rac->next; **/ root; /***/
                  while((AListCount < 10) && (ran != NULL))
                     {
                     if(ran == rac)
                        {
                        ran  = ran->next;
                        if(ran == NULL)
                           continue;
                        }
                     Config2 = SCCtable[ran->Sindex].C;
                     Strat2 = SCCtable[ran->Sindex].S;
                     Domain2 = SCCtable[ran->Sindex].D;
                     if(CombinedCheckApplies(ran->idn,checkinstance,AOVERSHTA,ran->Lindex,ran->Sindex,Config2,Strat2,Domain2,&part1,&part2,&part3) > 0)
                        {
                        if(part2 > 0)
                           {
                           foundpair = 0;
                              
                           if(ran->RB_Tree_Edgelist != NULL)
                              {
                              LastEdge2 = NULL;
                              LastJ = -1;
                              j = GetNextArealIndex(ran, LastJ, 1, &LastEdge2, cindex, &UsedTree);
                              LastJ = j;
                              }
                           else
                              j = 0;

                           while(j >= 0)
                              {
                              /**jj = (j + 1) % ran->numverts; **/
                              /**/if(j > 0)
                                 jj = j - 1;
                              else
                                 jj = ran->numverts - 1;/**/


                              PassCond = 0;
                              if((ran->x[j] <= (L1maxx + chktolerance)) && (ran->x[jj] >= (L1minx - chktolerance)))
                                 {
                                 if((ran->y[j] <= (L1maxy + chktolerance)) && (ran->y[jj] >= (L1miny - chktolerance)))
                                    PassCond = 1;
                                 else if((ran->y[jj] <= (L1maxy + chktolerance)) && (ran->y[j] >= (L1miny - chktolerance)))
                                    PassCond = 1;
                                 }
                              else if((ran->x[jj] <= (L1maxx + chktolerance)) && (ran->x[j] >= (L1minx - chktolerance)))
                                 {
                                 if((ran->y[j] <= (L1maxy + chktolerance)) && (ran->y[jj] >= (L1miny - chktolerance)))
                                    PassCond = 1;
                                 else if((ran->y[jj] <= (L1maxy + chktolerance)) && (ran->y[j] >= (L1miny - chktolerance)))
                                    PassCond = 1;
                                 }

                              if(PassCond > 0)
                                 {
                                 if(AdjacentLineSegments(rac->x[i],rac->y[i], rac->x[ii],rac->y[ii],
                                                        ran->x[j],ran->y[j],ran->x[jj],ran->y[jj],0.1) < 1)
                                    PassCond = 0;
                                 }

                              if(PassCond < 1)
                                 {
                                 if(ran->RB_Tree_Edgelist != NULL)
                                    {
                                    j = GetNextArealIndex(ran, LastJ, 1, &LastEdge2, cindex, &UsedTree);
                                    LastJ = j;
                                    }
                                 else
                                    {
                                    ++j;
                                    if(j >= ran->numverts)
                                       j = -1;
                                    }
                                 continue;
                                 }

                              if(LineSegmentsOverlap(rac->x[i],rac->y[i], rac->x[ii],rac->y[ii], ran->x[j],ran->y[j],ran->x[jj],ran->y[jj],
                                                   &x1, &y1, &x2, &y2,ActiveChecks[checkinstance].sensitivity/*0.01*/) > 0)
                                 {
                                 foundpair = 2;
                                 break; /*** break from the while j loop ***/
                                 }

                              ptldist1 = PointToLineDist2D(rac->x[i],rac->y[i], ran->x[j],ran->y[j],ran->x[jj],ran->y[jj]);

                              ptldist2 = PointToLineDist2D(rac->x[ii],rac->y[ii], ran->x[j],ran->y[j],ran->x[jj],ran->y[jj]);

                              ptldist1a = PointToLineDist2D(ran->x[j],ran->y[j], rac->x[i],rac->y[i],rac->x[ii],rac->y[ii]);

                              ptldist2a = PointToLineDist2D(ran->x[jj],ran->y[jj], rac->x[i],rac->y[i],rac->x[ii],rac->y[ii]);

                              whichline = 1;
                              if((ptldist1a + ptldist2a) < (ptldist1 + ptldist2))
                                 {
                                 ptldist1 = ptldist1a;
                                 ptldist2 = ptldist2a;
                                 whichline = 2;
                                 }

                              if((ptldist1 < ActiveChecks[checkinstance].sensitivity) &&
                                     (ptldist2 < ActiveChecks[checkinstance].sensitivity))
                                 {
                                 foundpair = 2;
                                 break; /*** break from the while j loop ***/
                                 }


                              PassCond = 0;
                              if((ptldist1 >= ActiveChecks[checkinstance].sensitivity) ||
                                    (ptldist2 >= ActiveChecks[checkinstance].sensitivity))
                                 {
ptldist2a = FindAcuteAngleBetweenSegments(rac->x[i],rac->y[i],rac->x[ii],rac->y[ii],
                                            ran->x[j],ran->y[j],ran->x[jj],ran->y[jj]);

if(ptldist2a < temp2)
PassCond = 1;

                                 if(PassCond > 0)
                                    {
                                    if(ptldist1 < ptldist2)
                                       {
                                       if((ActiveChecks[checkinstance].sensitivity < ptldist1) && 
                                          (ptldist1 < ActiveChecks[checkinstance].sensitivity2))
                                          {
                                          ptldistavg = ptldist1;
                                          }
                                       else if((ActiveChecks[checkinstance].sensitivity < ptldist2) &&
                                          (ptldist2 < ActiveChecks[checkinstance].sensitivity2))
                                          {
                                          ptldistavg = ptldist2;
                                          }
                                       }
                                    else
                                       {
                                       if((ActiveChecks[checkinstance].sensitivity < ptldist2) &&
                                          (ptldist2 < ActiveChecks[checkinstance].sensitivity2))
                                          {
                                          ptldistavg = ptldist2;
                                          }
                                       else if((ActiveChecks[checkinstance].sensitivity < ptldist1) &&
                                          (ptldist1 < ActiveChecks[checkinstance].sensitivity2))
                                          {
                                          ptldistavg = ptldist1;
                                          }
                                       }
                                    if(
                                         ((SensitivityCheck(OPENINT, AOVERSHTA, checkinstance, ptldist1) > 0) ||
                                           (SensitivityCheck(OPENINT, AOVERSHTA, checkinstance, ptldist2) > 0)))
                                       {
                                       PassCond2 = 0;
                                       if(ran->RB_Tree_Edgelist == NULL)
                                          {
                                          PassCond2 = PointInAreal(rac->x[i],rac->y[i],ran->x,ran->y,ran->numverts, &iii);
                                          if(PassCond2 == 0)
                                             PassCond2 = PointInAreal(rac->x[ii],rac->y[ii],ran->x,ran->y,ran->numverts, &iii);
                                          if(ran->ishole > 0)
                                             {
                                             if(PassCond2 == 0)
                                                PassCond2 = 1;
                                             else
                                                PassCond2 = 0;
                                             }
                                          }
                                       else
                                          {
                                          PassCond2 = PointInsideLargeAreal(rac->x[i],rac->y[i],ran, &iii);
                                          if(PassCond2 == 0)
                                             PassCond2 = PointInsideLargeAreal(rac->x[ii],rac->y[ii],ran, &iii);
                                          if(ran->ishole > 0)
                                             {
                                             if(PassCond2 == 0)
                                                PassCond2 = 1;
                                             else
                                                PassCond2 = 0;
                                             }
                                          }
                                       if(PassCond2 == 0)
                                          {
                                          if(rac->RB_Tree_Edgelist == NULL)
                                             {
                                             PassCond2 = PointInAreal(ran->x[j],ran->y[j],rac->x,rac->y,rac->numverts, &iii);
                                             if(PassCond2 == 0)
                                                PassCond2 = PointInAreal(ran->x[jj],ran->y[jj],rac->x,rac->y,rac->numverts, &iii);
                                             if(rac->ishole > 0)
                                                {
                                                if(PassCond2 == 0)
                                                   PassCond2 = 1;
                                                else
                                                   PassCond2 = 0;
                                                }
                                             }
                                          else
                                             {
                                             PassCond2 = PointInsideLargeAreal(ran->x[j],ran->y[j],rac, &iii);
                                             if(PassCond2 == 0)
                                                PassCond2 = PointInsideLargeAreal(ran->x[jj],ran->y[jj],rac, &iii);
                                             if(rac->ishole > 0)
                                                {
                                                if(PassCond2 == 0)
                                                   PassCond2 = 1;
                                                else
                                                   PassCond2 = 0;
                                                }
                                             }
                                          }

                                       if(PassCond2 == 1)
                                          {
                                          ii3 = TwoArealsIntersect(rac, ran, &xi, &yi, &AOAindex1, &AOAindex2, &TouchingAreals); 
                                          if(ii3 > 0)
                                             {
                                             foundpair = 1;
                                             savei = i;
                                             saveii = ii;
                                             savej = j;
                                             savejj = jj;
                                             minptldist = ptldistavg;
                                             }
                                          else
                                             PassCond2 = 0;
                                          }
                                       /**break; *** should break from the while j loop ***/
                                       }
                                    }
                                 }
                              if(ran->RB_Tree_Edgelist != NULL)
                                 {
                                 j = GetNextArealIndex(ran, LastJ, 1, &LastEdge2, cindex, &UsedTree);
                                 LastJ = j;
                                 }
                              else
                                 {
                                 ++j;
                                 if(j >= ran->numverts)
                                    j = -1;
                                 }
                              } /** end while j >= 0 ***/
                           if(foundpair == 1)
                              {
                              foundpair = 0;
                              ERc = (struct collection *) (malloc(SzC));
                              if(ERc == NULL)
                                 {
                                 printf("allocation memory exhausted during linear feature condition analysis\n");
                                 printf("processing cannot continue\n");
                                 exit(-1);
                                 }
                              ERc->magnitude = minptldist;
                              ERc->keyval = AOVERSHTA;
                              ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                              ERc->Sindex1 = rac->Sindex;
                              ERc->Sindex2 = ran->Sindex;
                              ERc->x[0] = rac->x[savei];
                              ERc->y[0] = rac->y[savei];
                              ERc->z[0] = rac->z[savei];
                              ERc->x[1] = rac->x[saveii];
                              ERc->y[1] = rac->y[saveii];
                              ERc->z[1] = rac->z[saveii];

                              ERc->x[2] = ran->x[savej];
                              ERc->y[2] = ran->y[savej];
                              ERc->z[2] = ran->z[savej];
                              ERc->x[3] = ran->x[savejj];
                              ERc->y[3] = ran->y[savejj];
                              ERc->z[3] = ran->z[savejj];

                              ERc->aa = rac;
                              ERc->aa2 = ran;
                              ERc->next = NULL;
                              if(ERroot == NULL)
                                 {
                                 ERroot = ERc;
                                 }
                              else
                                 {
                                 ERn = ERroot;
                                 while(ERn != NULL)
                                    {
                                    if((ERn->Cnumber == ERc->Cnumber) && (ERn->keyval == ERc->keyval))
                                       {
                                       if((ERn->aa == ERc->aa) && (ERn->aa2 == ERc->aa2))
                                          {
                                          if((ERc->x[0] == ERn->x[0]) && (ERc->y[0] == ERn->y[0]) &&
                                            (ERc->x[1] == ERn->x[1]) && (ERc->y[1] == ERn->y[1]))
                                             {
                                             if((ERc->x[2] == ERn->x[2]) && (ERc->y[2] == ERn->y[2]) &&
                                                  (ERc->x[3] == ERn->x[3]) && (ERc->y[3] == ERn->y[3]))
                                                break;
                                             else if((ERc->x[3] == ERn->x[2]) && (ERc->y[3] == ERn->y[2]) &&
                                                  (ERc->x[2] == ERn->x[3]) && (ERc->y[2] == ERn->y[3]))
                                                break;
                                             }
                                          else if((ERc->x[1] == ERn->x[0]) && (ERc->y[1] == ERn->y[0]) &&
                                            (ERc->x[0] == ERn->x[1]) && (ERc->y[0] == ERn->y[1]))
                                             {
                                             if((ERc->x[2] == ERn->x[2]) && (ERc->y[2] == ERn->y[2]) &&
                                                  (ERc->x[3] == ERn->x[3]) && (ERc->y[3] == ERn->y[3]))
                                                break;
                                             else if((ERc->x[3] == ERn->x[2]) && (ERc->y[3] == ERn->y[2]) &&
                                                  (ERc->x[2] == ERn->x[3]) && (ERc->y[2] == ERn->y[3]))
                                                break;
                                             }
                                          }
                                       else if((ERn->aa == ERc->aa2) && (ERn->aa2 == ERc->aa))
                                          {
                                          if((ERc->x[0] == ERn->x[2]) && (ERc->y[0] == ERn->y[2]) &&
                                            (ERc->x[1] == ERn->x[3]) && (ERc->y[1] == ERn->y[3]))
                                             {
                                             if((ERc->x[2] == ERn->x[0]) && (ERc->y[2] == ERn->y[0]) &&
                                                  (ERc->x[3] == ERn->x[1]) && (ERc->y[3] == ERn->y[1]))
                                                break;
                                             else if((ERc->x[3] == ERn->x[0]) && (ERc->y[3] == ERn->y[0]) &&
                                                  (ERc->x[2] == ERn->x[1]) && (ERc->y[2] == ERn->y[1]))
                                                break;
                                             }
                                          else if((ERc->x[1] == ERn->x[2]) && (ERc->y[1] == ERn->y[2]) &&
                                            (ERc->x[0] == ERn->x[3]) && (ERc->y[0] == ERn->y[3]))
                                             {
                                             if((ERc->x[2] == ERn->x[0]) && (ERc->y[2] == ERn->y[0]) &&
                                                  (ERc->x[3] == ERn->x[1]) && (ERc->y[3] == ERn->y[1]))
                                                break;
                                             else if((ERc->x[3] == ERn->x[0]) && (ERc->y[3] == ERn->y[0]) &&
                                                  (ERc->x[2] == ERn->x[1]) && (ERc->y[2] == ERn->y[1]))
                                                break;
                                             }
                                          }
                                       }

                                    ERn = ERn->next;
                                    }
                                 if(ERn == NULL)
                                    {
                                    ERc->next = ERroot;
                                    ERroot = ERc;
                                    }
                                 else
                                   free(ERc);
                                 }
                              } /*** end foundpair so make a condition ***/
                           } /*** end if part 2 ***/
                        } /** end check applies to ran ***/
                     ran = ran->next;
                     } /*** end while ran ***/

                  if(rac->RB_Tree_Edgelist != NULL)
                     {
                     i = GetNextArealIndex(rac, LastI, 1, &LastEdge1, cindex, &UsedTree);
                     LastI = i;
                     }
                  else
                     {
                     ++i;
                     if(i >= rac->numverts)
                        i = -1;
                     }

                  } /** end while i >= 0 ***/
               } /*** end if part1 ***/
            }  /**** end AOVERSHTA inspection  *****/



         if((CombinedCheckApplies(rac->idn,checkinstance,CONNECTFAIL,rac->Lindex,rac->Sindex,Config1,Strat1,Domain1,&part1,&part2,&part3) > 0) &&
                     (part1 > 0))
            {
            mindist = 100000.0;
            if(rac->ismulti == 1) /** a multi-region line - may have cehcked before ***/
               {
               RB_newKey2 = rac->idn + (checkinstance * 0.0001);
               if(( RB_newNode = RBExactQuery(Check_RB_Tree,&RB_newKey2)))
                  {
                  RB_cond = (struct ConditionCollection *) RB_newNode->info;
                  if(RB_cond->counter >= 1)
                     {
                     mindist = 0.0;
                     }
                  }
               }
            if(mindist > 1000) /*** then did not find it as already solved ***/
               {
               isclose = 0;
               if(rac->RB_Tree_Edgelist != NULL)
                  {
                  LastI = -1;
                  LastEdge1 = NULL;
                  ii = GetNextArealIndex(rac, LastI, 1, &LastEdge1, cindex, &UsedTree);
                  LastI = ii;
                  }
               else
                  {
                  ii = 0;
                  }
               while((ii >= 0) && (ii < rac->numverts))
                  {
                  if((rac->x[ii] >= minx) && (rac->x[ii] <= maxx) && (rac->y[ii] >= miny) && (rac->y[ii] <= maxy))
                     {
                     rpc = Proot;
                     while(rpc != NULL)
                        {
                        Config2 = SCCtable[rpc->Sindex].C;
                        Strat2 = SCCtable[rpc->Sindex].S;
                        Domain2 = SCCtable[rpc->Sindex].D;
                        if((rpc->numverts == -1) && /** rpc is a pure point ***/
                          (CombinedCheckApplies(rpc->idn,checkinstance,CONNECTFAIL,rpc->Lindex,rpc->Sindex,Config2,Strat2,Domain2,&part1,&part2,&part3) > 0) &&
                              (part2 > 0))
                           {
                           ptldist1 = Distance(rac->x[ii],rac->y[ii],rpc->x[0],rpc->y[0]);
                           if(SensitivityCheck(LTEQ, CONNECTFAIL, checkinstance, ptldist1) > 0)
                              {
                              isclose = 1;
                              break;
                              }
                           }
                        rpc = rpc->next;
                        } /*** end while looking at neighbor points ***/

                     if(isclose == 0)
                        {
                        rlc = Lroot;
                        while(rlc != NULL)
                           {
                           Config2 = SCCtable[rlc->Sindex].C;
                           Strat2 = SCCtable[rlc->Sindex].S;
                           Domain2 = SCCtable[rlc->Sindex].D;
                           if((CombinedCheckApplies(rlc->idn,checkinstance,CONNECTFAIL,rlc->Lindex,rlc->Sindex,Config2,Strat2,Domain2,&part1,&part2,&part3) > 0))
                              {
                              if(part2 > 0)
                                 {
                                 for(j=0; j<rlc->numnodes; j++)
                                    {
                                    if((rlc->x[j] >= minx) && (rlc->x[j] <= maxx) && (rlc->y[j] >= miny) && (rlc->y[j] <= maxy))
                                       {
                                       ptldist1 = Distance(rac->x[ii], rac->y[ii], rlc->x[j], rlc->y[j]);
                                       if(SensitivityCheck(LTEQ, CONNECTFAIL, checkinstance, ptldist1) > 0)
                                          {
                                          isclose = 1;
                                          break;  /*** break from the for loop ***/
                                          } /**** end if(SensitivityCheck****/
                                       }
                                    } /*** end for(j=1; j<rlc->numnodes; j++) ***/
                                 }
                              }
                           if(isclose > 0)
                              break;
                           rlc = rlc->next;
                           }
                        }

                     if(isclose == 0)
                        {
                        ran = root;
                        while((ran != NULL) && (isclose == 0))
                           {
                           if(ran != rac)
                              {
                              Config2 = SCCtable[ran->Sindex].C;
                              Strat2 = SCCtable[ran->Sindex].S;
                              Domain2 = SCCtable[ran->Sindex].D;
                              if((CombinedCheckApplies(ran->idn,checkinstance,CONNECTFAIL,ran->Lindex,ran->Sindex,Config2,Strat2,Domain2,&part1,&part2,&part3) > 0)
                                   && (part2 > 0))
                                 {
                                 if(ran->RB_Tree_Edgelist != NULL)
                                    {
                                    LastEdge2 = NULL;
                                    LastJ = -1;
                                    j = GetNextArealIndex(ran, LastJ, 1, &LastEdge2, cindex, &UsedTree);
                                    LastJ = j;
                                    }
                                 else
                                    j = 0;
                                 while((j >= 0) && (j < ran->numverts))
                                    {
                                    if((ran->x[j] >= minx) && (ran->x[j] <= maxx) && (ran->y[j] >= miny) && (ran->y[j] <= maxy))
                                       {
                                       ptldist1 = Distance(rac->x[ii], rac->y[ii], ran->x[j],ran->y[j]);
                                       if(SensitivityCheck(LTEQ, CONNECTFAIL, checkinstance, ptldist1) > 0) 
                                          {
                                          isclose = 1;
                                          break;
                                          }
                                       }
                                    if(ran->RB_Tree_Edgelist != NULL)
                                       {
                                       j = GetNextArealIndex(ran, LastJ, 1, &LastEdge2, cindex, &UsedTree);
                                       LastJ = j;
                                       }
                                    else
                                       ++j;
                                    }
                                 }
                              }
                           if(isclose > 0)
                              break;
                           ran = ran->next;
                           }
                        }
                     } /** end if((rac->x[ii] >= minx) && ....   ***/
                  if(rac->RB_Tree_Edgelist != NULL)
                     {
                     ii = GetNextArealIndex(rac, LastI, 1, &LastEdge1, cindex, &UsedTree);
                     LastI = ii;
                     }
                  else
                     ++ii;
                  } /** end while(ii ...  **/

               if((isclose == 0) && (rac->ismulti == 0))
                  {
                  ERc = (struct collection *) (malloc(SzC));
                  if(ERc == NULL)
                     {
                     printf("allocation memory exhausted during point feature condition analysis\n");
                     printf("processing cannot continue\n");
                     exit(-1);
                     }
                  ERc->x[0] = rac->x[0];
                  ERc->y[0] = rac->y[0];
                  ERc->z[0] = rac->z[0];
                  ERc->x[1] = rac->x[1];
                  ERc->y[1] = rac->y[1];
                  ERc->z[1] = rac->z[1];
                  ERc->magnitude = 0;
                  ERc->keyval = CONNECTFAIL;
                  ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                  ERc->Sindex1 = rac->Sindex;
                  ERc->IDN1 = rac->idn;
                  ERc->aa = rac;
                  ERc->next = NULL;
                  if(ERroot == NULL)
                     {
                     ERroot = ERc;
                     }
                  else
                    {
                      ERn = ERroot;
                      while(ERn != NULL)
                        {
                          if((ERn->aa == ERc->aa) && (ERn->Cnumber  == ERc->Cnumber)  && (ERn->keyval  == ERc->keyval))
                             {
                             if((ERn->x[0]   == ERc->x[0])   && (ERn->y[0]   == ERc->y[0])   &&
                                        (ERn->Sindex1 == ERc->Sindex1))
                               {
                                  break;
                               }
                            }
                          ERn = ERn->next;
                        }
                     if(ERn == NULL)
                        {
                        ERc->next = ERroot;
                        ERroot = ERc;
                        }
                     else
                        {
                        free(ERc);
                        } 
                     }
                  }
               else if(rac->ismulti > 0)   /** need to add result - even if found a connection, some other LM may have the line, but no connection **/
                  {
                  RB_newKey2 = rac->idn + (checkinstance * 0.0001);
                  if(( RB_newNode = RBExactQuery(Check_RB_Tree,&RB_newKey2)))
                     {
                     RB_cond = (struct ConditionCollection *) RB_newNode->info;
                     RB_cond->counter += isclose;
                     }
                  else
                     {
                     RB_cond = (struct ConditionCollection *) (malloc(SzCC));
                     if(RB_cond == NULL)
                        {
                        printf("memory has been exhausted during RB-Tree information alloction for CONNECTFAIL analysis\n");
                        exit(-1);
                        }
                     RB_cond->keyval = CONNECTFAIL;
                     RB_cond->Cnumber =  Make_Correct(CONNECTFAIL,checkinstance);
                     RB_cond->index_from_to = NULL;
                     RB_cond->gform = G_AREAL;
                     RB_cond->featureidn = rac->featureid;
                     RB_cond->localID = rac->localID;
                     RB_cond->counter = isclose;
                     RB_cond->radius = -1;
                     RB_cond->height = -1;
                     RB_cond->magnitude = 0.0;
                     RB_cond->IDN = rac->idn;
                     RB_cond->Sindex = rac->Sindex;
                     RB_cond->Lindex = rac->Lindex;

                     RB_cond->numnodes = 2;
                     RB_cond->x = (double *) (malloc(2 * SzD));
                     RB_cond->y = (double *) (malloc(2 * SzD));
                     RB_cond->z = (double *) (malloc(2 * SzD));
                     if(RB_cond->z == NULL)
                        {
                        printf("memory has been exhausted during RB-Tree element vertex alloction for CONNECTFAIL analysis\n");
                        exit(-1);
                        }
                     for(jj=0; jj< 2; jj++)
                        {
                        RB_cond->x[jj] = rac->x[jj];
                        RB_cond->y[jj] = rac->y[jj];
                        RB_cond->z[jj] = rac->z[jj];
                        }

                  RB_newDbl = (double *) (malloc(SzD));
                  if(RB_newDbl == NULL)
                     {
                     printf("memory has been exhausted during RB-Tree alloction for CONNECTFAIL analysis\n");
                     exit(-1);
                     }
                  *RB_newDbl = RB_newKey2; /**rac->localID; **/
                  RBTreeInsert(Check_RB_Tree,RB_newDbl, RB_cond);
                     }
                  }
               } /** end if(mindist > 1000) ***/


            } /** end CONNECTFAIL check for primary line feature ***/

          if((rac->firstindex == cindex) &&
              (OSIDE_LatLon_Count < OSIDE_LL_Limit) &&
                  (CombinedCheckApplies(rac->idn,checkinstance,OSIDE_LAT,rac->Lindex,rac->Sindex,
                             Config1,Strat1,Domain1,&part1,&part2,&part3) > 0) && (part1 > 0))
             {
             temp = FindRelevantSensitivity(OSIDE_LAT, checkinstance, &temp2);

             temp = YCoordToProjectCoord(temp);
             temp2 = YCoordToProjectCoord(temp2);

             if(temp2 < temp)
                {
                unuseddbl = temp2;
                temp = temp2;
                temp2 = unuseddbl;
                }
            temp -= ActiveChecks[checkinstance].sensitivity3;
            temp2 += ActiveChecks[checkinstance].sensitivity3;


             for(j=0; j<rac->numverts; j++)
                {
                if((rac->y[j] < temp) || (rac->y[j] > temp2))
                    {
                    ++OSIDE_LatLon_Count;
                    ERc = (struct collection *) (malloc(SzC));
                    if(ERc == NULL)
                      {
                      printf("allocation memory exhausted during linear feature condition analysis (Z-shear analysis)\n");
                      printf("processing cannot continue\n");
                      exit(-1);
                      }
                    if(rac->y[j] > temp2)
                       ERc->magnitude = rac->y[j] - temp2;
                    else
                       ERc->magnitude = temp - rac->y[j];
                    ERc->x[0] = rac->x[j];
                    ERc->y[0] = rac->y[j];
                    ERc->z[0] = rac->z[j];
                    ERc->IDN1 = rac->idn;
                    ERc->Sindex1 = rac->Sindex;
                    ERc->aa = rac; /** RawAreal **/
                    ERc->keyval = OSIDE_LAT;
                    ERc->Cnumber = Make_Correct(OSIDE_LAT,checkinstance);

                    if(ERroot == NULL)
                       {
                       ERroot = ERc;
                       ERroot->next = NULL;                                }
                    else
                       {
                       ERn = ERroot;
                       while(ERn != NULL)
                          {
                          if((ERn->keyval == ERc->keyval) && (ERc->Cnumber == ERn->Cnumber) && (ERn->aa == ERc->aa))
                             {
                             if((ERn->x[0] == ERc->x[0]) && (ERn->y[0] == ERc->y[0]))
                                break;
                             }
                          ERn = ERn->next;
                          }
                       if(ERn == NULL)
                          {
                          ERc->next = ERroot;
                          ERroot = ERc;
                          }
                       else
                          {
                          free(ERc);
                          }
                       }
                    }
                }
             }


          if((rac->firstindex == cindex) &&
             (OSIDE_LatLon_Count < OSIDE_LL_Limit) &&
                      (CombinedCheckApplies(rac->idn,checkinstance,OSIDE_LON,rac->Lindex,rac->Sindex,
                             Config1,Strat1,Domain1,&part1,&part2,&part3) > 0) && (part1 > 0))
             {
             temp = FindRelevantSensitivity(OSIDE_LON, checkinstance, &temp2);

             temp = XCoordToProjectCoord(temp);
             temp2 = XCoordToProjectCoord(temp2);

             if(temp2 < temp)
                {
                unuseddbl = temp2;
                temp = temp2;
                temp2 = unuseddbl;
                }
            temp -= ActiveChecks[checkinstance].sensitivity3;
            temp2 += ActiveChecks[checkinstance].sensitivity3;

             for(j=0; j<rac->numverts; j++)
                {
                if((rac->x[j] < temp) || (rac->x[j] > temp2))
                    {
                    ++OSIDE_LatLon_Count;
                    ERc = (struct collection *) (malloc(SzC));
                    if(ERc == NULL)
                      {
                      printf("allocation memory exhausted during linear feature condition analysis (Z-shear analysis)\n");
                      printf("processing cannot continue\n");
                      exit(-1);
                      }
                    if(rac->x[j] > temp2)
                       ERc->magnitude = rac->x[j] - temp2;
                    else
                       ERc->magnitude = temp - rac->x[j];
                    ERc->x[0] = rac->x[j];
                    ERc->y[0] = rac->y[j];
                    ERc->z[0] = rac->z[j];
                    ERc->IDN1 = rac->idn;
                    ERc->Sindex1 = rac->Sindex;
                    ERc->aa = rac; /** RawAreal **/
                    ERc->keyval = OSIDE_LON;
                    ERc->Cnumber = Make_Correct(OSIDE_LON,checkinstance);

                    if(ERroot == NULL)
                       {
                       ERroot = ERc;
                       ERroot->next = NULL;                                }
                    else
                       {
                       ERn = ERroot;
                       while(ERn != NULL)
                          {
                          if((ERn->keyval == ERc->keyval) && (ERc->Cnumber == ERn->Cnumber) && (ERn->aa == ERc->aa))
                             {
                             if((ERn->x[0] == ERc->x[0]) && (ERn->y[0] == ERc->y[0]))
                                break;
                             }
                          ERn = ERn->next;
                          }
                       if(ERn == NULL)
                          {
                          ERc->next = ERroot;
                          ERroot = ERc;
                          }
                       else
                          {
                          free(ERc);
                          }
                       }
                    }
                }
             }




          if((rac->firstindex == cindex)&& (CombinedCheckApplies(rac->idn,checkinstance,FEATOUTSIDE,rac->Lindex,rac->Sindex,
                             Config1,Strat1,Domain1,&part1,&part2,&part3) > 0) && (part1 > 0))
             {
             j = 0;
             FoundCondition = 0;
             tolerancepad = FindRelevantSensitivity(FEATOUTSIDE,checkinstance,&unuseddbl);
             while(j < rac->numverts)
                {
                if(rac->x[j] > LAEmaxx)
                    {
                    ptldist1 = Distance(rac->x[j],rac->y[j],LAEmaxx,rac->y[j]);
                    if(ptldist1 > tolerancepad)
                       FoundCondition = 1;
                    }
                if((FoundCondition  == 0) && (rac->x[j] < LAEminx))
                    {
                    ptldist1 = Distance(rac->x[j],rac->y[j],LAEminx,rac->y[j]);
                    if(ptldist1 > tolerancepad)
                       FoundCondition = 1;
                    }
                if((FoundCondition  == 0) && (rac->y[j] > LAEmaxy))
                    {
                    ptldist1 = Distance(rac->x[j],rac->y[j],rac->x[j],LAEmaxy);
                    if(ptldist1 > tolerancepad)
                       FoundCondition = 1;
                    }
                if((FoundCondition  == 0) && (rac->y[j] < LAEminy))
                    {
                    ptldist1 = Distance(rac->x[j],rac->y[j],rac->x[j],LAEminy);
                    if(ptldist1 > tolerancepad)
                       FoundCondition = 1;
                    }
                if(FoundCondition > 0)
                   {
                   FoundCondition = 0;
                   ERc = (struct collection *) (malloc(SzC));
                   if(ERc == NULL)
                     {
                     printf("allocation memory exhausted during linear feature condition analysis (Z-shear analysis)\n");
                     printf("processing cannot continue\n");
                     exit(-1);
                     }
                   ERc->magnitude = ptldist1;
                   ERc->x[0] = rac->x[j];
                   ERc->y[0] = rac->y[j];
                   ERc->z[0] = rac->z[j];
                   ERc->IDN1 = rac->idn;
                   ERc->Sindex1 = rac->Sindex;
                   ERc->aa = rac; /** RawAreal **/
                   ERc->keyval = FEATOUTSIDE;
                   ERc->Cnumber = Make_Correct(FEATOUTSIDE,checkinstance);

                   if(ERroot == NULL)
                      {
                      ERroot = ERc;
                      ERroot->next = NULL;                                }
                   else
                      {
                      ERn = ERroot;
                      while(ERn != NULL)
                         {
                         if((ERn->keyval == ERc->keyval) && (ERc->Cnumber == ERn->Cnumber) && (ERn->aa == ERc->aa))
                            {
                            if((ERn->x[0] == ERc->x[0]) && (ERn->y[0] == ERc->y[0]))
                               break;
                            }
                         ERn = ERn->next;
                         }
                      if(ERn == NULL)
                         {
                         ERc->next = ERroot;
                         ERroot = ERc;
                         }
                      else
                         {
                         free(ERc);
                         }
                      }
                   }
                ++j;
                }
             }


          if((rac->firstindex == cindex)&& (CombinedCheckApplies(rac->idn,checkinstance,BNDRYUNDERSHT,rac->Lindex,rac->Sindex,
                             Config1,Strat1,Domain1,&part1,&part2,&part3) > 0) && (part1 > 0))
             {
             j = 0;
             FoundCondition = 0;
             tolerancepad = FindRelevantSensitivity(BNDRYUNDERSHT,checkinstance,&temp);
             while(j < rac->numverts)
                {
                PassCond = 0;
                if(rac->x[j] < LAEmaxx)
                    {
                    ptldist1 = Distance(rac->x[j],rac->y[j],LAEmaxx,rac->y[j]);
                    if((ptldist1 > tolerancepad) && (ptldist1 < temp))
                       {
                       FoundCondition = 1;
                       PassCond += 1;
                       }
                    }
                if((FoundCondition  == 0) && (rac->x[j] > LAEminx))
                    {
                    ptldist1 = Distance(rac->x[j],rac->y[j],LAEminx,rac->y[j]);
                    if((ptldist1 > tolerancepad) && (ptldist1 < temp))
                       {
                       FoundCondition = 1;
                       PassCond += 1;
                       }
                    }
                if((FoundCondition  == 0) && (rac->y[j] < LAEmaxy))
                    {
                    ptldist1 = Distance(rac->x[j],rac->y[j],rac->x[j],LAEmaxy);
                    if((ptldist1 > tolerancepad) && (ptldist1 < temp))
                       {
                       FoundCondition = 1;
                       PassCond += 1;
                       }
                    }
                if((FoundCondition  == 0) && (rac->y[j] > LAEminy))
                    {
                    ptldist1 = Distance(rac->x[j],rac->y[j],rac->x[j],LAEminy);
                    if((ptldist1 > tolerancepad) && (ptldist1 < temp))
                       {
                       FoundCondition = 1;
                       PassCond += 1;
                       }
                    }
                if(FoundCondition > 0)
                   {
                   FoundCondition = 0;
                   ERc = (struct collection *) (malloc(SzC));
                   if(ERc == NULL)
                     {
                     printf("allocation memory exhausted during linear feature condition analysis (Z-shear analysis)\n");
                     printf("processing cannot continue\n");
                     exit(-1);
                     }
                   ERc->magnitude = ptldist1;
                   ERc->x[0] = rac->x[j];
                   ERc->y[0] = rac->y[j];
                   ERc->z[0] = rac->z[j];
                   ERc->IDN1 = rac->idn;
                   ERc->Sindex1 = rac->Sindex;
                   ERc->aa = rac; /** RawAreal **/
                   ERc->keyval = BNDRYUNDERSHT;
                   ERc->Cnumber = Make_Correct(BNDRYUNDERSHT,checkinstance);

                   if(ERroot == NULL)
                      {
                      ERroot = ERc;
                      ERroot->next = NULL;                                }
                   else
                      {
                      ERn = ERroot;
                      while(ERn != NULL)
                         {
                         if((ERn->keyval == ERc->keyval) && (ERc->Cnumber == ERn->Cnumber) && (ERn->aa == ERc->aa))
                            {
                            if((ERn->x[0] == ERc->x[0]) && (ERn->y[0] == ERc->y[0]))
                               break;
                            }
                         ERn = ERn->next;
                         }
                      if(ERn == NULL)
                         {
                         ERc->next = ERroot;
                         ERroot = ERc;
                         }
                      else
                         {
                         free(ERc);
                         }
                      }
                   }
                ++j;
                }
             }




         if((CombinedCheckApplies(rac->idn,checkinstance,COLINEAR,rac->Lindex,rac->Sindex,
            Config1,Strat1,Domain1,&part1,&part2,&part3) > 0) &&
               (part1 > 0))
            {
            if(rac->RB_Tree_Edgelist != NULL)
               {
               LastEdge1 = NULL;
               LastI = -1;
               i = GetNextArealIndex(rac, LastI, 1, &LastEdge1, cindex, &UsedTree);
               LastI = i;
               }
            else
               i = 0;
            while(i >= 0)
               {
               checkit = 0;
               if((rac->x[i] >= minx) && (rac->x[i] <= maxx) && (rac->y[i] >= miny) && (rac->y[i] <= maxy))  /** vert in the LM **/
                  {
                  if(i == 0)
                     i_minus = rac->numverts - 1;
                  else
                     i_minus = i - 1;
                  if(i == (rac->numverts - 1))
                     i_plus = 0;
                  else
                     i_plus = i + 1;
                  ptldist1 = PointToLineDist2D(rac->x[i],rac->y[i], rac->x[i_minus],rac->y[i_minus],rac->x[i_plus],rac->y[i_plus]);
                  if(ptldist1 <= ActiveChecks[checkinstance].sensitivity)
                     checkit = 1;
                  else
                     checkit = 0;
                  if(checkit > 0)
                     {
                     ptldist1 = Distance(rac->x[i_minus],rac->y[i_minus],rac->x[i_plus],rac->y[i_plus]);
                     if(ptldist1 >= ActiveChecks[checkinstance].sensitivity3)
                        checkit = 0;
                     }
                  if(checkit > 0)
                     {
                     ran = root;
                     if(ran == rac)
                        ran = ran->next;
                     while((checkit == 1) && (ran != NULL))
                        {
                        Config2 = SCCtable[ran->Sindex].C;
                        Strat2 = SCCtable[ran->Sindex].S;
                        Domain2 = SCCtable[ran->Sindex].D;
                        if( (CombinedCheckApplies(ran->idn,checkinstance,COLINEAR,
                                ran->Lindex,ran->Sindex,Config2,Strat2,Domain2,&part1,&part2,&part3) > 0) &&
                              (part2 > 0))
                           {
                           if(ran->RB_Tree_Edgelist != NULL)
                              {
                              LastEdge2 = NULL;
                              LastJ = -1;
                              jj = GetNextArealIndex(ran, LastJ, 1, &LastEdge2, cindex, &unusedint);
                              LastJ = jj;
                              while(jj >= 0)
                                 {
                                 mindist = Distance3D(rac->x[i],rac->y[i],rac->z[i],ran->x[jj],ran->y[jj],ran->z[jj]);
                                 if(mindist <= ActiveChecks[checkinstance].sensitivity2)
                                       /** call this a connecting node and discard condition ***/
                                    {
                                    checkit = 0;
                                    break;
                                    }
                                 jj = GetNextArealIndex(ran, LastJ, 1, &LastEdge2, cindex, &unusedint);
                                 LastJ = jj;
                                 }
                              }
                           else
                              {
                              for(jj=0; jj<ran->numverts; jj++)
                                 {
                                 if((ran->x[jj] >= minx) && (ran->x[jj] <= maxx) &&
                                            (ran->y[jj] >= miny) && (ran->y[jj] <= maxy))
                                    {
                                    mindist = Distance3D(rac->x[i],rac->y[i],rac->z[i],ran->x[jj],ran->y[jj],ran->z[jj]);
                                    if(mindist <= ActiveChecks[checkinstance].sensitivity2)
                                    /** call this a connecting node and discard condition ***/
                                       {
                                       checkit = 0;
                                       break;
                                       }
                                    }
                                 }
                              }
                           if(checkit == 0)
                              break;
                           }
                        ran = ran->next;
                        if(ran == rac)
                           ran = ran->next;
                        }  /** end checking the area features for connecting node status ****/


                     if(checkit > 0)
                        {
                        rlc = Lroot;
                        while(rlc != NULL)
                           {
                           Config2 = SCCtable[rlc->Sindex].C;
                           Strat2 = SCCtable[rlc->Sindex].S;
                           Domain2 = SCCtable[rlc->Sindex].D;
                           if((CombinedCheckApplies(rlc->idn,checkinstance,COLINEAR,
                                rlc->Lindex,rlc->Sindex,Config2,Strat2,Domain2,&part1,&part2,&part3) > 0) &&
                              (part2 > 0))
                              {
                              for(jj = 0; jj < rlc->numnodes; jj++)
                                 {
                                 if((rlc->x[jj] >= minx) && (rlc->x[jj] <= maxx) &&
                                         (rlc->y[jj] >= miny) && (rlc->y[jj] <= maxy))
                                    {
                                    mindist = Distance3D(rac->x[i],rac->y[i],rac->z[i],rlc->x[jj],rlc->y[jj],rlc->z[jj]);
                                    if(mindist <= ActiveChecks[checkinstance].sensitivity2)
                                    /** call this a connecting node and discard condition ***/
                                       {
                                       checkit = 0;
                                       break;
                                       }
                                    }
                                 }
                              if(checkit == 0)
                                 break;
                              }
                           rlc = rlc->next;
                           }
                        }

                     if(checkit > 0)
                        {
                        rpc = Proot;
                        while(rpc != NULL)
                           {
                           Config2 = SCCtable[rpc->Sindex].C;
                           Strat2 = SCCtable[rpc->Sindex].S;
                           Domain2 = SCCtable[rpc->Sindex].D;
                           if((rpc->numverts == -1) && /** rpc is a pure point ***/
                               (CombinedCheckApplies(rpc->idn,checkinstance,COLINEAR,
                                rpc->Lindex,rpc->Sindex,Config2,Strat2,Domain2,&part1,&part2,&part3) > 0) &&
                              (part2 > 0))
                              {
                              mindist = Distance3D(rac->x[i],rac->y[i],rac->z[i],rpc->x[0],rpc->y[0],rpc->z[0]);
                              if(mindist <= ActiveChecks[checkinstance].sensitivity2)
                              /** call this a connecting node and discard condition ***/
                                 {
                                 checkit = 0;
                                 break;
                                 }
                              }
                           rpc = rpc->next;
                           }
                        }

                     if(checkit > 0)
                        {
                        ERc = (struct collection *) (malloc(SzC));
                        if(ERc == NULL)
                           {
                           printf("allocation memory exhausted during linear feature condition analysis\n");
                           printf("processing cannot continue\n");
                           exit(-1);
                           }
                        ERc->x[0] = rac->x[i_minus];
                        ERc->y[0] = rac->y[i_minus];
                        ERc->z[0] = rac->z[i_minus];
                        ERc->x[1] = rac->x[i];
                        ERc->y[1] = rac->y[i];
                        ERc->z[1] = rac->z[i];
                        ERc->x[2] = rac->x[i_plus];
                        ERc->y[2] = rac->y[i_plus];
                        ERc->z[2] = rac->z[i_plus];

                        ERc->magnitude = 0.0;
                        ERc->keyval = COLINEAR;
                        ERc->Cnumber = Make_Correct(ERc->keyval,checkinstance);
                        ERc->Sindex1 = rac->Sindex;
                        ERc->ll = NULL;
                        ERc->pp = NULL;
                        ERc->aa = rac;
                        ERc->next = NULL;

                        ERn = ERroot;
                        while(ERn != NULL)
                           {
                           if((ERn->Cnumber == ERc->Cnumber) && (ERn->keyval == ERc->keyval) && (ERn->aa == ERc->aa) &&
                                (ERn->x[1] == ERc->x[1]) && (ERn->y[1] == ERc->y[1]) && (ERn->Sindex1 == ERc->Sindex1))
                              break;
                           ERn = ERn->next;
                           }
                        if(ERn == NULL)
                           {
                           ERc->next = ERroot;
                           ERroot = ERc;
                           }
                        else
                           free(ERc);
                        }

                     }  /*** end found 3 colinear points  ***/

                  } /*** end rln vertex is in the LM ***/
               if(rac->RB_Tree_Edgelist != NULL)
                  {
                  i = GetNextArealIndex(rac, LastI, 1, &LastEdge1, cindex, &UsedTree);
                  LastI = i;
                  }
               else
                  {
                  ++i;
                  if(i >= rac->numverts)
                     i = -1;
                  }
               } /** end looping thru rac vertices ****/
            } /*** end COLINEAR applies to rac ****/






         } /**** end for(checkinstance = 0; checkinstance < TtlActiveChecks; checkinstance++) ***/


      rac = rac->next;

      if(abortNow > 0)
         break;
      }  /*** end while rac != NULL ****/



   if((ErrorLookup[AUNDERSHTA].anyactive > 0) && (NeighborARoot != NULL))
      {
      NEc= EastE;
      while(NEc != NULL)
         {
         NEp = NEc;
         NEc = NEc->next;
         free(NEp);
         }
      NEc= WestE;
      while(NEc != NULL)
         {
         NEp = NEc;
         NEc = NEc->next;
         free(NEp);
         }
      NEc= NorthE;
      while(NEc != NULL)
         {
         NEp = NEc;
         NEc = NEc->next;
         free(NEp);
         }
      NEc= SouthE;
      while(NEc != NULL)
         {
         NEp = NEc;
         NEc = NEc->next;
         free(NEp);
         }
      }

   ERc = ERroot;
   while(ERc != NULL)
      {
      switch(ERc->keyval)
         {
         case ELEVGT:
         case ELEVLT:
            FwriteDynamicInfo(ERc->keyval,ERc->Cnumber,0,1,1,NULL,
              ERc->magnitude, -1.0, -1.0, -1.0,
              ERc->Sindex1,G_AREAL,ERc->aa->Lindex,ERc->aa->localID,ERc->aa->idn,-1.0,-1.0,
              ERc->x, ERc->y, ERc->z, 1,
              ERc->Sindex1,G_AREAL,ERc->aa->Lindex,ERc->aa->localID,ERc->aa->idn,-1.0,-1.0,
              ERc->x, ERc->y, ERc->z, 1);
            break;

         case ELEVEQ:
         case ELEVEQOPEN:
            X[0] = ERc->x[0];
            Y[0] = ERc->y[0];
            Z[0] = ERc->z[0];
            X[1] = ERc->x[1];
            Y[1] = ERc->y[1];
            Z[1] = ERc->z[1];
            FwriteDynamicInfo(ERc->keyval,ERc->Cnumber,0,1,1,NULL,
              ERc->magnitude, -1.0, -1.0, -1.0,
              ERc->Sindex1,G_AREAL,ERc->aa->Lindex,ERc->aa->localID,ERc->aa->idn,-1.0,-1.0,
              X,Y,Z,2,
              ERc->Sindex1,G_AREAL,ERc->aa->Lindex,ERc->aa->localID,ERc->aa->idn,-1.0,-1.0,
              X,Y,Z,2);
            break;

         case ELEVADJCHANGE:
         case FEATSPIKE:
            X[0] = ERc->x[0];
            Y[0] = ERc->y[0];
            Z[0] = ERc->z[0];
            X[1] = ERc->x[1];
            Y[1] = ERc->y[1];
            Z[1] = ERc->z[1];
            FwriteObjectAndMagnitude(ERc->keyval,ERc->Cnumber,
                        ERc->aa->idn, ERc->Sindex1,G_AREAL,ERc->aa->Lindex,ERc->aa->localID,-1.0,-1.0,ERc->magnitude,X,Y,Z,2, 1);
            break;

         case VVTERR1WAY:
         case VVTERR2WAY:
         case VVTERR3WAY:
            FwriteObjectAndMessage(ERc->keyval,ERc->Cnumber,
              ERc->aa->idn, G_AREAL,ERc->aa->Lindex,ERc->aa->localID, ERc->Sindex1,-1.0,-1.0,
              ERc->aa->x, ERc->aa->y, ERc->aa->z,2,"feature meeting specification");
            break;

         case AREAKINK:
            i = ERc->vertexindex1;
            j = ERc->vertexindex2;

            FwritePointObjectAndMagnitude(ERc->keyval, ERc->Cnumber,  ERc->magnitude, ERc->aa->idn, G_AREAL,
                                 ERc->aa->Lindex,ERc->aa->localID,
                                 ERc->Sindex1, ERc->x[1], ERc->y[1], ERc->z[1], ERc->Sindex1, ERc->aa->idn, G_AREAL,ERc->aa->Lindex,
                                 ERc->aa->localID, 3, ERc->x, ERc->y, ERc->z);
            break;

         case NOT_FLAT:
            FwritePointObjectAndMagnitude(ERc->keyval, ERc->Cnumber,  ERc->magnitude, ERc->aa->idn, G_AREAL,
                                 ERc->aa->Lindex,ERc->aa->localID,
                                 ERc->Sindex1, ERc->x[0], ERc->y[0], ERc->z[0], ERc->Sindex1, ERc->aa->idn, G_AREAL,ERc->aa->Lindex,
                                 ERc->aa->localID, 1, &ERc->x[1], &ERc->y[1], &ERc->z[1]);
            break;

         case ACOVERA:
         case AINSIDEHOLE:
            FwriteTwoObjects(ERc->keyval,ERc->Cnumber,
                             ERc->aa->idn,G_AREAL,ERc->aa->Lindex,ERc->aa->localID,ERc->aa->Sindex,-1.0,-1.0,2,ERc->aa->x,
                             ERc->aa->y,ERc->aa->z,
                             ERc->aa2->idn,G_AREAL,ERc->aa2->Lindex,ERc->aa2->localID,ERc->aa2->Sindex,-1.0,-1.0,2,ERc->aa2->x,
                             ERc->aa2->y,ERc->aa2->z);
            break;

         case FAILMERGEA:
         case FAILMERGEA2:
            FwriteTwoObjects(ERc->keyval,ERc->Cnumber,
                             ERc->aa->idn,G_AREAL,ERc->aa->Lindex,ERc->aa->localID,ERc->aa->Sindex,-1.0,-1.0,2,&ERc->x[0],
                             &ERc->y[0],&ERc->z[0],
                             ERc->aa2->idn,G_AREAL,ERc->aa2->Lindex,ERc->aa2->localID,ERc->aa2->Sindex,-1.0,-1.0,2,&ERc->x[2],
                             &ERc->y[2],&ERc->z[2]);
            break;

         /***case ANOCOVERLA: ***/
         case CONNECTFAIL:
         case QUALANOCOVLA:
            X[0] = ERc->x[0];
            Y[0] = ERc->y[0];
            Z[0] = ERc->z[0];
            X[1] = ERc->x[1];
            Y[1] = ERc->y[1];
            Z[1] = ERc->z[1];
            FwriteObject(ERc->keyval,ERc->Cnumber, ERc->aa->Lindex, ERc->Sindex1, G_AREAL, ERc->aa->localID,
                          ERc->aa->idn, -1.0, -1.0, X,Y,Z,2, 1);
            break;

         case COLINEAR:
            FwritePointAndObject(ERc->keyval,ERc->Cnumber,ERc->x[1],ERc->y[1],ERc->z[1], -1,
                       ERc->aa->Sindex, G_AREAL, ERc->aa->Lindex,ERc->aa->localID,
                          ERc->aa->idn,10.0, 0.0,ERc->x, ERc->y, ERc->z, 3);

            break;

         case FEATOUTSIDE:
            FwriteDynamicInfo(ERc->keyval,ERc->Cnumber,0,1,1,NULL,
              ERc->magnitude, -1.0, -1.0, -1.0,
              ERc->Sindex1,G_AREAL,ERc->aa->Lindex,ERc->aa->localID,ERc->aa->idn,-1.0,-1.0,
              ERc->x, ERc->y, ERc->z, 1,
              ERc->Sindex1,G_AREAL,ERc->aa->Lindex,ERc->aa->localID,ERc->aa->idn,-1.0,-1.0,
              ERc->x, ERc->y, ERc->z, 1);
            break;

         case OSIDE_LAT:
         case OSIDE_LON:
         case BNDRYUNDERSHT:
            FwriteObjectAndMagnitude(ERc->keyval,ERc->Cnumber,
                        ERc->aa->idn, ERc->Sindex1,G_AREAL,ERc->aa->Lindex,ERc->aa->localID,-1.0,-1.0,
                        ERc->magnitude,ERc->x,ERc->y,ERc->z,1, 1);
            break;



         case MULTIDFEAT:
         case MULTISENTINEL:
            i = ERc->vertexindex1;
            FwriteObject(ERc->keyval,ERc->Cnumber,ERc->aa->Lindex, ERc->Sindex1, G_AREAL, ERc->aa->localID,
                          ERc->aa->idn, -1.0, -1.0, &ERc->aa->x[i], &ERc->aa->y[i], &ERc->aa->z[i], 2, 1);
            break;


         case HIGHLIGHTED:
         case CUTOUT:
            FwriteObject(ERc->keyval,ERc->Cnumber, ERc->aa->Lindex, ERc->Sindex1, G_AREAL, ERc->aa->localID,
                          ERc->aa->idn, -1.0, -1.0, ERc->aa->x, ERc->aa->y, ERc->aa->z, 2, 1);
            break;

         case OVERUNDER:
         case ANOCOVERA:
            FwriteObject(ERc->keyval,ERc->Cnumber, ERc->aa->Lindex, ERc->Sindex1, G_AREAL, ERc->aa->localID,
                          ERc->aa->idn, -1.0, -1.0, 
                          &ERc->aa->x[ERc->vertexindex1], &ERc->aa->y[ERc->vertexindex1], &ERc->aa->z[ERc->vertexindex1], 2, 1);
            break;

        case OBJECTWITHOUT:
        case OBJ_WO_TWO:
        case FSFAIL:
        case ISOLATEDA:
        case COINCIDEFAIL:
        case PSHAREFAIL:
        case NOCOINCIDE:
             FwriteObject(ERc->keyval,ERc->Cnumber,ERc->aa->Lindex, ERc->Sindex1,
                                   G_AREAL,ERc->aa->localID,ERc->aa->idn,-1.0, -1.0,ERc->aa->x,
                                   ERc->aa->y,ERc->aa->z,2, 1);
             break;
         case AWITHOUTA:
            FwriteDynamicInfo(ERc->keyval,ERc->Cnumber,1,0,1,NULL,0.0,ERc->aa->x[0],ERc->aa->y[0],ERc->aa->z[0],
                             ERc->Sindex1,G_AREAL,ERc->aa->Lindex,ERc->aa->localID,ERc->aa->idn,-1.0,-1.0,
                             ERc->aa->x,ERc->aa->y,ERc->aa->z,2,
                             ERc->Sindex1,G_AREAL,ERc->aa->Lindex,ERc->aa->localID,ERc->aa->idn,-1.0,-1.0,
                             ERc->aa->x,ERc->aa->y,ERc->aa->z,2);
            break;

         case NONODEOVLP:
         case LLNONODEINT:
            if(ERc->ll != NULL)
               {
               FwritePointAndTwoObjects(ERc->keyval,ERc->Cnumber,ERc->px_int,ERc->py_int,ERc->pz_int,
                               ERc->aa->Sindex,G_LINE,ERc->aa->Lindex,ERc->aa->localID,
                               ERc->aa->idn,-1.0,-1.0,&ERc->x[0],&ERc->y[0],&ERc->z[0],2,
                               ERc->ll->Sindex,G_LINE,ERc->ll->Lindex,ERc->ll->localID,
                               ERc->ll->idn,-1.0,-1.0,&ERc->ll->x[ERc->vertexindex2],
                               &ERc->ll->y[ERc->vertexindex2],&ERc->ll->z[ERc->vertexindex2],2);
               }
            else if(ERc->pp != NULL)
               {
               FwritePointAndTwoObjects(ERc->keyval,ERc->Cnumber,ERc->px_int,ERc->py_int,ERc->pz_int,
                               ERc->aa->Sindex,G_LINE,ERc->aa->Lindex,ERc->aa->localID,
                               ERc->aa->idn,-1.0,-1.0,&ERc->x[0],&ERc->y[0],&ERc->z[0],2,
                               ERc->pp->Sindex,G_POINT,ERc->pp->Lindex,ERc->pp->localID,
                               ERc->pp->idn,-1.0,-1.0,&ERc->pp->x[0],
                               &ERc->pp->y[0],&ERc->pp->z[0],1);
               }
            else if(ERc->aa2 != NULL)
               {
               FwritePointAndTwoObjects(ERc->keyval,ERc->Cnumber,ERc->px_int,ERc->py_int,ERc->pz_int,
                               ERc->aa->Sindex,G_LINE,ERc->aa->Lindex,ERc->aa->localID,
                               ERc->aa->idn,-1.0,-1.0,&ERc->x[0],&ERc->y[0],&ERc->z[0],2,
                               ERc->aa2->Sindex,G_AREAL,ERc->aa2->Lindex,ERc->aa2->localID,
                               ERc->aa2->idn,-1.0,-1.0,&ERc->x[2],&ERc->y[2],&ERc->z[2],2);
               }
            break;

         case AREAINTAREA:
            FwritePointAndTwoObjects(ERc->keyval,ERc->Cnumber, ERc->x[0], ERc->y[0], ERc->z[0],
                             ERc->aa->Sindex,G_AREAL,ERc->aa->Lindex,ERc->aa->localID,ERc->aa->idn,-1.0,-1.0,ERc->aa->x,
                             ERc->aa->y,ERc->aa->z,2,
                             ERc->aa2->Sindex,G_AREAL,ERc->aa2->Lindex,ERc->aa2->localID,ERc->aa2->idn,-1.0,-1.0,ERc->aa2->x,
                             ERc->aa2->y,ERc->aa2->z,2);
            break;


         case CUT_INT:
            FwritePointAndTwoObjects(ERc->keyval,ERc->Cnumber, ERc->x[0], ERc->y[0], ERc->z[0],
                             ERc->aa->Sindex,G_AREAL,ERc->aa->Lindex,ERc->aa->localID,ERc->aa->idn,-1.0,-1.0,
                             &ERc->x[0],&ERc->y[0],&ERc->z[0],2,
                             ERc->aa2->Sindex,G_AREAL,ERc->aa2->Lindex,ERc->aa2->localID,ERc->aa2->idn,-1.0,-1.0,
                             &ERc->x[2],&ERc->y[2],&ERc->z[2],2);
            break;
         case PART_ISF:
         case AOVERLAPA: 
            if((ERc->vertexindex1 >= 0) && (ERc->vertexindex2 >= 0))
               {
               ii = ERc->vertexindex1;
               if(ii == 0)
                  jj = ERc->aa->numverts - 1;
               else
                  jj = ii - 1;
               X[0] = ERc->aa->x[jj];
               Y[0] = ERc->aa->y[jj];
               Z[0] = ERc->aa->z[jj];
               X[1] = ERc->aa->x[ii];
               Y[1] = ERc->aa->y[ii];
               Z[1] = ERc->aa->z[ii];

               ii = ERc->vertexindex2;
               if(ii == 0)
                  jj = ERc->aa2->numverts - 1;
               else
                  jj = ii - 1;
               X[2] = ERc->aa2->x[jj];
               Y[2] = ERc->aa2->y[jj];
               Z[2] = ERc->aa2->z[jj];
               X[3] = ERc->aa2->x[ii];
               Y[3] = ERc->aa2->y[ii];
               Z[3] = ERc->aa2->z[ii];
               FwritePointAndTwoObjects(ERc->keyval,ERc->Cnumber, ERc->x[0], ERc->y[0], ERc->z[0],
                             ERc->aa->Sindex,G_AREAL,ERc->aa->Lindex,ERc->aa->localID,ERc->aa->idn,-1.0,-1.0, &X[0],&Y[0],&Z[0],2,
                             ERc->aa2->Sindex,G_AREAL,ERc->aa2->Lindex,ERc->aa2->localID,ERc->aa2->idn,-1.0,-1.0, &X[2],&Y[2],&Z[2],2);
               }
            else
               {
               x1 = ERc->x[0], y1 = ERc->y[0];
               z1 = ERc->z[0];
               ERc->aa = FindEdgeClosestToPoint(ERc->x[0],ERc->y[0],root,NeighborARoot,ERc->aa,&ii);
               if(ii < 0)
                  {
                  ii = 0;
                  jj = ERc->aa->numverts - 1;
                  }
               else
                  jj = ii - 1;
               X[0] = ERc->aa->x[jj];
               Y[0] = ERc->aa->y[jj];
               Z[0] = ERc->aa->z[jj];
               X[1] = ERc->aa->x[ii];
               Y[1] = ERc->aa->y[ii];
               Z[1] = ERc->aa->z[ii];
               ERc->aa2 = FindEdgeClosestToPoint(ERc->x[0],ERc->y[0],root,NeighborARoot,ERc->aa2,&ii);
               if(ii < 0)
                  {
                  ii = 0;
                  jj = ERc->aa2->numverts - 1;
                  }
               else
                  jj = ii - 1;
               X[2] = ERc->aa2->x[jj];
               Y[2] = ERc->aa2->y[jj];
               Z[2] = ERc->aa2->z[jj];
               X[3] = ERc->aa2->x[ii];
               Y[3] = ERc->aa2->y[ii];
               Z[3] = ERc->aa2->z[ii];
               FwritePointAndTwoObjects(ERc->keyval,ERc->Cnumber, x1, y1, z1,
                             ERc->aa->Sindex,G_AREAL,ERc->aa->Lindex,ERc->aa->localID,ERc->aa->idn,-1.0,-1.0,
                              &X[0],&Y[0],&Z[0],2,
                             ERc->aa2->Sindex,G_AREAL,ERc->aa2->Lindex,ERc->aa2->localID,ERc->aa2->idn,-1.0,-1.0,
                              &X[2],&Y[2],&Z[2],2);
               }
            break;


         case SHAREPERIM:
         case AUNDERSHTA:
         case AOVERSHTA:
            FwriteMagnitudeAndTwoObjects(ERc->keyval,ERc->Cnumber,ERc->magnitude,
              ERc->aa->Sindex,G_AREAL,ERc->aa->Lindex,
              ERc->aa->localID,ERc->aa->idn,10.0,-1.0,&ERc->x[0],&ERc->y[0],&ERc->z[0],2,
              ERc->aa2->Sindex,G_AREAL,ERc->aa2->Lindex,
              ERc->aa2->localID,ERc->aa2->idn,10.0,-1.0,&ERc->x[2],&ERc->y[2],&ERc->z[2],2);
            break;
         case SLOPEDIRCH:
            FwriteObjectAndMagnitude(ERc->keyval,ERc->Cnumber,
                        ERc->aa->idn, ERc->Sindex1,G_AREAL,ERc->aa->Lindex,ERc->aa->localID,-1.0,-1.0,
                        ERc->magnitude,ERc->x,ERc->y,ERc->z,3, 1);
            break;


         default:
            printf("unrecognized key condition flag received during area feature analysis %d\n",ERc->keyval);
            break;
         }
      ERn = ERc;
      ERc = ERc->next;
      free(ERn);
      }
   return;
} /*** end PerformArealRelatedChecks ***/

