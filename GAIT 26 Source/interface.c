/************
GAIT (Geospatial Analysis Integrity Tool) is a geospatial data validation tool developed by the Institute for Defense Analyses (IDA) for the National Geospatial-Intelligence Agency (NGA).  

This source code was used to generate GAIT 26 executable software in accordance with Amendment 6 to Task Order DH-8-3815 under Contract HQ0034-14-D-0001.

IDA is furnishing this item "as is". IDA was not tasked or funded to generate developer documentation or to provide support for this source code. IDA does not provide any warranty of the item whatsoever, whether express, implied, or statutory, including, but not limited to, any warranty of fitness for a particular purpose or any warranty that the contents of the item will be error-free. In no event shall NGA or IDA be held liable for damages arising, directly or indirectly, from the use of this source code. 

This material may be reproduced by the U.S. Government pursuant to its unlimited use rights under DFARS 252.227-7014 [Feb 2014].

The Institute for Defense Analyses (IDA) is a Federally Funded Research and Development Center that provides scientific and technical expertise on issues important to national security to the Office of the Secretary of Defense, Joint Staff, Unified Commands, and Defense Agencies. 

© 2017 Institute for Defense Analyses
  4850 Mark Center Drive
  Alexandria, Virginia 22311-1882
  703.845-2000
  www.ida.org
************/
#include "interface.h"
#include "TTshare.h"

int OpeningSpecialLoc = 0;
char SpecialLoc[1000];



Pixmap plus_insen_pix,minus_insen_pix;
XFontStruct *LabelFont;
int MAX_SORT_COUNT   = 10000; 
int USE_LITTLE;
char GAIT_BIN_DIR[1000];
int GRID_LABEL_DRAW_OVERRIDE = 0;
int DO_MGCP_PORTRAY = 1;
int global_filter_cache=1;
FILE *batchsavefile;
char VersionStrCopy[50];

#define DO_FAN_VAR 1

int FORMATBUTTON = 0;

extern int NUNANPO_TYPE,POI_CONNECT,ZoomToPOIs,BOLD_CONTOUR,old_file_browser,
  DrawColorFill,OVERRIDING_CONTOUR,NO_FLATTEN_CONTOUR,DrawAnnotations,
  ATTRINSTYPE,USE_GREY,TheContourColor,old_file_browser,num_user_meta,
  dev_options,batchsilent,batchignore,batchuser,formatting,
  OVERRIDE_THICKNESS,SPECIAL_COLOR,COLOR_ALREADY_SET,
  LONG_ATTR_CHECK_HGT,LONG_ATTR_CHECK_ZV2,LONG_ATTR_CHECK_AREA,
  LONG_ATTR_CHECK_LEN,LONG_ATTR_CHECK_NAM,
  LONG_ATTR_AREA,LONG_ATTR_HGT,LONG_ATTR_ID,LONG_ATTR_ZV2,LONG_ATTR_AREA,LONG_ATTR_LEN,LONG_ATTR_NAM,
  DoLargeLabels,DoBoldLabels,SPECIAL_COND_COLOR,old_long_attr_style,
  INCLUDE_PROJECTION,attrins_source,NEED_SHADE_REDRAW,SpecialMapdrawPoly,
  CHECK_DATA_SET,NOTYPE;

extern char GAIT_HOME_DIR[1000];
extern char outattrdirectory[1000];
extern char outsumdirectory[1000];

extern Widget choose_xml1_dialog,choose_xml2_dialog,choose_xml3_dialog,
  choose_dialog,choose_es1_dialog,choose_es2_dialog,grid_head,fore_head,
  gridwid1,gridwid2,gridwid3,gridwid4,gridwid5,gridwid6,demwid,
  otherattrwid9,attrins_text_area,chooseshape_dialog,QAST_unzip,
  choose_txt_dialog,exe_wid,text_llx,text_lly,text_urx,text_ury;


extern int overwrite1_up,overwrite3_up,overwrite6_up,FORMAT_BEGIN,IMPORT_OUTPUT,
SPEC_WIN,REC_WIN,INVERT_3x3,DOMODELPOLYS,GROW_MODELS,DOMODELSUMMARY,DOTHEDUPES,GROW_STAMPS,
BIN_ATTR_TYPE,DO_LINES;


extern char dp2name             [1000];
extern char shape_out_name[200];
extern char attrinsfolder[1000];

extern int HAS_ID[NUM_ATTR_SCHEMA+5];

extern Font defaultfont;

extern int *LLFidTable;
extern int *FidFidTable;
extern int LLFidTableCount;



char **nga_qacr_lhs;
char **nga_qacr_rhs;
int   *nga_qacr_counts;
char **mgcp_qacr_lhs;
char **mgcp_qacr_rhs;
int   *mgcp_qacr_counts;
int current_line_nga  = 0;
int current_line_mgcp = 0;
int TotalNGAAttrInstances = 0;
int TotalMGCPAttrInstances = 0;
int QACR_COUNTRY=999;
int QACR_EXPORT_TRD_VERSION = 999;

int do_trex_checklist;

int ALSO_PRINT_USAGE    = 0;
int old_file_browser    = 0;
int Offchecks           = 1;
int TempGridsRead       = 0;
int TruncImport         = 1;
int OVERRIDE_GRID_STYLE = -1;
int REPORT_BEZIER       = 1;
int CLONE_RANGE         = 0;
int batch_offchecks     = 0;
int NewTrexColor        = 1;
int TREX_WRITE_LN_FILE  = 0;
int TREX_PROCESS_EDGES  = 1;
int ReFormatTrexXML     = 1;
int overriding_modal    = 0;

char *mgcp_attr_names[]=
  {
   "", 
   "unused",
   "Attribute Dependency errors",                                  
   "MGCP \"No FCODE Column\" errors",                              
   "MGCP Shapefile Naming errors",                                 
   "MGCP \"Shape Type\" errors",                                   
   "Blank Attribute errors",                                       
   "MGCP \"Mixed Null/Non-Null Optional Attribute\" errors",       
   "MGCP \"Invalid Field Length\" errors",                         
   "MGCP \"Required Attribute Assigned Null Value\" errors",       
   "MGCP \"UTF-8 Encoding\" anomalies"                             
  };


char *other_attr_names[]=
  {
	  "", 
	  "FCODE errors",                              
	  "Invalid Case errors",                       
	  "Non Domain Specific Pick-list errors",      
	  "Domain Specific Pick-list errors",          
	  "Unexpected FCODE-Geometry Pair errors",     
	  "Value Range errors",                        
	  "Unexpected Attribute errors",               
	  "Missing Attribute Field Or Value errors",   
	  "Metadata errors",                           
	  "Zero-Part Area/Line errors",                
	  "NULL Feature errors",                       
	  "Invalid Coordinate errors",                 
	  "Invalid Cut-Out errors",                    
	  "Unrecognized Column Names",                 
	  "Invalid Data Type errors",                  
	  "Empty or Invalid Shapefiles or Tables",     
	  "Geodatabase Bezier/Circle/Ellipse features" 
  };

char *trexspacer = " ";
char trex_qa_file[1000];
char trex_qc_file[1000];

int global_short_attr_count = 0;


char masterrun[100]; 
char bitmapfolder[1000],layer_save_file[100],masterrun2[500];

int chooseproj_origwidth,chooseshape_origwidth,choosees1_origwidth,choosees2_origwidth,choosetxt_origwidth,
choosexml1_origwidth,choosexml2_origwidth,choosexml3_origwidth,chooseattr_origwidth,choosedp_origwidth,
choosebr_origwidth;


unsigned char *FidMarkTable=NULL;


int *SaveLongCountsArea[NUM_C+1];
int *SaveLongCountsHgt [NUM_C+1];
int *SaveLongCountsLen [NUM_C+1];
int *SaveLongCountsNam [NUM_C+1];
int *SaveLongCountsId  [NUM_C+1];
int *SaveLongCountsZv2 [NUM_C+1];

char SaveLayerName[100];

char **fcodes;
char **others;


Widget choosenet_xml1_top,choosenet_xml1_left,choosenet_xml1_right,
  choosenet_xml2_top,choosenet_xml2_left,choosenet_xml2_right,
  choosenet_xml3_top,choosenet_xml3_left,choosenet_xml3_right,
  chooseattr_dialog,choosenetattr_top,choosenetattr_left,choosenetattr_right,
  choosedp_dialog,choosenetdp_top,choosenetdp_left,choosenetdp_right,
  choosebr_dialog,choosenetbr_top,choosenetbr_left,choosenetbr_right,
  choosenetproj_top,choosenetshape_top,choosenet_es1_top,terrain_output_import,
  choosenet_es2_top,choosenet_txt_top,draw_h_scroll,overriding_parent_wid=NULL,
  choosenetproj_left,choosenetshape_left,choosenet_es1_left,
  choosenet_es2_left,choosenet_txt_left,attrdialog,
  choosenetproj_right,choosenetshape_right,choosenet_es1_right,
  choosenet_es2_right,choosenet_txt_right,TopDPWidOutline,
  CHOOSESHAPE_BROWSE_fw,CHOOSE_ES1_BROWSE_fw,CHOOSE_ES2_BROWSE_fw,
  CHOOSE_TXT_BROWSE_fw,CHOOSE_XML1_BROWSE_fw,CHOOSE_XML2_BROWSE_fw,
  CHOOSE_XML3_BROWSE_fw,ATTRFOLDER_BROWSE_fw,savepref_wid,savelayer_wid,
  TopXML1WidOutline,TopXML2WidOutline,TopXML3WidOutline,
  TopProjWidOutline,TopShapeWidOutline,TopES1WidOutline,
  TopES2WidOutline,TopTXTWidOutline,TopAttrWidOutline,DP_BROWSE_fw,
  BROWSE_BROWSE_fw,TopBRWidOutline;




Widget *TXTWids      = NULL;
Widget *TXTHands     = NULL;
int    *TXTLevels    = NULL;   
int TXTWidsSaved     = 0;
int TXTWidsAllocced  = 0;

Widget *DATAWids      = NULL;
Widget *DATAHands     = NULL;
int    *DATALevels    = NULL;   
int DATAWidsSaved     = 0;
int DATAWidsAllocced  = 0;

Widget *XML1Wids      = NULL;
Widget *XML1Hands     = NULL;
int    *XML1Levels    = NULL;   
int XML1WidsSaved     = 0;
int XML1WidsAllocced  = 0;

Widget *XML2Wids      = NULL;
Widget *XML2Hands     = NULL;
int    *XML2Levels    = NULL;   
int XML2WidsSaved     = 0;
int XML2WidsAllocced  = 0;

Widget *XML3Wids      = NULL;
Widget *XML3Hands     = NULL;
int    *XML3Levels    = NULL;   
int XML3WidsSaved     = 0;
int XML3WidsAllocced  = 0;

Widget *ProjWids     = NULL;
Widget *ProjHands    = NULL;
int    *ProjLevels   = NULL;  
int ProjWidsSaved    = 0;
int ProjWidsAllocced = 0;

Widget *ShapeWids    = NULL;
Widget *ShapeHands   = NULL;
int    *ShapeLevels  = NULL; 
int ShapeWidsSaved   = 0;
int ShapeWidsAllocced= 0;

Widget *ES1Wids      = NULL;
Widget *ES1Hands     = NULL;
int    *ES1Levels    = NULL;   
int ES1WidsSaved     = 0;
int ES1WidsAllocced  = 0;

Widget *ES2Wids      = NULL;
Widget *ES2Hands     = NULL;
int    *ES2Levels    = NULL;   
int ES2WidsSaved     = 0;
int ES2WidsAllocced  = 0;

Widget *AttrWids      = NULL;
Widget *AttrHands     = NULL;
int    *AttrLevels    = NULL;  
int AttrWidsSaved     = 0;
int AttrWidsAllocced  = 0;

Widget *DPWids      = NULL;
Widget *DPHands     = NULL;
int    *DPLevels    = NULL;  
int DPWidsSaved     = 0;
int DPWidsAllocced  = 0;

Widget *BrowseWids      = NULL;
Widget *BrowseHands     = NULL;
int    *BrowseLevels    = NULL;  
int BrowseWidsSaved     = 0;
int BrowseWidsAllocced  = 0;




int layer_write_files;
int layer_write_total_files;
int layer_gzip_files;
int layer_gzip_total_files;

Pixmap *layer_bitmaps,*layer_filled_bitmaps;
XPoint * Toppoints;
struct FilterList * MarkerRoot = NULL;


double scale_factor,xpixels,ypixels,SPECIAL_PAD_DIST=10;
double db_min_z,db_max_z,db_min_z2,db_max_z2;
double Zgrid[4];
int temp_num_lods=-1,toppointsnum=0,LAYERPREFS_UP=0,layer_save_file_selected=0;


int counting_attr_only = 0;
int *LOD_geoms = NULL;
int *geoms;
int *renders;
int *styles;
int *reds;
int *greens;
int *blues;
int ExtraTopLevel;
int deletesentinellen;
int FAIL_PROJ_FOLDER;
int WidChunk=1000;
int GetTempFill = 0;
int rec_depth=0;
int CDFREPORT=0;
int DRAWING_TOPLEVEL = 0;
int NETS_ONLY = 0;






#if (NGA_TYPE == 1)

  extern char **gifd_class_defns; 
  extern char **gifd_class_names;
  extern char **gifd_class_codes;
  extern char **gifd_attr_types;
  extern char **gifd_attr_defns;
  extern char **gifd_attr_names;
  extern char **gifd_attr_codes;
  extern char **gifd_enum_names;
  extern char **gifd_enum_codes;
  extern int   *gifd_attr_enum_count;
  extern int   *gifd_attr_enum_start;
  extern int GIFD_CLASS_NUM;
  extern int GIFD_ATTR_NUM;
  extern int DOMAINSLEN;
  extern int STRATSLEN;

#else

extern int GIFD_CLASS_NUM ;
extern int GIFD_ATTR_NUM  ;       
extern char **gifd_attr_codes ;  
extern char **gifd_class_codes;
extern char **gifd_class_names;



#endif







extern XtAppContext app_context; 
extern Colormap cmap;
extern Dimension lod_hgt,HEIGHT;
extern XPoint * Drawpoints;
extern XPoint *hole_points;
extern short int PixArray[1050][900];
extern XColor *layer_colors;
extern Widget *layer_colorwindows;
extern Pixmap *layer_colorpix;
extern Widget *toplevel;
extern Widget *scale1;
extern Widget *scale2;
extern Widget *scale3;
extern Widget *layer_text1;
extern Widget *layer_text2;
extern Widget *layer_text3;
extern XmFontList fontlist;
extern XPoint * PolyPoints;
extern double SaveXScroll,SaveYScroll,SMALLAMOUNT;


extern Pixmap pixmap,pixmap2,pixmap3,clean_pixmap,stipmap_avg,stipmap_lgt,stipmap_hvy;
extern Pixmap Profile_pix,Demo_pix,Att_Demo_pix,plus_pix,minus_pix,
  DRAWING_PIXMAPS[NUM_DRAWING_PIXMAPS], DRAWING_CLIPMAPS[NUM_DRAWING_PIXMAPS];
extern Pixmap stipmapstypes[NUM_STIPMAPS]; 
extern Pixmap ERROR_BITMAP,over_pixmap;
 

extern struct InfoPrintContent *InfoRoot;
extern int    *HIGH_ERRNUM             ;
extern int    *HIGH_INSTANCE           ;
extern int    *HIGH_CONDNUM            ;
extern int    *HIGH_ECC1               ;
extern int    *HIGH_ECC2               ;
extern double *HIGH_MAG                ;
extern int rec_condnum                [MAX_STACK+1];
extern struct CondHighlight ***MasterHighlighter;
extern unsigned char **MasterStacker;
extern unsigned short int rec_errnum  [MAX_STACK+1];
extern unsigned short int rec_instance[MAX_STACK+1];

extern int LODS_USED[NUM_DRAWING_PIXMAPS];
extern int NumberOfGrids;
extern int VertexPrintLimit;
extern struct GlobalGridInfo *GridHeader;



extern struct EDCSLookup edcsstruct;

extern Widget toolbar[20],vert_scroll[100],ToolTipMaster,param_head,param2_head,
running_info,folder_wid,sum1_wid,sum2_wid,sum3_wid,data_wid,Select_head,
info_attr_head,infohead,infoparam_head,cond_dialog,lod_head,info_text_area,
pick_dialog,mgcpattrwid2,mgcpattrwid3,mgcpattrwid4,mgcpattrwid5,WW,info_list,
mgcpattrwid6,mgcpattrwid7,mgcpattrwid8,mgcpattrwid9,mgcpattrwid10;



extern Widget indir_work_dialog,Demo_drawing,
Att_Demo_drawing,fan_info,text_pane,fix_running,modelhead,Bbutton,list_point,
modes[10],condwid1,condwid2,condwid3,shapewid,
cascade[10],patch_t,terrain_to_import,stf_t,condwid,genwid,savecond_wid,TEXT_HELP,
msgdialogs[5000],sw,extract_dialog,run_format_dialog,CSD_head,
stackwids[ZOOM_REMEMBER_NUM],shift[7],beg_dialog,menubar,pop_parent,
regionhead,aoi_save_wid,aoi_shape_wid,xml1_wid,xml2_wid,xml3_wid,xml_running,
shapefile_text_area,shellhead2,netwid;



extern Widget vert_scroll_bo[25][CONDITION_ARRAY_SIZE][125];

extern char **LongValueList;
extern double *LongDValueList;


extern char  *CNAME[NUM_C],
  edcsstring            [150],
  SaveAOIShapeName      [100],
  metamapfile           [1000];
 


extern unsigned long mycolors[300],col[300],col2[300],col3[300],col4[300],
ColorBin1[SHADES_PER_BIN],ColorBin2[SHADES_PER_BIN],ColorBin3[SHADES_PER_BIN],
ColorBin4[SHADES_PER_BIN],ColorBin5[SHADES_PER_BIN],mybackground,myforeground;

extern long int StartTime,EXTRACT_STARTTIME,use_other_fileposn;

extern unsigned int PixDBWidth,PixDBHeight;

extern unsigned int EXTRACT_GRIDS_DONE;

extern int CLONE_DEFINITIONS,ThisClassLevel,head_in_use,deader_phead,num_shapes_processed,
RUNNING_INFO,STOP_FLAG,OVERRIDING_STYLE,browse5_up,browse6_up,browse7_up,import_source,
browse8_up,browse12_up,browse13_up,browse14_up,browse15_up,running,NPCAOnOff1,INFO_HEX,
load_modules,deader_head,batch_mode,NumNetsLoaded,input_source,output_source,DO_OVERRIDE,
GLOBAL_draw,GLOBAL_needextrapixmap,GLOBAL_showlayers,GLOBAL_activelayer,TopLayersDrawn,
SAVE_TOPCHANGE,grx,gry,xnum,ynum,STF_INPUT,DIGITS_TO_PRINT,SAVED_VIEWS,DPOnOff1,BROnOff1,
CURRENT_ZOOM,MAX_ZOOM,UNIQARRAYBUILT,MakingMaster,cond_start_onoff,info_window_up,CAOnOff1,
INFO_ATTR_WIN,SAVE_CREPORT_UP,dead_head5,dead_lod_head,busyinnitting,input_up,PrimaryLODSort,
SecondaryLODSort,IMPORT_INPUT,patch_source,PATCH_INPUT,stf_overwrite_source,layers_innitted,
*layers_up,DynLodMade,TempNumLODbands,INFO_PARAM_WIN,DEFAULT_DTP_UTM,DoMetadataChecking,
DEMO_UP,ATT_DEMO_UP,FAN_INFO,ERR_INFO,STOP_FIX_FLAG,FIX_RUNNING,DetailedInfo,curr_pop,
DoShort,DOALLCELLS,DOMAIN_DEFAULT_COLOR[NUM_D],browse26_up,DoAttrChecking,AppendInputSpec,
EXTRACT_POINTS_DONE,EXTRACT_LINEARS_DONE,EXTRACT_AREALS_DONE,load_head,LOS_WIN,GRID_WIN,
RUN_FORMAT_UP,BUSY,IMPORT_WIN,SCC_NUM,CSD_UP,polyptsallocced,MASTERTYPE,*profiling_layers,
DYNAMIC_SCC_NUM,MOD_UP,view_object_page,INscc_loop,INsac_loop,HyperClassUp[INscc_array],
HyperAttrUp [INsac_array],METATYPE,TEMP_ATTRIBUTION_TYPE,global_scroll_min,metamap_source,
global_scroll_max,global_scroll_value,global_scroll_slide_size,global_scroll_increment,LOS,
global_scroll_pg_increment,Total2DPoint,Total3DPoint,Total2DLine,Total3DLine,Total2DArea,
Total3DArea,logo_done,pop_up[2],DOUBLECLICK,DrivesAvailable[DRIVE_MAX],PFOnOff1,DrawLabels,
SFOnOff1,ES1OnOff1,ES2OnOff1,TXTOnOff1,DATAOnOff1,SHAPE_IMPORT_OUTPUT,NumNetDrives,TYPE,
NPPFOnOff1,NPSFOnOff1,NPES1OnOff1,NPES2OnOff1,NPTXTOnOff1,NPDATAOnOff1,metabrowse_up,GRID,
FromI,ToI,FromJ,ToJ,iLimit,jLimit,iStart,jStart,pref_up,DrawUserGrid,GLOBAL_SAVE_COORDS,
DrawQuarterDegreeGrid,DrawHalfDegreeGrid,DrawOneDegreeGrid,DrawUserGridL,DrawOneDegreeGridL,
DrawHalfDegreeGridL,DrawQuarterDegreeGridL,CLIPEXTRACT,KEEP_THICKNESS,ABORT_EXTRACT,
GRID_THICKNESS,GRID_COLOR,GRID_LABEL_COLOR,shape_source,IUseDMScoordinates,P_window,FLIP,
NON_ACTUAL,ACTUAL,UNIQSACNUM,CenterZoomOnVertices,CenterZoomOnErrors,DO_DESCRIBE,ABORT_ZOOM,
SPECIAL_VERTEX,DRAWING_INFO_ITEM,InfoItemsQueried,PROFILE_MODE,INFO_DOMAIN,INFO_LENGTH,
INFO_AREA,INFO_GEOMETRY,INFO_FID,INFO_GFID,INFO_COORDS,INFO_ATTRIBUTES,INFO_ATTR_LABELS,
INFO_ATTR_VALUES,FAN_MODE,INFO_MODE,DIST_MODE,ZOOM_MODE,CHECK_MODE,PAN_MODE,BAD_PROFILE,
AOI_MODE,BAD_ZOOM,BAD_PAN,startx,starty,grx,gry,xnum,ynum,startloadx,startloady,ADD_HIST,
pro_begx,pro_begy,BAD_BEGIN_PROFILE,BAD_FAN,BAD_INFO,dead_error,dead_obhead[5],attr_color,
current_ob_head,num_highlights,DRAW_VERTICES,ATTRIBUTION_INFO_TYPE,load_reg,GLOBAL_MI_NUM,
endloadx,endloady,load_modules,do_long_way,MARK_COLOR,MARK_SHAPE,INFO_WINDOW,info_window_up,
startzoomx,startzoomy,startpanx,startpany,MAX_ZOOM,AOI_SAVE_UP,AOI_LOAD_UP,AOI_SHAPE_UP,
ZoomSunAzimuth,ZoomSunAngle,dead_sdcs,dead_shade,CIRCLESIZE,MAXVERTSFOUND,browse30_up,
DRAWING_ERRORS,circlecount,gridcount,RETURN_VERTS,num_hole_points,PATCH_WIN,
POLY_SHAPE,POLY_COLOR,LINE_SHAPE,LINE_COLOR,END_LINE_SHAPE,END_LINE_COLOR,FAN_QUALITY,
linecount,polycount,browse27_up,browse28_up,browse29_up,CONTOUR_WIN,INFO_GRIDVALUES,
import_output_source,FORE_WIN,UNIQSCCNUM,XML_RUNNING,NPDPOnOff1,browse31_up,browse32_up,
HELP_UP[CONDITION_ARRAY_SIZE],deadfix[CONDITION_ARRAY_SIZE],OnOff1,VCOnOff1,FCOnOff1,
NPXML1OnOff1,NPXML2OnOff1,NPXML3OnOff1,XML1OnOff1,XML2OnOff1,XML3OnOff1,GLOBAL_ADDSPECS,
NPBROnOff1;

extern unsigned char DrawByConfig [NUM_C];
extern unsigned char DrawByStratum[NUM_S]; 
extern unsigned char DrawByDomain [NUM_D];
extern int DO_OBS[NUM_OBS]          ;
extern int    *MetaUserValue           ;
extern char **MetaUser;

extern int highlight_starts[HIGHLIGHTMAX];
extern int highlight_ends  [HIGHLIGHTMAX];
extern int OnOff2[NUMCHECKGROUPS];
extern int VCOnOff2[NUMCHECKGROUPS];
extern int VCOnOff3[CONDITION_ARRAY_SIZE];
extern int FCOnOff2[NUMCHECKGROUPS];
extern int FCOnOff3[CONDITION_ARRAY_SIZE];

extern struct SACarray * SACARRAY;
extern struct SCCarray * SCCARRAY;

extern unsigned char UNIQSCC[INscc_array];
extern unsigned char UNIQSAC[INsac_array];
extern unsigned char InfoSac[INsac_array+10];
extern unsigned char shortmsg_up[5000];


extern int    *GLOBAL_SAVE_COORDS_start;
extern int    *GLOBAL_SAVE_COORDS_end  ;

extern double llx_zoom,lly_zoom,FinalSortPercent,IMinXcoord,IMinYcoord,IMaxXcoord,
IMaxYcoord,DBWidth,DBHeight,GridX,GridY,GridSpace,urx_zoom,ury_zoom,ErrLLX,ErrLLY,
thex,they,PAD_DIST,PPAD_DIST,VPAD_DIST,ErrURX,ErrURY,FAN_ANGLE,OBS_HEIGHT,TGT_HEIGHT,
CLIPLLX,CLIPLLY,CLIPURX,CLIPURY,GridSigPercent,ZoomVertExag;

extern double *GLOBAL_MI_X1,*GLOBAL_MI_Y1;
extern double *GLOBAL_MI_X2,*GLOBAL_MI_Y2;
extern double *XNEW4;
extern double *YNEW4;



extern String help3,help4,help7,help8,help9,list_translations3,
translations_global,help4,list_translations14,list_translations15,
list_translations13,list_translations29,list_translations30,list_translations31,
list_translations32,list_translations33,list_translations34,list_translations35,
translations,list_translations36,list_translations37,list_translations38,
list_translations39,list_translations40,list_translations41,list_translations42,
list_translations43,list_translations44,list_translations7,list_translations12,
list_translations2,list_translations,list_translations21,list_translations4,
list_translations5,list_translations6,list_translations16,toptrans,
list_translations45,list_translations46,list_translations47,list_translations48,
list_translations49,list_translations50,list_translations51,list_translations52,
list_translations53,list_translations54,list_translations55,translations_paste,
list_translations56,list_translations57,list_translations58,list_translations59,
list_translations60,list_translations61,list_translations63,list_translations65;


extern unsigned char SCC_LIST_INNITTED,DYNAMIC_SCC_LIST_INNITTED;


extern char Sum1ESname           [1000];
extern char Sum2ESname           [1000];
extern char Sum3ESname           [1000];
extern char dp1name              [1000];
extern char XML1name             [1000];
extern char XML2name             [1000];
extern char XML3name             [1000];
extern char ntname               [1000];
extern char boname               [1000];
extern char esname               [1000];
extern char lkname               [1000];
extern char nsname               [1000];
extern char smname               [1000];
extern char vrname               [1000];
extern char project_to_open      [1000];
extern char importoutputdir      [1000];
extern char importdirectory      [1000];
extern char patchfile            [1000];
extern char stffix               [1000];
extern char ExtraMessage         [1000];
extern char EXTRACT_EXTRA_STR    [1000];
extern char EXTRACT_TIME         [1000];
extern char shapeimportoutputdir [1000];
extern char GAITProjectName      [1000];
extern char SaveAOIName           [100];
extern char SaveReportName        [100];
extern char SavePrefName          [100];
extern char SaveSettingName       [100];
extern char DriveNames [DRIVE_MAX][500];
extern char **NetDriveNames;
extern char **NetDrivePaths;



extern char **GAITProjList;


extern char **GAITExFileList;


extern char **GAITCondList;


extern char **GAITPrevList;


extern char **GAITAOIList;


extern char **GAITPrefList;


extern char **TempFolderList;


extern char **TempFileList;


extern int *POINT_PRI;
extern int *POINT_RED;
extern int *POINT_GREEN;
extern int *POINT_BLUE;

extern int *LINE_PRI;
extern int *LINE_RED;
extern int *LINE_GREEN;
extern int *LINE_BLUE;

extern int *AREA_PRI;
extern int *AREA_RED;
extern int *AREA_GREEN;
extern int *AREA_BLUE;
extern int *AREA_STYLE;

extern int *AREA_ECCS_USED;
extern int *LINE_ECCS_USED;
extern int *POINT_ECCS_USED;

extern struct SCCstoreint * SCC_LIST;
extern struct SCCstoreint * DYNAMIC_SCC_LIST;

extern Display *mydisplay;
extern Window mywindow; 
extern Pixmap pixmap;
extern Dimension width,height;
extern GC mygc,mybitgc;
extern Widget drawing_a,pref_dialog2;
extern XColor *layer_colors;
extern unsigned long BITWHITE,BITBLACK;
extern struct LODdisplaySH *LODindex_DYN;


extern int SLASHTYPE;

extern char PROJECTLOC[1500];
extern char DATALOC[1500];
extern char layer_pref_file[100];

extern int ATTRIBUTION_TYPE;
extern int GIFD_CLASS_NUM;
extern int DOMAIN_R[NUM_D];
extern int DOMAIN_G[NUM_D];
extern int DOMAIN_B[NUM_D];
extern int SHOW_POLY_VERTICES,SHOW_LINE_VERTICES,SHOW_END_VERTICES;
extern int NOT_ZOOMED,DRAWING_MARKERS,NO_CIRCLES,DRAW_NOW;

extern int area_index,lines_found_export,points_found_export;

extern double xunits,yunits,IRegionSize;

extern struct POIList  * POIRoot;


extern void CalculateOffsets(int recnum);
extern void WritePoint(FILE *outfile,int RECNUM,double Xpoint, double Ypoint, double Zpoint);
extern void WriteEndOfDBFile(FILE *outfile);
extern void record_bytes(FILE *outfile);
extern int bytes_written;
extern void WriteIndexFileEntry(FILE *outfile, int num);
extern void FreeArrays();
extern void MallocArrays();
extern int RealClose(double a, double b);




int DO_FAN()
{
  return DO_FAN_VAR;
}


void BuildModWin()
{
  Widget rowcol,rc2,form,label1,button,MOD_sw;
  Widget C_menu,S_menu,D_menu;
  static Widget MOD_head;
  int n=0,i,j,point1,point2,point3,point4;
  int maxnamelen,maxconfiglen;
  Arg resources[15];
  SpecialMenuItem C[NUM_C],S[NUM_S],D[NUM_D],C2[2];
  Dimension theheight;

  char *COBS[16]=
  { 
    "No Configuration",
    "Area", 
    "Directed Line", 
    "Footprint Model", 
    "Line", 
    "Point Feature", 
    "Point Model", 
    "Polygon",
    "Dynamic Model",
    "Grid",
    "Collision Volume (S)",
    "Collision Volume (P)",
    "Model Library Polygon",
    "Feature Model Point Feature",
    "Feature Model Linear Feature",
    "Feature Model Areal Feature"
  };







  BUSY = 1;  
  set_cursor(mydisplay,mywindow,WATCH);

  SetEndian(indirectory);

  if(DYNAMIC_SCC_LIST_INNITTED==0)
    {
      BuildDynamicArrayOfScc(indirectory);
    }
 

  if(SCC_LIST_INNITTED==0)
    {
      if(BuildArrayOfScc((Widget)NULL,indirectory)<0)
	{
	  BUSY = 0;  
	  set_cursor(mydisplay,mywindow,GOOD);
	  return;
	}
    }


  for(i=0;i<NUM_C;i++)
    {
      sprintf(C[i].label ,"%s",CNAME[i]); 
      C[i].cclass = &xmPushButtonWidgetClass;
      C[i].callback  = (void (*)())DynCCallback; 
      C[i].callback_data = i;
    }


  sprintf(C2[0].label," Directed Line ");       C2[0].cclass = &xmPushButtonWidgetClass;
  sprintf(C2[1].label,"     Line      ");       C2[1].cclass = &xmPushButtonWidgetClass;
  C2[0].callback = (void (*)())DynCCallback;    C2[0].callback_data = 2; 
  C2[1].callback = (void (*)())DynCCallback;    C2[1].callback_data = 4; 

  sprintf(S[0].label,"Unassigned");             S[0].cclass = &xmPushButtonWidgetClass;
  sprintf(S[1].label,"Applique");               S[1].cclass = &xmPushButtonWidgetClass;
  sprintf(S[2].label,"Coverage");               S[2].cclass = &xmPushButtonWidgetClass;
  sprintf(S[3].label,"Sub-Surface");            S[3].cclass = &xmPushButtonWidgetClass;
  sprintf(S[4].label,"Surface");                S[4].cclass = &xmPushButtonWidgetClass;
  
  S[0].callback = (void (*)())DynSCallback;     S[0].callback_data = 0;
  S[1].callback = (void (*)())DynSCallback;     S[1].callback_data = 1;
  S[2].callback = (void (*)())DynSCallback;     S[2].callback_data = 2;
  S[3].callback = (void (*)())DynSCallback;     S[3].callback_data = 4;
  S[4].callback = (void (*)())DynSCallback;     S[4].callback_data = 5;
    
  sprintf(D[0].label,"Unassigned");             D[0].cclass = &xmPushButtonWidgetClass;
  sprintf(D[1].label,"Air Mobility");           D[1].cclass = &xmPushButtonWidgetClass;
  sprintf(D[2].label,"Air Obstacle");           D[2].cclass = &xmPushButtonWidgetClass;
  sprintf(D[3].label,"Boundary");               D[3].cclass = &xmPushButtonWidgetClass;
  sprintf(D[4].label,"Bridging");               D[4].cclass = &xmPushButtonWidgetClass;
  sprintf(D[5].label,"Cultural");               D[5].cclass = &xmPushButtonWidgetClass;  
  sprintf(D[6].label,"Inland Water");           D[6].cclass = &xmPushButtonWidgetClass;
  sprintf(D[7].label,"Land Mobility");          D[7].cclass = &xmPushButtonWidgetClass;
  sprintf(D[8].label,"Land Obstacle");          D[8].cclass = &xmPushButtonWidgetClass;
  sprintf(D[9].label,"Military Use");           D[9].cclass = &xmPushButtonWidgetClass;
  sprintf(D[10].label,"Open Water");            D[10].cclass = &xmPushButtonWidgetClass;
  sprintf(D[11].label,"Terrain");               D[11].cclass = &xmPushButtonWidgetClass;
  sprintf(D[12].label,"Vegetation");            D[12].cclass = &xmPushButtonWidgetClass;
  sprintf(D[13].label,"Maritime Mobility");     D[13].cclass = &xmPushButtonWidgetClass;
  sprintf(D[14].label,"Maritime Obstacle");     D[14].cclass = &xmPushButtonWidgetClass;
  sprintf(D[15].label,"Maritime Culture");      D[15].cclass = &xmPushButtonWidgetClass;
  sprintf(D[16].label,"Weather");               D[16].cclass = &xmPushButtonWidgetClass;
  sprintf(D[17].label,"Space");                 D[17].cclass = &xmPushButtonWidgetClass;
  sprintf(D[18].label,"Descriptive");           D[18].cclass = &xmPushButtonWidgetClass;
  
  D[0].callback = (void (*)())DynDCallback;     D[0].callback_data = 0;
  D[1].callback = (void (*)())DynDCallback;     D[1].callback_data = 1;
  D[2].callback = (void (*)())DynDCallback;     D[2].callback_data = 2;
  D[3].callback = (void (*)())DynDCallback;     D[3].callback_data = 3; 
  D[4].callback = (void (*)())DynDCallback;     D[4].callback_data = 4;
  D[5].callback = (void (*)())DynDCallback;     D[5].callback_data = 5;
  D[6].callback = (void (*)())DynDCallback;     D[6].callback_data = 6;
  D[7].callback = (void (*)())DynDCallback;     D[7].callback_data = 7;
  D[8].callback = (void (*)())DynDCallback;     D[8].callback_data = 8;
  D[9].callback = (void (*)())DynDCallback;     D[9].callback_data = 9;
  D[10].callback = (void (*)())DynDCallback;    D[10].callback_data = 10;
  D[11].callback = (void (*)())DynDCallback;    D[11].callback_data = 11;
  D[12].callback = (void (*)())DynDCallback;    D[12].callback_data = 12;
  D[13].callback = (void (*)())DynDCallback;    D[13].callback_data = 13;
  D[14].callback = (void (*)())DynDCallback;    D[14].callback_data = 14;
  D[15].callback = (void (*)())DynDCallback;    D[15].callback_data = 15;
  D[16].callback = (void (*)())DynDCallback;    D[16].callback_data = 16;
  D[17].callback = (void (*)())DynDCallback;    D[17].callback_data = 17;
  D[18].callback = (void (*)())DynDCallback;    D[18].callback_data = 18;

  if(MOD_UP==0)
    {
      n=0;
      XtSetArg(resources[n],  XmNwidth,     600);            n++;  
      XtSetArg(resources[n],  XmNdeleteResponse, XmDESTROY); n++; 
      MOD_head = XtCreatePopupShell
	("Runtime Modification of CSD Values",topLevelShellWidgetClass,drawing_a,resources,n);
      
      rowcol = XtVaCreateWidget ("rowcol",
				 xmRowColumnWidgetClass, MOD_head, NULL);
      
      form = XtVaCreateWidget ("form.MOD", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,  
			       NULL);      
      
      label1 = XtVaCreateManagedWidget ("lab1",
					xmLabelWidgetClass, form,
					XmNlabelString, STRING("CURRENT Configuration / Stratum / Domain Settings"),
					XmNtopAttachment,          XmATTACH_FORM,
					XmNbottomAttachment,       XmATTACH_FORM,
					XmNleftAttachment,         XmATTACH_POSITION,
					XmNleftPosition,           0,
					XmNrightAttachment,        XmATTACH_POSITION,
					XmNrightPosition,          100,
					LABELWTRANSLATE,
					NULL);
      XtManageChild(form);
      
      form = XtVaCreateWidget ("form.MOD.sw.errors", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,  
			       NULL);
      
      MOD_sw = XtVaCreateManagedWidget ("scrolled_win",
					xmScrolledWindowWidgetClass, form,
					XmNwidth,                  100,
					XmNheight,                 300,
					XmNscrollingPolicy,        XmAUTOMATIC,
					XmNtopAttachment,          XmATTACH_FORM,
					XmNbottomAttachment,       XmATTACH_FORM,
					XmNleftAttachment,         XmATTACH_FORM,
					XmNrightAttachment,        XmATTACH_FORM,
					NULL);
      
      XtManageChild(form);
      



      
      maxnamelen   = 0;
      maxconfiglen = 0;
      
      for(j=0;j<DYNAMIC_SCC_NUM;j++)
	{
	  if((int)(strlen(DYNAMIC_SCC_LIST[j].SCC))>maxnamelen)
	    {
	      maxnamelen = strlen(DYNAMIC_SCC_LIST[j].SCC);
	    }

	  if((int)(strlen(COBS[DYNAMIC_SCC_LIST[j].config]))>maxconfiglen)
	    {
	      maxconfiglen = strlen(COBS[DYNAMIC_SCC_LIST[j].config]);
	    }

	  if((DYNAMIC_SCC_LIST[j].config==2)||(DYNAMIC_SCC_LIST[j].config==4))
	    {
	      if(maxconfiglen<16)
		{
		  maxconfiglen = 16;
		}
	    }
	}
     
      if(maxconfiglen<10)
	{
	  maxconfiglen = 10;
	}

      point1 = maxnamelen;
      point2 = point1+maxconfiglen;
      point3 = point2+14;
      point4 = point3+20;


      rc2 = XtVaCreateWidget ("rc.error.editor",xmRowColumnWidgetClass, MOD_sw, NULL);
      
      form = XtVaCreateWidget ("form.error.editor", xmFormWidgetClass, rc2,
			       XmNfractionBase,  point4,  
			       NULL);
      
      label1 = XtVaCreateManagedWidget ("lab1",
					xmLabelWidgetClass, form,
					XmNlabelString, STRING("Classification Label"),
					XmNtopAttachment,       XmATTACH_FORM,
					XmNbottomAttachment,    XmATTACH_FORM,
					XmNleftAttachment,      XmATTACH_FORM,
					XmNrightAttachment,     XmATTACH_POSITION,
					XmNrightPosition,       point1,
					LABELWTRANSLATE,
					NULL);
      
      label1 = XtVaCreateManagedWidget ("lab1",
					xmLabelWidgetClass, form,
					XmNlabelString, STRING("Configuration"),
					XmNtopAttachment,       XmATTACH_FORM,
					XmNbottomAttachment,    XmATTACH_FORM,
					XmNleftAttachment,      XmATTACH_POSITION,
					XmNleftPosition,        point1,
					XmNrightAttachment,     XmATTACH_POSITION,
					XmNrightPosition,       point2,
					LABELWTRANSLATE,
					NULL);
      label1 = XtVaCreateManagedWidget ("lab1",
					xmLabelWidgetClass, form,
					XmNlabelString, STRING("Stratum"),
					XmNtopAttachment,      XmATTACH_FORM,
					XmNbottomAttachment,   XmATTACH_FORM,
					XmNleftAttachment,     XmATTACH_POSITION,
					XmNleftPosition,       point2,
					XmNrightAttachment,    XmATTACH_POSITION,
					XmNrightPosition,      point3,
					LABELWTRANSLATE,
					NULL);
      
      label1 = XtVaCreateManagedWidget ("lab1",
					xmLabelWidgetClass, form,
					XmNlabelString, STRING("Domain"),
					XmNtopAttachment,      XmATTACH_FORM,
					XmNbottomAttachment,   XmATTACH_FORM,
					XmNleftAttachment,     XmATTACH_POSITION,
					XmNleftPosition,       point3,
					XmNrightAttachment,    XmATTACH_POSITION,
					XmNrightPosition,      point4,
					LABELWTRANSLATE,
					NULL);
      XtManageChild(form);
           
      for(j=0;j<DYNAMIC_SCC_NUM;j++)
	{
	  form = XtVaCreateWidget ("form.error.editor", xmFormWidgetClass, rc2,
				   XmNfractionBase,  point4,  
				   NULL);
	  
	  n = 0;  

	  button = XtVaCreateManagedWidget("Done",xmPushButtonWidgetClass, form,
					   XmNlabelString,       STRING(DYNAMIC_SCC_LIST[j].SCC),
					   XmNleftAttachment,    XmATTACH_FORM,
					   XmNrightAttachment,   XmATTACH_POSITION,
					   XmNtopAttachment,     XmATTACH_FORM,
					   XmNbottomAttachment,  XmATTACH_FORM,
					   XmNrightPosition,     point1,
					   XmNtraversalOn,       False,
					   XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					   NULL);


	  XtAddCallback(button, XmNactivateCallback, FACCCallback2, (XtPointer)SCC_LIST[j].listposn);
	  XtManageChild(button);	  
	  
	  if(
	     (DYNAMIC_SCC_LIST[j].config!=0)&&
	     (DYNAMIC_SCC_LIST[j].config!=2)&&
	     (DYNAMIC_SCC_LIST[j].config!=4)
	     )
	    {
	      
	      C_menu = XtVaCreateManagedWidget (C[DYNAMIC_SCC_LIST[j].config].label,
						xmLabelWidgetClass, form,
						LABELWTRANSLATE,
						NULL);
	    }
	  else if (
		   (DYNAMIC_SCC_LIST[j].config==2)||
		   (DYNAMIC_SCC_LIST[j].config==4)
		   )
	    {
	      
	      C_menu = SpecialBuildMenu (form,C2,2,(unsigned char)((DYNAMIC_SCC_LIST[j].config)/2-1));
	    }
	  else if (DYNAMIC_SCC_LIST[j].config==0)
	    {
	      
	      C_menu = SpecialBuildMenu (form,C,NUM_C,DYNAMIC_SCC_LIST[j].config);
	    }	

	  XtVaSetValues(C_menu,  
			XmNleftAttachment,   XmATTACH_POSITION,
			XmNleftPosition,     point1,
			XmNrightAttachment,  XmATTACH_POSITION,
			XmNrightPosition,    point2,
			XmNtopAttachment,    XmATTACH_FORM,
			XmNbottomAttachment, XmATTACH_FORM,
			NULL);
	  XtManageChild (C_menu);

	  S_menu = SpecialBuildMenu (form,S,NUM_S-1,DYNAMIC_SCC_LIST[j].strat);


	
	  XtVaSetValues(S_menu,  
			XmNleftAttachment,   XmATTACH_POSITION,
			XmNleftPosition,     point2,
			XmNrightAttachment,  XmATTACH_POSITION,
			XmNrightPosition,    point3,
			XmNtopAttachment,    XmATTACH_FORM,
			XmNbottomAttachment, XmATTACH_FORM,
			NULL);
	  XtManageChild (S_menu);

	  D_menu = SpecialBuildMenu (form,D,NUM_D,DYNAMIC_SCC_LIST[j].domain);
	  XtVaSetValues(D_menu,  
			XmNleftAttachment,   XmATTACH_POSITION,
			XmNleftPosition,     point3,
			XmNrightAttachment,  XmATTACH_POSITION,
			XmNrightPosition,    point4,
			XmNtopAttachment,    XmATTACH_FORM,
			XmNbottomAttachment, XmATTACH_FORM,
			NULL);
	  XtManageChild (D_menu);

	  for(i=0;i<NUM_C;i++)
	    {
	      C[i].callback_data=C[i].callback_data+NUM_C;
	    }
	  for(i=0;i<NUM_S;i++)
	    {
	      S[i].callback_data=S[i].callback_data+NUM_S;
	    }
	  for(i=0;i<NUM_D;i++)
	    {
	      D[i].callback_data=D[i].callback_data+NUM_D;
	    }
	  for(i=0;i<2;i++)
	    {
	      C2[i].callback_data=C2[i].callback_data+NUM_C;
	    }
	  XtManageChild(form);
	}
      XtManageChild(rc2);
      
      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,
			       NULL);

      n = 0;  

      button = XtVaCreateManagedWidget("Cancel",xmPushButtonWidgetClass, form,
				       XmNlabelString,       STRING("Cancel"),
				       XmNleftAttachment,    XmATTACH_POSITION,
				       XmNleftPosition,      1,
				       XmNrightAttachment,   XmATTACH_POSITION,
				       XmNrightPosition,     30,
				       XmNtraversalOn,       False,
				       XmNtranslations, XtParseTranslationTable ( translations_global ) ,
				       NULL);

      XtAddCallback(button, XmNactivateCallback, die_callback, (XtPointer)1007);
      XtManageChild(button);

      
      n = 0;  
      
      button = XtVaCreateManagedWidget("Apply",xmPushButtonWidgetClass, form,
				       XmNlabelString,       STRING("Apply"),
				       XmNleftAttachment,    XmATTACH_POSITION,
				       XmNleftPosition,      33,
				       XmNrightAttachment,   XmATTACH_POSITION,
				       XmNrightPosition,     66,
				       XmNtraversalOn,       False,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
				       NULL);

      XtAddCallback(button, XmNactivateCallback, SaveDefaultsCallback2, (XtPointer) NULL);
      XtManageChild(button);
       
      n = 0;  
      button = XtVaCreateManagedWidget("Help",xmPushButtonWidgetClass, form,
				       XmNlabelString,      STRING("Help"),
				       XmNleftAttachment,   XmATTACH_POSITION,
				       XmNleftPosition,     70,
				       XmNrightAttachment,  XmATTACH_POSITION,
				       XmNrightPosition,    99,
				       XmNtraversalOn,      False,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
				       NULL);

      XtAddCallback(button, XmNactivateCallback, FormatHelpCallback2, (XtPointer) NULL);
      XtManageChild(button);           
      XtManageChild(form);
      XtManageChild(rowcol);
       
      MOD_UP = 1;
      XtManageChild (MOD_head);
      MyPopup  (MOD_head);
      XtAddCallback(MOD_head,XmNdestroyCallback,ShellDeath,(XtPointer)227);       

      XtVaGetValues (MOD_head,  XmNheight, &theheight, NULL);
      XtVaSetValues(MOD_head,
		    XmNminHeight, theheight,
		    XmNmaxHeight, theheight,
		    NULL);

      XtAddEventHandler(MOD_head,StructureNotifyMask,False, myResizeHandler, (XtPointer)((int)theheight));

    }
  else
    {
      ResetWidget(MOD_head);
    }
  BUSY = 0;
  set_cursor(mydisplay,mywindow,GOOD);
}




void MappingChangeCallback(Widget w,XtPointer data,XtPointer callData)
{
  char message[200];
  
  if(input_source==0)
    {
      sprintf(message,"You must select an input source data directory\n\
before you can modify it's mappings.");
      not_while_running(w,message,1133,"Illegal Manuever",1);
      return;
    }
  else if(output_source==0)
    {
      sprintf(message,"You must select an output source data directory\n\
before you can modify mappings.");
      not_while_running(w,message,1134,"Illegal Manuever",1);
      return;
    }

  BuildModWin();
}



void SetCSD(Widget w,int rebuild_win)
{
  Widget rowcol,rc2,form,label1,button,csd_sw;
  Widget C_menu,S_menu,D_menu;
  int n=0,i,j,maxnamelen,maxconfiglen,point1,point2,point3,point4;
  Arg resources[15];
  SpecialMenuItem C[NUM_C],S[NUM_S],D[NUM_D],C2[2];
  Dimension theheight;
  int padlen,donepadding=0;
  char newstring[100],newpadstring[500];

  char *COBS[16]=
  { 
    "No Configuration",
    "Area", 
    "Directed Line", 
    "Footprint Model", 
    "Line", 
    "Point Feature", 
    "Point Model", 
    "Polygon",
    "Dynamic Model",
    "Grid",
    "Collision Volume (S)",
    "Collision Volume (P)",
    "Model Library Polygon",
    "Feature Model Point Feature",
    "Feature Model Linear Feature",
    "Feature Model Areal Feature"
  };



  SetEndian(importoutputdir);


  

  BUSY = 1;  
  set_cursor(mydisplay,mywindow,WATCH);


  BuildDynamicArrayOfScc(importoutputdir);


  if(rebuild_win==0)
    {
        if(BuildArrayOfScc(w,importoutputdir)<0)
	{
	  BUSY = 0;  
	  set_cursor(mydisplay,mywindow,GOOD);
	  return;
	}
    }


  for(i=0;i<NUM_C;i++)
    {
      sprintf(C[i].label ,"%s",CNAME[i]); 
      C[i].cclass = &xmPushButtonWidgetClass;
      C[i].callback  = (void (*)())CCallback; 
      C[i].callback_data = i;
    }


  sprintf(C2[0].label,"%s",CNAME[2]);       C2[0].cclass = &xmPushButtonWidgetClass;
  sprintf(C2[1].label,"%s",CNAME[4]);       C2[1].cclass = &xmPushButtonWidgetClass;
  C2[0].callback = (void (*)())CCallback;         C2[0].callback_data = 2; 
  C2[1].callback = (void (*)())CCallback;         C2[1].callback_data = 4; 


  sprintf(S[0].label,"Unassigned");            S[0].cclass = &xmPushButtonWidgetClass;
  sprintf(S[1].label,"Applique");              S[1].cclass = &xmPushButtonWidgetClass;
  sprintf(S[2].label,"Coverage");              S[2].cclass = &xmPushButtonWidgetClass;
  sprintf(S[3].label,"Sub-Surface");           S[3].cclass = &xmPushButtonWidgetClass;
  sprintf(S[4].label,"Surface");               S[4].cclass = &xmPushButtonWidgetClass;
  
  S[0].callback = (void (*)())SCallback;       S[0].callback_data = 0;
  S[1].callback = (void (*)())SCallback;       S[1].callback_data = 1;
  S[2].callback = (void (*)())SCallback;       S[2].callback_data = 2;
  S[3].callback = (void (*)())SCallback;       S[3].callback_data = 4;
  S[4].callback = (void (*)())SCallback;       S[4].callback_data = 5;
    
  sprintf(D[0].label,"Unassigned");            D[0].cclass = &xmPushButtonWidgetClass;
  sprintf(D[1].label,"Air Mobility");          D[1].cclass = &xmPushButtonWidgetClass;
  sprintf(D[2].label,"Air Obstacle");          D[2].cclass = &xmPushButtonWidgetClass;
  sprintf(D[3].label,"Boundary");              D[3].cclass = &xmPushButtonWidgetClass;
  sprintf(D[4].label,"Bridging");              D[4].cclass = &xmPushButtonWidgetClass;
  sprintf(D[5].label,"Cultural");              D[5].cclass = &xmPushButtonWidgetClass;  
  sprintf(D[6].label,"Inland Water");          D[6].cclass = &xmPushButtonWidgetClass;
  sprintf(D[7].label,"Land Mobility");         D[7].cclass = &xmPushButtonWidgetClass;
  sprintf(D[8].label,"Land Obstacle");         D[8].cclass = &xmPushButtonWidgetClass;
  sprintf(D[9].label,"Military Use");          D[9].cclass = &xmPushButtonWidgetClass;
  sprintf(D[10].label,"Open Water");           D[10].cclass = &xmPushButtonWidgetClass;
  sprintf(D[11].label,"Terrain");              D[11].cclass = &xmPushButtonWidgetClass;
  sprintf(D[12].label,"Vegetation");           D[12].cclass = &xmPushButtonWidgetClass;
  sprintf(D[13].label,"Maritime Mobility");    D[13].cclass = &xmPushButtonWidgetClass;
  sprintf(D[14].label,"Maritime Obstacle");    D[14].cclass = &xmPushButtonWidgetClass;
  sprintf(D[15].label,"Maritime Culture");     D[15].cclass = &xmPushButtonWidgetClass;
  sprintf(D[16].label,"Weather");              D[16].cclass = &xmPushButtonWidgetClass;
  sprintf(D[17].label,"Space");                D[17].cclass = &xmPushButtonWidgetClass;
  sprintf(D[18].label,"Descriptive");          D[18].cclass = &xmPushButtonWidgetClass;
  
  D[0].callback = (void (*)())DCallback;       D[0].callback_data = 0;
  D[1].callback = (void (*)())DCallback;       D[1].callback_data = 1;
  D[2].callback = (void (*)())DCallback;       D[2].callback_data = 2;
  D[3].callback = (void (*)())DCallback;       D[3].callback_data = 3; 
  D[4].callback = (void (*)())DCallback;       D[4].callback_data = 4;
  D[5].callback = (void (*)())DCallback;       D[5].callback_data = 5;
  D[6].callback = (void (*)())DCallback;       D[6].callback_data = 6;
  D[7].callback = (void (*)())DCallback;       D[7].callback_data = 7;
  D[8].callback = (void (*)())DCallback;       D[8].callback_data = 8;
  D[9].callback = (void (*)())DCallback;       D[9].callback_data = 9;
  D[10].callback = (void (*)())DCallback;      D[10].callback_data = 10;
  D[11].callback = (void (*)())DCallback;      D[11].callback_data = 11;
  D[12].callback = (void (*)())DCallback;      D[12].callback_data = 12;
  D[13].callback = (void (*)())DCallback;      D[13].callback_data = 13;
  D[14].callback = (void (*)())DCallback;      D[14].callback_data = 14;
  D[15].callback = (void (*)())DCallback;      D[15].callback_data = 15;
  D[16].callback = (void (*)())DCallback;      D[16].callback_data = 16;
  D[17].callback = (void (*)())DCallback;      D[17].callback_data = 17;
  D[18].callback = (void (*)())DCallback;      D[18].callback_data = 18;

  if(CSD_UP==0)
    {
      n=0;
      XtSetArg(resources[n],  XmNwidth,     600);            n++;        
      XtSetArg(resources[n],  XmNdeleteResponse, XmDESTROY); n++; 

      CSD_head = XtCreatePopupShell
	("CSD Modification",topLevelShellWidgetClass,drawing_a,resources,n);
      
      rowcol = XtVaCreateWidget ("rowcol",
				 xmRowColumnWidgetClass, CSD_head, NULL);
      
      form = XtVaCreateWidget ("form.csd", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,  
			       NULL);      
      
      label1 = XtVaCreateManagedWidget ("lab1",
					xmLabelWidgetClass, form,
					XmNlabelString, STRING("Configuration / Stratum / Domain Settings"),
					XmNtopAttachment,          XmATTACH_FORM,
					XmNbottomAttachment,       XmATTACH_FORM,
					XmNleftAttachment,         XmATTACH_POSITION,
					XmNleftPosition,           0,
					XmNrightAttachment,        XmATTACH_POSITION,
					XmNrightPosition,          100,
					LABELWTRANSLATE,
					NULL);
      XtManageChild(form);
      
      form = XtVaCreateWidget ("form.csd.sw.errors", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,  
			       NULL);
      
      csd_sw = XtVaCreateManagedWidget ("scrolled_win",
					xmScrolledWindowWidgetClass, form,
					XmNwidth,                  100,
					XmNheight,                 300,
					XmNscrollingPolicy,        XmAUTOMATIC,
					XmNtopAttachment,          XmATTACH_FORM,
					XmNbottomAttachment,       XmATTACH_FORM,
					XmNleftAttachment,         XmATTACH_FORM,
					XmNrightAttachment,        XmATTACH_FORM,
					NULL);
      
      XtManageChild(form);
      
      rc2 = XtVaCreateWidget ("rc.error.editor",xmRowColumnWidgetClass, csd_sw, NULL);

      

      maxnamelen   = 0;
      maxconfiglen = 0;

      for(j=0;j<SCC_NUM;j++)
	{
	  if((int)(strlen(SCC_LIST[j].SCC))>maxnamelen)
	    {
	      maxnamelen = strlen(SCC_LIST[j].SCC);
	    }

	  if((int)(strlen(COBS[SCC_LIST[j].config]))>maxconfiglen)
	    {
	      maxconfiglen = strlen(COBS[SCC_LIST[j].config]);
	    }

	  if((SCC_LIST[j].config==2)||(SCC_LIST[j].config==4))
	    {
	      if(maxconfiglen<16)
		{
		  maxconfiglen = 16;
		}
	    }
	}
          

      
      
      if(maxconfiglen<10)
	{
	  maxconfiglen = 10;
	}

      point1 = maxnamelen;
      point2 = point1+maxconfiglen;
      point3 = point2+14;
      point4 = point3+20;

      
      form = XtVaCreateWidget ("form.error.editor", xmFormWidgetClass, rc2,
			       XmNfractionBase,  point4,  
			       NULL);
      
      
      if(NGA_TYPE==1)
	{
	  label1 = XtVaCreateManagedWidget ("lab1",
					    xmLabelWidgetClass, form,
					    XmNlabelString, STRING("EC Label"),
					    XmNtopAttachment,       XmATTACH_FORM,
					    XmNbottomAttachment,    XmATTACH_FORM,
					    XmNleftAttachment,      XmATTACH_FORM,
					    XmNrightAttachment,     XmATTACH_POSITION,
					    XmNrightPosition,       point1,
					    LABELWTRANSLATE,
					    NULL);
	}
      else
	{
	  label1 = XtVaCreateManagedWidget ("lab1",
					    xmLabelWidgetClass, form,
					    XmNlabelString, STRING("Classifier"),
					    XmNtopAttachment,       XmATTACH_FORM,
					    XmNbottomAttachment,    XmATTACH_FORM,
					    XmNleftAttachment,      XmATTACH_FORM,
					    XmNrightAttachment,     XmATTACH_POSITION,
					    XmNrightPosition,       point1,
					    LABELWTRANSLATE,
					    NULL);
	}

      
      label1 = XtVaCreateManagedWidget ("lab1",
					xmLabelWidgetClass, form,
					XmNlabelString, STRING("Configuration"),
					XmNtopAttachment,       XmATTACH_FORM,
					XmNbottomAttachment,    XmATTACH_FORM,
					XmNleftAttachment,      XmATTACH_POSITION,
					XmNleftPosition,        point1,
					XmNrightAttachment,     XmATTACH_POSITION,
					XmNrightPosition,       point2,
					LABELWTRANSLATE,
					NULL);

      label1 = XtVaCreateManagedWidget ("lab1",
					xmLabelWidgetClass, form,
					XmNlabelString, STRING("Stratum"),
					XmNtopAttachment,      XmATTACH_FORM,
					XmNbottomAttachment,   XmATTACH_FORM,
					XmNleftAttachment,     XmATTACH_POSITION,
					XmNleftPosition,       point2,
					XmNrightAttachment,    XmATTACH_POSITION,
					XmNrightPosition,      point3,
					LABELWTRANSLATE,
					NULL);
      
      label1 = XtVaCreateManagedWidget ("lab1",
					xmLabelWidgetClass, form,
					XmNlabelString, STRING("Domain"),
					XmNtopAttachment,      XmATTACH_FORM,
					XmNbottomAttachment,   XmATTACH_FORM,
					XmNleftAttachment,     XmATTACH_POSITION,
					XmNleftPosition,       point3,
					XmNrightAttachment,    XmATTACH_POSITION,
					XmNrightPosition,      point4,
					LABELWTRANSLATE,
					NULL);
      XtManageChild(form);


      for(j=0;j<SCC_NUM;j++)
	{

	  if(NGA_TYPE==1)
	    {
	      
	      continue;
	    }


	  form = XtVaCreateWidget ("form.error.editor", xmFormWidgetClass, rc2,
				   XmNfractionBase, point4,  
				   NULL);
	  n = 0;  

	  button = XtVaCreateManagedWidget("ecc",xmPushButtonWidgetClass, form,
					   XmNlabelString,       STRING(SCC_LIST[j].SCC),
					   XmNleftAttachment,    XmATTACH_FORM,
					   XmNrightAttachment,   XmATTACH_POSITION,
					   XmNtopAttachment,     XmATTACH_FORM,
					   XmNbottomAttachment,  XmATTACH_FORM,
					   XmNrightPosition,     point1,
					   XmNtraversalOn,       False,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					   NULL);

	  if((SCC_LIST[j].config==10)||(SCC_LIST[j].config==11))
	    {
	      XtSetSensitive(button,False);
	    }
	  else
	    {
	      XtAddCallback(button, XmNactivateCallback, FACCCallback, (XtPointer)SCC_LIST[j].listposn);
	    }

	  XtManageChild(button);	  

	
	  if(
	     (SCC_LIST[j].config!=0)&&
	     (SCC_LIST[j].config!=2)&&
	     (SCC_LIST[j].config!=4)
	     )
	    {
	      
	      
	      C_menu = XtVaCreateManagedWidget (C[SCC_LIST[j].config].label,
						xmLabelWidgetClass, form,
						LABELWTRANSLATE,
						NULL);
	    }

	  else if (
		   (SCC_LIST[j].config==2)||
		   (SCC_LIST[j].config==4)
		   )
	    {
	      
	      

	      if(donepadding==0)
		{
		  padlen = ((point2-point1)-13)/2;
		  padlen = padlen-2;

		  if(padlen>0)
		    {
		      for(i=0;i<padlen;i++)
			{
			  newpadstring[i]=' ';
			}
		      newpadstring[i]='\0';
		      
		      newstring[0]='\0';
		      strcat(newstring,newpadstring);
		      strcat(newstring,C2[0].label);
		      strcat(newstring,newpadstring);
		      sprintf(C2[0].label,"%s",newstring); 

		      newstring[0]='\0';
		      strcat(newstring,newpadstring);
		      strcat(newstring,C2[1].label);
		      strcat(newstring,newpadstring);
		      sprintf(C2[1].label,"%s",newstring); 
		    }
		  donepadding = 1;
		}


	      
	      C_menu = SpecialBuildMenu (form,C2,2,(unsigned char)((SCC_LIST[j].config)/2-1));




	    }
	  else if (SCC_LIST[j].config==0)
	    {
	      
	      C_menu = SpecialBuildMenu (form,C,NUM_C,SCC_LIST[j].config);
	    }	


	  XtVaSetValues(C_menu,  
			XmNleftAttachment,   XmATTACH_POSITION,
			XmNleftPosition,     point1,
			XmNrightAttachment,  XmATTACH_POSITION,
			XmNrightPosition,    point2,
			XmNtopAttachment,    XmATTACH_FORM,
			XmNbottomAttachment, XmATTACH_FORM,
			NULL);
	  XtManageChild (C_menu);


	  S_menu = SpecialBuildMenu (form,S,NUM_S-1,SCC_LIST[j].strat);


	  XtVaSetValues(S_menu,  
			XmNleftAttachment,   XmATTACH_POSITION,
			XmNleftPosition,     point2,
			XmNrightAttachment,  XmATTACH_POSITION,
			XmNrightPosition,    point3,
			XmNtopAttachment,    XmATTACH_FORM,
			XmNbottomAttachment, XmATTACH_FORM,
			NULL);
	  XtManageChild (S_menu);

	  D_menu = SpecialBuildMenu (form,D,NUM_D,SCC_LIST[j].domain);

	  XtVaSetValues(D_menu,  
			XmNleftAttachment,   XmATTACH_POSITION,
			XmNleftPosition,     point3,
			XmNrightAttachment,  XmATTACH_POSITION,
			XmNrightPosition,    point4,
			XmNtopAttachment,    XmATTACH_FORM,
			XmNbottomAttachment, XmATTACH_FORM,
			NULL);

	  XtManageChild (D_menu);



	  for(i=0;i<NUM_C;i++)
	    {
	      C[i].callback_data=C[i].callback_data+NUM_C;
	    }
	  for(i=0;i<NUM_S;i++)
	    {
	      S[i].callback_data=S[i].callback_data+NUM_S;
	    }
	  for(i=0;i<NUM_D;i++)
	    {
	      D[i].callback_data=D[i].callback_data+NUM_D;
	    }
	  for(i=0;i<2;i++)
	    {
	      C2[i].callback_data=C2[i].callback_data+NUM_C;
	    }
	
	  XtManageChild(form);
	}


      XtManageChild(rc2);
      
      
      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,
			       NULL);
      
      button = XtVaCreateManagedWidget ("Help",xmPushButtonWidgetClass,form,
					XmNlabelString,        STRING("Help"),
					XmNleftAttachment,  XmATTACH_POSITION,
					XmNleftPosition,                    1,
					XmNrightAttachment, XmATTACH_POSITION,
					XmNrightPosition,                   49,
					XmNtraversalOn,                 False,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					NULL); 
      XtAddCallback(button, XmNactivateCallback, FormatHelpCallback, (XtPointer) NULL);
      XtManageChild(button);

  
       
      Bbutton = XtVaCreateManagedWidget ("Done",xmPushButtonWidgetClass,form,
					 XmNlabelString,        STRING("Done"),
					 XmNleftAttachment,  XmATTACH_POSITION,
					 XmNleftPosition,                    51,
					 XmNrightAttachment, XmATTACH_POSITION,
					 XmNrightPosition,                   99,
					 XmNtraversalOn,                 False,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					 NULL); 
      XtAddCallback(Bbutton, XmNactivateCallback, die_callback, (XtPointer)1006);
      XtManageChild(Bbutton);
      XtManageChild(form);
      
      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100, NULL);

      if(NGA_TYPE==1)
	{
	  button = XtVaCreateManagedWidget ("Create GAIT Project Using Current Settings",xmPushButtonWidgetClass,form,
					    XmNlabelString,        STRING("Create GAIT Project Using Current Settings"),
					    XmNleftAttachment,  XmATTACH_POSITION,
					    XmNleftPosition,                    10,
					    XmNrightAttachment, XmATTACH_POSITION,
					    XmNrightPosition,                   90,
					    XmNtraversalOn,                 False,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					    NULL); 
	}
      else
	{
	  button = XtVaCreateManagedWidget ("Create SEE-IT Database Using Current Settings",xmPushButtonWidgetClass,form,
					    XmNlabelString,        STRING("Create SEE-IT Database Using Current Settings"),
					    XmNleftAttachment,  XmATTACH_POSITION,
					    XmNleftPosition,                    10,
					    XmNrightAttachment, XmATTACH_POSITION,
					    XmNrightPosition,                   90,
					    XmNtraversalOn,                 False,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					    NULL); 
	}
      XtAddCallback(button, XmNactivateCallback, FormatCallback, (XtPointer) NULL);
      XtManageChild(button);
      XtManageChild(form);
      XtManageChild(rowcol);

      CSD_UP = 1;
      XtManageChild (CSD_head);
      MyPopup  (CSD_head);
      XtAddCallback(CSD_head,XmNdestroyCallback,ShellDeath,(XtPointer)223);       

      XtVaGetValues (CSD_head,  XmNheight, &theheight, NULL);
      XtVaSetValues(CSD_head,
		    XmNminHeight, theheight,
		    XmNmaxHeight, theheight,
		    NULL);

      XtAddEventHandler(CSD_head,StructureNotifyMask,False, myResizeHandler, (XtPointer)((int)theheight));
    }
  else
    {
      ResetWidget(CSD_head);
    }

  BUSY = 0;
  set_cursor(mydisplay,mywindow,GOOD);
}




int SilentConvertClassCode(char *oldcode)
{
  int i;

  for(i=1;i<INscc_loop;i++)
    {
      if(!strcmp(oldcode,GetECCCode(i)))
	{
	  return i-1;
	}
    }
  return -100;
}






char *GetLayerPart(char oldaline[])
{
  int len,startposn,endposn,i;
  char test[1000],aline[1000];
  static char newline[1000];

  sprintf(aline,"%s",oldaline);

  if(aline==NULL)
    {
      printf("(1) Ignoring blank line in InputSpecFile\n");
      return NULL;
    }
  if(aline[0]==0)
    {
      printf("(2) Ignoring blank line in InputSpecFile\n");
      return NULL;
    }
  if(aline[1]==0)
    {
      printf("(3) Ignoring blank line in InputSpecFile\n");
      return NULL;
    }




  len = strlen(aline);


  for(i=0;i<len;i++)
  {
	if((aline[i]==10)||(aline[i]==13))
	  {
		aline[i]   = '\n';
		aline[i+1] = '\0';
		break;
	  }
  }

 

  sscanf(aline,"%s",test);
  if(!strcmp(test,"GEOTIFF"))
  {
	  endposn = 9;
  }
  else
  {
	  endposn = 6;
  }

  len = strlen(aline);

  if(aline[len-2]!='"')
    {
      printf("(1) bad line in input file:  %s.  Ignoring this line %c %d\n",
	     aline,aline[len-1],len);

      for(i=0;i<len;i++)
	{
	  printf(" %d = %c\n",i,aline[i]);
	}

      return NULL;
    }


  startposn = -1;
 

  for(i=0;i<len-2;i++)
    {
      if(aline[i]=='"')
	{
	  startposn = i;
	}
    }

  if(startposn==-1)
    {
      printf("(4) bad line in input file:  %s.  Ignoring this line\n",aline);
      return NULL;
    }


  






  for(i=endposn; i<=(startposn-3); i++)
    {
      newline[i-endposn] = aline[i];
    }
  newline[i-endposn] = '\0';

  return newline;
}





void RemoveOldExtractFiles()
{
  char test[1000];
  FILE *deleteme;
  int i;


  for(i=1;i<100;i++)
  {
    sprintf(test,"%sareals%d.bin",importoutputdir,i);
    deleteme = fopen(test,"r");
    if(deleteme!=NULL)
	{
	  fclose(deleteme);

	  if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
	  {
	    sprintf(test,"del \"%sareals%d.bin\"",importoutputdir,i);
	  }
	  else
	  {
	    sprintf(test,"rm \"%sareals%d.bin\"",importoutputdir,i);
	  }

	  system(test);
	} 


    sprintf(test,"%sgrid%d.bin",importoutputdir,i);
    deleteme = fopen(test,"r");
    if(deleteme!=NULL)
	{
	  fclose(deleteme);

	  if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
	  {
	    sprintf(test,"del \"%sgrid%d.bin\"",importoutputdir,i);
	  }
	  else
	  {
	    sprintf(test,"rm \"%sgrid%d.bin\"",importoutputdir,i);
	  }
	  system(test);
	} 



    sprintf(test,"%slinears%d.bin",importoutputdir,i);
    deleteme = fopen(test,"r");
    if(deleteme!=NULL)
	{
	  fclose(deleteme);

	  if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
	  {
	    sprintf(test,"del \"%slinears%d.bin\"",importoutputdir,i);
	  }
	  else
	  {
	    sprintf(test,"rm \"%slinears%d.bin\"",importoutputdir,i);
	  }
	  system(test);
	}
  } 


  if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
  { 
    sprintf(test,"del /Q \"%s%s\\*.*\"",importoutputdir,outfoldername);
    system(test);
  } 
  else
  { 
    sprintf(test,"rm -r -f \"%s%s/*.*\"",importoutputdir,outfoldername);
    system(test);
  } 


  if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
  { 
    sprintf(test,"del /Q \"%sattribution_errors\\*.*\"",importoutputdir);
    system(test);
  } 
  else
  { 
    sprintf(test,"rm -r -f \"%sattribution_errors/*.*\"",importoutputdir);
    system(test);
  } 


  if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
  { 
    sprintf(test,"del /Q \"%ssummary_files\\*.*\"",importoutputdir);
    system(test);
  } 
  else
  { 
    sprintf(test,"rm -r -f \"%ssummary_files/*.*\"",importoutputdir);
    system(test);
  } 


  if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
  { 
    sprintf(test,"del /Q \"%sTREX_Reports\\*.*\"",importoutputdir);
    system(test);
  } 
  else
  { 
    sprintf(test,"rm -r -f \"%sTREX_Reports/*.*\"",importoutputdir);
    system(test);
  } 


  if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
  {
    sprintf(test,"del /Q \"%sinspection_files\\*.*\"",importoutputdir);
    system(test);
  }
  else
  {
    sprintf(test,"rm -r -f \"%sinspection_files/*.*\"",importoutputdir);
    system(test);
  }

  if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
  {
    sprintf(test,"del /Q \"%sXML\\*.*\"",importoutputdir);
    system(test);
  }
  else
  {
    sprintf(test,"rm -r -f \"%sXML/*.*\"",importoutputdir);
    system(test);
  }


  if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
  {
    sprintf(test,"del /Q \"%sQA\\*.*\"",importoutputdir);
    system(test);
  }
  else
  {
    sprintf(test,"rm -r -f \"%sQA/*.*\"",importoutputdir);
    system(test);
  }


  if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
  {
    sprintf(test,"del /Q \"%sQACR_files\\*.*\"",importoutputdir);
    system(test);
  }
  else
  {
    sprintf(test,"rm -r -f \"%sQACR_files/*.*\"",importoutputdir);
    system(test);
  }

  if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
  {
    sprintf(test,"del /Q \"%sview_network_files\\*.*\"",importoutputdir);
    system(test);
  }
  else
  {
    sprintf(test,"rm -r -f \"%sview_network_files/*.*\"",importoutputdir);
    system(test);
  }


  if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
  {
    sprintf(test,"del /Q \"%sexported_shapefiles\\*.*\"",importoutputdir);
    system(test);
  }
  else
  {
    sprintf(test,"rm -r -f \"%sexported_shapefiles/*.*\"",importoutputdir);
    system(test);
  }


  if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
  {
    sprintf(test,"del /Q \"%scondition_reports\\*.*\"",importoutputdir);
    system(test);
  }
  else
  {
    sprintf(test,"rm -r -f \"%scondition_reports/*.*\"",importoutputdir);
    system(test);
  }


}



void RemoveLayerFile()
{
  char test[5000];

  if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
    {
      sprintf(test,"del \"%slayercolors.txt\"",importoutputdir);
      system(test);
    }
  else
    {
      sprintf(test,"rm \"%slayercolors.txt\"",importoutputdir);
      system(test);
    }
}


void ResetContours()
{
  
}


void Import3CallbackClean(Widget w,XtPointer data,XtPointer callData)
{
  extern int unsavedignore;
  extern int UnsavedConditions;

  printf("creating project even though there are unsaved conditions or ignore settings\n");

  unsavedignore = 0;
  UnsavedConditions = 0;

  Import3Callback(w,(XtPointer)2,(XtPointer)2);
}


Widget GetImportShell()
{
  extern int import_head_in_use;
  extern Widget importshell,importshell2;

  if(import_head_in_use==1)
  {  
    return importshell;
  } 
  else
  { 
    return importshell2;
  }
}



int LoadMetaFile()
{
  FILE *temp;
  int line,i,j,foundit,bad,foundone=0;
  char errmsg[10000],lhs[1000],rhs[1000],aline[1000];
  int foundMGCPmeta[num_MGCP_meta];
  int foundmeta[num_meta];
  char ** MetaUserL = NULL;
  extern char *MetaLeft    [num_meta];
  extern char *MetaLeftMGCP[num_MGCP_meta];
  extern int MetaMappingPossible(int attr_type_in);


  

  if(MetaMappingPossible(ATTRIBUTION_TYPE)==0)
  {
    return 1;
  }

  if(metamap_source==0)
    {
      sprintf(errmsg,"Error: User-Defined is selected as the Metadata naming convention,\n\
but no Metadata mapping file has been specified.");
      
      not_while_running(GetImportShell(),errmsg,1401,"Can't read Metadata mapping file",1);
      return 0;
    }
  

  for(i=0;i<num_meta;i++)
    {
      foundmeta[i] = 0;
    }
  for(i=0;i<num_MGCP_meta;i++)
    {
      foundMGCPmeta[i] = 0;
    }
  
  
  temp = fopen(metamapfile,"r");
  if(temp==NULL)
    {
      sprintf(errmsg,"Error: User-Defined is selected as the Metadata naming convention,\n\
but the specified Metadata mapping file,\n\
%s,\n\
could not be opened for reading.  Either specify a valid, readable\n\
file, or change the Metadata naming convention.\n",metamapfile);

      not_while_running(GetImportShell(),errmsg,1396,"Can't read Metadata mapping file",1);
      return 0;
    }



  
  fgets(aline,1000,temp);
  line = 1;
  while(!feof(temp))
    {
      rhs[0] = '\0';
      lhs[0] = '\0';
      sscanf(aline,"%s%s",lhs,rhs);
      
      
      if((strlen(rhs)>10)||  ((strlen(lhs)>1)&&(strlen(rhs)<1)) )  
	{
	  if((strlen(rhs)>10))
	    {
	      sprintf(errmsg,"Error in Metadata mapping file, line %d:\n\
\"%s\" is too long (10 character maximum)\n",line,rhs);
	    }
	  else
	    {
	      sprintf(errmsg,"Error in Metadata mapping file, line %d:\n\
\"%s\" is too short (1 character minimum)\n",line,rhs);
	    }
	  
	  not_while_running(GetImportShell(),errmsg,1399,"Invalid Metadata mapping file",1);
	  fclose(temp);
	  return 0;
	}
      
      
      
      
      if(strlen(lhs)>2)
	{
	  foundit = 0;
	  
	  if((TEMP_ATTRIBUTION_TYPE==7)||(TEMP_ATTRIBUTION_TYPE==8))
	    {
	      for(i=0;i<num_MGCP_meta;i++)
		{
		  if(!strcmp(MetaLeftMGCP[i],lhs))
		    {
		      foundit = 1;
		      foundMGCPmeta[i] = 1;
		      break;
		    }	    
		}
	    }
	  else
	    {
	      for(i=0;i<num_meta;i++)
		{
		  if(!strcmp(MetaLeft[i],lhs))
		    {
		      foundit = 1;
		      foundmeta[i] = 1;
		      break;
		    }	    
		}
	    }

	  
	  if(foundit==0)
	    {
	      sprintf(errmsg,"Error in Metadata mapping file, line %d:\n\n\
\"%s\" is not recognized as a valid Metadata attribute\ncode for the selected attribution schema:\n      %s\n",
		      line,lhs,ParseAttributionType(TEMP_ATTRIBUTION_TYPE));
	      
	      not_while_running(GetImportShell(),errmsg,1397,"Invalid Metadata mapping file",1);
	      fclose(temp);
	      return 0;
	    }
	}
      else
	{
	  printf("Ignoring invalid or blank line %d in MetadataMappingFile\n",line);
	}

      fgets(aline,1000,temp);
      line = line + 1;
    }




  sprintf(errmsg,"Error in metadata mapping file.\n\
The following attribute(s) are not defined in the file:\n\
");
  bad = 0;


  if((TEMP_ATTRIBUTION_TYPE==7)||(TEMP_ATTRIBUTION_TYPE==8))
    {
      for(i=0;i<num_MGCP_meta;i++)
	{
	  if(foundMGCPmeta[i]==0)
	    {
	      bad = 1;
	      strcat(errmsg,MetaLeftMGCP[i]);
	      strcat(errmsg,"\n");
	    }
	}
    }
  else
    {
      for(i=0;i<num_meta;i++)
	{
	  if(foundmeta[i]==0)
	    {
	      bad = 1;
	      strcat(errmsg,MetaLeft[i]);
	      strcat(errmsg,"\n");
	    }
	}
    }


  if(bad==1)
    {
      strcat(errmsg,"\nALL metadata attributes must be defined in the\nselected Metadata Mapping File.");
      not_while_running(GetImportShell(),errmsg,1400,"Invalid Metadata mapping file",1);
      fclose(temp);
      return 0;
    }


  
  rewind(temp);

  num_user_meta = line -1;


  if(MetaUserValue!=NULL)
    {
      free(MetaUserValue);
    }
  if(MetaUser!=NULL)
    {
      free(MetaUser);
    }

  MetaUserValue = (int *) malloc(SzI*num_user_meta);
  if(MetaUserValue==NULL)
    {
      printf("out of memory trying to alloc %d at MetaUserValue\n",SzI*num_user_meta);
    }


  MetaUser      = (char **)malloc(sizeof(char *)*num_user_meta);
  if(MetaUser==NULL)
    {
      printf("out of memory trying to alloc %d at MetaUser\n",(int)sizeof(char *)*num_user_meta);
    }
  for(i=0;i<num_user_meta;i++)
    {
      MetaUser[i] = (char *)malloc(100);
      if(MetaUser[i]==NULL)
	{
	  printf("out of memory trying to alloc 100 at MetaUser[i]\n");
	}
    }


  MetaUserL      = (char **)malloc(sizeof(char *)*num_user_meta);
  if(MetaUserL==NULL)
    {
      printf("out of memory trying to alloc %d at MetaUserL\n",(int)sizeof(char *)*num_user_meta);
    }
  for(i=0;i<num_user_meta;i++)
    {
      MetaUserL[i] = (char *)malloc(100);
      if(MetaUserL[i]==NULL)
	{
	  printf("out of memory trying to alloc 100 at MetaUserL[i]\n");
	}
    }



  fgets(aline,1000,temp);
  line = 1;
  while(!feof(temp))
    {
      sscanf(aline,"%s%s",lhs,rhs);
      
      
      
      foundit = 0;
      for(i=0;i<GIFD_ATTR_NUM;i++)
	{
	  if(!strcmp(gifd_attr_codes[i],lhs))
	    {
	      foundit = 1;
	      break;
	    }	    
	}
      


      sprintf(MetaUser [line-1],"%s",rhs);
      sprintf(MetaUserL[line-1],"%s",lhs);
      MetaUserValue[line-1] = i;


      fgets(aline,1000,temp);
      line = line + 1;
    }
  fclose(temp);



  sprintf(errmsg,"Error in Metadata mapping file.\n\
The following value(s) maps to multiple attributes:\n\n");
  

  bad = 0;
  for(i=0;i<num_user_meta;i++)
    {
      

      foundone = 0;

      for(j=i+1;j<num_user_meta;j++)
	{
	  if(
	     (!strcmp(MetaUser[i],MetaUser[j]))  &&
	     (strcmp(MetaUserL[i],MetaUserL[j])) &&
	     (MetaUserValue[i]!=-999)            &&
	     (MetaUserValue[j]!=-999) 
	     )
	    {
	      foundone = 1;
	      MetaUserValue[i] = -999;
	      MetaUserValue[j] = -999;
	    }
	}

      
      if(foundone==1)
	{
	  strcat(errmsg,MetaUser[i]);
	  strcat(errmsg," ");
	  bad = bad + 1;
	  if(bad%5==0)
	    {
	      strcat(errmsg,"\n");
	    }
	}
    }



  for(i=0;i<num_user_meta;i++)
    {
      free(MetaUserL[i]);
    }
  free(MetaUserL);

  if(bad>0)
    {
      not_while_running(GetImportShell(),errmsg,1400,"Invalid Metadata mapping file",1);
      fclose(temp);
      return 0;
    }

  return 1;
}




void SaveCRFile()
{
  
  
  if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
    {
      sprintf(esname,"%scondition_reports\\%s.es",indirectory,SaveReportName);
    }
  else
    {
      sprintf(esname,"%scondition_reports/%s.es",indirectory,SaveReportName);
    }
  
  
  XtPopdown(XtParent(XtParent(XtParent(savecond_wid))));
  XtDestroyWidget(XtParent(XtParent(XtParent(savecond_wid))));
  
  reporthandleCallback((Widget)drawing_a, (XtPointer)1, (XtPointer)NULL );
}




void SaveExeFile(int nettype)
{
  Widget parent_wid;
  FILE *savefile;
  char message[1000];
  char savename[1000];
  extern Widget param_net_head,param2_net_head;
  extern int net_head_in_use;


  

  sprintf(savename,"%s",SaveSettingName);
  

  if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
    {
	  if(nettype==1)
	  {
        sprintf(SaveSettingName,"%sview_network_files\\%s.txt",indirectory,savename);
	  }
	  else
	  {
        sprintf(SaveSettingName,"%sinspection_files\\%s.txt",indirectory,savename);
	  }
    }
  else
    {
	  if(nettype==1)
	  {
        sprintf(SaveSettingName,"%sview_network_files/%s.txt",indirectory,savename);
	  }
	  else
	  {
        sprintf(SaveSettingName,"%sinspection_files/%s.txt",indirectory,savename);
	  }
    }

  printf("save settings to %s\n",SaveSettingName);
  
  
  XtDestroyWidget(XtParent(XtParent(XtParent(exe_wid))));
  
  
  if(nettype==1)
  {
    if(net_head_in_use==0)
    {
      parent_wid = param_net_head;
    }
    else if(net_head_in_use==1)
    {
      parent_wid = param2_net_head;
    }
    else
    {
      parent_wid = drawing_a;
    }
  }
  else
  {
    if(head_in_use==0)
    {
      parent_wid = param_head;
    }
    else if(head_in_use==1)
    {
      parent_wid = param2_head;
    }
    else
    {
      parent_wid = drawing_a;
    }
  }
 


  savefile = fopen(SaveSettingName,"w");
  if(savefile==NULL)
    {
      sprintf(message,"Could not open %s for write",SaveSettingName);
      not_while_running(parent_wid,message,1425,"Couldnt open file",1);
      return;
    }
  
  SaveAllSettingsFiles(savefile,0,nettype);
  
  fclose(savefile);
  
  sprintf(message,"Settings saved to file %s",SaveSettingName);
  not_while_running(parent_wid,message,1075,"Settings saved",5);

  sprintf(SaveSettingName,"%s",savename);

}




void SimpleKill2Callback(Widget w,XtPointer data,XtPointer callData)
{
  XtDestroyWidget(XtParent(XtParent(w)));
}


void OverWriteExe(Widget w,XtPointer data,XtPointer callData)
{
  XtDestroyWidget(XtParent(XtParent(w)));

  SaveExeFile(0);
}

void OverWriteNetExe(Widget w,XtPointer data,XtPointer callData)
{
  XtDestroyWidget(XtParent(XtParent(w)));

  SaveExeFile(1);
}




void OverWriteAOI(Widget w,XtPointer data,XtPointer callData)
{
  XtDestroyWidget(XtParent(XtParent(w)));

  SaveAOIFile();
}





void AskOverwriteFile(char testname[],int type, int nettype)
{
  static Widget dialog1,dialog3,dialog6;
  Widget temp_w,rowcol;
  Arg args[20];
  XmString t;
  char message[1000];
  int n=0;
  
  
  



  
  
  if(type==1)
    {
      if(overwrite1_up==1)
	  { 
	    ResetWidget(dialog1);
	    return;
	  } 
      sprintf(message,"The inspection file already exists:  \n  %s\n\nDo you want to overwrite it?\n",testname);
      sprintf(SaveSettingName,"%s",testname);
    }
  else if(type==3)
    {
      if(overwrite3_up==1)
	  { 
	    ResetWidget(dialog3);
	    return;
	  } 
      sprintf(message,"The location file already exists:  \n  %s\n\nDo you want to overwrite it?\n",testname);
      sprintf(SaveAOIName,"%s",testname);
    }
  else if(type==6)
    {
      if(overwrite6_up==1)
	  { 
	    ResetWidget(dialog6);
	    return;
	  } 
      sprintf(message,"The preference file already exists:  \n  %s.txt\n\nDo you want to overwrite it?\n",testname);
      sprintf(SavePrefName,"%s",testname);
    }
  
  t = XmStringCreateLtoR (message,XmSTRING_DEFAULT_CHARSET);
  
  n = 0;
  
  if(type==1)
    {
      n = 0;
      XtSetArg(args[n], XmNdeleteResponse, XmDESTROY);                   n++;
      dialog1 = XtCreatePopupShell("Overwrite?",topLevelShellWidgetClass,
				   drawing_a,args,n);
      
      rowcol = XtVaCreateWidget ("rowcol",
				 xmRowColumnWidgetClass,  dialog1, NULL);
    }
  else if(type==3)
    {
      n = 0;
      XtSetArg(args[n], XmNdeleteResponse, XmDESTROY);                   n++;
      dialog3 = XtCreatePopupShell("Overwrite?",topLevelShellWidgetClass,
				   drawing_a,args,n);
      
      rowcol = XtVaCreateWidget ("rowcol",
				 xmRowColumnWidgetClass,  dialog3, NULL);
    }
  else if(type==6)
    {
      n = 0;
      XtSetArg(args[n], XmNdeleteResponse, XmDESTROY);                   n++;
      dialog6 = XtCreatePopupShell("Overwrite?",topLevelShellWidgetClass,
				   drawing_a,args,n);
      
      rowcol = XtVaCreateWidget ("rowcol",
				 xmRowColumnWidgetClass,  dialog6, NULL);
    }
  
  XtSetArg(args[n], XmNautoUnmanage,      True);                       n++;
  XtSetArg(args[n], XmNcancelLabelString, STRING("No/Cancel"));        n++;
  XtSetArg(args[n], XmNokLabelString,     STRING("Yes (Overwrite)"));  n++;
  XtSetArg(args[n], XmNmessageString,     t);                          n++;
  XtSetArg(args[n], XmNdialogTitle,       STRING("Overwrite?"));       n++;
  XtSetArg(args[n], XmNdialogType,        XmDIALOG_QUESTION);          n++;

  temp_w = XmCreateMessageBox (rowcol,"mymessagebox",args,n);

  XtUnmanageChild (XmMessageBoxGetChild (temp_w, XmDIALOG_HELP_BUTTON));

  if(type==1)
    {
	  if(nettype==1)
	  {
        XtAddCallback (temp_w, XmNokCallback, (XtCallbackProc)OverWriteNetExe, testname);
	  }
	  else
	  {
        XtAddCallback (temp_w, XmNokCallback, (XtCallbackProc)OverWriteExe, testname);
	  }
    }
  else if(type==3)
    {
      XtAddCallback (temp_w, XmNokCallback, (XtCallbackProc)OverWriteAOI, testname);
    }
  else if(type==6)
    {
      XtAddCallback (temp_w, XmNokCallback, (XtCallbackProc)OverWritePrefs,(XtPointer)NULL);
    }


  XtAddCallback (temp_w, XmNcancelCallback, SimpleKill2Callback, (XtPointer)NULL);

  
  XtManageChild(temp_w);
  XtManageChild(rowcol);


  if(type==1)
    {
      XtManageChild(dialog1);
      XtAddCallback (dialog1, XmNdestroyCallback,ShellDeath,(XtPointer)4075);
      MyPopup (dialog1);
      overwrite1_up = 1;
    }
  else if(type==3)
    {
      XtManageChild(dialog3);
      XtAddCallback (dialog3, XmNdestroyCallback,ShellDeath,(XtPointer)4076);
      MyPopup (dialog3);
      overwrite3_up = 1;
    }
  else if(type==6)
    {
      XtManageChild(dialog6);
      XtAddCallback (dialog6, XmNdestroyCallback,ShellDeath,(XtPointer)4096);
      MyPopup (dialog6);
      overwrite6_up = 1;
    }

  XmStringFree (t);
}



void AskOverWrite()
{
  Widget dialog,temp_w,rowcol;
  Arg args[20];
  XmString t;
  char message[1000];
  int n=0;

  sprintf(message,"The project \"%s\" already exists.\n\nDo you want to overwrite it?\n",GAITProjectName);
  
  t = XmStringCreateLtoR (message,XmSTRING_DEFAULT_CHARSET);
  
  n = 0;
  XtSetArg(args[n], XmNdeleteResponse, XmDESTROY);                   n++;
  
  dialog = XtCreatePopupShell("Import",topLevelShellWidgetClass,
			      drawing_a,args,n);
  
  rowcol = XtVaCreateWidget ("rowcol",
			     xmRowColumnWidgetClass,  dialog, NULL);
  
  
  XtSetArg(args[n], XmNautoUnmanage,      True);                                        n++;
  XtSetArg(args[n], XmNcancelLabelString, STRING("No/Cancel"));                         n++;
  XtSetArg(args[n], XmNokLabelString,     STRING("Yes (Begin Importing/Overwriting)")); n++;
  XtSetArg(args[n], XmNmessageString,     t);                                           n++;
  XtSetArg(args[n], XmNdialogTitle,       STRING("Overwrite?"));                        n++;
  XtSetArg(args[n], XmNdialogType,        XmDIALOG_QUESTION);                           n++;
  
  
  temp_w = XmCreateMessageBox (rowcol,"mymessagebox",args,n);
  
  XtUnmanageChild (XmMessageBoxGetChild (temp_w, XmDIALOG_HELP_BUTTON));
  XtAddCallback (temp_w, XmNokCallback, Import3Callback, (XtPointer)1);
  XtAddCallback (temp_w, XmNcancelCallback, exitCallback, (XtPointer)20);  
  
  XtManageChild(temp_w);
  XtManageChild(rowcol);
  XtManageChild(dialog);
  
  XtAddCallback (dialog, XmNdestroyCallback,ShellDeath,(XtPointer)4050);
  
  MyPopup (dialog);
        
  XmStringFree (t);
}



int TestInputSpecFileExists(char tryfile[], int type)
{
  FILE *testfile;
  char aline[1000];

  testfile = fopen(tryfile,"r");
  if(testfile==NULL)
  {
    return 0;
  }

  fgets(aline,1000,testfile);
  if(feof(testfile))
  {
    fclose(testfile);
    return -1;
  }

  if(type==1)
  {
    fclose(testfile);
    return 1;
  }


  if(type==2)
  {
	while(!feof(testfile))
	{
	  if(!strncmp(aline,"GEOTIFF \"TREx DEM Raw\" ",23))
	  {
        fclose(testfile);
        return 1;
	  }
      fgets(aline,1000,testfile);
	}
  }

  fclose(testfile);
  return 0;

}


void OverWriteWrapperCallback(Widget w,XtPointer data,XtPointer callData)
{

  XtDestroyWidget(XtParent(XtParent(w)));

  AskOverWrite();
  FORMAT_BEGIN = 1; 
  XtDestroyWidget(GetImportShell());
  set_cursor(XtDisplay(GetImportShell()),XtWindow(GetImportShell()),ARROW);
  set_cursor(mydisplay,mywindow,GOOD);
}


void AskRaw()
{
  Widget dialog,temp_w,rowcol;
  Arg args[20];
  XmString t;
  char message[1000];
  int n=0;

  sprintf(message,"The TREx package specified contains a \"TDR\" folder,\nbut you have specified \"TREx analysis type\" = \"sQA\".\n\nDo you want to continue?\n");
  
  t = XmStringCreateLtoR (message,XmSTRING_DEFAULT_CHARSET);
  
  n = 0;
  XtSetArg(args[n], XmNdeleteResponse, XmDESTROY);                   n++;
  
  dialog = XtCreatePopupShell("TDR / sQA Question",topLevelShellWidgetClass,
			      drawing_a,args,n);
  
  rowcol = XtVaCreateWidget ("rowcol",
			     xmRowColumnWidgetClass,  dialog, NULL);
  
  
  XtSetArg(args[n], XmNautoUnmanage,      True);                                           n++;
  XtSetArg(args[n], XmNcancelLabelString, STRING("No/Cancel"));                            n++;
  XtSetArg(args[n], XmNokLabelString,     STRING("Yes (Begin Importing/Overwriting)")); n++;
  XtSetArg(args[n], XmNmessageString,     t);                                              n++;
  XtSetArg(args[n], XmNdialogTitle,       STRING("TDR / sQA Question"));                   n++;
  XtSetArg(args[n], XmNdialogType,        XmDIALOG_QUESTION);                              n++;
  
  
  temp_w = XmCreateMessageBox (rowcol,"mymessagebox",args,n);
  
  XtUnmanageChild (XmMessageBoxGetChild (temp_w, XmDIALOG_HELP_BUTTON));



  if(TestDB(importoutputdir,1)==1)
  {
    XtAddCallback (temp_w, XmNokCallback, OverWriteWrapperCallback, (XtPointer)1);
  }
  else
  {
    XtAddCallback (temp_w, XmNokCallback, Import3Callback, (XtPointer)1);
  }


  XtAddCallback (temp_w, XmNcancelCallback, exitCallback, (XtPointer)59);  
  
  XtManageChild(temp_w);
  XtManageChild(rowcol);
  XtManageChild(dialog);
   
  MyPopup (dialog);
        
  XmStringFree (t);
}



void Import2Callback(Widget w,XtPointer data,XtPointer callData)
{
  Widget dialog,temp_w,rowcol;
  Arg args[20];
  XmString t;
  char message[1000];
  int changeattr = 0,save_attr_type,n=0,tester,len2,j;
  extern int CREATING_TREX,TREX_TYPE;

  
  

  if(TEMP_ATTRIBUTION_TYPE==0)
  {
      not_while_running(w,"You must specify an attribution schema before you can build a project.",1527,"No attribution schema specified",1);   
    return;
  }

  if(CREATING_TREX==1)
  {
	if(TREX_TYPE==0)
	{
      not_while_running(w,"When creating a TREx project, you must specify the \"TREx analysis type\".",1631,"No TREx analysis type specified",1);   

	  if(batch_mode==1)
	  {
		exit(-1);
	  }
      return;     
	}

	if(TREX_TYPE==3)
	{
	  

	  if(TestInputSpecFileExists(importdirectory,2))
	  {
		printf("Contains raw\n");

	    AskRaw();
	    return;
	  }
	}
  }




  if(TYPE==2)
    {
      not_while_running(w,"Your current input type is \"extracted collection\".\n\
If you wish to import an extracted collection, you must use the\n\
\"Concatenate Databases\" option.",1144,"Bad Input Type",3);   
    }
  else if(import_source==0)
    {   
      if(NGA_TYPE==1)
	{
	  not_while_running(w,"You must specify a Project name before you can create a GAIT project.",1145,"No project name",1);   
	}
      else
	{
	  not_while_running(w,"You must specify a database if you wish\n\
to import it.  Use the \"Input Source\" button to\n\
select a database.",1146,"No database given",3);   
	}
    }
  else if(import_output_source==0)
    {   
      if(NGA_TYPE==1)
	{
	  not_while_running(w,"You must specify a Project name before you can create a GAIT project.",1147,"No project name",1);   
	}
      else
	{
	  not_while_running(w,"You must specify a location to store the imported database.\n\
Use the \"Destination Directory...\" button to do this.",1148,"No destination directory",3);   
	}
    }
  else if (FORMAT_BEGIN==0)
    {
      
      

      
      if(NGA_TYPE==1)
	{
	  if(TYPE==3)
	    {

	      
	      	      	      
	      if(batch_mode==0)
		{
		  set_cursor(mydisplay,mywindow,WATCH);
		  set_cursor(XtDisplay(GetImportShell()),XtWindow(GetImportShell()),WATCH);
		}


	      len2 = strlen(GAITProjectName);

	      for(j=0;j<len2;j++)
		{
		  if(
		     ((GAITProjectName[j]>=65)  && (GAITProjectName[j]<=90))  ||
		     ((GAITProjectName[j]>=48)  && (GAITProjectName[j]<=57))  ||
		     ((GAITProjectName[j]>=97)  && (GAITProjectName[j]<=122)) ||
		     (GAITProjectName[j]=='-') || (GAITProjectName[j]=='_')
		     )
		    {
		      
		    }
		  else
		    {
		      sprintf(message,"The Project Name you have entered is invalid because\n\
it contains the character \"%c\"\n\n\
Please enter a project name consisting of letters, numbers, \"-\", and \"_\"\n",
			      GAITProjectName[j]);
		      
		      
		      not_while_running(w,message,1418,"No project name",1);   
		      
		      set_cursor(mydisplay,mywindow,GOOD);
		      set_cursor(XtDisplay(GetImportShell()),XtWindow(GetImportShell()),ARROW);
		      return;
		    }
		}
	      




	         
	      

	      


	      tester = TestInputSpecFileExists(importdirectory,1);

	      if(tester<=0)
		{
		  if(tester==0)
		    {
		      sprintf(message,"An Input Specification File has not yet been created for\n\
the project %s.  You cannot create a project without first creating\n\
an Input Specification File.\n",GAITProjectName);
		    }
		  else
		    {
		      sprintf(message,"The Input Specification File for\n\
the project %s contains 0 specifications.  You cannot create a project without\n\
first creating an Input Specification File with specifications.\n",GAITProjectName);
		    }

		  not_while_running(w,message,1415,"Input Directory",5);

		  
		  set_cursor(mydisplay,mywindow,GOOD);
		  set_cursor(XtDisplay(GetImportShell()),XtWindow(GetImportShell()),GOOD);
		  return;
		}

	      
	      if(ATTRIBUTION_TYPE!=TEMP_ATTRIBUTION_TYPE)
		{
		  changeattr = 1;
		  save_attr_type = ATTRIBUTION_TYPE;
		  ATTRIBUTION_TYPE = TEMP_ATTRIBUTION_TYPE;
		  InitializeAttribution();
		}
	      
	     

	      
	      if(METATYPE==5)
		{
		  if(LoadMetaFile()==0)
		    {
		      set_cursor(XtDisplay(GetImportShell()),XtWindow(GetImportShell()),ARROW);
		      set_cursor(mydisplay,mywindow,GOOD);
		      return;
		    }
		}
	      
	      
	      if(BadShapeInput()==1)
		{
		  
		  
		  set_cursor(XtDisplay(GetImportShell()),XtWindow(GetImportShell()),ARROW);
		  set_cursor(mydisplay,mywindow,GOOD);

		  
		  if(changeattr==1)
		    {
		      ATTRIBUTION_TYPE = save_attr_type;
		      InitializeAttribution();
		    }
		  return;
		}
	      if(changeattr==1)
		{
		  ATTRIBUTION_TYPE = save_attr_type;
		  InitializeAttribution();
		}

	      set_cursor(XtDisplay(GetImportShell()),XtWindow(GetImportShell()),ARROW);
	      set_cursor(mydisplay,mywindow,GOOD);
	      
	    }
	  
	  
	  if(TestDB(importoutputdir,1)==1)
	    {
	      AskOverWrite();
	      FORMAT_BEGIN = 1;
	      XtDestroyWidget(GetImportShell());
	      set_cursor(XtDisplay(GetImportShell()),XtWindow(GetImportShell()),ARROW);
	      set_cursor(mydisplay,mywindow,GOOD);
	      return;
	    }

 
	  sprintf(message,"GAIT will now attempt to read the selected input\n\
file(s) and create a GAIT project.\n\n\
Importing may take some time!\n");
	}
      else
	{
	  
	  sprintf(message,"The program will now attempt to read the selected\n\
database and create an intermediate SEE-IT database,\n\
suitable for formatting.  After importing, you will\n\
be asked to provide information about the extracted\n\
data before formatting.  Importing may take some time!\n");
	}


      if((batch_mode==0)&&(NGA_TYPE==1))
	{
	  set_cursor(XtDisplay(GetImportShell()),XtWindow(GetImportShell()),ARROW);
	  set_cursor(mydisplay,mywindow,GOOD);
	}


      t = XmStringCreateLtoR (message,XmSTRING_DEFAULT_CHARSET);
      
      n = 0;
      XtSetArg(args[n], XmNdeleteResponse, XmDESTROY);                   n++;
      
      dialog = XtCreatePopupShell("Import",topLevelShellWidgetClass,
				  drawing_a,args,n);
      
      rowcol = XtVaCreateWidget ("rowcol",
				 xmRowColumnWidgetClass,  dialog, NULL);
      
      
      XtSetArg(args[n], XmNautoUnmanage,      True);                      n++;
      XtSetArg(args[n], XmNokLabelString,     STRING("Begin Importing")); n++;
      XtSetArg(args[n], XmNmessageString,     t);                         n++;
      XtSetArg(args[n], XmNdialogTitle,       STRING("Import"));          n++;
      XtSetArg(args[n], XmNdialogType,        XmDIALOG_INFORMATION);      n++;
      
      
      temp_w = XmCreateMessageBox (rowcol,"mymessagebox",args,n);
      
      XtUnmanageChild (XmMessageBoxGetChild (temp_w, XmDIALOG_HELP_BUTTON));
      XtAddCallback (temp_w, XmNokCallback, Import3Callback, (XtPointer)1);
      XtAddCallback (temp_w, XmNcancelCallback, exitCallback, (XtPointer)20);

      
      XtManageChild(temp_w);
      XtManageChild(rowcol);
      XtManageChild(dialog);
      
      XtAddCallback (dialog, XmNdestroyCallback,ShellDeath,(XtPointer)4050);
      
      MyPopup (dialog);
      
      FORMAT_BEGIN = 1;
      
      XmStringFree (t);
      XtDestroyWidget(GetImportShell());
    }
}



char *ParseAttributionType(int attr_type)
{
  extern int OVERRIDING_ATTRINS;
  extern int GetAttrInsType();

  if(attr_type==1)
    {
      return "GIFD D4";
    }
  if(attr_type==2)
    {
      return "GIFD D4 / NUNANPO";
    }
  else if(attr_type==3)
    {
      return "FACC+";
    }
  else if(attr_type==4)
    {
      return "FACC+ / NUNANPO";
    }
  else if(attr_type==5)
    {
      return "VMap2_TLM";
    }
  else if(attr_type==6)
    {
      return "VMap2_TLM / NUNANPO";
    }
  else if(attr_type==7)
    {
      return "MGCP (TRD3)";
    }
  else if(attr_type==8)
    {
      return "MGCP (TRD4)";
    }
  else if(attr_type==11)
    {
      return "UFD1";
    }
  else if(attr_type==12)
    {
      return "UFD1 / NUNANPO";
    }
  else if(attr_type==9)
    {
      return "UFD2";
    }
  else if(attr_type==10)
    {
      return "UFD2 / NUNANPO";
    }
  else if(attr_type==13)
    {
      return "UFD3";
    }
  else if(attr_type==14)
    {
      return "UFD3 / NUNANPO";
    }
  else if(attr_type==15)
    {
      return "LTDS (v4.0)";
    }
  else if(attr_type==16)
    {
      return "LTDS (v5.0)";
    }
  else if(attr_type==17)
    {
      return "S-UTDS (v4.0)";
    }
  else if(attr_type==18)
    {
      return "S-UTDS (v5.0)";
    }
  else if(attr_type==19)
    {
      return "RTDS (v4.0)";
    }
  else if(attr_type==20)
    {
      return "RTDS (v5.0)";
    }
  else if(attr_type==21)
    {
      return "GTDS (v4.0)";
    }
  else if(attr_type==22)
    {
      return "GTDS (v5.0)";
    }
  else if(attr_type==23)
    {
      return "NFDD (v6.0)";
    }
  else if(attr_type==24)
    {
      return "NFDD / NUNANPO (v6.0)";
    }
  else if(attr_type==25)
    {
      return "DFDD (BL 2010-2.00)";
    }
  else if(attr_type==26)
    {

	  if(OVERRIDING_ATTRINS>=0)
	  {
        if(OVERRIDING_ATTRINS==5)
		{
		  OVERRIDING_ATTRINS = -1;
          return "TREx";
		}
	    OVERRIDING_ATTRINS = -1;
		return "DFDD / NUNANPO (BL 2010-2.00)";
	  }

	  if(OVERRIDING_ATTRINS==-2)
	  {
        

	    OVERRIDING_ATTRINS = -1;
        return "DFDD / NUNANPO (BL 2010-2.00)";
	  }


	  if(GetAttrInsType()==5)
	  {
        return "TREx";
	  }

      return "DFDD / NUNANPO (BL 2010-2.00)";
    }
  else if(attr_type==27)
    {
      return "AFD (v2.6)"; 
    }
  else if(attr_type==28)
    {
      return "AFD / NUNANPO (v2.6)"; 
    }
  else if(attr_type==29)
    {
      return "GGDM (v2.2)";
    }
  else if(attr_type==30)
    {
      return "GGDM / NUNANPO (v2.2)";
    }
  else if(attr_type==39)
    {
      return "TDS (v4.0)";
    }
  else if(attr_type==41)
    {
      return "TDS (v5.2)";
    }
  else if(attr_type==43)
    {
      return "TDS (v6.1)";
    }


  else if(attr_type==45)
    {
      return "GGDM (v2.1)";
    }
  else if(attr_type==46)
    {
      return "GGDM / NUNANPO (v2.1)";
    }
  else if(attr_type==47)
    {
      return "GGDM (v3.0)";
    }
  else if(attr_type==48)
    {
      return "GGDM / NUNANPO (v3.0)";
    }




  else
    {
      printf("BAd PAT %d\n",attr_type);
      XBell(mydisplay,50);
      return "Unknown!";
    }
}



void type_cb(Widget menu_item,XtPointer client_data,XtPointer call_data)
{
  int item_no = (int) client_data;
  
  
  TYPE=item_no;  


  if(TYPE==0)
    {
      not_while_running(menu_item,"To import a single stf file, you must set the\n\
\"Input Source\" to the root file of a single\n\
stf.  Example:\n\n\
/usr/somewhere/stf/stf_file2.stf\n\
",1149,"Specification for stf file",5);
    }
  if(TYPE==1)
    {
      not_while_running(menu_item,"To import a collection of stf files, the\n\
\"Input Source\" must be a text file containing the full\n\
pathnames to each stf file to extract (1 per line).\n\n\
Example stf collection file:\n\n\
   /usr/nowhere/stf/stf_file.stf\n\
   /usr/somewhere/stf/stf_file2.stf\n\
   /bin/stf_file3.stf\n\
   /usr/nowhere/stf/stf_file4.stf\n\
   /disk2/myfiles/stf_file5.stf\n\n\
All databases in the collection must be in the same coordinate system,\n\
and the last line must be terminated by a newline\n\
",1150,"Specification for stf collection file",5);
    }
  else if(TYPE==2)
    {
      not_while_running(menu_item,"To combine a collection of previously extracted\n\
databases, each extracted database must reside in a\n\
seperate directory, and \"Input Source\" must\n\
be a text file containing the full pathnames to each\n\
directory where a previously extracted database\n\
resides (1 per line).\n\n\
Example extracted collection file:\n\n\
/disk2/myfiles/peice1\n\
/disk2/myfiles/peice2\n\
/disk2/myfiles/peice3\n\
/disk2/myfiles/peice4\n\n\
All databases in the collection must be in the same coordinate system.\n\
",1151,"Specification for extracted collection file",5);
    }
}


void ImportFormatCallback(Widget w,XtPointer data,XtPointer callData)
{
  
  if(import_output_source==1)
    {
      if(DEBUG==1){printf("Here is where we will do the formatting of the files in %s\n",importoutputdir);}


      set_cursor(XtDisplay(GetImportShell()),XtWindow(GetImportShell()),WATCH);
      SetCSD(XtParent(XtParent(w)),0); 
      set_cursor(XtDisplay(GetImportShell()),XtWindow(GetImportShell()),GOOD);

    }
  else
    {
      not_while_running(w,"You must select a destination directory before you\n\
can format the files residing in it.",1153,"Illegal Manuever",1);   
      return;     
    }
}


void importoutputfileDialogCallback(Widget w, XtPointer userData,
			       XmFileSelectionBoxCallbackStruct *data)
{
  char *junk;  
  
  XmStringGetLtoR(data->value,(XmStringCharSet) XmSTRING_DEFAULT_CHARSET, &junk);  
  
  if(junk[strlen(junk)]=='\0') 
    {
      if(
	 (junk[strlen(junk)-1]=='/')||
	 (junk[strlen(junk)-1]=='\\')
	 )
	{
	  junk[strlen(junk)-1]='\0';
	}
    }
  
  strcpy(importoutputdir,junk);
  XtFree(junk);

  if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
    {
      strcat(importoutputdir,"\\");
    }
  else
    {
      strcat(importoutputdir,"/");
    }

  if(DEBUG==1){printf("Import-output file name is %s\n",importoutputdir); }
  
  XtVaSetValues(terrain_output_import,XmNlabelString,STRING(importoutputdir),NULL);
  
  import_output_source=1; 
  IMPORT_OUTPUT = 0;

  XtDestroyWidget(XtParent(XtParent(w)));
}




void importoutput2fileDialogCallback(Widget w, XtPointer userData,
			       XmFileSelectionBoxCallbackStruct *data)
{
  char *junk;  
  
  if(old_file_browser==1)
  {
    XmStringGetLtoR(data->value,(XmStringCharSet) XmSTRING_DEFAULT_CHARSET, &junk);  
  }
  else
  {
	junk = (char *)malloc(1000);
	sprintf(junk,"%s",(char *)data);
  }

  
  if(junk[strlen(junk)]=='\0') 
    {
      if(
	 (junk[strlen(junk)-1]=='/')||
	 (junk[strlen(junk)-1]=='\\')
	 )
	{
	  junk[strlen(junk)-1]='\0';
	}
    }
  
  strcpy(shapeimportoutputdir,junk);
  if(old_file_browser==1)
  {
    XtFree(junk);
  }
  else
  {
	  free(junk);
  }

  if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
    {
      strcat(shapeimportoutputdir,"\\");
    }
  else
    {
      strcat(shapeimportoutputdir,"/");
    }

  if(DEBUG==1){printf("Shape Import-output file name is %s\n",shapeimportoutputdir); }
  
  
  

  XtVaSetValues(shapefile_text_area,XmNvalue,shapeimportoutputdir,NULL);


  shape_source=1; 
 
  

  if(old_file_browser==1)
  {
    XtDestroyWidget(XtParent(XtParent(w)));
    SHAPE_IMPORT_OUTPUT = 0;
  }
  else
  {
	HandleSuccessDos(chooseshape_dialog);
  }
}




int GoodFileName(char tester[],int type, int nettype)
{
  Widget parent_wid;
  FILE *test;
  int i;
  char message[1000],dir[1000];


  if(type==1)
    {
      parent_wid = exe_wid;
    }
  else if(type==2)
    {
      parent_wid = savecond_wid;
    }
  else if(type==3)
    {
      parent_wid = aoi_save_wid;
    }
  else if(type==4)
    {
      parent_wid = savelayer_wid;
    }
  else if(type==5)
    {
      parent_wid = aoi_shape_wid;
    }
  else if(type==6)
    {
      parent_wid = savepref_wid;
  }
  else
    {
      XBell(mydisplay,50);
      printf("bad type %d to GoodFileName\n",type);
      return 1;
    }
  

  if(strlen(tester)==0)
    {
      if(type!=4)
	{
	  not_while_running(XtParent(XtParent(XtParent(parent_wid))),
			    "To save, you must enter a name",1439,"Bad name",1);   
	}
      return 0;
    }



  for(i=0;i<(int)strlen(tester);i++)
    {
      if(
	 ((tester[i]>=65)  && (tester[i]<=90))  ||
	 ((tester[i]>=48)  && (tester[i]<=57))  ||
	 ((tester[i]>=97)  && (tester[i]<=122)) ||
	 (tester[i]=='-') || (tester[i]=='_')
	 )
	{
	  
	}
      else
	{
	  sprintf(message,"The name you have entered is invalid because\n\
it contains the character \"%c\"\n\n\
Please enter a name consisting of letters, numbers, \"-\", and \"_\"\n",
		  tester[i]);
	  
	  not_while_running(XtParent(XtParent(XtParent(parent_wid))),message,1424,"Bad name",1);   

	  return 0;
	}
    }



  

  if(type==2)
    {
      
      return 1;
    }
  if(type==4)
  {
	  return 1;
  }

  if(type==1)
    {  
	  if(nettype==1)
	  {
        if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
		{ 
	      sprintf(dir,"%sview_network_files\\%s.txt",indirectory,tester);
		} 
        else
		{ 
	      sprintf(dir,"%sview_network_files/%s.txt",indirectory,tester);
		} 
	  }
	  else
	  {
        if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
		{ 
	      sprintf(dir,"%sinspection_files\\%s.txt",indirectory,tester);
		} 
        else
		{ 
	      sprintf(dir,"%sinspection_files/%s.txt",indirectory,tester);
		} 
	  }
    }
  else if(type==3)
    {  
      if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
	{
	  sprintf(dir,"%spoints_of_interest_files\\%s.txt",indirectory,tester);
	}
      else
	{
	  sprintf(dir,"%spoints_of_interest_files/%s.txt",indirectory,tester);
	}
    }
  else if(type==5)
  {
	  
	  return 1;
  }
  else if(type==6)
  {
     if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
	 { 
       sprintf(dir,"%s\\ProjectPreferences\\%s.txt",PROJECTLOC,tester);
	 }
     else
	 { 
       sprintf(dir,"%s/ProjectPreferences/%s.txt",PROJECTLOC,tester);
	 } 
  }
  else
  {
	  XBell(mydisplay,50);
	  printf("unhandled case in GFN\n");
	  return 1;
  }


  test = fopen(dir,"r");
  if(test!=NULL)
    {
      AskOverwriteFile(tester,type,nettype);
      fclose(test);
      return 0;
    }

  return 1;
}



void SaveAOIFile()
{
  FILE *modfile;
  struct POIList *cfl;
  char dir[1000],badout[1000];
  int num=0;


  if((aoi_save_wid==NULL)||(AOI_SAVE_UP==0))
    {
      return;
    }


  if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
    {
      sprintf(dir,"%spoints_of_interest_files\\%s.txt",indirectory,SaveAOIName);
    }
  else
    {
      sprintf(dir,"%spoints_of_interest_files/%s.txt",indirectory,SaveAOIName);
    }
  
  
  XtDestroyWidget(XtParent(XtParent(XtParent(aoi_save_wid))));
  
 
  if(POIRoot==NULL)
    {  
      not_while_running(aoi_save_wid,"There are no current locations to save!",1434,"No locations to save",1);
      return;
    }
 



  modfile = fopen(dir,"w");
  if(modfile==NULL)
    {
      sprintf(badout,"unable to open %s for write\n",dir);
      not_while_running(drawing_a,badout,1267,"Unable to write",1);
      return;
    }
  
  
  
  
  fprintf(modfile,"%d\n",CoordinateSystem);
  
  if(POIRoot!=NULL)
    {
      cfl = POIRoot;
      
      while(cfl != NULL)
	{
	  if((cfl->type >=1)&&(cfl->type<=16))
	    {
	      num = num + 1;
	      
	      if(Ctype()==2)
		{
		  fprintf(modfile,"%d %lf %lf %s\n",
			  cfl->type,cfl->x,cfl->y,cfl->annotation);
		}
	      else
		{
		  fprintf(modfile,"%d %lf %lf %s\n",cfl->type, 
			  (cfl->x/100000.0)+Xtranslation,  
			  (cfl->y/100000.0)+Ytranslation,
			  cfl->annotation);
		}
	    }
	  cfl=cfl->next;
	}
    }
  
  
  fclose(modfile);
  
  sprintf(badout,"Saved %d locations to:\n  %s",num,dir);
  not_while_running(regionhead,badout,1435,"Saved Locations",5);
}


int IsValidDirectory(char *possiblefolder)
{

#if(USE_DOS==1)
  DWORD attrs;

  attrs = GetFileAttributes(possiblefolder);

  if(attrs==0xffffffff)
  {
    
    return 0;
  }

  if(attrs & FILE_ATTRIBUTE_DIRECTORY)
  {
    return 1;
  }

  return 0;
#else

  struct stat sb;

  if(stat(possiblefolder, &sb) == 0 && S_ISDIR(sb.st_mode))
  {    
    return 1;
  }

  return 0;

#endif
}


char *TestBrowseDir(Widget w,char *possiblefolder)
{
  char message[1000];
  extern int dead_browsefolderhead;


  if(IsValidDirectory(possiblefolder))
  {
    return possiblefolder;
  }

  sprintf(message,"Error:\n %s\n\nis not a valid folder.\n\nRe-setting GAIT browse folder to <not specified>",possiblefolder);

  if(dead_browsefolderhead==1)
  {
    
    not_while_running(drawing_a,message,1590,"Invalid Folder Specified",5);
  }
  else
  {
    not_while_running(w,message,1590,"Invalid Folder Specified",5);
  }

  return "<not specified>";

}



void SetInputDataFolder()
{
  int i,len;
  extern int COPY_PROJECT_FOLDER;
  extern int COPY_PROJECT_FOLDER2;


  if(COPY_PROJECT_FOLDER>0)
  {
    

	sprintf(shapeimportoutputdir,"%s",PROJECTLOC);

    if(IMPORT_WIN==1)
	{
      XmTextFieldSetString(shapefile_text_area,shapeimportoutputdir);
	}

	shape_source = 1;
  }
  else if(COPY_PROJECT_FOLDER2>0)
  {

	sprintf(shapeimportoutputdir,"%s",PROJECTLOC);

	len = strlen(shapeimportoutputdir);

	for(i=len-1;i>0;i--)
	{
      if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
	  {
        if(shapeimportoutputdir[i]=='\\')
		{
          shapeimportoutputdir[i] = '\0';
		  break;
		}
	  }
	  else
	  {
        if(shapeimportoutputdir[i]=='/')
		{
          shapeimportoutputdir[i] = '\0';
		  break;
		}
	  }
	}


    if(IMPORT_WIN==1)
	{
      XmTextFieldSetString(shapefile_text_area,shapeimportoutputdir);
	}

	shape_source = 1;
  }
}



void EnterFileCallback(Widget w,XtPointer data,XtPointer callData)
{
  char *value = XmTextFieldGetString (w);
  char testloc[1000],message[1000];
  int i,len,type,nettype;
  extern Widget browsefolder_wid;
  extern int dead_browsefolderhead;

  len     = strlen(value);
  type    = (int)data;
  nettype = ((int)callData==999999);


  for(i=0;i<500;i++) 
  {
    len = strlen(value);

    if((len>0)&&(type!=31))  
	{
      if(value[len]=='\0') 
	  {
	    if(value[len-1]=='/')  
		{
	      value[len-1]='\0';
		}
	    else if(value[len-1]=='\\')  
		{
	      value[len-1]='\0';
		}
	  }  
	}  
  }

 
  if(type==12)
    {

      if(UpdateProjectLoc(value)==1)
	{
	  if(strcmp(PROJECTLOC,value))
	  {
	    if(input_up==1)
		{
		  XtDestroyWidget(pick_dialog);
		} 
	  }
	  sprintf(PROJECTLOC,"%s",value);
	  XmTextFieldSetString(folder_wid,PROJECTLOC);

	  SetInputDataFolder();
	}
      else
	{
	  XmTextFieldSetString(folder_wid,PROJECTLOC);
	}
    }
  else if(type==13)
    {
      sprintf(Sum1ESname,"%s",value);
    }
  else if(type==14)
    {
      sprintf(Sum2ESname,"%s",value);
    }
  else if(type==15)
    {
      sprintf(Sum3ESname,"%s",value);
    }
  else if(type==16)
    {
      if(GoodFileName(value,1,0))
	{
	  sprintf(SaveSettingName,"%s",value);
	}
    }
  else if(type==17)
    {
      if(GoodFileName(value,1,nettype))
	{
	  sprintf(SaveSettingName,"%s",value);
	  SaveExeFile(nettype);
	}
    }
  else if(type==18)  
    {
      if(GoodFileName(value,2,0))
	{
	  sprintf(SaveReportName,"%s",value);
	}
    }
  else if(type==19)
    {
      if(GoodFileName(value,2,0))
	{
	  sprintf(SaveReportName,"%s",value);
	  SaveCRFile();
	}
    }
  else if((type==20)||(type==21))
    {
      

      IgnoredLineFile [0] = '\0';
      IgnoredPointFile[0] = '\0';

      if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
	{
	  sprintf(testloc,"%s\\%s\\",PROJECTLOC,value);
	}
      else
	{
	  sprintf(testloc,"%s/%s/",PROJECTLOC,value);
	}
      
      if(TestDB(testloc,1)==0)
	{
	  if(type==20)
	    {
	      sprintf(message,"The project name entered, \"%s\", is not a current,\n\
valid project in the current GAIT project folder:\n  %s\n\n\
Please enter a valid GAIT project in the current project folder,\n\
or use the \"Choose...\" button to select from the valid GAIT projects.\n\n\
GAIT will not \"Mark results using exported shapefiles\" until this problem\n\
is addressed",
		      value,PROJECTLOC);
	      
	      not_while_running(XtParent(XtParent(XtParent(XtParent(w)))),message,1429,"Invalid Project Entered",5);
	      return;
	    }
	  else
	    {
	      if(ConsultPreviouslyIgnored==1)
		{
		  sprintf(message,"The project name entered, \"%s\", is not a current,\n\
valid project in the current GAIT project folder:\n  %s\n\n\
GAIT will not \"Mark results using exported shapefiles\" until this problem\n\
is addressed (use the \"Inspection Options\" item under the \"Inspection\" menu)",
			  value,PROJECTLOC);
		  
		  not_while_running(drawing_a,message,1429,"Invalid Project Entered",5);
		}
	      return;
	    }
	}
      else
	{
	  sprintf(project_to_open,"%s",value);

	  if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
	    {
	      if(ProjectContainsLNfile(value))
		{
		  sprintf(IgnoredLineFile,"%s\\%s\\exported_shapefiles\\consolidated",PROJECTLOC,value);
		}
	      
	      if(ProjectContainsPTfile(value))
		{
		  sprintf(IgnoredPointFile,"%s\\%s\\exported_shapefiles\\consolidated",PROJECTLOC,value);
		}
	    }
	  else
	    {
	      if(ProjectContainsLNfile(value))
		{
		  sprintf(IgnoredLineFile,"%s/%s/exported_shapefiles/consolidated",PROJECTLOC,value);
		}
	      if(ProjectContainsPTfile(value))
		{
		  sprintf(IgnoredPointFile,"%s/%s/exported_shapefiles/consolidated",PROJECTLOC,value);
		}
	    }
      	}


      if((IgnoredPointFile[0]=='\0')&&(IgnoredLineFile[0]=='\0'))
	{

	  if(type==20)
	    {
	      sprintf(message,"Neither of the exported shapefiles:\n\
   \"condreportLN\" or \"condreportPT\"\n\
were found in the project \"%s\".\n\n\
You must enter a project that contains exported shapefiles\n\
to use this option.  For a list of the projects that contain\n\
exported shapefiles, use the \"Choose...\" button.",value);

	      not_while_running(XtParent(XtParent(XtParent(XtParent(w)))),message,1430,"Invalid Project Entered",5);
	      return;
	    }
	  else if(type==21)
	    {
	      if(ConsultPreviouslyIgnored==1)
		{
		  sprintf(message,"Neither of the exported shapefiles:\n\
   \"condreportLN\" or \"condreportPT\"\n\
were found in the project \"%s\".\n\n\
You must enter a project that contains exported shapefiles\n\
to use this option.\n\n\
GAIT will not \"Mark results using exported shapefiles\" until this problem\n\
is addressed (use the \"Inspection Options\" item under the \"Inspection\" menu)\n\n\
For a list of the projects that contain exported shapefiles, use the\n\
\"Choose...\" button on that menu.",value);

		  not_while_running(drawing_a,message,1430,"Invalid Project Entered",5);
		}
	      return;
	    }
	}
    }

  else if(type==22)
    {
      if(GoodFileName(value,3,0))
	{
	  sprintf(SaveAOIName,"%s",value);
	  SaveAOIFile();
	}
    }

  else if(type==23)
    {
      XBell(mydisplay,50);
      printf("validate %s here\n",value);
    }
  else if(type==24)
 {
      if(GoodFileName(value,4,0))
	{
	  sprintf(SaveLayerName,"%s",value); 	  
	}
    }
  else if(type==25)
    {
      if(GoodFileName(value,5,0))
	{
	  sprintf(SaveAOIShapeName,"%s",value);
	  SaveAOIShapes();
	}
    }
  else if(type==26)
    {
      printf("data folder %s\n",value);
    }
  else if(type==27)
    {
      sprintf(XML1name,"%s",value);
    }
  else if(type==28)
    {
      sprintf(XML2name,"%s",value);
    }
  else if(type==29)
    {
      sprintf(XML3name,"%s",value);
    }
  else if(type==30)
    {
      sprintf(dp1name,"%s",value);
    }
  else if(type==31)
    {
	  if(strcmp(value,"<not specified>"))
	  {
        sprintf(SpecialLoc,"%s",TestBrowseDir(w,value));

        if(USE_DOS==1)
		{ 
	      SpecialLoc[0] = timtoupper(SpecialLoc[0]); 
		} 

	    if(strcmp(SpecialLoc,"<not specified>"))
		{ 
	      len = strlen(SpecialLoc);
	      if(SpecialLoc[len-1]!=MYCHARSLASH)
		  {  
            strcat(SpecialLoc,MYSLASH);
		  } 
		} 
	  }

	  if(dead_browsefolderhead==0)
	  {
	    XtVaSetValues(browsefolder_wid,XmNvalue,SpecialLoc,NULL);
	  }

    }
  else if(type==32)
    {
      sprintf(dp2name,"%s",value);
    }
  else if(type==33)
  {
    if(GoodFileName(value,6,0))
	{
	  sprintf(SavePrefName,"%s",value);
	  RealSavePrefs(w);
	}
  }


  XtFree(value);
}



void importoutputhelpDialogCallback(Widget w,XtPointer data,XtPointer callData)
{
  if(NGA_TYPE==1)
    {
      not_while_running(w,"You may now specify a folder in which to look for\n\
data to import.",1181,"Input data folder selection help",5);
    }
  else
    {
      not_while_running(w,"You may now specify a location to store the\n\
extracted database.  As there will be numerous files, it\n\
is strongly suggested you choose an empty directory.",1182,"Output Import Directory",5);
    }
}


void SpecHelpCallback(Widget w,XtPointer data,XtPointer callData)
{
  not_while_running(w,"This window is used to define those SEDRIS objects to import or\n\
ignore.  Those objects selected will be imported, and those not\n\
selected will be ignored during the import process.",1183,"Import Rectangle help",5);
  
}



void RecHelpCallback(Widget w,XtPointer data,XtPointer callData)
{

  if(NGA_TYPE==1)
    {
      not_while_running(w,"This window is used to define an \"Import Rectangle\".  The rectangle is\n\
defined by 2 points, the lower left point and the upper right point of the\n\
rectangle.\n\n\
These points are expressed in decimal degrees in the range: (-180,-90)-(180,90).\n\n\
The lower left point must at all times be to the lower left\n\
of the upper right point.  Hit return in the text entry windows to test\n\
new values for acceptance.  Accepted values will remain, and rejected\n\
values will revert to the last acceptable value.\n\
Clicking \"Done/Accept Values\" also tests the values and reverts\n\
if bad input is entered.\n\n\
When an Import Rectangle is specified, AND the \"Import data from specified\n\
rectangle\" option is active, only the data \"in\" that rectangle will be\n\
imported during data import, where \"in\" means that the bounding rectangle\n\
of the object intersects or is inside the Import Rectangle.",1184,"Import Rectangle help",5);
    }
  else
    {
      not_while_running(w,"This window is used to define an \"Import Rectangle\".  The rectangle is\n\
defined by 2 points, the lower left point and the upper right point of the\n\
rectangle.  The lower left point must at all times be to the lower left\n\
of the upper right point.  Hit return in the text entry windows to test\n\
new values for acceptance.  Accepted values will remain, and rejected\n\
values will revert to the last acceptable value.\n\
Clicking \"Done/Accept Values\" also tests the values and reverts\n\
if bad input is entered.\n\n\
When an Import Rectangle is specified, AND the \"Import data from specified\n\
rectangle\" option is active, only the data \"in\" that rectangle will be\n\
imported during STF import, where \"in\" means that the bounding rectangle\n\
of the object intersects or is inside the Import Rectangle. \n\
(for GMIs, FMIs, and Grids, the single world transformation point is tested,\n\
and for point features, the single location of the point feature is tested)",1185,"Import Rectangle help",5);
    }
}



void ImportDestinationCallback(Widget w,XtPointer data,XtPointer callData)
{
  static Widget dialog,dialog2,dialog3;
  Widget rowcol,temp_w;
  Arg args[15];
  int n = 0;
  int type = (int)data;
  extern void SetAttrFolderCallback(Widget w, XtPointer userData, XmFileSelectionBoxCallbackStruct *data);
  
  if(running==1)
    {
      not_while_running(w,"You can not select a directory while\n\
the program is running",1186,"Illegal Manuever",1);   
      return;
    }
  
  
  if(type==0)
    {
      
      
      
      if(IMPORT_OUTPUT==1)
	{
	  
	  ResetWidget(dialog);
	  return;
	}
      
      
      
      n = 0;
      XtSetArg(args[n], XmNdeleteResponse, XmDESTROY);                   n++;
      

      dialog = XtCreatePopupShell("Directory Selection for Data/Extraction",topLevelShellWidgetClass,
                                  drawing_a,args,n);	  
      
      rowcol = XtVaCreateWidget ("rowcol",
				 xmRowColumnWidgetClass,  dialog, NULL);
      
      n = 0;
 
      XtSetArg(args[n], XmNtranslations, XtParseTranslationTable ( translations_global )); n++;
 
      temp_w = XmCreateFileSelectionBox (rowcol,"mymessagebox",args,n);
      
      XtAddCallback(temp_w, XmNokCallback,
		    (XtCallbackProc)importoutputfileDialogCallback,
		    (XtPointer)data);
      
      XtAddCallback(temp_w, XmNcancelCallback,
		    (XtCallbackProc)exitCallback,
		    (XtPointer)21);
      
      XtAddCallback(temp_w, XmNhelpCallback,
		    (XtCallbackProc)importoutputhelpDialogCallback,
		    (XtPointer)data);



      
      XtManageChild(temp_w);
      XtManageChild(rowcol);
      XtManageChild(dialog);
      
      XtAddCallback (dialog, XmNdestroyCallback,ShellDeath,(XtPointer)222);
      
      MyPopup (dialog);
      
            
      IMPORT_OUTPUT = 1;    
    }
  else if(type==1)
    {
      
      

      if(SHAPE_IMPORT_OUTPUT>0)
	{
	  

      set_cursor(XtDisplay(XtParent(XtParent(XtParent(w)))),
		  XtWindow(XtParent(XtParent(XtParent(w)))),WATCH);

	  if(SHAPE_IMPORT_OUTPUT==2)
	  {
  		
	    RefreshLocs();
	  }

	  ResetWidget(dialog2);
	  SHAPE_IMPORT_OUTPUT = 1;

      set_cursor(XtDisplay(XtParent(XtParent(XtParent(w)))),
		  XtWindow(XtParent(XtParent(XtParent(w)))),ARROW);

	  return;
	}

	  if((USE_DOS==1)&&(old_file_browser==0))
	  {
        dialog2 = DosBrowseCallback(w,(XtPointer)CHOOSESHAPE_BROWSE,(XtPointer)NULL);
		return;
	  }


      
      n = 0;
      XtSetArg(args[n], XmNdeleteResponse, XmDESTROY);                   n++;
     

      if(NGA_TYPE==1)
        {
	      if(USE_DOS==1)
		  {
	        dialog2 = XtCreatePopupShell("Input Data Folder Selection",topLevelShellWidgetClass,
					  drawing_a,args,n);
		  }
	  else
	    {
	      dialog2 = XtCreatePopupShell("Input Data Directory Selection",topLevelShellWidgetClass,
					  drawing_a,args,n);
	    }
 	}
      else
	{
	  dialog2 = XtCreatePopupShell("Directory Selection for Data/Extraction",topLevelShellWidgetClass,
				      drawing_a,args,n);	  
	}
      
      rowcol = XtVaCreateWidget ("rowcol",
				 xmRowColumnWidgetClass,  dialog2, NULL);
      
      n = 0;
      XtSetArg(args[n], XmNdirectory,    STRING(DATALOC));                                 n++;
      XtSetArg(args[n], XmNtranslations, XtParseTranslationTable ( translations_global )); n++;
     
      temp_w = XmCreateFileSelectionBox (rowcol,"mymessagebox",args,n);
      
      XtAddCallback(temp_w, XmNokCallback,
		    (XtCallbackProc)importoutput2fileDialogCallback,
		    (XtPointer)data);

      XtAddCallback(temp_w, XmNcancelCallback,
		    (XtCallbackProc)exitCallback,
		    (XtPointer)35);
      
      XtAddCallback(temp_w, XmNhelpCallback,
		    (XtCallbackProc)importoutputhelpDialogCallback,
		    (XtPointer)data);
      

      XtManageChild(temp_w);
      XtManageChild(rowcol);
      XtManageChild(dialog2);
      
      XtAddCallback (dialog2, XmNdestroyCallback,ShellDeath,(XtPointer)305);
      
      MyPopup (dialog2);
      
      SHAPE_IMPORT_OUTPUT = 1;    
    }
  else if(type==2)
    { 
      if(browse30_up>0)
	{
	  
	  
	  set_cursor(XtDisplay(XtParent(XtParent(XtParent(w)))),
		     XtWindow(XtParent(XtParent(XtParent(w)))),WATCH);
	  
	  if(browse30_up==2)
	    {
	      
	      RefreshLocs();
	    }
	  
	  ResetWidget(dialog3);
	  browse30_up = 1;
	  
	  set_cursor(XtDisplay(XtParent(XtParent(XtParent(w)))),
		     XtWindow(XtParent(XtParent(XtParent(w)))),ARROW);
	  
	  return;
	}
      
      if((USE_DOS==1)&&(old_file_browser==0))
	{
	  dialog3 = DosBrowseCallback(w,(XtPointer)ATTRFOLDER_BROWSE,(XtPointer)NULL);
	  return;
	}

      
      
      n = 0;
      XtSetArg(args[n], XmNdeleteResponse, XmDESTROY);                   n++;
      
      
      if(USE_DOS==1)
	{
	  dialog3 = XtCreatePopupShell("Folder Containing Attribution Files Selection",topLevelShellWidgetClass,
				       drawing_a,args,n);
	}
      else
	{
	  dialog3 = XtCreatePopupShell("Directory Containing Attribution Files Selection",topLevelShellWidgetClass,
				       drawing_a,args,n);
	}
      
      rowcol = XtVaCreateWidget ("rowcol",
				 xmRowColumnWidgetClass,  dialog3, NULL);
      
      n = 0;
      XtSetArg(args[n], XmNdirectory,    STRING(attrinsfolder));                           n++;
      XtSetArg(args[n], XmNtranslations, XtParseTranslationTable ( translations_global )); n++;
      XtSetArg(args[n], XmNpattern,      STRING("*.csv"));                                 n++;

      temp_w = XmCreateFileSelectionBox (rowcol,"mymessagebox",args,n);
      
      XtAddCallback(temp_w, XmNokCallback,
		    (XtCallbackProc)SetAttrFolderCallback,
		    (XtPointer)data);
      
      XtAddCallback(temp_w, XmNcancelCallback,
		    (XtCallbackProc)exitCallback,
		    (XtPointer)54);
      
      XtAddCallback(temp_w, XmNhelpCallback,
		    (XtCallbackProc)importoutputhelpDialogCallback,
		    (XtPointer)data);
      
      
      XtManageChild(temp_w);
      XtManageChild(rowcol);
      XtManageChild(dialog3);
      
      XtAddCallback (dialog3, XmNdestroyCallback,ShellDeath,(XtPointer)4091);
      
      MyPopup (dialog3);
      
      browse30_up = 1;    

    }


  
  XtSetSensitive(XmFileSelectionBoxGetChild (temp_w, XmDIALOG_LIST_LABEL),False);
  XtSetSensitive(XmFileSelectionBoxGetChild (temp_w, XmDIALOG_LIST)      ,False);



  XtVaSetValues(XmFileSelectionBoxGetChild (temp_w, XmDIALOG_DIR_LIST),
        XmNtranslations, XtParseTranslationTable (list_translations12),NULL);

  XtVaGetValues(XtParent(XmFileSelectionBoxGetChild (temp_w, XmDIALOG_DIR_LIST)),
                 XmNverticalScrollBar,&vert_scroll[FILE1_SCROLL ] ,NULL);

}



void SpecifyObjectsCallback(Widget w,XtPointer data,XtPointer callData)
{
  int n=0,i;
  Arg resources[15];
  Widget form,rowcol,button,toggle_wid;
  static Widget spec_head; 
  Dimension Pheight;

 
  char *OBTYPE[NUM_OBS]={
    "Polygon",
    "Linear Feature",
    "Areal Feature",
    "Point Feature",
    "Point Model",
    "Grid",
    "Collision Volume (S)",
    "Collision Volume (P)",
    "Model Library Polygon",
    "Feature Model Point Feature",
    "Feature Model Linear Feature",
    "Feature Model Areal Feature"
  };
  

  if(SPEC_WIN==0)
    {
      n=0;
      XtSetArg(resources[n],  XmNdeleteResponse, XmDESTROY); n++;
      XtSetArg(resources[n], XmNmaxWidth,            800);   n++;

      spec_head =
	XtCreatePopupShell
	("Specify Objects",topLevelShellWidgetClass,drawing_a,resources,n);
      
      rowcol = XtVaCreateWidget ("rowcol",
				 xmRowColumnWidgetClass, spec_head, NULL);
      

      
      for(i=0;i<NUM_OBS;i++)
	{	  
	  form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
				   XmNfractionBase,  100,
				   NULL);
	  
	  toggle_wid = XtVaCreateManagedWidget (OBTYPE[i],
						xmToggleButtonWidgetClass, form,
						XmNtopAttachment,          XmATTACH_FORM,
						XmNtraversalOn,            False,
						XmNbottomAttachment,       XmATTACH_FORM,
						XmNleftAttachment,         XmATTACH_WIDGET,
						XmNlabelString,            STRING(OBTYPE[i]),
						TOGGLETRANSLATE,     TOGGLEINCLUDE,
						NULL);
	  XtAddCallback (toggle_wid, XmNvalueChangedCallback,Iinvert, (XtPointer)(i+100));
	  XmToggleButtonSetState(toggle_wid,(Boolean)DO_OBS[i],(Boolean)0);

	  
	  XtManageChild(form);      
	}



      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,  
			       NULL);
      
      
      button = XtVaCreateManagedWidget ("Help",
					xmPushButtonWidgetClass, form,
					XmNtopAttachment,    XmATTACH_FORM,
					XmNtraversalOn,      False,
					XmNbottomAttachment, XmATTACH_FORM,
					XmNrightAttachment,  XmATTACH_POSITION,
					XmNrightPosition,    49,
					XmNleftAttachment,   XmATTACH_POSITION,
					XmNleftPosition,     1,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					NULL);
      
      XtAddCallback(button, XmNactivateCallback, SpecHelpCallback, (XtPointer)NULL);
      XtManageChild(button);


      button = XtVaCreateManagedWidget ("Done",
					xmPushButtonWidgetClass, form,
					XmNtopAttachment,    XmATTACH_FORM,
					XmNtraversalOn,      False,
					XmNbottomAttachment, XmATTACH_FORM,
					XmNrightAttachment,  XmATTACH_POSITION,
					XmNrightPosition,    99,
					XmNleftAttachment,   XmATTACH_POSITION,
					XmNleftPosition,     51,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					NULL);
      
      XtAddCallback(button, XmNactivateCallback, exitCallback, (XtPointer)27);
      XtManageChild(button);
      XtManageChild(form);

      XtManageChild (rowcol);
      MyPopup(spec_head); 
      XtAddCallback(spec_head,XmNdestroyCallback,ShellDeath,(XtPointer)291);

      
      XtVaGetValues(spec_head,  XmNheight,     &Pheight, NULL);
      XtVaSetValues(spec_head,  XmNminHeight,   Pheight, NULL);
      XtVaSetValues(spec_head,  XmNmaxHeight,   Pheight, NULL);

      XtAddEventHandler(spec_head,StructureNotifyMask,False, myResizeHandler, (XtPointer)((int)Pheight));

      SPEC_WIN=1;
    }
  else
    {
      ResetWidget(spec_head);
    }

}



void RectangleCallback(Widget w,XtPointer data,XtPointer callData)
{
  int n=0;
  Arg resources[15];
  Widget form,rowcol,button;
  static Widget rect_head; 
  char obs_str[50];
  Dimension Pheight;
  

  if(REC_WIN==0)
    {
      n=0;
      XtSetArg(resources[n],  XmNdeleteResponse, XmDESTROY); n++;

      rect_head =
	XtCreatePopupShell
	("Import Rectangle Specification",
	 topLevelShellWidgetClass,drawing_a,resources,n);
      
      rowcol = XtVaCreateWidget ("rowcol",
				 xmRowColumnWidgetClass, rect_head, NULL);
      
      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,  
			       NULL);
      
      sprintf(obs_str,"%.3lf",CLIPLLX);

      text_llx = XtVaCreateManagedWidget ("text_llx",
					  xmTextFieldWidgetClass, form,	  
					  XmNvalue,            obs_str,
					  XmNtraversalOn,      True,
					  XmNrightAttachment,  XmATTACH_POSITION,
					  XmNrightPosition,    99,
					  XmNleftAttachment,   XmATTACH_POSITION,
					  XmNleftPosition,     75,
					  XmNmaxLength,        12,
                      XmNtranslations,     XtParseTranslationTable ( translations_paste ) ,
					  NULL);
      
      button = XtVaCreateManagedWidget ("OH",
					xmLabelWidgetClass, form,
					XmNtopAttachment,    XmATTACH_FORM,
					XmNtraversalOn,      False,
					XmNbottomAttachment, XmATTACH_FORM,
					XmNrightAttachment,  XmATTACH_POSITION,
					XmNrightPosition,    75,
					XmNleftAttachment,   XmATTACH_POSITION,
					XmNleftPosition,     1,
					XmNlabelString,      STRING("Lower left x-coordinate of rectangle to import"),
					LABELWTRANSLATE,
					NULL);
      
      XtAddCallback (text_llx, XmNactivateCallback,
		     los_result, (XtPointer)5);
      
      
      XtManageChild(form);
      






      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,  
			       NULL);
      
      sprintf(obs_str,"%.3lf",CLIPLLY);

      text_lly = XtVaCreateManagedWidget ("text_lly",
					  xmTextFieldWidgetClass, form,	  
					  XmNvalue,            obs_str,
					  XmNtraversalOn,      True,
					  XmNrightAttachment,  XmATTACH_POSITION,
					  XmNrightPosition,    99,
					  XmNleftAttachment,   XmATTACH_POSITION,
					  XmNleftPosition,     75,
					  XmNmaxLength,        12,
                      XmNtranslations,     XtParseTranslationTable ( translations_paste ) ,
					  NULL);
      
      button = XtVaCreateManagedWidget ("TH",
					xmLabelWidgetClass, form,
					XmNtopAttachment,    XmATTACH_FORM,
					XmNtraversalOn,      False,
					XmNbottomAttachment, XmATTACH_FORM,
					XmNrightAttachment,  XmATTACH_POSITION,
					XmNrightPosition,    75,
					XmNleftAttachment,   XmATTACH_POSITION,
					XmNleftPosition,     1,
					XmNlabelString,      STRING("Lower left y-coordinate of rectangle to import"),
					LABELWTRANSLATE,
					NULL);

      XtAddCallback (text_lly, XmNactivateCallback,
		     los_result, (XtPointer)6);
      
      XtManageChild(form);
            







      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,  
			       NULL);
      
      sprintf(obs_str,"%.3lf",CLIPURX);

      text_urx = XtVaCreateManagedWidget ("text_urx",
					    xmTextFieldWidgetClass, form,	  
					    XmNvalue,            obs_str,
					    XmNtraversalOn,      True,
					    XmNrightAttachment,  XmATTACH_POSITION,
					    XmNrightPosition,    99,
					    XmNleftAttachment,   XmATTACH_POSITION,
					    XmNleftPosition,     75,
					    XmNmaxLength,        12,
                        XmNtranslations,     XtParseTranslationTable ( translations_paste ) ,
					    NULL);
      
      button = XtVaCreateManagedWidget ("LOSFA",
					xmLabelWidgetClass, form,
					XmNtopAttachment,    XmATTACH_FORM,
					XmNtraversalOn,      False,
					XmNbottomAttachment, XmATTACH_FORM,
					XmNrightAttachment,  XmATTACH_POSITION,
					XmNrightPosition,    75,
					XmNleftAttachment,   XmATTACH_POSITION,
					XmNleftPosition,     1,
					XmNlabelString,      STRING("Upper right x-coordinate of rectangle to import"),
					LABELWTRANSLATE,
					NULL);
      XtAddCallback (text_urx, XmNactivateCallback,
		     los_result, (XtPointer)7);
      XtManageChild(form);






            
      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,  
			       NULL);
      
      sprintf(obs_str,"%.3lf",CLIPURY);
      text_ury = XtVaCreateManagedWidget ("text_ury",
					      xmTextFieldWidgetClass, form,	  
					      XmNvalue,            obs_str,
					      XmNtraversalOn,      True,
					      XmNrightAttachment,  XmATTACH_POSITION,
					      XmNrightPosition,    99,
					      XmNleftAttachment,   XmATTACH_POSITION,
					      XmNleftPosition,     75,
					      XmNmaxLength,        12,
                          XmNtranslations,     XtParseTranslationTable ( translations_paste ) ,
					      NULL);
      
      button = XtVaCreateManagedWidget ("LOSFG",
					xmLabelWidgetClass, form,
					XmNtopAttachment,    XmATTACH_FORM,
					XmNtraversalOn,      False,
					XmNbottomAttachment, XmATTACH_FORM,
					XmNrightAttachment,  XmATTACH_POSITION,
					XmNrightPosition,    75,
					XmNleftAttachment,   XmATTACH_POSITION,
					XmNleftPosition,     1,
					XmNlabelString,      STRING("Upper right y-coordinate of rectangle to import"),
					LABELWTRANSLATE,
					NULL);
      XtAddCallback (text_ury, XmNactivateCallback,
		     los_result, (XtPointer)8);
      XtManageChild(form);
            




      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,  
			       NULL);
      

      button = XtVaCreateManagedWidget ("Done/Accept Values",
					xmPushButtonWidgetClass, form,
					XmNtopAttachment,    XmATTACH_FORM,
					XmNtraversalOn,      False,
					XmNbottomAttachment, XmATTACH_FORM,
					XmNrightAttachment,  XmATTACH_POSITION,
					XmNrightPosition,    99,
					XmNleftAttachment,   XmATTACH_POSITION,
					XmNleftPosition,     51,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					NULL);
      
      XtAddCallback(button, XmNactivateCallback, exitCallback, (XtPointer)6);
      XtManageChild(button);

      
      
      button = XtVaCreateManagedWidget ("Help",
					xmPushButtonWidgetClass, form,
					XmNtopAttachment,    XmATTACH_FORM,
					XmNtraversalOn,      False,
					XmNbottomAttachment, XmATTACH_FORM,
					XmNrightAttachment,  XmATTACH_POSITION,
					XmNrightPosition,    50,
					XmNleftAttachment,   XmATTACH_POSITION,
					XmNleftPosition,     1,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					NULL);
      
      XtAddCallback(button, XmNactivateCallback, RecHelpCallback, (XtPointer)NULL);
      XtManageChild(button);
      XtManageChild(form);


      XtManageChild (rowcol);
      MyPopup(rect_head); 
      XtAddCallback(rect_head,XmNdestroyCallback,ShellDeath,(XtPointer)288);

      
      XtVaGetValues(rect_head,  XmNheight,     &Pheight, NULL);
      XtVaSetValues(rect_head,  XmNminHeight,   Pheight, NULL);
      XtVaSetValues(rect_head,  XmNmaxHeight,   Pheight, NULL);

      XtAddEventHandler(rect_head,StructureNotifyMask,False, myResizeHandler, (XtPointer)((int)Pheight));

      REC_WIN=1;
    }
  else
    {
      ResetWidget(rect_head);
    }
}



void ImportHelpCallback(Widget w,XtPointer data,XtPointer callData)
{
  int choice=(int)data;

  if(choice==0)
    {
      if(NGA_TYPE==1)
	{
	  if(USE_DOS==1)
	    {
	not_while_running(w,"This window is used to create GAIT projects (import data).\n\n\
To import data, you must specify a Project name, and a location containing\n\
importable data (Shapefiles, DTED, Geodatabase, etc).\n\n\
This folder location must contain the data to import.  In the case of a file\n\
geodatabase, the file geodatabase is the data to import, so the folder which\n\
contains the file geodatabase must be chosen, just as with any other data format.\n\n\
GAIT will create a folder in the \"projects\" folder with the same name\n\
as the Project name you enter.  In this location, GAIT will also create\n\
the file \"InputSpecFile.txt\".  This file, the Input Specification File,\n\
contains specifications for what data should be imported to\n\
create the GAIT project.  The format of the Input Specification File is\n\
described in the GAIT user's guide.  It can be modified by hand if GAIT is\n\
unable to create it automatically.\n\n\
To create the  Input Specification File, specify the the folder\n\
containing the data files you wish to add to this file.\n\
Then, select \"Build Input Specification file\".\n\
This instructs GAIT to search the selected data folder for importable\n\
data formats and add them to the InputSpecFile.txt file.\n\n\
After a valid Input Specification File is created, it can be used to import\n\
the data it specifies by selecting:\n\
     \"Create GAIT project using Input Specification file\"\n\n\
This will begin the import process.\n\n\
There are several additional options that may be exercised.\n\
See their individual help buttons for descriptions.",1188,"Import Info",5);
	    }
	  else
	    {
	not_while_running(w,"This window is used to create GAIT projects (import data).\n\n\
To import data, you must specify a Project name, and a location containing\n\
importable data (Shapefiles, DTED, Geodatabase, etc).\n\n\
GAIT will create a directory in the \"projects\" directory with the same name\n\
as the Project name you enter.  In this location, GAIT will also create\n\
the file \"InputSpecFile.txt\".  This file, the Input Specification File,\n\
contains specifications for what data should be imported to\n\
create the GAIT project.  The format of the Input Specification File is\n\
described in the GAIT user's guide.  It can be modified by hand if GAIT is\n\
unable to create it automatically.\n\n\
To create the  Input Specification File, specify the the directory\n\
containing the data files you wish to add to this file.\n\
Then, select \"Build Input Specification file\".\n\
This instructs GAIT to search the selected data directory for importable\n\
data formats and add them to the InputSpecFile.txt file.\n\n\
After a valid Input Specification File is created, it can be used to import\n\
the data it specifies by selecting:\n\
     \"Create GAIT project using Input Specification file\"\n\n\
This will begin the import process.\n\n\
There are several additional options that may be exercised.\n\
See their individual help buttons for descriptions.",1188,"Import Info",5);
	    }	      
	}
      else
	{
	  not_while_running(w,"This window is used to import STF data.\n\n\
To import a single stf, you must specify the root stf using the\n\
\"Input Source\" button, AND select a directory location to store the\n\
imported database, THEN click the \"Imported Selected Data\" button.\n\n\
To import a collection of stfs, you must specify a text file with the\n\
\"Input Source\" button, which contains the full pathnames to each stf you\n\
wish to extract (1 per line).  These stfs will comprise 1 SEE-IT database\n\
after import.  You must also select a directory location to store the\n\
imported database, then click the \"Imported Selected Data\" button.\n\n\
To use imported databases with the SEE-IT tool, they must ALSO be\n\
formatted.  Formatting is done automatically after import.",1190,"Import Info",5);
	}
    }
  else if(choice==1)
    {
      not_while_running(w,"The \"Transpose World 3x3 Matricies\" option is used to transpose World 3x3\n\
matricies encountered during extraction of an STF.  At the date of this\n\
release, some STF producers are creating matricies that should be transposed,\n\
and others are producing matricies that should not be transposed.  In most cases\n\
we have seen, they should be transposed.  However, the official word about the\n\
correct way to produce an STF is that the matrix should not have to be transposed\n\
in order to get the proper result.  Therefore, at some point in the future, when\n\
producers are producing STFs like this, this option will be removed.",1191,"Transpose help",5);
    }
  else if(choice==2)
    {
      not_while_running(w,"The \"Create Footprint Models from point features with attribution\" option\n\
is used to instruct SEE-IT to create footprint models when it encounters\n\
point features with the following attributes:\n\
   Length (EAC_LENGTH)\n\
   Width (EAC_WIDTH)\n\
   Height (EAC_HEIGHT_ABOVE_SURFACE_LEVEL)\n\
   Angle (EAC_ORIENTATION_ANGLE)\n\
If ALL 4 of these attributes are found, SEE-IT will build a parallelepiped\n\
footprint model using these attributes.",1192,"Create footprints help",5);
    }
  else if(choice==3)
    {
      not_while_running(w,"The \"Directly attach components\" option is used to instruct SEE-IT to\n\
use the SEDRIS flag \"directly_attach_table_components\" when extracting\n\
STF data.  This will result in, attribute set (and other) data being used.\n\
This option will cause processing times to become significantly greater,\n\
due to the way the SEDRIS API currently functions.  Processing times may\n\
skyrocket if large location tables are present and this option is on.",1193,
			"Directly attach components help",5);
    }
  else if(choice==4)
    {
      not_while_running(w,"The \"Use model library polygons\" option is used to instruct SEE-IT to treat\n\
each polygon found in a model as a \"Model Library Polygon\" configuration\n\
object.  Therefore, if a model is composed of 20 polygons, SEE-IT will display\n\
all 20 of the polygons.",1194,"Use model polys help",5);
    }
  else if(choice==5)
    {
      not_while_running(w,"The \"Create model summary file\" option is used to create a text file in the\n\
destination directory called \"modelsummary.txt\". This file lists some information\n\
about the models SEE-IT encountered in the model library.  There is one line\n\
in this file for each model found in the model library.  Each line has the format:\n\
<model id number> <model name> <model x extent> <model y extent> <model z extent>\n\n\
",1195,"Model summary file help",5);
    }
  else if(choice==6)
    {
      not_while_running(w,"The \"Ignore revisited objects\" option is used to instruct SEE-IT NOT to re-extract\n\
objects from an STF more than 1 time.  If this option is not selected, SEE-IT will\n\
extract each object 1 time for each unique path leading to it from the environment\n\
root.  Typically, there is only 1 such path, so this option is not necessary.\n\
However, if many paths exist to an object, it will be extracted many times if\n\
this option is not selected.\n\n\
This option will result in greater memory consumption.",1196,"Ignore revisited objects",5);
 
    }
  else if(choice==7)
    {
      not_while_running(w,"The \"Color toplevel map objects\" option is used to instruct SEE-IT\n\
to color the outlines of certain areal features and polygons when\n\
creating the top level shaded relief during the format operation.\n\n\
If selected, areal features and polygons of the following domains\n\
will be outlined in the following colors on the toplevel shaded relief:\n\n\
Inland Water or Open Water:  blue\n\
Land Mobility             :  yellow\n\
Vegetation                :  light green\n\
Boundary                  :  dark green\n\n\
The \"Color as lines\" option is used to instruct SEE-IT to draw the\n\
raw outlines of each areal feature in the colors above.  (and not to try\n\
to combine adjacent areals).",1197,"Color toplevel map objects",5);

    }
  else if(choice==8)
    {
      not_while_running(w,"The \"Import Feature Models\" option is used to instruct SEE-IT to process\n\
any Feature Model Instances (by instancing the appropriate Feature Models).",1198,
"Import Feature Models",5);
    }
  else if(choice==9)
    {
      not_while_running(w,"The \"Import All Damaged States of Models\" option is used to instruct SEE-IT\n\
to process all states of \"State Related\" objects.  If a model (ie, a building)\n\
includes different representations for its damaged states, use of this option\n\
will result in all of those representations being extracted.\n\n\
If this option is not selected, only un-damaged representations will be used.",1199,
"Import All Damaged States of Models",5);
    }
  else if(choice==10)
    {
      if(NGA_TYPE==1)
	{
      not_while_running(w,"The \"Import data from specified rectangle\" option is used to instruct GAIT\n\
to extract only the data from input files which is \"in\" the specified rectangle\n\
of interest, where \"in\" means that the bounding rectangle of the object\n\
intersects or is inside the specified rectangle.",1200,"Import data from specified rectangle",5);
	}
      else
	{
      not_while_running(w,"The \"Import data from specified rectangle\" option is used to instruct SEE-IT\n\
to extract only the data from the STF(s) which is \"in\" the specified rectangle\n\
of interest, where \"in\" means that the bounding rectangle of the object\n\
intersects or is inside the specified rectangle. (for GMIs, FMIs, and Grids, the\n\
single world transformation point is tested, and for point features, the single\n\
location of the point feature is tested)",1201,"Import data from specified rectangle",5);
	}
    }
  else if(choice==11)
    {
      not_while_running(w,"The \"Create Stamp Models from point features with attribution\" option\n\
is used to instruct SEE-IT to create stamp models when it encounters\n\
point features with the following attributes:\n\
             Length (EAC_LENGTH)\n\
If this attribute is found, SEE-IT will build a circular stamp\n\
model using it's value.  If height (HGT_) is found, SEE-IT will\n\
use it as well.  Otherwise, the height of the stamp will be assigned 0.\n",
1202,"Create stamps help",5);
    }
  else if(choice==12)
    {
      not_while_running(w,"The \"Use Memory-Conserving Format Operation\" option\n\
is used to instruct SEE-IT to use a slower, but much\n\
less memory-intensive algorithm when creating a SEE-IT database.\n\n\
This option is useful when formatting very large databases, because\n\
the memory-intensive (faster) algorithm may consume more memory\n\
than your machine has.\n",1203,"Use Memory-Conserving Format Operation help",5);
    }
  else if(choice==13)
    {
      not_while_running(w,"The \"USE GMI/FMI object IDs for ModelLib Objects\" option\n\
is used to instruct SEE-IT to use the object IDs of FMIs and GMIs\n\
for objects in the model library (feature model areal features,\n\
feature model linear features, feature model point features,\n\
model library polygons, and bounding volumes).  This option will\n\
result in more memory usage during import.",1204,"USE GMI/FMI object IDs for ModelLib Objects help",5);
    }


 

 else if(choice==15)
    {
      if(NGA_TYPE==1)
	{
	  not_while_running(w,"The \"Do metadata checking\" option\n\
is used to instruct GAIT to perform special metadata-only\n\
attribution checks.  This is done when a project is created.",
			    1207,"Do metadata checking help",5);

	}
    }
 else if(choice==16)
    {
      if(NGA_TYPE==1)
	{
	  not_while_running(w,"The \"Append to Input Specification file if it exists already\" option\n\
is used to give GAIT special instructions when the \"Build Input Specification file\"\n\
button is pressed.\n\n\
Usually, GAIT will then create a new file called \"InputSpecFile.txt\"\n\
in the selected GAIT project folder, even if the file already exists.\n\n\
This option instructs GAIT to not overwrite an existing\n\
InputSpecFile.txt file, but add to it the new specifications.\n\
\n\n\
This option is useful when one wishes to create an Input Specification file\n\
from multiple sources (ie, one folder tree may contain Shapefiles, and\n\
another tree may contain DTED).  In this case, one could create an Input\n\
Specification file from the Shapefiles, then re-set the Input Data folder\n\
to the DTED folder, then click this \"Append\" option, then\n\
select the \"Build Input Specification file\" option again, appending the DTED\n\
specifications to the SHAPE specifications.",
			    1208,"Append to Input Specification file help",5);
	  
	}
    }
  else if(choice==17)
    {
      if(NGA_TYPE==1)
	{
	  not_while_running(w,"The \"Do attribution checking\" option\n\
is used to instruct GAIT to perform attribution inspections.\n\
This is done when a project is created.",
			    1209,"Do attribution checking help",5);
	  
	}
    }
  else if(choice==19)
    {
      if(NGA_TYPE==1)
	{
	  not_while_running(w,"The \"Do inspections after creating project using:\" option\n\
is used to instruct GAIT to perform inspections immediately\n\
after creating a project.  The user must choose which Master\n\
Profile they wish to use, and the entire database is inspected.\n\n\
This is a shortcut to the usual process:\n\
  1) Create GAIT project\n\
  2) Load appropriate Master Profile\n\
  3) Begin inspections\n\n\
If FCODE errors are encountered during data import, GAIT will NOT\n\
perform the inspections.  This is because FCODE errors have a major\n\
and undesirable impact on inspections, and should therefore be\n\
repaired before performing inspections.\n",
			    1394,"Do inspections after creating project using:",5);	 
	}
    }
  else if(choice==20)
    {
      if(NGA_TYPE==1)
	{
	  not_while_running(w,"The \"Metadata mapping file:\" is used only\n\
when \"User-Defined\" is selected as the \"Metadata naming convention\".\n\n\
It is used to specify a file that defines a user's own set of metadata\n\
field name mappings.\n\n\
This file is a simple text format file, with one entry per line,\n\
with each entry being of the form <Metadata Attribute> <Abbreviated Name>\n\n\
Example:\n\n\
ACE_EVAL_METHOD_CD ACEEVAL\n\
ALE_EVAL_METHOD_CD ALEEVAL\n\n\
If the above 2 lines were in the file specified, then the field name\n\
\"ACEEVAL\" would be interpreted as mapping to \"ACE_EVAL_METHOD_CD\"\n\
and \"ALEEVAL\" would be interpreted as mapping to \"ALE_EVAL_METHOD_CD\".\n\n\
Three example files are distributed with GAIT in the \"MetadataMappingFiles\"\n\
folder:     NGAMeta.txt, ESRIMeta.txt, and INGRMeta.txt\n\
These files contain the mappings GAIT uses for the \"MGCP/NGA\", \"ESRI\", and\n\
\"Intergraph\" mappings, respectively.  They can be used as templates\n\
for making custom mapping files.",
			    1395,"Metadata mapping file",5);
	}
    }
  else if(choice==21)
    {
      not_while_running(w,"The \"Use Environment Root #\" option is used\n\
to specify which Environment Root to process in an STF.  If an STF\n\
contains more than 1 Environment Root, SEE-IT will only create a SEE-IT\n\
database out of one of them.  This option allows the user to specify\n\
which one to use.",1407,"\"Use Environment Root #\" help",5);
    }
  else if(choice==22)
    {
      not_while_running(w,"The \"Specify format granularity\" option is used\n\
to specify the density to create GAIT regions during formatting.  Datasets which have\n\
extreme non-uniformity may have better inspection results using the High or Maximum setting.",
1500,"\"Specify format granularity\" help",5);
    }
  else if(choice==23)
    {
      not_while_running(w,"\
The \"Additional Attribution Inspections for NFDD/DFDD\" option is used\n\
when using the NFDD or DFDD attribution schemas.  It is used to specify\n\
what type of additional (relationship-based) attribution analyses should\n\
be performed during GAIT project creation:\n\n\
  \"None\":\n\
       Perform no additional relationship-based attribution analyses\n\
  \"NAS-based\":\n\
       Perform built-in NAS-based additional relationship-based attribution analyses\n\
  \"User-Specified with Valid Values\":\n\
       Perform user-specified additional relationship-based attribution analyses\nwith valid values inspections\n\
       (See \"Folder with attribution files\" help)\n\n",1528,"\"Additional Attribution Inspections for NFDD/DFDD\" help",5);
    }
  else if(choice==24)
    {
      not_while_running(w,"\
The \"Folder with attribution files\" option may be used with the NFDD or DFDD\n\
attribution schemas to specify a *folder* containing attribution specification files.\n\n\
The files in this folder may be used when doing additional relationship-based\n\
attribution analyses during GAIT project creation for these attribution schemas.\n\n\
These files must be named \"NFDD.csv\" and \"NFDD_domains.csv\" for NFDD, and\n\
\"DFDD.csv\" and \"DFDD_domains.csv\" for DFDD.  These files must comply with a\n\
specific documented format, and can only be used with the NFDD or DFDD attribution\n\
schemas, and only when using the \"User-Specified\" option under the\n\
\"Additional Attribution Inspections for NFDD/DFDD\" menu.",1529,"\"Folder with attribution files\" help",5);
    }
  else if(choice==25)
    {
      not_while_running(w,"\
The \"Allow Additional NUNANPO Values\" option\n\
may be used with some attribution schemas to specify that additional NUNANPO\n\
values may be used pick-liststhat do not include these values in the schema\n\
specification.\n\n\
This option is not available for attribution schema that forbid these values.\n\n\
NUNANPO values are listed in the \"NUNANPO.PDF\" file in the \"docs\" folde\n\
in the GAIT folder.",1537,"\"Allow Additional NUNANPO Values\" help",5);
    }
  else if(choice==26)
    {
      not_while_running(w,"\
The \"Ignore Feature Z Values\" option\n\
may be used to prevent GAIT from importing Z-coordinates from feature data.\n\n\
This option may be useful when attempting to perform strictly 2D analyses.",1635,"\"Ignore Feature Z Values\" help",5);
    }
}






void Iinvert(Widget w,XtPointer data,XtPointer callData)
{
  int choice = (int)data;
  extern int DO_FMIS;
  extern int DO_DAMAGED_MODELS;
  #if(NGA_TYPE==0)
  extern void toggle_attach();
  #endif
  extern int ConserveMemory;
  extern int GMI_ASSIGN_ID;
  extern int DoDev;
  extern int NoZ_Values;


  if(choice==0)
    {
      INVERT_3x3 = !INVERT_3x3;
    }
  else if(choice==1)
    {
      #if(NGA_TYPE==0)
      toggle_attach();
      #endif
    }
  else if(choice==2)
    {
      DOMODELPOLYS = !DOMODELPOLYS;
    }
  else if(choice==3)
    {
      GROW_MODELS = !GROW_MODELS;
    }
  else if(choice==4)
    {
      DOMODELSUMMARY = !DOMODELSUMMARY;
    }
  else if(choice==5)
    {
      DOTHEDUPES = !DOTHEDUPES;
    }
  else if(choice==6)
    {
    }
  else if(choice==7)
    {
      DO_FMIS = !DO_FMIS;
    }
  else if(choice==8)
    {
      DO_DAMAGED_MODELS = !DO_DAMAGED_MODELS;
    }
  else if(choice==9)
    {
      CLIPEXTRACT = !CLIPEXTRACT;
    }
  else if(choice==10)
    {
      DO_LINES = !DO_LINES;
    }
  else if(choice==11)
    {
      GROW_STAMPS = !GROW_STAMPS;
    }
  else if(choice==12)
    {
      ConserveMemory = !ConserveMemory;
    }
  else if(choice==13)
    {
      GMI_ASSIGN_ID = !GMI_ASSIGN_ID;
    }
  else if(choice==15)
    {
      DoMetadataChecking = !DoMetadataChecking;
    }
  else if(choice==16)
    {
      AppendInputSpec = !AppendInputSpec;
    }
  else if(choice==17)
    {
      DoAttrChecking = !DoAttrChecking;
    }
  else if(choice==18)
    {
      DoShort = !DoShort;
    }
  else if(choice==19)
    {
      DoDev = !DoDev;
    }
  else if(choice==20)
    {
      BIN_ATTR_TYPE = !BIN_ATTR_TYPE;
    }
  else if(choice==21)
    {
      NUNANPO_TYPE = !NUNANPO_TYPE;
    }
  else if(choice==22)
    {
      NoZ_Values = !NoZ_Values;
    }
  else if((choice>=100)&&(choice<=(100+NUM_OBS)))
    {
      DO_OBS[choice-100] = !DO_OBS[choice-100];
    }
  else
    {
      printf("Iinvert got bad flag %d\n",choice);
    }
}





void ImportSEEITButtonCallback(Widget w,XtPointer data,XtPointer callData)
{

  #if(NGA_TYPE==0)

  Widget rowcol,form,button,text_w,type_menu,DUPE_WID,button2,
    INVERT_WID,MODEL_POLY_WID,GROW_WID,model_sum_wid,buttonA;
  Arg args[15];
  int n = 0;
  char temp[1000];
  extern int DO_FMIS;
  extern int DO_DAMAGED_MODELS;
  extern int get_attach();
  extern int ConserveMemory;
  extern int GMI_ASSIGN_ID;

  
  MenuItem terrain_type[] = {
    {"STF (SEDRIS Transmittal File)",&xmPushButtonWidgetClass,(char)NULL, NULL, NULL, (void (*)())type_cb, 
     (XtPointer)0, (MenuItem *) NULL},
    {"STF collection",               &xmPushButtonWidgetClass,(char)NULL, NULL, NULL, (void (*)())type_cb, 
     (XtPointer)1, (MenuItem *) NULL},
    
    NULL,
  };


  
  if(IMPORT_WIN==0)
    {
      ABORT_EXTRACT = 0;
      
      GetImportShell() = XtCreatePopupShell("Import STF Data",
				       topLevelShellWidgetClass,drawing_a,args,n);



      rowcol = XtVaCreateWidget ("rowcol",
				 xmRowColumnWidgetClass, GetImportShell(), NULL);
      
      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,
			       NULL);
      
      text_w = XtVaCreateManagedWidget ("Import STF Data",
					xmLabelWidgetClass, form,
					XmNtraversalOn,      True,
					XmNrightAttachment,  XmATTACH_POSITION,
					XmNrightPosition,  99,
					XmNleftAttachment,   XmATTACH_POSITION,
					XmNleftPosition,     1,
					LABELWTRANSLATE,
					NULL);      
	
      XtManageChild(form);
      
      
      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,
			       NULL);
      

      TYPE = 0; 
      
      type_menu = BuildMenu (form, XmMENU_OPTION, "Input Type:", terrain_type);
	


      XtManageChild (type_menu);
      XtManageChild(form);
      

      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,
			       NULL);
      
      text_w = XtVaCreateManagedWidget ("Input Source:",
					xmLabelWidgetClass, form,
					LABELWTRANSLATE,
					NULL);

      XtManageChild(form);


      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,
			       NULL);
      
      if(import_source==0)
	{
	  terrain_to_import = XtVaCreateManagedWidget ("<none selected>                                        ",
						       xmLabelWidgetClass, form,
						       LABELWTRANSLATE,
						       NULL);
	}
      else if(import_source==1)
	{
	  terrain_to_import = XtVaCreateManagedWidget (importdirectory,
						       xmLabelWidgetClass, form,
						       LABELWTRANSLATE,
						       NULL); 
	}
      else
	{
	  printf("bad value %d for input_source!\n",input_source);
	  ExitWrapper(-1);
	}
      XtManageChild(form);




      
      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,
			       NULL);
      text_w = XtVaCreateManagedWidget ("Directory to store imported database, look for previously imported",
					xmLabelWidgetClass, form,
					LABELWTRANSLATE,
					NULL);
      XtManageChild(form);
      


      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,
			       NULL);
      
      text_w = XtVaCreateManagedWidget ("database to format:",
					xmLabelWidgetClass, form,
					LABELWTRANSLATE,
					NULL);


      XtManageChild(form);



      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,
			       NULL);
      
      if(import_output_source==0)
	{
	  terrain_output_import = XtVaCreateManagedWidget ("   <none selected>                                        ",
							   xmLabelWidgetClass, form,
							   LABELWTRANSLATE,
							   NULL);
	}
      else if(import_output_source==1)
	{
	  terrain_output_import = XtVaCreateManagedWidget (importoutputdir,
							   xmLabelWidgetClass, form,
							   LABELWTRANSLATE,
							   NULL); 
	}
      else
	{
	  printf("bad value %d for import_output_source!\n",input_source);
	  ExitWrapper(-1);
	}
      XtManageChild(form);



      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,
			       NULL);
      
      button = XtVaCreateManagedWidget ("Help",xmPushButtonWidgetClass,form,
					XmNlabelString,        STRING("Help"),
					XmNtraversalOn,                 False,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					NULL);
      XtAddCallback(button, XmNactivateCallback, ImportHelpCallback, (XtPointer)2);
      XtManageChild(button);
      
      GROW_WID = XtVaCreateManagedWidget ("Create Footprint Models from point features with attribution",
					  xmToggleButtonWidgetClass, form,
					  XmNtopAttachment,    XmATTACH_FORM,
					  XmNtraversalOn,      False,
					  XmNbottomAttachment, XmATTACH_FORM,
					  XmNleftAttachment,   XmATTACH_WIDGET,
					  XmNleftWidget,       button,
					  XmNlabelString, STRING("Create Footprint Models from point features with attribution"),
					  TOGGLETRANSLATE,     TOGGLEINCLUDE,
					  NULL);
      XtAddCallback (GROW_WID, XmNvalueChangedCallback,Iinvert, (XtPointer)3);
      XmToggleButtonSetState(GROW_WID,(Boolean)GROW_MODELS,(Boolean)0);
      
      XtManageChild(form);
      
      
      
      
      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,
			       NULL);
      
      button = XtVaCreateManagedWidget ("Help",xmPushButtonWidgetClass,form,
					XmNlabelString,        STRING("Help"),
					XmNtraversalOn,                 False,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					NULL);
      XtAddCallback(button, XmNactivateCallback, ImportHelpCallback, (XtPointer)11);
      XtManageChild(button);
      
      GROW_WID = XtVaCreateManagedWidget ("Create Stamp Models from point features with attribution",
					  xmToggleButtonWidgetClass, form,
					  XmNtopAttachment,    XmATTACH_FORM,
					  XmNtraversalOn,      False,
					  XmNbottomAttachment, XmATTACH_FORM,
					  XmNleftAttachment,   XmATTACH_WIDGET,
					  XmNleftWidget,       button,
					  XmNlabelString,      STRING("Create Stamp Models from point features with attribution"),
					  TOGGLETRANSLATE,     TOGGLEINCLUDE,
					  NULL);
      XtAddCallback (GROW_WID, XmNvalueChangedCallback,Iinvert, (XtPointer)11);
      XmToggleButtonSetState(GROW_WID,(Boolean)GROW_STAMPS,(Boolean)0);
      
      XtManageChild(form);
      
      
      
      
      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,
			       NULL);
      
      button = XtVaCreateManagedWidget ("Help",xmPushButtonWidgetClass,form,
					XmNlabelString,        STRING("Help"),
					XmNtraversalOn,                 False,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					NULL);
      XtAddCallback(button, XmNactivateCallback, ImportHelpCallback, (XtPointer)9);
      XtManageChild(button);
      
      button = XtVaCreateManagedWidget ("Import All Damaged States of Models",
					xmToggleButtonWidgetClass, form,
					XmNtopAttachment,          XmATTACH_FORM,
					XmNtraversalOn,            False,
					XmNbottomAttachment,       XmATTACH_FORM,
					XmNleftAttachment,         XmATTACH_WIDGET,
					XmNleftWidget,             button,
					XmNlabelString,            STRING("Import All Damaged States of Models"),
					TOGGLETRANSLATE,     TOGGLEINCLUDE,
					NULL);
      XtAddCallback (button, XmNvalueChangedCallback,Iinvert, (XtPointer)8);
      XmToggleButtonSetState(button,(Boolean)DO_DAMAGED_MODELS,(Boolean)0);
      
      XtManageChild(form);
		  
      
      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,
			       NULL);
      
      button = XtVaCreateManagedWidget ("Help",xmPushButtonWidgetClass,form,
					XmNlabelString,        STRING("Help"),
					XmNtraversalOn,                 False,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					NULL);
      XtAddCallback(button, XmNactivateCallback, ImportHelpCallback, (XtPointer)10);
      XtManageChild(button);
      
      
      button2 = XtVaCreateManagedWidget ("Import data from specified rectangle",
					 xmToggleButtonWidgetClass, form,
					 XmNtopAttachment,          XmATTACH_FORM,
					 XmNtraversalOn,            False,
					 XmNbottomAttachment,       XmATTACH_FORM,
					 XmNleftAttachment,         XmATTACH_WIDGET,
					 XmNleftWidget,             button,
					 XmNlabelString,            STRING("Import data from specified rectangle     "),
					 TOGGLETRANSLATE,     TOGGLEINCLUDE,
					 NULL);
      XtAddCallback (button2, XmNvalueChangedCallback,Iinvert, (XtPointer)9);
      XmToggleButtonSetState(button2,(Boolean)CLIPEXTRACT,(Boolean)0);
      
      
      button = XtVaCreateManagedWidget ("Specify Rectangle...",xmPushButtonWidgetClass,form,
					XmNlabelString,        STRING("Specify Rectangle..."),
					XmNtraversalOn,                 False,
					XmNleftAttachment,         XmATTACH_WIDGET,
					XmNleftWidget,             button2,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					NULL);
      XtAddCallback(button, XmNactivateCallback, RectangleCallback, (XtPointer)NULL);
      XtManageChild(button);
      
	  
      XtManageChild(form);
      









  

      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,
			       NULL);
      
      button = XtVaCreateManagedWidget ("Help",xmPushButtonWidgetClass,form,
					XmNlabelString,        STRING("Help"),
					XmNtraversalOn,                 False,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					NULL);
      XtAddCallback(button, XmNactivateCallback, ImportHelpCallback, (XtPointer)7);
      XtManageChild(button);
      
      
      
      buttonA = XtVaCreateManagedWidget ("Color toplevel map objects",
					 xmToggleButtonWidgetClass, form,
					 XmNtopAttachment,    XmATTACH_FORM,
					 XmNtraversalOn,      False,
					 XmNbottomAttachment, XmATTACH_FORM,
					 XmNleftAttachment,   XmATTACH_POSITION,
					 XmNleftPosition,     50,
					 XmNlabelString,      STRING("Color objects as lines"),
					 TOGGLETRANSLATE,     TOGGLEINCLUDE,
					 NULL);
      XtAddCallback (buttonA, XmNvalueChangedCallback,Iinvert, (XtPointer)10);
      XmToggleButtonSetState(buttonA,(Boolean)DO_LINES,(Boolean)0);
      
      XtManageChild(form);
      
      
      
      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,
			       NULL);
      
      
      button = XtVaCreateManagedWidget ("Help",xmPushButtonWidgetClass,form,
					XmNlabelString,        STRING("Help"),
					XmNtraversalOn,                 False,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					NULL);
      XtAddCallback(button, XmNactivateCallback, ImportHelpCallback, (XtPointer)3);
      XtManageChild(button);
      
      button = XtVaCreateManagedWidget ("Directly attach components",
					xmToggleButtonWidgetClass, form,
					XmNtopAttachment,          XmATTACH_FORM,
					XmNtraversalOn,            False,
					XmNbottomAttachment,       XmATTACH_FORM,
					XmNleftAttachment,         XmATTACH_WIDGET,
					XmNleftWidget,             button,
					XmNlabelString,            STRING("Directly attach components"),
					TOGGLETRANSLATE,     TOGGLEINCLUDE,
					NULL);
      XtAddCallback (button, XmNvalueChangedCallback,Iinvert, (XtPointer)1);
      XmToggleButtonSetState(button,(Boolean)get_attach(),(Boolean)0);
      
      
      
      
      button = XtVaCreateManagedWidget ("Help",xmPushButtonWidgetClass,form,
					XmNlabelString,        STRING("Help"),
					XmNtraversalOn,                 False,
					XmNleftAttachment,  XmATTACH_POSITION,
					XmNleftPosition,                    50,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					NULL);
      XtAddCallback(button, XmNactivateCallback, ImportHelpCallback, (XtPointer)1);
      XtManageChild(button);
      
      INVERT_WID = XtVaCreateManagedWidget ("Transpose World 3x3 Matricies",
					    xmToggleButtonWidgetClass, form,
					    XmNtopAttachment,          XmATTACH_FORM,
					    XmNtraversalOn,            False,
					    XmNbottomAttachment,       XmATTACH_FORM,
					    XmNleftAttachment,         XmATTACH_WIDGET,
					    XmNleftWidget,             button,
					    XmNlabelString,            STRING("Transpose World 3x3 Matricies"),
					    TOGGLETRANSLATE,     TOGGLEINCLUDE,
					    NULL);
      XtAddCallback (INVERT_WID, XmNvalueChangedCallback,Iinvert, (XtPointer)0);
      XmToggleButtonSetState(INVERT_WID,(Boolean)INVERT_3x3,(Boolean)0);
      
      XtManageChild(form);
      
      
      
      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,
			       NULL);
      
      button = XtVaCreateManagedWidget ("Help",xmPushButtonWidgetClass,form,
					XmNlabelString,        STRING("Help"),
					XmNtraversalOn,                 False,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					NULL);
      XtAddCallback(button, XmNactivateCallback, ImportHelpCallback, (XtPointer)4);
      XtManageChild(button);
      
      MODEL_POLY_WID = XtVaCreateManagedWidget ("Use model library polygons",
						xmToggleButtonWidgetClass, form,
						XmNtopAttachment,    XmATTACH_FORM,
						XmNtraversalOn,      False,
						XmNbottomAttachment, XmATTACH_FORM,
						XmNleftAttachment,   XmATTACH_WIDGET,
						XmNleftWidget,       button,
						XmNlabelString,      STRING("Use model library polygons"),
						TOGGLETRANSLATE,     TOGGLEINCLUDE,
						NULL);
      XtAddCallback (MODEL_POLY_WID, XmNvalueChangedCallback,Iinvert, (XtPointer)2);
      XmToggleButtonSetState(MODEL_POLY_WID,(Boolean)DOMODELPOLYS,(Boolean)0);
      
      
      button = XtVaCreateManagedWidget ("Help",xmPushButtonWidgetClass,form,
					XmNlabelString,        STRING("Help"),
					XmNtraversalOn,                 False,
					XmNleftAttachment,  XmATTACH_POSITION,
					XmNleftPosition,                    50,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					NULL);
      XtAddCallback(button, XmNactivateCallback, ImportHelpCallback, (XtPointer)5);
      XtManageChild(button);
      
      model_sum_wid = XtVaCreateManagedWidget ("Create model summary file",
					       xmToggleButtonWidgetClass, form,
					       XmNtopAttachment,    XmATTACH_FORM,
					       XmNtraversalOn,      False,
					       XmNbottomAttachment, XmATTACH_FORM,
					       XmNleftAttachment,   XmATTACH_WIDGET,
					       XmNleftWidget,       button,
					       XmNlabelString,      STRING("Create model summary file"),
					       TOGGLETRANSLATE,     TOGGLEINCLUDE,
					       NULL);
      XtAddCallback (model_sum_wid, XmNvalueChangedCallback,Iinvert, (XtPointer)4);
      XmToggleButtonSetState(model_sum_wid,(Boolean)DOMODELSUMMARY,(Boolean)0);
      
      
      XtManageChild(form);
      
      
      
      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,
			       NULL);
      
      button = XtVaCreateManagedWidget ("Help",xmPushButtonWidgetClass,form,
					XmNlabelString,        STRING("Help"),
					XmNtraversalOn,                 False,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					NULL);
      XtAddCallback(button, XmNactivateCallback, ImportHelpCallback, (XtPointer)6);
      XtManageChild(button);
      
      DUPE_WID = XtVaCreateManagedWidget ("Ignore revisited objects",
					  xmToggleButtonWidgetClass, form,
					  XmNtopAttachment,    XmATTACH_FORM,
					  XmNtraversalOn,      False,
					  XmNbottomAttachment, XmATTACH_FORM,
					  XmNleftAttachment,   XmATTACH_WIDGET,
					  XmNleftWidget,       button,
					  XmNlabelString,      STRING("Ignore revisited objects"),
					  TOGGLETRANSLATE,     TOGGLEINCLUDE,
					  NULL);
      XtAddCallback (DUPE_WID, XmNvalueChangedCallback,Iinvert, (XtPointer)5);
      XmToggleButtonSetState(DUPE_WID,(Boolean)DOTHEDUPES,(Boolean)0);
      
      
      
      
      button = XtVaCreateManagedWidget ("Help",xmPushButtonWidgetClass,form,
					XmNlabelString,        STRING("Help"),
					XmNtraversalOn,                 False,
					XmNleftAttachment,  XmATTACH_POSITION,
					XmNleftPosition,                    50,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					NULL);
      XtAddCallback(button, XmNactivateCallback, ImportHelpCallback, (XtPointer)8);
      XtManageChild(button);
      
      button = XtVaCreateManagedWidget ("Import Feature Models",
					xmToggleButtonWidgetClass, form,
					XmNtopAttachment,          XmATTACH_FORM,
					XmNtraversalOn,            False,
					XmNbottomAttachment,       XmATTACH_FORM,
					XmNleftAttachment,         XmATTACH_WIDGET,
					XmNleftWidget,             button,
					XmNlabelString,            STRING("Import Feature Models"),
					TOGGLETRANSLATE,     TOGGLEINCLUDE,
					NULL);
      XtAddCallback (button, XmNvalueChangedCallback,Iinvert, (XtPointer)7);
      XmToggleButtonSetState(button,(Boolean)DO_FMIS,(Boolean)0);
      
      XtManageChild(form);
      
      
      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,
			       NULL);
      
      button = XtVaCreateManagedWidget ("Help",xmPushButtonWidgetClass,form,
					XmNlabelString,        STRING("Help"),
					XmNtraversalOn,                 False,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					NULL);
      XtAddCallback(button, XmNactivateCallback, ImportHelpCallback, (XtPointer)13);
      XtManageChild(button);
      
      DUPE_WID = XtVaCreateManagedWidget ("Use Memory-Conserving Format Operation",
					  xmToggleButtonWidgetClass, form,
					  XmNtopAttachment,          XmATTACH_FORM,
					  XmNtraversalOn,            False,
					  XmNbottomAttachment,       XmATTACH_FORM,
					  XmNleftAttachment,         XmATTACH_WIDGET,
					  XmNleftWidget,             button,
					  XmNlabelString,            STRING("USE GMI/FMI object IDs for ModelLib Objects"),
					  TOGGLETRANSLATE,     TOGGLEINCLUDE,
					  NULL);
      XtAddCallback (DUPE_WID, XmNvalueChangedCallback,Iinvert, (XtPointer)13);
      XmToggleButtonSetState(DUPE_WID,(Boolean)GMI_ASSIGN_ID,(Boolean)0);
      
      XtManageChild(form);
      





      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,
			       NULL);
      
      button = XtVaCreateManagedWidget ("Help",xmPushButtonWidgetClass,form,
					XmNlabelString,        STRING("Help"),
					XmNtraversalOn,                 False,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					NULL);
      XtAddCallback(button, XmNactivateCallback, ImportHelpCallback, (XtPointer)21);
      XtManageChild(button);

      button2 = XtVaCreateManagedWidget ("Use Memory-Conserving Format Operation",
					xmLabelWidgetClass, form,
					XmNtopAttachment,          XmATTACH_FORM,
					XmNtraversalOn,            False,
					XmNbottomAttachment,       XmATTACH_FORM,
					XmNleftAttachment,         XmATTACH_WIDGET,
					XmNleftWidget,             button,
					XmNlabelString,            STRING("Use Environment Root #"),
					LABELWTRANSLATE,
					NULL);
      XtManageChild(button2);

      
      sprintf(temp,"%d",ENV_ROOT_NUM);
      env_root_area = XtVaCreateManagedWidget ("text_w",
					       xmTextFieldWidgetClass, form,	  
					       XmNvalue,           temp,
					       XmNtraversalOn,     True,
					       XmNleftAttachment,  XmATTACH_WIDGET,
					       XmNleftWidget,      button2,
					       XmNmaxLength,       6,
                           XmNtranslations,    XtParseTranslationTable ( translations_paste ) ,
					       NULL);
      
      XtAddCallback (env_root_area, XmNactivateCallback,
		     (XtCallbackProc)print_result2,(XtPointer)5);
      XtManageChild(env_root_area);
      
      XtManageChild(form);
      








      
      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,
			       NULL);
      
      button = XtVaCreateManagedWidget ("Specify Objects to Import...",
					xmPushButtonWidgetClass,form,
					XmNlabelString,        STRING("Specify Objects to Import..."),
					XmNtraversalOn,                 False,
					XmNleftAttachment,  XmATTACH_POSITION,
					XmNleftPosition,                    0,
					XmNrightAttachment, XmATTACH_POSITION,
					XmNrightPosition,                   48,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					NULL);
      XtAddCallback(button, XmNactivateCallback, SpecifyObjectsCallback, (XtPointer)NULL);
      XtManageChild(button);
      

      button = XtVaCreateManagedWidget ("Destination Directory...",xmPushButtonWidgetClass,form,
					XmNlabelString,        STRING("Destination Directory..."),
					XmNleftAttachment,  XmATTACH_POSITION,
					XmNleftPosition,                   52,
					XmNrightAttachment, XmATTACH_POSITION,
					XmNrightPosition,                  99,
					XmNtraversalOn,                 False,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					NULL); 
      XtAddCallback(button, XmNactivateCallback, ImportDestinationCallback, (XtPointer)0);
      XtManageChild(button);
   

      XtManageChild(form);
      
    
  
      
      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,
			       NULL);
      
      button = XtVaCreateManagedWidget ("Input Source...",xmPushButtonWidgetClass,form,
					XmNlabelString,        STRING("Input Source..."),
					XmNleftAttachment,  XmATTACH_POSITION,
					XmNleftPosition,                    0,
					XmNrightAttachment, XmATTACH_POSITION,
					XmNrightPosition,                   48,
					XmNtraversalOn,                 False,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					NULL); 
      XtAddCallback(button, XmNactivateCallback, ImportFileCallback, (XtPointer) NULL);
      XtManageChild(button);

      button = XtVaCreateManagedWidget ("Import Selected Data",xmPushButtonWidgetClass,form,
					XmNlabelString,        STRING("Import Selected Data"),
					XmNleftAttachment,  XmATTACH_POSITION,
					XmNleftPosition,                    52,
					XmNrightAttachment, XmATTACH_POSITION,
					XmNrightPosition,                   99,
					XmNtraversalOn,                 False,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					NULL); 
      XtAddCallback(button, XmNactivateCallback, Import2Callback, (XtPointer) NULL);
      XtManageChild(button);
      XtManageChild (form);

      

   



      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,
			       NULL);

      button = XtVaCreateManagedWidget ("Help",xmPushButtonWidgetClass,form,
					XmNlabelString,        STRING("Help"),
					XmNleftAttachment,  XmATTACH_POSITION,
					XmNleftPosition,                    0,
					XmNrightAttachment, XmATTACH_POSITION,
					XmNrightPosition,                   48,
					XmNtraversalOn,                 False,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					NULL);
      XtAddCallback(button, XmNactivateCallback, ImportHelpCallback, (XtPointer)0);
      XtManageChild(button);



      if(FORMATBUTTON==1)
	{
	  button = XtVaCreateManagedWidget ("Format Imported Database",xmPushButtonWidgetClass,form,
					    XmNlabelString,        STRING("Format Imported Database"),
					    XmNleftAttachment,  XmATTACH_POSITION,
					    XmNleftPosition,                    52,
					    XmNrightAttachment, XmATTACH_POSITION,
					    XmNrightPosition,                   99,
					    XmNtraversalOn,                 False,
					    XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					    NULL); 
	  XtAddCallback(button, XmNactivateCallback, ImportFormatCallback, (XtPointer) NULL);
	  XtManageChild(button);
	}

      
      
      button = XtVaCreateManagedWidget ("Done",xmPushButtonWidgetClass,form,
					XmNlabelString,        STRING("Done"),
					XmNleftAttachment,  XmATTACH_POSITION,
					XmNleftPosition,                    52,
					XmNrightAttachment, XmATTACH_POSITION,
					XmNrightPosition,                   99,
					XmNtraversalOn,                 False,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					NULL);
      XtAddCallback(button, XmNactivateCallback, die_callback, (XtPointer)114);
      XtManageChild(button);
      XtManageChild (form);
      XtManageChild (rowcol);
      
      IMPORT_WIN = 1;
      MyPopup(GetImportShell());
      XtAddCallback(GetImportShell(),XmNdestroyCallback,ShellDeath,(XtPointer)218);       
    }
  else
    {
      ResetWidget(GetImportShell());
    }
  #endif
}














int TestPrefFile(char *newname)
{
  FILE *testfile;

 testfile = fopen(newname,"r");
 if(testfile==NULL)
   {
     return 0;
   }

 fclose(testfile);
 
 return 1;

}


char * ProcessGAITPrefFile(char path[])
{
  int pathlen,loclen,i;
  char startloc[1000];
  static char newstr[1000];
  
  
  
  printf("processing potential GAIT Pref file %s\n",path);
  
  
  if(TestPrefFile(path)==0)
    {
      printf("    rejected potential GAIT pref file %s\n",path);
      
      return "..";
    }


  
  if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
    {
      sprintf(startloc,"%s\\ProjectPreferences",PROJECTLOC);
    }
  else
    {
      sprintf(startloc,"%s/ProjectPreferences",PROJECTLOC);
    }


  
  
  if(strlen(path)<strlen(startloc))
    {
      printf("error: potential project %s less than %s\n",path,PROJECTLOC);
    }
  
  loclen  = strlen(startloc) + 1;  
  pathlen = strlen(path);
  
  
  for(i=loclen;i<pathlen;i++)
    {
      newstr[i-loclen] = path[i];
    }
  newstr[i-loclen] = '\0';
  
  
  if(!strcmp(newstr,"."))
    {
      return "..";
    }
  if(!strcmp(newstr,".."))
    {
      return "..";
    }
    
  return newstr;
}









int ParseErrAxis(char *axisname,int line, char *exefile)
{
  char message[1000];

  if(!strcmp(axisname,"PRIMARY"))        {return 1;}
  else if(!strcmp(axisname,"SECONDARY")) {return 2;}
  else if(!strcmp(axisname,"TERTIARY"))  {return 3;}
  else
    {
      if(batch_mode==1)
	{
	  printf("Bad input in file %s, line %d\n",exefile,line);
	  printf("expected a participant name (PRIMARY,SECONDARY, or TERTIARY)\n");
	  printf("received: %s\n",axisname);
	  ExitWrapper(-1);
	}
      else
	{
	  sprintf(message,"Bad input in file %s, line %d\n\
Expected a participant name (PRIMARY,SECONDARY, or TERTIARY)\n\
Received: %s\n\
Terminating load of this file at the location of this error.",exefile,line,axisname);
	  not_while_running(drawing_a,message,1333,"Bad Inspection Specification File",1);
	}
    } 
  return -1;  
}


char * ParseAxisName(int axis)
{
  if(axis==1)
    {
      return("PRIMARY");
    }
  else if(axis==2)
    {
      return("SECONDARY");
    }
  else return("TERTIARY");  
}
 
 

int ParseNGACNumber(char *cname,int line, char *exefile, int level, int errnum)
{
  char message[1000];

  


  if(
	  (!strcmp(cname,"C_SOME_AREA")) ||
	  (!strcmp(cname,"C_ALL_AREA"))
	)
  {
    if(level==1)
	{
      if(ErrorLookup[errnum].Config1[C_AREA]==2)
	  {
        printf("Illegal to set %s for C_PRIMARY for inspection %s\n",cname,ErrorLookup[errnum].name);
	  }
	}
    if(level==2)
	{
      if(ErrorLookup[errnum].Config2[C_AREA]==2)
	  {
        printf("Illegal to set %s for C_SECONDARY for inspection %s\n",cname,ErrorLookup[errnum].name);
	  }
	}
    if(level==3)
	{
      if(ErrorLookup[errnum].Config3[C_AREA]==2)
	  {
        printf("Illegal to set %s for C_TERTIARY for inspection %s\n",cname,ErrorLookup[errnum].name);
	  }
	}
  }


  if(
	  (!strcmp(cname,"C_SOME_LINE")) ||
	  (!strcmp(cname,"C_ALL_LINE"))
	)
  {
    if(level==1)
	{
      if(ErrorLookup[errnum].Config1[C_LINE]==2)
	  {
        printf("Illegal to set %s for C_PRIMARY for inspection %s\n",cname,ErrorLookup[errnum].name);
	  }
	}
    if(level==2)
	{
      if(ErrorLookup[errnum].Config2[C_LINE]==2)
	  {
        printf("Illegal to set %s for C_SECONDARY for inspection %s\n",cname,ErrorLookup[errnum].name);
	  }
	}
    if(level==3)
	{
      if(ErrorLookup[errnum].Config3[C_LINE]==2)
	  {
        printf("Illegal to set %s for C_TERTIARY for inspection %s\n",cname,ErrorLookup[errnum].name);
	  }
	}
  }


  if(
	  (!strcmp(cname,"C_SOME_POFE")) ||
	  (!strcmp(cname,"C_ALL_POFE"))
	)
  {
    if(level==1)
	{
      if(ErrorLookup[errnum].Config1[C_POFE]==2)
	  {
        printf("Illegal to set %s for C_PRIMARY for inspection %s\n",cname,ErrorLookup[errnum].name);
	  }
	}
    if(level==2)
	{
      if(ErrorLookup[errnum].Config2[C_POFE]==2)
	  {
        printf("Illegal to set %s for C_SECONDARY for inspection %s\n",cname,ErrorLookup[errnum].name);
	  }
	}
    if(level==3)
	{
      if(ErrorLookup[errnum].Config3[C_POFE]==2)
	  {
        printf("Illegal to set %s for C_TERTIARY for inspection %s\n",cname,ErrorLookup[errnum].name);
	  }
	}
  }


  if(
	  (!strcmp(cname,"C_SOME_GRID")) ||
	  (!strcmp(cname,"C_ALL_GRID"))
	)
  {
    if(level==1)
	{
      if(ErrorLookup[errnum].Config1[C_GRID]==2)
	  {
        printf("Illegal to set %s for C_PRIMARY for inspection %s\n",cname,ErrorLookup[errnum].name);
	  }
	}
    if(level==2)
	{
      if(ErrorLookup[errnum].Config2[C_GRID]==2)
	  {
        printf("Illegal to set %s for C_SECONDARY for inspection %s\n",cname,ErrorLookup[errnum].name);
	  }
	}
    if(level==3)
	{
      if(ErrorLookup[errnum].Config3[C_GRID]==2)
	  {
        printf("Illegal to set %s for C_TERTIARY for inspection %s\n",cname,ErrorLookup[errnum].name);
	  }
	}
  }



  if(!strcmp(cname,"C_SOME_AREA")){return -1;}
  else if(!strcmp(cname,"C_SOME_LINE")){return -4;}
  else if(!strcmp(cname,"C_SOME_POFE")){return -5;}
  else if(!strcmp(cname,"C_SOME_POMO")){return -6;}
  else if(!strcmp(cname,"C_SOME_GRID")){return -9;}
  
  else if(!strcmp(cname,"C_ALL_AREA")){return 1;}
  else if(!strcmp(cname,"C_ALL_LINE")){return 4;}
  else if(!strcmp(cname,"C_ALL_POFE")){return 5;}
  else if(!strcmp(cname,"C_ALL_POMO")){return 6;}
  else if(!strcmp(cname,"C_ALL_GRID")){return 9;}
  else
    {
      if(batch_mode==1)
	{
	  printf("Bad input in file %s, line %d\n",exefile,line);
	  printf("expected a configuration name, received: %s\n",cname);
	  ExitWrapper(-1);
	}
      else
	{
	  sprintf(message,"Bad input in file %s, line %d:\n\
Expected a configuration name, received: %s\n\
Terminating load of this file at the location of this error.",exefile,line,cname);
	  not_while_running(drawing_a,message,1334,"Bad Inspection Specification File",1);
	}
    }
  return -999; 
}




int ParseCNumber(char *cname,int line, char *exefile)
{
  char message[1000];

  if(!strcmp(cname,"C_ALL")){return 100;}
  else if(!strcmp(cname,"C_NONE")){return 0;}
  else if(!strcmp(cname,"C_AREA")){return 1;}
  else if(!strcmp(cname,"C_DILI")){return 2;}
  else if(!strcmp(cname,"C_FOMO")){return 3;}
  else if(!strcmp(cname,"C_LINE")){return 4;}
  else if(!strcmp(cname,"C_POFE")){return 5;}
  else if(!strcmp(cname,"C_POMO")){return 6;}
  else if(!strcmp(cname,"C_POLY")){return 7;}
  else if(!strcmp(cname,"C_DYMO")){return 8;}
  else if(!strcmp(cname,"C_GRID")){return 9;}
  else if(!strcmp(cname,"C_COVS")){return 10;}
  else if(!strcmp(cname,"C_COVP")){return 11;}
  else if(!strcmp(cname,"C_MOLI")){return 12;}
  else if(!strcmp(cname,"C_MLPF")){return 13;}
  else if(!strcmp(cname,"C_MLLF")){return 14;}
  else if(!strcmp(cname,"C_MLAF")){return 15;}
  else
    {
      if(batch_mode==1)
	{
	  printf("Bad input in file %s, line %d\n",exefile,line);
	  printf("expected a configuration name, received: %s\n",cname);
	  ExitWrapper(-1);
	}
      else
	{
	  sprintf(message,"Bad input in file %s, line %d:\n\
Expected a configuration name, received: %s\n\
Terminating load of this file at the location of this error.",exefile,line,cname);
	  not_while_running(drawing_a,message,1335,"Bad Inspection Specification File",1);
	}
    }
  return -1; 
}


int ParseSNumber(char *sname,int line, char *exefile)
{
  char message[1000];

  if(!strcmp(sname,"S_ALL")){return 100;}
  else if(!strcmp(sname,"S_NONE")){return 0;}
  else if(!strcmp(sname,"S_APPL")){return 1;}
  else if(!strcmp(sname,"S_COVE")){return 2;}
  else if(!strcmp(sname,"S_SUBS")){return 4;}
  else if(!strcmp(sname,"S_SURF")){return 5;}
  else
    {
      printf("Bad input in file %s, line %d\n",exefile,line);
      printf("expected a stratum name, received: %s\n",sname);

      if(batch_mode==1)
	{
	  ExitWrapper(-1);
	}
      else
	{
	  sprintf(message,"Bad input in file %s, line %d\n\
Expected a stratum name, received: %s\n\
Terminating load of this file at the location of this error.",exefile,line,sname);
	  not_while_running(drawing_a,message,1336,"Bad Inspection Specification File",1);
	}
    }
  return -1;  
}



int ParseDNumber(char *dname,int line, char *exefile)
{
  char message[1000];

  if(!strcmp(dname,"D_ALL")){return 100;}
  else if(!strcmp(dname,"D_NONE")){return 0;}
  else if(!strcmp(dname,"D_AIMO")){return 1;}
  else if(!strcmp(dname,"D_AIOB")){return 2;}
  else if(!strcmp(dname,"D_BOUN")){return 3;}
  else if(!strcmp(dname,"D_BRID")){return 4;}
  else if(!strcmp(dname,"D_CULT")){return 5;}
  else if(!strcmp(dname,"D_INWA")){return 6;}
  else if(!strcmp(dname,"D_LAMO")){return 7;}
  else if(!strcmp(dname,"D_LAOB")){return 8;}
  else if(!strcmp(dname,"D_MIUS")){return 9;}
  else if(!strcmp(dname,"D_OPWA")){return 10;}
  else if(!strcmp(dname,"D_TERR")){return 11;}
  else if(!strcmp(dname,"D_VEGE")){return 12;}
  else if(!strcmp(dname,"D_MAMO")){return 13;}
  else if(!strcmp(dname,"D_MAOB")){return 14;}
  else if(!strcmp(dname,"D_MACU")){return 15;}
  else if(!strcmp(dname,"D_WEAT")){return 16;}
  else if(!strcmp(dname,"D_SPAC")){return 17;}
  else if(!strcmp(dname,"D_DESC")){return 18;}
  else
    {
      printf("Bad input in file %s, line %d\n",exefile,line);
      printf("expected a Domain name, received: %s\n",dname);
      
      if(batch_mode==1)
	{
	  ExitWrapper(-1);
	}
      else
	{
	  sprintf(message,"Bad input in file %s, line %d:\n\
Expected a Domain name, received: %s\n\
Terminating load of this file at the location of this error.",exefile,line,dname);
	  not_while_running(drawing_a,message,1337,"Bad Inspection Specification File",1);
	}
    }
  return -1; 
}



int SetPrimarySensitivity(int errnumber,int instance,char *errname,double sensitivity,int line, char *exefile)
{
  int cloneindex;
  int bad = 0;
  char message[1000];


  if(instance==1)
    {
      if((sensitivity>=ErrorLookup[errnumber].lowrange)&&(sensitivity<=ErrorLookup[errnumber].highrange))
	{
	  ErrorLookup[errnumber].sensitivity = sensitivity;
	}
      else
	{
	  bad = 1;
	}
    }
  else
    {
      cloneindex = GetCloneIndex(instance-1,errnumber);

      if(
	 (sensitivity>=ErrorLookup[errnumber].lowrange)&& 
	 (sensitivity<=ErrorLookup[errnumber].highrange)  
	 )
	{
	  CloneErrorLookup[cloneindex].sensitivity = sensitivity;
	}
      else
	{
	  bad  = 1;
	}
     }



  if(bad==1)
    {
      if(batch_mode==1)
	{
	  printf("bad input in inspection specification file %s, line %d.\n",exefile,line);
	  printf("attempted to set the primary tolerance for check %d (%s) instance %d to %lf\n",
		 errnumber,errname,instance,sensitivity);
	  printf("Acceptable range: %lf - %lf\n",ErrorLookup[errnumber].lowrange,ErrorLookup[errnumber].highrange);
	  ExitWrapper(-1);
	}
      else
	{
	  sprintf(message,"Bad input in inspection specification file %s, line %d:\n\
Attempted to set the primary tolerance for check %d (%s) instance %d to %lf.\n\
Acceptable range: %lf - %lf\n\
Terminating load of this file at the location of this error.",
		  exefile,line,errnumber,errname,instance,sensitivity,
		  ErrorLookup[errnumber].lowrange,ErrorLookup[errnumber].highrange);
	  
	  not_while_running(drawing_a,message,1338,"Bad Inspection Specification File",1);
	  
	  return -1;
	}
    }
  
  return 1;
}


int SetSecondarySensitivity(int errnumber,int instance, char *errname, double sensitivity,int line, char *exefile)
{
  int cloneindex;
  int bad = 0;
  char message[1000];


  if(instance==1)
    {
      if((sensitivity>=ErrorLookup[errnumber].lowrange2)&&(sensitivity<=ErrorLookup[errnumber].highrange2))
	{
	  ErrorLookup[errnumber].sensitivity2 = sensitivity;
	}
      else
	{
	  bad = 1;
	}
    }
  else
    {
      cloneindex = GetCloneIndex(instance-1,errnumber);

      if(
	 (sensitivity>=ErrorLookup[errnumber].lowrange2)&& 
	 (sensitivity<=ErrorLookup[errnumber].highrange2)  
	 )
	{
	  CloneErrorLookup[cloneindex].sensitivity2 = sensitivity;
	}
      else
	{
	  bad = 1;
	}
     }


  if(bad==1)
    {
      if(batch_mode==1)
	{
	  printf("bad input in inspection specification file %s, line %d.\n",exefile,line);
	  printf("attempted to set the secondary tolerance for check %d (%s) instance %d to %lf\n",
		 errnumber,errname,instance,sensitivity);
	  printf("Acceptable range: %lf - %lf\n",ErrorLookup[errnumber].lowrange2,ErrorLookup[errnumber].highrange2);
	  ExitWrapper(-1);
	}
      else
	{
	  sprintf(message,"Bad input in inspection specification file %s, line %d:\n\
Attempted to set the secondary tolerance for check %d (%s) instance %d to %lf.\n\
Acceptable range: %lf - %lf\n\
Terminating load of this file at the location of this error.",
		  exefile,line,errnumber,errname,instance,sensitivity,
		  ErrorLookup[errnumber].lowrange2,ErrorLookup[errnumber].highrange2);
	  
	  not_while_running(drawing_a,message,1339,"Bad Inspection Specification File",1);
	  
	  return -1;
	}
    }
  
  return 1;

}




int SetTertiarySensitivity(int errnumber,int instance, char *errname, double sensitivity,int line, char *exefile)
{
  int cloneindex;
  int bad = 0;
  char message[1000];


  if(instance==1)
    {
      if((sensitivity>=ErrorLookup[errnumber].lowrange3)&&(sensitivity<=ErrorLookup[errnumber].highrange3))
	{
	  ErrorLookup[errnumber].sensitivity3 = sensitivity;
	}
      else
	{
	  bad = 1;
	}
    }
  else
  { 
      cloneindex = GetCloneIndex(instance-1,errnumber);

      if(
	 (sensitivity>=ErrorLookup[errnumber].lowrange3)&& 
	 (sensitivity<=ErrorLookup[errnumber].highrange3)  
	 )
	{
	  CloneErrorLookup[cloneindex].sensitivity3 = sensitivity;
	}
      else
	{
	  bad = 1;
	}
  }


  if(bad==1)
    {
      if(batch_mode==1)
	{
	  printf("bad input in inspection specification file %s, line %d.\n",exefile,line);
	  printf("attempted to set the tertiary tolerance for check %d (%s) instance %d to %lf\n",
		 errnumber,errname,instance,sensitivity);
	  printf("Acceptable range: %lf - %lf\n",ErrorLookup[errnumber].lowrange3,ErrorLookup[errnumber].highrange3);
	  ExitWrapper(-1);
	}
      else
	{
	  sprintf(message,"Bad input in inspection specification file %s, line %d:\n\
Attempted to set the tertiary tolerance for check %d (%s) instance %d to %lf.\n\
Acceptable range: %lf - %lf\n\
Terminating load of this file at the location of this error.",
		  exefile,line,errnumber,errname,instance,sensitivity,
		  ErrorLookup[errnumber].lowrange3,ErrorLookup[errnumber].highrange3);
	  
	  not_while_running(drawing_a,message,1339,"Bad Inspection Specification File",1);
	  
	  return -1;
	}
    }
  
  return 1;

}


int SetQuaternarySensitivity(int errnumber,int instance, char *errname, double sensitivity,int line, char *exefile)
{
  int cloneindex;
  int bad = 0;
  char message[1000];


  if(instance==1)
    {
      if((sensitivity>=ErrorLookup[errnumber].lowrange4)&&(sensitivity<=ErrorLookup[errnumber].highrange4))
	{
	  ErrorLookup[errnumber].sensitivity4 = sensitivity;
	}
      else
	{
	  bad = 1;
	}
    }
  else
    {
      cloneindex = GetCloneIndex(instance-1,errnumber);

      if(
	 (sensitivity>=ErrorLookup[errnumber].lowrange4)&& 
	 (sensitivity<=ErrorLookup[errnumber].highrange4)  
	 )
	{
	  CloneErrorLookup[cloneindex].sensitivity4 = sensitivity;
	}
      else
	{
	  bad = 1;
	}
     }


  if(bad==1)
    {
      if(batch_mode==1)
	{
	  printf("bad input in inspection specification file %s, line %d.\n",exefile,line);
	  printf("attempted to set the quaternary (4th) tolerance for check %d (%s) instance %d to %lf\n",
		 errnumber,errname,instance,sensitivity);
	  printf("Acceptable range: %lf - %lf\n",ErrorLookup[errnumber].lowrange4,ErrorLookup[errnumber].highrange4);
	  ExitWrapper(-1);
	}
      else
	{
	  sprintf(message,"Bad input in inspection specification file %s, line %d:\n\
Attempted to set the quaternary (4th) tolerance for check %d (%s) instance %d to %lf.\n\
Acceptable range: %lf - %lf\n\
Terminating load of this file at the location of this error.",
		  exefile,line,errnumber,errname,instance,sensitivity,
		  ErrorLookup[errnumber].lowrange4,ErrorLookup[errnumber].highrange4);
	  
	  not_while_running(drawing_a,message,1339,"Bad Inspection Specification File",1);
	  
	  return -1;
	}
    }
  
  return 1;

}


int SetQuinarySensitivity(int errnumber,int instance, char *errname, double sensitivity,int line, char *exefile)
{
  int cloneindex;
  int bad = 0;
  char message[1000];


  if(instance==1)
    {
      if((sensitivity>=ErrorLookup[errnumber].lowrange5)&&(sensitivity<=ErrorLookup[errnumber].highrange5))
	{
	  ErrorLookup[errnumber].sensitivity5 = sensitivity;
	}
      else
	{
	  bad = 1;
	}
    }
  else
    {
      cloneindex = GetCloneIndex(instance-1,errnumber);

      if(
	 (sensitivity>=ErrorLookup[errnumber].lowrange5)&& 
	 (sensitivity<=ErrorLookup[errnumber].highrange5)  
	 )
	{
	  CloneErrorLookup[cloneindex].sensitivity5 = sensitivity;
	}
      else
	{
	  bad = 1;
	}
     }


  if(bad==1)
    {
      if(batch_mode==1)
	{
	  printf("bad input in inspection specification file %s, line %d.\n",exefile,line);
	  printf("attempted to set the quinary (5th) tolerance for check %d (%s) instance %d to %lf\n",
		 errnumber,errname,instance,sensitivity);
	  printf("Acceptable range: %lf - %lf\n",ErrorLookup[errnumber].lowrange5,ErrorLookup[errnumber].highrange5);
	  ExitWrapper(-1);
	}
      else
	{
	  sprintf(message,"Bad input in inspection specification file %s, line %d:\n\
Attempted to set the quinary (5th) tolerance for check %d (%s) instance %d to %lf.\n\
Acceptable range: %lf - %lf\n\
Terminating load of this file at the location of this error.",
		  exefile,line,errnumber,errname,instance,sensitivity,
		  ErrorLookup[errnumber].lowrange5,ErrorLookup[errnumber].highrange5);
	  
	  not_while_running(drawing_a,message,1339,"Bad Inspection Specification File",1);
	  
	  return -1;
	}
    }
  
  return 1;

}


int SetSenarySensitivity(int errnumber,int instance, char *errname, double sensitivity,int line, char *exefile)
{
  int cloneindex;
  int bad = 0;
  char message[1000];


  if(instance==1)
    {
      if((sensitivity>=ErrorLookup[errnumber].lowrange6)&&(sensitivity<=ErrorLookup[errnumber].highrange6))
	{
	  ErrorLookup[errnumber].sensitivity6 = sensitivity;
	}
      else
	{
	  bad = 1;
	}
    }
  else
    {
      cloneindex = GetCloneIndex(instance-1,errnumber);

      if(
	 (sensitivity>=ErrorLookup[errnumber].lowrange6)&& 
	 (sensitivity<=ErrorLookup[errnumber].highrange6)  
	 )
	{
	  CloneErrorLookup[cloneindex].sensitivity6 = sensitivity;
	}
      else
	{
	  bad = 1;
	}
     }


  if(bad==1)
    {
      if(batch_mode==1)
	{
	  printf("bad input in inspection specification file %s, line %d.\n",exefile,line);
	  printf("attempted to set the senary (6th) tolerance for check %d (%s) instance %d to %lf\n",
		 errnumber,errname,instance,sensitivity);
	  printf("Acceptable range: %lf - %lf\n",ErrorLookup[errnumber].lowrange6,ErrorLookup[errnumber].highrange6);
	  ExitWrapper(-1);
	}
      else
	{
	  sprintf(message,"Bad input in inspection specification file %s, line %d:\n\
Attempted to set the senary (6th) tolerance for check %d (%s) instance %d to %lf.\n\
Acceptable range: %lf - %lf\n\
Terminating load of this file at the location of this error.",
		  exefile,line,errnumber,errname,instance,sensitivity,
		  ErrorLookup[errnumber].lowrange6,ErrorLookup[errnumber].highrange6);
	  
	  not_while_running(drawing_a,message,1339,"Bad Inspection Specification File",1);
	  
	  return -1;
	}
    }
  
  return 1;

}



int ParseErrNumberWrapper(char *errname,int line, char *exefile)
{
  int result;
  char message[1000];

  result = ParseErrNumber(errname,line,exefile);

  if(result==-10)
  {
    return result;
  }

  if(result>=1)
  {
	if(IsNetCheck(result))
	{
      return result;
	}

    if(ErrorLookup[result].checkapplies==GAITandSEEITcheck)
	{
      return result;
	}
    if(ErrorLookup[result].checkapplies==GAITcheck)
	{
      if(NGA_TYPE==1)
	  {
        return result;
	  }
	}
    if(ErrorLookup[result].checkapplies==SEEITcheck)
	{
      if(NGA_TYPE==0)
	  {
        return result;
	  }
	}
  }

  if(batch_mode==1)
  {
	printf("Bad input (2) in file %s, line %d\n",exefile,line);
	printf("expected an error name, received: %s\n",errname);
	exit(-1);
  }


   sprintf(message,"\
Bad input (2) in file %s, line %d:\n\
Expected an error name, received: %s.\n\
Terminating load of this file at the location of this error.",exefile,line,errname);
      not_while_running(drawing_a,message,1606,"Bad Execution Options File",1);


  return -1;
}



void ApplyExecutionOptions(char *exefile, int nettype)
{
  FILE *optionfile;
  char aline[1000]; 
  char errname[100], arg2[100], arg3[100],arg4[100],message[1000],newstr[1000];
  double sensitivity;
  int errnumber,actornumber,level,line=0,setting,Ijunk;
  char chk_string[100];
  int cloneindex,num_checks,num_instances,instance,i,j,k,len,len2;


  chk_string   [0] = '\0';

  optionfile = fopen(exefile,"r");
  if(optionfile==NULL)
    {
      printf("couldnt open %s for read. Exiting.\n",exefile);
      ExitWrapper(-1);
    }

  
  fgets(aline,1000,optionfile);
  line++;
  sscanf(aline,"%s %d",chk_string,&num_checks);


  

  if(strcmp(chk_string,"UNIQUE_CHECKS"))
    {
      if(batch_mode==1)
	{
	  printf("Error in %s, line %d\n",exefile,line);
	  printf("The first line must be of the form \"UNIQUE_CHECKS <num_checks>\"\n");
	  printf("found first line %s\n",aline);
	  ExitWrapper(-1);
	}
      else
	{
	  sprintf(message,"Error in %s, line %d\n\
The first line must be of the form \"UNIQUE_CHECKS <num_checks>\"\n\
found first line: %s\n\
Terminating load of this file at the location of this error.",exefile,line,aline);
	  not_while_running(drawing_a,message,1340,"Bad Inspection Specification File",1);
	  fclose(optionfile);

	  return;
	}
    }


  for(i=0;i<num_checks;i++)
    {
      if(feof(optionfile))
	{
	  if(batch_mode==1)
	    {
	      printf("Error in %s, line %d\n",exefile,line);
	      printf("Found %d unique checks to be performed, but only found\n",num_checks);
	      printf("%d lines after the UNIQUE_CHECKS line.\n",i+1);
	      ExitWrapper(-1);
	    }
	  else
	    { 
	      sprintf(message,"Error in %s, line %d\n\
Found %d unique checks to be performed, but only found\n\
%d lines after the UNIQUE_CHECKS line.\n\
Terminating load of this file at the location of this error.",exefile,line,num_checks,i+1);
	      not_while_running(drawing_a,message,1341,"Bad Inspection Specification File",1);
	      fclose(optionfile);
	      return;	      
	    }
	  
	}

      fgets(aline,1000,optionfile);
      line++;
      chk_string[0] = '\0';
      sscanf(aline,"%s %d",chk_string,&num_instances);

      errnumber = ParseErrNumberWrapper(chk_string,line,exefile);
      if(errnumber<0)
	{
	  fclose(optionfile);
	  return;	      
	}

      ErrorLookup[errnumber].active   = 1;


      

   
      

	  if(num_instances>1)
	  {
        CLONE_RANGE = num_instances - 1;
	    CloneCallback((Widget)NULL,(XtPointer)errnumber, (XtPointer)999);
        CLONE_RANGE = 0;
	  }

    }




  
  
  for(i=0;i<CLONE_DEFINITIONS;i++)
    {
      if(IsNetCheck(CloneErrorLookup[i].CloneNumber)==nettype)
	  {
        CloneErrorLookup[i].active = 1;
	  }
    }






  fgets(aline,1000,optionfile);
  line++;
  while(!feof(optionfile))
    {



      errname[0] = '\0';
      arg2   [0] = '\0';
      arg3   [0] = '\0';
      arg4   [0] = '\0';
      instance   =  0  ;

      sscanf(aline,"%s %d %s",errname,&instance,arg3);      


      errnumber = ParseErrNumberWrapper(errname,line,exefile);
      if(errnumber<0)
	{
	  fclose(optionfile);
	  return;	      
	}


	  if((SingleInstance(errnumber))&&(instance>1))
	  {
		 
         
		 printf("Cannot create multiple instances of %s (%s)...ignoring instance %d\n",
			 ErrorLookup[errnumber].name,ParseErrName(errnumber),instance);
		 
		 fgets(aline,1000,optionfile);
		 line++;
		 continue;
	  }
      
      if(instance>(ErrorLookup[errnumber].num_clones+1))
	{
	  if(batch_mode==1)
	    {
	      printf("Bad input in inspection specification file %s, line %d.\n",exefile,line);
	      printf("Attempted to configure check instance %d for check %s,\n",instance,errname);
	      printf("but check %s has only %d instance(s) defined.\n",errname,
		     ErrorLookup[errnumber].num_clones+1);
	      ExitWrapper(-1);
	    }
	  else
	    {
	      sprintf(message,"Bad input in inspection specification file %s, line %d.\n\
Attempted to configure check instance %d for check %s,\n\
but check %s has only %d instance(s) defined.\n\
Terminating load of this file at the location of this error.\n",
		      exefile,line,instance,errname,errname,ErrorLookup[errnumber].num_clones+1);
		  not_while_running(drawing_a,message,1342,"Bad Inspection Specification File",1);
		  fclose(optionfile);
		  return;
	    }
	}


      if(instance<1)
	{
	  if(batch_mode==1)
	    {
	      printf("Bad input in inspection specification file %s, line %d.\n",exefile,line);
	      printf("Attempted to configure check instance %d for check %s!\n",instance,errname);
	      printf("Check instance numbers are greater than or equal to 1\n");
	      ExitWrapper(-1);
	    }
	  else
	    {
	      sprintf(message,"Bad input in inspection specification file %s, line %d.\n\
Attempted to configure check instance %d for check %s,\n\
Check instance numbers are greater than or equal to 1\n\
Terminating load of this file at the location of this error.\n",
		      exefile,line,instance,errname);
		  not_while_running(drawing_a,message,1343,"Bad Inspection Specification File",1);
		  fclose(optionfile);
		  return;
	    }
	}


      cloneindex = -1;

      if(instance>1)
	{
	  cloneindex = GetCloneIndex(instance-1,errnumber);
	}



      if(!strcmp(arg3,"off"))
	{
	  

	  if(instance==1)
	    {
	      if(BATCHDEBUG==1)printf("*** turn OFF instance 1 check %s\n",errname);
	      ErrorLookup[errnumber].active = 0;
	    }
	  else
	    {
	      if(BATCHDEBUG==1)printf("*** turn OFF instance %d check %s\n",instance,errname);
	      CloneErrorLookup[cloneindex].active = 0;
	    }
	}
      else if(!strcmp(arg3,"ANNOTATION"))
	{
	  
	  
	  len = strlen(aline);

	  for(i=0;i<len;i++)
	    {
	      if((aline[i]==10)||(aline[i]==13))
		{
		  aline[i] = '\0';
		  break;
		}
	    }

	  len = strlen(aline);

	  if(aline[len-1]!='"')
	    {
	      printf("bad input in inspection specification file %s, line %d.\n",exefile,line);
	      printf("line should be of form <errname> <num> ANNOTATION \"<annotation>\"\n");
	      printf("but the line does not end with \"\n");
	      printf("ignoring this line\n");
	    }
	  else
	    {
	      len2 = strlen(aline);
	      
	      for(i=0;i<len2;i++)
		{
		  if(aline[i]=='"')
		    {
		      break;
		    }
		}
	      
	      if(i==(len-1))
		{
		  
		  printf("bad input in inspection specification file %s, line %d.\n",exefile,line);
		  printf("line should be of form <errname> <num> ANNOTATION \"<annotation>\"\n");
		  printf("ignoring this line\n");
		}
	      else
		{
		  for(j=i+1,k=0;j<len-1;j++,k++)
		    {
		      newstr[k] = aline[j];
		    }
		  newstr[k] = '\0';
		  
		  
		  		  
		  
		  if(cloneindex>=0)
		    {
		      if(CloneErrorLookup[cloneindex].Annotation!=NULL)
			{
			  free(CloneErrorLookup[cloneindex].Annotation);
			}
		      CloneErrorLookup[cloneindex].Annotation = (char *)malloc(strlen(newstr)+5);
		      sprintf(CloneErrorLookup[cloneindex].Annotation,"%s",newstr);
		    }
		  else
		    {
		      if(ErrorLookup[errnumber].Annotation!=NULL)
			{
			  free(ErrorLookup[errnumber].Annotation);
			}
		      ErrorLookup[errnumber].Annotation = (char *)malloc(strlen(newstr)+5);
		      sprintf(ErrorLookup[errnumber].Annotation,"%s",newstr);
		    }
		}
	    }
	}

      else if(!strcmp(arg3,"TOLERANCE_PRIMARY"))
	{
	  errname[0] = '\0';
	  arg2   [0] = '\0';

	  sscanf(aline,"%s %d %s %lf",errname,&instance,arg2,&sensitivity);	  

	  if(ErrorLookup[errnumber].numthresholds<1)
	    {
	      if(batch_mode==1)
		{
		  printf("bad input in inspection specification file %s, line %d.\n",exefile,line);
		  printf("attempted to set the primary tolerance for check %d (%s)\n",errnumber,errname);
		  printf("this check has no tolerances\n");
		  ExitWrapper(-1);
		}
	      else
		{
		  sprintf(message,"Bad input in inspection specification file %s, line %d:\n\
Attempted to set the primary tolerance for check %d (%s)\n\
This check has no tolerances!\n\
Terminating load of this file at the location of this error.\n",exefile,line,errnumber,errname);		  
		  not_while_running(drawing_a,message,1344,"Bad Inspection Specification File",1);
		  fclose(optionfile);
		  return;	      
		}
	  }

	  Ijunk = SetPrimarySensitivity(errnumber,instance,errname,sensitivity,line,exefile);

	  if(Ijunk<0)
	    {
	      fclose(optionfile);
	      return;	      
	    }

	  if(BATCHDEBUG==1)
	    printf("** set primary tolerance for condition %d instance %d to %lf\n",errnumber,instance,sensitivity);
	}


      else if(!strcmp(arg3,"TOLERANCE_SECONDARY"))
	{
	  errname[0] = '\0';
	  arg2   [0] = '\0';

	  sscanf(aline,"%s %d %s %lf",errname,&instance,arg2,&sensitivity);	  
	  
	  if(ErrorLookup[errnumber].numthresholds<2)
	    {
	      if(batch_mode==1)
		{
		  printf("bad input in inspection specification file %s, line %d.\n",exefile,line);
		  printf("attempted to set the secondary tolerance for check %d (%s)\n",errnumber,errname);
		  printf("this check has %d tolerances\n",ErrorLookup[errnumber].numthresholds);
		  ExitWrapper(-1);
		}
	      else
		{
		  sprintf(message,"bad input in inspection specification file %s, line %d.\n\
Attempted to set the secondary tolerance for check %d (%s)\n\
This check has %d tolerances.\n\
Terminating load of this file at the location of this error.\n",
			  exefile,line,errnumber,errname,ErrorLookup[errnumber].numthresholds);

		  not_while_running(drawing_a,message,1345,"Bad Inspection Specification File",1);
		  fclose(optionfile);
		  return;	      
		}
	    }

	  Ijunk = SetSecondarySensitivity(errnumber,instance,errname,sensitivity,line,exefile);
	  if(Ijunk<0)
	    {
	      fclose(optionfile);
	      return;	      
	    }

	  if(BATCHDEBUG==1)
	    printf("** set secondary tolerance for condition %d instance %d to %lf\n",errnumber,instance,sensitivity);
	}




      else if(!strcmp(arg3,"TOLERANCE_TERTIARY"))
	{
	  errname[0] = '\0';
	  arg2   [0] = '\0';

	  sscanf(aline,"%s %d %s %lf",errname,&instance,arg2,&sensitivity);	  
	  
	  if(ErrorLookup[errnumber].numthresholds<3)
	    {
	      if(batch_mode==1)
		{
		  printf("bad input in inspection specification file %s, line %d.\n",exefile,line);
		  printf("attempted to set the tertiary tolerance for check %d (%s)\n",errnumber,errname);
		  printf("this check has %d tolerances\n",ErrorLookup[errnumber].numthresholds);
		  ExitWrapper(-1);
		}
	      else
		{
		  sprintf(message,"bad input in inspection specification file %s, line %d.\n\
Attempted to set the tertiary tolerance for check %d (%s)\n\
This check has %d tolerances.\n\
Terminating load of this file at the location of this error.\n",
			  exefile,line,errnumber,errname,ErrorLookup[errnumber].numthresholds);

		  not_while_running(drawing_a,message,1522,"Bad Inspection Specification File",1);
		  fclose(optionfile);
		  return;	      
		}
	    }

	  Ijunk = SetTertiarySensitivity(errnumber,instance,errname,sensitivity,line,exefile);
	  if(Ijunk<0)
	    {
	      fclose(optionfile);
	      return;	      
	    }

	  if(BATCHDEBUG==1)
	    printf("** set tertiary tolerance for condition %d instance %d to %lf\n",errnumber,instance,sensitivity);
	}

    else if(!strcmp(arg3,"TOLERANCE_QUATERNARY"))
	{
	  errname[0] = '\0';
	  arg2   [0] = '\0';

	  sscanf(aline,"%s %d %s %lf",errname,&instance,arg2,&sensitivity);	  
	  
	  if(ErrorLookup[errnumber].numthresholds<4)
	    {
	      if(batch_mode==1)
		{
		  printf("bad input in inspection specification file %s, line %d.\n",exefile,line);
		  printf("attempted to set the quaternary (4th) tolerance for check %d (%s)\n",errnumber,errname);
		  printf("this check has %d tolerances\n",ErrorLookup[errnumber].numthresholds);
		  ExitWrapper(-1);
		}
	      else
		{
		  sprintf(message,"bad input in inspection specification file %s, line %d.\n\
Attempted to set the quaternary (4th) tolerance for check %d (%s)\n\
This check has %d tolerances.\n\
Terminating load of this file at the location of this error.\n",
			  exefile,line,errnumber,errname,ErrorLookup[errnumber].numthresholds);

		  not_while_running(drawing_a,message,1523,"Bad Inspection Specification File",1);
		  fclose(optionfile);
		  return;	      
		}
	    }

	  Ijunk = SetQuaternarySensitivity(errnumber,instance,errname,sensitivity,line,exefile);
	  if(Ijunk<0)
	    {
	      fclose(optionfile);
	      return;	      
	    }

	  if(BATCHDEBUG==1)
	    printf("** set quaternary tolerance for condition %d instance %d to %lf\n",errnumber,instance,sensitivity);
	}
    else if(!strcmp(arg3,"TOLERANCE_QUINARY"))
	{
	  errname[0] = '\0';
	  arg2   [0] = '\0';

	  sscanf(aline,"%s %d %s %lf",errname,&instance,arg2,&sensitivity);	  
	  
	  if(ErrorLookup[errnumber].numthresholds<5)
	    {
	      if(batch_mode==1)
		{
		  printf("bad input in inspection specification file %s, line %d.\n",exefile,line);
		  printf("attempted to set the quinary (5th) tolerance for check %d (%s)\n",errnumber,errname);
		  printf("this check has %d tolerances\n",ErrorLookup[errnumber].numthresholds);
		  ExitWrapper(-1);
		}
	      else
		{
		  sprintf(message,"bad input in inspection specification file %s, line %d.\n\
Attempted to set the quinary (5th) tolerance for check %d (%s)\n\
This check has %d tolerances.\n\
Terminating load of this file at the location of this error.\n",
			  exefile,line,errnumber,errname,ErrorLookup[errnumber].numthresholds);

		  not_while_running(drawing_a,message,1524,"Bad Inspection Specification File",1);
		  fclose(optionfile);
		  return;	      
		}
	    }

	  Ijunk = SetQuinarySensitivity(errnumber,instance,errname,sensitivity,line,exefile);
	  if(Ijunk<0)
	    {
	      fclose(optionfile);
	      return;	      
	    }

	  if(BATCHDEBUG==1)
	    printf("** set quinary tolerance for condition %d instance %d to %lf\n",errnumber,instance,sensitivity);
	}

    else if(!strcmp(arg3,"TOLERANCE_SENARY"))
	{
	  errname[0] = '\0';
	  arg2   [0] = '\0';

	  sscanf(aline,"%s %d %s %lf",errname,&instance,arg2,&sensitivity);	  
	  
	  if(ErrorLookup[errnumber].numthresholds<6)
	    {
	      if(batch_mode==1)
		{
		  printf("bad input in inspection specification file %s, line %d.\n",exefile,line);
		  printf("attempted to set the senary (6th) tolerance for check %d (%s)\n",errnumber,errname);
		  printf("this check has %d tolerances\n",ErrorLookup[errnumber].numthresholds);
		  ExitWrapper(-1);
		}
	      else
		{
		  sprintf(message,"bad input in inspection specification file %s, line %d.\n\
Attempted to set the senary (6th) tolerance for check %d (%s)\n\
This check has %d tolerances.\n\
Terminating load of this file at the location of this error.\n",
			  exefile,line,errnumber,errname,ErrorLookup[errnumber].numthresholds);

		  not_while_running(drawing_a,message,1525,"Bad Inspection Specification File",1);
		  fclose(optionfile);
		  return;	      
		}
	    }

	  Ijunk = SetSenarySensitivity(errnumber,instance,errname,sensitivity,line,exefile);
	  if(Ijunk<0)
	    {
	      fclose(optionfile);
	      return;	      
	    }

	  if(BATCHDEBUG==1)
	    printf("** set senary tolerance for condition %d instance %d to %lf\n",errnumber,instance,sensitivity);
	}







    else if(!strcmp(arg3,"INCLUDE_BOUNDARY_CONDITIONS"))
	{
	  errname[0] = '\0';
	  arg2   [0] = '\0';
	  arg3   [0] = '\0';

	  sscanf(aline,"%s %d %s %s",errname,&instance,arg2,arg3);	  
	  
	  if(ErrorLookup[errnumber].UseBorderCondsDefault==2)
	    {
	      if(batch_mode==1)
		{
		  printf("bad input in inspection specification file %s, line %d.\n",exefile,line);
		  printf("attempted to set INCLUDE_BOUNDARY_CONDITIONS for check %d (%s)\n",errnumber,errname);
		  printf("this is not legal for this inspection\n");
		  ExitWrapper(-1);
		}
	      else
		{
		  sprintf(message,"bad input in inspection specification file %s, line %d.\n\
Attempted to set INCLUDE_BOUNDARY_CONDITIONS for check %d (%s)\n\
This is not legal for this inspection.\n\
Terminating load of this file at the location of this error.\n",
			  exefile,line,errnumber,errname);

		  not_while_running(drawing_a,message,1525,"Bad Inspection Specification File",1);
		  fclose(optionfile);
		  return;	      
		}
	    }

	  if(!strcmp(arg3,"ON"))
	  {
        if(instance==1)
		{ 
          ErrorLookup[errnumber].UseBorderConds = 1;
		} 
        else
		{ 
          cloneindex = GetCloneIndex(instance-1,errnumber);

          CloneErrorLookup[cloneindex].UseBorderConds = 1;
		}
	  }
	  else if(!strcmp(arg3,"OFF"))
	  {
        if(instance==1)
		{ 
          ErrorLookup[errnumber].UseBorderConds = 0;
		} 
        else
		{ 
          cloneindex = GetCloneIndex(instance-1,errnumber);

          CloneErrorLookup[cloneindex].UseBorderConds = 0;
		}
	  }
	  else
	  {
        if(batch_mode==1)
		{
		  printf("bad input in inspection specification file %s, line %d.\n",exefile,line);
		  printf("attempted to set INCLUDE_BOUNDARY_CONDITIONS for check %d (%s) to \"%s\"\n",errnumber,errname,arg3);
		  printf("INCLUDE_BOUNDARY_CONDITIONS may only be set to \"ON\" or \"OFF\"\n");
		  ExitWrapper(-1);
		}
	    else
		{
		  sprintf(message,"bad input in inspection specification file %s, line %d.\n\
Attempted to set INCLUDE_BOUNDARY_CONDITIONS for check %d (%s)\n\
This is not legal for this inspection.\n\
Terminating load of this file at the location of this error.\n",
			  exefile,line,errnumber,errname);

		  not_while_running(drawing_a,message,1540,"Bad Inspection Specification File",1);
		  fclose(optionfile);
		  return;	      
		}
	  }

	  if(BATCHDEBUG==1)
	    printf("** set INCLUDE_BOUNDARY_CONDITIONS for condition %d instance %d to %s\n",errnumber,instance,arg3);

	}





      else if(
	      (!strcmp(arg3,"C_PRIMARY"))   ||
	      (!strcmp(arg3,"C_SECONDARY")) ||
	      (!strcmp(arg3,"C_TERTIARY")) 
	      )
	{
	  if(!strcmp(arg3,"C_PRIMARY"))       {level=1;}
	  else if(!strcmp(arg3,"C_SECONDARY")){level=2;}
	  else if(!strcmp(arg3,"C_TERTIARY")) {level=3;} 


	  errname[0] = '\0';
	  arg2   [0] = '\0';
	  arg3   [0] = '\0';
	  arg4   [0] = '\0';
	  

	  sscanf(aline,"%s %d %s %s %s",errname,&instance,arg2,arg3,arg4);

	  if(NGA_TYPE==1)
	    {
	      if(!strcmp(arg4,"on"))
		{setting = 1;}
	      else if(!strcmp(arg4,"off"))
		{setting = 0;}
	      else
		{
		  printf("bad input in inspection specification file %s, line %d.\n",exefile,line);
		  printf("expected \"on\" or \"off\", got: %s\n",arg4);
		  ExitWrapper(-1);
		}

	      actornumber = ParseNGACNumber(arg3,line,exefile,level,errnumber);

	      if(actornumber<-100)
		{
		  fclose(optionfile);
		  return;	      
		}
	      
	      if(actornumber>0)
		{
		  if(cloneindex>=0)
		    {
		      

		      CloneErrorLookup[cloneindex].AllConfigOn[level][actornumber] = setting;
		    }
		  else
		    {
		      
		      ErrorLookup[errnumber].AllConfigOn[level][actornumber] = setting;
		    }
		  
		}
	      else
		{
		  actornumber = actornumber * -1;

		  if(cloneindex>=0)
		    {
		      
		      CloneErrorLookup[cloneindex].SpecifiedConfigOn[level][actornumber] = setting;
		    }
		  else
		    {
		      
		      ErrorLookup[errnumber].SpecifiedConfigOn[level][actornumber] = setting;
		    }
		}
	      
	    }
	  else
	    {
	      
	  
	      actornumber = ParseCNumber(arg3,line,exefile);
	      
	      if(actornumber<0)
		{
		  fclose(optionfile);
		  return;	      
		}
	      
	      
	      
	      
	      if( (!strcmp(arg4,"on")) || (!strcmp(arg4,"off")))
		{
		  if(!strcmp(arg4,"on")){setting = 1;}
		  else{setting = 0;}
		  
		  if(BATCHDEBUG==1)
		    printf("** for condition %d, instance %d turn level %d C:%d to %d\n",
			   errnumber,instance,level,actornumber,setting);
		  
		  if(level==1)
		    {
		      if(actornumber==100)
			{
			  for(i=0;i<NUM_C;i++)
			    {			  
			      if(cloneindex>=0)
				{
				  if(CloneErrorLookup[cloneindex].Config1[i]!=2)
				    {
				      CloneErrorLookup[cloneindex].Config1[i] = setting;
				    }
				}
			      else
				{
				  if(ErrorLookup[errnumber].Config1[i]!=2)
				    {
				      ErrorLookup[errnumber].Config1[i] = setting;
				    }
				}
			    }
			}
		      else if(ErrorLookup[errnumber].Config1[actornumber]==2)
			{
			  if(batch_mode==1)
			    {
			      printf("bad input in inspection specification file %s, line %d.\n",exefile,line);
			      printf("attempted to modify primary configuration %s for condition type %s\n",arg2,errname);
			      printf("this configuration is not defined for this condition.\n");
			      ExitWrapper(-1);
			    }
			  else
			    {
			      sprintf(message,"Bad input in inspection specification file %s, line %d:\n\
Attempted to modify primary configuration %s for condition type %s.\n\
This configuration is not defined for this condition.\n\
Terminating load of this file at the location of this error.\n",exefile,line,arg2,errname);
			      
			      not_while_running(drawing_a,message,1346,"Bad Inspection Specification File",1);
			      fclose(optionfile);
			      return;	      
			      
			    }
			}
		      else
			{
			  if(cloneindex>=0)
			    {
			      CloneErrorLookup[cloneindex].Config1[actornumber] = setting;
			    }
			  else
			    {
			      ErrorLookup[errnumber].Config1[actornumber] = setting;
			    }
			}
		    }
		  
		  
		  
		  
		  
		  else if(level==2)
		    {
		      if(actornumber==100)
			{
			  for(i=0;i<NUM_C;i++)
			    {
			      if(cloneindex>=0)
				{
				  if(CloneErrorLookup[cloneindex].Config2[i]!=2)
				    {
				      CloneErrorLookup[cloneindex].Config2[i] = setting;
				    }
				}
			      else
				{
				  if(ErrorLookup[errnumber].Config2[i]!=2)
				    {
				      ErrorLookup[errnumber].Config2[i] = setting;
				    }
				}
			    }
			}
		      else if(ErrorLookup[errnumber].Config2[actornumber]==2)
			{
			  if(batch_mode==1)
			    {
			      printf("bad input in inspection specification file %s, line %d.\n",exefile,line);
			      printf("attempted to modify secondary configuration %s for condition type %s\n",arg2,errname);
			      printf("this configuration is not defined for this condition.\n");
			      ExitWrapper(-1);
			    }
			  else
			    {
			      sprintf(message,"Bad input in inspection specification file %s, line %d:\n\
Attempted to modify secondary configuration %s for condition type %s\n\
This configuration is not defined for this condition.\n\
Terminating load of this file at the location of this error.\n",exefile,line,arg2,errname);
			      not_while_running(drawing_a,message,1347,"Bad Inspection Specification File",1);
			      fclose(optionfile);
			      return;	      
			    }
			}
		      else
			{
			  if(cloneindex>=0)
			    {
			      CloneErrorLookup[cloneindex].Config2[actornumber] = setting;
			    }
			  else
			    {
			      ErrorLookup[errnumber].Config2[actornumber] = setting;
			    }
			}
		    }
		  
		  
		  
		  
		  else if(level==3)
		    {
		      if(actornumber==100)
			{
			  for(i=0;i<NUM_C;i++)
			    {
			      if(cloneindex>=0)
				{
				  if(CloneErrorLookup[cloneindex].Config3[i]!=2)
				    {
				      CloneErrorLookup[cloneindex].Config3[i] = setting;
				    }
				}
			      else
				{
				  if(ErrorLookup[errnumber].Config3[i]!=2)
				    {
				      ErrorLookup[errnumber].Config3[i] = setting;
				    }
				}
			    }
			}
		      else if(ErrorLookup[errnumber].Config3[actornumber]==2)
			{
			  if(batch_mode==1)
			    {
			      printf("bad input in inspection specification file %s, line %d.\n",exefile,line);
			      printf("attempted to modify tertiary configuration %s for condition type %s\n",arg2,errname);
			      printf("this configuration is not defined for this condition.\n");
			      ExitWrapper(-1);
			    }
			  else
			    {
			      sprintf(message,"Bad input in inspection specification file %s, line %d:\n\
Attempted to modify tertiary configuration %s for condition type %s\n\
This configuration is not defined for this condition.\n\
Terminating load of this file at the location of this error.\n",exefile,line,arg2,errname);
			      not_while_running(drawing_a,message,1348,"Bad Inspection Specification File",1);			  
			      fclose(optionfile);
			      return;	 
			    }
			}
		      else
			{
			  if(cloneindex>=0)
			    {
			      CloneErrorLookup[cloneindex].Config3[actornumber] = setting;
			    }
			  else
			    {
			      ErrorLookup[errnumber].Config3[actornumber] = setting;
			    }
			}
		    }
		}
	      else
		{
		  if(batch_mode==1)
		    {
		      printf("bad input in inspection specification file %s, line %d.\n",exefile,line);
		      printf("expected \"on\" or \"off\", got: %s\n",arg4);
		      ExitWrapper(-1);
		    }
		  else
		    {
		      sprintf(message,"Bad input in inspection specification file %s, line %d:\n\
Expected \"on\" or \"off\", got: %s\n\
Terminating load of this file at the location of this error.\n",exefile,line,arg4);
		      not_while_running(drawing_a,message,1349,"Bad Inspection Specification File",1);
		      fclose(optionfile);
		      return;	 
		    }
		}
	    }
	}


      else if(
	      (!strcmp(arg3,"TOLERANCE_PRIMARY_OFF"))    ||
	      (!strcmp(arg3,"TOLERANCE_SECONDARY_OFF"))  ||
	      (!strcmp(arg3,"TOLERANCE_TERTIARY_OFF"))   ||
	      (!strcmp(arg3,"TOLERANCE_QUATERNARY_OFF")) ||
	      (!strcmp(arg3,"TOLERANCE_QUINARY_OFF"))    ||
	      (!strcmp(arg3,"TOLERANCE_SENARY_OFF"))
	      )
	  {
          if(cloneindex>=0)
		  {
			  if(!strcmp(arg3,"TOLERANCE_PRIMARY_OFF"))    {CloneErrorLookup[cloneindex].use_sen1 = 0;}
			  if(!strcmp(arg3,"TOLERANCE_SECONDARY_OFF"))  {CloneErrorLookup[cloneindex].use_sen2 = 0;}
			  if(!strcmp(arg3,"TOLERANCE_TERTIARY_OFF"))   {CloneErrorLookup[cloneindex].use_sen3 = 0;}
			  if(!strcmp(arg3,"TOLERANCE_QUATERNARY_OFF")) {CloneErrorLookup[cloneindex].use_sen4 = 0;}
			  if(!strcmp(arg3,"TOLERANCE_QUINARY_OFF"))    {CloneErrorLookup[cloneindex].use_sen5 = 0;}
			  if(!strcmp(arg3,"TOLERANCE_SENARY_OFF"))     {CloneErrorLookup[cloneindex].use_sen6 = 0;}
		  }
		  else
		  {
			  if(!strcmp(arg3,"TOLERANCE_PRIMARY_OFF"))    {ErrorLookup[errnumber].use_sen1 = 0;}
			  if(!strcmp(arg3,"TOLERANCE_SECONDARY_OFF"))  {ErrorLookup[errnumber].use_sen2 = 0;}
			  if(!strcmp(arg3,"TOLERANCE_TERTIARY_OFF"))   {ErrorLookup[errnumber].use_sen3 = 0;}
			  if(!strcmp(arg3,"TOLERANCE_QUATERNARY_OFF")) {ErrorLookup[errnumber].use_sen4 = 0;}
			  if(!strcmp(arg3,"TOLERANCE_QUINARY_OFF"))    {ErrorLookup[errnumber].use_sen5 = 0;}
			  if(!strcmp(arg3,"TOLERANCE_SENARY_OFF"))     {ErrorLookup[errnumber].use_sen6 = 0;}
		  }	    
	  }

      else if(
	      (!strcmp(arg3,"S_PRIMARY"))   ||
	      (!strcmp(arg3,"S_SECONDARY")) ||
	      (!strcmp(arg3,"S_TERTIARY")) 
	      )
	{
	  if(NGA_TYPE==1)
	    {
	      sprintf(message,"Bad input in inspection specification file %s, line %d:  %s\n",exefile,line,arg3);
	      not_while_running(drawing_a,message,1350,"Bad Inspection Specification File",1);
	      fclose(optionfile);
	      return;	 
	    }


	  if(!strcmp(arg3,"S_PRIMARY"))       {level=1;}
	  else if(!strcmp(arg3,"S_SECONDARY")){level=2;}
	  else if(!strcmp(arg3,"S_TERTIARY")) {level=3;} 


	  errname[0] = '\0';
	  arg2   [0] = '\0';
	  arg3   [0] = '\0';
	  arg4   [0] = '\0';

	  sscanf(aline,"%s %d %s %s %s",errname,&instance,arg2,arg3,arg4);
	  actornumber = ParseSNumber(arg3,line,exefile);
	  if(actornumber<0)
	    {
	      fclose(optionfile);
	      return;	      
	    }


	  if( (!strcmp(arg4,"on")) || (!strcmp(arg4,"off")))
	    {
	      if(!strcmp(arg4,"on")){setting = 1;}
	      else{setting = 0;}
	      
	      if(BATCHDEBUG==1)
		printf("** for condition %d, instance %d, turn level %d S:%d to %d\n",
		       errnumber,instance,level,actornumber,setting);
	      
	      if(level==1)
		{
		  if(actornumber==100)
		    {
		      for(i=0;i<NUM_S;i++)
			{
			  if(cloneindex>=0)
			    {
			      if(CloneErrorLookup[cloneindex].Stratum1[i]!=2)
				{
				  CloneErrorLookup[cloneindex].Stratum1[i] = setting;
				}
			    }
			  else
			    {
			      if(ErrorLookup[errnumber].Stratum1[i]!=2)
				{
				  ErrorLookup[errnumber].Stratum1[i] = setting;
				}
			    }
			}
		    }
		  else if(ErrorLookup[errnumber].Stratum1[actornumber]==2)
		    {
		      if(batch_mode==1)
			{
			  printf("bad input in inspection specification file %s, line %d.\n",exefile,line);
			  printf("attempted to modify primary stratum %s for condition type %s\n",arg2,errname);
			  printf("this stratum is not defined for this condition.\n");
			  ExitWrapper(-1);
			}
		      else
			{
			  sprintf(message,"Bad input in inspection specification file %s, line %d:\n\
Attempted to modify primary stratum %s for condition type %s.\n\
This stratum is not defined for this condition.\n\
Terminating load of this file at the location of this error.\n",exefile,line,arg2,errname);
			  not_while_running(drawing_a,message,1351,"Bad Inspection Specification File",1);
			  fclose(optionfile);
			  return;	 
			}
		    }
		  else
		    {
		      if(cloneindex>=0)
			{
			  CloneErrorLookup[cloneindex].Stratum1[actornumber] = setting;
			}
		      else
			{
			  ErrorLookup[errnumber].Stratum1[actornumber] = setting;
			}
		    }
		}


	      else if(level==2)
		{
		  if(actornumber==100)
		    {
		      for(i=0;i<NUM_S;i++)
			{
			  if(cloneindex>=0)
			    {
			      if(CloneErrorLookup[cloneindex].Stratum2[i]!=2)
				{
				  CloneErrorLookup[cloneindex].Stratum2[i] = setting;
				}
			    }
			  else
			    {
			      if(ErrorLookup[errnumber].Stratum2[i]!=2)
				{
				  ErrorLookup[errnumber].Stratum2[i] = setting;
				}
			    }
			}
		    }
		  else if(ErrorLookup[errnumber].Stratum2[actornumber]==2)
		    {
		      if(batch_mode==1)
			{
			  printf("bad input in inspection specification file %s, line %d.\n",exefile,line);
			  printf("attempted to modify secondary stratum %s for condition type %s\n",arg2,errname);
			  printf("this stratum is not defined for this condition.\n");
			  ExitWrapper(-1);
			}
		      else
			{
			  sprintf(message,"Bad input in inspection specification file %s, line %d:\n\
Attempted to modify secondary stratum %s for condition type %s.\n\
This stratum is not defined for this condition.\n\
Terminating load of this file at the location of this error.\n",exefile,line,arg2,errname);
			  not_while_running(drawing_a,message,1352,"Bad Inspection Specification File",1);
			  fclose(optionfile);
			  return;	 			  
			}
		    }
		  else
		    {
		      if(cloneindex>=0)
			{
			  CloneErrorLookup[cloneindex].Stratum2[actornumber] = setting;
			}
		      else
			{
			  ErrorLookup[errnumber].Stratum2[actornumber] = setting;
			}
		    }
		}


	      else if(level==3)
		{
		  if(actornumber==100)
		    {
		      for(i=0;i<NUM_S;i++)
			{
			  if(cloneindex>=0)
			    {
			      if(CloneErrorLookup[cloneindex].Stratum3[i]!=2)
				{
				  CloneErrorLookup[cloneindex].Stratum3[i] = setting;
				}
			    }
			  else
			    {
			      if(ErrorLookup[errnumber].Stratum3[i]!=2)
				{
				  ErrorLookup[errnumber].Stratum3[i] = setting;
				}
			    }
			}
		    }
		  else if(ErrorLookup[errnumber].Stratum3[actornumber]==2)
		    {
		      if(batch_mode==1)
			{
			  printf("bad input in inspection specification file %s, line %d.\n",exefile,line);
			  printf("attempted to modify tertiary stratum %s for condition type %s\n",arg2,errname);
			  printf("this stratum is not defined for this condition.\n");
			  ExitWrapper(-1);
			}
		      else
			{
			  sprintf(message,"Bad input in inspection specification file %s, line %d:\n\
Attempted to modify tertiary stratum %s for condition type %s.\n\
This stratum is not defined for this condition.\n\
Terminating load of this file at the location of this error.\n",exefile,line,arg2,errname);
			  not_while_running(drawing_a,message,1353,"Bad Inspection Specification File",1);
			  fclose(optionfile);
			  return;	 			  
			}
		    }
		  else
		    {
		      if(cloneindex>=0)
			{
			  CloneErrorLookup[cloneindex].Stratum3[actornumber] = setting;
			}
		      else
			{
			  ErrorLookup[errnumber].Stratum3[actornumber] = setting;
			}
		    }
		}
	    }
	  else
	    {
	      if(batch_mode==1)
		{
		  printf("bad input in inspection specification file %s, line %d.\n",exefile,line);
		  printf("expected \"on\" or \"off\", got: %s\n",arg4);
		  ExitWrapper(-1);
		}
	      else
		{
		  sprintf(message,"Bad input in inspection specification file %s, line %d.\n\
Expected \"on\" or \"off\", got: %s\n\
Terminating load of this file at the location of this error.\n",exefile,line,arg4);
		  not_while_running(drawing_a,message,1354,"Bad Inspection Specification File",1);
		  fclose(optionfile);
		  return;	 			  
		}
	    }
	}


      else if(
	      (!strcmp(arg3,"D_PRIMARY"))   ||
	      (!strcmp(arg3,"D_SECONDARY")) ||
	      (!strcmp(arg3,"D_TERTIARY")) 
	      )
	{

	  if(NGA_TYPE==1)
	    {
	      sprintf(message,"Bad input in inspection specification file %s, line %d:  %s\n",exefile,line,arg3);
	      not_while_running(drawing_a,message,1355,"Bad Inspection Specification File",1);
	      fclose(optionfile);
	      return;	 
	    }

	  if(!strcmp(arg3,"D_PRIMARY"))       {level=1;}
	  else if(!strcmp(arg3,"D_SECONDARY")){level=2;}
	  else if(!strcmp(arg3,"D_TERTIARY")) {level=3;} 


	  errname[0] = '\0';
	  arg2   [0] = '\0';
	  arg3   [0] = '\0';
	  arg4   [0] = '\0';

	  sscanf(aline,"%s %d %s %s %s",errname,&instance,arg2,arg3,arg4);	  
	  actornumber = ParseDNumber(arg3,line,exefile);

	  if(actornumber<0)
	    {
	      fclose(optionfile);
	      return;	 			  
	    }
	  
	  if( (!strcmp(arg4,"on")) || (!strcmp(arg4,"off")))
	    {
	      if(!strcmp(arg4,"on")){setting = 1;}
	      else{setting = 0;}
	     
	      if(BATCHDEBUG==1)
		printf("** for condition %d, instance %d turn level %d D:%d to %d\n",
		       errnumber,instance,level,actornumber,setting);
		
	      
	      if(level==1)
		{
		  if(actornumber==100)
		    {
		      for(i=0;i<NUM_D;i++)
			{
			  if(cloneindex>=0)
			    {
			      if(CloneErrorLookup[cloneindex].Domain1[i]!=2)
				{
				  CloneErrorLookup[cloneindex].Domain1[i] = setting;
				}
			    }
			  else
			    {
			      if(ErrorLookup[errnumber].Domain1[i]!=2)
				{
				  ErrorLookup[errnumber].Domain1[i] = setting;
				}
			    }
			}
		    }
		  else if(ErrorLookup[errnumber].Domain1[actornumber]==2)
		    {
		      if(batch_mode==1)
			{
			  printf("bad input in inspection specification file %s, line %d.\n",exefile,line);
			  printf("attempted to modify primary Domain %s for condition type %s\n",arg2,errname);
			  printf("this Domain is not defined for this condition.\n");
			  ExitWrapper(-1);
			}
		      else
			{
			  sprintf(message,"Bad input in inspection specification file %s, line %d:\n\
Attempted to modify primary Domain %s for condition type %s.\n\
This Domain is not defined for this condition.\n\
Terminating load of this file at the location of this error.\n",exefile,line,arg2,errname);
			  not_while_running(drawing_a,message,1356,"Bad Inspection Specification File",1);
			  fclose(optionfile);
			  return;
			}
		    }
		  else
		    {
		      if(cloneindex>=0)
			{
			  CloneErrorLookup[cloneindex].Domain1[actornumber] = setting;
			}
		      else
			{
			  ErrorLookup[errnumber].Domain1[actornumber] = setting;
			}
		    }
		}


	      else if(level==2)
		{
		  if(actornumber==100)
		    {
		      for(i=0;i<NUM_D;i++)
			{
			  if(cloneindex>=0)
			    {
			      if(CloneErrorLookup[cloneindex].Domain2[i]!=2)
				{
				  CloneErrorLookup[cloneindex].Domain2[i] = setting;
				}
			    }
			  else
			    {
			      if(ErrorLookup[errnumber].Domain2[i]!=2)
				{
				  ErrorLookup[errnumber].Domain2[i] = setting;
				}
			    }
			}
		    }
		  else if(ErrorLookup[errnumber].Domain2[actornumber]==2)
		    {
		      if(batch_mode==1)
			{
			  printf("bad input in inspection specification file %s, line %d.\n",exefile,line);
			  printf("attempted to modify secondary Domain %s for condition type %s\n",arg2,errname);
			  printf("this Domain is not defined for this condition.\n");
			  ExitWrapper(-1);
			}
		      else
			{
			  sprintf(message,"Bad input in inspection specification file %s, line %d:\n\
Attempted to modify secondary Domain %s for condition type %s.\n\
This Domain is not defined for this condition.\n\
Terminating load of this file at the location of this error.\n",exefile,line,arg2,errname);
			  not_while_running(drawing_a,message,1357,"Bad Inspection Specification File",1);
			  fclose(optionfile);
			  return;
			}
		    }
		  else
		    {
		      if(cloneindex>=0)
			{
			  CloneErrorLookup[cloneindex].Domain2[actornumber] = setting;
			}
		      else
			{
			  ErrorLookup[errnumber].Domain2[actornumber] = setting;
			}
		    }
		}

	      else if(level==3)
		{
		  if(actornumber==100)
		    {
		      for(i=0;i<NUM_D;i++)
			{
			  if(cloneindex>=0)
			    {
			      if(CloneErrorLookup[cloneindex].Domain3[i]!=2)
				{
				  CloneErrorLookup[cloneindex].Domain3[i] = setting;
				}
			    }
			  else
			    {
			      if(ErrorLookup[errnumber].Domain3[i]!=2)
				{
				  ErrorLookup[errnumber].Domain3[i] = setting;
				}
			    }
			}
		    }
		  else if(ErrorLookup[errnumber].Domain3[actornumber]==2)
		    {
		      if(batch_mode==1)
			{
			  printf("bad input in inspection specification file %s, line %d.\n",exefile,line);
			  printf("attempted to modify tertiary Domain %s for condition type %s\n",arg2,errname);
			  printf("this Domain is not defined for this condition.\n");
			  ExitWrapper(-1);
			}
		      else
			{
			  sprintf(message,"Bad input in inspection specification file %s, line %d:\n\
Attempted to modify tertiary Domain %s for condition type %s.\n\
This Domain is not defined for this condition.\n\
Terminating load of this file at the location of this error.\n",exefile,line,arg2,errname);
			  not_while_running(drawing_a,message,1358,"Bad Inspection Specification File",1);
			  fclose(optionfile);
			  return;
			}
		    }
		  else
		    {
		      if(cloneindex>=0)
			{
			  CloneErrorLookup[cloneindex].Domain3[actornumber] = setting;
			}
		      else
			{
			  ErrorLookup[errnumber].Domain3[actornumber] = setting;
			}
		    }
		}
	    }
	  else
	    {
	      if(batch_mode==1)
		{
		  printf("bad input in inspection specification file %s, line %d.\n",exefile,line);
		  printf("expected \"on\" or \"off\", got: %s\n",arg4);
		  ExitWrapper(-1);
		}
	      else
		{
		  sprintf(message,"Bad input in inspection specification file %s, line %d:\n\
Expected \"on\" or \"off\", got: %s\n\
Terminating load of this file at the location of this error.\n",exefile,line,arg4);
		  not_while_running(drawing_a,message,1359,"Bad Inspection Specification File",1);
		  fclose(optionfile);
		  return;
		}
	    }
	}
      else
	{
	  if(batch_mode==1)
	    {
	      printf("\nbad input in inspection specification file %s, line %d\n",exefile,line);
	      printf("expected any of:\n\
\"TOLERANCE_PRIMARY\", \"TOLERANCE_SECONDARY\",\n\
\"TOLERANCE_TERTIARY\", \"TOLERANCE_QUARTENARY\",\n\
\"TOLERANCE_QUINARY\", \"TOLERANCE_SENARY\",\n\
\"ANNOTATION\"\n\
\"C_PRIMARY\",\"C_SECONDARY\",\"C_TERTIARY\",\n\
\"S_PRIMARY\",\"S_SECONDARY\",\"S_TERTIARY\",\n\
\"D_PRIMARY\",\"D_SECONDARY\",\"D_TERTIARY\".\n\
Got: %s\n",arg3);
	      ExitWrapper(-1);
	    }
	  else
	    {
	      sprintf(message,"Bad input in inspection specification file %s, line %d:\n\
Expected any of:\n\
\"TOLERANCE_PRIMARY\", \"TOLERANCE_SECONDARY\",\n\
\"TOLERANCE_TERTIARY\", \"TOLERANCE_QUARTENARY\",\n\
\"TOLERANCE_QUINARY\", \"TOLERANCE_SENARY\",\n\
\"ANNOTATION\"\n\
\"C_PRIMARY\",\"C_SECONDARY\",\"C_TERTIARY\",\n\
\"S_PRIMARY\",\"S_SECONDARY\",\"S_TERTIARY\",\n\
\"D_PRIMARY\",\"D_SECONDARY\",\"D_TERTIARY\".\n\
Got: %s\n\
Terminating load of this file at the location of this error.\n",exefile,line,arg3);
	      not_while_running(drawing_a,message,1360,"Bad Inspection Specification File",1);
	      fclose(optionfile);
	      return;
	    }
	}
      fgets(aline,1000,optionfile);
      line++;
    }
  fclose(optionfile);

}




char *GetADDType(int ADDER)
{
  if(ADDER==0)
    {
      return "off";
    }
  else if(ADDER==1)
    {
      return "on";
    }
  else
    {
      printf("bad adder type to getadd %d\n",ADDER);
      ExitWrapper(-1);
    }
  return "!!";
}



int FindUnique(int modelindex,char interesting[])
{
  int i;

  

  for(i=0;i<MdlNames[modelindex].numuniqueAttr;i++)
    {      
      

      if(
	 ((NGA_TYPE==0)&&(!strcmp(interesting,GetEACLabel(GetCode(modelindex,i))))) ||
	 ((NGA_TYPE==1)&&(!strcmp(MakeCleanString(interesting),
				  MakeCleanString2(GetEACLabel(GetCode(modelindex,i))))))
	 )
	 
	{
	  return i;
	}
    }

  printf("Unable to find %s as a unique attribute of scc index %d\n",interesting,modelindex);

  return 0;

}


int TestAxis(int errnum, int axis, int geomtype, char *edcsfile, int line)
{
  char message[1000];
  int founderr=0;


  if(NGA_TYPE==0)
  {
	
	return 1;
  }

  if(axis==1)
  {
    if(ErrorLookup[errnum].Config1[geomtype]==2)
	{
	  founderr = 1;
	}
  }
  else if(axis==2)
  {
    if(ErrorLookup[errnum].Config2[geomtype]==2)
	{
	  founderr = 1;
	}
  }
  else if(axis==3)
  {
    if(ErrorLookup[errnum].Config3[geomtype]==2)
	{
	  founderr = 1;
	}
  }
  else
  {
	  
	  printf("Bad input in file:\n %s,\n   line %d:\n\
Internal error: got bad axis %d for %s\n\
Terminating load of this file at the location of this error.",
		  edcsfile,line,axis,ParseErrName(errnum));
	  return 0;
  }



  if(founderr==1)
  {
    sprintf(message,"Bad input in file:\n %s,\n   line %d\n\
Geometric type %s is not valid as the %s participant for %s\n\
Terminating load of this file at the location of this error.",
edcsfile,line,ParseCName(geomtype),ParseAxisName(axis),ParseErrName(errnum));

    not_while_running(drawing_a,message,1482,"Bad Inspection Specification File",1);
    return 0;
  }

  return 1;
}



int AddNewSACEntry(int SCCindex,int SACindex,int EEindex,int errnum,int clonenum, int axis, int ADDER, int geomtype, char *edcsfile, int line)
{
  struct IMarkSACList *Ncfl;
  struct IMarkSACList *Iroot;
  int cloneindex;


  if(TestAxis(errnum,axis,geomtype,edcsfile,line)==0)
  {
	return 0;
  }


  if(clonenum==0)
    {
      Iroot = ErrorLookup[errnum].IMarkSACRoot[axis][ADDER][geomtype];
    }
  else
    {
      cloneindex = GetCloneIndex(clonenum,errnum);
      Iroot = CloneErrorLookup[cloneindex].IMarkSACRoot[axis][ADDER][geomtype];
    }


  while(Iroot!=NULL)
    {
      if(
	     (Iroot->SCCindex==SCCindex)  &&
	     (Iroot->SACindex==SACindex)  &&
	     (Iroot->EEindex ==EEindex)  
	    ) 
	  {  
	    
	    return 1;
	  }
      Iroot = Iroot->next;
    }




  Ncfl = (struct IMarkSACList *) malloc(sizeof(struct IMarkSACList));
  if(Ncfl == NULL)
    { printf("Imark: Out of allocation memory\n"); ExitWrapper(-1); }

  Ncfl->SCCindex = SCCindex;
  Ncfl->SACindex = SACindex;
  Ncfl->EEindex  = EEindex; 



  if(clonenum==0)
    {      
      Ncfl->next = ErrorLookup[errnum].IMarkSACRoot[axis][ADDER][geomtype];
      ErrorLookup[errnum].IMarkSACRoot[axis][ADDER][geomtype] = Ncfl;
      ErrorLookup[errnum].sac_index[axis][ADDER][geomtype]++;
    }
  else
    {
      Ncfl->next = CloneErrorLookup[cloneindex].IMarkSACRoot[axis][ADDER][geomtype];
      CloneErrorLookup[cloneindex].IMarkSACRoot[axis][ADDER][geomtype] = Ncfl;
      CloneErrorLookup[cloneindex].sac_index[axis][ADDER][geomtype]++;
    }
  return 1;
}



int BatchIsLongAttr(char *squishEAL)
{
  int SAC;


  for(SAC=0;SAC<NumberOfAttributesEntries;SAC++)
  {

   if(MdlNames2[SAC].count<0)
	{
      if(!strcmp(
		          MakeCleanString(GetEACLabel(MdlNames2[SAC].code)),
		          MakeCleanString2(squishEAL)
				)
		)
	  {
	    return MdlNames2[SAC].code;
	  }
	}
  }

  return -1;
}



int HandleLongAttr(int long_attr_code,double Dvalue,double Dvalue2,int errnum,
				   int clonenum,int axis,int ADDER,int geomtype,
				   char *classname, int number_or_string, char *TheString)
{
  int num,i,SCC,SAC,foundboth,foundit,cloneindex,this_SCC;
  struct IMarkSACList *cfl;
  static int saved = -12345,saved_SCC=-12345,saved_geomtype=-12345,savenum=0;
  extern int old_long_attr_style;

  if(number_or_string==1)
    {
      Dvalue  = Dvalue  - SMALLAMOUNT;
      Dvalue2 = Dvalue2 + SMALLAMOUNT;
    }


  if((long_attr_code==-12345)&&(saved!=-12345))
  {
    

	

    for(i=0;i<savenum;i++)
	{ 	
	  free(LongValueList[i]);
	} 

    free(LongValueList);
    free(LongDValueList);

    saved          = -12345;
	saved_SCC      = -12345;
	saved_geomtype = -12345;
	savenum   = 0;
	return 1;
  }





  

  foundboth = -1;

  for(SCC=0;SCC<NumberOfModels;SCC++)
  {
   if(!strcmp(
	   MakeCleanString(GetECCLabel(MdlNames[SCC].code)),
	   MakeCleanString2(classname)
	   ))
   {
	 if(
		 ((geomtype==C_POFE)&&(!strcmp(MdlNames[SCC].name,"(POINT)"))) ||
		 ((geomtype==C_LINE)&&(!strcmp(MdlNames[SCC].name,"(LINE)"))) ||
		 ((geomtype==C_AREA)&&(!strcmp(MdlNames[SCC].name,"(AREA)")))
		 )
	 {

	   
	   for(SAC=0;SAC<MdlNames[SCC].numuniqueAttr;SAC++)
	   {
		   if(long_attr_code==GetCode(SCC,SAC))
		   {
			   foundboth = 1;
			   this_SCC = SCC;
			   break;
		   }
	   }
	   break;
	 }
   }
  }


  if(foundboth==-1)
  {
	return 0;
  }




  if(clonenum>0)
  {
    cloneindex = GetCloneIndex(clonenum,errnum);
  }


  
  
  if((saved!=long_attr_code)||(saved_geomtype!=geomtype)||(saved_SCC!=this_SCC))
  {
    
    if(savenum>0)
	{
      for(i=0;i<savenum;i++)
	  {  	
	    free(LongValueList[i]);
	  }  

      free(LongValueList);
      free(LongDValueList);
	}

	  if(old_long_attr_style==0)
	  {
        num = BuildLongAttrValList(SCC,long_attr_code,NULL,0,1);
	  }
	  else
	  {
        num = BuildLongAttrValList(SCC,long_attr_code,NULL,0,0);
	  }


    savenum = num;
    saved = long_attr_code;
	saved_SCC = this_SCC;
	saved_geomtype = geomtype;
  }
  else
  {

    

    num = savenum;
  }


  

  foundit = 0;

  for(i=0;i<num;i++)
  {
	if(i>0)
	{
	  if(number_or_string==1)
	    {
	      if(LongDValueList[i]==LongDValueList[i-1])
		{
		  
		  continue;
		}
	    }

	  if(!strcmp(LongValueList[i],LongValueList[i-1]))
	    {
	      
	      continue;
	    }
	}


	if(
	     ( (number_or_string==1) && ((LongDValueList[i]>=Dvalue)&&(LongDValueList[i]<=Dvalue2)) ) ||
	     ( (number_or_string==0) && (!strcmp(TheString,LongValueList[i])) )
	  )
	{
	 foundit = 1;
	 cfl = (struct IMarkSACList *) malloc(sizeof(struct IMarkSACList));
	 if(cfl == NULL)
	  { printf("Imark2: Out of allocation memory\n"); ExitWrapper(-1); }
	 cfl->SCCindex = SCC;
	 cfl->SACindex = SAC;
	 cfl->EEindex  = -2;


	 

	 cfl->saveval = (char *)malloc(strlen(LongValueList[i])+3);
	 sprintf(cfl->saveval,"%s",LongValueList[i]);


	 if(clonenum==0)
	  {
	    cfl->next = ErrorLookup[errnum].IMarkSACRoot[axis][ADDER][geomtype];
	    ErrorLookup[errnum].IMarkSACRoot[axis][ADDER][geomtype] = cfl;
        ErrorLookup[errnum].sac_index[axis][ADDER][geomtype]++;
	  }
	 else
	  {
	    cfl->next = CloneErrorLookup[cloneindex].IMarkSACRoot[axis][ADDER][geomtype];
	    CloneErrorLookup[cloneindex].IMarkSACRoot[axis][ADDER][geomtype] = cfl;
        CloneErrorLookup[cloneindex].sac_index[axis][ADDER][geomtype]++;
	  }
	}
  }

  

  return foundit;
}


void HandleBadInput()
{
  
}




int IBetween(double lowval,double highval,double testval)
{
  lowval  = lowval  - SMALLAMOUNT;
  highval = highval + SMALLAMOUNT;
  if(testval<lowval)
    {
      return 0;
    }
  if(testval>highval)
    {
      return 0;
    }
  return 1;
}

int IRangeBetween(double lowval,double highval,double lowtestval, double hightestval)
{
  lowval  = lowval  - SMALLAMOUNT;
  highval = highval + SMALLAMOUNT;

  if(lowtestval<lowval)
    {
      return 0;
    }
  if(hightestval>highval)
    {
      return 0;
    }
  return 1;
}







int DoBatchEDCSStuff(Widget w,char * edcsfile,int lines_to_skip, int verbose)
{
  FILE *edcs_in;
  char aline[1100],errname[100], axisname[100], classname[100], valarg[100], 
	  onoff[100],value[100],value2[100],valtype[100],thislabel[500], 
	  geomstring[100],message[500],cleaned[1000];
  int axis,instance,line=0,axisnum,errnum,ADDER,foundone,i,j,k,thisindex,thatindex,
	  clonenum,cloneindex,bad_lines=0,interesting,long_attr_code,pass,first,last;
  double Dvalue,Dvalue2,tempD;
  struct IMarkList *cfl;
  int geomtype=0;  
  extern int free_global_char_type;
  extern int old_long_attr_style;



  if(old_long_attr_style==0)
  {
    global_filter_cache = 0;  
    free_global_char_type = 0; 
  }

  


  

 for(errnum=1;errnum<=CONDITION_DEFINITIONS;errnum++)
    {

      for(i=0;i<=CONDITION_DEFINITIONS;i++)
	{
	  if(ErrorLookup[i].primaryEDCSstuff!=NULL)
	    {
	      free(ErrorLookup[i].primaryEDCSstuff);
	      ErrorLookup[i].primaryEDCSstuff = NULL;
	    } 
	  if(ErrorLookup[i].secondaryEDCSstuff!=NULL)
	    {
	      free(ErrorLookup[i].secondaryEDCSstuff);
	      ErrorLookup[i].secondaryEDCSstuff = NULL;
	    } 
	  if(ErrorLookup[i].tertiaryEDCSstuff!=NULL)
	    {
	      free(ErrorLookup[i].tertiaryEDCSstuff);
	      ErrorLookup[i].tertiaryEDCSstuff = NULL;
	    } 


  	  if(ErrorLookup[i].primaryFIDstuff!=NULL)
	    {
	      free(ErrorLookup[i].primaryFIDstuff);
	      ErrorLookup[i].primaryFIDstuff = NULL;
	    } 
	  if(ErrorLookup[i].secondaryFIDstuff!=NULL)
	    {
	      free(ErrorLookup[i].secondaryFIDstuff);
	      ErrorLookup[i].secondaryFIDstuff = NULL;
	    } 
	  if(ErrorLookup[i].tertiaryFIDstuff!=NULL)
	    {
	      free(ErrorLookup[i].tertiaryFIDstuff);
	      ErrorLookup[i].tertiaryFIDstuff = NULL;
	    } 

	}

      
      for(axis=1;axis<=3;axis++)
	{
	  for(ADDER=0;ADDER<=1;ADDER++)
	    {
	      if(ErrorLookup[errnum].model_index[axis][ADDER][geomtype]>0)
		{
		  ErrorLookup[errnum].model_index[axis][ADDER][geomtype]=0;
		}
	      
	      if(ErrorLookup[errnum].sac_index[axis][ADDER][geomtype]>0)
		{
		  ErrorLookup[errnum].sac_index[axis][ADDER][geomtype]=0;
		}
	    }
	}
    }

 ScrubALLEDCSMarkerLists(0,0);
	 


  
  edcs_in = fopen(edcsfile,"r");
  if(edcs_in==NULL)
    {
      if(batch_mode==1)
	{
	  printf("Could not open edcsfile %s for read\n",edcsfile);
	  ExitWrapper(-1);
	}
      else
	{
	  sprintf(message,"Could not open edcsfile %s for read\n",edcsfile);
	  not_while_running(drawing_a,message,1361,"Bad Inspection Specification File",1);
      global_filter_cache = 1;
      free_global_char_type = 1;
	  return -1;
	}
    }




  for(i=0;i<lines_to_skip;i++)
    {
      fgets(aline,1000,edcs_in);
      line++;
    }
  
  
  
  fgets(aline,1000,edcs_in);
  line++;
  while(!feof(edcs_in))
    {
      if(NGA_TYPE==1)
	{
	  sscanf(aline,"%s%d%s%s%s%s%s",
		 errname,
		 &instance,
		 axisname,
		 classname,
		 valarg,
		 onoff,
		 geomstring);
	}
      else
	{
	  sscanf(aline,"%s%d%s%s%s%s",
		 errname,
		 &instance,
		 axisname,
		 classname,
		 valarg,
		 onoff);
	  geomtype = 0;
	}




      errnum  = ParseErrNumberWrapper(errname,line,edcsfile);
      if(errnum<0)
	{
	  fclose(edcs_in);
      global_filter_cache = 1;
      free_global_char_type = 1;
	  return -1;	      
	}


	  if((SingleInstance(errnum))&&(instance>1))
	  {
		 
         
		 printf("Cannot (2) create multiple instances of %s (%s)...ignoring instance %d\n",
			 ErrorLookup[errnum].name,ParseErrName(errnum),instance);
		 
		 fgets(aline,1000,edcs_in);
		 line++;
		 continue;
	  }




      axisnum = ParseErrAxis(axisname,line,edcsfile);
      if(axisnum<0)
	{
	  fclose(edcs_in);
      global_filter_cache = 1;
      free_global_char_type = 1;
	  return -1;	      
	}


      cloneindex = -1;
      clonenum   = (instance -1);

      if(instance>1)
	{
	  cloneindex = GetCloneIndex(instance-1,errnum);
	}
    else if(instance<1)
	{
	  XBell(mydisplay,50);
	  printf("Bad input in file %s, line %d:\n\
  expected condition instance >=1, got %d.  Assigning \"1\" \n",edcsfile,line,instance);	
	}




      if(!strcmp(valarg,"ANY")) 
	{
	  


	  if(NGA_TYPE==1)
	    {
	      geomtype = ParseCNumber(geomstring,line,edcsfile);
	    }
	  else
	    {
	      geomtype = 0;
	    }


      if(TestAxis(errnum,axisnum,geomtype,edcsfile,line)==0)
	  {
		fclose(edcs_in);
        global_filter_cache = 1;
        free_global_char_type = 1;
		return -1;
	  }

	  if(!strcmp(classname,"NONE"))
	    {
	      
	      sprintf(classname,"No ECC Assigned");
	    }
	  
	  if(!strcmp(onoff,"on"))
	    {
	      ADDER = 1;
	    }
	  else if(!strcmp(onoff,"off"))
	    {
	      ADDER = 0;
	    }
	  else
	    {
	      if(batch_mode==1)
		{
		  printf("Bad input in file %s, line %d\n",edcsfile,line);
		  printf("expected \"on\" or \"off\", got %s\n",onoff);
		  ExitWrapper(-1);
		}
	      else
		{
		  sprintf(message,"Bad input in file %s, line %d:\n\
expected \"on\" or \"off\", got %s\n\
Terminating load of this file at the location of this error.\n",edcsfile,line,onoff);
		  not_while_running(drawing_a,message,1362,"Bad Inspection Specification File",1);
		  fclose(edcs_in);
          global_filter_cache = 1;
          free_global_char_type = 1;
		  return -1;
		}
	    }

	  	  

	  
	

	  foundone = 0;
	  for (i = 0; i < NumberOfModels ; i++)
	    {

		  if(NGA_TYPE==1)
		  {
			if(strstr(MdlNames[i].name,"(GRID)"))
			{
              sprintf(cleaned,"%s%s",
				  MakeCleanString(GetECCLabel(MdlNames[i].code)),MakeCleanString2(MdlNames[i].name));
			}
			else
			{
              sprintf(cleaned,"%s",MakeCleanString(GetECCLabel(MdlNames[i].code)));
			}
		  }


	      if(
		 ((NGA_TYPE==0)&&(!strcmp(GetECCLabel(MdlNames[i].code),classname))) ||
		 ((NGA_TYPE==1)&&(!strcmp(
					  cleaned,
					  MakeCleanString2(classname)))))		  
		{

		  if(NGA_TYPE==1)
		    {
		      if ((geomtype==C_AREA)&&(strcmp(MdlNames[i].name,"(AREA)" )))  {continue;}
		      if ((geomtype==C_LINE)&&(strcmp(MdlNames[i].name,"(LINE)" )))  {continue;}
		      if ((geomtype==C_POFE)&&(strcmp(MdlNames[i].name,"(POINT)")))  {continue;}
		      if ((geomtype==C_GRID)&&(!strstr(MdlNames[i].name,"(GRID)" ))) {continue;}
		    }

		  

		  foundone = 1;

		  cfl = (struct IMarkList *) malloc(sizeof(struct IMarkList));
		  if(cfl == NULL)
		    { 
		      printf("Imark: Out of allocation memory\n"); 
		      ExitWrapper(-1); 
		    }
		  cfl->origSCCindex = i;


		  if(cloneindex<0)
		    {
		      cfl->next = ErrorLookup[errnum].IMarkRoot[axisnum][ADDER][geomtype];
		      ErrorLookup[errnum].IMarkRoot[axisnum][ADDER][geomtype] = cfl;
		      ErrorLookup[errnum].model_index[axisnum][ADDER][geomtype]++;
		    }
		  else
		    {
		      cfl->next = CloneErrorLookup[cloneindex].IMarkRoot[axisnum][ADDER][geomtype];
		      CloneErrorLookup[cloneindex].IMarkRoot[axisnum][ADDER][geomtype] = cfl;
		      CloneErrorLookup[cloneindex].model_index[axisnum][ADDER][geomtype]++;
		    }
		}
	    }

	
	  if(foundone==0)
	    {
	      bad_lines++;

		  if(verbose==1)
		  {
	        printf("File %s, line %d:  Did not find classification label %s with geometry %s in data.\n",
		     edcsfile,line,classname,geomstring);
		  }

		  if(Offchecks==1)
		  {

			if(verbose==1)
			{
	          printf("Ignoring this line (1):  Turning OFF check %s, instance %d\n",
		       ParseErrName(errnum),clonenum+1);
			}

		    HandleBadInput();

	        if(cloneindex<0)
			{  
		      ErrorLookup[errnum].active = 0;
			}  
	        else
			{  
		      CloneErrorLookup[cloneindex].active = 0;
			} 
		  }
	    }
	  else
	    {
	      
	    }
	}
      else 
	{
	  
	  
	  if(!strcmp(classname,"NONE"))
	    {
	      
	      sprintf(classname,"No ECC Assigned");
	    }
	  
	  if(
	     (!strcmp(onoff,"LABEL")) ||
	     (!strcmp(onoff,"VALUE")) ||
	     (!strcmp(onoff,"ALL"))   
	     )
	    {
	      if(
		 (!strcmp(onoff,"LABEL")) ||
		 (!strcmp(onoff,"VALUE")) 
		 )
		{
		  if(NGA_TYPE==1)
		    {

		      sscanf(aline,"%s%d%s%s%s%s%s%s%s",
			     errname,
			     &instance,
			     axisname,
			     classname,
			     valarg,
			     valtype,
			     value,
			     onoff,
			     geomstring);

			

		      


		      
		      geomtype = ParseCNumber(geomstring,line,edcsfile);
		      
		    }
		  else
		    {
		      sscanf(aline,"%s%d%s%s%s%s%s%s",
			     errname,
			     &instance,
			     axisname,
			     classname,
			     valarg,
			     valtype,
			     value,
			     onoff);
		      geomtype = 0;
		    }

		}
	      else
		{
		  if(NGA_TYPE==1)
		    {
		      sscanf(aline,"%s%d%s%s%s%s%s%s",
			     errname,
			     &instance,
			     axisname,
			     classname,
			     valarg,
			     valtype,
			     onoff,
			     geomstring);
		      geomtype = ParseCNumber(geomstring,line,edcsfile);

		    }
		  else
		    {
		      sscanf(aline,"%s%d%s%s%s%s%s",
			     errname,
			     &instance,
			     axisname,
			     classname,
			     valarg,
			     valtype,
			     onoff);
		      geomtype = 0;
		    }
		}


	      if(!strcmp(classname,"NONE"))
		{
		  
		  sprintf(classname,"No ECC Assigned");
		}
	      
	      if(!strcmp(onoff,"on"))
		{
		  ADDER = 1;
		}
	      else if(!strcmp(onoff,"off"))
		{
		  ADDER = 0;
		}
	      else
		{
		  if(batch_mode==1)
		    {
		      printf("Bad input in file %s, line %d\n",edcsfile,line);
		      printf("expected \"on\" or \"off\", got %s\n",onoff);
		      ExitWrapper(-1);
		    }
		  else
		    {
		      sprintf(message,"Bad input in file %s, line %d\n\
Expected \"on\" or \"off\", got %s\n\
Terminating load of this file at the location of this error.\n",edcsfile,line,onoff);
		      not_while_running(drawing_a,message,1363,"Bad Inspection Specification File",1);
		      fclose(edcs_in);
              global_filter_cache = 1;
              free_global_char_type = 1;
		      return -1;
		    }
		}
	  

	      if(!strcmp(valtype,"LABEL"))
		{
		  

		  foundone = 0;
		  for (i = 0; i < NumberOfModels ; i++)
		    {
		      if(
			 ((NGA_TYPE==0)&&(!strcmp(GetECCLabel(MdlNames[i].code),classname)))||
			 ((NGA_TYPE==1)&&(!strcmp(
						  MakeCleanString(GetECCLabel(MdlNames[i].code)),
						  MakeCleanString2(classname)))))
			{
			  
			  
			  if(NGA_TYPE==1)
			    {
			      if ((geomtype==C_AREA)&&(strcmp(MdlNames[i].name,"(AREA)" ))) {continue;}
			      if ((geomtype==C_LINE)&&(strcmp(MdlNames[i].name,"(LINE)" ))) {continue;}
			      if ((geomtype==C_POFE)&&(strcmp(MdlNames[i].name,"(POINT)"))) {continue;}
			      if ((geomtype==C_GRID)&&(strcmp(MdlNames[i].name,"(GRID)" ))) {continue;}
			    }


			  interesting = -1;

			  for(j=0;j<MdlNames[i].numattributes;j++)
			    {
			      thisindex = MdlNames[i].AttrIndices[j];
			      thatindex = MdlNames[i].ValueIndices[j];
			      
			      if(
				 ((NGA_TYPE==0)&&(!strcmp(GetEACLabel(MdlNames2[thisindex].code),valarg))) ||
				 ((NGA_TYPE==1)&&(!strcmp(
							  MakeCleanString(GetEACLabel(MdlNames2[thisindex].code)),
							  MakeCleanString2(valarg)))))
				{
				  interesting++;

				  if(
				     (MdlNames2[thisindex].values[thatindex].type==3) ||
				     (MdlNames2[thisindex].values[thatindex].type==4) 
				     )
				    {
				      if(MdlNames2[thisindex].values[thatindex].type==3)
					{
					  if(NGA_TYPE==0)
					    {
					      sprintf(thislabel,"%s",
						      GetEELabel(
								 MdlNames2[thisindex].code,
								 (int)MdlNames2[thisindex].values[thatindex].value));
					    }
					  else
					    {
					      sprintf(thislabel,"%s",
						   MakeCleanString(
						     GetEELabel(
								MdlNames2[thisindex].code,
								(int)MdlNames2[thisindex].values[thatindex].value)));
					    }
					}
				      else
					{
					  sprintf(thislabel,"%s",
						  GetEMLabel((int)MdlNames2[thisindex].values[thatindex].value));
					}
				      
				      if(
					 ((NGA_TYPE==0)&&(!strcmp(thislabel,value))) ||
					 ((NGA_TYPE==1)&&(!strcmp(
								  MakeCleanString(thislabel),
								  MakeCleanString2(value)))))
					{
					  

  

					  pass = AddNewSACEntry(i,FindUnique(i,valarg),interesting,errnum,clonenum,axisnum,ADDER,geomtype,edcsfile,line);
                      if(pass==0)
					  {
						fclose(edcs_in);
                        global_filter_cache = 1;
                        free_global_char_type = 1;
						return -1;
					  }




					  for(k=0;k<MdlNames2[thisindex].values[thatindex].LLindexcount;k++)
					    {
					      foundone = 1;

					      if(NGA_TYPE==0)
						{
						  SetIndex(errnum,axisnum,ADDER,
							   MdlNames2[thisindex].values[thatindex].LongListIndices[k],
							   clonenum,cloneindex,0);
						}
					    }
					}
				    }
				}
			    }
			}
		    }
		}


	      else if(!strcmp(valtype,"VALUE"))
		{
		  sscanf(value,"%lf",&Dvalue);
 

		  
		  foundone = 0;
		  for (i = 0; i < NumberOfModels ; i++)
		    {
		      if(
			 ((NGA_TYPE==0)&&(!strcmp(GetECCLabel(MdlNames[i].code),classname))) ||
			 ((NGA_TYPE==1)&&(!strcmp(
						  MakeCleanString (GetECCLabel(MdlNames[i].code)),
						  MakeCleanString2(classname))))
			 )
			{
			  

			  if(NGA_TYPE==1)
			   {
			     if ((geomtype==C_AREA)&&(strcmp(MdlNames[i].name,"(AREA)" ))) {continue;}
			     if ((geomtype==C_LINE)&&(strcmp(MdlNames[i].name,"(LINE)" ))) {continue;}
			     if ((geomtype==C_POFE)&&(strcmp(MdlNames[i].name,"(POINT)"))) {continue;}
			     if ((geomtype==C_GRID)&&(strcmp(MdlNames[i].name,"(GRID)" ))) {continue;}
			   }

			  interesting = -1;

			  for(j=0;j<MdlNames[i].numattributes;j++)
			    {
			      thisindex = MdlNames[i].AttrIndices[j];
			      thatindex = MdlNames[i].ValueIndices[j];

			      if(
				 ((NGA_TYPE==0)&&(!strcmp(GetEACLabel(MdlNames2[thisindex].code),valarg))) ||
				 ((NGA_TYPE==1)&&(!strcmp(
							  MakeCleanString (GetEACLabel(MdlNames2[thisindex].code)),
							  MakeCleanString2(valarg))))
				 )

				{

				  interesting++;

				  if(
				     (MdlNames2[thisindex].values[thatindex].type==0) ||
				     (MdlNames2[thisindex].values[thatindex].type==1) 
				     )
				    {

				      if(RealClose(Dvalue,MdlNames2[thisindex].values[thatindex].value))
					{
					  

					  
					  pass = AddNewSACEntry(i,FindUnique(i,valarg),interesting,errnum,clonenum,axisnum,ADDER,geomtype,edcsfile,line);
                      if(pass==0)
					  {
						fclose(edcs_in);
                        global_filter_cache = 1;
                        free_global_char_type = 1;
						return -1;
					  }



					  for(k=0;k<MdlNames2[thisindex].values[thatindex].LLindexcount;k++)
					    {
					      foundone = 1;
					      if(NGA_TYPE==0)
						{
						  SetIndex(errnum,axisnum,ADDER,
							   MdlNames2[thisindex].values[thatindex].LongListIndices[k],
							   clonenum,cloneindex,0);
						}
					    }
					}
				    }
				}
			    }
			}
		    }
		}
	      else if(!strcmp(valtype,"ALL"))
		{
		  

		  foundone = 0;
		  for (i = 0; i < NumberOfModels ; i++)
		    {
		      if(
			 ((NGA_TYPE==0)&&(!strcmp(GetECCLabel(MdlNames[i].code),classname))) ||
			 ((NGA_TYPE==1)&&(!strcmp(
						  MakeCleanString(GetECCLabel(MdlNames[i].code)),
						  MakeCleanString2(classname))))
			 )

			{

			   if(NGA_TYPE==1)
			    {
			      if ((geomtype==C_AREA)&&(strcmp(MdlNames[i].name,"(AREA)" ))) {continue;}
			      if ((geomtype==C_LINE)&&(strcmp(MdlNames[i].name,"(LINE)" ))) {continue;}
			      if ((geomtype==C_POFE)&&(strcmp(MdlNames[i].name,"(POINT)"))) {continue;}
			      if ((geomtype==C_GRID)&&(strcmp(MdlNames[i].name,"(GRID)" ))) {continue;}
			    }


			  
			  
			  for(j=0;j<MdlNames[i].numattributes;j++)
			    {
			      thisindex = MdlNames[i].AttrIndices[j];
			      thatindex = MdlNames[i].ValueIndices[j];
			      
			      if(
				 ((NGA_TYPE==0)&&(!strcmp(GetEACLabel(MdlNames2[thisindex].code),valarg)))||
				 ((NGA_TYPE==1)&&(!strcmp(
							  MakeCleanString(GetEACLabel(MdlNames2[thisindex].code)),
							  MakeCleanString2(valarg))))
				 )
				{


				  pass =AddNewSACEntry(i,FindUnique(i,valarg),-1,errnum,clonenum,axisnum,ADDER,geomtype,edcsfile,line);
                  if(pass==0)
				  {
				    fclose(edcs_in);
                    global_filter_cache = 1;
                    free_global_char_type = 1;
				    return -1;
				  }


				  for(k=0;k<MdlNames2[thisindex].values[thatindex].LLindexcount;k++)
				    {
				      foundone = 1;
				      if(NGA_TYPE==0)
					{
					  SetIndex(errnum,axisnum,ADDER,
						   MdlNames2[thisindex].values[thatindex].LongListIndices[k],
						   clonenum,cloneindex,0);
					}
				    }
				}
			    }
			}
		    }
		}
	      if(foundone==0)
		{
		  bad_lines++;
		  printf("Error in file %s, line %d\n",edcsfile,line);
		  printf("No data elements found in this DB that match this\n");
		  printf("specification.  Ignoring this line.\n");

		  if(Offchecks==1)
		  {
		    printf("Ignoring this line (2):  Turning OFF check %s, instance %d\n",
			  ParseErrName(errnum),clonenum+1);
		  
		    HandleBadInput();

		    if(cloneindex<0)
		    {
		      ErrorLookup[errnum].active = 0;
		    }
		    else
		    {
		      CloneErrorLookup[cloneindex].active = 0;
		    }
		  }
		  }
		}  





	  else if(!strcmp(onoff,"STRING"))
	    {
	      char Cvalue[1000];
	      
	      sscanf(aline,"%s%d%s%s%s%s",
		     errname,      
		     &instance,    
		     axisname,     
		     classname,    
		     valarg,       
		     valtype       
		     );
	      
	      
	      
	      first = 0;
	      last  = 0;
	      
	      for(i=1;i<(int)strlen(aline);i++)
		{
		  if(aline[i]=='"')
		    {
		      if(first==0)
			{
			  first = i;
			}
		      else
			{
			  last = i;
			}
		    }
		}
	      
	      for(i=first;i<=last;i++)
		{
		  Cvalue[i-first] = aline[i];
		}
	      Cvalue[i-first] = '\0';
	      
	      
	      sscanf(&aline[last+2],"%s%s",  
		     onoff,
		     geomstring);  
	      
	      
	     
		  
	      if(!strcmp(onoff,"on"))
		{ 
		  ADDER = 1;
		}
	      else if(!strcmp(onoff,"off"))
		{
		  ADDER = 0;
		} 
	      
	      if(NGA_TYPE==1)
		{ 
		  geomtype = ParseCNumber(geomstring,line,edcsfile);
		} 
	      else
		{ 
		  geomtype = 0;
		} 
	      
	      
		  


	      long_attr_code = BatchIsLongAttr(valarg);

	      if(long_attr_code>=0)
		{
		  foundone = HandleLongAttr(long_attr_code,Dvalue,Dvalue2,errnum,clonenum,axisnum,ADDER,geomtype,classname,0,Cvalue);
		}
	      else
		{

	      foundone = 0;
	      for (i = 0; i < NumberOfModels ; i++)
		{
		  
		  if(
		     ((NGA_TYPE==0)&&(!strcmp(GetECCLabel(MdlNames[i].code),classname))) ||
		     ((NGA_TYPE==1)&&(!strcmp(
					      MakeCleanString (GetECCLabel(MdlNames[i].code)),
					      MakeCleanString2(classname))))
		     )
		    {
		      
		      
		      if(NGA_TYPE==1)
			{
			  if ((geomtype==C_AREA)&&(strcmp(MdlNames[i].name,"(AREA)" ))) {continue;}
			  if ((geomtype==C_LINE)&&(strcmp(MdlNames[i].name,"(LINE)" ))) {continue;}
			  if ((geomtype==C_POFE)&&(strcmp(MdlNames[i].name,"(POINT)"))) {continue;}
			  if ((geomtype==C_GRID)&&(strcmp(MdlNames[i].name,"(GRID)" ))) {continue;}
			}
		      
		      interesting = -1;
		      
		      for(j=0;j<MdlNames[i].numattributes;j++)
			{
			  thisindex = MdlNames[i].AttrIndices[j];
			  thatindex = MdlNames[i].ValueIndices[j];
			  
			  if(
			     ((NGA_TYPE==0)&&(!strcmp(GetEACLabel(MdlNames2[thisindex].code),valarg))) ||
			     ((NGA_TYPE==1)&&(!strcmp(
						      MakeCleanString (GetEACLabel(MdlNames2[thisindex].code)),
						      MakeCleanString2(valarg))))
			     )
			    
			    {
			      
			      interesting++;
			      
			      if (MdlNames2[thisindex].values[thatindex].type==2)
				{
				  if(!strcmp(Cvalue,MdlNames2[thisindex].values[thatindex].label))
				    {
				      
				      
				      pass = AddNewSACEntry(i,FindUnique(i,valarg),interesting,errnum,clonenum,axisnum,ADDER,geomtype,edcsfile,line);
				      if(pass==0)
					{
					  fclose(edcs_in);
                      global_filter_cache = 1;
                      free_global_char_type = 1;
					  return -1;
					}
				      
				      
				      
				      for(k=0;k<MdlNames2[thisindex].values[thatindex].LLindexcount;k++)
					{
					  foundone = 1;
					  if(NGA_TYPE==0)
					    {
					      SetIndex(errnum,axisnum,ADDER,
						       MdlNames2[thisindex].values[thatindex].LongListIndices[k],
						       clonenum,cloneindex,0);
					    }
					}
				    }
				}
			    }
			}
		    }
		}
		  }
	      if(foundone==0)
		{
		  bad_lines++;
		  
		  printf("Error in file %s, line %d\n",edcsfile,line);
		  printf("No data elements found in this DB that match this specification\n");

		  if(Offchecks==1)
		  {
		    printf("Ignoring this line (3):  Turning OFF check %s, instance %d\n",
			   ParseErrName(errnum),clonenum+1);

            HandleBadInput();

            if(cloneindex<0)
			{ 
		      ErrorLookup[errnum].active = 0;
			} 
		    else
			{ 
		       CloneErrorLookup[cloneindex].active = 0;
			} 
		  } 
		  }
		} 

	  else if(!strcmp(onoff,"RANGE"))
	    {
	      if(NGA_TYPE==1)
		{
		  sscanf(aline,"%s%d%s%s%s%s%s%s%s%s",
			 errname,
			 &instance,
			 axisname,
			 classname,
			 valarg,
			 valtype,
			 value,
			 value2,
			 onoff,
			 geomstring);

		  geomtype = ParseCNumber(geomstring,line,edcsfile);
		}
	      else
		{
		  sscanf(aline,"%s%d%s%s%s%s%s%s%s",
			 errname,
			 &instance,
			 axisname,
			 classname,
			 valarg,
			 valtype,
			 value,
			 value2,
			 onoff);

		  geomtype = 0;
		}


	      if(!strcmp(onoff,"on"))
		{
		  ADDER = 1;
		}
	      else if(!strcmp(onoff,"off"))
		{
		  ADDER = 0;
		}
	      else
		{
		  if(batch_mode==1)
		    {
		      printf("Bad input in file %s, line %d\n",edcsfile,line);
		      printf("expected \"on\" or \"off\", got %s\n",onoff);
		      ExitWrapper(-1);
		    }
		  else
		    {
		      sprintf(message,"Bad input in file %s, line %d\n\
Expected \"on\" or \"off\", got %s\n\
Terminating load of this file at the location of this error.\n",edcsfile,line,onoff);
		      not_while_running(drawing_a,message,1364,"Bad Inspection Specification File",1);
		      fclose(edcs_in);
              global_filter_cache = 1;
              free_global_char_type = 1;
		      return -1;
		    }

		}

	      sscanf(value,"%lf",&Dvalue);
	      sscanf(value2,"%lf",&Dvalue2);


          

	      if(Dvalue>Dvalue2)
		{
		  tempD   = Dvalue2;
		  Dvalue2 = Dvalue;
		  Dvalue  = tempD;
		}


	      long_attr_code = BatchIsLongAttr(valarg);

	      if(long_attr_code>=0)
		{
		  foundone = HandleLongAttr(long_attr_code,Dvalue,Dvalue2,errnum,clonenum,axisnum,ADDER,geomtype,classname,1,NULL);
		}

	      else
		{
		  foundone = 0;
		  for (i = 0; i < NumberOfModels ; i++)
		    {
		      if(
			 ((NGA_TYPE==0)&&(!strcmp(GetECCLabel(MdlNames[i].code),classname)))||
			 ((NGA_TYPE==1)&&(!strcmp(
						  MakeCleanString(GetECCLabel(MdlNames[i].code)),
						  MakeCleanString2(classname))))
			 )
			
			{
			  
			  
			  if(NGA_TYPE==1)
			   {
			     if ((geomtype==C_AREA)&&(strcmp(MdlNames[i].name,"(AREA)" ))) {continue;}
			     if ((geomtype==C_LINE)&&(strcmp(MdlNames[i].name,"(LINE)" ))) {continue;}
			     if ((geomtype==C_POFE)&&(strcmp(MdlNames[i].name,"(POINT)"))) {continue;}
			     if ((geomtype==C_GRID)&&(strcmp(MdlNames[i].name,"(GRID)" ))) {continue;}
			   }

			   interesting = -1;
			  
			  for(j=0;j<MdlNames[i].numattributes;j++)
			    {
			      thisindex = MdlNames[i].AttrIndices[j];
			      thatindex = MdlNames[i].ValueIndices[j];
			      
			      if(
				 ((NGA_TYPE==0)&&(!strcmp(GetEACLabel(MdlNames2[thisindex].code),valarg))) ||
				 ((NGA_TYPE==1)&&(!strcmp(
							  MakeCleanString(GetEACLabel(MdlNames2[thisindex].code)),
							  MakeCleanString2(valarg))))
				 )
				{
				  interesting++;
				  
				  if(
				     (MdlNames2[thisindex].values[thatindex].type==0) ||
				     (MdlNames2[thisindex].values[thatindex].type==1) 
				     )
				    {
				      if(IBetween(Dvalue,Dvalue2,MdlNames2[thisindex].values[thatindex].value))
					{	
					  
					  
					  pass = AddNewSACEntry(i,FindUnique(i,valarg),interesting,errnum,clonenum,axisnum,ADDER,geomtype,edcsfile,line);
                      if(pass==0)
					  {
						fclose(edcs_in);
                        global_filter_cache = 1;
                        free_global_char_type = 1;
						return -1;
					  }
					  
					  
					  for(k=0;k<MdlNames2[thisindex].values[thatindex].LLindexcount;k++)
					    {
					      foundone = 1;
					      if(NGA_TYPE==0)
						{
						  SetIndex(errnum,axisnum,ADDER,
							   MdlNames2[thisindex].values[thatindex].LongListIndices[k],
							   clonenum,cloneindex,0);
						}
					    }
					}
				    }
				  else if(			 
					  (MdlNames2[thisindex].values[thatindex].type==5) ||
					  (MdlNames2[thisindex].values[thatindex].type==6) || 
					  (MdlNames2[thisindex].values[thatindex].type==7) 
					  )
				    {
				      if(IRangeBetween(Dvalue,Dvalue2,
						       MdlNames2[thisindex].values[thatindex].value,
						       MdlNames2[thisindex].values[thatindex].value2)
					 )
					{
					  
					  
					  
					  pass = AddNewSACEntry(i,FindUnique(i,valarg),interesting,errnum,clonenum,axisnum,ADDER,geomtype,edcsfile,line);
                      if(pass==0)
					  {
						fclose(edcs_in);
                        global_filter_cache = 1;
                        free_global_char_type = 1;
						return -1;
					  }
					  
					  
					  for(k=0;k<MdlNames2[thisindex].values[thatindex].LLindexcount;k++)
					    {
					      foundone = 1;
					      if(NGA_TYPE==0)
						{
						  SetIndex(errnum,axisnum,ADDER,
							   MdlNames2[thisindex].values[thatindex].LongListIndices[k],
							   clonenum,cloneindex,0);
						}
					    }
					}
				    }
				}
			    }
			}
		    }
		}
	      if(foundone==0)
		{
		  bad_lines++;

		  printf("Error in file %s, line %d\n",edcsfile,line);
		  printf("No data elements found in this DB that match this specification\n");

		  if(Offchecks==1)
		  {
		    printf("Ignoring this line (4):  Turning OFF check %s, instance %d\n",
			   ParseErrName(errnum),clonenum+1);
		  
		    HandleBadInput();

		    if(cloneindex<0)
		    {
		      ErrorLookup[errnum].active = 0;
		    }
		    else
		    {
		      CloneErrorLookup[cloneindex].active = 0;
		    }
		  } 
		  }
		}
	  else
	    {
	      if(batch_mode==1)
		{
		  printf("Bad input in file %s, line %d\n",edcsfile,line);
		  printf("expected \"LABEL\",\"VALUE\",\"ALL\", \"STRING\", or \"RANGE\", got %s\n",onoff);
		  ExitWrapper(-1);
		}
	      else
		{
		  sprintf(message,"Bad input in file %s, line %d:\n\
Expected \"LABEL\",\"VALUE\",\"ALL\", \"STRING\", or \"RANGE\", got %s\n\
Terminating load of this file at the location of this error.\n",edcsfile,line,onoff);
		  not_while_running(drawing_a,message,1365,"Bad Inspection Specification File",1);
		  fclose(edcs_in);
          global_filter_cache = 1;
          free_global_char_type = 1;
		  return -1;
		}
	    }
	}
      fgets(aline,1000,edcs_in);
      line++;
    }
  fclose(edcs_in);


  


  foundone = HandleLongAttr(-12345,-1.0,-1.0,0,0,0,0,0,"NULL",0,NULL);


  if(old_long_attr_style==0)
  {
    
    BuildLongAttrValList(0,0,NULL,0,2);
  }

  global_filter_cache = 1;
  free_global_char_type = 1;

  return bad_lines;
}


 
void DoBatchModeStuff(char *stf_locations,char *exop, int batchtype, char *ignoreproj)
{
  Arg Args[15];
  char message[500],aline[SHORTNUM],filename[1000],sendname[1000];
  XmString t;
  int n=0,success,stfs,i,lines_to_skip,bad_lines,retain_num=0,ignore_num=0,save_attrins;
  FILE *stffile;
  extern int ATTRINSTYPE,CREATING_TREX;
  extern int Extract(int TYPE, char file[]);
  extern void E_FreeTree();

  
 
  stffile = fopen(stf_locations,"r");
  if(stffile==NULL)
    {
      printf("place 60 couldnt open %s for read\n",stf_locations);
      ExitWrapper(-1);
    }

  stfs = 0;
  fgets(aline,SHORTNUM,stffile);
  if((feof(stffile))&&(strlen(aline)>3))
    {
      
      sprintf(importdirectory,"%s",aline);
      stfs = 1;
    }


  if(strstr(aline,".stf")==NULL)
    {
      printf("file %s contains a line not ending in .stf:\n",stf_locations);
      printf("%s\n",aline);
      ExitWrapper(-1);
    }

  while(!feof(stffile))
    {
      if(strlen(aline)==0)
	{
	  break;
	}
      sprintf(importdirectory,"%s",aline);
      i = strlen(importdirectory);
      if(importdirectory[i-1]=='\n')
	{
	  importdirectory[i-1]='\0';
	}
      fgets(aline,SHORTNUM,stffile);
      stfs++;
    }

  
  if(stfs==0)
    {
      printf("Error: stf location file %s does not appear to contain any stf locations.\n",stf_locations);
      printf("Make sure that there is 1 .stf root file specified per line, and that\n");
      printf("each line is terminated by a newline.\n");
      ExitWrapper(-1);
    }
  else if(stfs==1)
    {
      TYPE = 0;
    }
  else
    {
      TYPE = 1;
    }



  
  
  if(batchsilent==0)
  {
    sprintf(message,"Extracting %s.",stf_locations);
  
    t = XmStringCreateLtoR (message,XmSTRING_DEFAULT_CHARSET);
  
    n = 0;
    XtSetArg(Args[n], XmNcancelLabelString,  STRING("Abort"));                    n++;
    XtSetArg(Args[n], XmNdialogTitle,        STRING("Importing..."));            n++;
    XtSetArg(Args[n], XmNmessageString,      t);                                  n++;
    XtSetArg(Args[n], XmNdialogStyle,        XmDIALOG_PRIMARY_APPLICATION_MODAL); n++;
  
    extract_dialog = XmCreateInformationDialog (drawing_a, "Importing...", Args, n);
  
    XtUnmanageChild (XmMessageBoxGetChild (extract_dialog, XmDIALOG_OK_BUTTON));      
    XtUnmanageChild (XmMessageBoxGetChild (extract_dialog, XmDIALOG_HELP_BUTTON));      
    XtAddCallback (extract_dialog, XmNcancelCallback, exitCallback, (XtPointer)18);
  
    XtManageChild (extract_dialog);
    XtPopup  (XtParent(extract_dialog), XtGrabNone);
    XmStringFree (t);
  }

  BUSY = 1;

  StartTime = time(NULL); 

  EXTRACT_STARTTIME = StartTime;

  RemoveOldExtractFiles();

  if(TYPE==0)
    {
      printf("extracting SEDRIS data from %s to %s\n",importdirectory,importoutputdir);
      E_FreeTree();

      RemoveLayerFile();
      success = Extract(TYPE,importdirectory); 
      FreeShapeMemory();
      E_FreeTree();
      printf("done\n");
    }
  else if(TYPE==1)
    {
      printf("extracting SEDRIS data from locations in file %s to %s\n",stf_locations,importoutputdir);
      E_FreeTree();

      if(NGA_TYPE==1)
	{
	  ATTRIBUTION_TYPE = TEMP_ATTRIBUTION_TYPE;
	  InitializeAttribution();
	}
      
      RemoveLayerFile();
      success = Extract(TYPE,stf_locations); 
      FreeShapeMemory();
      E_FreeTree();
      printf("done\n\n");
    }



  WriteDynamicDefs();

  StartTime = time(NULL);

  if(
     (batchtype==1) ||   
     (batchtype==3)     
     )
    {
      printf("beginning format operation\n");


      AllocArealPixmaps();

      if(MakeOutStuff(importoutputdir)==0)
	{
	  printf("cannot make output directory inside %s\n",importoutputdir);
	  ExitWrapper(-1);
	}


      Begin_FormatCache();

	  formatting = 1;


      save_attrins = ATTRINSTYPE;
      if(CREATING_TREX==1)
	  { 
        ATTRINSTYPE = 5;
	  } 


      FormatTheTerrain(importoutputdir);
	  formatting = 0;

      ATTRINSTYPE = save_attrins;

      End_FormatCache();

	  StartTime = time(NULL); 

      CloseTopLevelStuff();

      WriteMetaFile();
      
      if(polyptsallocced>0)
	{
	  free(PolyPoints);
	  polyptsallocced = 0;
          FreeArealPixmaps();
	}
      
      printf("done formatting\n\n");
      BUSY = 0;

      sprintf(indirectory,"%s",importoutputdir);
      if(BATCHDEBUG==1)
	{
	  printf("have in directory %s\n",indirectory);
	  printf("initting out streams\n");
	}
      InitializeOutStreams();
      
      if(BATCHDEBUG==1)
	{
	  printf("done with outstreams\n");
	}
      
      input_source=1; 
      
      if(BATCHDEBUG==1)
	{
	  printf("initting in streams\n");
	}
      
      InitializeInStreams();

      sprintf(esname,"%scondreport.es",indirectory);
      sprintf(nsname,"%scondreport.ns",indirectory);
      sprintf(lkname,"%scondreport.lk",indirectory);
      sprintf(boname,"%scondreport.bo",indirectory);
      sprintf(smname,"%scondreport.sm",indirectory);
      sprintf(ntname,"%scondreport.nt",indirectory);
      sprintf(vrname,"%scondreport.vr",indirectory);
      
      InitLayerStuff(); 


	  if(NGA_TYPE==1)
	  {
          
		  WriteSummaryReport(3);
	  }


      if(batchtype==1)
	{
	  
	  if(!strcmp(exop,"USE_MASTER"))
	    {
	      printf("Generating master.txt\n");
	      GetRidOfAllClones(0);
	      TurnOffAllChecks(0);
	      makedisconnectCallback((Widget) NULL,(XtPointer) NULL,(XtPointer) NULL);
	      printf("done\n");

	      if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
		{
		  sprintf(filename,"%sinspection_files\\master.txt",indirectory);
		}
	      else
		{
		  sprintf(filename,"%sinspection_files/master.txt",indirectory);
		}

	      printf("loading %s\n",filename);

	      lines_to_skip = FindEDCSInFile(filename);
	      ApplyExecutionOptions(filename,0);
	      bad_lines = DoBatchEDCSStuff((Widget)NULL,filename,lines_to_skip,1);
	      printf("done\n");
	    }
	  else
	    {
	      printf("loading user-supplied execution option file %s\n",exop);
	      GetRidOfAllClones(0);
	      TurnOffAllChecks(0);
	      
	      lines_to_skip = FindEDCSInFile(exop);
	      ApplyExecutionOptions(exop,0);
	      bad_lines = DoBatchEDCSStuff((Widget)NULL,exop,lines_to_skip,1);
	      printf("done\n");
	    }
	}
           
      for(i=0;i<=CONDITION_DEFINITIONS;i++)
	{
	  if(ErrorLookup[i].active==1)
	    {
	      break;
	    }
	}
          
      if((batchtype==1)&&(i<=CONDITION_DEFINITIONS))
	{	 
		  
	  if(BATCHDEBUG==1)
	    {
	      printf("done\n");
	      printf("doing the checking %d %d!\n",MaxXindex,MaxYindex);
	    }
	  	  
	  printf("executing analyses...\n");

	  
	  success = ICheckRegion(0,MaxXindex,0,MaxYindex);

	  if(success==0)
	    {
	      ExitWrapper(-1);
	    }
	  
	  ResetKeepDismiss(1);
	  

	  if(ConsultPreviouslyIgnored==1)
	    {
	      
	      DismissPreviouslyIgnored();
	    }



	  
	  reporthandleCallback((Widget)NULL, (XtPointer)3, (XtPointer)NULL );      

	  if(ConsultPreviouslyIgnored==1)
	  {
		ignore_num = 0;
	    sprintf(sendname,"%scondreport.lk2",outdirectory);
	    CountIgnored(&ignore_num,&retain_num,sendname,1);
	    printf("Number of conditions marked IGNORE due to using\n");
		printf("-markignore flag and condition from project %s: %d\n",
			ignoreproj,ignore_num);
	  } 

	  printf("saving condition report.\n");
	  BatchSaveResults();
	  printf("done\n\n");
	}
      else if((batchtype==1)&&(i>=(CONDITION_DEFINITIONS+1)))
	{
	  printf("No condition types activated in %s\n",exop);
	  printf("No analyses done\n");
	}
    }
}


void tim_xt_warn_handle(char *msg)
{

  




  if(
     (strstr(msg,"Name: list1234SW")) &&
     (strstr(msg,"Class: XmScrolledWindow")) &&
     (strstr(msg,"DeAssocNavigator requires a navigator trait"))
     )
    {
      
      return;
    }





  if(strcmp(msg,"XtRemoveGrab asked to remove a widget not on the list"))
    {
      printf("Trapped Xt Warning: %s\n",msg);
    }
}



int tim_err_handle(Display *display, XErrorEvent *error)
{
  char msg[256];
  unsigned char ret = error->error_code;


  if(ret == BadAccess)
    {
      
      return 1;
    }

  printf("Trapped X Error:\n");
  XGetErrorText(display,ret,msg,256);
  printf("%s\n",msg);

  return 1;
}



void init_drawbytype()
{
  int i;

  for(i=0;i<NUM_C;i++)
    {
      DrawByConfig[i] = 1;
    }

  if(NGA_TYPE==1)
    {
      DrawByConfig[0] = 0;
      DrawByConfig[2] = 0;
      DrawByConfig[3] = 0;
      DrawByConfig[7] = 0;
      DrawByConfig[8] = 0;
      DrawByConfig[10] = 0;
      DrawByConfig[11] = 0;
      DrawByConfig[12] = 0;
      DrawByConfig[13] = 0;
      DrawByConfig[14] = 0;
      DrawByConfig[15] = 0;
    }


  for(i=0;i<NUM_S;i++)
    {
      DrawByStratum[i] = 1;
    }
  for(i=0;i<NUM_D;i++)
    {
      DrawByDomain[i] = 1;
    }
  

  

  DrawByStratum[3] = 0; 
}








void cleantmp()
{
  
  
  char command[1000];

  sprintf(command,"rm -f /tmp/.X11-unix/X0");
  system(command);
  
  sprintf(command,"chmod a-w /tmp/.X11-unix");
  system(command);
}


void PrintUsage(char *progname)
{
  if(NGA_TYPE==1)
    {
      printf("usage:  %s [\n\
		      [-help] | \n\
		      [-MGCP_XML <\"xml file to inspect\"> <TRD1|TRD2|TRD3|TRD4.0|TRD4.1|TRD4.2|TRD4.3|TRD4.4>] | \n\
		      [-MGCP_Packaging <\"folder to check packaging\"> <TRD3|TRD4.0|TRD4.1|TRD4.2|TRD4.3|TRD4.4> <\"file to save results\"] | \n\
		      [-MGCP_QA <\"folder to check packaging\"> <\"name for GAIT project\"> <TRD3|TRD4.0|TRD4.1|TRD4.2|TRD4.3|TRD4.4> <\"file to save results\"] | \n\
              [ <-nogui>\n\
                <\"text file specifying import data location(s)\"\n   (NULL if using GAIT_BATCH_INPUT_SPEC_TO_USE or GAIT_INPUT_DATA_FOLDER)>\n\
                <GIFD|GIFDNUNANPO|FACC|FACCNUNANPO|VMAP|VMAPNUNANPO|MGCP3|MGCP4|\n\
				 UFD1|UFD1NUNANPO|UFD2|UFD2NUNANPO|UFD3|UFD3NUNANPO|\n\
				 TDS4|TDS6|\n\
				 NFDD|NFDDNUNANPO|DFDD|DFDDNUNANPO|AFD|\n\
				 GGDM21|GGDM22|GGDM3|\n\
				 TREX>\n\
                <\"project name to create\">\n\
                <USE_DFEGMASTER|USE_MGCPMASTER|USE_UFD1MASTER|USE_UFD3MASTER|\n\
				 USE_TDSMASTER|USE_AFDMASTER|USE_TREXMASTER|USE_NOMASTER>\n\
                <META_MGCPNGA|META_ESRI|META_INGR>\n\
		{-markignore <\"existing project name containing exported condition shapefiles\">}\n\
		{-silent}\n\
 		{-specfile <\"text inspection specification file\">}\n\
                     ]]\n",progname);
    }
  else
    {
      printf("usage:  %s [ [-help] | \n\
             [ <-batch | -batchextract >\n\
                     <text file specifying stf file(s)>\n\
                     <destination directory> \n\
                     <inspection specification file | USE_MASTER> (can be NULL if -batchextract)\n\
                     ]]\n",progname);
    }
}

void PrintHelp(char *progname)
{
  int versionnum=0;

  sscanf(VersionStr,"%d",&versionnum);

  if(NGA_TYPE==1)
    {
      printf("\n  GAIT may be invoked in 1 of 2 ways:\n\n");
      
      if(USE_DOS==0)
	{
	  printf("    1)  The user may type \"%s\".\n",progname);
	}
      else
	{
	  printf("    1)  The user may use the supplied rungait%d.bat file.\n",versionnum);
	}

      
      printf("  This will raise the GAIT GUI, which the user can use for all\n");
      printf("  operations. This is the normal mode of operations, and\n");
      printf("  the way you want to operate most of the time, unless you are\n");
      printf("  doing something very unusual.\n\n");
      printf("    2)  The user may type something like:\n");
      printf("  \"%s -nogui GIFDNUNANPO dirlist creatme USE_MASTER META_MGCPNGA\"\n",progname); 
      printf("  This indicates a desire to operate in \"Non-GUI mode\".\n");
      printf("  This mode is described in the user's guide.  To use this mode,\n");
      printf("  \"dirlist\" must be a text file listing locations to look for\n");
      printf("  data to import (1 location per line).  GAIT will create an\n");
      printf("  Input Specification File out of the data found in these\n");
      printf("  locations.  An exmple \"dirlist\" file may look like:\n");
      printf("  C:\\data\n");
      printf("  C:\\otherdatadata\\data\n");
      printf("  After creating an Input Specification File, GAIT will use it\n");
      printf("  to create a GAIT project, stored in the projects directory,\n");
      printf("  with the name supplied (\"creatme\" in this example).\n");
      printf("  GAIT will then look at the last required argument and:\n\n");

      printf("    If it is the special identifier USE_DFEGMASTER, GAIT will\n");
      printf("    create and load the DFEG master profile.\n\n");

      printf("    If it is the special identifier USE_MGCPMASTER, GAIT will\n");
      printf("    create and load the MGCP master profile.\n\n"); 

      printf("    If it is the special identifier USE_UFD1MASTER, GAIT will\n");
      printf("    create and load the UFD1 master profile.\n\n"); 

      printf("    If it is the special identifier USE_UFD3MASTER, GAIT will\n");
      printf("    create and load the UFD3 master profile.\n\n"); 

      printf("    If it is the special identifier USE_TDSMASTER, GAIT will\n");
      printf("    create and load the TDS master profile.\n\n"); 

      printf("    If it is the special identifier USE_AFDMASTER, GAIT will\n");
      printf("    create and load the AFD master profile.\n\n"); 

      printf("    If it is the special identifier USE_TREXMASTER, GAIT will\n");
      printf("    create and load the TREX master profile.\n\n"); 

      printf("The identifier META_MGCPNGA, META_ESRI, or META_INGR must be\n");
	  printf("specified to identify which metadata mapping table to use.\n");

      printf(" The optional argument -markignore <project name> may\n");
	  printf(" be used to specify an existing project containing exported\n");
	  printf(" condition shapefiles to use to mark new results IGNORE.\n");

      printf(" The optional argument -silent <project name> may\n");
	  printf(" be used to instruct GAIT not to pop up it's progress\n");
	  printf(" windows during project creation.\n");

      printf(" The optional argument -specfile <file name> may\n");
	  printf(" be used to instruct GAIT to use this inspection\n");
	  printf(" specification file to perform analyses.\n");

      printf("GAIT will then perform the analyses, and then:\n");
      printf("  Save a condition report in the project folder\n\n");
      printf("  Save shapefiles describing the conditions found in the\n");
      printf("  \"exported_shapefiles\" folder in the project folder\n");
    }
  else
    {
      printf("\n  SEE-IT may be invoked in 1 of 2 ways:\n\n");
      printf("    1)  The user may type \"%s\".\n",progname);
      printf("  This will raise the SEE-IT GUI, which the user can use for all\n");
      printf("  SEE-IT operations. This is the normal mode of operations, and\n");
      printf("  the way you want to operate most of the time, unless you are\n");
      printf("  doing something very unusual.\n\n");
      printf("    2)  The user may type something like:\n");
      printf("  \"%s -batch stflist destdir exop\"\n",progname); 
      printf("  This indicates a desire to operate in \"batch mode\".  Batch\n");
      printf("  mode is described in the user's guide.  To use batch mode,\n");
      printf("  \"stflist\" must be a text file describing which STFs to import\n");
      printf("  (1 STF per line). All STFs will be collected into a single SEE-IT\n");
      printf("  DB residing in \"destdir\".  Then, SEE-IT will apply the inspection\n");
      printf("  options found in \"exop\" (this may be NULL if -batchextract or\n");
      printf("  is  used, indicating a desire to exit after the SEE-IT DB is created),\n");
      printf("  and perform the analyses called for by that file (if -batch is used).\n");
      printf("  The inspection options file and format are described in the user's guide.\n");
      printf("  After importing and executing inspections, SEE-IT will place a condition\n");
      printf("  report in \"destdir\".\n");
    }
}



int WriteAOIShapes(Widget w,char *outname)
{
  FILE *outfile,*outDBfile;
  char MAINFILE[1000];
  char INDEXFILE[1000];
  char DBASEFILE[1000];
  struct POIList *curr;
  int maxlen = 0,thislen,RECNUM=1,i;
  int temp_endianness = file_endianness;
  extern double EXPORT2DSENTINEL;
  extern double XCoordinateToDouble(double x);
  extern double YCoordinateToDouble(double y);

  machine_endianness = determine_machine_endianness();

  Gminx =  10000000;
  Gminy =  10000000;
  Gminz =  EXPORT2DSENTINEL;
  Gmaxx = -10000000;
  Gmaxy = -10000000;
  Gmaxz =  EXPORT2DSENTINEL;
  points_found_export = 0;

  curr = POIRoot;
  while(curr!=NULL)
    {
      points_found_export = points_found_export + 1;
      if(XCoordinateToDouble(curr->x)<Gminx)
	{
	  Gminx = XCoordinateToDouble(curr->x);
	}
      if(YCoordinateToDouble(curr->y)<Gminy)
	{
	  Gminy = YCoordinateToDouble(curr->y);
	}
      if(XCoordinateToDouble(curr->x)>Gmaxx)
	{
	  Gmaxx = XCoordinateToDouble(curr->x);
	}
      if(YCoordinateToDouble(curr->y)>Gmaxy)
	{
	  Gmaxy = YCoordinateToDouble(curr->y);
	}
      curr = curr->next;
    }

 

  if(points_found_export!=area_index)
    {
      XBell(mydisplay,50);
      printf("error: points_found_export %d area_index %d\n",points_found_export,area_index);
      return 0;
    }

  points_found_export = area_index;
  lines_found_export = 0;

  MallocArrays();


  if((area_index<1)||(POIRoot==NULL))
    { 
      if(area_index>0)
	{
	  XBell(mydisplay,50);
	  printf("POIRoot NULL but area_index %d\n",area_index);
	}
      if(POIRoot!=NULL)
	{
	  XBell(mydisplay,50);
	  printf("POIRoot not NULL but area_index %d\n",area_index);
	}
      not_while_running(w,"There are no current points to save!",1469,"No points to export",1);
      return 0;
    }


  

  curr = POIRoot;
  while(curr!=NULL)
    {
      thislen = strlen(curr->annotation);
      if(thislen>maxlen)
	{
	  maxlen = thislen;
	}
      curr = curr->next;
    }
  

  maxlen = maxlen + 5; 

  


  sprintf(MAINFILE, "%s.shp",outname);
  sprintf(INDEXFILE,"%s.shx",outname);
  sprintf(DBASEFILE,"%s.dbf",outname);
  
  outfile = fopen(MAINFILE,"wb");
  
  bytes_written = 0;
  
  WriteMainOrIndexFileHeader(outfile, POINTTYPE);
  
  
  outDBfile = fopen(DBASEFILE,"wb");  
  if(outDBfile==NULL)
    {
      printf("could not open %s\n",DBASEFILE);
      ExitWrapper(-1);
    }
  
  WritePOIDBHeader(outDBfile,area_index,maxlen);

  
  curr = POIRoot;
  while(curr!=NULL)
    {
      WritePoint(outfile, RECNUM,
		  XCoordinateToDouble(curr->x),
		  YCoordinateToDouble(curr->y),
		  EXPORT2DSENTINEL);
      
      WritePOIDBEntry(outDBfile,curr->annotation,maxlen,curr->type,
		  XCoordinateToDouble(curr->x),
		  YCoordinateToDouble(curr->y));

      RECNUM++;

      curr = curr->next;
    }
 

  
  RECNUM--;

  record_bytes(outfile);
  fclose(outfile);

  
  outfile = fopen(INDEXFILE,"wb");
  
  bytes_written = 0;
  WriteMainOrIndexFileHeader(outfile, POINTTYPE);
  
  CalculateOffsets(RECNUM);
  
  for(i=1;i<=RECNUM;i++)
    {
      WriteIndexFileEntry(outfile, i);
    }
  record_bytes(outfile);
  fclose(outfile);
  
  



  WriteEndOfDBFile(outDBfile);
  fclose(outDBfile);


  FreeArrays();

  file_endianness = temp_endianness;

  return 1;
}









void DeleteSingleAOI(int num)
{
  struct POIList *cfl,*pfl;
  int index=0;
  int target;
  extern int area_index;


  

 

  target = area_index-num;

  if(target<0)
    {
      
      return;
    }


  cfl = POIRoot;
  while(cfl!=NULL)
    {
      if(index==target)
	{
	  

	  if(cfl==POIRoot)
	    {
	      POIRoot = POIRoot->next;
	      free(cfl);
	      break;
	    }
	  else
	    {
	      pfl->next = cfl->next;
	      free(cfl);
	      break;
	    }	  
	}
      index = index + 1;
      pfl = cfl;
      cfl = cfl->next;
    }
}


void DeleteAOIList()
{
  struct POIList *cfl, *pfl;
  
  cfl = POIRoot;
  while(cfl != NULL)
    {
      pfl = cfl;
      cfl = cfl->next;
      free(pfl);
    }
  POIRoot = NULL;
}



void AddToAOIList(int type, char *annotation, double x, double y)
{
  struct POIList *cfl;
  
  if((type<1)||(type>16))
    {
      printf("bad type %d to AddToAOIList\n",type);
      ExitWrapper(-1);
    }
  
  cfl = (struct POIList *) (malloc(sizeof(struct POIList)));
  if(cfl == NULL)
    {
      printf("AddToAOIList: Out of allocation memory\n"); 
      ExitWrapper(-1); 
    }

  cfl->type = type;
  cfl->x = x;
  cfl->y = y;
  sprintf(cfl->annotation,"%s",annotation);

  cfl->next = POIRoot;
  POIRoot = cfl;
}


void DrawAnnotation(char *annotation,double x,double y)
{
  
  
  double xshift,yshift,xmodifier;
  double llx_clip,lly_clip,urx_clip,ury_clip;
  extern void MakeClip(double *llx_clip,double *lly_clip,double *urx_clip,double *ury_clip);
  

  if(!strcmp(annotation,"<No Annotation>"))
    {
      return;
    }

  
  MakeClip(&llx_clip,&lly_clip,&urx_clip,&ury_clip);
  
  if(x<llx_clip)
    {
      return;
    }
  if(y<lly_clip)
    {
      return;
    }
  if(x>urx_clip)
    {
      return;
    }
  if(y>ury_clip)
    {
      return;
    }

  yshift = -12.0;

  xshift = (double)strlen(annotation);

  if(USE_DOS==1)
  {
    xshift = xshift * 3.0; 
  }
  else if(USE_LITTLE==1)
  {
    xshift = xshift * 6.0; 
  }
  else
  {
    xshift = xshift * 6.0; 
  }
  
  
  x = x-(double)(IRegionSize*xshift/xunits);
  y = y-(double)(IRegionSize*yshift/xunits);

  xmodifier = (double)(IRegionSize*xshift/xunits);


  if(x<llx_clip)
    {
      x = llx_clip +   ((IRegionSize*4.0)/xunits);   
    }
  if( (x+(xmodifier*2)) > urx_clip)
    {
      x = urx_clip - (xmodifier*2) - ((IRegionSize*4.0)/xunits);  
    }

  
  MAPdrawstring(x,y,
		annotation,
		DRAW_COLOR_BLACK,
		0,
		DRAW_NOW,0);
}



void ShowPOIs()
{
  extern int DrawAnnotations;


  


  struct POIList *cfl;
  int old[3],lasttype=-1;
  int color;
  double X[3],Y[3],lastX,lastY;
  double xold,yold,si6,co6,si12,co12,si18,co18,si24,co24,si30,co30;
  
  
  old[0] = SHOW_POLY_VERTICES;
  old[1] = SHOW_LINE_VERTICES;
  old[2] = SHOW_END_VERTICES;
  SHOW_POLY_VERTICES = 0;
  SHOW_LINE_VERTICES = 0;
  SHOW_END_VERTICES  = 0;
  
  
  cfl = POIRoot;
  while(cfl != NULL)
    {
      
      if((cfl->type>=1)&&(cfl->type<=16))
	{
	  if(cfl->type%4 == 1)
	    {
	      color = DRAW_COLOR_SP_RED; 
	    }
	  else if (cfl->type%4 == 2)
	    {
	      color = DRAW_COLOR_BLUE;
	    }
	  else if (cfl->type%4 == 3)
	    {
	      color = DRAW_COLOR_MEDGREEN; 
	    }
	  else if (cfl->type%4 == 0)
	    {
	      color = DRAW_COLOR_YELLOW;
	    }

	  if(DrawAnnotations==1)
	    {
	      
	      DrawAnnotation(cfl->annotation,cfl->x,cfl->y);
	    }

	  if(cfl->type<=4)
	    {
	      
	      MAPdrawline(-1,
			  (double)(cfl->x-(double)(IRegionSize*10.0/xunits)),
			  (double)(cfl->y+(double)(IRegionSize*10.0/xunits)),
			  (double)(cfl->x+(double)(IRegionSize*10.0/xunits)),
			  (double)(cfl->y-(double)(IRegionSize*10.0/xunits)),
			  color,DRAW_NOW);
	      
	      MAPdrawline(-1,
			  (double)(cfl->x-(double)(IRegionSize*10.0/xunits)),
			  (double)(cfl->y-(double)(IRegionSize*10.0/xunits)),
			  (double)(cfl->x+(double)(IRegionSize*10.0/xunits)),
			  (double)(cfl->y+(double)(IRegionSize*10.0/xunits)),
			  color,DRAW_NOW);
	      
	    }
	  else if(cfl->type<=8)
	    {
	      
	      MAPdrawcircle(cfl->x,cfl->y,20.0,-1*color,DRAW_NOW);
	    }
	  else if(cfl->type<=12)
	    {
	      
	      
	      si6 = sin(0.0174532 * 60);
	      co6 = cos(0.0174532 * 60);
	      si12 = sin(0.0174532 * 120);
	      co12 = cos(0.0174532 * 120);
	      si18 = sin(0.0174532 * 180);
	      co18 = cos(0.0174532 * 180);
	      si24 = sin(0.0174532 * 240);
	      co24 = cos(0.0174532 * 240);
	      si30 = sin(0.0174532 * 300);
	      co30 = cos(0.0174532 * 300);
	      
	      xold = (double)(cfl->x + (double)(IRegionSize*10.0/xunits));
	      yold = (double)(cfl->y);
	      
	      xold = xold - (double)(cfl->x);
	      yold = yold - (double)(cfl->y);         
	      
	      X[0] = (xold*co6 - yold*si6)+(double)(cfl->x);
	      Y[0] = (xold*si6 + yold*co6)+(double)(cfl->y);
	      
	      X[1] = (xold*co18 - yold*si18)+(double)(cfl->x);
	      Y[1] = (xold*si18 + yold*co18)+(double)(cfl->y);
	      
	      X[2] = (xold*co30 - yold*si30)+(double)(cfl->x);
	      Y[2] = (xold*si30 + yold*co30)+(double)(cfl->y);
	      
	      MAPdrawpoly(3,X,Y,color,1,1,1,DRAW_NOW);
	      X[0] = (double)(cfl->x + (double)(IRegionSize*10.0/xunits));
	      Y[0] = cfl->y;
	      
	      X[1] = (xold*co12 - yold*si12)+(double)(cfl->x);
	      Y[1] = (xold*si12 + yold*co12)+(double)(cfl->y);
	      
	      X[2] = (xold*co24 - yold*si24)+(double)(cfl->x);
	      Y[2] = (xold*si24 + yold*co24)+(double)(cfl->y);
	      MAPdrawpoly(3,X,Y,color,1,1,1,DRAW_NOW);
	    }
	  else if(cfl->type<=16)
	    {
	      
	      X[0] = (double)(cfl->x-(double)(IRegionSize*10.0/xunits));
	      Y[0] = (double)(cfl->y-(double)(IRegionSize*9.0/yunits));
	      X[1] = (double)(cfl->x+(double)(IRegionSize*10.0/xunits));
	      Y[1] = (double)(cfl->y-(double)(IRegionSize*9.0/yunits));
	      X[2] = (double)(cfl->x);
	      Y[2] = (double)(cfl->y+(double)(IRegionSize*9.0/yunits));
	      MAPdrawpoly(3,X,Y,color,1,1,1,DRAW_NOW);
	    }



      if((POI_CONNECT==1)&&(lasttype==cfl->type))
	  {
        MySetLineThickness(2);
        MAPdrawline(-1,(double)cfl->x,(double)cfl->y,(double)lastX,(double)lastY,color,DRAW_NOW);
        MySetLineThickness(0);
	  }

	  lastX = cfl->x;
	  lastY = cfl->y;
	  lasttype = cfl->type;

	}
      else
	{
	  printf("bad type %d to DrawPOIs\n",cfl->type);
	  ExitWrapper(-1);
	}

      cfl = cfl->next;
    }

  SHOW_POLY_VERTICES = old[0];
  SHOW_LINE_VERTICES = old[1];
  SHOW_END_VERTICES  = old[2];
}





void ShowRegionMarkers()
{
  


  struct FilterList *cfl;
  double Xdiamond[4], Ydiamond[4];
  int old[3];
  int MARKERCOLOR = DRAW_COLOR_RED;



  
  ShowPOIs();
    

  old[0] = SHOW_POLY_VERTICES;
  old[1] = SHOW_LINE_VERTICES;
  old[2] = SHOW_END_VERTICES;
  SHOW_POLY_VERTICES = 0;
  SHOW_LINE_VERTICES = 0;
  SHOW_END_VERTICES  = 0;


  cfl = MarkerRoot;
  while(cfl != NULL)
    {
      if(NOT_ZOOMED==1)
	{

	  Xdiamond[0] = (double) (cfl->index1 * (int)RegionSize);
	  Xdiamond[2] = Xdiamond[0] + RegionSize;
	  Xdiamond[1] = Xdiamond[0] + (RegionSize / 2.0);
      Xdiamond[3] = Xdiamond[0] + (RegionSize / 2.0);
  
	  Ydiamond[3] = (double) (cfl->index2 * (int)RegionSize);
      Ydiamond[1] = Ydiamond[3] + RegionSize;
      Ydiamond[0] = Ydiamond[3] + (RegionSize / 2.0);
      Ydiamond[2] = Ydiamond[3] + (RegionSize / 2.0);
	  
	  Xdiamond[0] += (0.1 * RegionSize);
	  Ydiamond[3] += (0.1 * RegionSize);
	  Xdiamond[2] -= (0.1 * RegionSize);
	  Ydiamond[1] -= (0.1 * RegionSize);
	  

	  DRAWING_MARKERS = 1;
 	  NO_CIRCLES = 1;

	  MAPdrawpoly(4,Xdiamond,Ydiamond,(unsigned char)MARKERCOLOR,1,1,5,DRAW_NOW);
	  NO_CIRCLES = 0;
	  DRAWING_MARKERS = 0;
	}

      cfl = cfl->next;
    }

  SHOW_POLY_VERTICES = old[0];
  SHOW_LINE_VERTICES = old[1];
  SHOW_END_VERTICES  = old[2];
}








void TimList(Widget w, XEvent *event, String *args, int *num_args)
{
  int updown,num_items;
  int pos_count;
  int *pos_list;

  if(*num_args!=1)
  {
    printf("Err: TL NA %d\n",*num_args);
	return;
  }

  if(!strcmp(args[0],"1"))
  {
    updown = -1; 
  }
  else
  {
    updown = 1; 
  }

  XmListGetSelectedPos(w,&pos_list,&pos_count);
  if(pos_count!=1)
  {
    return;
  }

  if((pos_list[0]+updown)<=0)
  {
	return;
  }

  XtVaGetValues(w ,XmNitemCount,&num_items,NULL);

  if((pos_list[0]+updown)>num_items)
  {
	return;
  }

  XmListDeselectAllItems(w);
  XmListSelectPos(w,pos_list[0]+updown,1);
}


void InitializeTopLevelStuff()
{
  FILE *infile;
  unsigned char UCjunk;
  char fname[1000],lodname[1000];
  int tempnum,Ijunk,maxxindex,maxyindex,i,j,len,numindices,Iclass;
  long int Ljunk;
  double Djunk,xfactor,yfactor,Dfactor1,Dfactor2,LODRegionSize;


  sprintf(bitmapfolder,"%sbitmaps",indirectory);
  
  if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
    {
      strcat(bitmapfolder,"\\");
    }
  else
    {
      strcat(bitmapfolder,"/");
    }
  
  if(TestOut(bitmapfolder)==0)
    {
      printf("error: failed to create directory for writing: %s\n",bitmapfolder);
      temp_num_lods = -1;
      return;
    }
  
  
  
  
  sprintf(fname,"%sLODbands.bin",indirectory);
  
  infile = fopen(fname,"rb");
  if(infile == NULL)
    {
      printf("unable to open file %s for read\n",fname);
      temp_num_lods = -1;
      return;
    }
  
  SEEIT_fread_int(&tempnum,infile);
  
  if(tempnum<1)
    {
      printf("bad number of layers %d\n",tempnum);
      temp_num_lods = -1;
      fclose(infile);
      return;
    }
  
  LOD_geoms       = (int *)malloc(SzI*(tempnum+5));
  
  
  for(i=1;i<=tempnum;i++)
    {
      SEEIT_fread_int(&len,infile);
      fread(&lodname[0],1,len,infile);
      
      sscanf(lodname,"%d%d",&Iclass,&LOD_geoms[i]);
      if(
	 (LOD_geoms[i]!=C_POFE) &&
	 (LOD_geoms[i]!=C_LINE) &&
	 (LOD_geoms[i]!=C_AREA) &&
	 (LOD_geoms[i]!=C_GRID)
	 )
	{
	  printf("Bad geometry in layer %d = %s (%d)\n",i,lodname,LOD_geoms[i]);
	  temp_num_lods = -1;
	  fclose(infile);
	  return;
	}
      
            
      SEEIT_fread_int(&numindices,infile);
      for(j=0;j<numindices;j++)
	{
	  SEEIT_fread_int(&Ijunk,infile);
	}
    }
  
  fclose(infile);
  
  
  
  
  
  
  
  sprintf(fname,"%sheader.bin",indirectory);
  infile = fopen(fname,"rb");
  if(infile == NULL)
    {
      printf("could not open header information file %s\n",fname);
      temp_num_lods = -1;
      return;
    }
  
  fread(&UCjunk,SzUC,1,infile);
  SEEIT_fread_double(&Djunk,infile);
  SEEIT_fread_double(&Djunk,infile);
  SEEIT_fread_double(&Djunk,infile);
  SEEIT_fread_double(&Djunk,infile);
  
  SEEIT_fread_double(&Djunk,infile);
  SEEIT_fread_double(&Djunk,infile);
  SEEIT_fread_double(&Djunk,infile);
  SEEIT_fread_double(&Djunk,infile);
  
  SEEIT_fread_long(&Ljunk,infile);
  
  SEEIT_fread_long(&Ljunk,infile);
  SEEIT_fread_long(&Ljunk,infile);
  SEEIT_fread_long(&Ljunk,infile);
  SEEIT_fread_long(&Ljunk,infile);
  SEEIT_fread_int(&Ijunk,infile);
  SEEIT_fread_int(&Ijunk,infile);
  SEEIT_fread_int(&Ijunk,infile);
  SEEIT_fread_double(&LODRegionSize,infile);
  SEEIT_fread_double(&Djunk,infile);
  SEEIT_fread_double(&Djunk,infile);
  SEEIT_fread_double(&Djunk,infile);
  SEEIT_fread_double(&Djunk,infile);
  SEEIT_fread_int(&maxxindex,infile);
  SEEIT_fread_int(&maxyindex,infile);
  
  fclose(infile);
  
  maxxindex = maxxindex + 1; 
  maxyindex = maxyindex + 1; 
  

  Dfactor1 = (990.0/(double)maxxindex);
  Dfactor2 = (790.0/(double)maxyindex);

  if(Dfactor2<Dfactor1)
    {
      Dfactor1 = Dfactor2;
    }
  
  xpixels = (double)(Dfactor1 * (double)maxxindex);
  ypixels = (double)(Dfactor1 * (double)maxyindex);
  
  xfactor = xpixels/(double)(LODRegionSize*maxxindex);
  yfactor = ypixels/(double)(LODRegionSize*maxyindex);
  

  
  if(xfactor<yfactor)
    {
      scale_factor = xfactor;
    }
  else
    {
      scale_factor = yfactor;
    }
  
  
  if(scale_factor<=0)
    {
      temp_num_lods = -1;
      return;
    }
  
  
  
  
  layer_bitmaps = (Pixmap *) malloc(sizeof(Pixmap) * (tempnum+5));
  if(layer_bitmaps==NULL)
    {
      printf("out of memory trying to alloc %d layers\n",NumLODbands);
      ExitWrapper(-1);
    }
  
  
  layer_filled_bitmaps = (Pixmap *) malloc(sizeof(Pixmap) * (tempnum+5));
  if(layer_bitmaps==NULL)
    {
      printf("out of memory trying to alloc %d layers (2)\n",NumLODbands);
      ExitWrapper(-1);
    }
  
  
  XSetForeground(mydisplay,mybitgc,BITBLACK);
  
  for(i=1;i<=tempnum;i++)
    {
      layer_bitmaps[i] = XCreatePixmap (XtDisplay (drawing_a),
					RootWindowOfScreen (XtScreen (drawing_a)),
					(unsigned int)xpixels,(unsigned int)ypixels,
					1);  
      
      XFillRectangle (XtDisplay (drawing_a),layer_bitmaps[i], mybitgc, 
		      0, 0,(unsigned int)xpixels,(unsigned int)ypixels);
      
      
      if(LOD_geoms[i]==C_AREA)
	{
	  layer_filled_bitmaps[i] = XCreatePixmap (XtDisplay (drawing_a),
						   RootWindowOfScreen (XtScreen (drawing_a)),
						   (unsigned int)xpixels,(unsigned int)ypixels,
						   1);  
	  
	  XFillRectangle (XtDisplay (drawing_a),layer_filled_bitmaps[i], mybitgc, 
			  0, 0,(unsigned int)xpixels,(unsigned int)ypixels);
	}
    }
  
  
  
  XSetForeground(mydisplay,mybitgc,BITWHITE);
  
  temp_num_lods = tempnum;
}



void MyUpdateWindow(int type, int num, int total)
{
  

 
  ExtraTopLevel = 1;

  if(type==1)
    {
      layer_write_files       = num;
      layer_write_total_files = total;
      layer_gzip_files        = 0;
      layer_gzip_total_files  = total;
    }
  else
    {
      layer_write_files       = total;
      layer_write_total_files = total;
      layer_gzip_files        = num;
      layer_gzip_total_files  = total;
    }

  InitializationAdvice(0.0,0.0,0.0,0.0,0.0,3);

  ExtraTopLevel = 0;

}



void CloseTopLevelStuff()
{
  int i;
  char filename[1000];
  
  
  
  
  for(i=1;i<=temp_num_lods;i++)
    {
      
  
      MyUpdateWindow(1,i,temp_num_lods);
    
      sprintf(filename,"%s/%d.xbm",bitmapfolder,i);
      XWriteBitmapFile(mydisplay, filename, layer_bitmaps[i],(unsigned int)xpixels,(unsigned int)ypixels,-1,-1);      
      
      if(LOD_geoms[i]==C_AREA)
	{
	  sprintf(filename,"%s/%db.xbm",bitmapfolder,i);
	  XWriteBitmapFile(mydisplay,filename,layer_filled_bitmaps[i],(unsigned int)xpixels,(unsigned int)ypixels,-1,-1);
	}
    }
  
  
  for(i=1;i<=temp_num_lods;i++)
    {
      MyUpdateWindow(2,i,temp_num_lods);
      
      XFreePixmap(mydisplay, layer_bitmaps[i]);
      if(LOD_geoms[i]==C_AREA)
	{
	  XFreePixmap(mydisplay, layer_filled_bitmaps[i]);
	}
      
      sprintf(filename,"gzip -f -1 \"%s%d.xbm\"",bitmapfolder,i);
      system(filename);
      
      if(LOD_geoms[i]==C_AREA)
	{
	  sprintf(filename,"gzip -f -1 \"%s%db.xbm\"",bitmapfolder,i);
	  system(filename);
	}
    }
  
  free(layer_bitmaps);
  free(layer_filled_bitmaps);
  free(LOD_geoms);
  
  
  
  
  temp_num_lods = -1;
  
  if(toppointsnum>0)
    {
      free(Toppoints);
      toppointsnum = 0;
    }
  
}



void ResetTopPoints(int num)
{
  
  if(toppointsnum>0)
    {
      free(Toppoints);
      toppointsnum = 0;
    }
  
  toppointsnum = num+1000;
  Toppoints = (XPoint *) (malloc(sizeof(XPoint) * (toppointsnum+5)));
  
}


short int ProcessX(short int inx)
{
  if(inx<0)
    {
      return 0;
    }
  if(inx>=xpixels)
    {
      return (short int)(xpixels-1);
    }
  return inx;
}

short int ProcessY(short int iny)
{
  if(iny<0)
    {
      return 0;
    }
  if(iny>=ypixels)
    {
      return (short int)(ypixels-1);
    }
  return iny;
}




void ProcessTopLevel(struct AreaAndHoles *areafeature,double *X,double *Y,int numverts,
		     double x,double y,int layer, int geomtype)
{
  Region exterior,hole;
  short int xcenter,ycenter;
  int i,j,insertindex,numdrawverts,numholesfound;
  struct AreaRing * temp;
  
  
  if(temp_num_lods<0)
    {
      InitializeTopLevelStuff();
    }
  
  if(scale_factor<=0)
    {
      XBell(mydisplay,50);
      printf("problem with scale factor %lf.  Aborting top level draw\n",scale_factor);
      return;
    }
  
  if(temp_num_lods<0)
    {
      XBell(mydisplay,50);
      printf("Error Creating Top Level View: found 0 layers\n");
      return;
    }
  
  
  if(layer>temp_num_lods)
    {
      XBell(mydisplay,50);
      printf("Error Creating Top Level View: found layer %d/%d\n",layer,temp_num_lods);
      return;
    }
  
  
  
  if(geomtype==C_POFE)
    {
      xcenter = (short int)(x*scale_factor);
      ycenter = (short int)(ypixels - y*scale_factor);
      
      
      if(
	 (xcenter>=5)           &&
	 (xcenter<=(xpixels-6)) &&
	 (ycenter>=5)           &&
	 (ycenter<=(ypixels-6))
	 )
	{
	  XDrawLine(mydisplay,layer_bitmaps[layer],mybitgc,xcenter-5,ycenter-5,xcenter+5,ycenter+5);
	  XDrawLine(mydisplay,layer_bitmaps[layer],mybitgc,xcenter-5,ycenter+5,xcenter+5,ycenter-5);
	}
      else
	{
	  
	  
	  for(i=xcenter-5,j=ycenter-5;  ((i<=(xcenter+5))&&(j<=ycenter+5));  i++,j++)
	    {
	      if(
		 (i>=0)       &&
		 (i<xpixels)  &&
		 (j>=0)       &&
		 (j<ypixels)
		 )
		{
		  XDrawPoint (mydisplay,layer_bitmaps[layer],mybitgc,(short int)i,(short int)j);
		}
	    }
	  
	  for(i=xcenter-5,j=ycenter+5;   ((i<=(xcenter+5))&&(j>=ycenter-5));  i++,j--)
	    {
	      if(
		 (i>=0)       &&
		 (i<xpixels)  &&
		 (j>=0)       &&
		 (j<ypixels)
		 )
		{
		  XDrawPoint (mydisplay,layer_bitmaps[layer],mybitgc,(short int)i,(short int)j);
		}
	    }
	}
      
      
    }
  
  
  
  
  
  else if(geomtype==C_LINE)
    {
      if(numverts>=toppointsnum)
	{
	  ResetTopPoints(numverts);
	}
      
      insertindex = 0;
      for(i=0;i<numverts;i++)
	{
	  
	  
	  Toppoints[i].x = ProcessX((short int)(           (X[i]*scale_factor)));
	  Toppoints[i].y = ProcessY((short int)(ypixels -  (Y[i]*scale_factor)));
	  
	  if(i>0)
	    {
	      if(
		 (Toppoints[i].x!=Toppoints[insertindex].x) ||
		 (Toppoints[i].y!=Toppoints[insertindex].y) 
		 )
		{
		  insertindex = insertindex + 1;
		  Toppoints[insertindex].x = Toppoints[i].x;
		  Toppoints[insertindex].y = Toppoints[i].y;
		}
	    }
	}
      
      numdrawverts = insertindex + 1;
      
      XDrawLines(mydisplay,layer_bitmaps[layer],mybitgc,Toppoints,numdrawverts,CoordModeOrigin);
    }
  
  
  
  else if(geomtype==C_GRID)
  { 
      
    if(numverts>=toppointsnum)
	{ 
      ResetTopPoints(numverts);
	}
      
    insertindex = 0;

    for(i=0;i<numverts;i++)
	{
	  
	  
	  Toppoints[i].x = ProcessX((short int)(           (X[i]*scale_factor)));
	  Toppoints[i].y = ProcessY((short int)(ypixels -  (Y[i]*scale_factor)));
	  
	  if(i>0)
	    {
	      if(
		 (Toppoints[i].x!=Toppoints[insertindex].x) ||
		 (Toppoints[i].y!=Toppoints[insertindex].y) 
		 )
		{
		  insertindex = insertindex + 1;
		  Toppoints[insertindex].x = Toppoints[i].x;
		  Toppoints[insertindex].y = Toppoints[i].y;
		}
	  }
	}
      
    insertindex = insertindex + 1;
    Toppoints[insertindex].x = Toppoints[0].x;
    Toppoints[insertindex].y = Toppoints[0].y;
      
    numdrawverts = insertindex + 1;
      
    XFillPolygon(mydisplay,layer_bitmaps[layer],mybitgc,Toppoints,numdrawverts,Convex,CoordModeOrigin);
          
  } 
  
  
  
  
  else if(geomtype==C_AREA)
    {
      
      
      if(areafeature->outer->numverts>=toppointsnum)
	{
	  ResetTopPoints(areafeature->outer->numverts);
	}      
      
      
      
      
      
      
      temp = areafeature->inner;
      numholesfound = 0;
      
      while(temp!=NULL)
	{
	  
	  numholesfound = numholesfound + 1;
	  
	  if(temp->numverts>=toppointsnum)
	    {
	      ResetTopPoints(temp->numverts);
	    }
	  
	  insertindex = 0;
	  for(i=0;i<temp->numverts;i++)
	    {
	      
	      
	      Toppoints[i].x = ProcessX((short int)(           (temp->x[i]*scale_factor)));
	      Toppoints[i].y = ProcessY((short int)(ypixels -  (temp->y[i]*scale_factor)));
	      
	      
	      
	      if(i>0)
		{
		  if(
		     (Toppoints[i].x!=Toppoints[insertindex].x) ||
		     (Toppoints[i].y!=Toppoints[insertindex].y) 
		     )
		    {
		      insertindex = insertindex + 1;
		      Toppoints[insertindex].x = Toppoints[i].x;
		      Toppoints[insertindex].y = Toppoints[i].y;
		    }
		}
	    }
	  
	  numdrawverts = insertindex + 1;
	  
	  XDrawLines(mydisplay,layer_bitmaps[layer],       mybitgc,Toppoints,numdrawverts,CoordModeOrigin);
	  XDrawLines(mydisplay,layer_filled_bitmaps[layer],mybitgc,Toppoints,numdrawverts,CoordModeOrigin);
	  
	  temp = temp->next;
	}
      
      if(numholesfound!=areafeature->numholes)
	{
	  XBell(mydisplay,50);
	  printf("Error: reported number of holes %d, actual number %d\n",areafeature->numholes,numholesfound);
	}
      
      
      
      
      
      
      
      
      insertindex = 0;
      for(i=0;i<areafeature->outer->numverts;i++)
	{
	  
	  
	  
	  
	  Toppoints[i].x = ProcessX((short int)(           (areafeature->outer->x[i]*scale_factor)));
	  Toppoints[i].y = ProcessY((short int)(ypixels -  (areafeature->outer->y[i]*scale_factor)));
	  
	  if(i>0)
	    {
	      if(
		 (Toppoints[i].x!=Toppoints[insertindex].x) ||
		 (Toppoints[i].y!=Toppoints[insertindex].y) 
		 )
		{
		  insertindex = insertindex + 1;
		  Toppoints[insertindex].x = Toppoints[i].x;
		  Toppoints[insertindex].y = Toppoints[i].y;
		}
	    }
	}
      
      insertindex = insertindex + 1;
      Toppoints[insertindex].x = Toppoints[0].x;
      Toppoints[insertindex].y = Toppoints[0].y;
      
      numdrawverts = insertindex + 1;
      
      exterior = XPolygonRegion(Toppoints,numdrawverts,EvenOddRule);
      
      
      
      
      
      temp = areafeature->inner;
      
      while(temp!=NULL)
	{
	  
	  
	  insertindex = 0;
	  for(i=0;i<temp->numverts;i++)
	    {
	      
	      
	      
	      Toppoints[i].x = ProcessX((short int)(           (temp->x[i]*scale_factor)));
	      Toppoints[i].y = ProcessY((short int)(ypixels -  (temp->y[i]*scale_factor)));
	      
	      if(i>0)
		{
		  if(
		     (Toppoints[i].x!=Toppoints[insertindex].x) ||
		     (Toppoints[i].y!=Toppoints[insertindex].y) 
		     )
		    {
		      insertindex = insertindex + 1;
		      Toppoints[insertindex].x = Toppoints[i].x;
		      Toppoints[insertindex].y = Toppoints[i].y;
		    }
		}
	    }
	  
	  numdrawverts = insertindex + 1;
	  
	  if(numdrawverts>2)
	    {
	      hole = XPolygonRegion(Toppoints,numdrawverts,EvenOddRule);	  
	      XSubtractRegion(exterior,hole,exterior);	  
	      XDestroyRegion(hole);
	    }
	  
	  temp = temp->next;
	}
      
      
      
      
      
      
      
      insertindex = 0;
      for(i=0;i<areafeature->outer->numverts;i++)
	{
	  
	  
	  Toppoints[i].x = ProcessX((short int)(           (areafeature->outer->x[i]*scale_factor)));
	  Toppoints[i].y = ProcessY((short int)(ypixels -  (areafeature->outer->y[i]*scale_factor)));
	  
	  
	  if(i>0)
	    {
	      if(
		 (Toppoints[i].x!=Toppoints[insertindex].x) ||
		 (Toppoints[i].y!=Toppoints[insertindex].y) 
		 )
		{
		  insertindex = insertindex + 1;
		  Toppoints[insertindex].x = Toppoints[i].x;
		  Toppoints[insertindex].y = Toppoints[i].y;
		}
	    }
	}
      
      numdrawverts = insertindex + 1;
      
      
      XDrawLines(mydisplay,layer_bitmaps[layer],mybitgc,Toppoints,numdrawverts,CoordModeOrigin);
      
      
      
      XSetRegion(mydisplay, mybitgc, exterior);
      
      
      XFillPolygon(mydisplay,layer_filled_bitmaps[layer],mybitgc,Toppoints,numdrawverts,Nonconvex,CoordModeOrigin);
      
      
      
      XDestroyRegion(exterior);
      XSetClipMask(mydisplay,mybitgc,None);
      
    }
}





void FillInDefaults()
{
  FILE *infile;
  char filename[5000],first[1000],second[1000],aline[1000];
  int result,i,rendertype,styletype,red,green,blue,layer_num;
  Colormap local_cmap = DefaultColormapOfScreen (XtScreen (drawing_a));

  
  
  
  
  
  for(i=0;i<NumLODbands;i++)
    {
      if(LODindex_DYN[i].geom==C_POFE)
	{
	  POINT_ECCS_USED[LODindex_DYN[i].ECC] = 1;
	}
      else if(LODindex_DYN[i].geom==C_LINE)
	{
	  LINE_ECCS_USED[LODindex_DYN[i].ECC] = 1;
	}
      else if(LODindex_DYN[i].geom==C_AREA)
	{
	  AREA_ECCS_USED[LODindex_DYN[i].ECC] = 1;
	}
    }
  
  
  
  
  
  
  
  
  
  
  
  if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
    {
      sprintf(filename,"%s\\ProjectPreferences\\%s",PROJECTLOC,layer_pref_file);
    }
  else
    {
      sprintf(filename,"%s/ProjectPreferences/%s",PROJECTLOC,layer_pref_file);
    }
  
  
  infile = fopen(filename,"r");
  if(infile==NULL)
    {
      sprintf(aline,"\
Error:  Could not open selected layer preference file for reading.\n%s\nDefault layer preferences will be used instead.\n",filename);
      
      not_while_running(drawing_a,aline,1451,"Could not open layer pref file",5);
      
      return;
    }
  
  first[0]  = '\0';
  second[0] = '\0';
  fgets(aline,1000,infile);
  
  
  while(!feof(infile))
    {
      sscanf(aline,"%s%s",first,second);
      
      if(!strcmp(first,"AREA"))
	{
	  result = SilentGetCodeIndex(second);
	  if(result>=0)
	    {
	      
	      if(AREA_ECCS_USED[result]==1)
		{
		  
		  sscanf(aline,"%s%s%d%d%d%d%d",first,second,&rendertype,&styletype,&red,&green,&blue);
		  
		  if(testvalues(aline,first,second,rendertype,styletype,red,green,blue)==1)
		    {
		      layer_num = GetLayerNum(C_AREA,result);
		      
		      if(layer_num>=0)
			{
			  LODindex_DYN[layer_num].draw_priority = rendertype;
			  LODindex_DYN[layer_num].draw_style    = styletype;
			  LODindex_DYN[layer_num].temp_style    = styletype;
			  
			  layer_colors[layer_num].red   = red;
			  layer_colors[layer_num].green = green;
			  layer_colors[layer_num].blue  = blue;
			  
			  
			  if (!XAllocColor (XtDisplay (drawing_a), local_cmap, &layer_colors[layer_num])) 
			    {
			      puts ("Couldn't XAllocColor!"); 
			    }
			  else
			    {
			      layer_colors[layer_num].red   = red;
			      layer_colors[layer_num].green = green;
			      layer_colors[layer_num].blue  = blue;

			      LODindex[LODindex_DYN[layer_num].other_index].temp_color  = layer_colors[layer_num].pixel;
			      LODindex[LODindex_DYN[layer_num].other_index].temp_rcolor = layer_colors[layer_num].red;
			      LODindex[LODindex_DYN[layer_num].other_index].temp_gcolor = layer_colors[layer_num].green;
			      LODindex[LODindex_DYN[layer_num].other_index].temp_bcolor = layer_colors[layer_num].blue;    
			      
			      LODindex[LODindex_DYN[layer_num].other_index].color  = layer_colors[layer_num].pixel;
			      LODindex[LODindex_DYN[layer_num].other_index].rcolor = layer_colors[layer_num].red;
			      LODindex[LODindex_DYN[layer_num].other_index].gcolor = layer_colors[layer_num].green;
			      LODindex[LODindex_DYN[layer_num].other_index].bcolor = layer_colors[layer_num].blue;
			    }
			}
		    }
		}
	    }
	}
      
      
      
      
      
      if(!strcmp(first,"POINT"))
	{
	  result = SilentGetCodeIndex(second);
	  if(result>=0)
	    {
	      
	      if(POINT_ECCS_USED[result]==1)
		{
		  
		  sscanf(aline,"%s%s%d%d%d%d%d",first,second,&rendertype,&styletype,&red,&green,&blue);
		  
		  
		  if(testvalues(aline,first,second,rendertype,styletype,red,green,blue)==1)
		    {
		      
		      layer_num = GetLayerNum(C_POFE,result);
		      
		      if(layer_num>=0)
			{
			  LODindex_DYN[layer_num].draw_priority = rendertype;
   			  LODindex_DYN[layer_num].draw_style    = styletype;
   			  LODindex_DYN[layer_num].temp_style    = styletype;
			  
			  layer_colors[layer_num].red   = red;
			  layer_colors[layer_num].green = green;
			  layer_colors[layer_num].blue  = blue;
			  
			  
			  if (!XAllocColor (XtDisplay (drawing_a), local_cmap, &layer_colors[layer_num])) 
			    {
			      puts ("Couldn't XAllocColor!"); 
			    }
			  else
			    {
			      layer_colors[layer_num].red   = red;
			      layer_colors[layer_num].green = green;
			      layer_colors[layer_num].blue  = blue;

			      LODindex[LODindex_DYN[layer_num].other_index].temp_color  = layer_colors[layer_num].pixel;
			      LODindex[LODindex_DYN[layer_num].other_index].temp_rcolor = layer_colors[layer_num].red;
			      LODindex[LODindex_DYN[layer_num].other_index].temp_gcolor = layer_colors[layer_num].green;
			      LODindex[LODindex_DYN[layer_num].other_index].temp_bcolor = layer_colors[layer_num].blue;    
			      
			      LODindex[LODindex_DYN[layer_num].other_index].color  = layer_colors[layer_num].pixel;
			      LODindex[LODindex_DYN[layer_num].other_index].rcolor = layer_colors[layer_num].red;
			      LODindex[LODindex_DYN[layer_num].other_index].gcolor = layer_colors[layer_num].green;
			      LODindex[LODindex_DYN[layer_num].other_index].bcolor = layer_colors[layer_num].blue;
			    }
			}
		    }
		}
	    }
	}
      
      
      
      
      
      if(!strcmp(first,"LINE"))
	{
	  result = SilentGetCodeIndex(second);
	  if(result>=0)
	    {
	      
	      if(LINE_ECCS_USED[result]==1)
		{
		  
		  sscanf(aline,"%s%s%d%d%d%d%d",first,second,&rendertype,&styletype,&red,&green,&blue);
		  
		  
		  if(testvalues(aline,first,second,rendertype,styletype,red,green,blue)==1)
		    {
		      
		      layer_num = GetLayerNum(C_LINE,result);
		      
		      if(layer_num>=0)
			{
			  LODindex_DYN[layer_num].draw_priority = rendertype;
			  LODindex_DYN[layer_num].draw_style    = styletype;
			  LODindex_DYN[layer_num].temp_style    = styletype;
			  			  			  
			  layer_colors[layer_num].red   = red;
			  layer_colors[layer_num].green = green;
			  layer_colors[layer_num].blue  = blue;
			  
			  
			  if (!XAllocColor (XtDisplay (drawing_a), local_cmap, &layer_colors[layer_num])) 
			    {
			      puts ("Couldn't XAllocColor!"); 
			    }
			  else
			    {
			      layer_colors[layer_num].red   = red;
			      layer_colors[layer_num].green = green;
			      layer_colors[layer_num].blue  = blue;
			      
			      LODindex[LODindex_DYN[layer_num].other_index].temp_color  = layer_colors[layer_num].pixel;
			      LODindex[LODindex_DYN[layer_num].other_index].temp_rcolor = layer_colors[layer_num].red;
			      LODindex[LODindex_DYN[layer_num].other_index].temp_gcolor = layer_colors[layer_num].green;
			      LODindex[LODindex_DYN[layer_num].other_index].temp_bcolor = layer_colors[layer_num].blue;    
			      
			      LODindex[LODindex_DYN[layer_num].other_index].color  = layer_colors[layer_num].pixel;
			      LODindex[LODindex_DYN[layer_num].other_index].rcolor = layer_colors[layer_num].red;
			      LODindex[LODindex_DYN[layer_num].other_index].gcolor = layer_colors[layer_num].green;
			      LODindex[LODindex_DYN[layer_num].other_index].bcolor = layer_colors[layer_num].blue;
			    }
			}
		    }
		}
	    }
	}
      
      
      
      fgets(aline,1000,infile);
    }
  
  
  fclose(infile);
  
}


void SetLayerPrefCallback(Widget w, Widget list_w, XtPointer callData)
{
  
  XmString *selectlist;
  char *text;
  char message[1000];
  int totalobjs;
  
  
  XtVaGetValues(list_w,
		XmNselectedItemCount,&totalobjs,
		XmNselectedItems    ,&selectlist,
		NULL);
  
  
  if(totalobjs!=1)
    {
      sprintf(message,"To select a layer preference set, select one from\n\
the list, and then click \"Use Selected Layer Preference Set\",\n\
or double-click it in the list.");
      
      not_while_running(w,message,1452,"Select Layer Preferences Help",5);
      
      return;
    }
  
  XmStringGetLtoR(selectlist[0],
		  (XmStringCharSet) XmSTRING_DEFAULT_CHARSET, &text);
  
  
  sprintf(layer_save_file,"%s",text);
  
  layer_save_file_selected = 1;
  
  XtVaSetValues(savepref_wid,
		XmNlabelString,      STRING(layer_save_file),
		NULL);  
  
  XtDestroyWidget(pref_dialog2);
  
}


void prefHelpCallback(Widget w, XtPointer userData, XtPointer callData)
{
  char message[2000];
  
  sprintf(message,"\
This window can be used to load and save layer preference sets.\n\
Layer preference sets define layer options such as colors, drawing priorities,\n\
and styles.\n\n\
To load a previously saved layer preference set, select it using the\n\
\"Choose...\" button, and then click \"Load Selected Layer Preferences\".\n\n\
To save your existing preferences, it is necessary to first select which\n\
existing preference set you wish to modify with your changes.  Do this by using\n\
the \"Choose...\" button.  You must also enter a name for the new preference set\n\
you are creating.  You can overwrite an existing set if you wish.\n\n\
After you have selected the existing preference set you wish to modify with your\n\
changes, and you have entered the name for the resulting preference set, click\n\
\"Using Current Settings, Create New Preference Set By Modifying Selected Set\".\n\
This will apply your settings to the existing preference set, creating a new one.\n\
You can then use this new preference set when creating projects or by loading\n\
them in existing projects using this same window.");

  
  not_while_running(w,message,1453,"Save/Load Layer Prefs Help",5);
}


void loadSavedPrefs(Widget w, XtPointer userData, XtPointer callData)
{
  Position px1, py1;
  char savefile[1000],test[1000];
  extern Widget lod_head,lod_head2;
  extern int layer_prefs_set,lod_head_in_use,dead_lod_head,dead_lod_head2;
  extern char layer_pref_file[100];

  extern Widget lod_head,lod_head2;
  extern Dimension lod_hgt;
  extern int dead_lod_head, lod_head_in_use;




  
  if(!strcmp(layer_save_file,"<none selected>"))
    {
      not_while_running(w,"To load a set of layer preferences, you must first select one.\n\
Use the \"Choose...\" button on the \"Save/Load Layer Preferences\"\n\
window to select a set of layer preferences.",1453,"Load Layer Prefs Error",5);
      return;
    }
  
  
  
  printf("load the pref file %s\n",layer_save_file);
  
  
  if((lod_head_in_use==0)&&(dead_lod_head==0))
    {
      XtPopdown(lod_head);
    } 
  else if((lod_head_in_use==1)&&(dead_lod_head2==0))
    {
      XtPopdown(lod_head2);
    }


  XtPopdown(XtParent(XtParent(XtParent(w))));
  XtDestroyWidget(XtParent(XtParent(XtParent(w))));
  
  
  
  
  
  if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
    {
      sprintf(test,"del \"%slayercolors.txt\"",indirectory);
      system(test);
    }
  else
    {
      sprintf(test,"rm \"%slayercolors.txt\"",indirectory);
      system(test);
    }
  
  
  
  
  if(layer_prefs_set==1)
    {
      sprintf(savefile,"%s",layer_pref_file);
    }
  
  sprintf(layer_pref_file,"%s",layer_save_file);
  
  
  InitLayerStuff();
  
  FillInRenderOrder();
  
  if(layer_prefs_set==1)
    {
      sprintf(layer_pref_file,"%s",savefile);
    }
  


  Record_SAVE_TOPCHANGE(2);
  RebuildTopImage(0);
  
  
  

 

  if((lod_head_in_use==0)&&(dead_lod_head==0))
    {
      XtVaGetValues(lod_head,XmNx,     &px1,NULL);  
      XtVaGetValues(lod_head,XmNy,     &py1,NULL);  
      XtVaGetValues(lod_head,XmNheight,&lod_hgt,NULL);  

      if(USE_DOS==1)
	{
	  px1 = px1 - 4;     
	  py1 = py1 - 30;     
	}

      if(px1<10)
        {
          px1 = 10;
        }
      if(py1<10)
        {
          py1 = 10;
        } 

      XtDestroyWidget(lod_head);
      dead_lod_head=1;
      lod_head_in_use=1;
      LODCallback(drawing_a,(XtPointer)((int)px1),(XtPointer)((int)py1));
    }
  else if((lod_head_in_use==1)&&(dead_lod_head2==0))
    {
      XtVaGetValues(lod_head2,XmNx,     &px1,NULL);  
      XtVaGetValues(lod_head2,XmNy,     &py1,NULL);  
      XtVaGetValues(lod_head2,XmNheight,&lod_hgt,NULL);  

      if(USE_DOS==1)
	{
	  px1 = px1 - 4;     
	  py1 = py1 - 30;     
	}

      if(px1<10)
        {
          px1 = 10;
        }
      if(py1<10)
        {
          py1 = 10;
        } 

      XtDestroyWidget(lod_head2);
      dead_lod_head2=1;
      lod_head_in_use=0;
      LODCallback(drawing_a,(XtPointer)((int)px1),(XtPointer)((int)py1));
    }








  
  SetColorRight();
  
  refreshCallback((Widget)NULL,(XtPointer)NULL,(XtPointer)NULL);
    
}






int PartitionLayerStuff(int p,int r)
{
  int i,j,tempI;
  char tempchar[100];
  
  i = p-1;
  j = r+1;
  while(1)
    {
      do{j=j-1;}
      while(strcmp(others[j],others[p])>0);
      
      do{i=i+1;}
      while(strcmp(others[i],others[p])<0);
      
      if(i<j)
	{
	  sprintf(tempchar,"%s",others[i]);
	  sprintf(others[i],"%s",others[j]);
	  sprintf(others[j],"%s",tempchar);

	  tempI = geoms[i];
	  geoms[i] = geoms[j];
	  geoms[j] = tempI;

	  tempI = renders[i];
	  renders[i] = renders[j];
	  renders[j] = tempI;

	  tempI = styles[i];
	  styles[i] = styles[j];
	  styles[j] = tempI;

	  tempI = reds[i];
	  reds[i] = reds[j];
	  reds[j] = tempI;

	  tempI = greens[i];
	  greens[i] = greens[j];
	  greens[j] = tempI;

	  tempI = blues[i];
	  blues[i] = blues[j];
	  blues[j] = tempI;

	  

	  sprintf(tempchar,"%s",fcodes[i]);
	  sprintf(fcodes[i],"%s",fcodes[j]);
	  sprintf(fcodes[j],"%s",tempchar);
	}
      else
	{
	  return j;
	}
    }
}


void SortLayerStuff(int p,int r)
{
  int q;
  if(p<r)
    {
      q = PartitionLayerStuff(p,r);
      SortLayerStuff(p,q);
      SortLayerStuff(q+1,r);
    }
}


int BadAttrSchema(int num)
{
  
  if((num<1)||(num>NUM_ATTR_SCHEMA))
  {
    return 1;
  }
  if((num>=15)&&(num<=22))
  {
    return 1;
  }
  if(num==28)
  {
    return 1;
  }
  if((num>=30)&&(num<=38))
  {
    return 1;
  }
  if((num>=40)&&(num<=42))
  {
    return 1;
  }
  if(num==44)
  {
    return 1;
  }
  if(num==46)
  {
    return 1;
  }



  if(USE_NFDD==0)
  {
    if((num==23)||(num==24))
	{
      return 1;
	}
  }

  if(USE_DFDD==0)
  {
    if((num==25)||(num==26))
	{
      return 1;
	}
  }

  return 0;

}

void ModifyLayerFile(int type,Widget w)
{
  FILE *infile,*outfile;
  char filename[1000],aline[1000],fcode[1000],first[1000],geomtype[1000],saveTMP[1000];
  int numlines=0,i,j,badinput,numspaces,len,save_attr_type,insertindex,domain,
    layer_num,numchecked;

  

  if(type>1)
    {
      

      save_attr_type = ATTRIBUTION_TYPE;
      numlines = 0;
      
      for(i=2;i<=NUM_ATTR_SCHEMA;i++) 
	{
	  if(BadAttrSchema(i))
	  {
        continue;
	  }

	  ATTRIBUTION_TYPE = i;
	  
	  InitializeAttribution();
	  
	  numlines = numlines + GIFD_CLASS_NUM;
	}

      numlines = numlines *3;
      printf("overall total is %d\n",numlines);  

      
      geoms   = (int *)malloc(SzI * (numlines+5));
      renders = (int *)malloc(SzI * (numlines+5));
      styles  = (int *)malloc(SzI * (numlines+5));
      reds    = (int *)malloc(SzI * (numlines+5));
      greens  = (int *)malloc(SzI * (numlines+5));
      blues   = (int *)malloc(SzI * (numlines+5));
      
      fcodes  = (char **)malloc(sizeof(char *) * (numlines+5));
      for(i=0;i<numlines;i++)
	{
	  fcodes[i] = (char *)malloc(10);
	}
      
      others  = (char **)malloc(sizeof(char *) * (numlines+5));
      for(i=0;i<numlines;i++)
	{
	  others[i] = (char *)malloc(100);
	}



      
      

      sprintf(saveTMP,"%s",layer_pref_file);
      if(type==3)
	{
	  sprintf(layer_pref_file,"Default (Baseline)");
	}
      else
	{
	  sprintf(layer_pref_file,"Default (MGCP)");
	}
      
      
      
      insertindex = 0;
      
      for(j=2;j<=NUM_ATTR_SCHEMA;j++) 
	{
	  if(BadAttrSchema(j))
	  {
        continue;
	  }

	  ATTRIBUTION_TYPE = j;
	  
	  InitializeAttribution();
	  	  
	  for(i=1;i<=GIFD_CLASS_NUM;i++)
	    {
	      domain = DOMAINS[i];
	      
	      geoms   [insertindex] = C_POFE;
	      renders [insertindex] = GetDefaultDrawPri(i);
	      styles  [insertindex] = -1;
	      reds    [insertindex] = DOMAIN_R[domain];
	      greens  [insertindex] = DOMAIN_G[domain];
	      blues   [insertindex] = DOMAIN_B[domain];
	      sprintf(fcodes[insertindex],"%s",GetECCCode(i));
	      insertindex = insertindex + 1;
	      
	      geoms   [insertindex] = C_LINE;
	      renders [insertindex] = GetDefaultDrawPri(i);
	      styles  [insertindex] = -1;
	      reds    [insertindex] = DOMAIN_R[domain];
	      greens  [insertindex] = DOMAIN_G[domain];
	      blues   [insertindex] = DOMAIN_B[domain];
	      sprintf(fcodes[insertindex],"%s",GetECCCode(i));
	      insertindex = insertindex + 1;

	      geoms   [insertindex] = C_AREA;
	      renders [insertindex] = GetDefaultDrawPri(i);
	      styles  [insertindex] = 4;
	      reds    [insertindex] = DOMAIN_R[domain];
	      greens  [insertindex] = DOMAIN_G[domain];
	      blues   [insertindex] = DOMAIN_B[domain];
	      sprintf(fcodes[insertindex],"%s",GetECCCode(i));	      
	      insertindex = insertindex + 1;
	    }
	}

      sprintf(layer_pref_file,"%s",saveTMP);

      ATTRIBUTION_TYPE = save_attr_type;

      
      InitializeAttribution();


      for(i=0;i<numlines;i++)
	{
	  if(geoms[i]==C_AREA)
	    {
	      sprintf(others[i],"AREA %s %d %d %d %d %d",
		      fcodes[i],renders[i],styles[i],reds[i],greens[i],blues[i]);
	    }
	  else if(geoms[i]==C_LINE)
	    {
	      sprintf(others[i],"LINE %s %d %d %d %d %d",
		      fcodes[i],renders[i],styles[i],reds[i],greens[i],blues[i]);
	    }
	  else if(geoms[i]==C_POFE)
	    {
	      sprintf(others[i],"POINT %s %d %d %d %d %d",
		      fcodes[i],renders[i],styles[i],reds[i],greens[i],blues[i]);
	    }
	}

      SortLayerStuff(0,numlines-1);

      for(i=0;i<numlines;i++)
	{
	  

	  numchecked=0;
	  for(j=i+1;j<numlines;j++)
	    {
	      
	      numchecked = numchecked + 1;
	      if(numchecked>5)
		{
		  break;
		}
	      
	      if  ( (!strcmp(fcodes[i],fcodes[j])) && (geoms[i]==geoms[j]) )
		{
		  geoms[j] = -2;
		}
	    }
	}
    }


  else if(type==1)
    {
      if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
	{
	  sprintf(filename,"%s\\ProjectPreferences\\%s",PROJECTLOC,layer_save_file);
	}
      else
	{
	  sprintf(filename,"%s/ProjectPreferences/%s",PROJECTLOC,layer_save_file);
	}
      
      
      infile = fopen(filename,"r");
      if(infile==NULL)
	{
	  sprintf(aline,"Error:  Could not open selected layer preference file for reading:\n  %s",
		  filename);
	  
	  not_while_running(drawing_a,aline,1457,"Could not open layer pref file",5);
	  
	  return;
	}
      
      
      fgets(aline,1000,infile);
      while(!feof(infile))
	{      
	  numlines = numlines + 1;
	  fgets(aline,1000,infile);
	}
      
      rewind(infile);
      
      
      geoms   = (int *)malloc(SzI * (numlines+5));
      renders = (int *)malloc(SzI * (numlines+5));
      styles  = (int *)malloc(SzI * (numlines+5));
      reds    = (int *)malloc(SzI * (numlines+5));
      greens  = (int *)malloc(SzI * (numlines+5));
      blues   = (int *)malloc(SzI * (numlines+5));
      
      fcodes  = (char **)malloc(sizeof(char *) * (numlines+5));
      for(i=0;i<numlines;i++)
	{
	  fcodes[i] = (char *)malloc(10);
	}
      
      others  = (char **)malloc(sizeof(char *) * (numlines+5));
      for(i=0;i<numlines;i++)
	{
	  others[i] = NULL;
	}
      
      fgets(aline,1000,infile);
      numlines = 0;
      badinput = 0;
      while(!feof(infile))
	{      
	   
	  
	  numlines = numlines + 1;
	  
	  first[0] = '\0';
	  sscanf(aline,"%s",first);
	  
	  if(strcmp(first,"##"))
	    {
	      
	      
	      len = strlen(aline);
	      
	      
	      
	      numspaces = 0;
	      for(i=0;i<len;i++)
		{
		  if(aline[i]==' ')
		    {
		      numspaces = numspaces + 1;
		    }
		}
	      
	      if(numspaces!=6)
		{
		  badinput = 1;
		  break;
		}
	      
	      sscanf(aline,"%s%s%d%d%d%d%d",
		     geomtype,
		     fcode,
		     &renders[numlines-1],
		     &styles [numlines-1],
		     &reds   [numlines-1],
		     &greens [numlines-1],
		     &blues  [numlines-1]);
	      
	      if(!strcmp(geomtype,"POINT"))
		{
		  geoms[numlines-1] = C_POFE;
		  if(styles[numlines-1]!=-1)
		    {
		      badinput = 7;
		      break;
		    }
		}
	      else if(!strcmp(geomtype,"LINE"))
		{
		  geoms[numlines-1] = C_LINE;
		  if(styles[numlines-1]!=-1)
		    {
		      badinput = 6;
		      break;
		    }
		}
	      else if(!strcmp(geomtype,"AREA"))
		{
		  geoms[numlines-1] = C_AREA;
		  
		  if((styles[numlines-1]<1)||(styles[numlines-1]>13))
		    {
		      badinput = 5;
		      break;
		    }
		}
	      else
		{
		  badinput = 2;
		  break;
		}
	      
	      if(strlen(fcode)!=5)
		{
		  badinput = 3;
		  break;
		}
	      else
		{
		  sprintf(fcodes[numlines-1],"%s",fcode);
		}
	      
	      if((renders[numlines-1]<0)||(renders[numlines-1]>5))
		{
		  badinput = 4;
		  break;
		}
	    }
	  else
	    {
	      geoms[numlines-1] = -1;
	      others[numlines-1] = (char *)malloc(strlen(aline)+5);
	      sprintf(others[numlines-1],"%s",aline);
	    }
	  
	  fgets(aline,1000,infile);
	}
      
      
      if(badinput>0)
	{
	  
	  if(badinput==2)
	    {
	      sprintf(aline,"Error on line %d parsing:  \n%s\n\n\
The first entry on a line must be POINT, LINE, AREA, or ##,\nread: %s\n",
		      numlines,filename,geomtype);
	    }
	  else if(badinput==4)
	    {
	      sprintf(aline,"Error on line %d parsing:  \n%s\n\n\
Render priorities must be 1-5, read: %d\n",numlines,filename,renders[numlines-1]);
	    }
	  else if(badinput==5)
	    {
	      sprintf(aline,"Error on line %d parsing:  \n%s\n\n\
Area styles must be 1-13, read: %d\n",numlines,filename,styles[numlines-1]);
	    }
	  else if(badinput==6)
	    {
	      sprintf(aline,"Error on line %d parsing:  \n%s\n\n\
Line styles must be -1, read: %d\n",numlines,filename,styles[numlines-1]);
	    }      
	  else if(badinput==7)
	    {
	      sprintf(aline,"Error on line %d parsing:  \n%s\n\n\
Point styles must be -1, read: %d\n",numlines,filename,styles[numlines-1]);
	    }
	  else
	    {
	      sprintf(aline,"Error on line %d parsing:  \n%s\n\n\
Lines must be of the form:\n\
<GEOMTYPE> <FCODE> <Render Priority 1-5> <Draw Style> <Red> <Green> <Blue>\n",
		      numlines,filename);
	    }
	  
	  
	  free(geoms);
	  free(renders);
	  free(styles);
	  free(reds);
	  free(greens);
	  free(blues);
	  
	  for(i=0;i<numlines;i++)
	    {
	      free(fcodes[i]);
	    }
	  free(fcodes);
	  
	  for(i=0;i<numlines;i++)
	    {
	      if(others[i]!=NULL)
		{
		  free(others[i]);
		}
	    }
	  free(others);
	  
	  
	  fclose(infile);
	  
	  not_while_running(w,aline,1457,"Modify Layer Prefs Error",5);
	  return;
	  
	  return;
	}
         
      fclose(infile);
    }


  


  for(i=0;i<numlines;i++)
    {
      


      if(geoms[i]<0)
	{
	  continue;
	}

        
      for(layer_num=0;layer_num<NumLODbands;layer_num++)
	{
	  if(
	     (LODindex_DYN[layer_num].geom                        ==geoms [i]) &&
	     (!strcmp(GetECCCode(LODindex_DYN[layer_num].ECC),      fcodes[i]))
	     )
	    {
	      if(renders[i]!=LODindex_DYN[layer_num].draw_priority)
		{
		  printf("found different draw pri %d/%d for %s\n",
			  renders[i],
              LODindex_DYN[layer_num].draw_priority,
			  GetECCCode(LODindex_DYN[layer_num].ECC));
		  renders[i] = LODindex_DYN[layer_num].draw_priority;
		  }

	      if(styles[i]!=LODindex_DYN[layer_num].draw_style)
		{
		  printf("found different draw style %d/%d for %s (%d)\n",
			  styles[i],LODindex_DYN[layer_num].draw_style,
			  GetECCCode(LODindex_DYN[layer_num].ECC),
			  LODindex_DYN[layer_num].geom
			  );
		  styles[i] = LODindex_DYN[layer_num].draw_style;
		}
	      
	      if(reds[i]  !=LODindex[LODindex_DYN[layer_num].other_index].rcolor)
		{
		  printf("found different red %d/%d for %s\n",
			 reds[i],
			 LODindex[LODindex_DYN[layer_num].other_index].rcolor,
			 GetECCCode(LODindex_DYN[layer_num].ECC));
		  
		  reds[i] = LODindex[LODindex_DYN[layer_num].other_index].rcolor;
		}
	      if(greens[i]!=LODindex[LODindex_DYN[layer_num].other_index].gcolor)
		{
		  printf("found different green %d/%d for %s\n",
			 greens[i],
			 LODindex[LODindex_DYN[layer_num].other_index].gcolor,
			 GetECCCode(LODindex_DYN[layer_num].ECC));
		  greens[i] = LODindex[LODindex_DYN[layer_num].other_index].gcolor;
		}
	      if(blues[i] !=LODindex[LODindex_DYN[layer_num].other_index].bcolor)
		{
		  printf("found different blue %d/%d for %s\n",
			 blues[i],
			 LODindex[LODindex_DYN[layer_num].other_index].bcolor,
			 GetECCCode(LODindex_DYN[layer_num].ECC));

		  blues[i] = LODindex[LODindex_DYN[layer_num].other_index].bcolor;
		}
	    }
	}
    }



  if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
    {
      sprintf(filename,"%s\\ProjectPreferences\\%s.txt",PROJECTLOC,SaveLayerName);
    }
  else
    {
      sprintf(filename,"%s/ProjectPreferences/%s.txt",PROJECTLOC,SaveLayerName);
    }
  
  
  outfile = fopen(filename,"w");
  if(outfile==NULL)
    {
      sprintf(aline,"Error:  Could not open layer preference file for writing:\n  %s",
	      filename);
      
      not_while_running(drawing_a,aline,1458,"Could not open layer pref file",5);
      
      free(geoms);
      free(renders);
      free(styles);
      free(reds);
      free(greens);
      free(blues);
      
      for(i=0;i<numlines;i++)
	{
	  free(fcodes[i]);
	}
      free(fcodes);
      
      for(i=0;i<numlines;i++)
	{
	  if(others[i]!=NULL)
	    {
	      free(others[i]);
	    }
	}
      free(others);
      
      return;
    }
  


  if(type>1)
    {
      
      
      fprintf(outfile,"## <GEOMTYPE> <FCODE> <Render Priority 1-5> <Draw Style> <Red> <Green> <Blue>\n");
      fprintf(outfile,"## \n");
      fprintf(outfile,"## Draw Style: -1 for LINE/POINT.  For AREA:\n");
      fprintf(outfile,"##\n");
      fprintf(outfile,"## 1 : Outline Only\n");
      fprintf(outfile,"## 2 : Light Filling\n");
      fprintf(outfile,"## 3 : Medium Filling\n");
      fprintf(outfile,"## 4 : Heavy Filling\n");
      fprintf(outfile,"## 5 : Fully Filled\n");
      fprintf(outfile,"## 6 : Dense Horizontal Lines\n");
      fprintf(outfile,"## 7 : Sparse Horizontal Lines\n");
      fprintf(outfile,"## 8 : Dense Vertical Lines\n");
      fprintf(outfile,"## 9 : Sparse Vertical Lines\n");
      fprintf(outfile,"## 10: Dense NW/SE Lines\n");
      fprintf(outfile,"## 11: Sparse NW/SE Lines\n");
      fprintf(outfile,"## 12: Dense NE/SW Lines\n");
      fprintf(outfile,"## 13: Sparse NE/SW Lines\n");
      fprintf(outfile,"## \n");
      fprintf(outfile,"## <Red,Green,Blue> : Integer values from 0 (none) to 65535 (Full Intensity)\n");
      fprintf(outfile,"##\n");
    }



  for(i=0;i<numlines;i++)
    {
      if(geoms[i]==-1)
	{
	  fprintf(outfile,"%s",others[i]);
	  
	  
	}
      else if(geoms[i]==-2)
	{
	  
	}
      else if(geoms[i]==C_AREA)
	{	  
	  fprintf(outfile,"AREA %s %d %d %d %d %d\n",
		  fcodes[i],renders[i],styles[i],
		  reds[i],greens[i],blues[i]);
	}
      else if(geoms[i]==C_LINE)
	{
	  fprintf(outfile,"LINE %s %d %d %d %d %d\n",
		 fcodes[i],renders[i],styles[i],
		 reds[i],greens[i],blues[i]);
	}
      else if(geoms[i]==C_POFE)
	{
	  fprintf(outfile,"POINT %s %d %d %d %d %d\n",
		  fcodes[i],renders[i],styles[i],
		  reds[i],greens[i],blues[i]);
	}
      else
	{
	  printf("bad geom %d\n",geoms[i]);
	}
    }


  fclose(outfile);


  free(geoms);
  free(renders);
  free(styles);
  free(reds);
  free(greens);
  free(blues);
  
  for(i=0;i<numlines;i++)
    {
      free(fcodes[i]);
    }
  free(fcodes);
  
  for(i=0;i<numlines;i++)
    {
      if(others[i]!=NULL)
	{
	  free(others[i]);
	}
    }

  free(others);
  
}


void ReportPrefFile(Widget w)
{
  char temp[1000];

  sprintf(temp,"Layer preference set \"%s\" has been created.",SaveLayerName);
  
  not_while_running(w,temp,1459,"Created Layer Prefs",5);
  
}





void overwritepreffile(Widget w, XtPointer userData, XtPointer callData)
{
  if(!strcmp(layer_save_file,"Default (Baseline)"))
    {
      ModifyLayerFile(3,w);
    }
  else if(!strcmp(layer_save_file,"Default (MGCP)"))
    {
      ModifyLayerFile(2,w);
    }
  else
    {
      ModifyLayerFile(1,w);
    }

  ReportPrefFile(w);

}

 


void modifySavedPrefs(Widget w, XtPointer userData, XtPointer callData)
{
  FILE *test;
  Widget dialog;
  Arg args[20];
  XmString mystring;
  int j,n=0;
  char filename[1000],tempchar[1000];
  char *testvalue;

  
  
  if(!strcmp(layer_save_file,"<none selected>"))
    {
      not_while_running(w,"To create a new set of layer preferences by modifying an old set,\n\
you must first select an old set to modify.\n\n\
Use the \"Choose...\" button on the \"Save/Load Layer Preferences\"\n\
window to select a set of layer preferences.",1455,"Modify Layer Prefs Error",5);
      return;
    }
  
  
  
  EnterFileCallback(savelayer_wid, (XtPointer)24,(XtPointer)NULL);
  
  
  
  
  testvalue = XmTextFieldGetString (savelayer_wid);
  
  
  for(j=0;j<(int)strlen(testvalue);j++)
    {
      if(
	 ((testvalue[j]>=65)  && (testvalue[j]<=90))  ||
	 ((testvalue[j]>=48)  && (testvalue[j]<=57))  ||
	 ((testvalue[j]>=97)  && (testvalue[j]<=122)) ||
	 (testvalue[j]=='-') || (testvalue[j]=='_')
	 )
	{
	  
	}
      else
	{
	  return;
	}
    }
  
  
  
  
  if((SaveLayerName[0]=='\0')||(strlen(testvalue)==0))
    {
      not_while_running(w,"To create a new set of layer preferences by modifying an old set,\n\
you must enter a name for the new preference set.  Use the\n\
\"Enter name for new layer preference set\" item on the\n\
\"Save/Load Layer Preferences\" window to enter the name.",1456,"Modify Layer Prefs Error",5);
      return;
    }
  
  
  
  printf("modify the pref file %s into new file %s\n",
	 layer_save_file,SaveLayerName);
  

  if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
    {
      sprintf(filename,"%s\\ProjectPreferences\\%s.txt",PROJECTLOC,SaveLayerName);
    }
  else
    {
      sprintf(filename,"%s/ProjectPreferences/%s.txt",PROJECTLOC,SaveLayerName);
    }
  
  
  test = fopen(filename,"r");
  if(test!=NULL)
    {
      sprintf(tempchar,"\
The layer preference file \"%s.txt\" already exists.\n\
Do you wish to overwrite it?",SaveLayerName);
      
      mystring = XmStringCreateLtoR(tempchar,XmSTRING_DEFAULT_CHARSET);

      n = 0;

      XtSetArg(args[n], XmNautoUnmanage,      True);                               n++;
      XtSetArg(args[n], XmNdialogTitle,  STRING("File Clobber Warning"));          n++;
      XtSetArg(args[n], XmNmessageString,mystring);                                n++;
      
      dialog = XmCreateWarningDialog (w, "File Clobber Warning", args, n);
      XtUnmanageChild (XmMessageBoxGetChild (dialog, XmDIALOG_HELP_BUTTON));
      
      XtAddCallback (dialog, XmNokCallback, overwritepreffile, w);
      
      XtManageChild (dialog);
      XtPopup  (XtParent(dialog), XtGrabNone);
      XmStringFree(mystring);
      fclose(test);
      return;
    }



  if(!strcmp(layer_save_file,"Default (Baseline)"))
    {
      ModifyLayerFile(3,w);
    }
  else if(!strcmp(layer_save_file,"Default (MGCP)"))
    {
      ModifyLayerFile(2,w);
    }
  else
    {
      ModifyLayerFile(1,w);
    }

  ReportPrefFile(w);

  
}





void save_layer_prefs(Widget w, XtPointer userData, XtPointer callData)
{
  static Widget dialog;
  Widget rc,form,button,button1,label1;
  Arg resources[15];
  int n=0;  
  
  
  if(LAYERPREFS_UP==1)
    {
      ResetWidget(dialog);
      return;
    }
  
  
  n=0;
  XtSetArg(resources[n],  XmNdeleteResponse, XmDESTROY); n++;
  XtSetArg(resources[n],  XmNmaxWidth,       800);       n++;
  
  
  dialog = XtCreatePopupShell("Save/Load Layer Preferences",topLevelShellWidgetClass,w,resources,n);
  
  
  rc = XtVaCreateManagedWidget
    (
     "XformWidget", xmPanedWindowWidgetClass, dialog,
     XmNrubberPositioning, False,
     XmNresizable,         True,
     XmNseparatorOn,       False,
     XmNsashHeight,        1,
     NULL
     );
  
  form = XtVaCreateWidget ("form7", xmFormWidgetClass, rc,
			   XmNpaneMinimum,     35,
			   XmNpaneMaximum,     35,
			   XmNseparatorOn,     False,
			   XmNfractionBase,    100,  
			   NULL);
  
  
  
  button = XtVaCreateManagedWidget ("Selected layer preference set:  ",
				    xmLabelWidgetClass,  form,
				    XmNtraversalOn,      False,
				    XmNleftAttachment,   XmATTACH_FORM,
				    XmNtopAttachment,    XmATTACH_FORM,
				    XmNbottomAttachment, XmATTACH_FORM,
				    LABELWTRANSLATE,
				    NULL);
  
  
  if(layer_save_file_selected==0)
    {
      sprintf(layer_save_file,"<none selected>");	
    }
  
  
  savepref_wid = XtVaCreateManagedWidget ("Red",
					  xmLabelWidgetClass, form,
					  XmNlabelString,      STRING(layer_save_file),
					  XmNcolumns,          15,
					  XmNleftAttachment,   XmATTACH_WIDGET,
					  XmNleftWidget,       button,
					  XmNtopAttachment,    XmATTACH_FORM,
					  XmNbottomAttachment, XmATTACH_FORM,
					  XmNmaxLength,        50,					    
					  LABELWTRANSLATE,
					  NULL);
  
  
  XtManageChild(savepref_wid);
  
  
  
  
  
  
  
  button1 = XtVaCreateManagedWidget ("Help4",
				     xmPushButtonWidgetClass, form,
				     XmNtraversalOn,      False,
				     XmNtopAttachment,    XmATTACH_FORM,
				     XmNbottomAttachment, XmATTACH_FORM,
				     XmNleftAttachment,   XmATTACH_WIDGET,
				     XmNleftWidget,       savepref_wid,
				     XmNlabelString,      STRING("Choose..."),
				     XmNtranslations, XtParseTranslationTable ( translations_global ) ,
				     NULL);
  XtAddCallback (button1, XmNactivateCallback,
		 ChoosePrefsCallback, (XtPointer)2);
  
  XtManageChild(button1);
  
  
  
  XtManageChild(form);
  
  
  
  
  
  
  
  form = XtVaCreateWidget ("form7", xmFormWidgetClass, rc,
			   XmNpaneMinimum,     35,
			   XmNpaneMaximum,     35,
			   XmNseparatorOn,     False,
			   XmNfractionBase,    100,  
			   NULL);
  
  
  label1 = XtVaCreateManagedWidget ("Name for new layer preference set:",
				    xmLabelWidgetClass,  form,
				    XmNrightAttachment,  XmATTACH_POSITION,
				    XmNrightPosition,    50,
				    XmNleftAttachment,   XmATTACH_POSITION,
				    XmNleftPosition,     0,
				    XmNalignment,        XmALIGNMENT_CENTER,
				    XmNtopAttachment,    XmATTACH_FORM,
				    XmNbottomAttachment, XmATTACH_FORM,
				    LABELWTRANSLATE,
				    NULL);
  XtManageChild(label1);
  
  
  
  savelayer_wid = XtVaCreateManagedWidget ("text_w",
					   xmTextFieldWidgetClass, form,	  
					   XmNvalue,               SaveLayerName,
					   XmNmaxLength,           24,
					   XmNtraversalOn,         True,
					   XmNrightAttachment,     XmATTACH_POSITION,
					   XmNrightPosition,       99,
					   XmNleftAttachment,      XmATTACH_POSITION,
					   XmNleftPosition,        51,
					   XmNtopAttachment,       XmATTACH_FORM,
					   XmNbottomAttachment,    XmATTACH_FORM,
                       XmNtranslations,        XtParseTranslationTable ( translations_paste ) ,
					   NULL);
  
  XtAddCallback (savelayer_wid, XmNactivateCallback,
		 EnterFileCallback, (XtPointer)24);
  XtManageChild(savelayer_wid);
  XtManageChild(form);
  
  
  
  
  
  
  
  
  
  
  form = XtVaCreateWidget ("form171", xmFormWidgetClass, rc,
			   XmNpaneMinimum,   25,
			   XmNpaneMaximum,   25,
			   XmNseparatorOn,   False,
			   XmNfractionBase,  100,  
			   NULL);      
  
  button  = XtVaCreateManagedWidget("SCR4",xmPushButtonWidgetClass,form,
				    XmNlabelString,       STRING("Load Selected Layer Preferences"),
				    XmNtopAttachment,     XmATTACH_FORM,
				    XmNbottomAttachment,  XmATTACH_FORM,
				    XmNrightAttachment,   XmATTACH_POSITION,
				    XmNrightPosition,     99,
				    XmNleftAttachment,    XmATTACH_POSITION,
				    XmNleftPosition,      1,
				    XmNtraversalOn,       False,
				    XmNtranslations, XtParseTranslationTable ( translations_global ) ,
				    NULL
				    );
  
  XtAddCallback(button, XmNactivateCallback,loadSavedPrefs, (XtPointer) NULL);
  XtManageChild(button);
  XtManageChild(form);
  
  
  
  
  form = XtVaCreateWidget ("form172", xmFormWidgetClass, rc,
			   XmNpaneMinimum,   25,
			   XmNpaneMaximum,   25,
			   XmNseparatorOn,   False,
			   XmNfractionBase,  100,  
			   NULL);      
  
  button  = XtVaCreateManagedWidget("SCR4",xmPushButtonWidgetClass,form,
				    XmNlabelString,       STRING("Using Current Settings, Create New Preference Set By Modifying Selected Set"),
				    XmNtopAttachment,     XmATTACH_FORM,
				    XmNbottomAttachment,  XmATTACH_FORM,
				    XmNrightAttachment,   XmATTACH_POSITION,
				    XmNrightPosition,     99,
				    XmNleftAttachment,    XmATTACH_POSITION,
				    XmNleftPosition,      1,
				    XmNtraversalOn,       False,
				    XmNtranslations, XtParseTranslationTable ( translations_global ) ,
				    NULL
				    );
  
  XtAddCallback(button, XmNactivateCallback,modifySavedPrefs, (XtPointer) NULL);
  XtManageChild(button);
  XtManageChild(form);
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  form = XtVaCreateWidget ("form173", xmFormWidgetClass, rc,
			   XmNpaneMinimum,   25,
			   XmNpaneMaximum,   25,
			   XmNseparatorOn,   False,
			   XmNfractionBase,  100,  
			   NULL);      
  
  button  = XtVaCreateManagedWidget("SCR4",xmPushButtonWidgetClass,form,
				    XmNlabelString,       STRING("Help"),
				    XmNtopAttachment,     XmATTACH_FORM,
				    XmNbottomAttachment,  XmATTACH_FORM,
				    XmNrightAttachment,   XmATTACH_POSITION,
				    XmNrightPosition,     50,
				    XmNleftAttachment,    XmATTACH_POSITION,
				    XmNleftPosition,      1,
				    XmNtraversalOn,       False,
				    XmNtranslations, XtParseTranslationTable ( translations_global ) ,
				    NULL
				    );
  
  XtAddCallback(button, XmNactivateCallback, prefHelpCallback, (XtPointer) NULL);
  
  XtManageChild(button);
  
  
  
  button  = XtVaCreateManagedWidget("SCR3",xmPushButtonWidgetClass,form,
				    XmNlabelString,       STRING("Done"),
				    XmNtopAttachment,     XmATTACH_FORM,
				    XmNbottomAttachment,  XmATTACH_FORM,
				    XmNrightAttachment,   XmATTACH_POSITION,
				    XmNrightPosition,     99,
				    XmNleftAttachment,    XmATTACH_POSITION,
				    XmNleftPosition,      50,
				    XmNtraversalOn,       False,
				    XmNtranslations, XtParseTranslationTable ( translations_global ) ,
				    NULL
				    );
  
  XtAddCallback(button, XmNactivateCallback, die_callback, (XtPointer) 1028);
  XtManageChild(button);
  XtManageChild(form);
  
  
  XtManageChild(rc);
  MyPopup(dialog); 
  
  
  XtAddCallback(dialog,XmNdestroyCallback,ShellDeath,(XtPointer)4078);
  
  
  LAYERPREFS_UP = 1;
  
}





char *GetNELong()
{
  return GetVariousPeices(1);
}


char *GetNELat()
{
  return GetVariousPeices(2);
}









char *GetDataContent(int type)
{

  
  
  double total=0;
  int i;
  static char retstr[100];


  if(type<=4)
    {      
      for (i = 0; i < NumberOfModels ; i++)
	{
	  if( (type==1) && (!strcmp(MdlNames[i].name,"(POINT)")))
	    {
	      total = total + MdlNames[i].occurrences;
	    }
	  else if( (type==2) && (!strcmp(MdlNames[i].name,"(LINE)")))
	    {
	      total = total + MdlNames[i].occurrences;
	    }
	  else if( (type==3) && (!strcmp(MdlNames[i].name,"(AREA)")))
	    {
	      total = total + MdlNames[i].occurrences;
	    }
	  else if( (type==4) && (!strstr(MdlNames[i].name,"(GRID)"))) 
	    {
	      total = total + MdlNames[i].occurrences;
	    }
	}
    }
  else if(type==5)
    {
      

	  if(!strstr(MdlNames[0].name,"(GRID)"))
	  {
        total = 1;
	  }
	  else
	  {
        total = 0;
	  }


      for(i = 1; i < NumberOfModels ; i++)
	{
	  if(!strstr(MdlNames[i].name,"(GRID)")) 
	    {
	      if(MdlNames[i].code!=MdlNames[i-1].code)
		{
		  total = total + 1;
		}
	    }
	}
    }
  else if(type==6)
    {
      
      for(i = 0; i < NumberOfModels ; i++)
	{
	  if(!strstr(MdlNames[i].name,"(GRID)"))  
	    {
	      total = total + 1;
	    }
	}
    }
  
  sprintf(retstr,"%.0lf",total);
  return retstr;
}


char *MakePlural(int num)
{
  if((num==0)||(num>1)) 
  {
	  return "s";
  }
  return "";
}



void AddQACREntry(char *lhs,char *rhs,int count,int ngamgcp)
{
  int i,len,starter=0,readingleadingspaces=1;

  

  len = strlen(rhs);
  for(i=0;i<len;i++)
  {
	if((rhs[i]<32)||(rhs[i]>126))
	{
	  rhs[i] = 32;
	}
	if(  ((i==len-1)||(i==len-2))  &&  (rhs[i]==':'))
	{
	  rhs[i] = 32;
	}

	if((rhs[i]==32)&&(readingleadingspaces==1))
	{
	  starter = i + 1;
	}
	if(rhs[i]!=32)
	{
	  readingleadingspaces = 0;
	}
  }


  if(ngamgcp==1)
  {
	nga_qacr_lhs[TotalNGAAttrInstances] = (char *)malloc(strlen(lhs)+5);
	nga_qacr_rhs[TotalNGAAttrInstances] = (char *)malloc(len+5);

	sprintf(nga_qacr_lhs[TotalNGAAttrInstances],"%s",lhs);
	sprintf(nga_qacr_rhs[TotalNGAAttrInstances],"%s",&rhs[starter]);
    nga_qacr_counts[TotalNGAAttrInstances] = count;

    TotalNGAAttrInstances = TotalNGAAttrInstances + 1;
  }
  else if(ngamgcp==2)
  {
	mgcp_qacr_lhs[TotalMGCPAttrInstances] = (char *)malloc(strlen(lhs)+5);
	mgcp_qacr_rhs[TotalMGCPAttrInstances] = (char *)malloc(len+5);

	sprintf(mgcp_qacr_lhs[TotalMGCPAttrInstances],"%s",lhs);
	sprintf(mgcp_qacr_rhs[TotalMGCPAttrInstances],"%s",&rhs[starter]);
    mgcp_qacr_counts[TotalMGCPAttrInstances] = count;

    TotalMGCPAttrInstances = TotalMGCPAttrInstances + 1;
  }
  else
  {
    printf("bad value %d to AddQACREntry\n",ngamgcp);
  }

}



void MakeRollupQACR()
{
  FILE *readfile;
  char infilename[1000],errtype[1000],errdesc[1000];
  int len1,len2,count;


  sprintf(infilename,"%sAttrStub.bin",outdirectory);
  readfile = fopen(infilename,"rb");
  if(readfile!=NULL)
  {

    SEEIT_fread_int(&len1,readfile);
 
	while(!feof(readfile))
	{

	  if(len1<=0)
	  {
		
		break;
	  }

	  if(len1>900)
	  {
		printf("Error creating QACR, len1 %d\n",len1);
		fclose(readfile);
		return;
	  }
      fread(&errtype[0], 1,len1,readfile);
	  if(len1>75)
	  {
		printf("Error creating QACR, lenq %d for %s\n",len1,errtype);
	  }
      errtype[len1] = '\0';
	  errtype[74]   = '\0';


	  SEEIT_fread_int(&len2,readfile);
	  if((len2<=0)||(len2>900))
	  {
		printf("Error creating QACR, len2 %d\n",len2);
		fclose(readfile);
		return;
	  }
      fread(&errdesc[0], 1,len2,readfile);
	  if(len2>150)
	  {
		printf("Error creating QACR, len2 %d for %s\n",len2,errdesc);
	  }
      errdesc[len2] = '\0';
	  errdesc[149]  = '\0';



	  SEEIT_fread_int(&count,readfile);


	  if(count<1)
	  {
		printf("bad QACR count %d for %s %s\n",count,errtype,errdesc);
		fclose(readfile);
		return;
	  }

      AddQACREntry(errtype,errdesc,count,1);
      AddQACREntry(errtype,errdesc,count,2);

	  SEEIT_fread_int(&len1,readfile);

	}

    fclose(readfile);
  }
  else
  {
	printf("error:  could not open %s for read\n",infilename);
  }

}


int GetUnkCount(char *searchstr)
{
  FILE *readfile;
  char txtfile[1000],aline[1000];
  int count = 0;

  
	
  

  sprintf(txtfile,"%sunkcolumn.txt",outattrdirectory);
  readfile = fopen(txtfile,"r");
  if(readfile!=NULL)
  {
	fgets(aline,1000,readfile);

	while(!feof(readfile))
	{
	  if(strstr(aline,searchstr)!=NULL)
	  {
		count = count + 1;
	  }
	  fgets(aline,1000,readfile);
	}
	fclose(readfile);
  } 
  else
  {
	printf("error:  could not open %s for read\n",txtfile);
	count = -1;
  }

  return count;
}



int FindLastSlash(char *thestr)
{
  int i,len,lastslash = -1;

  len = strlen(thestr);

  for(i=0;i<len;i++)
  {
    if(USE_DOS==1)
	{ 
	  if(thestr[i]=='\\')
	  { 
	    lastslash = i;
	  } 
	}
    else
	{
	  if(thestr[i]=='/')
	  {
	    lastslash = i;
	  }
	}
  }

  return lastslash;
}




void AddTrexReferenceDEMInfo(FILE *outfile)
{
  FILE *inspec;
  char filename[1000],aline[1000];
  int lastslash,wroteone=0;
  extern char *GetQuoted(char *instring,int quotenum);



  fprintf(outfile,"TREx Fill Sources\n\n");


  if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
  {
    sprintf(filename,"%s\\InputSpecFile.txt",indirectory);
  }
  else
  {
    sprintf(filename,"%s/InputSpecFile.txt",indirectory);
  }

  inspec = fopen(filename,"r");

  if(inspec==NULL)
  {
	fprintf(outfile,"Error: Could not open:\n  %s\n\n",filename);
	return;
  }



  fgets(aline,1000,inspec);

  while(!feof(inspec))
  {
    if(!strncmp(aline,"GEOTIFF ",8))
	{
      sprintf(filename,"%s",GetQuoted(aline,1));
	  if(
		  (!strcmp(filename,"Active Earthscape_0"))        ||
		  (!strcmp(filename,"HRTE3 Bare Earth_0"))         ||
		  (!strcmp(filename,"HRTE3 Reflective Surface_0")) ||
		  (!strcmp(filename,"SRTM Level 2_0"))             ||
		  (!strcmp(filename,"ASTER GDEM v2_0"))            ||
		  (!strcmp(filename,"DTED Level 1_0"))             ||
		  (!strcmp(filename,"CDEM_0"))                     ||
		  (!strcmp(filename,"GMTED mn300_0"))              ||
		  (!strcmp(filename,"GMTED mn75_0"))               ||

		  (!strcmp(filename,"AW3D30_0"))                   ||
		  (!strcmp(filename,"PGC_0"))                      ||
		  (!strcmp(filename,"GSDE_0"))                     ||
		  (!strcmp(filename,"FINDEM10_0"))                 ||
		  (!strcmp(filename,"MGCPNDEM_0"))                 ||
		  (!strcmp(filename,"NORDEM10_0"))                 ||
		  (!strcmp(filename,"NPDEM_0"))                    ||



		  (!strcmp(filename,"Active Earthscape_1"))        ||
		  (!strcmp(filename,"HRTE3 Bare Earth_1"))         ||
		  (!strcmp(filename,"HRTE3 Reflective Surface_1")) ||
		  (!strcmp(filename,"SRTM Level 2_1"))             ||
		  (!strcmp(filename,"ASTER GDEM v2_1"))            ||
		  (!strcmp(filename,"DTED Level 1_1"))             ||
		  (!strcmp(filename,"CDEM_1"))                     ||
		  (!strcmp(filename,"GMTED mn300_1"))              ||
		  (!strcmp(filename,"GMTED mn75_1"))               ||

		  (!strcmp(filename,"AW3D30_1"))                   ||
		  (!strcmp(filename,"PGC_1"))                      ||
		  (!strcmp(filename,"GSDE_1"))                     ||
		  (!strcmp(filename,"FINDEM10_1"))                 ||
		  (!strcmp(filename,"MGCPNDEM_1"))                 ||
		  (!strcmp(filename,"NORDEM10_1"))                 ||
		  (!strcmp(filename,"NPDEM_1"))                    ||



		  (!strcmp(filename,"Active Earthscape_2"))        ||
		  (!strcmp(filename,"HRTE3 Bare Earth_2"))         ||
		  (!strcmp(filename,"HRTE3 Reflective Surface_2")) ||
		  (!strcmp(filename,"SRTM Level 2_2"))             ||
		  (!strcmp(filename,"ASTER GDEM v2_2"))            ||
		  (!strcmp(filename,"DTED Level 1_2"))             ||
		  (!strcmp(filename,"CDEM_2"))                     ||
		  (!strcmp(filename,"GMTED mn300_2"))              ||
		  (!strcmp(filename,"GMTED mn75_2"))               ||

		  (!strcmp(filename,"AW3D30_2"))                   ||
		  (!strcmp(filename,"PGC_2"))                      ||
		  (!strcmp(filename,"GSDE_2"))                     ||
		  (!strcmp(filename,"FINDEM10_2"))                 ||
		  (!strcmp(filename,"MGCPNDEM_2"))                 ||
		  (!strcmp(filename,"NORDEM10_2"))                 ||
		  (!strcmp(filename,"NPDEM_2"))                    ||



		  (!strcmp(filename,"Active Earthscape_3"))        ||
		  (!strcmp(filename,"HRTE3 Bare Earth_3"))         ||
		  (!strcmp(filename,"HRTE3 Reflective Surface_3")) ||
		  (!strcmp(filename,"SRTM Level 2_3"))             ||
		  (!strcmp(filename,"ASTER GDEM v2_3"))            ||
		  (!strcmp(filename,"DTED Level 1_3"))             ||
		  (!strcmp(filename,"CDEM_3"))                     ||
		  (!strcmp(filename,"GMTED mn300_3"))              ||
		  (!strcmp(filename,"GMTED mn75_3"))               ||

		  (!strcmp(filename,"AW3D30_3"))                   ||
		  (!strcmp(filename,"PGC_3"))                      ||
		  (!strcmp(filename,"GSDE_3"))                     ||
		  (!strcmp(filename,"FINDEM10_3"))                 ||
		  (!strcmp(filename,"MGCPNDEM_3"))                 ||
		  (!strcmp(filename,"NORDEM10_3"))                 ||
		  (!strcmp(filename,"NPDEM_3"))

		)
	  {
        sprintf(filename,"%s",GetQuoted(aline,2));

	    lastslash = FindLastSlash(filename);
	    if((lastslash>=0)&&(lastslash<((int)strlen(filename)-1)))
		{
		  fprintf(outfile,"%s%s\n",trexspacer,&filename[lastslash+1]);
		  wroteone = 1;
		} 
	  } 
	}
    fgets(aline,1000,inspec);
  }

  if(wroteone==0)
  {
    fprintf(outfile,"%sNone found\n",trexspacer);
  }

  fclose(inspec);
}







void AddTrexEdgeInfo(FILE *summfile)
{
  FILE *readfile;
  int i,len,started,edges_found;
  char txtfile[1000],aline[1000];
  char BIGstring[1000];

  int edge_found[20];
  int hem_found[20],sdm_found[20],edm_found[20],wbm_found[20],dem_found[20];
  char edge_name[20][100];

  char *edge_annot[]=
  {
    "(N  GeoTile, S edge)",
    "(E  GeoTile, W edge)",
    "(S  GeoTile, N edge)",
    "(W  GeoTile, E edge)",
    "(NE GeoTile, S edge)",
    "(NE GeoTile, W edge)",
    "(NW GeoTile, E edge)",
    "(NW GeoTile, S edge)",
    "(SE GeoTile, N edge)",
    "(SE GeoTile, W edge)",
    "(SW GeoTile, E edge)",
    "(SW GeoTile, N edge)",
    "(N  GeoCell)",
    "(E  GeoCell)",
    "(S  GeoCell)",
    "(W  GeoCell)",
    "(NW GeoCell)",
    "(NE GeoCell)",
    "(SE GeoCell)",
    "(SW GeoCell)"
  };





  for(i=0;i<20;i++)
  {
	edge_found[i]   = 0;
    dem_found[i]    = 0;
    edm_found[i]    = 0;
    hem_found[i]    = 0;
    sdm_found[i]    = 0;
    wbm_found[i]    = 0;
	edge_name[i][0] = '\0';
  }


  sprintf(txtfile,"%stimp.bin",outdirectory);
  readfile = fopen(txtfile,"r");
  if(readfile!=NULL)
  { 
    fprintf(summfile,"TREx edge matching/neighbor post data found:\n\n");

	fgets(aline,1000,readfile);
	while(!feof(readfile))
	{
	  if(!strncmp(aline,"EDGE_SENTINEL ",14))
	  {
		  len= strlen(aline);

		  if(len>100)
		  {
			printf("Error processing edge matching info: (%d)\n",len);
			printf("%s\n",aline);
		  }
		  else
		  {
		    if(strstr(aline,"EDGE_SENTINEL DEM edges from the South edge of the North GeoTile")    !=NULL){edge_found[0]=1;  dem_found[0]=1;  sprintf(edge_name[0], "%s",&aline[len-8]); edge_name[0][7]  = '\0';}
		    if(strstr(aline,"EDGE_SENTINEL DEM edges from the West edge of the East GeoTile")      !=NULL){edge_found[1]=1;  dem_found[1]=1;  sprintf(edge_name[1], "%s",&aline[len-8]); edge_name[1][7]  = '\0';}
		    if(strstr(aline,"EDGE_SENTINEL DEM edges from the North edge of the South GeoTile")    !=NULL){edge_found[2]=1;  dem_found[2]=1;  sprintf(edge_name[2], "%s",&aline[len-8]); edge_name[2][7]  = '\0';}
		    if(strstr(aline,"EDGE_SENTINEL DEM edges from the East edge of the West GeoTile")      !=NULL){edge_found[3]=1;  dem_found[3]=1;  sprintf(edge_name[3], "%s",&aline[len-8]); edge_name[3][7]  = '\0';}
		    if(strstr(aline,"EDGE_SENTINEL DEM edges from the South edge of the Northeast GeoTile")!=NULL){edge_found[4]=1;  dem_found[4]=1;  sprintf(edge_name[4], "%s",&aline[len-8]); edge_name[4][7]  = '\0';}
		    if(strstr(aline,"EDGE_SENTINEL DEM edges from the West edge of the Northeast GeoTile") !=NULL){edge_found[5]=1;  dem_found[5]=1;  sprintf(edge_name[5], "%s",&aline[len-8]); edge_name[5][7]  = '\0';}
		    if(strstr(aline,"EDGE_SENTINEL DEM edges from the East edge of the Northwest GeoTile") !=NULL){edge_found[6]=1;  dem_found[6]=1;  sprintf(edge_name[6], "%s",&aline[len-8]); edge_name[6][7]  = '\0';}
		    if(strstr(aline,"EDGE_SENTINEL DEM edges from the South edge of the Northwest GeoTile")!=NULL){edge_found[7]=1;  dem_found[7]=1;  sprintf(edge_name[7], "%s",&aline[len-8]); edge_name[7][7]  = '\0';}
		    if(strstr(aline,"EDGE_SENTINEL DEM edges from the North edge of the Southeast GeoTile")!=NULL){edge_found[8]=1;  dem_found[8]=1;  sprintf(edge_name[8], "%s",&aline[len-8]); edge_name[8][7]  = '\0';}
		    if(strstr(aline,"EDGE_SENTINEL DEM edges from the West edge of the Southeast GeoTile") !=NULL){edge_found[9]=1;  dem_found[9]=1;  sprintf(edge_name[9], "%s",&aline[len-8]); edge_name[9][7]  = '\0';}
		    if(strstr(aline,"EDGE_SENTINEL DEM edges from the East edge of the Southwest GeoTile") !=NULL){edge_found[10]=1; dem_found[10]=1; sprintf(edge_name[10],"%s",&aline[len-8]); edge_name[10][7] = '\0';}
		    if(strstr(aline,"EDGE_SENTINEL DEM edges from the North edge of the Southwest GeoTile")!=NULL){edge_found[11]=1; dem_found[11]=1; sprintf(edge_name[11],"%s",&aline[len-8]); edge_name[11][7] = '\0';}
 
	        if(strstr(aline,"EDGE_SENTINEL DEM posts from the North GeoCell")                      !=NULL){edge_found[12]=1; dem_found[12]=1; sprintf(edge_name[12],"%s",&aline[len-8]); edge_name[12][7] = '\0';}
	        if(strstr(aline,"EDGE_SENTINEL DEM posts from the East GeoCell")                       !=NULL){edge_found[13]=1; dem_found[13]=1; sprintf(edge_name[13],"%s",&aline[len-8]); edge_name[13][7] = '\0';}
	        if(strstr(aline,"EDGE_SENTINEL DEM posts from the South GeoCell")                      !=NULL){edge_found[14]=1; dem_found[14]=1; sprintf(edge_name[14],"%s",&aline[len-8]); edge_name[14][7] = '\0';}
	        if(strstr(aline,"EDGE_SENTINEL DEM posts from the West GeoCell")                       !=NULL){edge_found[15]=1; dem_found[15]=1; sprintf(edge_name[15],"%s",&aline[len-8]); edge_name[15][7] = '\0';}
	        if(strstr(aline,"EDGE_SENTINEL DEM posts from the Northwest GeoCell")                  !=NULL){edge_found[16]=1; dem_found[16]=1; sprintf(edge_name[16],"%s",&aline[len-8]); edge_name[16][7] = '\0';}
	        if(strstr(aline,"EDGE_SENTINEL DEM posts from the Northeast GeoCell")                  !=NULL){edge_found[17]=1; dem_found[17]=1; sprintf(edge_name[17],"%s",&aline[len-8]); edge_name[17][7] = '\0';}
	        if(strstr(aline,"EDGE_SENTINEL DEM posts from the Southeast GeoCell")                  !=NULL){edge_found[18]=1; dem_found[18]=1; sprintf(edge_name[18],"%s",&aline[len-8]); edge_name[18][7] = '\0';}
	        if(strstr(aline,"EDGE_SENTINEL DEM posts from the Southwest GeoCell")                  !=NULL){edge_found[19]=1; dem_found[19]=1; sprintf(edge_name[19],"%s",&aline[len-8]); edge_name[19][7] = '\0';}

		    if(strstr(aline,"EDGE_SENTINEL EDM edges from the South edge of the North GeoTile")    !=NULL){edge_found[0]=1;  edm_found[0]=1;  sprintf(edge_name[0], "%s",&aline[len-8]); edge_name[0][7]  = '\0';}
		    if(strstr(aline,"EDGE_SENTINEL EDM edges from the West edge of the East GeoTile")      !=NULL){edge_found[1]=1;  edm_found[1]=1;  sprintf(edge_name[1], "%s",&aline[len-8]); edge_name[1][7]  = '\0';}
		    if(strstr(aline,"EDGE_SENTINEL EDM edges from the North edge of the South GeoTile")    !=NULL){edge_found[2]=1;  edm_found[2]=1;  sprintf(edge_name[2], "%s",&aline[len-8]); edge_name[2][7]  = '\0';}
		    if(strstr(aline,"EDGE_SENTINEL EDM edges from the East edge of the West GeoTile")      !=NULL){edge_found[3]=1;  edm_found[3]=1;  sprintf(edge_name[3], "%s",&aline[len-8]); edge_name[3][7]  = '\0';}
		    if(strstr(aline,"EDGE_SENTINEL EDM edges from the South edge of the Northeast GeoTile")!=NULL){edge_found[4]=1;  edm_found[4]=1;  sprintf(edge_name[4], "%s",&aline[len-8]); edge_name[4][7]  = '\0';}
		    if(strstr(aline,"EDGE_SENTINEL EDM edges from the West edge of the Northeast GeoTile") !=NULL){edge_found[5]=1;  edm_found[5]=1;  sprintf(edge_name[5], "%s",&aline[len-8]); edge_name[5][7]  = '\0';}
		    if(strstr(aline,"EDGE_SENTINEL EDM edges from the East edge of the Northwest GeoTile") !=NULL){edge_found[6]=1;  edm_found[6]=1;  sprintf(edge_name[6], "%s",&aline[len-8]); edge_name[6][7]  = '\0';}
		    if(strstr(aline,"EDGE_SENTINEL EDM edges from the South edge of the Northwest GeoTile")!=NULL){edge_found[7]=1;  edm_found[7]=1;  sprintf(edge_name[7], "%s",&aline[len-8]); edge_name[7][7]  = '\0';}
		    if(strstr(aline,"EDGE_SENTINEL EDM edges from the North edge of the Southeast GeoTile")!=NULL){edge_found[8]=1;  edm_found[8]=1;  sprintf(edge_name[8], "%s",&aline[len-8]); edge_name[8][7]  = '\0';}
		    if(strstr(aline,"EDGE_SENTINEL EDM edges from the West edge of the Southeast GeoTile") !=NULL){edge_found[9]=1;  edm_found[9]=1;  sprintf(edge_name[9], "%s",&aline[len-8]); edge_name[9][7]  = '\0';}
		    if(strstr(aline,"EDGE_SENTINEL EDM edges from the East edge of the Southwest GeoTile") !=NULL){edge_found[10]=1; edm_found[10]=1; sprintf(edge_name[10],"%s",&aline[len-8]); edge_name[10][7] = '\0';}
		    if(strstr(aline,"EDGE_SENTINEL EDM edges from the North edge of the Southwest GeoTile")!=NULL){edge_found[11]=1; edm_found[11]=1; sprintf(edge_name[11],"%s",&aline[len-8]); edge_name[11][7] = '\0';}
 
	        if(strstr(aline,"EDGE_SENTINEL EDM posts from the North GeoCell")                      !=NULL){edge_found[12]=1; edm_found[12]=1; sprintf(edge_name[12],"%s",&aline[len-8]); edge_name[12][7] = '\0';}
	        if(strstr(aline,"EDGE_SENTINEL EDM posts from the East GeoCell")                       !=NULL){edge_found[13]=1; edm_found[13]=1; sprintf(edge_name[13],"%s",&aline[len-8]); edge_name[13][7] = '\0';}
	        if(strstr(aline,"EDGE_SENTINEL EDM posts from the South GeoCell")                      !=NULL){edge_found[14]=1; edm_found[14]=1; sprintf(edge_name[14],"%s",&aline[len-8]); edge_name[14][7] = '\0';}
	        if(strstr(aline,"EDGE_SENTINEL EDM posts from the West GeoCell")                       !=NULL){edge_found[15]=1; edm_found[15]=1; sprintf(edge_name[15],"%s",&aline[len-8]); edge_name[15][7] = '\0';}
	        if(strstr(aline,"EDGE_SENTINEL EDM posts from the Northwest GeoCell")                  !=NULL){edge_found[16]=1; edm_found[16]=1; sprintf(edge_name[16],"%s",&aline[len-8]); edge_name[16][7] = '\0';}
	        if(strstr(aline,"EDGE_SENTINEL EDM posts from the Northeast GeoCell")                  !=NULL){edge_found[17]=1; edm_found[17]=1; sprintf(edge_name[17],"%s",&aline[len-8]); edge_name[17][7] = '\0';}
	        if(strstr(aline,"EDGE_SENTINEL EDM posts from the Southeast GeoCell")                  !=NULL){edge_found[18]=1; edm_found[18]=1; sprintf(edge_name[18],"%s",&aline[len-8]); edge_name[18][7] = '\0';}
	        if(strstr(aline,"EDGE_SENTINEL EDM posts from the Southwest GeoCell")                  !=NULL){edge_found[19]=1; edm_found[19]=1; sprintf(edge_name[19],"%s",&aline[len-8]); edge_name[19][7] = '\0';}

		    if(strstr(aline,"EDGE_SENTINEL HEM edges from the South edge of the North GeoTile")    !=NULL){edge_found[0]=1;  hem_found[0]=1;  sprintf(edge_name[0], "%s",&aline[len-8]); edge_name[0][7]  = '\0';}
		    if(strstr(aline,"EDGE_SENTINEL HEM edges from the West edge of the East GeoTile")      !=NULL){edge_found[1]=1;  hem_found[1]=1;  sprintf(edge_name[1], "%s",&aline[len-8]); edge_name[1][7]  = '\0';}
		    if(strstr(aline,"EDGE_SENTINEL HEM edges from the North edge of the South GeoTile")    !=NULL){edge_found[2]=1;  hem_found[2]=1;  sprintf(edge_name[2], "%s",&aline[len-8]); edge_name[2][7]  = '\0';}
		    if(strstr(aline,"EDGE_SENTINEL HEM edges from the East edge of the West GeoTile")      !=NULL){edge_found[3]=1;  hem_found[3]=1;  sprintf(edge_name[3], "%s",&aline[len-8]); edge_name[3][7]  = '\0';}
		    if(strstr(aline,"EDGE_SENTINEL HEM edges from the South edge of the Northeast GeoTile")!=NULL){edge_found[4]=1;  hem_found[4]=1;  sprintf(edge_name[4], "%s",&aline[len-8]); edge_name[4][7]  = '\0';}
		    if(strstr(aline,"EDGE_SENTINEL HEM edges from the West edge of the Northeast GeoTile") !=NULL){edge_found[5]=1;  hem_found[5]=1;  sprintf(edge_name[5], "%s",&aline[len-8]); edge_name[5][7]  = '\0';}
		    if(strstr(aline,"EDGE_SENTINEL HEM edges from the East edge of the Northwest GeoTile") !=NULL){edge_found[6]=1;  hem_found[6]=1;  sprintf(edge_name[6], "%s",&aline[len-8]); edge_name[6][7]  = '\0';}
		    if(strstr(aline,"EDGE_SENTINEL HEM edges from the South edge of the Northwest GeoTile")!=NULL){edge_found[7]=1;  hem_found[7]=1;  sprintf(edge_name[7], "%s",&aline[len-8]); edge_name[7][7]  = '\0';}
		    if(strstr(aline,"EDGE_SENTINEL HEM edges from the North edge of the Southeast GeoTile")!=NULL){edge_found[8]=1;  hem_found[8]=1;  sprintf(edge_name[8], "%s",&aline[len-8]); edge_name[8][7]  = '\0';}
		    if(strstr(aline,"EDGE_SENTINEL HEM edges from the West edge of the Southeast GeoTile") !=NULL){edge_found[9]=1;  hem_found[9]=1;  sprintf(edge_name[9], "%s",&aline[len-8]); edge_name[9][7]  = '\0';}
		    if(strstr(aline,"EDGE_SENTINEL HEM edges from the East edge of the Southwest GeoTile") !=NULL){edge_found[10]=1; hem_found[10]=1; sprintf(edge_name[10],"%s",&aline[len-8]); edge_name[10][7] = '\0';}
		    if(strstr(aline,"EDGE_SENTINEL HEM edges from the North edge of the Southwest GeoTile")!=NULL){edge_found[11]=1; hem_found[11]=1; sprintf(edge_name[11],"%s",&aline[len-8]); edge_name[11][7] = '\0';}
 
	        if(strstr(aline,"EDGE_SENTINEL HEM posts from the North GeoCell")                      !=NULL){edge_found[12]=1; hem_found[12]=1; sprintf(edge_name[12],"%s",&aline[len-8]); edge_name[12][7] = '\0';}
	        if(strstr(aline,"EDGE_SENTINEL HEM posts from the East GeoCell")                       !=NULL){edge_found[13]=1; hem_found[13]=1; sprintf(edge_name[13],"%s",&aline[len-8]); edge_name[13][7] = '\0';}
	        if(strstr(aline,"EDGE_SENTINEL HEM posts from the South GeoCell")                      !=NULL){edge_found[14]=1; hem_found[14]=1; sprintf(edge_name[14],"%s",&aline[len-8]); edge_name[14][7] = '\0';}
	        if(strstr(aline,"EDGE_SENTINEL HEM posts from the West GeoCell")                       !=NULL){edge_found[15]=1; hem_found[15]=1; sprintf(edge_name[15],"%s",&aline[len-8]); edge_name[15][7] = '\0';}
	        if(strstr(aline,"EDGE_SENTINEL HEM posts from the Northwest GeoCell")                  !=NULL){edge_found[16]=1; hem_found[16]=1; sprintf(edge_name[16],"%s",&aline[len-8]); edge_name[16][7] = '\0';}
	        if(strstr(aline,"EDGE_SENTINEL HEM posts from the Northeast GeoCell")                  !=NULL){edge_found[17]=1; hem_found[17]=1; sprintf(edge_name[17],"%s",&aline[len-8]); edge_name[17][7] = '\0';}
	        if(strstr(aline,"EDGE_SENTINEL HEM posts from the Southeast GeoCell")                  !=NULL){edge_found[18]=1; hem_found[18]=1; sprintf(edge_name[18],"%s",&aline[len-8]); edge_name[18][7] = '\0';}
	        if(strstr(aline,"EDGE_SENTINEL HEM posts from the Southwest GeoCell")                  !=NULL){edge_found[19]=1; hem_found[19]=1; sprintf(edge_name[19],"%s",&aline[len-8]); edge_name[19][7] = '\0';}

		    if(strstr(aline,"EDGE_SENTINEL SDM edges from the South edge of the North GeoTile")    !=NULL){edge_found[0]=1;  sdm_found[0]=1;  sprintf(edge_name[0], "%s",&aline[len-8]); edge_name[0][7]  = '\0';}
		    if(strstr(aline,"EDGE_SENTINEL SDM edges from the West edge of the East GeoTile")      !=NULL){edge_found[1]=1;  sdm_found[1]=1;  sprintf(edge_name[1], "%s",&aline[len-8]); edge_name[1][7]  = '\0';}
		    if(strstr(aline,"EDGE_SENTINEL SDM edges from the North edge of the South GeoTile")    !=NULL){edge_found[2]=1;  sdm_found[2]=1;  sprintf(edge_name[2], "%s",&aline[len-8]); edge_name[2][7]  = '\0';}
		    if(strstr(aline,"EDGE_SENTINEL SDM edges from the East edge of the West GeoTile")      !=NULL){edge_found[3]=1;  sdm_found[3]=1;  sprintf(edge_name[3], "%s",&aline[len-8]); edge_name[3][7]  = '\0';}
		    if(strstr(aline,"EDGE_SENTINEL SDM edges from the South edge of the Northeast GeoTile")!=NULL){edge_found[4]=1;  sdm_found[4]=1;  sprintf(edge_name[4], "%s",&aline[len-8]); edge_name[4][7]  = '\0';}
		    if(strstr(aline,"EDGE_SENTINEL SDM edges from the West edge of the Northeast GeoTile") !=NULL){edge_found[5]=1;  sdm_found[5]=1;  sprintf(edge_name[5], "%s",&aline[len-8]); edge_name[5][7]  = '\0';}
		    if(strstr(aline,"EDGE_SENTINEL SDM edges from the East edge of the Northwest GeoTile") !=NULL){edge_found[6]=1;  sdm_found[6]=1;  sprintf(edge_name[6], "%s",&aline[len-8]); edge_name[6][7]  = '\0';}
		    if(strstr(aline,"EDGE_SENTINEL SDM edges from the South edge of the Northwest GeoTile")!=NULL){edge_found[7]=1;  sdm_found[7]=1;  sprintf(edge_name[7], "%s",&aline[len-8]); edge_name[7][7]  = '\0';}
		    if(strstr(aline,"EDGE_SENTINEL SDM edges from the North edge of the Southeast GeoTile")!=NULL){edge_found[8]=1;  sdm_found[8]=1;  sprintf(edge_name[8], "%s",&aline[len-8]); edge_name[8][7]  = '\0';}
		    if(strstr(aline,"EDGE_SENTINEL SDM edges from the West edge of the Southeast GeoTile") !=NULL){edge_found[9]=1;  sdm_found[9]=1;  sprintf(edge_name[9], "%s",&aline[len-8]); edge_name[9][7]  = '\0';}
		    if(strstr(aline,"EDGE_SENTINEL SDM edges from the East edge of the Southwest GeoTile") !=NULL){edge_found[10]=1; sdm_found[10]=1; sprintf(edge_name[10],"%s",&aline[len-8]); edge_name[10][7] = '\0';}
		    if(strstr(aline,"EDGE_SENTINEL SDM edges from the North edge of the Southwest GeoTile")!=NULL){edge_found[11]=1; sdm_found[11]=1; sprintf(edge_name[11],"%s",&aline[len-8]); edge_name[11][7] = '\0';}
 
	        if(strstr(aline,"EDGE_SENTINEL SDM posts from the North GeoCell")                      !=NULL){edge_found[12]=1; sdm_found[12]=1; sprintf(edge_name[12],"%s",&aline[len-8]); edge_name[12][7] = '\0';}
	        if(strstr(aline,"EDGE_SENTINEL SDM posts from the East GeoCell")                       !=NULL){edge_found[13]=1; sdm_found[13]=1; sprintf(edge_name[13],"%s",&aline[len-8]); edge_name[13][7] = '\0';}
	        if(strstr(aline,"EDGE_SENTINEL SDM posts from the South GeoCell")                      !=NULL){edge_found[14]=1; sdm_found[14]=1; sprintf(edge_name[14],"%s",&aline[len-8]); edge_name[14][7] = '\0';}
	        if(strstr(aline,"EDGE_SENTINEL SDM posts from the West GeoCell")                       !=NULL){edge_found[15]=1; sdm_found[15]=1; sprintf(edge_name[15],"%s",&aline[len-8]); edge_name[15][7] = '\0';}
	        if(strstr(aline,"EDGE_SENTINEL SDM posts from the Northwest GeoCell")                  !=NULL){edge_found[16]=1; sdm_found[16]=1; sprintf(edge_name[16],"%s",&aline[len-8]); edge_name[16][7] = '\0';}
	        if(strstr(aline,"EDGE_SENTINEL SDM posts from the Northeast GeoCell")                  !=NULL){edge_found[17]=1; sdm_found[17]=1; sprintf(edge_name[17],"%s",&aline[len-8]); edge_name[17][7] = '\0';}
	        if(strstr(aline,"EDGE_SENTINEL SDM posts from the Southeast GeoCell")                  !=NULL){edge_found[18]=1; sdm_found[18]=1; sprintf(edge_name[18],"%s",&aline[len-8]); edge_name[18][7] = '\0';}
	        if(strstr(aline,"EDGE_SENTINEL SDM posts from the Southwest GeoCell")                  !=NULL){edge_found[19]=1; sdm_found[19]=1; sprintf(edge_name[19],"%s",&aline[len-8]); edge_name[19][7] = '\0';}

		    if(strstr(aline,"EDGE_SENTINEL WBM edges from the South edge of the North GeoTile")    !=NULL){edge_found[0]=1;  wbm_found[0]=1;  sprintf(edge_name[0], "%s",&aline[len-8]); edge_name[0][7]  = '\0';}
		    if(strstr(aline,"EDGE_SENTINEL WBM edges from the West edge of the East GeoTile")      !=NULL){edge_found[1]=1;  wbm_found[1]=1;  sprintf(edge_name[1], "%s",&aline[len-8]); edge_name[1][7]  = '\0';}
		    if(strstr(aline,"EDGE_SENTINEL WBM edges from the North edge of the South GeoTile")    !=NULL){edge_found[2]=1;  wbm_found[2]=1;  sprintf(edge_name[2], "%s",&aline[len-8]); edge_name[2][7]  = '\0';}
		    if(strstr(aline,"EDGE_SENTINEL WBM edges from the East edge of the West GeoTile")      !=NULL){edge_found[3]=1;  wbm_found[3]=1;  sprintf(edge_name[3], "%s",&aline[len-8]); edge_name[3][7]  = '\0';}
		    if(strstr(aline,"EDGE_SENTINEL WBM edges from the South edge of the Northeast GeoTile")!=NULL){edge_found[4]=1;  wbm_found[4]=1;  sprintf(edge_name[4], "%s",&aline[len-8]); edge_name[4][7]  = '\0';}
		    if(strstr(aline,"EDGE_SENTINEL WBM edges from the West edge of the Northeast GeoTile") !=NULL){edge_found[5]=1;  wbm_found[5]=1;  sprintf(edge_name[5], "%s",&aline[len-8]); edge_name[5][7]  = '\0';}
		    if(strstr(aline,"EDGE_SENTINEL WBM edges from the East edge of the Northwest GeoTile") !=NULL){edge_found[6]=1;  wbm_found[6]=1;  sprintf(edge_name[6], "%s",&aline[len-8]); edge_name[6][7]  = '\0';}
		    if(strstr(aline,"EDGE_SENTINEL WBM edges from the South edge of the Northwest GeoTile")!=NULL){edge_found[7]=1;  wbm_found[7]=1;  sprintf(edge_name[7], "%s",&aline[len-8]); edge_name[7][7]  = '\0';}
		    if(strstr(aline,"EDGE_SENTINEL WBM edges from the North edge of the Southeast GeoTile")!=NULL){edge_found[8]=1;  wbm_found[8]=1;  sprintf(edge_name[8], "%s",&aline[len-8]); edge_name[8][7]  = '\0';}
		    if(strstr(aline,"EDGE_SENTINEL WBM edges from the West edge of the Southeast GeoTile") !=NULL){edge_found[9]=1;  wbm_found[9]=1;  sprintf(edge_name[9], "%s",&aline[len-8]); edge_name[9][7]  = '\0';}
		    if(strstr(aline,"EDGE_SENTINEL WBM edges from the East edge of the Southwest GeoTile") !=NULL){edge_found[10]=1; wbm_found[10]=1; sprintf(edge_name[10],"%s",&aline[len-8]); edge_name[10][7] = '\0';}
		    if(strstr(aline,"EDGE_SENTINEL WBM edges from the North edge of the Southwest GeoTile")!=NULL){edge_found[11]=1; wbm_found[11]=1; sprintf(edge_name[11],"%s",&aline[len-8]); edge_name[11][7] = '\0';}
 
	        if(strstr(aline,"EDGE_SENTINEL WBM posts from the North GeoCell")                      !=NULL){edge_found[12]=1; wbm_found[12]=1; sprintf(edge_name[12],"%s",&aline[len-8]); edge_name[12][7] = '\0';}
	        if(strstr(aline,"EDGE_SENTINEL WBM posts from the East GeoCell")                       !=NULL){edge_found[13]=1; wbm_found[13]=1; sprintf(edge_name[13],"%s",&aline[len-8]); edge_name[13][7] = '\0';}
	        if(strstr(aline,"EDGE_SENTINEL WBM posts from the South GeoCell")                      !=NULL){edge_found[14]=1; wbm_found[14]=1; sprintf(edge_name[14],"%s",&aline[len-8]); edge_name[14][7] = '\0';}
	        if(strstr(aline,"EDGE_SENTINEL WBM posts from the West GeoCell")                       !=NULL){edge_found[15]=1; wbm_found[15]=1; sprintf(edge_name[15],"%s",&aline[len-8]); edge_name[15][7] = '\0';}
	        if(strstr(aline,"EDGE_SENTINEL WBM posts from the Northwest GeoCell")                  !=NULL){edge_found[16]=1; wbm_found[16]=1; sprintf(edge_name[16],"%s",&aline[len-8]); edge_name[16][7] = '\0';}
	        if(strstr(aline,"EDGE_SENTINEL WBM posts from the Northeast GeoCell")                  !=NULL){edge_found[17]=1; wbm_found[17]=1; sprintf(edge_name[17],"%s",&aline[len-8]); edge_name[17][7] = '\0';}
	        if(strstr(aline,"EDGE_SENTINEL WBM posts from the Southeast GeoCell")                  !=NULL){edge_found[18]=1; wbm_found[18]=1; sprintf(edge_name[18],"%s",&aline[len-8]); edge_name[18][7] = '\0';}
	        if(strstr(aline,"EDGE_SENTINEL WBM posts from the Southwest GeoCell")                  !=NULL){edge_found[19]=1; wbm_found[19]=1; sprintf(edge_name[19],"%s",&aline[len-8]); edge_name[19][7] = '\0';}
		  }
	  }

	  fgets(aline,1000,readfile);
	}

	fclose(readfile);
  }



  sprintf(BIGstring,"%sEdges found from neighbor GeoTiles: \n",trexspacer);
  edges_found = 0;

  for(i=0;i<12;i++)
  {
	if(edge_found[i]>0)
	{
	  
	  started=0;
	  edges_found = 1;
	  strcat(BIGstring,trexspacer);
	  strcat(BIGstring,trexspacer);
	  strcat(BIGstring,"{");
	  if(dem_found[i]>0) { if(started==1) {strcat(BIGstring,",");}	 strcat(BIGstring,"DEM");	started = 1; }
	  if(edm_found[i]>0) { if(started==1) {strcat(BIGstring,",");}	 strcat(BIGstring,"EDM");	started = 1; }
	  if(hem_found[i]>0) { if(started==1) {strcat(BIGstring,",");}	 strcat(BIGstring,"HEM");	started = 1; }
	  if(sdm_found[i]>0) { if(started==1) {strcat(BIGstring,",");}	 strcat(BIGstring,"SDM");	started = 1; }
	  if(wbm_found[i]>0) { if(started==1) {strcat(BIGstring,",");}	 strcat(BIGstring,"WBM");	started = 1; }
	  strcat(BIGstring,"}  ");
	  strcat(BIGstring,edge_annot[i]);
	  strcat(BIGstring,"  Neighbor GeoTile: ");
	  strcat(BIGstring,edge_name[i]);
	  strcat(BIGstring,"\n");
	}
  }

  if(edges_found==0)
  {
    strcat(BIGstring,trexspacer);
    strcat(BIGstring,trexspacer);
    strcat(BIGstring,"None\n");
  }

  fprintf(summfile,"%s",BIGstring); 



  fprintf(summfile,"\n"); 



  sprintf(BIGstring,"%sPosts found from neighbor GeoCells: \n",trexspacer);
  edges_found = 0;

  for(i=12;i<20;i++)
  {
	if(edge_found[i]>0)
	{
	  
	  started=0;
	  edges_found = 1;
	  strcat(BIGstring,trexspacer);
	  strcat(BIGstring,trexspacer);
	  strcat(BIGstring,"{");
	  if(dem_found[i]>0) { if(started==1) {strcat(BIGstring,",");}	 strcat(BIGstring,"DEM");	started = 1; }
	  if(edm_found[i]>0) { if(started==1) {strcat(BIGstring,",");}	 strcat(BIGstring,"EDM");	started = 1; }
	  if(hem_found[i]>0) { if(started==1) {strcat(BIGstring,",");}	 strcat(BIGstring,"HEM");	started = 1; }
	  if(sdm_found[i]>0) { if(started==1) {strcat(BIGstring,",");}	 strcat(BIGstring,"SDM");	started = 1; }
	  if(wbm_found[i]>0) { if(started==1) {strcat(BIGstring,",");}	 strcat(BIGstring,"WBM");	started = 1; }
	  strcat(BIGstring,"}  ");
	  strcat(BIGstring,edge_annot[i]);
	  strcat(BIGstring,"  Neighbor GeoCell: ");
	  strcat(BIGstring,edge_name[i]);
	  strcat(BIGstring,"\n");
	}
  }

  if(edges_found==0)
  {
    strcat(BIGstring,trexspacer);
    strcat(BIGstring,trexspacer);
    strcat(BIGstring,"None\n");
  }

  fprintf(summfile,"%s",BIGstring); 


}


int GetTRExMetaCount(char *txtfile, int verbose)
{
  FILE *readfile;
  char aline[1000];
  int count=0;

  readfile = fopen(txtfile,"r");
  if(readfile!=NULL)
  { 
	fgets(aline,1000,readfile);

    if(!strncmp(aline,"Unable to validate TREx metadata",32))
	{
	  fclose(readfile);
	  return 1; 
	}

	while(!feof(readfile))
	{
	  if(
		  (!strncmp(aline,"Error    ",9))||
		  (!strncmp(aline,"Error:   ",9))
		)
	  {
	    count = count + 1;
	  }
	  fgets(aline,1000,readfile);
	}
	fclose(readfile);
  } 
  else
  {
    if(verbose==1)
	{
	  printf("Error: Unable to open %s\n",txtfile);
	  return -1;
	}
  }

  return count;
}






char * DecodeCodepoint(char *codepoint)
{
  int i;
  static char retval[100]; 
  extern char *PartialUnicode[UnicodeNum*2];



  for(i=0;i<UnicodeNum*2;i=i+2)
  {
    if(!strcmp(codepoint,PartialUnicode[i]))
	{
	  sprintf(retval,"%s",PartialUnicode[i+1]);
	  return retval;
	}
  }

  return "Codepoint not in GAIT's catalog.  Look up manually?";
}




int AddTextFile(FILE *summfile, int type, char *qacr_lhs, int make_qacr)
{
  
  
  
  FILE *readfile;
  char txtfile[1000],aline[1000],savestring[1000],part1[1000],part2[1000],part3[1000],
    part4[1000],part5[1000],part6[1000],badattrstr[1000],attr1[1000],attr2[1000],qacr_str[200],
	txtfile1[1000],txtfile2[1000],testcodepoint[1000];
  int count=0,foundit=0,foundarea=0,foundline=0,foundpoint=0,i,total,insertindex,
	foundquote,inserted=0,wroteone=0,insertindex2=0,quotefound=0,possiblelastindex,newfile,
	firstfound,lastfound,foundnull,foundint=0,foundreal=0,foundstring=0,foundShape=0,txt_found,
	foundGD=0,foundIGD=0,foundGM=0,nam_found,nm3_found,nm4_found,iko_found,vdr_found,
	retcount=0,numadded=0,PLARLIMIT=500,plarbroke=0,foundDBF=0,foundINV=0,foundcurve,
	count1=0,count2=0,flag1=0,flag2=0,lastlen=0,len;
  
  int utf_err_types[11];
  extern char *GetTRExFileName();


  struct ListOfStr
  {
    char thestr[1000];
    char thestr2[1000];
    int count;
    int totalcount;
    struct ListOfStr *next;
  };
  
  struct ListOfStr *ListRoot = NULL;
  struct ListOfStr *temp     = NULL;
  struct ListOfStr *temp2    = NULL;
  struct ListOfStr *prev     = NULL;
  
  struct CodePointList
  {
    char *savecodepoint;
	int count;
    struct CodePointList * next;
  };
  struct CodePointList *codepointlist=NULL,*curr;
  
  extern char *UTF8errors[];

  for(i=0;i<11;i++)
  {
	utf_err_types[i] = 0;
  }


  if(type==1)
    {
      

      foundit = 0;  
      
      sprintf(txtfile,"%sunkcolumnG.txt",outattrdirectory);
      readfile = fopen(txtfile,"r");
      if(readfile!=NULL)
	{
	  fgets(aline,1000,readfile);
	  foundit = foundit + strlen(aline);
	  while(!feof(readfile))
	    {
	      if(strlen(aline)>=5)
		{

		  retcount = retcount + 1; 

		  if(retcount<10)
		  {
		    fprintf(summfile,"   ");
		  }
	      else if(retcount<100)
		  { 
		   fprintf(summfile,"  ");
		  } 
	      else if(retcount<1000)
		  { 
		   fprintf(summfile," ");
		  }
	      
		  fprintf(summfile,"    %d: %s",retcount,aline); 

		  if(make_qacr==1)
		  {
		    count = GetUnkCount(aline);

			if((count>0)&&(make_qacr==1))
			{
			  AddQACREntry(qacr_lhs,aline,count,2);
			}
		  }
		}
	    fgets(aline,1000,readfile);
 	    foundit = foundit + strlen(aline);
	    }
	  
	  fclose(readfile);
	}
      
      if(foundit<5)
	{
	  fprintf(summfile,"      None.\n");
	}

    return retcount;
  }
  
  else if(type==2)
    {
      
      
      sprintf(txtfile,"%sbadfcode.txt",outattrdirectory);
      readfile = fopen(txtfile,"r");
      if(readfile!=NULL)
	{
	  
	  fgets(aline,1000,readfile);
	  while(!feof(readfile))
	    {
	      
	      
	      if(
		  ( (strstr(aline,"FCODE")!=NULL) || (strstr(aline,"F_CODE")!=NULL) )     &&
		 (  (strstr(aline,"in data")!=NULL)  ||  (strstr(aline,"some data")!=NULL)  )
		 )
		{
		  sprintf(savestring,"%s",aline);
		  fgets(aline,1000,readfile);
		  sscanf(aline,"%d",&count);
		  
		  foundit = 0;
		  temp = ListRoot;
		  while(temp!=NULL)
		    {
		      if(!strcmp(temp->thestr,savestring))
			{
			  temp->count = temp->count + count;
			  foundit = 1;
			  break;
			}
		      temp = temp->next;
		    }

		  if(foundit==0)
		    {
		      temp = (struct ListOfStr *)malloc(sizeof(struct ListOfStr));
		      sprintf(temp->thestr,"%s",savestring);
		      temp->count = count;
		      temp->next  = ListRoot;
		      ListRoot    = temp;
		    }
		}
	      fgets(aline,1000,readfile);
	    }
	  fclose(readfile);


	  temp = ListRoot;
	  while(temp!=NULL)
	    {
	      wroteone = 1;
	      fprintf(summfile,"    %s         %d occurrences\n",temp->thestr,temp->count);

		  retcount = retcount + temp->count;
		  if(make_qacr==1)
		  {
			AddQACREntry(qacr_lhs,temp->thestr,temp->count,1);
		    AddQACREntry(qacr_lhs,temp->thestr,temp->count,2);
		  }
	      prev = temp;
	      temp = temp->next;
	      free(prev);
	    }
	  
	  if(wroteone==0)
	    {
	      fprintf(summfile,"      None.\n");
	    }
	}
      else
	{
	  fprintf(summfile,"      None.\n");
	}
      return retcount;
    }
  else if(type==3)
    {
      

	  if(counting_attr_only==1)  
	  {
        sprintf(txtfile,"%sbadattr.txt",outattrdirectory);
        readfile = fopen(txtfile,"r");
        if(readfile!=NULL)
		{
	      
	      fgets(aline,1000,readfile);
	      while(!feof(readfile))
		  {
            if(
		        (strstr(aline,"instances of")!=NULL) &&
		        (strstr(aline,"with invalid value:")!=NULL)
		      )
			{
		      sscanf(aline,"%d",&count);
			  retcount = retcount + count;
			}
            fgets(aline,1000,readfile);
		  }
	      fclose(readfile);		  
		}
	    return retcount;
	  }

      wroteone = 0;      
      sprintf(txtfile,"%sbadattr.txt",outattrdirectory);
      readfile = fopen(txtfile,"r");
      if(readfile!=NULL)
	{
	  
	  fgets(aline,1000,readfile);
	  while(!feof(readfile))
	    {
	      
	      
		  if(numadded >= PLARLIMIT)
		  {
			plarbroke = 1;
			break;
		  }

	      if(
		 (strstr(aline,"instances of")!=NULL) &&
		 (strstr(aline,"with invalid value:")!=NULL)
		 )
		{
		  sprintf(savestring,"%s",aline);

		  sscanf(aline,"%d%s%s%s%s%s%s%s",
			 &count,
			 part1,
			 part2,
			 badattrstr,
			 part3,
			 part4,
			 part5,
			 part6
			 );

		  
		  
		  foundquote = 0;
		  insertindex = 0;

		  for(i=0;i<(int)strlen(aline);i++)
		    {
		      if(foundquote==0)
			{
			  if(aline[i]=='"')
			    {
			      foundquote = 1;
			      part6[0] = '"';
			      insertindex = 1;
			    }
			}
		      else
			{
			  part6[insertindex] = aline[i];
			  insertindex = insertindex + 1;
			}
		    }
		  part6[insertindex] = '\0';
		  


		  sprintf(savestring,"%s  Invalid  %s",badattrstr,part6);
		  

		  foundit = 0;
		  temp = ListRoot;
		  while(temp!=NULL)
		    {
		      if(!strcmp(temp->thestr,savestring))
			{
			  temp->count = temp->count + count;
			  foundit = 1;
			  break;
			}
		      temp = temp->next;
		    }

		  if(foundit==0)
		    {
			  numadded = numadded + 1;

		      temp = (struct ListOfStr *)malloc(sizeof(struct ListOfStr));
		      sprintf(temp->thestr,"%s",savestring);
		      temp->count = count;


		      

		      inserted = 0;
		      temp2 = ListRoot;
		      prev  = NULL;

		      if(temp2!=NULL)
			{
			  sscanf(temp->thestr,"%s",attr1);
			  sscanf(temp2->thestr,"%s",attr2);

			  while(strcmp(attr1,attr2)>0)
			    {
			      if(temp2->next==NULL)
				  {
				    temp2->next = temp;
				    temp->next  = NULL;
				    inserted    = 1;
				    break;
				  }
			      prev = temp2;
			      temp2 = temp2->next;

			      if((temp==NULL)||(temp2==NULL))
				  {
				    break;
				  }
			      
			      sscanf(temp->thestr,"%s",attr1);
			      sscanf(temp2->thestr,"%s",attr2);			      
			    }
			}


		      if(inserted==0)
			{
			  if(prev==NULL)
			    {
			      temp->next = ListRoot;
			      ListRoot   = temp;
			    }
			  else
			    {
			      
			      temp->next = prev->next;
			      prev->next = temp;			  
			    }
			}
		    }
		}
	      fgets(aline,1000,readfile);
	    }
	  fclose(readfile);


	  if(ListRoot!=NULL)
	    {
	      fprintf(summfile,"                                                                  \n");
	      fprintf(summfile,"          Attribute            Invalid Value                Occurs\n");
	    }
	  else
	    {
	      fprintf(summfile,"      None.\n");
	    }
	  
	  total = 1;
	  temp  = ListRoot;	  
	  while(temp!=NULL)
	    {
	      fprintf(summfile,"     %d.",total);
	      
	      if(total<10)
		{
		  fprintf(summfile,"   ");
		}
	      else if(total<100)
		{
		  fprintf(summfile,"  ");
		}
	      else if(total<1000)
		{
		  fprintf(summfile," ");
		}
	      
	      
	      insertindex2      = 0;
	      quotefound        = 0;
	      possiblelastindex = 0;


	      for(i=0;i<(int)strlen(temp->thestr);i++)
		{
		  if(temp->thestr[i]=='"')
		    {
		      quotefound = i;
		      possiblelastindex = insertindex2 + 1;
		    }
		  
		  if(quotefound>0)
		    {
		      part3[insertindex2] = temp->thestr[i];
		      insertindex2 = insertindex2 + 1;
		    }
		}
	      
	      part3[possiblelastindex] = '\0';
	      
	      sscanf(temp->thestr,"%s%s",part1,part2);			  
	      
	      foundquote = 0;
	      insertindex = 0;

		  retcount = retcount + temp->count;

		  if(make_qacr==1)
		  {
			sprintf(qacr_str,"%s, value: %s",part1,part3);
			AddQACREntry(qacr_lhs,qacr_str,temp->count,1);
		    AddQACREntry(qacr_lhs,qacr_str,temp->count,2);
		  }


	      fprintf(summfile,"%s",part1);
	      for(i=strlen(part1)+7;i<28;i++)
		{
		  fprintf(summfile," ");
		}	  
	      fprintf(summfile,"%s",part3);
	      
	      for(i=strlen(part3);i<27;i++)
		{
		  fprintf(summfile," ");
		}	  
	      fprintf(summfile,"%8d",temp->count);
	      
	      sprintf(part4,"%8d",temp->count);
	      for(i=strlen(part4);i<8;i++)
		{
		  fprintf(summfile," ");
		}	  
		  fprintf(summfile,"\n");

	      total = total + 1;
	      prev = temp;
	      temp = temp->next;
	    }
	}
      else
	{
	  fprintf(summfile,"    None found.\n");
	}



      
      
      temp  = ListRoot;	  
      while(temp!=NULL)
	{
	  prev = temp;
	  temp = temp->next;
	  free(prev);
	}


	  if(plarbroke==1)
	  {
		  fprintf(summfile,"\n     Listing terminated after %d entries\n",PLARLIMIT);
		  fprintf(summfile,"     See %sbadattr.txt\n     for full list\n",outattrdirectory);
	  }
      return retcount;
    }
  else if((type==4)&&(ATTRTYPE_TREX()==0))
    {
      

      
      
	  if(make_qacr==1)
	  {
	    MakeRollupQACR();
	  }

      sprintf(txtfile,"%sAttrErrorRollup.bin",outdirectory);
      readfile = fopen(txtfile,"r");
      if(readfile!=NULL)
	{
	  
	  fgets(aline,1000,readfile);
	  while(!feof(readfile))
	    {
	      fprintf(summfile,"%s",aline);
	      fgets(aline,1000,readfile);
	    }
	  fclose(readfile);
	}
      else
	{
	  
	}
    }
  else if(type==5)
    {
      
      
      txt_found = 0;
      nam_found = 0;
      nm3_found = 0;
      nm4_found = 0;
      iko_found = 0;
      vdr_found = 0;

      sprintf(txtfile,"%sbadcase.txt",outattrdirectory);
      readfile = fopen(txtfile,"r");
      if(readfile!=NULL)
	{
	  
	  fgets(aline,1000,readfile);
	  while(!feof(readfile))
	    {
	      
	      
	      
	      
	      if(strstr(aline,"found for attribute TXT")!=NULL)
		{
		  txt_found = txt_found + 1;
		}
	      else if(strstr(aline,"found for attribute NAM")!=NULL)
		{
		  nam_found = nam_found + 1;
		}
	      else if(strstr(aline,"found for attribute NM3")!=NULL)
		{
		  nm3_found = nm3_found + 1;
		}
	      else if(strstr(aline,"found for attribute NM4")!=NULL)
		{
		  nm4_found = nm4_found + 1;
		}
	      else if(strstr(aline,"found for attribute IKO")!=NULL)
		{
		  iko_found = iko_found + 1;
		}
	      else if(strstr(aline,"found for attribute VDR")!=NULL)
		{
		  vdr_found = vdr_found + 1;
		}
	      else if(strstr(aline,"pick-list instances")!=NULL)
		{
		  sscanf(aline,"%d%s%s%s%s",
			 &count,part1,part2,part3,part4);

		  

		  firstfound = 0;
		  lastfound  = 0;
		  for(i=0;i<(int)strlen(aline);i++)
		    {
		      if(aline[i]=='"')
			{
			  if(firstfound==0)
			    {
			      firstfound = i;
			    }
			  else
			    {
			      lastfound = i;
			    }
			}
		    }
		  
		  for(i=firstfound;i<=lastfound;i++)
		    {
		      part5[i-firstfound] = aline[i];
		    }
		  part5[i-firstfound] = '\0';


		  
		  foundit = 0;
		  temp = ListRoot;
		  while(temp!=NULL)
		    {
		      if(
			 (!strcmp(temp->thestr ,part4)) &&
			 (!strcmp(temp->thestr2,part5)) 
			 )
			{
			  temp->count = temp->count + count;
			  foundit = 1;
			  break;
			}
		      temp = temp->next;
		    }

		  if(foundit==0)
		    {
		      temp = (struct ListOfStr *)malloc(sizeof(struct ListOfStr));
		      sprintf(temp->thestr, "%s",part4);
		      sprintf(temp->thestr2,"%s",part5);
		      temp->count      = count;
		      temp->totalcount = -1;
		      temp->next       = ListRoot;
		      ListRoot         = temp;
		    }
		}
	      fgets(aline,1000,readfile);
	    }
	  fclose(readfile);
	  
	  if((txt_found+nam_found+nm3_found+nm4_found+iko_found+vdr_found)>0)
	    {
	      fprintf(summfile,"   UFD \"Uppercase String\" violation%s:\n",MakePlural(txt_found+nam_found+nm3_found+nm4_found+iko_found+vdr_found));
	      if(iko_found>0)
		{
		  fprintf(summfile,"      IKO:  %d violation%s\n",iko_found,MakePlural(iko_found));

	      retcount = retcount + iko_found;

			if(make_qacr==1)
		  {
			AddQACREntry("UFD \"Uppercase String\" violation","IKO",iko_found,1);
		    AddQACREntry("UFD \"Uppercase String\" violation","IKO",iko_found,2);
		  }
		}
	      if(nam_found>0)
		{
		  fprintf(summfile,"      NAM:  %d violation%s\n",nam_found,MakePlural(nam_found));
	      retcount = retcount + nam_found;
		  if(make_qacr==1)
		  {
			AddQACREntry("UFD \"Uppercase String\" violation","NAM",nam_found,1);
		    AddQACREntry("UFD \"Uppercase String\" violation","NAM",nam_found,2);
		  }
		}
	      if(nm3_found>0)
		{
		  fprintf(summfile,"      NM3:  %d violation%s\n",nm3_found,MakePlural(nm3_found));
	      retcount = retcount + nm3_found;
		  if(make_qacr==1)
		  {
			AddQACREntry("UFD \"Uppercase String\" violation","NM3",nm3_found,1);
		    AddQACREntry("UFD \"Uppercase String\" violation","NM3",nm3_found,2);
		  }
		}
	      if(nm4_found>0)
		{
		  fprintf(summfile,"      NM4:  %d violation%s\n",nm4_found,MakePlural(nm4_found));
	      retcount = retcount + nm4_found;
		  if(make_qacr==1)
		  {
			AddQACREntry("UFD \"Uppercase String\" violation","NM4",nm4_found,1);
		    AddQACREntry("UFD \"Uppercase String\" violation","NM4",nm4_found,2);
		  }
		}
	      if(txt_found>0)
		{
		  fprintf(summfile,"      TXT:  %d violation%s\n",txt_found,MakePlural(txt_found));
	      retcount = retcount + txt_found;
		  if(make_qacr==1)
		  {
			AddQACREntry("UFD \"Uppercase String\" violation","TXT",txt_found,1);
		    AddQACREntry("UFD \"Uppercase String\" violation","TXT",txt_found,2);
		  }
		}
	      if(vdr_found>0)
		{
		  fprintf(summfile,"      VDR:  %d violation%s\n",vdr_found,MakePlural(vdr_found));
	      retcount = retcount + vdr_found;
		  if(make_qacr==1)
		  {
			AddQACREntry("UFD \"Uppercase String\" violation","VDR",vdr_found,1);
		    AddQACREntry("UFD \"Uppercase String\" violation","VDR",vdr_found,2);
		  }
		}
	    }
	  if(ListRoot!=NULL)
	    {
	      fprintf(summfile,"                                                                  \n");
	      fprintf(summfile,"          Attribute            Invalid Value                Occurs\n");
	    }
	  
	  if((ListRoot==NULL)&&((txt_found+nam_found+nm3_found+nm4_found+iko_found+vdr_found)==0))
	    {
	      fprintf(summfile,"      None.\n");
	    }
	  
		

	  total = 1;
	  temp = ListRoot;
	  while(temp!=NULL)
	    {
	      fprintf(summfile,"     %d.",total);
	      
	      if(total<10)
		{
		  fprintf(summfile,"   ");
		}
	      else if(total<100)
		{
		  fprintf(summfile,"  ");
		}
	      else if(total<1000)
		{
		  fprintf(summfile," ");
		}
	      
	      retcount = retcount + temp->count;
		  if(make_qacr==1)
		  {
			sprintf(qacr_str,"%s, value: %s",temp->thestr,temp->thestr2);
			AddQACREntry(qacr_lhs,qacr_str,temp->count,1);
		    AddQACREntry(qacr_lhs,qacr_str,temp->count,2);
		  }

	      fprintf(summfile,"%s",temp->thestr);
	      for(i=strlen(temp->thestr)+7;i<28;i++)
		{
		  fprintf(summfile," ");
		}	  
	      fprintf(summfile,"%s",temp->thestr2);
	      
	      for(i=strlen(temp->thestr2);i<27;i++)
		{
		  fprintf(summfile," ");
		}	  
	      fprintf(summfile,"%8d",temp->count);
	      
	      sprintf(part4,"%8d",temp->count);
	      for(i=strlen(part4);i<8;i++)
		{
		  fprintf(summfile," ");
		}	  


	      total = total + 1;
	      temp = temp->next; 
	    }

	  temp  = ListRoot;	  
	  while(temp!=NULL)
	    {
	      prev = temp;
	      temp = temp->next;
	      free(prev);
	    }
	  return retcount;
	  

	}
    }
	 else if(type==6)
    {
      

	  foundarea  = 0;
	  foundline  = 0;
	  foundpoint = 0;

      sprintf(txtfile,"%sbadshapes.txt",outattrdirectory);
      readfile = fopen(txtfile,"r");
      if(readfile!=NULL)
	  {
	   
	    fgets(aline,1000,readfile);
	    while(!feof(readfile))
		{
	      if(strstr(aline,"Area feature detected with")!=NULL)
		  {
			  foundarea = foundarea + 1;
		  }
	      if(strstr(aline,"Line feature detected with")!=NULL)
		  {
			  foundline = foundline + 1;
		  }
	      if(strstr(aline,"Point feature detected with")!=NULL)
		  {
			  foundpoint = foundpoint + 1;
		  }
	      fgets(aline,1000,readfile);
		}

		fclose(readfile);


		if(foundarea>=1)
		{
			fprintf(summfile,"      %d Zero-part area feature%s found.\n",foundarea,MakePlural(foundarea));

 	        retcount = retcount + foundarea;
			
			if(make_qacr==1)
			{
			 AddQACREntry(qacr_lhs,"Zero-part area features",foundarea,1);
		     AddQACREntry(qacr_lhs,"Zero-part area features",foundarea,2);
			} 
		}

		if(foundline>=1)
		{
			fprintf(summfile,"      %d Zero-part line feature%s found.\n",foundline,MakePlural(foundline));
	        retcount = retcount + foundline;
			if(make_qacr==1)
			{
			 AddQACREntry(qacr_lhs,"Zero-part line features",foundline,1);
		     AddQACREntry(qacr_lhs,"Zero-part line features",foundline,2);
			} 
		}

		if(foundpoint>=1)
		{
			fprintf(summfile,"      %d Zero-part point feature%s found.\n",foundpoint,MakePlural(foundpoint));
	        retcount = retcount + foundpoint;
			if(make_qacr==1)
			{
			 AddQACREntry(qacr_lhs,"Zero-part point features",foundpoint,1);
		     AddQACREntry(qacr_lhs,"Zero-part point features",foundpoint,2);
			} 
		}
		

		if((foundarea+foundline+foundpoint)==0)
		{
  	        fprintf(summfile,"      None.\n");
		}
	  }
	   else
		{
  	        fprintf(summfile,"      None.\n");
		}
	  return retcount;
	 }




	 else if(type==7)
    {
      
      
      foundnull = 0;
      
      sprintf(txtfile,"%snullshp.txt",outattrdirectory);
      readfile = fopen(txtfile,"r");
      if(readfile!=NULL)
	{
	  
	  fgets(aline,1000,readfile);
	  while(!feof(readfile))
	    {
	      if(strstr(aline,"is a NULL feature")!=NULL)
		{
		  foundnull = foundnull + 1;
		}
	      else if(strstr(aline,"area feature with only")!=NULL)
		{
		  foundnull = foundnull + 1;
		}
 
	      fgets(aline,1000,readfile);
	    }
	  
	  fclose(readfile);
	  
	  
	  if(foundnull>=1)
	    {
	      fprintf(summfile,"      %d NULL feature%s found.\n",foundnull,MakePlural(foundnull));
	      retcount = retcount + foundnull;
		  if(make_qacr==1)
			{
			 AddQACREntry("NULL Feature errors","NULL features found",foundnull,1);
		     AddQACREntry("NULL Feature errors","NULL features found",foundnull,2);
			} 
	    }
	  else
	    {
	      fprintf(summfile,"      None.\n");
	    }
	}
      else
	{
	  fprintf(summfile,"      None.\n");
	}
      return retcount;
    }
    
  else if(type==8)
    {
      
      
      foundit = 0;
      
      sprintf(txtfile,"%sbadcoord.txt",outattrdirectory);
      readfile = fopen(txtfile,"r");
      if(readfile!=NULL)
	{
	  
	  fgets(aline,1000,readfile);
	  while(!feof(readfile))
	    {
	      if(strstr(aline,"has invalid coordinates")!=NULL)
		{
		  foundit = foundit + 1;
		}	      
	      fgets(aline,1000,readfile);
	    }
	  
	  fclose(readfile);


	  if(foundit>=1)
	    {
	      fprintf(summfile,"      %d feature%s with invalid coordinates found.\n",foundit,MakePlural(foundit));
	      retcount = retcount + foundit;
		  if(make_qacr==1)
			{
			 AddQACREntry(qacr_lhs,"Features with invalid coordinates",foundit,1);
		     AddQACREntry(qacr_lhs,"Features with invalid coordinates",foundit,2);
			}
	    }
	  else
	    {
	      fprintf(summfile,"      None.\n");
	    }
	}
      else
	{
	  fprintf(summfile,"      None.\n");
	}
      return retcount;
    }
  
  
  
  
  else if(type==9)
    {
      
      foundit = 0;
      
      sprintf(txtfile,"%sbadhole.txt",outattrdirectory);
      readfile = fopen(txtfile,"r");
      if(readfile!=NULL)
	{
	  
	  fgets(aline,1000,readfile);
	  while(!feof(readfile))
	    {
	      if(strstr(aline,"But could not find an object this is a hole of for this record")!=NULL)
		{
		  foundit = foundit + 1;
		}	      
	      if(strstr(aline,"which is not inside the external boundary")!=NULL)
		{
		  foundit = foundit + 1;
		}	      
	      fgets(aline,1000,readfile);
	    }
	  
	  fclose(readfile);
	  
	  
	  if(foundit>=1)
	    {
	      fprintf(summfile,"      %d invalid cut-out error%s found.\n",foundit,MakePlural(foundit));
	      retcount = retcount + foundit;
		  if(make_qacr==1)
			{
			 AddQACREntry("Invalid Cut-Out errors","Invalid cut-outs",foundit,1);
		     AddQACREntry("Invalid Cut-Out errors","Invalid cut-outs",foundit,2);
			}
	    }
	  else
	    {
	      fprintf(summfile,"      None.\n");
	    }
	}
      else
	{
	  fprintf(summfile,"      None.\n");
	}
      return retcount;
    }

  
  
  else if(type==11)
    {

      foundit = 0;

      sprintf(txtfile,"%snofcodecolumn.txt",outattrdirectory);

      readfile = fopen(txtfile,"r");
      if(readfile!=NULL)
	{
	  
	  fgets(aline,1000,readfile);
	  while(!feof(readfile))
	    {
	      if(strstr(aline," not containing an ")==NULL)
		{
		  if(strlen(aline)>3)
		    {
		      foundit = foundit + 1;
		    }
		}	      
	      fgets(aline,1000,readfile);
	    }
	  
	  fclose(readfile);


	  if(foundit>=1)
	    {
	      fprintf(summfile,"      %d table%s with no \"FCODE\" column found.\n",foundit,MakePlural(foundit));
	      retcount = retcount + foundit;
		  if(make_qacr==1)
			{
 			 AddQACREntry(qacr_lhs,"Tables/Shapefiles with no \"FCODE\" column",foundit,2);
			}
	    }
	  else
	    {
	      fprintf(summfile,"      None.\n");
	    }
	}
      else
	{
	  fprintf(summfile,"      None.\n");
	}
      return retcount;
    }
  



  else if(type==12)
    {
      
      foundit = 0;
      
      sprintf(txtfile,"%sbadmgcpfilename.txt",outattrdirectory);
      readfile = fopen(txtfile,"r");
      if(readfile!=NULL)
	{
	  
	  fgets(aline,1000,readfile);
	  while(!feof(readfile))
	    {
	      if(strstr(aline,"Shapefiles with file names not meeting MGCP ShapeFile Implementation Rules")==NULL)
		{
		  if(strlen(aline)>3)
		    {
		      foundit = foundit + 1;
		    }
		}	      
	      fgets(aline,1000,readfile);
	    }
	  
	  fclose(readfile);
	  
	  
	  if(foundit>=1)
	    {
	      fprintf(summfile,"      %d shapefile%s with MGCP Shapefile Naming errors found.\n",foundit,MakePlural(foundit));
	      retcount = retcount + foundit;
		  if(make_qacr==1)
			{
 			 AddQACREntry(qacr_lhs,"Shapefiles with MGCP Shapefile Naming errors",foundit,2);
			}
	    }
	  else
	    {
	      fprintf(summfile,"      None.\n");
	    }
	}
      else
	{
	  fprintf(summfile,"      None.\n");
	}
      return retcount;
    }
  
  


  else if(type==13)
    {
      
      foundit = 0;
      
      sprintf(txtfile,"%sbadshapetype.txt",outattrdirectory);
      readfile = fopen(txtfile,"r");
      if(readfile!=NULL)
	{
	  
	  fgets(aline,1000,readfile);
	  while(!feof(readfile))
	    {
	      if(strstr(aline,"is not valid for MGCP")!=NULL)
		{
		  foundit = foundit + 1;
		}	      
	      fgets(aline,1000,readfile);
	    }
	  
	  fclose(readfile);
	  
	  
	  if(foundit>=1)
	    {
	      fprintf(summfile,"      %d shapefile%s with MGCP \"shape type\" errors found.\n",foundit,MakePlural(foundit));
	      retcount = retcount + foundit;
		  if(make_qacr==1)
			{
			 AddQACREntry(qacr_lhs,"Shapefiles with MGCP \"shape type\" errors",foundit,2);
			}
	    }
	  else
	    {
	      fprintf(summfile,"      None.\n");
	    }
	}
      else
	{
	  fprintf(summfile,"      None.\n");
	}
      return retcount;
    }


  
  else if(type==14)
    {
      
      foundint    = 0;
      foundreal   = 0;
      foundstring = 0;
      
      sprintf(txtfile,"%sblankattrval.txt",outattrdirectory);
      readfile = fopen(txtfile,"r");
      if(readfile!=NULL)
	{

	  


	  

	  if(global_short_attr_count==0)
	  {
	    fgets(aline,1000,readfile);
	    while(!feof(readfile))
		{
	      if(strstr(aline,"is a blank integer")!=NULL)
		  {
		   foundint = foundint + 1;
		  } 	      
	      if(strstr(aline,"is a blank real")!=NULL)
		  { 
		   foundreal = foundreal + 1;
		  }	       
	      if(strstr(aline,"is a blank string")!=NULL)
		  { 
		   foundstring = foundstring + 1;
		  }	       
	      fgets(aline,1000,readfile);
		}
	  }

	  fclose(readfile);

	  
	  if(foundint>=1)
	    {
	      fprintf(summfile,"      %d blank integer value%s found.\n",foundint,MakePlural(foundint));
	    }
	  
	  if(foundreal>=1)
	    {
	      fprintf(summfile,"      %d blank real value%s found.\n",foundreal,MakePlural(foundreal));
	    }
	  
	  if(foundstring>=1)
	    {
	      fprintf(summfile,"      %d blank string value%s found.\n",foundstring,MakePlural(foundstring));
	    }

	  
	  if(((foundint+foundreal+foundstring)==0)&&(global_short_attr_count==0))
	    {
	      fprintf(summfile,"      None.\n");
	    }
	  else
	  {
		
	    fprintf(summfile,"\n");
	    sprintf(txtfile,"%sblankG.txt",outattrdirectory);
        readfile = fopen(txtfile,"r");
        if(readfile!=NULL)
		{
	      fgets(aline,1000,readfile);
	      while(!feof(readfile))
		  {

            if(strlen(aline)>5)
			{
			  fprintf(summfile,"   %s",aline);

 			  sscanf(aline,"%s%s%s%d",part1,part2,part3,&foundit);

	          retcount = retcount + foundit;
			  if(make_qacr==1)
			  {
			   AddQACREntry(qacr_lhs,part2,foundit,2);
			  }
			}
	        fgets(aline,1000,readfile);
		  }
		  fclose(readfile);
		}
	  }
	}
      else
	{
	  fprintf(summfile,"      None.\n");
	}
      return retcount;
    }
  
    

  
  else if(type==15)
    {
	  if(ATTRIBUTION_TYPE!=7)
	  {
        printf("ATFMN: Should not be here with %d\n",ATTRIBUTION_TYPE);
		return retcount;
	  }
      
      foundint    = 0;
      foundreal   = 0;
      foundstring = 0;
      
      sprintf(txtfile,"%smgcpmixednull.txt",outattrdirectory);
      readfile = fopen(txtfile,"r");
      if(readfile!=NULL)
	{
	  
	  fgets(aline,1000,readfile);
	  while(!feof(readfile))
	    {
	      if(strstr(aline,"and Non-Null Integer values")!=NULL)
		{
		  foundint = foundint + 1;
		}	      
	      if(strstr(aline,"and Non-Null Real values")!=NULL)
		{
		  foundreal = foundreal + 1;
		}	      
	      if(strstr(aline,"and Non-Null Character values")!=NULL)
		{
		  foundstring = foundstring + 1;
		}	      
	      fgets(aline,1000,readfile);
	    }
	  
	  fclose(readfile);
	  
	  
	  if(foundint>=1)
	    {
	      fprintf(summfile,"      %d column%s with mixed Null/Non-Null integer values found.\n",foundint,MakePlural(foundint));

	      retcount = retcount + foundint;
		  if(make_qacr==1)
		  {
 			AddQACREntry(qacr_lhs,"Columns with mixed Null/Non-Null integer values",foundint,2);
		  }
	    }
	  
	  if(foundreal>=1)
	    {
	      fprintf(summfile,"      %d column%s with mixed Null/Non-Null real values found.\n",foundreal,MakePlural(foundreal));

		  retcount = retcount + foundreal;
		  if(make_qacr==1)
		  {
 			AddQACREntry(qacr_lhs,"Columns with mixed Null/Non-Null real values",foundreal,2);
		  }
	    }

	  if(foundstring>=1)
	    {
	      fprintf(summfile,"      %d column%s with mixed Null/Non-Null character values found.\n",foundstring,MakePlural(foundstring));
	      retcount = retcount + foundstring;
		  if(make_qacr==1)
		  {
 			AddQACREntry(qacr_lhs,"Columns with mixed Null/Non-Null character values",foundstring,2);
		  }
	    }

	  
	  if((foundint+foundreal+foundstring)==0)
	    {
	      fprintf(summfile,"      None.\n");
	    }
	}
      else
	{
	  fprintf(summfile,"      None.\n");
	}
      return retcount;
    }




 else if(type==16)
    {
      
      foundit    = 0;
      
      sprintf(txtfile,"%sbadtype.txt",outattrdirectory);
      readfile = fopen(txtfile,"r");
      if(readfile!=NULL)
	{
	  
	  fgets(aline,1000,readfile);
	  while(!feof(readfile))
	    {
	      if(strstr(aline,":  expected ")!=NULL)
		{
		  foundit = foundit + 1;
		}
	      fgets(aline,1000,readfile);
	    }
	  
	  fclose(readfile);
	  
	  
	  if(foundit==0)
	    {
	      fprintf(summfile,"      None.\n");
	    }
	  else if(foundit>=1)
	    {
	      fprintf(summfile,"      %d Attribute%s with invalid data type found.\n",foundit,MakePlural(foundit));

	      retcount = retcount + foundit;
		  if(make_qacr==1)
		  {
			AddQACREntry(qacr_lhs,"Columns with invalid data type",foundit,1);
		    AddQACREntry(qacr_lhs,"Columns with invalid data type",foundit,2);
		  }
	    }
	}
      else
	{
	  fprintf(summfile,"      None.\n");
	}
      return retcount;
    }




 else if(type==17)
   {
      
      foundit    = 0;
      
      sprintf(txtfile,"%sbadlen.txt",outattrdirectory);
      readfile = fopen(txtfile,"r");
      if(readfile!=NULL)
	{
	  
	  fgets(aline,1000,readfile);
	  while(!feof(readfile))
	    {
	      if(strstr(aline,":  expected ")!=NULL)
		{
		  foundit = foundit + 1;
		}
	      fgets(aline,1000,readfile);
	    }
	  
	  fclose(readfile);
	  
	  
	  if(foundit==0)
	    {
	      fprintf(summfile,"      None.\n");
	    }
	  else if(foundit>=1)
	    {
		  fprintf(summfile,"      %d Attribute%s with invalid field lengths found.\n",foundit,MakePlural(foundit));
          retcount = retcount + foundit;
		  if(make_qacr==1)
		  {
		    AddQACREntry(qacr_lhs,"Attributes with invalid field lengths",foundit,2);
		  }
	    }
	}
      else
	{
	  fprintf(summfile,"      None.\n");
	}
      return retcount;
    }



  else if(type==18)
    {
      
      foundShape = 0;
      foundGD    = 0;
      foundIGD   = 0;
      foundGM    = 0;
	  foundDBF   = 0;
      foundINV   = 0;

      sprintf(txtfile,"%semptyshapes.txt",outattrdirectory);
      readfile = fopen(txtfile,"r");
      if(readfile!=NULL)
	{
	  
	  fgets(aline,1000,readfile);
	  while(!feof(readfile))
	    {
	      if(strstr(aline,"Empty Shapefile")!=NULL)
		  {
		   foundShape = foundShape + 1;
		  }	      
	      if(strstr(aline,"Shapefile With Invalid DBF")!=NULL) 
		  {
		   foundDBF = foundDBF + 1;
		  }	      
	      if(strstr(aline,"Empty Geodatabase Table")!=NULL)
		  {
		   foundGD = foundGD + 1;
		  }
	      if(strstr(aline,"Invalid Geodatabase Table")!=NULL)
		  {
		   foundIGD = foundIGD + 1;
		  }
	      if(strstr(aline,"Empty GeoMedia Access Table")!=NULL)
		  {
		   foundGM = foundGM + 1;
		  }
	      if(strstr(aline,"Shapefile with invalid")!=NULL)  
		  {
		   foundINV = foundINV + 1;
		  }

	      fgets(aline,1000,readfile);
	    }
	  
	  fclose(readfile);
	}
	  
  	  if(foundIGD>=1)
	    {
	      fprintf(summfile,"      %d Invalid Geodatabase Table%s found.\n",foundIGD,MakePlural(foundIGD));

	      retcount = retcount + foundIGD;

		  if(make_qacr==1)
		  {
			AddQACREntry(qacr_lhs,"Invalid Geodatabase Tables found",foundIGD,1);
		    AddQACREntry(qacr_lhs,"Invalid Geodatabase Tables found",foundIGD,2);
		  }
	    }

	  if(foundShape>=1)
	    {
	      fprintf(summfile,"      %d blank Shapefile%s found.\n",foundShape,MakePlural(foundShape));

          retcount = retcount + foundShape;
		  if(make_qacr==1)
		  {
			AddQACREntry(qacr_lhs,"Blank Shapefiles found",foundShape,1);
		    AddQACREntry(qacr_lhs,"Blank Shapefiles found",foundShape,2);
		  }
	    }
	  
	  if(foundGD>=1)
	    {
	      fprintf(summfile,"      %d blank Geodatabase Table%s found.\n",foundGD,MakePlural(foundGD));

	      retcount = retcount + foundGD;

		  if(make_qacr==1)
		  {
			AddQACREntry(qacr_lhs,"Blank Geodatabase Tables found",foundGD,1);
		    AddQACREntry(qacr_lhs,"Blank Geodatabase Tables found",foundGD,2);
		  }
	    }
	  
	  if(foundGM>=1)
	    {
	      fprintf(summfile,"      %d blank GeoMedia Access Table%s found.\n",foundGM,MakePlural(foundGM));

          retcount = retcount + foundGM;

		  if(make_qacr==1)
		  {
			AddQACREntry(qacr_lhs,"Blank GeoMedia Access Tables found",foundGM,1);
		    AddQACREntry(qacr_lhs,"Blank GeoMedia Access Tables found",foundGM,2);
		  }
	    }
	  if(foundDBF>=1)
	    {
	      fprintf(summfile,"      %d Invalid Shapefile DBF file%s found.\n",foundDBF,MakePlural(foundDBF));

          retcount = retcount + foundDBF;

		  if(make_qacr==1)
		  {
			AddQACREntry(qacr_lhs,"Invalid Shapefile DBF files found",foundDBF,1);
		    AddQACREntry(qacr_lhs,"Invalid Shapefile DBF files found",foundDBF,2);
		  }
	    }

	  if(foundINV>=1)
	    {
	      fprintf(summfile,"      %d Invalid Shapefile with final feature%s found.\n",foundINV,MakePlural(foundINV));

          retcount = retcount + foundINV;

		  if(make_qacr==1)
		  {
			AddQACREntry(qacr_lhs,"Invalid Shapefile with final feature found",foundINV,1);
		    AddQACREntry(qacr_lhs,"Invalid Shapefile with final feature found",foundINV,2);
		  }
	    }
	  
	  
	  if((foundShape+foundGD+foundGM+foundDBF+foundINV)==0)
	    {
	      fprintf(summfile,"      None.\n");
	    }

      return retcount;
    }



 else if(type==19)
   {
      
      foundit    = 0;
      
      sprintf(txtfile,"%sbadutf.txt",outattrdirectory);
      readfile = fopen(txtfile,"r");
      if(readfile!=NULL)
	{
	  
	  fgets(aline,1000,readfile);
	  while(!feof(readfile))
	  { 
	    if(strstr(aline,"UTF-8 encoding anomaly for file/table:")!=NULL)
		{
		  foundit = foundit + 1;
		}

        for(i=0;i<11;i++)
		{ 
		  if(strstr(aline,UTF8errors[i]))
		  { 
	        utf_err_types[i] = utf_err_types[i] + 1;
		  } 
		}

		if((make_qacr>0) && (!strncmp(aline,"  Invalid codepoint: ",21)))  
		{
		  sprintf(testcodepoint,"%s",&aline[21]);

	      len = strlen(testcodepoint);
          if(testcodepoint[len-1]=='\n')
		  {
	        testcodepoint[len-1]='\0';
		  }

		  curr = codepointlist;
		  while(curr!=NULL)
		  {
			if(!strcmp(testcodepoint,curr->savecodepoint))
			{
			  curr->count = curr->count + 1;
			  break;
			}
			curr=curr->next;
		  }

		  if(curr==NULL)
		  {
			
			curr=malloc(sizeof (struct CodePointList));
			curr->savecodepoint = malloc(strlen(testcodepoint)+5);
			sprintf(curr->savecodepoint,"%s",testcodepoint);
			curr->count = 1;

			curr->next = codepointlist;
			codepointlist = curr;
		  }

		}

	    fgets(aline,1000,readfile);
	  }
	  
	  fclose(readfile);
	  
	  
	  if(foundit==0)
	    {
	      fprintf(summfile,"      None.\n");
	    }
	  else if(foundit>=1)
	    {

		  if(foundit==1)
		  {
		    fprintf(summfile,"      %d UTF-8 encoding anomaly found:\n",foundit);
		  }
		  else
		  {
		    fprintf(summfile,"      %d UTF-8 encoding anomalies found:\n",foundit);
		  }

		  curr = codepointlist;
		  while(curr!=NULL)
		  {
			fprintf(summfile,"       Invalid codepoint found: %s (%s) (%d)\n",curr->savecodepoint,DecodeCodepoint(curr->savecodepoint),curr->count);
			codepointlist = curr;
			curr=curr->next;

			free(codepointlist->savecodepoint);
			free(codepointlist);
		  }

	      for(i=0;i<11;i++)
		  { 
		    if(utf_err_types[i]>0)
			{
			  fprintf(summfile,"       Invalid UTF-8 format: %s (%d)\n",UTF8errors[i],utf_err_types[i]);
			}  
		  } 


          retcount = retcount + foundit;
		  if(make_qacr==1)
		  {
		    AddQACREntry(qacr_lhs,"UTF-8 encoding anomalies",foundit,2);
		  }
	    }
	}
      else
	{
	  fprintf(summfile,"      None.\n");
	}
      return retcount;
    }


	 else if(type==20)
    {
      
      
	  if(REPORT_BEZIER==0)
	  {
        printf("Error:  Should not call ATF20\n");
		return 0;
	  }

      foundcurve = 0;
      
      sprintf(txtfile,"%sbadcurves.txt",outattrdirectory);
      readfile = fopen(txtfile,"r");
      if(readfile!=NULL)
	{
	  
	  fgets(aline,1000,readfile);
	  while(!feof(readfile))
	    {
	      if(strstr(aline,"curve with")!=NULL)
		  { 
		    foundcurve = foundcurve + 1;
		  } 
 
	      fgets(aline,1000,readfile);
	    }
	  
	  fclose(readfile);
	  
	  
	  if(foundcurve>=1)
	    {
	      fprintf(summfile,"      %d Geodatabase Bezier/Circle/Ellipse feature%s found.\n",foundcurve,MakePlural(foundcurve));
	      retcount = retcount + foundcurve;
		  if(make_qacr==1)
			{
			 AddQACREntry("Geodatabase Bezier/Circle/Ellipse features","Geodatabase Bezier/Circle/Ellipse features",foundcurve,1);
		     AddQACREntry("Geodatabase Bezier/Circle/Ellipse features","Geodatabase Bezier/Circle/Ellipse features",foundcurve,2);
			} 
	    }
	  else
	    {
	      fprintf(summfile,"      None.\n");
	    }
	}
      else
	{
	  fprintf(summfile,"      None.\n");
	}
      return retcount;
    }

  else if(type==21)
    {

	  

	  wroteone = 0;

      sprintf(txtfile,"%stimp.bin",outdirectory);
      readfile = fopen(txtfile,"r");
      if(readfile!=NULL)
	  { 
        fprintf(summfile,"TREx Void Posts and Empty Masks\n\n");

	    fgets(aline,1000,readfile);
	    while(!feof(readfile))
	    {
		  if(!strncmp(aline,"VOID_SENTINEL ",14))
		  {
			wroteone = 1;
	        fprintf(summfile,"%s%s",trexspacer,&aline[14]);
		  }
	      fgets(aline,1000,readfile);
	    }
	    fclose(readfile);
	  } 

	  if(wroteone==0)
	  {
        fprintf(summfile,"%sNo DEM Finished found\n",trexspacer);
        fprintf(summfile,"%sNo empty masks found\n",trexspacer);
	  }

	  fprintf(summfile,"\n\n"); 

	  

      AddTrexReferenceDEMInfo(summfile);

	  fprintf(summfile,"\n\n"); 



	  

      AddTrexEdgeInfo(summfile);

	  fprintf(summfile,"\n\n"); 



	  

	  wroteone = 0;

      sprintf(txtfile,"%stimp.bin",outdirectory);
      readfile = fopen(txtfile,"r");
      if(readfile!=NULL)
	  { 
        fprintf(summfile,"TREx Data Packaging/Import\n\n");

	    fgets(aline,1000,readfile);
	    while(!feof(readfile))
	    {
		  if(!strncmp(aline,"IMPORT_SENTINEL ",16))
		  {
			if(!strncmp(aline,"IMPORT_SENTINEL Created surface difference file",47))
			{
			  
			  if(wroteone==1)
			  {
				if(lastlen>19)
				{
				  
				  fprintf(summfile,"\n");
				}
			  }
			}

			wroteone = 1;
			lastlen = strlen(aline);


	        fprintf(summfile,"%s%s",trexspacer,&aline[16]);
		  }
	      fgets(aline,1000,readfile);
	    }
	    fclose(readfile);
	  } 

	  if(wroteone==0)
	  {
        fprintf(summfile,"%sNo errors found and surface difference file not created\n",trexspacer);
	  }

	  fprintf(summfile,"\n\n"); 





	  

      readfile = fopen(txtfile,"r");
      if(readfile!=NULL)
	  { 

	    fgets(aline,1000,readfile);
	    while(!feof(readfile))
	    {
		  if(
			  (strncmp(aline,"VOID_SENTINEL ",14))   &&
			  (strncmp(aline,"IMPORT_SENTINEL ",16)) &&
			  (strncmp(aline,"EDGE_SENTINEL ",14))   &&
			  (strncmp(aline,"RANGE_SENTINEL ",15))  && 
			  (strncmp(aline,"LPC_SENTINEL ",13))    &&
			  (strncmp(aline,"ENV_SENTINEL ",13))   
			)
		  {
			if(!strncmp(aline,"Control Point Import Summary",28))
			{
	          fprintf(summfile,"%s",aline);
			}
			else
			{
			  if(strlen(aline)>2)
			  {
	            fprintf(summfile,"%s%s",trexspacer,aline);
			  }
			  else
			  {
				
	            fprintf(summfile,"%s",aline);
			  }
			}
		  }

	      fgets(aline,1000,readfile);
	    }
	    fclose(readfile);
	  } 




    }

  else if(type==22)
    {
      


	  count1 = 0;
	  count2 = 0;

	  flag1 = 0;
	  flag2 = 0;


      sprintf(txtfile ,"%s_XMLreport.txt",GetTRExFileName());
      sprintf(txtfile2,"%sXML%sTREx_raw_%s_results.txt",indirectory,GetSlash(),GetTRExSubName2(indirectory,0));          



	  count1 = GetTRExMetaCount(txtfile,1); 
	  if(count1<0)
	  {
		flag1 = 1;
		count1 = 0;
	  }

	  count2 = GetTRExMetaCount(txtfile2,0); 
	  if(count2<0)
	  {
		flag2 = 1;
		count2 = 0;
	  }

	  count = count1+count2;

      fprintf(summfile,"TREx XML Metadata error%s: %d\n",MakePlural(count),count);

	  if(flag1>0)
	  {
        fprintf(summfile,"\n");
        fprintf(summfile,"%sError: Unable to open expected XML result file: %s\n",trexspacer,txtfile);
	  }
	  if(flag2>0)
	  {
        fprintf(summfile,"\n");
        fprintf(summfile,"%sError: Unable to open expected XML result file: %s\n",trexspacer,txtfile1);
	  }


	  if(count>0)
	  {
		fprintf(summfile,"\n"); 

		if(count==1)
		{
          fprintf(summfile,"%sThis error is described in:\n",trexspacer);
		}
		else
		{
          fprintf(summfile,"%sThese errors are described in:\n",trexspacer);
		}

		if(count1>0)
		{
          fprintf(summfile,"   Finished XML (%d error%s):\n    %s\n",count1,MakePlural(count1),txtfile);
		}
		if(count2>0)
		{
          fprintf(summfile,"   Raw XML (%d error%s):\n    %s\n",count2,MakePlural(count2),txtfile2);
		}
	  }
    }

  else if(type==23)
    {
      

	  count = 0;  
	  count1 = 0; 

      sprintf(txtfile,"%s_GeoTIFFreport.txt",GetTRExFileName());

	  newfile = 0;

	  readfile = fopen(txtfile,"r");
      if(readfile!=NULL)
	  {   
	    fgets(aline,1000,readfile);

	    while(!feof(readfile))
		{   
	      if(!strncmp(aline," Error:   ",10))
		  { 
	        count = count + 1;
			if(newfile==1)
			{
			  count1 = count1 + 1;
			  newfile = 2;
			}
		  }  

 	      if(!strncmp(aline,"Errors found in",15))
		  { 
			newfile = 1;
		  }
	      fgets(aline,1000,readfile);
		}   
		fclose(readfile);
	  } 
	  else
	  {
		  printf("couldnt open %s\n",txtfile);
		  
	  }

      if(count==0)
	  {
        fprintf(summfile,"TREx GeoTIFF Header errors: 0\n");
	  }
	  else
	  {
        fprintf(summfile,"TREx GeoTIFF Header error%s: %d (from %d file%s)\n",
		  MakePlural(count),count,
		  count1,MakePlural(count1));

		fprintf(summfile,"\n"); 

		if(count==1)
		{
          fprintf(summfile,"%sThis error is described in:\n   %s\n",trexspacer,txtfile);
		}
		else
		{
          fprintf(summfile,"%sThese errors are described in:\n   %s\n",trexspacer,txtfile);
		}
	  }
    }




  return -1;
}







int GetConditionTypes()
{
  int TempArray[CONDITION_ARRAY_SIZE];
  int total=0;
  int i;


  for(i=0;i<=CONDITION_DEFINITIONS;i++)
    {
      TempArray[i] = 0;
    }
  
  
  for(i=1;i<=CONDITION_DEFINITIONS;i++)
  {
    if(IsNetCheck(i))
	{
      continue;
	}

    if(ErrorLookup[i].active==1)
	{
	  TempArray[i] = 1;
	}
  }
  

  for(i=0;i<CLONE_DEFINITIONS;i++)
  {
    if(IsNetCheck(CloneErrorLookup[i].CloneNumber))
	{
      continue;
	}

    if(CloneErrorLookup[i].active==1)
	{
	  TempArray[CloneErrorLookup[i].CloneNumber] = 1;
	}
  }
  

  for(i=0;i<=CONDITION_DEFINITIONS;i++)
    {
      total = total + TempArray[i];
    }

  return total;

}




int GetConditionInstances()
{
  int total=0;
  int i;
  
  
  for(i=1;i<=CONDITION_DEFINITIONS;i++)
  {
    if(IsNetCheck(i))
	{
      continue;
	}

    if(ErrorLookup[i].active==1)
	{
	  total = total + 1;
	}
  }
  

  for(i=0;i<CLONE_DEFINITIONS;i++)
  {
    if(IsNetCheck(CloneErrorLookup[i].CloneNumber))
	{
      continue;
	}

    if(CloneErrorLookup[i].active==1)
	{
	  total = total + 1;
	}
  }

  return total;
}


int GetConditionInstancesFound()
{
  int total=0;
  int i;
  
  
  for(i=1;i<=CONDITION_DEFINITIONS;i++)
  {
    if(IsNetCheck(i))
	{
      continue;
	}

    if((ErrorLookup[i].active==1)&&(ErrorLookup[i].number>0))
	{ 
	  total = total + 1;
	} 
  }  
  

  for(i=0;i<CLONE_DEFINITIONS;i++)
  {
    if(IsNetCheck(CloneErrorLookup[i].CloneNumber))
	{
      continue;
	}

    if((CloneErrorLookup[i].active==1)&&(CloneErrorLookup[i].number>0))
	{
	  total = total + 1;
	} 
  }

  return total;
}


int GetConditionCount()
{
  int total=0;
  int i;


  for(i=1;i<=CONDITION_DEFINITIONS;i++)
  {
    if(IsNetCheck(i))
	{
      continue;
	}

    if(ErrorLookup[i].active==1)
	{ 
      total = total + ErrorLookup[i].number;
	} 
  }


  for(i=0;i<CLONE_DEFINITIONS;i++)
  { 
    if(IsNetCheck(CloneErrorLookup[i].CloneNumber))
	{
      continue;
	}

    if(CloneErrorLookup[i].active==1)
	{
      total = total + CloneErrorLookup[i].number;
	}
  }

  return total;
}



void PrintShortConditionList(FILE *summfile)
{
  char tempa[1000];
  int ChecksOn   [CONDITION_ARRAY_SIZE],CountsFound[CONDITION_ARRAY_SIZE];
  int i,j,totalnum,cutpoint;

  
  for(i=0;i<=CONDITION_DEFINITIONS;i++)
    {
      if(IsNetCheck(i)==1)
	  {
        continue;
	  }

      ChecksOn   [i] = 0;
      CountsFound[i] = 0;
    }
  
  
  for(i=1;i<=CONDITION_DEFINITIONS;i++)
  { 
    if(IsNetCheck(i)==1)
	{
      continue;
	}

    if(ErrorLookup[i].active==1)
	{
	  ChecksOn[i] = ChecksOn[i] + 1;
	  CountsFound[i] = CountsFound[i] + ErrorLookup[i].number;
	} 
  }
  
  for(i=0;i<CLONE_DEFINITIONS;i++)
  {
    if(IsNetCheck(CloneErrorLookup[i].CloneNumber)==1)
	{
      continue;
	}

    if(CloneErrorLookup[i].active==1)
	{
	  ChecksOn[CloneErrorLookup[i].CloneNumber] = ChecksOn[CloneErrorLookup[i].CloneNumber] + 1;
	  CountsFound[CloneErrorLookup[i].CloneNumber] = 
	      CountsFound[CloneErrorLookup[i].CloneNumber] + CloneErrorLookup[i].number;
	}
  }

  
  totalnum = 1;


  for(i=0;i<=CONDITION_DEFINITIONS;i++)
    {

      if(IsNetCheck(i)==1)
	  { 
        continue;
	  } 

      if(ChecksOn[i]>0)
	{
	  fprintf(summfile,"     %d.",totalnum);
	  
	  if(totalnum<10)
	    {
	      fprintf(summfile,"   ");
	    }
	  else if(totalnum<100)
	    {
	      fprintf(summfile,"  ");
	    }
	  else if(totalnum<1000)
	    {
	      fprintf(summfile," ");
	    }


	  sprintf(tempa,"%s",ParseErrType(i));
	  cutpoint = 0;
	  if(strlen(tempa)>42)
	    {
	      
	      for(j=42;j>=0;j--)
		{
		  if(tempa[j]==' ')
		    {
		      tempa[j] = '\0';
		      cutpoint = j;
		      break;
		    }
		}
	    }

	  fprintf(summfile,"%s",tempa);
	  



	  for(j=strlen(tempa);j<44;j++)
	    {
	      fprintf(summfile," ");
	    }

	  sprintf(tempa,"%8d",ChecksOn[i]);
	  fprintf(summfile,"%s",tempa);

	  for(j=strlen(tempa);j<11;j++)
	    {
	      fprintf(summfile," ");
	    }

	  fprintf(summfile,"%10d\n",CountsFound[i]);

	  if(cutpoint>0)
	    {
	      fprintf(summfile,"          ");
	      sprintf(tempa,"%s",ParseErrType(i));
	      for(j=cutpoint+1;j<(int)strlen(tempa);j++)
		{
		  fprintf(summfile,"%c",tempa[j]);
		}
	      fprintf(summfile,"\n");
	    }
	  totalnum = totalnum + 1;
	}
    }
}



char * SetThisClassLevel(int returnearly, int useextract)
{
  XmString t;
  char tempjunk2 [1000],reallabel[1000];
  char test1[100],test2[100],test3[100];
  int level,vartouse;
  static char tempjunk[200];  
  extern int ClassLevel;
  extern int GetClassLevelStrings(int testclass,char retval1[],char retval2[],char retval3[]);

  if(useextract==1)
    {
      vartouse = ClassLevel;
    }
  else
    {
      vartouse = ThisClassLevel;
    }
  
 

  if(vartouse==-100)
  {
    sprintf(tempjunk,"None Found");
    sprintf(tempjunk2,"No Classification Data Found");
	level = 5;
  }
  else
  {
    level = GetClassLevelStrings(vartouse,test1,test2,test3);
    sprintf(tempjunk,"%s",test3);
    sprintf(tempjunk2,"Classification Level %s(%s) = %s",test1,test2,test3);
  }

  if(returnearly==1)
    {
      return tempjunk;
    }


  if(level==0)
    {
      
      XtVaSetValues(toolbar[TOOLBAR_CLASS],				
		    XmNarmColor,          mycolors[DRAW_COLOR_LTGREEN],
		    XmNbackground,        mycolors[DRAW_COLOR_LTGREEN],
		    NULL);
    }
  else if(level==1)
    {
      
      XtVaSetValues(toolbar[TOOLBAR_CLASS],				
		    XmNarmColor,          mycolors[DRAW_COLOR_PURPLE],
		    XmNbackground,        mycolors[DRAW_COLOR_PURPLE],
		    NULL);
    }
  else if(level==2)
    {
      
      XtVaSetValues(toolbar[TOOLBAR_CLASS],				
		    XmNarmColor,          mycolors[DRAW_COLOR_BLUE],
		    XmNbackground,        mycolors[DRAW_COLOR_BLUE],
		    NULL);
    }
  else if(level==3)
    {
      
      XtVaSetValues(toolbar[TOOLBAR_CLASS],				
		    XmNarmColor,          mycolors[DRAW_COLOR_RED],
		    XmNbackground,        mycolors[DRAW_COLOR_RED],
		    NULL);
    }
  else if(level==4)
    {
      
      XtVaSetValues(toolbar[TOOLBAR_CLASS],				
		    XmNarmColor,          mycolors[DRAW_COLOR_ORANGE],
		    XmNbackground,        mycolors[DRAW_COLOR_ORANGE],
		    NULL);
    }
  if(level==5)
    {
      
      XtVaSetValues(toolbar[TOOLBAR_CLASS],				
		    XmNarmColor,      mybackground,
		    XmNbackground,    mybackground,
		    NULL);
    }



  
  sprintf(reallabel,"  Classification:  \n%s",tempjunk);
  t = XmStringCreateLtoR (reallabel,XmSTRING_DEFAULT_CHARSET);
  
  XtVaSetValues(toolbar[TOOLBAR_CLASS], XmNlabelString,t,NULL);
  XcgLiteClueAddWidget(ToolTipMaster, toolbar[TOOLBAR_CLASS], tempjunk2, 0, 0);
  
  return "error!";
}




unsigned char GetGridShade(double x0,double y0,double z0,double x1,double y1,double z1,double x2,double y2,double z2, double L1, double L2, double L3, int counter)
{
  unsigned char color;
  int numverts = 3;
  double a,b,A,B,C,length,ShadedIp=1.0,ShadedKd=0.95,x10,y10,z10,x20,y20,z20;
  extern int PlaneEquation(double *A,double *B,double *C,double *D,double *x,double *y,double *z,int numverts);


  if(ZoomVertExag!=1.0)
  {
    z0 = z0 * ZoomVertExag;
    z1 = z1 * ZoomVertExag;
    z2 = z2 * ZoomVertExag;
  }


  
  x10 = x1 - x0;
  y10 = y1 - y0;
  z10 = z1 - z0;

  x20 = x2 - x0;
  y20 = y2 - y0;
  z20 = z2 - z0;

  A = (y10 * z20) - (z10 * y20);
  B = (z10 * x20) - (x10 * z20);
  C = (x10 * y20) - (y10 * x20);


  
  length = sqrt(A * A + B * B + C * C);

  A = A / length;
  B = B / length;
  C = C / length;

  
  a = A*L1 - B*L2 + C*L3;
  b = ShadedIp * ShadedKd * a * 63.0;
  if(b < 0)
  {
    b = 0 - b;
  }
  if(b > 63.0)
  {
    b = 63.0;
  }
  color = (unsigned char) b;
  color += 100;
  if((color < 100) || (color > 163))
  { 
    printf("Computed unexpected color %d length was %lf numverts %d\n",color,length,numverts);
    color = 101;
  }   
   return color;
}


int CalculateBytesPerGridValue(int flag)
{

  if((flag==1)||(flag==7))
  {
    return 1;  
  }
  else if(flag==2)
  {
    return 2;  
  }
  else if(flag==3)
  {
    return 2;  
  }
  else if(flag==4)
  {
    return 4;  
  }
  else if(flag==5)
  {
    return 4;  
  }
  else if(flag==6)
  {
    return 4;  
  }
  else if(flag==9)
  {
    return 8;  
  }

  printf("Internal error: CBPGV value %d\n",flag);
  XBell(mydisplay,50);
  return 8;

}








double GetGridValue(FILE *gridfile,long int gridstart,int gridtypeflag,int xindex,int yindex,int xnum, int ynum)
{
  int seekmult;
  double Zgrid;

  unsigned char tempchar;
  char tempchar2;
  short int tempshort;
  unsigned short int tempUshort;
  int tempint;
  unsigned int tempUint;
  float tempfloat;


  seekmult = CalculateBytesPerGridValue(gridtypeflag);


  fseek(gridfile,gridstart + (yindex*xnum + xindex)*seekmult,SEEK_SET);  




  if(gridtypeflag==1)
  {
    fread(&tempchar, 1,1,gridfile);
	Zgrid = (double)tempchar;
  }
  else if(gridtypeflag==7)
  {
    fread(&tempchar2, 1,1,gridfile);
	Zgrid = (double)tempchar2;
  }
  else if(gridtypeflag==2)
  {
    SEEIT_fread_short(&tempshort,gridfile);
	Zgrid = (double)tempshort;
  }
  else if(gridtypeflag==3)
  {
    SEEIT_fread_ushort(&tempUshort,gridfile);
	Zgrid = (double)tempUshort;
  }

  else if(gridtypeflag==4)
  {
    SEEIT_fread_int(&tempint,gridfile);
	Zgrid = (double)tempint;
  }
  else if(gridtypeflag==5)
  {
    SEEIT_fread_uint(&tempUint,gridfile);
	Zgrid = (double)tempUint;
  }
  else if(gridtypeflag==6)
  {
    SEEIT_fread_float(&tempfloat,gridfile);
	Zgrid = (double)tempfloat;
  }

  else if(gridtypeflag==9)
  {
    SEEIT_fread_double(&Zgrid,gridfile);
  }
  else
  {
    printf("Bad GGV:DS %d!\n",gridtypeflag);
	return 1;
  }

  return Zgrid;
}





unsigned long SetShadingColor(FILE *gridfile,long int gridstart,int gridtypeflag,int xindex,int yindex,int modifier,
					 int xnum,int ynum,double xspace,double yspace,double SA,double SB,double SC,int counter,
					 unsigned long *color2)
{
  double Xgrid[4];
  double Ygrid[4];
  double remainder;
  int mybin,seekmult;
  unsigned long color;

  unsigned char tempchar;
  char tempchar2;
  short int tempshort;
  unsigned short int tempUshort;
  int tempint;
  unsigned int tempUint;
  float tempfloat;

  


  Xgrid[0] = 10;
  Xgrid[1] = 10;
  Xgrid[2] = 10 + xspace*modifier;  
  Xgrid[3] = Xgrid[2];

  Ygrid[0] = 10;
  Ygrid[1] = 10 + yspace*modifier;  
  Ygrid[2] = 10 + yspace*modifier;
  Ygrid[3] = Ygrid[0];


  seekmult = CalculateBytesPerGridValue(gridtypeflag);


  fseek(gridfile,gridstart + (yindex*xnum + xindex)*seekmult,SEEK_SET);  




  if(gridtypeflag==1)
  {
    fread(&tempchar, 1,1,gridfile);
	Zgrid[0] = (double)tempchar;

	if((DrawContourLines==1)||(*color2==1))
	{
      fread(&tempchar, 1,1,gridfile);
	  Zgrid[3] = (double)tempchar;
	}
  }
  else if(gridtypeflag==7)
  {
    fread(&tempchar2, 1,1,gridfile);
	Zgrid[0] = (double)tempchar2;

	if((DrawContourLines==1)||(*color2==1))
	{
      fread(&tempchar2, 1,1,gridfile);
	  Zgrid[3] = (double)tempchar2;
	}
  }
  else if(gridtypeflag==2)
  {
    SEEIT_fread_short(&tempshort,gridfile);
	Zgrid[0] = (double)tempshort;
	if((DrawContourLines==1)||(*color2==1))
	{
      SEEIT_fread_short(&tempshort,gridfile);
	  Zgrid[3] = (double)tempshort;
	}
  }
  else if(gridtypeflag==3)
  {
    SEEIT_fread_ushort(&tempUshort,gridfile);
	Zgrid[0] = (double)tempUshort;
	if((DrawContourLines==1)||(*color2==1))
	{
      SEEIT_fread_ushort(&tempUshort,gridfile);
	  Zgrid[3] = (double)tempUshort;
	}
  }

  else if(gridtypeflag==4)
  {
    SEEIT_fread_int(&tempint,gridfile);
	Zgrid[0] = (double)tempint;
	if((DrawContourLines==1)||(*color2==1))
	{
      SEEIT_fread_int(&tempint,gridfile);
	  Zgrid[3] = (double)tempint;
	}
  }
  else if(gridtypeflag==5)
  {
    SEEIT_fread_uint(&tempUint,gridfile);
	Zgrid[0] = (double)tempUint;
	if((DrawContourLines==1)||(*color2==1))
	{
      SEEIT_fread_uint(&tempUint,gridfile);
	  Zgrid[3] = (double)tempUint;
	}
  }

  else if(gridtypeflag==6)
  {
    SEEIT_fread_float(&tempfloat,gridfile);
	Zgrid[0] = (double)tempfloat;
	if((DrawContourLines==1)||(*color2==1))
	{
      SEEIT_fread_float(&tempfloat,gridfile);
	  Zgrid[3] = (double)tempfloat;
	}
  }

  else if(gridtypeflag==9)
  {
    SEEIT_fread_double(&Zgrid[0],gridfile);
	if((DrawContourLines==1)||(*color2==1))
	{
      SEEIT_fread_double(&Zgrid[3],gridfile);
	}
  }

  else
  {
    printf("Bad DS %d!\n",gridtypeflag);
	return 1;
  }


  if((DrawColorFill==1)||(GetTempFill==1))
  {
    
	  
	if(Zgrid[0]<0)
	{
      
      Zgrid[0] = Zgrid[0] - ContourInterval;
	}

	mybin = (int)(Zgrid[0]/ContourInterval);
	remainder = Zgrid[0]/ContourInterval - mybin;


    mybin = mybin%NUMBER_OF_BINS;
	if(mybin<0)
	{
      mybin = NUMBER_OF_BINS + mybin;
	}


	if(remainder<0)
	{
      remainder = remainder + 1;
	}





	if(GetTempFill==1)
	{
      GetTempFill = mybin + 10;
	}

	if(NO_FLATTEN_CONTOUR==0)
	{
      remainder = 0;
	}

      switch(mybin)
	  { 	
	    case 0: 
	     color = ColorBin1[0+(int)(remainder*SHADES_PER_BIN)]; 
        break;
	    case 1: 
	     color = ColorBin2[0+(int)(remainder*SHADES_PER_BIN)]; 
        break;
	    case 2: 
	     color = ColorBin3[0+(int)(remainder*SHADES_PER_BIN)]; 
        break;
	    case 3: 
	     color = ColorBin4[0+(int)(remainder*SHADES_PER_BIN)]; 
        break;
	    case 4: 
	     color = ColorBin5[0+(int)(remainder*SHADES_PER_BIN)]; 
       break;
	  }

	  if(DrawColorFill==1)
	  {
        XSetForeground(mydisplay,mygc,color);
	  }

	  if(DrawContourLines==0)
	  {
		return color;
	  }

  }


  if((yindex+modifier)<(ynum-2))
  {
    fseek(gridfile,gridstart + ((yindex + modifier)*xnum + xindex)*seekmult,SEEK_SET);  
  }
  else
  {
    fseek(gridfile,gridstart + ((yindex + 1)*xnum + xindex)*seekmult,SEEK_SET);  
  }





  if(gridtypeflag==1)
  {
    fread(&tempchar, 1,1,gridfile);
	Zgrid[1] = (double)tempchar;
    fread(&tempchar, 1,1,gridfile);
	Zgrid[2] = (double)tempchar;  
  }
  else if(gridtypeflag==7)
  {
    fread(&tempchar2, 1,1,gridfile);
	Zgrid[1] = (double)tempchar2;
    fread(&tempchar2, 1,1,gridfile);
	Zgrid[2] = (double)tempchar2;  
  }
  else if(gridtypeflag==2)
  {
    SEEIT_fread_short(&tempshort,gridfile);
	Zgrid[1] = (double)tempshort;
    SEEIT_fread_short(&tempshort,gridfile);
	Zgrid[2] = (double)tempshort;
  }
  else if(gridtypeflag==3)
  {
    SEEIT_fread_ushort(&tempUshort,gridfile);
	Zgrid[1] = (double)tempUshort;
    SEEIT_fread_ushort(&tempUshort,gridfile);
	Zgrid[2] = (double)tempUshort;
  }
  else if(gridtypeflag==4)
  {
    SEEIT_fread_int(&tempint,gridfile);
	Zgrid[1] = (double)tempint;
    SEEIT_fread_int(&tempint,gridfile);
	Zgrid[2] = (double)tempint;
  }
  else if(gridtypeflag==5)
  {
    SEEIT_fread_uint(&tempUint,gridfile);
	Zgrid[1] = (double)tempUint;
    SEEIT_fread_uint(&tempUint,gridfile);
	Zgrid[2] = (double)tempUint;
  }
  else if(gridtypeflag==6)
  {
    SEEIT_fread_float(&tempfloat,gridfile);
	Zgrid[1] = (double)tempfloat;
    SEEIT_fread_float(&tempfloat,gridfile);
	Zgrid[2] = (double)tempfloat;
  }
  else if(gridtypeflag==9)
  {
    SEEIT_fread_double(&Zgrid[1],gridfile);
    SEEIT_fread_double(&Zgrid[2],gridfile);
  }
  else
  {
    printf("Bad DS %d!\n",gridtypeflag);
	return 1;  
  }



  if(DrawColorFill==1)
  {
    return color; 
  }

  color = GetGridShade(Xgrid[0],Ygrid[0],Zgrid[0],Xgrid[1],Ygrid[1],Zgrid[1],Xgrid[2],Ygrid[2],Zgrid[2],SA,SB,SC,counter);

  if(*color2==1)
  {
    *color2 = GetGridShade(Xgrid[0],Ygrid[0],Zgrid[0],Xgrid[2],Ygrid[2],Zgrid[2],Xgrid[3],Ygrid[3],Zgrid[3],SA,SB,SC,counter);
  }

  SetShadedColor(color);

  return color;

}



int IsActive(int lindex, int layer)
{
  if(LODindex[CrsWlk[lindex].LODband-1].active==1)
  {
    if((CrsWlk[lindex].LODband-1)==layer)
	{
      return 1;
	}
  }
  return 0;
}


void MAPdrawContourLine(int ContourMultiple, double X, double Y, double X2, double Y2, int lindex)
{

  

  if((BOLD_CONTOUR==1)&&(ContourMultiple%5==0))
  {
    OVERRIDE_THICKNESS = 5;
  }
  else
  {
    OVERRIDE_THICKNESS = 2;
  }

  XSetForeground(mydisplay,mygc,mycolors[TheContourColor]);

  SPECIAL_COLOR = -1;
  MAPdrawline(0,X,Y,X2,Y2,TheContourColor,lindex);

  XSetLineAttributes(mydisplay,mygc,0,LineSolid,CapButt,JoinMiter);
  XSetLineAttributes(mydisplay,mybitgc,0,LineSolid,CapButt,JoinMiter);	
  OVERRIDE_THICKNESS = -1;
}


void ContourLine(int x,int y,int x1,int y1, int thickness, int rendering_priority)
{

  if(thickness==5)
  {
    if(BOLD_CONTOUR==0)
	{
      thickness = 2;
	}
  }

  XSetLineAttributes(mydisplay,mygc,thickness,LineSolid,CapButt,JoinMiter);
  XSetLineAttributes(mydisplay,mybitgc,thickness,LineSolid,CapButt,JoinMiter);

  if(DRAWING_TOPLEVEL==1)
  {
    if(GLOBAL_draw==1)
	{
      XDrawLine(mydisplay,pixmap, mygc,   x,y,x1,y1);
	}
    else
	{
      XDrawLine(mydisplay,pixmap2, mygc,   x,y,x1,y1);
	}
  }
  else
  {
    XDrawLine(mydisplay,DRAWING_PIXMAPS[rendering_priority], mygc,   x,y,x1,y1);
    XDrawLine(mydisplay,DRAWING_CLIPMAPS[rendering_priority],mybitgc,x,y,x1,y1);
    LODS_USED[rendering_priority] = 1;
  }



  XSetLineAttributes(mydisplay,mygc,0,LineSolid,CapButt,JoinMiter);
  XSetLineAttributes(mydisplay,mybitgc,0,LineSolid,CapButt,JoinMiter);
}





void DrawShadedGrids(int layer)
{
  FILE *gridfile,*headfile;
  double Djunk;
  long int *fileposns;
  long int tempfileposn;
  int i,j,xnum,ynum,Ijunk,lindex,isactive,total=0;
  int numfiles,size,num_found=0;
  char filename[1000];


  sprintf(filename,"%sgridinfo.txt",indirectory);
  headfile = fopen(filename,"r");
  if(headfile==NULL)
    {
      printf("Couldnt open %s for read.\n",filename); 
	  XBell(mydisplay,50);
      return;
    }
  fscanf(headfile,"%d",&Ijunk); 
  while(!feof(headfile))
  {
    if(Ijunk>total)
	{
      total = Ijunk;
	}
    fscanf(headfile,"%d",&Ijunk); 
  }
  fclose(headfile);


  if(total>=1)
  {
    fileposns = (long int *)malloc( sizeof(long int) * (total+5) );
  }
  else
  {
    fileposns = NULL;
  }

  sprintf(filename,"%smultiinfo.txt",indirectory);
  headfile = fopen(filename,"r");
  if(headfile==NULL)
    {
      printf("Couldnt open %s for read.\n",filename); 
	  XBell(mydisplay,50);
      return;
    }
  
  fscanf(headfile,"%d",&Ijunk);    
  fscanf(headfile,"%d",&Ijunk);    
  fscanf(headfile,"%d",&Ijunk);    
  fscanf(headfile,"%d",&numfiles); 
  fclose(headfile);


  for(i=0;i<numfiles;i++)
  {


    num_found = 0;

    if(i==0)
	{
      sprintf(filename,"%sgrid.bin",indirectory);
	}
	else
	{
      sprintf(filename,"%sgrid%d.bin",indirectory,i+1);
	}

    gridfile = fopen(filename,"rb");
    if(gridfile==NULL)
	{
	 printf("Error: Could not open %s\n",filename);
	 return;
	} 



    fileposns[num_found] = 0;

    SEEIT_fread_int(&lindex,gridfile);
    while(!feof(gridfile))
	{ 
	  isactive = IsActive(lindex,layer-1);

	  if(isactive==1)
	  {
        if(isactive==1)
		{
	      fileposns[num_found] = ftell(gridfile) - SzI;
		}
	    num_found = num_found + 1;
	  }


      SEEIT_fread_int(&Ijunk,gridfile);
      SEEIT_fread_double(&Djunk,gridfile);
      SEEIT_fread_double(&Djunk,gridfile);
      SEEIT_fread_double(&Djunk,gridfile);
      SEEIT_fread_double(&Djunk,gridfile);
      SEEIT_fread_int(&Ijunk,gridfile);
      SEEIT_fread_int(&xnum,gridfile);
      SEEIT_fread_int(&ynum,gridfile);
      SEEIT_fread_int(&size,gridfile);

      tempfileposn = ftell(gridfile);

	  fseek(gridfile,tempfileposn+xnum*ynum*CalculateBytesPerGridValue(size),SEEK_SET);

      SEEIT_fread_int(&lindex,gridfile);
	}

    fclose(gridfile);

    for(j=0;j<num_found;j++)
	{
	  DrawShadedGrid(filename,fileposns[j]);
	}
  }

  if(fileposns!=NULL)
  {
    free(fileposns);
  }

}






int IsTrexToplevel(int layer_num)
{
  

  if(ATTRTYPE_TREX()==0)
  {
    return 1;
  }


 if(
	 (strstr(LODindex[layer_num].title,"TREx DEM Raw"))            ||
	 (strstr(LODindex[layer_num].title,"Reference DEM:"))          ||
	 (strstr(LODindex[layer_num].title,"Source Data Mask"))        ||
	 (strstr(LODindex[layer_num].title,"Edit Data Mask"))          ||
	 (strstr(LODindex[layer_num].title,"Height Error Map"))        ||
	 (strstr(LODindex[layer_num].title,"Reliability Mask"))        ||	 
	 (strstr(LODindex[layer_num].title,"TREx DEM Raw"))            ||
	 (strstr(LODindex[layer_num].title,"DTED Level 1"))            ||
	 (strstr(LODindex[layer_num].title,"SRTM Level 2"))            ||
	 (strstr(LODindex[layer_num].title,"ASTER GDEM v2"))           ||
	 (strstr(LODindex[layer_num].title,"Active Earthscape"))       ||
	 (strstr(LODindex[layer_num].title,"HRTE3 Bare Earth"))        ||
	 (strstr(LODindex[layer_num].title,"HRTE3 Reflective Surface"))||
	 (strstr(LODindex[layer_num].title,"CDEM"))                    ||
	 (strstr(LODindex[layer_num].title,"GMTED mn300"))             ||
	 (strstr(LODindex[layer_num].title,"GMTED mn75"))
   )
 {
   return 0;
 }

 if( (strstr(LODindex[layer_num].title,"TDF / ")) && (strstr(LODindex[layer_num].title,"Difference")) )
 {
   return 0;
 }

 return 1;

}



void DrawNonShadedGrids(int layer, int needextrapixmap)
{
  FILE *gridfile,*headfile;
  double Djunk;
  long int *fileposns;
  long int tempfileposn;
  int i,xnum,ynum,Ijunk,lindex,isactive,total=0,firstfound=1,offer=0;
  int numfiles,size,num_found=0,gridnum;
  char filename[1000];
  extern int PROCESS_GRID_VALUES;
  extern Pixmap global_mask_bitmap;








  sprintf(filename,"%sgridinfo.txt",indirectory);
  headfile = fopen(filename,"r");
  if(headfile==NULL)
    {
      printf("Couldnt open %s for read.\n",filename); 
	  XBell(mydisplay,50);
      return;
    }


  if((IsTrexToplevel(layer-1))&&(needextrapixmap==1))
  { 
    

    if(LODindex[layer-1].active==0)
	{ 
      LODindex[layer-1].active = 1;
      offer = 1;
	} 
  } 




  fscanf(headfile,"%d",&Ijunk); 
  while(!feof(headfile))
  {
    if(Ijunk>total)
	{
      total = Ijunk;
	}
    fscanf(headfile,"%d",&Ijunk); 
  }
  fclose(headfile);


  if(total>=1)
  {
    fileposns = (long int *)malloc( sizeof(long int) * (total+5) );
  }
  else
  {
    fileposns = NULL;
  }

  sprintf(filename,"%smultiinfo.txt",indirectory);
  headfile = fopen(filename,"r");
  if(headfile==NULL)
    {
      printf("Couldnt open %s for read.\n",filename); 
	  XBell(mydisplay,50);
      return;
    }
  
  fscanf(headfile,"%d",&Ijunk);    
  fscanf(headfile,"%d",&Ijunk);    
  fscanf(headfile,"%d",&Ijunk);    
  fscanf(headfile,"%d",&numfiles); 
  fclose(headfile);


  for(i=0;i<numfiles;i++)
  {
    num_found = 0;

    if(i==0)
	{
	  gridnum = 1;
      sprintf(filename,"%sgrid.bin",indirectory);
	}
	else
	{
	  gridnum = i + 1;
      sprintf(filename,"%sgrid%d.bin",indirectory,i+1);
	}

    gridfile = fopen(filename,"rb");
    if(gridfile==NULL)
	{
	 printf("Error: Could not open %s\n",filename);

     if(offer==1)
	 { 
       LODindex[layer-1].active = 0;
	 } 
	 return;
	} 



    fileposns[num_found] = 0;

    SEEIT_fread_int(&lindex,gridfile);

    while(!feof(gridfile))
	{ 

	  isactive = IsActive(lindex,layer-1);



	  if(isactive==1)
	  {
        if(isactive==1)
		{
	      fileposns[num_found] = ftell(gridfile) - SzI;

    
		  PROCESS_GRID_VALUES = 1;







	      PrepareForGridMasking(gridnum,fileposns[num_found],layer,firstfound,0);  
          firstfound = 0; 


		}
	    num_found = num_found + 1;
	  }


      SEEIT_fread_int(&Ijunk,gridfile);
      SEEIT_fread_double(&Djunk,gridfile);
      SEEIT_fread_double(&Djunk,gridfile);
      SEEIT_fread_double(&Djunk,gridfile);
      SEEIT_fread_double(&Djunk,gridfile);
      SEEIT_fread_int(&Ijunk,gridfile);
      SEEIT_fread_int(&xnum,gridfile);
      SEEIT_fread_int(&ynum,gridfile);
      SEEIT_fread_int(&size,gridfile);

	  size = CalculateBytesPerGridValue(size);

      tempfileposn = ftell(gridfile);

	  fseek(gridfile,tempfileposn+xnum*ynum*size,SEEK_SET);

      SEEIT_fread_int(&lindex,gridfile);
	}

    fclose(gridfile);
  }

  if(fileposns!=NULL)
  {
    free(fileposns);
  }

  PROCESS_GRID_VALUES = 0;

  

  XSetClipMask(mydisplay,   mygc,global_mask_bitmap);
  XSetClipMask(mydisplay,   mybitgc,global_mask_bitmap);


  if(offer==1)
  { 
    LODindex[layer-1].active = 0;
  } 


  
}












void DrawGridTopLevel(int layer)
{

  ABORT_ZOOM = 0;
  DRAWING_TOPLEVEL = 1;
  DrawShadedGrids(layer);
  DRAWING_TOPLEVEL = 0;
  FlushMainScreen(1);
}



void DrawShadedGrid(char *filename,long int fileposn)
{
  int save1;

  if(DrawColorFill==0)
  {
	save1 = OVERRIDING_CONTOUR;
	OVERRIDING_CONTOUR = 0;

    DrawRealShadedGrid(filename,fileposn);

	OVERRIDING_CONTOUR = save1;
    return;
  }

  if(OVERRIDING_CONTOUR==0)
  {
    DrawRealShadedGrid(filename,fileposn);
    return;
  }


  

  DrawColorFill      = 0;
  OVERRIDING_CONTOUR = 0;
  DrawRealShadedGrid(filename,fileposn);

  DrawColorFill      = 1;
  OVERRIDING_CONTOUR = 1;
  DrawRealShadedGrid(filename,fileposn);
}



void DrawOutlineEdge(int less_great, double tgtval, int color, int lindex, 
					 double x0, double y0, double x1, double y1, double x2, double y2, double x3, double y3)
{
  double z1,z2,z3,z4;
  extern int SPECIAL_OUTLINE_COLOR;

  SPECIAL_OUTLINE_COLOR = 1;

  z1 = Zgrid[0];
  z2 = Zgrid[1];
  z3 = Zgrid[2];
  z4 = Zgrid[3];
 


  


  if(less_great==0)
  {
    if((z1>=tgtval)&&(z2>=tgtval)&&(z3<tgtval)&&(z4<tgtval))
	{
      MAPdrawline(-1,x0,y0,x1,y1,color,lindex);
	}
    if((z2>=tgtval)&&(z3>=tgtval)&&(z4<tgtval)&&(z1<tgtval))
	{
      MAPdrawline(-1,x1,y1,x2,y2,color,lindex);
	}
    if((z3>=tgtval)&&(z4>=tgtval)&&(z1<tgtval)&&(z2<tgtval))
	{
      MAPdrawline(-1,x2,y2,x3,y3,color,lindex);
	}
    if((z4>=tgtval)&&(z1>=tgtval)&&(z2<tgtval)&&(z3<tgtval))
	{
      MAPdrawline(-1,x3,y3,x0,y0,color,lindex);
	}

    if((z1>=tgtval)&&(z2>=tgtval)&&(z3>=tgtval)&&(z4<tgtval))
	{
      MAPdrawline(-1,x0,y0,x2,y2,color,lindex);
	}
    if((z1>=tgtval)&&(z3>=tgtval)&&(z4>=tgtval)&&(z2<tgtval))
	{
      MAPdrawline(-1,x0,y0,x2,y2,color,lindex);
	}
    if((z1>=tgtval)&&(z2>=tgtval)&&(z4>=tgtval)&&(z3<tgtval))
	{
      MAPdrawline(-1,x1,y1,x3,y3,color,lindex);
	}
    if((z2>=tgtval)&&(z3>=tgtval)&&(z4>=tgtval)&&(z1<tgtval))
	{
      MAPdrawline(-1,x1,y1,x3,y3,color,lindex);
	}
  }
  else if(less_great==1)
  {
    if((z1!=tgtval)&&(z2!=tgtval)&&(z3==tgtval)&&(z4==tgtval))
	{
      MAPdrawline(-1,x0,y0,x1,y1,color,lindex);
	}
    if((z2!=tgtval)&&(z3!=tgtval)&&(z4==tgtval)&&(z1==tgtval))
	{
      MAPdrawline(-1,x1,y1,x2,y2,color,lindex);
	}
    if((z3!=tgtval)&&(z4!=tgtval)&&(z1==tgtval)&&(z2==tgtval))
	{
      MAPdrawline(-1,x2,y2,x3,y3,color,lindex);
	}
    if((z4!=tgtval)&&(z1!=tgtval)&&(z2==tgtval)&&(z3==tgtval))
	{
      MAPdrawline(-1,x3,y3,x0,y0,color,lindex);
	}

    if((z1!=tgtval)&&(z2!=tgtval)&&(z3!=tgtval)&&(z4==tgtval))
	{
      MAPdrawline(-1,x0,y0,x2,y2,color,lindex);
	}
    if((z1!=tgtval)&&(z3!=tgtval)&&(z4!=tgtval)&&(z2==tgtval))
	{
      MAPdrawline(-1,x0,y0,x2,y2,color,lindex);
	}
    if((z1!=tgtval)&&(z2!=tgtval)&&(z4!=tgtval)&&(z3==tgtval))
	{
      MAPdrawline(-1,x1,y1,x3,y3,color,lindex);
	}
    if((z2!=tgtval)&&(z3!=tgtval)&&(z4!=tgtval)&&(z1==tgtval))
	{
      MAPdrawline(-1,x1,y1,x3,y3,color,lindex);
	}
  }
  else if(less_great==2)
  {
    if((z1<=tgtval)&&(z2<=tgtval)&&(z3>tgtval)&&(z4>tgtval))
	{
      MAPdrawline(-1,x0,y0,x1,y1,color,lindex);
	}
    if((z2<=tgtval)&&(z3<=tgtval)&&(z4>tgtval)&&(z1>tgtval))
	{
      MAPdrawline(-1,x1,y1,x2,y2,color,lindex);
	}
    if((z3<=tgtval)&&(z4<=tgtval)&&(z1>tgtval)&&(z2>tgtval))
	{
      MAPdrawline(-1,x2,y2,x3,y3,color,lindex);
	}
    if((z4<=tgtval)&&(z1<=tgtval)&&(z2>tgtval)&&(z3>tgtval))
	{
      MAPdrawline(-1,x3,y3,x0,y0,color,lindex);
	}

    if((z1<=tgtval)&&(z2<=tgtval)&&(z3<=tgtval)&&(z4>tgtval))
	{
      MAPdrawline(-1,x0,y0,x2,y2,color,lindex);
	}
    if((z1<=tgtval)&&(z3<=tgtval)&&(z4<=tgtval)&&(z2>tgtval))
	{
      MAPdrawline(-1,x0,y0,x2,y2,color,lindex);
	}
    if((z1<=tgtval)&&(z2<=tgtval)&&(z4<=tgtval)&&(z3>tgtval))
	{
      MAPdrawline(-1,x1,y1,x3,y3,color,lindex);
	}
    if((z2<=tgtval)&&(z3<=tgtval)&&(z4<=tgtval)&&(z1>tgtval))
	{
      MAPdrawline(-1,x1,y1,x3,y3,color,lindex);
	}  
  }

  SPECIAL_OUTLINE_COLOR = 0;

}


double mymin(double a,double b)
{
  if(a<b)
  {
    return a;
  }
  return b;
}


void DrawRealShadedGrid(char *filename,long int fileposn)
{
  FILE *gridfile;
  double xspace,yspace,llx,lly,urx,ury,xmod,ymod,xindex,yindex,x_pix,SA,SB,SC,tgtval,pixmod,thisval;
  double Xpts[4],Ypts[4],tempa,tempb;
  long int gridstart;
  int x,y,xx,yy,pixelx,pixely,lindex,sindex,order,xnum,ynum,datasize,rendering_priority,
	  xmin,ymin,xmax,ymax,modifier,thickness,counter=0,small_thickness=2,big_thickness=5,
	  doing_discrete,draw_outline,draw_style,nonshadecolor,less_great=0,junkcolor,
	  STAR_LIMIT=20,GRID_VALUE_LIMIT=75,GRID_LABEL_LIMIT=210,
	  SaveDrawColorFill,SaveDrawContourLines;
  unsigned long color,color2;
  unsigned char MyMask[1000][800];
  extern Pixmap global_mask_bitmap;
  extern int PROCESS_GRID_VALUES,GRID_LABELS_DRAWN;
  extern void SetUpSunParameters(int AzimuthToSun, double SunElevationAngle, double *L1,double *L2, double *L3);
  extern void DrawContourLinesFromPoly(int vtxcnt, double *X, double *Y, double *Z, int lindex);








  color2 = 0;


  gridfile = fopen(filename,"rb");
  if(gridfile==NULL)
  {
    XBell(mydisplay,50);
	printf("Error: Could not open %s\n",filename);
	return;
  }

  memset(MyMask,8,1000*800);

  CacheGrid(gridfile,-1);
  rewind(gridfile);


  AllocateExtraColors();


  if(4>MAXVERTSFOUND)
    {
      ReSetVertexList(4);
      MAXVERTSFOUND = 4 + 1000;
    }


  SetUpSunParameters(ZoomSunAzimuth, ZoomSunAngle, &SA, &SB, &SC);


  

  fseek(gridfile,fileposn,SEEK_SET);


  SEEIT_fread_int(&lindex,gridfile);
  SEEIT_fread_int(&sindex,gridfile);
  SEEIT_fread_double(&xspace,gridfile);
  SEEIT_fread_double(&yspace,gridfile);
  SEEIT_fread_double(&llx,gridfile);
  SEEIT_fread_double(&lly,gridfile);
  SEEIT_fread_int(&order,gridfile); 
  SEEIT_fread_int(&xnum,gridfile);
  SEEIT_fread_int(&ynum,gridfile);
  SEEIT_fread_int(&datasize, gridfile); 



  rendering_priority = LODindex_DYN[LODindex[CrsWlk[lindex].LODband-1].other_index].draw_priority - 1;

  doing_discrete     = LODindex_DYN[LODindex[CrsWlk[lindex].LODband-1].other_index].do_discrete;

  draw_outline       = LODindex_DYN[LODindex[CrsWlk[lindex].LODband-1].other_index].do_outline;

  less_great         = LODindex_DYN[LODindex[CrsWlk[lindex].LODband-1].other_index].equal_type;

  tgtval             = LODindex_DYN[LODindex[CrsWlk[lindex].LODband-1].other_index].discrete_ignore_value;

  draw_style         = LODindex_DYN[LODindex[CrsWlk[lindex].LODband-1].other_index].draw_style;

  
  nonshadecolor      = LODindex[LODindex_DYN[LODindex[CrsWlk[lindex].LODband-1].other_index].other_index].temp_color;




  

 
  

  if(LODindex[CrsWlk[lindex].LODband-1].active==0)
  {
	fclose(gridfile);
    return;
  }


  LODS_USED[rendering_priority] = 1;



  gridstart = ftell(gridfile);








  
  urx = llx + xspace*(xnum-1);
  ury = lly + yspace*(ynum-1);

  UnTranslateCoords(&llx,&lly);
  UnTranslateCoords(&urx,&ury);



  




  if(Ctype()==1)
  {
    xspace = xspace * 100000;
    yspace = yspace * 100000;
  }




  pixelx = (int)llx_zoom;
  pixely = (int)lly_zoom;


  


  

  x_pix = IRegionSize/xunits;


  pixmod = mymin(xspace/x_pix,yspace/x_pix);

  


  
 


  if((draw_style==1)&&(pixmod<20))
  {
    

	if((x_pix*20.0>xspace)||(x_pix*20.0>yspace))
	{

      

	  color = AssignDrawingColor(-1 ,D_LAMO , lindex);

	  Xpts[0] = llx;
	  Ypts[0] = lly;

	  Xpts[1] = llx;
	  Ypts[1] = ury;

	  Xpts[2] = urx;
	  Ypts[2] = ury;

	  Xpts[3] = urx;
	  Ypts[3] = lly;

	  OVERRIDE_GRID_STYLE = 2; 
      MAPdrawpoly(4, Xpts, Ypts,color,1,1,1,lindex);
      OVERRIDE_GRID_STYLE = -1;

	  fclose(gridfile);
      return;
	}
  }




  SaveDrawColorFill = DrawColorFill;
  SaveDrawContourLines = DrawContourLines;

  if(draw_style!=0) 
  {
	
    DrawColorFill = 0;
	DrawContourLines = 0;
  }



  if((draw_style==0)&&(pixmod>STAR_LIMIT))
  {
    
    draw_style = 1;
  }



  if(pixmod>STAR_LIMIT)
  {
    
    draw_style = 1;
  }


  if((DrawColorFill>0)&&(draw_style!=0))
  {
    
    DrawColorFill = 0;
  }





  
  
  if(
	  (draw_style==1) ||
	  ( ((x_pix<xspace)&&(x_pix<yspace)) && (OVERRIDING_CONTOUR==0)  ) 
	)
  {




	

    urx_zoom = llx_zoom+(1000.0/xunits)*IRegionSize;
    ury_zoom = lly_zoom+(850.0/yunits) *IRegionSize;


	



	

	if(
		(urx<llx_zoom) ||
		(ury<lly_zoom) ||
		(llx>urx_zoom) ||
		(lly>ury_zoom)
	  )
	{
      
      fclose(gridfile);
      DrawColorFill = SaveDrawColorFill;
      DrawContourLines = SaveDrawContourLines;
	  return;
	}



	xmin = (int)((llx_zoom-llx)/xspace) - 2;
	ymin = (int)((lly_zoom-lly)/yspace) - 2;

	xmax = (int)((urx_zoom-llx)/xspace) + 2;
	ymax = (int)((ury_zoom-lly)/yspace) + 2;


	


	if(xmin<0)
	{
	  xmin = 0;
	}
	if(ymin<0)
	{
	  ymin = 0;
	}
	if(xmax>=(xnum-1))
	{
	  xmax = xnum-2;
	}
	if(ymax>=(ynum-1))
	{
	  ymax = ynum - 2;
	}

	if(draw_style==1)
	{
      
      xmax = xmax + 1;
	  ymax = ymax + 1;
	}


    if(GRID_LABELS_DRAWN<=250)
	{
      

	  GRID_LABEL_DRAW_OVERRIDE = 1;
	}


	for(x=xmin;x<=xmax;x++)
	{
      if(AbortZoom())
	  {
        break;
	  }

      for(y=ymin;y<=ymax;y++)
	  {


		if(draw_style==1)
		{
          

		  color = AssignDrawingColor(-1 ,D_LAMO , lindex);






		  thisval = GetGridValue(gridfile,gridstart,datasize,x,y,xnum,ynum);

          if(
                (doing_discrete==0) ||
				( (less_great==0) && (thisval>=tgtval)) ||
				( (less_great==1) && (thisval!=tgtval)) ||
				( (less_great==2) && (thisval<=tgtval))
               )
		  {
		    if(pixmod<GRID_VALUE_LIMIT)
			{ 
              

              MAPdrawStar(llx + x*xspace,
			          lly + y*yspace,
					  MY2DSENTINEL,
			          color,lindex,1);
			} 
		    else if(pixmod<GRID_LABEL_LIMIT)
			{ 
              

              MAPdrawStar(llx + x*xspace,
			          lly + y*yspace,
					  GetGridValue(gridfile,gridstart,datasize,x,y,xnum,ynum),
			          color,lindex,2);
			} 
		    else
			{ 
			  
              MAPdrawStar(llx + x*xspace,
			          lly + y*yspace,
					  GetGridValue(gridfile,gridstart,datasize,x,y,xnum,ynum),
			          color,lindex,3);
			} 
		  }


		  if(DrawContourLines==1)  
		  { 
			
            junkcolor = SetShadingColor(gridfile,gridstart,datasize,x,y,1,xnum,ynum,xspace,yspace,SA,SB,SC,counter,&color2);

		    Xpts[0] = llx + x*xspace;
		    Ypts[0] = lly + y*yspace;

		    Xpts[1] = llx + x*xspace;
		    Ypts[1] = lly + (y+1)*yspace;

		    Xpts[2] = llx + (x+1)*xspace;
		    Ypts[2] = lly + (y+1)*yspace;

		    Xpts[3] = llx + (x+1)*xspace;
		    Ypts[3] = lly + y*yspace;

		    SPECIAL_COLOR = TheContourColor;
            DrawContourLinesFromPoly(4,Xpts,Ypts,Zgrid,lindex);
		    SPECIAL_COLOR = -1;
		  } 



		  continue;
		}



		color2 = 1;


        color = SetShadingColor(gridfile,gridstart,datasize,x,y,1,xnum,ynum,xspace,yspace,SA,SB,SC,counter,&color2);


		

		counter = counter + 1;

		Xpts[0] = llx + x*xspace;
		Ypts[0] = lly + y*yspace;

		Xpts[1] = llx + x*xspace;
		Ypts[1] = lly + (y+1)*yspace;

		Xpts[2] = llx + (x+1)*xspace;
		Ypts[2] = lly + (y+1)*yspace;

		Xpts[3] = llx + (x+1)*xspace;
		Ypts[3] = lly + y*yspace;

		COLOR_ALREADY_SET = 1;
		if(DrawColorFill==1)
		{
		  
          MAPdrawpoly(4, Xpts, Ypts,color,1,1,1,lindex);
		}
		else
		{

		  if(PROCESS_GRID_VALUES==1) 
		  {
			 

			 if((doing_discrete>0)&&(draw_outline>0))
			 {
			   if(draw_style!=0)
			   {
                 DrawOutlineEdge(less_great,tgtval,nonshadecolor,lindex,Xpts[0],Ypts[0],Xpts[1],Ypts[1],Xpts[2],Ypts[2],Xpts[3],Ypts[3]);
			   }
			 } 
		  }


		  

          if(
                (doing_discrete==0) ||
				( (less_great==0) && ((Zgrid[0]>=tgtval)&&(Zgrid[1]>=tgtval)&&(Zgrid[2]>=tgtval)) ) ||
				( (less_great==1) && ((Zgrid[0]!=tgtval)&&(Zgrid[1]!=tgtval)&&(Zgrid[2]!=tgtval)) ) ||
				( (less_great==2) && ((Zgrid[0]<=tgtval)&&(Zgrid[1]<=tgtval)&&(Zgrid[2]<=tgtval)) )
               )
			  
			 {
               MAPdrawpoly(3, Xpts, Ypts,color,1,1,1,lindex);
			 }
		  
		}


		COLOR_ALREADY_SET = 0;


        if(DrawColorFill==0)
		{
          SetShadedColor(color2);
          COLOR_ALREADY_SET = 1;


		  if(PROCESS_GRID_VALUES==1) 
		  {
		     

             if(
				(doing_discrete==0) ||
				( (doing_discrete==1) && (less_great==0) && ((Zgrid[1]>=tgtval)&&(Zgrid[2]>=tgtval)&&(Zgrid[3]>=tgtval)) ) ||
				( (doing_discrete==1) && (less_great==1) && ((Zgrid[1]!=tgtval)&&(Zgrid[2]!=tgtval)&&(Zgrid[3]!=tgtval)) ) ||
				( (doing_discrete==1) && (less_great==2) && ((Zgrid[1]<=tgtval)&&(Zgrid[2]<=tgtval)&&(Zgrid[3]<=tgtval)) )
			   )
			 {
               MAPdrawpoly(3,&Xpts[1],&Ypts[1],color,1,1,1,lindex);
			 }

		     

		     tempa = Xpts[2];
		     tempb = Ypts[2];
             Xpts[2] = Xpts[3];
             Ypts[2] = Ypts[3];

             if(
				(doing_discrete==0) ||
				( (doing_discrete==1) && (less_great==0) && ((Zgrid[0]>=tgtval)&&(Zgrid[1]>=tgtval)&&(Zgrid[3]>=tgtval)) ) ||
				( (doing_discrete==1) && (less_great==1) && ((Zgrid[0]!=tgtval)&&(Zgrid[1]!=tgtval)&&(Zgrid[3]!=tgtval)) ) ||
				( (doing_discrete==1) && (less_great==2) && ((Zgrid[0]<=tgtval)&&(Zgrid[1]<=tgtval)&&(Zgrid[3]<=tgtval)) )
			   )
			 {
               MAPdrawpoly(3,Xpts,Ypts,color,1,1,1,lindex);
			 }

		     Xpts[2] = tempa;
		     Ypts[2] = tempb;
		  }

 


          Xpts[1] = Xpts[0];
          Ypts[1] = Ypts[0];

		  

          if(

				(doing_discrete==0) ||
				( (doing_discrete==1) && (less_great==0) && ((Zgrid[0]>=tgtval)&&(Zgrid[2]>=tgtval)&&(Zgrid[3]>=tgtval)) ) ||
				( (doing_discrete==1) && (less_great==1) && ((Zgrid[0]!=tgtval)&&(Zgrid[2]!=tgtval)&&(Zgrid[3]!=tgtval)) ) ||
				( (doing_discrete==1) && (less_great==2) && ((Zgrid[0]<=tgtval)&&(Zgrid[2]<=tgtval)&&(Zgrid[3]<=tgtval)) )
			   )
			 {
               MAPdrawpoly(3,&Xpts[1],&Ypts[1],color,1,1,1,lindex);
			 }
		  
          COLOR_ALREADY_SET = 0;
		}






		if(DrawContourLines==1)
		{
          Xpts[1] = llx + x*xspace;
          Ypts[1] = lly + (y+1)*yspace;
		  SPECIAL_COLOR = TheContourColor;
          DrawContourLinesFromPoly(4,Xpts,Ypts,Zgrid,lindex);
		  SPECIAL_COLOR = -1;
		}

	  } 
	} 

	GRID_LABEL_DRAW_OVERRIDE = 0;
  }
  else
  {


    


    
    modifier = (int)(x_pix/xspace);
	if( (int)(x_pix/yspace) > modifier )
	{
      modifier = (int)(x_pix/yspace);
	}


    XSetFillStyle(mydisplay,mygc,FillSolid);
    XSetFillStyle(mydisplay,mybitgc,FillSolid);

    for(x=10;x<990;x=x+1)
	{

      if(AbortZoom())
	  {
        break;
	  }

      for(y=10;y<790;y=y+1)
	  { 
        
	    

		if(OVERRIDING_CONTOUR==1)
		{
          if((x%2!=0)||(y%2!=0))
		  {
            continue;
		  }
		}


	    xmod = llx_zoom+((double)(x-10)/xunits)*IRegionSize;
	    ymod = lly_zoom+((double)(y-10)/yunits)*IRegionSize;

        xindex = (xmod - llx)/xspace;
	    yindex = (ymod - lly)/yspace;


	    if( ((xindex>=0)&&(xindex<(xnum-1))) && ((yindex>=0)&&(yindex<(ynum-1))) )
		{ 



          
          
          


          if(DrawContourLines==1)
		  { 
	        GetTempFill = 1;
		  }

		  color2 = 0;
          color = SetShadingColor(gridfile,gridstart,datasize,(int)xindex,(int)yindex,modifier,xnum,ynum,xspace,yspace,SA,SB,SC,counter,&color2);
		  counter = counter + 1;


		  if(GetTempFill>0)
		  {
			for(xx=x;xx<x+1;xx++)
			{
              for(yy=y;yy<y+1;yy++)
			  {
                MyMask[xx][yy] = GetTempFill - 10;
			  }
			}
            GetTempFill = 0;
		  }


          if(DRAWING_TOPLEVEL==1)
		  { 



			if(
				(doing_discrete==0) ||
				( (doing_discrete==1) && (less_great==0) && ((Zgrid[0]>=tgtval)&&(Zgrid[1]>=tgtval)&&(Zgrid[2]>=tgtval)) ) ||
				( (doing_discrete==1) && (less_great==1) && ((Zgrid[0]!=tgtval)&&(Zgrid[1]!=tgtval)&&(Zgrid[2]!=tgtval)) ) ||
				( (doing_discrete==1) && (less_great==2) && ((Zgrid[0]<=tgtval)&&(Zgrid[1]<=tgtval)&&(Zgrid[2]<=tgtval)) )
			  )
			{
	          if(GLOBAL_draw==1)
			  {  
                XDrawPoint(mydisplay,pixmap, mygc,   x,gry-y);
			  }  
	          else
			  {  
                XDrawPoint(mydisplay,pixmap2, mygc,   x,gry-y);
			  }  
	          if(GLOBAL_needextrapixmap==1)
			  {  
                XDrawPoint(mydisplay,over_pixmap, mygc,   x,gry-y);
			  }  
			}  
		  }
          else
		  { 
            if(PROCESS_GRID_VALUES==1)
			{
              if(
  				  (doing_discrete==0) ||
				  ( (doing_discrete==1) && (less_great==0) && ((Zgrid[0]>=tgtval)&&(Zgrid[1]>=tgtval)&&(Zgrid[2]>=tgtval)) ) ||
				  ( (doing_discrete==1) && (less_great==1) && ((Zgrid[0]!=tgtval)&&(Zgrid[1]!=tgtval)&&(Zgrid[2]!=tgtval)) ) ||
				  ( (doing_discrete==1) && (less_great==2) && ((Zgrid[0]<=tgtval)&&(Zgrid[1]<=tgtval)&&(Zgrid[2]<=tgtval)) )
                )
				
			  {
	            XDrawPoint(mydisplay,global_mask_bitmap,mybitgc,x,gry-y);
			  }
			}
			else if(
  				  (doing_discrete==0) ||
				  ( (doing_discrete==1) && (less_great==0) && ((Zgrid[0]>=tgtval)&&(Zgrid[1]>=tgtval)&&(Zgrid[2]>=tgtval)) ) ||
				  ( (doing_discrete==1) && (less_great==1) && ((Zgrid[0]!=tgtval)&&(Zgrid[1]!=tgtval)&&(Zgrid[2]!=tgtval)) ) ||
				  ( (doing_discrete==1) && (less_great==2) && ((Zgrid[0]<=tgtval)&&(Zgrid[1]<=tgtval)&&(Zgrid[2]<=tgtval)) )
                )
			{
			  
              XDrawPoint(mydisplay,DRAWING_PIXMAPS[rendering_priority], mygc,   x,gry-y);
              XDrawPoint(mydisplay,DRAWING_CLIPMAPS[rendering_priority],mybitgc,x,gry-y);
			}
		  } 
		  
          gridcount++;
          if((gridcount%GRIDCHUNK)==0)
		  { 
            if(DRAWING_TOPLEVEL==1)
			{ 
	          if(GLOBAL_draw==1)
			  {  
                XCopyArea (mydisplay, pixmap, mywindow, mygc, 0, 0, width, height, 0, 0);
			  }  
	          else
			  {  
                if((SpecialMapdrawPoly==0)||(GLOBAL_showlayers==1))
				{
                  XCopyArea (mydisplay, pixmap2, mywindow, mygc, 0, 0, width, height, 0, 0);
				}
		        else
				{
			      
				}
			  } 
			}
			else
			{
              if((SpecialMapdrawPoly==0)||(GLOBAL_showlayers==1))
			  {
                FlushMainScreen(GRID_LIMIT);
			  } 
			  else
			  {
                
			  }
			}   
		  }
		}
	  }
	}
  }
  fclose(gridfile);



  
  DrawColorFill = SaveDrawColorFill;
  DrawContourLines = SaveDrawContourLines;




  if(ABORT_ZOOM>0)
  {
    return;
  }



  if(DrawContourLines==1)
  {
    XSetForeground(mydisplay,mygc,mycolors[TheContourColor]);

    for(x=11;x<990-1;x=x+1)
	{
      for(y=11;y<790-1;y=y+1)
	  {
		  if(
			  (MyMask[x][y]    ==8) ||
			  (MyMask[x][y+1]  ==8) ||
			  (MyMask[x][y-1]  ==8) ||
			  (MyMask[x+1][y]  ==8) ||
			  (MyMask[x-1][y]  ==8) ||
			  (MyMask[x+1][y+1]==8) ||
			  (MyMask[x+1][y-1]==8) ||
			  (MyMask[x-1][y+1]==8) ||
			  (MyMask[x-1][y-1]==8)
			  )
		  {
            continue;
		  }

thickness = small_thickness;
if(MyMask[x][y]==0)
{
	thickness = big_thickness;
}

		  if(MyMask[x][y]!=MyMask[x][y-1]) 
		  {
            if((thickness==big_thickness)&&(MyMask[x][y-1]==4)) {thickness = big_thickness;} else {thickness = small_thickness;} 
            ContourLine(x,gry-y, x, gry-(y-1),thickness,rendering_priority);
		  }
		  if(MyMask[x][y]!=MyMask[x][y+1]) 
		  {
            if((thickness==big_thickness)&&(MyMask[x][y+1]==4)) {thickness = big_thickness;} else {thickness = small_thickness;} 
            ContourLine(x,gry-y, x, gry-(y+1),thickness,rendering_priority);
		  }
		  if(MyMask[x][y]!=MyMask[x+1][y]) 
		  {
            if((thickness==big_thickness)&&(MyMask[x+1][y]==4)) {thickness = big_thickness;} else {thickness = small_thickness;} 
            ContourLine(x,gry-y, x+1, gry-y,thickness,rendering_priority);
		  }
		  if(MyMask[x][y]!=MyMask[x-1][y]) 
		  {
            if((thickness==big_thickness)&&(MyMask[x-1][y]==4)) {thickness = big_thickness;} else {thickness = small_thickness;} 
            ContourLine(x,gry-y, x-1, gry-y,thickness,rendering_priority);
		  }
		  if(MyMask[x][y]!=MyMask[x+1][y+1]) 
		  {
            if((thickness==big_thickness)&&(MyMask[x+1][y+1]==4)) {thickness = big_thickness;} else {thickness = small_thickness;} 
            ContourLine(x,gry-y, x+1, gry-(y+1),thickness,rendering_priority);
		  }
		  if(MyMask[x][y]!=MyMask[x+1][y-1]) 
		  {
            if((thickness==big_thickness)&&(MyMask[x+1][y-1]==4)) {thickness = big_thickness;} else {thickness = small_thickness;} 
            ContourLine(x,gry-y, x+1, gry-(y-1),thickness,rendering_priority);
		  }
		  if(MyMask[x][y]!=MyMask[x-1][y+1]) 
		  {
            if((thickness==big_thickness)&&(MyMask[x-1][y+1]==4)) {thickness = big_thickness;} else {thickness = small_thickness;} 
            ContourLine(x,gry-y, x-1, gry-(y+1),thickness,rendering_priority);
		  }
		  if(MyMask[x][y]!=MyMask[x-1][y-1]) 
		  {
            if((thickness==big_thickness)&&(MyMask[x-1][y-1]==4)) {thickness = big_thickness;} else {thickness = small_thickness;} 
            ContourLine(x,gry-y, x-1, gry-(y-1),thickness,rendering_priority);
		  }
        
	  }
	}
  }
}






char *GetMetadataNaming()
{
  FILE *headfile;
  char temp[1000];
  static char aline[100];
  
 
  
  sprintf(temp,"%smetatype.txt",indirectory);
  headfile = fopen(temp,"r");
  if(headfile==NULL)
    {
      printf("Failed to generate summary info: couldnt open %s\n",temp); 
      return "Error";
    }
  else
    {
      fgets(aline,100,headfile);
      fclose(headfile);
      
      return aline;
    }
  
  return "!!";
}



char *GetQACRTemplate(int NGAMGCP, int type)
{
  char part1[100],part2[100],part3[100];
  static char retval[200];

  if(SLASHTYPE==DOS_TYPE)
  {
	sprintf(part1,"%sbin\\",GAIT_HOME_DIR);
  }
  else
  { 
	sprintf(part1,"bin/");
  }

  if(NGAMGCP==1)
  {
	sprintf(part2,"ag");
  }
  else
  {
 	sprintf(part2,"pc");
  }

  if(type==1)
  {
	sprintf(part3,"df1.dat"); 
  }
  else if(type==2)
  {
	sprintf(part3,"df2.dat"); 
  }
  else if(type==3)
  {
	sprintf(part3,"df3.dat"); 
  }
  else if(type==4)
  {
	sprintf(part3,"df4.dat"); 
  }
 else if(type==5)
  {
	sprintf(part3,"df5.dat"); 
  }
 else if(type==6)
  {
	sprintf(part3,"df6.dat"); 
  }

  sprintf(retval,"%s%s%s",part1,part2,part3);
  return retval;

}




int GetStartLoc(char *buf, int numbytes, int nga_or_mgcp)
{
  int i, j, k, donefirst=0, donesecond=0;
  int MAX_VERSION_LEN = 18; 
  char thisname[10];

  extern const char *ParticipantNationCodes4[32*3];


  if(QACR_COUNTRY>900)
  {
    sprintf(thisname,"XXX");
  }
  else
  {
    
    thisname[0] = ParticipantNationCodes4[QACR_COUNTRY][0];
    thisname[1] = ParticipantNationCodes4[QACR_COUNTRY][1];
    thisname[2] = ParticipantNationCodes4[QACR_COUNTRY][2];
    thisname[3] = '\0';  
  }


  for(i=0;i<numbytes;i++)
  {


	if(nga_or_mgcp==2)  
	{
      if(
	     (buf[i]==126)   &&
	     (buf[i+1]==126) &&
	     (buf[i+2]==126) &&
		 (donefirst==0)
	   )
	  {
		buf[i]   = thisname[0];
		buf[i+1] = thisname[1];
		buf[i+2] = thisname[2];

		donefirst = 1;
	  } 
	}


    if(
	   (buf[i]==33) &&
	   (buf[i+1]==33) &&
	   (buf[i+2]==33) &&
	   (buf[i+3]==33) &&
	   (buf[i+4]==33) &&
	   (buf[i+5]==33) &&
	   (donesecond==0)
	  ) 
	{ 
	  for(j=0;j<(int)strlen(VersionStr);j++)
	  {
		buf[i+j] = VersionStr[j];
	  }
	  for(k=j;k<MAX_VERSION_LEN;k++)
	  {
		buf[i+k] = 32;
	  }
	  donesecond = 1;
	  if(nga_or_mgcp==1)
	  {
        break;  
	  }
	} 


	if(donesecond==1)
	{  
	  if(nga_or_mgcp==2)  
	  { 
        if(
	        (buf[i]==45) &&
	        (buf[i+1]==45) &&
	        (buf[i+2]==45)
	      )
		{
	      if(QACR_EXPORT_TRD_VERSION==30)
		  {
		    buf[i] = '3';
		    buf[i+1] = '.';
		    buf[i+2] = '0';
		  }
	      else if(QACR_EXPORT_TRD_VERSION==40)
		  {
		    buf[i] = '4';
		    buf[i+1] = '.';
		    buf[i+2] = '0';
		  }
	      else if(QACR_EXPORT_TRD_VERSION==41)
		  {
		    buf[i] = '4';
		    buf[i+1] = '.';
		    buf[i+2] = '1';
		  }
	      else if(QACR_EXPORT_TRD_VERSION==42)
		  {
		    buf[i] = '4';
		    buf[i+1] = '.';
		    buf[i+2] = '2';
		  }
	      else if(QACR_EXPORT_TRD_VERSION==43)
		  {
		    buf[i] = '4';
		    buf[i+1] = '.';
		    buf[i+2] = '3';
		  }
	      else if(QACR_EXPORT_TRD_VERSION==44)
		  {
		    buf[i] = '4';
		    buf[i+1] = '.';
		    buf[i+2] = '4';
		  }
		  else 
		  {
		    buf[i] = ' ';
		    buf[i+1] = ' ';
		    buf[i+2] = ' ';
		  }
		  break;
		}    
	  } 
	} 
  }


  if(i>=numbytes)
  {
	return -1;
  }

  for(i=0;i<numbytes;i++)
  {
      if(
	     (buf[i]==124) &&
	     (buf[i+1]==124) &&
	     (buf[i+2]==124) &&
	     (buf[i+3]==124)
	   ) 
	  { 
	    return i;
	  } 
  } 

  return -1;
}



int WriteSequence(FILE *outfile,int seq1in, char *seq2in, char *seq3in, int seq4in)
{
  unsigned char charval,sentval=7;
  char seq1[1000],seq2[1000],seq3[1000],seq4[1000];
  int i, len, target1 = 4, target2 = 75, target3 = 150, target4 = 10;
  
  sprintf(seq1,"%d",seq1in);
  sprintf(seq2,"%s",seq2in);

  if(seq3in!=NULL)
  {
    sprintf(seq3,"%s",seq3in);
  }
  else
  {
    sprintf(seq3,"No Annotation");
  }

  if(seq4in>0)
  {
    sprintf(seq4,"%d",seq4in);
  }
  else
  {
     sprintf(seq4,"   ");
  }
  
  len = strlen(seq1);
  for(i=len;i<target1;i++)
    {
      seq1[i] = ' ';
    }
  seq1[target1] = '\0';


  len = strlen(seq2);
  for(i=len;i<target2;i++)
    {
      seq2[i] = ' ';
    }
  seq2[target2] = '\0';



  len = strlen(seq3);
  for(i=len;i<target3;i++)
    {
      seq3[i] = ' ';
    }
  seq3[target3] = '\0';


  len = strlen(seq4);
  for(i=len;i<target4;i++)
    {
      seq4[i] = ' ';
    }
  seq4[target4] = '\0';







  for(i=0;i<(int)strlen(seq1);i++)
    {
      charval = seq1[i];
      fwrite(&charval,1,1,outfile);
    }
  fwrite(&sentval,1,1,outfile);


  for(i=0;i<(int)strlen(seq2);i++)
    {
      charval = seq2[i];
      fwrite(&charval,1,1,outfile);
    }
  fwrite(&sentval,1,1,outfile);

  
  for(i=0;i<(int)strlen(seq3);i++)
    {
      charval = seq3[i];
      fwrite(&charval,1,1,outfile);
    }
  fwrite(&sentval,1,1,outfile);

  
  for(i=0;i<(int)strlen(seq4);i++)
    {
      charval = seq4[i];
      fwrite(&charval,1,1,outfile);
    }
  fwrite(&sentval,1,1,outfile);
  fwrite(&sentval,1,1,outfile);
  fwrite(&sentval,1,1,outfile);
  fwrite(&sentval,1,1,outfile);

  return strlen(seq1) + strlen(seq2) + strlen(seq3) + strlen(seq4) + 7;

}


void free_qacr_globals()
{
  int i;

  if(TotalNGAAttrInstances>0)
  {
	for(i=0;i<TotalNGAAttrInstances;i++)
	{
      free(nga_qacr_lhs[i]);
      free(nga_qacr_rhs[i]);
	}
  }

  if(TotalMGCPAttrInstances>0)
  {
	for(i=0;i<TotalMGCPAttrInstances;i++)
	{
	  free(mgcp_qacr_lhs[i]);
	  free(mgcp_qacr_rhs[i]);
	}
  }

  if(nga_qacr_lhs!=NULL)
  {
	free(nga_qacr_lhs);
  }
  if(nga_qacr_rhs!=NULL)
  {
    free(nga_qacr_rhs);
  }
  if(nga_qacr_counts!=NULL)
  {
    free(nga_qacr_counts);
  }

  if(mgcp_qacr_lhs!=NULL)
  {
    free(mgcp_qacr_lhs);
  }
  if(mgcp_qacr_rhs!=NULL)
  {
    free(mgcp_qacr_rhs);
  }
  if(mgcp_qacr_counts!=NULL)
  {
    free(mgcp_qacr_counts);
  }

  nga_qacr_lhs     = NULL;
  nga_qacr_rhs     = NULL;
  nga_qacr_counts  = NULL;
  mgcp_qacr_lhs    = NULL;
  mgcp_qacr_rhs    = NULL;
  mgcp_qacr_counts = NULL;
}


void IWriteFile(char *filename,char *message)
{
  FILE *outfile;

  outfile = fopen(filename,"w");
  if(outfile==NULL)
  {
	printf("Error: Could not create %s for write\n",filename);
	return;
  }
  fprintf(outfile,"%s\n",message);
  fclose(outfile);
}


void ICopyFile(char *source,char *target, char *message)
{
  char cleanname[2000];

  if(FileExists(source))
  {
    if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
	{  
      sprintf(cleanname,"copy \"%s\" \"%s\"",source,target);
	}  
    else
	{  
      sprintf(cleanname,"cp \"%s\" \"%s\"",source,target);
	} 

    system(cleanname);
  }
  else
  {
	IWriteFile(target,message);
  }
}


void CopyTRExFiles(long int thistime)
{
  char orig[1000],target[1000];
  extern char *GetTRExFileName();

  sprintf(orig,"%ssummary_files%sTREx_header_errors.txt",indirectory,GetSlash());
  sprintf(target,"%s_GeoTIFFreport.txt",GetTRExFileName());
  ICopyFile(orig,target,"Error: TREx_header_errors.txt not found in summary_files folder");

  sprintf(orig,"%sXML%sTREx_finished_%s_results.txt",indirectory,GetSlash(),GetTRExSubName2(indirectory,1));
  sprintf(target,"%s_XMLreport.txt",GetTRExFileName());
  ICopyFile(orig,target,"Error: Finished XML report not found in XML folder");

  sprintf(orig,"%ssummary_files%sICESATreport.csv",indirectory,GetSlash());
  sprintf(target,"%s_ICESATreport.csv",GetTRExFileName());
  ICopyFile(orig,target,"ICESAT analysis not performed");

  sprintf(orig,"%ssummary_files%sGCPreport.csv",indirectory,GetSlash());
  sprintf(target,"%s_GCPreport.csv",GetTRExFileName());
  ICopyFile(orig,target,"GCP analysis not performed");

}




void SetTRExChecklistFiles()
{
  int i,len;
  char testfile[1000];

  if(getenv("GAIT_TREX_QA_TEMPLATE")!=NULL)
  {
    sprintf(testfile,"%s",getenv("GAIT_TREX_QA_TEMPLATE"));
      
    printf("Found GAIT_TREX_QA_TEMPLATE environment variable %s\n",testfile);

    for(i=0;i<500;i++) 
	{ 
      len = strlen(testfile);

      if(len>0)
	  { 
        if(testfile[len]=='\0') 
		{ 
	      if(testfile[len-1]=='/')  
		  { 
	        testfile[len-1]='\0';
			printf("Illegal to specify GAIT_TREX_QA_TEMPLATE ending in \"/\".  Modified to %s\n",testfile);
		  } 
	      else if(testfile[len-1]=='\\')  
		  { 
	        testfile[len-1]='\0';
			printf("Illegal to specify GAIT_TREX_QA_TEMPLATE ending in \"\\\".  Modified to %s\n",testfile);
		  } 
		}   
	  }   
	}
	if(FileExists(testfile))
	{
	  sprintf(trex_qa_file,"%s",testfile);
	}
	else
	{
	  printf("Error: cannot open %s\n",testfile);
      sprintf(trex_qa_file,"%sTREx_Checklist_Templates%sTREX_QA_template.xlsx",GAIT_HOME_DIR,GetSlash());
	}
  }
  else
  {
    sprintf(trex_qa_file,"%sTREx_Checklist_Templates%sTREX_QA_template.xlsx",GAIT_HOME_DIR,GetSlash());
  }

  printf("Using %s as TREx QA template file\n",trex_qa_file);




  if(getenv("GAIT_TREX_QC_TEMPLATE")!=NULL)
  {
    sprintf(testfile,"%s",getenv("GAIT_TREX_QC_TEMPLATE"));
      
    printf("Found GAIT_TREX_QC_TEMPLATE environment variable %s\n",testfile);

    for(i=0;i<500;i++) 
	{ 
      len = strlen(testfile);

      if(len>0)
	  { 
        if(testfile[len]=='\0') 
		{ 
	      if(testfile[len-1]=='/')  
		  { 
	        testfile[len-1]='\0';
			printf("Illegal to specify GAIT_TREX_QC_TEMPLATE ending in \"/\".  Modified to %s\n",testfile);
		  } 
	      else if(testfile[len-1]=='\\')  
		  { 
	        testfile[len-1]='\0';
			printf("Illegal to specify GAIT_TREX_QC_TEMPLATE ending in \"\\\".  Modified to %s\n",testfile);
		  } 
		}   
	  }   
	}
	if(FileExists(testfile))
	{
	  sprintf(trex_qc_file,"%s",testfile);
	}
	else
	{
	  printf("Error: cannot open %s\n",testfile);
      sprintf(trex_qc_file,"%sTREx_Checklist_Templates%sTREX_QC_template.xlsx",GAIT_HOME_DIR,GetSlash());
	}
  }
  else
  {
    sprintf(trex_qc_file,"%sTREx_Checklist_Templates%sTREX_QC_template.xlsx",GAIT_HOME_DIR,GetSlash());
  }

  printf("Using %s as TREx QC template file\n",trex_qc_file);

}





void CreateTrexChecklist()
{
  char analysis_type[50],thetype[100];
  char cleanname[1000],orig[1000],target[1000],sheetname[10];
  extern char *GetTRExFileName();

#if(USE_DOS==1)
extern void ProcessExcel(char *infile, char *sheetname, char *analysis_type);
#endif


  if(do_trex_checklist==1)
  {
	if(USE_DOS==1)
	{
	  sprintf(thetype,"%s",GetTRExType(indirectory));
	  printf("Make checklist for type: %s\n",thetype);


	  if(!strcmp(thetype,"QC"))
	  {
        
		sprintf(orig,"%s",trex_qc_file);
		sprintf(sheetname,"QC");
		sprintf(analysis_type,"QC");
	  }
	  else if(!strcmp(thetype,"cQA"))
	  {
        
		sprintf(orig,"%s",trex_qa_file);
		sprintf(sheetname,"QA");
		sprintf(analysis_type,"Comprehensive QA");
	  }
	  else if(!strcmp(thetype,"sQA"))
	  {
        
		sprintf(orig,"%s",trex_qa_file);
		sprintf(sheetname,"QA");
		sprintf(analysis_type,"Standard QA");
	  }
	  else
	  {
		printf("Error: TREx type %s not recognized.  Expected QC, cQA, or sQA.\n",thetype);
		return;
	  }

	  printf("Use template file: %s\n",orig);


      sprintf(target,"%s.xlsx",GetTRExFileName());

      if(FileExists(orig))
	  { 
        if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
		{   
          sprintf(cleanname,"copy \"%s\" \"%s\"",orig,target);
		}
        system(cleanname);
	  }
	  else
	  {
	    printf("Cannot find TREx template file %s\n",orig);
		return;
	  }

	  if(FileExists(target)==0)
	  {
	    printf("Unable to copy %s to %s\n",orig,target);
		return;
	  }


	  printf("Have template file %s\n",target);

#if(USE_DOS==1)
	  ProcessExcel(target,sheetname,analysis_type);
#endif
	}
  }
  else
  {
	printf("NOT making TREx checklist due to GAIT_TREX_CREATE_CHECKLIST variable not \"ON\"\n");
  }

}


void WriteSummaryReport(int type)
{
  

  FILE *summfile,*nga_qacr_in,*nga_qacr_out,*mgcp_qacr_in,*mgcp_qacr_out;
  char *wholeNGAfile,*wholeMGCPfile;
  char outsummfile[1000],outfile[1000],outNGA_QACRfile[1000],
	  outMGCP_QACRfile[1000],inNGA_QACRfile[1000],inMGCP_QACRfile[1000],
	  temp[500],NGAheader[50],MGCPheader[50];
  int i,j,counter=0,totalbad,numbytesNGA,numbytesMGCP,do_nga_qacr,do_mgcp_qacr,
	  NGAstartloc,MGCPstartloc,TotalNGAInstances=0,TotalMGCPInstances=0,
	  TotalCondInstances=0,upperNGAlimit=0,upperMGCPlimit=0,TOP_LIMIT=499,
	  addon=0,mallocnum,numHbytesNGA,numHbytesMGCP,QACRhsize=24,result,
	  utc_year,utc_month,utc_day,utc_hour,utc_min,utc_sec;
  long int thistime=time(NULL);
  double djunk;
  struct tm *ptm;

  extern int RemovedOneDegree;
  extern void GetUTCValues(long int rawtime, 
				  int *utc_year,int *utc_month,int *utc_day,
		          int *utc_hour,int *utc_min,int *utc_sec);
  extern void SaveTime(long int thistime);
  extern char *GetTRExFileName();
  extern void RemoveTRExFiles(int type);
  extern long int ReadSavedTime();


  

  if(NETS_ONLY==1)
  {
    return;
  }


  if(type==1)
    {
      do_nga_qacr  = 1;
      do_mgcp_qacr = 0;

      if((ATTRTYPE_MGCP3())||(ATTRTYPE_MGCP4()))
	{
	  if(strstr(masterrun2,"MGCP"))
	    {
	      do_nga_qacr  = 0;
	      do_mgcp_qacr = 1;
	    }
	}
      





      if(!strcmp(ParseAttributionType(ATTRIBUTION_TYPE),"TREx"))
	  {
        if(ATTRTYPE_TREX())
		{ 
          RemoveTRExFiles(2); 
		  CreateTrexChecklist();
		} 

         sprintf(outsummfile,     "%s.txt",GetTRExFileName());
      }
	  else
	  {
         sprintf(outsummfile,     "%schecksummary.txt",outsumdirectory);
	  }

      
      
      
      nga_qacr_lhs     = (char **)malloc(sizeof(char *)*10000);
      nga_qacr_rhs     = (char **)malloc(sizeof(char *)*10000);
      nga_qacr_counts  = (int *)  malloc(SzI*10000);
      
      mgcp_qacr_lhs    = (char **)malloc(sizeof(char *)*10000);
      mgcp_qacr_rhs    = (char **)malloc(sizeof(char *)*10000);
      mgcp_qacr_counts = (int *)  malloc(SzI*10000);

      TotalNGAAttrInstances  = 0;
      TotalNGAInstances      = 0;
      TotalMGCPAttrInstances = 0;
      TotalMGCPInstances     = 0;

    } 
  else if(type==2)
    {
	  do_nga_qacr  = 0;
	  do_mgcp_qacr = 0;

      sprintf(outsummfile,"%stemp.txt",indirectory);
    }
  else if(type==3)
    {
	  do_nga_qacr  = 0;
	  do_mgcp_qacr = 0;

	  

      thistime=time(NULL);

	  GetUTCValues(thistime,
		  &utc_year,&utc_month,&utc_day,
		  &utc_hour,&utc_min,&utc_sec);

	  SaveTime(thistime);

	  if(ATTRTYPE_TREX())
	  {
        CopyTRExFiles(thistime);
	  }


      sprintf(outsummfile,"%sprojectsummary.txt",outsumdirectory);
    }




  summfile = fopen(outsummfile,"w");
  if(summfile==NULL)
    {
      printf("Fatal error: unable to open %s for write!\n",outsummfile);
      ExitWrapper(-1);
    }


  if((type==1)||(type==3))
    {
	  if(type==1)
	  {
        fprintf(summfile,"          GAIT Inspection Summary Report");
	  }
	  else if(type==3)
	  {
        fprintf(summfile,"          GAIT Project Creation Report");
	  }
      fprintf(summfile,"                                   \n");
      fprintf(summfile,"                                   \n");
      fprintf(summfile,"GAIT Version                     : %s\n",VersionStr);
      fprintf(summfile,"GAIT Project:                    :\n    %s\n",indirectory);

	  if(type==3)
	  {

		

        thistime = ReadSavedTime();

        fprintf(summfile,"Project Creation Date (local)              : %s",ctime(&thistime));

		ptm = gmtime(&thistime);

        fprintf(summfile,"Project Creation Date (UTC)                : %d-%02d-%02dT%02d:%02d:%02dZ\n",
	      ptm->tm_year + 1900,
	      ptm->tm_mon + 1,
	      ptm->tm_mday,
	      ptm->tm_hour,
	      ptm->tm_min,
	      ptm->tm_sec);
	  }
	  else
	  {

		

        thistime=time(NULL);

	    GetUTCValues(thistime,
		  &utc_year,&utc_month,&utc_day,
		  &utc_hour,&utc_min,&utc_sec);


        fprintf(summfile,"Report Date (local)              : %s",ctime(&thistime));


        fprintf(summfile,"Report Date (UTC)                : %d-%02d-%02dT%02d:%02d:%02dZ\n",
	      utc_year,
	      utc_month,
	      utc_day,
	      utc_hour,
	      utc_min,
	      utc_sec);
	  }

      fprintf(summfile,"                                   \n");
      fprintf(summfile,"GAIT PROJECT                       \n");
      fprintf(summfile,"                                   \n");
      fprintf(summfile,"SW Longitude                     : %s\n",GetSWLong(&djunk));
      fprintf(summfile,"SW Latitude                      : %s\n",GetSWLat(&djunk));
      fprintf(summfile,"NE Longitude                     : %s\n",GetNELong());
      fprintf(summfile,"NE Latitude                      : %s\n",GetNELat());
      fprintf(summfile,"                                   \n");
      fprintf(summfile,"Attribution Schema               : %s\n",ParseAttributionType(ATTRIBUTION_TYPE));   


      if(
		  (ATTRTYPE_D4()) || 
		  (ATTRTYPE_FACC()) || 
		  (ATTRTYPE_VMAP()) || 
		  (ATTRTYPE_UFD1()) || 
		  (ATTRTYPE_UFD2()) || 
		  (ATTRTYPE_UFD3())
		  )
	  { 
        fprintf(summfile,"Metadata Naming Convention       : %s\n",GetMetadataNaming());
	  }

      if(strcmp(ParseAttributionType(ATTRIBUTION_TYPE),"TREx"))
	  {
        fprintf(summfile,"Project Classification           : %s\n",SetThisClassLevel(1,0));
	  }

      fprintf(summfile,"Feature Types                    : %s\n",GetDataContent(5));
      fprintf(summfile,"Point Features                   : %s\n",GetDataContent(1));
      fprintf(summfile,"Line Features                    : %s\n",GetDataContent(2));
      fprintf(summfile,"Area Features                    : %s\n",GetDataContent(3));
      fprintf(summfile,"Total Features                   : %s\n",GetDataContent(4));
      fprintf(summfile,"                                   \n");
      fprintf(summfile,"Total Raster Files               : %s\n",GetVariousPeices(3));
      fprintf(summfile,"Total Raster Posts               : %s\n",GetVariousPeices(4));
      fprintf(summfile,"                                   \n");
      fprintf(summfile,"                                   \n");
    }


  

  if(!strcmp(ParseAttributionType(ATTRIBUTION_TYPE),"TREx"))
  {
	  sprintf(temp,"TREx GeoCell      : %s\n",GetTRExSubName2(indirectory,1));
	  fprintf(summfile,"%s",temp);

	  sprintf(temp,"TREx analysis type: %s\n\n\n",GetTRExType(indirectory));
	  fprintf(summfile,"%s",temp);



      AddTextFile(summfile,23,"Unused Title",type);                 
      fprintf(summfile,"                                 \n\n");    
      AddTextFile(summfile,22,"Unused Title",type);                 
      fprintf(summfile,"                                 \n\n");    
      AddTextFile(summfile,21,"Unused Title",type);                 
      fprintf(summfile,"                                 \n\n");    
  }


  

  if(strcmp(ParseAttributionType(ATTRIBUTION_TYPE),"TREx"))
  {
    fprintf(summfile,"Input Data Anomalies:               \n");
    fprintf(summfile,"                                   \n");
    fprintf(summfile,"1. Zero-Part Area/Line errors occur when line or area\n");
    fprintf(summfile,"   features contain 0 parts (no geometry)\n");
    fprintf(summfile,"                                   \n");
    fprintf(summfile,"   Zero-Part Area/Line errors found:\n");
    AddTextFile(summfile,6,"Zero-Part Area/Line errors",type);
    fprintf(summfile,"      \n");
    fprintf(summfile,"2. NULL Feature errors occur when shapefiles contain NULL\n");
    fprintf(summfile,"   shape types (no geometry)\n");
    fprintf(summfile,"                                   \n");
    fprintf(summfile,"   NULL Feature errors found:\n");
    AddTextFile(summfile,7,"NULL Feature errors",type);
    fprintf(summfile,"      \n");
    fprintf(summfile,"3. Invalid Coordinate errors occur when input data are not in\n");
    fprintf(summfile,"   geographic (lat/long) coordinates\n");
    fprintf(summfile,"                                   \n");
    fprintf(summfile,"   Invalid Coordinate errors found:\n");
    AddTextFile(summfile,8,"Invalid Coordinate errors",type);
    fprintf(summfile,"      \n");
    fprintf(summfile,"4. Invalid Cut-Out errors occur when cut-outs are found that are\n");
    fprintf(summfile,"   not contained in the feature's external boundary\n");
    fprintf(summfile,"                                   \n");
    fprintf(summfile,"   Invalid Cut-Out errors found:\n");
    AddTextFile(summfile,9,"Invalid Cut-Out errors",type);
    fprintf(summfile,"      \n");
    fprintf(summfile,"5. Unrecognized Column Names occur when tables contain columns which\n");
    fprintf(summfile,"   are unrecognized using the current attribution schema and metadata\n");
    fprintf(summfile,"   naming                          \n");
    fprintf(summfile,"                                   \n");
    fprintf(summfile,"   Unrecognized Column Names found:\n");
    AddTextFile(summfile,1,"Unrecognized Column Names",type);
    fprintf(summfile,"      \n");
    fprintf(summfile,"6. Invalid Data Type errors occur when data columns (attributes) do not\n");
    fprintf(summfile,"   have an appropriate data type (String, Integer) as specified by the data\n");
    fprintf(summfile,"   model for the given feature and attribute\n");
    fprintf(summfile,"                                   \n");
    fprintf(summfile,"   Invalid Data Type errors found:\n");
    AddTextFile(summfile,16,"Invalid Data Type errors",type);
    fprintf(summfile,"      \n");  
    fprintf(summfile,"7. Empty or Invalid Shapefiles or Tables occur when shapefiles or tables\n");
    fprintf(summfile,"   (Geodatabase or GeoMedia Access) contain no features or the DBF file for\n");
    fprintf(summfile,"   a shapefile has been truncated to 2.0GB and does not match the .shp file\n");
    fprintf(summfile,"                                   \n");
    fprintf(summfile,"   Empty or Invalid Shapefiles or Tables found:\n");
    AddTextFile(summfile,18,"Empty or Invalid Shapefiles or Tables",type);

    if(REPORT_BEZIER==1)
	{  
      fprintf(summfile,"      \n");  
      fprintf(summfile,"8. Geodatbase Bezier/Circle/Ellipse features are features in  Goedatabases\n");
      fprintf(summfile,"   coded as these types of curves, not as explicit geometries\n");
      fprintf(summfile,"                                   \n");
      fprintf(summfile,"   Geodatbase Bezier/Circle/Ellipse features found:\n");
      AddTextFile(summfile,20,"Empty or Invalid Shapefiles or Tables",type);
	}
  }


  if((ATTRTYPE_MGCP3())||(ATTRTYPE_MGCP4()))
  {
    fprintf(summfile,"      \n");
    fprintf(summfile,"%d. MGCP \"No FCODE Column\" errors occur when data tables do not\n",8+REPORT_BEZIER);
    fprintf(summfile,"   contain an \"FCODE\" column\n");
    fprintf(summfile,"                                   \n");
    fprintf(summfile,"   MGCP \"No FCODE Column\" errors found:\n");
    AddTextFile(summfile,11,"MGCP \"No FCODE Column\" errors",type);
    fprintf(summfile,"      \n");
    fprintf(summfile,"%d. MGCP Shapefile Naming errors occur when shapefile names are not\n",9+REPORT_BEZIER);
    fprintf(summfile,"   of the form [PAL][FCODE] or [PAL][FCODE]_<num>\n");
    fprintf(summfile,"                                   \n");
    fprintf(summfile,"   MGCP Shapefile Naming errors found:\n");
    AddTextFile(summfile,12,"MGCP Shapefile Naming errors",type);
    fprintf(summfile,"      \n");
    fprintf(summfile,"%d.MGCP \"Shape Type\" errors occur when shapefiles contain\n",10+REPORT_BEZIER);
    fprintf(summfile,"   features that are not of the following types: \n");
    fprintf(summfile,"   Point, PointZ, PolyLine, PolyLineZ, Polygon, PolygonZ \n");
    fprintf(summfile,"                                   \n");
    fprintf(summfile,"   MGCP \"Shape Type\" errors found:\n");
    AddTextFile(summfile,13,"MGCP \"Shape Type\" errors",type);
    fprintf(summfile,"      \n");


	if(ATTRTYPE_MGCP3())
	{
      fprintf(summfile,"%d.MGCP \"Invalid Field Length\" errors occur when shapefile\n",11+REPORT_BEZIER);
      fprintf(summfile,"   attributes have field lengths that do not match those that are called\n");
      fprintf(summfile,"   for by the MGCP Shapefile Implementation Document:  All Integer and\n");
      fprintf(summfile,"   Short Integer attribute fields should be length 6 except for BRF,\n");
      fprintf(summfile,"   which should be length 11.  All Real attribute fields should be length\n");
      fprintf(summfile,"   19, and all String attribute fields should have a length\n");
      fprintf(summfile,"   equal to the maximum length specified for that attribute in the\n");
      fprintf(summfile,"   Feature Catalog                                \n");
      fprintf(summfile,"                                   \n");
      fprintf(summfile,"   MGCP \"Invalid Field Length\" errors found:\n");
      AddTextFile(summfile,17,"MGCP \"Invalid Field Length\" errors",type);
      fprintf(summfile,"      \n");
	}
	else
	{
      fprintf(summfile,"%d.MGCP \"Invalid Field Length\" errors occur when shapefile\n",11+REPORT_BEZIER);
      fprintf(summfile,"   attributes have field lengths that do not match those that are called\n");
      fprintf(summfile,"   for by the MGCP Shapefile Implementation Document:  All Integer and\n");
      fprintf(summfile,"   All Short Integer attribute fields should be length 6.\n");
      fprintf(summfile,"   All Real attribute fields should be length 19.\n");
      fprintf(summfile,"   All String attribute fields should have a length\n");
      fprintf(summfile,"   equal to the maximum length specified for that attribute in the\n");
      fprintf(summfile,"   Feature Catalog                                \n");
      fprintf(summfile,"                                   \n");
      fprintf(summfile,"   MGCP \"Invalid Field Length\" errors found:\n");
      AddTextFile(summfile,17,"MGCP \"Invalid Field Length\" errors",type);
      fprintf(summfile,"      \n");
	}

    fprintf(summfile,"%d.MGCP \"UTF-8 Encoding\" anomalies occur when string attributes\n",12+REPORT_BEZIER);
    fprintf(summfile,"   in MGCP data do not meet UTF-8 coding specifications\n");
    fprintf(summfile,"   or are valid UTF-8 but are not on MGCP's approved list.\n");
    fprintf(summfile,"                                   \n");
    fprintf(summfile,"   MGCP \"UTF-8 Encoding\" anomalies found:\n");
    AddTextFile(summfile,19,"MGCP \"UTF-8 Encoding\" anomalies",type);
    fprintf(summfile,"      \n");

  }
 
  counter = 1;


  

  if(strcmp(ParseAttributionType(ATTRIBUTION_TYPE),"TREx"))
  {
    fprintf(summfile,"                                   \n");
    fprintf(summfile,"                                   \n");
    fprintf(summfile,"ATTRIBUTION ERRORS                 \n");
    fprintf(summfile,"                                   \n");
    fprintf(summfile,"%d. FCODE errors occur when a feature data set contains an FCODE which is\n",counter);
    fprintf(summfile,"   not recognized with the chosen attribution schema. \n");
    fprintf(summfile,"                                   \n");
    fprintf(summfile,"   FCODE errors found:           \n");
    AddTextFile(summfile,2,"FCODE errors",type);
    counter = counter + 1;
    fprintf(summfile,"                                   \n");

    if(DoBlankAttr()==1)
	{ 
      fprintf(summfile,"%d. Blank Attribute errors occur when a data table:\n",counter);
      fprintf(summfile,"   contains blank attributes (unpopulated with any value)   \n");
      fprintf(summfile,"                                   \n");
      fprintf(summfile,"   Blank Attribute errors found:           \n");
      AddTextFile(summfile,14,"Blank Attribute errors",type);
      counter = counter + 1;
      fprintf(summfile,"                                   \n");   
	}  

    if(ATTRTYPE_MGCP3())
	{ 
      fprintf(summfile,"%d. MGCP \"Mixed Null/Non-Null Optional Attribute\" errors\n",counter);
      fprintf(summfile,"   occur when a data table column for an optional attribute\n");
      fprintf(summfile,"   contains a mix of Null (-32768,-32768.0,\"N/A\") and non-Null values.\n");
      fprintf(summfile,"                                   \n");
      fprintf(summfile,"   MGCP \"Mixed Null/Non-Null Optional Attribute\" errors found:           \n");
      AddTextFile(summfile,15,"MGCP \"Mixed Null/Non-Null Optional Attribute\" errors",type);
      counter = counter + 1;
      fprintf(summfile,"                                   \n");
	} 

    fprintf(summfile,"%d. Invalid Case errors occur when:\n",counter);
    fprintf(summfile,"   - A recognized attribute is found for a feature             \n");
    fprintf(summfile,"   - The attribute has a known set of valid pick-list values   \n");
    fprintf(summfile,"   - The value assigned to the attribute is one of the valid values,\n");
    fprintf(summfile,"     but only after changing the case of at least one character.\n");

    if(ATTRTYPE_UFD1())
	{ 
      fprintf(summfile,"                     ------------or------------                                \n");
      fprintf(summfile,"   In the UFD1 attribution schema, a string value with at least\n");
      fprintf(summfile,"   one lower case letter (a-z) is assigned to a string attribute\n");
      fprintf(summfile,"   for a given fcode/geometry for which lower case letters are\n");
      fprintf(summfile,"   not allowed.                \n");
	} 

    fprintf(summfile,"                                   \n");
    fprintf(summfile,"   Invalid Case errors found:           \n");
    AddTextFile(summfile,5,"Invalid Case errors",type);
    counter = counter + 1;
    fprintf(summfile,"                                   \n");
    fprintf(summfile,"%d. Non Domain Specific Pick-list errors occur when:\n",counter);
    fprintf(summfile,"   - A recognized attribute is found for a feature             \n");
    fprintf(summfile,"   - The attribute has a known set of valid pick-list values   \n");
    fprintf(summfile,"   - The value assigned to the attribute is not one of the valid values\n");
    fprintf(summfile,"                                   \n");
    fprintf(summfile,"   Non Domain Specific Pick-list errors found:     \n");
    AddTextFile(summfile,3,"Non Domain Specific Pick-list errors",type);
    counter = counter + 1;
    fprintf(summfile,"                                   \n");
    AddTextFile(summfile,4,"SPECIAL",type);
    fprintf(summfile,"                                   \n");
    fprintf(summfile,"                                   \n");
  }


  if(type==1)
    {
      fprintf(summfile,"GEOMETRIC AND TOPOLOGIC INSPECTIONS\n");
      fprintf(summfile,"                                   \n");


      fprintf(summfile,"Inspection Profile               : %s\n",masterrun2);


      fprintf(summfile,"Types of Inspections Performed   : %d\n",GetConditionTypes());
      fprintf(summfile,"Total Number of Instances        : %d\n",GetConditionInstances());
      fprintf(summfile,"Conditions Detected              : %d\n",GetConditionCount());
      fprintf(summfile,"Inspection Time                  : %s\n",PrintTime(StartTime));
      fprintf(summfile,"                                   \n");
      fprintf(summfile,"Inspection                                            Instances  Conditions\n");
      PrintShortConditionList(summfile);
      fprintf(summfile,"                                 TOTAL                %8d     %8d\n",
	      GetConditionInstances(),GetConditionCount());
      fprintf(summfile,"                                   \n");

      if(RemovedOneDegree>=1)
	{ 
	  result = OneDegreeCheckOK(&totalbad);
	  fprintf(summfile,"1 or more instances of\n \"%s\", \"%s\", and/or\n \"%s\"\n",ErrorLookup[BNDRYUNDERSHT].name,ErrorLookup[LBNDUSHT].name,ErrorLookup[FEATOUTSIDE].name);
	  fprintf(summfile,"was not run because this project is not close enough to being contained\n");
	  fprintf(summfile,"within the closest 1 degree project box (%d vertices outside (>10000))\n",totalbad);
	}
      
      
    

    if(strcmp(ParseAttributionType(ATTRIBUTION_TYPE),"TREx"))
	{
      fprintf(summfile,"                                   \n");
      fprintf(summfile,"Relevant files (all found in the \"attribution_errors\" \nor \"summary_files\" folder of the project):\n"); 
      fprintf(summfile,"                                   \n");
      
      fprintf(summfile,"checksummary.txt       :  This file    \n");

      fprintf(summfile,"checkoptions.txt       :  An inspection specification file containing the\n");
      fprintf(summfile,"                          specifications used to generate the conditions\n");
      fprintf(summfile,"                          summarized above.\n");


      fprintf(summfile,"contentsummary.txt     :  A text file listing counts of features by\n");
      fprintf(summfile,"                          FCODE and geometry.\n");


      fprintf(summfile,"badshapes.txt          :  A text file listing the \"Zero-Part\n");
      fprintf(summfile,"                          Area/Line\" errors in detailed form.\n");

      fprintf(summfile,"nullshp.txt            :  A text file listing the \"Null Feature\"\n");
      fprintf(summfile,"                          errors in detailed form.\n");

      fprintf(summfile,"badcoord.txt           :  A text file listing the \"Invalid Coordinate\"\n");
      fprintf(summfile,"                          errors in detailed form.\n");

      fprintf(summfile,"badhole.txt            :  A text file listing the \"Invalid Cut-Out\"\n");
      fprintf(summfile,"                          errors in detailed form.\n");

      fprintf(summfile,"unkcolumn.txt          :  A text file listing the \"Unrecognized Column\n");
      fprintf(summfile,"                          Names\" in detailed form.\n");

      fprintf(summfile,"badtype.txt            :  A text file listing the \"Invalid Data Type\"\n");
      fprintf(summfile,"                          errors in detailed form.\n");

      fprintf(summfile,"emptyshapes.txt        :  A text file listing the \"Empty or Invalid Shapefiles\n");
      fprintf(summfile,"                          or Tables\" in detailed form.\n");

      if((ATTRTYPE_MGCP3())||(ATTRTYPE_MGCP4()))
	  { 
	    fprintf(summfile,"nofcodecolumn.txt      :  A text file listing the \"MGCP 'No FCODE Column'\"\n");
	    fprintf(summfile,"                          errors in detailed form.\n");
	  
	    fprintf(summfile,"badmgcpfilename.txt    :  A text file listing the \"MGCP Shapefile Naming\"\n");
	    fprintf(summfile,"                          errors in detailed form.\n");
	  
	    fprintf(summfile,"badshapetype.txt       :  A text file listing the \"MGCP 'Shape Type'\"\n");
	    fprintf(summfile,"                          errors in detailed form.\n");
	  
	    fprintf(summfile,"badlen.txt             :  A text file listing the \"MGCP 'Invalid Field\n");
	    fprintf(summfile,"                          Length'\" errors in detailed form.\n");
	  } 

      fprintf(summfile,"badfcode.txt           :  A text file listing the \"FCODE\" errors in\n");
      fprintf(summfile,"                          detailed form.\n");

      if((ATTRTYPE_MGCP3())||(ATTRTYPE_MGCP4()))
	  { 
	    fprintf(summfile,"blankattrval.txt       :  A text file listing the \"Blank Attribute errors\"\n");
	    fprintf(summfile,"                          in detailed form.\n");
	  
	    fprintf(summfile,"mgcpmixednull.txt      :  A text file listing the \"MGCP 'Mixed Null/Non-Null\n");
	    fprintf(summfile,"                          Optional Attribute'\" errors in detailed form.\n");
	  } 

      fprintf(summfile,"badcase.txt            :  A text file listing the \"Invalid case\"\n");
      fprintf(summfile,"                          errors in detailed form.\n");

      fprintf(summfile,"badattr.txt            :  A text file listing the \"Non Domain Specific\n");
      fprintf(summfile,"                          Pick-list\" errors in detailed form.\n");

      fprintf(summfile,"PickListErr.txt        :  A text file listing the \"Domain Specific\n");
      fprintf(summfile,"                          Pick-list\" errors in detailed form.\n");

      fprintf(summfile,"UnexpectedGeom.txt     :  A text file listing the \"Unexpected\n");
      fprintf(summfile,"                          FCODE-Geometry Pair\" errors in detailed form.\n");


      fprintf(summfile,"ValueRangeErr.txt      :  A text file listing the \"Value Range\"\n");
      fprintf(summfile,"                          errors in detailed form.\n");

      if(ATTRTYPE_MGCP3())
	  { 
	    fprintf(summfile,"ReqAttrNullValueErr.txt:  A text file listing the \"MGCP 'Required Attribute\n");
	    fprintf(summfile,"                          Assigned Null Value'\" errors in detailed form.\n");
	  } 

      fprintf(summfile,"UnexpectedAttr.txt     :  A text file listing the \"Unexpected Attribute\"\n");
      fprintf(summfile,"                          errors in detailed form.\n");

      fprintf(summfile,"MissingAttribute.txt   :  A text file listing the \"Missing Attribute Field Or Value\"\n");
      fprintf(summfile,"                          errors in detailed form.\n");
      
      if((ATTRTYPE_MGCP3())||(ATTRTYPE_MGCP4()))
	  { 
	    fprintf(summfile,"DependencyErr.txt      :  A text file listing the \"MGCP Attribute\n");
	    fprintf(summfile,"                          Dependency\" errors in detailed form.\n");
	  } 

      fprintf(summfile,"MetaDataErr.txt        :  A text file listing the \"Metadata\" errors\n");
      fprintf(summfile,"                          in detailed form.\n");

	} 
  } 

  fclose(summfile);


  if(QACRDEBUG==1)
  {
    printf("Total attr instances %d/%d\n",
	  TotalNGAAttrInstances,TotalMGCPAttrInstances);
  }


  
  if(type==1)
    {
      if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
	{
	  sprintf(outNGA_QACRfile, "%sQACR_files\\NGA_QACR.doc",  indirectory);
	  sprintf(outMGCP_QACRfile,"%sQACR_files\\MGCP_QACR.doc", indirectory);
	}
      else
	{
	  sprintf(outNGA_QACRfile, "%sQACR_files/NGA_QACR.doc",   indirectory);
	  sprintf(outMGCP_QACRfile,"%sQACR_files/MGCP_QACR.doc",  indirectory);
	}
      
      TotalCondInstances = GetConditionInstancesFound();
      
      TotalNGAInstances  = TotalNGAAttrInstances  + TotalCondInstances;
      TotalMGCPInstances = TotalMGCPAttrInstances + TotalCondInstances;
      
      if(QACRDEBUG==1)
	{
	  printf("Total Instances %d/%d\n",TotalNGAInstances,TotalMGCPInstances);
	}
      

	  if(1)
	{
	  if(TotalNGAInstances<=25)
	    {
	      sprintf(inNGA_QACRfile, "%s",GetQACRTemplate(1,1));
	      upperNGAlimit = 25;
	      mallocnum = 300000;
	    }
	  else if(TotalNGAInstances<=50)
	    {
	      sprintf(inNGA_QACRfile, "%s",GetQACRTemplate(1,2));
	      upperNGAlimit = 50;
	      mallocnum = 350000;
	    }
	  else if(TotalNGAInstances<=75)
	    {
	      sprintf(inNGA_QACRfile, "%s",GetQACRTemplate(1,3));
	      upperNGAlimit = 75;
	      mallocnum = 400000;
	    }
	  else if(TotalNGAInstances<=100)
	    {
	      sprintf(inNGA_QACRfile, "%s",GetQACRTemplate(1,4));
	      upperNGAlimit = 100;
	      mallocnum = 450000;
	    }
	  else if(TotalNGAInstances<=250)
	    {
	      sprintf(inNGA_QACRfile, "%s",GetQACRTemplate(1,5));
	      upperNGAlimit = 250;
	      mallocnum = 700000;
	    }
	  else
	    {
	      sprintf(inNGA_QACRfile, "%s",GetQACRTemplate(1,6));
	      upperNGAlimit = TOP_LIMIT;
	      mallocnum = 1200000;
	    }
	  
	  
	  
	  if(do_mgcp_qacr>0)
	    {
	      if(TotalMGCPInstances<=25)
		{
		  sprintf(inMGCP_QACRfile,"%s",GetQACRTemplate(2,1));
		  upperMGCPlimit = 25;
		  mallocnum = 300000;
		}
	      else if(TotalMGCPInstances<=50)
		{
		  sprintf(inMGCP_QACRfile,"%s",GetQACRTemplate(2,2));
		  upperMGCPlimit = 50;
		  mallocnum = 350000;
		}
	      else if(TotalMGCPInstances<=75)
		{
		  sprintf(inMGCP_QACRfile,"%s",GetQACRTemplate(2,3));
		  upperMGCPlimit = 75;
		  mallocnum = 400000;
		} 
	      else if(TotalMGCPInstances<=100)
		{
		  sprintf(inMGCP_QACRfile,"%s",GetQACRTemplate(2,4));
		  upperMGCPlimit = 100;
	  	  mallocnum = 450000;
		} 
	      else if(TotalMGCPInstances<=250)
		{
		  sprintf(inMGCP_QACRfile,"%s",GetQACRTemplate(2,5));
		  upperMGCPlimit = 250;
		  mallocnum = 700000;
		} 
	      else 
		{
		  sprintf(inMGCP_QACRfile,"%s",GetQACRTemplate(2,6));
		  upperMGCPlimit = TOP_LIMIT;
		  mallocnum = 1200000;
		} 
	    }
	  
	  
	  
	  
	  if(do_nga_qacr>0)
	    {
	      nga_qacr_in = fopen(inNGA_QACRfile,"rb");
	      if(nga_qacr_in==NULL)
		{   
		  printf("Error: unable to open %s for read!\n",inNGA_QACRfile);
		  free_qacr_globals();
		  do_nga_qacr  = 0;
		  do_mgcp_qacr = 0;
		}
	    }
	  
	  
	  if(do_mgcp_qacr>0)
	    {
	      mgcp_qacr_in = fopen(inMGCP_QACRfile,"rb");
	      if(mgcp_qacr_in==NULL)
		{   
		  printf("Error: unable to open %s for read!\n",inMGCP_QACRfile);
		  if(do_nga_qacr>0)
		    {
		      fclose(nga_qacr_in);
		    }
		  free_qacr_globals();
		  do_nga_qacr  = 0;
		  do_mgcp_qacr = 0;
		}  
	    }
	  
	  
	  if(do_nga_qacr>0)
	    {
		  nga_qacr_out = fopen(outNGA_QACRfile,"wb");
	      if(nga_qacr_out==NULL)
		{   
		  printf("Error: unable to open %s for write!\n",outNGA_QACRfile);
		  fclose(nga_qacr_in);
		  if(do_mgcp_qacr>0)
		    {
		      fclose(mgcp_qacr_in);
		    }
		  free_qacr_globals();
		  do_nga_qacr  = 0;
		  do_mgcp_qacr = 0;
		}   
	    }
	  
	  if(do_mgcp_qacr>0)
	    {
	      mgcp_qacr_out = fopen(outMGCP_QACRfile,"wb");
	      if(mgcp_qacr_out==NULL)
		{   
		  printf("Error: unable to open %s for write!\n",outMGCP_QACRfile);
		  fclose(mgcp_qacr_in);
		  if(do_nga_qacr>0)
		    {
		      fclose(nga_qacr_in);
		      fclose(nga_qacr_out);
		    }
		  free_qacr_globals();
		  do_nga_qacr  = 0;
		  do_mgcp_qacr = 0;
		} 
	    }
	  
	  
	  if(do_nga_qacr>0)
	    {
	      numHbytesNGA  = fread(&NGAheader[0], 1,QACRhsize,nga_qacr_in);
	      
	      if(numHbytesNGA!=QACRhsize)
		{
		  printf("error (1) reading %s: %d %d\n",inNGA_QACRfile,numHbytesNGA,QACRhsize);
		  fclose(nga_qacr_in);
		  fclose(nga_qacr_out);
		  if(do_mgcp_qacr>0)
		    {
		      fclose(mgcp_qacr_in);
		      fclose(mgcp_qacr_out);
		    }
		  free_qacr_globals();
		  do_nga_qacr  = 0;
		  do_mgcp_qacr = 0;
		} 
	    }
	  
	  
	  if(do_mgcp_qacr>0)
	    {
	      numHbytesMGCP = fread(&MGCPheader[0],1,QACRhsize,mgcp_qacr_in);
	  
	      if(numHbytesMGCP!=QACRhsize)
		{ 
		  printf("error (2) reading %s: %d %d\n",inMGCP_QACRfile,numHbytesMGCP,QACRhsize);
		  if(do_nga_qacr>0)
		    {
		      fclose(nga_qacr_in);
		      fclose(nga_qacr_out);
		    }
		  fclose(mgcp_qacr_in);
		  fclose(mgcp_qacr_out);
		  free_qacr_globals();
		  do_nga_qacr  = 0;
		  do_mgcp_qacr = 0;
		} 
	    }
	  
	  
	  
	  
	  
	  if(do_nga_qacr>0)
	    {
	      wholeNGAfile = (char *)malloc(mallocnum);
	      
	      if(wholeNGAfile==NULL)
		{
		  printf("bad wholeNGAfile\n");
		  ExitWrapper(-1);
		}  
	      numbytesNGA  = fread(&wholeNGAfile[0], 1,mallocnum,nga_qacr_in);
	      NGAstartloc  = GetStartLoc(wholeNGAfile,numbytesNGA,1);
	      
	      if(NGAstartloc<0)
		{
		  printf("error (3) reading %s\n",inNGA_QACRfile);
		  free_qacr_globals();
		  free(wholeNGAfile);
		  fclose(nga_qacr_in);
		  fclose(nga_qacr_out); 
		  if(do_mgcp_qacr>0)
		    {
		      fclose(mgcp_qacr_in);        
		      fclose(mgcp_qacr_out);		
		    }
		  do_nga_qacr  = 0;
		  do_mgcp_qacr = 0;
		} 
	      
	      if(QACRDEBUG==1)
		{
		  printf("startlocs %d  numbytes %d\n",
			 NGAstartloc,
			 numbytesNGA);
		}
	      
	      fwrite(&wholeNGAfile[0] ,1,NGAstartloc, nga_qacr_out);
	      current_line_nga  = 1;
	      
	    }
	  
	  
	  
	  if(do_mgcp_qacr>0)
	    {
	      wholeMGCPfile = (char *)malloc(mallocnum);
	      
	      if(wholeMGCPfile==NULL)
		{  
		  printf("bad wholeMGCPfile\n");
		  ExitWrapper(-1);;
		}  
	      numbytesMGCP = fread(&wholeMGCPfile[0],1,mallocnum,mgcp_qacr_in);
	      MGCPstartloc = GetStartLoc(wholeMGCPfile,numbytesMGCP,2);
	      
	      if(MGCPstartloc<0)
		{
		  printf("error (4) reading %s\n",inMGCP_QACRfile);
		  free_qacr_globals();
		  free(wholeMGCPfile);
		  fclose(mgcp_qacr_in);        
		  fclose(mgcp_qacr_out);		
		  if(do_nga_qacr>0)
		    {
		      free(wholeNGAfile);
		      fclose(nga_qacr_out); 
		      fclose(nga_qacr_in);
		    }
		  do_nga_qacr  = 0;
		  do_mgcp_qacr = 0;
  		} 
	      
	      if(QACRDEBUG==1)
		{
		  printf("mgcp startloc %d  numbytes %d\n",
			 MGCPstartloc,
			 numbytesMGCP);
		}

	      
	      fwrite(&wholeMGCPfile[0],1,MGCPstartloc,mgcp_qacr_out);
	      current_line_mgcp = 1;
	    }
	  
	  
	  
	  
	  if((do_nga_qacr+do_mgcp_qacr)>0)
	    {
	      for(i=1;i<=CONDITION_DEFINITIONS;i++)
		{
		  if((ErrorLookup[i].active==1)&&(ErrorLookup[i].number>0))
		    {
		      
		      if(do_nga_qacr>0)
			{
			  if(current_line_nga>upperNGAlimit)  
			    {
			      break;
			    }
			  
			  if(current_line_nga>TotalCondInstances)
			    {
			      printf("error creating QACR (1a): %d/%d\n",current_line_nga,TotalCondInstances);
			      break;
			    } 
			  
			  WriteSequence(nga_qacr_out,current_line_nga,
					ErrorLookup[i].name,
					ErrorLookup[i].Annotation,
					ErrorLookup[i].number);
			  
			  current_line_nga  = current_line_nga  + 1;
			  
			  NGAstartloc  = NGAstartloc  + 4 + 75 + 150 + 10 + 7;
			}
		      
		      
		      if(do_mgcp_qacr>0)
			{
			  if(current_line_mgcp>upperMGCPlimit)  
			    {
			      break;
			    }
			  
			  if(current_line_mgcp>TotalCondInstances)
			    {
			      printf("error creating QACR (1): %d/%d\n",current_line_mgcp,TotalCondInstances);
			      break;
			    } 
			  
			  WriteSequence(mgcp_qacr_out,current_line_mgcp,
					ErrorLookup[i].name,
					ErrorLookup[i].Annotation,
					ErrorLookup[i].number);
			  
			  current_line_mgcp = current_line_mgcp + 1;
			  
			  MGCPstartloc = MGCPstartloc + 4 + 75 + 150 + 10 + 7;
			}
		    }  
		  
		  
		  if(ErrorLookup[i].num_clones>0)
		    {
		      for(j=0;j<CLONE_DEFINITIONS;j++)
			{  
			  if(
			     (CloneErrorLookup[j].active==1)       &&
			     (CloneErrorLookup[j].number>0)        &&
			     (CloneErrorLookup[j].CloneNumber==i)
			     )
			    {
			      if(do_nga_qacr>0)
				{
				  if(current_line_nga>upperNGAlimit)
				    {
				      break;
				    }
				  
				  if(current_line_nga>TotalCondInstances)
				    {
				      printf("error creating QACR (2): %d/%d\n",current_line_nga,TotalCondInstances);
				      break;
				    } 
				  
				  WriteSequence(nga_qacr_out,current_line_nga,
						ErrorLookup[i].name,
						CloneErrorLookup[j].Annotation,
						CloneErrorLookup[j].number);
				  
				  current_line_nga  = current_line_nga  + 1;
				  NGAstartloc  = NGAstartloc  + 4 + 75 + 150 + 10 + 7;
				}
			      
			      if(do_mgcp_qacr>0)
				{
				  if(current_line_mgcp>upperMGCPlimit)
				    {
				      break;
				    } 
				  
				  if(current_line_mgcp>TotalCondInstances)
				    {
				      printf("error creating QACR (2a): %d/%d\n",current_line_mgcp,TotalCondInstances);
				      break;
				    } 
				  
				  WriteSequence(mgcp_qacr_out,current_line_mgcp,
						ErrorLookup[i].name,
						CloneErrorLookup[j].Annotation,
						CloneErrorLookup[j].number);
				  
				  current_line_mgcp = current_line_mgcp + 1;
				  MGCPstartloc = MGCPstartloc + 4 + 75 + 150 + 10 + 7;
				}
			    }
			} 
		    } 
		} 
	    } 
	} 
    } 
  
  
  
  
  
  if(do_nga_qacr>0)
    {
      
      
      for(i=0;i<TotalNGAAttrInstances;i++)
	{
	  if(current_line_nga>upperNGAlimit)
	    {
	      break;
	    }
	  WriteSequence(nga_qacr_out,current_line_nga,nga_qacr_lhs[i],nga_qacr_rhs[i],nga_qacr_counts[i]);			      
	  NGAstartloc  = NGAstartloc  + 4 + 75 + 150 + 10 + 7;
	  current_line_nga = current_line_nga + 1;
	}
    }
  
  if(do_mgcp_qacr>0)
    {
      for(i=0;i<TotalMGCPAttrInstances;i++)
	{
	  if(current_line_mgcp>upperMGCPlimit)
	    {
	      break;
	    }
 	  WriteSequence(mgcp_qacr_out,current_line_mgcp,mgcp_qacr_lhs[i],mgcp_qacr_rhs[i],mgcp_qacr_counts[i]);			      
	  MGCPstartloc  = MGCPstartloc  + 4 + 75 + 150 + 10 + 7;
	  current_line_mgcp = current_line_mgcp + 1;
	}
    }
  
  
  
  
  if(  ((do_nga_qacr+do_mgcp_qacr)>0)  &&  (type==1) )
    {
      
      
      
      if((do_nga_qacr>0)   )
	{
	  addon = 0;
	  if(upperNGAlimit==TOP_LIMIT)
	    {
	      if(current_line_nga<=TOP_LIMIT)
		{
		  addon = 1;
		}  
	    }  
	  
	  for(i=current_line_nga;i<=upperNGAlimit+addon;i++)
	    {
	      WriteSequence(nga_qacr_out, i,"   ","   ",-1);			      
	      NGAstartloc  = NGAstartloc  + 4 + 75 + 150 + 10 + 7;
	    }  
	  
	  
	  if(current_line_nga>TOP_LIMIT)
	    {
	      sprintf(temp,"QACR generation limited to %d entries",TOP_LIMIT);
	      WriteSequence(nga_qacr_out, i,temp,"   ",-1);	
	      NGAstartloc  = NGAstartloc  + 4 + 75 + 150 + 10 + 7;
	    }	
	  
	  
	  fwrite(&wholeNGAfile [NGAstartloc], 1,numbytesNGA -NGAstartloc, nga_qacr_out);
	  free(wholeNGAfile);
	  fclose(nga_qacr_in);
	  fclose(nga_qacr_out); 
	  
	  if(TotalNGAInstances==0)
	  {
 	    printf("BLANK NGA_QACR.doc file saved to %sQACR_files\n",indirectory);
	  }
	  else
	  {
 	    printf("NGA_QACR.doc file saved to %sQACR_files\n",indirectory);
	  }
	}
      
      
      
      
      
      
      if((do_mgcp_qacr>0)    )
	{
	  addon = 0;
	  if(upperMGCPlimit==TOP_LIMIT)
	    {
	      if(current_line_mgcp<=TOP_LIMIT)
		{ 
		  addon = 1;
		}  
	    } 
	  
	  for(i=current_line_mgcp;i<=upperMGCPlimit+addon;i++)
	    { 
	      WriteSequence(mgcp_qacr_out,i,"   ","   ",-1);
	      MGCPstartloc = MGCPstartloc + 4 + 75 + 150 + 10 + 7;
	    }  
	  
	  
	  
	  if(current_line_mgcp>TOP_LIMIT)
	    {
	      sprintf(temp,"QACR generation limited to %d entries",TOP_LIMIT);
	      WriteSequence(mgcp_qacr_out, i,temp,"   ",-1);	
	      MGCPstartloc  = MGCPstartloc  + 4 + 75 + 150 + 10 + 7;
	    }	
	  
	  fwrite(&wholeMGCPfile[MGCPstartloc],1,numbytesMGCP-MGCPstartloc,mgcp_qacr_out);
	  free(wholeMGCPfile);
	  fclose(mgcp_qacr_in);        
	  fclose(mgcp_qacr_out);

	  if(TotalMGCPInstances==0)
	  {
	    printf("BLANK MGCP_QACR.doc file saved to %sQACR_files\n",indirectory);
	  }
	  else
	  {
	    printf("MGCP_QACR.doc file saved to %sQACR_files\n",indirectory);
	  }
	} 
      
      
      free_qacr_globals();
      
      TotalNGAAttrInstances  = 0;
      TotalMGCPAttrInstances = 0;
      
    }
  
  
  if(type==2)
    {
      return;
    }
  
  
  
  
  
  sprintf(outfile,"%scheckoptions.txt",outsumdirectory);
  
  summfile = fopen(outfile,"w");
  if(summfile==NULL)
    {
      printf("Fatal error: unable to open %s for write!\n",outfile);
      ExitWrapper(-1);
    }
  
  SaveAllSettingsFiles(summfile,1,0);
  fclose(summfile);
  
  
  if(type==3)
  {
    printf("Project summary file saved to %s\n",outsummfile);
  }
  else
  {
    printf("Check summary file saved to %s\n",outsummfile);
  }
}


void ZeroThenExecuteCallback(Widget w, XtPointer userData, XtPointer callData)
{
  int type = (int)userData;

  

  zerooutCallback((Widget)NULL, (XtPointer)1, (XtPointer) 0);

  if(type==1)
  {
    CHECK_DATA_SET = 1;
  }
  ExecuteCallback(drawing_a,(XtPointer)0,(XtPointer)0);
  CHECK_DATA_SET = 0;
  
}


void AskZero(int type)
{
  Widget dialog;
  XmString t;
  Arg args[15];
  char message[1000];
  int n;

  sprintf(message,"Conditions currently exist in memory.\n\n\
You must remove these conditions before performing new analyses.\n\
You may save them using the \"Save Condition Report...\" item\n\
under the \"File\" menu, or you may remove them now and begin\n\
inspecting.");

  
  t = XmStringCreateLtoR (message,XmSTRING_DEFAULT_CHARSET);
  
  n = 0;
  XtSetArg(args[n], XmNokLabelString,     STRING("Remove conditions and begin inspecting"));          n++;
  XtSetArg(args[n], XmNdialogTitle,       STRING("Cannot begin analysis with current conditions")); n++;
  XtSetArg(args[n], XmNmessageString,     t);                                                       n++;
  
  dialog = XmCreateQuestionDialog (drawing_a, "Cannot begin analysis with current conditions", args, n);
  
  XtUnmanageChild (XmMessageBoxGetChild (dialog, XmDIALOG_HELP_BUTTON));
  
  XtAddCallback (dialog, XmNokCallback, ZeroThenExecuteCallback, (XtPointer)type);
  
  XtManageChild (dialog);
  XtPopup  (XtParent(dialog), XtGrabNone);
  XmStringFree (t);
}



void GenerateNetworkViewer()
{
  extern int dead_network;

  
  if(dead_network==1)
  {
    BuildNetworkViewer(drawing_a,(XtPointer)NULL,(XtPointer)NULL);
  }
  else
  {
    printf("Need to rebuild network viewer\n\n\n");
    BuildNetworkViewer(drawing_a,(XtPointer)1,(XtPointer)NULL);
  }
}




void ExecuteCallback(Widget w, XtPointer userData, XtPointer callData)
{
  char *message;
  char diecommand[1000],filename[1000];
  int i,success,checkon=0,conditions_present=0,bad_lines,lines_to_skip,result;
  int type = (int)userData,totalconds=0;
  extern Widget networkhead[3];
  extern int ADDNETS,dead_network,Current_net_head;



  if(running==1)
    {
      not_while_running(w,"You are already running!",1108,"Illegal Manuever",1);
      return;
    }
  


  if(type>0)  
  {
    DOALLCELLS = 1;
  }
  
  if(DOALLCELLS==1)
  { 
    load_modules = 1;
  }


  if(type>0)
    {
      

      revertCallback((Widget)NULL,(XtPointer)5,(XtPointer)5);
      
      
      if((head_in_use==0)&&(deader_head==0))
	{
	  XtPopdown(param_head);
	  XtDestroyWidget(param_head);
	  deader_head=1;
	  head_in_use=1;
	}
      else if((head_in_use==1)&&(deader_phead==0))
	{
	  XtPopdown(param2_head);
	  XtDestroyWidget(param2_head);
	  deader_phead=1;
	  head_in_use=0;
	}
    }


  if(type==1)
    {
      
      result = GenerateExeFiles(1);   
      
      if(result==0)
	{
	  return;
	}
      
      if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
	{
	  sprintf(filename,"%sinspection_files\\DFEG_master.txt",indirectory);
	} 
      else
	{
	  sprintf(filename,"%sinspection_files/DFEG_master.txt",indirectory);
	}
      
      sprintf(masterrun,"DFEG_master");
    }
  else if(type==3)
    {  
      result = GenerateExeFiles(2);   
      
      if(result==0)
	{
	  return;
	}
      
      if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
	{
	  sprintf(filename,"%sinspection_files\\MGCP_master.txt",indirectory);
	} 
      else
	{
	  sprintf(filename,"%sinspection_files/MGCP_master.txt",indirectory);
	} 
      
      sprintf(masterrun,"MGCP_master");
      
    }
  else if(type==4)
    {  
      result = GenerateExeFiles(3);
      
      if(result==0)
	{
	  return;
	}
      
      if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
	{
	  sprintf(filename,"%sinspection_files\\UFD1_master.txt",indirectory);
	} 
      else
	{
	  sprintf(filename,"%sinspection_files/UFD1_master.txt",indirectory);
	} 
      
      sprintf(masterrun,"UFD1_master");
      
    }
  else if(type==5)
    {  
      result = GenerateExeFiles(4);
      
      if(result==0)
	{
	  return;
	}
      
      if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
	{
	  sprintf(filename,"%sinspection_files\\UFD3_master.txt",indirectory);
	} 
      else
	{
	  sprintf(filename,"%sinspection_files/UFD3_master.txt",indirectory);
	} 
      
      sprintf(masterrun,"UFD3_master");
      
    }
  else if(type==11)
    {
      result = GenerateExeFiles(11);
      
      if(result==0)
	{
	  return;
	}
      
      if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
	{
	  sprintf(filename,"%sinspection_files\\TDS_master.txt",indirectory);
	} 
      else
	{
	  sprintf(filename,"%sinspection_files/TDS_master.txt",indirectory);
	} 
      
      sprintf(masterrun,"TDS_master");
      
    }
  else if(type==10)
    {  
      result = GenerateExeFiles(9);
      
      if(result==0)
	{
	  return;
	}
      
      if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
	{
	  sprintf(filename,"%sinspection_files\\AFD_master.txt",indirectory);
	} 
      else
	{
	  sprintf(filename,"%sinspection_files/AFD_master.txt",indirectory);
	} 
      
      sprintf(masterrun,"AFD_master");
      
    }
  else if(type==12)
    {
      result = GenerateExeFiles(12);
      
      if(result==0)
	{
	  return;
	}
      
      if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
	{
	  sprintf(filename,"%sinspection_files\\TREX_master.txt",indirectory);
	} 
      else
	{
	  sprintf(filename,"%sinspection_files/TREX_master.txt",indirectory);
	} 
      
      sprintf(masterrun,"TREX_master");
      
    }
  else if(type!=0)
    {
      XBell(mydisplay,50);
      printf("bad type %d to ExecuteCallback\n",type);
      type = 0;
    }
  

  if(type>0)
    {
      batch_mode = 1;
      
      printf("loading %s\n",filename);
      
      lines_to_skip = FindEDCSInFile(filename);
      ApplyExecutionOptions(filename,0);
      bad_lines = DoBatchEDCSStuff((Widget)NULL,filename,lines_to_skip,1);

      batch_mode = 0;
    }




  for(i=1;i<=CONDITION_DEFINITIONS;i++)
    {
      if(ErrorLookup[i].active==1)
	{
	  checkon = 1;
	}
      if(ErrorLookup[i].number>0)
	{
	  conditions_present = 1;
	}
    }


  for(i=0;i<CLONE_DEFINITIONS;i++)
    {	  
      if(CloneErrorLookup[i].active==1)
	{
	  checkon = 1;
	}
      if(CloneErrorLookup[i].number>0)
	{
	  conditions_present = 1;
	}
    }
  
  
  
  if(checkon==0)
    {
      not_while_running(w,"No conditions activated.\n\
Conditions may be activated by selecting the\n\
\"Inspection Options...\" option under the \"Inspection\" menu.",
			1109,"Illegal Manuever",1);
      return;
    }



  if(conditions_present==1)
    {
	  if(NETS_ONLY==0)
	  {
        AskZero(0);
        return;
	  }
	  else
	  {
		 printf("\n\nNOT ASKING ABOUT EXISTING CONDITIONS\n");
	  }
    }



  for(i=1;i<=CONDITION_DEFINITIONS;i++)
    {
      ErrorLookup[i].numberNets = 0;
 
	  if((ADDNETS>0)||(NETS_ONLY>0))
	  {
         
		 if(ErrorLookup[i].NETpos_list_made>0)
		 { 
	       free(ErrorLookup[i].NETpos_list);
	       ErrorLookup[i].NETpos_list_made = 0;
		 }   
	  } 

	  if(NETS_ONLY==0)
	  {
	    
        if(ErrorLookup[i].pos_list_made>0)
		{ 
	      free(ErrorLookup[i].pos_list);
	      ErrorLookup[i].pos_list_made = 0;
		}  
	  } 
  }

  for(i=0;i<CLONE_DEFINITIONS;i++)
    {
      CloneErrorLookup[i].numberNets = 0;


	  if((ADDNETS>0)||(NETS_ONLY>0))
	  {
        

        if(CloneErrorLookup[i].NETpos_list_made>0)
		{  
	      free(CloneErrorLookup[i].NETpos_list);
	      CloneErrorLookup[i].NETpos_list_made = 0;
		}  
	  }

	  if(NETS_ONLY==0)
	  {
	    
        if(CloneErrorLookup[i].pos_list_made>0)
		{ 
	      free(CloneErrorLookup[i].pos_list);
	      CloneErrorLookup[i].pos_list_made = 0;
		}  
	  } 
  }
  

if((ADDNETS>0)||(NETS_ONLY>0)||(NumNetsLoaded==0))
{
  sprintf(diecommand,"%snetworkdata.bin",outdirectory);
  ZeroNetworkFile(diecommand);
  NumNetsLoaded = 0;


  
  if(dead_network==0)
  {
    XtPopdown(networkhead[Current_net_head]);
  }

}




  if((input_source==1)&&(output_source==1)&&(load_modules==1))
    {
      
      if(DOALLCELLS > 0)
	{
	  iLimit = MaxXindex;
	  jLimit = MaxYindex;
	  iStart = 0;
	  jStart = 0;

	  
	}
      else
	{
	  iStart = FromI;
	  iLimit = ToI;
	  jStart = FromJ;
	  jLimit = ToJ;
	}      


      if(DEBUG==1){printf("Ready to go in %d %d %d %d\n",iStart,iLimit,jStart,jLimit);}

      set_cursor(mydisplay,mywindow,WATCH);

      XFlush(mydisplay);
      XmUpdateDisplay(drawing_a);

      STOP_FLAG = 0;

	  num_shapes_processed = 0;

      success = ICheckRegion(iStart,iLimit,jStart,jLimit);

      
      ResetBOoptions();

      ResetKeepDismiss(1);      

      if(ConsultPreviouslyIgnored==1)
	{
	  DismissPreviouslyIgnored();
	}

      if(success==1)
	{
	  reporthandleCallback((Widget)NULL, (XtPointer)3, (XtPointer)NULL );      	  

	  UpdateSummaryInfo(2," ",NULL,"Data Inspection Summary");
 	}
      else
	{
	  if(RUNNING_INFO==1)
	    { 	  
	      XtDestroyWidget(running_info);
	      RUNNING_INFO=0;
	    }
	  cleanse_events();
	  set_cursor(mydisplay,mywindow,GOOD);
	  
	  return;
	}



      if(NGA_TYPE==1)
	{
	  WriteSummaryReport(1);
	}
      
      


      if(DEBUG==1){printf("all computations done...cleaning up\n");}


      
      for(i=1;i<=CONDITION_DEFINITIONS;i++)
	  {

         if(ErrorLookup[i].number>0)
		 {
	       totalconds = totalconds + ErrorLookup[i].number;

		   if(NETS_ONLY==0)
		   {
			 
	         ErrorLookup[i].viewall     = 1;
	         ErrorLookup[i].viewsome    = 0;
		   }

		   if((ADDNETS>0)||(NETS_ONLY>0))
		   {
			 
	         ErrorLookup[i].viewallNET  = 0;
	         ErrorLookup[i].viewsomeNET = 0;
		   }
		 }
         else
		 {

		   if(NETS_ONLY==0)
		   {
			 
	         ErrorLookup[i].viewall     = 0;
	         ErrorLookup[i].viewsome    = 0;
		   }

		   if((ADDNETS>0)||(NETS_ONLY>0))
		   {
			 
	         ErrorLookup[i].viewallNET  = 0;
	         ErrorLookup[i].viewsomeNET = 0;
		   }
		 }
	}
      for(i=0;i<CLONE_DEFINITIONS;i++)
	  { 
        if(CloneErrorLookup[i].number>0)
		{
	      totalconds = totalconds + CloneErrorLookup[i].number;

		   if(NETS_ONLY==0)
		   {
			 
	         CloneErrorLookup[i].viewall     = 1;
	         CloneErrorLookup[i].viewsome    = 0;
		   }

		  if((ADDNETS>0)||(NETS_ONLY>0))
		  {
			 
	         CloneErrorLookup[i].viewallNET  = 0;
	         CloneErrorLookup[i].viewsomeNET = 0;
		  }
		}
        else
		{
		  if(NETS_ONLY==0)
		  {
			
	        CloneErrorLookup[i].viewall     = 0;
	        CloneErrorLookup[i].viewsome    = 0;
		  }

		  if((ADDNETS>0)||(NETS_ONLY>0))
		  {
			
	        CloneErrorLookup[i].viewallNET  = 0;
	        CloneErrorLookup[i].viewsomeNET = 0;
		  }
		}
	  }
	
      
      if(RUNNING_INFO==1)
	{
	  if( (totalconds>0) &&  (NETS_ONLY==0) )
	    {
		  
	      XtVaSetValues(running_info,XmNcancelLabelString, STRING("Stop Drawing Conditions"),NULL);
	    }
	  else
	    {
	      XtVaSetValues(running_info,XmNcancelLabelString, STRING("OK"),NULL);
	    }
	}
      

	  if(NETS_ONLY!=1)
	  {
        GenerateErrorEditor(0);
	  }


	  if((ADDNETS>0)||(NETS_ONLY==1))
	  {
        GenerateNetworkViewer();
	  }



      cleanse_events();
      set_cursor(mydisplay,mywindow,GOOD);

      return;
    }
  else
    {
      if((load_modules==0)&&(input_source==0)&&(output_source==0))
	{
	  if(NGA_TYPE==1)
	    {
	      message ="You must select a GAIT project before inspecting.\n\n\
Also, you must select which regions the tool is to\n\
be applied to.\n";
	    }
	  else
	    {
	      message ="You must select an input source data directory\n\
and an output directory before executing.\n\n\
Also, you must select which regions the tool is to\n\
be applied to.\n";
	    }
	}
      else if((input_source==0)&&(output_source==0))
	{
	  if(NGA_TYPE==1)
	    {
	      message ="You must select a GAIT project before inspecting";
	    }
	  else
	    {
	      message ="You must select an input source data directory\n\
and an output directory before executing.";
	    }
	}
      else if((input_source==0)&&(load_modules==0))
	{
	  if(NGA_TYPE==1)
	    {
	      message ="You must open a GAIT project before inspecting.\n\n\
Also, you must select which regions the tool is to\n\
be applied to.\n";
	    }
	  else
	    { 
	      message ="You must select an input data source directory before executing.\n\n\
Also, you must select which regions the tool is to\n\
be applied to.\n";
	    }
	}
      else  if(input_source==0)
	{
	  if(NGA_TYPE==1)
	    {
	      message ="You must open a GAIT project before executing.";
	    }
	  else
	    {
	      message ="You must select an input data source directory before executing.";
	    }
	}
      else  if((output_source==0)&&(load_modules==0))
	{
	  message ="You must select an output directory before executing.\n\n\
Also, you must select which regions the tool is to\n\
be applied to.\n";
	}
      else  if(output_source==0)
	{
	  message ="You must select an output directory before executing.";
	}
      else  if(load_modules==0)
	{
	  message ="You must select which regions the tool is to\n\
be applied to.\n";
	}
      not_while_running(XtParent(w),message,1110,"Not enough data to proceed",1);     
    }
}





void SavePixmapToFile(Pixmap pixmap_to_save, int type)
{
  XImage *myimage;
  XColor thiscolor;
  FILE *infile;
  unsigned char red_found[5000],green_found[5000],blue_found[5000],thisUC;
  char bitfolder[1000],filename[1000];
  short int thisshort;
  int num_colors_found = 0,foundcolor,colsize,thisI,i,j,k;
  unsigned long color_ind_found[5000],temp;

  
    
  sprintf(bitfolder,"%sbitmaps",indirectory);
  
  if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
    {
      strcat(bitfolder,"\\");
    }
  else
    {
      strcat(bitfolder,"/");
    }
  
  sprintf(filename,"%sconsolidated.bin",bitfolder);

  infile = fopen(filename,"wb");
  if(infile==NULL)
    {
      XBell(mydisplay,50);
      printf("could not open %s for write\n",filename);
    }


  for(i=0;i<5000;i++)
    {
      color_ind_found[i] = 0;
    }
  
  myimage = XGetImage(mydisplay,pixmap_to_save,0,0,width,height,XAllPlanes(),ZPixmap);
  
  
  for(i=0;i<height;i++)
    {      
      for(j=0;j<width;j++)
	{
	  temp = XGetPixel(myimage,j,i);
	  
	  thiscolor.red   = 0;
	  thiscolor.green = 0;
	  thiscolor.blue  = 0;
	  thiscolor.pixel = temp;
	  
	  foundcolor = 0;
	  
	  for(k=0;k<num_colors_found;k++)
	    {
	      if(color_ind_found[k]==temp)
		{
		  foundcolor = 1;
		}
	    }
	  
	  if(foundcolor==0)
	    {
	      if(!XQueryColor(mydisplay,cmap,&thiscolor))
		{
		  printf("bad color!\n");
		}
	      else
		{
		  red_found  [num_colors_found]  =  (unsigned char)(thiscolor.red  /256);
		  green_found[num_colors_found]  =  (unsigned char)(thiscolor.green/256);
		  blue_found [num_colors_found]  =  (unsigned char)(thiscolor.blue /256);
		  		  
		  if(num_colors_found<4990)
		    {
		      color_ind_found[num_colors_found] = temp;
		      num_colors_found = num_colors_found + 1;
		    }
		  else
		    {
		      printf("large number of colors\n");
		    }
		}
	    }
	}
    }



  
  
  fwrite(&num_colors_found,SzI,1,infile);
  
  if(num_colors_found<255)
    {
      colsize = SzUC;
    }
  else if(num_colors_found<32000)
    {
      colsize = SzShort;
    }
  else
    {
      colsize = SzI;
    }
  

  fwrite(&colsize,SzI,1,infile);


  for(i=0;i<num_colors_found;i++)
    {
      fwrite(&red_found[i]  ,SzUC,1,infile);
      fwrite(&green_found[i],SzUC,1,infile);
      fwrite(&blue_found[i] ,SzUC,1,infile);
      
    }



  for(i=0;i<height;i++)
    {      
      for(j=0;j<width;j++)
	{
	  temp = XGetPixel(myimage,j,i);
	  
	  foundcolor = -1;
	  
	  for(k=0;k<num_colors_found;k++)
	    {
	      if(color_ind_found[k]==temp)
		{
		  foundcolor = k;
		  break;
		}
	    }
	  
	  if(foundcolor<0)
	    {
	      printf("could not find color on second pass\n");
	      foundcolor = 0;
	    }
	  
	  if(colsize==SzUC)
	    {
	      thisUC = (unsigned char)foundcolor;
	      fwrite(&thisUC     ,SzUC,   1,infile);
	    }
	  else if(colsize==SzShort)
	    {
	      thisshort = (short int)foundcolor;
	      fwrite(&thisshort  ,SzShort,1,infile);
	    }
	  else if(colsize==SzI)
	    {
	      thisI = (int)foundcolor;
	      fwrite(&thisI      ,SzI,    1,infile);
	    }
	}
    }

  XDestroyImage(myimage);

  printf("wrote toplevel data with %d colors (type %d)\n",num_colors_found,type);

  fclose(infile);

}





int UsePreviousPixmap()
{
  Pixmap temp_bitmap;
  XColor mycolor;
  FILE *infile;
  char bitfolder[1000],filename[1000];
  unsigned long colors_found[5000];
  int num_colors_found=0,i,j,layer,Ijunk,Ijunk2,colsize,thisI,result;
  short int thiscolor;
  unsigned char red_color,green_color,blue_color,thisUC;


  sprintf(bitfolder,"%sbitmaps",indirectory);
  
  if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
    {
      strcat(bitfolder,"\\");
    }
  else
    {
      strcat(bitfolder,"/");
    }

  sprintf(filename,"%sconsolidated.bin",bitfolder);

  infile = fopen(filename,"rb");
  if(infile==NULL)
    {
      printf("could not find previous pixmap, creating a new one\n");
      return 0;
    }

  printf("reading previous pm...\n");

  

  SEEIT_fread_int(&num_colors_found,infile);
  SEEIT_fread_int(&colsize,infile);


  for(i=0;i<num_colors_found;i++)
    {
      fread(&red_color,  SzUC,1,infile);
      fread(&green_color,SzUC,1,infile);
      fread(&blue_color, SzUC,1,infile);
 
      

      mycolor.red   = red_color   * 256;
      mycolor.green = green_color * 256;
      mycolor.blue  = blue_color  * 256;
      
      if (!XAllocColor (mydisplay, cmap, &mycolor)) 
	{
	  printf("couldn't XAlloc a color...continuing, but things may look screwey...\n"); 
	}
      colors_found[i] = mycolor.pixel;      
    }


  for(i=0;i<height;i++)
    {      
      for(j=0;j<width;j++)
	{

	  if(colsize==SzUC)
	    {
	      fread(&thisUC, SzUC, 1, infile);
	      XSetForeground(mydisplay,mygc,colors_found[thisUC]); 
	    }
	  else if(colsize==SzShort)
	    {
	      SEEIT_fread_short(&thiscolor,infile);
	      XSetForeground(mydisplay,mygc,colors_found[thiscolor]); 
	    }
	  else if(colsize==SzI)
	    {
	      SEEIT_fread_int(&thisI,infile);
	      XSetForeground(mydisplay,mygc,colors_found[thisI]); 
	    }
	  else
	    {
	      XBell(mydisplay,50);
	      printf("bad color size %d\n",colsize);
	    }
	  
	  XDrawPoint (mydisplay, pixmap, mygc,j,i);
	}
    }
  fclose(infile);




  


  for(layer=0;layer<NumLODbands;layer++)
    {

      if(layer==0)
	{
	  
	  
	  sprintf(filename,"gzip -d -f \"%s%d.xbm.gz\"",bitfolder,layer+1);
	  system(filename);
	  
	  sprintf(filename,"%s%d.xbm",bitfolder,layer+1);
	  
	  
	  result = XReadBitmapFile(mydisplay,mywindow,filename,&PixDBWidth,
			  &PixDBHeight,&temp_bitmap,&Ijunk,&Ijunk2);
	  
			if(result!=BitmapSuccess)
			  {
				  printf("Fatal error: Could not read or uncompress %s(.gz)\n",filename);
				  printf("Be sure you have read and write privileges to this folder and file\n");
				  if(result==BitmapOpenFailed)
				  {
                    printf(" (BitmapOpenFailed)\n");
				  }
				  else if(result==BitmapFileInvalid)
				  {
                   printf(" (BitmapFileInvalid)\n");
				  }
				  else if(result==BitmapNoMemory)
				  {
                   printf(" (BitmapNoMemory)\n");
				  }
				  ExitWrapper(-1);
			  }
		      

	  xunits = mydmax((double)PixDBWidth,(double)PixDBHeight);
	  yunits = xunits;
	  
	  
	  sprintf(filename,"gzip -f -1 \"%s%d.xbm\"",bitfolder,layer+1);
	  system(filename);
	}
      
      
      sscanf(LODindex[layer].title,"%d%d",&Ijunk,&LODindex[layer].geomtype_single);
      if(
	 (LODindex[layer].geomtype_single!=C_POFE) &&
	 (LODindex[layer].geomtype_single!=C_LINE) &&
	 (LODindex[layer].geomtype_single!=C_AREA) &&
	 (LODindex[layer].geomtype_single!=C_GRID)
	 )
	{
	  XBell(mydisplay,50);
	  printf("bad geomtype %d on layer %d = %s\n",
		 LODindex[layer].geomtype_single,
		 layer,LODindex[layer].title);
	  return 0;
	} 
    }
  return 1;
}




void Relief(int draw)
{
  Pixmap temp_bitmap;
  double temp_xunits,temp_llx,temp_lly;
  unsigned int thiswidth,thisheight;
  int layer,Ijunk,Ijunk2,geoms,render_pri,targetgeom,sen1,sen2,result;
  int firstlayer=1,draw_style=-1,showlayers=0,needextrapixmap=0,trex_redo=0;
  char bitfolder[1000],filename[1000];
  extern int Read_TREX_Change();

  



  TopLayersDrawn   = 0;
  FinalSortPercent = 100.0;
  
  

  if(draw==1)
    {
      Read_SAVE_TOPCHANGE();  



      
      if(ATTRTYPE_TREX())
	  {
		if(Read_TREX_Change())
		{
		  trex_redo = 1;
		}
	  }



      if( (trex_redo==0) && ((SAVE_TOPCHANGE==0)||(SAVE_TOPCHANGE==1)) )
	{
	  if(UsePreviousPixmap()==1)
	    {
	      
	      
	      SaveCleanPixmap();
	      XCopyArea (mydisplay, pixmap, pixmap2,  mygc, 0, 0, width, height, 0, 0);
	      XCopyArea (mydisplay, pixmap, mywindow, mygc, 0, 0, width, height, 0, 0); 
		  TopLayersDrawn   = 0;
          FinalSortPercent = 0.0;
	      return;
	    }
	}
      else
	{
	  

      if(ATTRTYPE_TREX()==0)
	  {
	    printf("REBUILDING the top level representation due to previous failure\n");
	  }
	  else
	  {
	    printf("REBUILDING the top level representation\n");
	  }
	}
    }

  
  if(NOT_ZOOMED==0)
    {
      temp_xunits = xunits;
    }

 
  temp_llx    = llx_zoom;
  temp_lly    = lly_zoom;
  

  
  
  
  needextrapixmap = 0;
  if(draw==2)
  {
    for(layer=0;layer<NumLODbands;layer++)
	{
	  if(LODindex[layer].active==0)
	    {
	      needextrapixmap = 1;
	      break;
	    }
	}

    if(needextrapixmap==1)
	{
	  over_pixmap = XCreatePixmap (XtDisplay (drawing_a),
				       RootWindowOfScreen (XtScreen (drawing_a)), width, height,
				       DefaultDepthOfScreen (XtScreen (drawing_a)));
	  
	  set_color (drawing_a, "White",(XtPointer)NULL);
	  XFillRectangle (XtDisplay (drawing_a),over_pixmap, mygc, 0, 0, width, height);
	}
  }
  
  
  
  if((draw==0)||(draw==2))
    {
      if(NOT_ZOOMED==1)
	{
	  set_color (drawing_a, "White",(XtPointer)NULL);
	  XFillRectangle (XtDisplay (drawing_a), mywindow, mygc, 0, 0, width, height);
	  showlayers = 1;
	}
      
      set_cursor(mydisplay,mywindow,WATCH);
      TurnOnAll(0,&sen1,&sen2,0,0);  
    }
  else
    {
      showlayers = 1;
    }


  set_color (drawing_a, "White",(XtPointer)NULL);
  XFillRectangle (XtDisplay (drawing_a), pixmap2, mygc, 0, 0, width, height);


  
  
  sprintf(bitfolder,"%sbitmaps",indirectory);
  
  if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
    {
      strcat(bitfolder,"\\");
    }
  else
    {
      strcat(bitfolder,"/");
    }

  
  for(geoms=0;geoms<4;geoms++)
    {
      if(geoms==0)
	  {
	    targetgeom = C_GRID;
	  } 
      else if(geoms==1)
	  { 
	    targetgeom = C_AREA;
	  } 
      else if(geoms==2)
	  { 
	    targetgeom = C_LINE;
	  } 
      else if(geoms==3)
	  { 
	    targetgeom = C_POFE;
	  } 
      
      
      for(render_pri=5;render_pri>=1;render_pri--)
	  {	
		  

	    for(layer=0;layer<NumLODbands;layer++)
	    {

	      if(draw==1)
		  {
		    sscanf(LODindex[layer].title,"%d%d",&Ijunk,&LODindex[layer].geomtype_single);
		    if(
		       (LODindex[layer].geomtype_single!=C_POFE) &&
		       (LODindex[layer].geomtype_single!=C_LINE) &&
		       (LODindex[layer].geomtype_single!=C_AREA) &&
		       (LODindex[layer].geomtype_single!=C_GRID)
		      )
		    {
		      XBell(mydisplay,50);
		      printf("bad geomtype %d on layer %d = %s\n",
			     LODindex[layer].geomtype_single,
			     layer,LODindex[layer].title);
		    }
		  } 
	      
	      
	      
	      
	      if((LODindex[layer].active==0)&&(needextrapixmap==0))
		{
		  continue;
		}
	      if(LODindex[layer].geomtype_single!=targetgeom)
		{
		  continue;
		}	      
	      if(LODindex_DYN[LODindex[layer].other_index].draw_priority!=render_pri)
		{
		  continue;
		}

            
	      if(
		 (LODindex[layer].geomtype_single==C_GRID)                 &&
		 (LODindex_DYN[LODindex[layer].other_index].draw_style==0) &&
		 (DO_OVERRIDE==0)
		 )
		{
		  



		  if(firstlayer==1)
		    {
		      
		      
		      sprintf(filename,"gzip -d -f \"%s%d.xbm.gz\"",bitfolder,layer+1);
		      system(filename);
		      
		      sprintf(filename,"%s%d.xbm",bitfolder,layer+1);
		      
		      
		      result = XReadBitmapFile(mydisplay,mywindow,filename,&PixDBWidth,
				      &PixDBHeight,&temp_bitmap,&Ijunk,&Ijunk2);
		      
			  if(result!=BitmapSuccess)
			  {
				  printf("Fatal error: Could not read or uncompress %s(.gz)\n",filename);
				  printf("Be sure you have read and write privileges to this folder and file\n");
				  if(result==BitmapOpenFailed)
				  {
                    printf(" (BitmapOpenFailed)\n");
				  }
				  else if(result==BitmapFileInvalid)
				  {
                   printf(" (BitmapFileInvalid)\n");
				  }
				  else if(result==BitmapNoMemory)
				  {
                   printf(" (BitmapNoMemory)\n");
				  }
				  ExitWrapper(-1);
			  }
		      
		      xunits = mydmax((double)PixDBWidth,(double)PixDBHeight);
		      yunits = xunits;
		      
		      
		      sprintf(filename,"gzip -f -1 \"%s%d.xbm\"",bitfolder,layer+1);
		      system(filename);

			  firstlayer = 0;
		      
		      
		    }
		  
		  
		  
		  SpecialMapdrawPoly          = 1;
		  GLOBAL_draw                 = draw;
		  GLOBAL_needextrapixmap      = needextrapixmap;
		  GLOBAL_showlayers           = showlayers;
		  llx_zoom                    = 0;
		  lly_zoom                    = 0;

          if(batch_mode==1)
		  {
		    GLOBAL_draw                 = draw;
		    GLOBAL_needextrapixmap      = needextrapixmap;
		    GLOBAL_showlayers           = 0;
		  }

		  if(LODindex[layer].active==1)
		  {
			  GLOBAL_activelayer = 1;
		  }
		  else
		  {
			  
			  GLOBAL_activelayer = 0;
		  }

		  DrawGridTopLevel(layer+1);


		  llx_zoom                    = temp_llx;
		  lly_zoom                    = temp_lly;
		  SpecialMapdrawPoly          = 0;



	      TopLayersDrawn = TopLayersDrawn + 1;

	      if(draw==1)
		  {
		    InitializationAdvice(100.0,100.0,100.0,100.0,100.0,3);
		  }

		  
		  continue;
		}
	      


	      
	      
	      
	      
	      
	      if(LODindex[layer].geomtype_single!=C_GRID)
		{		  
		  sprintf(filename,"gzip -d -f \"%s%d.xbm.gz\"",bitfolder,layer+1);
		  system(filename);
		  
		  sprintf(filename,"%s%d.xbm",bitfolder,layer+1);
		  
		  if(firstlayer==1)
		    {
		      
		      result = XReadBitmapFile(mydisplay,mywindow,filename,&PixDBWidth,
				      &PixDBHeight,&temp_bitmap,&Ijunk,&Ijunk2);
		      
			  if(result!=BitmapSuccess)
			  {
				  printf("Fatal error: Could not read or uncompress %s(.gz)\n",filename);
				  printf("Be sure you have read and write privileges to this folder and file\n");
				  if(result==BitmapOpenFailed)
				  {
                    printf(" (BitmapOpenFailed)\n");
				  }
				  else if(result==BitmapFileInvalid)
				  {
                   printf(" (BitmapFileInvalid)\n");
				  }
				  else if(result==BitmapNoMemory)
				  {
                   printf(" (BitmapNoMemory)\n");
				  }
				  ExitWrapper(-1);
			  }
		      
		      
		      xunits = mydmax((double)PixDBWidth,(double)PixDBHeight);
		      yunits = xunits;
			  

		      sprintf(filename,"gzip -f -1 \"%s%d.xbm\"",bitfolder,layer+1);
		      system(filename);
		      
		      firstlayer = 0;
		    }
		  else
		    {
		      
		      result = XReadBitmapFile(mydisplay,mywindow,filename,&thiswidth,
				      &thisheight,&temp_bitmap,&Ijunk,&Ijunk2);

			 if(result!=BitmapSuccess)
			  {
				  printf("Fatal error: Could not read or uncompress %s(.gz)\n",filename);
				  printf("Be sure you have read and write privileges to this folder and file\n");
				  if(result==BitmapOpenFailed)
				  {
                    printf(" (BitmapOpenFailed)\n");
				  }
				  else if(result==BitmapFileInvalid)
				  {
                   printf(" (BitmapFileInvalid)\n");
				  }
				  else if(result==BitmapNoMemory)
				  {
                   printf(" (BitmapNoMemory)\n");
				  }
				  ExitWrapper(-1);
			  }
		      
		      
		      sprintf(filename,"gzip -f -1 \"%s%d.xbm\"",bitfolder,layer+1);
		      system(filename);
		      
		      if(thisheight!=PixDBHeight)
			{
			  XBell(mydisplay,50);
			  printf("error: found height 1 %d height %d=%d\n",
				 PixDBHeight,layer+1,thisheight);
			}

		      if(thiswidth!=PixDBWidth)
			{
			  XBell(mydisplay,50);
			  printf("error: found width 1 %d width %d=%d\n",
				 PixDBWidth,layer+1,thiswidth);
			}
		    }
		  
		  XSetClipOrigin(mydisplay, mygc, 10, 840-PixDBHeight);
		  XSetForeground(mydisplay, mygc,LODindex[layer].color);
		  XSetClipMask(mydisplay,   mygc,temp_bitmap);
		  
		  if(LODindex[layer].active==1)
		    {
		      if(draw==1)
			{
			  XFillRectangle (mydisplay, pixmap,   mygc, 0, 0, width, height);
			}
		      else
			{
			  XFillRectangle (mydisplay, pixmap2,   mygc, 0, 0, width, height);
			}
		    }
		  
		  if(needextrapixmap==1)
		    {
		      XFillRectangle (mydisplay, over_pixmap,   mygc, 0, 0, width, height);
		    }

		  if(showlayers==1)
		    {
		      XFillRectangle (mydisplay, mywindow, mygc, 0, 0, width, height);
		    }		  
		  
		  XFreePixmap(mydisplay,temp_bitmap);
		}

	      
	      else if(LODindex[layer].geomtype_single==C_GRID)
		{
		  

		 
		  
		

		  sprintf(filename,"gzip -d -f \"%s%d.xbm.gz\"",bitfolder,layer+1);
		  system(filename);
		  
		  sprintf(filename,"%s%d.xbm",bitfolder,layer+1);
		  
		  if(firstlayer==1)
		    {
		      
		      result = XReadBitmapFile(mydisplay,mywindow,filename,&PixDBWidth,
				      &PixDBHeight,&temp_bitmap,&Ijunk,&Ijunk2);

              if(result!=BitmapSuccess)
			  {
				  printf("Fatal error: Could not read or uncompress %s(.gz)\n",filename);
				  printf("Be sure you have read and write privileges to this folder and file\n");
				  if(result==BitmapOpenFailed)
				  {
                    printf(" (BitmapOpenFailed)\n");
				  }
				  else if(result==BitmapFileInvalid)
				  {
                   printf(" (BitmapFileInvalid)\n");
				  }
				  else if(result==BitmapNoMemory)
				  {
                   printf(" (BitmapNoMemory)\n");
				  }
				  ExitWrapper(-1);
			  }
		      
		      xunits = mydmax((double)PixDBWidth,(double)PixDBHeight);
		      yunits = xunits;
			  

		      sprintf(filename,"gzip -f -1 \"%s%d.xbm\"",bitfolder,layer+1);
		      system(filename);
		      
		      firstlayer = 0;
		    }
		  else
		    {
		      
		      result = XReadBitmapFile(mydisplay,mywindow,filename,&thiswidth,
				      &thisheight,&temp_bitmap,&Ijunk,&Ijunk2);
		      
			 if(result!=BitmapSuccess)
			  {
				  printf("Fatal error: Could not read or uncompress %s(.gz)\n",filename);
				  printf("Be sure you have read and write privileges to this folder and file\n");
				  if(result==BitmapOpenFailed)
				  {
                    printf(" (BitmapOpenFailed)\n");
				  }
				  else if(result==BitmapFileInvalid)
				  {
                   printf(" (BitmapFileInvalid)\n");
				  }
				  else if(result==BitmapNoMemory)
				  {
                   printf(" (BitmapNoMemory)\n");
				  }
				  ExitWrapper(-1);
			  }
		      
		      sprintf(filename,"gzip -f -1 \"%s%d.xbm\"",bitfolder,layer+1);
		      system(filename);
		      
		      if(thisheight!=PixDBHeight)
			{
			  XBell(mydisplay,50);
			  printf("error: found height 1 %d height %d=%d\n",
				 PixDBHeight,layer+1,thisheight);
			}
		      if(thiswidth!=PixDBWidth)
			{
			  XBell(mydisplay,50);
			  printf("error: found width 1 %d width %d=%d\n",
				 PixDBWidth,layer+1,thiswidth);
			}
		    }
		  



		  if(LODindex_DYN[LODindex[layer].other_index].do_discrete==1)
		  {


			if(NOT_ZOOMED==0)
			{
              
              llx_zoom    = 0;
              lly_zoom    = 0;
              xunits      = mydmax((double)PixDBWidth,(double)PixDBHeight);
              yunits      = xunits;
			}

		    


		    DrawNonShadedGrids(layer+1,needextrapixmap);


			if(NOT_ZOOMED==0)
			{
			  
              llx_zoom    = temp_llx;
              lly_zoom    = temp_lly;
              xunits      = temp_xunits;
			  yunits      = xunits;
			}

		    XSetClipOrigin(mydisplay, mygc, 0,0);  
		    XSetClipOrigin(mydisplay, mybitgc,0,0);
		  }
		  else
		  {
		    XSetClipOrigin(mydisplay, mygc, 10, 840-PixDBHeight);
		    XSetClipMask(mydisplay,mygc,temp_bitmap);
		  }





		  XSetForeground(mydisplay,mygc,LODindex[layer].color);



		  draw_style = LODindex_DYN[LODindex[layer].other_index].draw_style;
		  if(DO_OVERRIDE==1)
		    {
		      draw_style = OVERRIDING_STYLE;
		    }
		  
		  switch(draw_style)
		    {
		    case 1: 
		      XSetStipple   (mydisplay,mygc,stipmap_hvy);
		      XSetFillStyle (mydisplay,mygc,FillStippled);
		      break;
		    case 2: 
		      XSetStipple   (mydisplay,mygc,stipmap_lgt);
		      XSetFillStyle (mydisplay,mygc,FillStippled);
		      break;
		    case 3: 
		      XSetStipple   (mydisplay,mygc,stipmap_avg);
		      XSetFillStyle (mydisplay,mygc,FillStippled);
		      break;
		    case 4: 
		      XSetStipple   (mydisplay,mygc,stipmap_hvy);
		      XSetFillStyle (mydisplay,mygc,FillStippled);
		      break;
		    case 5: 
		      XSetFillStyle (mydisplay,mygc,FillSolid);  
		      break;
		    case 6: 
		      XSetStipple   (mydisplay,mygc,stipmapstypes[0]);
		      XSetFillStyle (mydisplay,mygc,FillStippled);
		      break;
		    case 7: 
		      XSetStipple   (mydisplay,mygc,stipmapstypes[1]);
		      XSetFillStyle (mydisplay,mygc,FillStippled);
		      break;
		    case 8: 
		      XSetStipple   (mydisplay,mygc,stipmapstypes[2]);
		      XSetFillStyle (mydisplay,mygc,FillStippled);
		      break;
		    case 9: 
		      XSetStipple   (mydisplay,mygc,stipmapstypes[3]);
		      XSetFillStyle (mydisplay,mygc,FillStippled);
		      break;
		    case 10: 
		      XSetStipple   (mydisplay,mygc,stipmapstypes[5]);
		      XSetFillStyle (mydisplay,mygc,FillStippled);
		      break;
		    case 11: 
		      XSetStipple   (mydisplay,mygc,stipmapstypes[4]);
		      XSetFillStyle (mydisplay,mygc,FillStippled);
		      break;
		    case 12: 
		      XSetStipple   (mydisplay,mygc,stipmapstypes[6]);
		      XSetFillStyle (mydisplay,mygc,FillStippled);
		      break;
		    case 13: 
		      XSetStipple   (mydisplay,mygc,stipmapstypes[7]);
		      XSetFillStyle (mydisplay,mygc,FillStippled);
		      break;
		    default:
		      XBell(mydisplay,50);
		      printf("Error (1) (%d) in toplevel: %d\n",layer,draw_style);
		    }

		  if(LODindex[layer].active==1)
		    {

		      if(draw==1)
			{
			  XFillRectangle (mydisplay, pixmap,   mygc, 0, 0, width, height);
			}
		      else
			{
			  XFillRectangle (mydisplay, pixmap2,   mygc, 0, 0, width, height);
			}
		    }
		
		  if((needextrapixmap==1)&&(IsTrexToplevel(layer)))
		    {
		      XFillRectangle (mydisplay, over_pixmap,   mygc, 0, 0, width, height);
		    }
		  
		  if((showlayers==1)&&(IsTrexToplevel(layer)))
		    {
		      XFillRectangle (mydisplay, mywindow, mygc, 0, 0, width, height);
		    }		  		  
		  XFreePixmap(mydisplay,temp_bitmap);
		}


       


       EndGridMasking();









	   
	      
	   if(LODindex[layer].geomtype_single==C_AREA)
		{
		  draw_style = LODindex_DYN[LODindex[layer].other_index].draw_style;
		  if(DO_OVERRIDE==1)
		    {
		      draw_style = OVERRIDING_STYLE;
		    }
		}
	      
	   if((LODindex[layer].geomtype_single==C_AREA)&&(draw_style!=1))
		{
		  
		  
		  
		  sprintf(filename,"gzip -d -f \"%s%db.xbm.gz\"",bitfolder,layer+1);
		  system(filename);
		  
		  sprintf(filename,"%s%db.xbm",bitfolder,layer+1);
		  
		  
		  result = XReadBitmapFile(mydisplay,mywindow,filename,&thiswidth,
				  &thisheight,&temp_bitmap,&Ijunk,&Ijunk2);
		  
		  	 if(result!=BitmapSuccess)
			  {
				  printf("Fatal error: Could not read or uncompress %s(.gz)\n",filename);
				  printf("Be sure you have read and write privileges to this folder and file\n");
				  if(result==BitmapOpenFailed)
				  {
                    printf(" (BitmapOpenFailed)\n");
				  }
				  else if(result==BitmapFileInvalid)
				  {
                   printf(" (BitmapFileInvalid)\n");
				  }
				  else if(result==BitmapNoMemory)
				  {
                   printf(" (BitmapNoMemory)\n");
				  }
				  ExitWrapper(-1);
			  }
		      
		  if(thisheight!=PixDBHeight)
		    {
		      XBell(mydisplay,50);
		      printf("error: found height 1 %d height %d=%d\n",
			     PixDBHeight,layer+1,thisheight);
		    }
		  if(thiswidth!=PixDBWidth)
		    {
		      XBell(mydisplay,50);
		      printf("error: found width 1 %d width %d=%d\n",
			     PixDBWidth,layer+1,thiswidth);
		    }


		  sprintf(filename,"gzip -f -1 \"%s%db.xbm\"",bitfolder,layer+1);
		  system(filename);

		  
		  XSetClipOrigin(mydisplay,mygc, 10, 840-PixDBHeight);
		  XSetForeground(mydisplay,mygc,LODindex[layer].color);
		  XSetClipMask  (mydisplay,mygc,temp_bitmap);
		  
		  
		  switch(draw_style)
		    {
		    case 2: 
		      XSetStipple   (mydisplay,mygc,stipmap_lgt);
		      XSetFillStyle (mydisplay,mygc,FillStippled);
		      break;
		    case 3: 
		      XSetStipple   (mydisplay,mygc,stipmap_avg);
		      XSetFillStyle (mydisplay,mygc,FillStippled);
		      break;
		    case 4: 
		      XSetStipple   (mydisplay,mygc,stipmap_hvy);
		      XSetFillStyle (mydisplay,mygc,FillStippled);
		      break;
		    case 5: 
		      XSetFillStyle (mydisplay,mygc,FillSolid);  
		      break;
		    case 6: 
		      XSetStipple   (mydisplay,mygc,stipmapstypes[0]);
		      XSetFillStyle (mydisplay,mygc,FillStippled);
		      break;
		    case 7: 
		      XSetStipple   (mydisplay,mygc,stipmapstypes[1]);
		      XSetFillStyle (mydisplay,mygc,FillStippled);
		      break;
		    case 8: 
		      XSetStipple   (mydisplay,mygc,stipmapstypes[2]);
		      XSetFillStyle (mydisplay,mygc,FillStippled);
		      break;
		    case 9: 
		      XSetStipple   (mydisplay,mygc,stipmapstypes[3]);
		      XSetFillStyle (mydisplay,mygc,FillStippled);
		      break;
		    case 10: 
		      XSetStipple   (mydisplay,mygc,stipmapstypes[5]);
		      XSetFillStyle (mydisplay,mygc,FillStippled);
		      break;
		    case 11: 
		      XSetStipple   (mydisplay,mygc,stipmapstypes[4]);
		      XSetFillStyle (mydisplay,mygc,FillStippled);
		      break;
		    case 12: 
		      XSetStipple   (mydisplay,mygc,stipmapstypes[6]);
		      XSetFillStyle (mydisplay,mygc,FillStippled);
		      break;
		    case 13: 
		      XSetStipple   (mydisplay,mygc,stipmapstypes[7]);
		      XSetFillStyle (mydisplay,mygc,FillStippled);
		      break;
		    default:
		      XBell(mydisplay,50);
		      printf("Error (2) (%d) in toplevel: %d\n",layer,draw_style);
		    }
      
		  
		  
		  		  

		  if(LODindex[layer].active==1)
		    {
		      if(draw==1)
			{
			  XFillRectangle (mydisplay, pixmap,   mygc, 0, 0, width, height);
			}
		      else
			{
			  XFillRectangle (mydisplay, pixmap2,   mygc, 0, 0, width, height);
			}	  
		    }

		  if((needextrapixmap==1)&&(IsTrexToplevel(layer)))
		    {
		      XFillRectangle (mydisplay, over_pixmap,   mygc, 0, 0, width, height);
		    }
		  
		  if(showlayers==1)
		    {
		      XFillRectangle (mydisplay, mywindow, mygc, 0, 0, width, height);
		    }

		  XFreePixmap(mydisplay,temp_bitmap);
		}


	      TopLayersDrawn = TopLayersDrawn + 1;

	      if(draw==1)
		{
		  InitializationAdvice(100.0,100.0,100.0,100.0,100.0,3);
		}
	      
	      XSetFillStyle (mydisplay,mygc,     FillSolid);  
	      XSetClipMask  (mydisplay,mygc,None);
	      XSetClipOrigin(mydisplay,mygc, 0,  0);

	    } 
	} 
    } 



  TopLayersDrawn   = 0;
  FinalSortPercent = 0.0;


  

  
  
  
  if(draw==1)
    {
      
      SavePixmapToFile(pixmap,1);
      SaveCleanPixmap();
    }
  else if((draw==2)&&(needextrapixmap==0))
    {
      
      SavePixmapToFile(pixmap2,2);
    }
  else if(needextrapixmap==1)
    {

      

      SavePixmapToFile(over_pixmap,3);
      XFreePixmap(mydisplay,over_pixmap);
    }
  
  XSetForeground(mydisplay,mygc,mycolors[DRAW_COLOR_BLACK]);
  
  if(draw==1)
    {
      
      
      XCopyArea (mydisplay, pixmap, pixmap2, mygc, 0, 0, width, height, 0, 0);
    }
  else
    {
      TurnOnAll(1,&Ijunk,&Ijunk,sen1,sen2);
      set_cursor(mydisplay,mywindow,GOOD);
    }
  

  
  
  if(NOT_ZOOMED==0)
    {
      xunits = temp_xunits;
      yunits = xunits;
    }

  Record_SAVE_TOPCHANGE(0);

}




void MakeGrid()
{
  
  
  Dimension x,y;
  
    

  XtVaGetValues (drawing_a, XmNwidth, &x, XmNheight, &y, NULL);

  grx = x;
  gry = y;

  if(DEBUG==1){printf("Window is of size %d %d\n",grx,gry);} 

  y=y-60;
  x=x-10;

  if((y/(MaxYindex - MinYindex+1))>=3){yunits=y/(MaxYindex - MinYindex+1);}
  if((x/(MaxXindex - MinXindex+1))>=3){xunits=x/(MaxXindex - MinXindex+1);}

  if(DEBUG==1){printf("%d %d %d %d\n",MinXindex,MaxXindex,MinYindex,MaxYindex); }
  if(DEBUG==1){printf("units are x=%lf y=%lf\n",xunits,yunits);} 

  if(xunits<yunits){yunits=xunits;}else{xunits=yunits;}

  if(DEBUG==1){printf("units are %lf %lf\n",xunits,yunits); }

  xnum = (MaxXindex - MinXindex)+1;
  ynum = (MaxYindex - MinYindex)+1;

  Relief(1);
}
 





void browsefilecancelDialogCallback(Widget w, XtPointer userData,
			       XmFileSelectionBoxCallbackStruct *data)
{
  XtDestroyWidget(XtParent(XtParent(w)));
}




int UpdateDataLoc(char *newloc)
{
  printf("new data location %s\n",newloc);
  return 1;
}




void browsefileDialogCallback(Widget w, XtPointer userData,
			      XmFileSelectionBoxCallbackStruct *data)
{
  
  
  char *dir;
  int type = (int)userData;
  extern Widget dp1_wid;
  
  
  
  
  if((type==CHOOSEPROJ_BROWSE)&&(USE_DOS==1)&&(old_file_browser==0))
    {
      dir = (char *)data;
    }
  else if((type==CHOOSE_ES1_BROWSE)&&(USE_DOS==1)&&(old_file_browser==0))
    {
      dir = (char *)data;
    }
  else if((type==CHOOSE_ES2_BROWSE)&&(USE_DOS==1)&&(old_file_browser==0))
    {
      dir = (char *)data;
    }
  else if((type==CHOOSE_TXT_BROWSE)&&(USE_DOS==1)&&(old_file_browser==0))
    {
      dir = (char *)data;
    }
  else if((type==CHOOSEDATA_BROWSE)&&(USE_DOS==1)&&(old_file_browser==0))
    {
      dir = (char *)data;
    }
  else if((type==CHOOSE_XML1_BROWSE)&&(USE_DOS==1)&&(old_file_browser==0))
    {
      dir = (char *)data;
    }
  else if((type==CHOOSE_XML2_BROWSE)&&(USE_DOS==1)&&(old_file_browser==0))
    {
      dir = (char *)data;
    }
  else if((type==CHOOSE_XML3_BROWSE)&&(USE_DOS==1)&&(old_file_browser==0))
    {
      dir = (char *)data;
    }
  else
    {
      XmStringGetLtoR(data->value,
		      (XmStringCharSet) XmSTRING_DEFAULT_CHARSET, &dir);
      
      if(DEBUG==1){printf("The file name is: %s\n",dir);}
      
      if(dir[strlen(dir)]=='\0') 
	{
	  if(dir[strlen(dir)-1]=='/')  
	    {
	      dir[strlen(dir)-1]='\0';
	    }
	  else if(dir[strlen(dir)-1]=='\\')  
	    {
	      dir[strlen(dir)-1]='\0';
	    }
	}
      
      if(DEBUG==1){printf("The file name is NOW: %s\n",dir);}
    }
  
  
  
  if(type==CHOOSEPROJ_BROWSE)
    {
      FAIL_PROJ_FOLDER = 0;
      if(UpdateProjectLoc(dir)==1)
	{
	  if(strcmp(PROJECTLOC,dir))
	    {
	      if(input_up==1)
		{
		  XtDestroyWidget(pick_dialog);
		}
	    }
	  
	  sprintf(PROJECTLOC,"%s",dir);
	  XmTextFieldSetString(folder_wid,PROJECTLOC);
	}
      else
	{
	  FAIL_PROJ_FOLDER = 1;
	  XmTextFieldSetString(folder_wid,PROJECTLOC);
	}
    }
  else if(type==CHOOSEDATA_BROWSE)
    {
      if(UpdateDataLoc(dir)==1)
	{
	  if(strcmp(DATALOC,dir))
	    {
	      if(input_up==1)
		{
		  XtDestroyWidget(pick_dialog);
		}
	    }
	  
	  sprintf(DATALOC,"%s",dir);
	  XmTextFieldSetString(data_wid,DATALOC);
	}
      else
	{
	  XmTextFieldSetString(data_wid,DATALOC);
	}
    }
  else if(type==CHOOSE_ES1_BROWSE)
    {
      FAIL_PROJ_FOLDER = 0;
      XmTextFieldSetString(sum1_wid,dir);
      strcpy(Sum1ESname,dir);
    }
  else if(type==CHOOSE_ES2_BROWSE)
    {
      FAIL_PROJ_FOLDER = 0;
      XmTextFieldSetString(sum2_wid,dir);
      strcpy(Sum2ESname,dir);
    }
  else if(type==CHOOSE_TXT_BROWSE)
    {
      FAIL_PROJ_FOLDER = 0;
      XmTextFieldSetString(sum3_wid,dir);
      strcpy(Sum3ESname,dir);
    }
  else if(type==CHOOSE_XML1_BROWSE)
    {
      FAIL_PROJ_FOLDER = 0;
      XmTextFieldSetString(xml1_wid,dir);
      strcpy(XML1name,dir);
    }
  else if(type==CHOOSE_XML2_BROWSE)
    {
      FAIL_PROJ_FOLDER = 0;
      XmTextFieldSetString(xml2_wid,dir);
      strcpy(XML2name,dir);
  }
  else if(type==CHOOSE_XML3_BROWSE)
    {
      FAIL_PROJ_FOLDER = 0;
      XmTextFieldSetString(xml3_wid,dir);
      strcpy(XML3name,dir);
    }
  else if(type==CHOOSE_DP_BROWSE)
    {
      strcpy(dp1name,dir);
      
      if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
	{
	  strcat(dp1name,"\\");
	}
      else
	{
	  strcat(dp1name,"/");
	}
      
      XtVaSetValues(dp1_wid,XmNvalue,dp1name,NULL);
    }
  else
    {
      XBell(mydisplay,50);
      printf("bad value to BFDC: %d\n",type);
    }
  
  if((USE_DOS==0)||(old_file_browser==1))
    {
      XtFree(dir);
      XtDestroyWidget(XtParent(XtParent(w)));
    }
}


int GetMaxIndex(int type, char *caller)
{

  if(type==CHOOSEPROJ_BROWSE)
  {
	return ProjWidsSaved;
  } 
  else if(type==CHOOSESHAPE_BROWSE)  
  {
	return ShapeWidsSaved;
  }
  else if(type==CHOOSE_ES1_BROWSE)
  {
	return ES1WidsSaved;
  }
  else if(type==CHOOSE_ES2_BROWSE)
  {
	return ES2WidsSaved;
  }
  else if(type==CHOOSE_TXT_BROWSE)
  {
	return TXTWidsSaved;
  }
  else if(type==CHOOSE_XML1_BROWSE)
  {
	return XML1WidsSaved;
  }
  else if(type==CHOOSE_XML2_BROWSE)
  {
	return XML2WidsSaved;
  }
  else if(type==CHOOSE_XML3_BROWSE)
  {
	return XML3WidsSaved;
  }
  else if(type==ATTRFOLDER_BROWSE)
  {
	return AttrWidsSaved;
  }
  else if(type==CHOOSE_DP_BROWSE)
  {
	return DPWidsSaved;
  }
  else if(type==CHOOSEBROWSE_BROWSE)
  {
	return BrowseWidsSaved;
  }
  else
  {
	printf("bad flag %d in GMI from %s\n",type,caller);
  }

  
  return 0;
}


char *GetPathFromWid(int type, int index)
{
  static char pathname[1000];
  XmString thename;
  char *text;
  int quotefound,len,i,firstcolon,insidetype=1,numcolon=0,nettype=0;
  
  if(type==CHOOSEPROJ_BROWSE)
    {
      XtVaGetValues(ProjWids[index],XmNlabelString,&thename,NULL);
	  if(ProjLevels[index]<0)
	  {
		nettype = 1;
	  }
    }
  else if(type==CHOOSESHAPE_BROWSE)
    {
      XtVaGetValues(ShapeWids[index],XmNlabelString,&thename,NULL);
	  if(ShapeLevels[index]<0)
	  {
		nettype = 1;
	  }
    }
  else if(type==CHOOSE_ES1_BROWSE)
    {
      XtVaGetValues(ES1Wids[index],XmNlabelString,&thename,NULL);
	  if(ES1Levels[index]<0)
	  {
		nettype = 1;
	  }
    }
  else if(type==CHOOSE_ES2_BROWSE)
    {
      XtVaGetValues(ES2Wids[index],XmNlabelString,&thename,NULL);
	  if(ES2Levels[index]<0)
	  {
		nettype = 1;
	  }
    }
  else if(type==CHOOSE_TXT_BROWSE)
    {
      XtVaGetValues(TXTWids[index],XmNlabelString,&thename,NULL);
	  if(TXTLevels[index]<0)
	  {
		nettype = 1;
	  }
    }
  else if(type==CHOOSE_XML1_BROWSE)
    {
      XtVaGetValues(XML1Wids[index],XmNlabelString,&thename,NULL);
	  if(XML1Levels[index]<0)
	  {
		nettype = 1;
	  }
    }
  else if(type==CHOOSE_XML2_BROWSE)
    {
      XtVaGetValues(XML2Wids[index],XmNlabelString,&thename,NULL);
	  if(XML2Levels[index]<0)
	  {
		nettype = 1;
	  }
    }
  else if(type==CHOOSE_XML3_BROWSE)
    {
      XtVaGetValues(XML3Wids[index],XmNlabelString,&thename,NULL);
	  if(XML3Levels[index]<0)
	  {
		nettype = 1;
	  }
    }
  else if(type==ATTRFOLDER_BROWSE)
    {
      XtVaGetValues(AttrWids[index],XmNlabelString,&thename,NULL);
	  if(AttrLevels[index]<0)
	  {
		nettype = 1;
	  }
    }
  else if(type==CHOOSE_DP_BROWSE)
    {
      XtVaGetValues(DPWids[index],XmNlabelString,&thename,NULL);
	  if(DPLevels[index]<0)
	  {
		nettype = 1;
	  }
    }
  else if(type==CHOOSEBROWSE_BROWSE)
    {
      XtVaGetValues(BrowseWids[index],XmNlabelString,&thename,NULL);
	  if(BrowseLevels[index]<0)
	  {
		nettype = 1;
	  }
    }
  else
    {
      printf("bad type %d to GPFW\n",type);
    }
  



  XmStringGetLtoR(thename,(XmStringCharSet) XmSTRING_DEFAULT_CHARSET, &text);

  XmStringFree(thename);  


  len = strlen(text);
  firstcolon = -1;
  for(i=0;i<len;i++)
  {
    if(text[i]==':')
	{
		numcolon = numcolon + 1;
		if(firstcolon<0)
		{
		  firstcolon = i;
		}
	}
  }


  if((nettype==1)&&(firstcolon>1))
  {
	

	if((firstcolon<2)||(len<4))
	{
		printf("Error:  Could not parse net path %s len %d\n",text,len);
		XtFree(text);
		return "Error: See console windoow";
	}

	for(i=firstcolon+2;i<len;i++)
	{
	  pathname[i-(firstcolon+2)] = text[i];
	}
    pathname[i-(firstcolon+2)] = '\0';





	XtFree(text);
	return pathname;
  }
  else if(numcolon==1)
  {
    insidetype = 1;
  }
  else if(numcolon==2)
  {
	insidetype = 0;
  }
   else if(numcolon==0)
  {
	insidetype = 1;
  }
  else
  {
	printf("bad number of colons %d in %s\n",numcolon,text);
  }

  if(DOSDEBUG==1)
  {
    printf("found %s was on and insidetype %d\n",text,insidetype);
  }

  
  

  
  if(insidetype==1)
    {
      sprintf(pathname,"%s",text);
      XtFree(text);
      return pathname;
    }
  


  
 
  
  quotefound = 0;
  
  len = strlen(text) - 1; 
  
  for(i=0;i<len;i++)
    {
      if(text[i]==':')
	{
	  quotefound = i;
	}
    }
  
  if(quotefound<2)
    {
      printf("error %d: could not find : in %s\n",quotefound,text);
    }
  
  
  if(text[quotefound-2]!='(')
    {
      printf("error %d: expected ( got %c in %s\n",
		  quotefound,
		  text[quotefound-2],
		  text);
    }
  
  for(i=quotefound-1;i<len;i++)
    {
      pathname[i-quotefound+1] = text[i];
    }
  
  pathname[i-quotefound+1] = '\0';
  
  XtFree(text);
  


  return pathname;
}



char *GetSelectedItem(Widget tempwid, Widget button,int forcefile)
{
  XmString *selectlist;
  char *text;
  int totalobjs;
  static char message[1000];


  XtVaGetValues(tempwid,
		XmNselectedItemCount,&totalobjs,
		XmNselectedItems    ,&selectlist,
		NULL);

  if(totalobjs==0)
  {
	if(forcefile==1)
	{
	  
      not_while_running(button,"Error: No \".es\" file selected.\n\nClick \"Help\" for more details.",1477,"No file selected",1);
      return errorsentinel;
	}
	else if(forcefile==2)
	{
	  
      not_while_running(button,"Error: No \".xml\" file selected.\n\nClick \"Help\" for more details.",1477,"No file selected",1);
      return errorsentinel;
	}
	else if(forcefile==3)
	{
	  
      not_while_running(button,"Error: No \".txt\" file selected.\n\nClick \"Help\" for more details.",1477,"No file selected",1);
      return errorsentinel;
	}
	else
	{
	  return "";
	}
  }
  else if(totalobjs!=1)
  {
    printf("error: %d items selected\n",totalobjs);
    return errorsentinel;
  }

  XmStringGetLtoR(selectlist[0],
		  (XmStringCharSet) XmSTRING_DEFAULT_CHARSET, &text);
  

  sscanf(text,"%s",project_to_open);
  
  sprintf(message,"%s",text);
  XtFree(text);
  return message;
}




void SetAttrFolderCallback(Widget w, XtPointer userData, XmFileSelectionBoxCallbackStruct *data)
{
  char *junk;  
  

    if(old_file_browser==1)
      {
	XmStringGetLtoR(data->value,(XmStringCharSet) XmSTRING_DEFAULT_CHARSET, &junk);
      }
    else
      {
  junk = (char *)malloc(1000);
  sprintf(junk,"%s",(char *)data); 
    }

  
  if(junk[strlen(junk)]=='\0') 
    {
      if(
	 (junk[strlen(junk)-1]=='/')||
	 (junk[strlen(junk)-1]=='\\')
	 )
	{
	  junk[strlen(junk)-1]='\0';
	}
    }
  
  strcpy(attrinsfolder,junk);

  free(junk);

  if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
    {
      strcat(attrinsfolder,"\\");
    }
  else
    {
      strcat(attrinsfolder,"/");
    }

  XtVaSetValues(attrins_text_area,XmNvalue,attrinsfolder,NULL);

    if(old_file_browser==1)
      {
	XtDestroyWidget(XtParent(XtParent(w)));
	browse30_up = 0;
      }
    else
      {
  HandleSuccessDos(chooseattr_dialog);
    }
}




void SetDPFolderCallback(Widget w, XtPointer userData, XmFileSelectionBoxCallbackStruct *data)
{
  char *junk;  
  extern Widget dp1_wid;

  if(old_file_browser==1)
  {
	XmStringGetLtoR(data->value,(XmStringCharSet) XmSTRING_DEFAULT_CHARSET, &junk);
  }
  else
  {
   junk = (char *)malloc(1000);
   sprintf(junk,"%s",(char *)data); 
  }


  if(junk[strlen(junk)]=='\0') 
    {
      if(
	 (junk[strlen(junk)-1]=='/')||
	 (junk[strlen(junk)-1]=='\\')
	 )
	{
	  junk[strlen(junk)-1]='\0';
	}
    }
  
  strcpy(dp1name,junk);

  free(junk);

  if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
    {
      strcat(dp1name,"\\");
    }
  else
    {
      strcat(dp1name,"/");
    }


  XtVaSetValues(dp1_wid,XmNvalue,dp1name,NULL);

  if(old_file_browser==1)
  {
	XtDestroyWidget(XtParent(XtParent(w)));
	browse31_up = 0;
  }
  else
  {
    HandleSuccessDos(choosedp_dialog);
  }
}




void SetBRFolderCallback(Widget w, XtPointer userData, XmFileSelectionBoxCallbackStruct *data)
{
  char *junk;  
  extern Widget browsefolder_wid;

  if(old_file_browser==1)
  {
	XmStringGetLtoR(data->value,(XmStringCharSet) XmSTRING_DEFAULT_CHARSET, &junk);
  }
  else
  {
   junk = (char *)malloc(1000);
   sprintf(junk,"%s",(char *)data); 
  }


  if(junk[strlen(junk)]=='\0') 
    {
      if(
	 (junk[strlen(junk)-1]=='/')||
	 (junk[strlen(junk)-1]=='\\')
	 )
	{
	  junk[strlen(junk)-1]='\0';
	}
    }
  
  strcpy(SpecialLoc,junk);

  free(junk);

  if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
    {
      strcat(SpecialLoc,"\\");
    }
  else
    {
      strcat(SpecialLoc,"/");
    }


  XtVaSetValues(browsefolder_wid,XmNvalue,SpecialLoc,NULL);

  if(old_file_browser==1)
  {
	XtDestroyWidget(XtParent(XtParent(w)));
	browse31_up = 0;
  }
  else
  {
    HandleSuccessDos(choosebr_dialog);
  }
}


void choose_dos_browse_cb(Widget w, XtPointer userData, XtPointer callData)
{
  char pathname[1000],tester[1000],finalval[1000];
  int type = (int)userData;
  int i,foundit;


  if(type==CHOOSEPROJ_BROWSE)
    {
      for(i=0;i<ProjWidsSaved;i++)
	{
	  if(XmToggleButtonGetState(ProjWids[i])==True)
	    {
	      sprintf(pathname,"%s",GetPathFromWid(CHOOSEPROJ_BROWSE,i));
	      if(DOSDEBUG==1)
		{
		  printf("Got path %s\n",pathname);
		}
	      browsefileDialogCallback((Widget)NULL,(XtPointer)CHOOSEPROJ_BROWSE,(XmFileSelectionBoxCallbackStruct *)pathname);
	      
	      if(FAIL_PROJ_FOLDER==0)
		{
		  
		  HandleSuccessDos(choose_dialog);
		}
	      
	      return;
	    } 
	} 
      
      not_while_running(XtParent(XtParent(XtParent(w))),"Error: No folder selected",1472,"Error",1);
      
    } 
  else if(type==CHOOSESHAPE_BROWSE)
    {
      for(i=0;i<ShapeWidsSaved;i++)
	 {
	   if(XmToggleButtonGetState(ShapeWids[i])==True)
	    {
	      sprintf(pathname,"%s",GetPathFromWid(CHOOSESHAPE_BROWSE,i));

	      importoutput2fileDialogCallback(w,(XtPointer)NULL,(XmFileSelectionBoxCallbackStruct *)pathname);
		  return;
	   }
	 }
  }
  else if(type==CHOOSE_ES1_BROWSE)
  {
    sprintf(tester,"%s",GetSelectedItem(CHOOSE_ES1_BROWSE_fw,w,1));
	if(strcmp(tester,errorsentinel))
	{	
      for(i=0;i<ES1WidsSaved;i++)
	  {
	   if(XmToggleButtonGetState(ES1Wids[i])==True)
	    {
	      sprintf(pathname,"%s\\%s",GetPathFromWid(CHOOSE_ES1_BROWSE,i),tester);
		 		  
	      browsefileDialogCallback((Widget)NULL,(XtPointer)CHOOSE_ES1_BROWSE,(XmFileSelectionBoxCallbackStruct *)pathname);

		  if(FAIL_PROJ_FOLDER==0)
		  {
			
			HandleSuccessDos(choose_es1_dialog);
		  }
	      return;
	    } 
	  } 
    }  
  }
  else if(type==CHOOSE_ES2_BROWSE)
  {
   sprintf(tester,"%s",GetSelectedItem(CHOOSE_ES2_BROWSE_fw,w,1));
	if(strcmp(tester,errorsentinel))
	{	
      for(i=0;i<ES2WidsSaved;i++)
	  {
	   if(XmToggleButtonGetState(ES2Wids[i])==True)
	    {
	      sprintf(pathname,"%s\\%s",GetPathFromWid(CHOOSE_ES2_BROWSE,i),tester);
		 		  
	      browsefileDialogCallback((Widget)NULL,(XtPointer)CHOOSE_ES2_BROWSE,(XmFileSelectionBoxCallbackStruct *)pathname);

		  if(FAIL_PROJ_FOLDER==0)
		  {
			
			HandleSuccessDos(choose_es2_dialog);
		  }
	      return;
	    } 
	  } 
    }  
  }
  else if(type==CHOOSE_TXT_BROWSE)
  {
	  
   
	foundit = 0;
    for(i=0;i<TXTWidsSaved;i++)
	  {
	   if(XmToggleButtonGetState(TXTWids[i])==True)
	    {
	      sprintf(pathname,"%s",GetPathFromWid(CHOOSE_TXT_BROWSE,i));
		  if(DOSDEBUG==1)
		  {
	       printf("Got path %s\n",pathname);
		  }
		  foundit = 1;
		  break;
	    } 
	  } 
      
	if(foundit==0)
	{
      not_while_running(XtParent(XtParent(XtParent(w))),"Error: No folder selected",1480,"Error",1);
	  return;
	}
      

	sprintf(tester,"%s",GetSelectedItem(CHOOSE_TXT_BROWSE_fw,w,0));

	if(!strcmp(tester,errorsentinel))
	{
	  sprintf(finalval,"%s",pathname);
	}
	else
	{
      sprintf(finalval,"%s\\%s",pathname,tester);
	}


    browsefileDialogCallback((Widget)NULL,(XtPointer)CHOOSE_TXT_BROWSE,(XmFileSelectionBoxCallbackStruct *)finalval);


	if(FAIL_PROJ_FOLDER==0)
	{
	  	
      HandleSuccessDos(choose_txt_dialog);
	}

  }


  else if(type==CHOOSE_XML1_BROWSE)
  {
    sprintf(tester,"%s",GetSelectedItem(CHOOSE_XML1_BROWSE_fw,w,2));
	if(strcmp(tester,errorsentinel))
	{	
      for(i=0;i<XML1WidsSaved;i++)
	  {
	   if(XmToggleButtonGetState(XML1Wids[i])==True)
	    {
	      sprintf(pathname,"%s\\%s",GetPathFromWid(CHOOSE_XML1_BROWSE,i),tester);
		 		  
	      browsefileDialogCallback((Widget)NULL,(XtPointer)CHOOSE_XML1_BROWSE,(XmFileSelectionBoxCallbackStruct *)pathname);

		  if(FAIL_PROJ_FOLDER==0)
		  {
			
			HandleSuccessDos(choose_xml1_dialog);
		  }
	      return;
	    } 
	  } 
    }  
  }
  else if(type==CHOOSE_XML2_BROWSE)
  {
   sprintf(tester,"%s",GetSelectedItem(CHOOSE_XML2_BROWSE_fw,w,3));
	if(strcmp(tester,errorsentinel))
	{	
      for(i=0;i<XML2WidsSaved;i++)
	  {
	   if(XmToggleButtonGetState(XML2Wids[i])==True)
	    {
	      sprintf(pathname,"%s\\%s",GetPathFromWid(CHOOSE_XML2_BROWSE,i),tester);
		 		  
	      browsefileDialogCallback((Widget)NULL,(XtPointer)CHOOSE_XML2_BROWSE,(XmFileSelectionBoxCallbackStruct *)pathname);

		  if(FAIL_PROJ_FOLDER==0)
		  {
			
			HandleSuccessDos(choose_xml2_dialog);
		  }
	      return;
	    } 
	  } 
    }  
  }
  else if(type==CHOOSE_XML3_BROWSE)
  {
	  
   
	foundit = 0;
    for(i=0;i<XML3WidsSaved;i++)
	  {
	   if(XmToggleButtonGetState(XML3Wids[i])==True)
	    {
	      sprintf(pathname,"%s",GetPathFromWid(CHOOSE_XML3_BROWSE,i));
		  if(DOSDEBUG==1)
		  {
	       printf("Got path %s\n",pathname);
		  }
		  foundit = 1;
		  break;
	    } 
	  } 
      
	if(foundit==0)
	{
      not_while_running(XtParent(XtParent(XtParent(w))),"Error: No folder selected",1480,"Error",1);
	  return;
	}
      

	sprintf(tester,"%s",GetSelectedItem(CHOOSE_XML3_BROWSE_fw,w,0));

	if(!strcmp(tester,errorsentinel))
	{
	  sprintf(finalval,"%s",pathname);
	}
	else
	{
      sprintf(finalval,"%s\\%s",pathname,tester);
	}


    browsefileDialogCallback((Widget)NULL,(XtPointer)CHOOSE_XML3_BROWSE,(XmFileSelectionBoxCallbackStruct *)finalval);


	if(FAIL_PROJ_FOLDER==0)
	{
	  	
      HandleSuccessDos(choose_xml3_dialog);
	}

  }
  else if(type==ATTRFOLDER_BROWSE)
    {
      for(i=0;i<AttrWidsSaved;i++)
	 {
	   if(XmToggleButtonGetState(AttrWids[i])==True)
	    {
	      sprintf(pathname,"%s",GetPathFromWid(ATTRFOLDER_BROWSE,i));

	      SetAttrFolderCallback(w,(XtPointer)NULL,(XmFileSelectionBoxCallbackStruct *)pathname);
		  return;
	   }
	 }
  }
  else if(type==CHOOSE_DP_BROWSE)
    {
      for(i=0;i<DPWidsSaved;i++)
	 {
	   if(XmToggleButtonGetState(DPWids[i])==True)
	    {
	      sprintf(pathname,"%s",GetPathFromWid(CHOOSE_DP_BROWSE,i));

	      SetDPFolderCallback(w,(XtPointer)NULL,(XmFileSelectionBoxCallbackStruct *)pathname);
		  return;
	   }
	 }
  }
  else if(type==CHOOSEBROWSE_BROWSE)
    {
      for(i=0;i<BrowseWidsSaved;i++)
	 {
	   if(XmToggleButtonGetState(BrowseWids[i])==True)
	    {
	      sprintf(pathname,"%s",GetPathFromWid(CHOOSEBROWSE_BROWSE,i));

		  SetBRFolderCallback(w,(XtPointer)NULL,(XmFileSelectionBoxCallbackStruct *)pathname);

		  return;
	   }
	 }
  }

  else
  {
	  printf("bad type %d to CDBC\n",type); 
  }
}


int DetermineClosed(char *pathname_in,int type, int level)
{
  XmString thename;
  int i,len,ignore,index,numcolon,maxindex;
  char pathname[1000],pathname2[1000];
  char *text;


  if(DOSDEBUG==1)
  {
    printf("determine closed takes in %s with level %d\n",pathname_in,level);
  }

  



  if(pathname_in[strlen(pathname_in)-1]!='\\')
  {
    sprintf(pathname,"%s\\",pathname_in);  
  }
  else
  {
    sprintf(pathname,"%s",pathname_in);  
  }
    

  len = strlen(pathname);

  maxindex = GetMaxIndex(type,"DetermineClosed");

  
  for(index=0;index<maxindex;index++)
   {

	 if(type==CHOOSEPROJ_BROWSE)
	  {
		 if((level<0)&&(ProjLevels[index]!=level))
		 {
		   
			 continue;
		 }

         if((level>=0)&&(ProjLevels[index]<0))
		 {
			 
			 continue;
		 }

        XtVaGetValues(ProjWids[index],XmNlabelString,&thename,NULL);
	  }
	 else if(type==CHOOSESHAPE_BROWSE)
	  {
		 if((level<0)&&(ShapeLevels[index]!=level))
		 {
		   
			 continue;
		 }

		 if((level>=0)&&(ShapeLevels[index]<0))
		 {
			 
			 continue;
		 }

	     XtVaGetValues(ShapeWids[index],XmNlabelString,&thename,NULL);
	  }
	 else if(type==CHOOSE_ES1_BROWSE)
	  {
		 if((level<0)&&(ES1Levels[index]!=level))
		 {
		   
			 continue;
		 }

		 if((level>=0)&&(ES1Levels[index]<0))
		 {
			 
			 continue;
		 }

        XtVaGetValues(ES1Wids[index],XmNlabelString,&thename,NULL);
	  }
	 else if(type==CHOOSE_ES2_BROWSE)
	  {
		 if((level<0)&&(ES2Levels[index]!=level))
		 {
		   
			 continue;
		 }

		 if((level>=0)&&(ES2Levels[index]<0))
		 {
			 
			 continue;
		 }

        XtVaGetValues(ES2Wids[index],XmNlabelString,&thename,NULL);
	  }
	 else if(type==CHOOSE_TXT_BROWSE)
	  {
		 if((level<0)&&(TXTLevels[index]!=level))
		 {
		   
			 continue;
		 }

		 if((level>=0)&&(TXTLevels[index]<0))
		 {
			 
			 continue;
		 }

        XtVaGetValues(TXTWids[index],XmNlabelString,&thename,NULL);
	  }



	 else if(type==CHOOSE_XML1_BROWSE)
	  {
		 if((level<0)&&(XML1Levels[index]!=level))
		 {
		   
			 continue;
		 }

		 if((level>=0)&&(XML1Levels[index]<0))
		 {
			 
			 continue;
		 }

        XtVaGetValues(XML1Wids[index],XmNlabelString,&thename,NULL);
	  }
	 else if(type==CHOOSE_XML2_BROWSE)
	  {
		 if((level<0)&&(XML2Levels[index]!=level))
		 {
		   
			 continue;
		 }

		 if((level>=0)&&(XML2Levels[index]<0))
		 {
			 
			 continue;
		 }

        XtVaGetValues(XML2Wids[index],XmNlabelString,&thename,NULL);
	  }
	 else if(type==CHOOSE_XML3_BROWSE)
	  {
		 if((level<0)&&(XML3Levels[index]!=level))
		 {
		   
			 continue;
		 }

		 if((level>=0)&&(XML3Levels[index]<0))
		 {
			 
			 continue;
		 }

        XtVaGetValues(XML3Wids[index],XmNlabelString,&thename,NULL);
	  }
	 else if(type==ATTRFOLDER_BROWSE)
	  {
		 if((level<0)&&(AttrLevels[index]!=level))
		 {
		   
			 continue;
		 }

		 if((level>=0)&&(AttrLevels[index]<0))
		 {
			 
			 continue;
		 }

	     XtVaGetValues(AttrWids[index],XmNlabelString,&thename,NULL);
	  }
	 else if(type==CHOOSE_DP_BROWSE)
	  {
		 if((level<0)&&(DPLevels[index]!=level))
		 {
		   
			 continue;
		 }

		 if((level>=0)&&(DPLevels[index]<0))
		 {
			 
			 continue;
		 }

	     XtVaGetValues(DPWids[index],XmNlabelString,&thename,NULL);
	  }
	 else if(type==CHOOSEBROWSE_BROWSE)
	  {
		 if((level<0)&&(BrowseLevels[index]!=level))
		 {
		   
			 continue;
		 }

		 if((level>=0)&&(BrowseLevels[index]<0))
		 {
			 
			 continue;
		 }

	     XtVaGetValues(BrowseWids[index],XmNlabelString,&thename,NULL);
	  }

	  else
	  {
	    printf("2 bad value %d to DetCl\n",type);
	  }
         


      XmStringGetLtoR(thename,(XmStringCharSet) XmSTRING_DEFAULT_CHARSET, &text);

	  XmStringFree(thename);



      len = strlen(text);
      numcolon = 0;
      for(i=0;i<len;i++)
	  {
	   if(text[i]==':')
	    {
	      numcolon = numcolon + 1;
	    }
	  }
      
	  ignore = 0;

	  if(
		  (!strncmp(text,deletesentinel,deletesentinellen)) ||
		  (!strncmp(text,deleteOpensentinel,deletesentinellen))
		)
	  {
		ignore = 1;
	  }
      else if(numcolon==1)
	{
	  sprintf(pathname2,"%s\\",GetPathFromWid(type,index));
	}
      else if(numcolon>1)
	{
	  sprintf(pathname2,"%s\\",GetPathFromWid(type,index));
	}
      else if(numcolon==0)
	{
	  sprintf(pathname2,"%s\\",GetPathFromWid(type,index));
	}
	  else
	{
	  printf("2 bad colon num in %s (%d)\n",text,numcolon);
	}

      XtFree(text); 

 

	  if(ignore==0)
	  {
        len = strlen(pathname);
        if(strcmp(pathname,pathname2))
		{
	      if(
			  (!strncmp(pathname,pathname2,len)) 
			  )
		  {
	      
			if(DOSDEBUG==1)
			{
	         printf("(1) %s is already open because of %s\n",pathname,pathname2);
			}
			
	       return 0;
		  }
		}
	  }
    }
  
 
  if(DOSDEBUG==1)
  {
	printf("%s was closed\n",pathname);
  }

  return 1;
}



void ReBuildWidgetList(int type)
{
  Widget *newlist,*newlist2;
  int *newlist3;
  int newnum=0,index,insertindex;
  

  

  
  if(type==CHOOSEPROJ_BROWSE)
    {
      for(index=0;index<ProjWidsSaved;index++)
	  {
	  if(ProjHands[index]!=NULL)
	    {
	      newnum = newnum + 1;
	    }
	  }

	  if(DOSDEBUG==1)
	  {
        printf("new list should have %d\n",newnum);
	  }

	  ProjWidsAllocced = newnum;
	  if(ProjWidsAllocced<WidChunk)
	  {
		  ProjWidsAllocced = WidChunk;
	  }

      newlist  = (Widget *)malloc(sizeof(Widget)*ProjWidsAllocced);
      newlist2 = (Widget *)malloc(sizeof(Widget)*ProjWidsAllocced);
      newlist3 = (int *)   malloc(SzI           *ProjWidsAllocced);
      insertindex = 0;

      for(index=0;index<ProjWidsSaved;index++)
	  {
	  if(ProjHands[index]!=NULL)
	    {
	      newlist [insertindex] = ProjWids  [index];
	      newlist2[insertindex] = ProjHands [index];
	      newlist3[insertindex] = ProjLevels[index];
	      insertindex = insertindex + 1;
	    }
	  }

	 if(ProjWidsSaved>0)
	 {
	   free(ProjWids);
	   free(ProjHands);
	   free(ProjLevels);
	 }

	 ProjWids   = newlist;
     ProjHands  = newlist2;
     ProjLevels = newlist3;
     ProjWidsSaved = newnum;
    }
  else if(type==CHOOSESHAPE_BROWSE)
    {
      for(index=0;index<ShapeWidsSaved;index++)
	  {
	  if(ShapeHands[index]!=NULL)
	    {
	      newnum = newnum + 1;
	    }
	  }

	  if(DOSDEBUG==1)
	  {
        printf("new list should have %d\n",newnum);
	  }

	  ShapeWidsAllocced = newnum;
	  if(ShapeWidsAllocced<WidChunk)
	  {
		  ShapeWidsAllocced = WidChunk;
	  }

      newlist  = (Widget *)malloc(sizeof(Widget)*ShapeWidsAllocced);
      newlist2 = (Widget *)malloc(sizeof(Widget)*ShapeWidsAllocced);
      newlist3 = (int *)   malloc(SzI           *ShapeWidsAllocced);
      insertindex = 0;

      for(index=0;index<ShapeWidsSaved;index++)
	  {
	  if(ShapeHands[index]!=NULL)
	    {
	      newlist [insertindex] = ShapeWids  [index];
	      newlist2[insertindex] = ShapeHands [index];
	      newlist3[insertindex] = ShapeLevels[index];
	      insertindex = insertindex + 1;
	    }
	  }

	 if(ShapeWidsSaved>0)
	 {
	   free(ShapeWids);
	   free(ShapeHands);
	   free(ShapeLevels);
	 }

	 ShapeWids   = newlist;
     ShapeHands  = newlist2;
     ShapeLevels = newlist3;
     ShapeWidsSaved = newnum;
    }
  else if(type==CHOOSE_ES1_BROWSE)
    {
      for(index=0;index<ES1WidsSaved;index++)
	  {
	  if(ES1Hands[index]!=NULL)
	    {
	      newnum = newnum + 1;
	    }
	  }

	  if(DOSDEBUG==1)
	  {
        printf("new list should have %d\n",newnum);
	  }

	  ES1WidsAllocced = newnum;
	  if(ES1WidsAllocced<WidChunk)
	  {
		  ES1WidsAllocced = WidChunk;
	  }

      newlist  = (Widget *)malloc(sizeof(Widget)*ES1WidsAllocced);
      newlist2 = (Widget *)malloc(sizeof(Widget)*ES1WidsAllocced);
      newlist3 = (int *)   malloc(SzI           *ES1WidsAllocced);
      insertindex = 0;

      for(index=0;index<ES1WidsSaved;index++)
	  {
	  if(ES1Hands[index]!=NULL)
	    {
	      newlist [insertindex] = ES1Wids  [index];
	      newlist2[insertindex] = ES1Hands [index];
	      newlist3[insertindex] = ES1Levels[index];
	      insertindex = insertindex + 1;
	    }
	  }

	 if(ES1WidsSaved>0)
	 {
	   free(ES1Wids);
	   free(ES1Hands);
	   free(ES1Levels);
	 }

	 ES1Wids   = newlist;
     ES1Hands  = newlist2;
     ES1Levels = newlist3;
     ES1WidsSaved = newnum;
    }  
  else if(type==CHOOSE_ES2_BROWSE)
    {
      for(index=0;index<ES2WidsSaved;index++)
	  {
	  if(ES2Hands[index]!=NULL)
	    {
	      newnum = newnum + 1;
	    }
	  }

	  if(DOSDEBUG==1)
	  {
        printf("new list should have %d\n",newnum);
	  }

	  ES2WidsAllocced = newnum;
	  if(ES2WidsAllocced<WidChunk)
	  {
		  ES2WidsAllocced = WidChunk;
	  }

      newlist  = (Widget *)malloc(sizeof(Widget)*ES2WidsAllocced);
      newlist2 = (Widget *)malloc(sizeof(Widget)*ES2WidsAllocced);
      newlist3 = (int *)   malloc(SzI           *ES2WidsAllocced);
      insertindex = 0;

      for(index=0;index<ES2WidsSaved;index++)
	  {
	  if(ES2Hands[index]!=NULL)
	    {
	      newlist [insertindex] = ES2Wids  [index];
	      newlist2[insertindex] = ES2Hands [index];
	      newlist3[insertindex] = ES2Levels[index];
	      insertindex = insertindex + 1;
	    }
	  }

	 if(ES2WidsSaved>0)
	 {
	   free(ES2Wids);
	   free(ES2Hands);
	   free(ES2Levels);
	 }

	 ES2Wids   = newlist;
     ES2Hands  = newlist2;
     ES2Levels = newlist3;
     ES2WidsSaved = newnum;
    }
	else if(type==CHOOSE_TXT_BROWSE)
    {
      for(index=0;index<TXTWidsSaved;index++)
	  {
	  if(TXTHands[index]!=NULL)
	    {
	      newnum = newnum + 1;
	    }
	  }

	  if(DOSDEBUG==1)
	  {
        printf("new list should have %d\n",newnum);
	  }

	  TXTWidsAllocced = newnum;
	  if(TXTWidsAllocced<WidChunk)
	  {
		  TXTWidsAllocced = WidChunk;
	  }

      newlist  = (Widget *)malloc(sizeof(Widget)*TXTWidsAllocced);
      newlist2 = (Widget *)malloc(sizeof(Widget)*TXTWidsAllocced);
      newlist3 = (int *)   malloc(SzI           *TXTWidsAllocced);
      insertindex = 0;

      for(index=0;index<TXTWidsSaved;index++)
	  {
	  if(TXTHands[index]!=NULL)
	    {
	      newlist [insertindex] = TXTWids  [index];
	      newlist2[insertindex] = TXTHands [index];
	      newlist3[insertindex] = TXTLevels[index];
	      insertindex = insertindex + 1;
	    }
	  }

	 if(TXTWidsSaved>0)
	 {
	   free(TXTWids);
	   free(TXTHands);
	   free(TXTLevels);
	 }

	 TXTWids   = newlist;
     TXTHands  = newlist2;
     TXTLevels = newlist3;
     TXTWidsSaved = newnum;
    }




  else if(type==CHOOSE_XML1_BROWSE)
    {
      for(index=0;index<XML1WidsSaved;index++)
	  {
	  if(XML1Hands[index]!=NULL)
	    {
	      newnum = newnum + 1;
	    }
	  }

	  if(DOSDEBUG==1)
	  {
        printf("new list should have %d\n",newnum);
	  }

	  XML1WidsAllocced = newnum;
	  if(XML1WidsAllocced<WidChunk)
	  {
		  XML1WidsAllocced = WidChunk;
	  }

      newlist  = (Widget *)malloc(sizeof(Widget)*XML1WidsAllocced);
      newlist2 = (Widget *)malloc(sizeof(Widget)*XML1WidsAllocced);
      newlist3 = (int *)   malloc(SzI           *XML1WidsAllocced);
      insertindex = 0;

      for(index=0;index<XML1WidsSaved;index++)
	  {
	  if(XML1Hands[index]!=NULL)
	    {
	      newlist [insertindex] = XML1Wids  [index];
	      newlist2[insertindex] = XML1Hands [index];
	      newlist3[insertindex] = XML1Levels[index];
	      insertindex = insertindex + 1;
	    }
	  }

	 if(XML1WidsSaved>0)
	 {
	   free(XML1Wids);
	   free(XML1Hands);
	   free(XML1Levels);
	 }

	 XML1Wids   = newlist;
     XML1Hands  = newlist2;
     XML1Levels = newlist3;
     XML1WidsSaved = newnum;
    }  
  else if(type==CHOOSE_XML2_BROWSE)
    {
      for(index=0;index<XML2WidsSaved;index++)
	  {
	  if(XML2Hands[index]!=NULL)
	    {
	      newnum = newnum + 1;
	    }
	  }

	  if(DOSDEBUG==1)
	  {
        printf("new list should have %d\n",newnum);
	  }

	  XML2WidsAllocced = newnum;
	  if(XML2WidsAllocced<WidChunk)
	  {
		  XML2WidsAllocced = WidChunk;
	  }

      newlist  = (Widget *)malloc(sizeof(Widget)*XML2WidsAllocced);
      newlist2 = (Widget *)malloc(sizeof(Widget)*XML2WidsAllocced);
      newlist3 = (int *)   malloc(SzI           *XML2WidsAllocced);
      insertindex = 0;

      for(index=0;index<XML2WidsSaved;index++)
	  {
	  if(XML2Hands[index]!=NULL)
	    {
	      newlist [insertindex] = XML2Wids  [index];
	      newlist2[insertindex] = XML2Hands [index];
	      newlist3[insertindex] = XML2Levels[index];
	      insertindex = insertindex + 1;
	    }
	  }

	 if(XML2WidsSaved>0)
	 {
	   free(XML2Wids);
	   free(XML2Hands);
	   free(XML2Levels);
	 }

	 XML2Wids   = newlist;
     XML2Hands  = newlist2;
     XML2Levels = newlist3;
     XML2WidsSaved = newnum;
    }  
  else if(type==CHOOSE_XML3_BROWSE)
    {
      for(index=0;index<XML3WidsSaved;index++)
	  {
	  if(XML3Hands[index]!=NULL)
	    {
	      newnum = newnum + 1;
	    }
	  }

	  if(DOSDEBUG==1)
	  {
        printf("new list should have %d\n",newnum);
	  }

	  XML3WidsAllocced = newnum;
	  if(XML3WidsAllocced<WidChunk)
	  {
		  XML3WidsAllocced = WidChunk;
	  }

      newlist  = (Widget *)malloc(sizeof(Widget)*XML3WidsAllocced);
      newlist2 = (Widget *)malloc(sizeof(Widget)*XML3WidsAllocced);
      newlist3 = (int *)   malloc(SzI           *XML3WidsAllocced);
      insertindex = 0;

      for(index=0;index<XML3WidsSaved;index++)
	  {
	  if(XML3Hands[index]!=NULL)
	    {
	      newlist [insertindex] = XML3Wids  [index];
	      newlist2[insertindex] = XML3Hands [index];
	      newlist3[insertindex] = XML3Levels[index];
	      insertindex = insertindex + 1;
	    }
	  }

	 if(XML3WidsSaved>0)
	 {
	   free(XML3Wids);
	   free(XML3Hands);
	   free(XML3Levels);
	 }

	 XML3Wids   = newlist;
     XML3Hands  = newlist2;
     XML3Levels = newlist3;
     XML3WidsSaved = newnum;
    }  
  else if(type==ATTRFOLDER_BROWSE)
    {
      for(index=0;index<AttrWidsSaved;index++)
	  {
	  if(AttrHands[index]!=NULL)
	    {
	      newnum = newnum + 1;
	    }
	  }

	  if(DOSDEBUG==1)
	  {
        printf("new list should have %d\n",newnum);
	  }

	  AttrWidsAllocced = newnum;
	  if(AttrWidsAllocced<WidChunk)
	  {
		  AttrWidsAllocced = WidChunk;
	  }

      newlist  = (Widget *)malloc(sizeof(Widget)*AttrWidsAllocced);
      newlist2 = (Widget *)malloc(sizeof(Widget)*AttrWidsAllocced);
      newlist3 = (int *)   malloc(SzI           *AttrWidsAllocced);
      insertindex = 0;

      for(index=0;index<AttrWidsSaved;index++)
	  {
	  if(AttrHands[index]!=NULL)
	    {
	      newlist [insertindex] = AttrWids  [index];
	      newlist2[insertindex] = AttrHands [index];
	      newlist3[insertindex] = AttrLevels[index];
	      insertindex = insertindex + 1;
	    }
	  }

	 if(AttrWidsSaved>0)
	 {
	   free(AttrWids);
	   free(AttrHands);
	   free(AttrLevels);
	 }

	 AttrWids   = newlist;
     AttrHands  = newlist2;
     AttrLevels = newlist3;
     AttrWidsSaved = newnum;
    }
  else if(type==CHOOSE_DP_BROWSE)
    {
      for(index=0;index<DPWidsSaved;index++)
	  {
	  if(DPHands[index]!=NULL)
	    {
	      newnum = newnum + 1;
	    }
	  }

	  if(DOSDEBUG==1)
	  {
        printf("new list should have %d\n",newnum);
	  }

	  DPWidsAllocced = newnum;
	  if(DPWidsAllocced<WidChunk)
	  {
		  DPWidsAllocced = WidChunk;
	  }

      newlist  = (Widget *)malloc(sizeof(Widget)*DPWidsAllocced);
      newlist2 = (Widget *)malloc(sizeof(Widget)*DPWidsAllocced);
      newlist3 = (int *)   malloc(SzI           *DPWidsAllocced);
      insertindex = 0;

      for(index=0;index<DPWidsSaved;index++)
	  {
	  if(DPHands[index]!=NULL)
	    {
	      newlist [insertindex] = DPWids  [index];
	      newlist2[insertindex] = DPHands [index];
	      newlist3[insertindex] = DPLevels[index];
	      insertindex = insertindex + 1;
	    }
	  }

	 if(DPWidsSaved>0)
	 {
	   free(DPWids);
	   free(DPHands);
	   free(DPLevels);
	 }

	 DPWids   = newlist;
     DPHands  = newlist2;
     DPLevels = newlist3;
     DPWidsSaved = newnum;
    }
  else if(type==CHOOSEBROWSE_BROWSE)
    {
      for(index=0;index<BrowseWidsSaved;index++)
	  {
	  if(BrowseHands[index]!=NULL)
	    {
	      newnum = newnum + 1;
	    }
	  }

	  if(DOSDEBUG==1)
	  {
        printf("new list should have %d\n",newnum);
	  }

	  BrowseWidsAllocced = newnum;
	  if(BrowseWidsAllocced<WidChunk)
	  {
		  BrowseWidsAllocced = WidChunk;
	  }

      newlist  = (Widget *)malloc(sizeof(Widget)*BrowseWidsAllocced);
      newlist2 = (Widget *)malloc(sizeof(Widget)*BrowseWidsAllocced);
      newlist3 = (int *)   malloc(SzI           *BrowseWidsAllocced);
      insertindex = 0;

      for(index=0;index<BrowseWidsSaved;index++)
	  {
	  if(BrowseHands[index]!=NULL)
	    {
	      newlist [insertindex] = BrowseWids  [index];
	      newlist2[insertindex] = BrowseHands [index];
	      newlist3[insertindex] = BrowseLevels[index];
	      insertindex = insertindex + 1;
	    }
	  }

	 if(BrowseWidsSaved>0)
	 {
	   free(BrowseWids);
	   free(BrowseHands);
	   free(BrowseLevels);
	 }

	 BrowseWids   = newlist;
     BrowseHands  = newlist2;
     BrowseLevels = newlist3;
     BrowseWidsSaved = newnum;
    }

  else
  {
	  printf("bad type %d to RBWL\n",type);
  }
}


void DeleteOldHandles(char *pathname, int type, int level)
{
  XmString thename;
  int index,maxindex;
  char *text;


  if(DOSDEBUG==1)
  {
    printf("ONLY delete for %s\n",pathname);
  }

  maxindex = GetMaxIndex(type,"DeleteOldHandles");

  for(index=0;index<maxindex;index++)
    {
	  if(type==CHOOSEPROJ_BROWSE)
	  {
	    if((level<0)&&(ProjLevels[index]!=level))
		{
		  
		  continue;
		}

        if((level>=0)&&(ProjLevels[index]<0))
		 {
			 
			 continue;
		 }

        XtVaGetValues(ProjWids[index],XmNlabelString,&thename,NULL);
	  }
	  else if(type==CHOOSESHAPE_BROWSE)
	  {
	    if((level<0)&&(ShapeLevels[index]!=level))
		{
		  
		  continue;
		}

        if((level>=0)&&(ShapeLevels[index]<0))
		 {
			 
			 continue;
		 }

        XtVaGetValues(ShapeWids[index],XmNlabelString,&thename,NULL);
	  }
	  else if(type==CHOOSE_ES1_BROWSE)
	  {
	    if((level<0)&&(ES1Levels[index]!=level))
		{
		  
		 continue;
		}

        if((level>=0)&&(ES1Levels[index]<0))
		 {
			 
			 continue;
		 }

         XtVaGetValues(ES1Wids[index],XmNlabelString,&thename,NULL);
	  }
	  else if(type==CHOOSE_ES2_BROWSE)
	  {
	    if((level<0)&&(ES2Levels[index]!=level))
		{
		  
		  continue;
		}

        if((level>=0)&&(ES2Levels[index]<0))
		 {
			 
			 continue;
		 }

        XtVaGetValues(ES2Wids[index],XmNlabelString,&thename,NULL);
	  }
	  else if(type==CHOOSE_TXT_BROWSE)
	  {
	    if((level<0)&&(TXTLevels[index]!=level))
		{
		  
		  continue;
		}

        if((level>=0)&&(TXTLevels[index]<0))
		 {
			 
			 continue;
		 }

        XtVaGetValues(TXTWids[index],XmNlabelString,&thename,NULL);
	  }



	  else if(type==CHOOSE_XML1_BROWSE)
	  {
	    if((level<0)&&(XML1Levels[index]!=level))
		{
		  
		 continue;
		}

        if((level>=0)&&(XML1Levels[index]<0))
		 {
			 
			 continue;
		 }

         XtVaGetValues(XML1Wids[index],XmNlabelString,&thename,NULL);
	  }
	  else if(type==CHOOSE_XML2_BROWSE)
	  {
	    if((level<0)&&(XML2Levels[index]!=level))
		{
		  
		 continue;
		}

        if((level>=0)&&(XML2Levels[index]<0))
		 {
			 
			 continue;
		 }

         XtVaGetValues(XML2Wids[index],XmNlabelString,&thename,NULL);
	  }
	  else if(type==CHOOSE_XML3_BROWSE)
	  {
	    if((level<0)&&(XML3Levels[index]!=level))
		{
		  
		 continue;
		}

        if((level>=0)&&(XML3Levels[index]<0))
		 {
			 
			 continue;
		 }

         XtVaGetValues(XML3Wids[index],XmNlabelString,&thename,NULL);
	  }
	  else if(type==ATTRFOLDER_BROWSE)
	  {
	    if((level<0)&&(AttrLevels[index]!=level))
		{
		  
		  continue;
		}

        if((level>=0)&&(AttrLevels[index]<0))
		 {
			 
			 continue;
		 }

        XtVaGetValues(AttrWids[index],XmNlabelString,&thename,NULL);
	  }
	  else if(type==CHOOSE_DP_BROWSE)
	  {
	    if((level<0)&&(DPLevels[index]!=level))
		{
		  
		  continue;
		}

        if((level>=0)&&(DPLevels[index]<0))
		 {
			 
			 continue;
		 }

        XtVaGetValues(DPWids[index],XmNlabelString,&thename,NULL);
	  }
	  else if(type==CHOOSEBROWSE_BROWSE)
	  {
	    if((level<0)&&(BrowseLevels[index]!=level))
		{
		  
		  continue;
		}

        if((level>=0)&&(BrowseLevels[index]<0))
		 {
			 
			 continue;
		 }

        XtVaGetValues(BrowseWids[index],XmNlabelString,&thename,NULL);
	  }
	  else
	  {
		  printf("bad flag %d to DELOLH\n",type);
	  }

	  XmStringGetLtoR(thename,(XmStringCharSet) XmSTRING_DEFAULT_CHARSET, &text);

	  if(
		  (!strncmp(text,deletesentinel,deletesentinellen)) ||
		  (!strncmp(text,deleteOpensentinel,deletesentinellen)) 
		)
	  {
		if(strstr(text,pathname)!=NULL)
		  {
			

			  if(DOSDEBUG==1)
			  {
			    printf("DELETING %s\n",text);
			  }

			  if(type==CHOOSEPROJ_BROWSE)
			  {
			   if(XtIsManaged(ProjHands[index]))
			   {
				XtUnmanageChild(ProjHands[index]);
			   }
	           XtDestroyWidget(ProjHands[index]);
               ProjHands[index] = NULL;

			   if(XtIsManaged(ProjWids[index]))
			   {
				XtUnmanageChild(ProjWids[index]);
			   }
	           XtDestroyWidget(ProjWids[index]);
               ProjWids[index] = NULL;
			  }

			  else if(type==CHOOSESHAPE_BROWSE)
			  {
			   if(XtIsManaged(ShapeHands[index]))
			   {
				XtUnmanageChild(ShapeHands[index]);
			   }
	           XtDestroyWidget(ShapeHands[index]);
               ShapeHands[index] = NULL;

			   if(XtIsManaged(ShapeWids[index]))
			   {
				XtUnmanageChild(ShapeWids[index]);
			   }
	           XtDestroyWidget(ShapeWids[index]);
               ShapeWids[index] = NULL;
			  }

			  else if(type==CHOOSE_ES1_BROWSE)
			  {
			   if(XtIsManaged(ES1Hands[index]))
			   {
				XtUnmanageChild(ES1Hands[index]);
			   }
	           XtDestroyWidget(ES1Hands[index]);
               ES1Hands[index] = NULL;

			   if(XtIsManaged(ES1Wids[index]))
			   {
				XtUnmanageChild(ES1Wids[index]);
			   }
	           XtDestroyWidget(ES1Wids[index]);
               ES1Wids[index] = NULL;
			  }

			  else if(type==CHOOSE_ES2_BROWSE)
			  {
			   if(XtIsManaged(ES2Hands[index]))
			   {
				XtUnmanageChild(ES2Hands[index]);
			   }
	           XtDestroyWidget(ES2Hands[index]);
               ES2Hands[index] = NULL;

			   if(XtIsManaged(ES2Wids[index]))
			   {
				XtUnmanageChild(ES2Wids[index]);
			   }
	           XtDestroyWidget(ES2Wids[index]);
               ES2Wids[index] = NULL;
			  }

			  else if(type==CHOOSE_TXT_BROWSE)
			  {
			   if(XtIsManaged(TXTHands[index]))
			   {
				XtUnmanageChild(TXTHands[index]);
			   }
	           XtDestroyWidget(TXTHands[index]);
               TXTHands[index] = NULL;

			   if(XtIsManaged(TXTWids[index]))
			   {
				XtUnmanageChild(TXTWids[index]);
			   }
	           XtDestroyWidget(TXTWids[index]);
               TXTWids[index] = NULL;
			  }



			  else if(type==CHOOSE_XML1_BROWSE)
			  {
			   if(XtIsManaged(XML1Hands[index]))
			   {
				XtUnmanageChild(XML1Hands[index]);
			   }
	           XtDestroyWidget(XML1Hands[index]);
               XML1Hands[index] = NULL;

			   if(XtIsManaged(XML1Wids[index]))
			   {
				XtUnmanageChild(XML1Wids[index]);
			   }
	           XtDestroyWidget(XML1Wids[index]);
               XML1Wids[index] = NULL;
			  }

  			  else if(type==CHOOSE_XML2_BROWSE)
			  {
			   if(XtIsManaged(XML2Hands[index]))
			   {
				XtUnmanageChild(XML2Hands[index]);
			   }
	           XtDestroyWidget(XML2Hands[index]);
               XML2Hands[index] = NULL;

			   if(XtIsManaged(XML2Wids[index]))
			   {
				XtUnmanageChild(XML2Wids[index]);
			   }
	           XtDestroyWidget(XML2Wids[index]);
               XML2Wids[index] = NULL;
			  }

  			  else if(type==CHOOSE_XML3_BROWSE)
			  {
			   if(XtIsManaged(XML3Hands[index]))
			   {
				XtUnmanageChild(XML3Hands[index]);
			   }
	           XtDestroyWidget(XML3Hands[index]);
               XML3Hands[index] = NULL;

			   if(XtIsManaged(XML3Wids[index]))
			   {
				XtUnmanageChild(XML3Wids[index]);
			   }
	           XtDestroyWidget(XML3Wids[index]);
               XML3Wids[index] = NULL;
			  }

			  else if(type==ATTRFOLDER_BROWSE)
			  {
			   if(XtIsManaged(AttrHands[index]))
			   {
				XtUnmanageChild(AttrHands[index]);
			   }
	           XtDestroyWidget(AttrHands[index]);
               AttrHands[index] = NULL;

			   if(XtIsManaged(AttrWids[index]))
			   {
				XtUnmanageChild(AttrWids[index]);
			   }
	           XtDestroyWidget(AttrWids[index]);
               AttrWids[index] = NULL;
			  }
			  else if(type==CHOOSE_DP_BROWSE)
			  {
			   if(XtIsManaged(DPHands[index]))
			   {
				XtUnmanageChild(DPHands[index]);
			   }
	           XtDestroyWidget(DPHands[index]);
               DPHands[index] = NULL;

			   if(XtIsManaged(DPWids[index]))
			   {
				XtUnmanageChild(DPWids[index]);
			   }
	           XtDestroyWidget(DPWids[index]);
               DPWids[index] = NULL;
			  }
			  else if(type==CHOOSEBROWSE_BROWSE)
			  {
			   if(XtIsManaged(BrowseHands[index]))
			   {
				XtUnmanageChild(BrowseHands[index]);
			   }
	           XtDestroyWidget(BrowseHands[index]);
               BrowseHands[index] = NULL;

			   if(XtIsManaged(BrowseWids[index]))
			   {
				XtUnmanageChild(BrowseWids[index]);
			   }
	           XtDestroyWidget(BrowseWids[index]);
               BrowseWids[index] = NULL;
			  }

			  else
			  {
				  printf("bad flag %d to deletter\n",type);
			  }
			}
		else
		{
			if(DOSDEBUG==1)
			{
			  printf("NOT deleting %s\n",text);
			}
		}
	  }
	  XtFree(text);
	  XmStringFree(thename);
	}

  ReBuildWidgetList(type);
}



void PrintStuff()
{
  XmString thename;
  char *text;
  int index;

printf("proj wids:\n");
  for(index=0;index<ProjWidsSaved;index++)
    {	
      XtVaGetValues(ProjWids[index],XmNlabelString,&thename,NULL);
	  XmStringGetLtoR(thename,(XmStringCharSet) XmSTRING_DEFAULT_CHARSET, &text);
	  printf("have %d %s\n",ProjLevels[index],text);
	  XtFree(text);
	  XmStringFree(thename);
	}
printf("shape wids:\n");
  for(index=0;index<ShapeWidsSaved;index++)
    {	
      XtVaGetValues(ShapeWids[index],XmNlabelString,&thename,NULL);
	  XmStringGetLtoR(thename,(XmStringCharSet) XmSTRING_DEFAULT_CHARSET, &text);
	  printf("have %s\n",text);
	  XtFree(text);
	  XmStringFree(thename);
	}
printf("es1 wids:\n");
  for(index=0;index<ES1WidsSaved;index++)
    {	
      XtVaGetValues(ES1Wids[index],XmNlabelString,&thename,NULL);
	  XmStringGetLtoR(thename,(XmStringCharSet) XmSTRING_DEFAULT_CHARSET, &text);
	  printf("have %s\n",text);
	  XtFree(text);
	  XmStringFree(thename);
	}
printf("es2 wids:\n");
  for(index=0;index<ES2WidsSaved;index++)
    {	
      XtVaGetValues(ES2Wids[index],XmNlabelString,&thename,NULL);
	  XmStringGetLtoR(thename,(XmStringCharSet) XmSTRING_DEFAULT_CHARSET, &text);
	  printf("have %s\n",text);
	  XtFree(text);
	  XmStringFree(thename);
	}
}


int DetermineRecursiveOpen(char *pathname,int type, int level)
{ 
  XmString thename;
  char teststring[1000];
  char *text;
  int index,maxindex;

  

 sprintf(teststring,"%s %s",deleteOpensentinel,pathname);

 maxindex = GetMaxIndex(type,"DetermineRecursiveOpen");

 
   for(index=0;index<maxindex;index++)
   {	 
     if(type==CHOOSEPROJ_BROWSE)
	 {
       if((level<0)&&(ProjLevels[index]!=level))
		{
	      
		 continue;
		}

       if((level>=0)&&(ProjLevels[index]<0))
		{ 
		  
		 continue;
		}

       XtVaGetValues(ProjWids[index],XmNlabelString,&thename,NULL);
	 }
	 else if(type==CHOOSESHAPE_BROWSE)
	 {
       if((level<0)&&(ShapeLevels[index]!=level))
		{
	      
		 continue;
		}

       if((level>=0)&&(ShapeLevels[index]<0))
		{ 
		  
		 continue;
		}

       XtVaGetValues(ShapeWids[index],XmNlabelString,&thename,NULL);
	 }
	 else if(type==CHOOSE_ES1_BROWSE)
	 {
       if((level<0)&&(ES1Levels[index]!=level))
		{
	      
		 continue;
		}

       if((level>=0)&&(ES1Levels[index]<0))
		{ 
		  
		 continue;
		}

       XtVaGetValues(ES1Wids[index],XmNlabelString,&thename,NULL);
	 }
	 else if(type==CHOOSE_ES2_BROWSE)
	 {
       if((level<0)&&(ES2Levels[index]!=level))
		{
	      
		 continue;
		}

       if((level>=0)&&(ES2Levels[index]<0))
		{ 
		  
		 continue;
		}

       XtVaGetValues(ES2Wids[index],XmNlabelString,&thename,NULL);
	 }
	 else if(type==CHOOSE_TXT_BROWSE)
	 {
       if((level<0)&&(TXTLevels[index]!=level))
		{
	      
		 continue;
		}

       if((level>=0)&&(TXTLevels[index]<0))
		{ 
		  
		 continue;
		}

       XtVaGetValues(TXTWids[index],XmNlabelString,&thename,NULL);
	 }



	 else if(type==CHOOSE_XML1_BROWSE)
	 {
       if((level<0)&&(XML1Levels[index]!=level))
		{
	      
		 continue;
		}

       if((level>=0)&&(XML1Levels[index]<0))
		{ 
		  
		 continue;
		}

       XtVaGetValues(XML1Wids[index],XmNlabelString,&thename,NULL);
	 }
	 else if(type==CHOOSE_XML2_BROWSE)
	 {
       if((level<0)&&(XML2Levels[index]!=level))
		{
	      
		 continue;
		}

       if((level>=0)&&(XML2Levels[index]<0))
		{ 
		  
		 continue;
		}

       XtVaGetValues(XML2Wids[index],XmNlabelString,&thename,NULL);
	 }
	 else if(type==CHOOSE_XML3_BROWSE)
	 {
       if((level<0)&&(XML3Levels[index]!=level))
		{
	      
		 continue;
		}

       if((level>=0)&&(XML3Levels[index]<0))
		{ 
		  
		 continue;
		}

       XtVaGetValues(XML3Wids[index],XmNlabelString,&thename,NULL);
	 }
	 else if(type==ATTRFOLDER_BROWSE)
	 {
       if((level<0)&&(AttrLevels[index]!=level))
		{
	      
		 continue;
		}

       if((level>=0)&&(AttrLevels[index]<0))
		{ 
		  
		 continue;
		}

       XtVaGetValues(AttrWids[index],XmNlabelString,&thename,NULL);
	 }
	 else if(type==CHOOSE_DP_BROWSE)
	 {
       if((level<0)&&(DPLevels[index]!=level))
		{
	      
		 continue;
		}

       if((level>=0)&&(DPLevels[index]<0))
		{ 
		  
		 continue;
		}

       XtVaGetValues(DPWids[index],XmNlabelString,&thename,NULL);
	 }
	 else if(type==CHOOSEBROWSE_BROWSE)
	 {
       if((level<0)&&(BrowseLevels[index]!=level))
		{
	      
		 continue;
		}

       if((level>=0)&&(BrowseLevels[index]<0))
		{ 
		  
		 continue;
		}

       XtVaGetValues(BrowseWids[index],XmNlabelString,&thename,NULL);
	 }
	 else
	 {
		 printf("bad flag %d to DRO\n",type);
	 }
      
     XmStringGetLtoR(thename,(XmStringCharSet) XmSTRING_DEFAULT_CHARSET, &text);
      
     if(!strcmp(teststring,text))
	 {
	   if(DOSDEBUG==1)
	   {
	    printf("Recursivly open This One\n");
	   }
      XtFree(text);
      XmStringFree(thename);
	  return 1;
	 } 
    XtFree(text);
    XmStringFree(thename);
   }
 return 0;
}


char *ExtractNetPath(char *pathname)
{
  int i,len,endval=-1;
  static char retval[1000];

  len = strlen(pathname);
  for(i=0;i<len;i++)
  {
	if(pathname[i]=='>')
	{
	 endval = i+3;
	 break;
	}
  }

  if(endval==-1)
  {
	  
	  endval = 0;
  }

  sprintf(retval,"%s",&pathname[endval]);
  return retval;
}





void AddTopLevelWidget(Widget topoutline, String thistrans, int type, char *thisdrive, int drivenum)
{
  Widget subhandle,suboutline,left,right;
  MyData *mydata3;

  subhandle = XtVaCreateManagedWidget("roothandle", xmHandleWidgetClass,
					  topoutline,
					  XmNtranslations, XtParseTranslationTable (thistrans),
					  NULL);
      
  left = XtVaCreateManagedWidget("left", xmPushButtonWidgetClass,
				     subhandle,
				     XmNlabelType,    XmPIXMAP,
				     XmNlabelPixmap,  minus_pix,					 
				     XmNtraversalOn,  False,
				     XmNtranslations, XtParseTranslationTable (thistrans),
				     NULL);

      
  right = XtVaCreateManagedWidget(thisdrive, xmToggleButtonWidgetClass,
				      subhandle,
				      XmNtraversalOn,   False,
				      XmNtranslations,  XtParseTranslationTable (thistrans),
				      XmNindicatorOn,   False,
				      NULL);
      
  AddWidToList(type,right,subhandle,2);
      
  suboutline = XtVaCreateManagedWidget("outlineChooseProjOnly", xmOutlineWidgetClass,
					   subhandle,
					   XmNindentation,  20,
					   XmNoutline,      TRUE,
					   XmNtranslations, XtParseTranslationTable (thistrans),
					   
					   NULL);
      
  
  mydata3  = (MyData *) (malloc(sizeof(MyData)));
  if(mydata3==NULL){printf("myb: out of allocation memory!\n"); ExitWrapper(-1);}
  mydata3->outlinewid = (XmOutlineWidget)suboutline;
  mydata3->level = 2;
  mydata3->type = type;   
  
  mydata3->pathname = (char *)malloc(5);
  sprintf(mydata3->pathname,"%c:",drivenum+65);
      
  XtAddCallback(left, 
    XmNactivateCallback, (XtCallbackProc)NEWToggleButtonHandleCB, 
    (XtPointer) mydata3);
      
  XtVaSetValues(subhandle, 
    XmNsubWidget, suboutline,
    NULL);
      
  XtAddCallback (right, XmNvalueChangedCallback,toggle_dos,(XtPointer)type);
      
  
  XtUnmanageChild(suboutline);
  XtVaSetValues(left, XmNlabelPixmap, plus_pix, NULL);
}



void AddDriveLetter(char *dname, int type,int drivenum)
{ 
  String temptrans; 
  Widget topoutline;
  XmString thename;
  char *text;
  int maxindex,index;


  maxindex = GetMaxIndex(type,"AddDriveLetter");

  if(type==CHOOSEPROJ_BROWSE)
  {
	topoutline = TopProjWidOutline;
	temptrans  = list_translations36;

	for(index=0;index<maxindex;index++)
	{
     XtVaGetValues(ProjWids[index],XmNlabelString,&thename,NULL);
	 if(ProjLevels[index]>0)
	  {
	    XmStringGetLtoR(thename,(XmStringCharSet) XmSTRING_DEFAULT_CHARSET, &text);
	    XmStringFree(thename);

		if(!strcmp(dname,text))
		{
			
			XtFree(text);
			return;
		}
		XtFree(text);
	  }
	}
  }
  else if(type==CHOOSESHAPE_BROWSE)
  {
	topoutline = TopShapeWidOutline;
	temptrans  = list_translations37;

	for(index=0;index<maxindex;index++)
	{
     XtVaGetValues(ShapeWids[index],XmNlabelString,&thename,NULL);
	 if(ShapeLevels[index]>0)
	  {
	    XmStringGetLtoR(thename,(XmStringCharSet) XmSTRING_DEFAULT_CHARSET, &text);
	    XmStringFree(thename);

		if(!strcmp(dname,text))
		{
			
			XtFree(text);
			return;
		}
		XtFree(text);
	  }
	}
   }
  else if(type==CHOOSE_ES1_BROWSE)
  {
	topoutline = TopES1WidOutline;
	temptrans  = list_translations39;

	for(index=0;index<maxindex;index++)
	{
     XtVaGetValues(ES1Wids[index],XmNlabelString,&thename,NULL);
	 if(ES1Levels[index]>0)
	  {
	    XmStringGetLtoR(thename,(XmStringCharSet) XmSTRING_DEFAULT_CHARSET, &text);
	    XmStringFree(thename);

		if(!strcmp(dname,text))
		{
			
			XtFree(text);
			return;
		}
		XtFree(text);
	  }
	}
   }
  else if(type==CHOOSE_ES2_BROWSE)
  {
	topoutline = TopES2WidOutline;
	temptrans  = list_translations41;

	for(index=0;index<maxindex;index++)
	{
     XtVaGetValues(ES2Wids[index],XmNlabelString,&thename,NULL);
	 if(ES2Levels[index]>0)
	  {
	    XmStringGetLtoR(thename,(XmStringCharSet) XmSTRING_DEFAULT_CHARSET, &text);
	    XmStringFree(thename);

		if(!strcmp(dname,text))
		{
			
			XtFree(text);
			return;
		}
		XtFree(text);
	  }
	}
   }
  else if(type==CHOOSE_TXT_BROWSE)
  {
	topoutline = TopTXTWidOutline;
	temptrans  = list_translations43;

	for(index=0;index<maxindex;index++)
	{
     XtVaGetValues(TXTWids[index],XmNlabelString,&thename,NULL);
	 if(TXTLevels[index]>0)
	  {
	    XmStringGetLtoR(thename,(XmStringCharSet) XmSTRING_DEFAULT_CHARSET, &text);
	    XmStringFree(thename);

		if(!strcmp(dname,text))
		{
			
			XtFree(text);
			return;
		}
		XtFree(text);
	  }
	}
   }




  else if(type==CHOOSE_XML1_BROWSE)
  {
	topoutline = TopXML1WidOutline;
	temptrans  = list_translations47;

	for(index=0;index<maxindex;index++)
	{
     XtVaGetValues(XML1Wids[index],XmNlabelString,&thename,NULL);
	 if(XML1Levels[index]>0)
	  {
	    XmStringGetLtoR(thename,(XmStringCharSet) XmSTRING_DEFAULT_CHARSET, &text);
	    XmStringFree(thename);

		if(!strcmp(dname,text))
		{
			
			XtFree(text);
			return;
		}
		XtFree(text);
	  }
	}
   }
  else if(type==CHOOSE_XML2_BROWSE)
  {
	topoutline = TopXML2WidOutline;
	temptrans  = list_translations49;

	for(index=0;index<maxindex;index++)
	{
     XtVaGetValues(XML2Wids[index],XmNlabelString,&thename,NULL);
	 if(XML2Levels[index]>0)
	  {
	    XmStringGetLtoR(thename,(XmStringCharSet) XmSTRING_DEFAULT_CHARSET, &text);
	    XmStringFree(thename);

		if(!strcmp(dname,text))
		{
			
			XtFree(text);
			return;
		}
		XtFree(text);
	  }
	}
   }
  else if(type==CHOOSE_XML3_BROWSE)
  {
	topoutline = TopXML3WidOutline;
	temptrans  = list_translations51;

	for(index=0;index<maxindex;index++)
	{
     XtVaGetValues(XML3Wids[index],XmNlabelString,&thename,NULL);
	 if(XML3Levels[index]>0)
	  {
	    XmStringGetLtoR(thename,(XmStringCharSet) XmSTRING_DEFAULT_CHARSET, &text);
	    XmStringFree(thename);

		if(!strcmp(dname,text))
		{
			
			XtFree(text);
			return;
		}
		XtFree(text);
	  }
	}
   }
  else if(type==ATTRFOLDER_BROWSE)
  {
	topoutline = TopAttrWidOutline;
	temptrans  = list_translations56;

	for(index=0;index<maxindex;index++)
	{
     XtVaGetValues(AttrWids[index],XmNlabelString,&thename,NULL);
	 if(AttrLevels[index]>0)
	  {
	    XmStringGetLtoR(thename,(XmStringCharSet) XmSTRING_DEFAULT_CHARSET, &text);
	    XmStringFree(thename);

		if(!strcmp(dname,text))
		{
			
			XtFree(text);
			return;
		}
		XtFree(text);
	  }
	}
   }
  else if(type==CHOOSE_DP_BROWSE)
  {
	topoutline = TopDPWidOutline;
	temptrans  = list_translations58;

	for(index=0;index<maxindex;index++)
	{
     XtVaGetValues(DPWids[index],XmNlabelString,&thename,NULL);
	 if(DPLevels[index]>0)
	  {
	    XmStringGetLtoR(thename,(XmStringCharSet) XmSTRING_DEFAULT_CHARSET, &text);
	    XmStringFree(thename);

		if(!strcmp(dname,text))
		{
			
			XtFree(text);
			return;
		}
		XtFree(text);
	  }
	}
   }
  else if(type==CHOOSEBROWSE_BROWSE)
  {
	topoutline = TopBRWidOutline;
	temptrans  = list_translations60;

	for(index=0;index<maxindex;index++)
	{
     XtVaGetValues(BrowseWids[index],XmNlabelString,&thename,NULL);
	 if(BrowseLevels[index]>0)
	  {
	    XmStringGetLtoR(thename,(XmStringCharSet) XmSTRING_DEFAULT_CHARSET, &text);
	    XmStringFree(thename);

		if(!strcmp(dname,text))
		{
			
			XtFree(text);
			return;
		}
		XtFree(text);
	  }
	}
   }
  else
  {
	printf("bad type in ADL %d\n",type);
  }
 
  

  AddTopLevelWidget(topoutline,temptrans,type,dname,drivenum);
}



void DeleteTopDriveLetter(int drivenum, int type)
{
  XmString thename;
  int len,maxindex,index;
  char pathname[1000],pathname2[1000],deletename[1000];
  char *text;
  
  

  maxindex = GetMaxIndex(type,"DeleteTopDriveLetter");

  sprintf(pathname,"%c:",65+drivenum);

  for(index=0;index<maxindex;index++)
  {	  
	  if(type==CHOOSEPROJ_BROWSE)
	  {
        XtVaGetValues(ProjWids[index],XmNlabelString,&thename,NULL);
	  }
	  else if(type==CHOOSESHAPE_BROWSE)
	  {
        XtVaGetValues(ShapeWids[index],XmNlabelString,&thename,NULL);
	  }
	  else if(type==CHOOSE_ES1_BROWSE)
	  {
        XtVaGetValues(ES1Wids[index],XmNlabelString,&thename,NULL);
	  }
	  else if(type==CHOOSE_ES2_BROWSE)
	  {
        XtVaGetValues(ES2Wids[index],XmNlabelString,&thename,NULL);
	  }
	  else if(type==CHOOSE_TXT_BROWSE)
	  {
        XtVaGetValues(TXTWids[index],XmNlabelString,&thename,NULL);
	  }
	  else if(type==CHOOSE_XML1_BROWSE)
	  {
        XtVaGetValues(XML1Wids[index],XmNlabelString,&thename,NULL);
	  }
	  else if(type==CHOOSE_XML2_BROWSE)
	  {
        XtVaGetValues(XML2Wids[index],XmNlabelString,&thename,NULL);
	  }
	  else if(type==CHOOSE_XML3_BROWSE)
	  {
        XtVaGetValues(XML3Wids[index],XmNlabelString,&thename,NULL);
	  }
	  else if(type==ATTRFOLDER_BROWSE)
	  {
        XtVaGetValues(AttrWids[index],XmNlabelString,&thename,NULL);
	  }
	  else if(type==CHOOSE_DP_BROWSE)
	  {
        XtVaGetValues(DPWids[index],XmNlabelString,&thename,NULL);
	  }
	  else if(type==CHOOSEBROWSE_BROWSE)
	  {
        XtVaGetValues(BrowseWids[index],XmNlabelString,&thename,NULL);
	  }
	  else
	  {
		  printf("bad type %d to DTD\n",type);
	  }
	      
      XmStringGetLtoR(thename,(XmStringCharSet) XmSTRING_DEFAULT_CHARSET, &text);
	  XmStringFree(thename);


      if(
		  (!strncmp(text,deletesentinel,deletesentinellen)) ||
		  (!strncmp(text,deleteOpensentinel,deletesentinellen))
		)
	  {
	    XtFree(text);
		continue;
	  }

	  XtFree(text);

	 sprintf(pathname2,"%s",GetPathFromWid(type,index));

     len = strlen(pathname);
	 if(1)    
		{
		  if(!strncmp(pathname,pathname2,len)) 
		    {
			  
			   
			  sprintf(deletename,"%s %s",deletesentinel,pathname2);
			  
			  if(type==CHOOSEPROJ_BROWSE)
			  {
				if(ProjLevels[index]>=0)
				{
                  XtVaSetValues(ProjWids[index],XmNlabelString,STRING(deletename),NULL);
				}
			  }
			  else if(type==CHOOSESHAPE_BROWSE)
			  {
				if(ShapeLevels[index]>=0)
				{
                  XtVaSetValues(ShapeWids[index],XmNlabelString,STRING(deletename),NULL);
				}
			  }
			  else if(type==CHOOSE_ES1_BROWSE)
			  {
				if(ES1Levels[index]>=0)
				{
                  XtVaSetValues(ES1Wids[index],XmNlabelString,STRING(deletename),NULL);
				}
			  }
			  else if(type==CHOOSE_ES2_BROWSE)
			  {
				if(ES2Levels[index]>=0)
				{
                  XtVaSetValues(ES2Wids[index],XmNlabelString,STRING(deletename),NULL);
				}
			  }
			  else if(type==CHOOSE_TXT_BROWSE)
			  {
				if(TXTLevels[index]>=0)
				{
                  XtVaSetValues(TXTWids[index],XmNlabelString,STRING(deletename),NULL);
				}
			  }
			  else if(type==CHOOSE_XML1_BROWSE)
			  {
				if(XML1Levels[index]>=0)
				{
                  XtVaSetValues(XML1Wids[index],XmNlabelString,STRING(deletename),NULL);
				}
			  }
			  else if(type==CHOOSE_XML2_BROWSE)
			  {
				if(XML2Levels[index]>=0)
				{
                  XtVaSetValues(XML2Wids[index],XmNlabelString,STRING(deletename),NULL);
				}
			  }
			  else if(type==CHOOSE_XML3_BROWSE)
			  {
				if(XML3Levels[index]>=0)
				{
                  XtVaSetValues(XML3Wids[index],XmNlabelString,STRING(deletename),NULL);
				}
			  }
			  else if(type==ATTRFOLDER_BROWSE)
			  {
				if(AttrLevels[index]>=0)
				{
                  XtVaSetValues(AttrWids[index],XmNlabelString,STRING(deletename),NULL);
				}
			  }
			  else if(type==CHOOSE_DP_BROWSE)
			  {
				if(DPLevels[index]>=0)
				{
                  XtVaSetValues(DPWids[index],XmNlabelString,STRING(deletename),NULL);
				}
			  }
			  else if(type==CHOOSEBROWSE_BROWSE)
			  {
				if(BrowseLevels[index]>=0)
				{
                  XtVaSetValues(BrowseWids[index],XmNlabelString,STRING(deletename),NULL);
				}
			  }
			  else
			  {
			    printf("(2) bad flag %d to NTBHCB\n",type);
			  }
		    }
		}
	 } 
  DeleteOldHandles(pathname,type,2);
}



void DeleteNetworkLevel(int level, int type)
{
  XmString thename;
  int maxindex,index,thislevel;
  char pathname2[1000],deletename[1000],nullstring[5];
  char *text;
  
  

  maxindex = GetMaxIndex(type,"DeleteNetworkLevel");
 
  for(index=0;index<maxindex;index++)
  {	  
	  if(type==CHOOSEPROJ_BROWSE)
	  {
        XtVaGetValues(ProjWids[index],XmNlabelString,&thename,NULL);
		thislevel = ProjLevels[index];
	  }
	  else if(type==CHOOSESHAPE_BROWSE)
	  {
        XtVaGetValues(ShapeWids[index],XmNlabelString,&thename,NULL);
		thislevel = ShapeLevels[index];
	  }
	  else if(type==CHOOSE_ES1_BROWSE)
	  {
        XtVaGetValues(ES1Wids[index],XmNlabelString,&thename,NULL);
		thislevel = ES1Levels[index];
	  }
	  else if(type==CHOOSE_ES2_BROWSE)
	  {
        XtVaGetValues(ES2Wids[index],XmNlabelString,&thename,NULL);
		thislevel = ES2Levels[index];
	  }
	  else if(type==CHOOSE_TXT_BROWSE)
	  {
        XtVaGetValues(TXTWids[index],XmNlabelString,&thename,NULL);
		thislevel = TXTLevels[index];
	  }
	  else if(type==CHOOSE_XML1_BROWSE)
	  {
        XtVaGetValues(XML1Wids[index],XmNlabelString,&thename,NULL);
		thislevel = XML1Levels[index];
	  }
	  else if(type==CHOOSE_XML2_BROWSE)
	  {
        XtVaGetValues(XML2Wids[index],XmNlabelString,&thename,NULL);
		thislevel = XML2Levels[index];
	  }
	  else if(type==CHOOSE_XML3_BROWSE)
	  {
        XtVaGetValues(XML3Wids[index],XmNlabelString,&thename,NULL);
		thislevel = XML3Levels[index];
	  }
	  else if(type==ATTRFOLDER_BROWSE)
	  {
        XtVaGetValues(AttrWids[index],XmNlabelString,&thename,NULL);
		thislevel = AttrLevels[index];
	  }
	  else if(type==CHOOSE_DP_BROWSE)
	  {
        XtVaGetValues(DPWids[index],XmNlabelString,&thename,NULL);
		thislevel = DPLevels[index];
	  }
	  else if(type==CHOOSEBROWSE_BROWSE)
	  {
        XtVaGetValues(BrowseWids[index],XmNlabelString,&thename,NULL);
		thislevel = BrowseLevels[index];
	  }
	  else
	  {
		  printf("bad type %d to DNL\n",type);
	  }

			  
      XmStringGetLtoR(thename,(XmStringCharSet) XmSTRING_DEFAULT_CHARSET, &text);
	  XmStringFree(thename);


      if(
		  (!strncmp(text,deletesentinel,deletesentinellen)) ||
		  (!strncmp(text,deleteOpensentinel,deletesentinellen))
		)
	  {
	    XtFree(text);
		continue;
	  }

	  sprintf(pathname2,"%s",text);

	  XtFree(text);

	 if(thislevel==level)
	 {
	  

	  sprintf(deletename,"%s %s",deletesentinel,pathname2);
			  
	  if(type==CHOOSEPROJ_BROWSE)
	  {
         XtVaSetValues(ProjWids[index],XmNlabelString,STRING(deletename),NULL);
	  }
	  else if(type==CHOOSESHAPE_BROWSE)
	  {
         XtVaSetValues(ShapeWids[index],XmNlabelString,STRING(deletename),NULL);
	  }
	  else if(type==CHOOSE_ES1_BROWSE)
	  {
         XtVaSetValues(ES1Wids[index],XmNlabelString,STRING(deletename),NULL);
	  }
	  else if(type==CHOOSE_ES2_BROWSE)
	  {
         XtVaSetValues(ES2Wids[index],XmNlabelString,STRING(deletename),NULL);
	  }
	  else if(type==CHOOSE_TXT_BROWSE)
	  {
         XtVaSetValues(TXTWids[index],XmNlabelString,STRING(deletename),NULL);
	  }
	  else if(type==CHOOSE_XML1_BROWSE)
	  {
         XtVaSetValues(XML1Wids[index],XmNlabelString,STRING(deletename),NULL);
	  }
	  else if(type==CHOOSE_XML2_BROWSE)
	  {
         XtVaSetValues(XML2Wids[index],XmNlabelString,STRING(deletename),NULL);
	  }
	  else if(type==CHOOSE_XML3_BROWSE)
	  {
         XtVaSetValues(XML3Wids[index],XmNlabelString,STRING(deletename),NULL);
	  }
	  else if(type==ATTRFOLDER_BROWSE)
	  {
         XtVaSetValues(AttrWids[index],XmNlabelString,STRING(deletename),NULL);
	  }
	  else if(type==CHOOSE_DP_BROWSE)
	  {
         XtVaSetValues(DPWids[index],XmNlabelString,STRING(deletename),NULL);
	  }
	  else if(type==CHOOSEBROWSE_BROWSE)
	  {
         XtVaSetValues(BrowseWids[index],XmNlabelString,STRING(deletename),NULL);
	  }
      else
	  {
	    printf("(2) bad flag %d to NTBHCB\n",type);
	  }
    }
  }
  
  nullstring[0] = '\0';
  DeleteOldHandles(nullstring,type,level);
}




int GetNumNetLevels(int type)
{
  int index,thislevel,maxindex,startlevel=5;


  maxindex = GetMaxIndex(type,"GetNumNetLevels");
 
  for(index=0;index<maxindex;index++)
  {
    if(type==CHOOSEPROJ_BROWSE)
	{
	  thislevel = ProjLevels[index];
	  if(thislevel>=0)
	  {
		continue;
	  }
	  if(startlevel>0)
	  {
	    startlevel = thislevel;
	  }
	  else if(startlevel!=thislevel)
	  {
		return 2;
	  }
	}
    else if(type==CHOOSESHAPE_BROWSE)
	{
	  thislevel = ShapeLevels[index];
	  if(thislevel>=0)
	  {
		continue;
	  }
	  if(startlevel>0)
	  {
	    startlevel = thislevel;
	  }
	  else if(startlevel!=thislevel)
	  {
		return 2;
	  }
	}
    else if(type==CHOOSE_ES1_BROWSE)
	{
	  thislevel = ES1Levels[index];
	  if(thislevel>=0)
	  {
		continue;
	  }
	  if(startlevel>0)
	  {
	    startlevel = thislevel;
	  }
	  else if(startlevel!=thislevel)
	  {
		return 2;
	  }
	}
    else if(type==CHOOSE_ES2_BROWSE)
	{
	  thislevel = ES2Levels[index];
	  if(thislevel>=0)
	  {
		continue;
	  }
	  if(startlevel>0)
	  {
	    startlevel = thislevel;
	  }
	  else if(startlevel!=thislevel)
	  {
		return 2;
	  }
	}
    else if(type==CHOOSE_TXT_BROWSE)
	{
	  thislevel = TXTLevels[index];
	  if(thislevel>=0)
	  {
		continue;
	  }
	  if(startlevel>0)
	  {
	    startlevel = thislevel;
	  }
	  else if(startlevel!=thislevel)
	  {
		return 2;
	  }
	}
    else if(type==CHOOSE_XML1_BROWSE)
	{
	  thislevel = XML1Levels[index];
	  if(thislevel>=0)
	  {
		continue;
	  }
	  if(startlevel>0)
	  {
	    startlevel = thislevel;
	  }
	  else if(startlevel!=thislevel)
	  {
		return 2;
	  }
	}
    else if(type==CHOOSE_XML2_BROWSE)
	{
	  thislevel = XML2Levels[index];
	  if(thislevel>=0)
	  {
		continue;
	  }
	  if(startlevel>0)
	  {
	    startlevel = thislevel;
	  }
	  else if(startlevel!=thislevel)
	  {
		return 2;
	  }
	}
    else if(type==CHOOSE_XML3_BROWSE)
	{
	  thislevel = XML3Levels[index];
	  if(thislevel>=0)
	  {
		continue;
	  }
	  if(startlevel>0)
	  {
	    startlevel = thislevel;
	  }
	  else if(startlevel!=thislevel)
	  {
		return 2;
	  }
	}
    else if(type==ATTRFOLDER_BROWSE)
	{
	  thislevel = AttrLevels[index];
	  if(thislevel>=0)
	  {
		continue;
	  }
	  if(startlevel>0)
	  {
	    startlevel = thislevel;
	  }
	  else if(startlevel!=thislevel)
	  {
		return 2;
	  }
	}
    else if(type==CHOOSE_DP_BROWSE)
	{
	  thislevel = DPLevels[index];
	  if(thislevel>=0)
	  {
		continue;
	  }
	  if(startlevel>0)
	  {
	    startlevel = thislevel;
	  }
	  else if(startlevel!=thislevel)
	  {
		return 2;
	  }
	}
    else if(type==CHOOSEBROWSE_BROWSE)
	{
	  thislevel = BrowseLevels[index];
	  if(thislevel>=0)
	  {
		continue;
	  }
	  if(startlevel>0)
	  {
	    startlevel = thislevel;
	  }
	  else if(startlevel!=thislevel)
	  {
		return 2;
	  }
	}
	else
	{
		printf("bad type %d to GNNL \n",type);
	}
  }
  return 0;
}



void CloseNetsOff(int type)
{
  Widget outlinewid,leftwid,rightwid;
  int toponoff;

  if(type==CHOOSEPROJ_BROWSE)
  {
    toponoff     = NPPFOnOff1;
    outlinewid   = choosenetproj_top;
    leftwid      = choosenetproj_left;
    rightwid     = choosenetproj_right;
	NPPFOnOff1   = 0; 
  }
  else if(type==CHOOSESHAPE_BROWSE)
  {
    toponoff     = NPSFOnOff1;
	outlinewid   = choosenetshape_top;
	leftwid      = choosenetshape_left;
	rightwid     = choosenetshape_right;
	NPSFOnOff1   = 0; 
  }
  else if(type==CHOOSE_ES1_BROWSE)
  {
    toponoff     = NPES1OnOff1;
    outlinewid   = choosenet_es1_top;
    leftwid      = choosenet_es1_left;
    rightwid     = choosenet_es1_right;
	NPES1OnOff1  = 0; 
  }
  else if(type==CHOOSE_ES2_BROWSE)
  {
    toponoff     = NPES2OnOff1;
    outlinewid   = choosenet_es2_top;
    leftwid      = choosenet_es2_left;
    rightwid     = choosenet_es2_right;
	NPES2OnOff1  = 0; 
  }
  else if(type==CHOOSE_TXT_BROWSE)
  {
    toponoff     = NPTXTOnOff1;
    outlinewid   = choosenet_txt_top;
    leftwid      = choosenet_txt_left;
    rightwid     = choosenet_txt_right;
    NPTXTOnOff1  = 0; 
  }
  else if(type==CHOOSE_XML1_BROWSE)
  {
    toponoff     = NPXML1OnOff1;
    outlinewid   = choosenet_xml1_top;
    leftwid      = choosenet_xml1_left;
    rightwid     = choosenet_xml1_right;
	NPXML1OnOff1  = 0; 
  }
  else if(type==CHOOSE_XML2_BROWSE)
  {
    toponoff     = NPXML2OnOff1;
    outlinewid   = choosenet_xml2_top;
    leftwid      = choosenet_xml2_left;
    rightwid     = choosenet_xml2_right;
	NPXML2OnOff1  = 0; 
  }
  else if(type==CHOOSE_XML3_BROWSE)
  {
    toponoff     = NPXML3OnOff1;
    outlinewid   = choosenet_xml3_top;
    leftwid      = choosenet_xml3_left;
    rightwid     = choosenet_xml1_right;
	NPXML3OnOff1  = 0; 
  }
  else if(type==ATTRFOLDER_BROWSE)
  {
    toponoff     = NPCAOnOff1;
	outlinewid   = choosenetattr_top;
	leftwid      = choosenetattr_left;
	rightwid     = choosenetattr_right;
	NPCAOnOff1   = 0; 
  }
  else if(type==CHOOSE_DP_BROWSE)
  {
    toponoff     = NPDPOnOff1;
	outlinewid   = choosenetdp_top;
	leftwid      = choosenetdp_left;
	rightwid     = choosenetdp_right;
	NPDPOnOff1   = 0; 
  }
  else if(type==CHOOSEBROWSE_BROWSE)
  {
    toponoff     = NPBROnOff1;
	outlinewid   = choosenetbr_top;
	leftwid      = choosenetbr_left;
	rightwid     = choosenetbr_right;
	NPBROnOff1   = 0; 
  }
  else
    {
      XBell(mydisplay,50);
      printf("CNO called with  bad flag %d\n",type);
      return;
    }
 

  if(toponoff==1)
  {
    
    XtUnmanageChild(outlinewid);
    XtVaSetValues(leftwid    , XmNlabelPixmap, plus_pix, NULL);
  }


}




void AddNetPlace(Widget outlinewid, int type, char *netname, String thistrans)
{
  Widget left,right,subsuboutline,subsubhandle;
  MyData *mydata3;
  int i,uselevel,index,thislevel,maxindex;
  int levelsfound[10000];

  maxindex = GetMaxIndex(type,"AddNetPlace");

  for(i=1;i<10000;i++)
  {
	levelsfound[i] = 0;
  }
 
  for(index=0;index<maxindex;index++)
  {
	if(type==CHOOSEPROJ_BROWSE)
	{
	 thislevel = ProjLevels[index];

	 if(thislevel<0)
	 {
	   levelsfound[thislevel*-1] = 1;
	 }
	}
	else if(type==CHOOSESHAPE_BROWSE)
	{
	 thislevel = ShapeLevels[index];
	 if(thislevel<0)
	 {
	   levelsfound[thislevel*-1] = 1;
	 }
	}
	else if(type==CHOOSE_ES1_BROWSE)
	{
	 thislevel = ES1Levels[index];
	 if(thislevel<0)
	 {
	   levelsfound[thislevel*-1] = 1;
	 }
	}
	else if(type==CHOOSE_ES2_BROWSE)
	{
	 thislevel = ES2Levels[index];
	 if(thislevel<0)
	 {
	   levelsfound[thislevel*-1] = 1;
	 }
	}
	else if(type==CHOOSE_TXT_BROWSE)
	{
	 thislevel = TXTLevels[index];
	 if(thislevel<0)
	 {
	   levelsfound[thislevel*-1] = 1;
	 }
	}
	else if(type==CHOOSE_XML1_BROWSE)
	{
	 thislevel = XML1Levels[index];
	 if(thislevel<0)
	 {
	   levelsfound[thislevel*-1] = 1;
	 }
	}
	else if(type==CHOOSE_XML2_BROWSE)
	{
	 thislevel = XML2Levels[index];
	 if(thislevel<0)
	 {
	   levelsfound[thislevel*-1] = 1;
	 }
	}
	else if(type==CHOOSE_XML3_BROWSE)
	{
	 thislevel = XML3Levels[index];
	 if(thislevel<0)
	 {
	   levelsfound[thislevel*-1] = 1;
	 }
	}
	else if(type==ATTRFOLDER_BROWSE)
	{
	 thislevel = AttrLevels[index];
	 if(thislevel<0)
	 {
	   levelsfound[thislevel*-1] = 1;
	 }
	}
	else if(type==CHOOSE_DP_BROWSE)
	{
	 thislevel = DPLevels[index];
	 if(thislevel<0)
	 {
	   levelsfound[thislevel*-1] = 1;
	 }
	}
	else if(type==CHOOSEBROWSE_BROWSE)
	{
	 thislevel = BrowseLevels[index];
	 if(thislevel<0)
	 {
	   levelsfound[thislevel*-1] = 1;
	 }
	}
	else
	{
	  printf("ANP called with bad type %d\n",type);
	  return;
	}
  }

  uselevel = 999;
  for(i=1;i<10000;i++)
  {
	if(levelsfound[i]==0)
	{
	  uselevel = -1*i;
	  break;
	}
  }

  if(uselevel>=0)
  {
	printf("error: could not find usable level for new net place %s\n",netname);
	return;
  }

  

  subsubhandle = XtVaCreateManagedWidget("roothandle", xmHandleWidgetClass,
			  outlinewid,
			  XmNtranslations, XtParseTranslationTable (thistrans),
			  NULL);
      
  left = XtVaCreateManagedWidget("left", xmPushButtonWidgetClass,
		     subsubhandle,
		     XmNlabelType,    XmPIXMAP,
		     XmNlabelPixmap,  minus_pix,					 
		     XmNtraversalOn,  False,
		     XmNtranslations, XtParseTranslationTable (thistrans),
		     NULL);

      
  right = XtVaCreateManagedWidget(netname, xmToggleButtonWidgetClass,
			      subsubhandle,
			      XmNtraversalOn,   False,
			      XmNtranslations,  XtParseTranslationTable (thistrans),
			      XmNindicatorOn,   False,
			      NULL);
      
  AddWidToList(type,right,subsubhandle,uselevel);
      
  subsuboutline = XtVaCreateManagedWidget("outlineChooseProjOnly", xmOutlineWidgetClass,
				   subsubhandle,
				   XmNindentation,  20,
				   XmNoutline,      TRUE,
				   XmNtranslations, XtParseTranslationTable (thistrans),
				   
				   NULL);
      
  
  mydata3  = (MyData *) (malloc(sizeof(MyData)));
  if(mydata3==NULL){printf("myb: out of allocation memory!\n"); ExitWrapper(-1);}
  mydata3->outlinewid = (XmOutlineWidget)subsuboutline;
  mydata3->level = uselevel;
  mydata3->type = type;
      
  mydata3->pathname = (char *)malloc(500);
  sprintf(mydata3->pathname,"%s",ExtractNetPath(netname));
      
  XtAddCallback(left, 
            XmNactivateCallback, (XtCallbackProc)NEWToggleButtonHandleCB, 
            (XtPointer) mydata3);
      
  XtVaSetValues(subsubhandle, 
		    XmNsubWidget, subsuboutline,
		    NULL);
      
  XtAddCallback (right, XmNvalueChangedCallback,toggle_dos,(XtPointer)type);
      
  

  XtUnmanageChild(subsuboutline);
  XtVaSetValues(left, XmNlabelPixmap, plus_pix, NULL);

}




void RebuildNetworkLocs(int type)
{
  Widget outlinewid;
  XmString thename;
  int i,index,savelevel,foundit,maxindex;
  int oklevels[10000],deletemelevels[10000];
  char thisname[1000];
  char *text;
  String thistrans;

  for(i=0;i<10000;i++)
  {
	oklevels[i]       = 0;
	deletemelevels[i] = 0;
  }

  maxindex = GetMaxIndex(type,"RebuildNetworkLocs");

  if(type==CHOOSEPROJ_BROWSE)
  {
    thistrans  = list_translations36;
    outlinewid = choosenetproj_top;
  }
  else if(type==CHOOSESHAPE_BROWSE)
  {
    thistrans  = list_translations37;
	outlinewid = choosenetshape_top;
  }
  else if(type==CHOOSE_ES1_BROWSE)
  {
    thistrans  = list_translations39;
    outlinewid = choosenet_es1_top;
   }
  else if(type==CHOOSE_ES2_BROWSE)
  {
    thistrans  = list_translations41;
    outlinewid = choosenet_es2_top;
   }
  else if(type==CHOOSE_TXT_BROWSE)
  {
    thistrans  = list_translations43;
    outlinewid = choosenet_txt_top;
  }
  else if(type==CHOOSE_XML1_BROWSE)
  {
    thistrans  = list_translations47;
    outlinewid = choosenet_xml1_top;
   }
  else if(type==CHOOSE_XML2_BROWSE)
  {
    thistrans  = list_translations49;
    outlinewid = choosenet_xml2_top;
   }
  else if(type==CHOOSE_XML3_BROWSE)
  {
    thistrans  = list_translations51;
    outlinewid = choosenet_xml3_top;
   }
  else if(type==ATTRFOLDER_BROWSE)
  {    
    thistrans  = list_translations56;
	outlinewid = choosenetattr_top;
  }
  else if(type==CHOOSE_DP_BROWSE)
  {    
    thistrans  = list_translations58;
	outlinewid = choosenetdp_top;
  }
  else if(type==CHOOSEBROWSE_BROWSE)
  {
    thistrans  = list_translations60;
	outlinewid = choosenetbr_top;
  }
  else
  {
	printf("bad type in RBNL %d\n",type);
  }


  for(i=0;i<NumNetDrives;i++)
   {
	 foundit = 0;
     sprintf(thisname,"<%s>: %s",NetDriveNames[i],NetDrivePaths[i]);

	 

     for(index=0;index<maxindex;index++)
	 {
	   if(type==CHOOSEPROJ_BROWSE)
	   {
		 savelevel = ProjLevels[index];

		 if(savelevel>=0)
		 {
		   continue;
		 }
		 else if(oklevels[savelevel*-1]==1)
		 {
		   continue;
		 }
		 else
		 {
	       XtVaGetValues(ProjWids[index],XmNlabelString,&thename,NULL);
		 } 
	   }
	   else if(type==CHOOSESHAPE_BROWSE)
	   {
		 savelevel = ShapeLevels[index];

		 if(savelevel>=0)
		 {
		   continue;
		 }
		 else if(oklevels[savelevel*-1]==1)
		 {
		   continue;
		 }
		 else
		 {
	       XtVaGetValues(ShapeWids[index],XmNlabelString,&thename,NULL);
		 } 
	   }
	   else if(type==CHOOSE_ES1_BROWSE)
	   {
		 savelevel = ES1Levels[index];

		 if(savelevel>=0)
		 {
		   continue;
		 }
		 else if(oklevels[savelevel*-1]==1)
		 {
		   continue;
		 }
		 else
		 {
	       XtVaGetValues(ES1Wids[index],XmNlabelString,&thename,NULL);
		 } 
	   }
	   else if(type==CHOOSE_ES2_BROWSE)
	   {
		 savelevel = ES2Levels[index];

		 if(savelevel>=0)
		 {
		   continue;
		 }
		 else if(oklevels[savelevel*-1]==1)
		 {
		   continue;
		 }
		 else
		 {
	       XtVaGetValues(ES2Wids[index],XmNlabelString,&thename,NULL);
		 } 
	   }
	   else if(type==CHOOSE_TXT_BROWSE)
	   {
		 savelevel = TXTLevels[index];

		 if(savelevel>=0)
		 {
		   continue;
		 }
		 else if(oklevels[savelevel*-1]==1)
		 {
		   continue;
		 }
		 else
		 {
	       XtVaGetValues(TXTWids[index],XmNlabelString,&thename,NULL);
		 }
	   }
	   else if(type==CHOOSE_XML1_BROWSE)
	   {
		 savelevel = XML1Levels[index];

		 if(savelevel>=0)
		 {
		   continue;
		 }
		 else if(oklevels[savelevel*-1]==1)
		 {
		   continue;
		 }
		 else
		 {
	       XtVaGetValues(XML1Wids[index],XmNlabelString,&thename,NULL);
		 } 
	   }
	   else if(type==CHOOSE_XML2_BROWSE)
	   {
		 savelevel = XML2Levels[index];

		 if(savelevel>=0)
		 {
		   continue;
		 }
		 else if(oklevels[savelevel*-1]==1)
		 {
		   continue;
		 }
		 else
		 {
	       XtVaGetValues(XML2Wids[index],XmNlabelString,&thename,NULL);
		 } 
	   }
	   else if(type==CHOOSE_XML3_BROWSE)
	   {
		 savelevel = XML3Levels[index];

		 if(savelevel>=0)
		 {
		   continue;
		 }
		 else if(oklevels[savelevel*-1]==1)
		 {
		   continue;
		 }
		 else
		 {
	       XtVaGetValues(XML3Wids[index],XmNlabelString,&thename,NULL);
		 } 
	   }
	   else if(type==ATTRFOLDER_BROWSE)
	   {
		 savelevel = AttrLevels[index];

		 if(savelevel>=0)
		 {
		   continue;
		 }
		 else if(oklevels[savelevel*-1]==1)
		 {
		   continue;
		 }
		 else
		 {
	       XtVaGetValues(AttrWids[index],XmNlabelString,&thename,NULL);
		 } 
	   }
	   else if(type==CHOOSE_DP_BROWSE)
	   {
		 savelevel = DPLevels[index];

		 if(savelevel>=0)
		 {
		   continue;
		 }
		 else if(oklevels[savelevel*-1]==1)
		 {
		   continue;
		 }
		 else
		 {
	       XtVaGetValues(DPWids[index],XmNlabelString,&thename,NULL);
		 } 
	   }
	   else if(type==CHOOSEBROWSE_BROWSE)
	   {
		 savelevel = BrowseLevels[index];

		 if(savelevel>=0)
		 {
		   continue;
		 }
		 else if(oklevels[savelevel*-1]==1)
		 {
		   continue;
		 }
		 else
		 {
	       XtVaGetValues(BrowseWids[index],XmNlabelString,&thename,NULL);
		 } 
	   }
	   else
	   {
         XBell(mydisplay,50);
		 printf("bad type %d to SNE\n",type);
	   }
	   

	   XmStringGetLtoR(thename,(XmStringCharSet) XmSTRING_DEFAULT_CHARSET, &text);
	   XmStringFree(thename);

	   if(!strcmp(text,thisname))
	   {
		 
         oklevels[savelevel*-1] = 1;
		 foundit = 1;
	   }
	   XtFree(text);
	 } 

     if(foundit==0)
	 {
	   
	   AddNetPlace(outlinewid,type,thisname,thistrans);
	 }

  } 




  

  

  

  for(index=0;index<maxindex;index++)
  {

    

    if(type==CHOOSEPROJ_BROWSE)
    {
	  savelevel = ProjLevels[index];

	  if(savelevel<0)
	  {
	    if(oklevels[savelevel*-1]==0)
		{
  	      if(GetNumNetLevels(type)==0)  
		  {
			
	        CloseNetsOff(type);
	        return;
		  }

		  
		  deletemelevels[savelevel*-1] = 1;
		  oklevels[savelevel*-1] = 1;  
		}
	  }
	}
    else if(type==CHOOSESHAPE_BROWSE)
    {
	  savelevel = ShapeLevels[index];
	  if(savelevel<0)
	  {
	    if(oklevels[savelevel*-1]==0)
		{
  	      if(GetNumNetLevels(type)==0) 
		  {
	        CloseNetsOff(type);
	        return;
		  }
		  
		  deletemelevels[savelevel*-1] = 1;
		  oklevels[savelevel*-1] = 1;  
		}
	  }
	}
    else if(type==CHOOSE_ES1_BROWSE)
    {
	  savelevel = ES1Levels[index];
	  if(savelevel<0)
	  {
	    if(oklevels[savelevel*-1]==0)
		{
  	      if(GetNumNetLevels(type)==0) 
		  {
	        CloseNetsOff(type);
	        return;
		  }
		  
		  deletemelevels[savelevel*-1] = 1;
		  oklevels[savelevel*-1] = 1;  
		}
	  }
	}
    else if(type==CHOOSE_ES2_BROWSE)
    {
	  savelevel = ES2Levels[index];
	  if(savelevel<0)
	  {
	    if(oklevels[savelevel*-1]==0)
		{
  	      if(GetNumNetLevels(type)==0) 
		  {
	        CloseNetsOff(type);
	        return;
		  }
		  
		  deletemelevels[savelevel*-1] = 1;
		  oklevels[savelevel*-1] = 1;  
		}
	  }
	}
    else if(type==CHOOSE_TXT_BROWSE)
    {
	  savelevel = TXTLevels[index];
	  if(savelevel<0)
	  {
	    if(oklevels[savelevel*-1]==0)
		{
  	      if(GetNumNetLevels(type)==0) 
		  {
	        CloseNetsOff(type);
	        return;
		  }
		  
		  deletemelevels[savelevel*-1] = 1;
		  oklevels[savelevel*-1] = 1;  
		}
	  }
	}
    else if(type==CHOOSE_XML1_BROWSE)
    {
	  savelevel = XML1Levels[index];
	  if(savelevel<0)
	  {
	    if(oklevels[savelevel*-1]==0)
		{
  	      if(GetNumNetLevels(type)==0) 
		  {
	        CloseNetsOff(type);
	        return;
		  }
		  
		  deletemelevels[savelevel*-1] = 1;
		  oklevels[savelevel*-1] = 1;  
		}
	  }
	}
    else if(type==CHOOSE_XML2_BROWSE)
    {
	  savelevel = XML2Levels[index];
	  if(savelevel<0)
	  {
	    if(oklevels[savelevel*-1]==0)
		{
  	      if(GetNumNetLevels(type)==0) 
		  {
	        CloseNetsOff(type);
	        return;
		  }
		  
		  deletemelevels[savelevel*-1] = 1;
		  oklevels[savelevel*-1] = 1;  
		}
	  }
	}
    else if(type==CHOOSE_XML3_BROWSE)
    {
	  savelevel = XML3Levels[index];
	  if(savelevel<0)
	  {
	    if(oklevels[savelevel*-1]==0)
		{
  	      if(GetNumNetLevels(type)==0) 
		  {
	        CloseNetsOff(type);
	        return;
		  }
		  
		  deletemelevels[savelevel*-1] = 1;
		  oklevels[savelevel*-1] = 1;  
		}
	  }
	}
    else if(type==ATTRFOLDER_BROWSE)
    {
	  savelevel = AttrLevels[index];
	  if(savelevel<0)
	  {
	    if(oklevels[savelevel*-1]==0)
		{
  	      if(GetNumNetLevels(type)==0) 
		  {
	        CloseNetsOff(type);
	        return;
		  }
		  
		  deletemelevels[savelevel*-1] = 1;
		  oklevels[savelevel*-1] = 1;  
		}
	  }
	}
    else if(type==CHOOSE_DP_BROWSE)
    {
	  savelevel = DPLevels[index];
	  if(savelevel<0)
	  {
	    if(oklevels[savelevel*-1]==0)
		{
  	      if(GetNumNetLevels(type)==0) 
		  {
	        CloseNetsOff(type);
	        return;
		  }
		  
		  deletemelevels[savelevel*-1] = 1;
		  oklevels[savelevel*-1] = 1;  
		}
	  }
	}
    else if(type==CHOOSEBROWSE_BROWSE)
    {
	  savelevel = BrowseLevels[index];
	  if(savelevel<0)
	  {
	    if(oklevels[savelevel*-1]==0)
		{
  	      if(GetNumNetLevels(type)==0) 
		  {
	        CloseNetsOff(type);
	        return;
		  }
		  
		  deletemelevels[savelevel*-1] = 1;
		  oklevels[savelevel*-1] = 1;  
		}
	  }
	}
	else
	{
		printf("bad flag %d in RBNL\n",type);
	}
  }


  for(i=1;i<10000;i++)
  {
    if(deletemelevels[i]==1)
	{
     printf("deleting level %d\n",i*-1);
	 DeleteNetworkLevel(i*-1,type);
	}
  }
}



void SetNetworkLabel(int type)
{
  Widget rightwid,leftwid;
  char tempstr[1000];

  if(type==CHOOSEPROJ_BROWSE)
  {
    rightwid  = choosenetproj_right;
    leftwid   = choosenetproj_left;
  }
  else if(type==CHOOSESHAPE_BROWSE)
  {
	rightwid  = choosenetshape_right;
	leftwid   = choosenetshape_left;
  }
  else if(type==CHOOSE_ES1_BROWSE)
  {
    rightwid  = choosenet_es1_right;
    leftwid   = choosenet_es1_left;
  }
  else if(type==CHOOSE_ES2_BROWSE)
  {
    rightwid  = choosenet_es2_right;
    leftwid   = choosenet_es2_left;
  }
  else if(type==CHOOSE_TXT_BROWSE)
  {
    rightwid  = choosenet_txt_right;
    leftwid   = choosenet_txt_left;
  }
  else if(type==CHOOSE_XML1_BROWSE)
  {
    rightwid  = choosenet_xml1_right;
    leftwid   = choosenet_xml1_left;
  }
  else if(type==CHOOSE_XML2_BROWSE)
  {
    rightwid  = choosenet_xml2_right;
    leftwid   = choosenet_xml2_left;
  }
  else if(type==CHOOSE_XML3_BROWSE)
  {
    rightwid  = choosenet_xml3_right;
    leftwid   = choosenet_xml3_left;
  }
  else if(type==ATTRFOLDER_BROWSE)
  {
    rightwid  = choosenetattr_right;
    leftwid   = choosenetattr_left;
  }
  else if(type==CHOOSE_DP_BROWSE)
  {
    rightwid  = choosenetdp_right;
    leftwid   = choosenetdp_left;
  }
  else if(type==CHOOSEBROWSE_BROWSE)
  {
    rightwid  = choosenetbr_right;
    leftwid   = choosenetbr_left;
  }
  else
  {
    XBell(mydisplay,50);
    printf("SNL called with  bad flag %d\n",type);
    return;
  }
 
  sprintf(tempstr,"My Network Places (%d)",NumNetDrives);

  XtVaSetValues(rightwid   , XmNlabelString, STRING(tempstr), NULL);

  if(NumNetDrives==0)
  {

	XtVaSetValues(leftwid, XmNlabelInsensitivePixmap,plus_insen_pix,NULL);

	XtSetSensitive(leftwid,  False);
    XtSetSensitive(rightwid, False);
  }
  else
  {
	XtSetSensitive(leftwid,  True);
	XtSetSensitive(rightwid, True);
  }

}




void RealRefreshLocs(int type)
{
  int i;
  char thisdrive[1000];
  
  
  
  
  RebuildNetworkLocs(type);
  SetNetworkLabel   (type);
  
  
  
  
  for(i=0;i<DRIVE_MAX;i++)
    { 
      if(DrivesAvailable[i]==-12345)
	{
	  
	  
	  DeleteTopDriveLetter(i,type);
	  continue;
	}
    }
  
  for(i=0;i<DRIVE_MAX;i++)
    { 
      if(DrivesAvailable[i]==-12345)
	{
	  continue;
	}
      
      if(strlen(DriveNames[i])>0)
	{
	  sprintf(thisdrive,"%s (%s) (%c:)",ParseDriveType(DrivesAvailable[i]),
		  DriveNames[i],
		  i+65);
	}
      else
	{
	  sprintf(thisdrive,"%s (%c:)",ParseDriveType(DrivesAvailable[i]),
		  i+65);
	}
      
      AddDriveLetter(thisdrive,type,i);
    }
  
}





void RefreshLocs()
{

  GetDriveLetters();  

  
  
  if(browse12_up>0)
    {
      RealRefreshLocs(CHOOSEPROJ_BROWSE);
    }
  if(SHAPE_IMPORT_OUTPUT>0)
    {
      RealRefreshLocs(CHOOSESHAPE_BROWSE);
    }
  if(browse13_up>0)
    {
      RealRefreshLocs(CHOOSE_ES1_BROWSE);
    }
  if(browse14_up>0)
    {
      RealRefreshLocs(CHOOSE_ES2_BROWSE);
    }
  if(browse15_up>0)
    {
      RealRefreshLocs(CHOOSE_TXT_BROWSE);
    }
  if(browse26_up>0)
    {
      RealRefreshLocs(CHOOSEDATA_BROWSE);
    }
  if(browse27_up>0)
    {
      RealRefreshLocs(CHOOSE_XML1_BROWSE);
    }
  if(browse28_up>0)
    {
      RealRefreshLocs(CHOOSE_XML2_BROWSE);
    }
  if(browse29_up>0)
    {
      RealRefreshLocs(CHOOSE_XML3_BROWSE);
    }
  if(browse30_up>0)
    {
      RealRefreshLocs(ATTRFOLDER_BROWSE);
    }
  if(browse31_up>0)
    {
      RealRefreshLocs(CHOOSE_DP_BROWSE);
    }
  if(browse32_up>0)
    {
      RealRefreshLocs(CHOOSEBROWSE_BROWSE);
    }
}


void NEWToggleButtonHandleCB(Widget w, MyData  *closure, XtPointer call_data)
{
  XtTranslations temptrans; 
  XmOutlineWidget Outline = (XmOutlineWidget) closure->outlinewid;
  XmOutlineWidget *saveoutlines;
  XmString thename;
  Widget outline,suboutline,subhandle,left,right,thiswid;
  Widget *savewids;
  MyData *mydata3;
  Dimension oldwidth;
  char *text;
  char **savepaths;
  char pathname[1000],pathname2[1000],deletename[1000],tempname[1000];
  int i,index,len,numcolon,num,type = closure->type,level = closure->level,
	  openthis,savetype,num_saved_wids=0,maxindex,donothing,closed,numslash,
	  maxlen,newsize,topnetonoff,origwidth,maxwidth,OpenEmbedded;

  

  

  outline = (Widget)Outline;


  if(rec_depth==0)
  {
	rec_depth = 1;
  }
  else if(rec_depth==1)
  {
	
    printf("too busy to expand/collapse\n");
    
  }
  else if(rec_depth>1)
  {
	
  }


  maxindex = GetMaxIndex(type,"NEWToggleButtonHandleCB");

  if(type==CHOOSEPROJ_BROWSE)
  {
	temptrans = XtParseTranslationTable(list_translations36);
    set_cursor(XtDisplay(choose_dialog),XtWindow(choose_dialog),WATCH);
	thiswid = choose_dialog;
    topnetonoff  = NPPFOnOff1;
  }
  else if(type==CHOOSESHAPE_BROWSE)
  {
	temptrans  = XtParseTranslationTable(list_translations37);
    set_cursor(XtDisplay(chooseshape_dialog),XtWindow(chooseshape_dialog),WATCH);
	thiswid = chooseshape_dialog;
	topnetonoff  = NPSFOnOff1;
  }
  else if(type==CHOOSE_ES1_BROWSE)
  {
	temptrans  = XtParseTranslationTable(list_translations39);
    set_cursor(XtDisplay(choose_es1_dialog),XtWindow(choose_es1_dialog),WATCH);
	thiswid = choose_es1_dialog;
    topnetonoff  = NPES1OnOff1;
  }
  else if(type==CHOOSE_ES2_BROWSE)
  {
	temptrans  = XtParseTranslationTable(list_translations41);
    set_cursor(XtDisplay(choose_es2_dialog),XtWindow(choose_es2_dialog),WATCH);
	thiswid = choose_es2_dialog;
    topnetonoff  = NPES2OnOff1;
  }
  else if(type==CHOOSE_TXT_BROWSE)
  {
	temptrans  = XtParseTranslationTable(list_translations43);
    set_cursor(XtDisplay(choose_txt_dialog),XtWindow(choose_txt_dialog),WATCH);
	thiswid = choose_txt_dialog;
    topnetonoff  = NPTXTOnOff1;
  }
  else if(type==CHOOSE_XML1_BROWSE)
  {
	temptrans  = XtParseTranslationTable(list_translations47);
    set_cursor(XtDisplay(choose_xml1_dialog),XtWindow(choose_xml1_dialog),WATCH);
	thiswid = choose_xml1_dialog;
    topnetonoff  = NPXML1OnOff1;
  }
  else if(type==CHOOSE_XML2_BROWSE)
  {
	temptrans  = XtParseTranslationTable(list_translations49);
    set_cursor(XtDisplay(choose_xml2_dialog),XtWindow(choose_xml2_dialog),WATCH);
	thiswid = choose_xml2_dialog;
    topnetonoff  = NPXML2OnOff1;
  }
  else if(type==CHOOSE_XML3_BROWSE)
  {
	temptrans  = XtParseTranslationTable(list_translations51);
    set_cursor(XtDisplay(choose_xml3_dialog),XtWindow(choose_xml3_dialog),WATCH);
	thiswid = choose_xml3_dialog;
    topnetonoff  = NPXML3OnOff1;
  }
  else if(type==ATTRFOLDER_BROWSE)
  {
	temptrans  = XtParseTranslationTable(list_translations56);
    set_cursor(XtDisplay(chooseattr_dialog),XtWindow(chooseattr_dialog),WATCH);
	thiswid = chooseattr_dialog;
	topnetonoff  = NPCAOnOff1;
  }
  else if(type==CHOOSE_DP_BROWSE)
  {
	temptrans  = XtParseTranslationTable(list_translations58);
    set_cursor(XtDisplay(choosedp_dialog),XtWindow(choosedp_dialog),WATCH);
	thiswid = choosedp_dialog;
	topnetonoff  = NPDPOnOff1;
  }
  else if(type==CHOOSEBROWSE_BROWSE)
  {
	temptrans  = XtParseTranslationTable(list_translations60);
    set_cursor(XtDisplay(choosebr_dialog),XtWindow(choosebr_dialog),WATCH);
	thiswid = choosebr_dialog;
	topnetonoff  = NPBROnOff1;
  }
  else
  {
	printf("bad type in NTBHC %d\n",type);
  }





  if(level==1)
    {
      if(type==CHOOSEPROJ_BROWSE)
	  {
	   if(PFOnOff1==1)
	    {
	      XtUnmanageChild(outline);
	      XtVaSetValues(w, XmNlabelPixmap, plus_pix, NULL);
	      PFOnOff1 = 0;
	    }
	   else if(PFOnOff1==0)
	    {
		  RefreshLocs();
	      XtManageChild(outline);
	      XtVaSetValues(w, XmNlabelPixmap, minus_pix, NULL);
	      PFOnOff1 = 1;
	    }
	  }
      else if(type==CHOOSESHAPE_BROWSE)
	  {
	   if(SFOnOff1==1)
	    {
	      XtUnmanageChild(outline);
	      XtVaSetValues(w, XmNlabelPixmap, plus_pix, NULL);
	      SFOnOff1 = 0;
	    }
	   else if(SFOnOff1==0)
	    {
		  RefreshLocs();
	      XtManageChild(outline);
	      XtVaSetValues(w, XmNlabelPixmap, minus_pix, NULL);
	      SFOnOff1 = 1;
	    }
	  }
      else if(type==CHOOSE_ES1_BROWSE)
	  {
	   if(ES1OnOff1==1)
	    {
	      XtUnmanageChild(outline);
	      XtVaSetValues(w, XmNlabelPixmap, plus_pix, NULL);
	      ES1OnOff1 = 0;
	    }
	   else if(ES1OnOff1==0)
	    {
		  RefreshLocs();
	      XtManageChild(outline);
	      XtVaSetValues(w, XmNlabelPixmap, minus_pix, NULL);
	      ES1OnOff1 = 1;
	    }
	  }
      else if(type==CHOOSE_ES2_BROWSE)
	  {
	   if(ES2OnOff1==1)
	    {
	      XtUnmanageChild(outline);
	      XtVaSetValues(w, XmNlabelPixmap, plus_pix, NULL);
	      ES2OnOff1 = 0;
	    }
	   else if(ES2OnOff1==0)
	    {
		  RefreshLocs();
	      XtManageChild(outline);
	      XtVaSetValues(w, XmNlabelPixmap, minus_pix, NULL);
	      ES2OnOff1 = 1;
	    }
	  }
      else if(type==CHOOSE_TXT_BROWSE)
	  {
	   if(TXTOnOff1==1)
	    {
	      XtUnmanageChild(outline);
	      XtVaSetValues(w, XmNlabelPixmap, plus_pix, NULL);
	      TXTOnOff1 = 0;
	    }
	   else if(TXTOnOff1==0)
	    {
		  RefreshLocs();
	      XtManageChild(outline);
	      XtVaSetValues(w, XmNlabelPixmap, minus_pix, NULL);
	      TXTOnOff1 = 1;
	    }
	  }
      else if(type==CHOOSE_XML1_BROWSE)
	  {
	   if(XML1OnOff1==1)
	    {
	      XtUnmanageChild(outline);
	      XtVaSetValues(w, XmNlabelPixmap, plus_pix, NULL);
	      XML1OnOff1 = 0;
	    }
	   else if(XML1OnOff1==0)
	    {
		  RefreshLocs();
	      XtManageChild(outline);
	      XtVaSetValues(w, XmNlabelPixmap, minus_pix, NULL);
	      XML1OnOff1 = 1;
	    }
	  }
      else if(type==CHOOSE_XML2_BROWSE)
	  {
	   if(XML2OnOff1==1)
	    {
	      XtUnmanageChild(outline);
	      XtVaSetValues(w, XmNlabelPixmap, plus_pix, NULL);
	      XML1OnOff1 = 0;
	    }
	   else if(XML2OnOff1==0)
	    {
		  RefreshLocs();
	      XtManageChild(outline);
	      XtVaSetValues(w, XmNlabelPixmap, minus_pix, NULL);
	      XML1OnOff1 = 1;
	    }
	  }
      else if(type==CHOOSE_XML3_BROWSE)
	  {
	   if(XML3OnOff1==1)
	    {
	      XtUnmanageChild(outline);
	      XtVaSetValues(w, XmNlabelPixmap, plus_pix, NULL);
	      XML1OnOff1 = 0;
	    }
	   else if(XML3OnOff1==0)
	    {
		  RefreshLocs();
	      XtManageChild(outline);
	      XtVaSetValues(w, XmNlabelPixmap, minus_pix, NULL);
	      XML1OnOff1 = 1;
	    }
	  }
      else if(type==ATTRFOLDER_BROWSE)
	  {
	   if(CAOnOff1==1)
	    {
	      XtUnmanageChild(outline);
	      XtVaSetValues(w, XmNlabelPixmap, plus_pix, NULL);
	      CAOnOff1 = 0;
	    }
	   else if(CAOnOff1==0)
	    {
		  RefreshLocs();
	      XtManageChild(outline);
	      XtVaSetValues(w, XmNlabelPixmap, minus_pix, NULL);
	      CAOnOff1 = 1;
	    }
	  }
      else if(type==CHOOSE_DP_BROWSE)
	  {
	   if(DPOnOff1==1)
	    {
	      XtUnmanageChild(outline);
	      XtVaSetValues(w, XmNlabelPixmap, plus_pix, NULL);
	      DPOnOff1 = 0;
	    }
	   else if(DPOnOff1==0)
	    {
		  RefreshLocs();
	      XtManageChild(outline);
	      XtVaSetValues(w, XmNlabelPixmap, minus_pix, NULL);
	      DPOnOff1 = 1;
	    }
	  }
      else if(type==CHOOSEBROWSE_BROWSE)
	  {
	   if(BROnOff1==1)
	    {
	      XtUnmanageChild(outline);
	      XtVaSetValues(w, XmNlabelPixmap, plus_pix, NULL);
	      BROnOff1 = 0;
	    }
	   else if(BROnOff1==0)
	    {
		  RefreshLocs();
	      XtManageChild(outline);
	      XtVaSetValues(w, XmNlabelPixmap, minus_pix, NULL);
	      BROnOff1 = 1;
	    }
	  }
      else
	  {
	    printf("bad type %d to NEWToggleButtonHandleCB\n",type);
	  }
  } 


    else if(level==-99999)
    {
     if(type==CHOOSEPROJ_BROWSE)
	  {
	     XtVaGetValues(choosenetproj_right,XmNlabelString,&thename,NULL);
	     XmStringGetLtoR(thename,(XmStringCharSet) XmSTRING_DEFAULT_CHARSET, &text);
		 XmStringFree(thename);
		 donothing = 0;
         if(strstr(text,"(0)")!=NULL)
		 {
           donothing = 1;
		   
		 }
		 XtFree(text);

	   if((NPPFOnOff1==1)&&(donothing==0))
	    {
	      XtUnmanageChild(outline);
	      XtVaSetValues(w, XmNlabelPixmap, plus_pix, NULL);
	      NPPFOnOff1 = 0;
	    }
	   else if((NPPFOnOff1==0)&&(donothing==0))
	    {
	      XtManageChild(outline);
	      XtVaSetValues(w, XmNlabelPixmap, minus_pix, NULL);
	      NPPFOnOff1 = 1;
	    }
	  }
      else if(type==CHOOSESHAPE_BROWSE)
	  {
	     XtVaGetValues(choosenetshape_right,XmNlabelString,&thename,NULL);
	     XmStringGetLtoR(thename,(XmStringCharSet) XmSTRING_DEFAULT_CHARSET, &text);
		 XmStringFree(thename);
		 donothing = 0;
         if(strstr(text,"(0)")!=NULL)
		 {
           donothing = 1;
		   
		 }
		 XtFree(text);

		 if((NPSFOnOff1==1)&&(donothing==0))
	    {
	      XtUnmanageChild(outline);
	      XtVaSetValues(w, XmNlabelPixmap, plus_pix, NULL);
	      NPSFOnOff1 = 0;
	    }
	   else if((NPSFOnOff1==0)&&(donothing==0))
	    {
	      XtManageChild(outline);
	      XtVaSetValues(w, XmNlabelPixmap, minus_pix, NULL);
	      NPSFOnOff1 = 1;
	    }
	  }
      else if(type==CHOOSE_ES1_BROWSE)
	  {
	     XtVaGetValues(choosenet_es1_right,XmNlabelString,&thename,NULL);
	     XmStringGetLtoR(thename,(XmStringCharSet) XmSTRING_DEFAULT_CHARSET, &text);
		 XmStringFree(thename);
		 donothing = 0;
         if(strstr(text,"(0)")!=NULL)
		 {
           donothing = 1;
		   
		 }
		 XtFree(text);

		 if((NPES1OnOff1==1)&&(donothing==0))
	    {
	      XtUnmanageChild(outline);
	      XtVaSetValues(w, XmNlabelPixmap, plus_pix, NULL);
	      NPES1OnOff1 = 0;
	    }
	   else if((NPES1OnOff1==0)&&(donothing==0))
	    {
	      XtManageChild(outline);
	      XtVaSetValues(w, XmNlabelPixmap, minus_pix, NULL);
	      NPES1OnOff1 = 1;
	    }
	  }
      else if(type==CHOOSE_ES2_BROWSE)
	  {
	     XtVaGetValues(choosenet_es2_right,XmNlabelString,&thename,NULL);
	     XmStringGetLtoR(thename,(XmStringCharSet) XmSTRING_DEFAULT_CHARSET, &text);
		 XmStringFree(thename);
		 donothing = 0;
         if(strstr(text,"(0)")!=NULL)
		 {
           donothing = 1;
		   
		 }
		 XtFree(text);

		 if((NPES2OnOff1==1)&&(donothing==0))
	    {
	      XtUnmanageChild(outline);
	      XtVaSetValues(w, XmNlabelPixmap, plus_pix, NULL);
	      NPES2OnOff1 = 0;
	    }
	   else if((NPES2OnOff1==0)&&(donothing==0))
	    {
	      XtManageChild(outline);
	      XtVaSetValues(w, XmNlabelPixmap, minus_pix, NULL);
	      NPES2OnOff1 = 1;
	    }
	  }
      else if(type==CHOOSE_TXT_BROWSE)
	  {
	     XtVaGetValues(choosenet_txt_right,XmNlabelString,&thename,NULL);
	     XmStringGetLtoR(thename,(XmStringCharSet) XmSTRING_DEFAULT_CHARSET, &text);
		 XmStringFree(thename);
		 donothing = 0;
         if(strstr(text,"(0)")!=NULL)
		 {
           donothing = 1;
		   
		 }
		 XtFree(text);

		 if((NPTXTOnOff1==1)&&(donothing==0))
	    {
	      XtUnmanageChild(outline);
	      XtVaSetValues(w, XmNlabelPixmap, plus_pix, NULL);
	      NPTXTOnOff1 = 0;
	    }
	   else if((NPTXTOnOff1==0)&&(donothing==0))
	    {
	      XtManageChild(outline);
	      XtVaSetValues(w, XmNlabelPixmap, minus_pix, NULL);
	      NPTXTOnOff1 = 1;
	    }
	  }
      else if(type==CHOOSE_XML1_BROWSE)
	  {
	     XtVaGetValues(choosenet_xml1_right,XmNlabelString,&thename,NULL);
	     XmStringGetLtoR(thename,(XmStringCharSet) XmSTRING_DEFAULT_CHARSET, &text);
		 XmStringFree(thename);
		 donothing = 0;
         if(strstr(text,"(0)")!=NULL)
		 {
           donothing = 1;
		   
		 }
		 XtFree(text);

		 if((NPXML1OnOff1==1)&&(donothing==0))
	    {
	      XtUnmanageChild(outline);
	      XtVaSetValues(w, XmNlabelPixmap, plus_pix, NULL);
	      NPXML1OnOff1 = 0;
	    }
	   else if((NPXML1OnOff1==0)&&(donothing==0))
	    {
	      XtManageChild(outline);
	      XtVaSetValues(w, XmNlabelPixmap, minus_pix, NULL);
	      NPXML1OnOff1 = 1;
	    }
	  }
      else if(type==CHOOSE_XML2_BROWSE)
	  {
	     XtVaGetValues(choosenet_xml2_right,XmNlabelString,&thename,NULL);
	     XmStringGetLtoR(thename,(XmStringCharSet) XmSTRING_DEFAULT_CHARSET, &text);
		 XmStringFree(thename);
		 donothing = 0;
         if(strstr(text,"(0)")!=NULL)
		 {
           donothing = 1;
		   
		 }
		 XtFree(text);

		 if((NPXML2OnOff1==1)&&(donothing==0))
	    {
	      XtUnmanageChild(outline);
	      XtVaSetValues(w, XmNlabelPixmap, plus_pix, NULL);
	      NPXML2OnOff1 = 0;
	    }
	   else if((NPXML2OnOff1==0)&&(donothing==0))
	    {
	      XtManageChild(outline);
	      XtVaSetValues(w, XmNlabelPixmap, minus_pix, NULL);
	      NPXML2OnOff1 = 1;
	    }
	  }
      else if(type==CHOOSE_XML3_BROWSE)
	  {
	     XtVaGetValues(choosenet_xml3_right,XmNlabelString,&thename,NULL);
	     XmStringGetLtoR(thename,(XmStringCharSet) XmSTRING_DEFAULT_CHARSET, &text);
		 XmStringFree(thename);
		 donothing = 0;
         if(strstr(text,"(0)")!=NULL)
		 {
           donothing = 1;
		   
		 }
		 XtFree(text);

		 if((NPXML3OnOff1==1)&&(donothing==0))
	    {
	      XtUnmanageChild(outline);
	      XtVaSetValues(w, XmNlabelPixmap, plus_pix, NULL);
	      NPXML3OnOff1 = 0;
	    }
	   else if((NPXML3OnOff1==0)&&(donothing==0))
	    {
	      XtManageChild(outline);
	      XtVaSetValues(w, XmNlabelPixmap, minus_pix, NULL);
	      NPXML3OnOff1 = 1;
	    }
	  }
      else if(type==ATTRFOLDER_BROWSE)
	  {
	     XtVaGetValues(choosenetattr_right,XmNlabelString,&thename,NULL);
	     XmStringGetLtoR(thename,(XmStringCharSet) XmSTRING_DEFAULT_CHARSET, &text);
		 XmStringFree(thename);
		 donothing = 0;
         if(strstr(text,"(0)")!=NULL)
		 {
           donothing = 1;
		   
		 }
		 XtFree(text);

		 if((NPCAOnOff1==1)&&(donothing==0))
	    {
	      XtUnmanageChild(outline);
	      XtVaSetValues(w, XmNlabelPixmap, plus_pix, NULL);
	      NPCAOnOff1 = 0;
	    }
	   else if((NPCAOnOff1==0)&&(donothing==0))
	    {
	      XtManageChild(outline);
	      XtVaSetValues(w, XmNlabelPixmap, minus_pix, NULL);
	      NPCAOnOff1 = 1;
	    }
	  }
      else if(type==CHOOSE_DP_BROWSE)
	  {
	     XtVaGetValues(choosenetdp_right,XmNlabelString,&thename,NULL);
	     XmStringGetLtoR(thename,(XmStringCharSet) XmSTRING_DEFAULT_CHARSET, &text);
		 XmStringFree(thename);
		 donothing = 0;
         if(strstr(text,"(0)")!=NULL)
		 {
           donothing = 1;
		   
		 }
		 XtFree(text);

		 if((NPDPOnOff1==1)&&(donothing==0))
	    {
	      XtUnmanageChild(outline);
	      XtVaSetValues(w, XmNlabelPixmap, plus_pix, NULL);
	      NPDPOnOff1 = 0;
	    }
	   else if((NPDPOnOff1==0)&&(donothing==0))
	    {
	      XtManageChild(outline);
	      XtVaSetValues(w, XmNlabelPixmap, minus_pix, NULL);
	      NPDPOnOff1 = 1;
	    }
	  }
      else if(type==CHOOSEBROWSE_BROWSE)
	  {
	     XtVaGetValues(choosenetbr_right,XmNlabelString,&thename,NULL);
	     XmStringGetLtoR(thename,(XmStringCharSet) XmSTRING_DEFAULT_CHARSET, &text);
		 XmStringFree(thename);
		 donothing = 0;
         if(strstr(text,"(0)")!=NULL)
		 {
           donothing = 1;
		   
		 }
		 XtFree(text);

		 if((NPBROnOff1==1)&&(donothing==0))
	    {
	      XtUnmanageChild(outline);
	      XtVaSetValues(w, XmNlabelPixmap, plus_pix, NULL);
	      NPBROnOff1 = 0;
	    }
	   else if((NPBROnOff1==0)&&(donothing==0))
	    {
	      XtManageChild(outline);
	      XtVaSetValues(w, XmNlabelPixmap, minus_pix, NULL);
	      NPBROnOff1 = 1;
	    }
	  }
      else
	  {
	    printf("bad type %d to NEWToggleButtonHandleCB\n",type);
	  }
    } 
  else
    {

      closed = DetermineClosed(closure->pathname,type,level);
      sprintf(pathname,"%s",closure->pathname);


      if(closed==1)
	{
	  
	  
	  if(DOSDEBUG==1)
	  {
	    printf("open path %s\n",pathname);
	  }

      

      if(XtIsManaged(outline))
	  {
		
		printf("\nError....should not be unmanaging here\n");
        XtUnmanageChild(outline);
	  }


	  if(level<0)
	  {
		if(!strncmp(closure->pathname,"My Network Places",17))
		 {
           printf("\n\n\nError:  Should not ne here\n\n");

		   TempFolderList = (char **)malloc(sizeof(char *)*NumNetDrives);
		   for(i=0;i<NumNetDrives;i++)
		   {
			 TempFolderList[i] = (char *)malloc(500);
			 sprintf(TempFolderList[i],"<%s>: %s",NetDriveNames[i],NetDrivePaths[i]);
		   }
		   num = NumNetDrives;
		}
		else
		{
           sprintf(pathname,"%s",ExtractNetPath(pathname));

		   if(DOSDEBUG==1)
		   {
		     printf("get list for %s (level %d)\n",pathname,level);
		   }

		   num = GetFolders(pathname,7,1);

		   if(DOSDEBUG==1)
		   {
		      printf("num %d\n",num);
		   }

           
		}
	  }
	  else
	  {
	    num = GetFolders(pathname,7,1);
      }


      if(DOSDEBUG==1)
	  {
       printf("sorting folder list\n");
	  }

	  SortFolderList(0,num-1,7);


	  if(DOSDEBUG==1)
	  {
	    printf("folder list generated\n");
	  }
	  


	  for(i=0;i<num;i++)
	    {


		  if(DOSDEBUG==1)
		  {
	        printf("got folder %s\n",TempFolderList[i]);
		  }

		  OpenEmbedded = 0;

		  if(OpeningSpecialLoc==1)
		  {
            if(strstr(SpecialLoc,TempFolderList[i]))
			{
              OpenEmbedded = 1;
			}

			
		  }


		  sprintf(tempname,"%s",TempFolderList[i]);

		  len = strlen(TempFolderList[i]);
		  if(TempFolderList[i][len-1]=='\\')
		  {
			  
			  tempname[len-1] = '\0';
		  }


		  

		  if(OpenEmbedded==1)
		  {
            openthis = 1;
		  }
		  else
		  {
		    openthis = DetermineRecursiveOpen(tempname,type,level); 
		  }


	      subhandle = XtVaCreateManagedWidget("roothandle", xmHandleWidgetClass,
						  outline,
						  XmNtranslations, temptrans,
						  NULL);
	      
	      left = XtVaCreateManagedWidget("left", xmPushButtonWidgetClass,
					     subhandle,
					     XmNlabelType,    XmPIXMAP,
					     XmNlabelPixmap,  plus_pix,					 
					     XmNtraversalOn,  False,
					     XmNtranslations, temptrans,
					     NULL);
	      
	      
	      right = XtVaCreateManagedWidget(tempname, xmToggleButtonWidgetClass,
					      subhandle,
					      XmNtraversalOn,   False,
					      XmNtranslations,  temptrans,
					      XmNindicatorOn,   False,
					      NULL);

          if(level==-99999)
		  {
	        AddWidToList(type,right,subhandle,-1*(i+1));
		  }
		  else if(level<0)
		  {
	        AddWidToList(type,right,subhandle,level);
		  }
		  else
		  {
	        AddWidToList(type,right,subhandle,999);
		  }

		  
	      suboutline = XtVaCreateManagedWidget("outlineChooseProjOnly", xmOutlineWidgetClass,
						   subhandle,
						   XmNindentation,  20,
						   XmNoutline,      TRUE,
						   XmNtranslations, temptrans,
						   
						   NULL);
	      
	      



	      mydata3  = (MyData *) (malloc(sizeof(MyData)));
	      if(mydata3==NULL){printf("myb: out of allocation memory!\n"); ExitWrapper(-1);}
	      mydata3->outlinewid = (XmOutlineWidget)suboutline;

		  if(level==-99999)
		  {
			if(DOSDEBUG==1)
			{
			  printf("setting level %d\n",-1*(i+1));
			}
			mydata3->level = -1*(i+1);
		  }
		  else if(level<0)
		  {
			if(DOSDEBUG==1)
			{
			  printf("using existing level %d\n",level);
			}
			mydata3->level = level;
		  }
		  else
		  {
	        mydata3->level = 999;
		  }
	      mydata3->type  = type;
	      
	      mydata3->pathname = (char *)malloc(strlen(TempFolderList[i])+5);
	      sprintf(mydata3->pathname,"%s",TempFolderList[i]);

		  
	      XtAddCallback(left, 
			    XmNactivateCallback, (XtCallbackProc)NEWToggleButtonHandleCB, 
			    (XtPointer) mydata3);
	      
	      XtVaSetValues(subhandle, 
			    XmNsubWidget, suboutline,
			    NULL);
	      

	      XtAddCallback (right, XmNvalueChangedCallback,toggle_dos,(XtPointer)type);

		  
		  XtUnmanageChild(suboutline);

	
	      if(openthis==1)
		  {
			if(DOSDEBUG==1)
			{
			  printf("setting savewid\n");
			}
	
			savetype = mydata3->type;
 
			if(num_saved_wids==0)
			{
			  saveoutlines = (XmOutlineWidget *)malloc(sizeof(XmOutlineWidget));
			  savewids     = (Widget *)         malloc(sizeof(Widget));
			  savepaths    = (char **)          malloc(sizeof(char *));
			}
			else
			{
			  saveoutlines = (XmOutlineWidget *)realloc(saveoutlines,(num_saved_wids+1)*sizeof(XmOutlineWidget));
			  savewids     = (Widget *)         realloc(savewids,    (num_saved_wids+1)*sizeof(Widget));
			  savepaths    = (char **)          realloc(savepaths,   (num_saved_wids+1)*sizeof(char *));
			}


			savepaths        [num_saved_wids] = (char *) malloc(strlen(mydata3->pathname)+5);
			saveoutlines     [num_saved_wids] = mydata3->outlinewid;
			savewids         [num_saved_wids] = left;
			sprintf(savepaths[num_saved_wids],"%s",mydata3->pathname);

			num_saved_wids = num_saved_wids + 1;
		  }

	    }
	  
   
	  


	  XtVaSetValues(w, XmNlabelPixmap, minus_pix, NULL);
	  
	  for(i=0;i<num;i++)
	    {
	      free(TempFolderList[i]);
	    }
	  free(TempFolderList);
	  TempFolderList = NULL;


      for(i=0;i<num_saved_wids;i++)
	  {

		if(DOSDEBUG==1)
		{
	      printf("calling recursively\n");
		}


	    mydata3  = (MyData *) (malloc(sizeof(MyData)));
	    if(mydata3==NULL){printf("myb: out of allocation memory!\n"); ExitWrapper(-1);}
	    mydata3->outlinewid = saveoutlines[i];

        if(level==-99999)
		{
		  

		  mydata3->level = -1*(i+1);
		}
		else if(level<0)
		{
		  

		  mydata3->level = level;
		}
		else
		{
          mydata3->level = 999;
		}
		
	    mydata3->type  = savetype;
	      
	    mydata3->pathname = (char *)malloc(strlen(savepaths[i])+5);
	    sprintf(mydata3->pathname,"%s",savepaths[i]);


	    rec_depth = rec_depth + 1;
        if(DOSDEBUG==1)
		{
		  printf("increasing rec_depth to %d\n",rec_depth);
		}
		NEWToggleButtonHandleCB(savewids[i],mydata3,(XtPointer)NULL);
		if(DOSDEBUG==1)
		{
		  printf("back\n");
		}

		free(savepaths[i]);
		
	  }
	  if(num_saved_wids>0)
	  {
		  free(savewids);
		  free(savepaths);
		  free(saveoutlines);
	  }

	  if(num>0)
	  {
		
	    if(rec_depth==1)
		{
		  if(DOSDEBUG==1)
		  {
            printf("delete old for %s with recursion depth %d\n",pathname,rec_depth);
		  }
          DeleteOldHandles(pathname,type,level);
		}
		if(DOSDEBUG==1)
		{
          printf("manage\n");
		}
	    XtManageChild(outline);
	  }
	}
      else
	{
	  

       if(DOSDEBUG==1)
	   {
		 printf("close path %s with level %d\n",pathname,level);	
	   }
	  
       len = strlen(pathname);


	  
	  if(XtIsManaged(outline))
	  {
	    XtUnmanageChild(outline);
	  }
	  else
	  {
		  printf("Error:  outline already unmanaged\n");
	  }


	  for(index=0;index<maxindex;index++)
	    {
		  if(type==CHOOSEPROJ_BROWSE)
		  {
		    if((level<0)&&(ProjLevels[index]!=level))
			{
		     
			 continue;
			}

            if((level>=0)&&(ProjLevels[index]<0))
			{ 
			 
			 continue;
			}

	        XtVaGetValues(ProjWids[index],XmNlabelString,&thename,NULL);
		  }
		  else if(type==CHOOSESHAPE_BROWSE)
		  {
		    if((level<0)&&(ShapeLevels[index]!=level))
			{
		     
			 continue;
			}

            if((level>=0)&&(ShapeLevels[index]<0))
			{ 
			 
			 continue;
			}

	        XtVaGetValues(ShapeWids[index],XmNlabelString,&thename,NULL);
		  }
		  else if(type==CHOOSE_ES1_BROWSE)
		  {
		    if((level<0)&&(ES1Levels[index]!=level))
			{
		     
			 continue;
			}

            if((level>=0)&&(ES1Levels[index]<0))
			{ 
			 
			 continue;
			}

	        XtVaGetValues(ES1Wids[index],XmNlabelString,&thename,NULL);
		  }
		  else if(type==CHOOSE_ES2_BROWSE)
		  {
		    if((level<0)&&(ES2Levels[index]!=level))
			{
		     
			 continue;
			}

            if((level>=0)&&(ES2Levels[index]<0))
			{ 
			 
			 continue;
			}

	        XtVaGetValues(ES2Wids[index],XmNlabelString,&thename,NULL);
		  }
		  else if(type==CHOOSE_TXT_BROWSE)
		  {
		     if((level<0)&&(TXTLevels[index]!=level))
			{
		     
			 continue;
			}

            if((level>=0)&&(TXTLevels[index]<0))
			{ 
			 
			 continue;
			}

	        XtVaGetValues(TXTWids[index],XmNlabelString,&thename,NULL);
		  }
		  else if(type==CHOOSE_XML1_BROWSE)
		  {
		    if((level<0)&&(XML1Levels[index]!=level))
			{
		     
			 continue;
			}

            if((level>=0)&&(XML1Levels[index]<0))
			{ 
			 
			 continue;
			}

	        XtVaGetValues(XML1Wids[index],XmNlabelString,&thename,NULL);
		  }
		  else if(type==CHOOSE_XML2_BROWSE)
		  {
		    if((level<0)&&(XML2Levels[index]!=level))
			{
		     
			 continue;
			}

            if((level>=0)&&(XML2Levels[index]<0))
			{ 
			 
			 continue;
			}

	        XtVaGetValues(XML2Wids[index],XmNlabelString,&thename,NULL);
		  }
		  else if(type==CHOOSE_XML3_BROWSE)
		  {
		    if((level<0)&&(XML3Levels[index]!=level))
			{
		     
			 continue;
			}

            if((level>=0)&&(XML3Levels[index]<0))
			{ 
			 
			 continue;
			}

	        XtVaGetValues(XML3Wids[index],XmNlabelString,&thename,NULL);
		  }
		  else if(type==ATTRFOLDER_BROWSE)
		  {
		    if((level<0)&&(AttrLevels[index]!=level))
			{
		     
			 continue;
			}

            if((level>=0)&&(AttrLevels[index]<0))
			{ 
			 
			 continue;
			}

	        XtVaGetValues(AttrWids[index],XmNlabelString,&thename,NULL);
		  }
		  else if(type==CHOOSE_DP_BROWSE)
		  {
		    if((level<0)&&(DPLevels[index]!=level))
			{
		     
			 continue;
			}

            if((level>=0)&&(DPLevels[index]<0))
			{ 
			 
			 continue;
			}

	        XtVaGetValues(DPWids[index],XmNlabelString,&thename,NULL);
		  }
		  else if(type==CHOOSEBROWSE_BROWSE)
		  {
		    if((level<0)&&(BrowseLevels[index]!=level))
			{
		     
			 continue;
			}

            if((level>=0)&&(BrowseLevels[index]<0))
			{ 
			 
			 continue;
			}

	        XtVaGetValues(BrowseWids[index],XmNlabelString,&thename,NULL);
		  }
		  else
		  {
			  printf("bad flag %d to NTBHCB\n",type);
		  }
	      
	      XmStringGetLtoR(thename,(XmStringCharSet) XmSTRING_DEFAULT_CHARSET, &text);
		  XmStringFree(thename);


		  
	      
		  if(
			  (!strncmp(text,deletesentinel,deletesentinellen)) ||
			  (!strncmp(text,deleteOpensentinel,deletesentinellen))
			)
		  {
			  XtFree(text);
			  continue;
		  }

	      len = strlen(text);
	      numcolon = 0;
	      for(i=0;i<len;i++)
		{
		  if(text[i]==':')
		    {
		      numcolon = numcolon + 1;
		    }
		}


	      
	      if(numcolon==1)
		{
		  sprintf(pathname2,"%s",GetPathFromWid(type,index));
		}
	      else if(numcolon>1)
		{
		  sprintf(pathname2,"%s",GetPathFromWid(type,index));
		}  
	      else if(numcolon==0) 
		{
		  sprintf(pathname2,"%s",GetPathFromWid(type,index));
		}  
	      else
		{
		  printf("1 bad colon num in %s (%d)\n",text,numcolon);
		}
		
		XtFree(text);


	      len = strlen(pathname);
	      if(strcmp(pathname,pathname2))
		{
		  if(!strncmp(pathname,pathname2,len)) 
		    {
			  



			  if(DetermineClosed(pathname2,type,level)==1)
				{
			    sprintf(deletename,"%s %s",deletesentinel,pathname2);
			  }
			  else
			  {
			    sprintf(deletename,"%s %s",deleteOpensentinel,pathname2);
			  }

			  if(type==CHOOSEPROJ_BROWSE)
			  {
                XtVaSetValues(ProjWids[index],XmNlabelString,STRING(deletename),NULL);
			  }
			  else if(type==CHOOSESHAPE_BROWSE)
			  {
                XtVaSetValues(ShapeWids[index],XmNlabelString,STRING(deletename),NULL);
			  }
			  else if(type==CHOOSE_ES1_BROWSE)
			  {
                XtVaSetValues(ES1Wids[index],XmNlabelString,STRING(deletename),NULL);
			  }
			  else if(type==CHOOSE_ES2_BROWSE)
			  {
                XtVaSetValues(ES2Wids[index],XmNlabelString,STRING(deletename),NULL);
			  }
			  else if(type==CHOOSE_TXT_BROWSE)
			  {
                XtVaSetValues(TXTWids[index],XmNlabelString,STRING(deletename),NULL);
			  }
			  else if(type==CHOOSE_XML1_BROWSE)
			  {
                XtVaSetValues(XML1Wids[index],XmNlabelString,STRING(deletename),NULL);
			  }
			  else if(type==CHOOSE_XML2_BROWSE)
			  {
                XtVaSetValues(XML2Wids[index],XmNlabelString,STRING(deletename),NULL);
			  }
			  else if(type==CHOOSE_XML3_BROWSE)
			  {
                XtVaSetValues(XML3Wids[index],XmNlabelString,STRING(deletename),NULL);
			  }
			  else if(type==ATTRFOLDER_BROWSE)
			  {
                XtVaSetValues(AttrWids[index],XmNlabelString,STRING(deletename),NULL);
			  }
			  else if(type==CHOOSE_DP_BROWSE)
			  {
                XtVaSetValues(DPWids[index],XmNlabelString,STRING(deletename),NULL);
			  }
			  else if(type==CHOOSEBROWSE_BROWSE)
			  {
                XtVaSetValues(BrowseWids[index],XmNlabelString,STRING(deletename),NULL);
			  }
			  else
			  {
			    printf("(2) bad flag %d to NTBHCB\n",type);
			  }
		    }
		}
	    } 



	  
	  XtVaSetValues(w, XmNlabelPixmap, plus_pix, NULL);


	} 
    } 




	

	maxindex = GetMaxIndex(type,"NEWToggleButtonHandleCB");
	maxlen = 21;

    for(index=0;index<maxindex;index++)
	{
      if(type==CHOOSEPROJ_BROWSE)
	  {
        XtVaGetValues(ProjWids[index],XmNlabelString,&thename,NULL);
 	  }
	  else if(type==CHOOSESHAPE_BROWSE)
	  {
        XtVaGetValues(ShapeWids[index],XmNlabelString,&thename,NULL);
	  }
	  else if(type==CHOOSE_ES1_BROWSE)
	  {
        XtVaGetValues(ES1Wids[index],XmNlabelString,&thename,NULL);
 	  }
	  else if(type==CHOOSE_ES2_BROWSE)
	  {
        XtVaGetValues(ES2Wids[index],XmNlabelString,&thename,NULL);
 	  }
	  else if(type==CHOOSE_TXT_BROWSE)
	  {
        XtVaGetValues(TXTWids[index],XmNlabelString,&thename,NULL);
 	  }
	  else if(type==CHOOSE_XML1_BROWSE)
	  {
        XtVaGetValues(XML1Wids[index],XmNlabelString,&thename,NULL);
 	  }
	  else if(type==CHOOSE_XML2_BROWSE)
	  {
        XtVaGetValues(XML2Wids[index],XmNlabelString,&thename,NULL);
 	  }
	  else if(type==CHOOSE_XML3_BROWSE)
	  {
        XtVaGetValues(XML3Wids[index],XmNlabelString,&thename,NULL);
 	  }
	  else if(type==ATTRFOLDER_BROWSE)
	  {
        XtVaGetValues(AttrWids[index],XmNlabelString,&thename,NULL);
	  }
	  else if(type==CHOOSE_DP_BROWSE)
	  {
        XtVaGetValues(DPWids[index],XmNlabelString,&thename,NULL);
	  }
	  else if(type==CHOOSEBROWSE_BROWSE)
	  {
        XtVaGetValues(BrowseWids[index],XmNlabelString,&thename,NULL);
	  }
	  else
	  {
		  printf("bad flag %d to NTBHCB\n",type);
	  }
	      
      XmStringGetLtoR(thename,(XmStringCharSet) XmSTRING_DEFAULT_CHARSET, &text);
	  XmStringFree(thename);


	  
	      
	  if(
		  (!strncmp(text,deletesentinel,deletesentinellen)) ||
		  (!strncmp(text,deleteOpensentinel,deletesentinellen))
		)
	  {
        XtFree(text);
        continue;
	  }


	  sprintf(pathname2,"%s",GetPathFromWid(type,index));

	  numslash = 0;
	  len = strlen(pathname2);
	  for(i=0;i<len;i++)
	  {
        if(pathname2[i]=='\\')
		{
          numslash = numslash + 1;
		}
	  }

	  

	  if((len+2*numslash)>maxlen)
	  {
		maxlen = len + 2*numslash;
	  }
	} 




    if(type==CHOOSEPROJ_BROWSE)
	{
      topnetonoff  = NPPFOnOff1;
	  origwidth    = chooseproj_origwidth;
	}
    else if(type==CHOOSESHAPE_BROWSE)
	{
	  topnetonoff  = NPSFOnOff1;
	  origwidth    = chooseshape_origwidth;
	}
    else if(type==CHOOSE_ES1_BROWSE)
	{
      topnetonoff  = NPES1OnOff1;
	  origwidth    = choosees1_origwidth;
	}
    else if(type==CHOOSE_ES2_BROWSE)
	{
      topnetonoff  = NPES2OnOff1;
	  origwidth    = choosees2_origwidth;
	}
    else if(type==CHOOSE_TXT_BROWSE)
	{
      topnetonoff  = NPTXTOnOff1;
	  origwidth    = choosetxt_origwidth;
	}
    else if(type==CHOOSE_XML1_BROWSE)
	{
      topnetonoff  = NPXML1OnOff1;
	  origwidth    = choosexml1_origwidth;
	}
    else if(type==CHOOSE_XML2_BROWSE)
	{
      topnetonoff  = NPXML2OnOff1;
	  origwidth    = choosexml2_origwidth;
	}
    else if(type==CHOOSE_XML3_BROWSE)
	{
      topnetonoff  = NPXML3OnOff1;
	  origwidth    = choosexml3_origwidth;
	}
    else if(type==ATTRFOLDER_BROWSE)
	{
	  topnetonoff  = NPCAOnOff1;
	  origwidth    = chooseattr_origwidth;
	}
    else if(type==CHOOSE_DP_BROWSE)
	{
	  topnetonoff  = NPDPOnOff1;
	  origwidth    = choosedp_origwidth;
	}
    else if(type==CHOOSEBROWSE_BROWSE)
	{
	  topnetonoff  = NPBROnOff1;
	  origwidth    = choosebr_origwidth;
	}
 	else
	{
	  XBell(mydisplay,50);
      printf("bad type %d to BOW\n",type);
	}


	if(origwidth<600)
	{
      printf("abnormal set of origwidth %d for type %d\n",origwidth,type);
      origwidth = 600;
	}



   if(topnetonoff==1)
   {

     for(i=0;i<NumNetDrives;i++)
	 { 
       sprintf(pathname2,"<%s>: %s",NetDriveNames[i],NetDrivePaths[i]);

      numslash = 0;
      len = strlen(pathname2);
      for(i=0;i<len;i++)
	  { 
        if(pathname2[i]=='\\')
		{ 
          numslash = numslash + 1;
		}
	  } 

	  

      if((len+2*numslash)>maxlen)
	  { 
        maxlen = len + 2*numslash;
	  } 
	 }   
   }


   XtVaGetValues (thiswid, XmNwidth, &oldwidth, NULL);

	

   

   if(type==CHOOSEPROJ_BROWSE)
   {
     newsize = (int)((maxlen-21)*9.25) + 309;
   }
   else
   {
     newsize = (int)((maxlen-21)*9.25) + 509;
   }


   maxwidth = DisplayWidth(mydisplay,DefaultScreen(mydisplay)) - 50;


   

   if(newsize>origwidth)
   {
	 if(newsize>maxwidth)
	 {
		 newsize = maxwidth;
	 }

     if(newsize!=oldwidth)
	 { 
       
       XtVaSetValues (thiswid, XmNwidth, newsize, NULL);
	 } 
   }  
   else if(oldwidth>origwidth)
   {
	 
     XtVaSetValues (thiswid, XmNwidth, origwidth, NULL);
   }


	





	
  if(type==CHOOSEPROJ_BROWSE)
  {
    set_cursor(XtDisplay(choose_dialog),XtWindow(choose_dialog),ARROW);
  }
  else if(type==CHOOSESHAPE_BROWSE)
  {
    set_cursor(XtDisplay(chooseshape_dialog),XtWindow(chooseshape_dialog),ARROW);
  }
  else if(type==CHOOSE_ES1_BROWSE)
  {
    set_cursor(XtDisplay(choose_es1_dialog),XtWindow(choose_es1_dialog),ARROW);
  }
  else if(type==CHOOSE_ES2_BROWSE)
  {
    set_cursor(XtDisplay(choose_es2_dialog),XtWindow(choose_es2_dialog),ARROW);
  }
  else if(type==CHOOSE_TXT_BROWSE)
  {
    set_cursor(XtDisplay(choose_txt_dialog),XtWindow(choose_txt_dialog),ARROW);
  }
  else if(type==CHOOSE_XML1_BROWSE)
  {
    set_cursor(XtDisplay(choose_xml1_dialog),XtWindow(choose_xml1_dialog),ARROW);
  }
  else if(type==CHOOSE_XML2_BROWSE)
  {
    set_cursor(XtDisplay(choose_xml2_dialog),XtWindow(choose_xml2_dialog),ARROW);
  }
  else if(type==CHOOSE_XML3_BROWSE)
  {
    set_cursor(XtDisplay(choose_xml3_dialog),XtWindow(choose_xml3_dialog),ARROW);
  }
  else if(type==ATTRFOLDER_BROWSE)
  {
    set_cursor(XtDisplay(chooseattr_dialog),XtWindow(chooseattr_dialog),ARROW);
  }
  else if(type==CHOOSE_DP_BROWSE)
  {
    set_cursor(XtDisplay(choosedp_dialog),XtWindow(choosedp_dialog),ARROW);
  }
  else if(type==CHOOSEBROWSE_BROWSE)
  {
    set_cursor(XtDisplay(choosebr_dialog),XtWindow(choosebr_dialog),ARROW);
  }
  else
  {
	printf("bad type in NTBHC %d\n",type);
  }


  rec_depth = rec_depth - 1;
  if(DOSDEBUG==1)
  {
    printf("on exit, rec_depth %d\n",rec_depth);
  }

  if(DOSDEBUG==1)
  {
    printf("done\n");
  }

}






void FreeWidList(int type, int destroyalso)
{
  int i;
  
  
  
  if(DOSDEBUG==1)
    {
      printf("\n\nfreeing\n\n");
    }
  
  if(type==CHOOSEPROJ_BROWSE)
    {
      if(ProjWidsSaved>0)
	{
	  if(DOSDEBUG==1)
	    {
	      printf("freeing %d wids\n",ProjWidsSaved);
	    }
	  
	  for(i=0;i<ProjWidsSaved;i++)
	    {
	      if((ProjWids[i]!=NULL)&&(destroyalso==1))
		{
		  XtDestroyWidget(ProjWids[i]);
		  XtDestroyWidget(ProjHands[i]);
		}
	    }
	  
	  free(ProjWids);
	  free(ProjHands);
	  free(ProjLevels);
	  ProjWids      = NULL;
	  ProjHands     = NULL;
	  ProjLevels    = NULL;
	  ProjWidsSaved = 0;
	}
    }
  else if(type==CHOOSESHAPE_BROWSE)
    {
      if(ShapeWidsSaved>0)
	{
	  if(DOSDEBUG==1)
	    {
	      printf("2 freeing %d wids\n",ShapeWidsSaved); 
	    }
	  
	  for(i=0;i<ShapeWidsSaved;i++)
	    {
	      if((ShapeWids[i]!=NULL)&&(destroyalso==1))
		{
		  XtDestroyWidget(ShapeWids[i]);
		  XtDestroyWidget(ShapeHands[i]);
		}
	    }
	  
	  free(ShapeWids);
	  free(ShapeHands);
	  free(ShapeLevels);
	  ShapeWids      = NULL;
	  ShapeHands     = NULL;
	  ShapeLevels    = NULL;
	  ShapeWidsSaved = 0;
	}
    }  
  else if(type==CHOOSE_ES1_BROWSE)
    {
      if(ES1WidsSaved>0)
	{
	  if(DOSDEBUG==1)
	    {
	      printf("3 freeing %d wids\n",ES1WidsSaved); 
	    }
	  
	  for(i=0;i<ES1WidsSaved;i++)
	    {
	      if((ES1Wids[i]!=NULL)&&(destroyalso==1))
		{
		  XtDestroyWidget(ES1Wids[i]);
		  XtDestroyWidget(ES1Hands[i]);
		}
	    }
	  
	  free(ES1Wids);
	  free(ES1Hands);
	  free(ES1Levels);
	  ES1Wids      = NULL;
	  ES1Hands     = NULL;
	  ES1Levels    = NULL;
	  ES1WidsSaved = 0;
	}
    }
  else if(type==CHOOSE_ES2_BROWSE)
    {
      
      if(ES2WidsSaved>0)
	{
	  if(DOSDEBUG==1)
	    {
	      printf("4 freeing %d wids\n",ES2WidsSaved); 
	    }
	  
	  for(i=0;i<ES2WidsSaved;i++)
	    {
	      if((ES2Wids[i]!=NULL)&&(destroyalso==1))
		{
		  XtDestroyWidget(ES2Wids[i]);
		  XtDestroyWidget(ES2Hands[i]);
		}
	    }
	  
	  free(ES2Wids);
	  free(ES2Hands);
	  free(ES2Levels);
	  ES2Wids      = NULL;
	  ES2Hands     = NULL;
	  ES2Levels    = NULL;
	  ES2WidsSaved = 0;
	}
    }
  else if(type==CHOOSE_TXT_BROWSE)
    {
      if(TXTWidsSaved>0)
	{
	  if(DOSDEBUG==1)
	    {
	      printf("5 freeing %d wids\n",TXTWidsSaved); 
	    }
	  
	  for(i=0;i<TXTWidsSaved;i++)
	    {
	      if((TXTWids[i]!=NULL)&&(destroyalso==1))
		{
		  XtDestroyWidget(TXTWids[i]);
		  XtDestroyWidget(TXTHands[i]);
		}
	    }
	  
	  free(TXTWids);
	  free(TXTHands);
	  free(TXTLevels);
	  TXTWids      = NULL;
	  TXTHands     = NULL;
	  TXTLevels    = NULL;
	  TXTWidsSaved = 0;
	}
    }
  else if(type==CHOOSEDATA_BROWSE)
    {
      if(DATAWidsSaved>0)
	{
	  if(DOSDEBUG==1)
	    {
	      printf("5 freeing %d wids\n",DATAWidsSaved); 
	    }
	  
	  for(i=0;i<DATAWidsSaved;i++)
	    {
	      if((DATAWids[i]!=NULL)&&(destroyalso==1))
		{
		  XtDestroyWidget(DATAWids[i]);
		  XtDestroyWidget(DATAHands[i]);
		}
	    }
	  
	  free(DATAWids);
	  free(DATAHands);
	  free(DATALevels);
	  DATAWids      = NULL;
	  DATAHands     = NULL;
	  DATALevels    = NULL;
	  DATAWidsSaved = 0;
	}
    }

  else if(type==CHOOSE_XML1_BROWSE)
    {
      if(XML1WidsSaved>0)
	{
	  if(DOSDEBUG==1)
	    {
	      printf("3 freeing %d wids\n",XML1WidsSaved); 
	    }
	  
	  for(i=0;i<XML1WidsSaved;i++)
	    {
	      if((XML1Wids[i]!=NULL)&&(destroyalso==1))
		{
		  XtDestroyWidget(XML1Wids[i]);
		  XtDestroyWidget(XML1Hands[i]);
		}
	    }
	  
	  free(XML1Wids);
	  free(XML1Hands);
	  free(XML1Levels);
	  XML1Wids      = NULL;
	  XML1Hands     = NULL;
	  XML1Levels    = NULL;
	  XML1WidsSaved = 0;
	}
    }

    else if(type==CHOOSE_XML2_BROWSE)
    {
      if(XML2WidsSaved>0)
	{
	  if(DOSDEBUG==1)
	    {
	      printf("3 freeing %d wids\n",XML2WidsSaved); 
	    }
	  
	  for(i=0;i<XML2WidsSaved;i++)
	    {
	      if((XML2Wids[i]!=NULL)&&(destroyalso==1))
		{
		  XtDestroyWidget(XML2Wids[i]);
		  XtDestroyWidget(XML2Hands[i]);
		}
	    }
	  
	  free(XML2Wids);
	  free(XML2Hands);
	  free(XML2Levels);
	  XML2Wids      = NULL;
	  XML2Hands     = NULL;
	  XML2Levels    = NULL;
	  XML2WidsSaved = 0;
	}
    }

	  else if(type==CHOOSE_XML3_BROWSE)
    {
      if(XML3WidsSaved>0)
	{
	  if(DOSDEBUG==1)
	    {
	      printf("3 freeing %d wids\n",XML3WidsSaved); 
	    }
	  
	  for(i=0;i<XML3WidsSaved;i++)
	    {
	      if((XML3Wids[i]!=NULL)&&(destroyalso==1))
		{
		  XtDestroyWidget(XML3Wids[i]);
		  XtDestroyWidget(XML3Hands[i]);
		}
	    }
	  
	  free(XML3Wids);
	  free(XML3Hands);
	  free(XML3Levels);
	  XML3Wids      = NULL;
	  XML3Hands     = NULL;
	  XML3Levels    = NULL;
	  XML3WidsSaved = 0;
	}
    }
  else if(type==ATTRFOLDER_BROWSE)
    {
      if(AttrWidsSaved>0)
	{
	  if(DOSDEBUG==1)
	    {
	      printf("freeing %d wids\n",AttrWidsSaved);
	    }
	  
	  for(i=0;i<AttrWidsSaved;i++)
	    {
	      if((AttrWids[i]!=NULL)&&(destroyalso==1))
		{
		  XtDestroyWidget(AttrWids[i]);
		  XtDestroyWidget(AttrHands[i]);
		}
	    }
	  
	  free(AttrWids);
	  free(AttrHands);
	  free(AttrLevels);
	  AttrWids      = NULL;
	  AttrHands     = NULL;
	  AttrLevels    = NULL;
	  AttrWidsSaved = 0;
	}
    }
  else if(type==CHOOSE_DP_BROWSE)
    {
      if(DPWidsSaved>0)
	{
	  if(DOSDEBUG==1)
	    {
	      printf("freeing %d wids\n",DPWidsSaved);
	    }
	  
	  for(i=0;i<DPWidsSaved;i++)
	    {
	      if((DPWids[i]!=NULL)&&(destroyalso==1))
		{
		  XtDestroyWidget(DPWids[i]);
		  XtDestroyWidget(DPHands[i]);
		}
	    }
	  
	  free(DPWids);
	  free(DPHands);
	  free(DPLevels);
	  DPWids      = NULL;
	  DPHands     = NULL;
	  DPLevels    = NULL;
	  DPWidsSaved = 0;
	}
    }
  else if(type==CHOOSEBROWSE_BROWSE)
    {
      if(BrowseWidsSaved>0)
	{
	  if(DOSDEBUG==1)
	    {
	      printf("freeing %d wids\n",BrowseWidsSaved);
	    }
	  
	  for(i=0;i<BrowseWidsSaved;i++)
	    {
	      if((BrowseWids[i]!=NULL)&&(destroyalso==1))
		{
		  XtDestroyWidget(BrowseWids[i]);
		  XtDestroyWidget(BrowseHands[i]);
		}
	    }
	  
	  free(BrowseWids);
	  free(BrowseHands);
	  free(BrowseLevels);
	  BrowseWids      = NULL;
	  BrowseHands     = NULL;
	  BrowseLevels    = NULL;
	  BrowseWidsSaved = 0;
	}
    }
  else
    {
      printf("bad type %d to FWL\n",type);
    }
}



void AddWidToList(int type, Widget wid, Widget subhandle, int level)
{
   
  if(type==CHOOSEPROJ_BROWSE)
  {
	  if(ProjWids==NULL)
	  {
		  if(ProjWidsSaved!=0)
		  {
			  XBell(mydisplay,50);
			  printf("got ProjWidsSaved %d but NULL ProjWids\n",ProjWidsSaved);
		  }

		  ProjLevels       = (int *)malloc(SzI * WidChunk);
		  ProjLevels[0]    = level;
		  ProjWids         = (Widget *)malloc(sizeof(Widget) * WidChunk);
		  ProjWids[0]      = wid;
		  ProjHands        = (Widget *)malloc(sizeof(Widget) * WidChunk);
		  ProjHands[0]     = subhandle;
		  ProjWidsSaved    = 1;
		  ProjWidsAllocced = WidChunk;
	  }
	  else
	  {
		  if(ProjWidsSaved==0)
		  {
			 XBell(mydisplay,50);
			 printf("got ProjWidsSaved 0 but non-NULL ProjWids\n");
		  }

		  ProjWidsSaved = ProjWidsSaved + 1;

		  if(ProjWidsSaved>=ProjWidsAllocced)
		  {
			ProjWidsAllocced = ProjWidsAllocced + WidChunk;

		    ProjWids   = (Widget *)realloc(ProjWids,  sizeof(Widget)*ProjWidsAllocced);
		    ProjHands  = (Widget *)realloc(ProjHands, sizeof(Widget)*ProjWidsAllocced);
		    ProjLevels = (int *)   realloc(ProjLevels,    SzI       *ProjWidsAllocced);
		  }

		  ProjWids  [ProjWidsSaved-1] = wid;
		  ProjHands [ProjWidsSaved-1] = subhandle;
		  ProjLevels[ProjWidsSaved-1] = level;

	  }
  }
  else if(type==CHOOSESHAPE_BROWSE)
  {
	  if(ShapeWids==NULL)
	  {
		  if(ShapeWidsSaved!=0)
		  {
			  XBell(mydisplay,50);
			  printf("got ShapeWidsSaved %d but NULL ShapeWids\n",ShapeWidsSaved);
		  }

		  ShapeLevels       = (int *)malloc(SzI * WidChunk);
		  ShapeLevels[0]    = level;
		  ShapeWids         = (Widget *)malloc(sizeof(Widget) * WidChunk);
		  ShapeWids[0]      = wid;
		  ShapeHands        = (Widget *)malloc(sizeof(Widget) * WidChunk);
		  ShapeHands[0]     = subhandle;
		  ShapeWidsSaved    = 1;
		  ShapeWidsAllocced = WidChunk;
	  }
	  else
	  {
		  if(ShapeWidsSaved==0)
		  {
			 XBell(mydisplay,50);
			 printf("got ShapeWidsSaved 0 but non-NULL ShapeWids\n");
		  }

		  ShapeWidsSaved = ShapeWidsSaved + 1;

		  if(ShapeWidsSaved>=ShapeWidsAllocced)
		  {
			ShapeWidsAllocced = ShapeWidsAllocced + WidChunk;

		    ShapeWids   = (Widget *)realloc(ShapeWids, sizeof(Widget)*ShapeWidsAllocced);
		    ShapeHands  = (Widget *)realloc(ShapeHands,sizeof(Widget)*ShapeWidsAllocced);
		    ShapeLevels = (int *)   realloc(ShapeLevels,   SzI       *ShapeWidsAllocced);
		  }

		  ShapeWids  [ShapeWidsSaved-1] = wid;
		  ShapeHands [ShapeWidsSaved-1] = subhandle;
		  ShapeLevels[ShapeWidsSaved-1] = level;
	  }
  }
 else if(type==CHOOSE_ES1_BROWSE)
  {
	  if(ES1Wids==NULL)
	  {
		  if(ES1WidsSaved!=0)
		  {
			  XBell(mydisplay,50);
			  printf("got ES1WidsSaved %d but NULL ES1Wids\n",ES1WidsSaved);
		  }

		  ES1Levels       = (int *)malloc(SzI * WidChunk);
		  ES1Levels[0]    = level;
		  ES1Wids         = (Widget *)malloc(sizeof(Widget) * WidChunk);
		  ES1Wids[0]      = wid;
		  ES1Hands        = (Widget *)malloc(sizeof(Widget) * WidChunk);
		  ES1Hands[0]     = subhandle;
		  ES1WidsSaved    = 1;
		  ES1WidsAllocced = WidChunk;
	  }
	  else
	  {
		  if(ES1WidsSaved==0)
		  {
			 XBell(mydisplay,50);
			 printf("got ES1WidsSaved 0 but non-NULL ES1Wids\n");
		  }

		  ES1WidsSaved = ES1WidsSaved + 1;

		  if(ES1WidsSaved>=ES1WidsAllocced)
		  {
			ES1WidsAllocced = ES1WidsAllocced + WidChunk;

		    ES1Wids   = (Widget *)realloc(ES1Wids, sizeof(Widget)*ES1WidsAllocced);
		    ES1Hands  = (Widget *)realloc(ES1Hands,sizeof(Widget)*ES1WidsAllocced);
		    ES1Levels = (int *)   realloc(ES1Levels,    SzI      *ES1WidsAllocced);
		  }

		  ES1Wids  [ES1WidsSaved-1] = wid;
		  ES1Hands [ES1WidsSaved-1] = subhandle;
		  ES1Levels[ES1WidsSaved-1] = level;
	  }
  }
  else if(type==CHOOSE_ES2_BROWSE)
  {
	  if(ES2Wids==NULL)
	  {
		  if(ES2WidsSaved!=0)
		  {
			  XBell(mydisplay,50);
			  printf("got ES2WidsSaved %d but NULL ES2Wids\n",ES2WidsSaved);
		  }

		  ES2Levels       = (int *)malloc(SzI * WidChunk);
		  ES2Levels[0]    = level;
		  ES2Wids         = (Widget *)malloc(sizeof(Widget) * WidChunk);
		  ES2Wids[0]      = wid;
		  ES2Hands        = (Widget *)malloc(sizeof(Widget) * WidChunk);
		  ES2Hands[0]     = subhandle;
		  ES2WidsSaved    = 1;
		  ES2WidsAllocced = WidChunk;
	  }
	  else
	  {
		  if(ES2WidsSaved==0)
		  {
			 XBell(mydisplay,50);
			 printf("got ES2WidsSaved 0 but non-NULL ES2Wids\n");
		  }

		  ES2WidsSaved = ES2WidsSaved + 1;

		  if(ES2WidsSaved>=ES2WidsAllocced)
		  {
			ES2WidsAllocced = ES2WidsAllocced + WidChunk;

		    ES2Wids   = (Widget *)realloc(ES2Wids, sizeof(Widget)*ES2WidsAllocced);
		    ES2Hands  = (Widget *)realloc(ES2Hands,sizeof(Widget)*ES2WidsAllocced);
		    ES2Levels = (int *)   realloc(ES2Levels,    SzI      *ES2WidsAllocced);
		  }

		  ES2Wids  [ES2WidsSaved-1] = wid;
		  ES2Hands [ES2WidsSaved-1] = subhandle;
		  ES2Levels[ES2WidsSaved-1] = level;
	  }
  }
  else if(type==CHOOSE_TXT_BROWSE)
  {
	  if(TXTWids==NULL)
	  {
		  if(TXTWidsSaved!=0)
		  {
			  XBell(mydisplay,50);
			  printf("got TXTWidsSaved %d but NULL TXTWids\n",TXTWidsSaved);
		  }

		  TXTLevels       = (int *)malloc(SzI * WidChunk);
		  TXTLevels[0]    = level;
		  TXTWids         = (Widget *)malloc(sizeof(Widget) * WidChunk);
		  TXTWids[0]      = wid;
		  TXTHands        = (Widget *)malloc(sizeof(Widget) * WidChunk);
		  TXTHands[0]     = subhandle;
		  TXTWidsSaved    = 1;
		  TXTWidsAllocced = WidChunk;
	  }
	  else
	  {
		  if(TXTWidsSaved==0)
		  {
			 XBell(mydisplay,50);
			 printf("got TXTWidsSaved 0 but non-NULL TXTWids\n");
		  }

		  TXTWidsSaved = TXTWidsSaved + 1;

		  if(TXTWidsSaved>=TXTWidsAllocced)
		  {
			TXTWidsAllocced = TXTWidsAllocced + WidChunk;

		    TXTWids   = (Widget *)realloc(TXTWids, sizeof(Widget)*TXTWidsAllocced);
		    TXTHands  = (Widget *)realloc(TXTHands,sizeof(Widget)*TXTWidsAllocced);
		    TXTLevels = (int *)   realloc(TXTLevels,    SzI      *TXTWidsAllocced);
		  }

		  TXTWids  [TXTWidsSaved-1] = wid;
		  TXTHands [TXTWidsSaved-1] = subhandle;
		  TXTLevels[TXTWidsSaved-1] = level;
	  }
  }


 else if(type==CHOOSE_XML1_BROWSE)
  {
	  if(XML1Wids==NULL)
	  {
		  if(XML1WidsSaved!=0)
		  {
			  XBell(mydisplay,50);
			  printf("got XML1WidsSaved %d but NULL XML1Wids\n",XML1WidsSaved);
		  }

		  XML1Levels       = (int *)malloc(SzI * WidChunk);
		  XML1Levels[0]    = level;
		  XML1Wids         = (Widget *)malloc(sizeof(Widget) * WidChunk);
		  XML1Wids[0]      = wid;
		  XML1Hands        = (Widget *)malloc(sizeof(Widget) * WidChunk);
		  XML1Hands[0]     = subhandle;
		  XML1WidsSaved    = 1;
		  XML1WidsAllocced = WidChunk;
	  }
	  else
	  {
		  if(XML1WidsSaved==0)
		  {
			 XBell(mydisplay,50);
			 printf("got XML1WidsSaved 0 but non-NULL XML1Wids\n");
		  }

		  XML1WidsSaved = XML1WidsSaved + 1;

		  if(XML1WidsSaved>=XML1WidsAllocced)
		  {
			XML1WidsAllocced = XML1WidsAllocced + WidChunk;

		    XML1Wids   = (Widget *)realloc(XML1Wids, sizeof(Widget)*XML1WidsAllocced);
		    XML1Hands  = (Widget *)realloc(XML1Hands,sizeof(Widget)*XML1WidsAllocced);
		    XML1Levels = (int *)   realloc(XML1Levels,    SzI      *XML1WidsAllocced);
		  }

		  XML1Wids  [XML1WidsSaved-1] = wid;
		  XML1Hands [XML1WidsSaved-1] = subhandle;
		  XML1Levels[XML1WidsSaved-1] = level;
	  }
  }


  else if(type==CHOOSE_XML2_BROWSE)
  {
	  if(XML2Wids==NULL)
	  {
		  if(XML2WidsSaved!=0)
		  {
			  XBell(mydisplay,50);
			  printf("got XML2WidsSaved %d but NULL XML2Wids\n",XML2WidsSaved);
		  }

		  XML2Levels       = (int *)malloc(SzI * WidChunk);
		  XML2Levels[0]    = level;
		  XML2Wids         = (Widget *)malloc(sizeof(Widget) * WidChunk);
		  XML2Wids[0]      = wid;
		  XML2Hands        = (Widget *)malloc(sizeof(Widget) * WidChunk);
		  XML2Hands[0]     = subhandle;
		  XML2WidsSaved    = 1;
		  XML2WidsAllocced = WidChunk;
	  }
	  else
	  {
		  if(XML2WidsSaved==0)
		  {
			 XBell(mydisplay,50);
			 printf("got XML2WidsSaved 0 but non-NULL XML2Wids\n");
		  }

		  XML2WidsSaved = XML2WidsSaved + 1;

		  if(XML2WidsSaved>=XML2WidsAllocced)
		  {
			XML2WidsAllocced = XML2WidsAllocced + WidChunk;

		    XML2Wids   = (Widget *)realloc(XML2Wids, sizeof(Widget)*XML2WidsAllocced);
		    XML2Hands  = (Widget *)realloc(XML2Hands,sizeof(Widget)*XML2WidsAllocced);
		    XML2Levels = (int *)   realloc(XML2Levels,    SzI      *XML2WidsAllocced);
		  }

		  XML2Wids  [XML2WidsSaved-1] = wid;
		  XML2Hands [XML2WidsSaved-1] = subhandle;
		  XML2Levels[XML2WidsSaved-1] = level;
	  }
  }


   else if(type==CHOOSE_XML3_BROWSE)
  {
	  if(XML3Wids==NULL)
	  {
		  if(XML3WidsSaved!=0)
		  {
			  XBell(mydisplay,50);
			  printf("got XML3WidsSaved %d but NULL XML3Wids\n",XML3WidsSaved);
		  }

		  XML3Levels       = (int *)malloc(SzI * WidChunk);
		  XML3Levels[0]    = level;
		  XML3Wids         = (Widget *)malloc(sizeof(Widget) * WidChunk);
		  XML3Wids[0]      = wid;
		  XML3Hands        = (Widget *)malloc(sizeof(Widget) * WidChunk);
		  XML3Hands[0]     = subhandle;
		  XML3WidsSaved    = 1;
		  XML3WidsAllocced = WidChunk;
	  }
	  else
	  {
		  if(XML3WidsSaved==0)
		  {
			 XBell(mydisplay,50);
			 printf("got XML3WidsSaved 0 but non-NULL XML3Wids\n");
		  }

		  XML3WidsSaved = XML3WidsSaved + 1;

		  if(XML3WidsSaved>=XML3WidsAllocced)
		  {
			XML3WidsAllocced = XML3WidsAllocced + WidChunk;

		    XML3Wids   = (Widget *)realloc(XML3Wids, sizeof(Widget)*XML3WidsAllocced);
		    XML3Hands  = (Widget *)realloc(XML3Hands,sizeof(Widget)*XML3WidsAllocced);
		    XML3Levels = (int *)   realloc(XML3Levels,    SzI      *XML3WidsAllocced);
		  }

		  XML3Wids  [XML3WidsSaved-1] = wid;
		  XML3Hands [XML3WidsSaved-1] = subhandle;
		  XML3Levels[XML3WidsSaved-1] = level;
	  }
  }

  else if(type==ATTRFOLDER_BROWSE)
  {
	  if(AttrWids==NULL)
	  {
		  if(AttrWidsSaved!=0)
		  {
			  XBell(mydisplay,50);
			  printf("got AttrWidsSaved %d but NULL AttrWids\n",AttrWidsSaved);
		  }

		  AttrLevels       = (int *)malloc(SzI * WidChunk);
		  AttrLevels[0]    = level;
		  AttrWids         = (Widget *)malloc(sizeof(Widget) * WidChunk);
		  AttrWids[0]      = wid;
		  AttrHands        = (Widget *)malloc(sizeof(Widget) * WidChunk);
		  AttrHands[0]     = subhandle;
		  AttrWidsSaved    = 1;
		  AttrWidsAllocced = WidChunk;
	  }
	  else
	  {
		  if(AttrWidsSaved==0)
		  {
			 XBell(mydisplay,50);
			 printf("got AttrWidsSaved 0 but non-NULL AttrWids\n");
		  }

		  AttrWidsSaved = AttrWidsSaved + 1;

		  if(AttrWidsSaved>=AttrWidsAllocced)
		  {
			AttrWidsAllocced = AttrWidsAllocced + WidChunk;

		    AttrWids   = (Widget *)realloc(AttrWids,  sizeof(Widget)*AttrWidsAllocced);
		    AttrHands  = (Widget *)realloc(AttrHands, sizeof(Widget)*AttrWidsAllocced);
		    AttrLevels = (int *)   realloc(AttrLevels,    SzI       *AttrWidsAllocced);
		  }

		  AttrWids  [AttrWidsSaved-1] = wid;
		  AttrHands [AttrWidsSaved-1] = subhandle;
		  AttrLevels[AttrWidsSaved-1] = level;

	  }
  }
  else if(type==CHOOSE_DP_BROWSE)
  {
	  if(DPWids==NULL)
	  {
		  if(DPWidsSaved!=0)
		  {
			  XBell(mydisplay,50);
			  printf("got DPWidsSaved %d but NULL DPWids\n",DPWidsSaved);
		  }

		  DPLevels       = (int *)malloc(SzI * WidChunk);
		  DPLevels[0]    = level;
		  DPWids         = (Widget *)malloc(sizeof(Widget) * WidChunk);
		  DPWids[0]      = wid;
		  DPHands        = (Widget *)malloc(sizeof(Widget) * WidChunk);
		  DPHands[0]     = subhandle;
		  DPWidsSaved    = 1;
		  DPWidsAllocced = WidChunk;
	  }
	  else
	  {
		  if(DPWidsSaved==0)
		  {
			 XBell(mydisplay,50);
			 printf("got DPWidsSaved 0 but non-NULL DPWids\n");
		  }

		  DPWidsSaved = DPWidsSaved + 1;

		  if(DPWidsSaved>=DPWidsAllocced)
		  {
			DPWidsAllocced = DPWidsAllocced + WidChunk;

		    DPWids   = (Widget *)realloc(DPWids,  sizeof(Widget)*DPWidsAllocced);
		    DPHands  = (Widget *)realloc(DPHands, sizeof(Widget)*DPWidsAllocced);
		    DPLevels = (int *)   realloc(DPLevels,    SzI       *DPWidsAllocced);
		  }

		  DPWids  [DPWidsSaved-1] = wid;
		  DPHands [DPWidsSaved-1] = subhandle;
		  DPLevels[DPWidsSaved-1] = level;

	  }
  }

  else if(type==CHOOSEBROWSE_BROWSE)
  {
	  if(BrowseWids==NULL)
	  {
		  if(BrowseWidsSaved!=0)
		  {
			  XBell(mydisplay,50);
			  printf("got BrowseWidsSaved %d but NULL BrowseWids\n",BrowseWidsSaved);
		  }

		  BrowseLevels       = (int *)malloc(SzI * WidChunk);
		  BrowseLevels[0]    = level;
		  BrowseWids         = (Widget *)malloc(sizeof(Widget) * WidChunk);
		  BrowseWids[0]      = wid;
		  BrowseHands        = (Widget *)malloc(sizeof(Widget) * WidChunk);
		  BrowseHands[0]     = subhandle;
		  BrowseWidsSaved    = 1;
		  BrowseWidsAllocced = WidChunk;
	  }
	  else
	  {
		  if(BrowseWidsSaved==0)
		  {
			 XBell(mydisplay,50);
			 printf("got BrowseWidsSaved 0 but non-NULL BrowseWids\n");
		  }

		  BrowseWidsSaved = BrowseWidsSaved + 1;

		  if(BrowseWidsSaved>=BrowseWidsAllocced)
		  {
			BrowseWidsAllocced = BrowseWidsAllocced + WidChunk;

		    BrowseWids   = (Widget *)realloc(BrowseWids,  sizeof(Widget)*BrowseWidsAllocced);
		    BrowseHands  = (Widget *)realloc(BrowseHands, sizeof(Widget)*BrowseWidsAllocced);
		    BrowseLevels = (int *)   realloc(BrowseLevels,    SzI       *BrowseWidsAllocced);
		  }

		  BrowseWids  [BrowseWidsSaved-1] = wid;
		  BrowseHands [BrowseWidsSaved-1] = subhandle;
		  BrowseLevels[BrowseWidsSaved-1] = level;
	  }
  }

  else
  {
	  printf("bad type %d to AWTL\n",type);
  }
}



void toggle_dos(Widget widget,XtPointer client_data,XtPointer call_data)
{
  static double lastclick =    0;
  static int    lastwid        = -999;
  Widget Wspecified;
  XmString *thesefiles;
  char pathname[1000],shortname[1000];
 
  double thistime,elapsed;
  int i,j,num,maxindex,type=(int)client_data,specifiedwid = -1,thislen,saveup=0,oldnum,insertindex;

  
  


  thistime = clock();

  maxindex = GetMaxIndex(type,"toggle_dos");


  
  for(i=0;i<maxindex;i++)
  {
	if(type==(CHOOSEPROJ_BROWSE))
	{
      XtVaSetValues(ProjWids[i],XmNbackground,mybackground,NULL);
      XtVaSetValues(ProjWids[i],XmNforeground,myforeground,NULL);
	  XmToggleButtonSetState(ProjWids[i],(Boolean)0,(Boolean)0);
	  if(widget==ProjWids[i])
	  {
	    specifiedwid = i;
	    Wspecified = ProjWids[i];
	  }
	}
	else if(type==CHOOSESHAPE_BROWSE)
	{
      XtVaSetValues(ShapeWids[i],XmNbackground,mybackground,NULL);
      XtVaSetValues(ShapeWids[i],XmNforeground,myforeground,NULL);
	  XmToggleButtonSetState(ShapeWids[i],(Boolean)0,(Boolean)0);
	  if(widget==ShapeWids[i])
	  {
	   specifiedwid = i;
	   Wspecified = ShapeWids[i];

 	   

	   sprintf(pathname,"%s\\",GetPathFromWid(type,i));

       set_cursor(XtDisplay(chooseshape_dialog),XtWindow(chooseshape_dialog),WATCH);
       set_cursor(mydisplay,mywindow,WATCH);





	   if(USE_DOS==1)
	   {
	     

         num = GetFolders(pathname,7,0);  

	     for(j=0;j<num;j++)
		 {
		   thislen = strlen(TempFolderList[j]);
		   

		   if(thislen>=5)
		   {
		     if
		       (
	              (TempFolderList[j][thislen-5]=='.')                                          &&
	            ( (TempFolderList[j][thislen-4]=='g') || (TempFolderList[j][thislen-4]=='G') ) &&
	            ( (TempFolderList[j][thislen-3]=='d') || (TempFolderList[j][thislen-3]=='D') ) &&
	            ( (TempFolderList[j][thislen-2]=='b') || (TempFolderList[j][thislen-2]=='B') ) &&
	              (TempFolderList[j][thislen-1]=='\\')
			   )
			 {
                TempFolderList[j][thislen-1] = '\0';  
				saveup = saveup + 1; 
			 }
			 else
			 {
				TempFolderList[j][0] = '\0'; 
			 }
		   }
		   else
		   {
		     TempFolderList[j][0] = '\0'; 
		   }
		 } 
	   }

       oldnum = num;



       num = GetFolders(pathname,8,1);

       set_cursor(XtDisplay(chooseshape_dialog),XtWindow(chooseshape_dialog),ARROW);
	   set_cursor(mydisplay,mywindow,GOOD);

       thesefiles = NULL;
	   thesefiles = (XmString *) (malloc(sizeof(XmString *) * (num+saveup)));


	   insertindex = 0;
 	   for(j=0;j<oldnum;j++)
	    {
		  if(TempFolderList[j][0]!='\0')
		  {
			GetShortName(shortname,TempFolderList[j]);

		    thesefiles[insertindex] = XmStringCreateLocalized (shortname);
			insertindex = insertindex + 1;
		  }
	      free(TempFolderList[j]);
	    }
	   if(TempFolderList!=NULL)
	   {
		 
		 free(TempFolderList);
	   }
	   TempFolderList = NULL;



	   for(j=0;j<num;j++)
	    {
		  thesefiles[insertindex] = XmStringCreateLocalized (TempFileList[j]);
		  insertindex = insertindex + 1;
	      free(TempFileList[j]);
	    }
	   if(TempFileList!=NULL)
	   {
		 
		 free(TempFileList);
	   }
	   TempFileList = NULL;
	   

       XtVaSetValues (CHOOSESHAPE_BROWSE_fw,
		     XmNitems,            thesefiles,
		     XmNitemCount,        num+saveup,
		     NULL);   

	   for(j=0;j<num;j++)
	    {
		  XmStringFree(thesefiles[j]);
	    }
	   if(num>0)
	   {
		   free(thesefiles);
	   }
	  }
	}

	else if(type==CHOOSE_ES1_BROWSE)
	{
      XmListDeselectAllItems(CHOOSE_ES1_BROWSE_fw);

      XtVaSetValues(ES1Wids[i],XmNbackground,mybackground,NULL);
      XtVaSetValues(ES1Wids[i],XmNforeground,myforeground,NULL);
	  XmToggleButtonSetState(ES1Wids[i],(Boolean)0,(Boolean)0);
	  if(widget==ES1Wids[i])
	  {
	   specifiedwid = i;
	   Wspecified = ES1Wids[i];

 	   

	   sprintf(pathname,"%s\\",GetPathFromWid(type,i));

       set_cursor(XtDisplay(choose_es1_dialog),XtWindow(choose_es1_dialog),WATCH);
       set_cursor(mydisplay,mywindow,WATCH);

       num = GetFolders(pathname,9,1);

	   if(num>0)
	   {
         SortCondList(0,num-1,3);
	   }

       set_cursor(XtDisplay(choose_es1_dialog),XtWindow(choose_es1_dialog),ARROW);
	   set_cursor(mydisplay,mywindow,GOOD);

       thesefiles = NULL;
	   if(num>0)
	   {
	     thesefiles = (XmString *) (malloc(sizeof(XmString *) * num));
	   }

 
        
	   for(j=0;j<num;j++)
	    {
		  thesefiles[j] = XmStringCreateLocalized (GAITCondList[j]);
	      free(GAITCondList[j]);
	    }
	   if(GAITCondList!=NULL)
	   {
		   
		  free(GAITCondList);
	   }
	   GAITCondList = NULL;
	   

       XtVaSetValues (CHOOSE_ES1_BROWSE_fw,
		     XmNitems,            thesefiles,
		     XmNitemCount,        num,
		     NULL);   

	   for(j=0;j<num;j++)
	    {
		  XmStringFree(thesefiles[j]);
	    }
	   if(num>0)
	   {
		   free(thesefiles);
	   }
	  }
	}

	else if(type==CHOOSE_ES2_BROWSE)
	{
      XmListDeselectAllItems(CHOOSE_ES2_BROWSE_fw);

      XtVaSetValues(ES2Wids[i],XmNbackground,mybackground,NULL);
      XtVaSetValues(ES2Wids[i],XmNforeground,myforeground,NULL);
	  XmToggleButtonSetState(ES2Wids[i],(Boolean)0,(Boolean)0);
	  if(widget==ES2Wids[i])
	  {
	   specifiedwid = i;
	   Wspecified = ES2Wids[i];

 	   

	   sprintf(pathname,"%s\\",GetPathFromWid(type,i));

       set_cursor(XtDisplay(choose_es2_dialog),XtWindow(choose_es2_dialog),WATCH);
       set_cursor(mydisplay,mywindow,WATCH);

       num = GetFolders(pathname,9,1);

       set_cursor(XtDisplay(choose_es2_dialog),XtWindow(choose_es2_dialog),ARROW);
	   set_cursor(mydisplay,mywindow,GOOD);

       thesefiles = NULL;
	   thesefiles = (XmString *) (malloc(sizeof(XmString *) * num));
 
        
	   for(j=0;j<num;j++)
	    {
		  thesefiles[j] = XmStringCreateLocalized (GAITCondList[j]);
	      free(GAITCondList[j]);
	    }
	   if(GAITCondList!=NULL)
	   {
		  
		  free(GAITCondList);
	   }
	   GAITCondList = NULL;
	   

       XtVaSetValues (CHOOSE_ES2_BROWSE_fw,
		     XmNitems,            thesefiles,
		     XmNitemCount,        num,
		     NULL);   

	   for(j=0;j<num;j++)
	    {
		  XmStringFree(thesefiles[j]);
	    }
	   if(num>0)
	   {
		   free(thesefiles);
	   }
	  }
	}

	else if(type==CHOOSE_TXT_BROWSE)
	{
	  XmListDeselectAllItems(CHOOSE_TXT_BROWSE_fw);
      XtVaSetValues(TXTWids[i],XmNbackground,mybackground,NULL);
      XtVaSetValues(TXTWids[i],XmNforeground,myforeground,NULL);
	  XmToggleButtonSetState(TXTWids[i],(Boolean)0,(Boolean)0);
	  if(widget==TXTWids[i])
	  {
	   specifiedwid = i;
	   Wspecified = TXTWids[i];

 	   

	   sprintf(pathname,"%s\\",GetPathFromWid(type,i));

       set_cursor(XtDisplay(choose_txt_dialog),XtWindow(choose_txt_dialog),WATCH);
       set_cursor(mydisplay,mywindow,WATCH);


       num = GetFolders(pathname,8,1);

       set_cursor(XtDisplay(choose_txt_dialog),XtWindow(choose_txt_dialog),ARROW);
	   set_cursor(mydisplay,mywindow,GOOD);

       thesefiles = NULL;
	   thesefiles = (XmString *) (malloc(sizeof(XmString *) * num));
 
        
	   for(j=0;j<num;j++)
	    {
		  thesefiles[j] = XmStringCreateLocalized (TempFileList[j]);
	      free(TempFileList[j]);
	    }
	   if(TempFileList!=NULL)
	   {
		  
		  free(TempFileList);
	   }
	   TempFileList = NULL;
	   

       XtVaSetValues (CHOOSE_TXT_BROWSE_fw,
		     XmNitems,            thesefiles,
		     XmNitemCount,        num,
		     NULL);   

	   for(j=0;j<num;j++)
	    {
		  XmStringFree(thesefiles[j]);
	    }
	   if(num>0)
	   {
		   free(thesefiles);
	   }
	  }
	}

	else if(type==CHOOSE_XML1_BROWSE)
	{
      XmListDeselectAllItems(CHOOSE_XML1_BROWSE_fw);

      XtVaSetValues(XML1Wids[i],XmNbackground,mybackground,NULL);
      XtVaSetValues(XML1Wids[i],XmNforeground,myforeground,NULL);
	  XmToggleButtonSetState(XML1Wids[i],(Boolean)0,(Boolean)0);
	  if(widget==XML1Wids[i])
	  {
	   specifiedwid = i;
	   Wspecified = XML1Wids[i];

 	   

	   sprintf(pathname,"%s\\",GetPathFromWid(type,i));

       set_cursor(XtDisplay(choose_xml1_dialog),XtWindow(choose_xml1_dialog),WATCH);
       set_cursor(mydisplay,mywindow,WATCH);

       num = GetFolders(pathname,10,1); 


	   if(num>0)
	   {
         SortFileList(0,num-1,7);
	   }

       set_cursor(XtDisplay(choose_xml1_dialog),XtWindow(choose_xml1_dialog),ARROW);
	   set_cursor(mydisplay,mywindow,GOOD);

       thesefiles = NULL;
	   if(num>0)
	   {
	     thesefiles = (XmString *) (malloc(sizeof(XmString *) * num));
	   }

 
        
	   for(j=0;j<num;j++)
	    {
		  thesefiles[j] = XmStringCreateLocalized (TempFileList[j]);
	      free(TempFileList[j]);
	    }
	   if(TempFileList!=NULL)
	   {
		   
		  free(TempFileList);
	   }
	   TempFileList = NULL;
	   

       XtVaSetValues (CHOOSE_XML1_BROWSE_fw,
		     XmNitems,            thesefiles,
		     XmNitemCount,        num,
		     NULL);   

	   for(j=0;j<num;j++)
	    {
		  XmStringFree(thesefiles[j]);
	    }
	   if(num>0)
	   {
		   free(thesefiles);
	   }
	  }
	}

	else if(type==CHOOSE_XML2_BROWSE)
	{
      XmListDeselectAllItems(CHOOSE_XML2_BROWSE_fw);

      XtVaSetValues(XML2Wids[i],XmNbackground,mybackground,NULL);
      XtVaSetValues(XML2Wids[i],XmNforeground,myforeground,NULL);
	  XmToggleButtonSetState(XML2Wids[i],(Boolean)0,(Boolean)0);
	  if(widget==XML2Wids[i])
	  {
	   specifiedwid = i;
	   Wspecified = XML2Wids[i];

 	   

	   sprintf(pathname,"%s\\",GetPathFromWid(type,i));

       set_cursor(XtDisplay(choose_xml2_dialog),XtWindow(choose_xml2_dialog),WATCH);
       set_cursor(mydisplay,mywindow,WATCH);

       num = GetFolders(pathname,11,1); 

	   if(num>0)
	   {
         SortFileList(0,num-1,7);
	   }

       set_cursor(XtDisplay(choose_xml2_dialog),XtWindow(choose_xml2_dialog),ARROW);
	   set_cursor(mydisplay,mywindow,GOOD);

       thesefiles = NULL;
	   if(num>0)
	   {
	     thesefiles = (XmString *) (malloc(sizeof(XmString *) * num));
	   }

 
        
	   for(j=0;j<num;j++)
	    {
		  thesefiles[j] = XmStringCreateLocalized (TempFileList[j]);
	      free(TempFileList[j]);
	    }
	   if(TempFileList!=NULL)
	   {
		   
		  free(TempFileList);
	   }
	   TempFileList = NULL;
	   

       XtVaSetValues (CHOOSE_XML2_BROWSE_fw,
		     XmNitems,            thesefiles,
		     XmNitemCount,        num,
		     NULL);   

	   for(j=0;j<num;j++)
	    {
		  XmStringFree(thesefiles[j]);
	    }
	   if(num>0)
	   {
		   free(thesefiles);
	   }
	  }
	}

	else if(type==CHOOSE_XML3_BROWSE)
	{
      XmListDeselectAllItems(CHOOSE_XML3_BROWSE_fw);

      XtVaSetValues(XML3Wids[i],XmNbackground,mybackground,NULL);
      XtVaSetValues(XML3Wids[i],XmNforeground,myforeground,NULL);
	  XmToggleButtonSetState(XML3Wids[i],(Boolean)0,(Boolean)0);
	  if(widget==XML3Wids[i])
	  {
	   specifiedwid = i;
	   Wspecified = XML3Wids[i];

 	   

	   sprintf(pathname,"%s\\",GetPathFromWid(type,i));

       set_cursor(XtDisplay(choose_xml3_dialog),XtWindow(choose_xml3_dialog),WATCH);
       set_cursor(mydisplay,mywindow,WATCH);

       num = GetFolders(pathname,8,1);

	   if(num>0)
	   {
         SortFileList(0,num-1,3);
	   }

       set_cursor(XtDisplay(choose_xml3_dialog),XtWindow(choose_xml3_dialog),ARROW);
	   set_cursor(mydisplay,mywindow,GOOD);

       thesefiles = NULL;
	   if(num>0)
	   {
	     thesefiles = (XmString *) (malloc(sizeof(XmString *) * num));
	   }

 
        
	   for(j=0;j<num;j++)
	    {
		  thesefiles[j] = XmStringCreateLocalized (TempFileList[j]);
	      free(TempFileList[j]);
	    }
	   if(TempFileList!=NULL)
	   {
		   
		  free(TempFileList);
	   }
	   TempFileList = NULL;
	   

       XtVaSetValues (CHOOSE_XML3_BROWSE_fw,
		     XmNitems,            thesefiles,
		     XmNitemCount,        num,
		     NULL);   

	   for(j=0;j<num;j++)
	    {
		  XmStringFree(thesefiles[j]);
	    }
	   if(num>0)
	   {
		   free(thesefiles);
	   }
	  }
	}

	else if(type==ATTRFOLDER_BROWSE)
	{
      XtVaSetValues(AttrWids[i],XmNbackground,mybackground,NULL);
      XtVaSetValues(AttrWids[i],XmNforeground,myforeground,NULL);
	  XmToggleButtonSetState(AttrWids[i],(Boolean)0,(Boolean)0);
	  if(widget==AttrWids[i])
	  {
	   specifiedwid = i;
	   Wspecified = AttrWids[i];

 	   

	   sprintf(pathname,"%s\\",GetPathFromWid(type,i));

       set_cursor(XtDisplay(chooseattr_dialog),XtWindow(chooseattr_dialog),WATCH);
       set_cursor(mydisplay,mywindow,WATCH);


	   if(USE_DOS==1)
	   {
	     

         num = GetFolders(pathname,7,0);  

	     for(j=0;j<num;j++)
		 {
		   thislen = strlen(TempFolderList[j]);
		   

		   if(thislen>=5)
		   {
		     if
		       (
	              (TempFolderList[j][thislen-5]=='.')                                          &&
	            ( (TempFolderList[j][thislen-4]=='g') || (TempFolderList[j][thislen-4]=='G') ) &&
	            ( (TempFolderList[j][thislen-3]=='d') || (TempFolderList[j][thislen-3]=='D') ) &&
	            ( (TempFolderList[j][thislen-2]=='b') || (TempFolderList[j][thislen-2]=='B') ) &&
	              (TempFolderList[j][thislen-1]=='\\')
			   )
			 {
                TempFolderList[j][thislen-1] = '\0';  
				saveup = saveup + 1; 
			 }
			 else
			 {
				TempFolderList[j][0] = '\0'; 
			 }
		   }
		   else
		   {
		     TempFolderList[j][0] = '\0'; 
		   }
		 } 
	   }

       oldnum = num;

       num = GetFolders(pathname,12,1);

       set_cursor(XtDisplay(chooseattr_dialog),XtWindow(chooseattr_dialog),ARROW);
	   set_cursor(mydisplay,mywindow,GOOD);

       thesefiles = NULL;
	   thesefiles = (XmString *) (malloc(sizeof(XmString *) * (num+saveup)));


	   insertindex = 0;
 	   for(j=0;j<oldnum;j++)
	    {
		  if(TempFolderList[j][0]!='\0')
		  {
			GetShortName(shortname,TempFolderList[j]);

		    thesefiles[insertindex] = XmStringCreateLocalized (shortname);
			insertindex = insertindex + 1;
		  }
	      free(TempFolderList[j]);
	    }
	   if(TempFolderList!=NULL)
	   {
		 
		 free(TempFolderList);
	   }
	   TempFolderList = NULL;



	   for(j=0;j<num;j++)
	    {
		  thesefiles[insertindex] = XmStringCreateLocalized (TempFileList[j]);
		  insertindex = insertindex + 1;
	      free(TempFileList[j]);
	    }
	   if(TempFileList!=NULL)
	   {
		 
		 free(TempFileList);
	   }
	   TempFileList = NULL;
	   

       XtVaSetValues (ATTRFOLDER_BROWSE_fw,
		     XmNitems,            thesefiles,
		     XmNitemCount,        num+saveup,
		     NULL);   

	   for(j=0;j<num;j++)
	    {
		  XmStringFree(thesefiles[j]);
	    }
	   if(num>0)
	   {
		   free(thesefiles);
	   }
	  }
	}
	else if(type==CHOOSE_DP_BROWSE)
	{
      XtVaSetValues(DPWids[i],XmNbackground,mybackground,NULL);
      XtVaSetValues(DPWids[i],XmNforeground,myforeground,NULL);
	  XmToggleButtonSetState(DPWids[i],(Boolean)0,(Boolean)0);
	  if(widget==DPWids[i])
	  {
	   specifiedwid = i;
	   Wspecified = DPWids[i];

 	   

	   sprintf(pathname,"%s\\",GetPathFromWid(type,i));

       set_cursor(XtDisplay(choosedp_dialog),XtWindow(choosedp_dialog),WATCH);
       set_cursor(mydisplay,mywindow,WATCH);


	   if(USE_DOS==1)
	   {
	     

         num = GetFolders(pathname,7,0);  

	     for(j=0;j<num;j++)
		 {
		   thislen = strlen(TempFolderList[j]);
		   

		   if(thislen>=5)
		   {
		     if
		       (
	              (TempFolderList[j][thislen-5]=='.')                                          &&
	            ( (TempFolderList[j][thislen-4]=='g') || (TempFolderList[j][thislen-4]=='G') ) &&
	            ( (TempFolderList[j][thislen-3]=='d') || (TempFolderList[j][thislen-3]=='D') ) &&
	            ( (TempFolderList[j][thislen-2]=='b') || (TempFolderList[j][thislen-2]=='B') ) &&
	              (TempFolderList[j][thislen-1]=='\\')
			   )
			 {
                TempFolderList[j][thislen-1] = '\0';  
				saveup = saveup + 1; 
			 }
			 else
			 {
				TempFolderList[j][0] = '\0'; 
			 }
		   }
		   else
		   {
		     TempFolderList[j][0] = '\0'; 
		   }
		 } 
	   }

       oldnum = num;

       num = GetFolders(pathname,8,1); 

       set_cursor(XtDisplay(choosedp_dialog),XtWindow(choosedp_dialog),ARROW);
	   set_cursor(mydisplay,mywindow,GOOD);

       thesefiles = NULL;
	   thesefiles = (XmString *) (malloc(sizeof(XmString *) * (num+saveup)));


	   insertindex = 0;
 	   for(j=0;j<oldnum;j++)
	    {
		  if(TempFolderList[j][0]!='\0')
		  {
			GetShortName(shortname,TempFolderList[j]);

		    thesefiles[insertindex] = XmStringCreateLocalized (shortname);
			insertindex = insertindex + 1;
		  }
	      free(TempFolderList[j]);
	    }
	   if(TempFolderList!=NULL)
	   {
		 
		 free(TempFolderList);
	   }
	   TempFolderList = NULL;



	   for(j=0;j<num;j++)
	    {
		  thesefiles[insertindex] = XmStringCreateLocalized (TempFileList[j]);
		  insertindex = insertindex + 1;
	      free(TempFileList[j]);
	    }
	   if(TempFileList!=NULL)
	   {
		 
		 free(TempFileList);
	   }
	   TempFileList = NULL;
	   

       XtVaSetValues (DP_BROWSE_fw,
		     XmNitems,            thesefiles,
		     XmNitemCount,        num+saveup,
		     NULL);   

	   for(j=0;j<num;j++)
	    {
		  XmStringFree(thesefiles[j]);
	    }
	   if(num>0)
	   {
		   free(thesefiles);
	   }
	  }
	}



	else if(type==CHOOSEBROWSE_BROWSE)
	{
      XtVaSetValues(BrowseWids[i],XmNbackground,mybackground,NULL);
      XtVaSetValues(BrowseWids[i],XmNforeground,myforeground,NULL);
	  XmToggleButtonSetState(BrowseWids[i],(Boolean)0,(Boolean)0);
	  if(widget==BrowseWids[i])
	  {
	   specifiedwid = i;
	   Wspecified = BrowseWids[i];

 	   

	   sprintf(pathname,"%s\\",GetPathFromWid(type,i));

       set_cursor(XtDisplay(choosebr_dialog),XtWindow(choosebr_dialog),WATCH);
       set_cursor(mydisplay,mywindow,WATCH);


	   if(USE_DOS==1)
	   {
	     

         num = GetFolders(pathname,7,0);  

	     for(j=0;j<num;j++)
		 {
		   thislen = strlen(TempFolderList[j]);
		   

		   if(thislen>=5)
		   {
		     if
		       (
	              (TempFolderList[j][thislen-5]=='.')                                          &&
	            ( (TempFolderList[j][thislen-4]=='g') || (TempFolderList[j][thislen-4]=='G') ) &&
	            ( (TempFolderList[j][thislen-3]=='d') || (TempFolderList[j][thislen-3]=='D') ) &&
	            ( (TempFolderList[j][thislen-2]=='b') || (TempFolderList[j][thislen-2]=='B') ) &&
	              (TempFolderList[j][thislen-1]=='\\')
			   )
			 {
                TempFolderList[j][thislen-1] = '\0';  
				saveup = saveup + 1; 
			 }
			 else
			 {
				TempFolderList[j][0] = '\0'; 
			 }
		   }
		   else
		   {
		     TempFolderList[j][0] = '\0'; 
		   }
		 } 
	   }

       oldnum = num;

       num = GetFolders(pathname,8,1); 

       set_cursor(XtDisplay(choosebr_dialog),XtWindow(choosebr_dialog),ARROW);
	   set_cursor(mydisplay,mywindow,GOOD);

       thesefiles = NULL;
	   thesefiles = (XmString *) (malloc(sizeof(XmString *) * (num+saveup)));


	   insertindex = 0;
 	   for(j=0;j<oldnum;j++)
	    {
		  if(TempFolderList[j][0]!='\0')
		  {
			GetShortName(shortname,TempFolderList[j]);

		    thesefiles[insertindex] = XmStringCreateLocalized (shortname);
			insertindex = insertindex + 1;
		  }
	      free(TempFolderList[j]);
	    }
	   if(TempFolderList!=NULL)
	   {
		 
		 free(TempFolderList);
	   }
	   TempFolderList = NULL;



	   for(j=0;j<num;j++)
	    {
		  thesefiles[insertindex] = XmStringCreateLocalized (TempFileList[j]);
		  insertindex = insertindex + 1;
	      free(TempFileList[j]);
	    }
	   if(TempFileList!=NULL)
	   {
		 
		 free(TempFileList);
	   }
	   TempFileList = NULL;
	   

       XtVaSetValues (BROWSE_BROWSE_fw,
		     XmNitems,            thesefiles,
		     XmNitemCount,        num+saveup,
		     NULL);   

	   for(j=0;j<num;j++)
	    {
		  XmStringFree(thesefiles[j]);
	    }
	   if(num>0)
	   {
		   free(thesefiles);
	   }
	  }
	}



	else
	{
		printf("bad value %d to TD2\n",type);
	}
  } 


  XtVaSetValues(widget,XmNbackground,myforeground,NULL);
  XtVaSetValues(widget,XmNforeground,mybackground,NULL);

  XmToggleButtonSetState(widget,(Boolean)1,(Boolean)0);

  if((type==CHOOSEPROJ_BROWSE)||(type==CHOOSESHAPE_BROWSE)||(type==CHOOSE_TXT_BROWSE)||
	 (type==ATTRFOLDER_BROWSE)||(type==CHOOSE_DP_BROWSE)||(type==CHOOSEBROWSE_BROWSE))
  {
    if((lastclick!=0)&&(specifiedwid==lastwid))
	{
	 elapsed = (thistime - lastclick)/CLOCKS_PER_SEC;
	 if((elapsed*1000.0)<DOUBLECLICK)
	 {
	   choose_dos_browse_cb(Wspecified,client_data,(XtPointer)NULL);
	 }
	}
  }

  lastclick = thistime;
  lastwid   = specifiedwid;

}



void folderhelpCallback2(Widget widget, XtPointer userData, XtPointer callData)
{
  char message[1000];
  int type=(int)userData;

  

  if(type==CHOOSEPROJ_BROWSE)
  {
      sprintf(message,"This window is used to choose a GAIT project folder.\n\
This is the folder that will be used to:\n\n\
  Store GAIT projects that are created (via Create GAIT Project...)\n\
  Look for GAIT projects to open (via Open GAIT Project...)\n\n\
The GAIT_PROJECTS environment variable can also be used to specify this\n\
folder.\n\n\
To choose a project folder, either:\n\n\
  Select (click) the desired folder name and click \"Choose Selected Folder\"\n\
       or\n\
  Double-click the desired folder\n\
   ");

  not_while_running(widget,message,1475,"GAIT Project Folder Help",5);
  }
  else if(type==CHOOSESHAPE_BROWSE)
  {
      sprintf(message,"This window is used to choose an input data folder.\n\
This is the folder that will be searched for data to import\n\n\
To choose an input data folder folder, either:\n\n\
  Select (click) the desired folder name and click \"Choose Selected Folder\"\n\
       or\n\
  Double-click the desired folder\n\
   ");

  not_while_running(widget,message,1476,"GAIT Input Data Folder Help",5);
  }
   else if((type==CHOOSE_ES1_BROWSE)||(type==CHOOSE_ES2_BROWSE))
  {
      sprintf(message,"This window is used to choose a component file of a GAIT\n\
condition report (the file ending in \".es\").\n\n\
To locate \".es\" files, browse the folder tree on the left and click\n\
the desired folder's name to select it.  Valid \".es\" files in the\n\
selected folder will be listed on the right side.\n\n\
A \".es\" file may be selected by double-clicking on it, or by\n\
selecting it, and then clicking \"Choose Selected \".es\" File\".");

  not_while_running(widget,message,1478,"\".es\" File Selection Help",5);
  }
   else if(type==CHOOSE_TXT_BROWSE)
  {
      
      sprintf(message,"This window is used to choose a file or path to use\n\
to save condition report comparisons.\n\n\
You can:\n\n\
   Select a specific file and click \"Choose Selected File/Folder\"\n\
        (the *file path* will then be entered in the previous form)\n\
                    -----------or-----------\n\
   Select a folder and click \"Choose Selected File/Folder\"\n\
        (the *folder path* will be entered in the previous form)\n\n\
If the file does not already exist, it is useful to select a folder\n\
using this window, and type the filename into the form after the\n\
folder name is filled in.");

  not_while_running(widget,message,1479,"Text File Selection Help",5);
  }

   
   
   
   else if(type==CHOOSE_XML1_BROWSE)
  {
      sprintf(message,"This window is used to choose an MGCP Cell Metatada file\n\
(an XML file ending in \".xml\").\n\n\
To locate \".xml\" files, browse the folder tree on the left and click\n\
the desired folder's name to select it.  Valid \".xml\" files in the\n\
selected folder will be listed on the right side.\n\n\
A \".xml\" file may be selected by double-clicking on it, or by\n\
selecting it, and then clicking \"Choose Selected \".xml\" File\".");

  not_while_running(widget,message,1485,"\".xml\" File Selection Help",5);
  }
   else if(type==CHOOSE_XML2_BROWSE)
  {
      sprintf(message,"This window is used to choose an MGCP XML refine file\n\
(a file ending in \".txt\").\n\n\
To locate \".txt\" files, browse the folder tree on the left and click\n\
the desired folder's name to select it.  Valid \".txt\" files in the\n\
selected folder will be listed on the right side.\n\n\
A \".txt\" file may be selected by double-clicking on it, or by\n\
selecting it, and then clicking \"Choose Selected \".txt\" File\".");

  not_while_running(widget,message,1486,"\".txt\" File Selection Help",5);
  }
   else if(type==CHOOSE_XML3_BROWSE)
  {
      sprintf(message,"This window is used to choose a file or path to use\n\
to save MGCP XML Validation results.\n\n\
You can:\n\n\
   Select a specific file and click \"Choose Selected File/Folder\"\n\
        (the *file path* will then be entered in the previous form)\n\
                    -----------or-----------\n\
   Select a folder and click \"Choose Selected File/Folder\"\n\
        (the *folder path* will be entered in the previous form)\n\n\
If the file does not already exist, it is useful to select a folder\n\
using this window, and type the filename into the form after the\n\
folder name is filled in.");

  not_while_running(widget,message,1487,"File/Folder Selection Help",5);
  }

  else if(type==ATTRFOLDER_BROWSE)
  {
    sprintf(message,"\
This window is used to choose a folder containing user-supplied\n\
attribution files to use when using one of the \"User-specified\"\n\
options for \"Additional Attribution Inspections for NFDD or DFDD\".\n\n\
To choose a folder, either:\n\n\
  Select (click) the desired folder name and click \"Choose Selected Folder\"\n\
       or\n\
  Double-click the desired folder\n\
  ");

    not_while_running(widget,message,1584,"Folder Selection Help",5);
  }

  else if(type==CHOOSE_DP_BROWSE)
  {

    sprintf(message,"\
This window is used to choose a folder containing a single MGCP Cell\n\
for Data Packaging checking.\n\n\
To choose a folder, either:\n\n\
  Select (click) the desired folder name and click \"Choose Selected Folder\"\n\
       or\n\
  Double-click the desired folder\n\
  ");

    not_while_running(widget,message,1585,"Folder Selection Help",5);
  }
  else if(type==CHOOSEBROWSE_BROWSE)
  {

    sprintf(message,"\
This window is used to choose a folder to be used by GAIT as a\n\
default path to open in subsequently created file browser windows.\n\n\
To choose a folder, either:\n\n\
  Select (click) the desired folder name and click \"Choose Selected Folder\"\n\
       or\n\
  Double-click the desired folder\n\
  ");

    not_while_running(widget,message,1591,"Folder Selection Help",5);
  }
  else
  {
	  printf("bad type %d to FHCB2\n",type); 
  }


}



void deselectlist(Widget w,XtPointer data,XtPointer callData)
{ 
  XmListDeselectAllItems(w);
}


void BrowseInterceptCallback(Widget widget, XtPointer userData, XtPointer callData)
{
  Widget browser_wid = (Widget)userData;

  

  HandleSuccessDos(browser_wid);
}



char GetSpecialLocLetter()
{
  return SpecialLoc[0];
}

int IsSpecialLoc(char driveletter)
{
  if(driveletter==GetSpecialLocLetter())
  {
    return 1;
  }
  return 0;
}



int IsSpecialNetLoc(char *pathname)
{
  char temppathname[1000];

  sprintf(temppathname,"%s%c",pathname,MYCHARSLASH);

  if(strstr(SpecialLoc,temppathname))
  {
    return 1;
  }
  return 0;
}





void OpenSpecialNetLoc(Widget left,MyData *mydata)
{
  OpeningSpecialLoc = 1;
  NEWToggleButtonHandleCB(left,mydata,NULL);
  OpeningSpecialLoc = 0;
}



void OpenSpecialLoc(Widget left,MyData *mydata)
{

  if(strlen(SpecialLoc)>1)
  {
    if((SpecialLoc[0]>=65)&&(SpecialLoc[0]<=90))
	{

	  

      OpeningSpecialLoc = 1;
      NEWToggleButtonHandleCB(left,mydata,NULL);
      OpeningSpecialLoc = 0;

	}
	else
	{
      printf("Not using browse location: %s\n",SpecialLoc);
	  printf(" because the location does not start with a valid drive letter\n");
	}
  }

}


Widget DosBrowseCallback(Widget w,XtPointer data,XtPointer callData)
{
  Widget dialog,handle,outline,rc,rc3,form,sw2,junkwid,left,right,
    Done,button,subhandle,suboutline,suboutline1,left1,right1,parent_wid,
	tempwid,subsubhandle,subsuboutline,saveleft=NULL,savenetleft=NULL;
  Dimension oldwidth;
  int i,n,scrollindex,scrollindex2,toponoff,type = (int)data,
	  showfiles,topnetonoff,leftpos; 
  char title[1000],thisdrive[1000];
  String thistrans,thistrans2;
  Arg resources[15];
  MyData *mydata3,*savemydata,*savenetmydata,*savemyTopnetdata;
  Atom ABNORMAL_DELETE;


  if(type==CHOOSEPROJ_BROWSE)
    {
	  FreeWidList(CHOOSEPROJ_BROWSE,0);  
      sprintf(title,"Choose Project Folder");
      scrollindex  = CHOOSEPROJ_SCROLL;
      thistrans    = list_translations36;
      parent_wid   = XtParent(XtParent(XtParent(w)));
      rec_depth    = 0;
      showfiles    = 0;
      toponoff     = PFOnOff1;
      NPPFOnOff1   = 0;  
      topnetonoff  = NPPFOnOff1;
      
    }
  else if(type==CHOOSESHAPE_BROWSE)
    {
      FreeWidList(CHOOSESHAPE_BROWSE,0);  
      sprintf(title,"Input Data Folder Selection");
      scrollindex  = CHOOSESHAPE_SCROLL;   
      scrollindex2 = CHOOSESHAPE_FILE;     
      thistrans    = list_translations37;  
      thistrans2   = list_translations38;  
      parent_wid   = XtParent(XtParent(XtParent(w)));
      rec_depth    = 0;
      showfiles    = 1;
      toponoff     = SFOnOff1;
      NPSFOnOff1   = 0;  
      topnetonoff  = NPSFOnOff1;
      
    }
  else if(type==CHOOSE_ES1_BROWSE)
    {
      FreeWidList(CHOOSE_ES1_BROWSE,0);  
      sprintf(title, "Choose First ES filename");
      scrollindex  = CHOOSE_ES1_SCROLL;    
      scrollindex2 = CHOOSE_ES1_FILE;      
      thistrans    = list_translations39;  
      thistrans2   = list_translations40;  
      parent_wid   = XtParent(XtParent(XtParent(w)));
      rec_depth    = 0;
      showfiles    = 1;
      toponoff     = ES1OnOff1;
      NPES1OnOff1  = 0;  
      topnetonoff  = NPES1OnOff1;
      
    }
  else if(type==CHOOSE_ES2_BROWSE)
    {
      FreeWidList(CHOOSE_ES2_BROWSE,0);  
      sprintf(title, "Choose Second ES filename");
      scrollindex  = CHOOSE_ES2_SCROLL;    
      scrollindex2 = CHOOSE_ES2_FILE;      
      thistrans    = list_translations41;  
      thistrans2   = list_translations42;  
      parent_wid   = XtParent(XtParent(XtParent(w)));
      rec_depth    = 0;
      showfiles    = 1;
      toponoff     = ES2OnOff1;
      NPES2OnOff1  = 0;  
      topnetonoff  = NPES2OnOff1;
      
    }
  else if(type==CHOOSE_TXT_BROWSE)
    {
      FreeWidList(CHOOSE_TXT_BROWSE,0);  
      sprintf(title, "Choose folder path or file to overwrite");
      scrollindex  = CHOOSE_TXT_SCROLL;    
      scrollindex2 = CHOOSE_TXT_FILE;      
      thistrans    = list_translations43;  
      thistrans2   = list_translations44;  
      parent_wid   = XtParent(XtParent(XtParent(w)));
      rec_depth    = 0;
      showfiles    = 1;
      toponoff     = TXTOnOff1;
      NPTXTOnOff1  = 0;  
      topnetonoff  = NPTXTOnOff1;
      
    }
  else if(type==CHOOSEDATA_BROWSE)
    {
      FreeWidList(CHOOSEDATA_BROWSE,0);  
      sprintf(title, "Choose data folder");
      scrollindex  = CHOOSEDATA_SCROLL;    
      scrollindex2 = CHOOSEDATA_FILE;      
      thistrans    = list_translations45;  
      thistrans2   = list_translations46;  
      parent_wid   = XtParent(XtParent(XtParent(w)));
      rec_depth    = 0;
      showfiles    = 1;
      toponoff     = DATAOnOff1;
      NPTXTOnOff1  = 0;  
      topnetonoff  = NPDATAOnOff1;
      
    }
  else if(type==CHOOSE_XML1_BROWSE) 
    {
      FreeWidList(CHOOSE_XML1_BROWSE,0);  
      sprintf(title, "Choose XML filename");
      scrollindex  = CHOOSE_XML1_SCROLL;    
      scrollindex2 = CHOOSE_XML1_FILE;      
      thistrans    = list_translations47;  
      thistrans2   = list_translations48;  
      parent_wid   = XtParent(XtParent(XtParent(w)));
      rec_depth    = 0;
      showfiles    = 1;
      toponoff     = XML1OnOff1;
      NPXML1OnOff1  = 0;  
      topnetonoff  = NPXML1OnOff1;
      
    }
  else if(type==CHOOSE_XML2_BROWSE)
    {
      FreeWidList(CHOOSE_XML2_BROWSE,0);  
      sprintf(title, "Choose Refine file filename");
      scrollindex  = CHOOSE_XML2_SCROLL;    
      scrollindex2 = CHOOSE_XML2_FILE;      
      thistrans    = list_translations49;  
      thistrans2   = list_translations50;  
      parent_wid   = XtParent(XtParent(XtParent(w)));
      rec_depth    = 0;
      showfiles    = 1;
      toponoff     = XML2OnOff1;
      NPXML2OnOff1  = 0;  
      topnetonoff  = NPXML2OnOff1;
      
    }
  else if(type==CHOOSE_XML3_BROWSE)
    {
      FreeWidList(CHOOSE_XML3_BROWSE,0);  
      sprintf(title, "Choose TXT file path or name");
      scrollindex  = CHOOSE_XML3_SCROLL;    
      scrollindex2 = CHOOSE_XML3_FILE;      
      thistrans    = list_translations51;  
      thistrans2   = list_translations52;  
      parent_wid   = XtParent(XtParent(XtParent(w)));
      rec_depth    = 0;
      showfiles    = 1;
      toponoff     = XML3OnOff1;
      NPXML3OnOff1  = 0;  
      topnetonoff  = NPXML3OnOff1;
      
    }
  else if(type==ATTRFOLDER_BROWSE)
    {
      FreeWidList(ATTRFOLDER_BROWSE,0);  
      sprintf(title,"Folder Containing Attribution Files Selection");
      scrollindex  = CHOOSEATTR_SCROLL;   
      scrollindex2 = CHOOSEATTR_FILE;     
      thistrans    = list_translations56;  
      thistrans2   = list_translations57;  
      parent_wid   = XtParent(XtParent(XtParent(w)));
      rec_depth    = 0;
      showfiles    = 1;
      toponoff     = CAOnOff1;
      NPCAOnOff1   = 0;  
      topnetonoff  = NPCAOnOff1;
      
    }
  else if(type==CHOOSE_DP_BROWSE)
    {
      FreeWidList(CHOOSE_DP_BROWSE,0);  
      sprintf(title,"Folder Containing MGCP Packaged Cell");
      scrollindex  = CHOOSE_DP_SCROLL;   
      scrollindex2 = CHOOSE_DP_FILE;     
      thistrans    = list_translations58;  
      thistrans2   = list_translations59;  
      parent_wid   = XtParent(XtParent(XtParent(w)));
      rec_depth    = 0;
      showfiles    = 1;
      toponoff     = DPOnOff1;
      NPDPOnOff1   = 0;  
      topnetonoff  = NPDPOnOff1;
      
    }
  else if(type==CHOOSEBROWSE_BROWSE)
    {
      FreeWidList(CHOOSEBROWSE_BROWSE,0);  
      sprintf(title,"Folder For Default Browsing");
      scrollindex  = CHOOSEBROWSE_SCROLL;   
      scrollindex2 = CHOOSEBROWSE_FILE;     
      thistrans    = list_translations60;  
      thistrans2   = list_translations61;  
      parent_wid   = XtParent(XtParent(XtParent(w)));
      rec_depth    = 0;
      showfiles    = 1;
      toponoff     = BROnOff1;
      NPBROnOff1   = 0;  
      topnetonoff  = NPBROnOff1;
      
    }

  else
    {
      XBell(mydisplay,50);
      printf("DosCB called with  bad flag %d\n",type);
      return NULL;
    }


  


  set_cursor(mydisplay,mywindow,WATCH);
  set_cursor(
	     XtDisplay(XtParent(XtParent(XtParent(w)))),
	     XtWindow (XtParent(XtParent(XtParent(w)))),WATCH);
  
  
  GetDriveLetters();

  
  n=0;
  XtSetArg(resources[n],  XmNsaveUnder, True);              n++;
  XtSetArg(resources[n],  XmNdeleteResponse, XmDO_NOTHING); n++;
  XtSetArg(resources[n],  XmNminWidth,       250);          n++;
  XtSetArg(resources[n],  XmNminHeight,      300);          n++;
  XtSetArg(resources[n],  XmNheight,         480);          n++;  
  XtSetArg(resources[n],  XmNtranslations,   XtParseTranslationTable (translations_global));  n++;


  


  dialog = XtCreatePopupShell(title,topLevelShellWidgetClass,drawing_a,resources,n);


  
  rc = XtVaCreateManagedWidget
    (
     "XformWidget", xmPanedWindowWidgetClass, dialog,
     XmNrubberPositioning, False,
     XmNresizable,         True,
     XmNseparatorOn,       False,
     XmNsashHeight,        1,
     XmNtranslations,      XtParseTranslationTable (translations_global),
     
     NULL
     );
  
  
  
  
  if(showfiles==1)
    {
      

      


	  
      tempwid = XtVaCreateManagedWidget
	(
	 "XformWidget", xmPanedWindowWidgetClass, rc,
	 
	 XmNresizable,         True,
   	 XmNseparatorOn,       False,  
	 XmNsashHeight,        5,      
	                               
	 XmNtranslations,      XtParseTranslationTable (translations_global),
  	 XmNorientation,       XmHORIZONTAL,
	 XmNsashShadowThickness, 0,
	 XmNsashWidth,           3, 
	 XmNspacing,             3, 
	 XmNsashIndent,        -30, 
	 

	 NULL
	 );
      

      
      rc3 = XtVaCreateManagedWidget
	(
	 "XformWidget", xmPanedWindowWidgetClass, tempwid,
	 XmNpaneMinimum,       100,
	 XmNpaneMaximum,       2000, 
	 XmNrubberPositioning, False,
	 XmNresizable,         True,
   	 XmNseparatorOn,       False, 
	 XmNsashHeight,        1,
	 XmNtranslations,      XtParseTranslationTable (translations_global),
	 NULL
	 );

      
      form = XtVaCreateWidget ("form.sw.editor", xmFormWidgetClass, rc3,
			       XmNfractionBase,  100,  
			       XmNtranslations,  XtParseTranslationTable (translations_global),
			       NULL);
      
      button = XtVaCreateManagedWidget ("Folders:",
					xmLabelWidgetClass,  form,
					XmNtraversalOn,      True,
					XmNrightAttachment,  XmATTACH_POSITION,
					XmNrightPosition,    100,
					XmNleftAttachment,   XmATTACH_POSITION,
					XmNleftPosition,     1,
					LABELWTRANSLATE,
					NULL);
      XtManageChild(form);



      form = XtVaCreateWidget ("form.sw.editor", xmFormWidgetClass, rc3,
			       XmNfractionBase,  100,  
			       XmNtranslations,  XtParseTranslationTable (translations_global),
			       NULL);
      
      sw2 = XtVaCreateManagedWidget ("scrolled_win",
				     xmScrolledWindowWidgetClass, form,
				     XmNwidth,                  500,
				     XmNheight,                 300,
				     XmNscrollingPolicy,        XmAUTOMATIC,
				     XmNscrollBarDisplayPolicy, XmSTATIC,
				     XmNtopAttachment,          XmATTACH_FORM,
				     XmNbottomAttachment,       XmATTACH_FORM,
				     XmNleftAttachment,         XmATTACH_FORM,
				     XmNrightAttachment,        XmATTACH_FORM,
				     XmNtranslations,           XtParseTranslationTable (thistrans),
				     
				     NULL);
      XtManageChild(form);
      XtManageChild(rc3);
      
      
      
      
      rc3 = XtVaCreateManagedWidget
	(
	 "XformWidget", xmPanedWindowWidgetClass, tempwid,
 	 XmNpaneMinimum,       200, 
	 XmNpaneMaximum,       200, 
	 XmNrubberPositioning, False,
	 XmNresizable,         True,
   	 XmNseparatorOn,       False, 
	 XmNsashHeight,        1,  
	 XmNtranslations,      XtParseTranslationTable (translations_global),
	 NULL
	 );
      
      form = XtVaCreateWidget ("form.sw.editor", xmFormWidgetClass, rc3,
			       XmNfractionBase,  100,  
			       XmNtranslations,  XtParseTranslationTable (translations_global),
			       NULL);
      
	  if((type==CHOOSE_ES1_BROWSE)||(type==CHOOSE_ES2_BROWSE))
	  {
        button = XtVaCreateManagedWidget ("\".es\" Files:",
					xmLabelWidgetClass,  form,
					XmNtraversalOn,      True,
					XmNrightAttachment,  XmATTACH_POSITION,
					XmNrightPosition,    100,
					XmNleftAttachment,   XmATTACH_POSITION,
					XmNleftPosition,     1,
					LABELWTRANSLATE,
					NULL);
	  }
	  else if(type==CHOOSE_XML1_BROWSE)
	  {
        button = XtVaCreateManagedWidget ("\".xml\" Files:",
					xmLabelWidgetClass,  form,
					XmNtraversalOn,      True,
					XmNrightAttachment,  XmATTACH_POSITION,
					XmNrightPosition,    100,
					XmNleftAttachment,   XmATTACH_POSITION,
					XmNleftPosition,     1,
					LABELWTRANSLATE,
					NULL);
	  }
	  else if(type==CHOOSE_XML2_BROWSE)
	  {
        button = XtVaCreateManagedWidget ("\".txt\" Files:",
					xmLabelWidgetClass,  form,
					XmNtraversalOn,      True,
					XmNrightAttachment,  XmATTACH_POSITION,
					XmNrightPosition,    100,
					XmNleftAttachment,   XmATTACH_POSITION,
					XmNleftPosition,     1,
					LABELWTRANSLATE,
					NULL);
	  }
	  else if(type==ATTRFOLDER_BROWSE)
	  {
        button = XtVaCreateManagedWidget ("\".csv\" Files:",
					xmLabelWidgetClass,  form,
					XmNtraversalOn,      True,
					XmNrightAttachment,  XmATTACH_POSITION,
					XmNrightPosition,    100,
					XmNleftAttachment,   XmATTACH_POSITION,
					XmNleftPosition,     1,
					LABELWTRANSLATE,
					NULL);
	  }
	  else
	  {
        button = XtVaCreateManagedWidget ("Files:",
					xmLabelWidgetClass,  form,
					XmNtraversalOn,      True,
					XmNrightAttachment,  XmATTACH_POSITION,
					XmNrightPosition,    100,
					XmNleftAttachment,   XmATTACH_POSITION,
					XmNleftPosition,     1,
					LABELWTRANSLATE,
					NULL);
	  }
      
      XtManageChild(form);
      
      
      
      form = XtVaCreateWidget ("form.sw.editor", xmFormWidgetClass, rc3,
			       XmNfractionBase,  100,  
			       XmNtranslations,  XtParseTranslationTable (translations_global),
			       NULL);
      
      n=0;
      XtSetArg(resources[n],  XmNlistSizePolicy,   XmCONSTANT);                           n++; 
      XtSetArg(resources[n],  XmNwidth,            200);                                  n++;
      XtSetArg(resources[n],  XmNtopAttachment,    XmATTACH_FORM);                        n++;
      XtSetArg(resources[n],  XmNbottomAttachment, XmATTACH_FORM);                        n++;
      XtSetArg(resources[n],  XmNleftAttachment,   XmATTACH_FORM);                        n++;
      XtSetArg(resources[n],  XmNrightAttachment,  XmATTACH_FORM);                        n++;
      XtSetArg(resources[n],  XmNtranslations,     XtParseTranslationTable (thistrans2)); n++;
      XtSetArg(resources[n],  XmNtraversalOn,      False);                                n++;
      XtSetArg(resources[n],  XmNeditable,         False);                                n++;
      XtSetArg(resources[n],  XmNselectionPolicy,  XmSINGLE_SELECT);                      n++;

	  


	  if(type==CHOOSESHAPE_BROWSE)
	  {
        CHOOSESHAPE_BROWSE_fw = XmCreateScrolledList (form, "list", resources,n);
	    XtAddCallback (CHOOSESHAPE_BROWSE_fw, XmNsingleSelectionCallback,deselectlist, (XtPointer)NULL);
        XtManageChild (CHOOSESHAPE_BROWSE_fw);
        XtVaGetValues (CHOOSESHAPE_BROWSE_fw,XmNverticalScrollBar,&vert_scroll[scrollindex2],NULL);
	  }
	  else if(type==CHOOSE_ES1_BROWSE)
	  {
        CHOOSE_ES1_BROWSE_fw = XmCreateScrolledList (form, "list", resources,n);
	    

        
        XtAddCallback (CHOOSE_ES1_BROWSE_fw,  XmNdefaultActionCallback, 
		     choose_dos_browse_cb, 
		     (XtPointer)type);


        XtManageChild (CHOOSE_ES1_BROWSE_fw);
        XtVaGetValues (CHOOSE_ES1_BROWSE_fw,XmNverticalScrollBar,&vert_scroll[scrollindex2],NULL);
	  }
	  else if(type==CHOOSE_ES2_BROWSE)
	  {
        CHOOSE_ES2_BROWSE_fw = XmCreateScrolledList (form, "list", resources,n);
	    

        
        XtAddCallback (CHOOSE_ES2_BROWSE_fw,  XmNdefaultActionCallback, 
		     choose_dos_browse_cb, 
		     (XtPointer)type);

		XtManageChild (CHOOSE_ES2_BROWSE_fw);
        XtVaGetValues (CHOOSE_ES2_BROWSE_fw,XmNverticalScrollBar,&vert_scroll[scrollindex2],NULL);
	  }
	  else if(type==CHOOSE_TXT_BROWSE)
	  {
        CHOOSE_TXT_BROWSE_fw = XmCreateScrolledList (form, "list", resources,n);
	    

        
        XtAddCallback (CHOOSE_TXT_BROWSE_fw,  XmNdefaultActionCallback, 
		     choose_dos_browse_cb, 
		     (XtPointer)type);

        XtManageChild (CHOOSE_TXT_BROWSE_fw);
        XtVaGetValues (CHOOSE_TXT_BROWSE_fw,XmNverticalScrollBar,&vert_scroll[scrollindex2],NULL);
	  }
	  else if(type==CHOOSE_XML1_BROWSE)
	  {
        CHOOSE_XML1_BROWSE_fw = XmCreateScrolledList (form, "list", resources,n);
	    

        
        XtAddCallback (CHOOSE_XML1_BROWSE_fw,  XmNdefaultActionCallback, 
		     choose_dos_browse_cb, 
		     (XtPointer)type);


        XtManageChild (CHOOSE_XML1_BROWSE_fw);
        XtVaGetValues (CHOOSE_XML1_BROWSE_fw,XmNverticalScrollBar,&vert_scroll[scrollindex2],NULL);
	  }
	  else if(type==CHOOSE_XML2_BROWSE)
	  {
        CHOOSE_XML2_BROWSE_fw = XmCreateScrolledList (form, "list", resources,n);
	    

        
        XtAddCallback (CHOOSE_XML2_BROWSE_fw,  XmNdefaultActionCallback, 
		     choose_dos_browse_cb, 
		     (XtPointer)type);


        XtManageChild (CHOOSE_XML2_BROWSE_fw);
        XtVaGetValues (CHOOSE_XML2_BROWSE_fw,XmNverticalScrollBar,&vert_scroll[scrollindex2],NULL);
	  }	  
	  else if(type==CHOOSE_XML3_BROWSE)
	  {
        CHOOSE_XML3_BROWSE_fw = XmCreateScrolledList (form, "list", resources,n);
	    

        
        XtAddCallback (CHOOSE_XML3_BROWSE_fw,  XmNdefaultActionCallback, 
		     choose_dos_browse_cb, 
		     (XtPointer)type);


        XtManageChild (CHOOSE_XML3_BROWSE_fw);
        XtVaGetValues (CHOOSE_XML3_BROWSE_fw,XmNverticalScrollBar,&vert_scroll[scrollindex2],NULL);
	  }
	  else if(type==ATTRFOLDER_BROWSE)
	  {
        ATTRFOLDER_BROWSE_fw = XmCreateScrolledList (form, "list", resources,n);
	    XtAddCallback (ATTRFOLDER_BROWSE_fw, XmNsingleSelectionCallback,deselectlist, (XtPointer)NULL);
        XtManageChild (ATTRFOLDER_BROWSE_fw);
        XtVaGetValues (ATTRFOLDER_BROWSE_fw,XmNverticalScrollBar,&vert_scroll[scrollindex2],NULL);
	  }
	  else if(type==CHOOSE_DP_BROWSE)
	  {
        DP_BROWSE_fw = XmCreateScrolledList (form, "list", resources,n);
	    XtAddCallback (DP_BROWSE_fw, XmNsingleSelectionCallback,deselectlist, (XtPointer)NULL);
        XtManageChild (DP_BROWSE_fw);
        XtVaGetValues (DP_BROWSE_fw,XmNverticalScrollBar,&vert_scroll[scrollindex2],NULL);
	  }
	  else if(type==CHOOSEBROWSE_BROWSE)
	  {
        BROWSE_BROWSE_fw = XmCreateScrolledList (form, "list", resources,n);
	    XtAddCallback (BROWSE_BROWSE_fw, XmNsingleSelectionCallback,deselectlist, (XtPointer)NULL);
        XtManageChild (BROWSE_BROWSE_fw);
        XtVaGetValues (BROWSE_BROWSE_fw,XmNverticalScrollBar,&vert_scroll[scrollindex2],NULL);
	  }
	  else
	  {
		  XBell(mydisplay,50);
		  printf("bad type %d inside DBCB2\n",type);
	  }

      XtManageChild(form);
      XtManageChild(rc3);
      XtManageChild(tempwid);
    }
  else
    {
      form = XtVaCreateWidget ("form.sw.editor", xmFormWidgetClass, rc,
			       XmNfractionBase,  100,  
			       XmNtranslations,  XtParseTranslationTable (translations_global),
			       NULL);
      
      sw2 = XtVaCreateManagedWidget ("scrolled_win",
				     xmScrolledWindowWidgetClass, form,
				     XmNwidth,                  700,
				     XmNheight,                 300,
				     XmNscrollingPolicy,        XmAUTOMATIC,
				     XmNscrollBarDisplayPolicy, XmSTATIC,
				     XmNtopAttachment,          XmATTACH_FORM,
				     XmNbottomAttachment,       XmATTACH_FORM,
				     XmNleftAttachment,         XmATTACH_FORM,
				     XmNrightAttachment,        XmATTACH_FORM,
				     XmNtranslations,           XtParseTranslationTable (thistrans),
				     
				     NULL);
      XtManageChild(form);
    }
      
  
  XtVaGetValues(sw2,XmNverticalScrollBar,&vert_scroll[scrollindex],NULL);
  XtVaGetValues(sw2,XmNhorizontalScrollBar,&junkwid,NULL);
  
  XtVaSetValues(vert_scroll[scrollindex], 
		XmNtraversalOn,  False, 
		
		NULL);
  
  XtVaSetValues(junkwid,                       XmNtraversalOn, False, NULL);
  
  
  
  
  handle = XtVaCreateManagedWidget("roothandle", xmHandleWidgetClass,
				   sw2,
				   XmNtranslations, XtParseTranslationTable (thistrans),
				   NULL);
  
  left = XtVaCreateManagedWidget("left", xmPushButtonWidgetClass,
				 handle,
				 XmNlabelType,    XmPIXMAP,
				 XmNlabelPixmap,  minus_pix,					 
				 XmNtraversalOn,  False,
				 XmNtranslations, XtParseTranslationTable (thistrans),
				 NULL);
  
  
  
  

    right = XtVaCreateManagedWidget("All Locations (close and re-open to refresh)",
				  xmLabelWidgetClass,
				  handle,
				  XmNtraversalOn,   False,
				  XmNtranslations,  XtParseTranslationTable (thistrans),
				  NULL);


  outline = XtVaCreateManagedWidget("outlineChooseProjOnly", xmOutlineWidgetClass,
				    handle,
				    XmNindentation,  20,
				    XmNoutline,      TRUE,
				    XmNtranslations, XtParseTranslationTable (thistrans),
				    
				    NULL);
  
  


  
  mydata3  = (MyData *) (malloc(sizeof(MyData)));
  if(mydata3==NULL){printf("myb: out of allocation memory!\n"); ExitWrapper(-1);}
  mydata3->outlinewid = (XmOutlineWidget)outline;
  mydata3->level = 1;
  mydata3->type = type;
  
  XtAddCallback(left, 
		XmNactivateCallback, (XtCallbackProc)NEWToggleButtonHandleCB, 
		(XtPointer) mydata3);
  
  XtVaSetValues(handle, 
		XmNsubWidget, outline,
		NULL);
  
  if(toponoff==0)
    {
      
      XtUnmanageChild(outline);
      XtVaSetValues(left, XmNlabelPixmap, plus_pix, NULL);
    }
  

   


  if(1) 
  {
	  sprintf(thisdrive,"My Network Places"); 
	  subhandle = XtVaCreateManagedWidget("roothandle", xmHandleWidgetClass,
					  outline,
					  XmNtranslations, XtParseTranslationTable (thistrans),
					  NULL);
      
      left1 = XtVaCreateManagedWidget("left", xmPushButtonWidgetClass,
				     subhandle,
				     XmNlabelType,    XmPIXMAP,
				     XmNlabelPixmap,  minus_pix,					 
				     XmNtraversalOn,  False,
				     XmNtranslations, XtParseTranslationTable (thistrans),
				     NULL);
      
      right1 = XtVaCreateManagedWidget(thisdrive, xmLabelWidgetClass,
				      subhandle,
				      XmNtraversalOn,   False,
				      XmNtranslations,  XtParseTranslationTable (thistrans),
				      XmNindicatorOn,   False,
				      NULL);
      
      
      
      suboutline1 = XtVaCreateManagedWidget("outlineChooseProjOnly", xmOutlineWidgetClass,
					   subhandle,
					   XmNindentation,  20,
					   XmNoutline,      TRUE,
					   XmNtranslations, XtParseTranslationTable (thistrans),
					   
					   NULL);
      
      
      mydata3  = (MyData *) (malloc(sizeof(MyData)));
      if(mydata3==NULL){printf("myb: out of allocation memory!\n"); ExitWrapper(-1);}
      mydata3->outlinewid = (XmOutlineWidget)suboutline1;
      mydata3->level = -99999; 
      mydata3->type = type;
      
	  mydata3->pathname = (char *)malloc(40);
      sprintf(mydata3->pathname,"My Network Places");
      
	  savemyTopnetdata = mydata3;

      XtAddCallback(left1, 
		    XmNactivateCallback, (XtCallbackProc)NEWToggleButtonHandleCB, 
		    (XtPointer) mydata3);
      
      XtVaSetValues(subhandle, 
		    XmNsubWidget, suboutline1,
		    NULL);
      
      


      if(topnetonoff==0)
	  {
       
       XtUnmanageChild(suboutline1);
       XtVaSetValues(left1, XmNlabelPixmap, plus_pix, NULL);
	  }


	  

	  



	  for(i=0;i<NumNetDrives;i++)
	  {
		 sprintf(thisdrive,"<%s>: %s",NetDriveNames[i],NetDrivePaths[i]);

         subsubhandle = XtVaCreateManagedWidget("roothandle", xmHandleWidgetClass,
					  suboutline1,
					  XmNtranslations, XtParseTranslationTable (thistrans),
					  NULL);
      
      left = XtVaCreateManagedWidget("left", xmPushButtonWidgetClass,
				     subsubhandle,
				     XmNlabelType,    XmPIXMAP,
				     XmNlabelPixmap,  minus_pix,					 
				     XmNtraversalOn,  False,
				     XmNtranslations, XtParseTranslationTable (thistrans),
				     NULL);

      
      right = XtVaCreateManagedWidget(thisdrive, xmToggleButtonWidgetClass,
				      subsubhandle,
				      XmNtraversalOn,   False,
				      XmNtranslations,  XtParseTranslationTable (thistrans),
				      XmNindicatorOn,   False,
				      NULL);
      
      AddWidToList(type,right,subsubhandle,-1*(i+1));
      
      subsuboutline = XtVaCreateManagedWidget("outlineChooseProjOnly", xmOutlineWidgetClass,
					   subsubhandle,
					   XmNindentation,  20,
					   XmNoutline,      TRUE,
					   XmNtranslations, XtParseTranslationTable (thistrans),
					   
					   NULL);

      
      mydata3  = (MyData *) (malloc(sizeof(MyData)));
      if(mydata3==NULL){printf("myb: out of allocation memory!\n"); ExitWrapper(-1);}
      mydata3->outlinewid = (XmOutlineWidget)subsuboutline;
      mydata3->level = -1*(i+1);
      mydata3->type = type;
      
      mydata3->pathname = (char *)malloc(500);
      sprintf(mydata3->pathname,"%s",ExtractNetPath(thisdrive));
      
      XtAddCallback(left, 
		    XmNactivateCallback, (XtCallbackProc)NEWToggleButtonHandleCB, 
		    (XtPointer) mydata3);
      
      XtVaSetValues(subsubhandle, 
		    XmNsubWidget, subsuboutline,
		    NULL);
      
      XtAddCallback (right, XmNvalueChangedCallback,toggle_dos,(XtPointer)type);
      
      

      XtUnmanageChild(subsuboutline);
      XtVaSetValues(left, XmNlabelPixmap, plus_pix, NULL);


	  if(IsSpecialNetLoc(mydata3->pathname))
	  {
        savenetleft = left;
		savenetmydata = mydata3;
	  }


	 }	  
    }

 


  for(i=0;i<DRIVE_MAX;i++)
    {
      
       if(DrivesAvailable[i]==-12345)
	   {
	     continue;
		}
      


      if(strlen(DriveNames[i])>0)
	{
	  sprintf(thisdrive,"%s (%s) (%c:)",ParseDriveType(DrivesAvailable[i]),
		  DriveNames[i],
		  i+65);
	}
      else
	{
	  sprintf(thisdrive,"%s (%c:)",ParseDriveType(DrivesAvailable[i]),
		  i+65);
	}
      
      subhandle = XtVaCreateManagedWidget("roothandle", xmHandleWidgetClass,
					  outline,
					  XmNtranslations, XtParseTranslationTable (thistrans),
					  NULL);
      
      left = XtVaCreateManagedWidget("left", xmPushButtonWidgetClass,
				     subhandle,
				     XmNlabelType,    XmPIXMAP,
				     XmNlabelPixmap,  minus_pix,					 
				     XmNtraversalOn,  False,
				     XmNtranslations, XtParseTranslationTable (thistrans),
				     NULL);

      
      right = XtVaCreateManagedWidget(thisdrive, xmToggleButtonWidgetClass,
				      subhandle,
				      XmNtraversalOn,   False,
				      XmNtranslations,  XtParseTranslationTable (thistrans),
				      XmNindicatorOn,   False,
				      NULL);
      
      AddWidToList(type,right,subhandle,2);
      
      suboutline = XtVaCreateManagedWidget("outlineChooseProjOnly", xmOutlineWidgetClass,
					   subhandle,
					   XmNindentation,  20,
					   XmNoutline,      TRUE,
					   XmNtranslations, XtParseTranslationTable (thistrans),
					   
					   NULL);
      
      
      mydata3  = (MyData *) (malloc(sizeof(MyData)));
      if(mydata3==NULL){printf("myb: out of allocation memory!\n"); ExitWrapper(-1);}
      mydata3->outlinewid = (XmOutlineWidget)suboutline;
      mydata3->level = 2;
      mydata3->type = type;
      
      mydata3->pathname = (char *)malloc(5);
      sprintf(mydata3->pathname,"%c:",i+65);
      
      XtAddCallback(left, 
		    XmNactivateCallback, (XtCallbackProc)NEWToggleButtonHandleCB, 
		    (XtPointer) mydata3);
      
      XtVaSetValues(subhandle, 
		    XmNsubWidget, suboutline,
		    NULL);
      
      XtAddCallback (right, XmNvalueChangedCallback,toggle_dos,(XtPointer)type);
      
      

      XtUnmanageChild(suboutline);
      XtVaSetValues(left, XmNlabelPixmap, plus_pix, NULL);
      
	  if(IsSpecialLoc((char)(i+65)))
	  {
        saveleft = left;
		savemydata = mydata3;
	  }

    }

      





  
  
  form = XtVaCreateWidget ("form2", xmFormWidgetClass, rc,
			   XmNpaneMinimum,   25,
			   XmNpaneMaximum,   25,
			   XmNfractionBase,  100,  
			   XmNtraversalOn,   False,
			   NULL);
  

  leftpos = 40;


  if(type==CHOOSEPROJ_BROWSE)
  {
     TopProjWidOutline = outline;

     button  = XtVaCreateManagedWidget("s_all_error",xmPushButtonWidgetClass,form,
				    XmNleftAttachment,  XmATTACH_POSITION,
				    XmNleftPosition,    0,
				    XmNrightAttachment, XmATTACH_POSITION,
				    XmNrightPosition,   leftpos,
				    XmNlabelString,     STRING("Choose Selected Folder"),
				    XmNtraversalOn,     False,
				    XmNtranslations, XtParseTranslationTable ( translations_global ) ,
				    NULL
				    ); 
	 }
  else if(type==CHOOSESHAPE_BROWSE)
  {
     TopShapeWidOutline = outline;

     button  = XtVaCreateManagedWidget("s_all_error",xmPushButtonWidgetClass,form,
				    XmNleftAttachment,  XmATTACH_POSITION,
				    XmNleftPosition,    0,
				    XmNrightAttachment, XmATTACH_POSITION,
				    XmNrightPosition,   leftpos,
				    XmNlabelString,     STRING("Choose Selected Folder"),
				    XmNtraversalOn,     False,
				    XmNtranslations, XtParseTranslationTable ( translations_global ) ,
				    NULL
				    ); 
	 }
  else if(type==CHOOSE_ES1_BROWSE)
  {
     TopES1WidOutline = outline;

     button  = XtVaCreateManagedWidget("s_all_error",xmPushButtonWidgetClass,form,
				    XmNleftAttachment,  XmATTACH_POSITION,
				    XmNleftPosition,    0,
				    XmNrightAttachment, XmATTACH_POSITION,
				    XmNrightPosition,   leftpos,
				    XmNlabelString,     STRING("Choose Selected \".es\" File"),
				    XmNtraversalOn,     False,
				    XmNtranslations, XtParseTranslationTable ( translations_global ) ,
				    NULL
				    ); 
  }
  else if(type==CHOOSE_ES2_BROWSE)
  {
     TopES2WidOutline = outline;

     button  = XtVaCreateManagedWidget("s_all_error",xmPushButtonWidgetClass,form,
				    XmNleftAttachment,  XmATTACH_POSITION,
				    XmNleftPosition,    0,
				    XmNrightAttachment, XmATTACH_POSITION,
				    XmNrightPosition,   leftpos,
				    XmNlabelString,     STRING("Choose Selected \".es\" File"),
				    XmNtraversalOn,     False,
				    XmNtranslations, XtParseTranslationTable ( translations_global ) ,
				    NULL
				    ); 
  }
  else if(type==CHOOSE_TXT_BROWSE)
  {
     TopTXTWidOutline = outline;

     button  = XtVaCreateManagedWidget("s_all_error",xmPushButtonWidgetClass,form,
				    XmNleftAttachment,  XmATTACH_POSITION,
				    XmNleftPosition,    0,
				    XmNrightAttachment, XmATTACH_POSITION,
				    XmNrightPosition,   leftpos,
				    XmNlabelString,     STRING("Choose Selected File/Folder"),
				    XmNtraversalOn,     False,
				    XmNtranslations, XtParseTranslationTable ( translations_global ) ,
				    NULL
				    ); 
  }
  else if(type==CHOOSE_XML1_BROWSE)
  {
     TopXML1WidOutline = outline;

     button  = XtVaCreateManagedWidget("s_all_error",xmPushButtonWidgetClass,form,
				    XmNleftAttachment,  XmATTACH_POSITION,
				    XmNleftPosition,    0,
				    XmNrightAttachment, XmATTACH_POSITION,
				    XmNrightPosition,   leftpos,
				    XmNlabelString,     STRING("Choose Selected \".xml\" File"),
				    XmNtraversalOn,     False,
				    XmNtranslations, XtParseTranslationTable ( translations_global ) ,
				    NULL
				    ); 
  }
  else if(type==CHOOSE_XML2_BROWSE)
  {
     TopXML2WidOutline = outline;

     button  = XtVaCreateManagedWidget("s_all_error",xmPushButtonWidgetClass,form,
				    XmNleftAttachment,  XmATTACH_POSITION,
				    XmNleftPosition,    0,
				    XmNrightAttachment, XmATTACH_POSITION,
				    XmNrightPosition,   leftpos,
				    XmNlabelString,     STRING("Choose Selected \".txt\" File"),
				    XmNtraversalOn,     False,
				    XmNtranslations, XtParseTranslationTable ( translations_global ) ,
				    NULL
				    ); 
  }
  else if(type==CHOOSE_XML3_BROWSE)
  {
     TopXML3WidOutline = outline;

     button  = XtVaCreateManagedWidget("s_all_error",xmPushButtonWidgetClass,form,
				    XmNleftAttachment,  XmATTACH_POSITION,
				    XmNleftPosition,    0,
				    XmNrightAttachment, XmATTACH_POSITION,
				    XmNrightPosition,   leftpos,
				    XmNlabelString,     STRING("Choose Selected File or Folder"),
				    XmNtraversalOn,     False,
				    XmNtranslations, XtParseTranslationTable ( translations_global ) ,
				    NULL
				    ); 
  }
  else if(type==ATTRFOLDER_BROWSE)
  {
     TopAttrWidOutline = outline;

     button  = XtVaCreateManagedWidget("s_all_error",xmPushButtonWidgetClass,form,
				    XmNleftAttachment,  XmATTACH_POSITION,
				    XmNleftPosition,    0,
				    XmNrightAttachment, XmATTACH_POSITION,
				    XmNrightPosition,   leftpos,
				    XmNlabelString,     STRING("Choose Selected Folder"),
				    XmNtraversalOn,     False,
				    XmNtranslations, XtParseTranslationTable ( translations_global ) ,
				    NULL
				    ); 
  }
  else if(type==CHOOSE_DP_BROWSE)
  {
     TopDPWidOutline = outline;

     button  = XtVaCreateManagedWidget("s_all_error",xmPushButtonWidgetClass,form,
				    XmNleftAttachment,  XmATTACH_POSITION,
				    XmNleftPosition,    0,
				    XmNrightAttachment, XmATTACH_POSITION,
				    XmNrightPosition,   leftpos,
				    XmNlabelString,     STRING("Choose Selected Folder"),
				    XmNtraversalOn,     False,
				    XmNtranslations, XtParseTranslationTable ( translations_global ) ,
				    NULL
				    ); 
  }
  else if(type==CHOOSEBROWSE_BROWSE)
  {
     TopBRWidOutline = outline;

     button  = XtVaCreateManagedWidget("s_all_error",xmPushButtonWidgetClass,form,
				    XmNleftAttachment,  XmATTACH_POSITION,
				    XmNleftPosition,    0,
				    XmNrightAttachment, XmATTACH_POSITION,
				    XmNrightPosition,   leftpos,
				    XmNlabelString,     STRING("Choose Selected Folder"),
				    XmNtraversalOn,     False,
				    XmNtranslations, XtParseTranslationTable ( translations_global ) ,
				    NULL
				    ); 
  }

  else
  {
    printf("bad value %d to NSUB\n",type);
  }


  
  XtAddCallback(button, XmNactivateCallback,choose_dos_browse_cb,(XtPointer)type);
  
  XtManageChild(button);
  
  button  = XtVaCreateManagedWidget("s_all_error",xmPushButtonWidgetClass,form,
				    XmNleftAttachment,  XmATTACH_POSITION,
				    XmNleftPosition,    leftpos,
				    XmNrightAttachment, XmATTACH_POSITION,
				    XmNrightPosition,   66,
				    XmNlabelString, STRING("Help"),
				    XmNtraversalOn,     False,
				    XmNtranslations, XtParseTranslationTable ( translations_global ) ,
				    NULL
				    ); 
  
  XtAddCallback(button, XmNactivateCallback,folderhelpCallback2,(XtPointer)type);
  
  XtManageChild(button);
  

  
  Done  = XtVaCreateManagedWidget("Help5",xmPushButtonWidgetClass,form,
				  XmNleftAttachment,  XmATTACH_POSITION,
				  XmNleftPosition,    66,
				  XmNrightAttachment, XmATTACH_POSITION,
				  XmNrightPosition,   100,
				  XmNlabelString, STRING("Cancel"),
				  XmNtraversalOn,     False,
				  XmNtranslations, XtParseTranslationTable ( translations_global ) ,
				  NULL
				  ); 
  
  XtAddCallback(Done, XmNactivateCallback,
		exitCallback, (XtPointer) 48);
  
  XtManageChild(Done);
  XtManageChild(form);
  
  
  XtManageChild(rc);

  overriding_parent_wid = parent_wid;
  MyPopup(dialog); 
  overriding_parent_wid = NULL;

  
  
  
  XtVaSetValues(vert_scroll[scrollindex],XmNincrement,30,NULL);
  
  if(type==CHOOSEPROJ_BROWSE)
    {
      browse12_up = 1;
    }
  else if(type==CHOOSESHAPE_BROWSE)
    {      
      
      XtAddEventHandler(dialog,StructureNotifyMask,False,myResizeHandler,(XtPointer)99999);      
      SHAPE_IMPORT_OUTPUT = 1;
    }
  else if(type==CHOOSE_ES1_BROWSE)
    {
      
      XtAddEventHandler(dialog,StructureNotifyMask,False,myResizeHandler,(XtPointer)99998);
      browse13_up = 1;
    }
  else if(type==CHOOSE_ES2_BROWSE)
    {
      
      XtAddEventHandler(dialog,StructureNotifyMask,False,myResizeHandler,(XtPointer)99997);
      browse14_up = 1;
    }
  else if(type==CHOOSE_TXT_BROWSE)
    {
      
      XtAddEventHandler(dialog,StructureNotifyMask,False,myResizeHandler,(XtPointer)99996);
      browse15_up = 1;
    }
  else if(type==CHOOSE_XML1_BROWSE)
    {
      
      XtAddEventHandler(dialog,StructureNotifyMask,False,myResizeHandler,(XtPointer)99995);
      browse27_up = 1;
    }
  else if(type==CHOOSE_XML2_BROWSE)
    {
      
      XtAddEventHandler(dialog,StructureNotifyMask,False,myResizeHandler,(XtPointer)99994);
      browse28_up = 1;
    }
  else if(type==CHOOSE_XML3_BROWSE)
    {
      
      XtAddEventHandler(dialog,StructureNotifyMask,False,myResizeHandler,(XtPointer)99993);
      browse29_up = 1;
    }
  else if(type==ATTRFOLDER_BROWSE)
    {
      browse30_up = 1;
    }
  else if(type==CHOOSE_DP_BROWSE)
    {
      browse31_up = 1;
    }
  else if(type==CHOOSEBROWSE_BROWSE)
    {
      browse32_up = 1;
    }
  else
    {
      printf("bad flag %d to DBC2\n",type);
    }
  
  
  set_cursor(mydisplay,mywindow,GOOD);
  
  set_cursor(
	     XtDisplay(XtParent(XtParent(XtParent(w)))),
	     XtWindow (XtParent(XtParent(XtParent(w)))),ARROW);
  

  XtVaGetValues (dialog, XmNwidth, &oldwidth, NULL);


  if(type==CHOOSEPROJ_BROWSE)
    {
      choose_dialog        = dialog;
	  choosenetproj_top    = suboutline1;
	  choosenetproj_left   = left1;
	  choosenetproj_right  = right1;
	  chooseproj_origwidth = oldwidth;
    }
  else if(type==CHOOSESHAPE_BROWSE)
    {
      chooseshape_dialog   = dialog;
	  choosenetshape_top   = suboutline1;
	  choosenetshape_left  = left1;
	  choosenetshape_right = right1;
	  chooseshape_origwidth= oldwidth;
    }
  else if(type==CHOOSE_ES1_BROWSE)
    {
      choose_es1_dialog    = dialog;
	  choosenet_es1_top    = suboutline1;
 	  choosenet_es1_left   = left1;
 	  choosenet_es1_right  = right1;
	  choosees1_origwidth  = oldwidth;
   }
  else if(type==CHOOSE_ES2_BROWSE)
    {
      choose_es2_dialog    = dialog;
	  choosenet_es2_top    = suboutline1;
 	  choosenet_es2_left   = left1;
 	  choosenet_es2_right  = right1;
	  choosees2_origwidth  = oldwidth;
   }
  else if(type==CHOOSE_TXT_BROWSE)
    {
      choose_txt_dialog    = dialog;
	  choosenet_txt_top    = suboutline1;
	  choosenet_txt_left   = left1;
	  choosenet_txt_right  = right1;
	  choosetxt_origwidth  = oldwidth;
    }
  else if(type==CHOOSE_XML1_BROWSE)
    {
      choose_xml1_dialog    = dialog;
	  choosenet_xml1_top    = suboutline1;
 	  choosenet_xml1_left   = left1;
 	  choosenet_xml1_right  = right1;
	  choosexml1_origwidth  = oldwidth;
   }
  else if(type==CHOOSE_XML2_BROWSE)
    {
      choose_xml2_dialog    = dialog;
	  choosenet_xml2_top    = suboutline1;
 	  choosenet_xml2_left   = left1;
 	  choosenet_xml2_right  = right1;
	  choosexml2_origwidth  = oldwidth;
   }
  else if(type==CHOOSE_XML3_BROWSE)
    {
      choose_xml3_dialog    = dialog;
	  choosenet_xml3_top    = suboutline1;
 	  choosenet_xml3_left   = left1;
 	  choosenet_xml3_right  = right1;
	  choosexml3_origwidth  = oldwidth;
   }
  else if(type==ATTRFOLDER_BROWSE)
    {
      chooseattr_dialog    = dialog;
	  choosenetattr_top    = suboutline1;
	  choosenetattr_left   = left1;
	  choosenetattr_right  = right1;
	  chooseattr_origwidth = oldwidth;
    }
  else if(type==CHOOSE_DP_BROWSE)
    {
      choosedp_dialog    = dialog;
	  choosenetdp_top    = suboutline1;
	  choosenetdp_left   = left1;
	  choosenetdp_right  = right1;
	  choosedp_origwidth = oldwidth;
    }
  else if(type==CHOOSEBROWSE_BROWSE)
    {
      choosebr_dialog    = dialog;
	  choosenetbr_top    = suboutline1;
	  choosenetbr_left   = left1;
	  choosenetbr_right  = right1;
	  choosebr_origwidth = oldwidth;
    }
  else
    {
      printf("error: bad flag %d to DBC\n",type);
    }

  RefreshLocs();




  ABNORMAL_DELETE = XmInternAtom (XtDisplay (dialog), "WM_DELETE_WINDOW", False);
  XmAddWMProtocolCallback (dialog, ABNORMAL_DELETE, BrowseInterceptCallback,dialog);


  if(saveleft!=NULL)
  {
    if(type!=CHOOSEBROWSE_BROWSE)
	{
      OpenSpecialLoc(saveleft,savemydata);
	}
  }


  if( ((SpecialLoc[0]<65)||(SpecialLoc[0]>90)) && (SpecialLoc[0]!='<') )
  {
    if(type!=CHOOSEBROWSE_BROWSE)
	{
      OpenSpecialNetLoc(left1,savemyTopnetdata);  

      OpenSpecialNetLoc(savenetleft,savenetmydata);
	}
  }


  return dialog;
}







void BrowseCallback(Widget w,XtPointer data,XtPointer callData)
{ 
  static Widget dialog[50];  
  Widget rowcol,temp_w;
  Arg args[15];
  int n = 0;
  int type = (int)data; 
  char titlestr[1000],tempstr[1000];



  if((type==CHOOSEPROJ_BROWSE)&&(browse12_up>0))
    { 
      set_cursor(XtDisplay(XtParent(XtParent(XtParent(w)))),
		 XtWindow(XtParent(XtParent(XtParent(w)))),WATCH);
      
      if(browse12_up==2)
	{	  
	  
	  RefreshLocs();
	}
      
      ResetWidget(dialog[CHOOSEPROJ_BROWSE]); 
      browse12_up = 1;
      
      set_cursor(XtDisplay(XtParent(XtParent(XtParent(w)))),
		 XtWindow(XtParent(XtParent(XtParent(w)))),ARROW);
      
      return;
    } 
  
  if((type==CHOOSE_ES1_BROWSE)&&(browse13_up>0))
    { 
      set_cursor(XtDisplay(XtParent(XtParent(XtParent(w)))),
		 XtWindow(XtParent(XtParent(XtParent(w)))),WATCH);
      
      if(browse13_up==2)
	{
	  
	  RefreshLocs();
	}
      
      ResetWidget(dialog[CHOOSE_ES1_BROWSE]); 
      browse13_up = 1;
      
      set_cursor(XtDisplay(XtParent(XtParent(XtParent(w)))),
		 XtWindow(XtParent(XtParent(XtParent(w)))),ARROW);
      
      return;
    } 
  if((type==CHOOSE_ES2_BROWSE)&&(browse14_up>0))
    { 
      set_cursor(XtDisplay(XtParent(XtParent(XtParent(w)))),
		 XtWindow(XtParent(XtParent(XtParent(w)))),WATCH);
      
      if(browse14_up==2)
	{
	  
	  RefreshLocs();
	}
      
      ResetWidget(dialog[CHOOSE_ES2_BROWSE]); 
      browse14_up = 1;
      
      set_cursor(XtDisplay(XtParent(XtParent(XtParent(w)))),
		 XtWindow(XtParent(XtParent(XtParent(w)))),ARROW);
      
      return;
    } 
  if((type==CHOOSE_TXT_BROWSE)&&(browse15_up>0))
    { 
      set_cursor(XtDisplay(XtParent(XtParent(XtParent(w)))),
		 XtWindow(XtParent(XtParent(XtParent(w)))),WATCH);
      
      if(browse15_up==2)
	{
	  
	  RefreshLocs();
	}
      
      ResetWidget(dialog[CHOOSE_TXT_BROWSE]); 
      browse15_up = 1;
      
      set_cursor(XtDisplay(XtParent(XtParent(XtParent(w)))),
		 XtWindow(XtParent(XtParent(XtParent(w)))),ARROW);
      
      return;
    } 


  if((type==CHOOSEDATA_BROWSE)&&(browse26_up>0))
    { 
      set_cursor(XtDisplay(XtParent(XtParent(XtParent(w)))),
		 XtWindow(XtParent(XtParent(XtParent(w)))),WATCH);
      
      if(browse26_up==2)
	{
	  
	  RefreshLocs();
	}
      
      ResetWidget(dialog[CHOOSEDATA_BROWSE]); 
      browse26_up = 1;
      
      set_cursor(XtDisplay(XtParent(XtParent(XtParent(w)))),
		 XtWindow(XtParent(XtParent(XtParent(w)))),ARROW);
      
      return;
    } 
  

  
  if((type==CHOOSE_XML1_BROWSE)&&(browse27_up>0))
    { 
      set_cursor(XtDisplay(XtParent(XtParent(XtParent(w)))),
		 XtWindow(XtParent(XtParent(XtParent(w)))),WATCH);
      
      if(browse27_up==2)
	  { 
	    
	    RefreshLocs();
	  } 

      ResetWidget(dialog[CHOOSE_XML1_BROWSE]); 
      browse27_up = 1;
      
      set_cursor(XtDisplay(XtParent(XtParent(XtParent(w)))),
		 XtWindow(XtParent(XtParent(XtParent(w)))),ARROW);
      
      return;
    } 


  if((type==CHOOSE_XML2_BROWSE)&&(browse28_up>0))
    { 
      set_cursor(XtDisplay(XtParent(XtParent(XtParent(w)))),
		 XtWindow(XtParent(XtParent(XtParent(w)))),WATCH);
      
      if(browse28_up==2)
	  { 
	    
	    RefreshLocs();
	  } 

      ResetWidget(dialog[CHOOSE_XML2_BROWSE]); 
      browse28_up = 1;
      
      set_cursor(XtDisplay(XtParent(XtParent(XtParent(w)))),
		 XtWindow(XtParent(XtParent(XtParent(w)))),ARROW);
      
      return;
    } 

  if((type==CHOOSE_XML3_BROWSE)&&(browse29_up>0))
    { 
      set_cursor(XtDisplay(XtParent(XtParent(XtParent(w)))),
		 XtWindow(XtParent(XtParent(XtParent(w)))),WATCH);
      
      if(browse29_up==2)
	  { 
	    
	    RefreshLocs();
	  } 

      ResetWidget(dialog[CHOOSE_XML3_BROWSE]); 
      browse29_up = 1;
      
      set_cursor(XtDisplay(XtParent(XtParent(XtParent(w)))),
		 XtWindow(XtParent(XtParent(XtParent(w)))),ARROW);
      
      return;
    } 

  if((type==ATTRFOLDER_BROWSE)&&(browse30_up>0))
    { 
      set_cursor(XtDisplay(XtParent(XtParent(XtParent(w)))),
		 XtWindow(XtParent(XtParent(XtParent(w)))),WATCH);
      
      if(browse30_up==2)
	  { 
	    
	    RefreshLocs();
	  } 

      ResetWidget(dialog[ATTRFOLDER_BROWSE]); 
      browse30_up = 1;
      
      set_cursor(XtDisplay(XtParent(XtParent(XtParent(w)))),
		 XtWindow(XtParent(XtParent(XtParent(w)))),ARROW);
      
      return;
    } 

  if((type==CHOOSE_DP_BROWSE)&&(browse31_up>0))
    { 
      set_cursor(XtDisplay(XtParent(XtParent(XtParent(w)))),
		 XtWindow(XtParent(XtParent(XtParent(w)))),WATCH);
      
      if(browse31_up==2)
	  { 
	    
	    RefreshLocs();
	  } 

      ResetWidget(dialog[CHOOSE_DP_BROWSE]); 
      browse31_up = 1;
      
      set_cursor(XtDisplay(XtParent(XtParent(XtParent(w)))),
		 XtWindow(XtParent(XtParent(XtParent(w)))),ARROW);
      
      return;
    }

  if((type==CHOOSEBROWSE_BROWSE)&&(browse32_up>0))
    { 
      set_cursor(XtDisplay(XtParent(XtParent(XtParent(w)))),
		 XtWindow(XtParent(XtParent(XtParent(w)))),WATCH);
      
      if(browse32_up==2)
	  { 
	    
	    RefreshLocs();
	  } 

      ResetWidget(dialog[CHOOSEBROWSE_BROWSE]); 
      browse32_up = 1;
      
      set_cursor(XtDisplay(XtParent(XtParent(XtParent(w)))),
		 XtWindow(XtParent(XtParent(XtParent(w)))),ARROW);
      
      return;
    }

  if((USE_DOS==1)&&(old_file_browser==0))
    {
      dialog[type] = DosBrowseCallback(w,data,callData);
      return;
    }


  

  if(type==CHOOSEPROJ_BROWSE)
    {
      sprintf(titlestr, "Choose project folder");
    }
  else if(type==CHOOSE_ES1_BROWSE)
    {
      sprintf(titlestr, "Choose First ES filename");
    }
  else if(type==CHOOSE_ES2_BROWSE)
    {
      sprintf(titlestr, "Choose Second ES filename");
    }
  else if(type==CHOOSE_TXT_BROWSE)
    {
      sprintf(titlestr, "Choose folder path or file to overwrite");
    }
  else if(type==CHOOSEDATA_BROWSE)
    {
      sprintf(titlestr, "Choose folder path");
    }
  else if(type==CHOOSE_XML1_BROWSE)
    {
      sprintf(titlestr, "Choose XML filename");
    }
  else if(type==CHOOSE_XML2_BROWSE)
    {
      sprintf(titlestr, "Choose Refine file .TXT filename");
    }
  else if(type==CHOOSE_XML3_BROWSE)
    {
      sprintf(titlestr, "Choose TXT output filename");
    }
  else if(type==ATTRFOLDER_BROWSE)
    {
      sprintf(titlestr, "Folder Containing Attribution Files Selection");
    }
  else if(type==CHOOSE_DP_BROWSE)
    {
      sprintf(titlestr, "Folder Containing MGCP Packaged Cell");
    }
  else
    {
      XBell(mydisplay,50);
      printf("bad type to chRR\n");
      return;
    }
  
  
  n = 0;
  XtSetArg(args[n], XmNdeleteResponse, XmDESTROY);                   n++;
  
  dialog[type] = XtCreatePopupShell(titlestr,topLevelShellWidgetClass,drawing_a,args,n);
  
  rowcol = XtVaCreateWidget ("rowcol", xmRowColumnWidgetClass,  dialog[type], NULL);
  
  
  n = 0;

  if((NGA_TYPE==1)&&(USE_DOS==1))
    {
      XtSetArg(args[n], XmNdirListLabelString,   STRING("Folders"));         n++;
    }



  if(strcmp(SpecialLoc,"<not specified>"))
  {
    XtSetArg(args[n], XmNdirectory,  STRING(SpecialLoc));  n++;
  }
  else
  {
    if((input_source==1)&&((type==CHOOSE_ES1_BROWSE)||(type==CHOOSE_ES2_BROWSE)))
	{
      sprintf(tempstr,"%scondition_reports",indirectory);
      XtSetArg(args[n], XmNdirectory,  STRING(tempstr));  n++;
    }
    else if(type==CHOOSEDATA_BROWSE)
    {
      XtSetArg(args[n], XmNdirectory,  STRING(DATALOC));  n++;
    }
    else
    {
      XtSetArg(args[n], XmNdirectory,  STRING(indirectory));  n++;
    }
  }



  if(
     (type==CHOOSE_ES1_BROWSE) ||
     (type==CHOOSE_ES2_BROWSE) 
     )
    {
      XtSetArg(args[n], XmNpattern,    STRING("*.es"));       n++;
    }


 
  XtSetArg(args[n], XmNtranslations, XtParseTranslationTable ( translations_global )); n++;
 
  temp_w = XmCreateFileSelectionBox (rowcol,"mymessagebox",args,n);
  

  XtAddCallback(temp_w, XmNokCallback,
		(XtCallbackProc)browsefileDialogCallback,
		(XtPointer)data);
  
  XtAddCallback(temp_w, XmNcancelCallback,
		(XtCallbackProc)browsefilecancelDialogCallback,
		(XtPointer)data); 
  

  
  
  XtSetSensitive(XmSelectionBoxGetChild(temp_w,XmDIALOG_HELP_BUTTON),False);
  
  
  
  XtManageChild(temp_w);
  XtManageChild(rowcol);
  XtManageChild(dialog[type]);
  

  if(type==CHOOSEPROJ_BROWSE){XtAddCallback(dialog[type],XmNdestroyCallback,ShellDeath,(XtPointer)(4003));}
  else if(type==CHOOSE_ES1_BROWSE){XtAddCallback(dialog[type],XmNdestroyCallback,ShellDeath,(XtPointer)(4061));}
  else if(type==CHOOSE_ES2_BROWSE){XtAddCallback(dialog[type],XmNdestroyCallback,ShellDeath,(XtPointer)(4062));}
  else if(type==CHOOSE_TXT_BROWSE){XtAddCallback(dialog[type],XmNdestroyCallback,ShellDeath,(XtPointer)(4063));}
  else if(type==CHOOSEDATA_BROWSE){XtAddCallback(dialog[type],XmNdestroyCallback,ShellDeath,(XtPointer)(4081));}
  else if(type==CHOOSE_XML1_BROWSE){XtAddCallback(dialog[type],XmNdestroyCallback,ShellDeath,(XtPointer)(4083));}
  else if(type==CHOOSE_XML2_BROWSE){XtAddCallback(dialog[type],XmNdestroyCallback,ShellDeath,(XtPointer)(4084));}
  else if(type==CHOOSE_XML3_BROWSE){XtAddCallback(dialog[type],XmNdestroyCallback,ShellDeath,(XtPointer)(4085));}
  else if(type==ATTRFOLDER_BROWSE) {XtAddCallback(dialog[type],XmNdestroyCallback,ShellDeath,(XtPointer)(4090));}
  else if(type==CHOOSE_DP_BROWSE) {XtAddCallback(dialog[type],XmNdestroyCallback,ShellDeath,(XtPointer)(4093));}
  else if(type==CHOOSEBROWSE_BROWSE) {XtAddCallback(dialog[type],XmNdestroyCallback,ShellDeath,(XtPointer)(4095));}


  MyPopup (dialog[type]);

  if(type==CHOOSEPROJ_BROWSE)        { browse12_up = 1;}
  else if(type==CHOOSE_ES1_BROWSE)   { browse13_up = 1;}
  else if(type==CHOOSE_ES2_BROWSE)   { browse14_up = 1;}
  else if(type==CHOOSE_TXT_BROWSE)   { browse15_up = 1;}
  else if(type==CHOOSEDATA_BROWSE)   { browse26_up = 1;}
  else if(type==CHOOSE_XML1_BROWSE)  { browse27_up = 1;}
  else if(type==CHOOSE_XML2_BROWSE)  { browse28_up = 1;}
  else if(type==CHOOSE_XML3_BROWSE)  { browse29_up = 1;}
  else if(type==ATTRFOLDER_BROWSE)   { browse30_up = 1;}
  else if(type==CHOOSE_DP_BROWSE)    { browse31_up = 1;}
  else if(type==CHOOSEBROWSE_BROWSE) { browse32_up = 1;}



  if((type==CHOOSEPROJ_BROWSE)||(type==CHOOSEDATA_BROWSE)||(type==ATTRFOLDER_BROWSE)||(type==CHOOSE_DP_BROWSE)||(type==CHOOSEBROWSE_BROWSE))
    {
      
      XtSetSensitive(XmFileSelectionBoxGetChild (temp_w, XmDIALOG_LIST_LABEL),False);
      XtSetSensitive(XmFileSelectionBoxGetChild (temp_w, XmDIALOG_LIST)      ,False);
    }
  
  
  
  XtVaSetValues(XmFileSelectionBoxGetChild (temp_w, XmDIALOG_DIR_LIST),
		XmNtranslations, XtParseTranslationTable (list_translations14),NULL);
  
  XtVaGetValues(XtParent(XmFileSelectionBoxGetChild (temp_w, XmDIALOG_DIR_LIST)),
		XmNverticalScrollBar,&vert_scroll[FILEOTHER_SCROLL ] ,NULL);
 
  XtVaSetValues(XmFileSelectionBoxGetChild (temp_w, XmDIALOG_LIST),
		XmNtranslations, XtParseTranslationTable (list_translations15),NULL);
  
  XtVaGetValues(XtParent(XmFileSelectionBoxGetChild (temp_w, XmDIALOG_LIST)),
		XmNverticalScrollBar,&vert_scroll[FILEOTHER1_SCROLL ] ,NULL);
}
  



void importfileDialogCallback(Widget w, XtPointer userData,
			XmFileSelectionBoxCallbackStruct *data)
{
  char *junk;  
  
  XmStringGetLtoR(data->value,(XmStringCharSet) XmSTRING_DEFAULT_CHARSET, &junk);  

  strcpy(importdirectory,junk);
  
  if(DEBUG==1){printf("Import file name is %s\n",importdirectory);}
    
  XtVaSetValues(terrain_to_import,XmNlabelString,STRING(importdirectory),NULL);
  
  import_source    = 1; 
  IMPORT_INPUT     = 0; 
  XtFree(junk);
}



void patchfileDialogCallback(Widget w, XtPointer userData,
			XmFileSelectionBoxCallbackStruct *data)
{
  char *junk;  
  
  XmStringGetLtoR(data->value,(XmStringCharSet) XmSTRING_DEFAULT_CHARSET, &junk);  

  strcpy(patchfile,junk);
  
  if(DEBUG==1){printf("Patch file is %s\n",patchfile);}

  XtVaSetValues(patch_t,XmNlabelString,STRING(patchfile),NULL);
  

  patch_source    = 1; 
  PATCH_INPUT     = 0; 
  XtFree(junk);
}


void stffileDialogCallback(Widget w, XtPointer userData,
			XmFileSelectionBoxCallbackStruct *data)
{
  char *junk;  
  
  XmStringGetLtoR(data->value,(XmStringCharSet) XmSTRING_DEFAULT_CHARSET, &junk);  

  strcpy(stffix,junk);
  
  if(DEBUG==1){printf("STF OVERWRITE file is %s\n",stffix);}

  XtVaSetValues(stf_t,XmNlabelString,STRING(stffix),NULL);

  stf_overwrite_source    = 1; 
  STF_INPUT     = 0; 
  XtFree(junk);
}


void non_fatal_error(Widget w, char message[],char title[])
{     
  not_while_running(w,message,1111,title,1);
}

void short_non_fatal_error(char message[],char title[])
{
  not_while_running(drawing_a,message,1112,title,1);
}










void SetEndian(char testdirectory[])
{
  FILE *testfile;
  char tester[1000];
  unsigned char a,b,c,d;


  sprintf(tester,"%ssizes.bin",testdirectory);
  testfile = fopen(tester,"rb");if(testfile==NULL){BadDB(0,tester); return ;}
  else
    {
      fread(&d, SzUC,1,testfile);
      fread(&a, SzUC,1,testfile);
      fread(&b, SzUC,1,testfile);
      fread(&c, SzUC,1,testfile);

      if(a!=SzI){printf("2 int size mismatch! %d vs %d\n",a,SzI); ExitWrapper(-1);}
      if(b!=SzD){printf("double size mismatch! %d vs %d\n",b,SzD); ExitWrapper(-1);}
      if(c!=sizeof(long int)){printf("long int size mismatch! %d vs %d\n",c,(int)sizeof(long int)); ExitWrapper(-1);}

      if(d==0)
	{file_endianness = 0;}
      else if(d==1)
	{file_endianness = 1;}
      else
	{printf("bad endian value %d\n",(int)d); ExitWrapper(-1);}
      fclose(testfile);
    }
 
}



int SetAttributionType(int silent, char *infile)
{
  unsigned char a;
  FILE *testfile;

  testfile = fopen(infile,"rb");if(testfile==NULL){BadDB(silent,infile); return -1;}

  fread(&a, SzUC,1,testfile);
 
  fclose(testfile);
 
  ATTRIBUTION_TYPE = (int)a;

  InitializeAttribution();

  return 1;
}


int CheckDataContent(char *testdir, int silent)
{
  

  char temp[1000];
  FILE *headfile;
  int num_long_entries,num_short_entries;
  double MINYREAD;
  double MINXREAD;
  double MAXYREAD;
  double MAXXREAD;  
  double MINY_P_READ;
  double MINX_P_READ;
  double MAXY_P_READ;
  double MAXX_P_READ;
  long int TERRAINPOLYSREAD;
  unsigned long int GRIDPOINTSREAD;
  long int POINT_POINTSREAD;
  long int LINEAR_POINTSREAD;
  long int AREAL_POINTSREAD;
  int GRIDSREAD;
  int coordflag;
  int totaldataread=0;
  sprintf(temp,"%sheader.txt",testdir);


  headfile = fopen(temp,"r");
  if(headfile==NULL)
    {
      if(silent==1)
	{
	  return 0;
	}

      
      sprintf(temp,
	      "Couldnt open %s for read.\nCannot continue with this project.",temp); 
      not_while_running(drawing_a,temp,1382,"Bad Project",1);
      return 0;
    }
  
  fscanf(headfile,"%d %lf %lf %lf %lf %lf %lf %lf %lf %ld %lu %ld %ld %ld %d %d %d\n",
	 &coordflag,
	 &MINXREAD,&MINYREAD,&MAXXREAD,&MAXYREAD,
	 &MINX_P_READ,&MINY_P_READ,&MAXX_P_READ,&MAXY_P_READ,
	 &TERRAINPOLYSREAD,
	 &GRIDPOINTSREAD,&POINT_POINTSREAD,&LINEAR_POINTSREAD,&AREAL_POINTSREAD,&GRIDSREAD,
	 &num_long_entries,&num_short_entries);
  
  totaldataread = POINT_POINTSREAD + LINEAR_POINTSREAD +
    AREAL_POINTSREAD + GRIDPOINTSREAD + TERRAINPOLYSREAD;
  
  
  
  fclose(headfile);
  
  if(totaldataread==0)
    {
      if(silent==1)
	{
	  return 0;
	}

      sprintf(temp,
	      "Project %s\nwas not created because no readable data existed.\nCannot continue with this project.",testdir); 
      not_while_running(drawing_a,temp,1383,"Bad Project",1);
      return 0;
    }
  return 1;
}




int TestDB(char testdirectory[], int silent)
{
  FILE *testfile;
  char tester[1000],outshapedirectory[1000],command[1000],testversion[100];
  unsigned char a,b,c,d;
  int i,len;


  


  
  if(NGA_TYPE==1)
    {
      sprintf(tester,"%sdbv.txt"   ,testdirectory);
      testfile = fopen(tester,"r");
      if(testfile==NULL)
	{
	  BadDB(silent,"tim_special"); 
	  return 0;
	}
      else
	{
	  for(i=0;i<100;i++)
	    {
	      testversion[i] = '\0';
	    }


	  fgets(testversion,100,testfile);


	  

	  len = strlen(testversion);
	  for(i=0;i<len;i++)
	    {
	      if((testversion[i]<32)||(testversion[i]>126))
		{
		  
		  testversion[i] = '\0';
		  break;
		}
	    }

	  
	  if(strcmp(testversion,VersionStr))
	    {
	      BadDB(silent,"tim_special");
	      fclose(testfile);
	      return 0;
	    }
	  
	  if(silent==0)
	    {
	      fscanf(testfile,"%d",&ThisClassLevel);

	      if((ThisClassLevel<-1)||(ThisClassLevel>43))
		{
		  ThisClassLevel = -100;
		}
	    }
	  
	  fclose(testfile);
	}
    }




  sprintf(tester,"%ssizes.bin",testdirectory);
  testfile = fopen(tester,"rb");if(testfile==NULL){BadDB(silent,tester); return 0;}
  else
    {
      fread(&d, SzUC,1,testfile);
      fread(&a, SzUC,1,testfile);
      fread(&b, SzUC,1,testfile);
      fread(&c, SzUC,1,testfile);

      if(a!=SzI)
	{
	  printf("3 int size mismatch! %d vs %d\n",a,SzI);
	  BadDB(silent,"tim_special"); 
	  fclose(testfile);
	  return 0;
	}
      if(b!=SzD)
	{
	  printf("double size mismatch! %d vs %d\n",b,SzD); 
	  BadDB(silent,"tim_special"); 
	  fclose(testfile);
	  return 0;
	}
      if(c!=sizeof(long int))
	{
	  printf("long int size mismatch! %d vs %d\n",c,(int)sizeof(long int)); 
	  BadDB(silent,"tim_special"); 
	  fclose(testfile);
	  return 0;
	}

      if(d==0)
	{
	  file_endianness = 0;
	}
      else if(d==1)
	{
	  file_endianness = 1;
	}
      else
	{
	  printf("bad endian value %d\n",(int)d);
	  ExitWrapper(-1);
	}
       
      SEEIT_fread_int(&Total2DPoint,testfile);
      SEEIT_fread_int(&Total3DPoint,testfile);
      SEEIT_fread_int(&Total2DLine, testfile);
      SEEIT_fread_int(&Total3DLine, testfile);
      SEEIT_fread_int(&Total2DArea, testfile);
      SEEIT_fread_int(&Total3DArea, testfile);

      if(silent==0)
	{
	  printf("read totals %d/%d %d/%d %d/%d\n",
		 Total2DPoint,
		 Total3DPoint,
		 Total2DLine,
		 Total3DLine,
		 Total2DArea,
		 Total3DArea);
	}

      fclose(testfile);
    }


  if(silent==1)
    {
      return 1;
    }


  

  sprintf(tester,"%sheader.txt"      ,testdirectory);
  testfile = fopen(tester,"r");if(testfile==NULL){BadDB(silent,tester); return 0;}else{fclose(testfile);}


  
  
  if(CheckDataContent(testdirectory,silent)==0)
    {
      return 0;
    }
  
  sprintf(tester,"%ssingleregion.bin",testdirectory);
  testfile = fopen(tester,"r");if(testfile==NULL){BadDB(silent,tester); return 0;}else{fclose(testfile);}

  sprintf(tester,"%spolytable.bin"   ,testdirectory);
  testfile = fopen(tester,"r");if(testfile==NULL){BadDB(silent,tester); return 0;}else{fclose(testfile);}

  sprintf(tester,"%sarealtable.bin"  ,testdirectory);
  testfile = fopen(tester,"r");if(testfile==NULL){BadDB(silent,tester); return 0;}else{fclose(testfile);}

  sprintf(tester,"%sarealdata.bin"   ,testdirectory);
  testfile = fopen(tester,"r");if(testfile==NULL){BadDB(silent,tester); return 0;}else{fclose(testfile);}

  

  sprintf(tester,"%slineartable.bin" ,testdirectory);
  testfile = fopen(tester,"r");if(testfile==NULL){BadDB(silent,tester); return 0;}else{fclose(testfile);}

  sprintf(tester,"%slineardata.bin"  ,testdirectory);
  testfile = fopen(tester,"r");if(testfile==NULL){BadDB(silent,tester); return 0;}else{fclose(testfile);}

  sprintf(tester,"%spointtable.bin"  ,testdirectory);
  testfile = fopen(tester,"r");if(testfile==NULL){BadDB(silent,tester); return 0;}else{fclose(testfile);}

  sprintf(tester,"%spointdata.bin"   ,testdirectory);
  testfile = fopen(tester,"r");if(testfile==NULL){BadDB(silent,tester); return 0;}else{fclose(testfile);}

  sprintf(tester,"%sbridgedata.bin"  ,testdirectory);
  testfile = fopen(tester,"r");if(testfile==NULL){BadDB(silent,tester); return 0;}else{fclose(testfile);}

  sprintf(tester,"%sbridgetable.bin" ,testdirectory);
  testfile = fopen(tester,"r");if(testfile==NULL){BadDB(silent,tester); return 0;}else{fclose(testfile);}

  sprintf(tester,"%sdynamicdefs.txt" ,testdirectory);
  testfile = fopen(tester,"r");if(testfile==NULL){BadDB(silent,tester); return 0;}else{fclose(testfile);}

  sprintf(tester,"%sdynamicdefs.bin" ,testdirectory);
  testfile = fopen(tester,"r");if(testfile==NULL){BadDB(silent,tester); return 0;}else{fclose(testfile);}

  sprintf(tester,"%sheader.bin"      ,testdirectory);
  testfile = fopen(tester,"r");if(testfile==NULL){BadDB(silent,tester); return 0;}else{fclose(testfile);}

  sprintf(tester,"%scodesshort.bin"      ,testdirectory);
  testfile = fopen(tester,"rb");if(testfile==NULL){BadDB(silent,tester); return 0;}else{fclose(testfile);}

  sprintf(tester,"%scodesfull.bin"      ,testdirectory);
  testfile = fopen(tester,"rb");if(testfile==NULL){BadDB(silent,tester); return 0;}else{fclose(testfile);}

  sprintf(tester,"%secclist.bin"     ,testdirectory);
  testfile = fopen(tester,"r");if(testfile==NULL){BadDB(silent,tester); return 0;}else{fclose(testfile);}

  sprintf(tester,"%secclookup.bin"   ,testdirectory);
  testfile = fopen(tester,"r");if(testfile==NULL){BadDB(silent,tester); return 0;}else{fclose(testfile);}

  

 
  
  
  sprintf(outdirectory,"%s%s",testdirectory,outfoldername);
  
  if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
    {
      strcat(outdirectory,"\\");
    }
  else
    {
      strcat(outdirectory,"/");
    }
  
  if(DEBUG==1){printf("Output file name is %s\n",outdirectory);}
  
  if(TestOut(outdirectory)==0)
    {
      output_source=0;
      return 0;
    }




  sprintf(outattrdirectory,"%sattribution_errors",testdirectory);
  
  if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
    {
      strcat(outattrdirectory,"\\");
    }
  else
    {
      strcat(outattrdirectory,"/");
    }
  
  if(DEBUG==1){printf("Output file name is %s\n",outattrdirectory);}
  
  if(TestOut(outattrdirectory)==0)
    {
      output_source=0;
      return 0;
    }



  sprintf(outsumdirectory,"%ssummary_files",testdirectory);
  
  if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
    {
      strcat(outsumdirectory,"\\");
    }
  else
    {
      strcat(outsumdirectory,"/");
    }
  
  if(DEBUG==1){printf("Output file name is %s\n",outsumdirectory);}
  
  if(TestOut(outsumdirectory)==0)
    {
      output_source=0;
      return 0;
    }





  sprintf(command,"%snetworkdata.bin",outdirectory);
  
  if(ZeroNetworkFile(command)==0)
    {
      printf("Unable to zero network file\n\n");
    }
  else
    {
      
    }
  NumNetsLoaded = 0;
  




  sprintf(outshapedirectory,"%sinspection_files",testdirectory);
  
  if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
    {
      strcat(outshapedirectory,"\\");
    }
  else
    {
      strcat(outshapedirectory,"/");
    }
  
  if(TestOut(outshapedirectory)==0)
    {
      output_source=0;
      return 0;
    }





  sprintf(outshapedirectory,"%sview_network_files",testdirectory);

  
  if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
    {
      strcat(outshapedirectory,"\\");
    }
  else
    {
      strcat(outshapedirectory,"/");
    }
  
  if(TestOut(outshapedirectory)==0)
    {
      output_source=0;
      return 0;
    }









  sprintf(outshapedirectory,"%spoints_of_interest_files",testdirectory);
  
  if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
    {
      strcat(outshapedirectory,"\\");
    }
  else
    {
      strcat(outshapedirectory,"/");
    }
  
  if(TestOut(outshapedirectory)==0)
    {
      output_source=0;
      return 0;
    }






  sprintf(outshapedirectory,"%scondition_reports",testdirectory);
  
  if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
    {
      strcat(outshapedirectory,"\\");
    }
  else
    {
      strcat(outshapedirectory,"/");
    }
  
  if(TestOut(outshapedirectory)==0)
    {
      output_source=0;
      return 0;
    }




  sprintf(outshapedirectory,"%sQACR_files",testdirectory);
  
  if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
    {
      strcat(outshapedirectory,"\\");
    }
  else
    {
      strcat(outshapedirectory,"/");
    }
  
  if(TestOut(outshapedirectory)==0)
    {
      output_source=0;
      return 0;
    }




  sprintf(outshapedirectory,"%sexported_shapefiles",testdirectory);
  
  if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
    {
      strcat(outshapedirectory,"\\");
    }
  else
    {
      strcat(outshapedirectory,"/");
    }
  
  if(TestOut(outshapedirectory)==0)
    {
      output_source=0;
      return 0;
    }



  sprintf(outshapedirectory,"%sTREx_Reports",testdirectory);
  
  if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
    {
      strcat(outshapedirectory,"\\");
    }
  else
    {
      strcat(outshapedirectory,"/");
    }
  
  if(TestOut(outshapedirectory)==0)
    {
      output_source=0;
      return 0;
    }




  if(NGA_TYPE==1)
    {
      sprintf(tester,"%sattrsch.bin",testdirectory);
      
      if (SetAttributionType(silent,tester)==-1)
	{
	  return 0;
	}
    }




  
  output_source=1;

  InitializeOutStreams();



  return 1;
}





void ScrubEDCSMarkerList2(int errnum, int axis, int ADDER, int clonenum, int cloneindex, int geomtype)
{
  struct IMarkSACList *temp, *prev;
  int numfree=0;

  if(clonenum==0)
    {
      temp = ErrorLookup[errnum].IMarkSACRoot[axis][ADDER][geomtype];
    }
  else
    {
      temp = CloneErrorLookup[cloneindex].IMarkSACRoot[axis][ADDER][geomtype];
    }
  
  prev = temp;
  
  while(temp!=NULL)
    {
      prev=temp;
      temp=temp->next;
	  if(prev->EEindex==-2)
	  {
		if(prev->saveval!=NULL) 
		  {
	         free(prev->saveval);
		  }
	  }
	  numfree = numfree + 1;

      free(prev);
    }


  if(clonenum==0)
    {
      ErrorLookup[errnum].IMarkSACRoot[axis][ADDER][geomtype] = NULL;
    }
  else
    {
      CloneErrorLookup[cloneindex].IMarkSACRoot[axis][ADDER][geomtype] = NULL;
    }

}






void ScrubEDCSMarkerList(int errnum, int axis, int ADDER, int clonenum, int cloneindex, int geomtype)
{
  struct IMarkList *temp, *prev;
  
  if(clonenum==0)
    {
      temp = ErrorLookup[errnum].IMarkRoot[axis][ADDER][geomtype];
    }
  else
    {
      temp = CloneErrorLookup[cloneindex].IMarkRoot[axis][ADDER][geomtype];
    }

  prev = temp;
  
  while(temp!=NULL)
    {
      prev=temp;
      temp=temp->next;
      free(prev);
    }
  
  if(clonenum==0)
    {
      ErrorLookup[errnum].IMarkRoot[axis][ADDER][geomtype] = NULL;
    }
  else
    {
      CloneErrorLookup[cloneindex].IMarkRoot[axis][ADDER][geomtype] = NULL;
    }
}




void ScrubALLEDCSMarkerLists(int newdb, int nettype)
{
  int i,j,k,l;
  int start;

  if(newdb==1)
    {
      start = 0;
    }
  else
    {
      start = 1;
    }



  for(i=start;i<=CONDITION_DEFINITIONS;i++)
    {
      

	  if(IsNetCheck(i)!=nettype)
	  {
        continue;
	  }


      for(j=0;j<3+1;j++)
	{
	  for(k=0;k<2;k++)
	    {
	      for(l=0;l<NUM_C;l++)
		{
		  ScrubEDCSMarkerList (i,j,k,0,-1,l);
		  ScrubEDCSMarkerList2(i,j,k,0,-1,l);
		}
	    }
	  	 
	  if(ErrorLookup[i].primaryEDCSstuff!=NULL)
	    {
	      free(ErrorLookup[i].primaryEDCSstuff);
	      ErrorLookup[i].primaryEDCSstuff = NULL;
	    }
	  if(ErrorLookup[i].secondaryEDCSstuff!=NULL)
	    {
	      free(ErrorLookup[i].secondaryEDCSstuff);
	      ErrorLookup[i].secondaryEDCSstuff = NULL;
	    }
	  if(ErrorLookup[i].tertiaryEDCSstuff!=NULL)
	    {
	      free(ErrorLookup[i].tertiaryEDCSstuff);
	      ErrorLookup[i].tertiaryEDCSstuff = NULL;
	    }


	  if(ErrorLookup[i].primaryFIDstuff!=NULL)
	    {
	      free(ErrorLookup[i].primaryFIDstuff);
	      ErrorLookup[i].primaryFIDstuff = NULL;
	    }
	  if(ErrorLookup[i].secondaryFIDstuff!=NULL)
	    {
	      free(ErrorLookup[i].secondaryFIDstuff);
	      ErrorLookup[i].secondaryFIDstuff = NULL;
	    }
	  if(ErrorLookup[i].tertiaryFIDstuff!=NULL)
	    {
	      free(ErrorLookup[i].tertiaryFIDstuff);
	      ErrorLookup[i].tertiaryFIDstuff = NULL;
	    }

	}
    }

  for(i=0;i<CLONE_DEFINITIONS;i++)
    {
	  if(IsNetCheck(CloneErrorLookup[i].CloneNumber)!=nettype)
	  {
        continue;
	  }


      for(j=0;j<3+1;j++)
	{
	  for(k=0;k<2;k++)
	    {
	      for(l=0;l<NUM_C;l++)
		{
		  ScrubEDCSMarkerList (-1,j,k,1,i,l);
		  ScrubEDCSMarkerList2(-1,j,k,1,i,l);
		}
	    }
	}
    }
}







int DeleteFromIMarkList(int index, int errnum, int axis, int ADDER, int clonenum, int cloneindex, int geomtype)
{
  struct IMarkList *temp, *prev;
  int num=0;

  
  
  if(clonenum==0)
    {
      index = ErrorLookup[errnum].model_index[axis][ADDER][geomtype]-index-1;      
      temp  = ErrorLookup[errnum].IMarkRoot[axis][ADDER][geomtype];
    }
  else
    {
      index = CloneErrorLookup[cloneindex].model_index[axis][ADDER][geomtype]-index-1;      
      temp  = CloneErrorLookup[cloneindex].IMarkRoot[axis][ADDER][geomtype]; 
    }


  if(index<0)
    {
      
      return 0;
    }




  while(temp!=NULL)
    {
      if(num==index)
	{
	  if(clonenum==0)
	    {
	      if(temp==ErrorLookup[errnum].IMarkRoot[axis][ADDER][geomtype])
		{
		  ErrorLookup[errnum].IMarkRoot[axis][ADDER][geomtype] = ErrorLookup[errnum].IMarkRoot[axis][ADDER][geomtype]->next;
		  free(temp);
		  break;  
		}
	      else
		{
		  prev->next = temp->next;
		  free(temp);
		  break;  
		}
	    }
	  else
	    {
	      if(temp==CloneErrorLookup[cloneindex].IMarkRoot[axis][ADDER][geomtype])
		{
		  CloneErrorLookup[cloneindex].IMarkRoot[axis][ADDER][geomtype] = 
		    CloneErrorLookup[cloneindex].IMarkRoot[axis][ADDER][geomtype]->next;
		  free(temp);
		  break;  
		}
	      else
		{
		  prev->next = temp->next;
		  free(temp);
		  break;  
		}
	    }
	}

      prev = temp;
      temp=temp->next;
      num++;
    }

  return 1;
}



int DeleteFromIMarkSACList(int index, int errnum, int axis, int ADDER, int clonenum, int cloneindex, int geomtype)
{
  struct IMarkSACList *temp, *prev;
  int num=0;

  
  
  if(clonenum==0)
    {
      index = ErrorLookup[errnum].sac_index[axis][ADDER][geomtype]-index-1;
      temp  = ErrorLookup[errnum].IMarkSACRoot[axis][ADDER][geomtype];
    }
  else
    {
      index = CloneErrorLookup[cloneindex].sac_index[axis][ADDER][geomtype]-index-1;
      temp  = CloneErrorLookup[cloneindex].IMarkSACRoot[axis][ADDER][geomtype];
    }


  if(index<0)
    {
      
      return 0;
    }
  

  while(temp!=NULL)
    {
      if(num==index)
	{
	  if(clonenum==0)
	    {
	      if(temp==ErrorLookup[errnum].IMarkSACRoot[axis][ADDER][geomtype])
		{
		  ErrorLookup[errnum].IMarkSACRoot[axis][ADDER][geomtype] = 
		    ErrorLookup[errnum].IMarkSACRoot[axis][ADDER][geomtype]->next;
		  free(temp);
		  break;  
		}
	      else
		{
		  prev->next = temp->next;
		  free(temp);
		  break;  
		}
	    }
	  else
	    {
	      if(temp==CloneErrorLookup[cloneindex].IMarkSACRoot[axis][ADDER][geomtype])
		{
		  CloneErrorLookup[cloneindex].IMarkSACRoot[axis][ADDER][geomtype] = 
		    CloneErrorLookup[cloneindex].IMarkSACRoot[axis][ADDER][geomtype]->next;
		  free(temp);
		  break;  
		}
	      else
		{
		  prev->next = temp->next;
		  free(temp);
		  break;  
		}
	    }
	}
      prev = temp;
      temp=temp->next;
      num++;
    }
  return 1;
}


void ScrubModelIndices(int newdb, int nettype)
{
  int errnum,axis,k,j,start;

  if(newdb==0)
    {
      start = 1;
    }
  else
    {
      start = 0;
    }

  for(errnum=start;errnum<=CONDITION_DEFINITIONS;errnum++)
  {
	if(IsNetCheck(errnum)==nettype)
	{
      for(axis=0;axis<(3+1);axis++)
	  {
	    for(k=0;k<2;k++)
		{
	      for(j=0;j<NUM_C;j++)
		  {
		    ErrorLookup[errnum].model_index[axis][k][j] = 0;
		    ErrorLookup[errnum].sac_index[axis][k][j] = 0;
		  }
		}
	  }
    }
  }

  for(errnum=0;errnum<CLONE_DEFINITIONS;errnum++)
  {
	if(IsNetCheck(CloneErrorLookup[errnum].CloneNumber)==nettype)
	{
      for(axis=0;axis<(3+1);axis++)
	  {
	    for(k=0;k<2;k++)
	    {
	      for(j=0;j<NUM_C;j++)
		  {
		    CloneErrorLookup[errnum].model_index[axis][k][j] = 0;
		    CloneErrorLookup[errnum].sac_index[axis][k][j]   = 0;
		  }
		}
	  }
    }
  }
}


int PartitionbyValue(int num,int p,int r)
{
  int thisindex,thatindex, temp;
  int i,j;
  int allnumeric = 1;
  double tempvalue,dtemp,x;
  
  
  
  
  
  for(i=p;i<=r;i++)
    {
      
      

      thisindex = MdlNames[num].AttrIndices[i];
      thatindex = MdlNames[num].ValueIndices[i];
      
      
      
      if(MdlNames2[thisindex].values[thatindex].type==2)
	{
	  allnumeric = 0;
	  break;
	}
    }
  
  
  if(allnumeric==1)
    {
      thisindex = MdlNames[num].AttrIndices[p];
      thatindex = MdlNames[num].ValueIndices[p];
      
      if(MdlNames2[thisindex].values[thatindex].type !=2)
	{
	  x = MdlNames2[thisindex].values[thatindex].value;
	}
      else
	{
	  
	}
      
      i = p-1;
      j = r+1;
      while(1)
	{
	  do
	    {
	      j=j-1;
	      thisindex = MdlNames[num].AttrIndices[j];
	      thatindex = MdlNames[num].ValueIndices[j];
	      
	      if(MdlNames2[thisindex].values[thatindex].type != 2)
		{
		  tempvalue = MdlNames2[thisindex].values[thatindex].value;
		}
	      else
		{
		  
		}
	      
	    }
	  while(tempvalue>x);


	  do
	    {
	      i=i+1;
	      thisindex = MdlNames[num].AttrIndices[i];
	      thatindex = MdlNames[num].ValueIndices[i];
	      
	      if(MdlNames2[thisindex].values[thatindex].type != 2)
		{
		  tempvalue = MdlNames2[thisindex].values[thatindex].value;
		}
	      else
		{
		  
		}
	    }
	  while(tempvalue<x);
	  
	  
	  
	  if(i<j)
	    {
	      temp = MdlNames[num].ValueIndices[i];
	      MdlNames[num].ValueIndices[i] = MdlNames[num].ValueIndices[j];
	      MdlNames[num].ValueIndices[j] = temp;
	      
	      
	      
	      dtemp = MdlNames[num].ValueCounts[i];
	      MdlNames[num].ValueCounts[i] = MdlNames[num].ValueCounts[j];
	      MdlNames[num].ValueCounts[j] = dtemp;
	    }
	  else 
	    {
	      return j;
	    }
	} 
    } 
  
  
  else 
    {
      x = MdlNames[num].ValueIndices[p];
      
      i = p-1;
      j = r+1;
      while(1)
	{
	  do{j=j-1;}
	  while(MdlNames[num].ValueIndices[j]>x);
	  
	  do{i=i+1;}
	  while(MdlNames[num].ValueIndices[i]<x);
	  
	  if(i<j)
	    {
	      temp = MdlNames[num].ValueIndices[i];
	      MdlNames[num].ValueIndices[i] = MdlNames[num].ValueIndices[j];
	      MdlNames[num].ValueIndices[j] = temp;
	      
	      
	      
	      dtemp = MdlNames[num].ValueCounts[i];
	      MdlNames[num].ValueCounts[i] = MdlNames[num].ValueCounts[j];
	      MdlNames[num].ValueCounts[j] = dtemp;
	    }
	  else 
	    {
	      return j;
	    }
	} 
    } 
}




int PartitionbyAttr(int num,int p,int r)
{
  int x, temp;
  int i,j;
  double dtemp;

  x = MdlNames[num].AttrIndices[p];
  i = p-1;
  j = r+1;
  while(1)
    {
      do{j=j-1;}
      while(MdlNames[num].AttrIndices[j]>x);

      do{i=i+1;}
      while(MdlNames[num].AttrIndices[i]<x);
    
      if(i<j)
	{
	  temp = MdlNames[num].AttrIndices[i];
	  MdlNames[num].AttrIndices[i] = MdlNames[num].AttrIndices[j];
	  MdlNames[num].AttrIndices[j] = temp;


	  
	  temp = MdlNames[num].ValueIndices[i];
	  MdlNames[num].ValueIndices[i] = MdlNames[num].ValueIndices[j];
	  MdlNames[num].ValueIndices[j] = temp;

	  dtemp = MdlNames[num].ValueCounts[i];
	  MdlNames[num].ValueCounts[i] = MdlNames[num].ValueCounts[j];
	  MdlNames[num].ValueCounts[j] = dtemp;
	}
      else
	{
	  return j;
	}
    }
}



int PartitionbyUniqAttr(int num,int p,int r)
{
  int x, temp;
  int i,j;
  double dtemp;

  x = MdlNames[num].UniqueAttr[p];
  i = p-1;
  j = r+1;
  while(1)
    {
      do{j=j-1;}
      while(MdlNames[num].UniqueAttr[j]>x);

      do{i=i+1;}
      while(MdlNames[num].UniqueAttr[i]<x);
    
      if(i<j)
	{
	  temp = MdlNames[num].UniqueAttr[i];
	  MdlNames[num].UniqueAttr[i] = MdlNames[num].UniqueAttr[j];
	  MdlNames[num].UniqueAttr[j] = temp;


	  

	  dtemp = MdlNames[num].UniqueCounts[i];
	  MdlNames[num].UniqueCounts[i] = MdlNames[num].UniqueCounts[j];
	  MdlNames[num].UniqueCounts[j] = dtemp;
	}
      else
	{
	  return j;
	}
    }
}



void SortByUniqAttr(int num, int p,int r)
{
  

  int q;
  if(p<r)
    {
      q = PartitionbyUniqAttr(num,p,r);
      SortByUniqAttr(num,p,q);
      SortByUniqAttr(num,q+1,r);
    }
}


void SortByAttr(int num, int p,int r)
{
  

  int q;
  if(p<r)
    {
      q = PartitionbyAttr(num,p,r);
      SortByAttr(num,p,q);
      SortByAttr(num,q+1,r);
    }
}





void SortByValue(int num, int p,int r)
{
  

  int q;
  if(p<r)
    {
      q = PartitionbyValue(num,p,r);
      SortByValue(num,p,q);
      SortByValue(num,q+1,r);
    }
}






void SwapMdl2(int num,int i,int j)
{
  double tempoccurrences        = MdlNames2[num].values[j].occurrences;
  double tempuniqueoccurrences  = MdlNames2[num].values[j].uniqueoccurrences;
  double tempvalue           = MdlNames2[num].values[j].value;
  double tempvalue2          = MdlNames2[num].values[j].value2;
  int temptype               = MdlNames2[num].values[j].type;
  int tempintervaltype       = MdlNames2[num].values[j].intervaltype;
  int tempuom                = MdlNames2[num].values[j].uom;
  int tempscale              = MdlNames2[num].values[j].scale;
  char *templabel            = MdlNames2[num].values[j].label;
  int tempLLindexcount       = MdlNames2[num].values[j].LLindexcount;
  int *tempLongListIndices   = MdlNames2[num].values[j].LongListIndices;
  int tempUniqueLLindexcount = MdlNames2[num].values[j].UniqueLLindexcount;
  int *tempUniqueLLindices   = MdlNames2[num].values[j].UniqueLLindices;
  int ii,jj;
  

  MdlNames2[num].values[j].occurrences        = MdlNames2[num].values[i].occurrences;
  MdlNames2[num].values[j].uniqueoccurrences  = MdlNames2[num].values[i].uniqueoccurrences;
  MdlNames2[num].values[j].value              = MdlNames2[num].values[i].value;
  MdlNames2[num].values[j].value2             = MdlNames2[num].values[i].value2;
  MdlNames2[num].values[j].type               = MdlNames2[num].values[i].type;
  MdlNames2[num].values[j].intervaltype       = MdlNames2[num].values[i].intervaltype;
  MdlNames2[num].values[j].uom                = MdlNames2[num].values[i].uom;
  MdlNames2[num].values[j].scale              = MdlNames2[num].values[i].scale;
  MdlNames2[num].values[j].label              = MdlNames2[num].values[i].label;
  MdlNames2[num].values[j].LLindexcount       = MdlNames2[num].values[i].LLindexcount;
  MdlNames2[num].values[j].LongListIndices    = MdlNames2[num].values[i].LongListIndices;
  MdlNames2[num].values[j].UniqueLLindexcount = MdlNames2[num].values[i].UniqueLLindexcount;
  MdlNames2[num].values[j].UniqueLLindices    = MdlNames2[num].values[i].UniqueLLindices;

 
  MdlNames2[num].values[i].occurrences        = tempoccurrences;
  MdlNames2[num].values[i].uniqueoccurrences  = tempuniqueoccurrences;
  MdlNames2[num].values[i].value              = tempvalue;
  MdlNames2[num].values[i].value2             = tempvalue2;
  MdlNames2[num].values[i].type               = temptype;
  MdlNames2[num].values[i].intervaltype       = tempintervaltype;
  MdlNames2[num].values[i].uom                = tempuom;
  MdlNames2[num].values[i].scale              = tempscale;
  MdlNames2[num].values[i].label              = templabel;
  MdlNames2[num].values[i].LLindexcount       = tempLLindexcount;
  MdlNames2[num].values[i].LongListIndices    = tempLongListIndices;
  MdlNames2[num].values[i].UniqueLLindexcount = tempUniqueLLindexcount;
  MdlNames2[num].values[i].UniqueLLindices    = tempUniqueLLindices;

  
  

  
  
  
  for(ii=0;ii<NumberOfModels;ii++)
    {
      for(jj=0;jj<MdlNames[ii].numattributes;jj++)
	{
	  if(MdlNames[ii].AttrIndices[jj] == num)
	    {
	      
	      if(MdlNames[ii].ValueIndices[jj]==i)
		{
		  MdlNames[ii].ValueIndices[jj] = j;
		}
	      else if(MdlNames[ii].ValueIndices[jj]==j)
		{
		  MdlNames[ii].ValueIndices[jj] = i;
		}
	    }
	}
    } 
}


int PartitionMdl2(int num,int p,int r)
{
  int i,j;
  double x;

  x = MdlNames2[num].values[p].value;
  i = p-1;
  j = r+1;
  while(1)
    {
      do{j=j-1;}
      while(MdlNames2[num].values[j].value>x);

      do{i=i+1;}
      while(MdlNames2[num].values[i].value<x);
    
      if(i<j)
	  {
	    SwapMdl2(num,i,j);
	  }
      else
	{
	  return j;
	}
    }
}



void QSortMdl2(int num, int p,int r)
{
  

  int q;
  if(p<r)
    {
      q = PartitionMdl2(num,p,r);
      QSortMdl2(num,p,q);
      QSortMdl2(num,q+1,r);
    }
}




void CacheGrid(FILE *gridfile,long int flag)
{
  double Djunk;
  long int stime,etime;
  int i,Ijunk,xnum,ynum,datasize,chunk=1;
  char *ctest;
  short int *stest;
  unsigned short int *ustest;
  int *itest;
  unsigned int *uitest;
  float *ftest;
  double *dtest;

  

  stime = time(NULL);

  SEEIT_fread_int(&Ijunk,gridfile);
  while(!feof(gridfile))
  {
    SEEIT_fread_int(&Ijunk,gridfile);
    SEEIT_fread_double(&Djunk,gridfile);
    SEEIT_fread_double(&Djunk,gridfile);
    SEEIT_fread_double(&Djunk,gridfile);
    SEEIT_fread_double(&Djunk,gridfile);
    SEEIT_fread_int(&Ijunk,gridfile); 
    SEEIT_fread_int(&xnum,gridfile);
    SEEIT_fread_int(&ynum,gridfile);
    SEEIT_fread_int(&datasize, gridfile); 

	if((datasize==1)||(datasize==7))
	{
      ctest = (char *)malloc(sizeof(char)*ynum*chunk);
	  for(i=0;i<xnum;i=i+chunk)
	  {
        fread(&ctest[0],ynum*chunk,1,gridfile);
		TempGridsRead = TempGridsRead + ynum;

		if((flag>0)&&(i%100==0))
		{
          GridSigPercent = 100.0 * (double)TempGridsRead/(double)flag;
		  if(GridSigPercent>100.0)
		  {
            GridSigPercent = 100.0;
		  }
          InitializationAdvice(100.0,100.0,100.0,100.0,100.0,3);
		}
	  }
	  free(ctest);
	}
	else if(datasize==2)
	{
      stest = (short int *)malloc(sizeof(short int)*ynum*chunk);
	  for(i=0;i<xnum;i=i+chunk)
	  {
        fread(&stest[0],ynum*2*chunk,1,gridfile);
		TempGridsRead = TempGridsRead + ynum;

		if((flag>0)&&(i%100==0))
		{
          GridSigPercent = 100.0 * (double)TempGridsRead/(double)flag;
		  if(GridSigPercent>100.0)
		  {
            GridSigPercent = 100.0;
		  }
          InitializationAdvice(100.0,100.0,100.0,100.0,100.0,3);
		}
	  }
	  free(stest);
	}

	else if(datasize==3)
	{
      ustest = (unsigned short int *)malloc(sizeof(unsigned short int)*ynum*chunk);
	  for(i=0;i<xnum;i=i+chunk)
	  {
        fread(&ustest[0],ynum*2*chunk,1,gridfile);
		TempGridsRead = TempGridsRead + ynum;

		if((flag>0)&&(i%100==0))
		{
          GridSigPercent = 100.0 * (double)TempGridsRead/(double)flag;
		  if(GridSigPercent>100.0)
		  {
            GridSigPercent = 100.0;
		  }
          InitializationAdvice(100.0,100.0,100.0,100.0,100.0,3);
		}
	  }
	  free(ustest);
	}



	else if(datasize==4)
	{
      itest = (int *)malloc(sizeof(int)*ynum*chunk);
	  for(i=0;i<xnum;i=i+chunk)
	  {
        fread(&itest[0],ynum*4*chunk,1,gridfile);
		TempGridsRead = TempGridsRead + ynum;

		if((flag>0)&&(i%100==0))
		{
          GridSigPercent = 100.0 * (double)TempGridsRead/(double)flag;
		  if(GridSigPercent>100.0)
		  {
            GridSigPercent = 100.0;
		  }
          InitializationAdvice(100.0,100.0,100.0,100.0,100.0,3);
		}
	  }
	  free(itest);
	}

	else if(datasize==5)
	{
      uitest = (unsigned int *)malloc(sizeof(unsigned int)*ynum*chunk);
	  for(i=0;i<xnum;i=i+chunk)
	  {
        fread(&uitest[0],ynum*4*chunk,1,gridfile);
		TempGridsRead = TempGridsRead + ynum;

		if((flag>0)&&(i%100==0))
		{
          GridSigPercent = 100.0 * (double)TempGridsRead/(double)flag;
		  if(GridSigPercent>100.0)
		  {
            GridSigPercent = 100.0;
		  }
          InitializationAdvice(100.0,100.0,100.0,100.0,100.0,3);
		}
	  }
	  free(uitest);
	}

	else if(datasize==6)
	{
      ftest = (float *)malloc(sizeof(float)*ynum*chunk);
	  for(i=0;i<xnum;i=i+chunk)
	  {
        fread(&ftest[0],ynum*4*chunk,1,gridfile);
		TempGridsRead = TempGridsRead + ynum;

		if((flag>0)&&(i%100==0))
		{
          GridSigPercent = 100.0 * (double)TempGridsRead/(double)flag;
		  if(GridSigPercent>100.0)
		  {
            GridSigPercent = 100.0;
		  }
          InitializationAdvice(100.0,100.0,100.0,100.0,100.0,3);
		}
	  }
	  free(ftest);
	}


	else if(datasize==9)
	{
      dtest = (double *)malloc(sizeof(double)*ynum*chunk);
	  for(i=0;i<xnum;i=i+chunk)
	  {
        fread(&dtest[0],ynum*8*chunk,1,gridfile);
		TempGridsRead = TempGridsRead + ynum;

		if((flag>0)&&(i%100==0))
		{
          GridSigPercent = 100.0 * (double)TempGridsRead/(double)flag;
		  if(GridSigPercent>100.0)
		  {
            GridSigPercent = 100.0;
		  }
          InitializationAdvice(100.0,100.0,100.0,100.0,100.0,3);
		}
	  }
	  free(dtest);
	}


	else
	{
       printf("bad datasize %d\n",datasize);
	   exit(1);
	}


    SEEIT_fread_int(&Ijunk,gridfile);
  }

  etime = time(NULL);

  
}


void CacheGrids()
{
  FILE *headfile;
  double MINYREAD, MINXREAD, MAXYREAD, MAXXREAD, MINY_P_READ, MINX_P_READ, MAXY_P_READ, MAXX_P_READ;
  long int POINT_POINTSREAD, LINEAR_POINTSREAD, AREAL_POINTSREAD;
  unsigned int TERRAINPOLYSREAD,GRIDPOINTSREAD;
  int i,Ijunk,GRIDSREAD, coordflag, num_long_entries,num_short_entries;
  char temp[1000];


  sprintf(temp,"%sheader.txt",indirectory);

  headfile = fopen(temp,"r");
  if(headfile==NULL)
    {
      printf("Couldnt open %s for read.\n",temp); 
	  XBell(mydisplay,50);
      return;
    }
  
  fscanf(headfile,"%d %lf %lf %lf %lf %lf %lf %lf %lf %u %u %ld %ld %ld %d %d %d\n",
	 &coordflag,
	 &MINXREAD,&MINYREAD,&MAXXREAD,&MAXYREAD,
	 &MINX_P_READ,&MINY_P_READ,&MAXX_P_READ,&MAXY_P_READ,
	 &TERRAINPOLYSREAD,
	 &GRIDPOINTSREAD,&POINT_POINTSREAD,&LINEAR_POINTSREAD,&AREAL_POINTSREAD,&GRIDSREAD,
	 &num_long_entries,&num_short_entries);

  fclose(headfile);













  sprintf(temp,"%smultiinfo.txt",indirectory);
  headfile = fopen(temp,"r");
  if(headfile==NULL)
    {
      printf("Couldnt open %s for read.\n",temp); 
	  XBell(mydisplay,50);
      return;
    }
  
  fscanf(headfile,"%d",&Ijunk);  
  fscanf(headfile,"%d",&Ijunk);  
  fscanf(headfile,"%d",&Ijunk);  
  fscanf(headfile,"%d",&Ijunk);  
  fclose(headfile);


  TempGridsRead = 0;

  for(i=0;i<Ijunk;i++)
  {
    if(i==0)
	{
      sprintf(temp,"%sgrid.bin",indirectory);
	}
	else
	{
      sprintf(temp,"%sgrid%d.bin",indirectory,i+1);
	}

    headfile = fopen(temp,"rb");
    if(headfile==NULL)
    {
      printf("Couldnt open %s for read...no gridded data in this project\n",temp); 
	  
      return;
    }

	CacheGrid(headfile,GRIDPOINTSREAD);

	fclose(headfile);
   }
}




void SortMdl2()
{
  char tempending[20];
  int SAC,i,allnumeric=0,nosort=0;


  
  i = strlen(indirectory);
  if(i>5)
  {
	sprintf(tempending,"%s",&indirectory[i-5]);
	if(!strcmp(tempending,"-all\\"))
	{
	  printf("not doing extra attribute sorting\n");
	  nosort = 1;
	}
  }


  GridSigPercent = 0.0;
 
  CacheGrids();

  GridSigPercent = 100.0;

  for(SAC=0;SAC<NumberOfAttributesEntries;SAC++)
    {
      FinalSortPercent = ((double)((double)SAC/(double)NumberOfAttributesEntries))*100.0;

      InitializationAdvice(100.0,100.0,100.0,100.0,100.0,3);

      for(i=0;i<MdlNames2[SAC].count;i++)
	{
	  allnumeric = 1;
	  
	  if(MdlNames2[SAC].values[i].uniqueoccurrences > 0)
	    {
	      
	      
  	      if(MdlNames2[SAC].values[i].type==2)
		{ 
		  
		  
		  allnumeric = 0;
		  break;
		}
	    } 
	}
      if((allnumeric==1)&&(nosort==0))
	{
	  
      if(MdlNames2[SAC].count<MAX_SORT_COUNT)
	  {
	    QSortMdl2(SAC,0,MdlNames2[SAC].count-1);
	  }
	  else
	  {
		
        printf("NS: %s (%d)\n",GetEACLabel(MdlNames2[SAC].code),MdlNames2[SAC].count);
	  }
	}
    }
 FinalSortPercent = 0.0; 
}


char *GetAREAName()
{
  extern int GetAttrIndex(char *eac);
  
  if((ATTRTYPE_D4()))
    {
      return GetEACLabel(GetAttrIndex("ARE_"));
    }
  else if((ATTRTYPE_FACC()))
    {
      return GetEACLabel(GetAttrIndex("ARE"));
    }
  else if((ATTRTYPE_VMAP()))
    {
      return GetEACLabel(GetAttrIndex("ARA"));
    }
  else if(ATTRTYPE_MGCP3())
    {
      return GetEACLabel(GetAttrIndex("ARA"));
    }
  else if(ATTRTYPE_MGCP4())
    {
      return "";  
    }
   else if((ATTRTYPE_UFD2()))
    {
      return "";  
    }
   else if((ATTRTYPE_UFD1()))
    {
      return "";  
    }
  else if((ATTRTYPE_UFD3()))
    {
      return "";  
    }
  else if((ATTRTYPE_TDS4())||(ATTRTYPE_TDS5())||(ATTRTYPE_TDS6()))
    {
      return GetEACLabel(GetAttrIndex("ARA"));
    }
  else if((ATTRTYPE_NFDD()))
    {
      return GetEACLabel(GetAttrIndex("ARA"));
    }
  else if((ATTRTYPE_DFDD()))
    {
      return GetEACLabel(GetAttrIndex("ARA"));
    }
  else if((ATTRTYPE_SAC()))
    {
      return GetEACLabel(GetAttrIndex("ARA"));
    }
  else if((ATTRTYPE_ANY_GGDM()))
    {
      return GetEACLabel(GetAttrIndex("ARA"));
    }
  else
    {
      printf("error: bad attr_type in GArN: %d\n",ATTRIBUTION_TYPE);
      return "error";
    }
}


int GetAREACode()
{
  extern int GetAttrIndex(char *eac);
  
  if((ATTRTYPE_D4()))
    {
      return GetAttrIndex("ARE_");
    }
  else if((ATTRTYPE_FACC()))
    {
      return GetAttrIndex("ARE");
    }
  else if((ATTRTYPE_VMAP()))
    {
      return GetAttrIndex("ARA");
    }
  else if(ATTRTYPE_MGCP3())
    {
      return GetAttrIndex("ARA");
    }
  else if(ATTRTYPE_MGCP4())
    {
      return -1;
    }
  else if((ATTRTYPE_UFD2()))
    {
      return -1;
    }
  else if((ATTRTYPE_UFD1()))
    {
      return -1;
    }
  else if((ATTRTYPE_UFD3()))
    {
      return -1;
    }
  else if((ATTRTYPE_TDS4())||(ATTRTYPE_TDS5())||(ATTRTYPE_TDS6()))
    {
      return GetAttrIndex("ARA");
    }
  else if((ATTRTYPE_NFDD()))
    {
      return GetAttrIndex("ARA");
    }
  else if((ATTRTYPE_DFDD()))
    {
      return GetAttrIndex("ARA");
    }
  else if((ATTRTYPE_SAC()))
    {
      return GetAttrIndex("ARA");
    }
  else if((ATTRTYPE_ANY_GGDM()))
    {
      return GetAttrIndex("ARA");
    }
  else
    {
      printf("error: bad attr_type in GArC: %d\n",ATTRIBUTION_TYPE);
      return 1;
    }
}


char *GetHGTName()
{
  extern int GetAttrIndex(char *eac);

  if((ATTRIBUTION_TYPE>=1)&&(ATTRIBUTION_TYPE<=54))
    {
      return GetEACLabel(GetAttrIndex("HGT"));
    }
  else
    {
      printf("error: bad attr_type in GHN: %d\n",ATTRIBUTION_TYPE);
      return "error";
    }
}


int GetHGTCode()
{
  extern int GetAttrIndex(char *eac);

  if((ATTRIBUTION_TYPE>=1)&&(ATTRIBUTION_TYPE<=54))
    {
      return GetAttrIndex("HGT");
    }
  else
    {
      printf("error: bad attr_type in GHC: %d\n",ATTRIBUTION_TYPE);
      return 1;
    }
}






char *GetLENName()
{
  extern int GetAttrIndex(char *eac);

  if(ATTRTYPE_D4())      {return GetEACLabel(GetAttrIndex("LEN_"));}
  if(ATTRTYPE_FACC())    {return GetEACLabel(GetAttrIndex("LEN"));}
  if(ATTRTYPE_VMAP())    {return GetEACLabel(GetAttrIndex("LEN"));}
  if(ATTRTYPE_MGCP3())   {return GetEACLabel(GetAttrIndex("LEN"));}
  if(ATTRTYPE_MGCP4())   {return GetEACLabel(GetAttrIndex("LEN"));}
  if(ATTRTYPE_UFD2())    {return GetEACLabel(GetAttrIndex("LEN"));}
  if(ATTRTYPE_UFD1())    {return GetEACLabel(GetAttrIndex("LEN"));}
  if(ATTRTYPE_UFD3())    {return GetEACLabel(GetAttrIndex("LEN"));}
  if(ATTRTYPE_ANY_TDS()) {return GetEACLabel(GetAttrIndex("LZN"));}
  if(ATTRTYPE_NFDD())    {return GetEACLabel(GetAttrIndex("LZN"));}
  if(ATTRTYPE_DFDD())    {return GetEACLabel(GetAttrIndex("LEN"));}
  if(ATTRTYPE_SAC())     {return GetEACLabel(GetAttrIndex("LEN"));}
  if(ATTRTYPE_ANY_GGDM()){return GetEACLabel(GetAttrIndex("LZN"));}

  printf("error: bad attr_type in GLN: %d\n",ATTRIBUTION_TYPE);
  return "error";
}


int GetLENCode()
{
  extern int GetAttrIndex(char *eac);


  if(ATTRTYPE_D4())      {return GetAttrIndex("LEN_");}
  if(ATTRTYPE_FACC())    {return GetAttrIndex("LEN");}
  if(ATTRTYPE_VMAP())    {return GetAttrIndex("LEN");}
  if(ATTRTYPE_MGCP3())   {return GetAttrIndex("LEN");}
  if(ATTRTYPE_MGCP4())   {return GetAttrIndex("LEN");}
  if(ATTRTYPE_UFD2())    {return GetAttrIndex("LEN");}
  if(ATTRTYPE_UFD1())    {return GetAttrIndex("LEN");}
  if(ATTRTYPE_UFD3())    {return GetAttrIndex("LEN");}
  if(ATTRTYPE_ANY_TDS()) {return GetAttrIndex("LZN");}
  if(ATTRTYPE_NFDD())    {return GetAttrIndex("LZN");}
  if(ATTRTYPE_DFDD())    {return GetAttrIndex("LEN");}
  if(ATTRTYPE_SAC())     {return GetAttrIndex("LEN");}
  if(ATTRTYPE_ANY_GGDM()){return GetAttrIndex("LZN");}

  printf("error: bad attr_type in GLC: %d\n",ATTRIBUTION_TYPE);
  return 1;

}





char *GetNAMName()
{
  extern int GetAttrIndex(char *eac);


  if(ATTRTYPE_D4())      {return GetEACLabel(GetAttrIndex("NAM"))  ;}
  if(ATTRTYPE_FACC())    {return GetEACLabel(GetAttrIndex("NAM"))  ;}
  if(ATTRTYPE_VMAP())    {return GetEACLabel(GetAttrIndex("NAM"))  ;}
  if(ATTRTYPE_MGCP3())   {return GetEACLabel(GetAttrIndex("NAM"))  ;}
  if(ATTRTYPE_MGCP4())   {return GetEACLabel(GetAttrIndex("NAM"))  ;}
  if(ATTRTYPE_UFD2())    {return GetEACLabel(GetAttrIndex("NAM"))  ;}
  if(ATTRTYPE_UFD1())    {return GetEACLabel(GetAttrIndex("NAM"))  ;}
  if(ATTRTYPE_UFD3())    {return GetEACLabel(GetAttrIndex("NAM"))  ;}
  if(ATTRTYPE_ANY_TDS()) {return GetEACLabel(GetAttrIndex("ZI005_FNA"));}
  if(ATTRTYPE_DFDD())    {return GetEACLabel(GetAttrIndex("NAM"));}
  if(ATTRTYPE_ANY_GGDM()){return GetEACLabel(GetAttrIndex("ZI005_FNA"));}

  if(ATTRTYPE_SAC())     {return "";}
  if(ATTRTYPE_NFDD())    {return "";}

  printf("error: bad attr_type in GNN: %d\n",ATTRIBUTION_TYPE);
  return "error";
}


int GetNAMCode()
{
  extern int GetAttrIndex(char *eac);

  if(ATTRTYPE_D4())      {return GetAttrIndex("NAM")      ;}
  if(ATTRTYPE_FACC())    {return GetAttrIndex("NAM")      ;}
  if(ATTRTYPE_VMAP())    {return GetAttrIndex("NAM")      ;}
  if(ATTRTYPE_MGCP3())   {return GetAttrIndex("NAM")      ;}
  if(ATTRTYPE_MGCP4())   {return GetAttrIndex("NAM")      ;}
  if(ATTRTYPE_UFD2())    {return GetAttrIndex("NAM")      ;}
  if(ATTRTYPE_UFD1())    {return GetAttrIndex("NAM")      ;}
  if(ATTRTYPE_UFD3())    {return GetAttrIndex("NAM")      ;}
  if(ATTRTYPE_ANY_TDS()) {return GetAttrIndex("ZI005_FNA");}
  if(ATTRTYPE_DFDD())    {return GetAttrIndex("NAM")      ;}
  if(ATTRTYPE_ANY_GGDM()){return GetAttrIndex("ZI005_FNA");}

  if(ATTRTYPE_SAC())     {return -1;}
  if(ATTRTYPE_NFDD())    {return -1;}

  printf("error: bad attr_type in GNC: %d\n",ATTRIBUTION_TYPE);
  return 1;
}




char *GetIDName()
{
  extern int GetAttrIndex(char *eac);
  
  if((ATTRTYPE_D4()))
    {
      return GetEACLabel(GetAttrIndex("GFID"));
    }
  else if((ATTRTYPE_FACC()))
    {
      return GetEACLabel(GetAttrIndex("FLDBID"));
    }
  else if((ATTRTYPE_VMAP()))
    {
      return "";
    }
  else if((ATTRTYPE_MGCP3())||(ATTRTYPE_MGCP4()))
    {
      return GetEACLabel(GetAttrIndex("UID"));
    }
  else if((ATTRTYPE_UFD2()))
    {
      return GetEACLabel(GetAttrIndex("GFID"));
    }
  else if((ATTRTYPE_UFD1()))
    {
      return GetEACLabel(GetAttrIndex("GFID"));
    }
  else if((ATTRTYPE_UFD3()))
    {
      return GetEACLabel(GetAttrIndex("GFID"));
    }
  else if((ATTRTYPE_TDS4())||(ATTRTYPE_TDS5())||(ATTRTYPE_TDS6()))
    {
      return GetEACLabel(GetAttrIndex("UFI"));
    }
  else if((ATTRTYPE_NFDD()))
    {
      return GetEACLabel(GetAttrIndex("UFI"));
    }
  else if((ATTRTYPE_DFDD()))
    {
      return GetEACLabel(GetAttrIndex("UID"));
    }
  else if((ATTRTYPE_SAC()))
    {
      return GetEACLabel(GetAttrIndex("UUID_1"));
    }
  else if((ATTRTYPE_ANY_GGDM()))
    {
      return GetEACLabel(GetAttrIndex("UFI"));
    }
 else
    {
      printf("error: bad attr_type in GIDN: %d\n",ATTRIBUTION_TYPE);
      return "error";
    }
}


int GetIDCode()
{
  extern int GetAttrIndex(char *eac);
  
  if((ATTRTYPE_D4()))
    {
      return GetAttrIndex("GFID");
    }
  else if((ATTRTYPE_FACC()))
    {
      return GetAttrIndex("FLDBID");
    }
  else if((ATTRTYPE_VMAP()))
    {
      return -1;
    }
  else if((ATTRTYPE_MGCP3())||(ATTRTYPE_MGCP4()))
    {
      return GetAttrIndex("UID");
    }
  else if((ATTRTYPE_UFD2()))
    {
      return GetAttrIndex("GFID");
    }
  else if((ATTRTYPE_UFD1()))
    {
      return GetAttrIndex("GFID");
    }
  else if((ATTRTYPE_UFD3()))
    {
      return GetAttrIndex("GFID");
    }
  else if((ATTRTYPE_TDS4())||(ATTRTYPE_TDS5())||(ATTRTYPE_TDS6()))
    {
      return GetAttrIndex("UFI");
    }
  else if((ATTRTYPE_NFDD()))
    {
      return GetAttrIndex("UFI");
    }
  else if((ATTRTYPE_DFDD()))
    {
      return GetAttrIndex("UID");
    }
  else if((ATTRTYPE_SAC()))
    {
      return GetAttrIndex("UUID_1");
    }
  else if((ATTRTYPE_ANY_GGDM()))
    {
      return GetAttrIndex("UFI");
    }
  else
    {
      printf("error: bad attr_type in GIDC: %d\n",ATTRIBUTION_TYPE);
      return 1;
    }
}







char *GetZVName()
{
  extern int GetAttrIndex(char *eac);
  
  if((ATTRTYPE_D4()))
    {
      return GetEACLabel(GetAttrIndex("ZV2"));
    }
  else if((ATTRTYPE_FACC()))
    {
      return GetEACLabel(GetAttrIndex("ZV2"));
    }
  else if((ATTRTYPE_VMAP()))
    {
      return GetEACLabel(GetAttrIndex("ZV2"));
    }
  else if((ATTRTYPE_MGCP3())||(ATTRTYPE_MGCP4()))
    {
      return "";
    }
  else if((ATTRTYPE_UFD2()))
    {
      return GetEACLabel(GetAttrIndex("ZV2"));
    }
  else if((ATTRTYPE_UFD1()))
    {
      return GetEACLabel(GetAttrIndex("ZV2"));
    }
  else if((ATTRTYPE_UFD3()))
    {
      return GetEACLabel(GetAttrIndex("ZV2"));
    }
  else if((ATTRTYPE_TDS4())||(ATTRTYPE_TDS5())||(ATTRTYPE_TDS6()))
    {
      return GetEACLabel(GetAttrIndex("ZVH"));
    }
  else if((ATTRTYPE_NFDD()))
    {
      return GetEACLabel(GetAttrIndex("ZVH"));
    }
  else if((ATTRTYPE_DFDD()))
    {
      return GetEACLabel(GetAttrIndex("ZVH"));
    }
  else if((ATTRTYPE_SAC()))
    {
      return GetEACLabel(GetAttrIndex("ZV7"));
    }
  else if((ATTRTYPE_ANY_GGDM()))
    {
      return GetEACLabel(GetAttrIndex("ZVH"));
    }
  else
    {
      printf("error: bad attr_type in GZVN: %d\n",ATTRIBUTION_TYPE);
      return "error";
    }
}


int GetZVCode()
{
  extern int GetAttrIndex(char *eac);
  
  if((ATTRTYPE_D4()))
    {
      return GetAttrIndex("ZV2");
    }
  else if((ATTRTYPE_FACC()))
    {
      return GetAttrIndex("ZV2");
    }
  else if((ATTRTYPE_VMAP()))
    {
      return GetAttrIndex("ZV2");
    }
  else if((ATTRTYPE_MGCP3())||(ATTRTYPE_MGCP4()))
    {
      return -1;
    }
  else if((ATTRTYPE_UFD2()))
    {
      return GetAttrIndex("ZV2");
    }
  else if((ATTRTYPE_UFD1()))
    {
      return GetAttrIndex("ZV2");
    }
  else if((ATTRTYPE_UFD3()))
    {
      return GetAttrIndex("ZV2");
    }
  else if((ATTRTYPE_TDS4())||(ATTRTYPE_TDS5())||(ATTRTYPE_TDS6()))
    {
      return GetAttrIndex("ZVH");
    }
  else if((ATTRTYPE_NFDD()))
    {
      return GetAttrIndex("ZVH");
    }
  else if((ATTRTYPE_DFDD()))
    {
      return GetAttrIndex("ZVH");
    }
  else if((ATTRTYPE_SAC()))
    {
      return GetAttrIndex("ZV7");
    }
  else if((ATTRTYPE_ANY_GGDM()))
    {
      return GetAttrIndex("ZVH");
    }
  else
    {
      printf("error: bad attr_type in GZVC: %d\n",ATTRIBUTION_TYPE);
      return 1;
    }
}



char *GetZVCode2()
{
  extern int GetAttrIndex(char *eac);
  
  if((ATTRTYPE_D4()))
    {
      return "ZV2";
    }
  else if((ATTRTYPE_FACC()))
    {
      return "ZV2";
    }
  else if((ATTRTYPE_VMAP()))
    {
      return "ZV2";
    }
  else if((ATTRTYPE_MGCP3())||(ATTRTYPE_MGCP4()))
    {
      return "";
    }
  else if((ATTRTYPE_UFD2()))
    {
      return "ZV2";
    }
  else if((ATTRTYPE_UFD1()))
    {
      return "ZV2";
    }
  else if((ATTRTYPE_UFD3()))
    {
      return "ZV2";
    }
  else if((ATTRTYPE_TDS4())||(ATTRTYPE_TDS5())||(ATTRTYPE_TDS6()))
    {
      return "ZVH";
    }
  else if((ATTRTYPE_NFDD()))
    {
      return "ZVH";
    }
  else if((ATTRTYPE_DFDD()))
    {
      return "ZVH";
    }
  else if((ATTRTYPE_SAC()))
    {
      return "ZV7";
    }
  else if((ATTRTYPE_ANY_GGDM()))
    {
      return "ZVH";
    }
  else
    {
      printf("error: bad attr_type in GZVC2: %d\n",ATTRIBUTION_TYPE);
      return "";
    }
}


int GetNumLongAttr(int type, int override)
{
  FILE *thisfile;
  short int thisflag;
  int thisfid=0,totalnum=0,lindex,ecc,geom;
  long int Ljunk;

  
  thisfile = GetLongAttrFilePtr(1,type);
  if(thisfile==NULL)
    {
      return NOTYPE;
    }
  
  
  SEEIT_fread_short(&thisflag,thisfile);
  while(!feof(thisfile))
    {
      if(thisflag!=0) 
	{
	  lindex = LLFidTable[thisfid];
	  
	  if(lindex>=0)  
	    {
	      
	      if(override==1)
		{
		  ecc    = SCCtable[CrsWlk[lindex].LtoSmapping].ECC;
		  geom   = CrsWlk[lindex].geomtype;
		  
		  if(type==LONG_ATTR_AREA)
		    {
		      SaveLongCountsArea[geom][ecc] = SaveLongCountsArea[geom][ecc] + 1;
		    }
		  else if(type==LONG_ATTR_HGT)
		    {
		      SaveLongCountsHgt[geom][ecc]  = SaveLongCountsHgt[geom][ecc] + 1;
		    }
		  else if(type==LONG_ATTR_LEN)
		    {
		      SaveLongCountsLen[geom][ecc]  = SaveLongCountsLen[geom][ecc] + 1;
		    }
		  else if(type==LONG_ATTR_NAM)
		    {
		      SaveLongCountsNam[geom][ecc]  = SaveLongCountsNam[geom][ecc] + 1;
		    }
		  else if(type==LONG_ATTR_ID)
		    {
		      SaveLongCountsId[geom][ecc]   = SaveLongCountsId[geom][ecc] + 1;
		    }
		  else if(type==LONG_ATTR_ZV2)
		    {
		      SaveLongCountsZv2[geom][ecc]  = SaveLongCountsZv2[geom][ecc] + 1;
		    }
		  else
		    {
		      printf("bad long attr %d to GNLA\n",type);
		      ExitWrapper(-1);;
		    }
		}
	      totalnum = totalnum + 1; 
	    }
	}
      thisfid = thisfid + 1;
      SEEIT_fread_long (&Ljunk,thisfile);
      SEEIT_fread_short(&thisflag,thisfile);
    }
  
  
  fclose(thisfile);

  return totalnum;
}



int GetGeom(char *inname)
{

  if(!strcmp(inname,"(POINT)"))
    {
      return C_POFE;
    }

  if(!strcmp(inname,"(LINE)"))
    {
      return C_LINE;
    }

  if(!strcmp(inname,"(AREA)"))
    {
      return C_AREA;
    }

  

  return C_NONE;
}



void AddLongAttrToMdl(int type, int numvalues,int attrcode, char *attrname)
{
  int i,ii,jj,saveindex,SAC,ecc,geom;


  if(attrcode<0)
    {
      printf("bad attr code in ALATM %d %d\n",type,attrcode);
      printf("%s\n",attrname);
      return;
    }
  
  if(strlen(attrname)<1)
    {
      printf("bad attr name in ALATM %d %d\n",type,attrcode);
      printf("%s\n",attrname);
      return;
    }
  
  saveindex = 0;
  for(SAC=0;SAC<NumberOfAttributesEntries;SAC++)
    {

      if(strcmp(GetEACLabel(MdlNames2[SAC].code),attrname)<0)
	{
	  
	}
      else
	{
	  saveindex = SAC;
	  break;
	}
    }
  
  NumberOfAttributesEntries = NumberOfAttributesEntries + 1;
  
  
  
  MdlNames2 = (struct AttrList *) realloc(MdlNames2, NumberOfAttributesEntries * sizeof(struct AttrList));
  
  for(i=NumberOfAttributesEntries-1;i>saveindex;i--)
    {
      MdlNames2[i] = MdlNames2[i-1];
    }
  

  MdlNames2[saveindex].code        = attrcode;
  MdlNames2[saveindex].occurrences = (double) numvalues;
  MdlNames2[saveindex].count       = -1;  
  MdlNames2[saveindex].values      = NULL;
  
  

  for(ii=0;ii<NumberOfModels;ii++)
    {

      for(jj=0;jj<MdlNames[ii].numattributes;jj++)
	{
	  if(MdlNames[ii].AttrIndices[jj] >= saveindex)
	    {
	      MdlNames[ii].AttrIndices[jj] = MdlNames[ii].AttrIndices[jj] + 1;
	    }
	}
      
      
      for(jj=0;jj<MdlNames[ii].numuniqueAttr;jj++)
	{ 
	  if(MdlNames[ii].UniqueAttr[jj] >= saveindex)
	    {
	      MdlNames[ii].UniqueAttr[jj] = MdlNames[ii].UniqueAttr[jj] + 1;
	    }	  
	}


      


      ecc  = MdlNames[ii].code;
      geom = GetGeom(MdlNames[ii].name);

	  if((geom==C_GRID)||(geom==C_NONE))
	  {
		  continue;
	  }

      
      if(type==LONG_ATTR_AREA)
	{
	  if(SaveLongCountsArea[geom][ecc]>0)
	    {
	      MdlNames[ii].numuniqueAttr   = MdlNames[ii].numuniqueAttr + 1;
	      MdlNames[ii].UniqueAttr      = (int *)realloc(MdlNames[ii].UniqueAttr,  SzI * MdlNames[ii].numuniqueAttr);
	      MdlNames[ii].UniqueCounts    = (double *)realloc(MdlNames[ii].UniqueCounts,SzD * MdlNames[ii].numuniqueAttr);
	      MdlNames[ii].UniqueAttr  [MdlNames[ii].numuniqueAttr-1]  = saveindex;
	      MdlNames[ii].UniqueCounts[MdlNames[ii].numuniqueAttr-1]  = SaveLongCountsArea[geom][ecc];
	    }
	}
      else if(type==LONG_ATTR_HGT)
	{
	  if(SaveLongCountsHgt[geom][ecc]>0)
	    {
	      MdlNames[ii].numuniqueAttr   = MdlNames[ii].numuniqueAttr + 1;
	      MdlNames[ii].UniqueAttr      = (int *)realloc(MdlNames[ii].UniqueAttr,  SzI * MdlNames[ii].numuniqueAttr);
	      MdlNames[ii].UniqueCounts    = (double *)realloc(MdlNames[ii].UniqueCounts,SzD * MdlNames[ii].numuniqueAttr);
	      MdlNames[ii].UniqueAttr  [MdlNames[ii].numuniqueAttr-1]  = saveindex;
	      MdlNames[ii].UniqueCounts[MdlNames[ii].numuniqueAttr-1]  = SaveLongCountsHgt[geom][ecc];
	    }
	}

      else if(type==LONG_ATTR_LEN)
	{
	  if(SaveLongCountsLen[geom][ecc]>0)
	    {
	      MdlNames[ii].numuniqueAttr   = MdlNames[ii].numuniqueAttr + 1;
	      MdlNames[ii].UniqueAttr      = (int *)realloc(MdlNames[ii].UniqueAttr,  SzI * MdlNames[ii].numuniqueAttr);
	      MdlNames[ii].UniqueCounts    = (double *)realloc(MdlNames[ii].UniqueCounts,SzD * MdlNames[ii].numuniqueAttr);
	      MdlNames[ii].UniqueAttr  [MdlNames[ii].numuniqueAttr-1]  = saveindex;
	      MdlNames[ii].UniqueCounts[MdlNames[ii].numuniqueAttr-1]  = SaveLongCountsLen[geom][ecc];
	    }
	}
      else if(type==LONG_ATTR_NAM)
	{
	  if(SaveLongCountsNam[geom][ecc]>0)
	    {
	      MdlNames[ii].numuniqueAttr   = MdlNames[ii].numuniqueAttr + 1;
	      MdlNames[ii].UniqueAttr      = (int *)realloc(MdlNames[ii].UniqueAttr,  SzI * MdlNames[ii].numuniqueAttr);
	      MdlNames[ii].UniqueCounts    = (double *)realloc(MdlNames[ii].UniqueCounts,SzD * MdlNames[ii].numuniqueAttr);
	      MdlNames[ii].UniqueAttr  [MdlNames[ii].numuniqueAttr-1]  = saveindex;
	      MdlNames[ii].UniqueCounts[MdlNames[ii].numuniqueAttr-1]  = SaveLongCountsNam[geom][ecc];
	    }
	}
      else if(type==LONG_ATTR_ID)
	{
	  if(SaveLongCountsId[geom][ecc]>0)
	    {
	      MdlNames[ii].numuniqueAttr   = MdlNames[ii].numuniqueAttr + 1;
	      MdlNames[ii].UniqueAttr      = (int *)realloc(MdlNames[ii].UniqueAttr,  SzI * MdlNames[ii].numuniqueAttr);
	      MdlNames[ii].UniqueCounts    = (double *)realloc(MdlNames[ii].UniqueCounts,SzD * MdlNames[ii].numuniqueAttr);
	      MdlNames[ii].UniqueAttr  [MdlNames[ii].numuniqueAttr-1]  = saveindex;
	      MdlNames[ii].UniqueCounts[MdlNames[ii].numuniqueAttr-1]  = SaveLongCountsId[geom][ecc];
	    }
	}
      else if(type==LONG_ATTR_ZV2)
	{
	  if(SaveLongCountsZv2[geom][ecc]>0)
	    {
	      MdlNames[ii].numuniqueAttr   = MdlNames[ii].numuniqueAttr + 1;
	      MdlNames[ii].UniqueAttr      = (int *)realloc(MdlNames[ii].UniqueAttr,  SzI * MdlNames[ii].numuniqueAttr);
	      MdlNames[ii].UniqueCounts    = (double *)realloc(MdlNames[ii].UniqueCounts,SzD * MdlNames[ii].numuniqueAttr);
	      MdlNames[ii].UniqueAttr  [MdlNames[ii].numuniqueAttr-1]  = saveindex;
	      MdlNames[ii].UniqueCounts[MdlNames[ii].numuniqueAttr-1]  = SaveLongCountsZv2[geom][ecc];
	    }
	}

    }
}



int GetParticularFID(int num)
{
  FILE *infile;
  char infilename[1000];
  int answer;

  if((num>=LLFidTableCount)||(num<0))
  {
	printf("bad value %d/%d to GPF\n",num,LLFidTableCount);
	return -1;
  }

  sprintf(infilename,"%sfidmap.bin",indirectory);
  infile = fopen(infilename,"rb");
  if(infile==NULL)
  {
    XBell(mydisplay,50);
    printf("could not open %s\n",infilename);
    return -1;
  }

  fseek(infile,SzI*num,SEEK_SET);

  SEEIT_fread_int(&answer,infile);
  fclose(infile);

  return answer;
}




void BuildFIDTable(int override, int size)
{
  FILE *infile;
  char infilename[1000];
  int num,thisnum;
  
  if(FidFidTable!=NULL)
    {
      free(FidFidTable);
      FidFidTable = NULL;
    }
  
  sprintf(infilename,"%sfidmap.bin",indirectory);
  infile = fopen(infilename,"rb");
  if(infile==NULL)
  {
    XBell(mydisplay,50);
    printf("could not open %s\n",infilename);
    return;
  }
 
  if(LLFidTableCount==0)
  {
	return;
  }

  FidFidTable = (int *)malloc(SzI*LLFidTableCount);

  num = 0;
  SEEIT_fread_int(&FidFidTable[num],infile);
  while(!feof(infile))
    {
      num = num + 1;

      SEEIT_fread_int(&thisnum,infile);
	  if(num<LLFidTableCount)
	  {
        FidFidTable[num] = thisnum;
	  }
    }
  
  fclose(infile);

  if(num!=LLFidTableCount)
  {
    printf("error in BFT: got %d FIDs, expected %d\n",num,LLFidTableCount);
  }

}


void FreeFidTable()
{
  if(FidFidTable!=NULL)
    {
      free(FidFidTable);
    }
  else
  {
	  printf("trying to free FidFidTable when it is already NULL\n");
  }

  FidFidTable = NULL;
}



void ClearFidList()
{
  int i;

  for(i=0;i<LLFidTableCount;i++)
    {
      FidMarkTable[i] = 0;
    }
}


void BuildLLTable(int override, int size)
{
  FILE *infile;
  char infilename[1000];
  int tempint,num,thisnum;
  
  
  if(LLFidTable!=NULL)
    {
      free(LLFidTable);
      LLFidTable = NULL;
    }
  
  sprintf(infilename,"%sllmap.bin",indirectory);
  infile = fopen(infilename,"rb");
  if(infile==NULL)
    {
      XBell(mydisplay,50);
      printf("could not open %s\n",infilename);
      LLFidTableCount = 0;
      return;
    }
  

  if(override==1)
    {
      LLFidTableCount = size;
       
    }
  else
    {
      LLFidTableCount = 0;
      
      SEEIT_fread_int(&tempint,infile);
      while(!feof(infile))
	  {
	    LLFidTableCount = LLFidTableCount + 1;
	    SEEIT_fread_int(&tempint,infile);
	  }
      rewind(infile);


      if(FidMarkTable!=NULL)
	{
	  free(FidMarkTable);
	  FidMarkTable = NULL;
	}
      FidMarkTable = (unsigned char *)malloc(SzUC*LLFidTableCount);
	  if(FidMarkTable==NULL)
	  {
		printf("Out of memory at FML\n");
		exit(-1);
	  }

      ClearFidList();

    }


  if(LLFidTableCount==0)
  {
    fclose(infile);
    return;
  }

  LLFidTable = (int *)malloc(SzI*LLFidTableCount);
  if(LLFidTable==NULL)
  {
    printf("Out of memory at LLFT\n");
	exit(-1);
  }

  num = 0;
  SEEIT_fread_int(&LLFidTable[num],infile);
  while(!feof(infile))
    {
      num = num + 1;
      SEEIT_fread_int(&thisnum,infile);

	  if(num<LLFidTableCount)
	  {
        LLFidTable[num] = thisnum;
	  }
    }
  
  fclose(infile);
}


void FreeLLTable()
{
  if(LLFidTable!=NULL)
    {
      free(LLFidTable);
    }
  else
  {
	
  }

  LLFidTable = NULL;
}



void FreeLongAttrArrays()
{
  if(SaveLongCountsArea[C_POFE]!=NULL){free(SaveLongCountsArea[C_POFE]);}
  if(SaveLongCountsArea[C_LINE]!=NULL){free(SaveLongCountsArea[C_LINE]);}
  if(SaveLongCountsArea[C_AREA]!=NULL){free(SaveLongCountsArea[C_AREA]);}
  
  if(SaveLongCountsHgt[C_POFE]!=NULL)free(SaveLongCountsHgt[C_POFE]);
  if(SaveLongCountsHgt[C_LINE]!=NULL)free(SaveLongCountsHgt[C_LINE]);
  if(SaveLongCountsHgt[C_AREA]!=NULL)free(SaveLongCountsHgt[C_AREA]);  

  if(SaveLongCountsLen[C_POFE]!=NULL)free(SaveLongCountsLen[C_POFE]);
  if(SaveLongCountsLen[C_LINE]!=NULL)free(SaveLongCountsLen[C_LINE]);
  if(SaveLongCountsLen[C_AREA]!=NULL)free(SaveLongCountsLen[C_AREA]);  

  if(SaveLongCountsNam[C_POFE]!=NULL)free(SaveLongCountsNam[C_POFE]);
  if(SaveLongCountsNam[C_LINE]!=NULL)free(SaveLongCountsNam[C_LINE]);
  if(SaveLongCountsNam[C_AREA]!=NULL)free(SaveLongCountsNam[C_AREA]);  

  if(SaveLongCountsId[C_POFE]!=NULL)free(SaveLongCountsId[C_POFE]);
  if(SaveLongCountsId[C_LINE]!=NULL)free(SaveLongCountsId[C_LINE]);
  if(SaveLongCountsId[C_AREA]!=NULL)free(SaveLongCountsId[C_AREA]);  

  if(SaveLongCountsZv2[C_POFE]!=NULL)free(SaveLongCountsZv2[C_POFE]);
  if(SaveLongCountsZv2[C_LINE]!=NULL)free(SaveLongCountsZv2[C_LINE]);
  if(SaveLongCountsZv2[C_AREA]!=NULL)free(SaveLongCountsZv2[C_AREA]);
  
  SaveLongCountsArea[C_POFE] = NULL;
  SaveLongCountsArea[C_LINE] = NULL;
  SaveLongCountsArea[C_AREA] = NULL;

  SaveLongCountsHgt[C_POFE] = NULL;
  SaveLongCountsHgt[C_LINE] = NULL;
  SaveLongCountsHgt[C_AREA] = NULL;

  SaveLongCountsLen[C_POFE] = NULL;
  SaveLongCountsLen[C_LINE] = NULL;
  SaveLongCountsLen[C_AREA] = NULL;

  SaveLongCountsNam[C_POFE] = NULL;
  SaveLongCountsNam[C_LINE] = NULL;
  SaveLongCountsNam[C_AREA] = NULL;

  SaveLongCountsId[C_POFE] = NULL;
  SaveLongCountsId[C_LINE] = NULL;
  SaveLongCountsId[C_AREA] = NULL;

  SaveLongCountsZv2[C_POFE] = NULL;
  SaveLongCountsZv2[C_LINE] = NULL;
  SaveLongCountsZv2[C_AREA] = NULL;
}


void AllocLongAttrArrays()
{
  int i;
  
  FreeLongAttrArrays();
  
  SaveLongCountsArea[C_POFE] = (int *)malloc(SzI*INscc_loop);
  SaveLongCountsArea[C_LINE] = (int *)malloc(SzI*INscc_loop);
  SaveLongCountsArea[C_AREA] = (int *)malloc(SzI*INscc_loop);
  
  SaveLongCountsHgt[C_POFE] = (int *)malloc(SzI*INscc_loop);
  SaveLongCountsHgt[C_LINE] = (int *)malloc(SzI*INscc_loop);
  SaveLongCountsHgt[C_AREA] = (int *)malloc(SzI*INscc_loop);

  SaveLongCountsLen[C_POFE] = (int *)malloc(SzI*INscc_loop);
  SaveLongCountsLen[C_LINE] = (int *)malloc(SzI*INscc_loop);
  SaveLongCountsLen[C_AREA] = (int *)malloc(SzI*INscc_loop);

  SaveLongCountsNam[C_POFE] = (int *)malloc(SzI*INscc_loop);
  SaveLongCountsNam[C_LINE] = (int *)malloc(SzI*INscc_loop);
  SaveLongCountsNam[C_AREA] = (int *)malloc(SzI*INscc_loop);
  
  SaveLongCountsId[C_POFE] = (int *)malloc(SzI*INscc_loop);
  SaveLongCountsId[C_LINE] = (int *)malloc(SzI*INscc_loop);
  SaveLongCountsId[C_AREA] = (int *)malloc(SzI*INscc_loop);
  
  SaveLongCountsZv2[C_POFE] = (int *)malloc(SzI*INscc_loop);
  SaveLongCountsZv2[C_LINE] = (int *)malloc(SzI*INscc_loop);
  SaveLongCountsZv2[C_AREA] = (int *)malloc(SzI*INscc_loop);

  if(SaveLongCountsZv2[C_AREA]==NULL)
  {
    printf("out of memory at SLCZ\n");
	exit(-1);
  }

  
  for(i=0;i<INscc_loop;i++)
    {
      SaveLongCountsArea[C_POFE][i] = 0;
      SaveLongCountsArea[C_LINE][i] = 0;
      SaveLongCountsArea[C_AREA][i] = 0;

      SaveLongCountsHgt[C_POFE][i] = 0;
      SaveLongCountsHgt[C_LINE][i] = 0;
      SaveLongCountsHgt[C_AREA][i] = 0;

      SaveLongCountsLen[C_POFE][i] = 0;
      SaveLongCountsLen[C_LINE][i] = 0;
      SaveLongCountsLen[C_AREA][i] = 0;

      SaveLongCountsNam[C_POFE][i] = 0;
      SaveLongCountsNam[C_LINE][i] = 0;
      SaveLongCountsNam[C_AREA][i] = 0;

      SaveLongCountsId[C_POFE][i] = 0;
      SaveLongCountsId[C_LINE][i] = 0;
      SaveLongCountsId[C_AREA][i] = 0;

      SaveLongCountsZv2[C_POFE][i] = 0;
      SaveLongCountsZv2[C_LINE][i] = 0;
      SaveLongCountsZv2[C_AREA][i] = 0;

    }
}




void AddLongAttributes()
{  
  int numarea,numhgt,numlen,numnam,numid,numzv2;

  BuildLLTable(-1,-1);
  AllocLongAttrArrays();
  numarea  = GetNumLongAttr(LONG_ATTR_AREA,1);
  numhgt   = GetNumLongAttr(LONG_ATTR_HGT,1);
  numid    = GetNumLongAttr(LONG_ATTR_ID,1);
  numzv2   = GetNumLongAttr(LONG_ATTR_ZV2,1);

  numlen   = GetNumLongAttr(LONG_ATTR_LEN,1);

  numnam   = GetNumLongAttr(LONG_ATTR_NAM,1);


  


  FreeLLTable();


  if((numlen>0)&&(GetLENCode()>0))
    {
      
      AddLongAttrToMdl(LONG_ATTR_LEN,numlen,GetLENCode(),GetLENName());
  }

  if((numnam>0)&&(GetNAMCode()>0))
    {
      
      AddLongAttrToMdl(LONG_ATTR_NAM,numnam,GetNAMCode(),GetNAMName());
  }


  if((numhgt>0)&&(GetHGTCode()>0))
    {
      
      AddLongAttrToMdl(LONG_ATTR_HGT,numhgt,GetHGTCode(),GetHGTName());
  }


  if((numarea>0)&&(GetAREACode()>0))
    {
      
      AddLongAttrToMdl(LONG_ATTR_AREA,numarea,GetAREACode(),GetAREAName());
    }


  if((numid>0)&&(GetIDCode()>0))
    {
      

	  if(ATTRTYPE_TREX()==0)
	  {
        AddLongAttrToMdl(LONG_ATTR_ID,numid,GetIDCode(),GetIDName());
	  }
    }


  if((numzv2>0)&&(GetZVCode()>0))
    {
      
      AddLongAttrToMdl(LONG_ATTR_ZV2,numzv2,GetZVCode(),GetZVName());
    }

  FreeLongAttrArrays();

}




void SortEDCSStuff()
{
  int i,begin,end;

  


  AddLongAttributes();
  SortMdl2(); 


  

  for(i=0;i<NumberOfModels;i++)
    {

      

      SortByAttr(i,0,MdlNames[i].numattributes-1);
      
      SortByUniqAttr(i,0,MdlNames[i].numuniqueAttr-1);


      

    }

  

  
  

  

  for(i=0;i<NumberOfModels;i++)
    {
      begin = 0;
      end = 0;

      while(end<MdlNames[i].numattributes)
	{	  
	  while(MdlNames[i].AttrIndices[end] == MdlNames[i].AttrIndices[begin])
	    {
	      end++;
	      
	      if(end >= MdlNames[i].numattributes-1)
		{

		  
		  if(end>=MdlNames[i].numattributes)
		    {
		      end--;
		    }



		  if(MdlNames[i].AttrIndices[end] != MdlNames[i].AttrIndices[begin])
		    {
		      end--;
		    }
		  break;
		}

	      if(MdlNames[i].AttrIndices[end] != MdlNames[i].AttrIndices[begin])
		{
		  end--;
		  break;
		}
	    }

	  if(end>begin)  
	    {
	      SortByValue(i,begin,end);
	    }

	  

	  begin = end+1;
	  end = begin;
	}
    }
}



void SetDBMaxValues()
{

  
  unsigned char UCjunk;
  double Djunk;
  long int Ljunk;
  int Ijunk;
  FILE *infile;
  extern char *metadata;


  infile = fopen(metadata,"rb");
  if(infile == NULL)
    {
      printf("could not open header information file %s\n",metadata);
      printf("can not continue without this file\n");
      ExitWrapper(-1);
    }
  
   fread(&UCjunk,SzUC,1,infile);
   SEEIT_fread_double(&Djunk,infile);
   SEEIT_fread_double(&Djunk,infile);
   SEEIT_fread_double(&Djunk,infile);
   SEEIT_fread_double(&Djunk,infile);

   SEEIT_fread_double(&Djunk,infile);
   SEEIT_fread_double(&Djunk,infile);
   SEEIT_fread_double(&Djunk,infile);
   SEEIT_fread_double(&Djunk,infile);

   SEEIT_fread_long(&Ljunk,infile);

   SEEIT_fread_long(&Ljunk,infile);
   SEEIT_fread_long(&Ljunk,infile);
   SEEIT_fread_long(&Ljunk,infile);
   SEEIT_fread_long(&Ljunk,infile);
   SEEIT_fread_int(&Ijunk,infile);
   SEEIT_fread_int(&Ijunk,infile);
   SEEIT_fread_int(&Ijunk,infile);
   SEEIT_fread_double(&Djunk,infile);
   SEEIT_fread_double(&IMinXcoord,infile);
   SEEIT_fread_double(&IMinYcoord,infile);
   SEEIT_fread_double(&IMaxXcoord,infile);
   SEEIT_fread_double(&IMaxYcoord,infile);
   
   fclose(infile);

   
}



int IS_MGCP_OTHER(int ECC)
{
  char temp[1000];

  sprintf(temp,"%s",GetECCCode(ECC));

  if(!strcmp(temp,"AC030"))  { return 1;}
  if(!strcmp(temp,"AH050"))  { return 1;}
  if(!strcmp(temp,"AJ010"))  { return 1;}
  if(!strcmp(temp,"AK160"))  { return 1;}
  if(!strcmp(temp,"AK190"))  { return 1;}
  if(!strcmp(temp,"AL015"))  { return 1;}
  if(!strcmp(temp,"AL170"))  { return 1;}
  if(!strcmp(temp,"AL200"))  { return 1;}
  if(!strcmp(temp,"AL210"))  { return 1;} 
  if(!strcmp(temp,"AM020"))  { return 1;}
  if(!strcmp(temp,"AM030"))  { return 1;}
  if(!strcmp(temp,"AM040"))  { return 1;}
  if(!strcmp(temp,"AM060"))  { return 1;}
  if(!strcmp(temp,"AM070"))  { return 1;}
  if(!strcmp(temp,"AT050"))  { return 1;}
  if(!strcmp(temp,"BB041"))  { return 1;}
  if(!strcmp(temp,"BB043"))  { return 1;}
  if(!strcmp(temp,"BB090"))  { return 1;}
  if(!strcmp(temp,"BB140"))  { return 1;}
  if(!strcmp(temp,"BB190"))  { return 1;}
  if(!strcmp(temp,"BB240"))  { return 1;}
  if(!strcmp(temp,"BD100"))  { return 1;}
  if(!strcmp(temp,"BH040"))  { return 1;}
  if(!strcmp(temp,"BH120"))  { return 1;}
  if(!strcmp(temp,"BH155"))  { return 1;}
  if(!strcmp(temp,"BI020"))  { return 1;}
  if(!strcmp(temp,"BI030"))  { return 1;}
  if(!strcmp(temp,"BJ031"))  { return 1;} 
  if(!strcmp(temp,"DB061"))  { return 1;} 
  if(!strcmp(temp,"DB090"))  { return 1;}
  if(!strcmp(temp,"DB115"))  { return 1;}
  if(!strcmp(temp,"DB160"))  { return 1;}
  if(!strcmp(temp,"DB180"))  { return 1;}
  if(!strcmp(temp,"DB200"))  { return 1;}
  if(!strcmp(temp,"EC010"))  { return 1;}
  if(!strcmp(temp,"GB015"))  { return 1;}
  if(!strcmp(temp,"GB045"))  { return 1;}
  if(!strcmp(temp,"GB055"))  { return 1;}
  if(!strcmp(temp,"GB075"))  { return 1;}

  return 0;
}



int IS_MGCP_ACTIVITY(int ECC)
{
  char temp[1000];

  sprintf(temp,"%s",GetECCCode(ECC));


  if(!strcmp(temp,"AA052"))  { return 1;}
  if(!strcmp(temp,"AB000"))  { return 1;}
  if(!strcmp(temp,"AB010"))  { return 1;}
  if(!strcmp(temp,"AC000"))  { return 1;}
  if(!strcmp(temp,"AD010"))  { return 1;}
  if(!strcmp(temp,"AD030"))  { return 1;}
  if(!strcmp(temp,"AD050"))  { return 1;}
  if(!strcmp(temp,"AJ030"))  { return 1;}
  if(!strcmp(temp,"AK030"))  { return 1;}
  if(!strcmp(temp,"AK040"))  { return 1;} 
  if(!strcmp(temp,"AK060"))  { return 1;}
  if(!strcmp(temp,"AK090"))  { return 1;}
  if(!strcmp(temp,"AK100"))  { return 1;}
  if(!strcmp(temp,"AK120"))  { return 1;}
  if(!strcmp(temp,"AK180"))  { return 1;}
  if(!strcmp(temp,"AL012"))  { return 1;}
  if(!strcmp(temp,"AL030"))  { return 1;}
  if(!strcmp(temp,"AL105"))  { return 1;}
  if(!strcmp(temp,"AL140"))  { return 1;}
  if(!strcmp(temp,"AM010"))  { return 1;}
  if(!strcmp(temp,"AN060"))  { return 1;}
  if(!strcmp(temp,"AQ116"))  { return 1;}
  if(!strcmp(temp,"AQ125"))  { return 1;}
  if(!strcmp(temp,"AQ135"))  { return 1;}
  if(!strcmp(temp,"AQ140"))  { return 1;}
  if(!strcmp(temp,"BA050"))  { return 1;}
  if(!strcmp(temp,"BB005"))  { return 1;}
  if(!strcmp(temp,"BB008"))  { return 1;}
  if(!strcmp(temp,"BH050"))  { return 1;}
  if(!strcmp(temp,"BH090"))  { return 1;}
  if(!strcmp(temp,"EC060"))  { return 1;}
  if(!strcmp(temp,"FA015"))  { return 1;} 
  if(!strcmp(temp,"FA100"))  { return 1;}
  if(!strcmp(temp,"GB005"))  { return 1;}
  if(!strcmp(temp,"GB035"))  { return 1;}
  if(!strcmp(temp,"SU001"))  { return 1;}

  return 0;
}



int IS_MGCP_LANDCOVER(int ECC)
{
  char temp[1000];

  sprintf(temp,"%s",GetECCCode(ECC));


  if(!strcmp(temp,"AA010"))  { return 1;}
  if(!strcmp(temp,"AA012"))  { return 1;}
  if(!strcmp(temp,"AL020"))  { return 1;}
  if(!strcmp(temp,"BA040"))  { return 1;}
  if(!strcmp(temp,"BH015"))  { return 1;}
  if(!strcmp(temp,"BH020"))  { return 1;}
  if(!strcmp(temp,"BH030"))  { return 1;}
  if(!strcmp(temp,"BH080"))  { return 1;}
  if(!strcmp(temp,"BH130"))  { return 1;}
  if(!strcmp(temp,"BH135"))  { return 1;}
  if(!strcmp(temp,"BH140"))  { return 1;}
  if(!strcmp(temp,"BH160"))  { return 1;}
  if(!strcmp(temp,"BJ020"))  { return 1;}
  if(!strcmp(temp,"BJ030"))  { return 1;}
  if(!strcmp(temp,"BJ100"))  { return 1;}
  if(!strcmp(temp,"BJ110"))  { return 1;}
  if(!strcmp(temp,"DA010"))  { return 1;}
  if(!strcmp(temp,"DB170"))  { return 1;}
  if(!strcmp(temp,"EA010"))  { return 1;}
  if(!strcmp(temp,"EB010"))  { return 1;}
  if(!strcmp(temp,"EB020"))  { return 1;}
  if(!strcmp(temp,"EC020"))  { return 1;}
  if(!strcmp(temp,"EC030"))  { return 1;}
  if(!strcmp(temp,"EC040"))  { return 1;}
  if(!strcmp(temp,"ED010"))  { return 1;}
  if(!strcmp(temp,"ED020"))  { return 1;}
  if(!strcmp(temp,"ZD020"))  { return 1;}
 
  return 0;

}


int IS_MGCP_ISLAND(int ECC)
{
  char temp[1000];

  sprintf(temp,"%s",GetECCCode(ECC));

  if(!strcmp(temp,"BA030"))  { return 1;}

  return 0;
}



int GetDefaultDrawPri(int ECC)
{
  int domain;


  if(ECC==0)
    {
      return 5;  
    }

  domain = DOMAINS[ECC];




  
  if(!strcmp(layer_pref_file,"Default (MGCP)"))
    {
	  

      if(IS_MGCP_ISLAND(ECC)==1)
	  {
	   return 5;
	  }
      else if(IS_MGCP_LANDCOVER(ECC)==1)
	  {
	   return 4;
	  }
      else if(IS_MGCP_ACTIVITY(ECC)==1)
	  {
	   return 3;
	  }
      else if(IS_MGCP_OTHER(ECC)==1)
	  {
	   return 2;
	  }

      
      
    }
  
  
  
  

  if(domain==D_GRTR) {return 2;}
  if(domain==D_MALI) {return 2;}
  if(domain==D_POPU) {return 2;}
  if(domain==D_POAN) {return 2;}
  if(domain==D_UTAN) {return 2;}
  if(domain==D_DEST) {return 2;}
  if(domain==D_AITO) {return 2;}
  if(domain==D_INWA) {return 2;}

  if(domain==D_VEGE) {return 3;}
  if(domain==D_AERO) {return 3;}
  if(domain==D_OCEN) {return 3;}
  if(domain==D_PHYS) {return 3;}

  if(domain==D_ELEV) {return 4;}
  if(domain==D_SLPO) {return 4;}
  if(domain==D_SUMA) {return 4;}

  if(domain==D_BOUN) {return 5;}
  if(domain==D_DAQU) {return 5;}
  if(domain==D_GENE) {return 5;}
  if(domain==D_GREL) {return 5;}

  printf("Error with default Drawing Priority %d %d\n",domain,ECC);
  return 5;
}



void FillInDefaultColors()
{
  int layer_num;
  int domain;
  int junk;


  
  
  for(layer_num=0;layer_num<NumLODbands;layer_num++)
    {
      

      if(LODindex_DYN[layer_num].geom==C_GRID)
	{
	  if(ATTRTYPE_TREX())
	  {
        junk = AssignTREXColor(layer_num);
	  }
	  else
	  {
	    
	    LODindex[layer_num].rcolor = 0;
	    LODindex[layer_num].gcolor = 0;
	    LODindex[layer_num].bcolor = 0;
	    LODindex[layer_num].color  = mycolors[DRAW_COLOR_BLACK];
	  }
	}
      else
	{

	  if((NewTrexColor==1)&&(ATTRTYPE_TREX())&&(!strcmp(GetECCCode(LODindex_DYN[layer_num].ECC),"GB005")))
	  {
		

	    LODindex[layer_num].rcolor = ORANGE_R;
	    LODindex[layer_num].gcolor = ORANGE_G;
	    LODindex[layer_num].bcolor = ORANGE_B;
	    LODindex[layer_num].color  = mycolors[DRAW_COLOR_ORANGE];
	  }
	  else
	  {
	    domain = DOMAINS[LODindex_DYN[layer_num].ECC];
	  
	    LODindex[layer_num].rcolor = DOMAIN_R[domain];
	    LODindex[layer_num].gcolor = DOMAIN_G[domain];
	    LODindex[layer_num].bcolor = DOMAIN_B[domain];
	    LODindex[layer_num].color  = mycolors[DOMAIN_DEFAULT_COLOR[domain]];
	  }
	}
    }
}





void AllocDefaultArrays()
{
  int i;

  POINT_PRI   = (int *)malloc(SzI*(GIFD_CLASS_NUM+5));
  POINT_RED   = (int *)malloc(SzI*(GIFD_CLASS_NUM+5));
  POINT_GREEN = (int *)malloc(SzI*(GIFD_CLASS_NUM+5));
  POINT_BLUE  = (int *)malloc(SzI*(GIFD_CLASS_NUM+5));
  
  LINE_PRI    = (int *)malloc(SzI*(GIFD_CLASS_NUM+5));
  LINE_RED    = (int *)malloc(SzI*(GIFD_CLASS_NUM+5));
  LINE_GREEN  = (int *)malloc(SzI*(GIFD_CLASS_NUM+5));
  LINE_BLUE   = (int *)malloc(SzI*(GIFD_CLASS_NUM+5));
  
  AREA_PRI    = (int *)malloc(SzI*(GIFD_CLASS_NUM+5));
  AREA_STYLE  = (int *)malloc(SzI*(GIFD_CLASS_NUM+5));
  AREA_RED    = (int *)malloc(SzI*(GIFD_CLASS_NUM+5));
  AREA_GREEN  = (int *)malloc(SzI*(GIFD_CLASS_NUM+5));
  AREA_BLUE   = (int *)malloc(SzI*(GIFD_CLASS_NUM+5));

  POINT_ECCS_USED  = (int *)malloc(SzI*(GIFD_CLASS_NUM+5));
  LINE_ECCS_USED   = (int *)malloc(SzI*(GIFD_CLASS_NUM+5));
  AREA_ECCS_USED   = (int *)malloc(SzI*(GIFD_CLASS_NUM+5));

  for(i=0;i<(GIFD_CLASS_NUM+5);i++)
    {
      POINT_ECCS_USED[i] = -1;
      LINE_ECCS_USED[i]  = -1;
      AREA_ECCS_USED[i]  = -1;
    }

}





int GetLayerNum(int geom, int ECC)
{
  int i;

  for(i=0;i<NumLODbands;i++)
    {
      if((LODindex_DYN[i].geom==geom)&&(LODindex_DYN[i].ECC==ECC))
	{
	  return i;
	}
    }

  XBell(mydisplay,50);
  printf("could not find layer %d %d\n",geom,ECC);
  return -1;
}



int testvalues(char line[], char geom[],char fcode[],int rendertype,int styletype,int red,int green,int blue)
{

  if((!strcmp(geom,"POINT")) && (styletype!=-1))
    {
      printf("Error in Defaults.txt, line: %s\n",line);
      printf("For POINT type, <Draw Style> must be -1\n");
      return 0;
    }

  if((!strcmp(geom,"LINE")) && (styletype!=-1))
    {
      printf("Error in Defaults.txt, line: %s\n",line);
      printf("For LINE type, <Draw Style> must be -1\n");
      return 0;
    }

  if((!strcmp(geom,"AREA")) && ((styletype<1)||(styletype>13)))
    {
      printf("Error in Defaults.txt, line: %s\n",line);
      printf("For AREA type, <Draw Style> must be 1-13\n");
      return 0;
    }

  if((rendertype<1)||(rendertype>5))
    {
      printf("Error in Defaults.txt, line: %s\n",line);
      printf("Render Priority must be 1-5\n");
      return 0;
    }

  if((red<0)||(red>65535))
    {
      printf("Error in Defaults.txt, line: %s\n",line);
      printf("Red value must be 0-65535\n");
      return 0;
    }

  if((green<0)||(green>65535))
    {
      printf("Error in Defaults.txt, line: %s\n",line);
      printf("Green value must be 0-65535\n");
      return 0;
    }

  if((blue<0)||(blue>65535))
    {
      printf("Error in Defaults.txt, line: %s\n",line);
      printf("Blue value must be 0-65535\n");
      return 0;
    }

  return 1;
}






void FreeDefaultArrays()
{
  free(POINT_PRI);
  free(POINT_RED);
  free(POINT_GREEN);
  free(POINT_BLUE);
  
  free(LINE_PRI);
  free(LINE_RED);
  free(LINE_GREEN);
  free(LINE_BLUE);
  
  free(AREA_PRI);
  free(AREA_STYLE);
  free(AREA_RED);
  free(AREA_GREEN);
  free(AREA_BLUE);
  free(POINT_ECCS_USED);
  free(LINE_ECCS_USED);
  free(AREA_ECCS_USED);
}



void AssignTREXIgnore(int layer_num)
{

   if(strstr(LODindex[layer_num].title,"Water Body Mask"))
   {
      
      LODindex_DYN[layer_num].do_discrete            = 1;
      LODindex_DYN[layer_num].equal_type             = 0; 
      LODindex_DYN[layer_num].discrete_ignore_value  = 0.5; 
      LODindex_DYN[layer_num].do_outline             = 0;
   }
   else if(strstr(LODindex[layer_num].title,"Edit Data Mask"))
   {
      
      LODindex_DYN[layer_num].do_discrete            = 1;
      LODindex_DYN[layer_num].equal_type             = 0; 
      LODindex_DYN[layer_num].discrete_ignore_value  = 0.5; 
      LODindex_DYN[layer_num].do_outline             = 0;
   }
   else if(strstr(LODindex[layer_num].title,"Height Error Map"))
   {
      
      LODindex_DYN[layer_num].do_discrete            = 1;
      LODindex_DYN[layer_num].equal_type             = 0; 
      LODindex_DYN[layer_num].discrete_ignore_value  = 0.0; 
      LODindex_DYN[layer_num].do_outline             = 0;
   }
   else if(strstr(LODindex[layer_num].title,"Reliability Mask"))
   {
      
      LODindex_DYN[layer_num].do_discrete            = 1;
      LODindex_DYN[layer_num].equal_type             = 0; 
      LODindex_DYN[layer_num].discrete_ignore_value  = 0.0; 
      LODindex_DYN[layer_num].do_outline             = 0;
   }
   else if(strstr(LODindex[layer_num].title,"Source Data Mask"))
   {
      
      LODindex_DYN[layer_num].do_discrete            = 1;
      LODindex_DYN[layer_num].equal_type             = 0; 
      LODindex_DYN[layer_num].discrete_ignore_value  = 0.5; 
      LODindex_DYN[layer_num].do_outline             = 0;
   }
   if(strstr(LODindex[layer_num].title,"TREx Edge Match WBM"))
   {
      
      LODindex_DYN[layer_num].do_discrete            = 1;
      LODindex_DYN[layer_num].equal_type             = 0; 
      LODindex_DYN[layer_num].discrete_ignore_value  = 0.5; 
      LODindex_DYN[layer_num].do_outline             = 0;
   }

}


int AssignTREXColor(int layer_num)
{


  if(
	       (strstr(LODindex[layer_num].title,"TDF / ")) &&
	       (strstr(LODindex[layer_num].title," Difference"))
		 )
  {
	LODindex[layer_num].rcolor = GRAY128_R;
	LODindex[layer_num].gcolor = GRAY128_G;
	LODindex[layer_num].bcolor = GRAY128_B;
	LODindex[layer_num].color  = mycolors[DRAW_COLOR_GRAY128];
	return DRAW_COLOR_GRAY128;
  }
  else if(strstr(LODindex[layer_num].title,"Water Body Mask"))
  {
	LODindex[layer_num].rcolor = BLUE_R;
	LODindex[layer_num].gcolor = BLUE_G;
	LODindex[layer_num].bcolor = BLUE_B;
	LODindex[layer_num].color  = mycolors[DRAW_COLOR_BLUE];
	return DRAW_COLOR_BLUE;
  }
  else if(strstr(LODindex[layer_num].title,"TREx Edge Match WBM"))
  {
	LODindex[layer_num].rcolor = BLUE_R;
	LODindex[layer_num].gcolor = BLUE_G;
	LODindex[layer_num].bcolor = BLUE_B;
	LODindex[layer_num].color  = mycolors[DRAW_COLOR_BLUE];
	return DRAW_COLOR_BLUE;
  }
  else if(strstr(LODindex[layer_num].title,"TREx DEM Finished"))
  {
	LODindex[layer_num].rcolor = LTGREEN_R;
	LODindex[layer_num].gcolor = LTGREEN_G;
	LODindex[layer_num].bcolor = LTGREEN_B;
	LODindex[layer_num].color  = mycolors[DRAW_COLOR_LTGREEN];
	return DRAW_COLOR_LTGREEN;
  }
  else if(strstr(LODindex[layer_num].title,"TREx Edge Match DEM"))
  {
	LODindex[layer_num].rcolor = LTCYAN_R;
	LODindex[layer_num].gcolor = LTCYAN_G;
	LODindex[layer_num].bcolor = LTCYAN_B;
	LODindex[layer_num].color  = mycolors[DRAW_COLOR_LTCYAN];
	return DRAW_COLOR_LTCYAN;
  }

  else if(
	       (strstr(LODindex[layer_num].title,"Active Earthscape"))        ||
           (strstr(LODindex[layer_num].title,"ASTER GDEM v2"))            ||
           (strstr(LODindex[layer_num].title,"DTED Level 1"))             ||
           (strstr(LODindex[layer_num].title,"SRTM Level 2"))             ||
           (strstr(LODindex[layer_num].title,"HRTE3 Bare Earth"))         || 
           (strstr(LODindex[layer_num].title,"HRTE3 Reflective Surface")) ||
           (strstr(LODindex[layer_num].title,"CDEM"))                     ||
           (strstr(LODindex[layer_num].title,"GMTED mn300"))              ||
           (strstr(LODindex[layer_num].title,"GMTED mn75"))
		 )
  {
	LODindex[layer_num].rcolor = MAGENTA_R;
	LODindex[layer_num].gcolor = MAGENTA_G;
	LODindex[layer_num].bcolor = MAGENTA_B;
	LODindex[layer_num].color  = mycolors[DRAW_COLOR_MAGENTA];
	return DRAW_COLOR_MAGENTA;
  }



  

  else
  {
	LODindex[layer_num].rcolor = 0;
	LODindex[layer_num].gcolor = 0;
	LODindex[layer_num].bcolor = 0;
	LODindex[layer_num].color  = mycolors[DRAW_COLOR_BLACK];
	return DRAW_COLOR_BLACK;
  }
}







int AssignTREXLayer(char *title)
{
  int ecc,geom;

  

  sscanf(title,"%d%d",&ecc,&geom);



  
  if( (strstr(title,"TDF / ")) && (strstr(title,"Difference")) )
  {
    return 5;
  }


  if(strstr(title,"Edit Data Mask"))
  {
    return 2;
  }
  if(strstr(title,"Height Error Map"))
  {
    return 2;
  }
  if(strstr(title,"Source Data Mask"))
  {
    return 2;
  }
  if(strstr(title,"Water Body Mask"))
  {
    return 2;
  }
  if(strstr(title,"Reliability Mask"))
  {
    return 2;
  }


  if(strstr(title,"TREx DEM Finished"))
  {
    return 3;
  }


  if(strstr(title,"Active Earthscape"))
  {
    return 4;
  }
  if(strstr(title,"HRTE3 Bare Earth"))
  {
    return 4;
  }
  if(strstr(title,"HRTE3 Reflective Surface"))
  {
    return 4;
  }
  if(strstr(title,"ASTER GDEM v2"))
  {
    return 4;
  }
  if(strstr(title,"SRTM Level 2"))
  {
    return 4;
  }
  if(strstr(title,"DTED Level 1"))
  {
    return 4;
  }
  if(strstr(title,"CDEM"))
  {
    return 4;
  }
  if(strstr(title,"GMTED mn300"))
  {
    return 4;
  }
  if(strstr(title,"GMTED mn75"))
  {
    return 4;
  }



  if(strstr(title,"TREx Edge Match DEM"))
  {
    return 5;
  }
  if(strstr(title,"TREx Edge Match WBM"))
  {
    return 2;
  }


  if(strstr(title,"TREx DEM Raw"))
  {
    return 5;
  }



  if(geom==C_GRID)
  {
    printf("Error: ATL grid with unexpected title %s\n",title);
	return 5;
  }

  return 1;  

}


int AssignTREXDraw(char *title)
{
  int ecc,geom;

  

  

  sscanf(title,"%d%d",&ecc,&geom);

  if(strstr(title,"Reliability Mask"))
  {
    return 12;
  }
  if(strstr(title,"Edit Data Mask"))
  {
    return 13;
  }
  if(strstr(title,"Height Error Map"))
  {
    return 9;
  }
  if(strstr(title,"Source Data Mask"))
  {
    return 7;
  }
  if(strstr(title,"Water Body Mask"))
  {
    return 3;
  }
  if(strstr(title,"TREx DEM Finished"))
  {
    return 0;
  }
  if(strstr(title,"TREx DEM Raw"))
  {
    return 0;
  }
  if(strstr(title,"Active Earthscape"))
  {
    return 0;
  }
  if(strstr(title,"HRTE3 Bare Earth"))
  {
    return 0;
  }
  if(strstr(title,"HRTE3 Reflective Surface"))
  {
    return 0;
  }
  if(strstr(title,"ASTER GDEM v2"))
  {
    return 0;
  }
  if(strstr(title,"SRTM Level 2"))
  {
    return 0;
  }
  if(strstr(title,"DTED Level 1"))
  {
    return 0;
  }
  if(strstr(title,"CDEM"))
  {
    return 0;
  }
  if(strstr(title,"GMTED mn300"))
  {
    return 0;
  }
  if(strstr(title,"GMTED mn75"))
  {
    return 0;
  }



  if(strstr(title,"TREx Edge Match DEM"))
  {
    return 0;
  }
  if(strstr(title,"TREx Edge Match WBM"))
  {
    return 4;  
  }


  if( (strstr(title,"TDF / ")) && (strstr(title,"Difference")) )
  {
    return 0;
  }


  printf("Error: ATD grid with unexpected title %s\n",title);
  return 0;

}





void InitLayerStuff()
{
  int i,j,k,num_spaces=0,layer_num;
  FILE *incolors;
  char incolorfile[5000];
  Colormap local_cmap = DefaultColormapOfScreen (XtScreen (drawing_a));
  
  
  if(layers_innitted==1)
    {
	  free(profiling_layers);
      free(layers_up);
      free(layer_colors);
      free(layer_colorwindows);
      free(layer_colorpix);
      free(toplevel);
      free(scale1);
      free(scale2);
      free(scale3);
      free(layer_text1);
      free(layer_text2);
      free(layer_text3);
    }


  profiling_layers = (int *) malloc(sizeof(int) * (NumLODbands + 5));
  if(profiling_layers==NULL)
    {
      printf("out of memory trying to alloc %d layers\n",NumLODbands);
      ExitWrapper(-1);
    }



  layers_up = (int *) malloc(sizeof(int) * (NumLODbands + 5));
  if(layers_up==NULL)
    {
      printf("out of memory trying to alloc %d layers\n",NumLODbands);
      ExitWrapper(-1);
    }
  
  
  layer_colors = (XColor *) malloc(sizeof(XColor) * (NumLODbands + 5));
  if(layer_colors==NULL)
    {
      printf("out of memory trying to alloc %d layers\n",NumLODbands);
      ExitWrapper(-1);
    }
  
  
  layer_colorwindows = (Widget *) malloc(sizeof(Widget) * (NumLODbands + 5));
  if(layer_colorwindows==NULL)
    {
      printf("out of memory trying to alloc %d layers\n",NumLODbands);
      ExitWrapper(-1);
    }
  

  layer_colorpix = (Pixmap *) malloc(sizeof(Pixmap) * (NumLODbands));
  if(layer_colorpix==NULL)
    {
      printf("out of memory trying to alloc %d layers\n",NumLODbands);
      ExitWrapper(-1);
    }
  for(i=0;i<NumLODbands;i++)
    {
      layer_colorpix[i] = 123987517;
    }

  



  
  toplevel = (Widget *) malloc(sizeof(Widget) * (NumLODbands + 5));
  if(toplevel==NULL)
    {
      printf("out of memory trying to alloc %d layers\n",NumLODbands);
      ExitWrapper(-1);
    }
  
  
  scale1 = (Widget *) malloc(sizeof(Widget) * (NumLODbands + 5));
  if(scale1==NULL)
    {
      printf("out of memory trying to alloc %d layers\n",NumLODbands);
      ExitWrapper(-1);
    }
  scale2 = (Widget *) malloc(sizeof(Widget) * (NumLODbands + 5));
  if(scale2==NULL)
    {
      printf("out of memory trying to alloc %d layers\n",NumLODbands);
      ExitWrapper(-1);
    }
  scale3 = (Widget *) malloc(sizeof(Widget) * (NumLODbands + 5));
  if(scale3==NULL)
    {
      printf("out of memory trying to alloc %d layers\n",NumLODbands);
      ExitWrapper(-1);
    }



  layer_text1 = (Widget *) malloc(sizeof(Widget) * (NumLODbands + 5));
  if(layer_text1==NULL)
    {
      printf("out of memory trying to alloc %d layers\n",NumLODbands);
      ExitWrapper(-1);
    }
  layer_text2 = (Widget *) malloc(sizeof(Widget) * (NumLODbands + 5));
 if(layer_text2==NULL)
    {
      printf("out of memory trying to alloc %d layers\n",NumLODbands);
      ExitWrapper(-1);
    }
  layer_text3 = (Widget *) malloc(sizeof(Widget) * (NumLODbands + 5));
  if(layer_text3==NULL)
    {
      printf("out of memory trying to alloc %d layers\n",NumLODbands);
      ExitWrapper(-1);
    }



  if(DynLodMade==1)
    {
      free(LODindex_DYN);
    }

  
  LODindex_DYN = (struct LODdisplaySH *) (malloc(sizeof(struct LODdisplaySH) * NumLODbands));
  if(LODindex_DYN==NULL)
    {
      printf("out of memory trying to allocate %d layers\n",NumLODbands);
      ExitWrapper(-1);
    }
  

  for(i=0;i<NumLODbands;i++)
    {
      sscanf(LODindex[i].title,"%d%d",&LODindex_DYN[i].ECC,&LODindex_DYN[i].geom);
      LODindex[i].filename = (char *)malloc(strlen(LODindex[i].title)+10);
      if(LODindex[i].filename==NULL)
	{
	  printf("FN out of memory trying to allocate %d FN\n",(int)strlen(LODindex[i].title));
	  ExitWrapper(-1);
	}
      
      LODindex_DYN[i].ECC = LODindex_DYN[i].ECC + 1;
      
      num_spaces = 0;
      k = 0;
      
      for(j=0;j<(int)strlen(LODindex[i].title);j++)
	{
	  if(num_spaces>=2)
	    {
	      LODindex[i].filename[k] = LODindex[i].title[j];
	      k = k + 1;
	    }
	  
	  if(LODindex[i].title[j]==' ')
	    {
	      num_spaces = num_spaces + 1;
	    }
	}
      LODindex[i].filename[k] = '\0';
      

      
      LODindex_DYN[i].other_index = i;

      



	  if(ATTRTYPE_TREX()==1)
	  {
        LODindex_DYN[i].draw_priority = AssignTREXLayer(LODindex[i].title);

        

        LODindex[i].active = IsTrexToplevel(i);
	  }
	  else
	  {
        LODindex_DYN[i].draw_priority = GetDefaultDrawPri(LODindex_DYN[i].ECC);
	  }


      
      LODindex_DYN[i].do_discrete            = 0;
      LODindex_DYN[i].equal_type             = 1;
      LODindex_DYN[i].discrete_ignore_value  = 0;
      LODindex_DYN[i].do_outline             = 0;

      if((ATTRTYPE_TREX()==1)&&(LODindex_DYN[i].geom==C_GRID))
	  {
        AssignTREXIgnore(i);
	  }



      if(LODindex_DYN[i].geom==C_AREA)
	{
	  LODindex_DYN[i].draw_style    = 4; 
	  LODindex_DYN[i].temp_style    = 4; 
	}
      else if(LODindex_DYN[i].geom==C_GRID)
	{
	  if(ATTRTYPE_TREX()==1)
	  {
        LODindex_DYN[i].draw_style = AssignTREXDraw(LODindex[i].title);
		LODindex_DYN[i].temp_style = LODindex_DYN[i].draw_style;
	  }
	  else
	  {
	    LODindex_DYN[i].draw_style    = 0; 
	    LODindex_DYN[i].temp_style    = 0; 
	  }
	}
	  else
	{
	  
	  LODindex_DYN[i].draw_style    = -1; 
	  LODindex_DYN[i].temp_style    = -1; 
	}
	
    }
  DynLodMade = 1;


  
  for(i=0;i<NumLODbands;i++)
    {
      layers_up[i] = 0;
      layer_colorwindows[i] = NULL;

      profiling_layers[i] = 1;

	  if(ATTRTYPE_TREX())
	  {
        profiling_layers[i] = 0;

		if(LODindex_DYN[i].geom==C_GRID)
		{
          profiling_layers[i] = 100; 
		  
		  if(strstr(LODindex[i].title,"TREx DEM Finished"))
		  {
            profiling_layers[i] = 101; 
		  }
		  
		}
	  }
    }
  
  layers_innitted = 1;
  



  
  sprintf(incolorfile,"%slayercolors.txt",indirectory);
  incolors = fopen(incolorfile,"r");
  if(incolors==NULL)
    {
      printf("did not find layer color spec file %s.  Creating default.\n",incolorfile);
      
      FillInDefaultColors();

      
      
      
      if(
	 (strcmp(layer_pref_file,"Default (MGCP)")) &&
         (strcmp(layer_pref_file,"Default (Baseline)"))
	 )
	{
	  AllocDefaultArrays();
	  FillInDefaults();
	  FreeDefaultArrays();
	}
      


      SortLayers(drawing_a,(XtPointer)999,(XtPointer)999);

      SaveLODColors(drawing_a);

      incolors = fopen(incolorfile,"r");
      if(incolors==NULL)
	{
	  printf("serious error.  unable to create default color spec file %s\n",incolorfile);
	  return;
	}
    }  





  

  
  fscanf(incolors,"%d",&PrimaryLODSort);
  fscanf(incolors,"%d",&SecondaryLODSort);
  

  

  for(layer_num=0;layer_num<NumLODbands;layer_num++)
    {
      fscanf(incolors,"%d",&LODindex_DYN[layer_num].other_index);
    }


  for(layer_num=0;layer_num<NumLODbands;layer_num++)
    {
      if(feof(incolors))return;   fscanf(incolors,"%d",&LODindex    [LODindex_DYN[layer_num].other_index].temp_rcolor);
      if(feof(incolors))return;   fscanf(incolors,"%d",&LODindex    [LODindex_DYN[layer_num].other_index].temp_gcolor);
      if(feof(incolors))return;   fscanf(incolors,"%d",&LODindex    [LODindex_DYN[layer_num].other_index].temp_bcolor);
      if(feof(incolors))return;   fscanf(incolors,"%d",&LODindex_DYN[layer_num].draw_priority);
      if(feof(incolors))return;   fscanf(incolors,"%d",&LODindex_DYN[layer_num].draw_style);
      if(feof(incolors))return;   fscanf(incolors,"%d",&LODindex_DYN[layer_num].ECC);
      if(feof(incolors))return;   fscanf(incolors,"%d",&LODindex_DYN[layer_num].geom);
      if(feof(incolors))return;   fscanf(incolors,"%d",&LODindex_DYN[layer_num].do_discrete);
      if(feof(incolors))return;   fscanf(incolors,"%d",&LODindex_DYN[layer_num].equal_type);
      if(feof(incolors))return;   fscanf(incolors,"%d",&LODindex_DYN[layer_num].do_outline);
      if(feof(incolors))return;   fscanf(incolors,"%lf",&LODindex_DYN[layer_num].discrete_ignore_value);


      LODindex_DYN[layer_num].temp_style = LODindex_DYN[layer_num].draw_style;


      if(
	 (LODindex[LODindex_DYN[layer_num].other_index].temp_rcolor>=0) &&
	 (LODindex[LODindex_DYN[layer_num].other_index].temp_gcolor>=0) &&
	 (LODindex[LODindex_DYN[layer_num].other_index].temp_bcolor>=0) 
	 )
	{
	  layer_colors[layer_num].red   = LODindex[LODindex_DYN[layer_num].other_index].temp_rcolor;
	  layer_colors[layer_num].green = LODindex[LODindex_DYN[layer_num].other_index].temp_gcolor;
	  layer_colors[layer_num].blue  = LODindex[LODindex_DYN[layer_num].other_index].temp_bcolor;
	  
	  if (!XAllocColor (XtDisplay (drawing_a), local_cmap, &layer_colors[layer_num])) 
	    {
	      puts ("Couldn't XAllocColor!"); 
	    }
	  else
	    {
	      

	      layer_colors[layer_num].red   = LODindex[LODindex_DYN[layer_num].other_index].temp_rcolor;
	      layer_colors[layer_num].green = LODindex[LODindex_DYN[layer_num].other_index].temp_gcolor;
	      layer_colors[layer_num].blue  = LODindex[LODindex_DYN[layer_num].other_index].temp_bcolor;
	      
	      LODindex[LODindex_DYN[layer_num].other_index].temp_color  = layer_colors[layer_num].pixel;
	      LODindex[LODindex_DYN[layer_num].other_index].temp_rcolor = layer_colors[layer_num].red;
	      LODindex[LODindex_DYN[layer_num].other_index].temp_gcolor = layer_colors[layer_num].green;
	      LODindex[LODindex_DYN[layer_num].other_index].temp_bcolor = layer_colors[layer_num].blue;    

	      LODindex[LODindex_DYN[layer_num].other_index].color  = layer_colors[layer_num].pixel;
	      LODindex[LODindex_DYN[layer_num].other_index].rcolor = layer_colors[layer_num].red;
	      LODindex[LODindex_DYN[layer_num].other_index].gcolor = layer_colors[layer_num].green;
	      LODindex[LODindex_DYN[layer_num].other_index].bcolor = layer_colors[layer_num].blue;
	    }
	}
    }
  fclose(incolors);     

}







void HandleMainButtons(int onoff)
{

  

  int i;
  Boolean setval = (Boolean)onoff;


  for(i=0;i<TOOLNUM;i++) 
    {
	  if(i==9)
	  {
		  continue;
	  }

      if(
	 (setval==True)&&
	 ( (i==0) || (i==1) || (i==6) )
	 )
	{
	  
	  continue;
	}

      if(i==TOOLBAR_CLASS)
	{
	  
	  continue;
	}
      
      XtSetSensitive(toolbar[i],setval);
    } 


  XtSetSensitive(cascade[1],setval); 
  XtSetSensitive(cascade[2],setval); 
  XtSetSensitive(cascade[3],setval); 
  XtSetSensitive(cascade[4],setval); 

  


  if(NGA_TYPE==1)
    {
      XtSetSensitive(condwid  ,setval); 
      XtSetSensitive(condwid3 ,setval); 
      XtSetSensitive(genwid  ,setval);  
      XtSetSensitive(shapewid,setval); 
      XtSetSensitive(condwid1,setval);  
      XtSetSensitive(condwid2,setval);  
    }


}







void HandleElevButtons()
{
  char filename[1000];
  FILE *ddefs,*headerbin;
  int shortlen=0,i;
  int Ijunk;
  double Djunk;
  unsigned char UCjunk,config;
  long int Ljunk;
  int surfacefound = 0;

  

  sprintf(filename,"%sheader.bin",indirectory);
  headerbin = fopen(filename,"rb");
  if(headerbin==NULL)
    {
      printf("unable to open %s\n",filename);
      ExitWrapper(-1);
    }

  fread(&UCjunk, SzUC,1,headerbin);
  SEEIT_fread_double(&Djunk,  headerbin);
  SEEIT_fread_double(&Djunk,  headerbin);
  SEEIT_fread_double(&Djunk,  headerbin);
  SEEIT_fread_double(&Djunk,  headerbin);
  SEEIT_fread_double(&Djunk,  headerbin);
  SEEIT_fread_double(&Djunk,  headerbin);
  SEEIT_fread_double(&Djunk,  headerbin);
  SEEIT_fread_double(&Djunk,  headerbin);

  SEEIT_fread_long(&Ljunk,  headerbin);
  SEEIT_fread_long(&Ljunk,  headerbin);
  SEEIT_fread_long(&Ljunk,  headerbin);
  SEEIT_fread_long(&Ljunk,  headerbin);
  SEEIT_fread_long(&Ljunk,  headerbin);
  SEEIT_fread_int (&Ijunk,  headerbin);
  
  SEEIT_fread_int(&Ijunk, headerbin);
  SEEIT_fread_int(&shortlen,headerbin);
  fclose(headerbin);







  
  sprintf(filename,"%sdynamicdefs.bin",indirectory);
  ddefs = fopen(filename,"rb");
  if(ddefs==NULL)
    {
      printf("unable to open %s\n",filename);
      ExitWrapper(-1);
    }
  
  
  for(i=0;i<shortlen;i++)
    {      
      SEEIT_fread_int(&Ijunk ,ddefs);
      fread(&config, SzUC,1,ddefs);
      fread(&UCjunk, SzUC,1,ddefs);
      fread(&UCjunk, SzUC,1,ddefs);


      if((config==C_GRID)||(config==C_POLY)||(config==C_MOLI))
	{
	  surfacefound = 1;
	}

    }
  fclose(ddefs);





  if(surfacefound==1)
    {
      
      XtSetSensitive(modes[5],    True);
      XtSetSensitive(modes[6],    True);
      XtSetSensitive(modes[7],    True);
	  if(DO_FAN()==1)
	  {
        XtSetSensitive(modes[8],    True);
	  }
    }
  else
    {      

      
      XtSetSensitive(modes[5],    False);
      XtSetSensitive(modes[6],    False);
      XtSetSensitive(modes[7],    False);
	  if(DO_FAN()==1)
	  {
        XtSetSensitive(modes[8],    False);
	  }

	  if((FAN_MODE>0)||(PROFILE_MODE>0)||(LOS>0))
	  {
        printf("Switching to zoom mode because no elevation data in this \n");
        FAN_MODE     = 0;
        PROFILE_MODE = 0;
        LOS          = 0;

        ZOOM_MODE = 1;

        XtVaSetValues(modes[0],XmNset,True, NULL);
        XtVaSetValues(modes[1],XmNset,False,NULL);
        XtVaSetValues(modes[2],XmNset,False,NULL);
        XtVaSetValues(modes[3],XmNset,False,NULL);
        XtVaSetValues(modes[4],XmNset,False,NULL);
        XtVaSetValues(modes[5],XmNset,False,NULL);
        XtVaSetValues(modes[6],XmNset,False,NULL);
        XtVaSetValues(modes[7],XmNset,False,NULL);
	    if(DO_FAN()==1)
		{ 
          XtVaSetValues(modes[8],XmNset,False,NULL);
		} 
	  }
    }
}





void MakeExeFiles()
{
  FILE *testfile;
  int result;
  char filename[1000];

  


  if(NGA_TYPE==1)
    {
      if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
	{
	  sprintf(filename,"%sinspection_files\\DFEG_master.txt",indirectory);
	}
      else
	{
	  sprintf(filename,"%sinspection_files/DFEG_master.txt",indirectory);
	}
    }
  else
    {
      if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
	{
	  sprintf(filename,"%sinspection_files\\master.txt",indirectory);
	}
      else
	{
	  sprintf(filename,"%sinspection_files/master.txt",indirectory);
	}
    }


  testfile = fopen(filename,"r");
  if(testfile==NULL)
    {
      result = GenerateExeFiles(1);      
    }
  else
    {
      fclose(testfile);
    }





  if(NGA_TYPE==1)
    {
      if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
	{
	  sprintf(filename,"%sinspection_files\\MGCP_master.txt",indirectory);
	}
      else
	{
	  sprintf(filename,"%sinspection_files/MGCP_master.txt",indirectory);
	}

      testfile = fopen(filename,"r");
      if(testfile==NULL)
	{
	  result = GenerateExeFiles(2);  
	}
      else
	{
	  fclose(testfile);
	}




      if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
	{
	  sprintf(filename,"%sinspection_files\\UFD1_master.txt",indirectory);
	}
      else
	{
	  sprintf(filename,"%sinspection_files/UFD1_master.txt",indirectory);
	}

      testfile = fopen(filename,"r");
      if(testfile==NULL)
	{
	  result = GenerateExeFiles(3);  
	}
      else
	{
	  fclose(testfile);
	}



      if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
	{
	  sprintf(filename,"%sinspection_files\\UFD3_master.txt",indirectory);
	}
      else
	{
	  sprintf(filename,"%sinspection_files/UFD3_master.txt",indirectory);
	}

      testfile = fopen(filename,"r");
      if(testfile==NULL)
	{
	  result = GenerateExeFiles(4);  
	}
      else
	{
	  fclose(testfile);
	}





      if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
	{
	  sprintf(filename,"%sinspection_files\\TDS_master.txt",indirectory);
	}
      else
	{
	  sprintf(filename,"%sinspection_files/TDS_master.txt",indirectory);
	}

      testfile = fopen(filename,"r");
      if(testfile==NULL)
	{
	  result = GenerateExeFiles(11);  
	}
      else
	{
	  fclose(testfile);
	}





      if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
	{
	  sprintf(filename,"%sinspection_files\\TREX_master.txt",indirectory);
	}
      else
	{
	  sprintf(filename,"%sinspection_files/TREX_master.txt",indirectory);
	}

      testfile = fopen(filename,"r");
      if(testfile==NULL)
	{
	  result = GenerateExeFiles(12);  
	}
      else
	{
	  fclose(testfile);
	}






    if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
	{
	  sprintf(filename,"%sinspection_files\\AFD_master.txt",indirectory);
	}
      else
	{
	  sprintf(filename,"%sinspection_files/AFD_master.txt",indirectory);
	}

      testfile = fopen(filename,"r");
      if(testfile==NULL)
	{
	  result = GenerateExeFiles(9);  
	}
      else
	{
	  fclose(testfile);
	}




    }
}





void AddToMarkerList()
{
  struct FilterList *nfl;
  int SzFL, i, j, k;
  int compositeindex,ind2,WasAdded;
  extern struct FilterList * MarkerRoot;
  extern struct LindexLookup * LindexTable;
  extern struct LindexLookup * FIDindexTable;
  extern void FreeFIDindexTableEntries(void);
  extern void InitializeFIDindexTable(void);


  
  
  InitializeFIDindexTable();

  compositeindex = (MaxXindex + 1) * (MaxYindex + 1);
  
  
  SzFL = sizeof(struct FilterList);
  for(i=0; i<=MaxXindex; i++)
    {
      for(j=0; j<=MaxYindex; j++)
	{
	  
	  
          compositeindex = (i * (MaxYindex + 1)) + j;

          WasAdded = 0;
	  
	  for(k=0; k<LindexTable[compositeindex].inside; k++)
	    {
	      ind2 = LindexTable[compositeindex].indices[k];
	      if(CrsWlk[ind2].toggle > 0)
		{
		  nfl = (struct FilterList *) (malloc(SzFL));
		  if(nfl == NULL)
		    {
		      printf("CreateMarkerList: Out of allocation memory\n");
		      ExitWrapper(-1);;
		    }
		  
		  nfl->index1 = i;
		  nfl->index2 = j;
		  
		  if(MarkerRoot == NULL)
		    {
		      nfl->next = NULL;
		    }
		  else
		    {
		      nfl->next = MarkerRoot;
		    }
		  MarkerRoot = nfl;
                  WasAdded = 1;
		  break;
		}
	    }
          if(WasAdded == 0)
             {
             for(k=0; k<FIDindexTable[compositeindex].inside; k++)
               {
                 ind2 = FIDindexTable[compositeindex].indices[k];
                 if(FidMarkTable[ind2] == 1)
                   {
                     nfl = (struct FilterList *) (malloc(SzFL));
                     if(nfl == NULL)
                       {
                         printf("CreateMarkerList: Out of allocation memory\n");
                         ExitWrapper(-1);;
                       }
   
                     nfl->index1 = i;
                     nfl->index2 = j;
   
                     if(MarkerRoot == NULL)
                       {
                         nfl->next = NULL;
                       }
                     else
                       {
                         nfl->next = MarkerRoot;
                       }
                     MarkerRoot = nfl;
                     break;
                   }
               }
            }
	}
    }
  FreeFIDindexTableEntries();
}




void FreeMarkerList()
{
  struct FilterList *cfl, *pfl;
  int i;
  extern int SACfull;
  extern struct FilterList * MarkerRoot;
 
  if(CrsWlk != NULL)
    {
      for(i=0; i<SACfull; i++)
        {
	      CrsWlk[i].toggle = 0;
	      CrsWlk[i].AttrErr = -1;
	      
        }
    }
  
  cfl = MarkerRoot;
  while(cfl != NULL)
    {
      pfl = cfl;
      cfl = cfl->next;
      free(pfl);
    }
  MarkerRoot = NULL;


  ClearFidList();
}

void BuildMasterRun(double percentdone)
{
  char temp[1000];
  temp[0] = '\0';

  if(STOP_FLAG==0)
  {
    sprintf(temp,"%s (%.2lf%% of project inspected)",masterrun,percentdone);   
  }
  else
  {
    sprintf(temp,"%s (%.2lf%% of project requested to inspect)",masterrun,percentdone);   
	strcat(temp,"\n                                 (Inspections terminated before completion)");
  }

  sprintf(masterrun2,"%s",temp);
}


void ResetMasterRun()
{
  sprintf(masterrun,"User-Defined");
}


void CountOtherTypes(int *DomainSpecific,int *UnexpectedFCGeom,int *ValueRange,
				  int *MGCPRequired,int *UnexpectedAttribute,int *MissingAttr,
				  int *AttrDep,int *Metadata,int *Conditional)
{
  FILE *readfile;
  char infilename[1000],strval[1000],strval2[1000];
  int len1,len2,count;

  *DomainSpecific      = 0;
  *UnexpectedFCGeom    = 0; 
  *ValueRange          = 0;
  *MGCPRequired        = 0;
  *UnexpectedAttribute = 0;
  *MissingAttr         = 0;
  *AttrDep             = 0;
  *Metadata            = 0;
  *Conditional         = 0;

  sprintf(infilename,"%sAttrStub.bin",outdirectory);
  readfile = fopen(infilename,"rb");
  if(readfile!=NULL)
  {

    SEEIT_fread_int(&len1,readfile);
 
	while(!feof(readfile))
	{

	  if(len1==-1)
	  {
  	    SEEIT_fread_int(&len2,readfile);
		*Conditional = len2;
	    break;
	  }


	  if((len1==0)||(len1<-1)||(len1>900))
	  {
		printf("Error reading stub, len1 %d\n",len1);
		fclose(readfile);
		return;
	  }


      fread(&strval[0], 1,len1,readfile);
	  if(len1>75)
	  {
		printf("Error reading stub, len %d for %s\n",len1,strval);
		if(len1>1000)
		{
		  len1 = 900;
		}
	  }
      strval[len1] = '\0';

	  SEEIT_fread_int(&len2,readfile);

	  if((len2<=0)||(len2>900))
	  {
		printf("Error reading stub, len2 %d\n",len2);
		fclose(readfile);
		return;
	  }
      fread(&strval2[0], 1,len2,readfile);
	  strval2[len2] = '\0';

	  SEEIT_fread_int(&count,readfile);


	  if(count<1)
	  {
		printf("bad stub count %d for %s %s\n",count,strval,strval2);
	  }
      else if(!strcmp(strval,"Domain-Specific Pick-list error"))
	  {
        *DomainSpecific      = *DomainSpecific + count;
	  }
	  else if(!strcmp(strval,"Unexpected FCODE-Geometry Pair error"))
	  {
        *UnexpectedFCGeom    = *UnexpectedFCGeom + count; 
 	  }
	  else if(!strcmp(strval,"Value Range error"))
	  {
        *ValueRange          = *ValueRange + count;
 	  }
	  else if(!strcmp(strval,"MGCP \"Required Attribute Assigned NULL Value\" error"))
	  {
        *MGCPRequired        = *MGCPRequired + count;
	  }
	  else if(!strcmp(strval,"Unexpected Attribute error"))
	  {
        *UnexpectedAttribute = *UnexpectedAttribute + count;
	  }
	  else if(!strcmp(strval,"Missing Attribute Field Or Value error"))
	  {
        *MissingAttr         = *MissingAttr + count;
	  }
	  else if(!strcmp(strval,"Missing Attribute error"))
	  {
        *MissingAttr         = *MissingAttr + count;
	  }
	  else if(!strcmp(strval,"Attribute Dependency error"))
	  {
        *AttrDep             = *AttrDep + count;
	  }
	  else if(!strcmp(strval,"Metadata error"))
	  {
        *Metadata            = *Metadata + count;
	  }
	  else
	  {
		printf("\n\nunexpected token %s in stub\n",strval);
	  }

	  SEEIT_fread_int(&len1,readfile);
	}

    fclose(readfile);
  }
  else
  {
	printf("error:  could not open %s for read\n",infilename);
  }
}


int GetAttrInsType()
{
  FILE *headfile;
  char temp[1000],message[1000];
  int Ijunk;


  sprintf(temp,"%smultiinfo.txt",indirectory);
  headfile = fopen(temp,"r");
  if(headfile==NULL)
    {
      sprintf(message,"Couldnt open %s for read.\n",temp); 
      not_while_running(drawing_a,message,1265,"Couldnt open file",1);
      return 0;
    }
  
  fscanf(headfile,"%d",&Ijunk);   
  fscanf(headfile,"%d",&Ijunk);   
  fscanf(headfile,"%d",&Ijunk);   
  fscanf(headfile,"%d",&Ijunk);   
  fscanf(headfile,"%d",&Ijunk);   
  fscanf(headfile,"%d",&Ijunk);   
  fscanf(headfile,"%d",&Ijunk);   
  fscanf(headfile,"%d",&Ijunk);   
  fscanf(headfile,"%d",&Ijunk);   
  fscanf(headfile,"%d",&Ijunk);   
  fscanf(headfile,"%d",&Ijunk);   
  fscanf(headfile,"%d",&Ijunk);   
  fscanf(headfile,"%d",&Ijunk);   

  fclose(headfile);
  return Ijunk;

}


void AddCountsToAttrTypes(int *totalmeta, int *totalerr, int *totalanomaly)
{
  FILE *summfile;
  char outsummfile[1000],newname[200];
  int DomainSpecific=0,UnexpectedFCGeom=0,ValueRange=0,MGCPRequired=0,
	  UnexpectedAttribute=0,MissingAttr=0,AttrDep=0,Metadata=0,count=0,
	  Conditional=0,thistype;

  extern Widget otherattrwid1,otherattrwid2,otherattrwid3,otherattrwid4,
	  otherattrwid5, otherattrwid6, otherattrwid7, otherattrwid8,
	  otherattrwid9, otherattrwid10,otherattrwid11,otherattrwid12,
	  otherattrwid13,otherattrwid14,otherattrwid15,otherattrwid16,
	  otherattrwid17;


  *totalmeta    = 0;
  *totalerr     = 0;
  *totalanomaly = 0;


  sprintf(outsummfile,"%stemp.txt",indirectory);

  summfile = fopen(outsummfile,"w");
  if(summfile==NULL)
    {
      printf("Fatal error: unable to open %s for write!\n",outsummfile);
      ExitWrapper(-1);
    }


  if(
     (ATTRTYPE_NFDD())  ||
     (ATTRTYPE_DFDD())
	 )
  {
     thistype = GetAttrInsType();

     if((thistype!=1)&&(thistype!=5))  
	 {
       CountOtherTypes(&DomainSpecific,
	              &UnexpectedFCGeom,
				  &ValueRange,
				  &MGCPRequired,
				  &UnexpectedAttribute,
				  &MissingAttr,
				  &AttrDep,
				  &Metadata,
				  &Conditional);
	 }
  }
  else
  {
     CountOtherTypes(&DomainSpecific,
	              &UnexpectedFCGeom,
				  &ValueRange,
				  &MGCPRequired,
				  &UnexpectedAttribute,
				  &MissingAttr,
				  &AttrDep,
				  &Metadata,
				  &Conditional);

  }
 
  *totalmeta = Metadata;
  *totalerr  = *totalerr + 
	           DomainSpecific + UnexpectedFCGeom + ValueRange + MGCPRequired +
			   UnexpectedAttribute + MissingAttr + AttrDep;


  if(
	  (ATTRTYPE_MGCP3()) ||(ATTRTYPE_MGCP4())  ||
	  (ATTRTYPE_UFD1()) || 
	  (ATTRTYPE_ANY_TDS()) ||
      (ATTRTYPE_SAC()) ||
      (ATTRTYPE_ANY_GGDM())
	  )
  {
    sprintf(newname,"%s (%d)",mgcp_attr_names[2],AttrDep);
    XtVaSetValues(mgcpattrwid2,XmNlabelString,STRING(newname),NULL);
  }
  else if(
	      (ATTRTYPE_NFDD())  ||
	      (ATTRTYPE_DFDD())
         )
  {
     
     if(GetAttrInsType()==4)
	 {
       sprintf(newname,"%s (%d)",mgcp_attr_names[2],AttrDep);
       XtVaSetValues(mgcpattrwid2,XmNlabelString,STRING(newname),NULL);
	 }
	 else
	 {
       XtVaSetValues(mgcpattrwid2,XmNlabelString,STRING(mgcp_attr_names[2]),NULL);
	 }
  }
  else
  {
	

    XtVaSetValues(mgcpattrwid2,XmNlabelString,STRING(mgcp_attr_names[2]),NULL);
  }




  if((ATTRTYPE_MGCP3())||(ATTRTYPE_MGCP4()))
  {
    count = AddTextFile(summfile,11,mgcp_attr_names[3],0);
    sprintf(newname,"%s (%d)",mgcp_attr_names[3],count);
    XtVaSetValues(mgcpattrwid3,XmNlabelString,STRING(newname),NULL);
    *totalanomaly = *totalanomaly + count;

    count = AddTextFile(summfile,12,mgcp_attr_names[4],0);
    sprintf(newname,"%s (%d)",mgcp_attr_names[4],count);
    XtVaSetValues(mgcpattrwid4,XmNlabelString,STRING(newname),NULL);
    *totalanomaly = *totalanomaly + count;

    count = AddTextFile(summfile,13,mgcp_attr_names[5],0);
    sprintf(newname,"%s (%d)",mgcp_attr_names[5],count);
    XtVaSetValues(mgcpattrwid5,XmNlabelString,STRING(newname),NULL);
    *totalanomaly = *totalanomaly + count;
  }



  if(DoBlankAttr()==1)
  {
    count = AddTextFile(summfile,14,mgcp_attr_names[6],0);
    sprintf(newname,"%s (%d)",mgcp_attr_names[6],count);
    XtVaSetValues(mgcpattrwid6,XmNlabelString,STRING(newname),NULL);

    *totalerr = *totalerr + count;
  }
  else
  {
     XtVaSetValues(mgcpattrwid6,XmNlabelString,STRING(mgcp_attr_names[6]),NULL);
  }



  if((ATTRTYPE_MGCP3())||(ATTRTYPE_MGCP4()))
  {

    if(ATTRTYPE_MGCP3())
	{
      
      count =  AddTextFile(summfile,15,mgcp_attr_names[7],0);
      sprintf(newname,"%s (%d)",mgcp_attr_names[7],count);
      XtVaSetValues(mgcpattrwid7,XmNlabelString,STRING(newname),NULL);
      *totalerr = *totalerr + count;
	}
	else 
	{
      
       XtVaSetValues(mgcpattrwid7, XmNlabelString,STRING(mgcp_attr_names[7]), NULL);
	}

    count = AddTextFile(summfile,17,mgcp_attr_names[8],0);
    sprintf(newname,"%s (%d)",mgcp_attr_names[8],count);
    XtVaSetValues(mgcpattrwid8,XmNlabelString,STRING(newname),NULL);
    *totalanomaly = *totalanomaly + count;
 
    sprintf(newname,"%s (%d)",mgcp_attr_names[9],MGCPRequired);       
    XtVaSetValues(mgcpattrwid9,XmNlabelString,STRING(newname),NULL);

    count = AddTextFile(summfile,19,mgcp_attr_names[10],0);    
    sprintf(newname,"%s (%d)",mgcp_attr_names[10],count);
    XtVaSetValues(mgcpattrwid10,XmNlabelString,STRING(newname),NULL);
    *totalanomaly = *totalanomaly + count;

  }
  else
 {
	

    XtVaSetValues(mgcpattrwid3, XmNlabelString,STRING(mgcp_attr_names[3]), NULL);
    XtVaSetValues(mgcpattrwid4, XmNlabelString,STRING(mgcp_attr_names[4]), NULL);
    XtVaSetValues(mgcpattrwid5, XmNlabelString,STRING(mgcp_attr_names[5]), NULL);
    
    XtVaSetValues(mgcpattrwid7, XmNlabelString,STRING(mgcp_attr_names[7]), NULL);
    XtVaSetValues(mgcpattrwid8, XmNlabelString,STRING(mgcp_attr_names[8]), NULL);
    XtVaSetValues(mgcpattrwid9, XmNlabelString,STRING(mgcp_attr_names[9]), NULL);
    XtVaSetValues(mgcpattrwid10,XmNlabelString,STRING(mgcp_attr_names[10]),NULL);
  }


 
 


  count = AddTextFile(summfile,2,other_attr_names[1],0);
  sprintf(newname,"%s (%d)",other_attr_names[1],count);
  XtVaSetValues(otherattrwid1,XmNlabelString,STRING(newname),NULL);
  *totalerr = *totalerr + count;


  count =  AddTextFile(summfile,5,other_attr_names[2],0);
  sprintf(newname,"%s (%d)",other_attr_names[2],count);
  XtVaSetValues(otherattrwid2,XmNlabelString,STRING(newname),NULL);
  *totalerr = *totalerr + count;

  counting_attr_only = 1;
  count = AddTextFile(summfile,3,other_attr_names[3],0);
  counting_attr_only = 0;
  sprintf(newname,"%s (%d)",other_attr_names[3],count);
  XtVaSetValues(otherattrwid3,XmNlabelString,STRING(newname),NULL);
  *totalerr = *totalerr + count;


  sprintf(newname,"%s (%d)",other_attr_names[4],DomainSpecific);
  XtVaSetValues(otherattrwid4,XmNlabelString,STRING(newname),NULL);

  sprintf(newname,"%s (%d)",other_attr_names[5],UnexpectedFCGeom);
  XtVaSetValues(otherattrwid5,XmNlabelString,STRING(newname),NULL);

  sprintf(newname,"%s (%d)",other_attr_names[6],ValueRange);
  XtVaSetValues(otherattrwid6,XmNlabelString,STRING(newname),NULL);

  sprintf(newname,"%s (%d)",other_attr_names[7],UnexpectedAttribute);
  XtVaSetValues(otherattrwid7,XmNlabelString,STRING(newname),NULL);

  sprintf(newname,"%s (%d)",other_attr_names[8],MissingAttr);
  XtVaSetValues(otherattrwid8,XmNlabelString,STRING(newname),NULL);
 
  if(
      (ATTRTYPE_NFDD()) ||
      (ATTRTYPE_DFDD()) 
	)
  {
    XtVaSetValues(otherattrwid9,XmNlabelString,STRING(other_attr_names[9]),NULL);
  }
  else
  {
    sprintf(newname,"%s (%d)",other_attr_names[9],Metadata);
    XtVaSetValues(otherattrwid9,XmNlabelString,STRING(newname),NULL);
  }

  count = AddTextFile(summfile,6,other_attr_names[10],0);
  sprintf(newname,"%s (%d)",other_attr_names[10],count);
  XtVaSetValues(otherattrwid10,XmNlabelString,STRING(newname),NULL);
  *totalanomaly = *totalanomaly + count;

  count = AddTextFile(summfile,7,other_attr_names[11],0);
  sprintf(newname,"%s (%d)",other_attr_names[11],count);
  XtVaSetValues(otherattrwid11,XmNlabelString,STRING(newname),NULL);
  *totalanomaly = *totalanomaly + count;

  count = AddTextFile(summfile,8,other_attr_names[12],0);
  sprintf(newname,"%s (%d)",other_attr_names[12],count);
  XtVaSetValues(otherattrwid12,XmNlabelString,STRING(newname),NULL);
  *totalanomaly = *totalanomaly + count;

  count = AddTextFile(summfile,9,other_attr_names[13],0);
  sprintf(newname,"%s (%d)",other_attr_names[13],count);
  XtVaSetValues(otherattrwid13,XmNlabelString,STRING(newname),NULL);
  *totalanomaly = *totalanomaly + count;

  count =  AddTextFile(summfile,1,other_attr_names[14],0);
  sprintf(newname,"%s (%d)",other_attr_names[14],count);
  XtVaSetValues(otherattrwid14,XmNlabelString,STRING(newname),NULL);
  *totalanomaly = *totalanomaly + count;

  count =  AddTextFile(summfile,16,other_attr_names[15],0);
  sprintf(newname,"%s (%d)",other_attr_names[15],count);
  XtVaSetValues(otherattrwid15,XmNlabelString,STRING(newname),NULL);
  *totalanomaly = *totalanomaly + count;

  count = AddTextFile(summfile,18,other_attr_names[16],0);
  sprintf(newname,"%s (%d)",other_attr_names[16],count);
  XtVaSetValues(otherattrwid16,XmNlabelString,STRING(newname),NULL);
  *totalanomaly = *totalanomaly + count;


  if(REPORT_BEZIER==1)
  {
    count = AddTextFile(summfile,20,other_attr_names[17],0);
    sprintf(newname,"%s (%d)",other_attr_names[17],count);
    XtVaSetValues(otherattrwid17,XmNlabelString,STRING(newname),NULL);
    *totalanomaly = *totalanomaly + count;
  }

  XtSetSensitive(otherattrwid4,True);
  XtSetSensitive(otherattrwid5,True);
  XtSetSensitive(otherattrwid6,True);
  XtSetSensitive(otherattrwid7,True);
  XtSetSensitive(otherattrwid8,True);


  if(
     (ATTRTYPE_NFDD())  ||
     (ATTRTYPE_DFDD())
	 )
  {
     if(GetAttrInsType()==1) 
	 {
        
         
		
        XtVaSetValues(otherattrwid4,XmNlabelString,STRING(other_attr_names[4]),NULL);
        XtSetSensitive(otherattrwid4,False);

        
        XtVaSetValues(otherattrwid5,XmNlabelString,STRING(other_attr_names[5]),NULL);
        XtSetSensitive(otherattrwid5,False);

        
        XtVaSetValues(otherattrwid6,XmNlabelString,STRING(other_attr_names[6]),NULL);
        XtSetSensitive(otherattrwid6,False);

        
        XtVaSetValues(otherattrwid7,XmNlabelString,STRING(other_attr_names[7]),NULL);
        XtSetSensitive(otherattrwid7,False);

        
        XtVaSetValues(otherattrwid8,XmNlabelString,STRING(other_attr_names[8]),NULL);
        XtSetSensitive(otherattrwid8,False);
	 }
  }

  fclose(summfile);
}




void FindMaxDBVals()
{
  char temp[1000],aline[1000];
  FILE *headfile;

  db_min_z  = -999999999;
  db_max_z  =  999999999;
  db_min_z2 = -999999999;
  db_max_z2 =  999999999;

  sprintf(temp,"%sdbv.txt",indirectory);
  headfile = fopen(temp,"r");
  if(headfile==NULL)
    {
      
      printf("Couldnt open %s for read.\n",temp); 
	  return;
    }
  
  fgets(aline,1000,headfile);
  if(feof(headfile)){printf("unexpected end (1) of dbv.txt\n"); fclose(headfile); return;}

  fgets(aline,1000,headfile);
  if(feof(headfile)){printf("unexpected end (2) of dbv.txt\n"); fclose(headfile); return;}

  fgets(aline,1000,headfile);
  if(feof(headfile)){printf("unexpected end (3) of dbv.txt\n"); fclose(headfile); return;}
  sscanf(aline,"%lf",&db_min_z);

  fgets(aline,1000,headfile);
  if(feof(headfile)){printf("unexpected end (4) of dbv.txt\n"); fclose(headfile); return;}
  sscanf(aline,"%lf",&db_max_z);
 
  fgets(aline,1000,headfile);
  if(feof(headfile)){printf("unexpected end (5) of dbv.txt\n"); fclose(headfile); return;}
  sscanf(aline,"%lf",&db_min_z2);

  fgets(aline,1000,headfile);
  if(feof(headfile)){printf("unexpected end (6) of dbv.txt\n"); fclose(headfile); return;}
  sscanf(aline,"%lf",&db_max_z2);
  fclose(headfile);
  
}



int BadConditions(int type, Widget w, Widget list_w, int flag)
{
  Widget dialog;
  XmString mystring;
  extern int unsavedignore;
  extern int UnsavedConditions;

  if((UnsavedConditions==0)&&(unsavedignore==0))
  { 
    return 0;
  }

  if(NGA_TYPE==0)
  {
    return 0;
  }

  dialog = XmCreateQuestionDialog (drawing_a, "Quit", NULL,(Cardinal)NULL);

  if(type==1)
  {
    XtAddCallback (dialog,  XmNokCallback, (XtCallbackProc)openProjectCallbackClean, list_w);
  }
  else if(type==2)
  {
    XtAddCallback (dialog,  XmNokCallback, Import3CallbackClean,NULL);
  }

  if(NGA_TYPE==1)
    {
	  if((UnsavedConditions==1)&&(unsavedignore==0))
	  {
		if(type==1)
		{
		  mystring = XmStringCreateLtoR("Unsaved conditions exist.\n\nOpen Project?",XmSTRING_DEFAULT_CHARSET);

          XtVaSetValues (dialog,
		     XmNmessageString,     mystring,
		     XmNhelpLabelString,   STRING("Save Condition Report"),
		     XmNokLabelString,     STRING("Open Project"),
		     XmNdialogTitle,       STRING("Open Project?"),
		     NULL);
		}
		else if(type==2)
		{
		  mystring = XmStringCreateLtoR("Unsaved conditions exist.\n\nCreate Project?",XmSTRING_DEFAULT_CHARSET);

          XtVaSetValues (dialog,
		     XmNmessageString,     mystring,
		     XmNhelpLabelString,   STRING("Save Condition Report"),
		     XmNokLabelString,     STRING("Create Project"),
		     XmNdialogTitle,       STRING("Create Project?"),
		     NULL);
		}

        XtAddCallback (dialog, XmNhelpCallback, SavereportCallback, NULL);
	  }
	  else if((UnsavedConditions==0)&&(unsavedignore==1))
	  {
        if(type==1)
		{
		  mystring = XmStringCreateLtoR("Unsaved retain/ignore settings exist.\n\nOpen Project?",XmSTRING_DEFAULT_CHARSET);

          XtVaSetValues (dialog,
		     XmNmessageString,     mystring,
		     XmNhelpLabelString,   STRING("Save Condition Report"),
		     XmNokLabelString,     STRING("Open Project"),
		     XmNdialogTitle,       STRING("Open Project?"),
		     NULL);
		}
		else if(type==2)
		{
		  mystring = XmStringCreateLtoR("Unsaved retain/ignore settings exist.\n\nCreate Project?",XmSTRING_DEFAULT_CHARSET);

          XtVaSetValues (dialog,
		     XmNmessageString,     mystring,
		     XmNhelpLabelString,   STRING("Save Condition Report"),
		     XmNokLabelString,     STRING("Create Project"),
		     XmNdialogTitle,       STRING("Create Project?"),
		     NULL);
		}

        XtAddCallback (dialog, XmNhelpCallback, SavereportCallback, NULL);
	  }
	  else if((UnsavedConditions==1)&&(unsavedignore==1))
	  {
        if(type==1)
		{
		  mystring = XmStringCreateLtoR("Unsaved conditions and retain/ignore settings exist.\n\nOpen Project?",XmSTRING_DEFAULT_CHARSET);

          XtVaSetValues (dialog,
		     XmNmessageString,     mystring,
		     XmNhelpLabelString,   STRING("Save Condition Report"),
		     XmNokLabelString,     STRING("Open Project"),
		     XmNdialogTitle,       STRING("Open Project?"),
		     NULL);
		}
		else if(type==2)
		{
		  mystring = XmStringCreateLtoR("Unsaved conditions and retain/ignore settings exist.\n\nCreate Project?",XmSTRING_DEFAULT_CHARSET);

          XtVaSetValues (dialog,
		     XmNmessageString,     mystring,
		     XmNhelpLabelString,   STRING("Save Condition Report"),
		     XmNokLabelString,     STRING("Create Project"),
		     XmNdialogTitle,       STRING("Create Project?"),
		     NULL);
		}

        XtAddCallback (dialog, XmNhelpCallback, SavereportCallback, NULL);
	  }
	  else
	  {
         printf("Error in BCCB %d %d\n",UnsavedConditions,unsavedignore);
         XBell(mydisplay,50);
	  }
    }
 
  XtManageChild (dialog);
  XtPopup(XtParent(dialog),XtGrabNone);

  return 1;
}


char *GetProjName(char *inprojpath)
{ 
  int i,lastslash = 0;
  char projpath[1000];
  static char retval[1000];


  sprintf(projpath,"%s",inprojpath);
  i = strlen(projpath);
  if(projpath[i-1]==MYCHARSLASH)
  {
    projpath[i-1] = '\0';
  }


  for(i=0;i<(int)strlen(projpath);i++)
  {
    if(projpath[i]==MYCHARSLASH)
	{
      lastslash = i+1;
	}
  }

  sprintf(retval,"%s",&projpath[lastslash]);

  return retval;

}


void inputfileDialogCallback(Widget w, XtPointer userData,
			     XmFileSelectionBoxCallbackStruct *data)
{
  Boolean zoom;
  char *junk;  
  char command[1000],title[500],help1[500];  
  XmString message2;
  int temp,min,max,slidesize,increment,Pincrement,i,j,k,SLDEBUG=0;
  double xrange,divider;
  int callInitInStreams,totalmeta,totalerr,totalanomaly;
  MyData mydata;
  extern int net_head_in_use,net_deader_head,net_deader_phead;
  extern Widget param_net_head,param2_net_head;


  


  ResetContours();

  TempNumLODbands = 0;

  GridSigPercent  = 0.0;

  if(DEBUG==1){printf("inputfileDialogCallback Received %d\n",(int)userData);}
  
  callInitInStreams = 1;

  ResetMasterRun();
  
   if((input_up==1)&&(NGA_TYPE==1))
   {
	 set_cursor(XtDisplay(pick_dialog),XtWindow(pick_dialog),WATCH);
   }

  set_cursor(mydisplay,mywindow,WATCH);



  if((int)userData==1)
    {
      

            
      junk = (char *)malloc(strlen(importoutputdir)+5);
      if(junk==NULL){printf("j: out of allocation memory!\n"); ExitWrapper(-1);}
      
      sprintf(junk,"%s",importoutputdir);

      sprintf(project_to_open,"%s",GetProjName(importoutputdir));
    }
  else if((int)userData==2)
  { 
     junk = (char *)malloc(  strlen(project_to_open) + strlen(PROJECTLOC) + 10 );
     if(junk==NULL){printf("j: out of allocation memory!\n"); ExitWrapper(-1);}
      
  
     if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
	 { 
	    sprintf(junk,"%s\\%s\\",PROJECTLOC,project_to_open);
	 } 
     else
	 { 
	    sprintf(junk,"%s/%s/",PROJECTLOC,project_to_open);
	 } 
  
     if(batchsilent==1)
	 { 
        printf("open project %s (%s)\n",project_to_open,junk);
	 } 
  }   
  else
    {
      XBell(mydisplay,50);
      printf("should not be here selecting a project\n");

      XtUnmanageChild(XtParent(XtParent(w)));  
      XmStringGetLtoR(data->value,(XmStringCharSet) XmSTRING_DEFAULT_CHARSET, &junk);
    }


  


 


  temp=strlen(junk);
  if(junk[temp]=='\0') 
    {
      if(
	 (junk[temp-1]=='/')||
	 (junk[temp-1]=='\\')
	 )
	{
	  junk[temp-1]='\0';
	}
    }
  else
    {
      printf("Error in output file name generation\n");
      XBell(mydisplay,50);
    }



  


  sprintf(command,"chmod -R a+rwx \"%s\"\n",junk);

  if(SLDEBUG==1)
  {
    printf("Doing command %s\n",command);
  }


  system(command);


  if(SLDEBUG==1)
  {
    printf("done\n");
  }


 if(USE_DOS==1)
  {
	 

    sprintf(command,"attrib -R \"%s\\*\" /S",junk);
	if(SLDEBUG==1)
	{
      printf("sldebug1 %s\n",command);
	}
	system(command);

    sprintf(command,"attrib -R \"%s\\bitmaps\"",junk);
	if(SLDEBUG==1)
	{
      printf("sldebug2 %s\n",command);
	}
	system(command);

    sprintf(command,"attrib -R \"%s\\bitmaps\\*\"",junk);
	if(SLDEBUG==1)
	{
      printf("sldebug3 %s\n",command);
	}
	system(command);
  }

  if(SLDEBUG==1)
  {
    printf("sldebug4 %s\n",command);
  }
  
  if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
    {
      strcat(junk,"\\");
    }
  else
    {
      strcat(junk,"/");
    }




  if(TestDB(junk,0)==0)
    {
      
 
      if((input_up==1)&&(NGA_TYPE==1))
	  {
 	    set_cursor(XtDisplay(pick_dialog),XtWindow(pick_dialog),ARROW);
	  }
	  set_cursor(mydisplay,mywindow,GOOD);
      input_up = 0;
     return;
    }


  SetEndian(junk);
 
  strcpy(indirectory,junk);
  free(junk);



  if(ATTRTYPE_TREX())
  {
	if(SPECIAL_PAD_DIST>15) 
	{
	  PAD_DIST = SPECIAL_PAD_DIST;
	}
	else if(PAD_DIST<11.0) 
	{
	  PAD_DIST = 22;
	}
  }
  else if(SPECIAL_PAD_DIST>=1)
  {
	
	PAD_DIST = SPECIAL_PAD_DIST;
  }
  else
  {
	PAD_DIST = 10;
  }


  if(NGA_TYPE==1)
  {
    printf("Attribution schema in effect %s\n",ParseAttributionType(ATTRIBUTION_TYPE));
  }


  
  
  
  if(dead_lod_head==0)
    {
      XtDestroyWidget(lod_head);
      dead_lod_head=1; 
    }



  
   
	   
   mydata.check_num = 0;
   mydata.axis      = 0;
   mydata.ADDER     = 0;
   mydata.viewonly  = 1;
   mydata.clonenum  = 0;
   mydata.type      = 0;
   mydata.geomtype  = 0;

   if ( MY_MODEL_UP(&mydata,0)==1)
   {
     XtDestroyWidget(modelhead);
   }

   if((input_up==1)&&(NGA_TYPE==1))
   {
     XtPopdown(pick_dialog);
     XtDestroyWidget(pick_dialog);
     input_up = 0;
   }

   if(GRID_WIN>0)
   {
     XtDestroyWidget(grid_head);
   }

   if(FORE_WIN>0)
   { 
     XtDestroyWidget(fore_head);
   } 

   

   NEED_SHADE_REDRAW = 0;

   if(dead_head5==0)
     {
       XtDestroyWidget(cond_dialog);
     }

   if(SAVE_CREPORT_UP==1)
     {
       XtDestroyWidget(XtParent(XtParent(XtParent(savecond_wid))));
     }

   sprintf(SaveReportName,"condreport");


   if(INFO_PARAM_WIN==1)
     {	   
       XtDestroyWidget(infoparam_head);
       INFO_PARAM_WIN = 0;
     }
   
   if(info_window_up==1)
     {
       XtDestroyWidget(infohead);
       info_window_up = 0;
     }


   if(INFO_ATTR_WIN==1)
     {
       XtDestroyWidget(info_attr_head);
       INFO_ATTR_WIN = 0;
     }

   
   DeleteAOIList();

   ScrubModelIndices(1,0);
   ScrubModelIndices(1,1);

   
   FreeMarkerList();

   
   ScrubALLEDCSMarkerLists(1,0);
   ScrubALLEDCSMarkerLists(1,1);

   InitializeOutStreams();

   TurnOffAllChecks(0);
   TurnOffAllChecks(1);

   RevertArrows(0);
   RevertArrows(1);

   GetRidOfAllClones(0);
   GetRidOfAllClones(1);
 
   
   
   if((head_in_use==0)&&(deader_head==0))
     {
       XtDestroyWidget(param_head);
       deader_head=1;
       head_in_use=1;
     }
   else if((head_in_use==1)&&(deader_phead==0))
     {
       XtDestroyWidget(param2_head);
       deader_phead=1;
       head_in_use=0;
     }


   if((net_head_in_use==0)&&(net_deader_head==0))
     {
       XtDestroyWidget(param_net_head);
       net_deader_head=1;
       net_head_in_use=1;
     }
   else if((net_head_in_use==1)&&(net_deader_phead==0))
     {
       XtDestroyWidget(param2_net_head);
       net_deader_phead=1;
       net_head_in_use=0;
     }



   for(i=0;i<=CONDITION_DEFINITIONS; i++)
   {
     

     ErrorLookup[i].scrollwidmadeNET  = 0;
     ErrorLookup[i].scrollwidmade     = 0;
     ErrorLookup[i].filterout         = 0;
     ErrorLookup[i].VConoff           = cond_start_onoff;
     ErrorLookup[i].onoff             = cond_start_onoff;
     ErrorLookup[i].masteronoff       = -1;
     ErrorLookup[i].pos_list_made     = 0;      
     ErrorLookup[i].NETpos_list_made  = 0;      

     for(j=0;j<NUM_C;j++)
	 { 
	   for(k=0;k<(3+1);k++)
	   {
	     ErrorLookup[i].AllConfigOn[k][j]       = 0;
	     ErrorLookup[i].SpecifiedConfigOn[k][j] = 1;
	   }
	 }   
   }




   ResetKeepDismiss(1);


  
  if(SCC_LIST_INNITTED==1)
    {
      free(SCC_LIST);
      SCC_LIST_INNITTED = 0;
    }
  
  if(DYNAMIC_SCC_LIST_INNITTED==1)
    {
      free(DYNAMIC_SCC_LIST);
      DYNAMIC_SCC_LIST_INNITTED = 0;
    }
  
  
  UNIQARRAYBUILT = 0;

  
  
  if(DEBUG==1){printf("Input file name is %s\n",indirectory); }
  
  input_source=1; 
  
  
  set_cursor(mydisplay,mywindow,GOOD);
  
  
  
  if(NGA_TYPE==1)
    {
      sprintf(title,"GAIT %s   Project: %s",VersionStr,indirectory);   
      SetThisClassLevel(0,0);
    }
  else
    {
      sprintf(title,"SEE-IT %s   Database: %s",VersionStr,indirectory);   
    }

  temp = strlen(title);
  title[temp-1] = '\0'; 
  
  
  
  XtVaSetValues(WW,XmNtitle,title,NULL);
 
  
  
  XtVaGetValues(modes[0],XmNset,&zoom,NULL);  
  if(DEBUG==1){printf("Found zoom to be %d\n",zoom);}
  
  sprintf(esname,"%scondreport.es",indirectory);
  sprintf(nsname,"%scondreport.ns",indirectory);
  sprintf(lkname,"%scondreport.lk",indirectory);
  sprintf(boname,"%scondreport.bo",indirectory);  
  sprintf(smname,"%scondreport.sm",indirectory);  
  sprintf(ntname,"%scondreport.nt",indirectory);  
  sprintf(vrname,"%scondreport.vr",indirectory);  
 
 
  

  if(callInitInStreams==1)
    {
	  if((int)userData==2)
	  {
        StartTime = time(NULL);  
	  }
      busyinnitting = 1;
      InitializeInStreams();
    }
  

  
  SortEDCSStuff();
  busyinnitting = 0;  


  SetDBMaxValues();
    

  SAVED_VIEWS = 0;
  CURRENT_ZOOM = 0;
  MAX_ZOOM = 0;
  

  
  set_color (drawing_a, "White",(XtPointer)NULL);
  XFillRectangle (XtDisplay (drawing_a), pixmap, mygc, 0, 0, width, height);
  SetColorRight();
  
  
  
  XCopyArea (mydisplay, pixmap, mywindow, mygc,
	     0, 0, width, height, 0, 0);
  
  
  input_up = 0;
  

 
  InitLayerStuff();

  FillInRenderOrder();


  

  NOT_ZOOMED = 1;
  set_shift  (0);
  llx_zoom   = 0;
  lly_zoom   = 0;
  lod_hgt    = 0;
  
  DBWidth  = (MaxXindex-MinXindex+1)*RegionSize;  
  DBHeight = (MaxYindex-MinYindex+1)*RegionSize;
  IRegionSize = mydmax(DBWidth,DBHeight);

  



  MakeGrid();



  

  if(Ctype()==1)
    {
      divider=100000.0;
    }
  else if(Ctype()==2)
    {
      divider=1;
    }


  if(zoom==1)
    {
      sprintf(help1,"%s Current extents: %s",
	      help3,
	      MakeUString2());
      
      message2 = XmStringCreate (help1, "TAG5");
      XtVaSetValues(TEXT_HELP,XmNfontList, fontlist,NULL);
      XtVaSetValues(TEXT_HELP,XmNlabelString,message2,NULL);
      XmStringFree(message2);
    }
  if(zoom==0)
    { 
      message2 = XmStringCreate (help4, "TAG5");
      XtVaSetValues(TEXT_HELP,XmNfontList, fontlist,NULL);
      XtVaSetValues(TEXT_HELP,XmNlabelString,message2,NULL);
      XmStringFree(message2);
    }
  

  

  


  if(DBWidth>DBHeight)
    {
      xrange = DBHeight;
    }
  else
    {
      xrange = DBWidth;
    }


  
  if(Ctype()==1)
    {
	  XtSetSensitive(gridwid1,True);
	  XtSetSensitive(gridwid2,True);
	  XtSetSensitive(gridwid3,True);
	  XtSetSensitive(gridwid4,True);
	  XtSetSensitive(gridwid5,True);
	  XtSetSensitive(gridwid6,True);


      xrange = xrange/100000.0; 


	  if(GridSpace<0)
	  {
	    if(xrange>100)
		{ 
	      GridSpace     = 5.0;
		} 
        else if(xrange>=5)
		{ 
	      GridSpace     = 1.0;
		} 
        else if (xrange>=1)
		{  
	      GridSpace     = 0.1;
		}  
        else if (xrange>=.1)
		{  
	      GridSpace     = 0.01;
		}  
        else if (xrange>=.01)
		{  
	      GridSpace     = 0.001;
		}  
        else if (xrange>=.001)
		{  
	      GridSpace     = 0.0001;
		}  
        else
		{  
	      GridSpace     = 0.00001;
		}  
	  }
    }

  else if(Ctype()==2)
    {

	  XtVaSetValues(gridwid1,XmNset,False,NULL);
	  XtVaSetValues(gridwid2,XmNset,False,NULL);
	  XtVaSetValues(gridwid3,XmNset,False,NULL);
	  XtVaSetValues(gridwid4,XmNset,False,NULL);
	  XtVaSetValues(gridwid5,XmNset,False,NULL);
	  XtVaSetValues(gridwid6,XmNset,False,NULL);
	  XtSetSensitive(gridwid1,False);
	  XtSetSensitive(gridwid2,False);
	  XtSetSensitive(gridwid3,False);
	  XtSetSensitive(gridwid4,False);
	  XtSetSensitive(gridwid5,False);
	  XtSetSensitive(gridwid6,False);

      DrawQuarterDegreeGrid  = 0;
      DrawQuarterDegreeGridL = 0;
      DrawHalfDegreeGrid     = 0;
      DrawHalfDegreeGridL    = 0;
      DrawOneDegreeGrid      = 0;
      DrawOneDegreeGridL     = 0;

	  if(GridSpace<0)
	  {
        if(xrange>=500000)     
		{ 
	      GridSpace = 100000;
		}      
        else if (xrange>=100000)
		{ 
	      GridSpace = 10000;
		} 
        else if (xrange>=10000)
		{ 
	      GridSpace = 1000;
		} 
        else if (xrange>=1000) 
		{ 
	      GridSpace = 100;
		} 
        else if (xrange>=100) 
		{ 
	      GridSpace = 10;
		}
        else 
		{ 
	      GridSpace = 1;
		} 
	  } 
  }

  SetLabelsToDefault(1);  

  
  DrawTopGrid();


  
  zerooutCallback((Widget)NULL, (XtPointer)1, (XtPointer) 0);
  zerooutCallback((Widget)NULL, (XtPointer)1, (XtPointer) 1);

  RemoveAnnotations(0);
  RemoveAnnotations(1);

  SaveXScroll = ScrollPercent(1);
  SaveYScroll = ScrollPercent(2);

  SAVE_ZOOM_STATE(SaveXScroll,SaveXScroll);


  HandleMainButtons(1); 

  HandleElevButtons();
   
  
  
  XtVaGetValues(vert_scroll[DRAWING_A_SCROLL],
		XmNminimum,      &min,
		XmNmaximum,      &max,
		XmNsliderSize,   &slidesize,
		XmNincrement,    &increment,
		XmNpageIncrement,&Pincrement,
		NULL);
  
  XmScrollBarSetValues(vert_scroll[DRAWING_A_SCROLL],
		       max-slidesize,
		       slidesize,
		       30,
		       Pincrement,
		       1);


  
  MakeSen((Widget)NULL,(XEvent *)NULL,(String *)NULL,(int *)NULL);
  ResetBOoptions();




  
  MakingMaster = 1;
  ExtraMessage[0] = '\0';



  InitializationAdvice(-1.0,-1.0,-1.0,-1.0,-1.0,-1);

  MakeExeFiles();
  MakingMaster = 0;  


  if(NGA_TYPE==1)
    {
      if((int)userData!=1)
	  {
		

		global_short_attr_count = 1; 
        AddCountsToAttrTypes(&totalmeta,&totalerr,&totalanomaly);
		global_short_attr_count = 0;
	  }



	  if(DoBlankAttr()==1)
	  {
		  XtSetSensitive(mgcpattrwid6,True);
	  }
	  else
	  {
          XtSetSensitive(mgcpattrwid6,False);
	  }



      if(ATTRTYPE_MGCP3())
	  { 
	   XtSetSensitive(mgcpattrwid2 ,True);
	   XtSetSensitive(mgcpattrwid3 ,True);
	   XtSetSensitive(mgcpattrwid4 ,True);
	   XtSetSensitive(mgcpattrwid5 ,True);
	   
	   XtSetSensitive(mgcpattrwid7 ,True);
	   XtSetSensitive(mgcpattrwid8 ,True);
	   XtSetSensitive(mgcpattrwid9 ,True);
	   XtSetSensitive(mgcpattrwid10,True);
	  }
      else if(ATTRTYPE_MGCP4())
	  { 
	   XtSetSensitive(mgcpattrwid2 ,True);
	   XtSetSensitive(mgcpattrwid3 ,True);
	   XtSetSensitive(mgcpattrwid4 ,True);
	   XtSetSensitive(mgcpattrwid5 ,True);
	   
	   XtSetSensitive(mgcpattrwid7 ,False);
	   XtSetSensitive(mgcpattrwid8 ,True);
	   XtSetSensitive(mgcpattrwid9 ,True);
	   XtSetSensitive(mgcpattrwid10,True);
	  }
      else
	  {
	   if(
	      (ATTRTYPE_UFD1()) ||
          (ATTRTYPE_ANY_TDS()) ||
	      (ATTRTYPE_SAC()) ||
	      (ATTRTYPE_ANY_GGDM())
	      )
	   {
	     XtSetSensitive(mgcpattrwid2,True);
	   }
	   else if(
	      (ATTRTYPE_NFDD()) ||
	      (ATTRTYPE_DFDD()) 
	      )
	   {
         

         if(GetAttrInsType()==4)
		 {
           XtSetSensitive(mgcpattrwid2,True);
		 }
		 else
		 {
           XtSetSensitive(mgcpattrwid2,False);
		 }

	   }
	   else
	   { 
	     XtSetSensitive(mgcpattrwid2,False);
	   } 


	   XtSetSensitive(mgcpattrwid3 ,False);
	   XtSetSensitive(mgcpattrwid4 ,False);
	   XtSetSensitive(mgcpattrwid5 ,False);
	   
	   XtSetSensitive(mgcpattrwid7 ,False);
	   XtSetSensitive(mgcpattrwid8 ,False);
	   XtSetSensitive(mgcpattrwid9 ,False);
	   XtSetSensitive(mgcpattrwid10,False);
	}



    if((ATTRIBUTION_TYPE>=23)&&(ATTRIBUTION_TYPE<=26))
	  {
        
        XtSetSensitive(otherattrwid9,False);
	  }
	  else
	  {
        XtSetSensitive(otherattrwid9,True);
	  }
    }

  if(batchsilent==0)
  {
    XtPopdown(XtParent(indir_work_dialog));
    XtDestroyWidget(indir_work_dialog);
  }
  else
  {
	 printf("project now created and open...\n");
  }


  FindMaxDBVals();
 
  


  

  load_modules = 0;

  if(TotalGridLayers()>0)
  {
    XtSetSensitive(demwid,True);
  }
  else
  {
    XtSetSensitive(demwid,False);
  }

  for(i=0;i<NumLODbands;i++)
  {
     LODindex[i].c1active = 0;
     LODindex[i].c2active = 0;
     LODindex[i].sp1active = 0;
  }



  if(
      (DrawContourLines!=0)   ||
      (ZoomSunAzimuth  !=315) ||
      (ZoomSunAngle    !=45)  ||
      (ZoomVertExag    !=1)   ||
      (USE_GREY        !=1)
    )
  {
    if(TotalGridLayers()>0)
	{
      NEED_SHADE_REDRAW = 1;
	}
  }


  if(NEED_SHADE_REDRAW>0)
  {
    set_cursor(mydisplay,mywindow,WATCH);
 
    
    RebuildTopImage(6);
    refreshCallback((Widget)NULL,(XtPointer)NULL,(XtPointer)NULL);
  
  }

  NEED_SHADE_REDRAW = 0;


  for(i=0;i<INsac_loop+10;i++)
    {
      InfoSac[i] = 1;
    }



  set_cursor(mydisplay,mywindow,GOOD);


  


  

}




void ShowFCODECallback(Widget w,XtPointer data,XtPointer callData)
{
  FILE *inspec;
  int totallen = 0,not_printed=1,lastshape = 1,len;
  char hugestring[4000],filename[1000],aline[1010],first[100],second[1000];


  if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
  {
    sprintf(filename,"%s\\%s\\InputSpecFile.txt",PROJECTLOC,GAITProjectName);
  }
  else
  {
    sprintf(filename,"%s/%s/InputSpecFile.txt",PROJECTLOC,GAITProjectName);
  }

  inspec = fopen(filename,"r");

  if(inspec==NULL)
  {
    sprintf(aline,"Error trying to open:\n  %s\n",filename);

    not_while_running(drawing_a,aline,1517,"Unable to open file",1);
	return;
  }


  fgets(aline,1000,inspec);

  while(!feof(inspec))
  {	
    sscanf(aline,"%s%s",first,second);
    if(!strcmp(second,"*****"))
	{
      totallen = totallen + strlen(aline);
	}
	fgets(aline,1000,inspec);
  }

  if(totallen==0)
  {
    printf("Error: No un-mapped files/tables found in %s\n",filename);
    XBell(mydisplay,50);
    return;
  }

  if(INFO_WINDOW==0)
  {
    MakeInfo(1);
  }
  else
  {
    ResetWidget(shellhead2);
  }


  hugestring[0] = '\0';
  strcat(hugestring,"Files/Tables for which an FCODE could not be automatically assigned:\n\n");

  rewind(inspec);

  fgets(aline,1000,inspec);

  while(!feof(inspec))
  {	
    sscanf(aline,"%s%s",first,second);

	if(
		(!strcmp(first,"GEODATABASE")) ||
		(!strcmp(first,"GEOMEDIAACC"))
		
	  )
	{
      len = strlen(aline);
	  aline[len-1] = ':';
	  aline[len]   = '\n';
	  aline[len+1] = '\0';
      sprintf(filename,"%s",aline);
	  not_printed = 2;
	}

    if(!strcmp(second,"*****"))
	{
      if(strcmp(first,"SHAPE"))
	  {
        if(not_printed==2) 
		{

          strcat(hugestring,"\n");
		  infoprint(hugestring);
          infoprintbold(filename);
		  hugestring[0] = '\0';


		  not_printed = 0; 
		}
		lastshape = 0;
	  }
	  else
	  {
        if(lastshape==0)
		{
          
          strcat(hugestring,"\n");
		}
		lastshape = 1;
	  }

      strcat(hugestring,aline);
	}

	if(strlen(hugestring)>3000)
	{
      infoprint(hugestring);
      hugestring[0] = '\0';
	}

	fgets(aline,1000,inspec);
  }

  fclose(inspec);

  if(strlen(hugestring)>5)
  {
    infoprint(hugestring);
  }

  return;
}



int BadInputSpecFile()
{
  FILE *inspec;
  char filename[1000],aline[1000],first[100],second[1000];


  if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
  {
    sprintf(filename,"%s\\%s\\InputSpecFile.txt",PROJECTLOC,GAITProjectName);
  }
  else
  {
    sprintf(filename,"%s/%s/InputSpecFile.txt",PROJECTLOC,GAITProjectName);
  }

  inspec = fopen(filename,"r");

  if(inspec==NULL)
  {
    sprintf(aline,"Error trying to open:\n  %s\n",filename);

    not_while_running(drawing_a,aline,1517,"Unable to open file",1);
	return 0;
  }

  fgets(aline,1000,inspec);
  

  while(!feof(inspec))
  {	
    sscanf(aline,"%s%s",first,second);
    if(!strcmp(second,"*****"))
	{
      fclose(inspec);
      return 1;
	}
	fgets(aline,1000,inspec);
  }

  fclose(inspec);
  return 0;
}


void Los_Pic_Callback(Widget w,XtPointer data,XtPointer callData)
{ 
  int n;
  Widget rowcol,form,Demo_draw,button;
  Arg args[15];
  XPoint points[5];
  
  if(DEMO_UP==0)
    {
      n=0;
      XtSetArg(args[n],  XmNminWidth,     620);         n++;  
      XtSetArg(args[n],  XmNminHeight,    250);         n++;  
      XtSetArg(args[n],  XmNmaxWidth,     620);         n++;  
      XtSetArg(args[n],  XmNmaxHeight,    250);         n++;
      XtSetArg(args[n],  XmNdeleteResponse, XmDESTROY); n++;
      
      Demo_drawing = XtCreatePopupShell("LOS terms",topLevelShellWidgetClass,
					drawing_a,args,n);
      
      rowcol = XtVaCreateWidget ("rowcol",
				 xmRowColumnWidgetClass, Demo_drawing, NULL);
      
      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,  
			       NULL);
      
      Demo_draw = XtVaCreateManagedWidget ("Demo It",
					   xmDrawingAreaWidgetClass, form,
					   XmNunitType,     XmPIXELS,
					   XmNwidth,        620, 
					   XmNheight,       210, 
					   XmNresizePolicy, XmNONE,
					   NULL);
      
      XtAddCallback (Demo_draw, XmNexposeCallback, redraw_net, (XtPointer) (1001));  
      
      XtManageChild(Demo_draw);  
      XtManageChild(form);
      
      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,  
			       NULL);
      
      button = XtVaCreateManagedWidget("Done1",xmPushButtonWidgetClass,form,
				       XmNlabelString, STRING("Done"),
				       XmNorientation, XmVERTICAL,
				       XmNleftAttachment,  XmATTACH_POSITION,
				       XmNleftPosition,    0,
				       XmNrightAttachment,  XmATTACH_POSITION,
				       XmNrightPosition,    99,
				       XmNtranslations, XtParseTranslationTable ( translations_global ) ,
				       NULL
				       ); 
      
      XtAddCallback (button, XmNactivateCallback,
		     die_callback, (XtPointer)(1001));
      
      XtManageChild(button);
      XtManageChild(form);   
      XtManageChild(rowcol);
      MyPopup(Demo_drawing);
      
      XtAddEventHandler(Demo_drawing,StructureNotifyMask,False, myResizeHandler, (XtPointer)((int)250));


      XtAddCallback(Demo_drawing,XmNdestroyCallback,ShellDeath,(XtPointer)4065);
      
      set_color(Demo_draw,"White",(XtPointer)NULL);
      
      Demo_pix = XCreatePixmap (XtDisplay (Demo_draw),
				RootWindowOfScreen (XtScreen (Demo_draw)), 620,210,
				DefaultDepthOfScreen (XtScreen (Demo_draw)));
      XFillRectangle (XtDisplay (Demo_draw), Demo_pix,       mygc, 0, 0, 620,210);
      
      set_color(Demo_draw,"Black",(XtPointer)NULL);
      
      XDrawLine(XtDisplay(Demo_draw),XtWindow(Demo_draw),mygc,100,100,520,50);
      XDrawLine(XtDisplay(Demo_draw),Demo_pix,           mygc,100,100,520,50);
      
      XSetForeground(XtDisplay (Demo_draw),mygc,mycolors[DRAW_COLOR_BLUE]);
      
      XDrawLine(XtDisplay(Demo_draw),XtWindow(Demo_draw),mygc, 520,100,520,50);
      XDrawLine(XtDisplay(Demo_draw),Demo_pix,           mygc, 520,100,520,50);
      
      XDrawString(XtDisplay(Demo_draw),XtWindow(Demo_draw),mygc,
		  530,70,"Target",6);
      XDrawString(XtDisplay(Demo_draw),XtWindow(Demo_draw),mygc,
		  530,85,"Height",6);
      XDrawString(XtDisplay(Demo_draw),Demo_pix,mygc,
		  530,70,"Target",6);
      XDrawString(XtDisplay(Demo_draw),Demo_pix,mygc,
		  530,85,"Height",6);
      
      XSetForeground(XtDisplay (Demo_draw),mygc,mycolors[DRAW_COLOR_BROWN]);
      
      XDrawString(XtDisplay(Demo_draw),XtWindow(Demo_draw),mygc,
		  350,170,"Terrain",7);
      XDrawString(XtDisplay(Demo_draw),Demo_pix,mygc,
		  350,170,"Terrain",7);
      
      XDrawLine(XtDisplay(Demo_draw),XtWindow(Demo_draw),mygc,100,200,200,160);
      XDrawLine(XtDisplay(Demo_draw),Demo_pix,        mygc,100,200,200,160);
      
      XDrawLine(XtDisplay(Demo_draw),XtWindow(Demo_draw),mygc,200,160,280,170);
      XDrawLine(XtDisplay(Demo_draw),Demo_pix,           mygc,200,160,280,170);
      
      XDrawLine(XtDisplay(Demo_draw),XtWindow(Demo_draw),mygc,280,170,350,130);
      XDrawLine(XtDisplay(Demo_draw),Demo_pix,           mygc,280,170,350,130);
      
      XDrawLine(XtDisplay(Demo_draw),XtWindow(Demo_draw),mygc,350,130,440,150);
      XDrawLine(XtDisplay(Demo_draw),Demo_pix,           mygc,350,130,440,150);
      
      XDrawLine(XtDisplay(Demo_draw),XtWindow(Demo_draw),mygc,440,150,520,100);
      XDrawLine(XtDisplay(Demo_draw),Demo_pix,           mygc,440,150,520,100);
      
      XDrawLine(XtDisplay(Demo_draw),XtWindow(Demo_draw),mygc,520,100,620,120);
      XDrawLine(XtDisplay(Demo_draw),Demo_pix,           mygc,520,100,620,120);
      
      XDrawLine(XtDisplay(Demo_draw),XtWindow(Demo_draw),mygc,0,180,100,200);
      XDrawLine(XtDisplay(Demo_draw),Demo_pix,           mygc,0,180,100,200);
      
      
      
      XDrawLine(XtDisplay(Demo_draw),XtWindow(Demo_draw),mygc,315,140,315,150);
      XDrawLine(XtDisplay(Demo_draw),Demo_pix,           mygc,315,140,315,150);
      
      XSetForeground(XtDisplay (Demo_draw),mygc,mycolors[DRAW_COLOR_PURPLE]);
      
      points[0].x = 370;
      points[0].y = 134;
      points[1].x = 390;
      points[1].y = 139;
      points[2].x = 390;
      points[2].y = 100;
      points[3].x = 370;
      points[3].y = 100;
      
      XFillPolygon(XtDisplay (Demo_draw),XtWindow(Demo_draw),mygc,points,4,Convex,CoordModeOrigin);
      XFillPolygon(XtDisplay (Demo_draw),Demo_pix,mygc,points,4,Convex,CoordModeOrigin);
      
      XSetForeground(XtDisplay (Demo_draw),mygc,mycolors[DRAW_COLOR_MEDGREEN]);
      
      
      
      points[0].x = 305;
      points[0].y = 140;
      points[1].x = 315;
      points[1].y = 110;
      points[2].x = 325;
      points[2].y = 140;
      
      XFillPolygon(XtDisplay (Demo_draw),XtWindow(Demo_draw),mygc,points,3,Convex,CoordModeOrigin);
      XFillPolygon(XtDisplay (Demo_draw),Demo_pix,mygc,points,3,Convex,CoordModeOrigin);
      
      XDrawLine(XtDisplay(Demo_draw),XtWindow(Demo_draw),mygc, 100,200,100,100);
      XDrawLine(XtDisplay(Demo_draw),Demo_pix,           mygc, 100,200,100,100);
      
      XDrawString(XtDisplay(Demo_draw),XtWindow(Demo_draw),mygc,
		  10,130,"Observer",8);
      XDrawString(XtDisplay(Demo_draw),XtWindow(Demo_draw),mygc,
		  10,145,"Height",6);
      XDrawString(XtDisplay(Demo_draw),Demo_pix,mygc,
		  10,130,"Observer",8);
      XDrawString(XtDisplay(Demo_draw),Demo_pix,mygc,
		  10,145,"Height",6);
      
      set_color(Demo_draw,"Black",(XtPointer)NULL);
      
      XDrawString(XtDisplay(Demo_draw),XtWindow(Demo_draw),mygc,
		  200,70,"Line of Sight",13);
      XDrawString(XtDisplay(Demo_draw),Demo_pix,mygc,
		  200,70,"Line of Sight",13);
      
      XDrawString(XtDisplay(Demo_draw),XtWindow(Demo_draw),mygc,
		  160,145,"Observer",8);
      XDrawString(XtDisplay(Demo_draw),Demo_pix,mygc,
		  160,145,"Observer",8);
      
      XDrawString(XtDisplay(Demo_draw),XtWindow(Demo_draw),mygc,
		  420,100,"Target",6);
      XDrawString(XtDisplay(Demo_draw),Demo_pix,mygc,
		  420,100,"Target",6);
      
      
      XDrawLine(XtDisplay(Demo_draw),XtWindow(Demo_draw),mygc,105,105,160,130);
      XDrawLine(XtDisplay(Demo_draw),Demo_pix,           mygc,105,105,160,130);
      
      
      XDrawLine(XtDisplay(Demo_draw),XtWindow(Demo_draw),mygc,515,55,470,85);
      XDrawLine(XtDisplay(Demo_draw),Demo_pix,           mygc,515,55,470,88);
      
      XDrawArc(mydisplay,XtWindow(Demo_draw),mygc,520-5,50-5,10,10,0,23040);
      XDrawArc(mydisplay,Demo_pix           ,mygc,520-5,50-5,10,10,0,23040);
      
      XDrawArc(mydisplay,XtWindow(Demo_draw),mygc,100-5,100-5,10,10,0,23040);
      XDrawArc(mydisplay,Demo_pix           ,mygc,100-5,100-5,10,10,0,23040);
      
      DEMO_UP=1;
    }
  else
    {
      ResetWidget(Demo_drawing);
    }  
}




void Att_Pic_Callback(Widget w,XtPointer data,XtPointer callData)
{ 
  int n,i;
  Widget rowcol,form,Att_Demo_draw,button;
  Arg args[15];
  char message[200];

  if(ATT_DEMO_UP==0)
    {
      n=0;

      
      XtSetArg(args[n],  XmNdeleteResponse, XmDESTROY); n++;
      
      Att_Demo_drawing = XtCreatePopupShell("Attribution Grid terms",topLevelShellWidgetClass,
					drawing_a,args,n);
      
      rowcol = XtVaCreateWidget ("rowcol",
				 xmRowColumnWidgetClass, Att_Demo_drawing, NULL);
      
      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,  
			       NULL);
      
      Att_Demo_draw = XtVaCreateManagedWidget ("Att_Demo It",
					   xmDrawingAreaWidgetClass, form,
					   XmNunitType,     XmPIXELS,
					   XmNwidth,        620, 
					   XmNheight,       550, 
					   XmNresizePolicy, XmNONE,
					   NULL);
      
      XtAddCallback (Att_Demo_draw, XmNexposeCallback, redraw_net, (XtPointer) (1002));  

      
      XtManageChild(Att_Demo_draw);  
      XtManageChild(form);
      
      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,  
			       NULL);
      
      button = XtVaCreateManagedWidget("Done1",xmPushButtonWidgetClass,form,
				       XmNlabelString, STRING("Done"),
				       XmNorientation, XmVERTICAL,
				       XmNleftAttachment,  XmATTACH_POSITION,
				       XmNleftPosition,    0,
				       XmNrightAttachment,  XmATTACH_POSITION,
				       XmNrightPosition,    99,
				       XmNtranslations, XtParseTranslationTable ( translations_global ) ,
				       NULL
				       ); 
      
      XtAddCallback (button, XmNactivateCallback,
		     die_callback, (XtPointer)(1011));
      
      XtManageChild(button);
      XtManageChild(form);   
      XtManageChild(rowcol);
      MyPopup(Att_Demo_drawing);
      
      XtAddCallback(Att_Demo_drawing,XmNdestroyCallback,ShellDeath,(XtPointer)4068);
      
      set_color(Att_Demo_draw,"White",(XtPointer)NULL);
      
      Att_Demo_pix = XCreatePixmap (XtDisplay (Att_Demo_draw),
				RootWindowOfScreen (XtScreen (Att_Demo_draw)), 620,600,
				DefaultDepthOfScreen (XtScreen (Att_Demo_draw)));
      XFillRectangle (XtDisplay (Att_Demo_draw), Att_Demo_pix,       mygc, 0, 0, 620,600);
      

      set_color(Att_Demo_draw,"Blue",(XtPointer)NULL);
         
      XDrawString(XtDisplay(Att_Demo_draw),XtWindow(Att_Demo_draw),mygc,
		  30,33,"Data Extent",15);
      XDrawString(XtDisplay(Att_Demo_draw),Att_Demo_pix,mygc,
		  30,33,"Data Extent",15);
            
      XDrawLine(XtDisplay(Att_Demo_draw),XtWindow(Att_Demo_draw),mygc, 20,20,600,20);
      XDrawLine(XtDisplay(Att_Demo_draw),Att_Demo_pix,           mygc, 20,20,600,20);

      XDrawLine(XtDisplay(Att_Demo_draw),XtWindow(Att_Demo_draw),mygc, 20,20,20,308);
      XDrawLine(XtDisplay(Att_Demo_draw),Att_Demo_pix,           mygc, 20,20,20,308);

      XDrawLine(XtDisplay(Att_Demo_draw),XtWindow(Att_Demo_draw),mygc, 20,308,600,308);
      XDrawLine(XtDisplay(Att_Demo_draw),Att_Demo_pix,           mygc, 20,308,600,308);

      XDrawLine(XtDisplay(Att_Demo_draw),XtWindow(Att_Demo_draw),mygc, 600,308,600,20);
      XDrawLine(XtDisplay(Att_Demo_draw),Att_Demo_pix,           mygc, 600,308,600,20);


      set_color(Att_Demo_draw,"Green",(XtPointer)NULL);

      for(i=0;i<5;i++)
	{
	  	  
	  if(i!=4)
	    {
	      XDrawLine(XtDisplay(Att_Demo_draw),XtWindow(Att_Demo_draw),mygc, 120,50+(i*60),480,50+(i*60));
	      XDrawLine(XtDisplay(Att_Demo_draw),Att_Demo_pix,           mygc, 120,50+(i*60),480,50+(i*60));
	    }
	  else
	    {
	      XDrawLine(XtDisplay(Att_Demo_draw),XtWindow(Att_Demo_draw),mygc, 130,50+(i*60),480,50+(i*60));
	      XDrawLine(XtDisplay(Att_Demo_draw),Att_Demo_pix,           mygc, 130,50+(i*60),480,50+(i*60));	      
	    }
	}

      for(i=0;i<10;i++)
	{
	  
	  if(i==0)
	    {
	      XDrawLine(XtDisplay(Att_Demo_draw),XtWindow(Att_Demo_draw),mygc, 120+(i*40),50,120+(i*40),280);
	      XDrawLine(XtDisplay(Att_Demo_draw),Att_Demo_pix,           mygc, 120+(i*40),50,120+(i*40),280);
	    }
	  else
	    {
	      XDrawLine(XtDisplay(Att_Demo_draw),XtWindow(Att_Demo_draw),mygc, 120+(i*40),50,120+(i*40),290);
	      XDrawLine(XtDisplay(Att_Demo_draw),Att_Demo_pix,           mygc, 120+(i*40),50,120+(i*40),290);
	    }
	}
      XDrawString(XtDisplay(Att_Demo_draw),XtWindow(Att_Demo_draw),mygc,
		  300,305,"Attribution Grid",16);
      XDrawString(XtDisplay(Att_Demo_draw),Att_Demo_pix,mygc,
		  300,305,"Attribution Grid",16);

      set_color(Att_Demo_draw,"Red",(XtPointer)NULL);

      XDrawLine(XtDisplay(Att_Demo_draw),XtWindow(Att_Demo_draw),mygc, 200,200,240,200);
      XDrawLine(XtDisplay(Att_Demo_draw),Att_Demo_pix,           mygc, 200,200,240,200);

      XDrawLine(XtDisplay(Att_Demo_draw),XtWindow(Att_Demo_draw),mygc, 200,200,205,195);
      XDrawLine(XtDisplay(Att_Demo_draw),Att_Demo_pix,           mygc, 200,200,205,195);

      XDrawLine(XtDisplay(Att_Demo_draw),XtWindow(Att_Demo_draw),mygc, 200,200,205,205);
      XDrawLine(XtDisplay(Att_Demo_draw),Att_Demo_pix,           mygc, 200,200,205,205);

      XDrawLine(XtDisplay(Att_Demo_draw),XtWindow(Att_Demo_draw),mygc, 240,200,235,195);
      XDrawLine(XtDisplay(Att_Demo_draw),Att_Demo_pix,           mygc, 240,200,235,195);

      XDrawLine(XtDisplay(Att_Demo_draw),XtWindow(Att_Demo_draw),mygc, 240,200,235,205);
      XDrawLine(XtDisplay(Att_Demo_draw),Att_Demo_pix,           mygc, 240,200,235,205);

      XDrawString(XtDisplay(Att_Demo_draw),XtWindow(Att_Demo_draw),mygc,
		  210,198,"l1",2);
      XDrawString(XtDisplay(Att_Demo_draw),Att_Demo_pix,mygc,
		  210,198,"l1",2);

      sprintf(message,"The distance \"l1\" is called: ");
      XDrawString(XtDisplay(Att_Demo_draw),XtWindow(Att_Demo_draw),mygc,
		  5,325,message,strlen(message));
      XDrawString(XtDisplay(Att_Demo_draw),Att_Demo_pix,mygc,
		  5,325,message,strlen(message));

      sprintf(message,"   \"Attribution Grid X Spacing\"");
      XDrawString(XtDisplay(Att_Demo_draw),XtWindow(Att_Demo_draw),mygc,
		  5,340,message,strlen(message));
      XDrawString(XtDisplay(Att_Demo_draw),Att_Demo_pix,mygc,
		  5,340,message,strlen(message));

 
      set_color(Att_Demo_draw,"Brown",(XtPointer)NULL);

      XDrawLine(XtDisplay(Att_Demo_draw),XtWindow(Att_Demo_draw),mygc, 186, 230, 186, 170);
      XDrawLine(XtDisplay(Att_Demo_draw),Att_Demo_pix,           mygc, 186, 230, 186, 170);

      XDrawLine(XtDisplay(Att_Demo_draw),XtWindow(Att_Demo_draw),mygc, 186, 170, 191, 175);
      XDrawLine(XtDisplay(Att_Demo_draw),Att_Demo_pix,           mygc, 186, 170, 191, 175);

      XDrawLine(XtDisplay(Att_Demo_draw),XtWindow(Att_Demo_draw),mygc, 186, 170, 181, 175);
      XDrawLine(XtDisplay(Att_Demo_draw),Att_Demo_pix,           mygc, 186, 170, 181, 175);

      XDrawLine(XtDisplay(Att_Demo_draw),XtWindow(Att_Demo_draw),mygc, 186, 230, 181, 225);
      XDrawLine(XtDisplay(Att_Demo_draw),Att_Demo_pix,           mygc, 186, 230, 181, 225);

      XDrawLine(XtDisplay(Att_Demo_draw),XtWindow(Att_Demo_draw),mygc, 186, 230, 191, 225);
      XDrawLine(XtDisplay(Att_Demo_draw),Att_Demo_pix,           mygc, 186, 230, 191, 225);

      XDrawString(XtDisplay(Att_Demo_draw),XtWindow(Att_Demo_draw),mygc,
		  162,210,"l2",2);
      XDrawString(XtDisplay(Att_Demo_draw),Att_Demo_pix,mygc,
		  162,210,"l2",2);

      sprintf(message,"The distance \"l2\" is called: ");
      XDrawString(XtDisplay(Att_Demo_draw),XtWindow(Att_Demo_draw),mygc,
		  5,355,message,strlen(message));
      XDrawString(XtDisplay(Att_Demo_draw),Att_Demo_pix,mygc,
		  5,355,message,strlen(message));

      sprintf(message,"   \"Attribution Grid Y Spacing\"");
      XDrawString(XtDisplay(Att_Demo_draw),XtWindow(Att_Demo_draw),mygc,
		  5,370,message,strlen(message));
      XDrawString(XtDisplay(Att_Demo_draw),Att_Demo_pix,mygc,
		  5,370,message,strlen(message));
      
      set_color(Att_Demo_draw,"Purple",(XtPointer)NULL);
      XDrawString(XtDisplay(Att_Demo_draw),XtWindow(Att_Demo_draw),mygc,
		  117,293,"P",1);
      XDrawString(XtDisplay(Att_Demo_draw),Att_Demo_pix,mygc,
		  117,293,"P",1);

      sprintf(message,"The point \"P\" has coordinates: ");
      XDrawString(XtDisplay(Att_Demo_draw),XtWindow(Att_Demo_draw),mygc,
		  5,385,message,strlen(message));
      XDrawString(XtDisplay(Att_Demo_draw),Att_Demo_pix,mygc,
		  5,385,message,strlen(message));

      sprintf(message,"   (Attribution Grid ll corner X-Coordinate,");
      XDrawString(XtDisplay(Att_Demo_draw),XtWindow(Att_Demo_draw),mygc,
		  5,400,message,strlen(message));
      XDrawString(XtDisplay(Att_Demo_draw),Att_Demo_pix,mygc,
		  5,400,message,strlen(message));
 
      sprintf(message,"    Attribution Grid ll corner Y-Coordinate)");
      XDrawString(XtDisplay(Att_Demo_draw),XtWindow(Att_Demo_draw),mygc,
		  5,415,message,strlen(message));
      XDrawString(XtDisplay(Att_Demo_draw),Att_Demo_pix,mygc,
		  5,415,message,strlen(message));
      

      set_color(Att_Demo_draw,"Black",(XtPointer)NULL);
      sprintf(message,"The number of desired vertical cells in the");
      XDrawString(XtDisplay(Att_Demo_draw),XtWindow(Att_Demo_draw),mygc,
		  5,430,message,strlen(message));
      XDrawString(XtDisplay(Att_Demo_draw),Att_Demo_pix,mygc,
		  5,430,message,strlen(message));
      
      sprintf(message,"attribution grid (4 in this example), is called:");
      XDrawString(XtDisplay(Att_Demo_draw),XtWindow(Att_Demo_draw),mygc,
		  5,445,message,strlen(message));
      XDrawString(XtDisplay(Att_Demo_draw),Att_Demo_pix,mygc,
		  5,445,message,strlen(message));
 
      sprintf(message,"   \"Number of X-cells for attribution grid\"");
      XDrawString(XtDisplay(Att_Demo_draw),XtWindow(Att_Demo_draw),mygc,
		  5,460,message,strlen(message));
      XDrawString(XtDisplay(Att_Demo_draw),Att_Demo_pix,mygc,
		  5,460,message,strlen(message));

      sprintf(message,"The number of desired horizontal cells in the");
      XDrawString(XtDisplay(Att_Demo_draw),XtWindow(Att_Demo_draw),mygc,
		  5,475,message,strlen(message));
      XDrawString(XtDisplay(Att_Demo_draw),Att_Demo_pix,mygc,
		  5,475,message,strlen(message));
      
      sprintf(message,"attribution grid (9 in this example), is called:");
      XDrawString(XtDisplay(Att_Demo_draw),XtWindow(Att_Demo_draw),mygc,
		  5,490,message,strlen(message));
      XDrawString(XtDisplay(Att_Demo_draw),Att_Demo_pix,mygc,
		  5,490,message,strlen(message));
 
      sprintf(message,"   \"Number of Y-cells for attribution grid\"");
      XDrawString(XtDisplay(Att_Demo_draw),XtWindow(Att_Demo_draw),mygc,
		  5,505,message,strlen(message));
      XDrawString(XtDisplay(Att_Demo_draw),Att_Demo_pix,mygc,
		  5,505,message,strlen(message));
        
      ATT_DEMO_UP=1;
    }
  else
    {
      ResetWidget(Att_Demo_drawing);
    }  
}



void make_los_result(char *message,char *title,int type)
{
  XmString t; 
  Arg args[15];
  int n=0;
  XmString ok = XmStringCreateLocalized ("OK");
  
  XtSetArg(args[n], XmNautoUnmanage, False);   n++;
  XtSetArg(args[n], XmNcancelLabelString, ok); n++;
  
  if(type==1)
    {fan_info = XmCreateErrorDialog (drawing_a, title, args, n);}
  else  if(type==2)
    {fan_info = XmCreateQuestionDialog (drawing_a, title, args, n);}
  else  if(type==3)
    {fan_info = XmCreateWarningDialog (drawing_a, title, args, n);}
  else  if(type==4)
    {fan_info = XmCreateWorkingDialog (drawing_a, title, args, n);}
  else  
    {fan_info = XmCreateInformationDialog (drawing_a, title, args, n);}
  
  XtUnmanageChild (XmMessageBoxGetChild (fan_info, XmDIALOG_OK_BUTTON));
  XtUnmanageChild (XmMessageBoxGetChild (fan_info, XmDIALOG_HELP_BUTTON));
  
  t = XmStringCreateLtoR (message,XmSTRING_DEFAULT_CHARSET);
  
  XtVaSetValues (fan_info,
		 XmNmessageString,    t,
		 XmNdialogTitle,       STRING(title),
		 NULL);
  
  XtAddCallback (fan_info, XmNcancelCallback, exitCallback, (XtPointer)8);
  XtManageChild (fan_info);
  XtPopup  (XtParent(fan_info), XtGrabNone);  
  FAN_INFO=1;
  XmStringFree (t);
  XmStringFree (ok);
}


void make_err_info(char *message,char *title)
{
  Arg args[15];
  int n,i,num_lines=0;
  Widget form,err_info,button,pane;
  Dimension h,Pheight;

  for(i=0;i<(int)(strlen(message));i++)
    {
      if(message[i]=='\n')
	{
	  num_lines++;
	  if(num_lines>1000){break;}
	}
    }

  if(num_lines>30)
    {
      num_lines = 30;
    }


  n=0;
  XtSetArg(args[n], XmNautoUnmanage,        False);         n++;
  XtSetArg(args[n], XmNwidth,               300);           n++;
  XtSetArg(args[n], XmNmaxWidth,            800);           n++;
  XtSetArg(args[n], XmNminHeight,           150);           n++;
  XtSetArg(args[n], XmNmaxHeight,           600);           n++;
  XtSetArg(args[n], XmNminWidth,            150);           n++;
  XtSetArg(args[n], XmNdeleteResponse,      XmDESTROY);     n++;




  err_info  = XtCreatePopupShell(title,topLevelShellWidgetClass,
				 drawing_a,args,n);
  
  pane = XtVaCreateWidget("pane",xmPanedWindowWidgetClass, err_info,
			  XmNsashWidth,     1, 
			  XmNsashHeight,    1,
			  XmNseparatorOn,   False,
			  XmNsashIndent,    0,
			  NULL
			  );
  
  form = XtVaCreateWidget("panedform",xmFormWidgetClass,pane,
			  XmNfractionBase,5,NULL);
  
  n=0;
  XtSetArg(args[n], XmNscrollVertical,          True);              n++;
  XtSetArg(args[n], XmNscrollHorizontal,        True);              n++;
  XtSetArg(args[n], XmNeditMode,                XmMULTI_LINE_EDIT); n++;
  XtSetArg(args[n], XmNeditable,                False);             n++;
  XtSetArg(args[n], XmNcursorPositionVisible,   False);             n++;
  XtSetArg(args[n], XmNwordWrap,                True);              n++;
  XtSetArg(args[n], XmNvalue,                   message);           n++;
  XtSetArg(args[n], XmNrows,                    num_lines+3);       n++;

   
  text_pane = XmCreateScrolledText(pane,"stuff",args,n);

  XtVaSetValues(XtParent(text_pane),
		XmNleftAttachment,   XmATTACH_FORM,
		XmNrightAttachment,  XmATTACH_FORM,
		XmNtopAttachment,    XmATTACH_FORM,
		XmNbottomAttachment, XmATTACH_FORM,
		NULL
		);

  XtManageChild(text_pane);
  XtManageChild(form);
  
  form = XtVaCreateWidget("panedform",xmFormWidgetClass,pane,
			  XmNfractionBase,5,NULL);
  
  
  
  button = XtVaCreateManagedWidget("OK",
				   xmPushButtonWidgetClass, form,
				   XmNtopAttachment,    XmATTACH_FORM,
				   XmNbottomAttachment, XmATTACH_FORM,
				   XmNleftAttachment,   XmATTACH_POSITION,
				   XmNleftPosition,     2,
				   XmNrightAttachment, XmATTACH_POSITION,
				   XmNrightPosition,   3,
				   XmNshowAsDefault,   True,
				   XmNdefaultButtonShadowThickness, 1,
				   XmNtranslations, XtParseTranslationTable ( translations_global ) ,
				   NULL);


  XtAddCallback (button, XmNactivateCallback, exitCallback, (XtPointer)9);
  
  XtManageChild(form);

  XtVaGetValues(button,XmNheight,&h,NULL);        
  XtVaSetValues(form,XmNpaneMaximum,h,XmNpaneMinimum,h,NULL);

  XtAddCallback(err_info,XmNdestroyCallback,ShellDeath,(XtPointer)217);

  XtManageChild(pane);
  MyPopup  (err_info);  
  ERR_INFO=1;

  XtVaGetValues(err_info,  XmNheight,     &Pheight, NULL);
  

  XtAddEventHandler(err_info,StructureNotifyMask,False, myResizeHandler, (XtPointer)((int)600));

}





void make_running(char *message,char *title,int doneflag)
{
  XmString t;
  Arg args[15];
  int n=0;
  XmString pic = XmStringCreateLocalized ("Stop Inspecting");  
 

  

  t = XmStringCreateLtoR (message,XmSTRING_DEFAULT_CHARSET);

  XtSetArg(args[n], XmNautoUnmanage,      False);                                      n++;
  XtSetArg(args[n], XmNcancelLabelString, pic);                                        n++;
  XtSetArg(args[n], XmNmessageString,     t);                                          n++;
  XtSetArg(args[n], XmNdialogTitle,       STRING(title));                              n++;		
  XtSetArg(args[n], XmNtranslations, XtParseTranslationTable ( translations_global )); n++;


  if(doneflag==0)
    {
      
      XtSetArg(args[n], XmNdialogStyle,       XmDIALOG_PRIMARY_APPLICATION_MODAL); n++;
    }
  else
  {
	 XtSetArg(args[n], XmNdeleteResponse,    XmDESTROY);        n++;  
  }

  running_info = XmCreateInformationDialog (drawing_a, title, args, n);
  
  XtUnmanageChild (XmMessageBoxGetChild (running_info, XmDIALOG_OK_BUTTON));
  XtUnmanageChild (XmMessageBoxGetChild (running_info, XmDIALOG_HELP_BUTTON));
  
  if(batch_mode==1)
  {
	
    XtUnmanageChild (XmMessageBoxGetChild (running_info, XmDIALOG_CANCEL_BUTTON));
  }


  XtAddCallback (running_info, XmNcancelCallback, exitCallback, (XtPointer)24);
  if(doneflag==1)
  {
	XtAddCallback(running_info,XmNdestroyCallback,ShellDeath,(XtPointer)309); 
  }


  XtManageChild (running_info);
  XtPopup  (XtParent(running_info), XtGrabNone);  
  RUNNING_INFO=1;
  XmStringFree (t);
  XmStringFree (pic);
}



void make_fix_running(char *message,char *title,int doneflag)
{
  XmString t;
  Arg args[15];
  int n=0;
  XmString pic = XmStringCreateLocalized ("Stop Repairing the STF");  
  
  if(STOP_FIX_FLAG==1){ XmStringFree (pic); return;}
  
  t = XmStringCreateLtoR (message,XmSTRING_DEFAULT_CHARSET);
  
  XtSetArg(args[n], XmNautoUnmanage,      False);            n++;
  XtSetArg(args[n], XmNcancelLabelString, pic);              n++;
  XtSetArg(args[n], XmNmessageString,     t);                n++;
  XtSetArg(args[n], XmNdialogTitle,       STRING(title));    n++;		
  if(doneflag==0)
    {
      
      XtSetArg(args[n], XmNdialogStyle,       XmDIALOG_PRIMARY_APPLICATION_MODAL); n++;
    }

  fix_running = XmCreateInformationDialog (drawing_a, title, args, n);
  
  XtUnmanageChild (XmMessageBoxGetChild (fix_running, XmDIALOG_OK_BUTTON));
  XtUnmanageChild (XmMessageBoxGetChild (fix_running, XmDIALOG_HELP_BUTTON));

  XtAddCallback (fix_running, XmNcancelCallback, exitCallback,(XtPointer)25);
  XtManageChild (fix_running);
  XtPopup  (XtParent(fix_running), XtGrabNone);  
  FIX_RUNNING=1;
  XmStringFree (t);
  XmStringFree (pic);
}




void make_xml_running(char *message,char *title,int doneflag)
{
  XmString t;
  Arg args[15];
  int n=0;
  
  t = XmStringCreateLtoR (message,XmSTRING_DEFAULT_CHARSET);
  
  XtSetArg(args[n], XmNautoUnmanage,      False);            n++;
  XtSetArg(args[n], XmNmessageString,     t);                n++;
  XtSetArg(args[n], XmNdialogTitle,       STRING(title));    n++;		
  
  XtSetArg(args[n], XmNdialogStyle,       XmDIALOG_PRIMARY_APPLICATION_MODAL); n++;

  xml_running = XmCreateInformationDialog (drawing_a, title, args, n);
  
  XtUnmanageChild (XmMessageBoxGetChild (xml_running, XmDIALOG_OK_BUTTON));
  XtUnmanageChild (XmMessageBoxGetChild (xml_running, XmDIALOG_HELP_BUTTON));
  XtUnmanageChild (XmMessageBoxGetChild (xml_running, XmDIALOG_CANCEL_BUTTON));

  XtAddCallback (xml_running, XmNcancelCallback, exitCallback,(XtPointer)49);


  XtManageChild (xml_running);
  XtPopup  (XtParent(xml_running), XtGrabNone);  
  XML_RUNNING=1;
  XmStringFree (t);
}


void editInputSpecCallback(Widget w,XtPointer data,XtPointer callData)
{
  char command[1000];

  printf("edit Input Spec File %s\n",importdirectory);

  if(USE_DOS==1)
  {
    
    sprintf(command,"start \"tt\" \"%s\"",importdirectory);

    system(command);
  }
  else
  {
    system(importdirectory);
  }

}


void XMLResultsCallback(Widget w,XtPointer data,XtPointer callData)
{
  FILE *errfile;
  XmString t1;
  int uniqnum = (int)data,addy1,addy2,addy3,totallen=0,lines=0;
  char *text1;
  char newstring[500],aline[1000],hugestring[10000];

  XtVaGetValues(msgdialogs[uniqnum],XmNmessageString,&t1,NULL); 

#if((USE_MAC==1)||(USE_DOS==1)||(USE_LINUX==1))
  text1 = XmStringUnparse(t1,NULL,0,XmCHARSET_TEXT,NULL,0,(XmParseModel)NULL);
#else
  XmStringGetLtoR(t1,
		  (XmStringCharSet) XmSTRING_DEFAULT_CHARSET, &text1);
#endif

  addy1 = (int)text1;
  addy2 = (int)strstr(text1,"written to file:");
  addy3 = (int)strstr(text1,"Total time: ");


  sprintf(newstring,"%s",&text1[addy2-addy1+18]);
  newstring[addy3-addy2-18] = '\0';


  errfile = fopen(newstring,"r");
  if(errfile==NULL)
  {
    sprintf(aline,"Error trying to open:\n  %s\n",newstring);

    not_while_running(w,aline,1498,"Unable to open file",1);
	return;
  }

  
  if(INFO_WINDOW==0)
    {
      MakeInfo(1);
    }
  else
    {
      ResetWidget(shellhead2);
    }
  
  hugestring[0] = '\0';

  fgets(aline,1000,errfile);
  lines = lines + 1;
	  
  while(!feof(errfile))
  {
    strcat(hugestring,aline);
	      
    totallen = totallen + strlen(aline);
	      
	if(totallen>9000)
	{
	  infoprint(hugestring);
	  totallen = 0;
	  hugestring[0] = '\0';
	}

	if(lines>10000)
	{
      break;
	}
	fgets(aline,1000,errfile);
	lines = lines + 1;
  }

  if(lines>10000)
  {
    hugestring[0] = '\0';
	sprintf(hugestring,"\n\nAborting output after 10,000 lines...see file for full list of errors:\n  %s\n\n",newstring);
    infoprint(hugestring);
  }
  else
  {
    infoprint(hugestring);
  }

  fclose(errfile);

 }


void shortmsg(Widget w,char *message,int uniqnum,char *title,int type)
{
  static Widget savemessagebox,savemessagebox2;
  XmString t;
  Arg args[15];
  int n=0,newy;
  Dimension thisy;
  extern int DO_QAST,QAST_LEAVEWINDOWS;


  


  
  

  if((uniqnum==1497)&& ((DO_QAST==1)&&(QAST_LEAVEWINDOWS==0)) )
  {
    return;
  }

  if((shortmsg_up[uniqnum]==1) && (uniqnum!=1484) && (uniqnum!=1497) )
    {
      if(uniqnum==1402)
	  {
	   t = XmStringCreateLtoR (message,"mytag1");
	   XtVaSetValues(savemessagebox,XmNmessageString,t,NULL);
	  }
      else if(uniqnum==1440)
	  {
	   t = XmStringCreateLtoR (message,"mytag1");
	   XtVaSetValues(savemessagebox2,XmNmessageString,t,NULL);
	  }

      ResetMBWidget(msgdialogs[uniqnum]);

      return;
    }



  t = XmStringCreateLtoR (message,"mytag1");

  n=0;

  XtSetArg(args[n], XmNdeleteResponse,    XmDESTROY);                                  n++;  
  XtSetArg(args[n], XmNautoUnmanage,      False);                                      n++;

  XtSetArg(args[n], XmNwordWrap,          True);                                       n++; 
  XtSetArg(args[n], XmNscrollHorizontal,  False);                                      n++; 

  if(uniqnum==1219)
  {
    XtSetArg(args[n], XmNhelpLabelString,   STRING("Show Unrecognized Tables/Files")); n++;
    XtSetArg(args[n], XmNokLabelString,     STRING("OK"));                             n++;
    XtSetArg(args[n], XmNcancelLabelString, STRING("Open Input Specification File"));  n++;
  }
  else
  {
    XtSetArg(args[n], XmNhelpLabelString,   STRING("Show Picture"));                   n++;
    XtSetArg(args[n], XmNcancelLabelString, STRING("OK"));                             n++;
  }
  XtSetArg(args[n], XmNmessageString,     t);                                          n++;
  XtSetArg(args[n], XmNdialogTitle,       STRING(title));                              n++;		
  XtSetArg(args[n], XmNtranslations, XtParseTranslationTable ( translations_global )); n++;




  if((uniqnum==1229)||(type==1230))
    {
      XtSetArg(args[n], XmNcancelLabelString, STRING("Sounds Good.")); n++;
    }
  if(uniqnum==1497)
    {
      XtSetArg(args[n], XmNhelpLabelString, STRING("Display Results")); n++;
    }

  if(type==1)
    {
      msgdialogs[uniqnum] = XmCreateErrorDialog       (w, title, args, n);
    }
  else  if(type==2)
    {
      msgdialogs[uniqnum] = XmCreateQuestionDialog    (w, title, args, n);
    }
  else  if(type==3)
    {
      msgdialogs[uniqnum] = XmCreateWarningDialog     (w, title, args, n);
    }
  else  if(type==4)
    {
      msgdialogs[uniqnum] = XmCreateWorkingDialog     (w, title, args, n);
    }
  else  
    {
      msgdialogs[uniqnum] = XmCreateInformationDialog (w, title, args, n);
	}

 
  if(uniqnum==1402)
    {
      savemessagebox  = msgdialogs[uniqnum];
    }
  if(uniqnum==1440)
    {
      savemessagebox2 = msgdialogs[uniqnum];
    }
  if(uniqnum==1597)
    {
      QAST_unzip = msgdialogs[uniqnum];
      XtUnmanageChild (XmMessageBoxGetChild (msgdialogs[uniqnum], XmDIALOG_CANCEL_BUTTON));
    }



  if((uniqnum==1319)||(uniqnum==1320))
    {
      XtAddCallback (msgdialogs[uniqnum], XmNhelpCallback, Los_Pic_Callback, (XtPointer) NULL);
    }

  if((uniqnum>=1304) &&(uniqnum<=1313))
    {
      XtAddCallback (msgdialogs[uniqnum], XmNhelpCallback, Att_Pic_Callback, (XtPointer) NULL);
    }

  if(uniqnum==1497)
    {
      XtAddCallback (msgdialogs[uniqnum], XmNhelpCallback, XMLResultsCallback, (XtPointer)uniqnum);
    }


  if(uniqnum!=1219)
  {
    XtUnmanageChild (XmMessageBoxGetChild (msgdialogs[uniqnum], XmDIALOG_OK_BUTTON));
  }
  else if(USE_DOS==0)
  {
	
    XtUnmanageChild (XmMessageBoxGetChild (msgdialogs[uniqnum], XmDIALOG_CANCEL_BUTTON));
  }



  if(uniqnum==1536)
  {
    XtUnmanageChild (XmMessageBoxGetChild (msgdialogs[uniqnum], XmDIALOG_CANCEL_BUTTON));
	attrdialog = msgdialogs[uniqnum];
  }

  if(uniqnum==1219)
  {
    if(BadInputSpecFile())
	{
      XtAddCallback (msgdialogs[uniqnum], XmNhelpCallback, ShowFCODECallback, (XtPointer) NULL);
      XtAddCallback (msgdialogs[uniqnum], XmNcancelCallback, editInputSpecCallback, (XtPointer)NULL);
	}
    else
	{
      XtUnmanageChild (XmMessageBoxGetChild (msgdialogs[uniqnum], XmDIALOG_HELP_BUTTON));
      XtUnmanageChild (XmMessageBoxGetChild (msgdialogs[uniqnum], XmDIALOG_CANCEL_BUTTON));
	}
    XtAddCallback (msgdialogs[uniqnum], XmNokCallback, exitCallback, (XtPointer)39);
  }
  else if((uniqnum!=1319)&&(uniqnum!=1320)&&(uniqnum!=1497)&&((uniqnum>1313)||(uniqnum<1304)))
  {
    XtUnmanageChild (XmMessageBoxGetChild (msgdialogs[uniqnum], XmDIALOG_HELP_BUTTON));
  }


  if(uniqnum!=1219)
  {
    XtAddCallback (msgdialogs[uniqnum], XmNcancelCallback, exitCallback, (XtPointer)39);
  }

  XtManageChild(msgdialogs[uniqnum]);
  XtAddCallback(msgdialogs[uniqnum],XmNdestroyCallback,ShellDeath2,(XtPointer)uniqnum); 

  XmStringFree (t);
  
  shortmsg_up[uniqnum] = 1;


  XtVaGetValues(msgdialogs[uniqnum],XmNy,&thisy,NULL);  

  if(  
	  (thisy+XtHeight(msgdialogs[uniqnum]))>
	  (DisplayHeight(mydisplay,DefaultScreen(mydisplay))-DOS_HEIGHT_MODIFIER)
	)
  {
	newy = DisplayHeight(mydisplay,DefaultScreen(mydisplay))-
		XtHeight(msgdialogs[uniqnum])-DOS_HEIGHT_MODIFIER;

	if(newy<0)
	{
      
	   newy = 25; 
	}
    XtVaSetValues(msgdialogs[uniqnum],XmNy,newy,NULL);  
  }
}







void not_while_running(Widget w,char *message,int mode,char *title,int type)
{
  XmString t;
  extern int PossibleToPopInfoWin;

    


  if(batch_mode==1)
  {
    if(mode!=-1)
	{
	  if(batchsavefile!=NULL)
	  {
		printf("%s\n\n",message);
		fprintf(batchsavefile,"%s\n",message);
	  }
	  else
	  {
        printf("%s\n",message);
	  }
	  return;
	}
  }


  if((mode==-1)&&(RUNNING_INFO==1))
    {
      if(!strcmp(title,"Data Inspection Summary"))
	  {
		
		
        XtManageChild (XmMessageBoxGetChild (running_info, XmDIALOG_CANCEL_BUTTON));
	  }
  
	  t = XmStringCreateLtoR (message,"mytag1");
	  
	  XtVaSetValues (running_info,
			 XmNmessageString, t,
			 XmNdialogTitle,   STRING(title),
			 NULL);
	  XmStringFree (t);
	  return;
    }
  if((mode==-4)&&(FIX_RUNNING==1))
    {
      t = XmStringCreateLtoR (message,"mytag1");

      XtVaSetValues (fix_running,
		     XmNmessageString,    t,
		     XmNdialogTitle, STRING(title),
		     NULL);
      XmStringFree (t);
      return; 
    }
  else if(mode==-1)
    {
      make_running(message,title,0);
      return;
    }
  else if(mode==-4)
    {
      make_fix_running(message,title,0);
      return;
    }
  else if((mode==-5)&&(XML_RUNNING==1))
  {
    t = XmStringCreateLtoR (message,"mytag1");

    XtVaSetValues (xml_running,
		     XmNmessageString,    t,
		     XmNdialogTitle, STRING(title),
		     NULL);
    XmStringFree (t);
    return;   }
  else if(mode==-5)
  {
     make_xml_running(message,title,0);
	 return;
  }


  if((mode==0)&&(FAN_INFO==1))
    {
      t = XmStringCreateLtoR (message,"mytag1");
      
      XtVaSetValues (fan_info,
		     XmNmessageString,    t,
		     NULL);
      XmStringFree (t);
      return; 
    }  
  else if(mode==0)
    {
      make_los_result(message,title,type);
      return;
    }

  if((mode==-2)&&(ERR_INFO==1)&&(DetailedInfo==1))
    {
      
      
      XtVaSetValues (text_pane,
		     XmNvalue, message,
		     NULL);
      
      XtVaSetValues(XtParent(XtParent(XtParent(text_pane))),
		    XmNtitle, title,
		    NULL);   
      return; 
    }  
  else if((mode==-2)&&(ERR_INFO==1)&&(DetailedInfo==2))
    {
      XtVaSetValues (text_pane,
		     XmNvalue, message,
		     NULL);
      
      XtVaSetValues(XtParent(XtParent(XtParent(text_pane))),
		    XmNtitle, title,
		    NULL);   

      
      ResetWidget(XtParent(XtParent(XtParent(text_pane))));   
      return; 
    }  
  else if((mode==-2)&&(DetailedInfo>0))
    {
      
      if(PossibleToPopInfoWin==1)
	  {
        
        make_err_info(message,title);
	  }
      return;
    }
  else if((mode==-2)&&(ERR_INFO==1))
    {
      
      XtDestroyWidget(XtParent(XtParent(XtParent(text_pane))));
      return;
    }
  else if(mode==-2)
    {
      
      return;
    }





  if(mode>=1000)
    {
      shortmsg(w,message,mode,title,type);
    }
  else
    {
      printf("Got bad uniqnum %d\n",mode);
      XBell(mydisplay,50);
      return;
    }
}




void inputfilehelpDialogCallback(Widget w,XtPointer data,XtPointer callData)
{
 
  if(NGA_TYPE==1)
    {
      if(USE_DOS==1)
	{
	  not_while_running(w,"This window is used to specify a folder containing a GAIT\n\
project.  This project must have been created by the GAIT\n\
import process.",1114,"Input Project",5);
	}
      else
	{
	  not_while_running(w,"This window is used to specify a directory containing a GAIT\n\
project.  This database must have been created by the GAIT\n\
import and format processes.",1115,"Input Project",5);
	}
    }
  else
    {
      not_while_running(w,"This window is used to specify a directory containing a SEE-IT\n\
database.  This database must have been created by the SEE-IT\n\
import and format processes.",1116,"Input Directory",5);
    }
}


void importfilehelpDialogCallback(Widget w,XtPointer data,XtPointer callData)
{     
  not_while_running(w,"You may now specify the database you wish to import.\n\
For STF files, you must specify the root stf file.",1117,"Import Database",5);
  
}


void patchfilehelpDialogCallback(Widget w,XtPointer data,XtPointer callData)
{     
  not_while_running(w,"Use this dialog to specify the (previously created)\n\
patch file you wish to use.",1118,"Select Patch File",5);
}


void stffilehelpDialogCallback(Widget w,XtPointer data,XtPointer callData)
{     
  not_while_running(w,"Use this dialog to specify the STF root\n\
file to be OVERWRITTEN while applying the repairs specified\n\
in your patch file.",1119,"Select STF File",5);
}



void openProjectCallbackClean(Widget w,Widget list_w,XtPointer unused)
{
  extern int unsavedignore;
  extern int UnsavedConditions;

  printf("opening project even though there are unsaved conditions or ignore settings\n");

  unsavedignore = 0;
  UnsavedConditions = 0;

  openProjectCallback(w,list_w,unused);
}


void openProjectCallback(Widget w,Widget list_w,XtPointer unused)
{
  XmString *selectlist;
  char *text;
  char message[1000];
  int totalobjs;
  extern int unsavedignore;
  extern int UnsavedConditions;


  if(BadConditions(1,w,list_w,0))
  { 
    return;
  }  


  XtVaGetValues(list_w,
		XmNselectedItemCount,&totalobjs,
		XmNselectedItems    ,&selectlist,
		NULL);
  

  if(totalobjs!=1)
    {
      sprintf(message,"To open a GAIT project, select one of the projects\n\
in the list, and then click \"Open Selected Project\",\n\
or double-click it in the list.");

      not_while_running(w,message,1417,"Open Project Help",5);
 
      return;
    }

  XmStringGetLtoR(selectlist[0],
		  (XmStringCharSet) XmSTRING_DEFAULT_CHARSET, &text);
  

  sscanf(text,"%s",project_to_open);

  printf("open project %s\n",project_to_open);

  if((input_source>0)&&(output_source>0))
  {
	
    
    zerooutCallback((Widget)NULL, (XtPointer)1, (XtPointer) 0);
  }

  inputfileDialogCallback(drawing_a,(XtPointer)2,
			  (XmFileSelectionBoxCallbackStruct *)NULL);


  XtFree(text);

}




void PickHelpCallback(Widget w,XtPointer data,XtPointer callData)
{     
  int type=(int)data;
  char message[2000];

  if(type==1)
    {
      sprintf(message,"This window is used to select a GAIT project to open.  The valid\n\
projects found in the current GAIT project folder are shown.  To open\n\
a project, select it from the list and then click \"Open Selected Project\",\n\
or double-click it in the list.");

      not_while_running(w,message,1416,"Select Project Help",5);
    }
  else if(type==2)
    {
      sprintf(message,"This window is used to load inspection settings. There are 2 choices:\n\n\
To load a master specification profile, select the appropriate button.\n\
                              ---or---                             \n\
To load an individual inspection file, select the filename from the list shown,\n\
and then click the \"Load Selected File\" button.  The files shown are\n\
the files GAIT has tailored automatically for this project, plus any\n\
additional files the user may have saved.\n\n\
When loading an individual inspection file (not a master profile), you may choose\n\
to either add those specifications to the current set or not by using the button\n\
labeled \"Add to current specifications when loading file\".");

      not_while_running(w,message,1421,"Load Inspection File Help",5);
    }

  else if(type==3)
    {
      sprintf(message,"This window is used to load previously saved condition reports.\n\
Condition reports found in the current project are shown.  To load\n\
a condition report, select it from the list and then click\n\
\"Load Selected Condition Report\", or double-click it in the list.");

      not_while_running(w,message,1427,"Load Condition Report Help",5);
    }
  else if(type==4)
    {

      sprintf(message,"\
This window is used to specify which project's exported shapefile\n\
results you with to use when using the \"Mark results using exported\n\
shapefiles in project:\" option.\n\n\
Projects in the current GAIT project folder which contain exported\n\
shapefiles are listed.\n\n\
To select a project, select it from the list and then click\n\
\"Use Selected Project's Exported Shapefiles\", or double-click it in the list.");


      not_while_running(w,message,1431,"Select Project With Exported Shapefiles Help",5);
    }
  else if(type==5)
    {
      sprintf(message,"This window is used to load previously saved location sets.\n\
Location sets found in the current project are shown.  To load\n\
a location set, select it from the list and then click\n\
\"Load Selected Location Set\", or double-click it in the list.");



      not_while_running(w,message,1438,"Select Location Set Help",5);
    }
  else if(type==6)
    {
      sprintf(message,"\
This window is used to select a layer preference set to use when\n\
creating a GAIT project.  Layer preference sets contain preferences\n\
for colors, styles, and rendering priorities.\n\n\
For instance, a user may have previously saved a layer preference set\n\
(using the View->By Layer... window) specifying that Area BUILDINGs should\n\
be drawn blue, with rendering priority 3, and style \"Heavy Filling\".\n\n\
The user could then load this preference set and GAIT will apply these\n\
preferences when creating a new project.\n\n\
Preference sets are stored in a folder called \"ProjectPreferences\" which\n\
is located inside the current \"projects\" folder.  The preference sets\n\
found are shown.  To load a preference set, select it from the list and\n\
then click \"Use Selected Layer Preference Set\", or double-click it in the list.");
      
      not_while_running(w,message,1450,"Select Location Set Help",5);
    }
  else if(type==7)
    {
      sprintf(message,"\
This window is used to select a layer preference set to use with\n\
the \"Save/Load Layer Preferences\" window.\n\n\
After selecting a layer preference set using this window, the\n\
\"Save/Load Layer Preferences\" window may be used to either\n\
load that preference set, or to modify that preference set and\n\
save the modified preference set with a new name.\n\n\
Layer preference sets contain preferences for colors, styles,\n\
and rendering priorities.\n\n\
For instance, a user may have previously saved a layer preference set\n\
(using the \"Save/Load Layer Preferences\" window) specifying that Area BUILDINGs\n\
should be drawn blue, with rendering priority 3, and style \"Heavy Filling\".\n\n\
The user could then load this preference set and GAIT will apply these\n\
preferences to the current project.\n\n\
Preference sets are stored in a folder called \"ProjectPreferences\" which\n\
is located inside the current \"projects\" folder.  The preference sets\n\
found are shown.  To choose a preference set, select it from the list and\n\
then click \"Use Selected Layer Preference Set\", or double-click it in the list.");
 
      not_while_running(w,message,1454,"Select Location Set Help",5);
    }
  else if(type==8)
    {
      sprintf(message,"\
This window is used to load and save preference sets.\n\n\
To save the current state of GAIT as a preference set, enter a name\n\
for the new preference set and click \"Save Preferences\".\n\n\
To load a preference set, select it in the list and click\n\
\"Load Selected Preference Set\".\n\n\
Preference sets are saved in the \"ProjectPreferences\" folder inside\n\
the current projects folder, so changing the project folder will change\n\
what preferences are available and where your preferences get saved.\n");

      not_while_running(w,message,1605,"Select Location Set Help",5);
  }
  else if(type==9)
  { 
      sprintf(message,"This window is used to load network settings. There are 2 choices:\n\n\
To load a known set of network specifications, select the appropriate button\n\
(for example, \"Load MGCP Network Specifications\").\n\
                              ---or---                             \n\
To load an individual specification file, select the filename from the list shown,\n\
and then click the \"Load Selected File\" button.  The files shown are\n\
the files GAIT has tailored automatically for this project, plus any\n\
additional files the user may have saved.");

      not_while_running(w,message,1608,"Load Network Specification File Help",5);
  }
  else
  {
      XBell(mydisplay,50);
      printf("bad value %d to PichHelpCallback\n",type);
  }
}




void MyPopup(Widget wid)
{
  Widget comp_parent;
  int dis_wid,dis_hgt,ancestor_hgt,newval;
  Dimension parentx,parenty,thisx,thisy;

  

  if(overriding_parent_wid!=NULL)
  {
    comp_parent = overriding_parent_wid;
  }
  else
  {
    ancestor_hgt = 0;
    comp_parent = XtParent(wid);

    while(XtIsShell(comp_parent)==False)
     {
       comp_parent = XtParent(comp_parent);
       ancestor_hgt = ancestor_hgt + 1;
       if(ancestor_hgt>10)
	{
          break;
	}
     }
  }

  
  XtVaGetValues(comp_parent,XmNx, &parentx,NULL);  
  XtVaGetValues(comp_parent,XmNy, &parenty,NULL);  

  dis_wid = DisplayWidth(mydisplay,DefaultScreen(mydisplay));
  dis_hgt = DisplayHeight(mydisplay,DefaultScreen(mydisplay)) - DOS_HEIGHT_MODIFIER; 

  
 
  if(
	  ((parentx+XtWidth(comp_parent)/4)<dis_wid) &&
	  ((parentx+XtWidth(comp_parent)/4)>0)
	  )
  {
    XtVaSetValues(wid,XmNx, parentx+XtWidth(comp_parent)/4,NULL);  
  }
  else
  {
	
    XtVaSetValues(wid,XmNx,1,NULL);  
  }

 
  if(
	  ((parenty+XtHeight(comp_parent)/4)<dis_hgt) &&
	  ((parenty+XtHeight(comp_parent)/4)>0)
	  )
  {
    XtVaSetValues(wid,XmNy, parenty+XtHeight(comp_parent)/4,NULL);  
  }
  else if( (parenty<=dis_hgt))
  {
	
	
    XtVaSetValues(wid,XmNy,parenty,NULL);  
  }

  if(overriding_modal==1)
  {
    XtPopup(wid,XtGrabExclusive);
  }
  else
  {
    XtPopup(wid,XtGrabNone);
  }

  

  XtVaGetValues(wid,XmNx, &thisx,NULL);  
  XtVaGetValues(wid,XmNy, &thisy,NULL);  

  if(thisx<=0)
  {
	
    XtVaSetValues(wid,XmNx,1,NULL);  
  }
  if(thisy<=0)
  {
	
    XtVaSetValues(wid,XmNy,1,NULL);  
  }


  if((thisx+XtWidth(wid))>dis_wid)
  {
	newval = dis_wid-XtWidth(wid)-10;

	if(newval<=0)
	{
	  newval = dis_wid-XtWidth(wid);
	  if(newval<=0)
	  {
	    newval = 1;
	  }
	}
    XtVaSetValues(wid,XmNx,newval,NULL);  
  }


  if((thisy+XtHeight(wid))>dis_hgt)
  {
	newval = dis_hgt-XtHeight(wid);
	if(newval<=0)
	 {
	   newval = 1;
	 }
    XtVaSetValues(wid,XmNy,newval,NULL);  
  }

  if(!strcmp(XtName(wid),"Select GAIT Project"))
  {
	if(XtWidth(wid)>(dis_wid*.9))
	{
	  newval = (int)(dis_wid*.75);
      XtVaSetValues(wid,XmNwidth,newval,NULL);  
	  newval = (int)(dis_wid*.1);
      XtVaSetValues(wid,XmNx,newval,NULL);  
	}
  }
}



void toggle_revert(Widget widget,XtPointer client_data,XtPointer call_data)
{
  if(GLOBAL_ADDSPECS==0)
  { 
    GLOBAL_ADDSPECS = 1;
  }
  else
  {
    GLOBAL_ADDSPECS = 0;
  } 
}


void toggle_offchecks(Widget widget,XtPointer client_data,XtPointer call_data)
{
  if(Offchecks==0)
  { 
    Offchecks = 1;
  }
  else
  {
    Offchecks = 0;
  } 
}


Widget MakePicker(Widget parent,int type, int num, int pass1, int pass2)
{

  
  
  Widget picker,temp_w,list_w,button,form,rowcol,parent_wid,tog,label1;
  XmString *pick_list;
  Arg args[20];
  char thistitle[500];
  int i,foundfeat,foundgrid,n=0,nettype=0;
  

  if(parent==NULL)
  {
	  parent_wid = sw;
  }
  else
  {
	  parent_wid = parent;
  }

  
  if(type==9)
  {
    type = 2;
	nettype = 1;
  }
 

  XtSetArg(args[n],  XmNdeleteResponse, XmDESTROY); n++;
  
  set_cursor(mydisplay,mywindow,WATCH);

  if(type==1)
    {
      picker = XtCreatePopupShell("Select GAIT Project",
				  topLevelShellWidgetClass,parent_wid,args,n);
    }
  else if(type==2)
    {
	  if(nettype==1)
	  {
        picker = XtCreatePopupShell("Select Network Specification File",
				  topLevelShellWidgetClass,parent_wid,args,n);
	  }
	  else
	  {
        picker = XtCreatePopupShell("Select Inspection File",
				  topLevelShellWidgetClass,parent_wid,args,n);
	  }
    }
  else if(type==3)
    {
      picker = XtCreatePopupShell("Select Condition Report",
				  topLevelShellWidgetClass,parent_wid,args,n);
    }
  else if(type==4)
    {
      picker = XtCreatePopupShell("Select Project with Saved Results",
				  topLevelShellWidgetClass,parent_wid,args,n);
    }
  else if(type==5)
    {
      picker = XtCreatePopupShell("Select Saved Locations",
				  topLevelShellWidgetClass,parent_wid,args,n);
    }
  else if((type==6)||(type==7))
    {
      picker = XtCreatePopupShell("Select Layer Preference Set",
				  topLevelShellWidgetClass,parent_wid,args,n);
    }
  else if(type==8)
    {
      picker = XtCreatePopupShell("Load/Save Preferences",
				  topLevelShellWidgetClass,parent_wid,args,n);
    }
  else
    {
      printf("bad type %d to MakePicker\n",type);
      ExitWrapper(-1);
    }

  
  
  rowcol = XtVaCreateManagedWidget
    (
     "XformWidget", xmPanedWindowWidgetClass, picker,
     XmNrubberPositioning, False,
     XmNresizable,         True,
     XmNseparatorOn,       False,
     XmNsashHeight,        1,
     NULL
     );
  
  
  form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			   XmNfractionBase,   100,
			   NULL);
  
  if(type==1)
    {
      foundfeat = pass1;
      foundgrid = pass2;


      if((foundfeat>0)&&(foundgrid>0))
	{
	  sprintf(thistitle,"GAIT Projects (number of features/posts) (attribution schema) (2D/3D):");
	}
      else if(foundfeat>0)
	{
	  sprintf(thistitle,"GAIT Projects (number of features) (attribution schema) (2D/3D):");
	}
      else if(foundgrid>0)
	{
	  sprintf(thistitle,"GAIT Projects (number of posts) (attribution schema) (2D/3D):");
	}
      else
	{
	  sprintf(thistitle,"GAIT Projects (attribution schema) (2D/3D):");
	}

      temp_w = XtVaCreateManagedWidget (thistitle,
					xmLabelWidgetClass,  form,
					XmNtraversalOn,      True,
					XmNrightAttachment,  XmATTACH_POSITION,
					XmNrightPosition,    99,
					XmNleftAttachment,   XmATTACH_POSITION,
					XmNleftPosition,     1,
				        LABELWTRANSLATE,
					NULL);
    }
  else if(type==2)
    {
	  if(nettype==1)
	  {
        temp_w = XtVaCreateManagedWidget ("Available Network Specification Files:",
					xmLabelWidgetClass,  form,
					XmNtraversalOn,      True,
					XmNrightAttachment,  XmATTACH_POSITION,
					XmNrightPosition,    99,
					XmNleftAttachment,   XmATTACH_POSITION,
					XmNleftPosition,     1,
				        LABELWTRANSLATE,
					NULL);
	  }
	  else
	  {
        temp_w = XtVaCreateManagedWidget ("Available Inspection Files:",
					xmLabelWidgetClass,  form,
					XmNtraversalOn,      True,
					XmNrightAttachment,  XmATTACH_POSITION,
					XmNrightPosition,    99,
					XmNleftAttachment,   XmATTACH_POSITION,
					XmNleftPosition,     1,
				        LABELWTRANSLATE,
					NULL);
	  }
    }
  else if(type==3)
    {
      temp_w = XtVaCreateManagedWidget ("Available Condition Reports:",
					xmLabelWidgetClass,  form,
					XmNtraversalOn,      True,
					XmNrightAttachment,  XmATTACH_POSITION,
					XmNrightPosition,    99,
					XmNleftAttachment,   XmATTACH_POSITION,
					XmNleftPosition,     1,
				        LABELWTRANSLATE,
					NULL);
    }
  else if(type==4)
    {
      temp_w = XtVaCreateManagedWidget ("Available Projects With Exported Results:",
					xmLabelWidgetClass,  form,
					XmNtraversalOn,      True,
					XmNrightAttachment,  XmATTACH_POSITION,
					XmNrightPosition,    99,
					XmNleftAttachment,   XmATTACH_POSITION,
					XmNleftPosition,     1,
				        LABELWTRANSLATE,
					NULL);
    }
  else if(type==5)
    {
      temp_w = XtVaCreateManagedWidget ("Available Location Sets:",
					xmLabelWidgetClass,  form,
					XmNtraversalOn,      True,
					XmNrightAttachment,  XmATTACH_POSITION,
					XmNrightPosition,    99,
					XmNleftAttachment,   XmATTACH_POSITION,
					XmNleftPosition,     1,
				        LABELWTRANSLATE,
					NULL);
    }
  else if((type==6)||(type==7))
    {
      temp_w = XtVaCreateManagedWidget ("Available Layer Preference Sets:",
					xmLabelWidgetClass,  form,
					XmNtraversalOn,      True,
					XmNrightAttachment,  XmATTACH_POSITION,
					XmNrightPosition,    99,
					XmNleftAttachment,   XmATTACH_POSITION,
					XmNleftPosition,     1,
				        LABELWTRANSLATE,
					NULL);
    }
  else if(type==8)
    {
      temp_w = XtVaCreateManagedWidget ("Available Preference Sets:",
					xmLabelWidgetClass,  form,
					XmNtraversalOn,      True,
					XmNrightAttachment,  XmATTACH_POSITION,
					XmNrightPosition,    99,
					XmNleftAttachment,   XmATTACH_POSITION,
					XmNleftPosition,     1,
				        LABELWTRANSLATE,
					NULL);
    }
    
  
  XtManageChild(form);


  pick_list = (XmString *) (malloc(sizeof(XmString *) * num));
  if(pick_list==NULL){printf("bl6: out of allocation memory!\n"); ExitWrapper(-1);}
  
  
  if(type==1)
    {
      for(i=0;i<num;i++)
	{
	  pick_list[i] = XmStringCreateLocalized (GAITProjList[i]);
	}
    }
  else if(type==2)
    {
      for(i=0;i<num;i++)
	{
	  pick_list[i] = XmStringCreateLocalized (GAITExFileList[i]);
	}
    }
  else if(type==3)
    {
      for(i=0;i<num;i++)
	{
	  pick_list[i] = XmStringCreateLocalized (GAITCondList[i]);
	}
    }
  else if(type==4)
    {
      for(i=0;i<num;i++)
	{
	  pick_list[i] = XmStringCreateLocalized (GAITPrevList[i]);
	}
    }
  else if(type==5)
    {
      for(i=0;i<num;i++)
	{
	  pick_list[i] = XmStringCreateLocalized (GAITAOIList[i]);
	}
    }
  else if((type==6)||(type==7))
    {
      for(i=0;i<num;i++)
	{
	  pick_list[i] = XmStringCreateLocalized (GAITPrefList[i]);
	}
    }
  else if(type==8)
    {
      for(i=0;i<num;i++)
	{
	  pick_list[i] = XmStringCreateLocalized (TempFileList[i]);
	}
    }
  


  n=0;
  
  if(type==1)
    {
      XtSetArg(args[n], XmNtranslations, XtParseTranslationTable (list_translations29)); n++;
    }
  else if(type==2)
    {
	  if(nettype==1)
	  {
        XtSetArg(args[n], XmNtranslations, XtParseTranslationTable (list_translations65)); n++;
	  }
	  else
	  {
        XtSetArg(args[n], XmNtranslations, XtParseTranslationTable (list_translations30)); n++;
	  }
    }
  else if(type==3)
    {
      XtSetArg(args[n], XmNtranslations, XtParseTranslationTable (list_translations31)); n++;
    }
  else if(type==4)
    {
      XtSetArg(args[n], XmNtranslations, XtParseTranslationTable (list_translations32)); n++;
    }
  else if(type==5)
    {
      XtSetArg(args[n], XmNtranslations, XtParseTranslationTable (list_translations33)); n++;
    }
  else if(type==6)
    {
      XtSetArg(args[n], XmNtranslations, XtParseTranslationTable (list_translations34)); n++;
    }
  else if(type==7)
    {
      XtSetArg(args[n], XmNtranslations, XtParseTranslationTable (list_translations35)); n++;
    }
  else if(type==8)
    {
      XtSetArg(args[n], XmNtranslations, XtParseTranslationTable (list_translations63)); n++;
    }


  
  XtSetArg(args[n], XmNlistSizePolicy,   XmCONSTANT);         n++;
  XtSetArg(args[n], XmNitemCount,        num);                n++;
  XtSetArg(args[n], XmNvisibleItemCount, 10);                 n++;

  if(num>0)
  {
    XtSetArg(args[n], XmNitems,            pick_list);          n++;
  }

  if(type==2)
  {
	
    XtSetArg(args[n], XmNselectionPolicy,  XmEXTENDED_SELECT);  n++;
  }
  else
  {
    XtSetArg(args[n], XmNselectionPolicy,  XmBROWSE_SELECT);    n++;
  }


  XtSetArg(args[n], XmNtraversalOn,      False);              n++;
  
  list_w = XmCreateScrolledList (rowcol, "pick list",args,n);
  
  
  if(type==1)
    {
      XtVaGetValues(list_w,XmNverticalScrollBar,&vert_scroll[INDB_SCROLL ] ,NULL);
    }
  else if(type==2)
    {
	  if(nettype==1)
	  {
        XtVaGetValues(list_w,XmNverticalScrollBar,&vert_scroll[EXEFILE_NETSCROLL ] ,NULL);
	  }
	  else
	  {
        XtVaGetValues(list_w,XmNverticalScrollBar,&vert_scroll[EXEFILE_SCROLL ] ,NULL);
	  }
    }
  else if(type==3)
    {
      XtVaGetValues(list_w,XmNverticalScrollBar,&vert_scroll[CONDPICK_SCROLL ] ,NULL);
    }
  else if(type==4)
    {
      XtVaGetValues(list_w,XmNverticalScrollBar,&vert_scroll[PREVPICK_SCROLL ] ,NULL);
    }
  else if(type==5)
    {
      XtVaGetValues(list_w,XmNverticalScrollBar,&vert_scroll[AOI_LOAD ] ,NULL);
    }
  else if(type==6)
    {
      XtVaGetValues(list_w,XmNverticalScrollBar,&vert_scroll[LAYER_LOAD ] ,NULL);
    }
  else if(type==7)
    {
      XtVaGetValues(list_w,XmNverticalScrollBar,&vert_scroll[SAVELAYER] ,NULL);
    }
  else if(type==8)
    {
      XtVaGetValues(list_w,XmNverticalScrollBar,&vert_scroll[SAVEPREFS] ,NULL);
    }
  
  XtManageChild (list_w);
  
  
  
  if(type==1)
    {
      
      XtAddCallback (list_w,  XmNdefaultActionCallback, 
		     (XtCallbackProc)openProjectCallback, 
		     list_w);
    }
  else if(type==2)
    {
      

	  if(nettype==1)
	  {
        XtAddCallback (list_w,  XmNdefaultActionCallback, 
		     (XtCallbackProc)loadNETsettingCallback, 
		     list_w);
	  }
	  else
	  {
        XtAddCallback (list_w,  XmNdefaultActionCallback, 
		     (XtCallbackProc)loadEXEsettingCallback, 
		     list_w);
	  }
    }
  else if(type==3)
    {
      XtAddCallback (list_w,  XmNdefaultActionCallback, 
		     (XtCallbackProc)preloadCRsettingCallback,
		     list_w);
    }
  else if(type==4)
    {
      XtAddCallback (list_w,  XmNdefaultActionCallback, 
		     (XtCallbackProc)prevsetCallback,
		     list_w);
    }
  else if(type==5)
    {
      XtAddCallback (list_w,  XmNdefaultActionCallback, 
		     (XtCallbackProc)AOILoadsettingCallback,
		     list_w);
    }
  else if(type==6)
    {
      XtAddCallback (list_w,  XmNdefaultActionCallback, 
		     (XtCallbackProc)LoadLayerPrefCallback,
		     list_w);
    }
  else if(type==7)
    {
      XtAddCallback (list_w,  XmNdefaultActionCallback, 
		     (XtCallbackProc)SetLayerPrefCallback,
		     list_w);
    }
  else if(type==8)
    {
      XtAddCallback (list_w,  XmNdefaultActionCallback, 
		     (XtCallbackProc)LoadPrefCallback,
		     list_w);
    }
  


  
  if(num>0)
  {
    for(i=0;i<num;i++)
    {
      XmStringFree(pick_list[i]);
    }

    free(pick_list);
  }
  
  
  
  if(type==1)
    {
      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNpaneMinimum,   25,
			       XmNpaneMaximum,   25,
			       XmNfractionBase,  100,  
			       NULL);
      
      button = XtVaCreateManagedWidget("Open Selected Project",xmPushButtonWidgetClass,form,
				       XmNlabelString,     STRING("Open Selected Project"),
				       XmNorientation,     XmVERTICAL,
				       XmNleftAttachment,  XmATTACH_POSITION,
				       XmNleftPosition,    1,
				       XmNrightAttachment, XmATTACH_POSITION,
				       XmNrightPosition,   99,
				       XmNtranslations, XtParseTranslationTable ( translations_global ) ,
				       NULL
				       ); 
      
      XtAddCallback(button, XmNactivateCallback,
		    (XtCallbackProc)openProjectCallback,list_w);
      
      XtManageChild(button);
      XtManageChild(form);
    }
  else if(type==2)
    {

	  if(nettype==1)
	  {

		  

      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNpaneMinimum,   25,
			       XmNpaneMaximum,   25,
			       XmNfractionBase,  100,  
			       NULL);
      
      button = XtVaCreateManagedWidget("Load Selected File(s)",xmPushButtonWidgetClass,form,
				       XmNlabelString,     STRING("Load Selected File(s)"),
				       XmNorientation,     XmVERTICAL,
				       XmNleftAttachment,  XmATTACH_POSITION,
				       XmNleftPosition,    1,
				       XmNrightAttachment, XmATTACH_POSITION,
				       XmNrightPosition,   99,
				       XmNtranslations, XtParseTranslationTable ( translations_global ) ,
				       NULL
				       ); 
      
      XtAddCallback(button, XmNactivateCallback,
		    (XtCallbackProc)loadNETsettingCallback,list_w);
      
      XtManageChild(button);
      XtManageChild(form);


      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNpaneMinimum,   25,
			       XmNpaneMaximum,   25,
			       XmNfractionBase,  100,  
			       NULL);
      
      button = XtVaCreateManagedWidget("Load TDS Network Specifications",xmPushButtonWidgetClass,form,
				       XmNlabelString,     STRING("Load TDS Network Specifications"),
				       XmNorientation,     XmVERTICAL,
				       XmNleftAttachment,  XmATTACH_POSITION,
				       XmNleftPosition,    1,
				       XmNrightAttachment, XmATTACH_POSITION,
				       XmNrightPosition,   99,
					   XmNtranslations, XtParseTranslationTable ( translations_global ) ,
				       NULL
				       ); 

      XtAddCallback(button, XmNactivateCallback, preloadNETsettingCallback,(XtPointer)1); 


      XtManageChild(button);
      XtManageChild(form);


      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNpaneMinimum,   25,
			       XmNpaneMaximum,   25,
			       XmNfractionBase,  100,  
			       NULL);
      
      button = XtVaCreateManagedWidget("Load MGCP Network Specifications",xmPushButtonWidgetClass,form,
				       XmNlabelString,     STRING("Load MGCP Network Specifications"),
				       XmNorientation,     XmVERTICAL,
				       XmNleftAttachment,  XmATTACH_POSITION,
				       XmNleftPosition,    1,
				       XmNrightAttachment, XmATTACH_POSITION,
				       XmNrightPosition,   99,
					   XmNtranslations, XtParseTranslationTable ( translations_global ) ,
				       NULL
				       ); 
      
      XtAddCallback(button, XmNactivateCallback, preloadNETsettingCallback,(XtPointer)2); 
      
      XtManageChild(button);
      XtManageChild(form);




	  }
	  else
	  {
	    form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNpaneMinimum,   25,
			       XmNpaneMaximum,   25,
			       XmNfractionBase,  100,  
			       NULL);

        tog = XtVaCreateManagedWidget ("the_test",
				 xmToggleButtonWidgetClass, form,
				 XmNtraversalOn,      False,
                 XmNleftAttachment,  XmATTACH_POSITION,
                 XmNleftPosition,    1,
                 XmNrightAttachment, XmATTACH_POSITION,
                 XmNrightPosition,   99,
                 XmNlabelString,      STRING("Add to current specifications when loading file"),
                 XmNtranslations, XtParseTranslationTable ( translations_global ) ,
				 TOGGLEINCLUDE,
				 NULL);
  
       XtManageChild(tog);
       XtManageChild(form);

       XtAddCallback (tog, XmNvalueChangedCallback, toggle_revert, (XtPointer)NULL);
       XmToggleButtonSetState(tog,(Boolean)GLOBAL_ADDSPECS,(Boolean)0);





	   form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNpaneMinimum,   25,
			       XmNpaneMaximum,   25,
			       XmNfractionBase,  100,  
			       NULL);

      tog = XtVaCreateManagedWidget ("the_test",
				 xmToggleButtonWidgetClass, form,
				 XmNtraversalOn,      False,
                 XmNleftAttachment,  XmATTACH_POSITION,
                 XmNleftPosition,    1,
                 XmNrightAttachment, XmATTACH_POSITION,
                 XmNrightPosition,   99,
                 XmNlabelString,      STRING("Turn off inspections with invalid/incomplete specifications"),
                 XmNtranslations, XtParseTranslationTable ( translations_global ) ,
				 TOGGLEINCLUDE,
				 NULL);
  
     XtManageChild(tog);
     XtManageChild(form);

     XtAddCallback (tog, XmNvalueChangedCallback, toggle_offchecks, (XtPointer)NULL);
     XmToggleButtonSetState(tog,(Boolean)Offchecks,(Boolean)0);




      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNpaneMinimum,   25,
			       XmNpaneMaximum,   25,
			       XmNfractionBase,  100,  
			       NULL);
      
      button = XtVaCreateManagedWidget("Load Selected File(s)",xmPushButtonWidgetClass,form,
				       XmNlabelString,     STRING("Load Selected File(s)"),
				       XmNorientation,     XmVERTICAL,
				       XmNleftAttachment,  XmATTACH_POSITION,
				       XmNleftPosition,    1,
				       XmNrightAttachment, XmATTACH_POSITION,
				       XmNrightPosition,   99,
				       XmNtranslations, XtParseTranslationTable ( translations_global ) ,
				       NULL
				       ); 
      
      XtAddCallback(button, XmNactivateCallback,
		    (XtCallbackProc)loadEXEsettingCallback,list_w);
      
      XtManageChild(button);
      XtManageChild(form);






      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNpaneMinimum,   25,
			       XmNpaneMaximum,   25,
			       XmNfractionBase,  100,  
			       NULL);
      
      button = XtVaCreateManagedWidget("Load MGCP Master Profile",xmPushButtonWidgetClass,form,
				       XmNlabelString,     STRING("Load MGCP Master Profile"),
				       XmNorientation,     XmVERTICAL,
				       XmNleftAttachment,  XmATTACH_POSITION,
				       XmNleftPosition,    1,
				       XmNrightAttachment, XmATTACH_POSITION,
				       XmNrightPosition,   99,
					   XmNtranslations, XtParseTranslationTable ( translations_global ) ,
				       NULL
				       ); 
      
      XtAddCallback(button, XmNactivateCallback, preloadsettingCallback,(XtPointer)1);
      
      XtManageChild(button);
      XtManageChild(form);





      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNpaneMinimum,   25,
			       XmNpaneMaximum,   25,
			       XmNfractionBase,  100,  
			       NULL);
      
      button = XtVaCreateManagedWidget("Load DFEG Master Profile",xmPushButtonWidgetClass,form,
				       XmNlabelString,     STRING("Load DFEG Master Profile"),
				       XmNorientation,     XmVERTICAL,
				       XmNleftAttachment,  XmATTACH_POSITION,
				       XmNleftPosition,    1,
				       XmNrightAttachment, XmATTACH_POSITION,
				       XmNrightPosition,   99,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
				       NULL
				       ); 
      
      XtAddCallback(button, XmNactivateCallback, preloadsettingCallback,(XtPointer)2);

      XtManageChild(button);
      XtManageChild(form);



      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNpaneMinimum,   25,
			       XmNpaneMaximum,   25,
			       XmNfractionBase,  100,  
			       NULL);
      
      button = XtVaCreateManagedWidget("Load UFD1 Master Profile",xmPushButtonWidgetClass,form,
				       XmNlabelString,     STRING("Load UFD1 Master Profile"),
				       XmNorientation,     XmVERTICAL,
				       XmNleftAttachment,  XmATTACH_POSITION,
				       XmNleftPosition,    1,
				       XmNrightAttachment, XmATTACH_POSITION,
				       XmNrightPosition,   99,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
				       NULL
				       ); 
      
      XtAddCallback(button, XmNactivateCallback, preloadsettingCallback,(XtPointer)4);

      XtManageChild(button);
      XtManageChild(form);


      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNpaneMinimum,   25,
			       XmNpaneMaximum,   25,
			       XmNfractionBase,  100,  
			       NULL);
      
      button = XtVaCreateManagedWidget("Load UFD3 Master Profile",xmPushButtonWidgetClass,form,
				       XmNlabelString,     STRING("Load UFD3 Master Profile"),
				       XmNorientation,     XmVERTICAL,
				       XmNleftAttachment,  XmATTACH_POSITION,
				       XmNleftPosition,    1,
				       XmNrightAttachment, XmATTACH_POSITION,
				       XmNrightPosition,   99,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
				       NULL
				       ); 
      
      XtAddCallback(button, XmNactivateCallback, preloadsettingCallback,(XtPointer)5);

      XtManageChild(button);
      XtManageChild(form);



      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNpaneMinimum,   25,
			       XmNpaneMaximum,   25,
			       XmNfractionBase,  100,  
			       NULL);
      
      button = XtVaCreateManagedWidget("Load TDS Master Profile",xmPushButtonWidgetClass,form,
				       XmNlabelString,     STRING("Load TDS Master Profile"),
				       XmNorientation,     XmVERTICAL,
				       XmNleftAttachment,  XmATTACH_POSITION,
				       XmNleftPosition,    1,
				       XmNrightAttachment, XmATTACH_POSITION,
				       XmNrightPosition,   99,
				       XmNtranslations, XtParseTranslationTable ( translations_global ) ,
				       NULL
				       ); 
      
      XtAddCallback(button, XmNactivateCallback, preloadsettingCallback,(XtPointer)13);

      XtManageChild(button);
      XtManageChild(form);



      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNpaneMinimum,   25,
			       XmNpaneMaximum,   25,
			       XmNfractionBase,  100,  
			       NULL);
      
       button = XtVaCreateManagedWidget("Load AFD Master Profile",xmPushButtonWidgetClass,form,
				       XmNlabelString,     STRING("Load AFD Master Profile"),
				       XmNorientation,     XmVERTICAL,
				       XmNleftAttachment,  XmATTACH_POSITION,
				       XmNleftPosition,    1,
				       XmNrightAttachment, XmATTACH_POSITION,
				       XmNrightPosition,   99,
				       XmNtranslations, XtParseTranslationTable ( translations_global ) ,
				       NULL
				       ); 
      
       XtAddCallback(button, XmNactivateCallback, preloadsettingCallback,(XtPointer)10);

       XtManageChild(button);
       XtManageChild(form);



      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNpaneMinimum,   25,
			       XmNpaneMaximum,   25,
			       XmNfractionBase,  100,  
			       NULL);

      button = XtVaCreateManagedWidget("Load TREx Master Profile",xmPushButtonWidgetClass,form,
				       XmNlabelString,     STRING("Load TREx Master Profile"),
				       XmNorientation,     XmVERTICAL,
				       XmNleftAttachment,  XmATTACH_POSITION,
				       XmNleftPosition,    1,
				       XmNrightAttachment, XmATTACH_POSITION,
				       XmNrightPosition,   99,
				       XmNtranslations, XtParseTranslationTable ( translations_global ) ,
				       NULL
				       ); 
      
      XtAddCallback(button, XmNactivateCallback, preloadsettingCallback,(XtPointer)12);

      XtManageChild(button);
      XtManageChild(form);


	 }
    } 
  else if(type==3)
    {
      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNpaneMinimum,   25,
			       XmNpaneMaximum,   25,
			       XmNfractionBase,  100,  
			       NULL);
      
      button = XtVaCreateManagedWidget("Load Selected Condition Report",xmPushButtonWidgetClass,form,
				       XmNlabelString,     STRING("Load Selected Condition Report"),
				       XmNorientation,     XmVERTICAL,
				       XmNleftAttachment,  XmATTACH_POSITION,
				       XmNleftPosition,    1,
				       XmNrightAttachment, XmATTACH_POSITION,
				       XmNrightPosition,   99,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
				       NULL
				       ); 
      

      XtAddCallback(button, XmNactivateCallback,
		    (XtCallbackProc)preloadCRsettingCallback,list_w);

      XtManageChild(button);
      XtManageChild(form);
    }
  else if(type==4)
    {
      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNpaneMinimum,   25,
			       XmNpaneMaximum,   25,
			       XmNfractionBase,  100,  
			       NULL);
      
      button = XtVaCreateManagedWidget("Open Selected Project",xmPushButtonWidgetClass,form,
				       XmNlabelString,     STRING("Use Selected Project's Exported Shapefiles"),
				       XmNorientation,     XmVERTICAL,
				       XmNleftAttachment,  XmATTACH_POSITION,
				       XmNleftPosition,    1,
				       XmNrightAttachment, XmATTACH_POSITION,
				       XmNrightPosition,   99,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
				       NULL
				       ); 
      
      XtAddCallback(button, XmNactivateCallback,
		    (XtCallbackProc)prevsetCallback,list_w);
      
      XtManageChild(button);
      XtManageChild(form);
    }
  else if(type==5)
    {
      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNpaneMinimum,   25,
			       XmNpaneMaximum,   25,
			       XmNfractionBase,  100,  
			       NULL);
      
      button = XtVaCreateManagedWidget("Load Selected Location Set",xmPushButtonWidgetClass,form,
				       XmNlabelString,     STRING("Load Selected Location Set"),
				       XmNorientation,     XmVERTICAL,
				       XmNleftAttachment,  XmATTACH_POSITION,
				       XmNleftPosition,    1,
				       XmNrightAttachment, XmATTACH_POSITION,
				       XmNrightPosition,   99,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
				       NULL
				       ); 
      
      XtAddCallback(button, XmNactivateCallback,
		    (XtCallbackProc)AOILoadsettingCallback,list_w);
      
      XtManageChild(button);
      XtManageChild(form);
    }
  
  else if(type==6)
    {
      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNpaneMinimum,   25,
			       XmNpaneMaximum,   25,
			       XmNfractionBase,  100,  
			       NULL);
      
      button = XtVaCreateManagedWidget("Load Selected Location Set",xmPushButtonWidgetClass,form,
				       XmNlabelString,     STRING("Use Selected Layer Preference Set"),
				       XmNorientation,     XmVERTICAL,
				       XmNleftAttachment,  XmATTACH_POSITION,
				       XmNleftPosition,    1,
				       XmNrightAttachment, XmATTACH_POSITION,
				       XmNrightPosition,   99,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
				       NULL
				       ); 
      
      XtAddCallback(button, XmNactivateCallback,
		    (XtCallbackProc)LoadLayerPrefCallback,list_w);
      
      XtManageChild(button);
      XtManageChild(form);
    }
 else if(type==7)
    {
      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNpaneMinimum,   25,
			       XmNpaneMaximum,   25,
			       XmNfractionBase,  100,  
			       NULL);
      
      button = XtVaCreateManagedWidget("Choose Selected Location Set",xmPushButtonWidgetClass,form,
				       XmNlabelString,     STRING("Use Selected Layer Preference Set"),
				       XmNorientation,     XmVERTICAL,
				       XmNleftAttachment,  XmATTACH_POSITION,
				       XmNleftPosition,    1,
				       XmNrightAttachment, XmATTACH_POSITION,
				       XmNrightPosition,   99,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
				       NULL
				       ); 
      
      XtAddCallback(button, XmNactivateCallback,
		    (XtCallbackProc)SetLayerPrefCallback,list_w);
      
      XtManageChild(button);
      XtManageChild(form);
    }

 else if(type==8)
    {
      
      form = XtVaCreateWidget ("form7", xmFormWidgetClass, rowcol,
			   XmNpaneMinimum,     35,
			   XmNpaneMaximum,     35,
			   XmNseparatorOn,     False,
			   XmNfractionBase,    100,  
			   NULL);
  
  
      label1 = XtVaCreateManagedWidget ("Name for saving preferences:",
				    xmLabelWidgetClass,  form,
				    XmNrightAttachment,  XmATTACH_POSITION,
				    XmNrightPosition,    50,
				    XmNleftAttachment,   XmATTACH_POSITION,
				    XmNleftPosition,     0,
				    XmNalignment,        XmALIGNMENT_CENTER,
				    XmNtopAttachment,    XmATTACH_FORM,
				    XmNbottomAttachment, XmATTACH_FORM,
				    LABELWTRANSLATE,
				    NULL);
      XtManageChild(label1);
  
  
  
      savepref_wid = XtVaCreateManagedWidget ("text_w",
					  xmTextFieldWidgetClass, form,	  
					  XmNvalue,               SavePrefName,
					  XmNmaxLength,           24,
					  XmNtraversalOn,         True,
					  XmNrightAttachment,     XmATTACH_POSITION,
					  XmNrightPosition,       99,
					  XmNleftAttachment,      XmATTACH_POSITION,
					  XmNleftPosition,        51,
					  XmNtopAttachment,       XmATTACH_FORM,
					  XmNbottomAttachment,    XmATTACH_FORM,
                      XmNtranslations,        XtParseTranslationTable ( translations_paste ) ,
					  NULL);
  
      XtAddCallback (savepref_wid, XmNactivateCallback,
		   EnterFileCallback, (XtPointer)33);
      XtManageChild(savepref_wid);
      XtManageChild(form);



      form = XtVaCreateWidget ("form17e", xmFormWidgetClass, rowcol,
			   XmNpaneMinimum,   35,
			   XmNpaneMaximum,   35,
			   XmNseparatorOn,   False,
			   XmNfractionBase,  100,  
			   NULL);      


     button = XtVaCreateManagedWidget("Choose Selected Preferences",xmPushButtonWidgetClass,form,
				       XmNlabelString,     STRING("Load Selected Preference Set"),
                       XmNtopAttachment,                XmATTACH_FORM,
                       XmNbottomAttachment,             XmATTACH_FORM,
				       XmNorientation,     XmVERTICAL,
				       XmNleftAttachment,  XmATTACH_POSITION,
				       XmNleftPosition,    1,
				       XmNrightAttachment, XmATTACH_POSITION,
				       XmNrightPosition,   60,
                       
					   XmNtranslations, XtParseTranslationTable ( translations_global ) ,
				       NULL
				       ); 

     XtAddCallback(button, XmNactivateCallback,
		    (XtCallbackProc)LoadPrefCallback,list_w);



      button  = XtVaCreateManagedWidget("SCR4",xmPushButtonWidgetClass,form,
				    XmNlabelString,                  STRING("Save Preferences"),
				    XmNtopAttachment,                XmATTACH_FORM,
				    XmNbottomAttachment,             XmATTACH_FORM,
				    XmNrightAttachment,              XmATTACH_POSITION,
				    XmNrightPosition,                99,
				    XmNleftAttachment,               XmATTACH_POSITION,
				    XmNleftPosition,                 61,
					
					
				    
				    XmNtranslations, XtParseTranslationTable ( translations_global ) ,
				    NULL
				    ); 
  
      XtAddCallback(button, XmNactivateCallback, savePrefCallback, (XtPointer) NULL);
      XtManageChild(button); 
      XtManageChild(form);

    }  
  
  form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			   XmNpaneMinimum,   25,
			   XmNpaneMaximum,   25,
			   XmNfractionBase,  100,  
			   NULL);
  
  button = XtVaCreateManagedWidget("Help",xmPushButtonWidgetClass,form,
				   XmNlabelString, STRING("Help"),
				   XmNorientation, XmVERTICAL,
				   XmNleftAttachment,  XmATTACH_POSITION,
				   XmNleftPosition,    1,
				   XmNrightAttachment,  XmATTACH_POSITION,
				   XmNrightPosition,    50,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
				   NULL
				   ); 
  
  if((type==2)&&(nettype==1))
  {
    XtAddCallback(button, XmNactivateCallback,
		PickHelpCallback, (XtPointer)9);
  }
  else
  {
    XtAddCallback(button, XmNactivateCallback,
		PickHelpCallback, (XtPointer)type);
  }

  XtManageChild(button);
  


  button = XtVaCreateManagedWidget("Done",xmPushButtonWidgetClass,form,
				   XmNlabelString,     STRING("Done/Cancel"),
				   XmNorientation,     XmVERTICAL,
				   XmNleftAttachment,  XmATTACH_POSITION,
				   XmNleftPosition,    50,
				   XmNrightAttachment, XmATTACH_POSITION,
				   XmNrightPosition,   99,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
				   NULL
				   ); 




  if(type==1)
    {
      XtAddCallback(button, XmNactivateCallback,
		    die_callback, (XtPointer)1018);
    }
  else if(type==2)
    {
	  if(nettype==1)
	  {
        XtAddCallback(button, XmNactivateCallback,
		    die_callback, (XtPointer)1035);
	  }
	  else
	  {
        XtAddCallback(button, XmNactivateCallback,
		    die_callback, (XtPointer)1019);
	  }
    }
  else if(type==3)
    {
      XtAddCallback(button, XmNactivateCallback,
		    die_callback, (XtPointer)1020);
    }
  else if(type==4)
    {
      XtAddCallback(button, XmNactivateCallback,
		    die_callback, (XtPointer)1021);
    }
  else if(type==5)
    {
      XtAddCallback(button, XmNactivateCallback,
		    die_callback, (XtPointer)1023);
    }
  else if(type==6)
    {
      XtAddCallback(button, XmNactivateCallback,
		    die_callback, (XtPointer)1026);
    }
  else if(type==7)
    {
      XtAddCallback(button, XmNactivateCallback,
		    die_callback, (XtPointer)1027);
    }
  else if(type==8)
    {
      XtAddCallback(button, XmNactivateCallback,
		    die_callback, (XtPointer)1034);
    }



  XtManageChild(button);
  XtManageChild(form);
  XtManageChild(rowcol);


  MyPopup(picker);


  if(type==1)
    {
      XtAddCallback(picker,XmNdestroyCallback,ShellDeath,(XtPointer)4071);
    }
  else if(type==2)
    {
	  if(nettype==1)
	  {
        XtAddCallback(picker,XmNdestroyCallback,ShellDeath,(XtPointer)4100);
	  }
	  else
	  {
        XtAddCallback(picker,XmNdestroyCallback,ShellDeath,(XtPointer)4072);
	  }
    }
  else if(type==3)
    {
      XtAddCallback(picker,XmNdestroyCallback,ShellDeath,(XtPointer)4073);
    }
  else if(type==4)
    {
      XtAddCallback(picker,XmNdestroyCallback,ShellDeath,(XtPointer)4074);
    }
  else if(type==5)
    {
      XtAddCallback(picker,XmNdestroyCallback,ShellDeath,(XtPointer)297);
    }
  else if(type==6)
    {
      XtAddCallback(picker,XmNdestroyCallback,ShellDeath,(XtPointer)4077);
    }
  else if(type==7)
    {
      XtAddCallback(picker,XmNdestroyCallback,ShellDeath,(XtPointer)4079);
    }
  else if(type==8)
    {
      XtAddCallback(picker,XmNdestroyCallback,ShellDeath,(XtPointer)4097);
    }

  set_cursor(mydisplay,mywindow,GOOD);
  return picker;
}





void InputButtonCallback(Widget w,XtPointer data,XtPointer callData)
{ 
  static Widget dialog;
  Widget temp_w,rowcol;
  Arg args[15];
  int n = 0,num,i,foundfeat,foundgrid;
  char message[1000];


  if(running==1)
    {
      not_while_running(w,"You can not select an input directory while\n\
the program is running",1120,"Illegal Manuever",1);   
      return;
    }

  
  if(input_up==1)
    {
      
      ResetWidget(dialog);
      return;
    }
  

  set_cursor(mydisplay,mywindow,WATCH);
 


  if(NGA_TYPE==1)
    {

      num = GetFolders(PROJECTLOC,1,1);

      
      if(num==0)
	{
	  sprintf(message,"No valid, current GAIT projects were found in\n\
the current GAIT project folder:\n\n  %s\n\n\
The \"Specify GAIT Project Folder...\" option under the \"File\"\n\
menu can be used to specify a folder containing GAIT projects,\n\n\
      or\n\n\
The \"Create GAIT Project...\" option under the \"File\" menu can\n\
be used to create GAIT projects in the currently selected GAIT\n\
project folder.\n",PROJECTLOC);
	  
	  not_while_running(w,message,1414,"No Projects Found",1);   
      set_cursor(mydisplay,mywindow,GOOD);
	  return;

	}
      else
	{
	  

	  SortProjList(0,num-1,1);

	  

	}



    ModifyProjList(num,&foundfeat,&foundgrid);


           

      pick_dialog = MakePicker(NULL,1,num,foundfeat,foundgrid); 
      dialog      = pick_dialog;

      input_up = 1;
       
      for(i=0;i<num;i++)
	{
	  free(GAITProjList[i]);
	}
      free(GAITProjList);
      GAITProjList = NULL;

    }
  else
    {

      


      n = 0;
      XtSetArg(args[n], XmNdeleteResponse, XmDESTROY);                   n++;
      
      dialog = XtCreatePopupShell("Input Selection",topLevelShellWidgetClass,
				  drawing_a,args,n);
      
      rowcol = XtVaCreateWidget ("rowcol",
				 xmRowColumnWidgetClass,  dialog, NULL);
      
      
      n = 0;
      
      if(NGA_TYPE==1)
	{
	  if(USE_DOS==1)
	    {
	      XtSetArg(args[n], XmNdirListLabelString,   STRING("Folders"));                       n++;
	      XtSetArg(args[n], XmNselectionLabelString, STRING("Selected GAIT Project folder"));  n++;
	    }
	  else
	    {
	      XtSetArg(args[n], XmNselectionLabelString, STRING("Selected GAIT Project Directory")); n++;
	    }
	}
      else
	{
	  XtSetArg(args[n], XmNselectionLabelString, STRING("Selected SEE-IT DB (directory)"));      n++;
	}
      
      
      if(NGA_TYPE==1)
	{
	  XtSetArg(args[n], XmNdirectory,  STRING(PROJECTLOC));    n++;
	}
      
      XtSetArg(args[n], XmNtranslations, XtParseTranslationTable ( translations_global )); n++;
 
      temp_w = XmCreateFileSelectionBox (rowcol,"mymessagebox",args,n);
      
      
      
      XtAddCallback(temp_w, XmNokCallback,
		    (XtCallbackProc)inputfileDialogCallback,
		    (XtPointer)NULL);
      
      XtAddCallback(temp_w, XmNcancelCallback,
		    (XtCallbackProc)exitCallback,
		    (XtPointer)14);
      
      XtAddCallback(temp_w, XmNhelpCallback,
		    (XtCallbackProc)inputfilehelpDialogCallback,
		    (XtPointer)NULL);
      
      
      XtManageChild(temp_w);
      XtManageChild(rowcol);
      XtManageChild(dialog);
      
      XtAddCallback (dialog, XmNdestroyCallback,ShellDeath,(XtPointer)206);
      
      MyPopup (dialog);
      
      
      
      
      
      XtSetSensitive(XmFileSelectionBoxGetChild (temp_w, XmDIALOG_LIST_LABEL),False);
      XtSetSensitive(XmFileSelectionBoxGetChild (temp_w, XmDIALOG_LIST)      ,False);
      
      
      XtVaSetValues(XmFileSelectionBoxGetChild (temp_w, XmDIALOG_DIR_LIST),
		    XmNtranslations, XtParseTranslationTable (list_translations13),NULL);
      
      XtVaGetValues(XtParent(XmFileSelectionBoxGetChild (temp_w, XmDIALOG_DIR_LIST)),
		    XmNverticalScrollBar,&vert_scroll[INDBFILE_SCROLL ] ,NULL);
      

      input_up = 1;    
    }

 set_cursor(mydisplay,mywindow,GOOD);

}





void ImportFileCallback(Widget w,XtPointer data,XtPointer callData)
{ 
  Widget fileDialog;      
  Arg args[15];
  int n = 0;
  
  if(running==1)
    {
      not_while_running(w,"You can not select an intput directory while\n\
the program is running",1122,"Illegal Manuever",1);   
      return;
    }
  else if(IMPORT_INPUT==1)
    {
      
      return;
    }
  
  XtSetArg(args[n], XmNautoUnmanage,   TRUE);                                 n++;
  XtSetArg(args[n], XmNdeleteResponse, XmDESTROY);                            n++;

  if(NGA_TYPE==1)
    {
      XtSetArg(args[n], XmNdialogTitle,    STRING("Selection of Input Specification File"));  n++;		
    }
  else
    {
      XtSetArg(args[n], XmNdialogTitle,    STRING("Import Database Selection"));  n++;		
    }


  XtSetArg(args[n], XmNtranslations, XtParseTranslationTable ( translations_global )); n++;

  fileDialog = 
    XmCreateFileSelectionDialog(XtParent(w), "IDS", args, n);
  
  XtAddCallback(fileDialog, XmNokCallback,
		(XtCallbackProc)importfileDialogCallback,
		(XtPointer)data);
  
  XtAddCallback(fileDialog, XmNcancelCallback,
		(XtCallbackProc)exitCallback,
		(XtPointer)15);
  
  XtAddCallback(fileDialog, XmNhelpCallback,
		(XtCallbackProc)importfilehelpDialogCallback,
		(XtPointer)data);
  
  XtAddCallback(fileDialog,XmNdestroyCallback,ShellDeath,(XtPointer)219);

  
  XtManageChild(fileDialog);
  
  IMPORT_INPUT = 1;    
}



void PatchFileCallback(Widget w,XtPointer data,XtPointer callData)
{ 
  Widget fileDialog;      
  Arg args[15];
  int n = 0;
  
  if(running==1)
    {
      not_while_running(w,"You can not do this while\n\
the program is running",1123,"Illegal Manuever",1);   
      return;
    }
  else if(PATCH_INPUT==1)
    {
      
      return;
    }

  
  XtSetArg(args[n], XmNautoUnmanage,   TRUE);                                          n++;
  XtSetArg(args[n], XmNdeleteResponse, XmDESTROY);                                     n++;
  XtSetArg(args[n], XmNdialogTitle,    STRING("Patch file selection"));                n++;		
  XtSetArg(args[n], XmNtranslations, XtParseTranslationTable ( translations_global )); n++;

  fileDialog = 
    XmCreateFileSelectionDialog(XtParent(w), "Patch File Selection", args, n);
  
  XtAddCallback(fileDialog, XmNokCallback,
		(XtCallbackProc)patchfileDialogCallback,
		(XtPointer)data);
  
  XtAddCallback(fileDialog, XmNcancelCallback,
		(XtCallbackProc)exitCallback,
		(XtPointer)16);

  XtAddCallback(fileDialog, XmNhelpCallback,
		(XtCallbackProc)patchfilehelpDialogCallback,
		(XtPointer)data);

  XtAddCallback(fileDialog,XmNdestroyCallback,ShellDeath,(XtPointer)256);
  
  
  XtManageChild(fileDialog);
  
  PATCH_INPUT = 1;    
}




void STFFileCallback(Widget w,XtPointer data,XtPointer callData)
{ 
  Widget fileDialog;      
  Arg args[15];
  int n = 0;
  
  if(running==1)
    {
      not_while_running(w,"You can not do this while\n\
the program is running",1124,"Illegal Manuever",1);   
      return;
    }
  else if(STF_INPUT==1)
    {
      
      return;
    }

  
  XtSetArg(args[n], XmNautoUnmanage,   TRUE);                                          n++;
  XtSetArg(args[n], XmNdeleteResponse, XmDESTROY);                                     n++;
  XtSetArg(args[n], XmNdialogTitle,    STRING("STF OVERWRITE file selection"));        n++;		
  XtSetArg(args[n], XmNtranslations, XtParseTranslationTable ( translations_global )); n++;

  fileDialog = 
    XmCreateFileSelectionDialog(XtParent(w), "STF OVERWRITE File Selection", args, n);


  XtAddCallback(fileDialog, XmNokCallback,
		(XtCallbackProc)stffileDialogCallback,
		(XtPointer)data);
  
  XtAddCallback(fileDialog, XmNcancelCallback,
		(XtCallbackProc)exitCallback,
		(XtPointer)17);

  XtAddCallback(fileDialog, XmNhelpCallback,
		(XtCallbackProc)stffilehelpDialogCallback,
		(XtPointer)data);

  XtAddCallback(fileDialog,XmNdestroyCallback,ShellDeath,(XtPointer)257);

  
  XtManageChild(fileDialog);
  
  STF_INPUT = 1;    
}





void update_extract(int DO_FMIS,
		    int num_fmareal, int num_fmpoint, int num_fmlinear,
		    int firstmodel , int secondmodel, int thirdmodel  ,
		    int num_coll   , int num_par    , int num_stamp   , int num_foot,
		    int num_polys  , int num_areals , int num_points  , int num_modelpolys,
		    int num_linears, int num_gmi    , int num_fmi     , long int gridpointsdone,
		    int done       , int longnum)
{
  char message[1700];
  char message2[1700];
  XmString t;
  static long int last_redraw=0,ThisTime;
  
  

  if(batchsilent==1)
  {
	  return;
  }

  ThisTime = time(NULL);
  
  if(((ThisTime-last_redraw)>0) || (done==1))
    {
      
      if(done==0)
	{
	  sprintf(message,"Extracting %s....\n\n",importdirectory);
	}
      else
	{
	  sprintf(message,"DONE Extracting %s....\n\n",importdirectory);
	}
      
      if(longnum>=0)
	{  
	  sprintf(message2,"STF Files completed                     : %d\n",longnum);      
	  strcat(message,message2);
	}
      
      if(firstmodel>=0)
	{
	  sprintf(message2,"Models Pass 1 (dependencies)            : %d\n\
Models Pass 2 (stamps)                  : %d\n\
Models Pass 3 (footprints,polys)        : %d\n",firstmodel,secondmodel,thirdmodel);
	  strcat(message,message2);
	}
      else
	{
	  sprintf(message2,"   <no model library found>       \n");
	  strcat(message,message2);
	}
      
      
      if(DO_FMIS==1)
	{
	  sprintf(message2,"Feature Model Point Features instanced  : %d\n\
Feature Model Linear Features instanced : %d\n\
Feature Model Areal Features instanced  : %d\n\
Feature Model Instances instanced       : %d\n",num_fmpoint,num_fmlinear,num_fmareal,num_fmi);
	  strcat(message,message2);
	}
      
      
      sprintf(message2,"Point Features                          : %d\n\
Linear Features                         : %d\n\
Areal Features                          : %d\n\
Polygons                                : %d\n\
Model Library Polygons instanced        : %d\n\
Spherical Collision Volumes             : %d\n\
Parallelepiped Collision Volumes        : %d\n\
Stamp Models                            : %d\n\
Footprint Models                        : %d\n\
Geometry Model Instances instanced      : %d\n\
Grid Points                             : %ld\n\n\
Elapsed time: %s\n",
	      num_points,num_linears,num_areals,num_polys,num_modelpolys,num_coll,num_par,num_stamp,num_foot,num_gmi,gridpointsdone,PrintTime(StartTime));
      
      
      
      strcat(message,message2);
      
      t = XmStringCreateLtoR (message,XmSTRING_DEFAULT_CHARSET);
      XtVaSetValues(extract_dialog,XmNmessageString,t,NULL); 
      XmStringFree(t);
      XmUpdateDisplay(drawing_a);

      last_redraw = ThisTime;
    }
}



void FACCCallback(Widget w,XtPointer data,XtPointer callData)
{
  char filename[500],message[50000],thisname[1000];
  FILE *codes;
  int namelen,numsac,i,SCC,type,sac,j,thislen,leftoff=0,maxlen=45;
  char polyflag[500];
  extern char *GetECCLabel(int code);
  extern char *GetEACLabel(int code);

  sprintf(filename,"%scodesshort.bin",importoutputdir);
  
  codes = fopen(filename,"rb");
  if(codes==NULL)
    {
      printf("place 7 couldnt open %s\n",filename);
      ExitWrapper(-1);
    }
  fseek(codes,(long int)data,SEEK_SET);


  

  
  
  SEEIT_fread_int(&SCC,     codes);
  SEEIT_fread_int(&numsac,  codes);
  SEEIT_fread_int(&type,    codes);

  
  sprintf(message,"Assigned attributes for %s are:\n\n",
	  GetECCLabel(SCC));
  
  if(numsac==0)
    {
      strcat(message,"NO EACs assigned.");
    }
  else if(numsac<40)
    {
      

      for(i=0;i<numsac;i++)
	{
	  
	  
	  SEEIT_fread_int(&sac,codes);
	  
	  if(sac==-3)
	    {
	      SEEIT_fread_int(&namelen ,codes);
	      fread(&polyflag,1, namelen,codes);
	      polyflag[namelen]='\0';
	      strcat(message,"polygon flag: ");
	      strcat(message,polyflag);
	      strcat(message,"\n");      
	    }
	  else if(sac==-1)
	    {
	      SEEIT_fread_int(&namelen ,codes);
	      fread(&polyflag,1, namelen,codes);
	      polyflag[namelen]='\0';
	      if(NGA_TYPE==1)
		{
		  strcat(message,"Layer Identifier: ");
		}
	      else
		{
		  strcat(message,"LOD Identifier: ");
		}
	      strcat(message,polyflag);
	      strcat(message,"\n");      
	    }
	  else
	    {
	      strcat(message,GetEACLabel(sac));
	      strcat(message,"\n");      
	    }      
	}
    }
  else
    {

      for(i=0;i<numsac;i++)
	{
	  

	  SEEIT_fread_int(&sac,codes);
	  
	  sprintf(thisname,"%s",GetEACLabel(sac));



	  if(sac==-3)
	    {
	      
	      SEEIT_fread_int(&namelen ,codes);
	      fread(&polyflag,1, namelen,codes);
	      polyflag[namelen]='\0';
	      continue;
	    }
	  else if(sac==-1)
	    {
	      
	      SEEIT_fread_int(&namelen ,codes);
	      fread(&polyflag,1, namelen,codes);
	      polyflag[namelen]='\0';
	      continue;
	    }



	  if(leftoff==0)
	    {
	      
	      
	      thislen = strlen(thisname);


	      if(thislen<maxlen)
		{
		  strcat(message,thisname);
		  
		  for(j=thislen;j<=maxlen;j++)
		    {
		      strcat(message," ");
		      leftoff = 1;
		    }
		}
	    }
	  else
	    {
	      
	      thislen = strlen(thisname);
	      if(thislen<maxlen)
		{
		  strcat(message,thisname);
		  strcat(message,"\n");      
		  leftoff = 0;
		}
	    }
	}
      
      
            
      fseek(codes,(long int)data,SEEK_SET);
      SEEIT_fread_int(&SCC,     codes);
      SEEIT_fread_int(&numsac,  codes);
      SEEIT_fread_int(&type,    codes);
    
      if(leftoff==1)
	{
	  strcat(message,"\n");      
	}



      for(i=0;i<numsac;i++)
	{
	  

	  SEEIT_fread_int(&sac,codes);
	  
	  if(sac==-3)
	    {
	      SEEIT_fread_int(&namelen ,codes);
	      fread(&polyflag,1, namelen,codes);
	      polyflag[namelen]='\0';
	      strcat(message,"polygon flag: ");
	      strcat(message,polyflag);
	      strcat(message,"\n");      
	    }
	  else if(sac==-1)
	    {
	      SEEIT_fread_int(&namelen ,codes);
	      fread(&polyflag,1, namelen,codes);
	      polyflag[namelen]='\0';
	      if(NGA_TYPE==1)
		{
		  strcat(message,"Layer Identifier: ");
		}
	      else
		{
		  strcat(message,"LOD Identifier: ");
		}
	      strcat(message,polyflag);
	      strcat(message,"\n");      
	    }
	  else
	    {
	      sprintf(thisname,"%s",GetEACLabel(sac));
	      
	      thislen = strlen(thisname);

	      if(thislen>=maxlen)
		{
		  strcat(message,thisname);
		  strcat(message,"\n");      
		}
	    }
	}





      
    }
  fclose(codes);
    
  not_while_running(w,message,1125,"EACs assigned",5); 
}



void FormatHelpCallback(Widget w,XtPointer data,XtPointer callData)
{
  not_while_running(w,"This window may be used to modify default values for\n\
Configuration, Stratum, and Domain, the 3 axes along which\n\
SEE-IT classifies data.  Each Classifier found in the database is\n\
shown with it's default Configuration, Stratum, and Domain\n\
values.  Some may appear more than once.  This is for\n\
those which have different sets of Attributes or LODS.\n\n\
To see the Attributes and LODs associated with a Classifier, click\n\
the button displaying that Classifier.\n\n\
Click the:\n\
    \"Create SEE-IT Database Using Current Settings\"\n\
button to create a SEE-IT format database.  This database will\n\
be stored in the same location as the existing extracted data.",1127,"Help",5);
	
}


void FormatHelpCallback2(Widget w,XtPointer data,XtPointer callData)
{
  not_while_running(w,"This window may be used to modify CURRENT\n\
values for Configuration, Stratum, and Domain, the 3\n\
axes along which SEE-IT classifies data.  Each Classification label\n\
found in the database is shown with it's current\n\
Configuration, Stratum, and Domain values.\n\n\
Some Classifiers may appear more than once.  This is for\n\
those which have different Attributes, or have different\n\
configurations. To see the Attributes associated with a Classifier,\n\
click the button displaying that Classifier.\n\n\
When you are satisfied with the displayed values, click the\n\
\"Use These Settings\" button to make your changes take effect.",1129,"Help",5);
  
}

void CCallback(Widget w,int data,XtPointer callData)
{
  int row;
  int item;
  
  row = data/NUM_C;
  item = data - (row*NUM_C);  
  SCC_LIST[row].config = item;
  DYNAMIC_SCC_LIST[row].config = item;

  if(DEBUG==1)
    {
      printf("C Callback got a %d...\n",data);
      printf("This means the %d-th item is now %d\n",row,item);
    }
}


void SCallback(Widget w,int data,XtPointer callData)
{
  int row;
  int item;
  
  row = data/NUM_S;
  item = data - (row*NUM_S);
  SCC_LIST[row].strat = item;
  DYNAMIC_SCC_LIST[row].strat = item;
  
  if(DEBUG==1)
    {
      printf("S Callback got a %d...\n",data);
      printf("This means the %d-th item is now %d\n",row,item);
    }
}


void DCallback(Widget w,int data,XtPointer callData)
{
  int row;
  int item;
  
  row = data/NUM_D;
  item = data - (row*NUM_D);
  SCC_LIST[row].domain = item;
  DYNAMIC_SCC_LIST[row].domain = item;
  
  if(DEBUG==1)
    { 
      printf("D Callback got a %d...\n",data);
      printf("This means the %d-th item is now %d\n",row,item);
    }
}


void DynCCallback(Widget w,int data,XtPointer callData)
{
  int row;
  int item;
  
  row = data/NUM_C;
  item = data - (row*NUM_C);  
  DYNAMIC_SCC_LIST[row].config = item;
  
  SCC_LIST[row].config = item;
  
  if(DEBUG==1)
    { 
      printf("Dyn C Callback got a %d...\n",data);
      printf("This means the %d-th item is now %d\n",row,item);
    }
}


void DynSCallback(Widget w,int data,XtPointer callData)
{
 int row;
  int item;
  
  row = data/NUM_S;
  item = data - (row*NUM_S);
  DYNAMIC_SCC_LIST[row].strat = item;
  SCC_LIST[row].strat = item;

  if(DEBUG==1)
    { 
      printf("Dyn S Callback got a %d...\n",data);
      printf("This means the %d-th item is now %d\n",row,item);
    }
}


void DynDCallback(Widget w,int data,XtPointer callData)
{
  int row;
  int item;
  
  row = data/NUM_D;
  item = data - (row*NUM_D);
  DYNAMIC_SCC_LIST[row].domain = item;
  SCC_LIST[row].domain = item;

  if(DEBUG==1)
    { 
      printf("Dyn D Callback got a %d...\n",data);
      printf("This means the %d-th item is now %d\n",row,item);
    }
}



void RemoveExtractFiles()
{
  char command[5000];
  int result;
  
  if((USE_DOS==0)||(SLASHTYPE==NONDOS_TYPE))
    {
	  

      sprintf(command,"rm -f \"%s\"bridges.bin",importoutputdir);
      result = system(command);

      sprintf(command,"rm -f \"%s\"points.bin",importoutputdir);
      result = system(command);

      sprintf(command,"rm -f \"%s\"linears*.bin",importoutputdir);
      result = system(command);

      sprintf(command,"rm -f \"%s\"polys.bin",importoutputdir);
      result = system(command);

      sprintf(command,"rm -f \"%s\"areals*.bin",importoutputdir);
      result = system(command);

    }
  else
    {
	  
      sprintf(command,"del \"%sbridges.bin\"",importoutputdir);
      system(command);
      sprintf(command,"del \"%spoints.bin\"",importoutputdir);
      system(command);
      sprintf(command,"del \"%slinears*.bin\"",importoutputdir);
      system(command);
      sprintf(command,"del \"%spolys.bin\"",importoutputdir);
      system(command);
      sprintf(command,"del \"%sareals*.bin\"",importoutputdir);
      system(command);
    }
}



void kill_run_format(Widget w,XtPointer data,XtPointer callData)
{
  RemoveExtractFiles();
}






void help_run_format(Widget w,int data,XtPointer callData)
{
  extern int SH_bad_objects;

  if(NGA_TYPE==1)
    {
      if((DoShort==1)&&(SH_bad_objects>0))
	{
	  not_while_running(w,"Congratulations!\n\n\
You have successfully created a GAIT project.\n\n\
Unfortunately, since FCODE errors exist, GAIT did\n\
not continue on and do the analyses, as requested.\n\
The FCODE error(s) must be repaired first.\n\n",
1130,"Created GAIT Project with FCODE Errors",5);
}
      else if(DoShort==1)
	{
	  not_while_running(w,"Congratulations!\n\n\
You have successfully created a GAIT project.\n\n\
GAIT is now continuing on to do the analyses, as requested.",
			    1130,"Created GAIT Project, Now Inspecting",5);
	}
      else if(SH_bad_objects>0)
	  {
	  not_while_running(w,"Congratulations!\n\n\
You have successfully created a GAIT project.\n\n\
Unfortunately, the project contains FCODE errors.\n\n\
The FCODE errors in this project, along with any other\n\
Attribution Errors, are available under the \"View\"\n\
menu, in \"Attribution Errors/Input Data Anomalies\".\n\n",
1130,"Created GAIT Project with FCODE Errors",5);
	  }
	  else
	{
	  not_while_running(w,"Congratulations!\n\n\
You have successfully created a GAIT project.\n\n",
1130,"Created GAIT Project",5);
	}
    }
  else
    {
      not_while_running(w,"Congratulations!\n\n\
You have successfully extracted and formatted a SEE-IT Database.",
			1131,"Post Formatting Information",5);
    }
}


char *AddExtractString(int type, int num1, int num2, int num3, int num4,
					   unsigned int num5, unsigned int num6, unsigned int num7, unsigned int num8)
{
  static char answer1[100],answer2[100],answer3[100],answer4[100],
	  answer5[200],answer6[200],answer7[200],answer8[200];

  if(type==4)
  {
    if(num5==0)
      {
	return "";
      }
  }
  else if(type==8)
  {
    if(num6==0)
      {
	return "";
      }
  }
  else if((type<4)&&(num1<=0)) 
  {
	return "";
  }
  else if((type>4)&&(num2<=0))
  {
	return "";
  }

  if(type==1)
  {
    sprintf(answer1,"Point Features                   : %d\n",num1);	
	return answer1;
  }
  else if(type==2)
  {
    sprintf(answer2,"Line Features                    : %d\n",num1);	
	return answer2;
  }
  else if(type==3)
  {
    sprintf(answer3,"Area Features                    : %d\n",num1);	
	return answer3;
  }
  else if(type==4)
  {
    sprintf(answer4,"%ss                            : %u\n",GetECCLabel(0),num5);	
	return answer4;
  }
  else if(type==5)
  {
    sprintf(answer5,"Point Features Formatted                   : %d / %d\n",num1,num2);
	return answer5;
  }
  else if(type==6)
  {
    sprintf(answer6,"\
Line Features Read                         : %d / %d\n\
Line Features Formatted                    : %d / %d\n",num1,num2,num3,num4);
	return answer6;
  }
  else if(type==7)
  {
    sprintf(answer7,"\
Area Features Read                         : %d / %d\n\
Area Features Formatted                    : %d / %d\n",num1,num2,num3,num4);
	return answer7;
  }
  else if(type==8)
  {
	
    sprintf(answer8,"\
%ss Read                                 : %u / %u\n\
%ss Formatted                            : %u / %u\n",GetECCLabel(0),num5,num6,GetECCLabel(0),num7,num8);
	return answer8;
  }

  return "";
}



char *AddAttrErrString(int totalmeta,int totalerr,int totalanomaly)
{
  char answer1[100],answer2[100],answer3[100];
  static char retval[300];

  answer1[0] = '\0';
  answer2[0] = '\0';
  answer3[0] = '\0';
  retval[0]  = '\0';

  sprintf(answer1,"Input Data Anomalies             : %d\n",totalanomaly);
  sprintf(answer2,"Attribution Errors               : %d\n",totalerr);
  sprintf(answer3,"Metadata Errors                  : %d\n",totalmeta);

  sprintf(retval,"\n%s%s%s",answer1,answer2,answer3);
  return retval;
}


void AssessEnvVars()
{
  

  if((ATTRINSTYPE==2)&&((TEMP_ATTRIBUTION_TYPE!=23)&&(TEMP_ATTRIBUTION_TYPE!=25)))
  {
    printf("Error:  Cannot use GAIT_ADDITIONAL_ATTRIBUTION_TYPE = NAS with Attribution Schema = %s\n",ParseAttributionType(TEMP_ATTRIBUTION_TYPE));
	exit(-1);
  }
  if((ATTRINSTYPE==3)&&((TEMP_ATTRIBUTION_TYPE!=23)&&(TEMP_ATTRIBUTION_TYPE!=25)))
  {
    printf("Error:  Cannot use GAIT_ADDITIONAL_ATTRIBUTION_TYPE = USER with Attribution Schema = %s\n",ParseAttributionType(TEMP_ATTRIBUTION_TYPE));
	exit(-1);
  }
  if((ATTRINSTYPE==4)&&((TEMP_ATTRIBUTION_TYPE!=23)&&(TEMP_ATTRIBUTION_TYPE!=25)))
  {
    printf("Error:  Cannot use GAIT_ADDITIONAL_ATTRIBUTION_TYPE = USERWITHVV with Attribution Schema = %s\n",ParseAttributionType(TEMP_ATTRIBUTION_TYPE));
	exit(-1);
  }

  if(attrins_source==1)
  {
    if(
		(strcmp(attrinsfolder,"NULL")) &&
		(strcmp(attrinsfolder,"NULL/")) &&
		(strcmp(attrinsfolder,"NULL\\"))
	  )
	{
      if(ATTRINSTYPE==1)
	  {
        printf("Error:  Cannot use GAIT_ADDITIONAL_ATTRIBUTION_TYPE = NONE with GAIT_FOLDER_WITH_ATTRIBUTION_FILES (which is set to %s)\n",attrinsfolder);
		printf("  When using GAIT_FOLDER_WITH_ATTRIBUTION_FILES, you must specify GAIT_ADDITIONAL_ATTRIBUTION_TYPE = USER\n");
	    exit(-1);
	  } 
      if(ATTRINSTYPE==2)
	  { 
        printf("Error:  Cannot use GAIT_ADDITIONAL_ATTRIBUTION_TYPE = NAS with GAIT_FOLDER_WITH_ATTRIBUTION_FILES (which is set to %s)\n",attrinsfolder);
		printf("  When using GAIT_FOLDER_WITH_ATTRIBUTION_FILES, you must specify GAIT_ADDITIONAL_ATTRIBUTION_TYPE = USER\n");
	    exit(-1);
	  } 
	}
	else if(ATTRINSTYPE==3)
	{
      printf("Error:  When using GAIT_ADDITIONAL_ATTRIBUTION_TYPE = USER,\n");
	  printf("  you must specify a non-NULL GAIT_FOLDER_WITH_ATTRIBUTION_FILES (which is set to %s)\n",attrinsfolder);
      exit(-1);
	}
	else if(ATTRINSTYPE==4)
	{
      printf("Error:  When using GAIT_ADDITIONAL_ATTRIBUTION_TYPE = USERWITHVV,\n");
	  printf("  you must specify a non-NULL GAIT_FOLDER_WITH_ATTRIBUTION_FILES (which is set to %s)\n",attrinsfolder);
      exit(-1);
	}
  }
}


void DoNGABAtchStuff(char *argv0, char *dirlistfile,char *projname,char *exop,char *ignoreproj,char *exefile)
{
  FILE *inlocs=NULL;
  char cleanname[5000],aline[5000],filename[1000],sendname[1000],newfile[1000];
  int len,i,success,bad_lines,lines_to_skip,ignore_num=0,retain_num=0;
  extern char masterrun[100];
  extern int BATCH_FAIL;
  extern void E_FreeTree();

  AssessEnvVars();

  if(exefile!=NULL)
  {
    inlocs = fopen(exefile,"r");
	if(inlocs==NULL)
	{
      printf("Could not open inspection specification file %s:\n  assuming it will be generated during project creation\n",exefile);
	}
	else
	{
	  fclose(inlocs);

      printf("Testing user-supplied inspection specification file %s\n",exefile);
      GetRidOfAllClones(0);
      TurnOffAllChecks(0);
      lines_to_skip = FindEDCSInFile(exefile);
      ApplyExecutionOptions(exefile,0);
      bad_lines = DoBatchEDCSStuff((Widget)NULL,exefile,lines_to_skip,0); 
      printf("Done testing user-supplied inspection specification file\n");
	}

    if(!strcmp(exop,"USE_NOMASTER"))
	{
      printf("Processing batch mode arguments %s project: %s mastertype: %s\n",dirlistfile,projname,exop);
      printf("  Using inspection specifications from user file %s\n",exefile);
	}
	else
	{
      printf("Processing batch mode arguments %s project: %s\n",dirlistfile,projname);
      printf("  Using inspection specifications from master specifification %s AND user file %s\n",exop,exefile);
	}
  }
  else if(!strcmp(exop,"USE_NOMASTER"))
  {
    printf("When using the USE_NOMASTER option, you must specify an inspection specification file\n");
	printf("using the \"-specfile <filename>\" option\n");
    PrintUsage(argv0);
    ExitWrapper(-1);
  }
  else
  {
    printf("Processing batch mode arguments %s project: %s mastertype: %s\n",dirlistfile,projname,exop);
  }

  if(batchsilent==1)
  {
    printf("using silent mode\n");
  }


  if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
  {
    sprintf(importoutputdir,"%s\\%s\\",PROJECTLOC,projname);
  }
  else
  {
    sprintf(importoutputdir,"%s/%s/",PROJECTLOC,projname);
  }



  
  if(TestOut(importoutputdir)==0)
    {
      ExitWrapper(-1);
    }



  sprintf(outdirectory,"%spoints_of_interest_files",importoutputdir);
  if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
    {
      strcat(outdirectory,"\\");
    }
  else
    {
      strcat(outdirectory,"/");
    }
  
  if(TestOut(outdirectory)==0)
    {
      ExitWrapper(-1);
    }

  sprintf(outdirectory,"%sexported_shapefiles",importoutputdir);
  if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
    {
      strcat(outdirectory,"\\");
    }
  else
    {
      strcat(outdirectory,"/");
    }
  
  if(TestOut(outdirectory)==0)
    {
      ExitWrapper(-1);
    }


  sprintf(outdirectory,"%scondition_reports",importoutputdir);
  if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
    {
      strcat(outdirectory,"\\");
    }
  else
    {
      strcat(outdirectory,"/");
    }
  
  if(TestOut(outdirectory)==0)
    {
      ExitWrapper(-1);
    }


  sprintf(outdirectory,"%s%s",importoutputdir,outfoldername);
  if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
    {
      strcat(outdirectory,"\\");
    }
  else
    {
      strcat(outdirectory,"/");
    }
  
  if(TestOut(outdirectory)==0)
    {
      ExitWrapper(-1);
    }


  sprintf(outdirectory,"%sbitmaps",importoutputdir);
  if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
    {
      strcat(outdirectory,"\\");
    }
  else
    {
      strcat(outdirectory,"/");
    }
  
  if(TestOut(outdirectory)==0)
    {
      ExitWrapper(-1);
    }



  RemoveOldFiles();


  AppendInputSpec = 0;


  sprintf(aline,"NULL");
  if(getenv("GAIT_BATCH_INPUT_SPEC_TO_USE")!=NULL)
  {
    sprintf(aline,"%s",getenv("GAIT_BATCH_INPUT_SPEC_TO_USE"));

	if(strlen(shapeimportoutputdir)>0)
	{
	  if(strcmp(aline,"NULL"))
	  {
	    printf("Error: Have both GAIT_BATCH_INPUT_SPEC_TO_USE=%s and\n GAIT_INPUT_DATA_FOLDER = %s\n",aline,shapeimportoutputdir);
	    printf("Only one of these may be set\n\n\n");
	    exit(-1);
	  }
	}
  }

  if(strcmp(aline,"NULL"))
  {

    if(FileExists(aline)==0)
	{
      printf("Error: Found environment variable GAIT_BATCH_INPUT_SPEC_TO_USE with value %s\n",aline);
      printf("...cannot open this file.  Exiting.\n");
      exit(-1);
	}

    printf("Found environment variable GAIT_BATCH_INPUT_SPEC_TO_USE with value %s\n",aline);
    printf("...using this file as the InputSpecFile.txt for this project\n");



    if(strcmp(dirlistfile,"NULL"))
	{
      printf("\nerror: when using GAIT_BATCH_INPUT_SPEC_TO_USE, the\n\
\"text file specifying import data location(s)\" parameter should be \"NULL\"\n");
	  printf("found both:\n");
	  printf("GAIT_BATCH_INPUT_SPEC_TO_USE = %s\n",aline);
	  printf("and\n");
	  printf("\"text file specifying import data location(s)\": %s\n",dirlistfile);
	  printf("cannot continue\n\n");
	  exit(-1);
	}

    if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
	{ 
	  sprintf(importdirectory,"%s\\%s\\InputSpecFile.txt",PROJECTLOC,projname);
	  sprintf(importoutputdir,"%s\\%s\\",PROJECTLOC,projname);

      sprintf(cleanname,"copy \"%s\" \"%s\"",aline,importdirectory);
	} 
    else
	{ 
	  sprintf(importdirectory,"%s/%s/InputSpecFile.txt",PROJECTLOC,projname);
	  sprintf(importoutputdir,"%s/%s/",PROJECTLOC,projname);

      sprintf(cleanname,"cp \"%s\" \"%s\"",aline,importdirectory);
	}

	system(cleanname);
  }
  else if(shape_source==0)
  {
    sprintf(cleanname,"%s",dirlistfile);
    len = strlen(dirlistfile);


    for(i=0;i<len;i++)
    {
      if(
	     (cleanname[i]<32) ||
	     (cleanname[i]>126)    
	    )
	  { 
	    cleanname[i] = '\0';
	  } 
    }

    cleanname[i] = '\0';

    inlocs = fopen(cleanname,"r");
    if(inlocs==NULL)
    {
      printf("Could not open %s for read.  Exiting\n",cleanname);
      ExitWrapper(-1);
    }


    do
	{
      if(feof(inlocs))
	  {
	    break;
	  } 
      aline[0] = '\0';
      fgets(aline,1000,inlocs);
      
      sprintf(cleanname,"%s",aline);
      len = strlen(aline);
      for(i=0;i<len;i++)
	  { 
	    if(
	       (cleanname[i]<32) ||
	       (cleanname[i]>126)    
	      )
		{
	      cleanname[i] = '\0';
	    }
	  }

      cleanname[i] = '\0';


      if(strlen(cleanname)<3)
	  {
	    
	    break;
	  } 
      else
	  {
	    printf("processing %s\n",cleanname);
	  } 


      sprintf(shapeimportoutputdir,"%s",cleanname);


      if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
	  { 
	    sprintf(importdirectory,"%s\\%s\\InputSpecFile.txt",PROJECTLOC,projname);
	    sprintf(importoutputdir,"%s\\%s\\",PROJECTLOC,projname);
	  } 
      else
	  { 
	    sprintf(importdirectory,"%s/%s/InputSpecFile.txt",PROJECTLOC,projname);
	    sprintf(importoutputdir,"%s/%s/",PROJECTLOC,projname);
	  } 

      import_source = 1;
      shape_source  = 1;

	  
      ngainfileCallback((Widget)NULL,(XtPointer)1,(XtPointer)NULL);

      if(BATCH_FAIL==1)
	  { 
	    ExitWrapper(-1);
	  } 

      AppendInputSpec = 1;
	}while(!feof(inlocs));
  }
  else
  {
    

    if(strcmp(dirlistfile,"NULL"))
	{
      printf("\nerror: when using GAIT_INPUT_DATA_FOLDER, the\n\
\"text file specifying import data location(s)\" parameter should be \"NULL\"\n");
	  printf("found both:\n");
	  printf("GAIT_INPUT_DATA_FOLDER = %s\n",shapeimportoutputdir);
	  printf("and\n");
	  printf("\"text file specifying import data location(s)\": %s\n",dirlistfile);
	  printf("cannot continue\n\n");
	  exit(-1);
	}


    if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
	{ 
	  sprintf(importdirectory,"%s\\%s\\InputSpecFile.txt",PROJECTLOC,projname);
	  sprintf(importoutputdir,"%s\\%s\\",PROJECTLOC,projname);
	} 
    else
	{ 
	  sprintf(importdirectory,"%s/%s/InputSpecFile.txt",PROJECTLOC,projname);
	  sprintf(importoutputdir,"%s/%s/",PROJECTLOC,projname);
	} 

    import_source = 1;
    shape_source  = 1;

	
	ngainfileCallback((Widget)NULL,(XtPointer)1,(XtPointer)NULL);


    if(BATCH_FAIL==1)
	{ 
	  ExitWrapper(-1);
	} 
  }


  
  
  
  



  

  TYPE = 3; 
  Import3Callback((Widget) NULL,(XtPointer) NULL,(XtPointer)1);
  printf("done importing data\n");

  

  SetEndian(indirectory);
  

  

  sprintf(indirectory,"%s",importoutputdir);

  printf("have in directory %s\n",indirectory);
  
  input_source  = 1;
  output_source = 1;
  
  if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
    {
      sprintf(esname,"%scondition_reports\\condreport.es",indirectory);
      sprintf(nsname,"%scondition_reports\\condreport.ns",indirectory);
      sprintf(lkname,"%scondition_reports\\condreport.lk",indirectory);
      sprintf(boname,"%scondition_reports\\condreport.bo",indirectory);
      sprintf(smname,"%scondition_reports\\condreport.sm",indirectory);
      sprintf(ntname,"%scondition_reports\\condreport.nt",indirectory);
      sprintf(vrname,"%scondition_reports\\condreport.vr",indirectory);
    }
  else
    {
      sprintf(esname,"%scondition_reports/condreport.es",indirectory);
      sprintf(nsname,"%scondition_reports/condreport.ns",indirectory);
      sprintf(lkname,"%scondition_reports/condreport.lk",indirectory);
      sprintf(boname,"%scondition_reports/condreport.bo",indirectory);
      sprintf(smname,"%scondition_reports/condreport.sm",indirectory);
      sprintf(ntname,"%scondition_reports/condreport.nt",indirectory);
      sprintf(vrname,"%scondition_reports/condreport.vr",indirectory);
    }
      


  


  

  
  Offchecks = batch_offchecks;  


  if(!strcmp(exop,"USE_DFEGMASTER"))
    {
      printf("Generating DFEG_master.txt\n");
      GetRidOfAllClones(0);
      TurnOffAllChecks(0);
      
      printf("done\n");

      if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
	  {
	   sprintf(filename,"%sinspection_files\\DFEG_master.txt",indirectory);
	  }
      else
	  {
	   sprintf(filename,"%sinspection_files/DFEG_master.txt",indirectory);
	  }
     
	  if(exefile==NULL)
	  {
        printf("loading %s\n",filename);
        lines_to_skip = FindEDCSInFile(filename);
        ApplyExecutionOptions(filename,0);
        bad_lines = DoBatchEDCSStuff((Widget)NULL,filename,lines_to_skip,1);
        printf("done\n");
	    sprintf(masterrun,"DFEG_master");
	  }

    }
   else if(!strcmp(exop,"USE_MGCPMASTER"))
    {
      printf("Generating MGCP_master.txt\n");
      GetRidOfAllClones(0);
      TurnOffAllChecks(0);
      
      printf("done\n");

      if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
	  { 
	   sprintf(filename,"%sinspection_files\\MGCP_master.txt",indirectory);
	  }
      else
	  { 
	   sprintf(filename,"%sinspection_files/MGCP_master.txt",indirectory);
	  } 

      if(exefile==NULL)
	  {
        printf("loading %s\n",filename);
        lines_to_skip = FindEDCSInFile(filename);
        ApplyExecutionOptions(filename,0);
        bad_lines = DoBatchEDCSStuff((Widget)NULL,filename,lines_to_skip,1);
        printf("done\n");
	    sprintf(masterrun,"MGCP_master");
	  }
    }
  else if(!strcmp(exop,"USE_UFD1MASTER"))
    {
      printf("Generating UFD1_master.txt\n");
      GetRidOfAllClones(0);
      TurnOffAllChecks(0);
      
      printf("done\n");

      if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
	  { 
	   sprintf(filename,"%sinspection_files\\UFD1_master.txt",indirectory);
	  }
      else
	  { 
	   sprintf(filename,"%sinspection_files/UFD1_master.txt",indirectory);
	  } 

	  if(exefile==NULL)
	  {
        printf("loading %s\n",filename);
        lines_to_skip = FindEDCSInFile(filename);
        ApplyExecutionOptions(filename,0);
        bad_lines = DoBatchEDCSStuff((Widget)NULL,filename,lines_to_skip,1);
        printf("done\n");
	    sprintf(masterrun,"UFD1_master");
	  }
    }
    else if(!strcmp(exop,"USE_UFD3MASTER"))
    {
      printf("Generating UFD3_master.txt\n");
      GetRidOfAllClones(0);
      TurnOffAllChecks(0);
      
      printf("done\n");

      if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
	  { 
	   sprintf(filename,"%sinspection_files\\UFD3_master.txt",indirectory);
	  }
      else
	  { 
	   sprintf(filename,"%sinspection_files/UFD3_master.txt",indirectory);
	  } 

	  if(exefile==NULL)
	  {
        printf("loading %s\n",filename);
        lines_to_skip = FindEDCSInFile(filename);
        ApplyExecutionOptions(filename,0);
        bad_lines = DoBatchEDCSStuff((Widget)NULL,filename,lines_to_skip,1);
        printf("done\n");
	    sprintf(masterrun,"UFD3_master");
	  }
    }
    else if(!strcmp(exop,"USE_TDSMASTER"))
    {
      printf("Generating TDS_master.txt\n");
      GetRidOfAllClones(0);
      TurnOffAllChecks(0);
      
      printf("done\n");

      if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
	{ 
	  sprintf(filename,"%sinspection_files\\TDS_master.txt",indirectory);
	}
      else
	{ 
	  sprintf(filename,"%sinspection_files/TDS_master.txt",indirectory);
	} 

	  if(exefile==NULL)
	  {
        printf("loading %s\n",filename);
        lines_to_skip = FindEDCSInFile(filename);
        ApplyExecutionOptions(filename,0);
        bad_lines = DoBatchEDCSStuff((Widget)NULL,filename,lines_to_skip,1);
        printf("done\n");
        sprintf(masterrun,"TDS_master");
	  }
    }
    else if(!strcmp(exop,"USE_TREXMASTER"))
    {
      printf("Generating TREX_master.txt\n");
      GetRidOfAllClones(0);
      TurnOffAllChecks(0);
      
      printf("done\n");

      if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
	{ 
	  sprintf(filename,"%sinspection_files\\TREX_master.txt",indirectory);
	}
      else
	{ 
	  sprintf(filename,"%sinspection_files/TREX_master.txt",indirectory);
	} 

	  if(exefile==NULL)
	  {
        printf("loading %s\n",filename);
        lines_to_skip = FindEDCSInFile(filename);
        ApplyExecutionOptions(filename,0);
        bad_lines = DoBatchEDCSStuff((Widget)NULL,filename,lines_to_skip,1);
        printf("done\n");
        sprintf(masterrun,"TREX_master");
	  }
    }

    else if(!strcmp(exop,"USE_AFDMASTER"))
    {
      printf("Generating AFD_master.txt\n");
      GetRidOfAllClones(0);
      TurnOffAllChecks(0);
      
      printf("done\n");

      if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
	{ 
	  sprintf(filename,"%sinspection_files\\AFD_master.txt",indirectory);
	}
      else
	{ 
	  sprintf(filename,"%sinspection_files/AFD_master.txt",indirectory);
	} 

	  if(exefile==NULL)
	  {
        printf("loading %s\n",filename);
        lines_to_skip = FindEDCSInFile(filename);
        ApplyExecutionOptions(filename,0);
        bad_lines = DoBatchEDCSStuff((Widget)NULL,filename,lines_to_skip,1);
        printf("done\n");
        sprintf(masterrun,"AFD_master");
	  }
    }	
	else if(!strcmp(exop,"USE_NOMASTER"))
    {
      printf("loading user-supplied execution option file %s\n",exefile);
      GetRidOfAllClones(0);
      TurnOffAllChecks(0);
      lines_to_skip = FindEDCSInFile(exefile);
      ApplyExecutionOptions(exefile,0);
      bad_lines = DoBatchEDCSStuff((Widget)NULL,exefile,lines_to_skip,1);
      printf("done\n");
      ResetMasterRun(); 
    }



	if((exefile!=NULL)&&(strcmp(exop,"USE_NOMASTER")))
	{
       
	   

       printf("Loading user-supplied execution option file %s AND master %s\n",exefile,filename);

       sprintf(newfile,"%stemp0.txt",outdirectory);
	   CombineExeOptionsFiles(filename,exefile,newfile);

       GetRidOfAllClones(0);
       TurnOffAllChecks(0);
       lines_to_skip = FindEDCSInFile(newfile);
       ApplyExecutionOptions(newfile,0);
       bad_lines = DoBatchEDCSStuff((Widget)NULL,newfile,lines_to_skip,1);
       printf("done\n");
       ResetMasterRun(); 
	}



  printf("executing analyses...(%s)\n",masterrun);

  
  success = ICheckRegion(0,MaxXindex,0,MaxYindex);
  if(success==0)
    {
      ExitWrapper(-1);
    }




  ResetKeepDismiss(1);

  if(ConsultPreviouslyIgnored==1)
    {
      
      DismissPreviouslyIgnored();
    }


  if(NGA_TYPE==1)
    {
     WriteSummaryReport(1);
    }
  
  printf("saving interim cond report\n");
  reporthandleCallback((Widget)NULL, (XtPointer)3, (XtPointer)NULL );      

  if(ConsultPreviouslyIgnored==1)
  {
    sprintf(sendname,"%scondreport.lk2",outdirectory);
    CountIgnored(&ignore_num,&retain_num,sendname,1);
    printf("Number of conditions marked IGNORE due to using -markignore flag\n");
	printf("and saved condition shapefiles from project \"%s\": %d\n",
		ignoreproj,ignore_num);
  } 


  
  printf("writing condition report...\n");

  
  if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
    {
      sprintf(esname,"%scondition_reports\\condreport.es",indirectory);
      sprintf(nsname,"%scondition_reports\\condreport.ns",indirectory);
      sprintf(lkname,"%scondition_reports\\condreport.lk",indirectory);
      sprintf(boname,"%scondition_reports\\condreport.bo",indirectory);
      sprintf(smname,"%scondition_reports\\condreport.sm",indirectory);
      sprintf(ntname,"%scondition_reports\\condreport.nt",indirectory);
      sprintf(vrname,"%scondition_reports\\condreport.vr",indirectory);
    }
  else
    {
      sprintf(esname,"%scondition_reports/condreport.es",indirectory);
      sprintf(nsname,"%scondition_reports/condreport.ns",indirectory);
      sprintf(lkname,"%scondition_reports/condreport.lk",indirectory);
      sprintf(boname,"%scondition_reports/condreport.bo",indirectory);
      sprintf(smname,"%scondition_reports/condreport.sm",indirectory);
      sprintf(ntname,"%scondition_reports/condreport.nt",indirectory);
      sprintf(vrname,"%scondition_reports/condreport.vr",indirectory);
    }
      
  reporthandleCallback((Widget)NULL, (XtPointer)1, (XtPointer)NULL );      

  
  
  printf("writing shapefiles...\n");
  MakeAllShapefiles((Widget)NULL,0,0);
  printf("Saved shapefile conditions to: %sexported_shapefiles\n\n",indirectory);
   


  printf("done\n\n");
  
}









void BuildOpenMenu(double AttrChk,int ECCdone, int ECCttl,int polys_read, int polys_done,int model_polys_done,int areals_done,int linears_done,int points_done,
                   int s_coll_done, int p_coll_done, int stamps_done, int foot_done, int bridges_done,
                   unsigned int Gptread, unsigned int GptDone,int FMpoint,int  FMlinear,int  FMareal,
                   double PCacount, double IndexPrep, double PCattr, double PCattrval,int DON)
{
  
  
  XmString t;
  Arg args[15];
  char message[2000],FORMATTIME[1000];  
  int n, totalmeta,totalerr,totalanomaly;
  static long int last_redraw=0,ThisTime;
  static int testaa = 0;

  if(FORMATBUTTON==1)
  { 
    if(testaa==0)
	{ 
      EXTRACT_POINTS_DONE  = FORMAT_POINT_NUM;
      EXTRACT_LINEARS_DONE = FORMAT_LINE_NUM;
      EXTRACT_AREALS_DONE  = FORMAT_AREA_NUM;
	  printf("abnormal set of extract counts\n");
	  testaa = 1;
	} 
  } 


  ThisTime = time(NULL);
  
  

  if(((ThisTime-last_redraw)>0) || (DON==1))
    {      

      if(NGA_TYPE==1)
	{
	  sprintf(FORMATTIME,"%s",PrintTime(StartTime));
	  
	  if(DON==1)
	    {

          AddCountsToAttrTypes(&totalmeta,&totalerr,&totalanomaly);


	      sprintf(message,"Completed creating project:\n %s\n\n\
This project contains:\n\n\
%s%s%s%s%s\n\
%s\n\
Extract Time:  %sFormat Time:   %sTotal Time:    %s\n\n",
		      importoutputdir,
		      AddExtractString(1,points_done,-1,-1,-1,0,0,0,0),
		      AddExtractString(2,linears_done,-1,-1,-1,0,0,0,0),
		      AddExtractString(3,areals_done,-1,-1,-1,0,0,0,0),
		      AddExtractString(4,-1,-1,-1,-1,GptDone,0,0,0),
			  AddAttrErrString(totalmeta,totalerr,totalanomaly),
		      EXTRACT_EXTRA_STR,
		      EXTRACT_TIME,
		      FORMATTIME,
		      PrintTime(EXTRACT_STARTTIME));

		  if(batchsilent==0)
		  {
	        XtVaSetValues (run_format_dialog,
			     XmNdialogTitle, STRING("Project Creation Summary"),
			     NULL);
		  }
	  }
	  else
	  { 
	      sprintf(message,"Formatting\n %s\n\n\
Creating Indices                           : %d / %d\n\n\
%s%s%s%s\n\
%s\n\
Attribute Frequency Analysis               : %.1lf %%\n\
Preparing for indexing operations          : %.1lf %%\n\
Indexing by Attribute                      : %.1lf %%\n\
Indexing by Attribute Value                : %.1lf %%\n\n\
Attribute Inspection                       : %.1lf %%\n\n\
Extract Time: %sFormat Time:  %sTotal Time:   %s",
		      importoutputdir,ECCdone,ECCttl,

		      AddExtractString(5,points_done, EXTRACT_POINTS_DONE,-1,-1,0,0,0,0),

		      AddExtractString(6,
			  polys_read,  EXTRACT_LINEARS_DONE,
		      linears_done,EXTRACT_LINEARS_DONE,0,0,0,0),

              AddExtractString(7,
			  polys_done,  EXTRACT_AREALS_DONE,
		      areals_done, EXTRACT_AREALS_DONE,0,0,0,0),

		      AddExtractString(8,0,0,0,0,
			  Gptread,     EXTRACT_GRIDS_DONE,
		      GptDone,     EXTRACT_GRIDS_DONE),

		      EXTRACT_EXTRA_STR,
                      PCacount,IndexPrep,PCattr,PCattrval,AttrChk,
		      EXTRACT_TIME,
		      FORMATTIME,
		      PrintTime(EXTRACT_STARTTIME));
            }
	  } 
      else
	  {       
	   if(DON==1)
	   {  
	      sprintf(message,"Completed formatting\n %s\n\
This data may now be used as an input SEE-IT directory.\n\n\
Objects in Catalog                         : %d\n\n\
Data formatted:\n\n\
Point Features Formatted                   : %d\n\
Linear Features Formatted                  : %d\n\
Areal Features Formatted                   : %d\n\
Polygons Formatted                         : %d\n\
Model Library Polygons Formatted           : %d\n\
Spherical Collision Volumes Formatted      : %d\n\
Parallelepiped Collision Volumes Formatted : %d\n\
Stamp Models Formatted                     : %d\n\
Footprint Models Formatted                 : %d\n\
Grid Points Formatted                      : %d\n\
Feature Model Point Features Formatted     : %d\n\
Feature Model Linear Features Formatted    : %d\n\
Feature Model Areal Features Formatted     : %d\n\n\
Elapsed time: %s\n",
		  importoutputdir,ECCdone,
		  points_done,linears_done,areals_done,polys_done,model_polys_done,
		  s_coll_done,p_coll_done,stamps_done,foot_done,GptDone,FMpoint, FMlinear, FMareal,PrintTime(StartTime));
	   }
	  
	  else
	  { 
	      sprintf(message,"Formatting\n %s\n\n\
Creating Catalog of Objects                : %d of %d\n\n\
Point Features Formatted                   : %d\n\
Linear Features Formatted                  : %d\n\
Areal Features Formatted                   : %d\n\
Polygons Read                              : %d\n\
Polygons Formatted                         : %d\n\
Model Library Polygons Formatted           : %d\n\
Spherical Collision Volumes Formatted      : %d\n\
Parallelepiped Collision Volumes Formatted : %d\n\
Stamp Models Formatted                     : %d\n\
Footprint Models Formatted                 : %d\n\
Grid Points Read                           : %d\n\
Grid Points Formatted                      : %d\n\
Feature Model Point Features Formatted     : %d\n\
Feature Model Linear Features Formatted    : %d\n\
Feature Model Areal Features Formatted     : %d\n\n\
Attribute Frequency Analysis (percent)     : %.1lf\n\
Preparing for indexing operations (percent): %.1lf\n\
Indexing by Attribute (percent)            : %.1lf\n\
Indexing by Attribute Value (percent)      : %.1lf\n\n\
Attribute Inspection (percent)             : %.1lf\n\n\
Elapsed time: %s\n",
		      importoutputdir,ECCdone,ECCttl,
		      points_done,linears_done,areals_done,polys_read,polys_done,model_polys_done,
s_coll_done,p_coll_done,stamps_done,foot_done,Gptread,GptDone,
FMpoint,FMlinear,FMareal,PCacount,IndexPrep,PCattr,PCattrval,AttrChk,PrintTime(StartTime));
            }
        }


	  if(batchsilent==1)
	  {
		if(((ThisTime-last_redraw)>10)||(DON==1))
		{
		  AddSilentStuff(message,2);
          last_redraw = ThisTime;
		}
		return;
	  }


     t = XmStringCreateLtoR (message,XmSTRING_DEFAULT_CHARSET);
  
     if(RUN_FORMAT_UP==0)
       {
         n = 0;
         XtSetArg(args[n], XmNautoUnmanage,  False);                                  n++;  
         XtSetArg(args[n], XmNdeleteResponse, XmDESTROY);                             n++; 
         
         XtSetArg(args[n], XmNdialogTitle,   STRING("Formatting..."));                n++;
         XtSetArg(args[n], XmNmessageString, t);                                      n++;
               
         run_format_dialog = XmCreateInformationDialog (drawing_a, "Done Formatting", args, n);
   
         XtAddCallback (run_format_dialog, XmNokCallback,     (XtCallbackProc)die_callback, (XtPointer)1024);   
         XtAddCallback (run_format_dialog, XmNcancelCallback, (XtCallbackProc)kill_run_format, (XtPointer) NULL);
         XtAddCallback (run_format_dialog, XmNhelpCallback,   (XtCallbackProc)help_run_format, (XtPointer) NULL);
      
         XtManageChild (run_format_dialog);
         XtPopup  (XtParent(run_format_dialog), XtGrabNone);
         XmStringFree (t); 
	
         XtUnmanageChild (XmMessageBoxGetChild (run_format_dialog, XmDIALOG_CANCEL_BUTTON));
         XtUnmanageChild (XmMessageBoxGetChild (run_format_dialog, XmDIALOG_HELP_BUTTON));
         XtUnmanageChild (XmMessageBoxGetChild (run_format_dialog, XmDIALOG_OK_BUTTON));

         XtAddCallback(run_format_dialog,XmNdestroyCallback,ShellDeath,(XtPointer)228);       
         RUN_FORMAT_UP=1;
         set_cursor(XtDisplay(run_format_dialog),XtWindow(run_format_dialog),WATCH);
       }
     else
       {
         XtVaSetValues (run_format_dialog,
		     XmNmessageString,    t,
	   	     NULL);
         XmStringFree(t);
       }
     real_periodic_redraw();
     last_redraw = ThisTime;
    }

}





int MakeOutStuff(char testdirectory[])
{
  char testdir[1000];
  extern void CreateXMLTemplate(char *dir);

  sprintf(outdirectory,"%s%s",testdirectory,outfoldername);
  
  if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
    {
      strcat(outdirectory,"\\");
    }
  else
    {
      strcat(outdirectory,"/");
    }
  
  if(DEBUG==1){printf("Output file name is %s\n",outdirectory);}
  
  if(TestOut(outdirectory)==0)
    {
      output_source=0;
      return 0;
    }
  


  sprintf(outattrdirectory,"%sattribution_errors",testdirectory);
  
  if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
    {
      strcat(outattrdirectory,"\\");
    }
  else
    {
      strcat(outattrdirectory,"/");
    }
  
  if(DEBUG==1){printf("Output file name is %s\n",outattrdirectory);}
  
  if(TestOut(outattrdirectory)==0)
    {
      output_source=0;
      return 0;
    }
  


  sprintf(outsumdirectory,"%ssummary_files",testdirectory);
  
  if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
    {
      strcat(outsumdirectory,"\\");
    }
  else
    {
      strcat(outsumdirectory,"/");
    }
  
  if(DEBUG==1){printf("Output file name is %s\n",outsumdirectory);}
  
  if(TestOut(outsumdirectory)==0)
    {
      output_source=0;
      return 0;
    }
  

  sprintf(testdir,"%sXML",testdirectory);
  
  if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
    {
      strcat(testdir,"\\");
    }
  else
    {
      strcat(testdir,"/");
    }
  
  if(DEBUG==1){printf("Output file name is %s\n",testdir);}
  
  if(TestOut(testdir)==0)
    {
      output_source=0;
      return 0;
    }

  CreateXMLTemplate(testdir);




  sprintf(testdir,"%sQA",testdirectory);
  
  if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
    {
      strcat(testdir,"\\");
    }
  else
    {
      strcat(testdir,"/");
    }
  
  if(DEBUG==1){printf("Output file name is %s\n",testdir);}
  
  if(TestOut(testdir)==0)
    {
      output_source=0;
      return 0;
    }









  return 1;
}


void RemoveOldFiles()
{
  char test[5000];

  

  if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
    {
      sprintf(test,"rmdir /S /Q \"%scondition_reports\"",importoutputdir);
      system(test);
      sprintf(test,"rmdir /S /Q \"%sbitmaps\"",importoutputdir);
      system(test);
      sprintf(test,"rmdir /S /Q \"%sexported_shapefiles\"",importoutputdir);
      system(test);
      sprintf(test,"rmdir /S /Q \"%sQACR_files\"",importoutputdir);
      system(test);
      sprintf(test,"rmdir /S /Q \"%sTREx_Reports\"",importoutputdir);
      system(test);
    }
  else
    {
      sprintf(test,"rm -r -f \"%scondition_reports\"",importoutputdir);
      system(test);
      sprintf(test,"rm -r -f \"%sbitmaps\"",importoutputdir);
      system(test);
      sprintf(test,"rm -r -f \"%sexported_shapefiles\"",importoutputdir);
      system(test);
      sprintf(test,"rm -r -f \"%sQACR_files\"",importoutputdir);
      system(test);
      sprintf(test,"rm -r -f \"%sTREx_Reports\"",importoutputdir);
      system(test);
   }


  sprintf(test,"%scondition_reports",importoutputdir);
  
  if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
    {
      strcat(test,"\\");
    }
  else
    {
      strcat(test,"/");
    }
  
  if(TestOut(test)==0)
    {
      ExitWrapper(-1);
    }



  sprintf(test,"%sbitmaps",importoutputdir);
  
  if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
    {
      strcat(test,"\\");
    }
  else
    {
      strcat(test,"/");
    }
  
  if(TestOut(test)==0)
    {
      ExitWrapper(-1);
    }


  sprintf(test,"%sexported_shapefiles",importoutputdir);
  
  if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
    {
      strcat(test,"\\");
    }
  else
    {
      strcat(test,"/");
    }
  
  if(TestOut(test)==0)
    {
      ExitWrapper(-1);
    }



  sprintf(test,"%sattribution_errors",importoutputdir);
  
  if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
    {
      strcat(test,"\\");
    }
  else
    {
      strcat(test,"/");
    }
  
  if(TestOut(test)==0)
    {
      ExitWrapper(-1);
    }

}




void RemoveMasters()
{
  char test[2000];
  extern void RemoveFile(char *tname);

  if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
    {
      sprintf(test,"%sinspection_files\\DFEG_master.txt",importoutputdir);
	  RemoveFile(test);
      sprintf(test,"%sinspection_files\\MGCP_master.txt",importoutputdir);
	  RemoveFile(test);
      sprintf(test,"%sinspection_files\\UFD1_master.txt",importoutputdir);
	  RemoveFile(test);
      sprintf(test,"%sinspection_files\\UFD3_master.txt",importoutputdir);
	  RemoveFile(test);
      sprintf(test,"%sinspection_files\\TDS_master.txt",importoutputdir);
	  RemoveFile(test);
      sprintf(test,"%sinspection_files\\AFD_master.txt",importoutputdir);
	  RemoveFile(test);
      sprintf(test,"%sinspection_files\\TREX_master.txt",importoutputdir);
	  RemoveFile(test);
    }
  else
    {
      sprintf(test,"%sinspection_files/DFEG_master.txt",importoutputdir);
	  RemoveFile(test);
      sprintf(test,"%sinspection_files/MGCP_master.txt",importoutputdir);
	  RemoveFile(test);
      sprintf(test,"%sinspection_files/UFD1_master.txt",importoutputdir);
	  RemoveFile(test);
      sprintf(test,"%sinspection_files/UFD3_master.txt",importoutputdir);
	  RemoveFile(test);
      sprintf(test,"%sinspection_files/TDS_master.txt",importoutputdir);
	  RemoveFile(test);
      sprintf(test,"%sinspection_files/AFD_master.txt",importoutputdir);
	  RemoveFile(test);
      sprintf(test,"%sinspection_files/TREX_master.txt",importoutputdir);
	  RemoveFile(test);
    }
}




void CopyBndryMatchFile()
{
  char filename1[1000],filename2[1000],command2[2000];

    if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
	{

	  if((ATTRTYPE_D4()))
	  {
        sprintf(filename1,"%sbin\\D4_BndryAttrMatch.csv",GAIT_HOME_DIR);
	  }
	  else if((ATTRTYPE_FACC()))
	  { 
        sprintf(filename1,"%sbin\\FACC_PLUS_BndryAttrMatch.csv",GAIT_HOME_DIR);
 	  } 
	  else if((ATTRTYPE_VMAP()))
	  { 
        sprintf(filename1,"%sbin\\VMAP_BndryAttrMatch.csv",GAIT_HOME_DIR);
	  } 
	  else if(ATTRTYPE_MGCP3())
	  { 
        sprintf(filename1,"%sbin\\MGCP3_BndryAttrMatch.csv",GAIT_HOME_DIR);
 	  }
	  else if(ATTRTYPE_MGCP4())
	  { 
        sprintf(filename1,"%sbin\\MGCP4_BndryAttrMatch.csv",GAIT_HOME_DIR);
 	  } 
	  else if((ATTRTYPE_UFD2()))
	  { 
        sprintf(filename1,"%sbin\\UFD2_BndryAttrMatch.csv",GAIT_HOME_DIR);
	  } 
	  else if((ATTRTYPE_UFD1()))
	  { 
        sprintf(filename1,"%sbin\\UFD1_BndryAttrMatch.csv",GAIT_HOME_DIR);
	  }  
	  else if((ATTRTYPE_UFD3()))
	  { 
        sprintf(filename1,"%sbin\\UFD3_BndryAttrMatch.csv",GAIT_HOME_DIR);
 	  }

	  else if(ATTRTYPE_TDS4())
	  { 
        sprintf(filename1,"%sbin\\TDS4_BndryAttrMatch.csv",GAIT_HOME_DIR);
	  }
	  else if(ATTRTYPE_TDS5())
	  { 
        sprintf(filename1,"%sbin\\TDS5_BndryAttrMatch.csv",GAIT_HOME_DIR);
	  }
	  else if(ATTRTYPE_TDS6())
	  { 
        sprintf(filename1,"%sbin\\TDS6_BndryAttrMatch.csv",GAIT_HOME_DIR);
	  }
	  else if((ATTRTYPE_NFDD()))
	  { 
        sprintf(filename1,"%sbin\\NFDD_BndryAttrMatch.csv",GAIT_HOME_DIR);
	  }
	  else if((ATTRTYPE_DFDD()))
	  { 
        sprintf(filename1,"%sbin\\DFDD_BndryAttrMatch.csv",GAIT_HOME_DIR);
	  }
	  else if((ATTRTYPE_SAC()))
	  { 
        sprintf(filename1,"%sbin\\AFD_BndryAttrMatch.csv",GAIT_HOME_DIR);
	  }


	  else if((ATTRTYPE_GGDM21()))
	  { 
        sprintf(filename1,"%sbin\\GGDM21_BndryAttrMatch.csv",GAIT_HOME_DIR);
	  }
	  else if((ATTRTYPE_GGDM22()))
	  { 
        sprintf(filename1,"%sbin\\GGDM22_BndryAttrMatch.csv",GAIT_HOME_DIR);
	  }
	  else if((ATTRTYPE_GGDM3()))
	  { 
        sprintf(filename1,"%sbin\\GGDM3_BndryAttrMatch.csv",GAIT_HOME_DIR);
	  }
	  else
	  {
		printf("unexpecgted AT %d to CBAMF\n",ATTRIBUTION_TYPE);
	  }



      sprintf(filename2,"%sinspection_files\\BndryAttrMatch.csv",indirectory);

      sprintf(command2,"copy \"%s\" \"%s\"",filename1,filename2);
	} 
	else
	{
	  if((ATTRTYPE_D4()))
	  {
        sprintf(filename1,"%sbin/D4_BndryAttrMatch.csv",GAIT_HOME_DIR);
	  }
	  else if((ATTRTYPE_FACC()))
	  { 
        sprintf(filename1,"%sbin/FACC_PLUS_BndryAttrMatch.csv",GAIT_HOME_DIR);
	  } 
	  else if((ATTRTYPE_VMAP()))
	  { 
        sprintf(filename1,"%sbin/VMAP_BndryAttrMatch.csv",GAIT_HOME_DIR);
	  } 
	  else if(ATTRTYPE_MGCP3())
	  { 
        sprintf(filename1,"%sbin/MGCP3_BndryAttrMatch.csv",GAIT_HOME_DIR);
 	  } 
	  else if(ATTRTYPE_MGCP4())
	  { 
        sprintf(filename1,"%sbin/MGCP4_BndryAttrMatch.csv",GAIT_HOME_DIR);
 	  } 
	  else if((ATTRTYPE_UFD2()))
	  { 
        sprintf(filename1,"%sbin/UFD2_BndryAttrMatch.csv",GAIT_HOME_DIR);
	  } 
	  else if((ATTRTYPE_UFD1()))
	  { 
        sprintf(filename1,"%sbin/UFD1_BndryAttrMatch.csv",GAIT_HOME_DIR);
	  }  
	  else if((ATTRTYPE_UFD3()))
	  { 
        sprintf(filename1,"%sbin/UFD3_BndryAttrMatch.csv",GAIT_HOME_DIR);
	  }

	  else if(ATTRTYPE_TDS4())
	  { 
        sprintf(filename1,"%sbin/TDS4_BndryAttrMatch.csv",GAIT_HOME_DIR);
	  }
	  else if(ATTRTYPE_TDS5())
	  { 
        sprintf(filename1,"%sbin/TDS5_BndryAttrMatch.csv",GAIT_HOME_DIR);
	  }
	  else if(ATTRTYPE_TDS6())
	  { 
        sprintf(filename1,"%sbin/TDS6_BndryAttrMatch.csv",GAIT_HOME_DIR);
	  }
	  else if((ATTRTYPE_NFDD()))
	  { 
        sprintf(filename1,"%sbin/NFDD_BndryAttrMatch.csv",GAIT_HOME_DIR);
	  }
	  else if((ATTRTYPE_DFDD()))
	  { 
        sprintf(filename1,"%sbin/DFDD_BndryAttrMatch.csv",GAIT_HOME_DIR);
	  }
	  else if((ATTRTYPE_SAC()))
	  { 
        sprintf(filename1,"%sbin/AFD_BndryAttrMatch.csv",GAIT_HOME_DIR);
	  }

	  else if((ATTRTYPE_GGDM21()))
	  { 
        sprintf(filename1,"%sbin/GGDM21_BndryAttrMatch.csv",GAIT_HOME_DIR);
	  }
	  else if((ATTRTYPE_GGDM22()))
	  { 
        sprintf(filename1,"%sbin/GGDM22_BndryAttrMatch.csv",GAIT_HOME_DIR);
	  }
	  else if((ATTRTYPE_GGDM3()))
	  { 
        sprintf(filename1,"%sbin/GGDM3_BndryAttrMatch.csv",GAIT_HOME_DIR);
	  }
	  else
	  {
		printf("unexpecgted AT %d to CBAMF\n",ATTRIBUTION_TYPE);
	  }


	  sprintf(filename2,"%sinspection_files/BndryAttrMatch.csv",indirectory);

      sprintf(command2,"cp \"%s\" \"%s\"",filename1,filename2);
	} 

	system(command2);


        if(ATTRTYPE_TDS6())
           {
           if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
              {
              sprintf(filename1,"%sbin\\TDS6_CollectAttrStats.csv",GAIT_HOME_DIR);
              sprintf(filename2,"%sinspection_files\\CollectAttrStats.csv",indirectory);
              sprintf(command2,"copy \"%s\" \"%s\"",filename1,filename2);
              system(command2);

              sprintf(filename1,"%sinternal_data\\MarkersForAttributeStats.csv",indirectory);
              sprintf(filename2,"%sinspection_files\\MarkersForAttributeStats.csv",indirectory);
              sprintf(command2,"move \"%s\" \"%s\"",filename1,filename2);
              system(command2);
              }
           else
              {
              sprintf(filename1,"%sbin/TDS6_CollectAttrStats.csv",GAIT_HOME_DIR);
              sprintf(filename2,"%sinspection_files/CollectAttrStats.csv",indirectory);
              sprintf(command2,"cp \"%s\" \"%s\"",filename1,filename2);
              system(command2);

              sprintf(filename1,"%sinternal_data/MarkersForAttributeStats.csv",indirectory);
              sprintf(filename2,"%sinspection_files/MarkersForAttributeStats.csv",indirectory);
              sprintf(command2,"mv \"%s\" \"%s\"",filename1,filename2);
              system(command2);
              }
           }

}



void Begin_FormatCache()
{
  sprintf(indirectory,"%s",importoutputdir);

  Begin_LongFiles(LONG_ATTR_CHECK_HGT);
  Begin_LongFiles(LONG_ATTR_CHECK_ZV2);
  Begin_LongFiles(LONG_ATTR_CHECK_AREA);
  Begin_LongFiles(LONG_ATTR_CHECK_LEN);
  Begin_LongFiles(LONG_ATTR_CHECK_NAM);
}


void End_FormatCache()
{
  End_LongFiles(LONG_ATTR_CHECK_HGT);
  End_LongFiles(LONG_ATTR_CHECK_ZV2);
  End_LongFiles(LONG_ATTR_CHECK_AREA);
  End_LongFiles(LONG_ATTR_CHECK_LEN);
  End_LongFiles(LONG_ATTR_CHECK_NAM);
}


void FormatCallback(Widget w,XtPointer data,XtPointer callData)
{
  int i,result,lines_to_skip,success,bad_lines,totalconds=0,save_attrins;
  FILE *out, *ddefs;
  char fname[1000],filename[1000],testdirectory[1000];
  extern int SH_bad_objects,DO_QAST,QAST_LEAVEWINDOWS,CREATING_TREX;
  extern Widget GetTopShell(Widget w);

#if(USE_DOS==1)
  extern void CoUninit();
#endif

  

  


  

#if(USE_DOS==1)
  CoUninit(); 
#endif


  if(FORMATBUTTON==1)
  {
    ATTRIBUTION_TYPE = TEMP_ATTRIBUTION_TYPE;
	printf("Abnormally set ATTRIBUTION_TYPE to %d\n",ATTRIBUTION_TYPE);
	InitializeAttribution();
  }


  BUSY = 1;
  set_cursor(mydisplay,mywindow,WATCH);
  if(IMPORT_WIN==1){set_cursor(XtDisplay(GetImportShell()),XtWindow(GetImportShell()),WATCH);}


  if(DYNAMIC_SCC_LIST_INNITTED==0)
    {
      BuildDynamicArrayOfScc(importoutputdir);
    }
 
  if(SCC_LIST_INNITTED==0)
    {
      if(BuildArrayOfScc((Widget)NULL,importoutputdir)<0)
	{
	  BUSY = 0;  
	  set_cursor(mydisplay,mywindow,GOOD);
	  return;
	}
    }


  SortListbyOrder(0,SCC_NUM-1);


  sprintf(fname,"%sdynamicdefs.txt",importoutputdir);

  out = fopen(fname,"w");
  if(out==NULL)
    {
      printf("couldnt open %s for write\n",fname);
      ExitWrapper(-1);
    }

 

  sprintf(fname,"%sdynamicdefs.bin",importoutputdir);

  ddefs = fopen(fname,"wb");
  if(ddefs==NULL)
    {
      printf("couldnt open %s for write\n",fname);
      ExitWrapper(-1);
    }




  for(i=0;i<SCC_NUM;i++)
    {
      fprintf(out,"%d %d %d %d\n",
	      SCC_LIST[i].sccint,SCC_LIST[i].config,SCC_LIST[i].strat,SCC_LIST[i].domain);

      SEEIT_fwrite_int(&SCC_LIST[i].sccint, ddefs);
      fwrite(&SCC_LIST[i].config, SzUC,1,ddefs);
      fwrite(&SCC_LIST[i].strat,  SzUC,1,ddefs);
      fwrite(&SCC_LIST[i].domain, SzUC,1,ddefs);
      
    }
  fclose(out);
  fclose(ddefs);

  SortListbySCC(0,SCC_NUM-1);

  if(CSD_UP==1)
    {
      

      
      XtSetSensitive(Bbutton,False);
    }

  StartTime = time(NULL);
  result = TestShort(importoutputdir);
  if(result==0)
    {
      BUSY = 0;
      set_cursor(mydisplay,mywindow,GOOD);
      return;
    }


  AllocArealPixmaps();

  RemoveOldFiles();

  Begin_FormatCache();

  formatting = 1;

  save_attrins = ATTRINSTYPE;
  if(CREATING_TREX==1)
  {
    ATTRINSTYPE = 5;
  }


  FormatTheTerrain(importoutputdir);
  formatting = 0;

  ATTRINSTYPE = save_attrins;


  if((DO_QAST==1)&&(QAST_LEAVEWINDOWS==0))
  {
    if(RUN_FORMAT_UP==1)
	{
	  XtPopdown(GetTopShell(run_format_dialog));
	  XtDestroyWidget(run_format_dialog);
	  RUN_FORMAT_UP=0;
	} 
  }


  End_FormatCache();

  if(batchsilent==1)
  {
	  printf("opening project %s...\n",importoutputdir);
  }

  StartTime = time(NULL); 

  CloseTopLevelStuff();


  RemoveMasters();

  if(FORMATBUTTON==0)
    {
      RemoveExtractFiles();
    }

  WriteMetaFile();

  if(polyptsallocced>0)
    {
      free(PolyPoints);
      polyptsallocced = 0;
      FreeArealPixmaps();
    }


  if(batchsilent==0)
  {
	if(RUN_FORMAT_UP==1) 
	{
      set_cursor(XtDisplay(run_format_dialog),XtWindow(run_format_dialog),GOOD);
	}
    if(IMPORT_WIN==1){set_cursor(XtDisplay(GetImportShell()),XtWindow(GetImportShell()),GOOD);}
  }


 




  if(CSD_UP==1)
    {
      XtDestroyWidget(CSD_head);
      CSD_UP = 0;
    }


  



  if(RUN_FORMAT_UP==1)
  {
    if(FORMATBUTTON==1)
    {
      XtManageChild (XmMessageBoxGetChild (run_format_dialog, XmDIALOG_CANCEL_BUTTON));
    }

   if(batch_mode==0)
    {
      XtManageChild (XmMessageBoxGetChild (run_format_dialog, XmDIALOG_HELP_BUTTON));
      XtManageChild (XmMessageBoxGetChild (run_format_dialog, XmDIALOG_OK_BUTTON));
    }
  }



  

  sprintf(testdirectory,"%sinspection_files",indirectory);

  if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
    {
      strcat(testdirectory,"\\");
    }
  else
    {
      strcat(testdirectory,"/");
    }

  if(TestOut(testdirectory)==0)
    {
      printf("Error, cannot create %s\n",testdirectory);
    }


  CopyBndryMatchFile();


  if(NGA_TYPE==1)
    {

      if((DoShort==1)&&(SH_bad_objects>0))
	  { 
	   
  	   if(batchsilent==0)
	   {
	     XtVaSetValues(run_format_dialog,
			XmNokLabelString, STRING("Not inspecting due to FCODE errors"),
			NULL);
	   }

	   inputfileDialogCallback(drawing_a,(XtPointer)1,
			     (XmFileSelectionBoxCallbackStruct *)NULL);
	  } 
	  else if(SH_bad_objects>0)
	  { 
	   
  	   if((batchsilent==0)&&(DO_QAST==0))
	   {
	     XtVaSetValues(run_format_dialog,
			XmNhelpLabelString, STRING("FCODE Error Help"),
			NULL);
	   }

	   inputfileDialogCallback(drawing_a,(XtPointer)1,
			     (XmFileSelectionBoxCallbackStruct *)NULL);
	  }

      else if(DoShort==1)
	  {

	   if(batchsilent==0)
	   {
	     XtVaSetValues(run_format_dialog,XmNokLabelString, STRING("OK"),NULL);
	   }

	  
	  
	  inputfileDialogCallback(drawing_a,(XtPointer)1,
			     (XmFileSelectionBoxCallbackStruct *)NULL);


	  batch_mode = 1;


	  makedisconnectCallback((Widget) NULL,(XtPointer) NULL,(XtPointer) NULL);


	  if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
	    {
	      if(MASTERTYPE==1)
		{
		  sprintf(filename,"%sinspection_files\\DFEG_master.txt",indirectory);
		  sprintf(masterrun,"DFEG_master");
		}
	      else if(MASTERTYPE==3)
		{
		  sprintf(filename,"%sinspection_files\\MGCP_master.txt",indirectory);
		  sprintf(masterrun,"MGCP_master");
		}
	      else if(MASTERTYPE==4)
		{
		  sprintf(filename,"%sinspection_files\\UFD1_master.txt",indirectory);
		  sprintf(masterrun,"UFD1_master");
		}
	      else if(MASTERTYPE==5)
		{
		  sprintf(filename,"%sinspection_files\\UFD3_master.txt",indirectory);
		  sprintf(masterrun,"UFD3_master");
		}
	      else if(MASTERTYPE==10)
		{
		  sprintf(filename,"%sinspection_files\\AFD_master.txt",indirectory);
		  sprintf(masterrun,"AFD_master");
		}
	      else if(MASTERTYPE==11)
		{
		  sprintf(filename,"%sinspection_files\\TDS_master.txt",indirectory);
		  sprintf(masterrun,"TDS_master");
		}
	      else if(MASTERTYPE==12)
		{
		  sprintf(filename,"%sinspection_files\\TREX_master.txt",indirectory);
		  sprintf(masterrun,"TREX_master");
		}
	      else
		{
		  printf("Error: bad master type %d.  Aborting load.\n",MASTERTYPE);
		  batch_mode = 0;
		  STOP_FLAG  = 0;
		  return;
		}
	    }
	  else
	    {
	      if(MASTERTYPE==1)
		{
		  sprintf(filename,"%sinspection_files/DFEG_master.txt",indirectory);
		  sprintf(masterrun,"DFEG_master");
		}
	      else if(MASTERTYPE==3)
		{
		  sprintf(filename,"%sinspection_files/MGCP_master.txt",indirectory);
		  sprintf(masterrun,"MGCP_master");
 		}
	      else if(MASTERTYPE==4)
		{
		  sprintf(filename,"%sinspection_files/UFD1_master.txt",indirectory);
		  sprintf(masterrun,"UFD1_master");
 		}
	      else if(MASTERTYPE==5)
		{
		  sprintf(filename,"%sinspection_files/UFD3_master.txt",indirectory);
		  sprintf(masterrun,"UFD3_master");
 		}
	      else if(MASTERTYPE==10)
		{
		  sprintf(filename,"%sinspection_files/AFD_master.txt",indirectory);
		  sprintf(masterrun,"AFD_master");
 		}
	      else if(MASTERTYPE==11)
		{
		  sprintf(filename,"%sinspection_files/TDS_master.txt",indirectory);
		  sprintf(masterrun,"TDS_master");
 		}
	      else if(MASTERTYPE==12)
		{
		  sprintf(filename,"%sinspection_files/TREX_master.txt",indirectory);
		  sprintf(masterrun,"TREX_master");
 		}
	      else
		{
		  printf("Error: bad master type %d.  Aborting load.\n",MASTERTYPE);
		  batch_mode = 0;
		  STOP_FLAG  = 0;
		  return;
		}
	    }


	  printf("loading %s\n",filename);

	  lines_to_skip = FindEDCSInFile(filename);
	  ApplyExecutionOptions(filename,0);
	  bad_lines = DoBatchEDCSStuff((Widget)NULL,filename,lines_to_skip,1);


	  printf("executing analyses automatically...(%d,%d)-(%d,%d)\n",
		 0,MaxXindex,0,MaxYindex);

	  batch_mode = 0;
	  STOP_FLAG  = 0;
	  num_shapes_processed = 0;

	  success = ICheckRegion(0,MaxXindex,0,MaxYindex);


	  ResetKeepDismiss(1);


	  if(ConsultPreviouslyIgnored==1)
	    {
	      DismissPreviouslyIgnored();
	    }
	  
	  
	  ResetBOoptions();
	  


	  if(success==0)
	    {
	      
	      if(RUNNING_INFO==1)
		{ 	  
		  XtDestroyWidget(running_info);
		  RUNNING_INFO=0;
		}
	      cleanse_events();
	      set_cursor(mydisplay,mywindow,GOOD);
	      
	      return;
	    }
	  
	  reporthandleCallback((Widget)NULL, (XtPointer)3, (XtPointer)NULL );      
 

	  if(NGA_TYPE==1)
	    {
          WriteSummaryReport(3); 
	      WriteSummaryReport(1); 
	    }
	  
	  
	  if(DEBUG==1){printf("all computations done...cleaning up\n");}
	  
	  
	  
	  for(i=1;i<=CONDITION_DEFINITIONS;i++)
	    {
	      if(ErrorLookup[i].number>0)
		{
		  totalconds = totalconds + ErrorLookup[i].number;
		  ErrorLookup[i].viewall  = 1;
		  ErrorLookup[i].viewsome = 0;
		}
	      else
		{
		  ErrorLookup[i].viewall  = 0;
		  ErrorLookup[i].viewsome = 0;
		}
	    }
	  for(i=0;i<CLONE_DEFINITIONS;i++)
	    {
	      if(CloneErrorLookup[i].number>0)
		{
		  totalconds = totalconds + CloneErrorLookup[i].number;
		  CloneErrorLookup[i].viewall  = 1;
		  CloneErrorLookup[i].viewsome = 0;
		}
	      else
		{
		  CloneErrorLookup[i].viewall  = 0;
		  CloneErrorLookup[i].viewsome = 0;
		}
	    }

	  
	  if(RUNNING_INFO==1)
	    {
	      if(totalconds>0)
		{
		  XtVaSetValues(running_info,XmNcancelLabelString, STRING("Stop Drawing Conditions"),NULL);
		}
	      else
		{
		  XtVaSetValues(running_info,XmNcancelLabelString, STRING("OK"),NULL);
		}
	    }
	  

	  
	  GenerateErrorEditor(0);
	  
	  cleanse_events();
	  BUSY = 0;
	  set_cursor(mydisplay,mywindow,GOOD);
	  
	  return;  

	}
      else
	  { 
	    

	    if(batchsilent==0)
		{
		  if((DO_QAST==0)||(QAST_LEAVEWINDOWS==1))
		  {
	        XtVaSetValues(run_format_dialog,
			  XmNokLabelString, STRING("OK"),
			  NULL);
		  }
		} 

	    
	    inputfileDialogCallback(drawing_a,(XtPointer)1,
				  (XmFileSelectionBoxCallbackStruct *)NULL);
	  } 
    }
  else
    {
	  if(batchsilent==0)
	  {
        XtVaSetValues(run_format_dialog,
		    XmNokLabelString, STRING("OK"),
		    NULL);
	  }

      
      inputfileDialogCallback(drawing_a,(XtPointer)1,
			      (XmFileSelectionBoxCallbackStruct *)NULL);      
    }


  if(FORMATBUTTON==1)
    {
      XtVaSetValues(run_format_dialog,
		    XmNcancelLabelString, STRING("Delete Extract Files"),
		    NULL);
    }



  if(NGA_TYPE==1)
  {
	
	WriteSummaryReport(3);
  }




  BUSY = 0;
  set_cursor(mydisplay,mywindow,GOOD);
}







void ReallySaveDefaultsCallback2(Widget w,XtPointer data,XtPointer callData)
{
  FILE *out;
  char name[500];
  char fname[500];
  int i;

  BUSY = 1;
  set_cursor(mydisplay,mywindow,WATCH);
  
  SortListbyOrder(0,SCC_NUM-1);

  if(WRITETXT==1)
    {
      if((int)callData==1)
	{
	  sprintf(fname,"%sdynamicdefs.txt",importoutputdir);
	  out = fopen(fname,"w");
	}

      if(out==NULL)
	{
	  printf("couldnt open %s for write\n",fname);
	  ExitWrapper(-1);
	}
      for(i=0;i<SCC_NUM;i++)
	{
	  if((int)callData==1)
	    {
	      fprintf(out,"%d %d %d %d\n",
		      SCC_LIST[i].sccint,SCC_LIST[i].config,SCC_LIST[i].strat,SCC_LIST[i].domain);
	    }
	  else
	    {
	      SEEIT_fwrite_int(&SCC_LIST[i].sccint,out);
	      fwrite(&SCC_LIST[i].config,SzUC,1,out);
	      fwrite(&SCC_LIST[i].strat ,SzUC,1,out);
	      fwrite(&SCC_LIST[i].domain,SzUC,1,out);
	    }
	}
      fclose(out);
    }
  
  if(WRITEBIN==1)
    {
      if((int)callData==1)
	{
	  sprintf(fname,"%sdynamicdefs.bin",importoutputdir);
	}

      out = fopen(fname,"wb");
      if(out==NULL)
	{
	  printf("couldnt open %s for write\n",fname);
	  ExitWrapper(-1);
	}
      for(i=0;i<SCC_NUM;i++)
	{
	  SEEIT_fwrite_int(&SCC_LIST[i].sccint,out);
	  fwrite(&SCC_LIST[i].config,SzUC,1,out);
	  fwrite(&SCC_LIST[i].strat ,SzUC,1,out);
	  fwrite(&SCC_LIST[i].domain,SzUC,1,out);
	}
      fclose(out);
    }

  if((int)callData!=1)
    {
      sprintf(name,"Wrote out settings to\n%s\n",fname);      
      not_while_running(XtParent(w),name,1375,"Settings Written",5);
    }



  SortListbySCC(0,SCC_NUM-1);

  BUSY = 0;
  set_cursor(mydisplay,mywindow,GOOD);
}







void SaveDynamicDefaultsCallback(Widget w,XtPointer data,XtPointer callData)
{
  FILE *out;
  char name[500];
  char fname[500];
  int i;

  BUSY = 1;
  set_cursor(mydisplay,mywindow,WATCH);
  
  SortListbyDOrder(0,DYNAMIC_SCC_NUM-1);


  if(WRITETXT==1)
    {
      sprintf(fname,"%sdynamicdefs.txt",indirectory);
	
      out = fopen(fname,"w");
      if(out==NULL)
	{
	  printf("couldnt open %s for write\n",fname);
	  ExitWrapper(-1);
	}
      for(i=0;i<DYNAMIC_SCC_NUM;i++)
	{
	  fprintf(out,"%d %d %d %d\n",
		  DYNAMIC_SCC_LIST[i].sccint,DYNAMIC_SCC_LIST[i].config,DYNAMIC_SCC_LIST[i].strat,DYNAMIC_SCC_LIST[i].domain);
	}
      fclose(out);
    }

  if(WRITEBIN==1)
    {
      sprintf(fname,"%sdynamicdefs.bin",indirectory);
      out = fopen(fname,"wb");
      if(out==NULL)
	{
	  printf("couldnt open %s for write\n",fname);
	  ExitWrapper(-1);
	}
      for(i=0;i<DYNAMIC_SCC_NUM;i++)
	{
	  SEEIT_fwrite_int(&DYNAMIC_SCC_LIST[i].sccint,out);
	  fwrite(&DYNAMIC_SCC_LIST[i].config,SzUC,1,out);
	  fwrite(&DYNAMIC_SCC_LIST[i].strat ,SzUC,1,out);
	  fwrite(&DYNAMIC_SCC_LIST[i].domain,SzUC,1,out);
	}
      fclose(out);
    }
  
  sprintf(name,"Wrote out settings to\n%s\n",fname);      
  not_while_running(XtParent(w),name,1376,"Settings Written",5);
  
  SortListbyDSCC(0,DYNAMIC_SCC_NUM-1);

  BUSY = 0;
  set_cursor(mydisplay,mywindow,GOOD);
}





void SaveDefaultsCallback2(Widget w,XtPointer data,XtPointer callData)
{
  extern void ReadDynamicDefsFile(void);

  SaveDynamicDefaultsCallback(w,data,(XtPointer)NULL);
  ReadDynamicDefsFile();

  MOD_UP = 0;
  XtDestroyWidget (XtParent(XtParent(XtParent(w))));
}



int PartitionbySCC(int p,int r)
{
  char x[500];
  int i,j;
  struct SCCstoreint temp;

  sprintf(x,"%s",SCC_LIST[p].SCC);
  i = p-1;
  j = r+1;
  while(1)
    {
      do{j=j-1;}
      while(strcmp(SCC_LIST[j].SCC,x)>0);

      do{i=i+1;}
      while(strcmp(SCC_LIST[i].SCC,x)<0);
    
      if(i<j)
	{
	  temp = SCC_LIST[i];
	  SCC_LIST[i] = SCC_LIST[j];
	  SCC_LIST[j] = temp;
	}
      else
	{
	  return j;
	}
    }
}

int PartitionbyDSCC(int p,int r)
{
  char x[500];
  int i,j;
  struct SCCstoreint temp;

  sprintf(x,"%s",DYNAMIC_SCC_LIST[p].SCC);
  i = p-1;
  j = r+1;
  while(1)
    {
      do{j=j-1;}
      while(strcmp(DYNAMIC_SCC_LIST[j].SCC,x)>0);

      do{i=i+1;}
      while(strcmp(DYNAMIC_SCC_LIST[i].SCC,x)<0);
    
      if(i<j)
	{
	  temp = DYNAMIC_SCC_LIST[i];
	  DYNAMIC_SCC_LIST[i] = DYNAMIC_SCC_LIST[j];
	  DYNAMIC_SCC_LIST[j] = temp;
	}
      else
	{
	  return j;
	}
    }
}
 









void SortListbySCC(int p,int r)
{
  int q;

  
  if(p<r)
    {
      q = PartitionbySCC(p,r);
      SortListbySCC(p,q);
      SortListbySCC(q+1,r);
    }
}


void SortListbyDSCC(int p,int r)
{
  
  int q;
  if(p<r)
    {
      q = PartitionbyDSCC(p,r);
      SortListbyDSCC(p,q);
      SortListbyDSCC(q+1,r);
    }
}


int PartitionbyOrder(int p,int r)
{
  int x;
  int i,j;
  struct SCCstoreint temp;

  x = SCC_LIST[p].orig_position;
  i = p-1;
  j = r+1;
  while(1)
    {
      do{j=j-1;}
      while(SCC_LIST[j].orig_position>x);

      do{i=i+1;}
      while(SCC_LIST[i].orig_position<x);
    
      if(i<j)
	{
	  temp = SCC_LIST[i];
	  SCC_LIST[i] = SCC_LIST[j];
	  SCC_LIST[j] = temp;
	}
      else
	{
	  return j;
	}
    }
}

int PartitionbyDOrder(int p,int r)
{
  int x;
  int i,j;
  struct SCCstoreint temp;

  x = DYNAMIC_SCC_LIST[p].orig_position;
  i = p-1;
  j = r+1;
  while(1)
    {
      do{j=j-1;}
      while(DYNAMIC_SCC_LIST[j].orig_position>x);

      do{i=i+1;}
      while(DYNAMIC_SCC_LIST[i].orig_position<x);
    
      if(i<j)
	{
	  temp = DYNAMIC_SCC_LIST[i];
	  DYNAMIC_SCC_LIST[i] = DYNAMIC_SCC_LIST[j];
	  DYNAMIC_SCC_LIST[j] = temp;
	}
      else
	{
	  return j;
	}
    }
}

void SortListbyOrder(int p,int r)
{
  int q;
  
  if(p<r)
    {
      q = PartitionbyOrder(p,r);
      SortListbyOrder(p,q);
      SortListbyOrder(q+1,r);
    }
}


void SortListbyDOrder(int p,int r)
{
  int q;

  if(p<r)
    {
      q = PartitionbyDOrder(p,r);
      SortListbyDOrder(p,q);
      SortListbyDOrder(q+1,r);
    }
}



void VerifyContainsShapes(char *projname)
{

  IgnoredPointFile[0] = '\0';
  IgnoredLineFile [0] = '\0';
  

  if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
  { 
    if(ProjectContainsLNfile(projname))
	{
	  sprintf(IgnoredLineFile,"%s\\%s\\exported_shapefiles\\consolidated",PROJECTLOC,projname);
	}

      
    if(ProjectContainsPTfile(projname))
	{
	  sprintf(IgnoredPointFile,"%s\\%s\\exported_shapefiles\\consolidated",PROJECTLOC,projname);
	}

  }
  else
  {
    if(ProjectContainsLNfile(projname))
	{
	  sprintf(IgnoredLineFile,"%s/%s/exported_shapefiles/consolidated",PROJECTLOC,projname);
	}
      if(ProjectContainsPTfile(projname))
	{
	  sprintf(IgnoredPointFile,"%s/%s/exported_shapefiles/consolidated",PROJECTLOC,projname);
	}
  }

  if((IgnoredPointFile[0]=='\0')&&(IgnoredLineFile[0]=='\0'))
  {
    printf("The project \"%s\" does not contain either of the exported shapefiles:\n",projname);
	printf("consolidated1LN or consolidated1PT.  When using the -markignore option,\n");
	printf("you are required to supply a project containing exported shapefiles.\n");
	ExitWrapper(-1);
  }

  ConsultPreviouslyIgnored = 1;
}




void TestProjectName(int containsshapes, char *projname)
{
  int goodname,i;

  for(i=0;i<(int)strlen(projname);i++)
  {
    if(
       ((projname[i]>=65)  && (projname[i]<=90))  ||
       ((projname[i]>=48)  && (projname[i]<=57))  ||
       ((projname[i]>=97)  && (projname[i]<=122)) ||
       (projname[i]=='-') || (projname[i]=='_')	
	  ) 
	   {
		 goodname  =1;
	   }
	   else
	   {
	    printf("\n\nThe project name: %s\n   contains the invalid character: \"%c\"\n\n",projname,projname[i]);
		printf("aborting batch mode\n\n");
	    ExitWrapper(-1);
	   }
  }

  if(containsshapes==1)
  {
	  VerifyContainsShapes(projname);
  }

}



void FailInstall()
{
  if(USE_DOS==1)
    {
      printf("Verify that the GAITHOME variable has been set correctly.\n");
      printf("Usually this is done in the batch file used to launch GAIT (ie, rungait26.bat).\n");
      printf("A typical example is \"SET GAITHOME=C:\\Documents and Settings\\Admin\\Desktop\\GAIT-WINDOWS-26\"\n");
      printf("GAIT cannot continue until this variable is set correctly\n");
    }
  ExitWrapper(-1);
}


void VerifyCorrectLocation()
{
  

  char filename[1000];
  int i,tempnum=76;

  char *allfiles[76]=
  {
    "D4_combo.bin",
    "D4_domains.bin",
    "FACC_PLUS_combo.bin",
    "FACC_PLUS_domains.bin",
    "VMAP_combo.bin",
    "VMAP_augdomains.bin",
    "MGCP3_combo.bin",
    "MGCP3_domains.bin",
    "MGCP3_VV.bin",
    "MGCP3_VVdomains.bin",
    "MGCP3_ReqFCODES.bin",
    "MGCP4_combo.bin",
    "MGCP4_domains.bin",


    "GGDM21_combo.bin",
    "GGDM21_domains.bin",
    "GGDM21_VV.bin",
    "GGDM21_VVdomains.bin",
	"GGDM21_BndryAttrMatch.csv",

    "GGDM22_combo.bin",
    "GGDM22_domains.bin",
    "GGDM22_VV.bin",
    "GGDM22_VVdomains.bin",
	"GGDM22_BndryAttrMatch.csv",

    "GGDM3_combo.bin",
    "GGDM3_domains.bin",
    "GGDM3_VV.bin",
    "GGDM3_VVdomains.bin",
	"GGDM3_BndryAttrMatch.csv",

    "UFD1_combo.bin",
    "UFD1_domains.bin",
    "UFD2_combo.bin",
    "UFD2_domains.bin",
    "UFD3_combo.bin",
    "UFD3_domains.bin",
    "AFD_combo.bin",
    "AFD_domains.bin",
    "UFD1_VV.bin",
    "UFD1_VVdomains.bin",
    "agdf1.dat",
    "agdf2.dat",
    "agdf3.dat",
    "agdf4.dat",
    "agdf5.dat",
    "agdf6.dat",
    "pcdf1.dat",
    "pcdf2.dat",
    "pcdf3.dat",
    "pcdf4.dat",
    "pcdf5.dat",
    "pcdf6.dat",
 	"D4_BndryAttrMatch.csv",
	"MGCP3_BndryAttrMatch.csv",
	"MGCP4_BndryAttrMatch.csv",
	"NFDD_BndryAttrMatch.csv",
	"DFDD_BndryAttrMatch.csv",
	"AFD_BndryAttrMatch.csv",
	"FACC_PLUS_BndryAttrMatch.csv",
	"VMAP_BndryAttrMatch.csv",
	"UFD1_BndryAttrMatch.csv",
	"UFD2_BndryAttrMatch.csv",
	"UFD3_BndryAttrMatch.csv",
	"TDS4_BndryAttrMatch.csv",
    "TDS4_combo.bin",
    "TDS4_domains.bin",
    "TDS4_VV.bin",
    "TDS4_VVdomains.bin",
    "TDS4_VVT3.bin",
    "TDS4_VV3domains.bin",
    "TDS4NotExtracted.bin",
    "TDS6_combo.bin",
    "TDS6_domains.bin",
    "TDS6_VV.bin",
    "TDS6_VVdomains.bin",
    "TDS6NotExtracted.bin",
    "MGCP4FullPortrayAttrs.bin",
    "TDS6FullPortrayAttrs.bin"
  };

  

  i=strlen(GAIT_HOME_DIR);
  
  if(USE_DOS==1) 
    {
      if(GAIT_HOME_DIR[i]=='\0') 
	{  
	  if(GAIT_HOME_DIR[i-1]!='\\')
	    {
	      GAIT_HOME_DIR[i]   = '\\';
	      GAIT_HOME_DIR[i+1] = '\0';
	    } 
	} 
      sprintf(GAIT_BIN_DIR,"%sbin\\",GAIT_HOME_DIR);
    }
  else
    {
      if(GAIT_HOME_DIR[i]=='\0') 
	{  
	  if(GAIT_HOME_DIR[i-1]!='/')
	    {
	      GAIT_HOME_DIR[i]   = '/';
	      GAIT_HOME_DIR[i+1] = '\0';
	    } 
	} 
      sprintf(GAIT_BIN_DIR,"%sbin/",GAIT_HOME_DIR);
    }


  printf("GAIT_HOME_DIR: %s\n",GAIT_HOME_DIR);
  printf("GAIT_BIN_DIR : %s\n",GAIT_BIN_DIR);


  for(i=0;i<tempnum;i++)
    {
      sprintf(filename,"%s%s",GAIT_BIN_DIR,allfiles[i]);
      if(FileExists(filename)==0)
	{
	  printf("error:  could not open %s for read\n",filename);
	  FailInstall();
	}
    }
}




void SetGAITHomeDir(char *stub)
{
  char tempstring[1000],tempstring2[1000];
  int i,len,insertindex,lastslash,addy1,addy2,madeachange;

  if(USE_DOS==1)
    {
      


      if(getenv("GAITHOME")!=NULL)
	{
	  sprintf(GAIT_HOME_DIR,"%s",getenv("GAITHOME"));
	  
	  printf("Found GAITHOME %s\n",GAIT_HOME_DIR);
	  sprintf(tempstring,"UserDir=%s",GAIT_HOME_DIR);
	  putenv(tempstring);
	}
      else
	{
	  printf("Error: Did not find GAITHOME environment variable!\n  This variable should be set in the batch file used to launch GAIT.\n\n");
	  #if(USE_DOS==1) 
	  _getcwd(tempstring,1000);
      #endif

	  printf("Attempting to use %s\n",tempstring);
	  sprintf(GAIT_HOME_DIR,"%s",tempstring);	  
	  printf("Found GAITHOME %s\n",GAIT_HOME_DIR);
	  sprintf(tempstring,"UserDir=%s",GAIT_HOME_DIR);
	  putenv(tempstring);
	}
    }
  else
    {
      if(stub[0]=='/')
	{
	  sprintf(GAIT_HOME_DIR,"%s",stub);
	}
      else
	{
#if(USE_DOS==1)
	 
	  _getcwd(tempstring,1000);
#else
extern char *getcwd(char *buf, size_t size);
	  getcwd(tempstring,1000);
#endif
	  sprintf(GAIT_HOME_DIR,"%s/%s",tempstring,stub);
	}


      madeachange = 1;
      while(madeachange==1)
	{
	  

	  madeachange = 0;

	  addy1 = (int)GAIT_HOME_DIR;
	  addy2 = (int)strstr(GAIT_HOME_DIR,"/./");

	  if(addy2>addy1)
	    {
	      madeachange = 1;

	      
	      sprintf(tempstring,"%s",GAIT_HOME_DIR);

	      
	      tempstring[addy2-addy1+1] = '\0';

	      
	      strcat(tempstring,&GAIT_HOME_DIR[addy2-addy1+3]);
	      sprintf(GAIT_HOME_DIR,"%s",tempstring);
	    }
	}



      madeachange = 1;
      while(madeachange==1)
	{
	  
	  
	  madeachange = 0;
	  insertindex = 0;
	  lastslash = -1;
	  sprintf(tempstring,"%s",GAIT_HOME_DIR);
	  len = strlen(tempstring);
	  
	  for(i=0;i<len;i++)
	    {
	      tempstring2[insertindex] = tempstring[i];
	      insertindex = insertindex + 1;

	      if(madeachange==1)
		{
		  
		  continue;
		}

	      if((tempstring[i]=='/')&&(i>0)&&(i<len-3))
		{
		  if(
		     (tempstring[i+1]=='.')&&
		     (tempstring[i+2]=='.')&&
		     (tempstring[i+3]=='/')
		     )
		    {
		      
		      insertindex = insertindex - (i-lastslash);
		      i = i + 3; 
		      madeachange = 1;
		    }
		  else
		    {
		      lastslash = i;
		    }
		}
	      else if(tempstring[i]=='/')
		{
		  lastslash = i;
		}
	    }

	  tempstring2[insertindex] = '\0';
	  sprintf(GAIT_HOME_DIR,"%s",tempstring2);
	}



      lastslash = 0;
      
      for(i=0;i<(int)strlen(GAIT_HOME_DIR);i++)
	{
	  if(GAIT_HOME_DIR[i]=='/')
	    {
	      lastslash = i;
	    }
	}
      
      
      GAIT_HOME_DIR[lastslash] = '\0';
    }
}





#define MAX_ENV_VALUES 50

char EnvValues[MAX_ENV_VALUES][100];
int EnvSetInt[MAX_ENV_VALUES];
int EnvSetIntCount;
int EnvSetIntDefault;



int INT_CHECK(char *value)
{
  int i;
  
  for(i=0;i<(int)(strlen(value));i++)
  { 
    if((value[i]<'0')||(value[i]>'9'))
	{
	  return 0; 
	}
  }
  if(strlen(value)==0)
    {
      return 0;
    }
  return 1;
}



int GetFirstSecondThird(char *aline,char first[],char second[],char third[], int line)
{
  int i,len,foundequal;
  
  sscanf(aline,"%s",first);

  if(strcmp(first,"SET"))
  {
    printf("Error loading preference file, line %d: %s\n",line,aline);
	printf("This line does not start with \"SET \"");
    return 0;
  } 

  len = strlen(aline);
  foundequal = 0;

  for(i=0;i<len;i++)
  {
    if(aline[i]=='=')
	{
      foundequal = i;
      break;
	}
  }

  if(foundequal==0)
  {
    printf("Error loading preference file, line %d: %s\n",line,aline);
	printf("This line does not contain an \"=\" character");
    return 0;
  }

  sprintf(second,"%s",&aline[4]);
  second[foundequal-4] = '\0';

  sprintf(third,"%s",&aline[foundequal+1]);

  return 1;
}


int GetIntFromFile(FILE *envfile,char *varname,int current_value)
{
  char aline[1000],first[500],second[500],third[500];
  int i,len,line;

  

  rewind(envfile);

  fgets(aline,1000,envfile);
  line = 1;

  while(!feof(envfile))
  {
    len = strlen(aline);
	if(aline[len-1]<32)
	{
      aline[len-1] = '\0';
	}

	if(GetFirstSecondThird(aline,first,second,third,line)==0)
	{
      return current_value;
	}

	if(!strcmp(second,varname))
	{
      for(i=0;i<EnvSetIntCount;i++)
	  {
        if(!strcmp(EnvValues[i],third))
		{
          return EnvSetInt[i];
		}
	  }
	  printf("Error: Got %s with unexpected value %s\n",second,third);
	  return current_value;
	}

    fgets(aline,1000,envfile);
	line = line + 1;
  }

  return current_value;
}


double GetDoubleFromFile(FILE *envfile,char *varname,double current_value)
{
  char aline[1000],first[500],second[500],third[500];
  int len,line;
  double retval;

  

  rewind(envfile);

  fgets(aline,1000,envfile);
  line = 1;

  while(!feof(envfile))
  {
    len = strlen(aline);
	if(aline[len-1]<32)
	{
      aline[len-1] = '\0';
	}

	if(GetFirstSecondThird(aline,first,second,third,line)==0)
	{
      return current_value;
	}


	if(!strcmp(second,varname))
	{
	  if(NUM_CHECK(third))
	  { 
        sscanf(third,"%lf",&retval);
        return retval;
	  } 
	  else
	  { 
        printf("Illegal value for variable %s: %s (expected real value)\n",second,third);
        return current_value;
	  } 
	}

    fgets(aline,1000,envfile);
	line = line + 1;
  }

  return current_value;
}




int GetInt2FromFile(FILE *envfile,char *varname,int current_value)
{
  char aline[1000],first[500],second[500],third[500];
  int len,retval,line;

  

  rewind(envfile);

  fgets(aline,1000,envfile);
  line = 1;

  while(!feof(envfile))
  {
    len = strlen(aline);
	if(aline[len-1]<32)
	{
      aline[len-1] = '\0';
	}

	if(GetFirstSecondThird(aline,first,second,third,line)==0)
	{
      return current_value;
	}


	if(!strcmp(second,varname))
	{
	  if(INT_CHECK(third))
	  { 
        sscanf(third,"%d",&retval);
        return retval;
	  } 
	  else
	  { 
        printf("Illegal value for variable %s: %s (expected integer value)\n",second,third);
        return current_value;
	  } 
	}

    fgets(aline,1000,envfile);
	line = line + 1;
  }

  return current_value;
}



char *GetStringFromFile(FILE *envfile,char *varname,char *current_value)
{
  char aline[1000],first[500],second[500];
  int i,len,line;
  static char third[500];

  

  rewind(envfile);

  fgets(aline,1000,envfile);
  line = 1;

  while(!feof(envfile))
  {
    len = strlen(aline);
	if(aline[len-1]<32)
	{
      aline[len-1] = '\0';
	}

	if(GetFirstSecondThird(aline,first,second,third,line)==0)
	{
      return current_value;
	}


	if(!strcmp(second,varname))
	{

	  if(
		  (!strcmp(varname,"GAIT_EXPORT_CONDITION_SHAPEFILE_NAME"))||
		  (!strcmp(varname,"GAIT_PROJECT_NAME"))
		 ) 
	  { 
        len = strlen(third);

         for(i=0;i<len;i++)
		 { 
           if(
               ((third[i]<65)   || (third[i]>90))  &&
               ((third[i]<48)   || (third[i]>57))  &&
               ((third[i]<97)   || (third[i]>122)) &&
                (third[i]!='-') && (third[i]!='_')
		      )
		   {
             printf("Error: Found %s variable with illegal value: %s\n",second,third);
             printf("   The value %s is invalid because it contains the character \"%c\"\n",third,third[i]);
             printf("     Only names consisting of letters, numbers, \"-\", and \"_\" are allowed\n");

             return current_value;
		   }
		 }
	  }

	  return third;
	}

    fgets(aline,1000,envfile);
	line = line + 1;
  }

  return current_value;
}




double SetGAITVarDouble(FILE *envfile,int flag,double origval,char *varname,char *usage)
{
  char env_value[2000];
  double retval;



  if(flag==1)
  {
    fprintf(envfile,"SET %s=%lf\n",varname,origval);
	return origval;
  }

  if(flag==2)
  {
	return GetDoubleFromFile(envfile,varname,origval);
  }


  if(ALSO_PRINT_USAGE==1)
  {  
    printf("REM Variable: %s\n",varname);
    printf("REM  Use: %s\n",usage);

	if(!strcmp(varname,"GAIT_CONTOUR_INTERVAL"))
	{
      printf("REM  Acceptable values (real):\n");
      printf("REM    >0-2000 (default: 10.0)\n");
      printf("SET %s=10.0\n",varname);
	}
	else if(!strcmp(varname,"GAIT_SUN_AZIMUTH"))
	{
      printf("REM  Acceptable values (integer):\n");
      printf("REM    0-359 (default: 315)\n");
      printf("SET %s=315\n",varname);
	}
	else if(!strcmp(varname,"GAIT_SUN_ANGLE"))
	{
      printf("REM  Acceptable values (integer):\n");
      printf("REM    15-75 (default: 45)\n");
      printf("SET %s=45\n",varname);
	}
	else if(!strcmp(varname,"GAIT_VERTICAL_EXAGGERATION"))
	{
      printf("REM  Acceptable values (real):\n");
      printf("REM    0.1-1000 (default: 1.0)\n");
      printf("SET %s=1.0\n",varname);
	}
	else if(!strcmp(varname,"GAIT_LOS_OBSERVER_HEIGHT"))
	{
      printf("REM  Acceptable values (real):\n");
      printf("REM    0.1-1000 (default: 1.7)\n");
      printf("SET %s=1.7\n",varname);
	}
	else if(!strcmp(varname,"GAIT_LOS_TARGET_HEIGHT"))
	{
      printf("REM  Acceptable values (real):\n");
      printf("REM    0.1-1000 (default: 1.7)\n");
      printf("SET %s=1.7\n",varname);
	}
	else if(!strcmp(varname,"GAIT_LOS_FAN_ANGLE"))
	{
	  if(DO_FAN()==1)
	  {
        printf("REM  Acceptable values (real):\n");
        printf("REM    0.1-360.0 (default: 45.0)\n");
        printf("SET %s=45.0\n",varname);
	  }
	}
	else if(!strcmp(varname,"GAIT_LOS_FAN_GRANULARITY"))
	{
      printf("REM  Acceptable values (integer):\n");
      printf("REM    1-10 (default: 5)\n");
      printf("SET %s=5\n",varname);
	}
	else if(!strcmp(varname,"GAIT_USER_GRID_X_ANCHOR"))
	{
      printf("REM  Acceptable values (real):\n");
      printf("REM    -180.0 - 180.0 (default: 0.0)\n");
      printf("SET %s=0.0\n",varname);
	}
	else if(!strcmp(varname,"GAIT_USER_GRID_Y_ANCHOR"))
	{
      printf("REM  Acceptable values (real):\n");
      printf("REM    -90.0 - 90.0 (default: 0.0)\n");
      printf("SET %s=0.0\n",varname);
	}
	else if(!strcmp(varname,"GAIT_IMPORT_RECTANGLE_LLX"))
	{
      printf("REM  Acceptable values (real):\n");
      printf("REM    -180.0 - 180.0 (default: -180.0)\n");
      printf("SET %s=-180.0\n",varname);
	}
	else if(!strcmp(varname,"GAIT_IMPORT_RECTANGLE_URX"))
	{
      printf("REM  Acceptable values (real):\n");
      printf("REM    -180.0 - 180.0 (default: 180.0)\n");
      printf("SET %s=180.0\n",varname);
	}
	else if(!strcmp(varname,"GAIT_IMPORT_RECTANGLE_LLY"))
	{
      printf("REM  Acceptable values (real):\n");
      printf("REM    -90.0 - 90.0 (default: -90.0)\n");
      printf("SET %s=-90.0\n",varname);
	}
	else if(!strcmp(varname,"GAIT_IMPORT_RECTANGLE_URY"))
	{
      printf("REM  Acceptable values (real):\n");
      printf("REM    -90.0 - 90.0 (default: 90.0)\n");
      printf("SET %s=90.0\n",varname);
	}
	else if(!strcmp(varname,"GAIT_CONDITION_ZOOM_PAD_DISTANCE"))
	{
      printf("REM  Acceptable values (real):\n");
      printf("REM    1.0 - 5000.0 (default: 10.0)\n");
      printf("SET %s=10.0\n",varname);
	}
	else if(!strcmp(varname,"GAIT_INFO_VERTEX_ZOOM_PAD_DISTANCE"))
	{
      printf("REM  Acceptable values (real):\n");
      printf("REM    1.0 - 5000.0 (default: 10.0)\n");
      printf("SET %s=10.0\n",varname);
	}
	else if(!strcmp(varname,"GAIT_POI_ZOOM_PAD_DISTANCE"))
	{
      printf("REM  Acceptable values (real):\n");
      printf("REM    1.0 - 5000.0 (default: 10.0)\n");
      printf("SET %s=10.0\n",varname);
	}
	else if(!strcmp(varname,"GAIT_USER_GRID_SPACING"))
	{
      printf("REM  Acceptable values (real):\n");
      printf("REM    .00001 - 10.0 (default: 1.0)\n");
      printf("SET %s=1.0\n",varname);
	}
	else if(!strcmp(varname,"GAIT_TREX_CP_STDV_LIMIT"))
	{
      printf("REM  Acceptable values (real):\n");
      printf("REM    0 - 200.0 (default: 1.0)\n");
      printf("SET %s=1.0\n",varname);
	}
	else if(!strcmp(varname,"GAIT_TREX_CP_AVG_LIMIT"))
	{
      printf("REM  Acceptable values (real):\n");
      printf("REM    0 - 500.0 (default: 20.0)\n");
      printf("SET %s=20.0\n",varname);
	}
	else if(!strcmp(varname,"GAIT_TREX_GCP_DIFF_LIMIT"))
	{
      printf("REM  Acceptable values (real):\n");
      printf("REM    0 - 500.0 (default: 20.0)\n");
      printf("SET %s=20.0\n",varname);
	}
	else if(!strcmp(varname,"GAIT_CONDITION_LIMIT"))
	{
	  
	}
	else if(!strcmp(varname,"GAIT_SHAPE_LIMIT"))
	{
	  
	}
	else
	{
      printf("Error: SGVI2 %s\n",varname);
	  exit(1);
	}
	printf("REM\n");
  }


  if(getenv(varname)!=NULL)
  {
    sprintf(env_value,"%s",getenv(varname));

	


	

	if(NUM_CHECK(env_value))
	{
       sscanf(env_value,"%lf",&retval);
	   return retval;
	}
  }

  return origval;
}


int SetGAITVarInt2(FILE *envfile,int flag,int origval,char *varname,char *usage)
{
  char env_value[2000];
  int retval;


  if(flag==1)
  {
    fprintf(envfile,"SET %s=%d\n",varname,origval);
	return origval;
  }

  if(flag==2)
  {
	return GetInt2FromFile(envfile,varname,origval);
  }


  if(ALSO_PRINT_USAGE==1)
  {  

	if(!strcmp(varname,"GAIT_INFO_MAX_DECIMALS_TO_PRINT"))
	{
      printf("REM Variable: %s\n",varname);
      printf("REM  Use: %s\n",usage);
      printf("REM  Acceptable values (integer):\n");
      printf("REM    1-15 (default: 10)\n");
      printf("SET %s=10\n",varname);
	}
	else if(!strcmp(varname,"GAIT_INFO_MAX_COORDINATES_TO_PRINT"))
	{
      printf("REM Variable: %s\n",varname);
      printf("REM  Use: %s\n",usage);
      printf("REM  Acceptable values (integer):\n");
      printf("REM    1-99999999 (default: 25000)\n");
      printf("SET %s=25000\n",varname);
	}
	else if(!strcmp(varname,"GAIT_CONDITION_LIMIT"))
	{
	  
	}
	else if(!strcmp(varname,"GAIT_SHAPE_LIMIT"))
	{
	  
	}
	else
	{
      printf("Error: SGVI2 %s\n",varname);
	  exit(1);
	}
	printf("REM\n");
  }

  if(getenv(varname)!=NULL)
  {
    sprintf(env_value,"%s",getenv(varname));

	

	

	if(INT_CHECK(env_value))
	{
       sscanf(env_value,"%d",&retval);
	   return retval;
	}
	else
	{
      printf("** Found illegal value %s for %s: expected integer\n",env_value,varname);
	}
  }

  return origval;
}



char *SetGAITVarString(FILE *envfile,int flag, char *realorigvalue,char *origvalue,char *varname,char *usage)
{
  int i,j,len;
  char env_value[2000];
  static char retvalue[2000];


  if(flag==1)
  {
    if(!strcmp(varname,"GAIT_BROWSE_FOLDER_NAME"))
	{
      if(!strcmp(realorigvalue,"<not specified>"))
	  {
        fprintf(envfile,"SET %s=NULL\n",varname);
	  }
	}
	else
	{
      fprintf(envfile,"SET %s=%s\n",varname,realorigvalue);
	}

	return realorigvalue;
  }

  if(flag==2)
  {
	return GetStringFromFile(envfile,varname,realorigvalue);
  }


  if(ALSO_PRINT_USAGE==1)
  {  
    printf("REM Variable: %s\n",varname);
    printf("REM  Use: %s\n",usage);
	if(!strcmp(varname,"GAIT_EXPORT_CONDITION_SHAPEFILE_NAME"))
	{
      printf("SET %s=consolidated\n",varname);
	}
	else if(!strcmp(varname,"GAIT_FOLDER_WITH_ATTRIBUTION_FILES"))
	{
      printf("SET %s=NULL\n",varname);
	}
	else if(!strcmp(varname,"GAIT_INPUT_DATA_FOLDER"))
	{
      printf("SET %s=NULL\n",varname);
	}
	else if(!strcmp(varname,"GAIT_BROWSE_FOLDER_NAME"))
	{
      printf("SET %s=NULL\n",varname);
	}
	else if(!strcmp(varname,"GAIT_PROJECT_NAME"))
	{
      printf("SET %s=NULL\n",varname);
	}
	else
	{
      printf("Error: SGVS %s\n",varname);
	  exit(1);
	}
	printf("REM\n");
  }

  if(getenv(varname)!=NULL)
  {
    sprintf(env_value,"%s",getenv(varname));
  
	
    
	if(!strcmp(varname,"GAIT_EXPORT_CONDITION_SHAPEFILE_NAME"))
	{
      len = strlen(env_value);

      for(i=0;i<len;i++)
	  {
        if(
            ((env_value[i]<65)   || (env_value[i]>90))  &&
            ((env_value[i]<48)   || (env_value[i]>57))  &&
            ((env_value[i]<97)   || (env_value[i]>122)) &&
             (env_value[i]!='-') && (env_value[i]!='_')
		     )
		{
          printf("Error: Found %s environment variable with illegal value: %s\n",varname,env_value);
          printf("   The value %s is invalid because it contains the character \"%c\"\n",env_value,env_value[i]);
          printf("     Only names consisting of letters, numbers, \"-\", and \"_\" are allowed\n");
          printf("     Using default value \"%s\" instead\n",origvalue);
	      sprintf(retvalue,"%s",origvalue);
          return retvalue;
		}
	  }

      sprintf(retvalue,"%s",env_value);
	  return retvalue;

	}
	else if(!strcmp(varname,"GAIT_FOLDER_WITH_ATTRIBUTION_FILES"))
	{
      sprintf(retvalue,"%s",env_value);
	  len = strlen(retvalue);

      if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
	  {
        if(retvalue[len-1]!='\\')
		{
          sprintf(retvalue,"%s\\",env_value);
		}
	  } 
      else
	  {
        if(retvalue[len-1]!='/')
		{
          sprintf(retvalue,"%s/",env_value);
		}
	  } 
	  return retvalue;
	}


	else if(!strcmp(varname,"GAIT_PROJECT_NAME"))
	{
	  if(!strcmp(env_value,"NULL"))
	  {
		return "";
	  }

      len = strlen(env_value);

	  for(j=0;j<len;j++)
	  {
		if(
		    ((env_value[j]<65)   || (env_value[j]>90))  &&
		    ((env_value[j]<48)   || (env_value[j]>57))  &&
		    ((env_value[j]<97)   || (env_value[j]>122)) &&
		    (env_value[j]!='-')  && (env_value[j]!='_')
		  )
		{
		  printf("The GAIT_PROJECT_NAME entered is invalid because\n\
it contains the character \"%c\"\n\
Valid project names consist of letters, numbers, \"-\", and \"_\"\n",
			      env_value[j]);
          return "";
		}
	  }

      sprintf(retvalue,"%s",env_value);

	
	  return retvalue;

	}


	else if(!strcmp(varname,"GAIT_BROWSE_FOLDER_NAME"))
	{

	  if(!strcmp(env_value,"NULL"))
	  {
        sprintf(retvalue,"<not specified>");
		return retvalue;
	  }

      if(IsValidDirectory(env_value))
	  { 
        sprintf(retvalue,"%s",env_value);

        len = strlen(retvalue);
        if(retvalue[len-1]!=MYCHARSLASH)
		{  
		  printf("Adding ending slash to GAIT_BROWSE_FOLDER_NAME=%s\n",retvalue);
          strcat(retvalue,MYSLASH);
	      printf("Using GAIT_BROWSE_FOLDER_NAME = %s\n",retvalue);
		} 

	    return retvalue;
	  } 

	  if(strcmp(env_value,"<not specified>"))
	  {
        printf("\
Error processing environment variable:\n\
  Variable: GAIT_BROWSE_FOLDER_NAME\n\
  Value: %s\n\
  Error: %s is not a valid folder.\n\
  Re-setting GAIT browse folder to <not specified>\n",env_value,env_value);
	  }

	  return "<not specified>";

	} 

	else
	{
      sprintf(retvalue,"%s",env_value);
      return retvalue;
	}
  }

  sprintf(retvalue,"%s",origvalue);
  return retvalue;

}


int SetGAITVarInt(FILE *envfile,int flag,int current_value,char *varname,char *usage)
{
  int i;
  char env_value[2000];
  extern int CREATING_TREX;

  if(flag==1)
  {
    

    for(i=0;i<EnvSetIntCount;i++)
	{
      if(EnvSetInt[i]==current_value)
	  {
        
        fprintf(envfile,"SET %s=%s\n",varname,EnvValues[i]);
		return current_value;
	  }
	}

	printf("Error: %s currently set to unrecognized value %d...cannot save\n",varname,current_value);
	return current_value;
  }

  if(flag==2)
  {
	return GetIntFromFile(envfile,varname,current_value);
  }


  if(ALSO_PRINT_USAGE==1)
  {
    printf("REM Variable: %s\n",varname);
    printf("REM  Use: %s\n",usage);
    printf("REM  Acceptable values:\n");
	for(i=0;i<EnvSetIntCount;i++)
	{
      if(i==0)
	  {
        printf("REM    ");
	  }

      if(i==EnvSetIntDefault)
	  {
        printf("\"%s\" (default)",EnvValues[i]);
	  }
	  else
	  {
        printf("\"%s\"",EnvValues[i]);
	  }

	  if(i!=(EnvSetIntCount-1))
	  {
        printf(", ");

        if((i+1)%10==0)
		{ 
          printf("\nREM    ");
		}
	  }
	}
    printf("\n");

    printf("SET %s=%s\n",varname,EnvValues[EnvSetIntDefault]);
    printf("REM\n");
  }

  if(getenv(varname)!=NULL)
  {
    sprintf(env_value,"%s",getenv(varname));
  
    for(i=0;i<EnvSetIntCount;i++)
	{
      if(!strcmp(env_value,EnvValues[i]))
	  { 
        

		if(!strcmp(varname,"GAIT_CREATE_PROJECT_SCHEMA"))
		{
		  if(!strcmp(env_value,"TREX"))
		  {
			printf("Setting special TREX\n");
            CREATING_TREX = 1;
		  }
		}

        return EnvSetInt[i];
	  } 
	}

    printf("Error: Found %s environment variable with unexpected value: %s\n",varname,env_value);
    printf("  Valid values for this variable are:\n");
	printf("    ");
	for(i=0;i<EnvSetIntCount;i++)
	{
      if(i==EnvSetIntDefault)
	  {
        printf("\"%s\" (default)",EnvValues[i]);
	  }
	  else
	  {
        printf("\"%s\"",EnvValues[i]);
	  }

	  if(i!=(EnvSetIntCount-1))
	  {
        printf(", ");

        if((i+1)%10==0)
		{ 
          printf("\n    ");
		}
	  }
	}

	if(!strcmp(varname,"TREX_SUB_GEOCELL"))
	{
      printf("\n");
      exit(1);	  
	}
	else
	{
      printf("\n    Setting value to \"%s\"\n",EnvValues[EnvSetIntDefault]);
	}
  }

  return EnvSetInt[EnvSetIntDefault];

}



void SetGridInfo(FILE *envfile, int flag, char *varname, char *usage)
{
  int i;
  char env_value[2000];


  if(flag==1)
  {
    

	if(DrawQuarterDegreeGrid==1)
	{
      fprintf(envfile,"SET %s=%s\n",varname,EnvValues[1]);
	  return;
	}
	if(DrawQuarterDegreeGridL==1)
	{
      fprintf(envfile,"SET %s=%s\n",varname,EnvValues[2]);
	  return;
	}
	if(DrawHalfDegreeGrid==1)
	{
      fprintf(envfile,"SET %s=%s\n",varname,EnvValues[3]);
	  return;
	}
	if(DrawHalfDegreeGridL==1)
	{
      fprintf(envfile,"SET %s=%s\n",varname,EnvValues[4]);
	  return;
	}
	if(DrawOneDegreeGrid==1)
	{
      fprintf(envfile,"SET %s=%s\n",varname,EnvValues[5]);
	  return;
	}
	if(DrawOneDegreeGridL==1)
	{
      fprintf(envfile,"SET %s=%s\n",varname,EnvValues[6]);
	  return;
	}
	if(DrawUserGrid==1)
	{
      fprintf(envfile,"SET %s=%s\n",varname,EnvValues[7]);
	  return;
	}
	if(DrawUserGridL==1)
	{
      fprintf(envfile,"SET %s=%s\n",varname,EnvValues[8]);
	  return;
	}

	
	fprintf(envfile,"SET %s=%s\n",varname,EnvValues[0]);

	return;
  }


  if(ALSO_PRINT_USAGE==1)
  {
    printf("REM Variable: %s\n",varname);
    printf("REM  Use: %s\n",usage);
    printf("REM  Acceptable values:\n");
	for(i=0;i<EnvSetIntCount;i++)
	{
      if(i==0)
	  {
        printf("REM    ");
	  }

      if(i==EnvSetIntDefault)
	  {
        printf("\"%s\" (default)",EnvValues[i]);
	  }
	  else
	  {
        printf("\"%s\"",EnvValues[i]);
	  }

	  if(i!=(EnvSetIntCount-1))
	  {
        printf(", ");

        if((i+1)%10==0)
		{ 
          printf("\nREM    ");
		}
	  }
	}
    printf("\n");

    printf("SET %s=%s\n",varname,EnvValues[EnvSetIntDefault]);
    printf("REM\n");
  }


  if(getenv(varname)!=NULL)
  {  
    sprintf(env_value,"%s",getenv(varname));
  
    for(i=0;i<EnvSetIntCount;i++)
	{
      if(!strcmp(env_value,EnvValues[i]))
	  {

		

        DrawQuarterDegreeGrid  = 0;
        DrawQuarterDegreeGridL = 0;
        DrawHalfDegreeGrid     = 0;
        DrawHalfDegreeGridL    = 0;
        DrawOneDegreeGrid      = 0;
        DrawOneDegreeGridL     = 0;
        DrawUserGrid           = 0;
        DrawUserGridL          = 0;
        DrawLabels             = 0;

		if(i==0)
		{
          
          return; 
		}
		else if(i==1)
		{
          
          DrawQuarterDegreeGrid = 1;
		  return;
		}
		else if(i==2)
		{
          
          DrawQuarterDegreeGridL = 1;
          DrawLabels             = 1;
		  return;
		}
		else if(i==3)
		{
          
          DrawHalfDegreeGrid = 1;
		  return;
		}
		else if(i==4)
		{
          
          DrawHalfDegreeGridL = 1;
          DrawLabels          = 1;
		  return;
		}
		else if(i==5)
		{
          
          DrawOneDegreeGrid = 1;
		  return;
		}
		else if(i==6)
		{
          
          DrawOneDegreeGridL = 1;
          DrawLabels         = 1;
		  return;
		}
		else if(i==7)
		{
          
          DrawUserGrid = 1;
		  return;
		}
		else if(i==8)
		{
          
          DrawUserGridL = 1;
          DrawLabels    = 1;
		  return;
		}
	  } 
	}

    printf("Error: Found %s environment variable with unexpected value: %s\n",varname,env_value);
    printf("  Valid values for this variable are:\n");
	printf("    ");
	for(i=0;i<EnvSetIntCount;i++)
	{
      if(i==EnvSetIntDefault)
	  {
        printf("\"%s\" (default)",EnvValues[i]);
	  }
	  else
	  {
        printf("\"%s\"",EnvValues[i]);
	  }

	  if(i!=(EnvSetIntCount-1))
	  {
        printf(", ");

        if((i+1)%10==0)
		{ 
          printf("\n    ");
		}
	  }
	}

    printf("\n    Setting value to \"%s\"\n",EnvValues[EnvSetIntDefault]);
  }

  DrawQuarterDegreeGrid  = 0;
  DrawQuarterDegreeGridL = 0;
  DrawHalfDegreeGrid     = 0;
  DrawHalfDegreeGridL    = 0;
  DrawOneDegreeGrid      = 0;
  DrawOneDegreeGridL     = 0;
  DrawUserGrid           = 0;
  DrawUserGridL          = 0;

}



void SetModeInfo(FILE *envfile, int flag, char *varname, char *usage)
{
  int i;
  char env_value[2000];


  if(flag==1)
  {
	


	if(ZOOM_MODE==1)
	{
      fprintf(envfile,"SET %s=%s\n",varname,EnvValues[0]);
	  return;
	}
	if(PAN_MODE==1)
	{
      fprintf(envfile,"SET %s=%s\n",varname,EnvValues[1]);
	  return;
	}
	if(INFO_MODE==1)
	{
      fprintf(envfile,"SET %s=%s\n",varname,EnvValues[2]);
	  return;
	}
	if(DIST_MODE==1)
	{
      fprintf(envfile,"SET %s=%s\n",varname,EnvValues[3]);
	  return;
	}
	if(CHECK_MODE==1)
	{
      fprintf(envfile,"SET %s=%s\n",varname,EnvValues[4]);
	  return;
	}
	if((PROFILE_MODE==1)&&(ACTUAL==1))
	{
      fprintf(envfile,"SET %s=%s\n",varname,EnvValues[5]);
	  return;
	}
	if((PROFILE_MODE==1)&&(NON_ACTUAL==1)&&(LOS==1))
	{
      fprintf(envfile,"SET %s=%s\n",varname,EnvValues[7]);
	  return;
	}
	if((PROFILE_MODE==1)&&(NON_ACTUAL==1))
	{
      fprintf(envfile,"SET %s=%s\n",varname,EnvValues[6]);
	  return;
	}
	if(FAN_MODE==1)
	{
      fprintf(envfile,"SET %s=%s\n",varname,EnvValues[8]);
	  return;
	}

	printf("Error in SMI: Unable to save current mode-state (%d %d %d %d)\n",PROFILE_MODE,ACTUAL,NON_ACTUAL,LOS);

	return;
  }



  if(ALSO_PRINT_USAGE==1)
  {
    printf("REM Variable: %s\n",varname);
    printf("REM  Use: %s\n",usage);
    printf("REM  Acceptable values:\n");
	for(i=0;i<EnvSetIntCount;i++)
	{
      if(i==0)
	  {
        printf("REM    ");
	  }

      if(i==EnvSetIntDefault)
	  {
        printf("\"%s\" (default)",EnvValues[i]);
	  }
	  else
	  {
        printf("\"%s\"",EnvValues[i]);
	  }

	  if(i!=(EnvSetIntCount-1))
	  {
        printf(", ");

        if((i+1)%10==0)
		{ 
          printf("\nREM    ");
		}
	  }
	}
    printf("\n");

    printf("SET %s=%s\n",varname,EnvValues[EnvSetIntDefault]);
    printf("REM\n");
  }


  ZOOM_MODE    = 0;
  INFO_MODE    = 0;
  PROFILE_MODE = 0;
  LOS          = 0;
  FAN_MODE     = 0;
  DIST_MODE    = 0;
  CHECK_MODE   = 0;
  PAN_MODE     = 0;


  if(getenv(varname)!=NULL)
  {  
    sprintf(env_value,"%s",getenv(varname));
  
    for(i=0;i<EnvSetIntCount;i++)
	{
      if(!strcmp(env_value,EnvValues[i]))
	  {

		

		if(i==0)
		{
          ZOOM_MODE = 1;
          return; 
		}
		else if(i==1)
		{
          PAN_MODE = 1;
		  return;
		}
		else if(i==2)
		{
          INFO_MODE = 1;
		  return;
		}
		else if(i==3)
		{
          DIST_MODE = 1;
		  return;
		}
		else if(i==4)
		{
          CHECK_MODE = 1;
		  return;
		}
		else if(i==5)
		{
          PROFILE_MODE = 1;
		  NON_ACTUAL   = 0;
		  ACTUAL       = 1;
		  LOS          = 0;
		  return;
		}
		else if(i==6)
		{
          PROFILE_MODE = 1;
		  NON_ACTUAL   = 1;
		  ACTUAL       = 0;
		  LOS          = 0;
		  return;
		}
		else if(i==7)
		{
          PROFILE_MODE = 1;
		  NON_ACTUAL   = 1;
		  ACTUAL       = 0;
		  LOS          = 1;
		  return;
		}
		else if(i==8)
		{
          LOS = 1;
		  return;
		}
	  } 
	}

    printf("Error: Found %s environment variable with unexpected value: %s\n",varname,env_value);
    printf("  Valid values for this variable are:\n");
	printf("    ");
	for(i=0;i<EnvSetIntCount;i++)
	{
      if(i==EnvSetIntDefault)
	  {
        printf("\"%s\" (default)",EnvValues[i]);
	  }
	  else
	  {
        printf("\"%s\"",EnvValues[i]);
	  }

	  if(i!=(EnvSetIntCount-1))
	  {
        printf(", ");

        if((i+1)%10==0)
		{ 
          printf("\n    ");
		}
	  }
	}

    printf("\n    Setting value to \"%s\"\n",EnvValues[EnvSetIntDefault]);
  }


  ZOOM_MODE    = 1;
  INFO_MODE    = 0;
  PROFILE_MODE = 0;
  LOS          = 0;
  FAN_MODE     = 0;
  DIST_MODE    = 0;
  CHECK_MODE   = 0;
  PAN_MODE     = 0;
}




void ProcessEnvVars(FILE *envfile, int flag)
{
  int i;
  extern double NoiseThreshold,MaxDifference,GCPdifLimit;
  extern int SAVE_COMPARE_FILE,COMPARE_VERBOSITY,XML_TRD_TYPE,DP_TRD_TYPE,
	  DRAW_POINT_LABELS,DRAW_LINE_LABELS,DRAW_AREA_LABELS,LABEL_PROXIMITY,
	  LABEL_VOLUME,QAST_LEAVEWINDOWS,QAST_USEPACKAGELOCATION,INTERSECTION_BASED,
	  ADDNETS,COPY_PROJECT_FOLDER,COPY_PROJECT_FOLDER2,QACR_EXPORT_TRD_VERSION,
	  MAX_SHAPE_NUM,OmitGridSentinels,user_trex_cell,TREX_TYPE,NoZ_Values;
  extern unsigned long int CONDITION_LIMIT;
  extern const char *ParticipantNationCodes4[32*3];



  

  sprintf(EnvValues[0],"ON");
  sprintf(EnvValues[1],"OFF");
  EnvSetInt[0] = 1;
  EnvSetInt[1] = 0;
  EnvSetIntCount = 2;
  EnvSetIntDefault = 1;

  
  SHOW_POLY_VERTICES       = SetGAITVarInt(envfile,flag,SHOW_POLY_VERTICES,"GAIT_SHOW_AREA_VERTICES","Used to control the \"Show area vertices\" button on the \"Miscellaneous Parameters\" window");
  SHOW_LINE_VERTICES       = SetGAITVarInt(envfile,flag,SHOW_LINE_VERTICES,"GAIT_SHOW_LINE_VERTICES","Used to control the \"Show line vertices\" button on the \"Miscellaneous Parameters\" window");
  SHOW_END_VERTICES        = SetGAITVarInt(envfile,flag,SHOW_END_VERTICES,"GAIT_SHOW_LINE_END_NODES","Used to control the \"Show line end nodes\" button on the \"Miscellaneous Parameters\" window");
  INCLUDE_PROJECTION       = SetGAITVarInt(envfile,flag,INCLUDE_PROJECTION,"GAIT_INCLUDE_WGS84_SHAPE_PROJECTION","Used to control the \"Include Geographic WGS84 Projection File with Exported Condition Shapefiles\" button on the \"Miscellaneous Parameters\" window");
  DoLargeLabels            = SetGAITVarInt(envfile,flag,DoLargeLabels,"GAIT_LARGE_GRID_LABELS","Used to control the \"Use large text size for grid labels\" button on the \"Miscellaneous Parameters\" window");
  DoBoldLabels             = SetGAITVarInt(envfile,flag,DoLargeLabels,"GAIT_BOLD_GRID_LABELS","Used to control the \"Use bold font for grid labels\" button on the \"Miscellaneous Parameters\" window");
  IUseDMScoordinates       = SetGAITVarInt(envfile,flag,IUseDMScoordinates,"GAIT_SHOW_DMS_COORDINATES","Used to control the \"Show Coordinates in Degrees/Minutes/Seconds\" button on the \"Miscellaneous Parameters\" window");
  GRID                     = SetGAITVarInt(envfile,flag,GRID,"GAIT_SHOW_INSPECTION_GRID","Used to control the \"Show Inspection Grid in Background\" button on the \"Miscellaneous Parameters\" window");
  NUNANPO_TYPE             = SetGAITVarInt(envfile,flag,NUNANPO_TYPE,"GAIT_ALLOW_ADDITIONAL_NUNANPO","Used to control the \"Allow Additional NUNANPO Values\" button on the \"Create GAIT Project...\" window");
  CLIPEXTRACT              = SetGAITVarInt(envfile,flag,CLIPEXTRACT,"GAIT_IMPORT_FROM_RECTANGLE","Used to control the \"Import data from specified rectangle\" button on the \"Create GAIT Project...\" window");
  AppendInputSpec          = SetGAITVarInt(envfile,flag,AppendInputSpec,"GAIT_APPEND_TO_INPUT_SPEC","Used to control the \"Append to Input Specification file if it exists already\" button on the \"Create GAIT Project...\" window");
  DoShort                  = SetGAITVarInt(envfile,flag,DoShort,"GAIT_DO_INSPECTIONS_AFTER_CREATE","Used to control the \"Do inspections after creating project using:\" button on the \"Create GAIT Project...\" window");
  SAVE_COMPARE_FILE        = SetGAITVarInt(envfile,flag,SAVE_COMPARE_FILE,"GAIT_SAVE_COMPARE_RESULTS","Used to control the \"Save Results to Text File\" button on the \"Compare/Summarize Condition Report(s)\" window");
  DetailedInfo             = SetGAITVarInt(envfile,flag,DetailedInfo,"GAIT_GIVE_DETAILED_CONDITION_INFORMATION","Used to control the \"Give detailed information about individual conditions\" button on the \"Conditions Found\" window");
  CenterZoomOnVertices     = SetGAITVarInt(envfile,flag,CenterZoomOnVertices,"GAIT_INFO_ZOOM_TO_VERTICES","Used to control the \"Zoom to individual conditions\" button on the \"Conditions Found\" window");
  INFO_DOMAIN              = SetGAITVarInt(envfile,flag,INFO_DOMAIN,"GAIT_INFO_FUNCTIONAL_CATEGORY","Used to control the \"Functional Category\" button on the \"Parameters (information)\" window");
  INFO_ATTR_LABELS         = SetGAITVarInt(envfile,flag,INFO_ATTR_LABELS,"GAIT_INFO_ATTRIBUTE_LABELS","Used to control the \"Attribute Labels (names)\" button on the \"Parameters (information)\" window");
  INFO_HEX                 = SetGAITVarInt(envfile,flag,INFO_HEX,"GAIT_INFO_HEX","Used to control the \"Show hexadecimal encoding for non-ASCII string values\" button on the \"Parameters (information)\" window");
  COPY_PROJECT_FOLDER      = SetGAITVarInt(envfile,flag,COPY_PROJECT_FOLDER, "GAIT_SET_INPUT_DATA_PATH", "Used to control the \"Also use this path for the Input Data Folder (\"Create GAIT Project\" window)\" button on the \"Select Project Folder\" window");
  COPY_PROJECT_FOLDER2     = SetGAITVarInt(envfile,flag,COPY_PROJECT_FOLDER2,"GAIT_SET_INPUT_DATA_PATH2","Used to control the \"Use the folder containing this folder for the Input Data Folder\" button on the \"Select Project Folder\" window");
  batch_offchecks          = SetGAITVarInt(envfile,flag,batch_offchecks,"GAIT_BATCH_TURN_OFF_INSPECTIONS","Used to control the \"Turn off inspections with invalid/incomplete specifications\" button on the \"Select Project Folder\" window **when using batch mode**");
  NoZ_Values               = SetGAITVarInt(envfile,flag,NoZ_Values,"GAIT_IGNORE_Z_VALUES","Used to control the \"Ignore Feature Z Values\" button on the \"Create GAIT Project...\" window");
  TREX_WRITE_LN_FILE       = SetGAITVarInt(envfile,flag,TREX_WRITE_LN_FILE,"GAIT_TREX_WRITE_LN_FILE","Used to specify whether to export LN shapefiles for TREx projects (the TREx master profile should never generate any line conditions, though)");



  if((COPY_PROJECT_FOLDER==1)&&(COPY_PROJECT_FOLDER2==1))
  {
    printf("\nError processing environment variables:\n");
	printf("Cannot set both GAIT_SET_INPUT_DATA_PATH and GAIT_SET_INPUT_DATA_PATH2 to \"ON\"\n");
    printf("Resetting both values to their default values (\"OFF\")\n\n");
  }


  INFO_COORDS              = SetGAITVarInt(envfile,flag,INFO_COORDS,"GAIT_INFO_COORDINATES","Used to control the \"Coordinates\" button on the \"Parameters (information)\" window");
  DRAW_VERTICES            = SetGAITVarInt(envfile,flag,DRAW_VERTICES,"GAIT_INFO_NUMBER_VERTICES","Used to control the \"Number Vertices\" button on the \"Parameters (information)\" window");
  ErrorLookup[0].DO_EDCS_COMBO[0][0][0] = SetGAITVarInt(envfile,flag,ErrorLookup[0].DO_EDCS_COMBO[0][0][0],"GAIT_VIEW_FEATURE_ATTRIBUTE_COMBINATIONS","Used to control the \"Locate COMBINATIONS of features and attributes\" button on the \"Attribution Highlighting\" window");
  POI_CONNECT              = SetGAITVarInt(envfile,flag,POI_CONNECT,"GAIT_POI_DRAW_LINE","Used to control the \"Draw line between points with the same symbol and color\" button on the \"Points Of Interest\" window");
  ZoomToPOIs               = SetGAITVarInt(envfile,flag,ZoomToPOIs,"GAIT_POI_ZOOM_TO_POINTS","Used to control the \"Zoom to individual points\" button on the \"Points Of Interest\" window");
  ConsultPreviouslyIgnored = SetGAITVarInt(envfile,flag,ConsultPreviouslyIgnored,"GAIT_MARK_RESULTS","Used to control the \"Mark results using exported shapefiles in project:\" button on the \"Inspection Options\" window");
  old_file_browser         = SetGAITVarInt(envfile,flag,old_file_browser,"GAIT_OLD_FILE_BROWSER","Used to specify that the (old) X-Windows style file browser should be used for Windows machines");
  DrawContourLines         = SetGAITVarInt(envfile,flag,DrawContourLines,"GAIT_DRAW_CONTOUR_LINES","Used to control the \"Draw Contour Lines\" button on the \"Contour and Profile Parameters\" window");
  BOLD_CONTOUR             = SetGAITVarInt(envfile,flag,BOLD_CONTOUR,"GAIT_DRAW_5TH_CONTOUR_BOLD","Used to control the \"Draw every 5th contour line bold\" button on the \"Contour and Profile Parameters\" window");
  DrawColorFill            = SetGAITVarInt(envfile,flag,DrawColorFill,"GAIT_DRAW_CONTOURS_COLOR_FILLED","Used to control the \"Draw Contours as Color Fill\" button on the \"Contour and Profile Parameters\" window");
  OVERRIDING_CONTOUR       = SetGAITVarInt(envfile,flag,OVERRIDING_CONTOUR,"GAIT_USE_TRANSPARENT_CONTOURS","Used to control the \"Use transparency when using color filled contours\" button on the \"Contour and Profile Parameters\" window");
  QAST_LEAVEWINDOWS        = SetGAITVarInt(envfile,flag,QAST_LEAVEWINDOWS,"GAIT_LEAVE_PROGRESS_WINDOWS_QAST","Used to control the \"Leave progress windows available during QA\" button on the \"Validate MGCP Data Packaging/Perform QA\" window");
  QAST_USEPACKAGELOCATION  = SetGAITVarInt(envfile,flag,QAST_LEAVEWINDOWS,"GAIT_USE_PACKAGE_LOCATION_QAST","Used to control the \"Use package folder location to create GAIT project for QA\" button on the \"Validate MGCP Data Packaging/Perform QA\" window");
  INTERSECTION_BASED       = SetGAITVarInt(envfile,flag,INTERSECTION_BASED,"GAIT_NETWORK_INTERSECTIONS","Used to control the \"Create Networks Based on Intersections\" button on the \"Network Options\" window");
  ADDNETS                  = SetGAITVarInt(envfile,flag,INTERSECTION_BASED,"GAIT_NETS_AND_INSPECTIONS","Used to control the \"Create Networks When Performing Inspections\" button on the \"Network Options\" window");



  EnvSetIntDefault = 0;

  

  CenterZoomOnErrors   = SetGAITVarInt(envfile,flag,CenterZoomOnErrors,"GAIT_ZOOM_TO_CONDITIONS","Used to control the \"Zoom to individual conditions\" button on the \"Conditions Found\" window");
  INFO_GEOMETRY        = SetGAITVarInt(envfile,flag,INFO_GEOMETRY,"GAIT_INFO_GEOMETRIC_TYPE","Used to control the \"Geometric Type\" button on the \"Parameters (information)\" window");
  INFO_LENGTH          = SetGAITVarInt(envfile,flag,INFO_LENGTH,"GAIT_INFO_LENGTH","Used to control the \"Length (meters)\" button on the \"Parameters (information)\" window");
  INFO_AREA            = SetGAITVarInt(envfile,flag,INFO_AREA,"GAIT_INFO_AREA","Used to control the \"Area (sq. meters)\" button on the \"Parameters (information)\" window");
  INFO_FID             = SetGAITVarInt(envfile,flag,INFO_FID,"GAIT_INFO_FID","Used to control the \"FID\" button on the \"Parameters (information)\" window");
  INFO_GFID            = SetGAITVarInt(envfile,flag,INFO_GFID,"GAIT_INFO_GFID","Used to control the \"GFID/FLDBID/UID\" button on the \"Parameters (information)\" window");
  INFO_ATTR_VALUES     = SetGAITVarInt(envfile,flag,INFO_ATTR_VALUES,"GAIT_INFO_ATTRIBUTE_VALUE_LABELS","Used to control the \"Attribute Value Labels\" button on the \"Parameters (information)\" window");
  INFO_ATTRIBUTES      = SetGAITVarInt(envfile,flag,INFO_ATTRIBUTES,"GAIT_INFO_ATTRIBUTES","Used to control the \"Attributes\" button on the \"Parameters (information)\" window");
  INFO_GRIDVALUES      = SetGAITVarInt(envfile,flag,INFO_GRIDVALUES,"GAIT_INFO_GRIDVALUES","Used to control the \"Show gridded data values\" button on the \"Parameters (information)\" window");
  DrawAnnotations      = SetGAITVarInt(envfile,flag,DrawAnnotations,"GAIT_POI_DRAW_ANNOTATIONS","Used to control the \"Display Annotations\" button on the \"Points Of Interest\" window");
  DOALLCELLS           = SetGAITVarInt(envfile,flag,DOALLCELLS,"GAIT_INSPECT_ALL_REGIONS","Used to control the \"All Regions\" button on the \"Inspection Options\" window");
  NO_FLATTEN_CONTOUR   = SetGAITVarInt(envfile,flag,NO_FLATTEN_CONTOUR,"GAIT_SHADE_CONTOUR_BANDS","Used to control the \"Use shades of color between contour bands\" button on the \"Contour and Profile Parameters\" window");
  DRAW_POINT_LABELS    = SetGAITVarInt(envfile,flag,DRAW_POINT_LABELS,"GAIT_DRAW_POINT_LABELS","Used to control the \"Show point labels\" button on the \"Miscellaneous Parameters\" window");
  DRAW_LINE_LABELS     = SetGAITVarInt(envfile,flag,DRAW_LINE_LABELS,"GAIT_DRAW_LINE_LABELS" ,"Used to control the \"Show line labels\" button on the \"Miscellaneous Parameters\" window");
  DRAW_AREA_LABELS     = SetGAITVarInt(envfile,flag,DRAW_AREA_LABELS,"GAIT_DRAW_AREA_LABELS" ,"Used to control the \"Show area labels\" button on the \"Miscellaneous Parameters\" window");
  OmitGridSentinels    = SetGAITVarInt(envfile,flag,OmitGridSentinels,"GAIT_OMIT_GRID_SENTINELS","Used to control the \"Omit Sentinel values from profiles and contour lines\" button on the \"Contour and Profile Parameters\" window");
  Offchecks            = SetGAITVarInt(envfile,flag,Offchecks,"GAIT_TURN_OFF_INSPECTIONS","Used to control the \"Turn off inspections with invalid/incomplete specifications\" button on the \"Select Project Folder\" window");
  TREX_PROCESS_EDGES   = SetGAITVarInt(envfile,flag,TREX_PROCESS_EDGES,"GAIT_TREX_PROCESS_EDGES","Used to indicate whether GAIT should process edge matching for TREx projects");
  do_trex_checklist    = SetGAITVarInt(envfile,flag,do_trex_checklist,"GAIT_TREX_CREATE_CHECKLIST","Used to indicate whether GAIT should create TREx checklists for TREx projects");

  sprintf(EnvValues[0],"Not Specified");
  EnvSetInt[0] = -1;
  sprintf(EnvValues[1],"1");
  EnvSetInt[1] = 0;
  sprintf(EnvValues[2],"2");
  EnvSetInt[2] = 1;
  sprintf(EnvValues[3],"3");
  EnvSetInt[3] = 2;
  sprintf(EnvValues[4],"4");
  EnvSetInt[4] = 3;
  EnvSetIntCount   = 5;
  EnvSetIntDefault = 0;

  user_trex_cell = SetGAITVarInt(envfile,flag,user_trex_cell,"TREX_SUB_GEOCELL" ,"Used to indicate which TREx sub-GeoCell to process for packages with multiple GeoCells (1: westernmost cell, 2: next cell to the east, etc)");

  sprintf(EnvValues[0],"Not Specified");
  EnvSetInt[0] = 0;
  sprintf(EnvValues[1],"QC");
  EnvSetInt[1] = 1;
  sprintf(EnvValues[2],"cQA");
  EnvSetInt[2] = 2;
  sprintf(EnvValues[3],"sQA");
  EnvSetInt[3] = 3;
  EnvSetIntCount   = 4;
  EnvSetIntDefault = 0;

  TREX_TYPE = SetGAITVarInt(envfile,flag,TREX_TYPE,"GAIT_TREX_ANALYSIS_TYPE","Used to control the \"TREx analysis type\" button on the \"Create GAIT Project...\" window");


  sprintf(EnvValues[0],"Close Together");
  EnvSetInt[0] = 1;
  sprintf(EnvValues[1],"Medium");
  EnvSetInt[1] = 2;
  sprintf(EnvValues[2],"Far Apart");
  EnvSetInt[2] = 4;
  EnvSetIntCount   = 3;
  EnvSetIntDefault = 1;

  LABEL_PROXIMITY = SetGAITVarInt(envfile,flag,LABEL_PROXIMITY,"GAIT_LABEL_PROXIMITY" ,"Used to control the \"Label proximity on single features:\" button on the \"Miscellaneous Parameters\" window");


  sprintf(EnvValues[0],"Low");
  EnvSetInt[0] = 1;
  sprintf(EnvValues[1],"Medium");
  EnvSetInt[1] = 2;
  sprintf(EnvValues[2],"High");
  EnvSetInt[2] = 4;
  EnvSetIntCount   = 3;
  EnvSetIntDefault = 0;

  LABEL_VOLUME    = SetGAITVarInt(envfile,flag,LABEL_VOLUME,"GAIT_LABEL_VOLUME"    ,"Used to control the \"Total label volume:\" button on the \"Miscellaneous Parameters\" window");







  for(i=0;i<=93;i=i+3)
  {
    sprintf(EnvValues[i/3],"%s",ParticipantNationCodes4[i]);
    EnvSetInt[i/3] = i;
  }

  sprintf(EnvValues[32],"None");
  EnvSetInt[32] = 999;

  EnvSetIntCount   = 33;
  EnvSetIntDefault = 32;

  QACR_COUNTRY    = SetGAITVarInt(envfile,flag,QACR_COUNTRY,"GAIT_QACR_COUNTRY"    ,"Used to control the \"Participant Country for MGCP QACR:\" button on the \"Miscellaneous Parameters\" window");



  sprintf(EnvValues[0],"None");
  EnvSetInt[0] = 999;
  sprintf(EnvValues[1],"3.0");
  EnvSetInt[1] = 30;
  sprintf(EnvValues[2],"4.0");
  EnvSetInt[2] = 40;
  sprintf(EnvValues[3],"4.1");
  EnvSetInt[3] = 41;
  sprintf(EnvValues[4],"4.2");
  EnvSetInt[4] = 42;
  sprintf(EnvValues[5],"4.3");
  EnvSetInt[5] = 43;
  sprintf(EnvValues[6],"4.4");
  EnvSetInt[6] = 44;
  EnvSetIntCount   = 7;
  EnvSetIntDefault = 0;

  QACR_EXPORT_TRD_VERSION    = SetGAITVarInt(envfile,flag,QACR_EXPORT_TRD_VERSION,"GAIT_MGCP_QACR_TRD"    ,"Used to control the \"TRD Version for MGCP QACR:\" button on the \"Miscellaneous Parameters\" window");





  sprintf(EnvValues[0],"NONE");
  EnvSetInt[0] = 0;
  sprintf(EnvValues[1],"GIFD");
  EnvSetInt[1] = 1;
  sprintf(EnvValues[2],"FACC");
  EnvSetInt[2] = 3;
  sprintf(EnvValues[3],"VMAP");
  EnvSetInt[3] = 5;
  sprintf(EnvValues[4],"MGCP3");
  EnvSetInt[4] = 7;
  sprintf(EnvValues[5],"MGCP4");
  EnvSetInt[5] = 8;
  sprintf(EnvValues[6],"UFD1");
  EnvSetInt[6] = 11;
  sprintf(EnvValues[7],"UFD2");
  EnvSetInt[7] = 9;
  sprintf(EnvValues[8],"UFD3");
  EnvSetInt[8] = 13;


  


  sprintf(EnvValues[9],"NFDD");
  EnvSetInt[9] = 23;
  sprintf(EnvValues[10],"DFDD");
  EnvSetInt[10] = 25;	
  sprintf(EnvValues[11],"AFD"); 
  EnvSetInt[11] = 27;
  sprintf(EnvValues[12],"GGDM22");
  EnvSetInt[12] = 29;

  sprintf(EnvValues[13],"TDS4");
  EnvSetInt[13] = 39;

  sprintf(EnvValues[14],"TDS6");
  EnvSetInt[14] = 43;

  sprintf(EnvValues[15],"GGDM21");
  EnvSetInt[15] = 45;

  sprintf(EnvValues[16],"GGDM3");
  EnvSetInt[16] = 47;

  sprintf(EnvValues[17],"TREX");
  EnvSetInt[17] = 26;


  EnvSetIntCount   = 18;
  EnvSetIntDefault = 0;

  TEMP_ATTRIBUTION_TYPE       = SetGAITVarInt(envfile,flag,TEMP_ATTRIBUTION_TYPE,"GAIT_CREATE_PROJECT_SCHEMA","Used to specify the \"Attribution Schema:\" value on the \"Create GAIT Project...\" window");


  if( (PossibleForNUNANPO(TEMP_ATTRIBUTION_TYPE)==0) && (NUNANPO_TYPE==1) )
  {
    for(i=0;i<EnvSetIntCount;i++)
	{
      if(TEMP_ATTRIBUTION_TYPE==EnvSetInt[i])
	  {
        printf("**Error:  Cannot set GAIT_ALLOW_ADDITIONAL_NUNANPO to 1 with GAIT_CREATE_PROJECT_SCHEMA = %s\n",EnvValues[i]);
		printf("...Setting GAIT_ALLOW_ADDITIONAL_NUNANPO to \"OFF\"\n");
	  }
	}
    NUNANPO_TYPE = 0;
  }


  sprintf(EnvValues[0], "BLACK");
  sprintf(EnvValues[1], "RED");
  sprintf(EnvValues[2], "GREEN");
  sprintf(EnvValues[3], "DARKGREEN");
  sprintf(EnvValues[4], "BLUE");
  sprintf(EnvValues[5], "YELLOW");
  sprintf(EnvValues[6], "PURPLE");
  sprintf(EnvValues[7], "CYAN");
  sprintf(EnvValues[8], "BROWN");
  sprintf(EnvValues[9], "WHITE");
  EnvSetInt[0] =  51;
  EnvSetInt[1] =   1;
  EnvSetInt[2] =  27;
  EnvSetInt[3] =  50;
  EnvSetInt[4] =  55;
  EnvSetInt[5] =  28;
  EnvSetInt[6] =  40;
  EnvSetInt[7] =  30;
  EnvSetInt[8] =  53;
  EnvSetInt[9] = 255;
  EnvSetIntCount   = 10;
  EnvSetIntDefault = 0;

  GRID_COLOR         = SetGAITVarInt(envfile,flag,GRID_COLOR,"GAIT_GRID_LINE_COLOR","Used to specify the \"Grid line color:\" value on the \"Miscellaneous Parameters\" window" );
  GRID_LABEL_COLOR   = SetGAITVarInt(envfile,flag,GRID_LABEL_COLOR,"GAIT_GRID_LABEL_COLOR","Used to specify the \"Grid label color:\" value on the \"Miscellaneous Parameters\" window" );

  EnvSetInt[1]       = -1;
  EnvSetIntDefault   = 1;
  SPECIAL_COND_COLOR = SetGAITVarInt(envfile,flag,SPECIAL_COND_COLOR,"GAIT_HIGHLIGHT_COLOR","Used to specify the \"Highlighting Color:\" value on the \"Miscellaneous Parameters\" window" );

  



  sprintf(EnvValues[0], "1");
  sprintf(EnvValues[1], "2");
  sprintf(EnvValues[2], "3");
  sprintf(EnvValues[3], "4");
  sprintf(EnvValues[4], "5");
  EnvSetInt[0] =  1;
  EnvSetInt[1] =  2;
  EnvSetInt[2] =  3;
  EnvSetInt[3] =  4;
  EnvSetInt[4] =  5;
  EnvSetIntCount   = 5;
  EnvSetIntDefault = 0;

  GRID_THICKNESS   = SetGAITVarInt(envfile,flag,GRID_THICKNESS,"GAIT_GRID_LINE_THICKNESS","Used to specify the \"Grid line thickness:\" value on the \"Miscellaneous Parameters\" window" );




  sprintf(EnvValues[0], "NONE");
  sprintf(EnvValues[1], "QUARTER_DEGREE_NO_LABELS");
  sprintf(EnvValues[2], "QUARTER_DEGREE_WITH_LABELS");
  sprintf(EnvValues[3], "HALF_DEGREE_NO_LABELS");
  sprintf(EnvValues[4], "HALF_DEGREE_WITH_LABELS");
  sprintf(EnvValues[5], "ONE_DEGREE_NO_LABELS");
  sprintf(EnvValues[6], "ONE_DEGREE_WITH_LABELS");
  sprintf(EnvValues[7], "USER_DEFINED_NO_LABELS");
  sprintf(EnvValues[8], "USER_DEFINED_WITH_LABELS");
  EnvSetIntCount   = 9;
  EnvSetIntDefault = 0;

 
  SetGridInfo(envfile,flag,"GAIT_COORDINATE_GRID","Used to specify the \"Coordinate Grid\" setting on the \"View->Coordinate Grid\" menu");




  sprintf(EnvValues[0], "ZOOM");
  sprintf(EnvValues[1], "PAN");
  sprintf(EnvValues[2], "INFORMATION");
  sprintf(EnvValues[3], "DISTANCE");
  sprintf(EnvValues[4], "LOCALIZED_INSPECTION");
  sprintf(EnvValues[5], "ACTUAL_PROFILE");
  sprintf(EnvValues[6], "ZOOM_PROFILE");
  sprintf(EnvValues[7], "LOS_PROFILE");
  sprintf(EnvValues[8], "LOS_FAN");
  EnvSetIntCount   = 9;
  EnvSetIntDefault = 0;

  SetModeInfo(envfile,flag,"GAIT_MODE","Used to specify the \"Mode\" setting on the \"Mode\" menu");



  sprintf(EnvValues[0], "1");
  sprintf(EnvValues[1], "2");
  sprintf(EnvValues[2], "3");
  sprintf(EnvValues[3], "4.0");
  sprintf(EnvValues[4], "4.1");
  sprintf(EnvValues[5], "4.2");
  sprintf(EnvValues[6], "4.3");
  sprintf(EnvValues[7], "4.4");
  EnvSetInt[0] =  1;
  EnvSetInt[1] =  2;
  EnvSetInt[2] =  3;
  EnvSetInt[3] =  4;
  EnvSetInt[4] =  41;
  EnvSetInt[5] =  42;
  EnvSetInt[6] =  43;
  EnvSetInt[7] =  44;
  EnvSetIntCount   = 8;
  EnvSetIntDefault = 2;

  XML_TRD_TYPE       = SetGAITVarInt(envfile,flag,XML_TRD_TYPE,"GAIT_XML_TRD_VERSION","Used to specify the \"Validate Against:\" value on the \"Validate MGCP Cell XML\" window" );

  sprintf(EnvValues[0], "3");
  sprintf(EnvValues[1], "4.0");
  sprintf(EnvValues[2], "4.1");
  sprintf(EnvValues[3], "4.2");
  sprintf(EnvValues[4], "4.3");
  sprintf(EnvValues[5], "4.4");
  EnvSetInt[0]     = 3;
  EnvSetInt[1]     = 4;
  EnvSetInt[2]     = 41;
  EnvSetInt[3]     = 42;
  EnvSetInt[4]     = 43;
  EnvSetInt[5]     = 44;
  EnvSetIntCount   = 6;
  EnvSetIntDefault = 0;

  DP_TRD_TYPE       = SetGAITVarInt(envfile,flag,DP_TRD_TYPE,"GAIT_DP_TRD_VERSION","Used to specify the \"Validate Against:\" value on the \"Validate MGCP Data Packaging\" window" );


  sprintf(EnvValues[0], "LOW");
  sprintf(EnvValues[1], "MEDIUM");
  sprintf(EnvValues[2], "HIGH");
  sprintf(EnvValues[3], "COMPLETE");
  EnvSetInt[0] =  1;
  EnvSetInt[1] =  2;
  EnvSetInt[2] =  3;
  EnvSetInt[3] =  4;
  EnvSetIntCount   = 4;
  EnvSetIntDefault = 0;

  COMPARE_VERBOSITY = SetGAITVarInt(envfile,flag,COMPARE_VERBOSITY,"GAIT_COMPARE_DESCRIPTION_DETAIL","Used to specify the \"Description Detail:\" value on the \"Compare/Summarize Condition Report(s)\" window" );
  

  sprintf(EnvValues[0], "ALL_DECIMALS");
  sprintf(EnvValues[1], "ONE_DECIMAL");
  sprintf(EnvValues[2], "NO_DECIMALS");
  EnvSetInt[0] =  0;
  EnvSetInt[1] =  1;
  EnvSetInt[2] =  2;
  EnvSetIntCount   = 3;
  EnvSetIntDefault = 1;

  TruncImport = SetGAITVarInt(envfile,flag,TruncImport,"GAIT_IMPORT_DIGITS","Used to specify how many how many digits beyond the decimal point to import for some attribute values" );


  sprintf(EnvValues[0], "NONE");
  sprintf(EnvValues[1], "NAS");
  sprintf(EnvValues[2], "USER");
  sprintf(EnvValues[3], "USERWITHVV");
  EnvSetInt[0] =  1;
  EnvSetInt[1] =  2;
  EnvSetInt[2] =  3;
  EnvSetInt[3] =  4;
  EnvSetIntCount   = 4;
  EnvSetIntDefault = 0;

  ATTRINSTYPE   = SetGAITVarInt(envfile,flag,ATTRINSTYPE,"GAIT_ADDITIONAL_ATTRIBUTION_TYPE","Used to specify the \"Additional Attribution Inspections for NFDD/DFDD:\" value on the \"Create GAIT Project...\" window" );



  sprintf(EnvValues[0], "MGCPNGA");
  sprintf(EnvValues[1], "ESRI");
  sprintf(EnvValues[2], "INGR");
  sprintf(EnvValues[3], "USER");
  EnvSetInt[0] =  1;
  EnvSetInt[1] =  2;
  EnvSetInt[2] =  3;
  EnvSetInt[3] =  5;
  EnvSetIntCount   = 4;
  EnvSetIntDefault = 0;

  METATYPE   = SetGAITVarInt(envfile,flag,METATYPE,"GAIT_METADATA_NAMING_CONVENTION","Used to specify the \"Metadata naming convention:\" value on the \"Create GAIT Project...\" window" );

 
  sprintf(EnvValues[0], "DFEG");
  sprintf(EnvValues[1], "MGCP");
  sprintf(EnvValues[2], "UFD1");
  sprintf(EnvValues[3], "UFD3");
  sprintf(EnvValues[4], "TDS");
  sprintf(EnvValues[5], "AFD"); 
  sprintf(EnvValues[6], "TREX");


  EnvSetInt[0] =  1;
  EnvSetInt[1] =  3;
  EnvSetInt[2] =  4;
  EnvSetInt[3] =  5;
  EnvSetInt[4] =  11;
  EnvSetInt[5] =  10;
  EnvSetInt[6] =  12;

  EnvSetIntCount   = 7;
  EnvSetIntDefault = 0;

  MASTERTYPE   = SetGAITVarInt(envfile,flag,MASTERTYPE,"GAIT_MASTER_AFTER_CREATE","Used to specify the \"Do inspections after creating project using:\" value on the \"Create GAIT Project...\" window" );





  sprintf(EnvValues[0], "INHERENT");
  sprintf(EnvValues[1], "BLACK");
  sprintf(EnvValues[2], "RED");
  sprintf(EnvValues[3], "GREEN");
  sprintf(EnvValues[4], "DARKGREEN");
  sprintf(EnvValues[5], "BLUE");
  sprintf(EnvValues[6], "YELLOW");
  sprintf(EnvValues[7], "PURPLE");
  sprintf(EnvValues[8], "CYAN");
  sprintf(EnvValues[9], "BROWN");
  sprintf(EnvValues[10],"WHITE");
  EnvSetInt[0]  = 999;
  EnvSetInt[1]  = 51;
  EnvSetInt[2]  = 1;
  EnvSetInt[3]  = 27;
  EnvSetInt[4]  = 50;
  EnvSetInt[5]  = 55;
  EnvSetInt[6]  = 28;
  EnvSetInt[7]  = 40;
  EnvSetInt[8]  = 30;
  EnvSetInt[9]  = 53;
  EnvSetInt[10] = 255;
  EnvSetIntCount   = 11;
  EnvSetIntDefault = 0;

  POLY_COLOR     = SetGAITVarInt(envfile,flag,POLY_COLOR,"GAIT_AREA_VERTEX_COLOR","Used to specify the \"Area vertex color:\" value on the \"Miscellaneous Parameters\" window" );
  LINE_COLOR     = SetGAITVarInt(envfile,flag,LINE_COLOR,"GAIT_LINE_VERTEX_COLOR","Used to specify the \"Line vertex color:\" value on the \"Miscellaneous Parameters\" window" );
  END_LINE_COLOR = SetGAITVarInt(envfile,flag,END_LINE_COLOR,"GAIT_LINE_END_NODE_COLOR","Used to specify the \"Line end node color:\" value on the \"Miscellaneous Parameters\" window" );



  sprintf(EnvValues[0], "TRIANGLE");
  sprintf(EnvValues[1], "STAR");
  sprintf(EnvValues[2], "XMARK");
  sprintf(EnvValues[3], "CIRCLE");
  EnvSetInt[0]  = 0;
  EnvSetInt[1]  = 1;
  EnvSetInt[2]  = 2;
  EnvSetInt[3]  = 3;
  EnvSetIntCount   = 4;
  EnvSetIntDefault = 0;

  POLY_SHAPE     = SetGAITVarInt(envfile,flag,POLY_SHAPE,"GAIT_AREA_VERTEX_MARKER","Used to specify the \"Area vertex marker:\" value on the \"Miscellaneous Parameters\" window" );
  END_LINE_SHAPE = SetGAITVarInt(envfile,flag,END_LINE_SHAPE,"GAIT_LINE_END_NODE_MARKER","Used to specify the \"Line end node marker:\" value on the \"Miscellaneous Parameters\" window" );
  MARK_SHAPE     = SetGAITVarInt(envfile,flag,MARK_SHAPE,"GAIT_POI_SYMBOL_TYPE","Used to specify the POI symbol type value on the \"Points Of Interest\" window" );

  sprintf(EnvValues[4], "ARROW");
  EnvSetInt[4]   = 4;
  EnvSetIntCount = 5;
  LINE_SHAPE     = SetGAITVarInt(envfile,flag,LINE_SHAPE,"GAIT_LINE_VERTEX_MARKER","Used to specify the \"Line vertex marker:\" value on the \"Miscellaneous Parameters\" window" );

  sprintf(EnvValues[0], "RED");
  sprintf(EnvValues[1], "GREEN");
  sprintf(EnvValues[2], "BLUE");
  sprintf(EnvValues[3], "YELLOW");
  EnvSetInt[0] =   1;
  EnvSetInt[1] =  50;
  EnvSetInt[2] =  55;
  EnvSetInt[3] =  28;
  EnvSetIntCount   = 4;
  EnvSetIntDefault = 0;

  MARK_COLOR     = SetGAITVarInt(envfile,flag,MARK_COLOR,"GAIT_POI_COLOR","Used to specify the POI color value on the \"Points Of Interest\" window" );





  sprintf(EnvValues[0], "GREY_SHADED");
  sprintf(EnvValues[1], "RED_SHADED");
  sprintf(EnvValues[2], "GREEN_SHADED");
  sprintf(EnvValues[3], "BLUE_SHADED");
  EnvSetInt[0] =  1;
  EnvSetInt[1] =  2;
  EnvSetInt[2] =  3;
  EnvSetInt[3] =  4;
  EnvSetIntCount   = 4;
  EnvSetIntDefault = 0;

  USE_GREY = SetGAITVarInt(envfile,flag,USE_GREY,"GAIT_DEM_SHADED_RELIEF_COLOR","Used to specify the \"Shaded relief color\" value on the \"Shading Parameters\" window" );


  sprintf(EnvValues[0], "HIGH");
  sprintf(EnvValues[1], "MEDIUM");
  sprintf(EnvValues[2], "LOW");
  sprintf(EnvValues[3], "VERY LOW");
  EnvSetInt[0] =  1;
  EnvSetInt[1] =  2;
  EnvSetInt[2] =  3;
  EnvSetInt[3] =  10;
  EnvSetIntCount   = 4;
  EnvSetIntDefault = 0;


  sprintf(EnvValues[0], "RED");
  sprintf(EnvValues[1], "GREEN");
  sprintf(EnvValues[2], "BLUE");
  sprintf(EnvValues[3], "BLACK");
  sprintf(EnvValues[4], "WHITE");
  sprintf(EnvValues[5], "PURPLE");
  sprintf(EnvValues[6], "TAN");
  sprintf(EnvValues[7], "GREY");
  sprintf(EnvValues[8], "BROWN");
  sprintf(EnvValues[9], "YELLOW");
  EnvSetInt[0] =  2;
  EnvSetInt[1] =  27;
  EnvSetInt[2] =  55;
  EnvSetInt[3] =  51;
  EnvSetInt[4] =  255;
  EnvSetInt[5] =  40;
  EnvSetInt[6] =  54;
  EnvSetInt[7] =  128;
  EnvSetInt[8] =  53;
  EnvSetInt[9] =  28;
  EnvSetIntCount   = 10;
  EnvSetIntDefault = 3;

  TheContourColor = SetGAITVarInt(envfile,flag,TheContourColor,"GAIT_CONTOUR_LINE_COLOR","Used to specify the \"Contour Line Color\" value on the \"Contour and Profile Parameters\" window");


  

  ContourInterval = SetGAITVarDouble     (envfile,flag,ContourInterval, "GAIT_CONTOUR_INTERVAL","Used to specify the \"Contour Interval\" value on the \"Contour and Profile Parameters\" window");
  ZoomSunAzimuth  = (int)SetGAITVarDouble(envfile,flag,ZoomSunAzimuth,  "GAIT_SUN_AZIMUTH","Used to specify the \"Sun Azimuth\" value on the \"Shading Parameters\" window");
  ZoomSunAngle    = (int)SetGAITVarDouble(envfile,flag,ZoomSunAngle,    "GAIT_SUN_ANGLE","Used to specify the \"Sun Angle\" value on the \"Shading Parameters\" window");
  ZoomVertExag    = SetGAITVarDouble     (envfile,flag,ZoomVertExag,    "GAIT_VERTICAL_EXAGGERATION","Used to specify the \"Vertical Exaggeration\" value on the \"Shading Parameters\" window");
  OBS_HEIGHT      = SetGAITVarDouble     (envfile,flag,OBS_HEIGHT,      "GAIT_LOS_OBSERVER_HEIGHT","Used to specify the \"Observer Height\" value on the \"LOS Parameters\" window");
  TGT_HEIGHT      = SetGAITVarDouble     (envfile,flag,TGT_HEIGHT,      "GAIT_LOS_TARGET_HEIGHT","Used to specify the \"Target Height\" value on the \"LOS Parameters\" window");

  if(DO_FAN()==1)
  {
    FAN_ANGLE       = SetGAITVarDouble     (envfile,flag,FAN_ANGLE,       "GAIT_LOS_FAN_ANGLE","Used to specify the \"LOS Fan Angle\" value on the \"LOS Parameters\" window");
    FAN_QUALITY     = (int)SetGAITVarDouble(envfile,flag,FAN_QUALITY,     "GAIT_LOS_FAN_GRANULARITY","Used to specify the \"LOS Fan Granularity\" value on the \"LOS Parameters\" window");
  }

  NoiseThreshold = 1.0;
  NoiseThreshold = SetGAITVarDouble (envfile,flag,NoiseThreshold, "GAIT_TREX_CP_STDV_LIMIT",  "Used to specify maximum standard deviation for TREx control point LE90 calculations");
  MaxDifference  = 20.0;
  MaxDifference  = SetGAITVarDouble (envfile,flag,MaxDifference,  "GAIT_TREX_CP_AVG_LIMIT",   "Used to specify maximum elevation differences for TREx control point LE90 calculations");
  GCPdifLimit    = 20.0;
  GCPdifLimit    = SetGAITVarDouble (envfile,flag,GCPdifLimit,    "GAIT_TREX_GCP_DIFF_LIMIT", "Used for TREx GCP comparative statistic calculations");

  if((NoiseThreshold<0)||(NoiseThreshold>200.0))
  {
    printf("**Illegal value %lf used for environment variable GAIT_TREX_CP_STDV_LIMIT (valid values 0 to 200)\n",NoiseThreshold);
	printf("...using 1 instead\n");
	NoiseThreshold = 1.0;
  }

  if((MaxDifference<0)||(MaxDifference>500.0))
  {
    printf("**Illegal value %lf used for environment variable GAIT_TREX_CP_AVG_LIMIT (valid values 0 to 500)\n",MaxDifference);
	printf("...using 20 instead\n");
	MaxDifference = 20.0;
  }

  if((GCPdifLimit<0)||(GCPdifLimit>500.0))
  {
    printf("**Illegal value %lf used for environment variable GAIT_TREX_GCP_DIFF_LIMIT (valid values 0 to 500)\n",GCPdifLimit);
	printf("...using 20 instead\n");
	GCPdifLimit = 20.0;
  }

  if((ContourInterval<0)||(ContourInterval>2000))
  {
    printf("**Illegal value %lf used for environment variable GAIT_CONTOUR_INTERVAL (valid values >0 to 2000)\n",ContourInterval);
	printf("...using 10 instead\n");
	ContourInterval = 10.0;
  }

  if((ZoomSunAzimuth<0)||(ZoomSunAzimuth>359))
  {
    printf("**Illegal value %d used for environment variable GAIT_SUN_AZIMUTH (valid values 0-359)\n",ZoomSunAzimuth);
	printf("...using 315 instead\n");
	ZoomSunAzimuth = 315;
  }

  if((ZoomSunAngle<15)||(ZoomSunAngle>75))
  {
    printf("**Illegal value %d used for environment variable GAIT_SUN_ANGLE (valid values 15-75)\n",ZoomSunAngle);
	printf("...using 45 instead\n");
	ZoomSunAngle = 45;
  }

  if((ZoomVertExag<.1)||(ZoomVertExag>1000))
  {
    printf("**Illegal value %lf used for environment variable GAIT_VERTICAL_EXAGGERATION (valid values 0.1-1000)\n",ZoomVertExag);
	printf("...using 1.0 instead\n");
	ZoomVertExag = 1.0;
  }

  if((OBS_HEIGHT<0)||(OBS_HEIGHT>=2000))
  {
    printf("**Illegal value %lf used for environment variable GAIT_LOS_OBSERVER_HEIGHT (valid values 0.1-1000)\n",OBS_HEIGHT);
	printf("...using 1.7 instead\n");
	OBS_HEIGHT = 1.7;
  }
  if((TGT_HEIGHT<0)||(TGT_HEIGHT>=2000))
  {
    printf("**Illegal value %lf used for environment variable GAIT_LOS_TARGET_HEIGHT (valid values 0.1-1000)\n",TGT_HEIGHT);
	printf("...using 1.7 instead\n");
	TGT_HEIGHT = 1.7;
  }

  if(DO_FAN()==1)
  {
    if((FAN_ANGLE<.1)||(FAN_ANGLE>360))
	{ 
      printf("**Illegal value %lf used for environment variable GAIT_LOS_FAN_ANGLE (valid values 1-360)\n",FAN_ANGLE);
	  printf("...using 45 instead\n");
	  FAN_ANGLE = 45.0;
	} 
    if((FAN_QUALITY<1)||(FAN_QUALITY>10))
	{ 
      printf("**Illegal value %d used for environment variable GAIT_LOS_FAN_GRANULARITY (valid values 1-10)\n",FAN_QUALITY);
	  printf("...using 5 instead\n");
	  FAN_QUALITY = 5;
	} 
  }




  GridX     = SetGAITVarDouble(envfile,flag,GridX,    "GAIT_USER_GRID_X_ANCHOR","Used to specify the \"User-Defined Coordinate Grid X Anchor Point\" value on the \"Miscellaneous Parameters\" window");
  if((GridX<-180)||(GridX>180))
  {
    printf("**Illegal value %lf used for environment variable GAIT_USER_GRID_X_ANCHOR\n",GridX);
	printf("...using 0 instead\n");
	GridX = 0;
  }


  GridY     = SetGAITVarDouble(envfile,flag,GridY,    "GAIT_USER_GRID_Y_ANCHOR","Used to specify the \"User-Defined Coordinate Grid Y Anchor Point\" value on the \"Miscellaneous Parameters\" window");
  if((GridY<-90)||(GridY>90))
  {
    printf("**Illegal value %lf used for environment variable GAIT_USER_GRID_Y_ANCHOR\n",GridY);
	printf("...using 0 instead\n");
	GridY = 0;
  }


  GridSpace = SetGAITVarDouble(envfile,flag,GridSpace,"GAIT_USER_GRID_SPACING","Used to specify the \"User-Defined Coordinate Grid Spacing\" value on the \"Miscellaneous Parameters\" window");
  if((GridSpace<.00001)||(GridSpace>10))
  {
    printf("**Illegal value %lf used for environment variable GAIT_USER_GRID_SPACING\n",GridSpace);
	printf("..this value must be between .00001 and 10 (inclusive)\n");
	printf("...using 1.0 instead\n");
	GridSpace = 1.0;
  }

  sprintf(shape_out_name,"%s",SetGAITVarString(envfile,flag,shape_out_name,"consolidated","GAIT_EXPORT_CONDITION_SHAPEFILE_NAME","Used to specify the \"Export Shapefile Root Name\" value on the \"Miscellaneous Parameters\" window"));


  sprintf(GAITProjectName,"%s",SetGAITVarString(envfile,flag,GAITProjectName,"","GAIT_PROJECT_NAME","Used to specify the \"Project Name:\" value on the \"Create GAIT Project...\" window"));

  sprintf(shapeimportoutputdir,"%s",SetGAITVarString(envfile,flag,shapeimportoutputdir,"","GAIT_INPUT_DATA_FOLDER","Used to specify the \"Input Data Folder:\" value on the \"Create GAIT Project...\" window"));

  if(shapeimportoutputdir[0]!='\0')
  {
    shape_source = 1;
  }



  sprintf(SpecialLoc,"%s",SetGAITVarString(envfile,flag,SpecialLoc,"<not specified>","GAIT_BROWSE_FOLDER_NAME","Used to specify the \"GAIT browse folder:\" value on the \"Select Browse Folder\" window"));


  


  attrinsfolder[0] ='\0';
  sprintf(attrinsfolder,"%s",SetGAITVarString(envfile,flag,attrinsfolder,"","GAIT_FOLDER_WITH_ATTRIBUTION_FILES","Used to specify the \"Folder with attribution files:\" value on the \"Create GAIT Project...\" window\nREM  Use NULL except when using NFDD/DFDD projects with \"Additional Attribution Inspections for NFDD/DFDD:\" set to \"USER\""));

  if(attrinsfolder[0]!='\0')
  {
    attrins_source = 1;
  }



  CLIPLLX     = SetGAITVarDouble(envfile,flag,CLIPLLX,    "GAIT_IMPORT_RECTANGLE_LLX","Used to specify the \"Lower left x-coordinate of rectangle to import\" value on the \"Import Rectangle Specification\" window");
  if((CLIPLLX<-180)||(CLIPLLX>180))
  {
    printf("**Illegal value %lf used for environment variable GAIT_IMPORT_RECTANGLE_LLX\n",CLIPLLX);
	printf("...using -180 instead\n");
	CLIPLLX = -180;
  }

  CLIPLLY     = SetGAITVarDouble(envfile,flag,CLIPLLY,    "GAIT_IMPORT_RECTANGLE_LLY","Used to specify the \"Lower left y-coordinate of rectangle to import\" value on the \"Import Rectangle Specification\" window");
  if((CLIPLLY<-90)||(CLIPLLY>90))
  {
    printf("**Illegal value %lf used for environment variable GAIT_IMPORT_RECTANGLE_LLY\n",CLIPLLY);
	printf("...using -90 instead\n");
	CLIPLLY = -90;
  }

  CLIPURX     = SetGAITVarDouble(envfile,flag,CLIPURX,    "GAIT_IMPORT_RECTANGLE_URX","Used to specify the \"Upper right x-coordinate of rectangle to import\" value on the \"Import Rectangle Specification\" window");
  if((CLIPURX<-180)||(CLIPURX>180))
  {
    printf("**Illegal value %lf used for environment variable GAIT_IMPORT_RECTANGLE_URX\n",CLIPURX);
	printf("...using 180 instead\n");
	CLIPURX = 180;
  }
  if(CLIPURX<CLIPLLX)
  {
    printf("**Illegal value %lf used for environment variable GAIT_IMPORT_RECTANGLE_URX\n",CLIPURX);
	printf("..this value must be greater than or equal to GAIT_IMPORT_RECTANGLE_LLX (%lf)\n",CLIPLLX);
	printf("...using 180 instead\n");
	CLIPURX = 180;
  }

  CLIPURY     = SetGAITVarDouble(envfile,flag,CLIPURY,    "GAIT_IMPORT_RECTANGLE_URY","Used to specify the \"Upper right y-coordinate of rectangle to import\" value on the \"Import Rectangle Specification\" window");
  if((CLIPURY<-90)||(CLIPURY>90))
  {
    printf("**Illegal value %lf used for environment variable GAIT_IMPORT_RECTANGLE_URY\n",CLIPURY);
	printf("...using 90 instead\n");
	CLIPURY = 90;
  }
  if(CLIPURY<CLIPLLY)
  {
    printf("**Illegal value %lf used for environment variable GAIT_IMPORT_RECTANGLE_URY\n",CLIPURY);
	printf("..this value must be greater than or equal to GAIT_IMPORT_RECTANGLE_LLY (%lf)\n",CLIPLLY);
	printf("...using 90 instead\n");
	CLIPURY = 90;
  }

  SPECIAL_PAD_DIST = 10;
  SPECIAL_PAD_DIST  = SetGAITVarDouble(envfile,flag,SPECIAL_PAD_DIST,    "GAIT_CONDITION_ZOOM_PAD_DISTANCE","Used to specify the \"Pad Distance\" value on the \"Individual Condition Zoom Pad Distance\" window");
  if((SPECIAL_PAD_DIST<1)||(SPECIAL_PAD_DIST>5000))
  {
    printf("**Illegal value %lf used for environment variable GAIT_CONDITION_ZOOM_PAD_DISTANCE\n",SPECIAL_PAD_DIST);
	printf("..this value must be 1 to 5000\n");
  }




  CONDITION_LIMIT = 2000000;
  CONDITION_LIMIT = SetGAITVarInt2(envfile,flag,CONDITION_LIMIT,"GAIT_CONDITION_LIMIT","Nothing to see here");
  if(CONDITION_LIMIT<10)
  {
    printf("**Illegal value %ld used for environment variable GAIT_CONDITION_LIMIT\n",CONDITION_LIMIT);
	printf("..this value must be greater than 10\n");
	printf("...using 2000000 instead\n");
	CONDITION_LIMIT = 2000000;
  }
  else if(CONDITION_LIMIT!=2000000)
  {
    printf("***Setting GAIT_CONDITION_LIMIT to %ld\n",CONDITION_LIMIT);
  }



  MAX_SHAPE_NUM = 750000;
  MAX_SHAPE_NUM = SetGAITVarInt2(envfile,flag,MAX_SHAPE_NUM,"GAIT_SHAPE_LIMIT","Nothing to see here");
  if(MAX_SHAPE_NUM<50000)
  {
    printf("**Illegal value %d used for environment variable GAIT_SHAPE_LIMIT\n",MAX_SHAPE_NUM);
	printf("..this value must be at least 50000\n");
	printf("...using 750000 instead\n");
	MAX_SHAPE_NUM = 750000;
  }
  else if(MAX_SHAPE_NUM!=750000)
  {
    printf("***Setting GAIT_SHAPE_LIMIT to %d\n",MAX_SHAPE_NUM);
  }






  DIGITS_TO_PRINT = SetGAITVarInt2(envfile,flag,DIGITS_TO_PRINT,"GAIT_INFO_MAX_DECIMALS_TO_PRINT","Used to specify the \"Number of decimals to show\" value on the \"Parameters (information)\" window");
  if((DIGITS_TO_PRINT<0)||(DIGITS_TO_PRINT>15))
  {
    printf("**Illegal value %d used for environment variable GAIT_INFO_MAX_DECIMALS_TO_PRINT\n",DIGITS_TO_PRINT);
	printf("..this value must be between 1 and 10 (inclusive)\n");
	printf("...using 10 instead\n");
	DIGITS_TO_PRINT = 10;
  }


  VertexPrintLimit = SetGAITVarInt2(envfile,flag,VertexPrintLimit,"GAIT_INFO_MAX_COORDINATES_TO_PRINT","Used to specify the \"Maximum number of coordinates to show\" value on the \"Parameters (information)\" window");
  if((VertexPrintLimit<0)||(VertexPrintLimit>99999999))
  {
    printf("**Illegal value %d used for environment variable GAIT_INFO_MAX_COORDINATES_TO_PRINT\n",VertexPrintLimit);
	printf("..this value must be between 1 and 99999999 (inclusive)\n");
	printf("...using 25000 instead\n");
	VertexPrintLimit = 25000;
  }



  VPAD_DIST = SetGAITVarDouble(envfile,flag,VPAD_DIST,    "GAIT_INFO_VERTEX_ZOOM_PAD_DISTANCE","Used to specify the \"Pad Distance\" value on the \"Individual Vertex Zoom Pad Distance\" window");
  if((VPAD_DIST<MIN_PAD_DIST)||(VPAD_DIST>MAX_PAD_DIST))
  {
    printf("**Illegal value %lf used for environment variable GAIT_INFO_VERTEX_ZOOM_PAD_DISTANCE\n",VPAD_DIST);
	printf("..this value must be between 1 and 5000 (inclusive)\n");
	printf("...using %lf instead\n",DEFAULT_PAD_DIST);
	VPAD_DIST = DEFAULT_PAD_DIST;
  }

  PPAD_DIST = SetGAITVarDouble(envfile,flag,PPAD_DIST,    "GAIT_POI_ZOOM_PAD_DISTANCE","Used to specify the \"Pad Distance\" value on the \"Point Of Interest Zoom Pad Distance\" window");
  if((PPAD_DIST<MIN_PAD_DIST)||(PPAD_DIST>MAX_PAD_DIST))
  {
    printf("**Illegal value %lf used for environment variable GAIT_POI_ZOOM_PAD_DISTANCE\n",PPAD_DIST);
	printf("..this value must be between 1 and 5000 (inclusive)\n");
	printf("...using %lf instead\n",DEFAULT_PAD_DIST);
	PPAD_DIST = DEFAULT_PAD_DIST;
  }




  if(ALSO_PRINT_USAGE==1)  
  {
    printf("REM Variable: GAIT_BATCH_INPUT_SPEC_TO_USE\n");
    printf("REM  Use: Used to specify an Input Specification File to use when using batch mode\n");
    printf("REM   If this variable is used, the \"text file specifying import data location(s)\"\n");
    printf("REM   argument for batch mode must be NULL.\n");
    printf("REM   If the \"text file specifying import data location(s)\" argument for batch mode\n");
    printf("REM   is used, this variable must either be NULL or not set\n");
    printf("REM  Example usage: GAIT_BATCH_INPUT_SPEC_TO_USE=C:\\Documents and Settings\\Admin\\Desktop\\test\\InputSpecFile.txt\n");
    printf("SET GAIT_BATCH_INPUT_SPEC_TO_USE=NULL\n");
    printf("REM\n");
  }

}





int BatchCheckMGCPXML(char *filename,char *charversion)
{ 
  extern int XML_TRD_TYPE;
  extern void XMLwrapperCallback(Widget w, XtPointer userData, XtPointer callData);

  if(!strcmp(charversion,"TRD1"))
  {
	XML_TRD_TYPE = 1;
  }
  else if(!strcmp(charversion,"TRD2"))
  {
	XML_TRD_TYPE = 2;
  }
  else if(!strcmp(charversion,"TRD3"))
  {
	XML_TRD_TYPE = 3;
  }
  else if(!strcmp(charversion,"TRD4.0"))
  {
	XML_TRD_TYPE = 4;
  }
  else if(!strcmp(charversion,"TRD4.1"))
  {
	XML_TRD_TYPE = 41;
  }
  else if(!strcmp(charversion,"TRD4.2"))
  {
	XML_TRD_TYPE = 42;
  }
  else if(!strcmp(charversion,"TRD4.3"))
  {
	XML_TRD_TYPE = 43;
  }
  else if(!strcmp(charversion,"TRD4.4"))
  {
	XML_TRD_TYPE = 44;
  }
  else
  {
	printf("Bad version \"%s\".  Expected \"TRD1\", \"TRD2\", \"TRD3\", \"TRD4.0\", \"TRD4.1\", \"TRD4.2\", \"TRD4.3\", or \"TRD4.4\"\n",charversion);
	return 0;
  }

  batch_mode = 1;

  printf("Check MGCP XML %s version %s\n",filename,charversion);

  sprintf(XML1name,"%s",filename);
  XML2name[0] = '\0';
  XML3name[0] = '\0';

  XMLwrapperCallback((Widget)NULL, (XtPointer)NULL, (XtPointer)NULL);
  return 1;
} 




int MGCPBatchPackageCheck(char *packagefolder, char *charversion, char *savefile)
{
  extern int DP_TRD_TYPE;

  

  if(!strcmp(charversion,"TRD3"))
  {
	DP_TRD_TYPE = 3;
  }
  else if(!strcmp(charversion,"TRD4.0"))
  {
	DP_TRD_TYPE = 4;
  }
  else if(!strcmp(charversion,"TRD4.1"))
  {
	DP_TRD_TYPE = 41;
  }
  else if(!strcmp(charversion,"TRD4.2"))
  {
	DP_TRD_TYPE = 42;
  }
  else if(!strcmp(charversion,"TRD4.3"))
  {
	DP_TRD_TYPE = 43;
  }
  else if(!strcmp(charversion,"TRD4.4"))
  {
	DP_TRD_TYPE = 44;
  }
  else
  {
	printf("Bad version \"%s\".  Expected \"TRD3\", \"TRD4.0\", \"TRD4.1\", \"TRD4.2\", \"TRD4.3\", or \"TRD4.4\"\n",charversion);
	return 0;
  }


  
  sprintf(PROJECTLOC,"%sprojects",GAIT_HOME_DIR);
  printf("PROJECTLOC: %s\n",PROJECTLOC);

  sprintf(dp1name,"%s",packagefolder);

  batchsavefile = fopen(savefile,"w");
  if(batchsavefile==NULL)
  {
	printf("Error: unable to open \"%s\" for write\n",savefile);
	return 0;
  }

  fprintf(batchsavefile,"MGCP packaging results for folder:\n %s\n using version %s\n\n",dp1name,charversion);

  batch_mode = 1;

  DPwrapperCallback((Widget)NULL, (XtPointer)1, (XtPointer)NULL);

  printf("Data packaging results saved to %s\n",savefile);

  if(batchsavefile!=NULL)
  {
	fclose(batchsavefile);
  }

  return 1;
}


void ReOpenBatchSaveFile(char *savefile)
{
  
  
  

  if(batchsavefile!=NULL)
  {
	fclose(batchsavefile);
  }

  batchsavefile = fopen(savefile,"w");
  if(batchsavefile==NULL)
  {
	printf("Error: unable to re-open \"%s\" for write\n",savefile);
  }

}


int MGCPBatchQACheck(char *packagefolder,char *gaitprojname, char *charversion, char *savefile)
{
  extern int DP_TRD_TYPE;
  extern int FORCE_DP_OVERWRITE;

  

  if(!strcmp(charversion,"TRD3"))
  {
	DP_TRD_TYPE = 3;
  }
  else if(!strcmp(charversion,"TRD4.0"))
  {
	DP_TRD_TYPE = 4;
  }
  else if(!strcmp(charversion,"TRD4.1"))
  {
	DP_TRD_TYPE = 41;
  }
  else if(!strcmp(charversion,"TRD4.2"))
  {
	DP_TRD_TYPE = 42;
  }
  else if(!strcmp(charversion,"TRD4.3"))
  {
	DP_TRD_TYPE = 43;
  }
  else if(!strcmp(charversion,"TRD4.4"))
  {
	DP_TRD_TYPE = 44;
  }
  else
  {
	printf("Bad version \"%s\".  Expected \"TRD3\", \"TRD4.0\", \"TRD4.1\", \"TRD4.2\", \"TRD4.3\", or \"TRD4.4\"\n",charversion);
	return 0;
  }


  
  
  printf("using DP PROJECTLOC: %s\n",PROJECTLOC);


  sprintf(dp1name,"%s",packagefolder);
  sprintf(dp2name,"%s",gaitprojname);

  batchsavefile = fopen(savefile,"w");
  if(batchsavefile==NULL)
  {
	printf("Error: unable to open \"%s\" for write\n",savefile);
	return 0;
  }

  batch_mode = 1;

  FORCE_DP_OVERWRITE = 1;

  sprintf(dp1name,"%s",packagefolder);
  sprintf(dp2name,"%s",gaitprojname);


  DPwrapperCallback((Widget)NULL,(XtPointer)2,(XtPointer)savefile);


  printf("MGCP partial QA results also saved to %s\n",savefile);

  if(batchsavefile!=NULL)
  {
	fclose(batchsavefile);
  }
  return 1;
}



void escapeCallback(Widget w,XtPointer data,XtPointer callData)
{
  
  ABORT_ZOOM = 2;
}



void AssessHolidays()
{
  int i,thisyear,thismonth,thisday;
  extern int GetTimeValues(int *year, int *month, int *day);
#define num_holidays 26
  int holiday_years [num_holidays]={0,0, 0, 0,  0,  0,  0, 0, 0, 0,    2017,  2018,  2019, 2020, 2017,  2018,  2019, 2020, 2017,  2018,  2019, 2020, 2017,  2018,  2019, 2020};
  int holiday_months[num_holidays]={1,7, 7, 2, 10, 12,  1, 2, 4, 7,       6,     6,     6,    6,   12,    12,    12,   12,    3,     3,     3,    3,    9,     9,     9,    9};
  int holiday_days  [num_holidays]={1,1,17,14, 31, 31, 26, 2, 1, 7,      21,    21,    21,   20,   21,    21,    21,   21,   20,    20,    20,   19,   22,    22,    23,   22};

  char *holiday_messages[num_holidays] = 
  {
    "You shouldn't be at work today!  It's New Year's Day!  Go home!",
    "You shouldn't be at work today!  It's Canada Day (eh)!  Go home...eat poutine!",
    "You shouldn't be at work today!  It's Tim Stone's Birthday!  Go home!\n  (PS, it's also World Emoji day)",
    "You shouldn't be at work today!  It's Valentine's Day!  Go home!",
    "You shouldn't be at work today!  It's Halloween!  Go home and scare some kids!",
    "You shouldn't be at work today!  It's New Year's Eve!  Go home!",

    "You shouldn't be at work today!  It's Australia Day!\n  Go home and play a Didgeridoo!",

    "You shouldn't be at work today!  It's Groundhog Day!\n  Go home and study obscure American holidays!",
    "Reminder:  Today is April Fools' Day!",
    "Important reminder:  Today is World Chocolate Day!",

	"Ahh...the first day of summer.  Good time to be working with GAIT.",
	"Ahh...the first day of summer.  Good time to be working with GAIT.",
	"Ahh...the first day of summer.  Good time to be working with GAIT.",
	"Ahh...the first day of summer.  Good time to be working with GAIT.",

	"Ahh...the first day of winter.  Good time to be working with GAIT.",
	"Ahh...the first day of winter.  Good time to be working with GAIT.",
	"Ahh...the first day of winter.  Good time to be working with GAIT.",
	"Ahh...the first day of winter.  Good time to be working with GAIT.",

	"Ahh...the first day of spring.  Good time to be working with GAIT.",
	"Ahh...the first day of spring.  Good time to be working with GAIT.",
	"Ahh...the first day of spring.  Good time to be working with GAIT.",
	"Ahh...the first day of spring.  Good time to be working with GAIT.",

	"Ahh...the first day of fall.  Good time to be working with GAIT.",
	"Ahh...the first day of fall.  Good time to be working with GAIT.",
	"Ahh...the first day of fall.  Good time to be working with GAIT.",
	"Ahh...the first day of fall.  Good time to be working with GAIT."
  };

  if(batch_mode>0)
  {
    return;
  }

  if(GetTimeValues(&thisyear,&thismonth,&thisday))
  {
	for(i=0;i<num_holidays;i++)
	{
	  if((holiday_years[i]==0)||(thisyear==holiday_years[i]))
	  {
		if((holiday_months[i]==thismonth)&&(holiday_days[i]==thisday))
		{
          not_while_running(drawing_a,holiday_messages[i],1636,"Nothing to see here",1);
          XBell(mydisplay,1);
		}
	  }
	}
  }  
}







String fallbacks[] = {
    "*fontList: -*-courier-bold-r-*--*-90-*=mytag1,-*-courier-bold-r-*--*-180-*=mytag3,-*-courier-medium-r-*--*-90-*=mytag2",NULL};






int main(int argc, char **argv)
{
  Widget W,  
    form,    
    form2,   
    rc,      
    menubar2;

  Screen *myscreen;

  Pixmap icon_pix,toolbar_pixmap[20],toolbar_insen_pixmap[20];
  XmString t;
  XtActionsRec actions;
  XtActionsRec actions2;
  Arg resources[20];	
  int n=0,good,MOD;
  char startloc[1000];
  Atom ABNORMAL_DELETE;
  char *bat_option=NULL;     
  char *stf_locations=NULL;  
  char *exe_options=NULL;    


  FILE *test;
  char testfile[1000],outshapedirectory[1000];


  int batchtype=0,col_index;
  int line=0,newcode,snumber,dnumber,i,j,len,doingQAcheck=0;
  FILE *tempfile;
  char strat[100],dom[100],ecc[1000],aline[1000],temp[1000],batchignorename[500],specfilename[1000];


  extern int DOMAINSLEN,STRATSLEN,CREATING_TREX,DO_TIFFSURFACE,GetNum(char *ecc);





  

#if(NGA_TYPE==0)
  
  static MenuItem configuration_menu[] = 
  {
    { "No Configuration", &xmToggleButtonWidgetClass,'!', NULL, NULL,
      (void (*)())draw_poly, (XtPointer) 0,     (MenuItem *) NULL },
    { "Area", &xmToggleButtonWidgetClass,            '!', NULL, NULL,
      (void (*)())draw_poly, (XtPointer) 1,     (MenuItem *) NULL },
    { "Directed Line", &xmToggleButtonWidgetClass,   '!', NULL, NULL,
      (void (*)())draw_poly, (XtPointer) 2,     (MenuItem *) NULL },
    { "Footprint Model", &xmToggleButtonWidgetClass, '!', NULL, NULL,
      (void (*)())draw_poly, (XtPointer) 3,     (MenuItem *) NULL },
    { "Line", &xmToggleButtonWidgetClass,            '!', NULL, NULL,
      (void (*)())draw_poly, (XtPointer) 4,     (MenuItem *) NULL },
    { "Point Feature", &xmToggleButtonWidgetClass,   '!', NULL, NULL,
      (void (*)())draw_poly, (XtPointer) 5,     (MenuItem *) NULL },
    { "Point Model", &xmToggleButtonWidgetClass,     '!', NULL, NULL,
      (void (*)())draw_poly, (XtPointer) 6,     (MenuItem *) NULL },
    { "Polygon", &xmToggleButtonWidgetClass,         '!', NULL, NULL,
      (void (*)())draw_poly, (XtPointer) 7,     (MenuItem *) NULL },
    { "Dynamic Model", &xmToggleButtonWidgetClass,   '!', NULL, NULL,
      (void (*)())draw_poly, (XtPointer) 8,     (MenuItem *) NULL },
    { "Grid", &xmToggleButtonWidgetClass,            '!', NULL, NULL,
      (void (*)())draw_poly, (XtPointer) 9,     (MenuItem *) NULL },
    { "Collision Volume (S)", &xmToggleButtonWidgetClass,'!', NULL, NULL,
      (void (*)())draw_poly, (XtPointer) 10,     (MenuItem *) NULL },
    { "Collision Volume (P)", &xmToggleButtonWidgetClass,'!', NULL, NULL,
      (void (*)())draw_poly, (XtPointer) 11,     (MenuItem *) NULL },
    { "Model Library Polygon", &xmToggleButtonWidgetClass,'!', NULL, NULL,
      (void (*)())draw_poly, (XtPointer) 12,     (MenuItem *) NULL },
    { "Feature Model Point Feature", &xmToggleButtonWidgetClass,'!', NULL, NULL,
      (void (*)())draw_poly, (XtPointer) 13,     (MenuItem *) NULL },
    { "Feature Model Linear Feature", &xmToggleButtonWidgetClass,'!', NULL, NULL,
      (void (*)())draw_poly, (XtPointer) 14,     (MenuItem *) NULL },
    { "Feature Model Areal Feature", &xmToggleButtonWidgetClass,'!', NULL, NULL,
      (void (*)())draw_poly, (XtPointer) 15,     (MenuItem *) NULL },
    { "Select All", &xmPushButtonWidgetClass,        '!', NULL, NULL,
      (void (*)())all_toggle, (XtPointer) 1000, (MenuItem *) NULL },
    { "De-Select All", &xmPushButtonWidgetClass,     '!', NULL, NULL,
	(void (*)())all_toggle, (XtPointer) 2000, (MenuItem *) NULL },
    {NULL},
  };

  static MenuItem stratum_menu[] = {
    { "No Stratum", &xmToggleButtonWidgetClass,  '!', NULL, NULL,
      (void (*)())draw_poly, (XtPointer) 100,   (MenuItem *) NULL },
    { "Applique", &xmToggleButtonWidgetClass,    '!', NULL, NULL,
      (void (*)())draw_poly, (XtPointer) 101,   (MenuItem *) NULL },
    { "Coverage", &xmToggleButtonWidgetClass,    '!', NULL, NULL,
      (void (*)())draw_poly, (XtPointer) 102,   (MenuItem *) NULL },
    
    { "Sub-Surface", &xmToggleButtonWidgetClass, '!', NULL, NULL,
      (void (*)())draw_poly, (XtPointer) 104,   (MenuItem *) NULL },
    { "Surface", &xmToggleButtonWidgetClass,     '!', NULL, NULL,
      (void (*)())draw_poly, (XtPointer) 105,   (MenuItem *) NULL },
    { "Select All", &xmPushButtonWidgetClass,    '!', NULL, NULL,
      (void (*)())all_toggle, (XtPointer) 3000, (MenuItem *) NULL },
    { "De-Select All", &xmPushButtonWidgetClass, '!', NULL, NULL,
      (void (*)())all_toggle, (XtPointer) 4000, (MenuItem *) NULL },
    {NULL},
  };


  static MenuItem domain_menu[] = {
    { "No Domain",   &xmToggleButtonWidgetClass, '!', NULL, NULL,
      (void (*)())draw_poly, (XtPointer) 200, (MenuItem *) NULL },
    { "Air Mobility",      &xmToggleButtonWidgetClass, '!', NULL, NULL,
      (void (*)())draw_poly, (XtPointer) 201, (MenuItem *) NULL },
    { "Air Obstacle",      &xmToggleButtonWidgetClass, '!', NULL, NULL,
      (void (*)())draw_poly, (XtPointer) 202, (MenuItem *) NULL },
    { "Boundary",          &xmToggleButtonWidgetClass, '!', NULL, NULL,
      (void (*)())draw_poly, (XtPointer) 203, (MenuItem *) NULL },
    { "Bridging",          &xmToggleButtonWidgetClass, '!', NULL, NULL,
      (void (*)())draw_poly, (XtPointer) 204, (MenuItem *) NULL },
    { "Cultural",          &xmToggleButtonWidgetClass, '!', NULL, NULL,
      (void (*)())draw_poly, (XtPointer) 205, (MenuItem *) NULL },
    { "Inland Water",      &xmToggleButtonWidgetClass, '!', NULL, NULL,
      (void (*)())draw_poly, (XtPointer) 206, (MenuItem *) NULL },
    { "Land Mobility",     &xmToggleButtonWidgetClass, '!', NULL, NULL,
      (void (*)())draw_poly, (XtPointer) 207, (MenuItem *) NULL },
    { "Land Obstacle",     &xmToggleButtonWidgetClass, '!', NULL, NULL,
      (void (*)())draw_poly, (XtPointer) 208, (MenuItem *) NULL },
    { "Military Use",      &xmToggleButtonWidgetClass, '!', NULL, NULL,
      (void (*)())draw_poly, (XtPointer) 209, (MenuItem *) NULL },
    { "Open Water",        &xmToggleButtonWidgetClass, '!', NULL, NULL,
      (void (*)())draw_poly, (XtPointer) 210, (MenuItem *) NULL },
    { "Terrain",           &xmToggleButtonWidgetClass, '!', NULL, NULL,
      (void (*)())draw_poly, (XtPointer) 211, (MenuItem *) NULL },
    { "Vegetation",        &xmToggleButtonWidgetClass, '!', NULL, NULL,
      (void (*)())draw_poly, (XtPointer) 212, (MenuItem *) NULL },
    { "Maritime Mobility", &xmToggleButtonWidgetClass, '!', NULL, NULL,
      (void (*)())draw_poly, (XtPointer) 213, (MenuItem *) NULL },
    { "Maritime Obstacle", &xmToggleButtonWidgetClass, '!', NULL, NULL,
      (void (*)())draw_poly, (XtPointer) 214, (MenuItem *) NULL },
    { "Maritime Culture",  &xmToggleButtonWidgetClass, '!', NULL, NULL,
      (void (*)())draw_poly, (XtPointer) 215, (MenuItem *) NULL },
    { "Weather",           &xmToggleButtonWidgetClass, '!', NULL, NULL,
      (void (*)())draw_poly, (XtPointer) 216, (MenuItem *) NULL },
    { "Space",             &xmToggleButtonWidgetClass, '!', NULL, NULL,
      (void (*)())draw_poly, (XtPointer) 217, (MenuItem *) NULL },
    { "Descriptive",       &xmToggleButtonWidgetClass, '!', NULL, NULL,
      (void (*)())draw_poly, (XtPointer) 218, (MenuItem *) NULL },
    { "Select All",        &xmPushButtonWidgetClass,   '!', NULL, NULL,
      (void (*)())all_toggle,(XtPointer) 5000,(MenuItem *) NULL },
    { "De-Select All",     &xmPushButtonWidgetClass,   '!', NULL, NULL,
      (void (*)())all_toggle,(XtPointer) 6000,(MenuItem *) NULL },
      {NULL},
  };


#endif
  

 

  static MenuItem fore_menu[] = {
    { "0.25 Degree Grid Without Labels", &xmToggleButtonWidgetClass, '!', NULL, NULL,
      (void (*)())Forecallback, (XtPointer) 1, (MenuItem *) NULL },
    { "0.25 Degree Grid With Labels", &xmToggleButtonWidgetClass, '!', NULL, NULL,
      (void (*)())Forecallback, (XtPointer) 2, (MenuItem *) NULL },

    { "0.50 Degree Grid Without Labels", &xmToggleButtonWidgetClass, '!', NULL, NULL,
      (void (*)())Forecallback, (XtPointer) 3, (MenuItem *) NULL },
    { "0.50 Degree Grid With Labels", &xmToggleButtonWidgetClass, '!', NULL, NULL,
      (void (*)())Forecallback, (XtPointer) 4, (MenuItem *) NULL },

    { "1.0 Degree Grid Without Labels", &xmToggleButtonWidgetClass, '!', NULL, NULL,
      (void (*)())Forecallback, (XtPointer) 5, (MenuItem *) NULL },
    { "1.0 Degree Grid With Labels", &xmToggleButtonWidgetClass, '!', NULL, NULL,
      (void (*)())Forecallback, (XtPointer) 6, (MenuItem *) NULL },


	{ "User-Defined Grid Without Labels", &xmToggleButtonWidgetClass, '!', NULL, NULL,
      (void (*)())Forecallback, (XtPointer) 7, (MenuItem *) NULL },
	{ "User-Defined Grid With Labels", &xmToggleButtonWidgetClass, '!', NULL, NULL,
      (void (*)())Forecallback, (XtPointer) 8, (MenuItem *) NULL },

    {NULL},
  };



  
  
  MenuItem Mode_Menu[] = {
    { "Zoom",&xmToggleButtonWidgetClass, '!', "Ctrl<Key>Z","Ctrl+z",
      (void (*)())modeCallback, (XtPointer)1,(MenuItem *) NULL},
    { "Pan", &xmToggleButtonWidgetClass, '!',"Ctrl<Key>p","Ctrl+p",
      (void (*)())modeCallback, (XtPointer)3, (MenuItem *) NULL },
    { "Information", &xmToggleButtonWidgetClass, '!', "Ctrl<Key>N","Ctrl+n",
      (void (*)())modeCallback, (XtPointer)2, (MenuItem *) NULL },
    { "Distance", &xmToggleButtonWidgetClass, '!', "Ctrl<Key>D","Ctrl+d",
      (void (*)())modeCallback, (XtPointer)8, (MenuItem *) NULL },
    { "Localized Inspection", &xmToggleButtonWidgetClass, '!',NULL,NULL,
      (void (*)())modeCallback, (XtPointer)9, (MenuItem *) NULL },
    { "Actual Profile", &xmToggleButtonWidgetClass, '!',NULL,NULL,
      (void (*)())modeCallback, (XtPointer)4, (MenuItem *) NULL },
    { "Zoom Profile", &xmToggleButtonWidgetClass, '!', NULL, NULL,
      (void (*)())modeCallback, (XtPointer)5, (MenuItem *) NULL },
    { "LOS Profile", &xmToggleButtonWidgetClass, '!',NULL,NULL,
      (void (*)())modeCallback, (XtPointer)6, (MenuItem *) NULL },
#if(DO_FAN_VAR==1)
    { "LOS Fan", &xmToggleButtonWidgetClass, '!',NULL,NULL,
     (void (*)()) modeCallback, (XtPointer)7, (MenuItem *) NULL },
#endif
    {NULL},
  };



#if (NGA_TYPE==1)
  
   MenuItem shapeerr_menu[] = {
    { "Zero-Part Area/Line errors", &xmPushButtonWidgetClass, '!',NULL,NULL,
      (void (*)())AttrErr8Callback, NULL,  (MenuItem *) NULL },
    { "Null Feature errors", &xmPushButtonWidgetClass, '!',NULL,NULL,
      (void (*)())AttrErr11Callback, NULL,  (MenuItem *) NULL },
    { "Invalid Coordinate errors", &xmPushButtonWidgetClass, '!',NULL,NULL,
      (void (*)())AttrErr12Callback, NULL,  (MenuItem *) NULL },
    { "Invalid Cut-Out errors", &xmPushButtonWidgetClass, '!',NULL,NULL,
      (void (*)())AttrErr16Callback, NULL,  (MenuItem *) NULL },
    { "Unrecognized Column Names", &xmPushButtonWidgetClass, '!',NULL,NULL,
      (void (*)())AttrErr17Callback, NULL,  (MenuItem *) NULL },
    { "Invalid Data Type", &xmPushButtonWidgetClass, '!',NULL,NULL,
      (void (*)())AttrErr24Callback, NULL,  (MenuItem *) NULL },
    { "Empty or Invalid Shapefiles or Tables", &xmPushButtonWidgetClass, '!',NULL,NULL,
      (void (*)())AttrErr27Callback, NULL,  (MenuItem *) NULL },
    { "Geodatabase Bezier/Circle/Ellipse features", &xmPushButtonWidgetClass, '!',NULL,NULL,
      (void (*)())AttrErr30Callback, NULL,  (MenuItem *) NULL },
    { "MGCP \"No FCODE Column\" errors", &xmPushButtonWidgetClass, '!',NULL,NULL,
      (void (*)())AttrErr19Callback, NULL,  (MenuItem *) NULL },
    { "MGCP Shapefile Naming errors", &xmPushButtonWidgetClass, '!',NULL,NULL,
      (void (*)())AttrErr20Callback, NULL,  (MenuItem *) NULL },
    { "MGCP \"Shape Type\" errors", &xmPushButtonWidgetClass, '!',NULL,NULL,
      (void (*)())AttrErr21Callback, NULL,  (MenuItem *) NULL },

    { "MGCP \"Invalid Field Length\" errors", &xmPushButtonWidgetClass, '!',NULL,NULL,
      (void (*)())AttrErr25Callback, NULL,  (MenuItem *) NULL },

    { "MGCP \"UTF-8 Encoding\" anomalies", &xmPushButtonWidgetClass, '!',NULL,NULL,
      (void (*)())AttrErr29Callback, NULL,  (MenuItem *) NULL },

    {NULL},
  };


  MenuItem attribution_menu[] = {  
    { "Input Data Anomalies", &xmCascadeButtonWidgetClass, '!', NULL, NULL,
      0, 0, shapeerr_menu },
    { "FCODE errors", &xmPushButtonWidgetClass, '!',NULL,NULL,
      (void (*)())AttrErr6Callback, NULL,  (MenuItem *) NULL },    
    { "Blank Attribute errors", &xmPushButtonWidgetClass, '!',NULL,NULL,
      (void (*)())AttrErr22Callback, NULL,  (MenuItem *) NULL },    
    { "MGCP \"Mixed Null/Non-Null Optional Attribute\" errors", &xmPushButtonWidgetClass, '!',NULL,NULL,
      (void (*)())AttrErr23Callback, NULL,  (MenuItem *) NULL },    
    { "Invalid Case errors", &xmPushButtonWidgetClass, '!',NULL,NULL,
      (void (*)())AttrErr10Callback, NULL,  (MenuItem *) NULL },    
    { "Non Domain Specific Pick-list errors", &xmPushButtonWidgetClass, '!',NULL,NULL,
      (void (*)())AttrErr1Callback, NULL,  (MenuItem *) NULL },    
    { "Domain Specific Pick-list errors", &xmPushButtonWidgetClass, '!',NULL,NULL,
      (void (*)())AttrErr3Callback, NULL,  (MenuItem *) NULL },    
    { "Unexpected FCODE-Geometry Pair errors", &xmPushButtonWidgetClass, '!',NULL,NULL,
      (void (*)())AttrErr13Callback, NULL,  (MenuItem *) NULL },    

    { "Value Range errors", &xmPushButtonWidgetClass, '!',NULL,NULL,
      (void (*)())AttrErr2Callback, NULL,  (MenuItem *) NULL },    

    { "MGCP \"Required Attribute Assigned Null Value\" errors", &xmPushButtonWidgetClass, '!',NULL,NULL,
      (void (*)())AttrErr26Callback, NULL,  (MenuItem *) NULL },    
 
	{ "Unexpected Attribute errors", &xmPushButtonWidgetClass, '!',NULL,NULL,
      (void (*)())AttrErr5Callback, NULL,  (MenuItem *) NULL },    

    { "Missing Attribute Field Or Value errors", &xmPushButtonWidgetClass, '!',NULL,NULL,
      (void (*)())AttrErr14Callback, NULL,  (MenuItem *) NULL },    

    { "Attribute Dependency errors", &xmPushButtonWidgetClass, '!',NULL,NULL,
      (void (*)())AttrErr18Callback, NULL,  (MenuItem *) NULL },    

    { "Metadata errors", &xmPushButtonWidgetClass, '!',NULL,NULL,
      (void (*)())AttrErr7Callback, NULL,  (MenuItem *) NULL },    

    { "Condensed Summary", &xmPushButtonWidgetClass, '!',NULL,NULL,
      (void (*)())AttrErr9Callback, NULL,  (MenuItem *) NULL },    

    {NULL},
  };




 


  MenuItem View_Menu[] = {  
    { "Conditions...", &xmPushButtonWidgetClass, '!',"Ctrl<Key>C","Ctrl+c",
      (void (*)())ErrorSelectionCallback, NULL,  (MenuItem *) NULL },
    { "Conditions by Feature...", &xmPushButtonWidgetClass, '!',"Ctrl<Key>F","Ctrl+f",
      (void (*)())ConditionObjectCallback,(XtPointer)view_object_page,  (MenuItem *) NULL },


    { "Network Options...",&xmPushButtonWidgetClass, '!',NULL,NULL,
      (void (*)())NETmodifyCallback, (XtPointer)NULL, (MenuItem *) NULL },

	{ "Networks...", &xmPushButtonWidgetClass, '!',NULL,NULL,
      (void (*)())BuildNetworkViewer,(XtPointer)NULL,  (MenuItem *) NULL },


    
    { "Coordinate Grid", &xmCascadeButtonWidgetClass, '!', NULL, NULL,
      0, 0, fore_menu },
    { "Attribution Errors/Input Data Anomalies", &xmCascadeButtonWidgetClass, '!', NULL, NULL,
      0, 0, attribution_menu },
    { "By Attribution...", &xmPushButtonWidgetClass, '!', NULL, NULL,
      (void (*)())ModelButton4Callback, (XtPointer)0,  (MenuItem *) NULL },    
	{ "By Layer...", &xmPushButtonWidgetClass, '!',"Ctrl<Key>L","Ctrl+l",
      (void (*)())LODCallback, NULL,  (MenuItem *) NULL },    
    { "Points Of Interest...", &xmPushButtonWidgetClass, '!', NULL, NULL,
      (void (*)())AOIButtonCallback, NULL,  (MenuItem *) NULL },    
    { "Summary Information...", &xmPushButtonWidgetClass,   '!',"Ctrl<Key>S","Ctrl+s",
      (void (*)())SummaryCallback, NULL,  (MenuItem *) NULL },    
    { "Refresh View", &xmPushButtonWidgetClass, '!',"Ctrl<Key>V","Ctrl+v",
      (void (*)())refreshCallback, NULL,  (MenuItem *) NULL },
    { "Screen Grab", &xmPushButtonWidgetClass, '!',"Ctrl<Key>G","Ctrl+g",
      (void (*)())grabCallback, NULL,  (MenuItem *) NULL },
    {NULL},
  };
  
#else
  MenuItem View_Menu[] = {  
    { "Conditions...", &xmPushButtonWidgetClass, '!',"Ctrl<Key>C","Ctrl+c",
      (void (*)())ErrorSelectionCallback, NULL,  (MenuItem *) NULL },
    { "Conditions by Object...", &xmPushButtonWidgetClass, '!',"Ctrl<Key>F","Ctrl+f",
      (void (*)())ConditionObjectCallback,(XtPointer)view_object_page,  (MenuItem *) NULL },
    { "Networks associated with particular inspections...", &xmPushButtonWidgetClass, '!',NULL,NULL,
      (void (*)())BuildNetworkViewer,(XtPointer)NULL,  (MenuItem *) NULL },
    
    { "Configuration", &xmCascadeButtonWidgetClass, '!', NULL, NULL,
      0, 0, configuration_menu },
    { "Stratum", &xmCascadeButtonWidgetClass, '!', NULL, NULL,
      0, 0, stratum_menu },
    { "Domain", &xmCascadeButtonWidgetClass, '!', NULL, NULL,
      0, 0, domain_menu },
    { "Foreground", &xmCascadeButtonWidgetClass, '!', NULL, NULL,
      0, 0, fore_menu },
    { "By Attribution...", &xmPushButtonWidgetClass, '!',"Ctrl<Key>Y","Ctrl+y",
      (void (*)())ModelButton4Callback, (XtPointer)0,  (MenuItem *) NULL },    
    { "By LOD...", &xmPushButtonWidgetClass, '!',"Ctrl<Key>L","Ctrl+l",
      (void (*)())LODCallback, NULL,  (MenuItem *) NULL },    
    { "Points Of Interest...", &xmPushButtonWidgetClass, '!',"Ctrl<Key>A","Ctrl+a",
      (void (*)())AOIButtonCallback, NULL,  (MenuItem *) NULL },    
    { "Summary Information...", &xmPushButtonWidgetClass,   '!',"Ctrl<Key>S","Ctrl+s",
      (void (*)())SummaryCallback, NULL,  (MenuItem *) NULL },    
    { "Refresh View", &xmPushButtonWidgetClass, '!',"Ctrl<Key>V","Ctrl+v",
      (void (*)())refreshCallback, NULL,  (MenuItem *) NULL },
    { "Screen Grab", &xmPushButtonWidgetClass, '!',"Ctrl<Key>G","Ctrl+g",
      (void (*)())grabCallback, NULL,  (MenuItem *) NULL },
    {NULL},
  };
#endif
  

  MenuItem Stack_Menu[] = {  
    { "Restore current/latest zoom", &xmPushButtonWidgetClass, '0',"Ctrl<Key>0","Ctrl+0",
      (void (*)())ZoomStackCallback, (XtPointer)0,  (MenuItem *) NULL },
    { "Restore view from 1 zoom ago", &xmPushButtonWidgetClass, '1',"Ctrl<Key>1","Ctrl+1",
      (void (*)())ZoomStackCallback, (XtPointer)1,  (MenuItem *) NULL },
    { "Restore view from 2 zooms ago", &xmPushButtonWidgetClass, '2',"Ctrl<Key>2","Ctrl+2",
      (void (*)())ZoomStackCallback, (XtPointer)2,  (MenuItem *) NULL },
    { "Restore view from 3 zooms ago", &xmPushButtonWidgetClass, '3',"Ctrl<Key>3","Ctrl+3",
      (void (*)())ZoomStackCallback, (XtPointer)3,  (MenuItem *) NULL },
    { "Restore view from 4 zooms ago", &xmPushButtonWidgetClass, '4',"Ctrl<Key>4","Ctrl+4",
      (void (*)())ZoomStackCallback, (XtPointer)4,  (MenuItem *) NULL },
    { "Restore view from 5 zooms ago", &xmPushButtonWidgetClass, '5',"Ctrl<Key>5","Ctrl+5",
      (void (*)())ZoomStackCallback, (XtPointer)5,  (MenuItem *) NULL },
    { "Restore view from 6 zooms ago", &xmPushButtonWidgetClass, '6',"Ctrl<Key>6","Ctrl+6",
      (void (*)())ZoomStackCallback, (XtPointer)6,  (MenuItem *) NULL },
    { "Restore view from 7 zooms ago", &xmPushButtonWidgetClass, '7',"Ctrl<Key>7","Ctrl+7",
      (void (*)())ZoomStackCallback, (XtPointer)7,  (MenuItem *) NULL },
    { "Restore view from 8 zooms ago", &xmPushButtonWidgetClass, '8',"Ctrl<Key>8","Ctrl+8",
      (void (*)())ZoomStackCallback, (XtPointer)8,  (MenuItem *) NULL },
    { "Restore view from 9 zooms ago", &xmPushButtonWidgetClass, '9',"Ctrl<Key>9","Ctrl+9",
      (void (*)())ZoomStackCallback, (XtPointer)9,  (MenuItem *) NULL },
    {NULL},
  };




#if (NGA_TYPE==1)

  static MenuItem qacr_menu[] = 
  {
    { "Open NGA_QACR.doc file",
      &xmPushButtonWidgetClass,'!',NULL,NULL,
      (void (*)())open_doc, (XtPointer) DOC_NGAQACR,     (MenuItem *) NULL },
    { "Open MGCP_QACR.doc file",
      &xmPushButtonWidgetClass,'!',NULL,NULL,
      (void (*)())open_doc, (XtPointer) DOC_MGCPQACR,    (MenuItem *) NULL },

    { "Open projectsummary.txt file",
      &xmPushButtonWidgetClass,'!',NULL,NULL,
      (void (*)())open_doc, (XtPointer) DOC_PROJSUMM,    (MenuItem *) NULL },
    { "Open checksummary.txt file",
      &xmPushButtonWidgetClass,'!',NULL,NULL,
      (void (*)())open_doc, (XtPointer) DOC_CHECKSUMM,    (MenuItem *) NULL },

    { "Open \"Unique Names as HTML\" file",
      &xmPushButtonWidgetClass,'!',NULL,NULL,
      (void (*)())open_doc, (XtPointer) DOC_UNIQUENAMES,    (MenuItem *) NULL },
    {NULL},
  };


  MenuItem File_Menu[] = {
    { "Open GAIT Project...",&xmPushButtonWidgetClass, '!',"Ctrl<Key>O","Ctrl+o",
      (void (*)())InputButtonCallback,  NULL, (MenuItem *) NULL },
    { "Create GAIT Project...", &xmPushButtonWidgetClass, '!',NULL,NULL,
      (void (*)())ImportGAITButtonCallback, (XtPointer)1, (MenuItem *) NULL },
    { "Specify GAIT Project Folder...",&xmPushButtonWidgetClass,'!',NULL,NULL,
      (void (*)())FolderCallback,  NULL, (MenuItem *) NULL },

#if(USE_DOS==1)
    { "Specify GAIT Browse Folder...",&xmPushButtonWidgetClass,'!',NULL,NULL,
      (void (*)())BrowseFolderCallback,  NULL, (MenuItem *) NULL },
#endif

    { "Load/Save Preferences...",&xmPushButtonWidgetClass,'!',NULL,NULL,
      (void (*)())PrefsCallback,  NULL, (MenuItem *) NULL },

    
    { "Save Condition Report...",&xmPushButtonWidgetClass, '!',NULL,NULL,
      (void (*)())SavereportCallback, (XtPointer)NULL, (MenuItem *) NULL },
    { "Load Condition Report...",&xmPushButtonWidgetClass, '!',NULL,NULL,
      (void (*)())LoadreportCallback, (XtPointer)NULL, (MenuItem *) NULL },

    { "Compare/Summarize Condition Report(s)...",&xmPushButtonWidgetClass, '!',NULL,NULL,
      (void (*)())CompareReportCallback, (XtPointer)NULL, (MenuItem *) NULL },

    { "Validate MGCP XML Metadata...",&xmPushButtonWidgetClass, '!',NULL,NULL,
      (void (*)())XMLCallback, (XtPointer)NULL, (MenuItem *) NULL },

    { "Validate MGCP Data Packaging/Perform Partial QA...",&xmPushButtonWidgetClass, '!',NULL,NULL,
      (void (*)())DPCallback, (XtPointer)NULL, (MenuItem *) NULL },

    { "Re-generate inspection specification files for current project",&xmPushButtonWidgetClass,'!', NULL,NULL,
      (void (*)())makedisconnectCallback, (XtPointer)NULL,(MenuItem *) NULL},

    { "Export Shapefiles from current conditions",&xmPushButtonWidgetClass, '!',NULL,NULL,
      (void (*)())MakeAllShapefiles, (XtPointer)0, (MenuItem *) NULL },

    { "Open report file for current project", &xmCascadeButtonWidgetClass, '!', NULL, NULL,
      0, 0, qacr_menu },

    { "", &xmSeparatorWidgetClass, '!',NULL,NULL,NULL,NULL,NULL },
    { "Quit", &xmPushButtonWidgetClass, '!', "Ctrl<Key>Q","Ctrl+q", 
      (void (*)())quitCallback, NULL,  (MenuItem *) NULL },
    {NULL},
  };

#elif (NGA_TYPE==0)

  MenuItem File_Menu[] = {
    { "Open SEE-IT Format Database...",&xmPushButtonWidgetClass, '!',"Ctrl<Key>I","Ctrl+i",
      (void (*)())InputButtonCallback,  NULL, (MenuItem *) NULL },
    { "Import STF Data...", &xmPushButtonWidgetClass, '!',"Ctrl<Key>T","Ctrl+t",
      (void (*)())ImportSEEITButtonCallback, NULL, (MenuItem *) NULL },
    { "Save Condition Report...",&xmPushButtonWidgetClass, '!',NULL,NULL,
      (void (*)())SavereportCallback, (XtPointer)NULL, (MenuItem *) NULL },
    { "Load Condition Report...",&xmPushButtonWidgetClass, '!',NULL,NULL,
      (void (*)())LoadreportCallback, (XtPointer)NULL, (MenuItem *) NULL },
    
    { "Apply Patch File (start repair job)...",&xmPushButtonWidgetClass, '!', "Ctrl<Key>j","Ctrl+j",
      (void (*)())fixCallback, (XtPointer)NULL,(MenuItem *) NULL},
    { "Re-generate inspection specification files for current project",&xmPushButtonWidgetClass, '!', NULL,NULL,
      (void (*)())makedisconnectCallback, (XtPointer)NULL,(MenuItem *) NULL},
    { "Export Shapefiles from current conditions", &xmCascadeButtonWidgetClass, 
      '!', NULL, NULL, 0, 0, shape_menu },
    { "", &xmSeparatorWidgetClass, '!',NULL,NULL,NULL,NULL,NULL },
    { "Quit", &xmPushButtonWidgetClass, '!', "Ctrl<Key>Q","Ctrl+q", 
      (void (*)())quitCallback, NULL,  (MenuItem *) NULL },
    {NULL},
  };

#endif



#if (NGA_TYPE==1)
 
  MenuItem Params_Menu[] = {
    { "Miscellaneous Parameters...",&xmPushButtonWidgetClass,'!',NULL,NULL,
      (void (*)())ForeGridCallback, NULL, (MenuItem *) NULL },
    { "Grid Options...",&xmPushButtonWidgetClass, '!',"Ctrl<Key>M","Ctrl+m",
      (void (*)())gridmenuCallback, (XtPointer)NULL, (MenuItem *) NULL },
    {NULL},
  };
#else
  MenuItem Params_Menu[] = {
    { "Miscellaneous Drawing Parameters...",&xmPushButtonWidgetClass,'!',NULL,NULL,
      (void (*)())ForeGridCallback, NULL, (MenuItem *) NULL },
    { "Modify Current Mappings...",&xmPushButtonWidgetClass, '!',"Ctrl<Key>u","Ctrl+u",
      (void (*)())MappingChangeCallback, NULL, (MenuItem *) NULL },
    {NULL},
  };
#endif



#if(NGA_TYPE==1)
  
  MenuItem Check_Menu[] = {
    { "Inspection Options...",&xmPushButtonWidgetClass, '!',"Ctrl<Key>I","Ctrl+i",
      (void (*)())modifyCallback, (XtPointer)NULL, (MenuItem *) NULL },
    { "", &xmSeparatorWidgetClass, '!',NULL,NULL,NULL,NULL,NULL },

    { "Begin Inspecting Using Current Inspection Options", &xmPushButtonWidgetClass, 
      '!',"Ctrl<Key>b","Ctrl+b",(void (*)())ExecuteCallback, (XtPointer)0, (MenuItem *) NULL },

    { "", &xmSeparatorWidgetClass, '!',NULL,NULL,NULL,NULL,NULL },

    { "Set Inspection Options to \"DFEG Master Profile\" and Begin Inspecting", &xmPushButtonWidgetClass, 
      '!',NULL,NULL,(void (*)())ExecuteCallback, (XtPointer)1, (MenuItem *) NULL },

    { "Set Inspection Options to \"MGCP Master Profile\" and Begin Inspecting", &xmPushButtonWidgetClass, 
      '!',NULL,NULL,(void (*)())ExecuteCallback, (XtPointer)3, (MenuItem *) NULL },

    { "Set Inspection Options to \"UFD1 Master Profile\" and Begin Inspecting", &xmPushButtonWidgetClass, 
      '!',NULL,NULL,(void (*)())ExecuteCallback, (XtPointer)4, (MenuItem *) NULL },

    { "Set Inspection Options to \"UFD3 Master Profile\" and Begin Inspecting", &xmPushButtonWidgetClass, 
      '!',NULL,NULL,(void (*)())ExecuteCallback, (XtPointer)5, (MenuItem *) NULL },

    { "Set Inspection Options to \"TDS Master Profile\" and Begin Inspecting", &xmPushButtonWidgetClass, 
      '!',NULL,NULL,(void (*)())ExecuteCallback, (XtPointer)11, (MenuItem *) NULL },

    { "Set Inspection Options to \"AFD Master Profile\" and Begin Inspecting", &xmPushButtonWidgetClass, 
      '!',NULL,NULL,(void (*)())ExecuteCallback, (XtPointer)10, (MenuItem *) NULL },

    { "Set Inspection Options to \"TREx Master Profile\" and Begin Inspecting", &xmPushButtonWidgetClass, 
      '!',NULL,NULL,(void (*)())ExecuteCallback, (XtPointer)12, (MenuItem *) NULL },

    {NULL},
  };

#else

  MenuItem Check_Menu[] = {
    { "Inspection Options...",&xmPushButtonWidgetClass, '!',"Ctrl<Key>I","Ctrl+i",
      (void (*)())modifyCallback, (XtPointer)NULL, (MenuItem *) NULL },
    { "", &xmSeparatorWidgetClass, '!',NULL,NULL,NULL,NULL,NULL },
    { "Begin Inspecting Using Current Inspection Options", &xmPushButtonWidgetClass, '!',"Ctrl<Key>b","Ctrl+b",
      (void (*)())ExecuteCallback,(XtPointer)0, (MenuItem *) NULL },
    {NULL},
  };

#endif






#if (NGA_TYPE==1)


  static MenuItem documentation_menu[] = 
  {
    { "Open What's New Document",
      &xmPushButtonWidgetClass,'!',NULL,NULL,
      (void (*)())open_doc, (XtPointer) DOC_WHATSNEW,     (MenuItem *) NULL },
    { "Open GAIT Technical Reference Manual",
      &xmPushButtonWidgetClass,'!',NULL,NULL,
      (void (*)())open_doc, (XtPointer) DOC_TRM,          (MenuItem *) NULL },
    { "Open GAIT Basics",
      &xmPushButtonWidgetClass,'!',NULL,NULL,
      (void (*)())open_doc, (XtPointer) DOC_BASICS,       (MenuItem *) NULL },
    { "Open GAIT Inspections",
      &xmPushButtonWidgetClass,'!',NULL,NULL,
      (void (*)())open_doc, (XtPointer) DOC_INSPECTIONS,  (MenuItem *) NULL },
    { "Open GAIT Cookbook",
      &xmPushButtonWidgetClass,'!',NULL,NULL,
      (void (*)())open_doc, (XtPointer) DOC_COOKBOOK,     (MenuItem *) NULL },
    { "Open NFDD/DFDD GAIT Schema Description Document",
      &xmPushButtonWidgetClass,'!',NULL,NULL,
      (void (*)())open_doc, (XtPointer) DOC_SCHEMA,       (MenuItem *) NULL },
    {NULL},
  };



    static MenuItem documentation_menu2[] = 
  {
    { "Open GIFD D4 Schema Information document",
      &xmPushButtonWidgetClass,'!',NULL,NULL,
      (void (*)())open_doc, (XtPointer) DOC_D4,          (MenuItem *) NULL },
    { "Open FACC+ Schema Information document",
      &xmPushButtonWidgetClass,'!',NULL,NULL,
      (void (*)())open_doc, (XtPointer) DOC_FACC,          (MenuItem *) NULL },
    { "Open VMap2_TLM Schema Information document",
      &xmPushButtonWidgetClass,'!',NULL,NULL,
      (void (*)())open_doc, (XtPointer) DOC_VMAP,          (MenuItem *) NULL },
    { "Open MGCP (TRD3) Schema Information document",
      &xmPushButtonWidgetClass,'!',NULL,NULL,
      (void (*)())open_doc, (XtPointer) DOC_MGCP3,          (MenuItem *) NULL },
    { "Open MGCP (TRD4) Schema Information document",
      &xmPushButtonWidgetClass,'!',NULL,NULL,
      (void (*)())open_doc, (XtPointer) DOC_MGCP4,          (MenuItem *) NULL },
    { "Open UFD1 Schema Information document",
      &xmPushButtonWidgetClass,'!',NULL,NULL,
      (void (*)())open_doc, (XtPointer) DOC_UFD1,          (MenuItem *) NULL },
    { "Open UFD2 Schema Information document",
      &xmPushButtonWidgetClass,'!',NULL,NULL,
      (void (*)())open_doc, (XtPointer) DOC_UFD2,          (MenuItem *) NULL },
    { "Open UFD3 Schema Information document",
      &xmPushButtonWidgetClass,'!',NULL,NULL,
      (void (*)())open_doc, (XtPointer) DOC_UFD3,          (MenuItem *) NULL },

    { "Open TDS (v4.0) Schema Information document",
      &xmPushButtonWidgetClass,'!',NULL,NULL,
      (void (*)())open_doc, (XtPointer) DOC_TDS4,         (MenuItem *) NULL },

    { "Open TDS (v6.1) Schema Information document",
      &xmPushButtonWidgetClass,'!',NULL,NULL,
      (void (*)())open_doc, (XtPointer) DOC_TDS6,          (MenuItem *) NULL },

    { "Open AFD (v2.6) Schema Information document", 
      &xmPushButtonWidgetClass,'!',NULL,NULL,
      (void (*)())open_doc, (XtPointer) DOC_SAC,         (MenuItem *) NULL },

    { "Open GGDM (v2.1) Schema Information document",
      &xmPushButtonWidgetClass,'!',NULL,NULL,
      (void (*)())open_doc, (XtPointer) DOC_GGDM21,         (MenuItem *) NULL },
    { "Open GGDM (v2.2) Schema Information document",
      &xmPushButtonWidgetClass,'!',NULL,NULL,
      (void (*)())open_doc, (XtPointer) DOC_GGDM22,         (MenuItem *) NULL },
    { "Open GGDM (v3.0) Schema Information document",
      &xmPushButtonWidgetClass,'!',NULL,NULL,
      (void (*)())open_doc, (XtPointer) DOC_GGDM3,         (MenuItem *) NULL },
    {NULL},
  };


  static MenuItem documentation_menu3[] = 
  {
    { "Open GIFD D4 Metadata Guidance Document",
      &xmPushButtonWidgetClass,'!',NULL,NULL,
      (void (*)())open_doc, (XtPointer) DOC_METADATA,     (MenuItem *) NULL },
    { "Open NUNANPO Guidance Document",
      &xmPushButtonWidgetClass,'!',NULL,NULL,
      (void (*)())open_doc, (XtPointer) DOC_NUNANPO,      (MenuItem *) NULL },
	{NULL},
  };



  static MenuItem documentation_menu4[] = 
  {
   { "Open MGCP Illegal Shared Face (V10) (TRD3) Excel Spreadsheet",
      &xmPushButtonWidgetClass,'!',NULL,NULL,
      (void (*)())open_doc, (XtPointer) DOC_MGCPISF3,      (MenuItem *) NULL },

   { "Open MGCP Illegal Shared Face (V15) (TRD4) Excel Spreadsheet",
      &xmPushButtonWidgetClass,'!',NULL,NULL,
      (void (*)())open_doc, (XtPointer) DOC_MGCPISF4,      (MenuItem *) NULL },


   { "Open MGCP Point to Point Proximity (V6) (TRD3) Excel Spreadsheet",
      &xmPushButtonWidgetClass,'!',NULL,NULL,
      (void (*)())open_doc, (XtPointer) DOC_MGCPPPP3,      (MenuItem *) NULL },	  

   { "Open MGCP Point to Point Proximity (V8) (TRD4) Excel Spreadsheet",
      &xmPushButtonWidgetClass,'!',NULL,NULL,
      (void (*)())open_doc, (XtPointer) DOC_MGCPPPP4,      (MenuItem *) NULL },	  


   { "Open MGCP Illogical Shared Lines (V13) (TRD3) Excel Spreadsheet",
      &xmPushButtonWidgetClass,'!',NULL,NULL,
      (void (*)())open_doc, (XtPointer) DOC_MGCPISL3,      (MenuItem *) NULL },	  

   { "Open MGCP Illogical Shared Lines (V13) (TRD4) Excel Spreadsheet",
      &xmPushButtonWidgetClass,'!',NULL,NULL,
      (void (*)())open_doc, (XtPointer) DOC_MGCPISL4,      (MenuItem *) NULL },	  


   { "Open MGCP Numeric Value Range (V10) (TRD3) Excel Spreadsheet",
      &xmPushButtonWidgetClass,'!',NULL,NULL,
      (void (*)())open_doc, (XtPointer) DOC_MGCPRANGE3,      (MenuItem *) NULL },	  

   { "Open MGCP Numeric Value Range (V7) (TRD4) Excel Spreadsheet",
      &xmPushButtonWidgetClass,'!',NULL,NULL,
      (void (*)())open_doc, (XtPointer) DOC_MGCPRANGE4,      (MenuItem *) NULL },	  

   { "Open MGCP Illogical Attribute Enumeration (V11) (TRD4) Excel Spreadsheet",
      &xmPushButtonWidgetClass,'!',NULL,NULL,
      (void (*)())open_doc, (XtPointer) DOC_MGCPIAE,      (MenuItem *) NULL },	  

   { "Open MGCP Illogical Point Inside Area (V6) (TRD4) Excel Spreadsheet",
      &xmPushButtonWidgetClass,'!',NULL,NULL,
      (void (*)())open_doc, (XtPointer) DOC_MGCPIPA,      (MenuItem *) NULL },	  

   { "Open MGCP Illogical Point On Line (V4) (TRD4) Excel Spreadsheet",
      &xmPushButtonWidgetClass,'!',NULL,NULL,
      (void (*)())open_doc, (XtPointer) DOC_MGCPIPL,      (MenuItem *) NULL },	  

   { "Open MGCP Illogical Line Inside Area (V5) (TRD4) Excel Spreadsheet",
      &xmPushButtonWidgetClass,'!',NULL,NULL,
      (void (*)())open_doc, (XtPointer) DOC_MGCPILA,      (MenuItem *) NULL },	  

   { "Open MGCP Feature Terminates At (V2) (TRD4) Excel Spreadsheet",
      &xmPushButtonWidgetClass,'!',NULL,NULL,
      (void (*)())open_doc, (XtPointer) DOC_MGCPFTA,      (MenuItem *) NULL },	  


   { "Open MGCP XML Validation Spreadsheet",
      &xmPushButtonWidgetClass,'!',NULL,NULL,
      (void (*)())open_doc, (XtPointer) DOC_MGCPXML,      (MenuItem *) NULL },	  

	{NULL},

  };

  static MenuItem documentation_menu5[] = 
  {
   { "Open TDS4 Illegal Shared Face (V1) Excel Spreadsheet",
      &xmPushButtonWidgetClass,'!',NULL,NULL,
      (void (*)())open_doc, (XtPointer) DOC_TDSISF4,      (MenuItem *) NULL },	  

   { "Open TDS6 Illegal Shared Face (V3) Excel Spreadsheet",
      &xmPushButtonWidgetClass,'!',NULL,NULL,
      (void (*)())open_doc, (XtPointer) DOC_TDSISF6,      (MenuItem *) NULL },	  

   { "Open TDS4 Illegal Shared Curve (V3) Excel Spreadsheet",
      &xmPushButtonWidgetClass,'!',NULL,NULL,
      (void (*)())open_doc, (XtPointer) DOC_TDSISL4,      (MenuItem *) NULL },	  

   { "Open TDS6 Illegal Shared Curve (V2) Excel Spreadsheet",
      &xmPushButtonWidgetClass,'!',NULL,NULL,
      (void (*)())open_doc, (XtPointer) DOC_TDSISL6,      (MenuItem *) NULL },	  

   { "Open TDS6 Illogical Attribute Enumeration (V6) Excel Spreadsheet",
      &xmPushButtonWidgetClass,'!',NULL,NULL,
      (void (*)())open_doc, (XtPointer) DOC_TDSIAE,      (MenuItem *) NULL },	  

	{NULL},
  };


  static MenuItem mprofile_menu[] = 
  {
    { "Open GAIT Master Profile Document",
      &xmPushButtonWidgetClass,'!',NULL,NULL,
      (void (*)())open_doc, (XtPointer) DOC_XWALK,     (MenuItem *) NULL },
	{NULL},
  };



  MenuItem Help_Menu[] = {
    { "General Help",&xmPushButtonWidgetClass, '!',NULL,NULL,
      (void (*)())helpCallback, NULL, (MenuItem *) NULL },
    { "Attribution Help",&xmPushButtonWidgetClass,'!',NULL,NULL,
      (void (*)())sdcsCallback, NULL, (MenuItem *) NULL },
    { "GAIT Documentation", &xmCascadeButtonWidgetClass, '!', NULL, NULL,
      0, 0, documentation_menu },
    { "Master Profile Documentation", &xmCascadeButtonWidgetClass, '!', NULL, NULL,
      0, 0, mprofile_menu },
    { "Schema Documentation", &xmCascadeButtonWidgetClass, '!', NULL, NULL,
      0, 0, documentation_menu2 },
    { "NGA Documentation", &xmCascadeButtonWidgetClass, '!', NULL, NULL,
      0, 0, documentation_menu3 },
    { "MGCP Documentation", &xmCascadeButtonWidgetClass, '!', NULL, NULL,
      0, 0, documentation_menu4 },
    { "TDS Documentation", &xmCascadeButtonWidgetClass, '!', NULL, NULL,
      0, 0, documentation_menu5 },

    { "",&xmSeparatorWidgetClass, '!',NULL,NULL,
      (void (*)())NULL, NULL, (MenuItem *) NULL },
    { "About GAIT",&xmPushButtonWidgetClass, '!',NULL,NULL,
      (void (*)())creditCallback, NULL, (MenuItem *) NULL },



    

    {NULL},
  };
  




#else

  MenuItem Help_Menu[] = {
    { "General Help",&xmPushButtonWidgetClass, '!',"Ctrl<Key>H","Ctrl+h",
      (void (*)())helpCallback, NULL, (MenuItem *) NULL },
    { "EDCS/Attribution Help Window",&xmPushButtonWidgetClass, '!',"Ctrl<Key>W","Ctrl+w",
      (void (*)())sdcsCallback, NULL, (MenuItem *) NULL },
    { "Load MI file (miNetwork.txt)",&xmPushButtonWidgetClass,'!',NULL,NULL,
      (void (*)())LoadMICallback, NULL, (MenuItem *) NULL },
    {NULL},
  };
#endif



  MenuItem Help_Menu2[] = {
    { "Escape from current zoom and leave results",&xmPushButtonWidgetClass, 
      '!', "<Key>Escape","Escape",
      (void (*)())escapeCallback, (XtPointer)NULL,(MenuItem *) NULL},
    
    {NULL},
  };


  static char plus_bits[] =
  {
    (char)0x18, (char)0x18, (char)0x18, (char)0xff, (char)0xff, (char)0x18, (char)0x18, (char)0x18
  };

  static char minus_bits[] =
  {
    (char)0x00, (char)0x00, (char)0x00, (char)0xff, (char)0xff, (char)0x00, (char)0x00, (char)0x00
  };

  static char plus_insen_bits[] =
  {
    (char)0x10, (char)0x08, (char)0x10, (char)0xaa, (char)0x55, (char)0x08, (char)0x10, (char)0x08
  };

  static char minus_insen_bits[] =
  {
    (char)0x00, (char)0x00, (char)0x00, (char)0xaa, (char)0x55, (char)0x00, (char)0x00, (char)0x00
  };
  

  static char zoom_bits[] = {
    (char)0xe0, (char)0x01, (char)0x18, (char)0x06, (char)0x04, (char)0x08, (char)0x02, (char)0x10, 
    (char)0x02, (char)0x10, (char)0x01, (char)0x20, (char)0x01, (char)0x20, (char)0x01, (char)0x20, 
    (char)0x01, (char)0x20, (char)0x02, (char)0x10, (char)0x02, (char)0x10, (char)0x04, (char)0x18,
    (char)0x18, (char)0x3e, (char)0xe0, (char)0x7d, (char)0x00, (char)0x78, (char)0x00, (char)0x70};

  static char zoom_insen_bits[] = {
    (char)0x40, (char)0x01, (char)0x10, (char)0x04, (char)0x04, (char)0x00, (char)0x00, (char)0x10, 
    (char)0x02, (char)0x00, (char)0x00, (char)0x20, (char)0x01, (char)0x00, (char)0x00, (char)0x20, 
    (char)0x01, (char)0x00, (char)0x00, (char)0x10, (char)0x02, (char)0x00, (char)0x00, (char)0x10,
    (char)0x08, (char)0x2a, (char)0xa0, (char)0x54, (char)0x00, (char)0x28, (char)0x00, (char)0x50};



  static char left_bits[] = {
    (char)0x80, (char)0x00, (char)0xc0, (char)0x00, (char)0xe0, (char)0x00, (char)0xf0, (char)0x00, 
    (char)0xf8, (char)0xff, (char)0xfc, (char)0xff, (char)0xfe, (char)0xff, (char)0xff, (char)0xff, 
    (char)0xfe, (char)0xff, (char)0xfc, (char)0xff, (char)0xf8, (char)0xff, (char)0xf0, (char)0x00, 
    (char)0xe0, (char)0x00, (char)0xc0, (char)0x00, (char)0x80, (char)0x00, (char)0x00, (char)0x00};

  static char left_insen_bits[] = {
    (char)0x00, (char)0x00, (char)0x40, (char)0x00, (char)0x00, (char)0x00, (char)0x50, (char)0x00, 
    (char)0x00, (char)0x00, (char)0x54, (char)0x55, (char)0x00, (char)0x00, (char)0x55, (char)0x55, 
    (char)0x00, (char)0x00, (char)0x54, (char)0x55, (char)0x00, (char)0x00, (char)0x50, (char)0x00,
    (char)0x00, (char)0x00, (char)0x40, (char)0x00, (char)0x00, (char)0x00, (char)0x00, (char)0x00};
  
  static char right_bits[] = {
    (char)0x00, (char)0x01, (char)0x00, (char)0x03, (char)0x00, (char)0x07, (char)0x00, (char)0x0f, 
    (char)0xff, (char)0x1f, (char)0xff, (char)0x3f, (char)0xff, (char)0x7f, (char)0xff, (char)0xff, 
    (char)0xff, (char)0x7f, (char)0xff, (char)0x3f, (char)0xff, (char)0x1f, (char)0x00, (char)0x0f,
    (char)0x00, (char)0x07, (char)0x00, (char)0x03, (char)0x00, (char)0x01, (char)0x00, (char)0x00};

  static char right_insen_bits[] = {
    (char)0x00, (char)0x00, (char)0x00, (char)0x02, (char)0x00, (char)0x00, (char)0x00, (char)0x0a, 
    (char)0x00, (char)0x00, (char)0xaa, (char)0x2a, (char)0x00, (char)0x00, (char)0xaa, (char)0xaa, 
    (char)0x00, (char)0x00, (char)0xaa, (char)0x2a, (char)0x00, (char)0x00, (char)0x00, (char)0x0a,
    (char)0x00, (char)0x00, (char)0x00, (char)0x02, (char)0x00, (char)0x00, (char)0x00, (char)0x00};
    



  static char in_bits[] = {
    (char)0x01, (char)0x80, (char)0x02, (char)0x40, (char)0x24, (char)0x24, (char)0x38, (char)0x1c, 
    (char)0x38, (char)0x1c, (char)0x3c, (char)0x3c, (char)0x00, (char)0x00, (char)0x00, (char)0x00, 
    (char)0x00, (char)0x00, (char)0x00, (char)0x00, (char)0x3c, (char)0x3c, (char)0x38, (char)0x1c, 
    (char)0x38, (char)0x1c, (char)0x24, (char)0x24, (char)0x02, (char)0x40, (char)0x01, (char)0x80};

  static char in_insen_bits[] = {
    (char)0x01, (char)0x80, (char)0x00, (char)0x00, (char)0x24, (char)0x24, (char)0x10, (char)0x08, 
    (char)0x28, (char)0x14, (char)0x34, (char)0x2c, (char)0x00, (char)0x00, (char)0x00, (char)0x00, 
    (char)0x00, (char)0x00, (char)0x00, (char)0x00, (char)0x34, (char)0x2c, (char)0x28, (char)0x14,
    (char)0x10, (char)0x08, (char)0x24, (char)0x24, (char)0x00, (char)0x00, (char)0x01, (char)0x80};
  
  

  static char out_bits[] = {
    (char)0x0f, (char)0xf0, (char)0x07, (char)0xe0, (char)0x07, (char)0xe0, (char)0x09, (char)0x90, 
    (char)0x10, (char)0x08, (char)0x20, (char)0x04, (char)0x00, (char)0x00, (char)0x00, (char)0x00, 
    (char)0x00, (char)0x00, (char)0x00, (char)0x00, (char)0x20, (char)0x04, (char)0x10, (char)0x08, 
    (char)0x09, (char)0x90, (char)0x07, (char)0xe0, (char)0x07, (char)0xe0, (char)0x0f, (char)0xf0};

  static char out_insen_bits[] = {
    (char)0x0b, (char)0xd0, (char)0x05, (char)0xa0, (char)0x02, (char)0x40, (char)0x09, (char)0x90, 
    (char)0x00, (char)0x00, (char)0x20, (char)0x04, (char)0x00, (char)0x00, (char)0x00, (char)0x00, 
    (char)0x00, (char)0x00, (char)0x00, (char)0x00, (char)0x20, (char)0x04, (char)0x00, (char)0x00,
    (char)0x09, (char)0x90, (char)0x02, (char)0x40, (char)0x05, (char)0xa0, (char)0x0b, (char)0xd0};
  
  


  static char hand_bits[] = {
    (char)0x80, (char)0x01, (char)0x58, (char)0x0e, (char)0x64, (char)0x12, (char)0x64, (char)0x52, 
    (char)0x48, (char)0xb2, (char)0x48, (char)0x92, (char)0x16, (char)0x90, (char)0x19, (char)0x80,
    (char)0x11, (char)0x40, (char)0x02, (char)0x40, (char)0x04, (char)0x40, (char)0x04, (char)0x20,
    (char)0x08, (char)0x20, (char)0x10, (char)0x10, (char)0x20, (char)0x10, (char)0x20, (char)0x10};
  
  static char hand_insen_bits[] = {
    (char)0x80, (char)0x00, (char)0x48, (char)0x0a, (char)0x20, (char)0x10, (char)0x44, (char)0x42, 
    (char)0x00, (char)0x10, (char)0x48, (char)0x82, (char)0x14, (char)0x10, (char)0x01, (char)0x80, 
    (char)0x10, (char)0x00, (char)0x02, (char)0x40, (char)0x00, (char)0x00, (char)0x04, (char)0x20,
    (char)0x00, (char)0x00, (char)0x10, (char)0x10, (char)0x00, (char)0x00, (char)0x20, (char)0x10};
  


 




  static char ruler_bits[] = {
    (char)0xc0, (char)0x01, (char)0x20, (char)0x02, (char)0x00, (char)0x02, (char)0x00, (char)0x01, 
    (char)0x84, (char)0x10, (char)0x86, (char)0x30, (char)0x3f, (char)0x7e, (char)0x86, (char)0x30, 
    (char)0x04, (char)0x10, (char)0x00, (char)0x00, (char)0xff, (char)0x7f, (char)0x55, (char)0x55,
    (char)0x01, (char)0x40, (char)0xff, (char)0x7f, (char)0x00, (char)0x00, (char)0x00, (char)0x00};

  static char ruler_insen_bits[] = {
    (char)0x80, (char)0x00, (char)0x20, (char)0x02, (char)0x00, (char)0x00, (char)0x00, (char)0x01, 
    (char)0x04, (char)0x10, (char)0x82, (char)0x20, (char)0x2d, (char)0x5a, (char)0x82, (char)0x20, 
    (char)0x04, (char)0x10, (char)0x00, (char)0x00, (char)0x55, (char)0x55, (char)0x55, (char)0x55,
    (char)0x00, (char)0x00, (char)0x55, (char)0x55, (char)0x00, (char)0x00, (char)0x00, (char)0x00};


  static char info_bits[] = {
    (char)0xe0, (char)0x07, (char)0xf0, (char)0x0f, (char)0x38, (char)0x1c, (char)0x18, (char)0x18, 
    (char)0x38, (char)0x18, (char)0x30, (char)0x1c, (char)0x00, (char)0x0e, (char)0x00, (char)0x07, 
    (char)0x80, (char)0x03, (char)0xc0, (char)0x01, (char)0x40, (char)0x01, (char)0x78, (char)0x0f,
    (char)0x70, (char)0x07, (char)0x60, (char)0x03, (char)0xc0, (char)0x01, (char)0x80, (char)0x00};

  static char info_insen_bits[] = {
    (char)0xe0, (char)0x07, (char)0x10, (char)0x0c, (char)0x18, (char)0x18, (char)0x08, (char)0x10, 
    (char)0x18, (char)0x10, (char)0x10, (char)0x18, (char)0x00, (char)0x0c, (char)0x00, (char)0x06, 
    (char)0x00, (char)0x03, (char)0x80, (char)0x00, (char)0x40, (char)0x01, (char)0x28, (char)0x0a,
    (char)0x50, (char)0x05, (char)0x20, (char)0x02, (char)0x40, (char)0x01, (char)0x80, (char)0x00};


static char refresh_bits[] = {
   (char)0xc0, (char)0x03, (char)0x80, (char)0x07, (char)0x10, (char)0x0f, (char)0x38, (char)0x1e, 
   (char)0x7c, (char)0x1c, (char)0xfe, (char)0x1c, (char)0xff, (char)0x1d, (char)0x38, (char)0x1c, 
   (char)0x38, (char)0x1c, (char)0xb8, (char)0xff, (char)0x38, (char)0x7f, (char)0x38, (char)0x3e,
   (char)0x78, (char)0x1c, (char)0xf0, (char)0x08, (char)0xe0, (char)0x01, (char)0xc0, (char)0x03};

static char refresh_insen_bits[] = {
   (char)0x80, (char)0x02, (char)0x00, (char)0x05, (char)0x00, (char)0x0a, (char)0x10, (char)0x14, 
   (char)0x28, (char)0x08, (char)0x54, (char)0x14, (char)0xaa, (char)0x08, (char)0x10, (char)0x14, 
   (char)0x28, (char)0x08, (char)0x10, (char)0x55, (char)0x28, (char)0x2a, (char)0x10, (char)0x14,
   (char)0x28, (char)0x08, (char)0x50, (char)0x00, (char)0xa0, (char)0x00, (char)0x40, (char)0x01};


  static char bitmap_bits[] = {
    (char)0x11, (char)0x11, (char)0x00, (char)0x00, (char)0x44, (char)0x44, (char)0x00, (char)0x00, 
    (char)0x11, (char)0x11, (char)0x00, (char)0x00, (char)0x44, (char)0x44, (char)0x00, (char)0x00, 
    (char)0x11, (char)0x11, (char)0x00, (char)0x00, (char)0x44, (char)0x44, (char)0x00, (char)0x00, 
    (char)0x11, (char)0x11, (char)0x00, (char)0x00, (char)0x44, (char)0x44, (char)0x00, (char)0x00};
  
  static char bitmap_lgt_bits[] = {
    (char)0x11, (char)0x11, (char)0x00, (char)0x00, (char)0x00, (char)0x00, (char)0x00, (char)0x00, 
    (char)0x11, (char)0x11, (char)0x00, (char)0x00, (char)0x00, (char)0x00, (char)0x00, (char)0x00, 
    (char)0x11, (char)0x11, (char)0x00, (char)0x00, (char)0x00, (char)0x00, (char)0x00, (char)0x00, 
    (char)0x11, (char)0x11, (char)0x00, (char)0x00, (char)0x00, (char)0x00, (char)0x00, (char)0x00};

  static char bitmap_hvy_bits[] = {
    (char)0x55, (char)0x55, (char)0x00, (char)0x00, (char)0x55, (char)0x55, (char)0x00, (char)0x00, 
    (char)0x55, (char)0x55, (char)0x00, (char)0x00, (char)0x55, (char)0x55, (char)0x00, (char)0x00, 
    (char)0x55, (char)0x55, (char)0x00, (char)0x00, (char)0x55, (char)0x55, (char)0x00, (char)0x00, 
    (char)0x55, (char)0x55, (char)0x00, (char)0x00, (char)0x55, (char)0x55, (char)0x00, (char)0x00};


  
  static char light_horiz_bits[] = {
    (char)0x00, (char)0x00, (char)0x00, (char)0x00, (char)0x00, (char)0x00, (char)0xff, (char)0xff, 
    (char)0x00, (char)0x00, (char)0x00, (char)0x00, (char)0x00, (char)0x00, (char)0x00, (char)0x00, 
    (char)0x00, (char)0x00, (char)0x00, (char)0x00, (char)0x00, (char)0x00, (char)0xff, (char)0xff,
    (char)0x00, (char)0x00, (char)0x00, (char)0x00, (char)0x00, (char)0x00, (char)0x00, (char)0x00};
  
  static char dense_horiz_bits[] = {
    (char)0x00, (char)0x00, (char)0xff, (char)0xff, (char)0x00, (char)0x00, (char)0x00, (char)0x00, 
    (char)0x00, (char)0x00, (char)0xff, (char)0xff, (char)0x00, (char)0x00, (char)0x00, (char)0x00, 
    (char)0x00, (char)0x00, (char)0xff, (char)0xff, (char)0x00, (char)0x00, (char)0x00, (char)0x00,
    (char)0x00, (char)0x00, (char)0xff, (char)0xff, (char)0x00, (char)0x00, (char)0x00, (char)0x00};
  
  static char light_vert_bits[] = {
    (char)0x08, (char)0x08, (char)0x08, (char)0x08, (char)0x08, (char)0x08, (char)0x08, (char)0x08, 
    (char)0x08, (char)0x08, (char)0x08, (char)0x08, (char)0x08, (char)0x08, (char)0x08, (char)0x08, 
    (char)0x08, (char)0x08, (char)0x08, (char)0x08, (char)0x08, (char)0x08, (char)0x08, (char)0x08,
    (char)0x08, (char)0x08, (char)0x08, (char)0x08, (char)0x08, (char)0x08, (char)0x08, (char)0x08};

  static char dense_vert_bits[] = {
    (char)0x22, (char)0x22, (char)0x22, (char)0x22, (char)0x22, (char)0x22, (char)0x22, (char)0x22, 
    (char)0x22, (char)0x22, (char)0x22, (char)0x22, (char)0x22, (char)0x22, (char)0x22, (char)0x22, 
    (char)0x22, (char)0x22, (char)0x22, (char)0x22, (char)0x22, (char)0x22, (char)0x22, (char)0x22,
    (char)0x22, (char)0x22, (char)0x22, (char)0x22, (char)0x22, (char)0x22, (char)0x22, (char)0x22};

  
  static char nesw_bits[] = {
    (char)0x80, (char)0x80, (char)0x40, (char)0x40, (char)0x20, (char)0x20, (char)0x10, (char)0x10, 
    (char)0x08, (char)0x08, (char)0x04, (char)0x04, (char)0x02, (char)0x02, (char)0x01, (char)0x01, 
    (char)0x80, (char)0x80, (char)0x40, (char)0x40, (char)0x20, (char)0x20, (char)0x10, (char)0x10,
    (char)0x08, (char)0x08, (char)0x04, (char)0x04, (char)0x02, (char)0x02, (char)0x01, (char)0x01};
  
  static char nwse_bits[] = {
    (char)0x01, (char)0x01, (char)0x02, (char)0x02, (char)0x04, (char)0x04, (char)0x08, (char)0x08, 
    (char)0x10, (char)0x10, (char)0x20, (char)0x20, (char)0x40, (char)0x40, (char)0x80, (char)0x80, 
    (char)0x01, (char)0x01, (char)0x02, (char)0x02, (char)0x04, (char)0x04, (char)0x08, (char)0x08,
    (char)0x10, (char)0x10, (char)0x20, (char)0x20, (char)0x40, (char)0x40, (char)0x80, (char)0x80};


  static char sparse_nwse_bits[] = {
    (char)0x01, (char)0x00, (char)0x02, (char)0x00, (char)0x04, (char)0x00, (char)0x08, (char)0x00, 
    (char)0x10, (char)0x00, (char)0x20, (char)0x00, (char)0x40, (char)0x00, (char)0x80, (char)0x00, 
    (char)0x00, (char)0x01, (char)0x00, (char)0x02, (char)0x00, (char)0x04, (char)0x00, (char)0x08,
    (char)0x00, (char)0x10, (char)0x00, (char)0x20, (char)0x00, (char)0x40, (char)0x00, (char)0x80};
  
  static char sparse_nesw_bits[] = {
    (char)0x00, (char)0x80, (char)0x00, (char)0x40, (char)0x00, (char)0x20, (char)0x00, (char)0x10, 
    (char)0x00, (char)0x08, (char)0x00, (char)0x04, (char)0x00, (char)0x02, (char)0x00, (char)0x01, 
    (char)0x80, (char)0x00, (char)0x40, (char)0x00, (char)0x20, (char)0x00, (char)0x10, (char)0x00,
    (char)0x08, (char)0x00, (char)0x04, (char)0x00, (char)0x02, (char)0x00, (char)0x01, (char)0x00};
  




  static char seeit_bits[] = {
    (char)0x00, (char)0x00, (char)0x00, (char)0x00, (char)0x00, (char)0x00, (char)0xfc, (char)0x3f, (char)0xfe, 
    (char)0x3f, (char)0xfe, (char)0x3f, (char)0xfc, (char)0x3f, (char)0xfe, (char)0x3f, (char)0xfe, (char)0x3f, 
    (char)0xfc, (char)0x3f, (char)0xfe, (char)0x3f, (char)0xfe, (char)0x3f, (char)0xfc, (char)0x3f, (char)0xfe, 
    (char)0x3f, (char)0xfe, (char)0x3f, (char)0x3c, (char)0x00, (char)0x1e, (char)0x00, (char)0x1e, (char)0x00,
    (char)0x3c, (char)0x00, (char)0x1e, (char)0x00, (char)0x1e, (char)0x00, (char)0x3c, (char)0x00, (char)0x1e, 
    (char)0x00, (char)0x1e, (char)0x00, (char)0x3c, (char)0x00, (char)0x1e, (char)0x00, (char)0x1e, (char)0x00, 
    (char)0x3c, (char)0x00, (char)0x1e, (char)0x00, (char)0x1e, (char)0x00, (char)0xfc, (char)0x3f, (char)0xfe, 
    (char)0x03, (char)0xfe, (char)0x03, (char)0xfc, (char)0x3f, (char)0xfe, (char)0x03, (char)0xfe, (char)0x03,
    (char)0xfc, (char)0x3f, (char)0xfe, (char)0x03, (char)0xfe, (char)0x03, (char)0xfc, (char)0x3f, (char)0xfe, 
    (char)0x03, (char)0xfe, (char)0x03, (char)0x00, (char)0x3c, (char)0x1e, (char)0x00, (char)0x1e, (char)0x00, 
    (char)0x00, (char)0x3c, (char)0x1e, (char)0x00, (char)0x1e, (char)0x00, (char)0x00, (char)0x3c, (char)0x1e, 
    (char)0x00, (char)0x1e, (char)0x00, (char)0x00, (char)0x3c, (char)0x1e, (char)0x00, (char)0x1e, (char)0x00,
    (char)0x00, (char)0x3c, (char)0x1e, (char)0x00, (char)0x1e, (char)0x00, (char)0xfc, (char)0x3f, (char)0xfe, 
    (char)0x3f, (char)0xfe, (char)0x3f, (char)0xfc, (char)0x3f, (char)0xfe, (char)0x3f, (char)0xfe, (char)0x3f, 
    (char)0xfc, (char)0x3f, (char)0xfe, (char)0x3f, (char)0xfe, (char)0x3f, (char)0xfc, (char)0x3f, (char)0xfe, 
    (char)0x3f, (char)0xfe, (char)0x3f, (char)0x00, (char)0x00, (char)0x00, (char)0x00, (char)0x00, (char)0x00,
    (char)0x00, (char)0x00, (char)0x00, (char)0x00, (char)0x00, (char)0x00, (char)0xf0, (char)0xff, (char)0x7f, 
    (char)0xfe, (char)0xff, (char)0x0f, (char)0xf0, (char)0xff, (char)0x7f, (char)0xfe, (char)0xff, (char)0x0f, 
    (char)0xf0, (char)0xff, (char)0x7f, (char)0xfe, (char)0xff, (char)0x0f, (char)0xf0, (char)0xff, (char)0x7f, 
    (char)0xfe, (char)0xff, (char)0x0f, (char)0x00, (char)0xf8, (char)0x00, (char)0x00, (char)0x1f, (char)0x00,
    (char)0x00, (char)0xf8, (char)0x00, (char)0x00, (char)0x1f, (char)0x00, (char)0x00, (char)0xf8, (char)0x00, 
    (char)0x00, (char)0x1f, (char)0x00, (char)0x00, (char)0xf8, (char)0x00, (char)0x00, (char)0x1f, (char)0x00, 
    (char)0x00, (char)0xf8, (char)0x00, (char)0x00, (char)0x1f, (char)0x00, (char)0x00, (char)0xf8, (char)0x00, 
    (char)0x00, (char)0x1f, (char)0x00, (char)0x00, (char)0xf8, (char)0x00, (char)0x00, (char)0x1f, (char)0x00,
    (char)0x00, (char)0xf8, (char)0x00, (char)0x00, (char)0x1f, (char)0x00, (char)0x00, (char)0xf8, (char)0x00, 
    (char)0x00, (char)0x1f, (char)0x00, (char)0x00, (char)0xf8, (char)0x00, (char)0x00, (char)0x1f, (char)0x00, 
    (char)0x00, (char)0xf8, (char)0x00, (char)0x00, (char)0x1f, (char)0x00, (char)0x00, (char)0xf8, (char)0x00, 
    (char)0x00, (char)0x1f, (char)0x00, (char)0x00, (char)0xf8, (char)0x00, (char)0x00, (char)0x1f, (char)0x00,
    (char)0x00, (char)0xf8, (char)0x00, (char)0x00, (char)0x1f, (char)0x00, (char)0xf0, (char)0xff, (char)0x7f, 
    (char)0x00, (char)0x1f, (char)0x00, (char)0xf0, (char)0xff, (char)0x7f, (char)0x00, (char)0x1f, (char)0x00, 
    (char)0xf0, (char)0xff, (char)0x7f, (char)0x00, (char)0x1f, (char)0x00, (char)0xf0, (char)0xff, (char)0x7f, 
    (char)0x00, (char)0x1f, (char)0x00, (char)0x00, (char)0x00, (char)0x00, (char)0x00, (char)0x00, (char)0x00};



  static  char gaitbits_bits[] = {
   (char)0xc0, (char)0xff, (char)0x00, (char)0x00, (char)0xfe, (char)0x03, (char)0xe0, (char)0xff, (char)0x03, (char)0x00, (char)0xff, (char)0x07,
   (char)0xf0, (char)0xff, (char)0x07, (char)0x80, (char)0xff, (char)0x0f, (char)0x78, (char)0x00, (char)0x0f, (char)0xc0, (char)0x03, (char)0x1e,
   (char)0x3c, (char)0x00, (char)0x1e, (char)0xe0, (char)0x01, (char)0x3c, (char)0x1e, (char)0x00, (char)0x1c, (char)0xf0, (char)0x00, (char)0x78,
   (char)0x0f, (char)0x00, (char)0x00, (char)0x78, (char)0x00, (char)0xf0, (char)0x07, (char)0x00, (char)0x00, (char)0x38, (char)0x00, (char)0xe0,
   (char)0x07, (char)0x00, (char)0x00, (char)0x38, (char)0x00, (char)0xe0, (char)0x07, (char)0xfe, (char)0x07, (char)0xf8, (char)0xff, (char)0xff,
   (char)0x07, (char)0xfe, (char)0x0f, (char)0xf8, (char)0xff, (char)0xff, (char)0x07, (char)0xfe, (char)0x1f, (char)0xf8, (char)0xff, (char)0xff,
   (char)0x07, (char)0x00, (char)0x1c, (char)0x38, (char)0x00, (char)0xe0, (char)0x07, (char)0x00, (char)0x1c, (char)0x38, (char)0x00, (char)0xe0,
   (char)0x0f, (char)0x00, (char)0x1c, (char)0x38, (char)0x00, (char)0xe0, (char)0x1e, (char)0x00, (char)0x1e, (char)0x38, (char)0x00, (char)0xe0,
   (char)0x3c, (char)0x00, (char)0x0f, (char)0x38, (char)0x00, (char)0xe0, (char)0x78, (char)0x80, (char)0x07, (char)0x38, (char)0x00, (char)0xe0,
   (char)0xf0, (char)0xff, (char)0x03, (char)0x38, (char)0x00, (char)0xe0, (char)0xe0, (char)0xff, (char)0x01, (char)0x38, (char)0x00, (char)0xe0,
   (char)0xc0, (char)0xff, (char)0x00, (char)0x38, (char)0x00, (char)0xe0, (char)0x00, (char)0x00, (char)0x00, (char)0x00, (char)0x00, (char)0x00,
   (char)0x00, (char)0x00, (char)0x00, (char)0x00, (char)0x00, (char)0x00, (char)0x00, (char)0x00, (char)0x00, (char)0x00, (char)0x00, (char)0x00,
   (char)0x00, (char)0x00, (char)0x00, (char)0x00, (char)0x00, (char)0x00, (char)0x00, (char)0x00, (char)0x00, (char)0x00, (char)0x00, (char)0x00,
   (char)0x00, (char)0x00, (char)0x00, (char)0x00, (char)0x00, (char)0x00, (char)0xff, (char)0xff, (char)0x1f, (char)0xf8, (char)0xff, (char)0xff,
   (char)0xff, (char)0xff, (char)0x1f, (char)0xf8, (char)0xff, (char)0xff, (char)0xff, (char)0xff, (char)0x1f, (char)0xf8, (char)0xff, (char)0xff,
   (char)0x00, (char)0x0e, (char)0x00, (char)0x00, (char)0x70, (char)0x00, (char)0x00, (char)0x0e, (char)0x00, (char)0x00, (char)0x70, (char)0x00,
   (char)0x00, (char)0x0e, (char)0x00, (char)0x00, (char)0x70, (char)0x00, (char)0x00, (char)0x0e, (char)0x00, (char)0x00, (char)0x70, (char)0x00,
   (char)0x00, (char)0x0e, (char)0x00, (char)0x00, (char)0x70, (char)0x00, (char)0x00, (char)0x0e, (char)0x00, (char)0x00, (char)0x70, (char)0x00,
   (char)0x00, (char)0x0e, (char)0x00, (char)0x00, (char)0x70, (char)0x00, (char)0x00, (char)0x0e, (char)0x00, (char)0x00, (char)0x70, (char)0x00,
   (char)0x00, (char)0x0e, (char)0x00, (char)0x00, (char)0x70, (char)0x00, (char)0x00, (char)0x0e, (char)0x00, (char)0x00, (char)0x70, (char)0x00,
   (char)0x00, (char)0x0e, (char)0x00, (char)0x00, (char)0x70, (char)0x00, (char)0x00, (char)0x0e, (char)0x00, (char)0x00, (char)0x70, (char)0x00,
   (char)0x00, (char)0x0e, (char)0x00, (char)0x00, (char)0x70, (char)0x00, (char)0x00, (char)0x0e, (char)0x00, (char)0x00, (char)0x70, (char)0x00,
   (char)0x00, (char)0x0e, (char)0x00, (char)0x00, (char)0x70, (char)0x00, (char)0xff, (char)0xff, (char)0x1f, (char)0x00, (char)0x70, (char)0x00,
   (char)0xff, (char)0xff, (char)0x1f, (char)0x00, (char)0x70, (char)0x00, (char)0xff, (char)0xff, (char)0x1f, (char)0x00, (char)0x70, (char)0x00};





  





  sprintf(VersionStrCopy,"%s",VersionStr);

  shapeimportoutputdir[0] = '\0';  

  ProcessEnvVars(NULL,0);


  if(!strcmp(shapeimportoutputdir,"NULL"))
  {
    shapeimportoutputdir[0] = '\0';
  }

  SetGAITHomeDir(argv[0]);


  
  VerifyCorrectLocation();


  AbsoluteAccuracy = 1;

  for(i=0;i<NUM_ATTR_SCHEMA+5;i++)
    {
      HAS_ID[i] = 1;
    }

  HAS_ID[5]  = 0; 
  HAS_ID[6]  = 0; 


  SaveLongCountsArea[C_POFE] = NULL;
  SaveLongCountsArea[C_LINE] = NULL;
  SaveLongCountsArea[C_AREA] = NULL;

  SaveLongCountsHgt[C_POFE] = NULL;
  SaveLongCountsHgt[C_LINE] = NULL;
  SaveLongCountsHgt[C_AREA] = NULL;

  SaveLongCountsLen[C_POFE] = NULL;
  SaveLongCountsLen[C_LINE] = NULL;
  SaveLongCountsLen[C_AREA] = NULL;

  SaveLongCountsNam[C_POFE] = NULL;
  SaveLongCountsNam[C_LINE] = NULL;
  SaveLongCountsNam[C_AREA] = NULL;

  SaveLongCountsId[C_POFE] = NULL;
  SaveLongCountsId[C_LINE] = NULL;
  SaveLongCountsId[C_AREA] = NULL;

  SaveLongCountsZv2[C_POFE] = NULL;
  SaveLongCountsZv2[C_LINE] = NULL;
  SaveLongCountsZv2[C_AREA] = NULL;


  if(NGA_TYPE==1)
    {
      FixDifferentDomains(0);
      InitializeAttribution();      
    }



  Sum1ESname[0]           = '\0';
  Sum2ESname[0]           = '\0';
  Sum3ESname[0]           = '\0';
  dp1name[0]              = '\0';
  XML1name[0]             = '\0';
  XML2name[0]             = '\0';
  XML3name[0]             = '\0';
  SaveSettingName[0]      = '\0';
  SaveReportName[0]       = '\0';
  SavePrefName[0]         = '\0';
  SaveAOIName[0]          = '\0';
  SaveLayerName[0]        = '\0';


  if((INscc_loop!=STRATSLEN)||(INscc_loop!=DOMAINSLEN))
    {      
      printf("bad sizes!\n");
      printf("sizes %d %d %d\n",INscc_loop,DOMAINSLEN,STRATSLEN);
    }




  




  if(NGA_TYPE==1)
    {
      
      
    }
  else
    {
      tempfile = fopen("EDCS_CSD.rdr","r");
      
      if(tempfile!=NULL)
	{
	  fgets(aline,1000,tempfile);
	  line++;
	  while(!feof(tempfile))
	    {
	      sscanf(aline,"%s%s%s",strat,dom,ecc);
	      snumber = ParseSNumber(strat,line,"EDCS_CSD.rdr");
	      dnumber = ParseDNumber(dom,line,"EDCS_CSD.rdr");
	      
	      newcode = GetNum(ecc);
	      if(newcode>0)
		{
		  STRATS[newcode] = snumber;
		  DOMAINS[newcode] = dnumber;
		}
	      fgets(aline,1000,tempfile);
	      line++;
	    }
	  
	  fclose(tempfile);
	}
    }

  


  for(i=0;i<INscc_loop;i++)
    {
      HyperClassUp[i] = 0;
    }
  for(i=0;i<INsac_loop;i++)
    {
      HyperAttrUp[i] = 0;
    }


  if(determine_machine_endianness()==0)
    {
      USE_LITTLE = 1;
    }
  else
    {
      USE_LITTLE = 0;
    }

  printf("UL %d\n",USE_LITTLE);

  if(USE_LITTLE==1)
    {
      machine_endianness = 0;
    }
  else
    {
      machine_endianness = 1;
    }

  if(USE_DOS==1)
  {
	  SLASHTYPE = DOS_TYPE;
  }
  else
  {
	  SLASHTYPE = NONDOS_TYPE;
	  old_file_browser = 1;
  }


  for(i=0;i<argc;i++)
  {
    len = strlen(argv[i]);
	for(j=0;j<len;j++)
	{
      if(argv[i][j]<32)
	  {
        argv[i][j] = '\0';
		break;
	  }
	}
  }




  if(
          (NGA_TYPE==1) &&
          (USE_DOS==1)  &&
          (argc==4)
         )
  { 
	if(!strcmp(argv[1],"-MGCP_XML"))
	{
      printf("Check MGCP XML %s version %s\n",argv[2],argv[3]);
	  if(BatchCheckMGCPXML(argv[2],argv[3])==0)
	  {
	    PrintUsage(argv[0]);
	  }
	  else
	  {
		printf("Done with batch mode XML checking\n");
	  }
	  ExitWrapper(-1);	  
	}
  }


  if(
          (NGA_TYPE==1) &&
          (USE_DOS==1)  &&
          (argc==5)
         )
  { 
    if(!strcmp(argv[1],"-MGCP_Packaging"))
	{
	  if(MGCPBatchPackageCheck(argv[2],argv[3],argv[4])==0)
	  {
	    PrintUsage(argv[0]);
	  }
	  ExitWrapper(-1);	  
	}
  }


  if(
          (NGA_TYPE==1) &&
          (USE_DOS==1)  &&
          (argc==6)
         )
  { 
    if(!strcmp(argv[1],"-MGCP_QA"))
	{ 
      doingQAcheck = 1; 
	  batch_mode = 1;
	} 
  }


  if(doingQAcheck==0)
  {

  if(
     (NGA_TYPE==1) &&
     (USE_DOS==1)  &&
     (argc==2)     &&
     (  (!strcmp(argv[1],"-nga"))  ||  (!strcmp(argv[1],"-nga2"))  ||  (!strcmp(argv[1],"-ngaD"))  )
     )
    {
      
      batch_mode = 0;

	  if(!strcmp(argv[1],"-nga2"))
	  {
		old_file_browser = 1;
	  }
	  if(!strcmp(argv[1],"-ngaD"))
	  {
		dev_options = 1;
	  }
    }
  else if(
	  (NGA_TYPE==1) &&
	  (USE_DOS==0)  &&
	  (argc==1)
	  )
    {
      
      batch_mode = 0;
    }
  else if(NGA_TYPE==1)
    {
      

	 

      if(argc<2)
	{
	  PrintUsage(argv[0]);
	  ExitWrapper(-1);
	}

      if(argc==2)
	{
	  if(
	     (strcmp(argv[1],"-help")) &&
	     (strcmp(argv[1],"help"))  &&
	     (strcmp(argv[1],"-h"))    &&
	     (strcmp(argv[1],"h"))
	     )
	    {
	      PrintUsage(argv[0]);
	      ExitWrapper(-1);	  
	    }
	  
	  PrintHelp(argv[0]);
	  ExitWrapper(-1);
	}

      if( 
		  (argc!=7) &&   
		  (argc!=8) &&   
		  (argc!=9) &&   
		  (argc!=10)&&   
		  (argc!=11)&&   
		  (argc!=12)     
		  )
	{
	  PrintUsage(argv[0]);
	  ExitWrapper(-1);	  
	}



      if(strcmp(argv[1],"-nogui"))
	{
	  PrintUsage(argv[0]);
	  ExitWrapper(-1);	  
	}

      
      if((argc==8) && (strcmp(argv[7],"-silent")))
	{
	  PrintUsage(argv[0]);
	  ExitWrapper(-1);	  
	}
      
      if(argc==10)
	  {
		 if( (strcmp(argv[7],"-silent"))  &&  (strcmp(argv[9],"-silent")) )
		 { 
	       PrintUsage(argv[0]);
	       ExitWrapper(-1);	  
		 } 
	  }

      if((argc==12) && (strcmp(argv[9],"-silent")))
	{
	  PrintUsage(argv[0]);
	  ExitWrapper(-1);	  
	}
      
     batchsilent = ((argc==8)||(argc==10)||(argc==12));

     if(argc==9)  
	 { 
       if (!strcmp(argv[7],"-markignore"))
	   {
          
          sprintf(batchignorename,"%s",argv[8]);

          batchignore = 1;
	   }
       else if (!strcmp(argv[7],"-specfile"))
	   {
          
          sprintf(specfilename,"%s",argv[8]);
		  batchuser = 1;
	   }
	   else 
	   {  
	     PrintUsage(argv[0]);
	     ExitWrapper(-1);	  
	   } 
	 }

     if(argc==10)
	 {
       if ( (!strcmp(argv[7],"-markignore")) && (!strcmp(argv[9],"-silent")) )
	   {
          
          sprintf(batchignorename,"%s",argv[8]);
          batchignore = 1;
	   }
       else if ( (!strcmp(argv[7],"-silent")) && (!strcmp(argv[8],"-specfile")) )
	   {
          
          sprintf(specfilename,"%s",argv[9]);
		  batchuser = 1;
	   }
	   else
	   {  
	     PrintUsage(argv[0]);
	     ExitWrapper(-1);	  
	   } 
	 }

	 if(argc==11)
	 {
       if ( (!strcmp(argv[7],"-markignore")) && (!strcmp(argv[9],"-specfile")) )
	   {
          
          sprintf(batchignorename,"%s",argv[8]);
          sprintf(specfilename,   "%s",argv[10]);
          batchignore = 1;
		  batchuser = 1;
	   }
	   else
	   {
	     PrintUsage(argv[0]);
	     ExitWrapper(-1);	  
	   }
	 }

	 if(argc==12)
	 {
       if ( (!strcmp(argv[7],"-markignore")) && (!strcmp(argv[9],"-silent")) && (!strcmp(argv[10],"-specfile")) )
	   {
          
          sprintf(batchignorename,"%s",argv[8]);
          sprintf(specfilename,   "%s",argv[11]);
          batchignore = 1;
		  batchuser   = 1;
	   }
	   else
	   {
	     PrintUsage(argv[0]);
	     ExitWrapper(-1);	  
	   }
	 }


      

      printf("\n\nsilent %d ignore %d user %d\n",batchsilent,batchignore,batchuser);

      if(batchignore>0)
	  {
        printf("   batch ignore name %s\n",batchignorename);
	  }
      if(batchuser>0)
	  {
        printf("   batch specfile %s\n",specfilename);
	  }




      sprintf(layer_pref_file,"Default (Baseline)");
      
      
      
      if(!strcmp(argv[6],"META_MGCPNGA"))
	{
	  METATYPE = 1;
	}
      else  if(!strcmp(argv[6],"META_ESRI"))
	{
	  METATYPE = 2;
	}
      else  if(!strcmp(argv[6],"META_INGR"))
	{
	  METATYPE = 3;
	}
      else
	{
	  printf("Bad metadata mapping argument: %s\n",argv[6]);
	  PrintUsage(argv[0]);
	  ExitWrapper(-1);
	}




      if(!strcmp(argv[3],"GIFD"))
	{
	  ATTRIBUTION_TYPE = 1;
	}
      else if(!strcmp(argv[3],"GIFDNUNANPO"))
	{
	  ATTRIBUTION_TYPE = 2;
	}
      else if(!strcmp(argv[3],"FACC"))
	{
	  ATTRIBUTION_TYPE = 3;
	}
      else if(!strcmp(argv[3],"FACCNUNANPO"))
	{
	  ATTRIBUTION_TYPE = 4;
	}
      else if(!strcmp(argv[3],"VMAP"))
	{
	  ATTRIBUTION_TYPE = 5;
	}
      else if(!strcmp(argv[3],"VMAPNUNANPO"))
	{
	  ATTRIBUTION_TYPE = 6;
	}
      else if(!strcmp(argv[3],"MGCP3"))
	{
	  ATTRIBUTION_TYPE = 7;
	  sprintf(layer_pref_file,"Default (MGCP)");
	}
      else if(!strcmp(argv[3],"MGCP4"))
	{
	  ATTRIBUTION_TYPE = 8;
	  sprintf(layer_pref_file,"Default (MGCP)");
	}
      else if(!strcmp(argv[3],"UFD1"))
	{
	  ATTRIBUTION_TYPE = 11;
	}
      else if(!strcmp(argv[3],"UFD1NUNANPO"))
	{
	  ATTRIBUTION_TYPE = 12;
	}
      else if(!strcmp(argv[3],"UFD2"))
	{
	  ATTRIBUTION_TYPE = 9;
	}
      else if(!strcmp(argv[3],"UFD2NUNANPO"))
	{
	  ATTRIBUTION_TYPE = 10;
	}
      else if(!strcmp(argv[3],"UFD3"))
	{
	  ATTRIBUTION_TYPE = 13;
	}
      else if(!strcmp(argv[3],"UFD3NUNANPO"))
	{
	  ATTRIBUTION_TYPE = 14;
	}




      else if(!strcmp(argv[3],"NFDD"))
	{
	  ATTRIBUTION_TYPE = 23;
	}
      else if(!strcmp(argv[3],"NFDDNUNANPO"))
	{
	  ATTRIBUTION_TYPE = 24;
	}
      else if(!strcmp(argv[3],"DFDD"))
	{
	  ATTRIBUTION_TYPE = 25;
	}
      else if(!strcmp(argv[3],"DFDDNUNANPO"))
	{
	  ATTRIBUTION_TYPE = 26;
	}

      else if(!strcmp(argv[3],"SAC"))  
	{
	  ATTRIBUTION_TYPE = 27;
	}
      else if(!strcmp(argv[3],"AFD")) 
	{
	  ATTRIBUTION_TYPE = 27;
	}

      else if(!strcmp(argv[3],"GGDM22"))
	{
	  ATTRIBUTION_TYPE = 29;
	}
      else if(!strcmp(argv[3],"GGDM21"))
	{
	  ATTRIBUTION_TYPE = 45;
	}
      else if(!strcmp(argv[3],"TDS4"))
	{
	  ATTRIBUTION_TYPE = 39;
	}
      else if(!strcmp(argv[3],"TDS6"))
	{
	  ATTRIBUTION_TYPE = 43;
	}
      else if(!strcmp(argv[3],"GGDM3"))
	{
	  ATTRIBUTION_TYPE = 47;
	}

      else if(!strcmp(argv[3],"TREX"))
	{ 
	  CREATING_TREX = 1;
	  ATTRIBUTION_TYPE = 26;
	}



    else
	{
	  printf("Bad attribution type %s\n",argv[3]);
	  PrintUsage(argv[0]);
	  ExitWrapper(-1);
	}


      TEMP_ATTRIBUTION_TYPE = ATTRIBUTION_TYPE;
      InitializeAttribution();
      batch_mode = 1;

    }





       
  if((argc!=5)&&(argc!=1)&&(argc!=2)&&(NGA_TYPE==0))
    {
      PrintUsage(argv[0]);
      ExitWrapper(-1);
    }

  if((argc==5)&&(NGA_TYPE==0))
    {
      batch_mode=1;
    }


  
  if((argc==2)&&(NGA_TYPE==0))
    {
      if(
	 (strcmp(argv[1],"-help")) &&
	 (strcmp(argv[1],"help"))  &&
	 (strcmp(argv[1],"-h"))    &&
	 (strcmp(argv[1],"h"))
	 )
	{
	  PrintUsage(argv[0]);
	  ExitWrapper(-1);	  
	}

      PrintHelp(argv[0]);
      ExitWrapper(-1);
    }
  } 


  if(USE_DOS==1)
  {
	if(batch_mode==1)
	{
      
	  

	  sprintf(temp,"set DISPLAY=127.0.0.1:0.0");
	  system(temp);
	  
	  sprintf(temp,"set XKEYSYMDB=.\\XKeysymDB");
	  system(temp);
	  
	  sprintf(temp,"\"%srungait26-runx.bat\"",GAIT_HOME_DIR);
	  system(temp);
	}
  }









  InitGrid();
  InitErrorStuff();


  InitOtherStuff();

  i = 0;

  putenv("display=127.0.0.1:0.0");
  putenv("xkeysymdb=.\\XKeysymDB");



  



  
  i = 0;

  if(NGA_TYPE==1)
  {
    W = XtAppInitialize(&app_context, "GAIT", 
		      (XrmOptionDescList)NULL , 0,
		      &i, 
              NULL,
		      fallbacks,NULL,(Cardinal)NULL);
  }
  else
  {
    W = XtAppInitialize(&app_context, "SEE-IT", 
		      (XrmOptionDescList)NULL , 0,
		      &i, 
              NULL,
		      fallbacks,NULL,(Cardinal)NULL);
  }


  if (W == NULL){printf("Couldnt get a window!\n"); ExitWrapper(-1);}



 


  actions.string = "draw";
  actions.proc = (XtActionProc)draw;
  XtAppAddActions (app_context, &actions, 1);

 
  actions2.string = "list_scroll";
  actions2.proc = (XtActionProc)list_scroll;
  XtAppAddActions (app_context, &actions2, 1);

  actions2.string = "list_scroll_spec";
  actions2.proc = (XtActionProc)list_scroll_spec;
  XtAppAddActions (app_context, &actions2, 1);

  actions2.string = "list_scroll_bo";
  actions2.proc = (XtActionProc)list_scroll_bo;
  XtAppAddActions (app_context, &actions2, 1);
 
  actions2.string = "list_scroll_vc";
  actions2.proc = (XtActionProc)list_scroll_vc;
  XtAppAddActions (app_context, &actions2, 1);

  actions2.string = "list_scroll_net";
  actions2.proc = (XtActionProc)list_scroll_net;
  XtAppAddActions (app_context, &actions2, 1);

  actions2.string = "RetainError";
  actions2.proc = (XtActionProc)RetainError;
  XtAppAddActions (app_context, &actions2, 1);
  
  actions2.string = "MakeSen";
  actions2.proc = (XtActionProc)MakeSen;
  XtAppAddActions (app_context, &actions2, 1);

  

  actions2.string = "ListPrevItem";
  actions2.proc = (XtActionProc)do_nothing;
  XtAppAddActions (app_context, &actions2, 1);
 
  actions2.string = "ListEndSelect";
  actions2.proc = (XtActionProc)do_nothing;
  XtAppAddActions (app_context, &actions2, 1);

  actions2.string = "ListBeginSelect";
  actions2.proc = (XtActionProc)do_nothing;
  XtAppAddActions (app_context, &actions2, 1);

  actions2.string = "ListNextItem";
  actions2.proc = (XtActionProc)do_nothing;
  XtAppAddActions (app_context, &actions2, 1);
 
  actions2.string = "ListKbdSelectAll";
  actions2.proc = (XtActionProc)do_nothing;
  XtAppAddActions (app_context, &actions2, 1);

  actions2.string = "ListKbdDeSelectAll";
  actions2.proc = (XtActionProc)do_nothing;
  XtAppAddActions (app_context, &actions2, 1);


  actions2.string = "ListExtendPrevItem";
  actions2.proc = (XtActionProc)do_nothing;
  XtAppAddActions (app_context, &actions2, 1);

  actions2.string = "ListExtendNextItem";
  actions2.proc = (XtActionProc)do_nothing;
  XtAppAddActions (app_context, &actions2, 1);

  actions2.string = "ListKbdEndExtend";
  actions2.proc = (XtActionProc)do_nothing;
  XtAppAddActions (app_context, &actions2, 1);

  actions2.string = "ListKbdCancel";
  actions2.proc = (XtActionProc)do_nothing;
  XtAppAddActions (app_context, &actions2, 1);







  actions2.string = "TimMoveList";
  actions2.proc = (XtActionProc)TimList;
  XtAppAddActions (app_context, &actions2, 1);


 


  actions2.string = "do_nothing2";
  actions2.proc = (XtActionProc)do_nothing2;
  XtAppAddActions (app_context, &actions2, 1);

  actions2.string = "RemoveAddMode";
  actions2.proc = (XtActionProc)remove_add_mode;
  XtAppAddActions (app_context, &actions2, 1);

  

  n = 0;
  XtSetArg(resources[n],XmNmaxWidth,                1030); n++; 
  XtSetArg(resources[n],XmNmaxHeight,                900); n++; 
  XtSetArg(resources[n],XmNheight,                   700); n++; 
  XtSetArg(resources[n],XmNwidth,                    930); n++; 
  XtSetArg(resources[n],XmNdefaultPosition,        False); n++; 
  XtSetArg(resources[n],XmNx,                         25); n++; 
  XtSetArg(resources[n],XmNy,                          5); n++; 


  if(NGA_TYPE==1)
    {
      sprintf(aline,"GAIT %s",VersionStr);
      XtSetArg(resources[n],XmNtitle,   aline); n++; 
    }
  else
    {
      XtSetArg(resources[n],XmNtitle,          "SEE-IT 2.2"); n++; 
    }
  XtSetArg(resources[n],XmNdeleteResponse,  XmDO_NOTHING); n++; 


  if(NGA_TYPE==1)
    {
      WW = XtCreatePopupShell("GAIT",topLevelShellWidgetClass,W,resources,n);
    }
  else
    {
      WW = XtCreatePopupShell("SEE-IT",topLevelShellWidgetClass,W,resources,n);
    }
  
  if(NGA_TYPE==1)
    {
      if(USE_DOS==1)
	{
	  icon_pix = XCreatePixmapFromBitmapData (XtDisplay (WW),
						  RootWindowOfScreen (XtScreen (WW)),
						  gaitbits_bits, 48,48, 0, 1, 1);
	}
      else
	{
	  icon_pix = XCreatePixmapFromBitmapData (XtDisplay (WW),
						  RootWindowOfScreen (XtScreen (WW)),
						  gaitbits_bits, 48,48, 1, 0, 1);
	}
    }
  else
    {
      icon_pix = XCreatePixmapFromBitmapData (XtDisplay (WW),
					      RootWindowOfScreen (XtScreen (WW)),
					      seeit_bits, 48,48, 1, 0, 1);
    }



  if(USE_LINUX==0)
  {
	
    XtVaSetValues (WW,
		 XmNiconPixmap, icon_pix,
		 NULL);
  }


  form = XtVaCreateWidget ("form1", xmFormWidgetClass, WW,
			    XmNfractionBase,  100,  
			    NULL);

  XtVaGetValues(form,XmNbackground,&mybackground,NULL);
  XtVaGetValues(form,XmNforeground,&myforeground,NULL);


  n = 0;
  XtSetArg(resources[n], XmNleftAttachment,   XmATTACH_FORM); n++;
  XtSetArg(resources[n], XmNbottomAttachment, XmATTACH_FORM); n++;



  rc = XmCreateRowColumn(form, "bottomStuff", resources, n); 

  menubar = XmCreateMenuBar (form, "menubar",NULL,0);
  cascade[0] = BuildPulldownMenu (menubar, "File",         'Y' , False, File_Menu);
  cascade[1] = BuildPulldownMenu2(menubar, "Mode",         'Y' , False, Mode_Menu);
  cascade[2] = BuildPulldownMenu (menubar, "View",         'Y' , False, View_Menu);
  cascade[3] = BuildPulldownMenu (menubar, "Inspection",   'Y' , False, Check_Menu);
  cascade[4] = BuildPulldownMenu (menubar, "Parameters",   'Y' , False, Params_Menu);
  cascade[5] = BuildPulldownMenu (menubar, "Help",         'Y' , False, Help_Menu);   
  XtManageChild(menubar);

 

  
  menubar2 = XmCreateMenuBar (form, "menubar2",NULL,0);
  BuildPulldownMenu (menubar2, "",         'Y' , True, Help_Menu2);   
  XtManageChild(menubar2);


 
  menubar2 = XmCreateMenuBar (form, "menubar2",NULL,0);
  BuildPulldownMenu (menubar2, "",         'Y' , True, Stack_Menu);   
  XtManageChild(menubar2);


  
  plus_pix = XCreatePixmapFromBitmapData (XtDisplay (WW),
					  RootWindowOfScreen (XtScreen (WW)),
					  plus_bits, 8,8, myforeground,mybackground,
					  DefaultDepthOfScreen(XtScreen(WW)));
  
  minus_pix = XCreatePixmapFromBitmapData (XtDisplay (WW),
					   RootWindowOfScreen (XtScreen (WW)),
					   minus_bits, 8,8, myforeground,mybackground,
					   DefaultDepthOfScreen(XtScreen(WW)));


  plus_insen_pix = XCreatePixmapFromBitmapData (XtDisplay (WW),
					  RootWindowOfScreen (XtScreen (WW)),
					  plus_insen_bits, 8,8, myforeground,mybackground,
					  DefaultDepthOfScreen(XtScreen(WW)));
  
  minus_insen_pix = XCreatePixmapFromBitmapData (XtDisplay (WW),
					   RootWindowOfScreen (XtScreen (WW)),
					   minus_insen_bits, 8,8, myforeground,mybackground,
					   DefaultDepthOfScreen(XtScreen(WW)));


  toolbar_pixmap[0] = XCreatePixmapFromBitmapData (XtDisplay(WW),RootWindowOfScreen (XtScreen (WW)),
						   left_bits, 16,16, myforeground, mybackground,
						   DefaultDepthOfScreen(XtScreen(WW)));
  toolbar_pixmap[1] = XCreatePixmapFromBitmapData (XtDisplay(WW),RootWindowOfScreen (XtScreen (WW)),
						   right_bits, 16,16, myforeground, mybackground,
						   DefaultDepthOfScreen(XtScreen(WW)));
  toolbar_pixmap[2] = XCreatePixmapFromBitmapData (XtDisplay(WW),RootWindowOfScreen (XtScreen (WW)),
						   zoom_bits, 16,16, myforeground, mybackground,
						   DefaultDepthOfScreen(XtScreen(WW)));
  toolbar_pixmap[3] = XCreatePixmapFromBitmapData (XtDisplay(WW),RootWindowOfScreen (XtScreen (WW)),
						   in_bits, 16,16, myforeground, mybackground,
						   DefaultDepthOfScreen(XtScreen(WW)));
  toolbar_pixmap[4] = XCreatePixmapFromBitmapData (XtDisplay(WW),RootWindowOfScreen (XtScreen (WW)),
						   out_bits, 16,16, myforeground, mybackground,
						   DefaultDepthOfScreen(XtScreen(WW)));

  
  toolbar_pixmap[5] = XCreatePixmapFromBitmapData (XtDisplay(WW),RootWindowOfScreen (XtScreen (WW)),
						   out_bits, 16,16, myforeground, mybackground,
						   DefaultDepthOfScreen(XtScreen(WW)));


  toolbar_insen_pixmap[0] = XCreatePixmapFromBitmapData (XtDisplay(WW),RootWindowOfScreen (XtScreen (WW)),
						   left_insen_bits, 16,16, myforeground, mybackground,
						   DefaultDepthOfScreen(XtScreen(WW)));
  toolbar_insen_pixmap[1] = XCreatePixmapFromBitmapData (XtDisplay(WW),RootWindowOfScreen (XtScreen (WW)),
						   right_insen_bits, 16,16, myforeground, mybackground,
						   DefaultDepthOfScreen(XtScreen(WW)));
  toolbar_insen_pixmap[2] = XCreatePixmapFromBitmapData (XtDisplay(WW),RootWindowOfScreen (XtScreen (WW)),
						   zoom_insen_bits, 16,16, myforeground, mybackground,
						   DefaultDepthOfScreen(XtScreen(WW)));
  toolbar_insen_pixmap[3] = XCreatePixmapFromBitmapData (XtDisplay(WW),RootWindowOfScreen (XtScreen (WW)),
						   in_insen_bits, 16,16, myforeground, mybackground,
						   DefaultDepthOfScreen(XtScreen(WW)));
  toolbar_insen_pixmap[4] = XCreatePixmapFromBitmapData (XtDisplay(WW),RootWindowOfScreen (XtScreen (WW)),
						   out_insen_bits, 16,16, myforeground, mybackground,
						   DefaultDepthOfScreen(XtScreen(WW)));

  
  toolbar_insen_pixmap[5] = XCreatePixmapFromBitmapData (XtDisplay(WW),RootWindowOfScreen (XtScreen (WW)),
						   out_insen_bits, 16,16, myforeground, mybackground,
						   DefaultDepthOfScreen(XtScreen(WW)));




  


  	  




  toolbar_pixmap[6] = XCreatePixmapFromBitmapData (XtDisplay(WW),RootWindowOfScreen (XtScreen (WW)),
						   hand_bits, 16,16, myforeground, mybackground,
						   DefaultDepthOfScreen(XtScreen(WW)));
  toolbar_insen_pixmap[6] = XCreatePixmapFromBitmapData (XtDisplay(WW),RootWindowOfScreen (XtScreen (WW)),
							 hand_insen_bits, 16,16, myforeground, mybackground,
							 DefaultDepthOfScreen(XtScreen(WW)));
  
  
  toolbar_pixmap[7] = XCreatePixmapFromBitmapData (XtDisplay(WW),RootWindowOfScreen (XtScreen (WW)),
						   ruler_bits, 16,16, myforeground, mybackground,
						   DefaultDepthOfScreen(XtScreen(WW)));
  toolbar_insen_pixmap[7] = XCreatePixmapFromBitmapData (XtDisplay(WW),RootWindowOfScreen (XtScreen (WW)),
							 ruler_insen_bits, 16,16, myforeground, mybackground,
							 DefaultDepthOfScreen(XtScreen(WW)));



  toolbar_pixmap[8] = XCreatePixmapFromBitmapData (XtDisplay(WW),RootWindowOfScreen (XtScreen (WW)),
						   info_bits, 16,16, myforeground, mybackground,
						   DefaultDepthOfScreen(XtScreen(WW)));
  toolbar_insen_pixmap[8] = XCreatePixmapFromBitmapData (XtDisplay(WW),RootWindowOfScreen (XtScreen (WW)),
							 info_insen_bits, 16,16, myforeground, mybackground,
							 DefaultDepthOfScreen(XtScreen(WW)));



  toolbar_pixmap[9] = XCreatePixmapFromBitmapData (XtDisplay(WW),RootWindowOfScreen (XtScreen (WW)),
						   refresh_bits, 16,16, myforeground, mybackground,
						   DefaultDepthOfScreen(XtScreen(WW)));
  toolbar_insen_pixmap[9] = XCreatePixmapFromBitmapData (XtDisplay(WW),RootWindowOfScreen (XtScreen (WW)),
							 refresh_insen_bits, 16,16, myforeground, mybackground,
							 DefaultDepthOfScreen(XtScreen(WW)));




if(XCG==1)
  {
    ToolTipMaster = XtCreatePopupShell( 
				       "popup_shell", 
				       xcgLiteClueWidgetClass, WW,
				       NULL,0);
  }


  for(i=0;i<TOOLNUM;i++)
    {
	  if(i==9)
	  {
		  toolbar[i] = NULL;
		  continue;
	  }


      if(i==0)
	{
	  toolbar[i]  = XtVaCreateManagedWidget("TOOLB1",xmPushButtonWidgetClass,form,
						XmNlabelType,       XmPIXMAP,
						XmNlabelPixmap,     toolbar_pixmap[i],
						XmNleftAttachment,  XmATTACH_WIDGET,
						XmNleftWidget,      menubar,
						XmNtraversalOn,     FALSE,
						XmNtranslations, XtParseTranslationTable ( translations_global ) ,
						NULL
						); 
	}
      else if(i==TOOLBAR_CLASS)
	{
	  t = XmStringCreateLtoR ("  Classification:  \n ",XmSTRING_DEFAULT_CHARSET);
	  
	  toolbar[i]  = XtVaCreateManagedWidget(" Classification Level   ",xmLabelWidgetClass,form,
						XmNlabelString,     t,
						XmNleftAttachment,  XmATTACH_WIDGET,
						XmNleftWidget,      toolbar[i-2],  
						XmNtraversalOn,     FALSE,
						LABELWTRANSLATE,
						NULL
						); 
	  
	  
	}
      else
	{
	  toolbar[i]  = XtVaCreateManagedWidget("TOOLB2",xmPushButtonWidgetClass,form,
						XmNlabelType,       XmPIXMAP,
						XmNlabelPixmap,     toolbar_pixmap[i],
						XmNleftAttachment,  XmATTACH_WIDGET,
						XmNleftWidget,      toolbar[i-1],
						XmNtraversalOn,     FALSE,
						XmNtranslations, XtParseTranslationTable ( translations_global ) ,
						NULL
						); 
	}
      XtManageChild(toolbar[i]);
      
      if(i!=TOOLBAR_CLASS)
	{
	  XtAddCallback (toolbar[i], XmNactivateCallback,toolbarCallback, (XtPointer)i);
	  
	  XtVaSetValues(toolbar[i], XmNlabelInsensitivePixmap,toolbar_insen_pixmap[i],NULL);
	}
    }

  if(XCG==1)
    {
      XcgLiteClueAddWidget(ToolTipMaster, toolbar[0], "Go back to previous view", 0, 0);
      XcgLiteClueAddWidget(ToolTipMaster, toolbar[1], "Go forward to next view", 0, 0);
      XcgLiteClueAddWidget(ToolTipMaster, toolbar[2], "Change to zoom mode", 0, 0);
      XcgLiteClueAddWidget(ToolTipMaster, toolbar[3], "Fixed zoom in", 0, 0);
      XcgLiteClueAddWidget(ToolTipMaster, toolbar[4], "Fixed zoom out", 0, 0);
      XcgLiteClueAddWidget(ToolTipMaster, toolbar[5], "Zoom to full extent of data", 0, 0);
      XcgLiteClueAddWidget(ToolTipMaster, toolbar[6], "Change to pan mode", 0, 0);
      XcgLiteClueAddWidget(ToolTipMaster, toolbar[7], "Change to distance mode", 0, 0);
      XcgLiteClueAddWidget(ToolTipMaster, toolbar[8], "Change to information mode", 0, 0);

      if(NGA_TYPE==1)
	{
	  XcgLiteClueAddWidget(ToolTipMaster, toolbar[TOOLBAR_CLASS], "No project loaded", 0, 0);
	}
    }






  for(n=0;n<ZOOM_REMEMBER_NUM;n++)
    {
      XtSetSensitive(stackwids[n],False);
    }

  n = 0;
  SAVED_VIEWS = 0;
  CURRENT_ZOOM = 0;


  sw = XtVaCreateManagedWidget ("scrolled_win",
				xmScrolledWindowWidgetClass, form,
				XmNwidth,                    800,
				XmNheight,                   600,
				XmNscrollingPolicy,          XmAUTOMATIC,
				XmNscrollBarDisplayPolicy,   XmSTATIC,
				XmNtopAttachment,            XmATTACH_FORM,
				XmNbottomAttachment,         XmATTACH_WIDGET,
				XmNleftAttachment,           XmATTACH_POSITION,
				XmNleftPosition,             0,
				XmNrightAttachment,          XmATTACH_POSITION,
				XmNrightPosition,            100,
				XmNbottomWidget,             rc,
				NULL);
  

  XtVaGetValues(sw,XmNverticalScrollBar,&vert_scroll[DRAWING_A_SCROLL],NULL);
  XtVaGetValues(sw,XmNhorizontalScrollBar,&draw_h_scroll,NULL);
 
 
   XtVaGetValues(vert_scroll[DRAWING_A_SCROLL],
		    XmNminimum,      &global_scroll_min,
		    XmNmaximum,      &global_scroll_max,
		    XmNvalue,        &global_scroll_value,
		    XmNsliderSize,   &global_scroll_slide_size,
		    XmNincrement,    &global_scroll_increment,
		    XmNpageIncrement,&global_scroll_pg_increment,
		    NULL);
      

      XmScrollBarSetValues(vert_scroll[DRAWING_A_SCROLL],
			   global_scroll_value,
			   global_scroll_slide_size,
			   30,
			   global_scroll_pg_increment,
			   1);
   



 


  logo_done = 1; 
  drawing_a = XtVaCreateManagedWidget ("drawing_a",
				       xmDrawingAreaWidgetClass, sw,
				       XmNtranslations, XtParseTranslationTable (translations),
				       XmNunitType,     XmPIXELS,
				       XmNwidth,        1000,  
				       XmNheight,       850,   
				       XmNresizePolicy, XmNONE,
				       NULL);






  XtAddCallback (drawing_a, XmNexposeCallback, redraw,(XtPointer) NULL);
  XtVaGetValues (drawing_a, XmNwidth, &width, XmNheight, &height, NULL);
 

 

    
  stipmap_avg   = XCreateBitmapFromData (XtDisplay (drawing_a),
					 RootWindowOfScreen (XtScreen (drawing_a)),bitmap_bits ,16,16);
  
  stipmap_lgt   = XCreateBitmapFromData (XtDisplay (drawing_a),
					 RootWindowOfScreen (XtScreen (drawing_a)),bitmap_lgt_bits ,16,16);
  
  stipmap_hvy   = XCreateBitmapFromData (XtDisplay (drawing_a),
					 RootWindowOfScreen (XtScreen (drawing_a)),bitmap_hvy_bits ,16,16);
  
  stipmapstypes[0] = XCreateBitmapFromData (XtDisplay (drawing_a),
					 RootWindowOfScreen (XtScreen (drawing_a)),dense_horiz_bits ,16,16);
  stipmapstypes[1] = XCreateBitmapFromData (XtDisplay (drawing_a),
					 RootWindowOfScreen (XtScreen (drawing_a)),light_horiz_bits ,16,16);
  stipmapstypes[2] = XCreateBitmapFromData (XtDisplay (drawing_a),
					 RootWindowOfScreen (XtScreen (drawing_a)),dense_vert_bits ,16,16);
  stipmapstypes[3] = XCreateBitmapFromData (XtDisplay (drawing_a),
					 RootWindowOfScreen (XtScreen (drawing_a)),light_vert_bits ,16,16);
  stipmapstypes[4] = XCreateBitmapFromData (XtDisplay (drawing_a),
					 RootWindowOfScreen (XtScreen (drawing_a)),nesw_bits ,16,16);
  stipmapstypes[5] = XCreateBitmapFromData (XtDisplay (drawing_a),
					 RootWindowOfScreen (XtScreen (drawing_a)),nwse_bits ,16,16);
  stipmapstypes[6] = XCreateBitmapFromData (XtDisplay (drawing_a),
					 RootWindowOfScreen (XtScreen (drawing_a)),sparse_nwse_bits ,16,16);
  stipmapstypes[7] = XCreateBitmapFromData (XtDisplay (drawing_a),
					 RootWindowOfScreen (XtScreen (drawing_a)),sparse_nesw_bits ,16,16);



  

  
  
  pixmap      = XCreatePixmap (XtDisplay (drawing_a),
			       RootWindowOfScreen (XtScreen (drawing_a)), width, height,
			       DefaultDepthOfScreen (XtScreen (drawing_a)));
  

  for(i=0;i<NUM_DRAWING_PIXMAPS;i++)
    {
      DRAWING_PIXMAPS[i] = XCreatePixmap (XtDisplay (drawing_a),
					  RootWindowOfScreen (XtScreen (drawing_a)), width, height,
					  DefaultDepthOfScreen (XtScreen (drawing_a)));
      
      DRAWING_CLIPMAPS[i] = XCreatePixmap (XtDisplay (drawing_a),
					   RootWindowOfScreen (XtScreen (drawing_a)), width, height,
					   1);  
    }
  
  
  ERROR_BITMAP = XCreatePixmap (XtDisplay (drawing_a),
				RootWindowOfScreen (XtScreen (drawing_a)), width, height,
				1);  


  pixmap2     = XCreatePixmap (XtDisplay (drawing_a),
			       RootWindowOfScreen (XtScreen (drawing_a)), width, height,
			       DefaultDepthOfScreen (XtScreen (drawing_a)));

  pixmap3     = XCreatePixmap (XtDisplay (drawing_a),
			       RootWindowOfScreen (XtScreen (drawing_a)), width, height,
			       DefaultDepthOfScreen (XtScreen (drawing_a)));

  clean_pixmap     = XCreatePixmap (XtDisplay (drawing_a),
				    RootWindowOfScreen (XtScreen (drawing_a)), width, height,
				    DefaultDepthOfScreen (XtScreen (drawing_a)));
     
  
  

  
 
  form2 = XtVaCreateWidget ("form2", xmFormWidgetClass, rc,
			    XmNfractionBase,  100,  
			    NULL);

  MOD = 8;
  
  TEXT_HELP = XtVaCreateManagedWidget ("Choose or create a project using options under the \"File\" menu.",
				       xmLabelWidgetClass,  form2,
				       XmNtopAttachment,    XmATTACH_FORM,
				       XmNbottomAttachment, XmATTACH_FORM,
				       XmNrightAttachment,  XmATTACH_POSITION,
				       XmNrightPosition,    63+MOD,
				       XmNleftAttachment,   XmATTACH_POSITION,
				       XmNleftPosition,     0,
				       XmNalignment,        XmALIGNMENT_BEGINNING, 
				       LABELWTRANSLATE,
				       NULL);
  
  shift[0] = XtVaCreateManagedWidget ("arrow11",
				      xmArrowButtonWidgetClass, form2,
				      XmNarrowDirection,   XmARROW_LEFT,
				      XmNrightAttachment,  XmATTACH_POSITION,
				      XmNrightPosition,    65+MOD,
				      XmNleftAttachment,   XmATTACH_POSITION,
				      XmNleftPosition,     63+MOD,
				      NULL);  
  XtAddCallback (shift[0], XmNactivateCallback,shiftCallback,(XtPointer)5);
  
  shift[1] = XtVaCreateManagedWidget ("arrow12",
				      xmArrowButtonWidgetClass, form2,
				      XmNarrowDirection,   XmARROW_RIGHT,
				      XmNrightAttachment,  XmATTACH_POSITION,
				      XmNrightPosition,    67+MOD,
				      XmNleftAttachment,   XmATTACH_POSITION,
				      XmNleftPosition,     65+MOD,
				      NULL);
  XtAddCallback (shift[1], XmNactivateCallback, shiftCallback, (XtPointer)6);
  
  shift[2] = XtVaCreateManagedWidget ("arrow13",
				      xmArrowButtonWidgetClass, form2,
				      XmNarrowDirection,   XmARROW_UP,
				      XmNrightAttachment,  XmATTACH_POSITION,
				      XmNrightPosition,    69+MOD,
				      XmNleftAttachment,   XmATTACH_POSITION,
				      XmNleftPosition,     67+MOD,
				      NULL);
  XtAddCallback (shift[2], XmNactivateCallback,shiftCallback, (XtPointer)7);
  
  shift[3] = XtVaCreateManagedWidget ("arrow14",
				      xmArrowButtonWidgetClass, form2,
				      XmNarrowDirection,   XmARROW_DOWN,
				      XmNrightAttachment,  XmATTACH_POSITION,
				      XmNrightPosition,    71+MOD,
				      XmNleftAttachment,   XmATTACH_POSITION,
				      XmNleftPosition,     69+MOD,
				      NULL);
  XtAddCallback (shift[3], XmNactivateCallback,shiftCallback, (XtPointer)8);


  if(XCG==1)
    {
      XcgLiteClueAddWidget(ToolTipMaster, shift[0], "Shift view 1 screen left (west)", 0, 0);
      XcgLiteClueAddWidget(ToolTipMaster, shift[1], "Shift view 1 screen right (east)", 0, 0);
      XcgLiteClueAddWidget(ToolTipMaster, shift[2], "Shift view 1 screen up (north)", 0, 0);
      XcgLiteClueAddWidget(ToolTipMaster, shift[3], "Shift view 1 screen down (south)", 0, 0);
    }


  XtManageChild(form2);





  if(batch_mode==0)
    {
      n = 0;
      XtSetArg(resources[n], XmNmessageString, STRING("Please wait while data is loaded.")); n++;
      XtSetArg(resources[n], XmNdialogStyle,   XmDIALOG_PRIMARY_APPLICATION_MODAL);          n++;
      XtSetArg(resources[n], XmNdialogTitle,   STRING("Busy"));                              n++;
      
      beg_dialog = XmCreateWorkingDialog (WW, "Wait", resources, n);
      
      XtUnmanageChild (XmMessageBoxGetChild (beg_dialog, XmDIALOG_OK_BUTTON));
      XtUnmanageChild (XmMessageBoxGetChild (beg_dialog, XmDIALOG_HELP_BUTTON));
      XtUnmanageChild (XmMessageBoxGetChild (beg_dialog, XmDIALOG_CANCEL_BUTTON));
      
      XtManageChild(beg_dialog);
    }






  XtManageChild(rc);
  XtManageChild(form);



  if(batch_mode==1)
  {
	
    XtRealizeWidget(WW);  
  }
  else
  {
     XtPopup(WW,XtGrabNone);
  }

  XtAddEventHandler(WW,StructureNotifyMask,False, myResizeHandler, (XtPointer)((int)900));
  XtAddEventHandler(WW,StructureNotifyMask,False, myResizeWidthHandler, (XtPointer)((int)1030)); 
  XtAddEventHandler(WW,StructureNotifyMask,False, myMenuHandler, (XtPointer)NULL);
  XtAddEventHandler(WW,StructureNotifyMask,False, myLogoHandler, (XtPointer)NULL);


  if(batch_mode==0)
    {
      XtPopup(XtParent(beg_dialog), XtGrabNone);
    }
  else
    {
      
  }




  

  
  
  ABNORMAL_DELETE = XmInternAtom (XtDisplay (WW), "WM_DELETE_WINDOW", False);
  XmAddWMProtocolCallback (WW, ABNORMAL_DELETE, quitCallback, WW);


  ABNORMAL_DELETE = XmInternAtom (XtDisplay (WW), "WM_SAVE_YOURSELF", False);
  XmAddWMProtocolCallback (WW, ABNORMAL_DELETE, Atom1Callback, WW);

  ABNORMAL_DELETE = XmInternAtom (XtDisplay (WW), "WM_QUERYENDSESSION", False);
  XmAddWMProtocolCallback (WW, ABNORMAL_DELETE, Atom2Callback, WW);
   



  mygc      = XCreateGC(XtDisplay(WW),XtWindow(WW),0,0);

  mybitgc   = XCreateGC(XtDisplay(WW),DRAWING_CLIPMAPS[0],0,0);


  mywindow  = XtWindow(drawing_a);
  mydisplay = XtDisplay(drawing_a);
  myscreen  = XtScreen(drawing_a);
  


  

  XtVaSetValues(XmGetXmDisplay(mydisplay),XmNdragInitiatorProtocolStyle,XmDRAG_NONE,NULL);
  XtVaSetValues(XmGetXmDisplay(mydisplay),XmNdragReceiverProtocolStyle,XmDRAG_NONE,NULL);


  if(DisplayWidth(mydisplay,DefaultScreen(mydisplay)) < 900)
    {
      printf("Resetting display width due to small screen (%d)\n",
	     DisplayWidth(mydisplay,DefaultScreen(mydisplay)));
      XtVaSetValues(WW,XmNmaxWidth, DisplayWidth(mydisplay,DefaultScreen(mydisplay)),NULL);
      XtVaSetValues(WW,XmNwidth,    DisplayWidth(mydisplay,DefaultScreen(mydisplay)),NULL);
    }
  
  if(DisplayHeight(mydisplay,DefaultScreen(mydisplay)) < 700)
    {
      printf("Resetting display height due to small screen (%d)\n",
	     DisplayHeight(mydisplay,DefaultScreen(mydisplay)));
      XtVaSetValues(WW,XmNmaxHeight, DisplayHeight(mydisplay,DefaultScreen(mydisplay)),NULL);
      XtVaSetValues(WW,XmNheight,    DisplayHeight(mydisplay,DefaultScreen(mydisplay)),NULL);
    }
  
  
  
  cmap = DefaultColormapOfScreen(myscreen);
  

  
  XtVaGetValues(drawing_a,XmNheight,&HEIGHT,NULL);
  
  
  XtVaGetValues(drawing_a,XmNbackground,&mybackground,NULL);
  XtVaGetValues(drawing_a,XmNforeground,&myforeground,NULL);
  XSetBackground(mydisplay,mygc,mybackground);
  
  
  col_index = find_col_index();
  Greyit(); 
  
  SetColorRight();
  


  XFillRectangle (XtDisplay (drawing_a), pixmap, mygc, 0, 0, width, height);
  
  ClearDrawingPixmaps(1); 
  ClearErrorBitmap();


  

  BITWHITE = WhitePixelOfScreen(XtScreen(drawing_a));
  BITBLACK = BlackPixelOfScreen(XtScreen(drawing_a));

  ClearBitmaps(1); 
  ZeroPixmapFlags();
  


  SetColorRight();

  
  logo_done = 0;
  do_logo();

  PutImageOnPixmap (2,0,0,toolbar_pixmap[5]);
  PutImageOnPixmap2(1,0,0,toolbar_insen_pixmap[5]);

  
  
  XtVaSetValues(drawing_a,XmNbackground,mycolors[DRAW_COLOR_WHITE],NULL);
  
  
  
  XSetErrorHandler(tim_err_handle);
  
  XtSetWarningHandler(tim_xt_warn_handle);




  
  if(col_index<256)
    {
      
      
      for(i=col_index;i<256;i++)
	{
	  mycolors[0] = i;
	  XFreeColors(mydisplay,cmap,mycolors,1,0);
	}
      
      Greyit(); 
    }
  
  
  
  set_shift(0);      
  
  init_drawbytype(); 
  
  SetToggles();      



  if(ZOOM_MODE==1)
  {
    XtVaSetValues(modes[0],XmNset,True,NULL);
  }
  else if(PAN_MODE==1)
  {
    XtVaSetValues(modes[1],XmNset,True,NULL);
  }
  else if(INFO_MODE==1)
  {
    XtVaSetValues(modes[2],XmNset,True,NULL);
  }
  else if(DIST_MODE==1)
  {
    XtVaSetValues(modes[3],XmNset,True,NULL);
  }
  else if(CHECK_MODE==1)
  {
    XtVaSetValues(modes[4],XmNset,True,NULL);
  }
  else if(PROFILE_MODE==1)
  {
    if(ACTUAL==1)
	{
      XtVaSetValues(modes[5],XmNset,True,NULL);
	}
	else
	{
      if(LOS==0)
	  {
        XtVaSetValues(modes[6],XmNset,True,NULL);
	  }
	  else
	  {
        XtVaSetValues(modes[7],XmNset,True,NULL);
	  }
	}
  }
  else if(FAN_MODE==1)
  {
	if(DO_FAN()==1)
	{
      XtVaSetValues(modes[8],XmNset,True,NULL);
	}
  }

  set_cursor(mydisplay,mywindow,GOOD);

  

 

  

  sprintf(PROJECTLOC,"%sprojects",GAIT_HOME_DIR);
  printf("PROJECTLOC: %s\n",PROJECTLOC);


  SetTRExChecklistFiles();

  if(getenv("GAIT_PROJECTS")!=NULL)
  {
    sprintf(testfile,"%s",getenv("GAIT_PROJECTS"));
      
    printf("Found GAIT_PROJECTS environment variable %s\n",testfile);


    for(i=0;i<500;i++) 
	{ 
      len = strlen(testfile);

      if(len>0)
	  { 
        if(testfile[len]=='\0') 
		{ 
	      if(testfile[len-1]=='/')  
		  { 
	        testfile[len-1]='\0';
			printf("Illegal to specify GAIT_PROJECTS ending in \"/\".  Modified to %s\n",testfile);
		  } 
	      else if(testfile[len-1]=='\\')  
		  { 
	        testfile[len-1]='\0';
			printf("Illegal to specify GAIT_PROJECTS ending in \"\\\".  Modified to %s\n",testfile);
		  } 
		}   
	  }   
	} 


    if(UpdateProjectLoc(testfile)==1)
	{
	  sprintf(PROJECTLOC,"%s",testfile);
	}
    else
	{
	  printf("Failed to use %s\nas GAIT project folder.  Probable causes:\n  this is not a folder or\n  you do not have write permissions to this folder\n  the path may have a \".\" in it\n",testfile);
	}
  } 




  if(GAITProjectName[0]!='\0')
  {
    

    if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
	{
	  sprintf(importdirectory,"%s\\%s\\InputSpecFile.txt",PROJECTLOC,GAITProjectName);
	  sprintf(importoutputdir,"%s\\%s\\",PROJECTLOC,GAITProjectName);
	}
    else
	{
	  sprintf(importdirectory,"%s/%s/InputSpecFile.txt",PROJECTLOC,GAITProjectName);
	  sprintf(importoutputdir,"%s/%s/",PROJECTLOC,GAITProjectName);
	}

    import_source        = 1;
    import_output_source = 1;
  }









 if(getenv("GAIT_TYPE2_ATTR")!=NULL)
  {
    sprintf(testfile,"%s",getenv("GAIT_TYPE2_ATTR"));

	if(!strcmp(testfile,"0"))
	{
	  printf("Setting GAIT_TYPE2_ATTR to 0\n");
	  old_long_attr_style = 0;
	}
	else if(!strcmp(testfile,"1"))
	{
	  printf("Setting GAIT_TYPE2_ATTR to 1\n");
	  old_long_attr_style = 1;
	}
	else
	{
      printf("Found illegal value %s for GAIT_TYPE2_ATTR: expected 0 or 1\n",testfile);
	}
  }





 if(getenv("GAIT_DO_TIFFSURFACE")!=NULL)
  {
    sprintf(testfile,"%s",getenv("GAIT_DO_TIFFSURFACE"));

	if(!strcmp(testfile,"0"))
	{
	  printf("Setting GAIT_DO_TIFFSURFACE to 0\n");
	  DO_TIFFSURFACE = 0;
	}
	else if(!strcmp(testfile,"1"))
	{
	  printf("Setting GAIT_DO_TIFFSURFACE to 1\n");
	  DO_TIFFSURFACE = 1;
	}
	else
	{
      printf("Found illegal value %s for GAIT_DO_TIFFSURFACE: expected 0 or 1\n",testfile);
	}
  }


 if(getenv("GAIT_DO_MGCP_PORTRAY")!=NULL)
  {
    sprintf(testfile,"%s",getenv("GAIT_DO_MGCP_PORTRAY"));

	if(!strcmp(testfile,"0"))
	{
	  printf("Setting GAIT_DO_MGCP_PORTRAY to 0\n");
	  DO_MGCP_PORTRAY = 0;
	}
	else if(!strcmp(testfile,"1"))
	{
	  printf("Setting GAIT_DO_MGCP_PORTRAY to 1\n");
	  DO_MGCP_PORTRAY = 1;
	}
	else
	{
      printf("Found illegal value %s for GAIT_DO_MGCP_PORTRAY: expected 0 or 1\n",testfile);
	}
  }






 if(getenv("GAIT_REWRITE_TREX_XML")!=NULL)
  {
    sprintf(testfile,"%s",getenv("GAIT_REWRITE_TREX_XML"));

	if(!strcmp(testfile,"0"))
	{
	  printf("Setting GAIT_REWRITE_TREX_XML to 0 (do not reformat TREx XMLs)\n");
	  ReFormatTrexXML = 0;
	}
	else if(!strcmp(testfile,"1"))
	{
	  printf("Setting GAIT_REWRITE_TREX_XML to 1 (reformat TREx XMLs)\n");
	  ReFormatTrexXML = 1;
	}
	else
	{
      printf("Found illegal value %s for GAIT_REWRITE_TREX_XML: expected 0 or 1\n",testfile);
	}
  }






 if(getenv("GAIT_MAX_SORT_COUNT")!=NULL)
  {
    sprintf(testfile,"%s",getenv("GAIT_MAX_SORT_COUNT"));


	if(INT_CHECK(testfile))
	{
       sscanf(testfile,"%d",&i);
	   if(i>100)
	   {
         printf("got %d for GAIT_MAX_SORT_COUNT\n",i);
         MAX_SORT_COUNT = i;
	   }
	   else
	   {
         printf("Error: got %d for GAIT_MAX_SORT_COUNT...this value is too small, it must be greater than 100\n",i);
	   }
	}
	else
	{
      printf("Found illegal value %s for GAIT_MAX_SORT_COUNT: expected integer\n",testfile);
	}
  }

  
  if(getenv("GAIT_DATA")!=NULL)
    {
      sprintf(DATALOC,"%s",getenv("GAIT_DATA"));
      
      printf("Found GAIT_DATA environment variable %s\n",DATALOC);
    }
  else
    {
      sprintf(DATALOC,"%s",GAIT_HOME_DIR);
    }
  

  printf("DATALOC: %s\n",DATALOC);

  
  
  if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
    {
      sprintf(startloc,"%s\\ProjectPreferences\\",PROJECTLOC);
    }
  else
    {
      sprintf(startloc,"%s/ProjectPreferences/",PROJECTLOC);
    }

  if(TestOut(startloc)==0)
    {
      printf("failed to read or create %s\n",startloc);
    }
   


  if(doingQAcheck==1) 
  { 
	if(MGCPBatchQACheck(argv[2],argv[3],argv[4],argv[5])==0)
	{
	  PrintUsage(argv[0]);
	}
	ExitWrapper(-1);
  }





  if((batch_mode==1)&&(NGA_TYPE==1))
    {
	  if(strlen(argv[4])>75)
	  {
		  printf("\n\nThe project name: %s\n   is too long.  Use a name with 75 or less characters.\n\n",argv[4]);
		  ExitWrapper(-1);
	  }


	  TestProjectName(0,argv[4]); 

	  if(batchignore==1)
	  { 
		

	    if(strlen(batchignorename)>75)
		{ 
		  printf("\n\nThe project name: %s\n   is too long.  Use a name with 75 or less characters.\n\n",batchignorename);
		  ExitWrapper(-1);
		}

	    TestProjectName(1,batchignorename);
	  } 

	  if(batchuser==1)
	  {
		  printf("test user supplied inspection options file %s\n",specfilename);
	  }


	  if(
	    (strcmp(argv[5],"USE_DFEGMASTER")) &&
	    (strcmp(argv[5],"USE_MGCPMASTER")) &&
	    (strcmp(argv[5],"USE_UFD1MASTER")) &&
	    (strcmp(argv[5],"USE_UFD3MASTER")) &&
	    (strcmp(argv[5],"USE_TDSMASTER"))  &&
	    (strcmp(argv[5],"USE_TREXMASTER")) &&
	    (strcmp(argv[5],"USE_AFDMASTER"))  &&
	    (strcmp(argv[5],"USE_NOMASTER"))
	   )
	   {
	    PrintUsage(argv[0]);
		ExitWrapper(-1);
	   }

	  if(batchignore==1)
	  {
        if(batchuser==1)
		{ 
          DoNGABAtchStuff(argv[0],argv[2],argv[4],argv[5],batchignorename,specfilename);
		} 
	    else
		{ 
          DoNGABAtchStuff(argv[0],argv[2],argv[4],argv[5],batchignorename,NULL);
		} 
	  }
	  else
	  {
        if(batchuser==1)
		{ 
          DoNGABAtchStuff(argv[0],argv[2],argv[4],argv[5],NULL,specfilename);
		}
		else
		{
          DoNGABAtchStuff(argv[0],argv[2],argv[4],argv[5],NULL,NULL);
		}
	  }
   

      printf("done with Non-GUI mode\n");
      ExitWrapper(1);
    }
  else if(batch_mode==1)
    {
      bat_option     = argv[1];

      good = 1;

      if(!strcmp(bat_option,"-batch"))
	{
	  batchtype = 1;
	}
      else if(!strcmp(bat_option,"-batchextract"))
	{
	  batchtype = 3;
	}
      else
	{
	  good = 0;
	}
      
      
      if(good==0)
	{
	  printf("usage:  %s [ [-help] | \n\
             [-batch | -batchextract\n\
                     <text file specifying stf file(s)>\n\
                     <destination directory> \n\
                     <inspection specification file | USE_MASTER> (can be NULL if -batchextract)\n\
                     ]]\n",argv[0]);
	  ExitWrapper(-1);
	}

      
      stf_locations  = argv[2];
      test = fopen(argv[2],"r");
      if(test==NULL)
	{
	  printf("couldnt open %s for read.  Exiting.\n",argv[2]);
	  ExitWrapper(-1);
	}
      fclose(test);
 


      if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
	{
	  sprintf(importoutputdir,"%s\\",argv[3]);
	}
      else 
	{
	  sprintf(importoutputdir,"%s/",argv[3]);
	}
      
    


    


      

      sprintf(outdirectory,"%sbitmaps",importoutputdir);
      
      if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
	{
	  strcat(outdirectory,"\\");
	}
      else
	{
	  strcat(outdirectory,"/");
	}
      
      if(TestOut(outdirectory)==0)
	{
	  ExitWrapper(-1);
	}
      
 

      sprintf(outdirectory,"%s%s",importoutputdir,outfoldername);
      
      if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
	{
	  strcat(outdirectory,"\\");
	}
      else
	{
	  strcat(outdirectory,"/");
	}
      
      if(TestOut(outdirectory)==0)
	{
	  ExitWrapper(-1);
	}
      
    
    
      sprintf(outshapedirectory,"%sexported_shapefiles",importoutputdir);
      
      if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
	{
	  strcat(outshapedirectory,"\\");
	}
      else
	{
	  strcat(outshapedirectory,"/");
	}
      
      if(TestOut(outshapedirectory)==0)
	{
	  ExitWrapper(-1);
	}
    


      sprintf(testfile,"%scell0.pgm",importoutputdir);
      test = fopen(testfile,"w");
      if(test==NULL)
	{
	  printf("couldnt open %s for write (destination directory).  Exiting.\n",testfile);
	  ExitWrapper(-1);
	}
      fclose(test);


      sprintf(testfile,"%sdynamicdefs.bin",outdirectory);
      test = fopen(testfile,"wb");
      if(test==NULL)
	{
	  printf("couldnt open %s for write (destination directory).  Exiting.\n",testfile);
	  ExitWrapper(-1);
	}
      fclose(test);  
      

      
      exe_options    = argv[4];
      if(
	 (strcmp(exe_options,"NULL")) &&
	 (strcmp(exe_options,"USE_MASTER"))
	 )
	{
	  test = fopen(argv[4],"r");
	  if(test==NULL)
	    {
	      printf("couldnt open %s for read. Exiting.\n",argv[4]);
	      ExitWrapper(-1);
	    }
	  fclose(test);
	}
      else if((batchtype==1)&&(!strcmp(exe_options,"NULL")))
	{
	  
	  printf("You may specify NULL as the exe_options file only with\n");
	  printf("  -batchextract\n");
	  ExitWrapper(-1);
	}
    
	  if(batchignore==1) 
	  {
       DoBatchModeStuff(stf_locations,exe_options, batchtype,argv[8]);
	  }
	  else
	  {
        DoBatchModeStuff(stf_locations,exe_options, batchtype,NULL);
	  }
      printf("batch mode execution completed.\n");
      ExitWrapper(-1);
    
    }
  set_cursor(mydisplay,mywindow,GOOD);


  XtSetMultiClickTime(mydisplay,DOUBLECLICK);



  HandleMainButtons(0);

  XtSetSensitive(netwid,0); 

    
  
  if((NGA_TYPE==1)&&(USE_DOS==1))
    {
      cleantmp();
    }

 
  pop_up[0] = 0;
  pop_up[1] = 0;
  pop_parent = W;
  deletesentinellen = strlen(deletesentinel);


  
  defaultfont = XLoadFont(mydisplay,"fixed");


  LabelFont = XLoadQueryFont(mydisplay,"-*-courier-bold-r-*--*-90-*");
  if(LabelFont)
  {
    XSetFont(mydisplay,mygc,LabelFont->fid);
    XSetFont(mydisplay,mybitgc,LabelFont->fid);
  }
  else
  {
    printf("Failed to load font 1.\n");
  }

  

  if(batch_mode==0)
  {
    if(getenv("GAIT_EASTER_EGGS")==NULL)
	{ 
      AssessHolidays();
	}
  }

  XtAppMainLoop(app_context); 
    
  printf("Major problem.\n"); 
  return -999;
}




