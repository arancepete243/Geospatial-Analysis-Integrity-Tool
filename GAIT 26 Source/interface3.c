/************
GAIT (Geospatial Analysis Integrity Tool) is a geospatial data validation tool developed by the Institute for Defense Analyses (IDA) for the National Geospatial-Intelligence Agency (NGA).  

This source code was used to generate GAIT 26 executable software in accordance with Amendment 6 to Task Order DH-8-3815 under Contract HQ0034-14-D-0001.

IDA is furnishing this item "as is". IDA was not tasked or funded to generate developer documentation or to provide support for this source code. IDA does not provide any warranty of the item whatsoever, whether express, implied, or statutory, including, but not limited to, any warranty of fitness for a particular purpose or any warranty that the contents of the item will be error-free. In no event shall NGA or IDA be held liable for damages arising, directly or indirectly, from the use of this source code. 

This material may be reproduced by the U.S. Government pursuant to its unlimited use rights under DFARS 252.227-7014 [Feb 2014].

The Institute for Defense Analyses (IDA) is a Federally Funded Research and Development Center that provides scientific and technical expertise on issues important to national security to the Office of the Secretary of Defense, Joint Staff, Unified Commands, and Defense Agencies. 

© 2017 Institute for Defense Analyses
  4850 Mark Center Drive
  Alexandria, Virginia 22311-1882
  703.845-2000
  www.ida.org
************/
#include "interface.h"


#if(USE_DOS==0)
#include<dirent.h>
#endif

extern Widget savelayer_wid;
extern char GAIT_BIN_DIR[1000];
extern char GAIT_HOME_DIR[1000];
extern char attrinsfolder[1000];
extern char masterrun[100];
extern char SpecialLoc[1000];
extern char shape_out_name[200];
extern char layer_pref_file[100];
extern int LAYERPREFS_UP,pref2_up,PPAD_UP,NO_QUERY,batchsilent,NEED_SHADE_REDRAW;
extern double SaveXScroll,SaveYScroll;
extern double *global_bridge_wid,*global_bridge_wd1;

extern int NOTYPE;
extern int C_TYPE;
extern int D_TYPE;
extern int I_TYPE;

extern int BIN_ATTR_TYPE;
extern int ATTRINSTYPE;
extern int INCLUDE_PROJECTION;



extern int LLFidTableCount     ;
extern int *LLFidTable         ;


extern int FromI,ToI,FromJ,ToJ,iLimit,jLimit,iStart,jStart;

extern unsigned char *FidMarkTable;

short int *Scache_types;
long int  *Scache_posns;
double    *Scache_nums;
char     **Scache_chars;
int SpecialHGTCache = 0;
int NetRouteType    = 0;

int user_trex_cell=-1; 
int ROUTING_INFO = 0;

char GErr[1000];
int DrivesAvailable[DRIVE_MAX]; 
char DriveNames[DRIVE_MAX][500];

int NumNetDrives=0;
char **NetDriveNames=NULL;
char **NetDrivePaths=NULL;

int DOUBLECLICK    = 300;  
int LINE_TYPE_ONLY = 0;
int DO_OBS[NUM_OBS];
int COMPARE_VERBOSITY       = 1;
int SAVE_COMPARE_FILE       = 0;
int MakingMaster            = 0;
int NumNetsLoaded           = 0;
int NetsPresent             = 0;
int totalALL                = 0;
int ENV_ROOT_NUM            = 1;
int SAVE_TOPCHANGE          = 0;
int NO_REBUILD              = 0;
int TopLayersDrawn          = 0;
int TempNumLODbands         = 0;
int popmem                  = 0;
int KILL_ATTR_WIN           = 1;
int unsavedignore           = 0;
int UnsavedConditions       = 0;
int GLOBAL_ADDSPECS         = 0;
int GLOBAL_ADDNETSPECS      = 0;
int ContourColorsAllocated  = 0;
int ExtraGraysAllocated     = 0;
int PossibleToPopInfoWin    = 0;
int QAST_LEAVEWINDOWS       = 0;
int COPY_PROJECT_FOLDER     = 0;
int COPY_PROJECT_FOLDER2    = 0;
int QAST_USEPACKAGELOCATION = 0;
int QAST_IS                 = 1;
int POINT_LABELS_DRAWN      = 0;
int LINE_LABELS_DRAWN       = 0;
int AREA_LABELS_DRAWN       = 0;
int GRID_LABELS_DRAWN       = 0;
int NetModifyMasterRun      = 1;
int FORCE_DP_OVERWRITE      = 0;
int FoundHGTrange           = 0;
int OVERRIDING_ATTRINS      = -1;
int MAX_SHAPE_NUM           = 750000;

int    *HIGH_ERRNUM        = NULL;
int    *HIGH_INSTANCE      = NULL;
int    *HIGH_CONDNUM       = NULL;
int    *HIGH_ECC1          = NULL;
int    *HIGH_ECC2          = NULL;
double *HIGH_MAG           = NULL;

char trexid1[100];
char trexid2[100];
char trexid3[100];
char trexid4[100];

char trexlongid1[100];
char trexlongid2[100];
char trexlongid3[100];
char trexlongid4[100];



int GLOBAL_draw;
int GLOBAL_needextrapixmap;
int GLOBAL_showlayers;
int GLOBAL_activelayer;

int alldatafiles;

int *SPECNUM;
int specalloced = 0;
char *tables_found  [1000];
char ExtraMessage   [1000];
char globalmessage  [5000];
char project_to_open[1000];
char QAST_XML           [1000]; 
char QAST_CELL          [1000]; 
char QAST_REPORT        [1000]; 
char QAST_REPORTFOLDER  [1000]; 
char QAST_CONDREPORTNAME[1000]; 

unsigned short int rec_errnum  [MAX_STACK+1];
unsigned short int rec_instance[MAX_STACK+1];
int rec_condnum                [MAX_STACK+1];


int *POINT_PRI;
int *POINT_RED;
int *POINT_GREEN;
int *POINT_BLUE;

int *LINE_PRI;
int *LINE_RED;
int *LINE_GREEN;
int *LINE_BLUE;

int *AREA_PRI;
int *AREA_RED;
int *AREA_GREEN;
int *AREA_BLUE;
int *AREA_STYLE;

int *AREA_ECCS_USED;
int *LINE_ECCS_USED;
int *POINT_ECCS_USED;



int num_per_page     = 25;
int view_object_page =  1;  
int maxpages         =  0;
int pageptrsalloced  =  0;
int numobs;
long int *pageptrs;
int ThisClassLevel;
int DO_QAST=0;

Dimension over_width,over_height,lod_hgt;
Position over_px1,over_py1;
int override_location = 0;


unsigned char shortmsg_up[5000];
unsigned long mybackground ;
unsigned long myforeground ;
char PROJECTLOC[1500];
char DATALOC[1500];


int KEEP_THICKNESS = 0;
int FORCE_REDRAW   = 0;
int DRAWING_ERRORS = 0;
int NO_EXE_REBUILD = 0;


int global_scroll_min;
int global_scroll_max;
int global_scroll_value;
int global_scroll_slide_size;
int global_scroll_increment;
int global_scroll_pg_increment;

int global_trex_shape_layer=-1;

long int use_other_fileposn=-1;



struct LODdisplaySH *LODindex_DYN = NULL;
int PrimaryLODSort   = 3; 
int SecondaryLODSort = 2; 
int DynLodMade       = 0;


String translations = 
 "Shift<Btn1Up>:  draw(shiftb1up)\n <Btn1Down>:   draw(down)\n <Btn1Up>: draw(up)\n <Btn1Motion>: draw(motion)\n <Btn2Down>: draw(mid_down)\n <Btn2Up>: draw(mid_up)\n <Btn2Motion>: draw(mid_motion)\n <Btn3Down>: draw(right_down)\n <Btn3Motion>: draw(right_motion)\n <Btn3Up>: draw(right_up)\n <Btn4Up>: draw(scrollup)\n <Btn5Up>: draw(scrolldown)\n <Motion>: draw(distmotion)";


String translations_global = 
 "#override\n <Btn2Down>: do_nothing2(2down)\n <Btn2Up>: do_nothing2(2up)";



String translations_paste = 
 "#override\n <Btn2Down>: do_nothing2(2down)\n <Btn2Up>: do_nothing2(2up)";










String list_translations = 
"#override\n\
\
<Key>a,<Key>b,<Key>c,<Key>d,<Key>e,<Key>f,<Key>g,<Key>h,<Key>i,<Key>j,<Key>k,<Key>l,<Key>m,<Key>n,<Key>o,\
<Key>p,<Key>q,<Key>r,<Key>s,<Key>t,<Key>u,<Key>v,<Key>w,<Key>x,<Key>y,<Key>z,<Key>A,<Key>B,<Key>C,<Key>D,\
<Key>E,<Key>F,<Key>G,<Key>H,<Key>I,<Key>J,<Key>K,<Key>L,<Key>M,<Key>N,<Key>O,<Key>P,<Key>Q,<Key>R,<Key>S,\
<Key>T,<Key>U,<Key>V,<Key>W,<Key>X,<Key>Y,<Key>Z,<Key>1,<Key>2,<Key>3,<Key>4,<Key>5,<Key>6,<Key>7,<Key>8,\
<Key>9,<Key>0,<Key>[,<Key>],<Key>;,<Key>',<Key>.,<Key>/,<Key>0x02c,<Key>0x05c,<Key>osfBackSpace,<Key>osfDelete\
\
\
\
: do_nothing2(ha)\n <Key>osfLeft: list_scroll(5,0)\n <Key>osfRight: list_scroll(5,1)\n <Key>osfUp: ListPrevItem()ListEndSelect()\n <Btn4Up>:          list_scroll(1,1)\n <Btn5Up>:          list_scroll(2,1)\n <Btn2Down>: do_nothing2(2down)\n <Btn2Up>: do_nothing2(2up)";







String list_translations2 = 
"#override\n\
\
<Key>a,<Key>b,<Key>c,<Key>d,<Key>e,<Key>f,<Key>g,<Key>h,<Key>i,<Key>j,<Key>k,<Key>l,<Key>m,<Key>n,<Key>o,\
<Key>p,<Key>q,<Key>r,<Key>s,<Key>t,<Key>u,<Key>v,<Key>w,<Key>x,<Key>y,<Key>z,<Key>A,<Key>B,<Key>C,<Key>D,\
<Key>E,<Key>F,<Key>G,<Key>H,<Key>I,<Key>J,<Key>K,<Key>L,<Key>M,<Key>N,<Key>O,<Key>P,<Key>Q,<Key>R,<Key>S,\
<Key>T,<Key>U,<Key>V,<Key>W,<Key>X,<Key>Y,<Key>Z,<Key>1,<Key>2,<Key>3,<Key>4,<Key>5,<Key>6,<Key>7,<Key>8,\
<Key>9,<Key>0,<Key>[,<Key>],<Key>;,<Key>',<Key>.,<Key>/,<Key>0x02c,<Key>0x05c,<Key>osfBackSpace,<Key>osfDelete\
\
\
\
: do_nothing2(ha)\n <Key>osfLeft: list_scroll(5,0)\n <Key>osfRight: list_scroll(5,1)\n <Btn4Up>:          list_scroll(1,2)\n <Btn5Up>:          list_scroll(2,2)\n <Btn2Down>: do_nothing2(2down)\n <Btn2Up>: do_nothing2(2up)";








String list_translations3 = 
"#override\n <Btn4Up>:          list_scroll(1,3)\n <Btn5Up>:          list_scroll(2,3)\n <Btn2Down>: do_nothing2(2down)\n <Btn2Up>: do_nothing2(2up)";



String list_translations4 = 
"#override\n <Btn4Up>:          list_scroll(1,4)\n <Btn5Up>:          list_scroll(2,4)\n <Btn2Down>: do_nothing2(2down)\n <Btn2Up>: do_nothing2(2up)";



String list_translations5 = 
"#override\n <Btn4Up>:          list_scroll(1,5)\n <Btn5Up>:          list_scroll(2,5)\n <Btn2Down>: do_nothing2(2down)\n <Btn2Up>: do_nothing2(2up)";



String list_translations6 = 
"#override\n <Btn4Up>:          list_scroll(1,6)\n <Btn5Up>:          list_scroll(2,6)\n <Btn2Down>: do_nothing2(2down)\n <Btn2Up>: do_nothing2(2up)";



String list_translations7 = 
"#override\n <Btn4Up>:          list_scroll(1,7)\n <Btn5Up>:          list_scroll(2,7)\n <Btn2Down>: do_nothing2(2down)\n <Btn2Up>: do_nothing2(2up)";



String list_translations8 = 
"#override\n <Btn4Up>: list_scroll(1,8)\n <Btn5Up>: list_scroll(2,8)\n <Btn2Down>: do_nothing2(2down)\n <Btn2Up>: do_nothing2(2up)";




  

String list_translations9 = 
"#override\n <Key>osfUp:    ListPrevItem()  ListEndSelect()\n <Btn4Up>:          list_scroll(1,9)\n <Btn5Up>:          list_scroll(2,9)\n <Btn2Down>: do_nothing2(2down)\n <Btn2Up>: do_nothing2(2up)";




String list_translations10 = 
"#override\n <Btn4Up>:          list_scroll(1,10)\n <Btn5Up>:          list_scroll(2,10)\n <Btn2Down>: do_nothing2(2down)\n <Btn2Up>: do_nothing2(2up)";


String list_translations11 = 
"#override\n <Btn4Up>:          list_scroll(1,11)\n <Btn5Up>:          list_scroll(2,11)\n <Btn2Down>: do_nothing2(2down)\n <Btn2Up>: do_nothing2(2up)";




String list_translations12 = 
"#override\n <Btn1Down>:   ListBeginSelect() ListEndSelect()\n <Btn4Up>:     list_scroll(1,12)\n <Btn5Up>:     list_scroll(2,12)\n <Btn2Down>: do_nothing2(2down)\n <Btn2Up>: do_nothing2(2up)";



String list_translations13 = 
"#override\n <Btn1Down>:   ListBeginSelect() ListEndSelect()\n <Btn4Up>:     list_scroll(1,13)\n <Btn5Up>:     list_scroll(2,13)\n <Btn2Down>: do_nothing2(2down)\n <Btn2Up>: do_nothing2(2up)";




String list_translations14 = 
"#override\n <Btn1Down>:   ListBeginSelect() ListEndSelect()\n <Btn4Up>:     list_scroll(1,14)\n <Btn5Up>:     list_scroll(2,14)\n <Btn2Down>: do_nothing2(2down)\n <Btn2Up>: do_nothing2(2up)";




String list_translations15 = 
"#override\n <Btn1Down>:   ListBeginSelect() ListEndSelect()\n <Btn4Up>:     list_scroll(1,15)\n <Btn5Up>:     list_scroll(2,15)\n <Btn2Down>: do_nothing2(2down)\n <Btn2Up>: do_nothing2(2up)";









String list_translations16 = 
"#override\n\
\
<Key>a,<Key>b,<Key>c,<Key>d,<Key>e,<Key>f,<Key>g,<Key>h,<Key>i,<Key>j,<Key>k,<Key>l,<Key>m,<Key>n,<Key>o,\
<Key>p,<Key>q,<Key>r,<Key>s,<Key>t,<Key>u,<Key>v,<Key>w,<Key>x,<Key>y,<Key>z,<Key>A,<Key>B,<Key>C,<Key>D,\
<Key>E,<Key>F,<Key>G,<Key>H,<Key>I,<Key>J,<Key>K,<Key>L,<Key>M,<Key>N,<Key>O,<Key>P,<Key>Q,<Key>R,<Key>S,\
<Key>T,<Key>U,<Key>V,<Key>W,<Key>X,<Key>Y,<Key>Z,<Key>1,<Key>2,<Key>3,<Key>4,<Key>5,<Key>6,<Key>7,<Key>8,\
<Key>9,<Key>0,<Key>[,<Key>],<Key>;,<Key>',<Key>.,<Key>/,<Key>0x02c,<Key>0x05c,<Key>osfBackSpace,<Key>osfDelete\
\
\
\
: do_nothing2(ha)\n <Key>osfUp: ListPrevItem()\n <Key>osfDown: ListNextItem()\n <Btn4Up>:     list_scroll_spec(1,-1)\n <Btn5Up>:     list_scroll_spec(2,-1)\n <Btn2Down>: do_nothing2(2down)\n <Btn2Up>: do_nothing2(2up)";



String list_translations16b = 
"#override\n\
\
<Key>a,<Key>b,<Key>c,<Key>d,<Key>e,<Key>f,<Key>g,<Key>h,<Key>i,<Key>j,<Key>k,<Key>l,<Key>m,<Key>n,<Key>o,\
<Key>p,<Key>q,<Key>r,<Key>s,<Key>t,<Key>u,<Key>v,<Key>w,<Key>x,<Key>y,<Key>z,<Key>A,<Key>B,<Key>C,<Key>D,\
<Key>E,<Key>F,<Key>G,<Key>H,<Key>I,<Key>J,<Key>K,<Key>L,<Key>M,<Key>N,<Key>O,<Key>P,<Key>Q,<Key>R,<Key>S,\
<Key>T,<Key>U,<Key>V,<Key>W,<Key>X,<Key>Y,<Key>Z,<Key>1,<Key>2,<Key>3,<Key>4,<Key>5,<Key>6,<Key>7,<Key>8,\
<Key>9,<Key>0,<Key>[,<Key>],<Key>;,<Key>',<Key>.,<Key>/,<Key>0x02c,<Key>0x05c,<Key>osfBackSpace,<Key>osfDelete\
\
\
\
: do_nothing2(ha)\n <Key>osfUp: TimMoveList(1)\n <Key>osfDown: TimMoveList(2)\n <Btn4Up>:     list_scroll_spec(1,-1)\n <Btn5Up>:     list_scroll_spec(2,-1)\n <Btn2Down>: do_nothing2(2down)\n <Btn2Up>: do_nothing2(2up)";

















String toptrans = 
"#override\n <Btn1Down>: MenuBarSelect() MakeSen()\n <Btn4Down>: CleanupMenuBar()\n <Btn4Up>: CleanupMenuBar()\n <Btn5Down>: CleanupMenuBar()\n <Btn5Up>: CleanupMenuBar()\n <Btn2Down>: CleanupMenuBar()\n <Btn2Up>: CleanupMenuBar()\n <Btn3Down>: CleanupMenuBar()\n <Btn3Up>: CleanupMenuBar()";








String list_translations17 = 
"#override\n <Btn1Down>:   ListBeginSelect() ListEndSelect()\n <Btn4Up>:     list_scroll(1,16)\n <Btn5Up>:     list_scroll(2,16)\n <Btn2Down>: do_nothing2(2down)\n <Btn2Up>: do_nothing2(2up)";

String list_translations18 = 
"#override\n <Btn1Down>:   ListBeginSelect() ListEndSelect()\n <Btn4Up>:     list_scroll(1,17)\n <Btn5Up>:     list_scroll(2,17)\n <Btn2Down>: do_nothing2(2down)\n <Btn2Up>: do_nothing2(2up)";


String list_translations21 = 
"#override\n <Btn1Down>:   ListBeginSelect() ListEndSelect()\n <Btn4Up>:     list_scroll(1,20)\n <Btn5Up>:     list_scroll(2,20)\n <Btn2Down>: do_nothing2(2down)\n <Btn2Up>: do_nothing2(2up)";





String list_translations23 = 
"#override\n <Btn4Up>:          list_scroll(1,23)\n <Btn5Up>:          list_scroll(2,23)\n <Btn2Down>: do_nothing2(2down)\n <Btn2Up>: do_nothing2(2up)";


char list_translations24[1000];




String list_translations25 = 
"#override\n <Btn4Up>:          list_scroll(1,25)\n <Btn5Up>:          list_scroll(2,25)\n <Btn2Down>: do_nothing2(2down)\n <Btn2Up>: do_nothing2(2up)";


char list_translations26[1000];
char list_translations27[1000];



String list_translations28 = 
"#override\n <Btn4Up>: list_scroll(1,28)\n <Btn5Up>: list_scroll(2,28)\n <Btn2Down>: do_nothing2(2down)\n <Btn2Up>: do_nothing2(2up)";





String list_translations29 = 
"#override\n <Btn4Up>:     list_scroll(1,29)\n <Btn5Up>:     list_scroll(2,29)\n <Btn2Down>: do_nothing2(2down)\n <Btn2Up>: do_nothing2(2up)";

String list_translations30 = 
"#override\n <Btn4Up>:     list_scroll(1,30)\n <Btn5Up>:     list_scroll(2,30)\n <Btn2Down>: do_nothing2(2down)\n <Btn2Up>: do_nothing2(2up)";

String list_translations31 = 
"#override\n <Btn4Up>:     list_scroll(1,31)\n <Btn5Up>:     list_scroll(2,31)\n <Btn2Down>: do_nothing2(2down)\n <Btn2Up>: do_nothing2(2up)";

String list_translations32 = 
"#override\n <Btn4Up>:     list_scroll(1,32)\n <Btn5Up>:     list_scroll(2,32)\n <Btn2Down>: do_nothing2(2down)\n <Btn2Up>: do_nothing2(2up)";

String list_translations33 = 
"#override\n <Btn4Up>:     list_scroll(1,33)\n <Btn5Up>:     list_scroll(2,33)\n <Btn2Down>: do_nothing2(2down)\n <Btn2Up>: do_nothing2(2up)";

String list_translations34 = 
"#override\n <Btn4Up>:     list_scroll(1,34)\n <Btn5Up>:     list_scroll(2,34)\n <Btn2Down>: do_nothing2(2down)\n <Btn2Up>: do_nothing2(2up)";

String list_translations35 = 
"#override\n <Btn4Up>:     list_scroll(1,35)\n <Btn5Up>:     list_scroll(2,35)\n <Btn2Down>: do_nothing2(2down)\n <Btn2Up>: do_nothing2(2up)";

String list_translations36 = 
"#override\n <Btn4Up>:     list_scroll(1,36)\n <Btn5Up>:     list_scroll(2,36)\n <Btn2Down>: do_nothing2(2down)\n <Btn2Up>: do_nothing2(2up)";

String list_translations37 = 
"#override\n <Btn4Up>:     list_scroll(1,37)\n <Btn5Up>:     list_scroll(2,37)\n <Btn2Down>: do_nothing2(2down)\n <Btn2Up>: do_nothing2(2up)";



String list_translations38 = 
"#override\n <Btn4Up>:     list_scroll(1,38)\n <Btn5Up>:     list_scroll(2,38)\n <Btn2Down>: do_nothing2(2down)\n <Btn2Up>: do_nothing2(2up)\n <Btn1Down>: do_nothing2(ignore)\n <Btn1Up>: do_nothing2(ignore)";




String list_translations39 = 
"#override\n <Btn4Up>:     list_scroll(1,39)\n <Btn5Up>:     list_scroll(2,39)\n <Btn2Down>: do_nothing2(2down)\n <Btn2Up>: do_nothing2(2up)";

String list_translations40 = 
"#override\n <Btn4Up>:     list_scroll(1,40)\n <Btn5Up>:     list_scroll(2,40)\n <Btn2Down>: do_nothing2(2down)\n <Btn2Up>: do_nothing2(2up)";

String list_translations41 = 
"#override\n <Btn4Up>:     list_scroll(1,41)\n <Btn5Up>:     list_scroll(2,41)\n <Btn2Down>: do_nothing2(2down)\n <Btn2Up>: do_nothing2(2up)";

String list_translations42 = 
"#override\n <Btn4Up>:     list_scroll(1,42)\n <Btn5Up>:     list_scroll(2,42)\n <Btn2Down>: do_nothing2(2down)\n <Btn2Up>: do_nothing2(2up)";

String list_translations43 = 
"#override\n <Btn4Up>:     list_scroll(1,43)\n <Btn5Up>:     list_scroll(2,43)\n <Btn2Down>: do_nothing2(2down)\n <Btn2Up>: do_nothing2(2up)";

String list_translations44 = 
"#override\n <Btn4Up>:     list_scroll(1,44)\n <Btn5Up>:     list_scroll(2,44)\n <Btn2Down>: do_nothing2(2down)\n <Btn2Up>: do_nothing2(2up)";

String list_translations45 = 
"#override\n <Btn4Up>:     list_scroll(1,45)\n <Btn5Up>:     list_scroll(2,45)\n <Btn2Down>: do_nothing2(2down)\n <Btn2Up>: do_nothing2(2up)";

String list_translations46 = 
"#override\n <Btn4Up>:     list_scroll(1,46)\n <Btn5Up>:     list_scroll(2,46)\n <Btn2Down>: do_nothing2(2down)\n <Btn2Up>: do_nothing2(2up)";

String list_translations47 = 
"#override\n <Btn4Up>:     list_scroll(1,47)\n <Btn5Up>:     list_scroll(2,47)\n <Btn2Down>: do_nothing2(2down)\n <Btn2Up>: do_nothing2(2up)";

String list_translations48 = 
"#override\n <Btn4Up>:     list_scroll(1,48)\n <Btn5Up>:     list_scroll(2,48)\n <Btn2Down>: do_nothing2(2down)\n <Btn2Up>: do_nothing2(2up)";

String list_translations49 = 
"#override\n <Btn4Up>:     list_scroll(1,49)\n <Btn5Up>:     list_scroll(2,49)\n <Btn2Down>: do_nothing2(2down)\n <Btn2Up>: do_nothing2(2up)";

String list_translations50 = 
"#override\n <Btn4Up>:     list_scroll(1,50)\n <Btn5Up>:     list_scroll(2,50)\n <Btn2Down>: do_nothing2(2down)\n <Btn2Up>: do_nothing2(2up)";

String list_translations51 = 
"#override\n <Btn4Up>:     list_scroll(1,51)\n <Btn5Up>:     list_scroll(2,51)\n <Btn2Down>: do_nothing2(2down)\n <Btn2Up>: do_nothing2(2up)";

String list_translations52 = 
"#override\n <Btn4Up>:     list_scroll(1,52)\n <Btn5Up>:     list_scroll(2,52)\n <Btn2Down>: do_nothing2(2down)\n <Btn2Up>: do_nothing2(2up)";

String list_translations53 = 
"#override\n <Btn4Up>:     list_scroll(1,53)\n <Btn5Up>:     list_scroll(2,53)\n <Btn2Down>: do_nothing2(2down)\n <Btn2Up>: do_nothing2(2up)";

String list_translations54 = 
"#override\n <Btn4Up>:     list_scroll(1,54)\n <Btn5Up>:     list_scroll(2,54)\n <Btn2Down>: do_nothing2(2down)\n <Btn2Up>: do_nothing2(2up)";

String list_translations55 = 
"#override\n <Btn4Up>:     list_scroll(1,55)\n <Btn5Up>:     list_scroll(2,55)\n <Btn2Down>: do_nothing2(2down)\n <Btn2Up>: do_nothing2(2up)";


String list_translations56 = 
"#override\n <Btn4Up>:     list_scroll(1,56)\n <Btn5Up>:     list_scroll(2,56)\n <Btn2Down>: do_nothing2(2down)\n <Btn2Up>: do_nothing2(2up)";


String list_translations57 = 
"#override\n <Btn4Up>:     list_scroll(1,57)\n <Btn5Up>:     list_scroll(2,57)\n <Btn2Down>: do_nothing2(2down)\n <Btn2Up>: do_nothing2(2up)\n <Btn1Down>: do_nothing2(ignore)\n <Btn1Up>: do_nothing2(ignore)";


String list_translations58 = 
"#override\n <Btn4Up>:     list_scroll(1,58)\n <Btn5Up>:     list_scroll(2,58)\n <Btn2Down>: do_nothing2(2down)\n <Btn2Up>: do_nothing2(2up)";


String list_translations59 = 
"#override\n <Btn4Up>:     list_scroll(1,59)\n <Btn5Up>:     list_scroll(2,59)\n <Btn2Down>: do_nothing2(2down)\n <Btn2Up>: do_nothing2(2up)\n <Btn1Down>: do_nothing2(ignore)\n <Btn1Up>: do_nothing2(ignore)";



String list_translations60 = 
"#override\n <Btn4Up>:     list_scroll(1,60)\n <Btn5Up>:     list_scroll(2,60)\n <Btn2Down>: do_nothing2(2down)\n <Btn2Up>: do_nothing2(2up)";


String list_translations61 = 
"#override\n <Btn4Up>:     list_scroll(1,61)\n <Btn5Up>:     list_scroll(2,61)\n <Btn2Down>: do_nothing2(2down)\n <Btn2Up>: do_nothing2(2up)\n <Btn1Down>: do_nothing2(ignore)\n <Btn1Up>: do_nothing2(ignore)";





String list_translations62 = "#override\n\
\
<Key>a,<Key>b,<Key>c,<Key>d,<Key>e,<Key>f,<Key>g,<Key>h,<Key>i,<Key>j,<Key>k,<Key>l,<Key>m,<Key>n,<Key>o,\
<Key>p,<Key>q,<Key>r,<Key>s,<Key>t,<Key>u,<Key>v,<Key>w,<Key>x,<Key>y,<Key>z,<Key>A,<Key>B,<Key>C,<Key>D,\
<Key>E,<Key>F,<Key>G,<Key>H,<Key>I,<Key>J,<Key>K,<Key>L,<Key>M,<Key>N,<Key>O,<Key>P,<Key>Q,<Key>R,<Key>S,\
<Key>T,<Key>U,<Key>V,<Key>W,<Key>X,<Key>Y,<Key>Z,<Key>1,<Key>2,<Key>3,<Key>4,<Key>5,<Key>6,<Key>7,<Key>8,\
<Key>9,<Key>0,<Key>[,<Key>],<Key>;,<Key>',<Key>.,<Key>/,<Key>0x02c,<Key>0x05c,<Key>osfBackSpace,<Key>osfDelete\
\
\
\
: do_nothing2(ha)\n <Key>osfUp: ListPrevItem() ListKbdSelectAll()\n <Key>osfDown: ListNextItem() ListKbdSelectAll()\n <Btn4Up>:     list_scroll_spec(1,-1)\n <Btn5Up>:     list_scroll_spec(2,-1)\n <Btn2Down>: do_nothing2(2down)\n <Btn2Up>: do_nothing2(2up)";


String list_translations63 = 
"#override\n <Btn4Up>:     list_scroll(1,63)\n <Btn5Up>:     list_scroll(2,63)\n <Btn2Down>: do_nothing2(2down)\n <Btn2Up>: do_nothing2(2up)";


String list_translations64 = 
"#override\n <Btn4Up>:          list_scroll(1,64)\n <Btn5Up>:          list_scroll(2,64)\n <Btn2Down>: do_nothing2(2down)\n <Btn2Up>: do_nothing2(2up)";


String list_translations65 = 
"#override\n <Btn4Up>:          list_scroll(1,65)\n <Btn5Up>:          list_scroll(2,65)\n <Btn2Down>: do_nothing2(2down)\n <Btn2Up>: do_nothing2(2up)";


#if (NGA_TYPE == 1)

  extern char **gifd_class_defns; 
  extern char **gifd_class_names;
  extern char **gifd_class_codes;
  extern char **gifd_attr_types;
  extern char **gifd_attr_defns;
  extern char **gifd_attr_names;
  extern char **gifd_attr_codes;
  extern char **gifd_enum_names;
  extern char **gifd_enum_codes;
  extern int   *gifd_attr_enum_count;
  extern int   *gifd_attr_enum_start;
  extern int GIFD_CLASS_NUM;
  extern int GIFD_ATTR_NUM;
  extern int DOMAINSLEN;
  extern int STRATSLEN;

  extern char *D4_class_defns[]; 
  extern char *D4_class_names[];
  extern char *D4_class_codes[];
  extern char *D4_attr_types[];
  extern char *D4_attr_defns[];
  extern char *D4_attr_names[];
  extern char *D4_attr_codes[];
  extern char *D4_enum_names[];
  extern char *D4_enum_codes[];
  extern int   D4_attr_enum_count[];
  extern int   D4_attr_enum_start[];
  extern char *D4_nunanpo_enum_names[];
  extern char *D4_nunanpo_enum_codes[];
  extern int   D4_nunanpo_attr_enum_count[];
  extern int   D4_nunanpo_attr_enum_start[];
  extern int   D4_CLASS_NUM;
  extern int   D4_ATTR_NUM;
  extern int   D4DOMAINSLEN;
  extern int   D4STRATSLEN;
  extern unsigned char D4DOMAINS[];
  extern unsigned char D4STRATS[];

  extern char *FLDB_class_defns[]; 
  extern char *FLDB_class_names[];
  extern char *FLDB_class_codes[];
  extern char *FLDB_attr_types[];
  extern char *FLDB_attr_defns[];
  extern char *FLDB_attr_names[];
  extern char *FLDB_attr_codes[];
  extern char *FLDB_enum_names[];
  extern char *FLDB_enum_codes[];
  extern int   FLDB_attr_enum_count[];
  extern int   FLDB_attr_enum_start[];
  extern char *FLDB_nunanpo_enum_names[];
  extern char *FLDB_nunanpo_enum_codes[];
  extern int   FLDB_nunanpo_attr_enum_count[];
  extern int   FLDB_nunanpo_attr_enum_start[];
  extern int   FLDB_CLASS_NUM;
  extern int   FLDB_ATTR_NUM;
  extern int   FLDBDOMAINSLEN;
  extern int   FLDBSTRATSLEN;
  extern unsigned char FLDBDOMAINS[];
  extern unsigned char FLDBSTRATS[];

  extern char *VMAP_class_defns[]; 
  extern char *VMAP_class_names[];
  extern char *VMAP_class_codes[];
  extern char *VMAP_attr_types[];
  extern char *VMAP_attr_defns[];
  extern char *VMAP_attr_names[];
  extern char *VMAP_attr_codes[];
  extern char *VMAP_enum_names[];
  extern char *VMAP_enum_codes[];
  extern int   VMAP_attr_enum_count[];
  extern int   VMAP_attr_enum_start[];
  extern char *VMAP_nunanpo_enum_names[];
  extern char *VMAP_nunanpo_enum_codes[];
  extern int   VMAP_nunanpo_attr_enum_count[];
  extern int   VMAP_nunanpo_attr_enum_start[];
  extern int   VMAP_CLASS_NUM;
  extern int   VMAP_ATTR_NUM;
  extern int   VMAPDOMAINSLEN;
  extern int   VMAPSTRATSLEN;
  extern unsigned char VMAPDOMAINS[];
  extern unsigned char VMAPSTRATS[];

  extern char *MGCP3_class_defns[]; 
  extern char *MGCP3_class_names[];
  extern char *MGCP3_class_codes[];
  extern char *MGCP3_attr_types[];
  extern char *MGCP3_attr_defns[];
  extern char *MGCP3_attr_names[];
  extern char *MGCP3_attr_codes[];
  extern char *MGCP3_enum_names[];
  extern char *MGCP3_enum_codes[];
  extern int   MGCP3_attr_enum_count[];
  extern int   MGCP3_attr_enum_start[];
  extern int   MGCP3_CLASS_NUM;
  extern int   MGCP3_ATTR_NUM;
  extern int   MGCP3DOMAINSLEN;
  extern int   MGCP3STRATSLEN;
  extern unsigned char MGCP3DOMAINS[];
  extern unsigned char MGCP3STRATS[];

 
  extern char *MGCP4_class_defns[]; 
  extern char *MGCP4_class_names[];
  extern char *MGCP4_class_codes[];
  extern char *MGCP4_attr_types[];
  extern char *MGCP4_attr_defns[];
  extern char *MGCP4_attr_names[];
  extern char *MGCP4_attr_codes[];
  extern char *MGCP4_enum_names[];
  extern char *MGCP4_enum_codes[];
  extern int   MGCP4_attr_enum_count[];
  extern int   MGCP4_attr_enum_start[];
  extern int   MGCP4_CLASS_NUM;
  extern int   MGCP4_ATTR_NUM;
  extern int   MGCP4DOMAINSLEN;
  extern int   MGCP4STRATSLEN;
  extern unsigned char MGCP4DOMAINS[];
  extern unsigned char MGCP4STRATS[];


#if(USE_UFD==1)
  extern char *UFD1_class_defns[]; 
  extern char *UFD1_class_names[];
  extern char *UFD1_class_codes[];
  extern char *UFD1_attr_types[];
  extern char *UFD1_attr_defns[];
  extern char *UFD1_attr_names[];
  extern char *UFD1_attr_codes[];
  extern char *UFD1_enum_names[];
  extern char *UFD1_enum_codes[];
  extern int   UFD1_attr_enum_count[];
  extern int   UFD1_attr_enum_start[];
  extern char *UFD1_nunanpo_enum_names[];
  extern char *UFD1_nunanpo_enum_codes[];
  extern int   UFD1_nunanpo_attr_enum_count[];
  extern int   UFD1_nunanpo_attr_enum_start[];
  extern int   UFD1_CLASS_NUM;
  extern int   UFD1_ATTR_NUM;
  extern int   UFD1DOMAINSLEN;
  extern int   UFD1STRATSLEN;
  extern unsigned char UFD1DOMAINS[];
  extern unsigned char UFD1STRATS[];


  extern char *UFD2_class_defns[]; 
  extern char *UFD2_class_names[];
  extern char *UFD2_class_codes[];
  extern char *UFD2_attr_types[];
  extern char *UFD2_attr_defns[];
  extern char *UFD2_attr_names[];
  extern char *UFD2_attr_codes[];
  extern char *UFD2_enum_names[];
  extern char *UFD2_enum_codes[];
  extern int   UFD2_attr_enum_count[];
  extern int   UFD2_attr_enum_start[];
  extern char *UFD2_nunanpo_enum_names[];
  extern char *UFD2_nunanpo_enum_codes[];
  extern int   UFD2_nunanpo_attr_enum_count[];
  extern int   UFD2_nunanpo_attr_enum_start[];
  extern int   UFD2_CLASS_NUM;
  extern int   UFD2_ATTR_NUM;
  extern int   UFD2DOMAINSLEN;
  extern int   UFD2STRATSLEN;
  extern unsigned char UFD2DOMAINS[];
  extern unsigned char UFD2STRATS[];


  extern char *UFD3_class_defns[]; 
  extern char *UFD3_class_names[];
  extern char *UFD3_class_codes[];
  extern char *UFD3_attr_types[];
  extern char *UFD3_attr_defns[];
  extern char *UFD3_attr_names[];
  extern char *UFD3_attr_codes[];
  extern char *UFD3_enum_names[];
  extern char *UFD3_enum_codes[];
  extern int   UFD3_attr_enum_count[];
  extern int   UFD3_attr_enum_start[];
  extern char *UFD3_nunanpo_enum_names[];
  extern char *UFD3_nunanpo_enum_codes[];
  extern int   UFD3_nunanpo_attr_enum_count[];
  extern int   UFD3_nunanpo_attr_enum_start[];
  extern int   UFD3_CLASS_NUM;
  extern int   UFD3_ATTR_NUM;
  extern int   UFD3DOMAINSLEN;
  extern int   UFD3STRATSLEN;
  extern unsigned char UFD3DOMAINS[];
  extern unsigned char UFD3STRATS[];
#endif


#if(USE_TDS==1)
  extern char *TDS4_class_defns[]; 
  extern char *TDS4_class_names[];
  extern char *TDS4_class_codes[];
  extern char *TDS4_attr_types[];
  extern char *TDS4_attr_defns[];
  extern char *TDS4_attr_names[];
  extern char *TDS4_attr_codes[];
  extern char *TDS4_enum_names[];
  extern char *TDS4_enum_codes[];
  extern int   TDS4_attr_enum_count[];
  extern int   TDS4_attr_enum_start[];
  extern int   TDS4_CLASS_NUM;
  extern int   TDS4_ATTR_NUM;
  extern int   TDS4DOMAINSLEN;
  extern int   TDS4STRATSLEN;
  extern unsigned char TDS4DOMAINS[];
  extern unsigned char TDS4STRATS[];

  extern char *TDS6_class_defns[]; 
  extern char *TDS6_class_names[];
  extern char *TDS6_class_codes[];
  extern char *TDS6_attr_types[];
  extern char *TDS6_attr_defns[];
  extern char *TDS6_attr_names[];
  extern char *TDS6_attr_codes[];
  extern char *TDS6_enum_names[];
  extern char *TDS6_enum_codes[];
  extern int   TDS6_attr_enum_count[];
  extern int   TDS6_attr_enum_start[];
  extern int   TDS6_CLASS_NUM;
  extern int   TDS6_ATTR_NUM;
  extern int   TDS6DOMAINSLEN;
  extern int   TDS6STRATSLEN;
  extern unsigned char TDS6DOMAINS[];
  extern unsigned char TDS6STRATS[];
#endif


#if(USE_NFDD==1)

  extern char *NFDD_class_defns[]; 
  extern char *NFDD_class_names[];
  extern char *NFDD_class_codes[];
  extern char *NFDD_attr_types[];
  extern char *NFDD_attr_defns[];
  extern char *NFDD_attr_names[];
  extern char *NFDD_attr_codes[];
  extern char *NFDD_enum_names[];
  extern char *NFDD_enum_codes[];
  extern int   NFDD_attr_enum_count[];
  extern int   NFDD_attr_enum_start[];
  extern char *NFDD_nunanpo_enum_names[];
  extern char *NFDD_nunanpo_enum_codes[];
  extern int   NFDD_nunanpo_attr_enum_count[];
  extern int   NFDD_nunanpo_attr_enum_start[];
  extern int   NFDD_CLASS_NUM;
  extern int   NFDD_ATTR_NUM;
  extern int   NFDDDOMAINSLEN;
  extern int   NFDDSTRATSLEN;
  extern unsigned char NFDDDOMAINS[];
  extern unsigned char NFDDSTRATS[];

#else  
char *NFDD_attr_types[] = {
"Nothing"
};
#endif


#if(USE_DFDD==1)

  extern char *DFDD_class_defns[]; 
  extern char *DFDD_class_names[];
  extern char *DFDD_class_codes[];
  extern char *DFDD_attr_types[];
  extern char *DFDD_attr_defns[];
  extern char *DFDD_attr_names[];
  extern char *DFDD_attr_codes[];
  extern char *DFDD_enum_names[];
  extern char *DFDD_enum_codes[];
  extern int   DFDD_attr_enum_count[];
  extern int   DFDD_attr_enum_start[];
  extern char *DFDD_nunanpo_enum_names[];
  extern char *DFDD_nunanpo_enum_codes[];
  extern int   DFDD_nunanpo_attr_enum_count[];
  extern int   DFDD_nunanpo_attr_enum_start[];
  extern int   DFDD_CLASS_NUM;
  extern int   DFDD_ATTR_NUM;
  extern int   DFDDDOMAINSLEN;
  extern int   DFDDSTRATSLEN;
  extern unsigned char DFDDDOMAINS[];
  extern unsigned char DFDDSTRATS[];

#else  

char *DFDD_attr_types[] = {
"Nothing"
};

#endif

  extern char *SAC_class_defns[]; 
  extern char *SAC_class_names[];
  extern char *SAC_class_codes[];
  extern char *SAC_attr_types[];
  extern char *SAC_attr_defns[];
  extern char *SAC_attr_names[];
  extern char *SAC_attr_codes[];
  extern char *SAC_enum_names[];
  extern char *SAC_enum_codes[];
  extern int   SAC_attr_enum_count[];
  extern int   SAC_attr_enum_start[];
  extern int   SAC_CLASS_NUM;
  extern int   SAC_ATTR_NUM;
  extern int   SACDOMAINSLEN;
  extern int   SACSTRATSLEN;
  extern unsigned char SACDOMAINS[];
  extern unsigned char SACSTRATS[];


#if (USE_GGDM==1)

  extern char *GGDM21_class_defns[]; 
  extern char *GGDM21_class_names[];
  extern char *GGDM21_class_codes[];
  extern char *GGDM21_attr_types[];
  extern char *GGDM21_attr_defns[];
  extern char *GGDM21_attr_names[];
  extern char *GGDM21_attr_codes[];
  extern char *GGDM21_enum_names[];
  extern char *GGDM21_enum_codes[];
  extern int   GGDM21_attr_enum_count[];
  extern int   GGDM21_attr_enum_start[];
  extern int   GGDM21_CLASS_NUM;
  extern int   GGDM21_ATTR_NUM;
  extern int   GGDM21DOMAINSLEN;
  extern int   GGDM21STRATSLEN;
  extern unsigned char GGDM21DOMAINS[];
  extern unsigned char GGDM21STRATS[];

  extern char *GGDM22_U_class_defns[]; 
  extern char *GGDM22_U_class_names[];
  extern char *GGDM22_U_class_codes[];
  extern char *GGDM22_U_attr_types[];
  extern char *GGDM22_U_attr_defns[];
  extern char *GGDM22_U_attr_names[];
  extern char *GGDM22_U_attr_codes[];
  extern char *GGDM22_U_enum_names[];
  extern char *GGDM22_U_enum_codes[];
  extern int   GGDM22_U_attr_enum_count[];
  extern int   GGDM22_U_attr_enum_start[];
  extern int   GGDM22_U_CLASS_NUM;
  extern int   GGDM22_U_ATTR_NUM;
  extern int   GGDM22_UDOMAINSLEN;
  extern int   GGDM22_USTRATSLEN;
  extern unsigned char GGDM22_UDOMAINS[];
  extern unsigned char GGDM22_USTRATS[];

  extern char *GGDM3_class_defns[]; 
  extern char *GGDM3_class_names[];
  extern char *GGDM3_class_codes[];
  extern char *GGDM3_attr_types[];
  extern char *GGDM3_attr_defns[];
  extern char *GGDM3_attr_names[];
  extern char *GGDM3_attr_codes[];
  extern char *GGDM3_enum_names[];
  extern char *GGDM3_enum_codes[];
  extern int   GGDM3_attr_enum_count[];
  extern int   GGDM3_attr_enum_start[];
  extern int   GGDM3_CLASS_NUM;
  extern int   GGDM3_ATTR_NUM;
  extern int   GGDM3DOMAINSLEN;
  extern int   GGDM3STRATSLEN;
  extern unsigned char GGDM3DOMAINS[];
  extern unsigned char GGDM3STRATS[];

#endif

  int INscc_loop; 
  int INsac_loop; 



#else

extern int GIFD_CLASS_NUM ;
extern int GIFD_ATTR_NUM  ;       
extern char **gifd_attr_codes ;  
extern char **gifd_class_codes;
extern char **gifd_class_names;




#endif




int SLASHTYPE   = 0;
int  cond_start_onoff = 0;

int TEMP_ATTRIBUTION_TYPE = 0;  

int ATTRIBUTION_INFO_TYPE = 2;


int ATTRIBUTION_TYPE = 2; 





double FinalSortPercent = 0.0;
double GridSigPercent = 0.0;

unsigned int EXTRACT_POINTS_DONE;
unsigned int EXTRACT_LINEARS_DONE;
unsigned int EXTRACT_AREALS_DONE;
unsigned int EXTRACT_GRIDS_DONE;
long int EXTRACT_STARTTIME;
char EXTRACT_EXTRA_STR[1000];
char EXTRACT_TIME[1000];


int INFO_DOMAIN      = 0;
int INFO_LENGTH      = 1;
int INFO_AREA        = 1;
int INFO_GEOMETRY    = 1;
int INFO_FID         = 1;
int INFO_GFID        = 1;
int INFO_COORDS      = 0;
int INFO_ATTRIBUTES  = 1;
int INFO_ATTR_LABELS = 0;
int INFO_ATTR_VALUES = 1;
int INFO_HEX         = 0;
int INFO_GRIDVALUES  = 1;
 
int LOAD_SETTINGS_UP = 0;
int SAVE_CREPORT_UP  = 0;
int SAVE_SETTINGS_UP = 0;
int CO_INNITTED      = 0;
int LAYER_GEOM_UP    = 0;
int LAYER_FC_UP      = 0;
int LAYER_MGCP_UP    = 0;

int LOAD_NETSETTINGS_UP = 0;


Widget msgdialogs[5000];
Widget cascade[10];


#if(NGA_TYPE==1)


int DOMAIN_R[NUM_D] = {DKCYAN_R, PURPLE_R, YELLOW_R, YELLOW_R, SALMON_R, BROWN_R, BLACK_R,
		       BLUE_R, PURPLE_R, BLUE_R, BROWN_R, PURPLE_R, LTCYAN_R, BROWN_R,
		       BROWN_R, MAGENTA_R, LTGREEN_R, TAN_R};
int DOMAIN_G[NUM_D] = {DKCYAN_G, PURPLE_G, YELLOW_G, YELLOW_G, SALMON_G, BROWN_G, BLACK_G,
		       BLUE_G, PURPLE_G, BLUE_G, BROWN_G, PURPLE_G, LTCYAN_G, BROWN_G,
		       BROWN_G, MAGENTA_G, LTGREEN_G, TAN_G};
int DOMAIN_B[NUM_D] = {DKCYAN_B, PURPLE_B, YELLOW_B, YELLOW_B, SALMON_B, BROWN_B, BLACK_B,
		       BLUE_B, PURPLE_B, BLUE_B, BROWN_B, PURPLE_B, LTCYAN_B, BROWN_B,
		       BROWN_B, MAGENTA_B, LTGREEN_B, TAN_B};

int DOMAIN_DEFAULT_COLOR[NUM_D] = {
  DRAW_COLOR_DKCYAN,
  DRAW_COLOR_PURPLE,
  DRAW_COLOR_YELLOW,
  DRAW_COLOR_YELLOW,
  DRAW_COLOR_SALMON,
  DRAW_COLOR_BROWN,
  DRAW_COLOR_BLACK,
  DRAW_COLOR_BLUE,
  DRAW_COLOR_PURPLE,
  DRAW_COLOR_BLUE,
  DRAW_COLOR_BROWN,
  DRAW_COLOR_PURPLE,
  DRAW_COLOR_LTCYAN,
  DRAW_COLOR_BROWN,
  DRAW_COLOR_BROWN,
  DRAW_COLOR_MAGENTA,
  DRAW_COLOR_LTGREEN,
  DRAW_COLOR_TAN,
  DRAW_COLOR_BLACK
};



#else

int DOMAIN_R[NUM_D] = {GRAY4_R, LTCYAN_R, DKCYAN_R, YELLOW_R, LTGREEN_R, PURPLE_R, BLUE_R,
		       LTCYAN_R, DKCYAN_R, LAVENDER_R, BLUE_R, BROWN_R, MEDGREEN_R, LTCYAN_R, DKCYAN_R,
		       PURPLE_R, MEDGREEN2_R, MEDGREEN2_R, MEDGREEN2_R};
int DOMAIN_G[NUM_D] = {GRAY4_G, LTCYAN_G, DKCYAN_G, YELLOW_G, LTGREEN_G, PURPLE_G, BLUE_G,
		       LTCYAN_G, DKCYAN_G, LAVENDER_G, BLUE_G, BROWN_G, MEDGREEN_G, LTCYAN_G, DKCYAN_G,
		       PURPLE_G, MEDGREEN2_G, MEDGREEN2_G, MEDGREEN2_G};
int DOMAIN_B[NUM_D] = {GRAY4_B, LTCYAN_B, DKCYAN_B, YELLOW_B, LTGREEN_B, PURPLE_B, BLUE_B,
		       LTCYAN_B, DKCYAN_B, LAVENDER_B, BLUE_B, BROWN_B, MEDGREEN_B, LTCYAN_B, DKCYAN_B,
		       PURPLE_B, MEDGREEN2_B, MEDGREEN2_B, MEDGREEN2_B};

int DOMAIN_DEFAULT_COLOR[NUM_D] = {
  DRAW_COLOR_GRAY4,
  DRAW_COLOR_LTCYAN,
  DRAW_COLOR_DKCYAN,
  DRAW_COLOR_YELLOW,
  DRAW_COLOR_LTGREEN,
  DRAW_COLOR_PURPLE,
  DRAW_COLOR_BLUE,
  DRAW_COLOR_LTCYAN,
  DRAW_COLOR_DKCYAN,
  DRAW_COLOR_LAVENDER,
  DRAW_COLOR_BLUE,
  DRAW_COLOR_BROWN,
  DRAW_COLOR_MEDGREEN,
  DRAW_COLOR_LTCYAN,
  DRAW_COLOR_DKCYAN,
  DRAW_COLOR_PURPLE,
  DRAW_COLOR_MEDGREEN2,
  DRAW_COLOR_MEDGREEN2,
  DRAW_COLOR_MEDGREEN2
};

#endif

int METATYPE   = 1; 
int BATCH_FAIL = 0;
int MASTERTYPE = 1;

int layers_innitted=0;
int    *layers_up;
unsigned char  *profiling_layers;
XColor *layer_colors;
Widget *layer_colorwindows;
Pixmap *layer_colorpix;
Widget *toplevel;
Widget *scale1;
Widget *scale2;
Widget *scale3;
Widget *layer_text1;
Widget *layer_text2;
Widget *layer_text3;



int AREALNODELIMIT  =  50000000;   
int LINEARNODELIMIT =  50000000;   


int EAREALNODELIMIT  = 5000000;  
int ELINEARNODELIMIT = 5000000;  
int EGRIDNODELIMIT   = 5000000;  


unsigned char PolyPixels[2500][2500]; 
char GAITProjectName[1000];


int DRAWING_MARKERS = 0;
int HyperClassUp[INscc_array];  
int HyperAttrUp [INsac_array];

int DRAWING_NETWORKS = 0;


char outshpname[1000];
int SPECIAL_NAME = 0;



unsigned char UNIQSCC[INscc_array];
unsigned char UNIQSAC[INsac_array];
int UNIQARRAYBUILT = 0;
int UNIQSCCNUM = 0;
int UNIQSACNUM = 0;
int CLONE_DEFINITIONS=0;
int NO_CIRCLES=0;


short int PixArray[1050][900];
short int PixArray2[1050][900];
int DetailedInfo=0;


#define UNITLIMIT 1
#define QUICKDEBUG 0


char *CENTERCNAME[NUM_C]={"         Unassigned         ",
			  "            Area            ",
			  "        Directed Line       ",
			  "       Footprint Model      ",
			  "            Line            ",
			  "        Point Feature       ",
			  "         Point Model        ",
			  "          Polygon           ",
			  "       Dynamic Model        ",
			  "            Grid            ",
			  "    Collision Volume (S)    ",
			  "    Collision Volume (P)    ",
			  "   Model Library Polygon    ",
			  "Feature Model Point Feature ",
			  "Feature Model Linear Feature",
			  "Feature Model Areal Feature "};


char *CNAME[NUM_C]={"Unassigned",
		    "Area","Directed Line",
		    "Footprint Model",
		    "Line",
		    "Point Feature",
		    "Point Model",
		    "Polygon",
		    "Dynamic Model",
		    "Grid",
		    "Collision Volume (S)",
		    "Collision Volume (P)",
		    "Model Library Polygon",
		    "Feature Model Point Feature",
		    "Feature Model Linear Feature",
		    "Feature Model Areal Feature"};

char *CNAMES[NUM_C]={"Unassigned",
		    "Area","Directed Line",
		    "Footprint Model",
		    "Line",
		    "Point",
		    "Point Model",
		    "Polygon",
		    "Dynamic Model",
		    "Grid",
		    "Collision Volume (S)",
		    "Collision Volume (P)",
		    "Model Library Polygon",
		    "Feature Model Point Feature",
		    "Feature Model Linear Feature",
		    "Feature Model Areal Feature"};



#if(NGA_TYPE==1)
char *DNAME[NUM_D]={"Aeronautical",
		    "Aids to Navigation",
		    "Boundaries",
		    "Data Quality",
		    "Defensive Structures",
		    "Elevation",
		    "Ground Transportation",
		    "Inland Water",
		    "Maritime Limits",
		    "Ocean Environment",
		    "Physiography",
		    "Population",
		    "Ports and Harbors",
		    "Slope Polygon",
		    "Surface Materials",
		    "Utilities and Industry",
		    "Vegetation",
		    "General",
                    "special-unused-xyz"};

char *MGCPNAME[NUM_D]={
	        "Other",
		    "Activity",
		    "Landcover",
		  };

#else
char *DNAME[NUM_D]={"Unassigned",
		    "Air Mobility",
		    "Air Obstacle",
		    "Boundary",
		    "Bridging",
		    "Cultural",
		    "Inland Water",
		    "Land Mobility",
		    "Land Obstacle",
		    "Military Use",
		    "Open Water",
		    "Terrain",
		    "Vegetation",
		    "Maritime Mobility",
		    "Maritime Obstacle", 
		    "Maritime Culture",
		    "Weather",
		    "Space",
		    "Descriptive"};
char *MGCPNAME[NUM_D]={
	        "Other",
		    "Activity",
		    "Landcover",
		  };

#endif



int attr_min,attr_max,attr_color=27;
int stipple_choice = 3;
int SHAPE_EXPORT = 0;
int SHAPE_PASS   = 0;
int CONDITIONSHAPE=1;
int SHAPE_SILENT = 0;

int PossibleToCenterZoom    = 0;
int PossibleToCenterNetZoom = 0;
int CenterZoomOnErrors      = 1;
int CenterZoomOnNets        = 0;
int CenterZoomOnVertices    = 0;
double PAD_DIST  = DEFAULT_PAD_DIST; 
double NPAD_DIST = 100;              
double VPAD_DIST = DEFAULT_PAD_DIST; 
double PPAD_DIST = DEFAULT_PAD_DIST; 
int ADD_HIST=1;
int InfoItemsQueried;


double *XNEW4 = NULL;
double *YNEW4 = NULL;
XPoint * Drawpoints;
XPoint * PolyPoints;
XPoint *hole_points;
int num_hole_points = 0;
int RETURN_VERTS    = 0;

int polyptsallocced=0;
int pix_wid1=10  ; 
int pix_wid2=100 ; 
int pix_wid3=500 ; 
int pix_wid4=1200; 
int pix_wid5=2500; 

int MAXVERTSFOUND=0;


int DIGITS_TO_PRINT = 10; 


int CLIPEXTRACT = 0;


#if(NGA_TYPE==1)
double CLIPLLX = -180.000;
double CLIPLLY =  -90.000;
double CLIPURX =  180.000;
double CLIPURY =   90.000;
#else
double CLIPLLX = -9999999;
double CLIPLLY = -9999999;
double CLIPURX =  9999999;
double CLIPURY =  9999999;
#endif



double ErrLLX;
double ErrLLY;
double ErrURX;
double ErrURY;
 
double IMinXcoord;
double IMinYcoord; 
double IMaxXcoord;
double IMaxYcoord;


double *Iintvalues    = NULL;
int *Iintindices   = NULL;
double *Ifloatvalues  = NULL;
int *Ifloatindices = NULL;



int do_long_way = 1;




int SAVED_VIEWS=0;
int CURRENT_ZOOM = 0;


double SAVE_LLX[ZOOM_REMEMBER_NUM+1];
double SAVE_LLY[ZOOM_REMEMBER_NUM+1];
double SAVE_URX[ZOOM_REMEMBER_NUM+1];
double SAVE_URY[ZOOM_REMEMBER_NUM+1];
double SAVE_UNI[ZOOM_REMEMBER_NUM+1];
double SAVE_XSB[ZOOM_REMEMBER_NUM+1];
double SAVE_YSB[ZOOM_REMEMBER_NUM+1];


int CLAMPFEATURES=0;
int CIRCLESIZE=10;
int NOT_ZOOMED=1;
int INVERT_3x3 = 0;
int DOMODELPOLYS = 1;
int DOMODELSUMMARY = 0;
int DOTHEDUPES = 0;
int busyinnitting=0;



int SHOW_POLY_VERTICES=0;
int SHOW_LINE_VERTICES=0;
int SHOW_END_VERTICES=0;

unsigned char InfoSac[INsac_array+10];


int num_highlights=0;
int highlight_starts[HIGHLIGHTMAX];
int highlight_ends  [HIGHLIGHTMAX];

int num_highlights2=0;
int highlight_starts2[HIGHLIGHTMAX];
int highlight_ends2  [HIGHLIGHTMAX];
double IRegionSize;



int FLIP=1; 





struct ErrData
{
  int errnum;
  int instance;
  int axis;
};


struct InfoPrintContent *InfoRoot = NULL;







struct CondHighlight ***MasterHighlighter = NULL;
unsigned char **MasterStacker=NULL;


char **GAITProjList = NULL;


char **GAITExFileList = NULL;


char **GAITCondList = NULL;


char **GAITPrevList = NULL;


char **GAITAOIList = NULL;


char **GAITPrefList = NULL;


char **TempFolderList = NULL;



char **TempFileList = NULL;





struct BOList
{
  int ob_num;
  int errnum;
  int instance;
  int viewall;
  int viewsome;
  int selectcount;
  int *selectlist;
  int *speclist;
  Widget allwid,somewid;
  struct BOList * next;
};

struct BOList *BOOnList = NULL;









struct BOLevelList
{
  int ob_num;
  int group_num;
  int errnum;
  int instance;
  struct BOLevelList * next;
};

struct BOLevelList *BOLevelListRoot = NULL;











struct BOSave2
{
  int errnum;
  int num_errs;
  int instance;
  double magnitude;
  int ECC2;
  int LLindex2;
  int specnum;
};
struct BOSave
{
  char geomtype;
  double idindex;
  int ECC1;
  int LLindex1;
  int thisnum;
  int groupinout[NUMCHECKGROUPS];  
  struct BOSave2 *conds;           
};

int BOSaveCount = 0;
struct BOSave BOSaveArray[25];




struct EDCSLookup edcsstruct;




struct FixLine
{
  char errtype[20];
  int fixtype;
  char object_id [IDSIZE];
  char object_id2[IDSIZE];
  double xpoint;
  double ypoint;
};

struct FixLine * fixentries;




int OnOff1;
int OnOff2[NUMCHECKGROUPS];

int VCOnOff1;
int VCOnOff2[NUMCHECKGROUPS];
int VCOnOff3[CONDITION_ARRAY_SIZE];


int FCOnOff1;
int FCOnOff2[NUMCHECKGROUPS];
int FCOnOff3[CONDITION_ARRAY_SIZE];


int NETOnOff1;


int PFOnOff1   = 1;
int SFOnOff1   = 1;
int ES1OnOff1  = 1;
int ES2OnOff1  = 1;
int TXTOnOff1  = 1;
int DATAOnOff1 = 1;
int XML1OnOff1 = 1;
int XML2OnOff1 = 1;
int XML3OnOff1 = 1;
int CAOnOff1   = 1;
int DPOnOff1   = 1;
int NPDPOnOff1 = 1;
int BROnOff1   = 1;
int NPBROnOff1 = 1;


int NPPFOnOff1   = 0;
int NPSFOnOff1   = 0;
int NPES1OnOff1  = 0;
int NPES2OnOff1  = 0;
int NPTXTOnOff1  = 0;
int NPDATAOnOff1 = 0;
int NPXML1OnOff1 = 0;
int NPXML2OnOff1 = 0;
int NPXML3OnOff1 = 0;
int NPCAOnOff1   = 0;



int BOOnOff1=1;
int alloced_boonoff2 = 0;
int *BOOnOff2;

int ABORT_ROUTING=0;



int MaxECCLenFound=0;
int L_RECNUM = 0;
int P_RECNUM = 0;
FILE *l_outfile;
FILE *p_outfile;
FILE *l_outDBfile;
FILE *p_outDBfile;
FILE *silentfile=NULL;

int l_bytes_written = 0;
int p_bytes_written = 0;
int    *G_l_length;
int    *G_l_offsets;
int    *G_p_length;
int    *G_p_offsets;
int temp_SH_endianness;
int MY_ARRAY_INNITTED=0;
double thex,they; 


int SunAzimuth = 315;
int SunAngle   = 45;
int VertExag = 1;

int ZoomSunAzimuth = 315;
int ZoomSunAngle   = 45;
double ZoomVertExag = 1.0;


int num_t_dupes=0;

String 
  help3 = "Left: Zoom in on a box   ESC: abort zoom    ",
  help4 = "Left: Select a region to obtain information on    Right: get (x,y,z)",
  help7 = "Left: Click and drag a line for a terrain profile.",
  help8 = "Left: Click and drag a line for an LOS fan.",
  help9 = "Left: Click and drag on the map to pan";




XmString  text_help;
XmString TempQASTbigmessage;
XmFontList    	fontlist;





int circlecount = 0;
int linecount   = 0;
int polycount   = 0;
int gridcount   = 0;


unsigned char LODS_INNITTED = 0;

struct SACarray * SACARRAY=NULL;
struct SCCarray * SCCARRAY=NULL;
int SCCARRAY_INDICES = 0;
int SACARRAY_INDICES = 0;



struct SCCstoreint * SCC_LIST;
unsigned char SCC_LIST_INNITTED = 0;
int SCC_NUM = 0; 

struct SCCstoreint * DYNAMIC_SCC_LIST;
unsigned char DYNAMIC_SCC_LIST_INNITTED = 0;
int DYNAMIC_SCC_NUM = 0; 

unsigned char DrawByConfig [NUM_C];
unsigned char DrawByStratum[NUM_S]; 
unsigned char DrawByDomain [NUM_D];

int DoMetadataChecking     = 1;
int DoAttrChecking         = 1;
int AppendInputSpec        = 0;
int DoShort                = 0;
int DrawUserGrid           = 0;   
int DrawUserGridL          = 0;   
int DrawOneDegreeGrid      = 0;   
int DrawOneDegreeGridL     = 0;   
int DrawHalfDegreeGrid     = 0;   
int DrawHalfDegreeGridL    = 0;   
int DrawQuarterDegreeGrid  = 0;   
int DrawQuarterDegreeGridL = 0;   
int DrawLabels             = 0;   
int TYPE                   = -1;  
int ABORT_EXTRACT          = 0;   
int ABORT_CONCAT           = 0;   
int ABORT_ZOOM             = 0;   


int area_index=0;
int Current_head=1;
int Current_net_head=1;
int credits=0; 

int FORMAT_BEGIN=0;                     
int FILL_FLAG=4;                     
int GRID=0;                          
int P_window=0;                      
int SPEC_WIN=0;                      
int REC_WIN=0;                       
int LOS_WIN=0;                       
int CONTOUR_WIN=0;                   
int GRID_WIN=0;                      
int BAD_BEGIN_PROFILE=1;             
int BAD_PROFILE=1;                   
int BAD_FAN=1;                       
int BAD_ZOOM=1;                      
int BAD_PAN=1;                       
int BAD_INFO=1;                      
int FAN_INFO=0;                      
int ERR_INFO=0;                      
int FIX_RUNNING=0;
int XML_RUNNING=0;
int XML_TRD_TYPE=4;                  
int DP_TRD_TYPE=4;                   
int RUNNING_INFO=0;                  
int PATCH_WIN=0;   
int IMPORT_WIN=0;                    
int STF_INPUT=0;                  
int PATCH_INPUT=0;                  
int IMPORT_INPUT=0;                  
int IMPORT_OUTPUT=0;
int SHAPE_IMPORT_OUTPUT=0;
int STOP_FIX_FLAG=0;
int STOP_FLAG=0;
int FAN_QUALITY = 5;               
int MARK_SHAPE=0;                  
int MARK_COLOR=1;                  
int HELP_UP[CONDITION_ARRAY_SIZE]; 
int BUSY=0;                        
                                    
int GRID_THICKNESS    = 1;         
int END_LINE_COLOR    = 999;       
int POLY_SHAPE        = 2;         
int LINE_SHAPE        = 2;         
int END_LINE_SHAPE    = 2;         
int POLY_COLOR        = 999;       
int LINE_COLOR        = 999;       
int GRID_COLOR        = 51;        
int GRID_LABEL_COLOR  = 51;        
int AOI_SAVE_UP       = 0;
int AOI_SHAPE_UP      = 0;
int metabrowse_up     = 0;
int AOI_LOAD_UP       = 0;
int PAD_UP            = 0;
int VPAD_UP           = 0;
int NPAD_UP           = 0;
int ABNORMAL_LOAD_UP  = 0;
int DO_LINES          = 1;
int DO_DESCRIBE       = 0;        
int batch_mode        = 0;
int GROW_MODELS       = 0;        
int GROW_STAMPS       = 0;        
int SACARRAYBUILT     = 0;
int SCCARRAYBUILT     = 0;
int MAX_ZOOM          = 0;        
int info_window_up    = 0;
int DRAW_ONLY         = 0;
int DRAW_VERTICES     = 0;
int DRAWING_INFO_ITEM = 0;
int DRAW_NOW          = -1;
int OVERRIDING_STYLE  = 1;
int DO_OVERRIDE       = 0;
int prev_up           = 0;
int pref_up           = 0;
int overwrite1_up     = 0;
int overwrite3_up     = 0;
int overwrite6_up     = 0;



FILE *IIDD,*IIDH;

int IUseDMScoordinates = 0;





int SEDIDRecordSize = 2 * (sizeof(unsigned char) + sizeof(unsigned short int));



int SzC = sizeof(struct ECCtgtList);
int SzA = sizeof(struct EACtgtList);

double OBS_HEIGHT =  1.7;    
double TGT_HEIGHT =  1.7;    
double FAN_ANGLE  = 45.0;    




char outgrid [100];
char outgrid2[100];
char outgrid3[100];
double OutGridX=-1,OutGridY=-1,OutGridND=-1,OutGridSpace=-1;
int OutGridXNum=-1,OutGridYNum=-1;

char stffix              [1000];
char patchfile           [1000];
char importdirectory     [1000];
char importoutputdir     [1000];
char shapeimportoutputdir[1000];
char metamapfile         [1000];
char ntname              [1000];
char boname              [1000];
char esname              [1000];
char lkname              [1000];
char nsname              [1000];
char smname              [1000];
char vrname              [1000];
char Sum1ESname          [1000];
char Sum2ESname          [1000];
char Sum3ESname          [1000];
char dp1name             [1000];
char dp2name             [1000];
char XML1name            [1000];
char XML2name            [1000];
char XML3name            [1000];
char SaveSettingName      [100];
char SaveReportName       [100];
char SavePrefName         [100];
char SaveAOIName          [100];
char SaveAOIShapeName     [100];
char SaveLayerName        [100];

int num_user_meta = 0;
int *MetaUserValue = NULL;
char **MetaUser = NULL;





unsigned int PixDBWidth,PixDBHeight;
double DBWidth,DBHeight;



double urx_zoom;
double ury_zoom;
double llx_zoom=0;
double lly_zoom=0;
double xunits,yunits;
int grx,gry,xnum,ynum;
int startx,starty;
int startloadx,startloady,endloadx,endloady;
int startzoomx=0,startzoomy=0,endzoomx=0,endzoomy=0;
int startpanx=0,startpany=0;
int head_in_use=0;
int head2_in_use=1;
int lod_head_in_use=0;



long int StartTime;
int LODS_USED[NUM_DRAWING_PIXMAPS];



XtAppContext app_context; 
Dimension width, height;
Dimension realheight,realwidth;


Pixmap pixmap,pixmap2,pixmap3,clean_pixmap,stipmap_avg,stipmap_lgt,stipmap_hvy;
Pixmap Profile_pix,Demo_pix,Att_Demo_pix,areal_pixmap1,areal_pixmap2,areal_pixmap3,areal_pixmap4,areal_pixmap5,plus_pix,minus_pix,
  DRAWING_PIXMAPS[NUM_DRAWING_PIXMAPS], DRAWING_CLIPMAPS[NUM_DRAWING_PIXMAPS];
Pixmap stipmapstypes[NUM_STIPMAPS]; 
Pixmap ERROR_BITMAP;




Widget WW,shellhead2,sw,drawing_a, beg_dialog,total_w,text_ul,text_lr,text_w2,
  text_w3,text_w4,text_w5,modes[10],TEXT_HELP,previousresults,prev_dialog,dphead,
  import,text_output2,losbutton,profile,Profile_drawing,TempWidget=NULL,zoom_b,
  Profile_draw,list_point,MARKtext_w2,MARKtext_w3,pick_dialog,
  shift[7],fan_info,text_pane,text_obs,text_tgt,proj_folder_button1,loadhead,
  text_quality,text_angle,errorhead[3],specifichead[3],running_info,zoom_pad_w,
  param_head,param2_head,terrain_to_import,shapefile_text_area,net_zoom_pad_w,
  extract_dialog,metamap_text_area,metamap_browse_area,networkhead[3],net_zoom_b,
  concat_dialog,CSD_head,run_format_dialog,indir_work_dialog,Tstrat[NUM_S+2],
  Demo_drawing,Att_Demo_drawing,sdcshead,S_list_w,S_list2_w,proj_folder_button2,
  text_area,Bbutton,search_w,sum1_wid,sum2_wid,sum3_wid,modelhead,exefile_dialog,
  stf_t,patch_t,patchshell,min_attr_wid,max_attr_wid,data_wid,dp1_wid,QAST_unzip,
  sun_az_w_z,sun_angle_w_z,vert_ex_w_z,xml1_wid,xml2_wid,xml3_wid,allpref_dialog,
  fix_running,lod_head,text_llx,text_lly,text_urx,text_ury,exe_wid,routing_info,
  text_build  [CONDITION_ARRAY_SIZE][3+1],pop_menu[2],pop_parent,cond_dialog,
  togA          [CONDITION_ARRAY_SIZE],      togB        [CONDITION_ARRAY_SIZE],
  fixhead       [CONDITION_ARRAY_SIZE],      FixList     [CONDITION_ARRAY_SIZE],
  metalong1,metalong2,stackwids[ZOOM_REMEMBER_NUM],xml_running,
  fore_ver,lod_head2,ddwid,dmswid,fore_grid_s,fore_grid_xa,fore_grid_ya,fore_con, 
  zoom_dialog=NULL,savecond_wid,savepref_wid,
  netwid,info_text_area,info_list=NULL,info_tog[INsac_array+10],vpad_text_sen_w,
  infoparam_head,infohead,info_attr_head,vert_scroll[100],Select_head,dp2_wid,
  info_scc_defs,info_sac_defs,toolbar[20],menubar, top_menu[10],
  ToolTipMaster,condwid,condwid1,condwid2,condwid3,genwid,shapewid,regionhead,fore_ver2,
  folder_wid,GlobalTotals,page_wid,topright,TopHandle,env_root_area,
  TopLeft,master_sw2,FCGlobalTotals,ob_head[5],BOlist_w,BOlist2_w,
  NETGlobalTotals,aoi_save_wid,aoi_dialog,browsefolder_wid;


Widget vert_scroll_bo[25][CONDITION_ARRAY_SIZE][125];



Widget *LOD;

Display *mydisplay;
Window mywindow ; 


int Total2DPoint=0,Total3DPoint=0,Total2DLine=0,Total3DLine=0,Total2DArea=0,Total3DArea=0;


unsigned long col [300];                 
unsigned long col2[300];                 
unsigned long col3[300];                 
unsigned long col4[300];                 
unsigned long ColorBin1[SHADES_PER_BIN]; 
unsigned long ColorBin2[SHADES_PER_BIN]; 
unsigned long ColorBin3[SHADES_PER_BIN]; 
unsigned long ColorBin4[SHADES_PER_BIN]; 
unsigned long ColorBin5[SHADES_PER_BIN]; 
unsigned long mycolors[300];             
unsigned long BITWHITE, BITBLACK;        

char edcsstring[150];
GC mygc,mybitgc ; 
Colormap cmap;
Dimension HEIGHT;  

int stf_overwrite_source = 0;
int patch_source         = 0;
int CSD_UP               = 0;
int MOD_UP               = 0;
int INDIR_WORK_UP        = 0;
int RUN_FORMAT_UP        = 0;
int output_source        = 0;
int input_source         = 0;
int import_source        = 0;
int shape_source         = 0;
int metamap_source       = 0;
int import_output_source = 0;
int browse5_up           = 0;
int browse6_up           = 0;
int browse7_up           = 0;
int browse8_up           = 0;
int browse12_up          = 0;
int browse13_up          = 0;
int browse14_up          = 0;
int browse15_up          = 0;
int browse26_up          = 0;
int browse27_up          = 0;
int browse28_up          = 0;
int browse29_up          = 0;
int browse30_up          = 0;
int browse31_up          = 0;
int browse32_up          = 0;
int current_ob_head      = 0;
int dead_xml             = 1;
int dead_dp              = 1;
int dead_network         = 1;
int dead_shade           = 1;
int dead_compare         = 1;
int dead_checkfilter     = 1;
int dead_trexchoose      = 1;

int fcodefilter_up       = 0;
int dead_obhead[5];
int dead_zero_head=1;
int dead_lod_head=1;
int dead_lod_head2=1;
int dead_sdcs=1;
int deadfix[CONDITION_ARRAY_SIZE];
int dead_side=1;
int deader_head=1;
int deader_phead=1;
int dead_head3=1;
int dead_folderhead=1;
int dead_browsefolderhead=1;
int dead_datahead=1;
int dead_other_head3=1;
int dead_head4=1;
int dead_head5=1;
int dead_head6=1;
int dead_head7=1;
int dead_error=1;
int pro_begx=-1,  pro_begy=-1;
int ATT_DEMO_UP=0;
int DEMO_UP=0;
int INFO_WINDOW=0;
int load_reg=0;
int load_head=1;
int running = 0;
int input_up=0;
int load_modules=0;
int logo_done=0;
int NAV_UP=0;
int INFO_PARAM_WIN=0;
int FORE_WIN=0;
int INFO_ATTR_WIN=0;
int ZOOM_MODE    = 1;   
int INFO_MODE    = 0;
int PROFILE_MODE = 0;
int AOI_MODE     = 0;
int ACTUAL       = 0;
int NON_ACTUAL   = 0;
int LOS          = 0;
int FAN_MODE     = 0;
int DIST_MODE    = 0;
int CHECK_MODE   = 0;
int PAN_MODE     = 0;
int pop_up[2];
int curr_pop = 0;
int PIXMAP_MODIFIER = 0; 
int DOALLCELLS=1;



int mymax(int a, int b)
{
  if(a>b){return a;}
  return b;
}


void SetColorRight()
{
  set_color(drawing_a, "Black",(XtPointer)NULL);
}


int SingleInstance(int checktype)
{
  return (
	       (checktype==MASKMONO)    ||
	       (checktype==KERNELSTATS) ||
	       (checktype==BILINSTATS)
		 );
}


char * MakeUString2()
{
  

  FILE *headfile;
  double MINYREAD, MINXREAD, MAXYREAD, MAXXREAD;
  char temp[1000];
  unsigned char UCjunk;
  static char result[100]; 
 


  sprintf(temp,"%sheader.bin",indirectory);
  headfile = fopen(temp,"rb");
  if(headfile==NULL)
    {
      printf("unable to open %s\n",temp);
      ExitWrapper(-1);
    }

  fread(&UCjunk, SzUC,1,headfile);
  SEEIT_fread_double(&MINXREAD,  headfile);
  SEEIT_fread_double(&MINYREAD,  headfile);
  SEEIT_fread_double(&MAXXREAD,  headfile);
  SEEIT_fread_double(&MAXYREAD,  headfile);   
  fclose(headfile);


  if(Ctype()==2)
    {
      
      sprintf(result,"x: %.3lf y: %.3lf m",
		  MAXXREAD-MINXREAD,
		  MAXYREAD-MINYREAD);
    }
  else if(Ctype()==1)	
    {
      
      sprintf(result,"x: %.*lf y: %.*lf deg",
		  15,MAXXREAD-MINXREAD,
		  15,MAXYREAD-MINYREAD);	
    }


  return result;
}


char * MakeUString(double x,double y)
{
  static char result[100];
  
  if(Ctype()==2)
    {
      
      sprintf(result,"x: %.3lf y: %.3lf m",x,y);
    }
  else if(Ctype()==1)	
    {
      
      sprintf(result,"x: %.*lf y: %.*lf deg",
		  DIGITS_TO_PRINT,x/100000.0,
		  DIGITS_TO_PRINT,y/100000.0);
    }

  return result;
}




void print_annot_result(Widget text_w, MyData *userData, XtPointer call_data)
{
  
  
  int index;
  char *value = XmTextFieldGetString (text_w);
  
  int errnum   = userData->check_num;
  int clonenum = userData->clonenum;
  
  
  ResetMasterRun();

  if(clonenum==0)
    {
      if(ErrorLookup[errnum].Annotation!=NULL)
	{
	  free(ErrorLookup[errnum].Annotation);
	}
      
      ErrorLookup[errnum].Annotation = (char *) (malloc(strlen(value)+5));
      sprintf(ErrorLookup[errnum].Annotation,"%s",value);

      
      XtVaSetValues(ErrorLookup[errnum].annot_label,
		    XmNlabelString,
		    STRING(ErrorLookup[errnum].Annotation),
		    NULL);
    }
  else
    {
      index = GetCloneIndex(clonenum,errnum);
      
      if(CloneErrorLookup[index].Annotation!=NULL)
	{
	  free(CloneErrorLookup[index].Annotation);
	}
      CloneErrorLookup[index].Annotation = (char *) (malloc(strlen(value)+5));
      sprintf(CloneErrorLookup[index].Annotation,"%s",value);
      
      XtVaSetValues(CloneErrorLookup[index].annot_label,
		    XmNlabelString,
		    STRING(CloneErrorLookup[index].Annotation),
		    NULL);
    }
  XtFree (value);    
}
  








void
kill_help_callback(Widget dialog, XtPointer client_data, XtPointer call_data)
{
  int num=(int)client_data;

  XtDestroyWidget(XtParent(XtParent(dialog)));

  if((num>CONDITION_DEFINITIONS)||(num<0)) 
    {
      printf("Bad arg to kill_help: %d\n",num);
    }
  
  HELP_UP[num]=0;
}




void kill_fcode_callback(Widget button,XtPointer client_data, XtPointer call_data)
{
  XtDestroyWidget(XtParent(XtParent(XtParent(button))));
}


char *PadSpecial(int num)
{
  static char retval[100];

  

  if(num<10)
  {
    sprintf(retval,"       %d",num);
  }
  else if(num<100)
  {
    sprintf(retval,"      %d",num);
  }
  else if(num<1000)
  {
    sprintf(retval,"     %d",num);
  }
  else if(num<10000)
  {
    sprintf(retval,"    %d",num);
  }
  else if(num<100000)
  {
    sprintf(retval,"   %d",num);
  }
  else if(num<1000000)
  {
    sprintf(retval,"  %d",num);
  }
  else if(num<10000000)
  {
    sprintf(retval," %d",num);
  }
  else
  {
    sprintf(retval,"%d",num);
  }

  return retval;
}


void kill_model_callback(Widget button, MyData *mydata, XtPointer call_data)
{
  Widget parent_wid;
  int errnum   = mydata->check_num;
  int ADDER    = mydata->ADDER;
  int axis     = mydata->axis;
  int geomtype = mydata->geomtype;
  int clonenum = mydata->clonenum;
  int index=-1;
  char title[100];


  


  
  parent_wid = XtParent(XtParent(XtParent(button)));
  set_cursor(XtDisplay(parent_wid),XtWindow(parent_wid),WATCH);
  set_cursor(mydisplay,mywindow,WATCH);



  if(mydata->clonenum>0)
    {
      index = GetCloneIndex(mydata->clonenum,mydata->check_num);
    }




  if((KILL_ATTR_WIN==1)||(KILL_ATTR_WIN==2))
  {
    if(mydata->clonenum==0)
    {
     
	  XmListDeleteAllItems(ErrorLookup[errnum].EAVlist[axis][ADDER][geomtype]);
	  XmListDeleteAllItems(ErrorLookup[errnum].EASlist[axis][ADDER][geomtype]);
    }
    else
    {
     
	 XmListDeleteAllItems(CloneErrorLookup[index].EAVlist[axis][ADDER][geomtype]);
	 XmListDeleteAllItems(CloneErrorLookup[index].EASlist[axis][ADDER][geomtype]);
    }
  }


  if(mydata->check_num+mydata->axis+mydata->ADDER==0)
    {
      
      
      

      CreateLongListEntries(mydata->check_num,mydata->axis,mydata->ADDER,0,mydata->clonenum,index, 0); 

	  SetFidMarkTable(-999,NULL,-1,NULL,0,0,0,0,0);

      

  }


  if((KILL_ATTR_WIN==1)||(KILL_ATTR_WIN==2))
  {
    XtDestroyWidget(XtParent(XtParent(XtParent(button))));
  }


  

  if((KILL_ATTR_WIN==0)||(KILL_ATTR_WIN==1))
  {
   if(mydata->check_num+mydata->axis+mydata->ADDER==0)
    {
      

      refreshCallback((Widget)NULL,(XtPointer)NULL,(XtPointer)NULL);
    }
  }





  

  if((NGA_TYPE==1)&&(geomtype>0))
    {
      if(clonenum==0)
	{
	  sprintf(title,"%s",PadSpecial(
		  ErrorLookup[errnum].model_index[axis][ADDER][geomtype] +
		  ErrorLookup[errnum].sac_index  [axis][ADDER][geomtype]));
	  
	  XtVaSetValues(ErrorLookup[errnum].specwidget[axis][ADDER][geomtype],
			XmNlabelString,
			STRING(title),
			NULL);
	}
      else
	{
	  sprintf(title,"%s",PadSpecial(
		  CloneErrorLookup[index].model_index[axis][ADDER][geomtype] +
		  CloneErrorLookup[index].sac_index  [axis][ADDER][geomtype]));

	  XtVaSetValues(CloneErrorLookup[index].specwidget[axis][ADDER][geomtype],
			XmNlabelString,
			STRING(title),
			NULL);
	}
    }


  KILL_ATTR_WIN = 1;

  

  set_cursor(XtDisplay(parent_wid),XtWindow(parent_wid),ARROW);
  set_cursor(mydisplay,mywindow,GOOD);

}



void kill_model_callback2(Widget button, MyData *mydata, XtPointer call_data)
{
  
  KILL_ATTR_WIN = 0;	
  kill_model_callback(button,mydata,call_data);
  KILL_ATTR_WIN = 1;
}


void kill_model_callback3(Widget button, MyData *mydata, XtPointer call_data)
{
  
  KILL_ATTR_WIN = 2;	
  kill_model_callback(button,mydata,call_data);
  KILL_ATTR_WIN = 1;
}




void
help_actor_callback(Widget button, XtPointer client_data, XtPointer call_data)
{


  not_while_running(button,"This window can be used to set which data objects will be used\n\
in this inspection.  The inspection is described at the top of this\n\
window, as are the participant(s) which are involved in this check.\n\n\
For each participant in the check, you must specify which objects are\n\
to be included by either using the appropriate buttons.\n\n\
The \"All\" buttons provide a quick way to specify that all objects\n\
of a particular geometry are to be included as a particular participant\n\
(except objects that are specified to exclude for that same geometry\n\
and participant).\n\n\
If the \"All\" buttons are not selected, the \"Specified\" buttons may be\n\
used to indicate that the objects specified as objects to \"Include\" for\n\
that geometry and participant should be objects inspected (except objects\n\
that are specified to exclude for that same geometry and participant).\n\n\
Objects specified to Exclude are always excluded for that geometry and\n\
participant, regardless of whether \"All\" or \"Selected\" is specified.",1000,"Actor help",5);


}





void
kill_actor_callback(Widget button, XtPointer client_data, XtPointer call_data)
{
  int num=(int)client_data;

  if((num>CONDITION_DEFINITIONS)||(num<0)) 
    {
      printf("Bad arg to kill_actor: %d\n",num);
    }
  
  XtDestroyWidget(XtParent(XtParent(XtParent(button))));
}






void kill_pad_callback(Widget button, XtPointer client_data, XtPointer call_data)
{
  extern int bad_los_result;

  los_result(zoom_pad_w,(XtPointer)9,(XtPointer)NULL);

  if(bad_los_result==1)
    {
      not_while_running(button,"The pad distance entered was invalid. It has been reset\nto the last valid value (valid range: 1-5000)",
			1464,"Invalid Condition Pad Distance",1);
      return;
    }

  XtDestroyWidget(XtParent(XtParent(XtParent(button))));
}











void kill_sense_callback(Widget button,MyData * userData, XtPointer call_data)
{
  int errnum   = userData->check_num;
  int success=0,bad=0;


    


  if(ErrorLookup[errnum].numthresholds>=1)
  {
    print_result(userData->Swid_to_pass[1],userData,&success,1);

    if(success==-1)
	{
      not_while_running(button,"The tolerance entered was invalid.  It has been reset\nto the last valid value",
			    1461,"Invalid Tolerance",1);
      success = 0;
	  bad = 1;
	} 
  } 
  if(ErrorLookup[errnum].numthresholds>=2)
  {  
    print_result(userData->Swid_to_pass[2],userData,&success,2);

    if(success==-1)
	{
	  not_while_running(button,
			    "The secondary tolerance entered was invalid. It has been reset\nto the last valid value",
			    1463,"Invalid Secondary Tolerance",1);
      success = 0;
	  bad = 1;
	}
  }
  if(ErrorLookup[errnum].numthresholds>=3)
  {  
    print_result(userData->Swid_to_pass[3],userData,&success,3);

    if(success==-1)
	{
	  not_while_running(button,
			    "The tertiary (3rd) tolerance entered was invalid. It has been reset\nto the last valid value",
			    1518,"Invalid Tertiary Tolerance",1);
      success = 0;
	  bad = 1;
	}
  }
  if(ErrorLookup[errnum].numthresholds>=4)
  {  
    print_result(userData->Swid_to_pass[4],userData,&success,4);

    if(success==-1)
	{
	  not_while_running(button,
			    "The quaternary (4th) tolerance entered was invalid. It has been reset\nto the last valid value",
			    1519,"Invalid Quaternary Tolerance",1);
      success = 0;
	  bad = 1;
	}
  }
  if(ErrorLookup[errnum].numthresholds>=5)
  {  
    print_result(userData->Swid_to_pass[5],userData,&success,5);

    if(success==-1)
	{
	  not_while_running(button,
			    "The quinary (5th) tolerance entered was invalid. It has been reset\nto the last valid value",
			    1520,"Invalid Quinary Tolerance",1);
      success = 0;
	  bad = 1;
	}
  }
  if(ErrorLookup[errnum].numthresholds>=6)
  {
    print_result(userData->Swid_to_pass[6],userData,&success,6);

    if(success==-1)
	{
	  not_while_running(button,
			    "The senary (6th) tolerance entered was invalid. It has been reset\nto the last valid value",
			    1521,"Invalid Senary Tolerance",1);
      success = 0;
	  bad = 1;
	}
  }

  if((ErrorLookup[errnum].numthresholds>=7)||(ErrorLookup[errnum].numthresholds<1))
  {
    XBell(mydisplay,50);
    printf("bad number of tolerances %d to kill_sense_callback\n",ErrorLookup[errnum].numthresholds);
  }

  if(bad==0)
  {
    XtDestroyWidget(XtParent(XtParent(XtParent(button))));
  }
}



void
kill_annot_callback(Widget button, MyData * userData, XtPointer call_data)
{
  print_annot_result(userData->wid_to_pass,userData,(XtPointer)NULL);

  XtDestroyWidget(XtParent(XtParent(XtParent(button))));
}



void
help_ann_callback(Widget button, XtPointer client_data, XtPointer call_data)
{
  int errnum=(int)client_data;
  char message[1000];

  if(errnum>=1000)
    {
      errnum = errnum-1000;
    }
  
  sprintf(message,"This window can be used to set or modify an annotation for this inspection.\n\n\
This annotation appears here, and in the execution options window under the\n\
inspection name.\n\n\
It also appears in shapefile conditions that are exported, and in the\n\
conditions found window.\n\n\
This annotation is filled in automatically if using a GAIT-provided profile\n\
(ie, MGCP_master.txt)");

  not_while_running(button,message,1375,"Annotation Help",5);
}


char *GetToleranceNumName(int num)
{

  if(num==1)
  {
    return "Primary";
  }
  if(num==2)
  {
    return "Secondary";
  }
  if(num==3)
  {
    return "Tertiary (3rd)";
  }
  if(num==4)
  {
    return "Quaternary (4th)";
  }
  if(num==5)
  {
    return "Quinary (5th)";
  }
  if(num==6)
  {
    return "Senary (6th)";
  }

  printf("Error: GTNN got %d\n",num);
  XBell(mydisplay,50);
  return "Error";
}


char *GetToleranceUnits(int num, int errnum)
{

  if(num==1)
  {
    return ErrorLookup[errnum].units;
  }
  if(num==2)
  {
    return ErrorLookup[errnum].units2;
  }
  if(num==3)
  {
    return ErrorLookup[errnum].units3;
  }
  if(num==4)
  {
    return ErrorLookup[errnum].units4;
  }
  if(num==5)
  {
    return ErrorLookup[errnum].units5;
  }
  if(num==6)
  {
    return ErrorLookup[errnum].units6;
  }

  printf("Error: GTNN got %d\n",num);
  XBell(mydisplay,50);
  return "Error";
}



void help_sense_callback(Widget button, XtPointer client_data, XtPointer call_data)
{
  int errnum=(int)client_data;
  char messagetemp[1000];
  char message[5000];
  char temp[500];
  int i=0;

  
  if((errnum>CONDITION_DEFINITIONS)||(errnum<0))
  {
	printf("Bad arg to help_sense: %d\n",errnum);
	return;
  } 
  

  sprintf(messagetemp,"%s",ErrorLookup[errnum].name);
  while(messagetemp[i]!='\0')
  {
  	if(messagetemp[i]=='\n')
	{
	  messagetemp[i]=' ';
	}
	  
	i++;
	
	if(i>400)
	{
	  printf("Bad news.  Did not detect end of string within 400 chars for %d\n",errnum); 
	  XBell(mydisplay,50);
	}
  }

      if(IsNetCheck(errnum))
	{
	  sprintf(message,"\
This window is used to set the tolerance used to\n\
compute networks for viewing.\n\n\
To change the tolerances shown,\n\
simply enter the new value(s) and hit <return>.  Out of range\n\
values will revert to the previous acceptable value.\n\n\
%s\n\n\
Acceptable range for primary tolerance: %lf - %lf (%s)",
		  ErrorLookup[errnum].description,
		  ErrorLookup[errnum].lowrange,ErrorLookup[errnum].highrange,ErrorLookup[errnum].units);
	}
    else if(ErrorLookup[errnum].numthresholds==1)
	{
	  sprintf(message,"This window is used to set the tolerance used to check for\n\
\"%s\" conditions.\n\n\
To change the tolerance shown,\n\
simply enter the new value and hit <return>.  Out of range\n\
values will revert to the previous acceptable value.\n\n\
Acceptable range: %lf - %lf (%s)\n",
		  messagetemp,
		  ErrorLookup[errnum].lowrange,
		  ErrorLookup[errnum].highrange,
		  ErrorLookup[errnum].units);
	}
    else if((ErrorLookup[errnum].numthresholds==2)&&(ErrorLookup[errnum].range==1))
	{
	  sprintf(message,"This window is used to set the tolerance used to check for\n\
\"%s\" conditions.\n\n\
To change the tolerances shown,\n\
simply enter the new value(s) and hit <return>.  Out of range\n\
values will revert to the previous acceptable value.\n\n\
%s\n\n\
Acceptable range for primary tolerance: %lf - %lf (%s)\n\
Acceptable range for secondary tolerance: %lf - %lf (%s)\n\n\
Note:  Because the two tolerances represent a range (conditions\n\
must have magnitudes between the primary and secondary tolerances),\n\
the primary tolerance must be less than or equal to the secondary\n\
tolerance AT ALL TIMES.  This means you may have to set the\n\
secondary tolerance before you set the primary tolerance.",
		  messagetemp,
		  ErrorLookup[errnum].description,
		  ErrorLookup[errnum].lowrange,ErrorLookup[errnum].highrange,ErrorLookup[errnum].units,
		  ErrorLookup[errnum].lowrange2,ErrorLookup[errnum].highrange2,ErrorLookup[errnum].units2);
	}
      else  if(ErrorLookup[errnum].numthresholds==2) 
	{
	  sprintf(message,"This window is used to set the tolerance used to check for\n\
\"%s\" conditions.\n\n\
To change the tolerances shown,\n\
simply enter the new value(s) and hit <return>.  Out of range\n\
values will revert to the previous acceptable value.\n\n\
%s\n\n\
Acceptable range for primary tolerance: %lf - %lf (%s)\n\
Acceptable range for secondary tolerance: %lf - %lf (%s)",
		  messagetemp,
		  ErrorLookup[errnum].description,
		  ErrorLookup[errnum].lowrange,ErrorLookup[errnum].highrange,ErrorLookup[errnum].units,
		  ErrorLookup[errnum].lowrange2,ErrorLookup[errnum].highrange2,ErrorLookup[errnum].units2);
	}
   else  if((ErrorLookup[errnum].numthresholds>2)&&(ErrorLookup[errnum].numthresholds<=6))
	{
	  sprintf(message,"This window is used to set the tolerance used to check for\n\
\"%s\" conditions.\n\n\
To change the tolerance shown,\n\
simply enter the new value and hit <return>.  Out of range\n\
values will revert to the previous acceptable value.\n\n\
Acceptable ranges: \n\n",messagetemp);

	  if(ErrorLookup[errnum].numthresholds>0)
	  {
	    sprintf(temp,"%s: %lf - %lf (%s)\n",
          GetToleranceNumName(1),
		  ErrorLookup[errnum].lowrange,
		  ErrorLookup[errnum].highrange,
		  ErrorLookup[errnum].units);
	    strcat(message,temp);
	  }
	  if(ErrorLookup[errnum].numthresholds>1)
	  {
	    sprintf(temp,"%s: %lf - %lf (%s)\n",
          GetToleranceNumName(2),
		  ErrorLookup[errnum].lowrange2,
		  ErrorLookup[errnum].highrange2,
		  ErrorLookup[errnum].units2);
	    strcat(message,temp);
	  }
	  if(ErrorLookup[errnum].numthresholds>2)
	  {
	    sprintf(temp,"%s: %lf - %lf (%s)\n",
          GetToleranceNumName(3),
		  ErrorLookup[errnum].lowrange3,
		  ErrorLookup[errnum].highrange3,
		  ErrorLookup[errnum].units3);
	    strcat(message,temp);
	  }
	  if(ErrorLookup[errnum].numthresholds>3)
	  {
	    sprintf(temp,"%s: %lf - %lf (%s)\n",
          GetToleranceNumName(4),
		  ErrorLookup[errnum].lowrange4,
		  ErrorLookup[errnum].highrange4,
		  ErrorLookup[errnum].units4);
	    strcat(message,temp);
	  }
	  if(ErrorLookup[errnum].numthresholds>4)
	  {
	    sprintf(temp,"%s: %lf - %lf (%s)\n",
          GetToleranceNumName(5),
		  ErrorLookup[errnum].lowrange5,
		  ErrorLookup[errnum].highrange5,
		  ErrorLookup[errnum].units5);
	    strcat(message,temp);
	  }
	  if(ErrorLookup[errnum].numthresholds>5)
	  {
	    sprintf(temp,"%s: %lf - %lf (%s)\n",
          GetToleranceNumName(6),
		  ErrorLookup[errnum].lowrange6,
		  ErrorLookup[errnum].highrange6,
		  ErrorLookup[errnum].units6);
	    strcat(message,temp);
	  }

		  
	}

    else
	{ 
      XBell(mydisplay,50);   
	  printf("bad numthresholds %d in help_sense_callback\n",ErrorLookup[errnum].numthresholds);
	  return;
	}


	not_while_running(button,message,3000+errnum,"Tolerance Help",5);
}



char * PrintTime(long int TheStartTime)
{
  long int elapsed,end;
  long int el_hours=0,el_mins=0,el_days=0; 
  static char thebuff[500];

  end = time(NULL);

  elapsed = end - TheStartTime;

   
  
  if(elapsed>=86400)
    {
      el_days = elapsed/86400;
      elapsed = elapsed - el_days*86400;
    }
  if(elapsed>=3600)
    {
      el_hours = elapsed/3600;
      elapsed = elapsed - el_hours*3600;
    }
  if(elapsed>=60)
    {
      el_mins = elapsed/60;
      elapsed = elapsed - el_mins*60;
    }

  if(el_days==1)
    {
      if(el_hours==1)
	{
	  sprintf(thebuff,"%ld day, %ld hour, %ld min, %ld sec\n",
		  el_days,el_hours,el_mins,elapsed);
	}
      else
	{
	  sprintf(thebuff,"%ld day, %ld hours, %ld min, %ld sec\n",
		  el_days,el_hours,el_mins,elapsed);
	}
    }
  else if(el_days>1)
    {
      if(el_hours==1)
	{
	  sprintf(thebuff,"%ld days, %ld hour, %ld min, %ld sec\n",
		  el_days,el_hours,el_mins,elapsed);
	}
      else
	{
	  sprintf(thebuff,"%ld days, %ld hours, %ld min, %ld sec\n",
		  el_days,el_hours,el_mins,elapsed);
	}
    }
  else if(el_hours==1)
    {
      sprintf(thebuff,"%ld hour, %ld min, %ld sec\n",
	      el_hours,el_mins,elapsed);
    }
  else if(el_hours>1)
    {
      sprintf(thebuff,"%ld hours, %ld min, %ld sec\n",
	      el_hours,el_mins,elapsed);
    }
  else if(el_mins>0)
    {
      sprintf(thebuff,"%ld min, %ld sec\n",
	      el_mins,elapsed);
    }
  else 
    {
      sprintf(thebuff,"%ld sec\n",
	      elapsed);
    }
  return(thebuff);
}


void real_periodic_redraw()
{
  XEvent event;
  
  
  
  if(batch_mode==0)
    {
      while(XCheckMaskEvent(mydisplay,
			    ButtonPressMask|ButtonReleaseMask|KeyPressMask|KeyReleaseMask,&event))
	{
	  XtDispatchEvent(&event);
	}
    }
  XmUpdateDisplay(drawing_a); 
}




void SetNumLODs()
{
  FILE *temp;
  char tempstr[1000];

  sprintf(tempstr,"%sLODbands.bin",indirectory);

  temp = fopen(tempstr,"rb");
  if(temp != NULL)
   {
     SEEIT_fread_int(&TempNumLODbands,temp);
     fclose(temp);
  }
  else
  {
	  XBell(mydisplay,50);
	  printf("Error: could not open %s\n",tempstr);
  }
}


void InitializationAdvice(double PCacount, double IndexPrep, double PCattr, 
						  double PCattrval, double ECCdone, int DON)
{
  int n;
  char message[2000],message1[2000],message2[2000];  
  XmString t;
  Arg args[15];
  extern int ExtraTopLevel;
  extern int layer_write_files;
  extern int layer_write_total_files;
  extern int layer_gzip_files;
  extern int layer_gzip_total_files;
  static long int last_redraw=0,ThisTime;


  if(TempNumLODbands==0)
  {
    SetNumLODs();
  }

  if(ExtraTopLevel==0)
  {
    layer_write_files       = TempNumLODbands;
	layer_write_total_files = TempNumLODbands;
	layer_gzip_files        = TempNumLODbands;
	layer_gzip_total_files  = TempNumLODbands;
  }
  else
  {
    
	TempNumLODbands = layer_write_total_files;
  }

  if(batchsilent==1)
  {
	  return;
  }


  ThisTime = time(NULL);
  

  if((MakingMaster==1))
    {

	  if((ThisTime-last_redraw)>0) 
	  {

        if(strlen(ExtraMessage)>2)
		{ 
		  if((ThisTime-last_redraw)>3)
		  { 
		    
		    printf("First file after %ld delay: %s\n",ThisTime-last_redraw,ExtraMessage);
		  } 
	      sprintf(message1,"Creating inspection specification files...Current file:\n %s",ExtraMessage);
		} 
        else
		{ 
	      sprintf(message1,"Creating inspection specification files...");
		} 

        sprintf(message2,"Elapsed Time: %s\n",PrintTime(StartTime));

        sprintf(message,"%s\n\n%s",message1,message2);

        t = XmStringCreateLtoR (message,XmSTRING_DEFAULT_CHARSET);

        XtVaSetValues (indir_work_dialog,
		     XmNmessageString,    t,
		     NULL);
        XmStringFree(t);
      
        real_periodic_redraw();
        last_redraw = ThisTime;      
	  }
    }
  else if( ((ThisTime-last_redraw)>0) && ((busyinnitting==1)||((ExtraTopLevel>0)||(TopLayersDrawn>0))))
    {

	  sprintf(message,"Loading project:\n\
%s:\n\n\
Writing layer files                        : %d/%d\n\
Compressing layer files                    : %d/%d\n\
Lookup Table initialization (%%)            : %.1lf\n\
Object Lookup Table Read (%%)               : %.1lf\n\
Lookup Table Read (%%)                      : %.1lf\n\
Attribute Lookup Table Read (%%)            : %.1lf\n\
Cross-Index Lookup Read (%%)                : %.1lf\n\
Reading Grid Signatures (%%)                : %.1lf\n\
Final Sorting (%%)                          : %.1lf\n\
Drawing Toplevel Layers                    : %d/%d\n\n\
Elapsed time: %s\n",
		  indirectory,
		  layer_write_files,
		  TempNumLODbands,
		  layer_gzip_files,
		  TempNumLODbands,
		  PCacount,
		  IndexPrep,
		  PCattr,
		  PCattrval, 
		  ECCdone,
		  GridSigPercent,
		  FinalSortPercent,
		  TopLayersDrawn,
		  TempNumLODbands,
		  PrintTime(StartTime));
	


      t = XmStringCreateLtoR (message,XmSTRING_DEFAULT_CHARSET);
      
      if(INDIR_WORK_UP==0)
	{
	  n = 0;
	  XtSetArg(args[n], XmNautoUnmanage,   False);                               n++;  
	  XtSetArg(args[n], XmNdeleteResponse, XmDESTROY);                           n++; 
	  if(NGA_TYPE==1)
	    {
	      XtSetArg(args[n], XmNdialogTitle,    STRING("Loading Project..."));       n++;
	      XtSetArg(args[n], XmNmessageString,  t);                                   n++;
	      XtSetArg(args[n], XmNdialogStyle,    XmDIALOG_PRIMARY_APPLICATION_MODAL);  n++;
	      indir_work_dialog = XmCreateInformationDialog (drawing_a, "Loading Project...", args, n);
	    }
	  else
	    {
	      XtSetArg(args[n], XmNdialogTitle,    STRING("Loading Database..."));       n++;
	      XtSetArg(args[n], XmNmessageString,  t);                                   n++;
	      XtSetArg(args[n], XmNdialogStyle,    XmDIALOG_PRIMARY_APPLICATION_MODAL);  n++;
	      indir_work_dialog = XmCreateInformationDialog (drawing_a, "Loading Database...", args, n);
	    }
	  
	  XtManageChild (indir_work_dialog);
	  XtPopup  (XtParent(indir_work_dialog), XtGrabNone);
	  XmStringFree (t); 
	  
	  XtUnmanageChild (XmMessageBoxGetChild (indir_work_dialog, XmDIALOG_CANCEL_BUTTON));
	  XtUnmanageChild (XmMessageBoxGetChild (indir_work_dialog, XmDIALOG_HELP_BUTTON));
	  XtUnmanageChild (XmMessageBoxGetChild (indir_work_dialog, XmDIALOG_OK_BUTTON));
	  
	  XtAddCallback(indir_work_dialog,XmNdestroyCallback,ShellDeath,(XtPointer)303);       
	  INDIR_WORK_UP=1;
	  set_cursor(XtDisplay(indir_work_dialog),XtWindow(indir_work_dialog),WATCH);
	  set_cursor(mydisplay,mywindow,WATCH);
	}
      else
	{
	  XtVaSetValues (indir_work_dialog,
			 XmNmessageString,    t,
			 NULL);
	  XmStringFree(t);
	}
      real_periodic_redraw();
      last_redraw = ThisTime;
    }
}




double GetLowNum(int errnum,int tolnum)
{
  if(tolnum==1)
  {
    return ErrorLookup[errnum].lowrange;
  }
  else if(tolnum==2)
  {
    return ErrorLookup[errnum].lowrange2;
  }
  else if(tolnum==3)
  { 
    return ErrorLookup[errnum].lowrange3;
  }
  else if(tolnum==4)
  {
    return ErrorLookup[errnum].lowrange4;
  }
  else if(tolnum==5)
  {
    return ErrorLookup[errnum].lowrange5;
  }
  else if(tolnum==6)
  {
    return ErrorLookup[errnum].lowrange6;
  }
  else
  {
    XBell(mydisplay,50);
	printf("BAD combo GLN %d\n",tolnum);
  }      
  return 0;
}



double GetHighNum(int errnum,int tolnum)
{
  if(tolnum==1)
  {
    return ErrorLookup[errnum].highrange;
  }
  else if(tolnum==2)
  {
    return ErrorLookup[errnum].highrange2;
  }
  else if(tolnum==3)
  { 
    return ErrorLookup[errnum].highrange3;
  }
  else if(tolnum==4)
  {
    return ErrorLookup[errnum].highrange4;
  }
  else if(tolnum==5)
  {
    return ErrorLookup[errnum].highrange5;
  }
  else if(tolnum==6)
  {
    return ErrorLookup[errnum].highrange6;
  }
  else
  {
    XBell(mydisplay,50);
	printf("BAD combo GLN %d\n",tolnum);
  }      
  return 0;
}





void print_first_result(Widget text_w, MyData *userData, int *call_data)
{
  print_result(text_w,userData,call_data,1);
}
void print_second_result(Widget text_w, MyData *userData, int *call_data)
{
  print_result(text_w,userData,call_data,2);
}
void print_third_result(Widget text_w, MyData *userData, int *call_data)
{
  print_result(text_w,userData,call_data,3);
}
void print_fourth_result(Widget text_w, MyData *userData, int *call_data)
{
  print_result(text_w,userData,call_data,4);
}
void print_fifth_result(Widget text_w, MyData *userData, int *call_data)
{
  print_result(text_w,userData,call_data,5);
}
void print_sixth_result(Widget text_w, MyData *userData, int *call_data)
{
  print_result(text_w,userData,call_data,6);
}



int IsNumeric(char *value)
{
  int i,dots=0;

  for(i=0;i<(int)(strlen(value));i++)
  {
    if((value[i]<'0')||(value[i]>'9'))
	{ 
	  if(value[i]=='.'){dots++;if(dots<2){continue;}}
	  if(value[i]=='-'){if(i==0){continue;}}	  
	  return 0;
	} 
  }

  return 1;
}



void print_result(Widget text_w, MyData *userData, int *call_data, int tolnum)
{
  
  
  int i,dots=0,index;
  char *value = XmTextFieldGetString (text_w);
  int bad_value=0; 
  char orig_valueCH[100];
  double NewValue,lownum,highnum;


  int errnum   = userData->check_num;
  int clonenum = userData->clonenum;


  if (!strcmp(value,"Not Available")) 
    {
      return;
    }


  sprintf(orig_valueCH,"%lf",GetSens(clonenum,errnum,tolnum));	


  
  for(i=0;i<(int)(strlen(value));i++)
    {
      if((value[i]<'0')||(value[i]>'9'))
	{
	  if(value[i]=='.'){dots++;if(dots<2){continue;}}
	  if(value[i]=='-'){if(i==0){continue;}}	  
	  bad_value = 1; 
	  break;
	}
    }
  
  if((bad_value==1)||(strlen(value)==0))
    {
      
      if(SENSDEBUG==1){printf("detected bad input\n");}
      XmTextFieldSetString(text_w,orig_valueCH);
      *call_data = -1;
      XtFree (value);    
      return;
    }

  
  lownum  = GetLowNum(errnum,tolnum);
  highnum = GetHighNum(errnum,tolnum);


  

  sscanf(value,"%lf",&NewValue);
  if(DEBUG==1){printf("found good value %lf\n",NewValue);}

  if(clonenum==0)
    {
	  if(
	     ((NewValue>=lownum)&&(NewValue<=highnum))&&
	     (
	      (ErrorLookup[errnum].numthresholds==1)                      ||
	      (ErrorLookup[errnum].numthresholds>2 )                      ||
	      ((tolnum==1)&&(NewValue<=ErrorLookup[errnum].sensitivity2)) ||
	      ((tolnum==2)&&(NewValue>=ErrorLookup[errnum].sensitivity))  ||
	      (ErrorLookup[errnum].range==0)
	      )
	     )
	    {
	      
	      
	      

		  if(tolnum==1)
		  {
	        ErrorLookup[errnum].sensitivity = NewValue;
		  }
		  else if(tolnum==2)
		  {
	        ErrorLookup[errnum].sensitivity2 = NewValue;
		  }
		  else if(tolnum==3)
		  {
	        ErrorLookup[errnum].sensitivity3 = NewValue; 
		  }
		  else if(tolnum==4)
		  {
	        ErrorLookup[errnum].sensitivity4 = NewValue;
		  }
		  else if(tolnum==5)
		  {
	        ErrorLookup[errnum].sensitivity5 = NewValue;
		  }
		  else if(tolnum==6)
		  {
	        ErrorLookup[errnum].sensitivity6 = NewValue;
		  }
		  else
		  {
            printf("Bad TN %d to PR!\n",tolnum);
			XBell(mydisplay,50);
		  }

          ResetMasterRun();
	    }
	  else
	    {
	      
	      XmTextFieldSetString(text_w,orig_valueCH);
	      *call_data = -1;
	      if(DEBUG==1){printf("Out of range\n");}
	    }
	   
    }  
  else
    {
      index = GetCloneIndex(clonenum,errnum);
      

	  if(
	     ((NewValue>=lownum)&&(NewValue<=highnum))&&
	     (
	      (ErrorLookup[errnum].numthresholds==1)                          ||
	      (ErrorLookup[errnum].numthresholds>2 )                          ||
	      ((tolnum==1)&&(NewValue<=CloneErrorLookup[index].sensitivity2)) ||
	      ((tolnum==2)&&(NewValue>=CloneErrorLookup[index].sensitivity))  ||
	      (ErrorLookup[errnum].range==0)
	      )
	     )
	    {
	      
	      
	      

		  if(tolnum==1)
		  {
	        CloneErrorLookup[index].sensitivity = NewValue;
		  }
		  else if(tolnum==2)
		  {
	        CloneErrorLookup[index].sensitivity2 = NewValue;
		  }
		  else if(tolnum==3)
		  {
	        CloneErrorLookup[index].sensitivity3 = NewValue;
		  }
		  else if(tolnum==4)
		  {
	        CloneErrorLookup[index].sensitivity4 = NewValue;
		  }
		  else if(tolnum==5)
		  {
	        CloneErrorLookup[index].sensitivity5 = NewValue;
		  }
		  else if(tolnum==6)
		  {
	        CloneErrorLookup[index].sensitivity6 = NewValue;
		  }
		  else
		  {
            printf("Bad TN2 %d to PR!\n",tolnum);
			XBell(mydisplay,50);
		  }

		  ResetMasterRun();
	    }
	  else
	    {
	      
	      XmTextFieldSetString(text_w,orig_valueCH);
	      *call_data = -1;
	      if(DEBUG==1){printf("Out of range\n");}
	    }
    }
  XtFree (value);    
}





char *GetMGCP_ReqFCODESFile()
{ 
  static char result[1000];
  char ending[10];

  if(BIN_ATTR_TYPE==1)
  {
    sprintf(ending,"bin");
  }
  else
  {
    sprintf(ending,"csv");
  }
  if(ATTRTYPE_MGCP3())
    {
      sprintf(result,"%sMGCP3_ReqFCODES.%s",GAIT_BIN_DIR,ending);
      return result;
    }
  else if(ATTRTYPE_MGCP4())
    {
      sprintf(result,"%sMGCP4_ReqFCODES.%s",GAIT_BIN_DIR,ending);
	  return result;
    }
  
  return "UNKNOWN!!!"; 
}



char *GetTDS_NotExtracted_File()
{
  static char result[1000];
  char ending[10];

  if(BIN_ATTR_TYPE==1)
  {
    sprintf(ending,"bin");
  }
  else
  {
    sprintf(ending,"csv");
  }


  if(ATTRTYPE_TDS4())
    {
      sprintf(result,"%sTDS4NotExtracted.%s",GAIT_BIN_DIR,ending);
      return result;
    }
  else if(ATTRTYPE_TDS6())
    {
      sprintf(result,"%sTDS6NotExtracted.%s",GAIT_BIN_DIR,ending);
      return result;
    }
  return "UNKNOWN!!!"; 
}




char *GetVV3_File()
{ 
  static char result[1000];
  char ending[10];

  if(BIN_ATTR_TYPE==1)
  {
    sprintf(ending,"bin");
  }
  else
  {
    sprintf(ending,"csv");
  }
  

  if(ATTRTYPE_TDS4())
    {
      sprintf(result,"%sTDS4_VVT3.%s",GAIT_BIN_DIR,ending);
      return result;
    }
  else
    {
      printf("error: GetVVFile called with AT %d\n",ATTRIBUTION_TYPE);
      XBell(mydisplay,50);
    }
  return "UNKNOWN!!!"; 
}


char *GetVVFile()
{ 
  static char result[1000];
  char ending[10];

  if(BIN_ATTR_TYPE==1)
  {
    sprintf(ending,"bin");
  }
  else
  {
    sprintf(ending,"csv");
  }
  
  if(ATTRTYPE_MGCP3())
    {
      sprintf(result,"%sMGCP3_VV.%s",GAIT_BIN_DIR,ending);
      return result;
    }
  else if(ATTRTYPE_MGCP4())
    {
	  
    }
  else if((ATTRTYPE_UFD1()))
    {
      sprintf(result,"%sUFD1_VV.%s",GAIT_BIN_DIR,ending);
      return result;
    }
  else if((ATTRTYPE_NFDD()))
    {
	  if(ATTRINSTYPE==4)
	  {
        sprintf(result,"%sNFDD_VV.%s",attrinsfolder,ending);
        return result;
	  }
    }
  else if((ATTRTYPE_DFDD()))
    {
	  if(ATTRINSTYPE==4)
	  {
        sprintf(result,"%sDFDD_VV.%s",attrinsfolder,ending);
        return result;
	  }
    }


  else if(ATTRTYPE_GGDM21())
    {
      sprintf(result,"%sGGDM21_VV.%s",GAIT_BIN_DIR,ending);
      return result;
    }
  else if(ATTRTYPE_GGDM22())
    {
      sprintf(result,"%sGGDM22_VV.%s",GAIT_BIN_DIR,ending);
      return result;
    }
  else if(ATTRTYPE_GGDM3())
    {
      sprintf(result,"%sGGDM3_VV.%s",GAIT_BIN_DIR,ending);
      return result;
    }


  else if(ATTRTYPE_TDS4())
    {
      sprintf(result,"%sTDS4_VV.%s",GAIT_BIN_DIR,ending);
      return result;
    }
  else if(ATTRTYPE_TDS6())
    {
      sprintf(result,"%sTDS6_VV.%s",GAIT_BIN_DIR,ending);
      return result;
    }
  else
    {
      printf("error: GetVVFile called with AT %d\n",ATTRIBUTION_TYPE);
      XBell(mydisplay,50);
    }
  return "UNKNOWN!!!"; 
}




char *GetVVDomainsFile()
{ 
  static char result[1000];
  char ending[10];

  if(BIN_ATTR_TYPE==1)
  {
    sprintf(ending,"bin");
  }
  else
  {
    sprintf(ending,"csv");
  }
  
  if(ATTRTYPE_MGCP3())
    {
      sprintf(result,"%sMGCP3_VVdomains.%s",GAIT_BIN_DIR,ending);
      return result;
    }
  else if(ATTRTYPE_MGCP4())
    {
	  
    }
  else if((ATTRTYPE_UFD1()))
    {
      sprintf(result,"%sUFD1_VVdomains.%s",GAIT_BIN_DIR,ending);
      return result;
    }
  else if((ATTRTYPE_NFDD()))
    {
	  if(ATTRINSTYPE==4)
	  {
        sprintf(result,"%sNFDD_VVdomains.%s",attrinsfolder,ending);
        return result;
	  }
    }
  else if((ATTRTYPE_DFDD()))
    {
	  if(ATTRINSTYPE==4)
	  {
        sprintf(result,"%sDFDD_VVdomains.%s",attrinsfolder,ending);
	  }
	  else
	  {
        sprintf(result,"%sDFDD_VVdomains.%s",GAIT_BIN_DIR,ending);
	  }
      return result;
    }

  else if(ATTRTYPE_GGDM21())
    {
      sprintf(result,"%sGGDM21_VVdomains.%s",GAIT_BIN_DIR,ending);
      return result;
    }
  else if(ATTRTYPE_GGDM22())
    {
      sprintf(result,"%sGGDM22_VVdomains.%s",GAIT_BIN_DIR,ending);
      return result;
    }
  else if(ATTRTYPE_GGDM3())
    {
      sprintf(result,"%sGGDM3_VVdomains.%s",GAIT_BIN_DIR,ending);
      return result;
    }

  else if(ATTRTYPE_TDS4())
    {
      sprintf(result,"%sTDS4_VVdomains.%s",GAIT_BIN_DIR,ending);
      return result;
    }
  else if(ATTRTYPE_TDS6())
    {
      sprintf(result,"%sTDS6_VVdomains.%s",GAIT_BIN_DIR,ending);
      return result;
    }
  else
    {
      printf("error: GetVVDomainsFile called with AT %d\n",ATTRIBUTION_TYPE);
      XBell(mydisplay,50);
    }
  return "UNKNOWN!!!"; 
}





char *GetVV3DomainsFile()
{ 
  static char result[1000];
  char ending[10];

  if(BIN_ATTR_TYPE==1)
  {
    sprintf(ending,"bin");
  }
  else
  {
    sprintf(ending,"csv");
  }
  

  if(ATTRTYPE_TDS4())
    {
      sprintf(result,"%sTDS4_VV3domains.%s",GAIT_BIN_DIR,ending);
      return result;
    }
  else
    {
      printf("error: GetVVT3DomFile called with AT %d\n",ATTRIBUTION_TYPE);
      XBell(mydisplay,50);
    }
  return "UNKNOWN!!!"; 
}




char *GetDomainFile()
{ 
  static char result[1000];
  char ending[10];

  if(BIN_ATTR_TYPE==1)
  {
    sprintf(ending,"bin");
  }
  else
  {
    sprintf(ending,"csv");
  }
  
  if((ATTRTYPE_D4()))
    {
      sprintf(result,"%sD4_domains.%s",GAIT_BIN_DIR,ending);
      return result;
    }
  else if((ATTRTYPE_FACC()))
    {
      sprintf(result,"%sFACC_PLUS_domains.%s",GAIT_BIN_DIR,ending);
      return result;
    }
  else if((ATTRTYPE_VMAP()))
    {
      sprintf(result,"%sVMAP_augdomains.%s",GAIT_BIN_DIR,ending);
      return result;
    }
  else if(ATTRTYPE_MGCP3())
    {
      sprintf(result,"%sMGCP3_domains.%s",GAIT_BIN_DIR,ending);
      return result;
    }
  else if(ATTRTYPE_MGCP4())
    {
      sprintf(result,"%sMGCP4_domains.%s",GAIT_BIN_DIR,ending);
      return result;
    }
  else if((ATTRTYPE_UFD1()))
    {
      sprintf(result,"%sUFD1_domains.%s",GAIT_BIN_DIR,ending);
      return result;
    }
  else if((ATTRTYPE_UFD2()))
    {
      sprintf(result,"%sUFD2_domains.%s",GAIT_BIN_DIR,ending);
      return result;
    }
  else if((ATTRTYPE_UFD3()))
    {
      sprintf(result,"%sUFD3_domains.%s",GAIT_BIN_DIR,ending);
      return result;
    }
  else if((ATTRTYPE_NFDD()))
    {
	  if(ATTRINSTYPE==2)
	  {
        sprintf(result,"%sNFDD_domains.%s",GAIT_BIN_DIR,ending);
	  }
	  else if((ATTRINSTYPE==3)||(ATTRINSTYPE==4))
	  {
        sprintf(result,"%sNFDD_domains.%s",attrinsfolder,ending);
	  }
      return result;
    }
  else if((ATTRTYPE_DFDD()))
    {
	  if(ATTRINSTYPE==2)
	  {
        sprintf(result,"%sDFDD_domains.%s",GAIT_BIN_DIR,ending);
	  }
	  else if((ATTRINSTYPE==3)||(ATTRINSTYPE==4))
	  {
        sprintf(result,"%sDFDD_domains.%s",attrinsfolder,ending);
	  }
      return result;
    }
  else if((ATTRTYPE_SAC()))
    {
      sprintf(result,"%sAFD_domains.%s",GAIT_BIN_DIR,ending);
      return result;
    }

  else if((ATTRTYPE_GGDM21()))
    {
      sprintf(result,"%sGGDM21_domains.%s",GAIT_BIN_DIR,ending);
      return result;
    }
  else if((ATTRTYPE_GGDM22()))
    {
      sprintf(result,"%sGGDM22_domains.%s",GAIT_BIN_DIR,ending);
      return result;
    }
  else if((ATTRTYPE_GGDM3()))
    {
      sprintf(result,"%sGGDM3_domains.%s",GAIT_BIN_DIR,ending);
      return result;
    }


  else if(ATTRTYPE_TDS4())
    {
      sprintf(result,"%sTDS4_domains.%s",GAIT_BIN_DIR,ending);
      return result;
    }
  else if(ATTRTYPE_TDS6())
    {
      sprintf(result,"%sTDS6_domains.%s",GAIT_BIN_DIR,ending);
      return result;
    }
  
  return "UNKNOWN!!!"; 
}


char *GetFileNamefile()
{
  static char result[1000];
  
  if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
  {
    sprintf(result,"%sinternal_data\\sfs.bin",indirectory);
  }
  else
  {
    sprintf(result,"%sinternal_data/sfs.bin",indirectory);
  }

  return result;
}



char *GetPVfile()
{
  static char result[1000];
  extern int DO_MGCP_PORTRAY;

  if(ATTRTYPE_TDS6())
  {
	if(DO_MGCP_PORTRAY==0) 
	{
      return "NOFILE";
	}
    sprintf(result,"%sTDS6FullPortrayAttrs.bin",GAIT_BIN_DIR);
  } 
  else if(ATTRTYPE_MGCP4())
  {
	if(DO_MGCP_PORTRAY==0)
	{
      return "NOFILE";
	}
    sprintf(result,"%sMGCP4FullPortrayAttrs.bin",GAIT_BIN_DIR);
  }
  else
  {
    return "NOFILE";
  }
  
  return result;
}


char *GetComboFile()
{
  static char result[1000];
  char ending[10];

  if(BIN_ATTR_TYPE==1)
  {
    sprintf(ending,"bin");
  }
  else
  {
    sprintf(ending,"csv");
  }

  if((ATTRTYPE_D4()))
    {
      sprintf(result,"%sD4_combo.%s",GAIT_BIN_DIR,ending);
      return result;
    }
  else if((ATTRTYPE_FACC()))
    {
      sprintf(result,"%sFACC_PLUS_combo.%s",GAIT_BIN_DIR,ending);
      return result;
    }
  else if((ATTRTYPE_VMAP()))
    {
      sprintf(result,"%sVMAP_combo.%s",GAIT_BIN_DIR,ending);
      return result;
    }
  else if(ATTRTYPE_MGCP3())
    {
      sprintf(result,"%sMGCP3_combo.%s",GAIT_BIN_DIR,ending);
      return result;
    }
  else if(ATTRTYPE_MGCP4())
    {
      sprintf(result,"%sMGCP4_combo.%s",GAIT_BIN_DIR,ending);
      return result;
    }
  else if((ATTRTYPE_UFD1()))
    {
      sprintf(result,"%sUFD1_combo.%s",GAIT_BIN_DIR,ending);
      return result;
    }
  else if((ATTRTYPE_UFD2()))
    {
      sprintf(result,"%sUFD2_combo.%s",GAIT_BIN_DIR,ending);
      return result;
    }
  else if((ATTRTYPE_UFD3()))
    {
      sprintf(result,"%sUFD3_combo.%s",GAIT_BIN_DIR,ending);
      return result;
    }
  else if((ATTRTYPE_NFDD()))
    {
	  if(ATTRINSTYPE==2)
	  {
        sprintf(result,"%sNFDD_combo.%s",GAIT_BIN_DIR,ending);
	  }
	  else if((ATTRINSTYPE==3)||(ATTRINSTYPE==4))
	  {
        sprintf(result,"%sNFDD.%s",attrinsfolder,ending);
	  }
      return result;
    }
  else if((ATTRTYPE_DFDD()))
    {
	  if(ATTRINSTYPE==2)
	  {
        sprintf(result,"%sDFDD_combo.%s",GAIT_BIN_DIR,ending);
	  }
	  else if((ATTRINSTYPE==3)||(ATTRINSTYPE==4))
	  {
        sprintf(result,"%sDFDD.%s",attrinsfolder,ending);
	  }
      return result;
    }
  else if((ATTRTYPE_SAC()))
    {
      sprintf(result,"%sAFD_combo.%s",GAIT_BIN_DIR,ending);
      return result;
    }

  else if((ATTRTYPE_GGDM21()))
    {
      sprintf(result,"%sGGDM21_combo.%s",GAIT_BIN_DIR,ending);
      return result;
    }
  else if((ATTRTYPE_GGDM22()))
    {
      sprintf(result,"%sGGDM22_combo.%s",GAIT_BIN_DIR,ending);
      return result;
    }
  else if((ATTRTYPE_GGDM3()))
    {
      sprintf(result,"%sGGDM3_combo.%s",GAIT_BIN_DIR,ending);
      return result;
    }


  else if(ATTRTYPE_TDS4())
    {
      sprintf(result,"%sTDS4_combo.%s",GAIT_BIN_DIR,ending);
      return result;
    }
  else if(ATTRTYPE_TDS6())
    {
      sprintf(result,"%sTDS6_combo.%s",GAIT_BIN_DIR,ending);
      return result;
    }
  
  return "UNKNOWN!!!"; 
}


char *GetBoundaryMatchFile()
{
  static char retval[1000];

  

  if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
  { 
    sprintf(retval,"%sinspection_files\\BndryAttrMatch.csv",indirectory);
  }
  else
  { 
    sprintf(retval,"%sinspection_files/BndryAttrMatch.csv",indirectory);
  } 
  return retval;
}



void InitializeAttribution()
{
  




  #if(NGA_TYPE==1)

  if(ATTRIBUTION_TYPE==1)
    {
      gifd_attr_defns      = D4_attr_defns;
      gifd_attr_types      = D4_attr_types;
      gifd_class_names     = D4_class_names;
      gifd_class_codes     = D4_class_codes;
      gifd_class_defns     = D4_class_defns;
      gifd_attr_names      = D4_attr_names;
      gifd_attr_codes      = D4_attr_codes;
      gifd_enum_names      = D4_enum_names;
      gifd_enum_codes      = D4_enum_codes;
      gifd_attr_enum_start = D4_attr_enum_start;
      gifd_attr_enum_count = D4_attr_enum_count;
      STRATS               = D4STRATS;
      DOMAINS              = D4DOMAINS;
      GIFD_CLASS_NUM       = D4_CLASS_NUM;
      GIFD_ATTR_NUM        = D4_ATTR_NUM;
      DOMAINSLEN           = D4DOMAINSLEN;
      STRATSLEN            = D4STRATSLEN;      
      INscc_loop           = D4_CLASS_NUM + 1;
      INsac_loop           = D4_ATTR_NUM + 1;
    }  
  else if(ATTRIBUTION_TYPE==2)
    {
      gifd_attr_defns      = D4_attr_defns;
      gifd_attr_types      = D4_attr_types;
      gifd_class_names     = D4_class_names;
      gifd_class_codes     = D4_class_codes;
      gifd_class_defns     = D4_class_defns;
      gifd_attr_names      = D4_attr_names;
      gifd_attr_codes      = D4_attr_codes;
      gifd_enum_names      = D4_nunanpo_enum_names;
      gifd_enum_codes      = D4_nunanpo_enum_codes;
      gifd_attr_enum_start = D4_nunanpo_attr_enum_start;
      gifd_attr_enum_count = D4_nunanpo_attr_enum_count;
      STRATS               = D4STRATS;
      DOMAINS              = D4DOMAINS;
      GIFD_CLASS_NUM       = D4_CLASS_NUM;
      GIFD_ATTR_NUM        = D4_ATTR_NUM;
      DOMAINSLEN           = D4DOMAINSLEN;
      STRATSLEN            = D4STRATSLEN;      
      INscc_loop           = D4_CLASS_NUM + 1;
      INsac_loop           = D4_ATTR_NUM + 1;
    }  
  else if(ATTRIBUTION_TYPE==3)
    {
      gifd_attr_defns      = FLDB_attr_defns;
      gifd_attr_types      = FLDB_attr_types;
      gifd_class_names     = FLDB_class_names;
      gifd_class_codes     = FLDB_class_codes;
      gifd_class_defns     = FLDB_class_defns;
      gifd_attr_names      = FLDB_attr_names;
      gifd_attr_codes      = FLDB_attr_codes;
      gifd_enum_names      = FLDB_enum_names;
      gifd_enum_codes      = FLDB_enum_codes;
      gifd_attr_enum_start = FLDB_attr_enum_start;
      gifd_attr_enum_count = FLDB_attr_enum_count;
      STRATS               = FLDBSTRATS;
      DOMAINS              = FLDBDOMAINS;
      GIFD_CLASS_NUM       = FLDB_CLASS_NUM;
      GIFD_ATTR_NUM        = FLDB_ATTR_NUM;
      DOMAINSLEN           = FLDBDOMAINSLEN;
      STRATSLEN            = FLDBSTRATSLEN;      
      INscc_loop           = FLDB_CLASS_NUM + 1;
      INsac_loop           = FLDB_ATTR_NUM + 1;
    }  
  else if(ATTRIBUTION_TYPE==4)
    {
      gifd_attr_defns      = FLDB_attr_defns;
      gifd_attr_types      = FLDB_attr_types;
      gifd_class_names     = FLDB_class_names;
      gifd_class_codes     = FLDB_class_codes;
      gifd_class_defns     = FLDB_class_defns;
      gifd_attr_names      = FLDB_attr_names;
      gifd_attr_codes      = FLDB_attr_codes;
      gifd_enum_names      = FLDB_nunanpo_enum_names;
      gifd_enum_codes      = FLDB_nunanpo_enum_codes;
      gifd_attr_enum_start = FLDB_nunanpo_attr_enum_start;
      gifd_attr_enum_count = FLDB_nunanpo_attr_enum_count;
      STRATS               = FLDBSTRATS;
      DOMAINS              = FLDBDOMAINS;
      GIFD_CLASS_NUM       = FLDB_CLASS_NUM;
      GIFD_ATTR_NUM        = FLDB_ATTR_NUM;
      DOMAINSLEN           = FLDBDOMAINSLEN;
      STRATSLEN            = FLDBSTRATSLEN;      
      INscc_loop           = FLDB_CLASS_NUM + 1;
      INsac_loop           = FLDB_ATTR_NUM + 1;
    }  
  else if(ATTRIBUTION_TYPE==5)
    {
      gifd_attr_defns      = VMAP_attr_defns;
      gifd_attr_types      = VMAP_attr_types;
      gifd_class_names     = VMAP_class_names;
      gifd_class_codes     = VMAP_class_codes;
      gifd_class_defns     = VMAP_class_defns;
      gifd_attr_names      = VMAP_attr_names;
      gifd_attr_codes      = VMAP_attr_codes;
      gifd_enum_names      = VMAP_enum_names;
      gifd_enum_codes      = VMAP_enum_codes;
      gifd_attr_enum_start = VMAP_attr_enum_start;
      gifd_attr_enum_count = VMAP_attr_enum_count;
      STRATS               = VMAPSTRATS;
      DOMAINS              = VMAPDOMAINS;
      GIFD_CLASS_NUM       = VMAP_CLASS_NUM;
      GIFD_ATTR_NUM        = VMAP_ATTR_NUM;
      DOMAINSLEN           = VMAPDOMAINSLEN;
      STRATSLEN            = VMAPSTRATSLEN;      
      INscc_loop           = VMAP_CLASS_NUM + 1;
      INsac_loop           = VMAP_ATTR_NUM + 1;
    }  
  else if(ATTRIBUTION_TYPE==6)
    {
      gifd_attr_defns      = VMAP_attr_defns;
      gifd_attr_types      = VMAP_attr_types;
      gifd_class_names     = VMAP_class_names;
      gifd_class_codes     = VMAP_class_codes;
      gifd_class_defns     = VMAP_class_defns;
      gifd_attr_names      = VMAP_attr_names;
      gifd_attr_codes      = VMAP_attr_codes;
      gifd_enum_names      = VMAP_nunanpo_enum_names;
      gifd_enum_codes      = VMAP_nunanpo_enum_codes;
      gifd_attr_enum_start = VMAP_nunanpo_attr_enum_start;
      gifd_attr_enum_count = VMAP_nunanpo_attr_enum_count;
      STRATS               = VMAPSTRATS;
      DOMAINS              = VMAPDOMAINS;
      GIFD_CLASS_NUM       = VMAP_CLASS_NUM;
      GIFD_ATTR_NUM        = VMAP_ATTR_NUM;
      DOMAINSLEN           = VMAPDOMAINSLEN;
      STRATSLEN            = VMAPSTRATSLEN;      
      INscc_loop           = VMAP_CLASS_NUM + 1;
      INsac_loop           = VMAP_ATTR_NUM + 1;
    }  
  else if(ATTRTYPE_MGCP3())
    {
      gifd_attr_defns      = MGCP3_attr_defns;
      gifd_attr_types      = MGCP3_attr_types;
      gifd_class_names     = MGCP3_class_names;
      gifd_class_codes     = MGCP3_class_codes;
      gifd_class_defns     = MGCP3_class_defns;
      gifd_attr_names      = MGCP3_attr_names;
      gifd_attr_codes      = MGCP3_attr_codes;
      gifd_enum_names      = MGCP3_enum_names;
      gifd_enum_codes      = MGCP3_enum_codes;
      gifd_attr_enum_start = MGCP3_attr_enum_start;
      gifd_attr_enum_count = MGCP3_attr_enum_count;
      STRATS               = MGCP3STRATS;
      DOMAINS              = MGCP3DOMAINS;
      GIFD_CLASS_NUM       = MGCP3_CLASS_NUM;
      GIFD_ATTR_NUM        = MGCP3_ATTR_NUM;
      DOMAINSLEN           = MGCP3DOMAINSLEN;
      STRATSLEN            = MGCP3STRATSLEN;      
      INscc_loop           = MGCP3_CLASS_NUM + 1;
      INsac_loop           = MGCP3_ATTR_NUM + 1;
    }  
  else if(ATTRTYPE_MGCP4())
    {
      gifd_attr_defns      = MGCP4_attr_defns;
      gifd_attr_types      = MGCP4_attr_types;
      gifd_class_names     = MGCP4_class_names;
      gifd_class_codes     = MGCP4_class_codes;
      gifd_class_defns     = MGCP4_class_defns;
      gifd_attr_names      = MGCP4_attr_names;
      gifd_attr_codes      = MGCP4_attr_codes;
      gifd_enum_names      = MGCP4_enum_names;
      gifd_enum_codes      = MGCP4_enum_codes;
      gifd_attr_enum_start = MGCP4_attr_enum_start;
      gifd_attr_enum_count = MGCP4_attr_enum_count;
      STRATS               = MGCP4STRATS;
      DOMAINS              = MGCP4DOMAINS;
      GIFD_CLASS_NUM       = MGCP4_CLASS_NUM;
      GIFD_ATTR_NUM        = MGCP4_ATTR_NUM;
      DOMAINSLEN           = MGCP4DOMAINSLEN;
      STRATSLEN            = MGCP4STRATSLEN;      
      INscc_loop           = MGCP4_CLASS_NUM + 1;
      INsac_loop           = MGCP4_ATTR_NUM + 1;
    }

#if(USE_UFD==1)

  else if(ATTRIBUTION_TYPE==11)
    {
      gifd_attr_defns      = UFD1_attr_defns;
      gifd_attr_types      = UFD1_attr_types;
      gifd_class_names     = UFD1_class_names;
      gifd_class_codes     = UFD1_class_codes;
      gifd_class_defns     = UFD1_class_defns;
      gifd_attr_names      = UFD1_attr_names;
      gifd_attr_codes      = UFD1_attr_codes;
      gifd_enum_names      = UFD1_enum_names;
      gifd_enum_codes      = UFD1_enum_codes;
      gifd_attr_enum_start = UFD1_attr_enum_start;
      gifd_attr_enum_count = UFD1_attr_enum_count;
      STRATS               = UFD1STRATS;
      DOMAINS              = UFD1DOMAINS;
      GIFD_CLASS_NUM       = UFD1_CLASS_NUM;
      GIFD_ATTR_NUM        = UFD1_ATTR_NUM;
      DOMAINSLEN           = UFD1DOMAINSLEN;
      STRATSLEN            = UFD1STRATSLEN;      
      INscc_loop           = UFD1_CLASS_NUM + 1;
      INsac_loop           = UFD1_ATTR_NUM + 1;
    }  
  else if(ATTRIBUTION_TYPE==12)
    {
      gifd_attr_defns      = UFD1_attr_defns;
      gifd_attr_types      = UFD1_attr_types;
      gifd_class_names     = UFD1_class_names;
      gifd_class_codes     = UFD1_class_codes;
      gifd_class_defns     = UFD1_class_defns;
      gifd_attr_names      = UFD1_attr_names;
      gifd_attr_codes      = UFD1_attr_codes;
      gifd_enum_names      = UFD1_nunanpo_enum_names;
      gifd_enum_codes      = UFD1_nunanpo_enum_codes;
      gifd_attr_enum_start = UFD1_nunanpo_attr_enum_start;
      gifd_attr_enum_count = UFD1_nunanpo_attr_enum_count;
      STRATS               = UFD1STRATS;
      DOMAINS              = UFD1DOMAINS;
      GIFD_CLASS_NUM       = UFD1_CLASS_NUM;
      GIFD_ATTR_NUM        = UFD1_ATTR_NUM;
      DOMAINSLEN           = UFD1DOMAINSLEN;
      STRATSLEN            = UFD1STRATSLEN;      
      INscc_loop           = UFD1_CLASS_NUM + 1;
      INsac_loop           = UFD1_ATTR_NUM + 1;
    }  
  else if(ATTRIBUTION_TYPE==9)
    {
      gifd_attr_defns      = UFD2_attr_defns;
      gifd_attr_types      = UFD2_attr_types;
      gifd_class_names     = UFD2_class_names;
      gifd_class_codes     = UFD2_class_codes;
      gifd_class_defns     = UFD2_class_defns;
      gifd_attr_names      = UFD2_attr_names;
      gifd_attr_codes      = UFD2_attr_codes;
      gifd_enum_names      = UFD2_enum_names;
      gifd_enum_codes      = UFD2_enum_codes;
      gifd_attr_enum_start = UFD2_attr_enum_start;
      gifd_attr_enum_count = UFD2_attr_enum_count;
      STRATS               = UFD2STRATS;
      DOMAINS              = UFD2DOMAINS;
      GIFD_CLASS_NUM       = UFD2_CLASS_NUM;
      GIFD_ATTR_NUM        = UFD2_ATTR_NUM;
      DOMAINSLEN           = UFD2DOMAINSLEN;
      STRATSLEN            = UFD2STRATSLEN;      
      INscc_loop           = UFD2_CLASS_NUM + 1;
      INsac_loop           = UFD2_ATTR_NUM + 1;
    }  
  else if(ATTRIBUTION_TYPE==10)
    {
      gifd_attr_defns      = UFD2_attr_defns;
      gifd_attr_types      = UFD2_attr_types;
      gifd_class_names     = UFD2_class_names;
      gifd_class_codes     = UFD2_class_codes;
      gifd_class_defns     = UFD2_class_defns;
      gifd_attr_names      = UFD2_attr_names;
      gifd_attr_codes      = UFD2_attr_codes;
      gifd_enum_names      = UFD2_nunanpo_enum_names;
      gifd_enum_codes      = UFD2_nunanpo_enum_codes;
      gifd_attr_enum_start = UFD2_nunanpo_attr_enum_start;
      gifd_attr_enum_count = UFD2_nunanpo_attr_enum_count;
      STRATS               = UFD2STRATS;
      DOMAINS              = UFD2DOMAINS;
      GIFD_CLASS_NUM       = UFD2_CLASS_NUM;
      GIFD_ATTR_NUM        = UFD2_ATTR_NUM;
      DOMAINSLEN           = UFD2DOMAINSLEN;
      STRATSLEN            = UFD2STRATSLEN;      
      INscc_loop           = UFD2_CLASS_NUM + 1;
      INsac_loop           = UFD2_ATTR_NUM + 1;
    }  
  else if(ATTRIBUTION_TYPE==13)
    {
      gifd_attr_defns      = UFD3_attr_defns;
      gifd_attr_types      = UFD3_attr_types;
      gifd_class_names     = UFD3_class_names;
      gifd_class_codes     = UFD3_class_codes;
      gifd_class_defns     = UFD3_class_defns;
      gifd_attr_names      = UFD3_attr_names;
      gifd_attr_codes      = UFD3_attr_codes;
      gifd_enum_names      = UFD3_enum_names;
      gifd_enum_codes      = UFD3_enum_codes;
      gifd_attr_enum_start = UFD3_attr_enum_start;
      gifd_attr_enum_count = UFD3_attr_enum_count;
      STRATS               = UFD3STRATS;
      DOMAINS              = UFD3DOMAINS;
      GIFD_CLASS_NUM       = UFD3_CLASS_NUM;
      GIFD_ATTR_NUM        = UFD3_ATTR_NUM;
      DOMAINSLEN           = UFD3DOMAINSLEN;
      STRATSLEN            = UFD3STRATSLEN;      
      INscc_loop           = UFD3_CLASS_NUM + 1;
      INsac_loop           = UFD3_ATTR_NUM + 1;
    }  
  else if(ATTRIBUTION_TYPE==14)
    {
      gifd_attr_defns      = UFD3_attr_defns;
      gifd_attr_types      = UFD3_attr_types;
      gifd_class_names     = UFD3_class_names;
      gifd_class_codes     = UFD3_class_codes;
      gifd_class_defns     = UFD3_class_defns;
      gifd_attr_names      = UFD3_attr_names;
      gifd_attr_codes      = UFD3_attr_codes;
      gifd_enum_names      = UFD3_nunanpo_enum_names;
      gifd_enum_codes      = UFD3_nunanpo_enum_codes;
      gifd_attr_enum_start = UFD3_nunanpo_attr_enum_start;
      gifd_attr_enum_count = UFD3_nunanpo_attr_enum_count;
      STRATS               = UFD3STRATS;
      DOMAINS              = UFD3DOMAINS;
      GIFD_CLASS_NUM       = UFD3_CLASS_NUM;
      GIFD_ATTR_NUM        = UFD3_ATTR_NUM;
      DOMAINSLEN           = UFD3DOMAINSLEN;
      STRATSLEN            = UFD3STRATSLEN;      
      INscc_loop           = UFD3_CLASS_NUM + 1;
      INsac_loop           = UFD3_ATTR_NUM + 1;
    }  
#endif

#if(USE_NFDD==1)

  else if(ATTRIBUTION_TYPE==23)
    {
      gifd_attr_defns      = NFDD_attr_defns;
      gifd_attr_types      = NFDD_attr_types;
      gifd_class_names     = NFDD_class_names;
      gifd_class_codes     = NFDD_class_codes;
      gifd_class_defns     = NFDD_class_defns;
      gifd_attr_names      = NFDD_attr_names;
      gifd_attr_codes      = NFDD_attr_codes;
      gifd_enum_names      = NFDD_enum_names;
      gifd_enum_codes      = NFDD_enum_codes;
      gifd_attr_enum_start = NFDD_attr_enum_start;
      gifd_attr_enum_count = NFDD_attr_enum_count;
      STRATS               = NFDDSTRATS;
      DOMAINS              = NFDDDOMAINS;
      GIFD_CLASS_NUM       = NFDD_CLASS_NUM;
      GIFD_ATTR_NUM        = NFDD_ATTR_NUM;
      DOMAINSLEN           = NFDDDOMAINSLEN;
      STRATSLEN            = NFDDSTRATSLEN;      
      INscc_loop           = NFDD_CLASS_NUM + 1;
      INsac_loop           = NFDD_ATTR_NUM + 1;
    }  
  else if(ATTRIBUTION_TYPE==24)
    {
      gifd_attr_defns      = NFDD_attr_defns;
      gifd_attr_types      = NFDD_attr_types;
      gifd_class_names     = NFDD_class_names;
      gifd_class_codes     = NFDD_class_codes;
      gifd_class_defns     = NFDD_class_defns;
      gifd_attr_names      = NFDD_attr_names;
      gifd_attr_codes      = NFDD_attr_codes;
      gifd_enum_names      = NFDD_nunanpo_enum_names;
      gifd_enum_codes      = NFDD_nunanpo_enum_codes;
      gifd_attr_enum_start = NFDD_nunanpo_attr_enum_start;
      gifd_attr_enum_count = NFDD_nunanpo_attr_enum_count;
      STRATS               = NFDDSTRATS;
      DOMAINS              = NFDDDOMAINS;
      GIFD_CLASS_NUM       = NFDD_CLASS_NUM;
      GIFD_ATTR_NUM        = NFDD_ATTR_NUM;
      DOMAINSLEN           = NFDDDOMAINSLEN;
      STRATSLEN            = NFDDSTRATSLEN;      
      INscc_loop           = NFDD_CLASS_NUM + 1;
      INsac_loop           = NFDD_ATTR_NUM + 1;
    }  

#endif


#if(USE_DFDD==1)

    else if(ATTRIBUTION_TYPE==25)
    {
      gifd_attr_defns      = DFDD_attr_defns;
      gifd_attr_types      = DFDD_attr_types;
      gifd_class_names     = DFDD_class_names;
      gifd_class_codes     = DFDD_class_codes;
      gifd_class_defns     = DFDD_class_defns;
      gifd_attr_names      = DFDD_attr_names;
      gifd_attr_codes      = DFDD_attr_codes;
      gifd_enum_names      = DFDD_enum_names;
      gifd_enum_codes      = DFDD_enum_codes;
      gifd_attr_enum_start = DFDD_attr_enum_start;
      gifd_attr_enum_count = DFDD_attr_enum_count;
      STRATS               = DFDDSTRATS;
      DOMAINS              = DFDDDOMAINS;
      GIFD_CLASS_NUM       = DFDD_CLASS_NUM;
      GIFD_ATTR_NUM        = DFDD_ATTR_NUM;
      DOMAINSLEN           = DFDDDOMAINSLEN;
      STRATSLEN            = DFDDSTRATSLEN;      
      INscc_loop           = DFDD_CLASS_NUM + 1;
      INsac_loop           = DFDD_ATTR_NUM + 1;
    }  
  else if((ATTRIBUTION_TYPE==26)||(ATTRIBUTION_TYPE==261))  
    {
      gifd_attr_defns      = DFDD_attr_defns;
      gifd_attr_types      = DFDD_attr_types;
      gifd_class_names     = DFDD_class_names;
      gifd_class_codes     = DFDD_class_codes;
      gifd_class_defns     = DFDD_class_defns;
      gifd_attr_names      = DFDD_attr_names;
      gifd_attr_codes      = DFDD_attr_codes;
      gifd_enum_names      = DFDD_nunanpo_enum_names;
      gifd_enum_codes      = DFDD_nunanpo_enum_codes;
      gifd_attr_enum_start = DFDD_nunanpo_attr_enum_start;
      gifd_attr_enum_count = DFDD_nunanpo_attr_enum_count;
      STRATS               = DFDDSTRATS;
      DOMAINS              = DFDDDOMAINS;
      GIFD_CLASS_NUM       = DFDD_CLASS_NUM;
      GIFD_ATTR_NUM        = DFDD_ATTR_NUM;
      DOMAINSLEN           = DFDDDOMAINSLEN;
      STRATSLEN            = DFDDSTRATSLEN;      
      INscc_loop           = DFDD_CLASS_NUM + 1;
      INsac_loop           = DFDD_ATTR_NUM + 1;
    }

#endif

    else if(ATTRIBUTION_TYPE==27)
    {
      gifd_attr_defns      = SAC_attr_defns;
      gifd_attr_types      = SAC_attr_types;
      gifd_class_names     = SAC_class_names;
      gifd_class_codes     = SAC_class_codes;
      gifd_class_defns     = SAC_class_defns;
      gifd_attr_names      = SAC_attr_names;
      gifd_attr_codes      = SAC_attr_codes;
      gifd_enum_names      = SAC_enum_names;
      gifd_enum_codes      = SAC_enum_codes;
      gifd_attr_enum_start = SAC_attr_enum_start;
      gifd_attr_enum_count = SAC_attr_enum_count;
      STRATS               = SACSTRATS;
      DOMAINS              = SACDOMAINS;
      GIFD_CLASS_NUM       = SAC_CLASS_NUM;
      GIFD_ATTR_NUM        = SAC_ATTR_NUM;
      DOMAINSLEN           = SACDOMAINSLEN;
      STRATSLEN            = SACSTRATSLEN;      
      INscc_loop           = SAC_CLASS_NUM + 1;
      INsac_loop           = SAC_ATTR_NUM + 1;
    }  


#if(USE_TDS==1)
  else if(ATTRTYPE_TDS4())  
    {
      gifd_attr_defns      = TDS4_attr_defns;
      gifd_attr_types      = TDS4_attr_types;
      gifd_class_names     = TDS4_class_names;
      gifd_class_codes     = TDS4_class_codes;
      gifd_class_defns     = TDS4_class_defns;
      gifd_attr_names      = TDS4_attr_names;
      gifd_attr_codes      = TDS4_attr_codes;
      gifd_enum_names      = TDS4_enum_names;
      gifd_enum_codes      = TDS4_enum_codes;
      gifd_attr_enum_start = TDS4_attr_enum_start;
      gifd_attr_enum_count = TDS4_attr_enum_count;
      STRATS               = TDS4STRATS;
      DOMAINS              = TDS4DOMAINS;
      GIFD_CLASS_NUM       = TDS4_CLASS_NUM;
      GIFD_ATTR_NUM        = TDS4_ATTR_NUM;
      DOMAINSLEN           = TDS4DOMAINSLEN;
      STRATSLEN            = TDS4STRATSLEN;      
      INscc_loop           = TDS4_CLASS_NUM + 1;
      INsac_loop           = TDS4_ATTR_NUM + 1;
    }   
  else if(ATTRTYPE_TDS6())  
    {
      gifd_attr_defns      = TDS6_attr_defns;
      gifd_attr_types      = TDS6_attr_types;
      gifd_class_names     = TDS6_class_names;
      gifd_class_codes     = TDS6_class_codes;
      gifd_class_defns     = TDS6_class_defns;
      gifd_attr_names      = TDS6_attr_names;
      gifd_attr_codes      = TDS6_attr_codes;
      gifd_enum_names      = TDS6_enum_names;
      gifd_enum_codes      = TDS6_enum_codes;
      gifd_attr_enum_start = TDS6_attr_enum_start;
      gifd_attr_enum_count = TDS6_attr_enum_count;
      STRATS               = TDS6STRATS;
      DOMAINS              = TDS6DOMAINS;
      GIFD_CLASS_NUM       = TDS6_CLASS_NUM;
      GIFD_ATTR_NUM        = TDS6_ATTR_NUM;
      DOMAINSLEN           = TDS6DOMAINSLEN;
      STRATSLEN            = TDS6STRATSLEN;      
      INscc_loop           = TDS6_CLASS_NUM + 1;
      INsac_loop           = TDS6_ATTR_NUM + 1;
  }
#endif






#if(USE_GGDM==1)



    else if(ATTRIBUTION_TYPE==29)  
    {
      gifd_attr_defns      = GGDM22_U_attr_defns;
      gifd_attr_types      = GGDM22_U_attr_types;
      gifd_class_names     = GGDM22_U_class_names;
      gifd_class_codes     = GGDM22_U_class_codes;
      gifd_class_defns     = GGDM22_U_class_defns;
      gifd_attr_names      = GGDM22_U_attr_names;
      gifd_attr_codes      = GGDM22_U_attr_codes;
      gifd_enum_names      = GGDM22_U_enum_names;
      gifd_enum_codes      = GGDM22_U_enum_codes;
      gifd_attr_enum_start = GGDM22_U_attr_enum_start;
      gifd_attr_enum_count = GGDM22_U_attr_enum_count;
      STRATS               = GGDM22_USTRATS;
      DOMAINS              = GGDM22_UDOMAINS;
      GIFD_CLASS_NUM       = GGDM22_U_CLASS_NUM;
      GIFD_ATTR_NUM        = GGDM22_U_ATTR_NUM;
      DOMAINSLEN           = GGDM22_UDOMAINSLEN;
      STRATSLEN            = GGDM22_USTRATSLEN;      
      INscc_loop           = GGDM22_U_CLASS_NUM + 1;
      INsac_loop           = GGDM22_U_ATTR_NUM + 1;
    }

    else if(ATTRIBUTION_TYPE==45)
    {
      gifd_attr_defns      = GGDM21_attr_defns;
      gifd_attr_types      = GGDM21_attr_types;
      gifd_class_names     = GGDM21_class_names;
      gifd_class_codes     = GGDM21_class_codes;
      gifd_class_defns     = GGDM21_class_defns;
      gifd_attr_names      = GGDM21_attr_names;
      gifd_attr_codes      = GGDM21_attr_codes;
      gifd_enum_names      = GGDM21_enum_names;
      gifd_enum_codes      = GGDM21_enum_codes;
      gifd_attr_enum_start = GGDM21_attr_enum_start;
      gifd_attr_enum_count = GGDM21_attr_enum_count;
      STRATS               = GGDM21STRATS;
      DOMAINS              = GGDM21DOMAINS;
      GIFD_CLASS_NUM       = GGDM21_CLASS_NUM;
      GIFD_ATTR_NUM        = GGDM21_ATTR_NUM;
      DOMAINSLEN           = GGDM21DOMAINSLEN;
      STRATSLEN            = GGDM21STRATSLEN;      
      INscc_loop           = GGDM21_CLASS_NUM + 1;
      INsac_loop           = GGDM21_ATTR_NUM + 1;
    }

    else if(ATTRIBUTION_TYPE==47)
    {
      gifd_attr_defns      = GGDM3_attr_defns;
      gifd_attr_types      = GGDM3_attr_types;
      gifd_class_names     = GGDM3_class_names;
      gifd_class_codes     = GGDM3_class_codes;
      gifd_class_defns     = GGDM3_class_defns;
      gifd_attr_names      = GGDM3_attr_names;
      gifd_attr_codes      = GGDM3_attr_codes;
      gifd_enum_names      = GGDM3_enum_names;
      gifd_enum_codes      = GGDM3_enum_codes;
      gifd_attr_enum_start = GGDM3_attr_enum_start;
      gifd_attr_enum_count = GGDM3_attr_enum_count;
      STRATS               = GGDM3STRATS;
      DOMAINS              = GGDM3DOMAINS;
      GIFD_CLASS_NUM       = GGDM3_CLASS_NUM;
      GIFD_ATTR_NUM        = GGDM3_ATTR_NUM;
      DOMAINSLEN           = GGDM3DOMAINSLEN;
      STRATSLEN            = GGDM3STRATSLEN;      
      INscc_loop           = GGDM3_CLASS_NUM + 1;
      INsac_loop           = GGDM3_ATTR_NUM + 1;
    }


#endif




  else
    {
      printf("unexpected attribution schema %d\n",ATTRIBUTION_TYPE);
      ExitWrapper(-1);
    }

  #endif
}




int SingleNetworkSelected()
{
  
  int totalchecks=0,totalconds=0,totalhighlighted=0,errnum,cloneindex;
  
  
  NETGetGlobalTotals(&totalchecks,&totalconds,&totalhighlighted);
  
  if(totalhighlighted!=1)
    {
      return 0;
    }



  



  for(errnum=1;errnum<=CONDITION_DEFINITIONS;errnum++)
    {
      if(IsNetCheck(errnum)==1)
	{
	  if(ErrorLookup[errnum].viewallNET==1)
	    {
	      return 0;
	    }
	}
    }

 
  for(cloneindex=0;cloneindex<CLONE_DEFINITIONS;cloneindex++)
    {	
      if(IsNetCheck(CloneErrorLookup[cloneindex].CloneNumber)==1)
	{
	  if(CloneErrorLookup[cloneindex].viewallNET==1)
	    {
	      return 0;
	    }
	}
    }

  return 1;

}



void choose_specific_network(Widget w,XtPointer client_data,XtPointer call_data)
{ 
  static int LOCALBUSY = 0;
  int *pos_list;
  int errnum = (int)client_data,pos_count,i;


  


  XmListGetSelectedPos(ErrorLookup[errnum].scrollwidNET,&pos_list,&pos_count);
  
  if(ErrorLookup[errnum].NETpos_list_made>0)
    {
      free(ErrorLookup[errnum].NETpos_list);
      ErrorLookup[errnum].NETpos_list_made = 0;
    }
  
  ErrorLookup[errnum].NETpos_list = (int *)malloc(SzI*pos_count);
  if(ErrorLookup[errnum].NETpos_list==NULL)
    {
      printf("Failed to alloc %d PLM\n",pos_count);
      ExitWrapper(-1);
    }


  for(i=0;i<pos_count;i++)
    {
      ErrorLookup[errnum].NETpos_list[i] = pos_list[i];
    }
  
  ErrorLookup[errnum].NETpos_list_made = pos_count;




  if(
     (ErrorLookup[errnum].viewallNET ==0) &&
     (ErrorLookup[errnum].viewsomeNET==0)
     )
    {
      
      return;
    }


  if(LOCALBUSY==1)
    {
      printf("Arrow action ignored due to being too busy\n");
      return;
    }

  if(BUSY==1)
    {
      printf("Action ignored due to being too busy\n");
      return; 
    }



  LOCALBUSY = 1;


  if(SingleNetworkSelected()==1)
    {    
      PossibleToCenterNetZoom = 1;
      refreshCallback((Widget)NULL,(XtPointer)NULL,(XtPointer)NULL);
      PossibleToCenterNetZoom = 0;
    }
  UpdateAllTotals();

  LOCALBUSY = 0;
}




void choose_specific_network2(Widget w,XtPointer client_data,XtPointer call_data)
{ 
  static int LOCALBUSY = 0;
  int *pos_list;
  int cloneindex = (int)client_data,pos_count,i;


  



  XmListGetSelectedPos(CloneErrorLookup[cloneindex].scrollwidNET,&pos_list,&pos_count);
  
  if(CloneErrorLookup[cloneindex].NETpos_list_made>0)
    {
      free(CloneErrorLookup[cloneindex].NETpos_list);
      CloneErrorLookup[cloneindex].NETpos_list_made = 0;
    }
  
  CloneErrorLookup[cloneindex].NETpos_list = (int *)malloc(SzI*pos_count);
  if(CloneErrorLookup[cloneindex].NETpos_list==NULL)
    {
      printf("Failed to alloc %d PPLM\n",pos_count);
      ExitWrapper(-1);
    }
  
  
  for(i=0;i<pos_count;i++)
    {
      CloneErrorLookup[cloneindex].NETpos_list[i] = pos_list[i];
    }
  
  CloneErrorLookup[cloneindex].NETpos_list_made = pos_count;
  



  if(
     (CloneErrorLookup[cloneindex].viewallNET ==0) &&
     (CloneErrorLookup[cloneindex].viewsomeNET==0)
     )
    {
      
      return;
    }


  if(LOCALBUSY==1)
    {
      printf("Arrow action ignored due to being too busy\n");
      return;
    }

  if(BUSY==1)
    {
      printf("Action ignored due to being too busy\n");
      return; 
    }

  LOCALBUSY = 1;
  
  if(SingleNetworkSelected()==1)
    {    
      PossibleToCenterNetZoom = 1;
      refreshCallback((Widget)NULL,(XtPointer)NULL,(XtPointer)NULL);
      PossibleToCenterNetZoom = 0;
    }

  UpdateAllTotals();

  LOCALBUSY = 0;
}






char *GetNetAnnotation(int checknum, int clonenum)
{
  FILE *netfile;
  int i,index,clonenumber,count;
  int totalnets = 0;
  char filename[1000],title[2000];
  static char retvalue[2000];


  
  sprintf(filename,"%scondreport.nt",outdirectory);
  netfile = fopen(filename,"rb");
  if(netfile==NULL)
    {
      printf("NetError: could not open %s for read\n",filename);
      return 0;
    }
  
  SEEIT_fread_int(&totalnets,netfile);
  
  
  
  for(i=0; i<totalnets; i++)
    {
      SEEIT_fread_int(&index,      netfile);
      SEEIT_fread_int(&clonenumber,netfile);
      SEEIT_fread_int(&count,      netfile);
      fread(&title[0],1000,1,      netfile);
      
      

      if(
	 (index==checknum)      &&
	 (clonenum==clonenumber)
	 )
	{
	  sprintf(retvalue,"%s",title);
	  fclose(netfile);
	  return retvalue;
	}

    }

  fclose(netfile);

  XBell(mydisplay,50);
  printf("Unable to find annotation for instance %d\n",clonenum);

  return "No Annotation Found";

}



int GetNetworkCount(int type, int errnum, int clonenum)
{
  FILE *netfile;
  int i,index,clonenumber,count;
  int totalnets = 0,retval=0;
  char filename[1000],title[1000];


  sprintf(filename,"%scondreport.nt",outdirectory);
  netfile = fopen(filename,"rb");
  if(netfile==NULL)
    {
      printf("NetError: could not open %s for read\n",filename);
      return 0;
    }

  SEEIT_fread_int(&totalnets,netfile);

  if(type==-1)
    {
      retval = totalnets;
    }
  else if(type==0)
    {
      

      for(i=0; i<totalnets; i++)
	{
	  SEEIT_fread_int(&index,      netfile);
	  SEEIT_fread_int(&clonenumber,netfile);
	  SEEIT_fread_int(&count,      netfile);
	  fread(&title[0],1000,1,      netfile);
	  
	  if(
	     (index==errnum)
	     )
	    {
	      retval = retval + 1;
	    }
	}
    }
  else if(type==1)
    {
      

      for(i=0; i<totalnets; i++)
	{
	  SEEIT_fread_int(&index,      netfile);
	  SEEIT_fread_int(&clonenumber,netfile);
	  SEEIT_fread_int(&count,      netfile);
	  fread(&title[0],1000,1,      netfile);
	  
	  retval = retval + count;
	}
    }
  else if(type==2)
    {
      

      for(i=0; i<totalnets; i++)
	{
	  SEEIT_fread_int(&index,      netfile);
	  SEEIT_fread_int(&clonenumber,netfile);
	  SEEIT_fread_int(&count,      netfile);
	  fread(&title[0],1000,1,      netfile);
	
	  if(
	     (clonenumber==clonenum) &&
	     (index==errnum)
	     )
	    {
	      retval = retval + count;
	    }
	}
    }
  else if(type==3)
    {
      

      for(i=0; i<totalnets; i++)
	{
	  SEEIT_fread_int(&index,      netfile);
	  SEEIT_fread_int(&clonenumber,netfile);
	  SEEIT_fread_int(&count,      netfile);
	  fread(&title[0],1000,1,      netfile);
	
	  if(
	     (index==errnum)
	     )
	    {
	      retval = retval + count;
	    }
	}
    }
  fclose(netfile);
  return retval;
}





void NETGetGlobalTotals(int *totalchecks,int *totalconds,int *totalhighlighted)
{
  int numnets,errnum,cloneindex;


  numnets = GetNetworkCount(-1,-1,-1);      
  *totalchecks = numnets;

  if(numnets>0)
    {
      *totalconds = GetNetworkCount(1,-1,-1);
    }


  *totalhighlighted = 0;
  
  for(errnum=1;errnum<=CONDITION_DEFINITIONS;errnum++)
    {
      if(ErrorLookup[errnum].numberNets>0)
	{
	  if(ErrorLookup[errnum].viewallNET==1)
	    {
	      *totalhighlighted = *totalhighlighted + ErrorLookup[errnum].numberNets;
	    }
	  else if(ErrorLookup[errnum].viewsomeNET==1)
	    {
	      *totalhighlighted = *totalhighlighted + ErrorLookup[errnum].NETpos_list_made;
	    }
	}
    }	
  
  for(cloneindex=0;cloneindex<CLONE_DEFINITIONS;cloneindex++)
    {	
      if(CloneErrorLookup[cloneindex].numberNets>0)
	{
	  if(CloneErrorLookup[cloneindex].viewallNET==1)
	    {
	      *totalhighlighted = *totalhighlighted + CloneErrorLookup[cloneindex].numberNets;
	    }
	  else if(CloneErrorLookup[cloneindex].viewsomeNET==1)
	    {
	      *totalhighlighted = *totalhighlighted + CloneErrorLookup[cloneindex].NETpos_list_made;
	    }
	}
    }

}






void NETBuildSpecificCond(Widget parent, int errnum, int clonenum, int scr_width, int makewatch)
{
  Widget subhandle,junkwid,rc3,form,widtozero;
  XmString *error_items;
  Dimension width;
  Arg resources[15];
  int cloneindex,total=0,zeroout;
  int n=0,i=0;
  char temp[1000],filename[1000];
  extern char * GetSubnetName(char * fname, int TgtCheck, int TgtCnumber);
  extern int NetworkNameSize;
  extern char **NetworkNames;
  extern void FreeNetworkNames();


  if(clonenum<0)
    {
      clonenum = 0;
    }


  total = GetNetworkCount(2,errnum,clonenum);

  
  if(total==0)
    {
      printf("NETBuildSpecificCond got total 0\n");
      XBell(mydisplay,50);
      return;
    }

  set_cursor(mydisplay,mywindow,WATCH);
  if(makewatch==1)
  {
	  set_cursor(XtDisplay(networkhead[Current_net_head]),XtWindow(networkhead[Current_net_head]),WATCH);
  }

  if(clonenum>0)
    {
      cloneindex = GetCloneIndex(clonenum,errnum);
    }

 if(scr_width==-1)
   {
     XtVaGetValues(networkhead[Current_net_head], XmNwidth, &width, NULL);
     scr_width = width - 200;
   }

 error_items = (XmString *) (malloc(sizeof(XmString *) * total));
 if(error_items==NULL){printf("error_items: out of allocation memory!\n"); ExitWrapper(-1);}
 
 sprintf(filename,"%scondreport.nt",outdirectory);





 GetSubnetName(filename,errnum,clonenum);
 
 
 if(NetworkNameSize!=total)
   {
     printf("mismatch between expected network name size and actual %d/%d\n",
	    NetworkNameSize,total );
     
     for(i=1;i<=total;i++)
       {
	 sprintf(temp,"Network #%d: Unknown name",i);
	 error_items[i-1] = XmStringCreateLocalized (temp);
       }     
   }
 else
   {
     for(i=1;i<=total;i++)
       {
	 sprintf(temp,"Network #%d: %s ",i,NetworkNames[i-1]);
	 error_items[i-1] = XmStringCreateLocalized (temp);
       }
   }

 FreeNetworkNames();
 

 
  

 
 if(clonenum>0)
   {
     sprintf(list_translations27,"#override\n <Btn4Up>:          list_scroll_net(1,%d,%d)ListEndSelect()\n <Btn5Up>:          list_scroll_net(2,%d,%d)RemoveAddMode()\n <Btn2Down>: do_nothing2(2down)\n <Btn2Up>: do_nothing2(2up)",
	     -1,cloneindex,-1,cloneindex);
     
   }
 else
   {
     sprintf(list_translations27,"#override\n <Btn4Up>:          list_scroll_net(1,%d,%d)ListEndSelect()\n <Btn5Up>:          list_scroll_net(2,%d,%d)RemoveAddMode()\n <Btn2Down>: do_nothing2(2down)\n <Btn2Up>: do_nothing2(2up)",
	     errnum,-1,errnum,-1);
   }
 

 

 
 if(total<10)
   {
     i=total; 
   }
 else
   {
     i=10;
   }
 




 XtSetArg(resources[n],  XmNlistSizePolicy,    XmCONSTANT);  n++;
 XtSetArg(resources[n],  XmNheight, i*20 + 22);              n++;
 XtSetArg(resources[n], 
	  XmNtranslations, 
	  XtParseTranslationTable (list_translations27));    n++;
 


 subhandle = XtVaCreateManagedWidget("subhandle",
				     xmHandleWidgetClass,
				     parent,
				     NULL);
 
 
 
 
 rc3 = XtVaCreateWidget ("rowcol",xmRowColumnWidgetClass, subhandle, 
			 NULL);
  
 
 form = XtVaCreateWidget ("form.error.editor", xmFormWidgetClass, rc3,
			  XmNfractionBase,  100, 
			  NULL);
 
 
 if(clonenum>0)
   {
      
      junkwid = XmCreateScrolledList (form, "list1234",NULL,0);
      
      XtVaSetValues (junkwid,
		     XmNitems,            error_items,
		     XmNitemCount,        total,
		     XmNvisibleItemCount, i,
		     XmNselectionPolicy,  XmEXTENDED_SELECT,
		     NULL);   
      XtManageChild (junkwid);
      
      XtVaGetValues(junkwid, XmNwidth, &width, NULL);
      XtDestroyWidget (junkwid);
      

      CloneErrorLookup[cloneindex].maxscrollsizeNET = width;


      if(width<scr_width)
	{
	  scr_width = width;
	}
      

      XtSetArg(resources[n],  XmNwidth,             scr_width);   n++;


      
      CloneErrorLookup[cloneindex].scrollwidNET = 
	XmCreateScrolledList (form, "list", resources,n);
      
      XtVaSetValues (CloneErrorLookup[cloneindex].scrollwidNET,
		     XmNitems,            error_items,
		     XmNitemCount,        total,
		     XmNvisibleItemCount, i,
		     XmNselectionPolicy,  XmEXTENDED_SELECT,
		     NULL);


      
      XtVaGetValues(CloneErrorLookup[cloneindex].scrollwidNET,
		    XmNverticalScrollBar,&CloneErrorLookup[cloneindex].vertwidNET ,NULL);
      XtAddCallback (CloneErrorLookup[cloneindex].scrollwidNET, 
		     XmNextendedSelectionCallback, choose_specific_network2, (XtPointer)cloneindex);
      XtManageChild (CloneErrorLookup[cloneindex].scrollwidNET);

      XtAddCallback (CloneErrorLookup[cloneindex].scrollwidNET,  XmNdefaultActionCallback,quick_network2, (XtPointer)cloneindex);



      XtVaGetValues(CloneErrorLookup[cloneindex].scrollwidNET,  
		    XmNwidth, &width, NULL);



      XtVaSetValues(CloneErrorLookup[cloneindex].scrollwidNET,  
		    XmNlistSizePolicy,    XmCONSTANT,
		    NULL); 
      

      if(CloneErrorLookup[cloneindex].NETpos_list_made>0)
	{
	  
	  XtVaSetValues (CloneErrorLookup[cloneindex].scrollwidNET,
			 XmNselectionPolicy,  XmMULTIPLE_SELECT,
			 NULL);
	  
	  for(i=0;i<CloneErrorLookup[cloneindex].NETpos_list_made;i++)
	    {	      
	      XmListSelectPos(CloneErrorLookup[cloneindex].scrollwidNET,
			      CloneErrorLookup[cloneindex].NETpos_list[i],0);
	    }
	  XtVaSetValues (CloneErrorLookup[cloneindex].scrollwidNET,
			 XmNselectionPolicy,  XmEXTENDED_SELECT,
			 NULL);
	  zeroout = 0;
	}
      else
	{
	  widtozero = CloneErrorLookup[cloneindex].scrollwidNET;
	  zeroout = 1;
	}
      XmListSetAddMode(CloneErrorLookup[cloneindex].scrollwidNET,False);
    }
  else
    {
      
      junkwid = XmCreateScrolledList (form, "list1234",NULL,0);
      
      XtVaSetValues (junkwid,
		     XmNitems,            error_items,
		     XmNitemCount,        total,
		     XmNvisibleItemCount, i,
		     XmNselectionPolicy,  XmEXTENDED_SELECT,
		     NULL);  
      XtManageChild (junkwid);

      XtVaGetValues(junkwid, XmNwidth, &width, NULL);
      XtDestroyWidget (junkwid);
      
      
      ErrorLookup[errnum].maxscrollsizeNET = width;

      

      if(width<scr_width)
	{
	  scr_width = width;
	}

      XtSetArg(resources[n],  XmNwidth,             scr_width);   n++;


      ErrorLookup[errnum].scrollwidNET = 
	XmCreateScrolledList (form, "list", resources,n);
      
      
      XtVaSetValues (ErrorLookup[errnum].scrollwidNET,
		     XmNitems,            error_items,
		     XmNitemCount,        total,
		     XmNvisibleItemCount, i,
		     XmNselectionPolicy,  XmEXTENDED_SELECT,
		     NULL);
      
      
      XtVaGetValues(ErrorLookup[errnum].scrollwidNET,
		    XmNverticalScrollBar,&ErrorLookup[errnum].vertwidNET,NULL);
      XtAddCallback (ErrorLookup[errnum].scrollwidNET, 
		     XmNextendedSelectionCallback, choose_specific_network, (XtPointer) errnum);
      XtManageChild (ErrorLookup[errnum].scrollwidNET);


      XtAddCallback (ErrorLookup[errnum].scrollwidNET,  XmNdefaultActionCallback,quick_network, (XtPointer)errnum);


      if(ErrorLookup[errnum].NETpos_list_made>0)
	{

	  XtVaSetValues (ErrorLookup[errnum].scrollwidNET,
			 XmNselectionPolicy,  XmMULTIPLE_SELECT,
			 NULL);
	  
	  for(i=0;i<ErrorLookup[errnum].NETpos_list_made;i++)
	    {
	      XmListSelectPos(ErrorLookup[errnum].scrollwidNET,ErrorLookup[errnum].NETpos_list[i],0);
	    }
	  XtVaSetValues (ErrorLookup[errnum].scrollwidNET,
			 XmNselectionPolicy,  XmEXTENDED_SELECT,
			 NULL);
	  zeroout = 0;
	}
      else
	{
	  widtozero = ErrorLookup[errnum].scrollwidNET;
	  zeroout = 1;
	}
      XmListSetAddMode(ErrorLookup[errnum].scrollwidNET,False);
    }
  
  
  XtManageChild(form);
  XtManageChild(rc3);
  
  
  
  if(zeroout==1)
    {
      
      XmListDeselectAllItems(widtozero);
    }
  
  for (i = 0; i <  total; i++)
    {
      XmStringFree (error_items[i]);
    }     
  free(error_items);



  set_cursor(mydisplay,mywindow,GOOD);
  if(makewatch==1)
  {
	  set_cursor(XtDisplay(networkhead[Current_net_head]),XtWindow(networkhead[Current_net_head]),ARROW);
  }



}






void NETToggleButtonHandleCB(Widget w, MyData  *closure, XtPointer call_data)
{
  XmOutlineWidget outline = (XmOutlineWidget) closure->outlinewid;
  int level = closure->level;
  int check_num,clonenum,cloneindex;

  
  if(level==1)
    {
      if(NETOnOff1==1)
	{
	  XtUnmanageChild((Widget) outline);
	  XtVaSetValues(w, XmNlabelPixmap, plus_pix, NULL);
	  NETOnOff1 = 0;
	}
      else if(NETOnOff1==0)
	{
	  XtManageChild((Widget) outline);
	  XtVaSetValues(w, XmNlabelPixmap, minus_pix, NULL);
	  NETOnOff1 = 1;
	}
    }
  else if(level==4)
    {
      
      
      clonenum  = closure->clonenum;
      check_num = closure->check_num;
      
      if(clonenum>0)
	{
	  cloneindex = GetCloneIndex(clonenum,check_num);
	  if(CloneErrorLookup[cloneindex].NETonoff==1)
	    {
	      XtUnmanageChild((Widget) outline);
	      CloneErrorLookup[cloneindex].NETonoff = 0;
	      XtVaSetValues(w, XmNlabelPixmap, plus_pix, NULL);
	    }
	  else if(CloneErrorLookup[cloneindex].NETonoff==0)
	    {
	      if(CloneErrorLookup[cloneindex].scrollwidmadeNET==0)
		{
		  NETBuildSpecificCond((Widget) outline, check_num, clonenum,-1,1);
		  
		  CloneErrorLookup[cloneindex].scrollwidmadeNET = 1;
		}
	      
	      XtManageChild((Widget) outline);

	      CloneErrorLookup[cloneindex].NETonoff = 1;
	      XtVaSetValues(w, XmNlabelPixmap, minus_pix, NULL);
	    }	  
	}
      else
	{
	  check_num   = closure->check_num;

	  if(check_num>CONDITION_DEFINITIONS)
	    {
	      printf("bad index in NETonoff %d\n",check_num);
	    }
	  else if(ErrorLookup[check_num].NETonoff==1)
	    {
	      XtUnmanageChild((Widget) outline);
	      ErrorLookup[check_num].NETonoff = 0;
	      XtVaSetValues(w, XmNlabelPixmap, plus_pix, NULL);
	    }
	  else if(ErrorLookup[check_num].NETonoff==0)
	    {
	      if(ErrorLookup[check_num].scrollwidmadeNET==0)
		{
		  NETBuildSpecificCond((Widget) outline, check_num, -1,-1,1);

		  ErrorLookup[check_num].scrollwidmadeNET = 1;
		}

	      XtManageChild((Widget) outline);

	      ErrorLookup[check_num].NETonoff = 1;
	      XtVaSetValues(w, XmNlabelPixmap, minus_pix, NULL);
	    }
	}
    }
  else
    {
      printf("got bad level %d\n",level);
    }
}
   



int GetNETSelected(int errnum, int clonenum)
{
  
  
  int retval = 0;
  int cloneindex = -1;
  int start,end;
  
  if(clonenum>0)
    {
      cloneindex = GetCloneIndex(clonenum,errnum);
    }
  
  if(
     (ErrorLookup[errnum].numberNets>0) &&
     ((clonenum==-100) || (clonenum==0))
     )
    {
      if(ErrorLookup[errnum].viewallNET==1)
	{
	  retval = retval + ErrorLookup[errnum].numberNets;
	}
      else if(ErrorLookup[errnum].viewsomeNET==1)
	{
	  retval = retval + ErrorLookup[errnum].NETpos_list_made;
	}
    }
  
  
  if(cloneindex>=0)
    {
      start = cloneindex;
      end   = cloneindex + 1;
    }
  else
    {
      start = 0;
      end   = CLONE_DEFINITIONS;
    }
  

  for(cloneindex=start;cloneindex<end;cloneindex++)
    {	
      if(
	 (CloneErrorLookup[cloneindex].numberNets>0) &&
	 (CloneErrorLookup[cloneindex].CloneNumber==errnum)
	 )
	{
	  if(CloneErrorLookup[cloneindex].viewallNET==1)
	    {
	      retval = retval + CloneErrorLookup[cloneindex].numberNets;
	    }
	  else if(CloneErrorLookup[cloneindex].viewsomeNET==1)
	    {
	      retval = retval + CloneErrorLookup[cloneindex].NETpos_list_made;
	    }
	}
    }
  return retval;
}



int AnyCloneNets(int errnum)
{
  int i;

  

  for(i=0;i<CLONE_DEFINITIONS;i++)
  {
    if(CloneErrorLookup[i].numberNets>0)
	{
	  if(CloneErrorLookup[i].CloneNumber==errnum)
	  {
        return 1;
	  }
	}
  } 
  return 0;
}


void NETGetTotals(int groupnum,int *totalchecks, int *totalconds, int *totalselected)
{
  int numnets=0;
  int errnum;

  

  
  *totalchecks   = 0;
  *totalselected = 0;
  
  for(errnum=1;errnum<=CONDITION_DEFINITIONS;errnum++)
    {
		  
      if(
	 (ErrorLookup[errnum].mygroup==groupnum) &&
	 ((ErrorLookup[errnum].numberNets>0) || (AnyCloneNets(errnum)>0) )
	 )
	{
	  numnets = GetNetworkCount(0,errnum,-1);  
	  *totalchecks = *totalchecks + numnets;

	  if(numnets>0)
	    {
	      *totalconds    = *totalconds    + GetNetworkCount(3,errnum,-1);    
	      *totalselected = *totalselected + GetNETSelected(errnum,-100);
	    }
	}
    }  
}



void NETGetTotal(int errnum, int *totalconds, int *totalchecks, int *totalhighlighted)
{
  int numnets;
  


  *totalconds       = 0;
  *totalchecks      = 0;
  *totalhighlighted = 0;

  
  numnets = GetNetworkCount(0,errnum,-1);
  *totalchecks = numnets;
  
  if(numnets>0)
    {
      *totalconds = GetNetworkCount(3,errnum,-1);
      *totalhighlighted = GetNETSelected(errnum,-100);
    }
  
}












void toggle_view_some_NET(Widget widget,MyData *mydata,XtPointer call_data)
{
  int errnum     = mydata->check_num;
  int cloneINDEX = mydata->clonenum;
  
  if(cloneINDEX==-1)
    {
      if(ErrorLookup[errnum].viewsomeNET==0)
	{
	  ErrorLookup[errnum].viewsomeNET = 1;

	  if(ErrorLookup[errnum].viewallNET==1)
	    {
	      XmToggleButtonSetState(ErrorLookup[errnum].viewallwidNET,0,(Boolean)0);
	      ErrorLookup[errnum].viewallNET = 0;
	    }
	}
      else
	{
	  ErrorLookup[errnum].viewsomeNET = 0;
	}
    }
  else
    {
      if(CloneErrorLookup[cloneINDEX].viewsomeNET==0)
	{
	  CloneErrorLookup[cloneINDEX].viewsomeNET = 1;
	  
	  if(CloneErrorLookup[cloneINDEX].viewallNET==1)
	    {
	      XmToggleButtonSetState(CloneErrorLookup[cloneINDEX].viewallwidNET,0,(Boolean)0);
	      CloneErrorLookup[cloneINDEX].viewallNET = 0;
	    }
	}
      else
	{
	  CloneErrorLookup[cloneINDEX].viewsomeNET = 0;
	}
    }
  UpdateAllTotals();
}



void toggle_view_all_NET(Widget widget,MyData *mydata,XtPointer call_data)
{
  int errnum     = mydata->check_num;
  int cloneINDEX = mydata->clonenum;


  if(cloneINDEX==-1)
    {
      if(ErrorLookup[errnum].viewallNET==0)
	{
	  ErrorLookup[errnum].viewallNET = 1;

	  if(ErrorLookup[errnum].viewsomeNET==1)
	    {
	      XmToggleButtonSetState(ErrorLookup[errnum].viewsomewidNET,0,(Boolean)0);
	      ErrorLookup[errnum].viewsomeNET = 0;
	    }
	}
      else
	{
	  ErrorLookup[errnum].viewallNET = 0;
	} 
    }
  else
    {
      if(CloneErrorLookup[cloneINDEX].viewallNET==0)
	{
	  CloneErrorLookup[cloneINDEX].viewallNET = 1;

	  if(CloneErrorLookup[cloneINDEX].viewsomeNET==1)
	    {
	      XmToggleButtonSetState(CloneErrorLookup[cloneINDEX].viewsomewidNET,0,(Boolean)0);
	      CloneErrorLookup[cloneINDEX].viewsomeNET = 0;
	    }
	}
      else
	{
	  CloneErrorLookup[cloneINDEX].viewallNET = 0;
	}
    }
  UpdateAllTotals();
}







void select_all_error_NET(Widget w,XtPointer data,XtPointer callData)
{ 
  int type=(int)data;
  int i;

  



  for(i=1;i<=CONDITION_DEFINITIONS;i++)
    {
      if(ErrorLookup[i].numberNets>0)
	{
	  if(type==1)
	    {
	      XmToggleButtonSetState(ErrorLookup[i].viewallwidNET, (Boolean)1,(Boolean)0);
	      XmToggleButtonSetState(ErrorLookup[i].viewsomewidNET,(Boolean)0,(Boolean)0);
	    }
	  else
	    {
	      XmToggleButtonSetState(ErrorLookup[i].viewallwidNET, (Boolean)0,(Boolean)0);
	      XmToggleButtonSetState(ErrorLookup[i].viewsomewidNET,(Boolean)0,(Boolean)0);
	    }
	}
    }

  
  for(i=0;i<CLONE_DEFINITIONS;i++)
    {
      if(CloneErrorLookup[i].numberNets>0)
	{
	  if(type==1)
	    {
	      XmToggleButtonSetState(CloneErrorLookup[i].viewallwidNET, (Boolean)1,(Boolean)0);
	      XmToggleButtonSetState(CloneErrorLookup[i].viewsomewidNET,(Boolean)0,(Boolean)0);
	    }
	  else
	    {
	      XmToggleButtonSetState(CloneErrorLookup[i].viewallwidNET, (Boolean)0,(Boolean)0);
	      XmToggleButtonSetState(CloneErrorLookup[i].viewsomewidNET,(Boolean)0,(Boolean)0);
	    }
	}
    }


  


  if(type==1)
    {
      for(i=1;i<=CONDITION_DEFINITIONS;i++)
	{
	  ErrorLookup[i].viewallNET  = 1;
	  ErrorLookup[i].viewsomeNET = 0;
	}
  
      for(i=0;i<CLONE_DEFINITIONS;i++)
	{
	  CloneErrorLookup[i].viewallNET  = 1;
	  CloneErrorLookup[i].viewsomeNET = 0;
	}
    }
  else
    {
      for(i=1;i<=CONDITION_DEFINITIONS;i++)
	{
	  ErrorLookup[i].viewallNET  = 0;
	  ErrorLookup[i].viewsomeNET = 0;
	}
  
      for(i=0;i<CLONE_DEFINITIONS;i++)
	{
	  CloneErrorLookup[i].viewallNET  = 0;
	  CloneErrorLookup[i].viewsomeNET = 0;
	}
    }
  UpdateAllTotals();
}








void toggled8(Widget widget,XtPointer client_data,XtPointer call_data)
{
  if(CenterZoomOnVertices==0)
    {
      CenterZoomOnVertices = 1;
    }
  else 
    {
      CenterZoomOnVertices = 0;
    }
}


void Help_errCallback_NET(Widget w,XtPointer data,XtPointer callData)
{
  not_while_running(w,
"This window is used to highlight networks.\n\
The networks to highlight/describe are selected/deselected\n\
from the list of networks shown by clicking on them.  It is\n\
possible to view all or some of any networks by clicking the\n\
\"Highlight All\" and \"Highlight Selected\" buttons associated with them.\n\n\
All networks that are selected will be drawn red when the\n\
screen is refreshed by zooming or any other refreshes.",1409,"Network Viewing Help",5);
}





void myResizeWidthHandler3(Widget w, XtPointer userData, XEvent *event, Boolean *continue_to_dispatch)
{
  
  if(event->type == ConfigureNotify)  
    {
      XConfigureEvent *conf = (XConfigureEvent *)event;
      int new_width = conf->width;
      int errnum,cloneindex;
      
      
      new_width = new_width - 200;
      if(new_width<200)
	{
	  new_width = 200;
	}
      
      for(cloneindex=0;cloneindex<CLONE_DEFINITIONS;cloneindex++)
	{
	  if(CloneErrorLookup[cloneindex].scrollwidmadeNET==1)
	    {
	      if(new_width>CloneErrorLookup[cloneindex].maxscrollsizeNET)
		{
		  XtVaSetValues (CloneErrorLookup[cloneindex].scrollwidNET,
				 XmNwidth, CloneErrorLookup[cloneindex].maxscrollsizeNET,
				 NULL);
		}
	      else
		{
		  XtVaSetValues (CloneErrorLookup[cloneindex].scrollwidNET,XmNwidth, new_width, NULL);
		}
	    }
	}

      for(errnum=1;errnum<=CONDITION_DEFINITIONS;errnum++)
	{
	  if(ErrorLookup[errnum].scrollwidmadeNET==1)
	    {
	      if(new_width>ErrorLookup[errnum].maxscrollsizeNET)
		{
		  XtVaSetValues (ErrorLookup[errnum].scrollwidNET,
				 XmNwidth, ErrorLookup[errnum].maxscrollsizeNET,
				 NULL);
		}
	      else
		{
			  XtVaSetValues (ErrorLookup[errnum].scrollwidNET,XmNwidth, new_width, NULL);
		}
	    }
	}
    }
}




void net_toggled6(Widget widget,XtPointer client_data,XtPointer call_data)
{
  if(CenterZoomOnNets==0)
    {
      CenterZoomOnNets = 1;
    }
  else 
    {
      CenterZoomOnNets = 0;
    }
}


void help_npad_callback(Widget w,XtPointer data,XtPointer callData)
{
  not_while_running(XtParent(w),"This window is used to set the amount of \"padding\" distance\n\
to be used when zooming the screen to individual networks.\n\
When the screen is zoomed to individual networks, the network\n\
will be shown on the screen with at least this amount of distance,\n\
in meters, added on all sides of it.",1612,"Network Padding Distance Help",5);
}



void kill_npad_callback(Widget button, XtPointer client_data, XtPointer call_data)
{
  extern int bad_los_result;

  los_result(net_zoom_pad_w,(XtPointer)12,(XtPointer)NULL);

  if(bad_los_result==1)
    {
      not_while_running(button,"The pad distance entered was invalid. It has been reset\nto the last valid value (valid range: 1-5000)",
			1613,"Invalid Network Pad Distance",1);
      return;
    }

  XtDestroyWidget(XtParent(XtParent(XtParent(button))));
}





void set_npad_distance(Widget w,XtPointer data,XtPointer callData)
{ 

  int n=0;
  static Widget npad_head;
  Widget rowcol,form,exitbutton,sep;
  Arg resources[20];
  char temp[500];
  Dimension Pheight;

  if(NPAD_UP==0)
    {
      XtSetArg(resources[n],  XmNdeleteResponse, XmDESTROY); n++; 
      XtSetArg(resources[n],  XmNmaxWidth,       800);          n++;  

      npad_head = XtCreatePopupShell
	("Individual Network Zoom Pad Distance",
	 topLevelShellWidgetClass,XtParent(XtParent(XtParent(w))),resources,n);
      
      rowcol = XtVaCreateWidget ("rowcol",
				 xmRowColumnWidgetClass, npad_head, NULL);
      

      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,  
			       NULL);
      
      
      XtVaCreateManagedWidget ("",
			       xmLabelWidgetClass, form,
			       XmNtopAttachment,    XmATTACH_FORM,
			       XmNbottomAttachment, XmATTACH_FORM,
			       XmNrightAttachment,  XmATTACH_POSITION,
			       XmNrightPosition,  100,
			       XmNleftAttachment,  XmATTACH_POSITION,
			       XmNleftPosition,     0,
			       XmNalignment,        XmALIGNMENT_CENTER,
			       XmNlabelString, STRING("Pad Distance:"),
			       LABELWTRANSLATE,
			       NULL);
      XtManageChild(form);
      


      
      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,  
			       NULL);
      
      sprintf(temp,"%lf",NPAD_DIST);

      net_zoom_pad_w = XtVaCreateManagedWidget ("text_w",
					    xmTextFieldWidgetClass, form,	  
					    XmNvalue,           temp,
					    XmNtraversalOn,     True,
					    XmNrightAttachment, XmATTACH_POSITION,
					    XmNrightPosition,   80,
					    XmNleftAttachment,  XmATTACH_POSITION,
					    XmNleftPosition,    0,
					    XmNmaxLength,       15,
                        XmNtranslations,    XtParseTranslationTable ( translations_paste ) ,
					    NULL);

      XtAddCallback (net_zoom_pad_w, XmNactivateCallback,
		     los_result, (XtPointer)12);


      
      XtManageChild(form);
      

      sep = XtVaCreateManagedWidget ("sep1",
				     xmSeparatorWidgetClass, rowcol,
				     NULL);
      
      
      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,
			       NULL);
      exitbutton = XtVaCreateManagedWidget("Help", xmPushButtonWidgetClass, form,
					   XmNlabelString, STRING("Help"),
					   XmNleftAttachment,   XmATTACH_POSITION,
					   XmNleftPosition,     30,
					   XmNrightAttachment,   XmATTACH_POSITION,
					   XmNrightPosition,     50,
					   XmNtraversalOn,  False,
					   XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					   NULL);
      XtAddCallback(exitbutton, XmNactivateCallback, help_npad_callback, (XtPointer)NULL);
      XtManageChild(exitbutton);
      
      n = 0;  
      exitbutton = XtVaCreateManagedWidget("Exit",xmPushButtonWidgetClass, form,
					   XmNlabelString,      STRING("Done"),
					   XmNleftAttachment,   XmATTACH_POSITION,
					   XmNleftPosition,     50,
					   XmNrightAttachment,  XmATTACH_POSITION,
					   XmNrightPosition,    70,
					   XmNtraversalOn,      False,
					   XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					   NULL);

      XtAddCallback(exitbutton, XmNactivateCallback, kill_npad_callback, (XtPointer)NULL);
      XtManageChild(exitbutton);

      XtManageChild(form);
      XtManageChild (rowcol);
      
      XtAddCallback(npad_head,XmNdestroyCallback,(XtCallbackProc)ShellDeath,(XtPointer)4101);       
      MyPopup(npad_head); 
      NPAD_UP = 1;

      XtVaGetValues(npad_head,  XmNheight,     &Pheight, NULL);
      XtVaSetValues(npad_head,  XmNminHeight,   Pheight, NULL);
      XtVaSetValues(npad_head,  XmNmaxHeight,   Pheight, NULL);

      XtAddEventHandler(npad_head,StructureNotifyMask,False, myResizeHandler, (XtPointer)((int)Pheight));
    }
  else
    {
      ResetWidget(npad_head);
    }
}


void net_route_cb(Widget menu_item,XtPointer client_data,XtPointer call_data)
{
  int item_no = (int) client_data;

  NetRouteType = item_no;
}


Widget BuildNetRouteMenu(Widget parent,int menu_type,char *menu_title,MenuItem *items)
{
  Widget menu, cascade, widget;
  int i,n=0;
  XmString str;
  Arg args[5];
  
  menu = XmCreatePulldownMenu (parent, "_pulldown", NULL, 0);
  
  str = XmStringCreateLocalized (menu_title);
  XtSetArg (args[n], XmNsubMenuId, menu);  n++;
  XtSetArg (args[n], XmNlabelString, str); n++;
  XtSetArg (args[n], XmNtranslations, XtParseTranslationTable ( translations_global )); n++;

  cascade = XmCreateOptionMenu (parent, menu_title, args, n);
  XmStringFree (str);
  
  for (i = 0; items[i].label != NULL; i++) 
    {
      widget = XtVaCreateManagedWidget (items[i].label,
					*items[i].cclass, menu,
					NULL);
      
	  if(
		  ((i==0)&&(NetRouteType==0))   ||
		  ((i==1)&&(NetRouteType==2))   ||
		  ((i==2)&&(NetRouteType==1))
		)
	{
	  XtVaSetValues(cascade,				
			XmNmenuHistory, widget,
			NULL);
	}

      if (items[i].callback)
	XtAddCallback (widget,
		       (items[i].cclass == &xmToggleButtonWidgetClass ||
			items[i].cclass == &xmToggleButtonWidgetClass) ?
		       XmNvalueChangedCallback : 
		       XmNactivateCallback,      
		       (XtCallbackProc)items[i].callback, items[i].callback_data);
    }
  return menu_type == XmMENU_POPUP ? menu : cascade;
}









void RouteHelpCallback(Widget parent, XtPointer client_data, XtPointer call_data)
{  
   not_while_running(parent,"\
These options control the GAIT network display and route-finding capabilities.\n\n\
\"Draw Network Only\"     : Used to draw networks without routing\n\
\"Draw Route Only\"       : Used to draw route(s) without networks\n\
\"Draw Network and Route\": Used to draw networks and routes on top of them in bold\n\n\
When drawing/computing routes:\n\n\
GAIT attempts to calculate a least-distance route between specific\n\
Start and Goal locations specified **at vertices*** on the network.\n\
Routes can not be planned between area feature external and internal rings.\n\
Route Start and Goal points are designated using \"Points of Interest\":\n\n\
The annotation for the Start and Goal points of interest must have the specific format:\n\
  \"Start Instance I Network N\" and \"Goal Instance I Network N\":\n\
    \"I\": the \"Instantiation Number\" of the network\n\
    \"N\": corresponds to the \"Network #\" for that Instantiation.\n\n\
Example to specify Instance 1, network 63 Start and Goal points:\n\n\
     \"Start Instance 1 Network 63\"\n\
     \"Goal Instance 1 Network 63\"",1634,"Routing Drawing Help",5);
}


void BuildNetworkViewer(Widget parent, XtPointer client_data, XtPointer call_data)
{  
  
  extern int GetSubnetExtents(char * fname, int TgtCnumber, int TgtIndex, 
			      double *MinX, double *MinY, double *MaxX, double *MaxY);


  Arg resources[15];
  int n=0,i=0,j;
  Widget rc,form,Done,sw2,label1,button,setB,network_route_menu;
  char temp[200];
  int totalchecks=0,totalconds=0, totalhighlighted=0;
  XmString str;
  MyData *mydata;
  Widget handle,left,right,rc3,tempwid,
    outline,scrolloutline,checkhandle,junkwid;
  int checknum,cloneindex,clonenum;
  MyData *mydata3, *mydata4;

  MenuItem network_route_type[] = {
    {"Draw Network Only",
     &xmPushButtonWidgetClass,'!', NULL, NULL, (void (*)())net_route_cb, (XtPointer)0, (MenuItem *) NULL},
    {"Draw Route Only",
     &xmPushButtonWidgetClass,'!', NULL, NULL, (void (*)())net_route_cb, (XtPointer)2, (MenuItem *) NULL},
    {"Draw Network and Route",
     &xmPushButtonWidgetClass,'!', NULL, NULL, (void (*)())net_route_cb, (XtPointer)1, (MenuItem *) NULL},
    {NULL},
  };

  int rebuild_win=(int)client_data;



  if(NumNetsLoaded==0)
    {
      printf("Error: 0 networks loaded\n");
      XBell(mydisplay,50);
      return;
    }


  if((rebuild_win==1)&&(dead_network==0))
  {

	
    XtRemoveCallback(networkhead[Current_net_head],XmNdestroyCallback,ShellDeath,(XtPointer)4069);

    XtDestroyWidget(networkhead[Current_net_head]);
    dead_network=1;
    Current_net_head++;
    if(Current_net_head==3){Current_net_head=0;}

  }


  if(dead_network==1)
    {
      n=0;
      XtSetArg(resources[n],  XmNdeleteResponse, XmDESTROY);    n++;
      XtSetArg(resources[n],  XmNminWidth,       250);          n++;
      XtSetArg(resources[n],  XmNminHeight,      300);          n++;

	
      networkhead[Current_net_head] = 
	XtCreatePopupShell("View Networks",
			   topLevelShellWidgetClass,drawing_a,resources,n);
      
      
      rc = XtVaCreateManagedWidget
	(
	 "XformWidget", xmPanedWindowWidgetClass, networkhead[Current_net_head],
	 XmNrubberPositioning, False,
	 XmNresizable,         True,
	 XmNseparatorOn,       False,
	 XmNsashHeight,        1,
	 XmNtranslations,      XtParseTranslationTable (list_translations28),
	 
	 NULL
	 );

      
      form = XtVaCreateWidget ("form.error.editor", xmFormWidgetClass, rc,
			       XmNpaneMinimum,   15,
			       XmNpaneMaximum,   15,
			       XmNfractionBase,  100,  
			       XmNtraversalOn,   False,
			       XmNtranslations,  XtParseTranslationTable (list_translations28),
			       NULL);
   
      
      sprintf(temp,"Number of Networks: %d (from %d Specifications)",
	      GetNetworkCount(1,-1,-1),GetNetworkCount(-1,-1,-1));
      

      label1 = XtVaCreateManagedWidget (temp,
					xmLabelWidgetClass, form,
					XmNrightAttachment, XmATTACH_POSITION,
					XmNrightPosition,   100,
					XmNleftAttachment,  XmATTACH_POSITION,
					XmNleftPosition,    0,
					XmNalignment,       XmALIGNMENT_CENTER,
					XmNtraversalOn,     False,
					XmNtranslations,    XtParseTranslationTable (list_translations28),
					NULL);
      XtManageChild(form);



      form = XtVaCreateWidget ("form.sw.editor", xmFormWidgetClass, rc,
			       XmNfractionBase,  100,  
			       XmNtranslations,  XtParseTranslationTable (list_translations28), 
			       NULL);
      
      sw2 = XtVaCreateManagedWidget ("scrolled_win",
				     xmScrolledWindowWidgetClass, form,
				     XmNwidth,                  700,
				     XmNheight,                 300,
				     XmNscrollingPolicy,        XmAUTOMATIC,
				     XmNscrollBarDisplayPolicy, XmSTATIC,
				     XmNtopAttachment,          XmATTACH_FORM,
				     XmNbottomAttachment,       XmATTACH_FORM,
				     XmNleftAttachment,         XmATTACH_FORM,
				     XmNrightAttachment,        XmATTACH_FORM,
				     XmNtranslations,           XtParseTranslationTable (list_translations28),
				     
				     NULL);
      
      XtManageChild(form);
      

      
      XtVaGetValues(sw2,XmNverticalScrollBar,&vert_scroll[NETWORK_SCROLL],NULL);
      XtVaGetValues(sw2,XmNhorizontalScrollBar,&junkwid,NULL);
      
      XtVaSetValues(vert_scroll[NETWORK_SCROLL], 
		    XmNtraversalOn,  False, 
		    
		    NULL);
      
      XtVaSetValues(junkwid,                       XmNtraversalOn, False, NULL);
      



      
      
      
      handle = XtVaCreateManagedWidget("roothandle", xmHandleWidgetClass,
				       sw2,
				       XmNtranslations, XtParseTranslationTable (list_translations28),
				       NULL);
      
      left = XtVaCreateManagedWidget("left", xmPushButtonWidgetClass,
				     handle,
				     XmNlabelType,    XmPIXMAP,
				     XmNlabelPixmap,  minus_pix,					 
				     XmNtraversalOn,  False,
				     XmNtranslations, XtParseTranslationTable (list_translations28),
				     NULL);
      
      right = XtVaCreateManagedWidget("All Computed Networks", xmLabelWidgetClass,
				      handle,
				      LABELWTRANSLATE,
				      NULL);
      
      totalchecks      = 0;
      totalconds       = 0;
      totalhighlighted = 0;



      NETGetGlobalTotals(&totalchecks,&totalconds,&totalhighlighted);


      if(totalchecks==1)
	{
	  sprintf(temp," (%d instance, %d networks, %d highlighted)",
		  totalchecks,totalconds,totalhighlighted);
	}
      else
	{
	  sprintf(temp," (%d instances, %d networks, %d highlighted)",
		  totalchecks,totalconds,totalhighlighted);
	}
      
      NETGlobalTotals = XtVaCreateManagedWidget(temp, xmLabelWidgetClass,
						handle,
						XmNtraversalOn,   False,
						XmNtranslations,  XtParseTranslationTable (list_translations28),
						NULL);
      
      outline = XtVaCreateManagedWidget("outline", xmOutlineWidgetClass,
					handle,
					XmNindentation,  20,
					XmNoutline,      TRUE,
					XmNtranslations, XtParseTranslationTable (list_translations28),
					
					NULL);
      
      
      mydata3  = (MyData *) (malloc(sizeof(MyData)));
      if(mydata3==NULL){printf("myb: out of allocation memory!\n"); ExitWrapper(-1);}
      mydata3->outlinewid = (XmOutlineWidget)outline;
      mydata3->level = 1;
      
      XtAddCallback(left, 
		    XmNactivateCallback, (XtCallbackProc)NETToggleButtonHandleCB, 
		    (XtPointer) mydata3);
      
      XtVaSetValues(handle, 
		    XmNsubWidget, outline,
		    NULL);
      
      
      if(NETOnOff1==0)
	{
	  
	  XtUnmanageChild(outline);
	  XtVaSetValues(left, XmNlabelPixmap, plus_pix, NULL);
	}
      
     



	
	      
	      
	for(checknum=1;checknum<=CONDITION_DEFINITIONS;checknum++)
	{
	    if(IsNetCheck(checknum)==0)
		{ 
		   continue;
		}
		    
		totalconds       = 0;
		totalchecks      = 0;
		totalhighlighted = 0;

		NETGetTotal(checknum, &totalconds, &totalchecks,&totalhighlighted);  
		  
		if(totalconds==0)
		{
		   
		    continue;
		}
		  

		
		  
		if(ErrorLookup[checknum].numberNets>0)
		{      
		   checkhandle = XtVaCreateManagedWidget("subhandle",
							    xmHandleWidgetClass,
							    outline,   
							    XmNtranslations, XtParseTranslationTable (list_translations28),
							    
							    NULL);
		         
		   sprintf(temp,"%s (%d) (Instantiation 1)\n(%s)",
			      ParseErrType(checknum),ErrorLookup[checknum].numberNets,
			      GetNetAnnotation(checknum,0));

		      
		      
		   str = XmStringCreateLtoR (temp, "mytag1");
		      
		      
		   mydata  = (MyData *) (malloc(sizeof(MyData)));
		   if(mydata==NULL){printf("myb: out of allocation memory!\n"); ExitWrapper(-1);}
		      
		   mydata->check_num = checknum;
		   mydata->clonenum  = -1;
		      

		   rc3 = XtVaCreateWidget ("rowcol",xmRowColumnWidgetClass, checkhandle, 
				  XmNtranslations, XtParseTranslationTable (list_translations28),
				  NULL);
		      
		      
		   form = XtVaCreateWidget ("form.error.editor", xmFormWidgetClass, rc3,
					       XmNfractionBase,  100,  
						   XmNtranslations,  XtParseTranslationTable (list_translations28),
					       NULL);
		      
		      
		   left = XtVaCreateManagedWidget("left", xmPushButtonWidgetClass,
						     form,
						     XmNlabelType,       XmPIXMAP,
						     XmNlabelPixmap,     minus_pix,
						     XmNarrowDirection,  XmARROW_DOWN,
						     XmNshadowThickness, 0,
						     XmNtraversalOn,     False,
							 XmNtranslations,    XtParseTranslationTable (list_translations28),
						     NULL);
		      
		      tempwid = 
			XtVaCreateManagedWidget ("the_test",
						 xmLabelWidgetClass, form,
						 XmNtopAttachment,    XmATTACH_FORM,
						 XmNtraversalOn,      True,
						 XmNbottomAttachment, XmATTACH_FORM,
						 XmNleftAttachment,   XmATTACH_POSITION,
						 XmNleftPosition,     4,
						 XmNrightAttachment,  XmATTACH_POSITION,
						 XmNrightPosition,    100,
						 XmNlabelString,      str,
						 XmNalignment,        XmALIGNMENT_BEGINNING,
						 XmNtranslations,     XtParseTranslationTable (list_translations28),
						 XmNtraversalOn,      False,
						 NULL);
		      
		      XtManageChild(form);
		      
		      
		      form = XtVaCreateWidget ("form.error.editor", xmFormWidgetClass, rc3,
					       XmNfractionBase,  100,  
					       XmNtranslations,  XtParseTranslationTable (list_translations28),
					       NULL);
		      
		      ErrorLookup[checknum].viewallwidNET = 
			XtVaCreateManagedWidget ("the_test",
						 xmToggleButtonWidgetClass, form,
						 XmNtopAttachment,    XmATTACH_FORM,
						 XmNtraversalOn,      True,
						 XmNbottomAttachment, XmATTACH_FORM,
						 XmNleftAttachment,   XmATTACH_POSITION,
						 XmNleftPosition,     5,
						 XmNlabelString,      STRING("Highlight All"),
						 XmNalignment,        XmALIGNMENT_BEGINNING,
						 XmNtranslations,     
						 XtParseTranslationTable (list_translations28),
						 XmNtraversalOn,      False,
						 TOGGLEINCLUDE,
						 NULL);
		      
		      ErrorLookup[checknum].viewsomewidNET = 
			XtVaCreateManagedWidget ("the_test",
						 xmToggleButtonWidgetClass, form,
						 XmNtopAttachment,    XmATTACH_FORM,
						 XmNtraversalOn,      True,
						 XmNbottomAttachment, XmATTACH_FORM,
						 XmNleftAttachment,   XmATTACH_WIDGET,
						 XmNleftWidget,       ErrorLookup[checknum].viewallwidNET,
						 XmNlabelString,      STRING("Highlight Selected"),
						 XmNalignment,        XmALIGNMENT_BEGINNING,
						 XmNtranslations,     
						 XtParseTranslationTable (list_translations28),
						 XmNtraversalOn,      False,
						 TOGGLEINCLUDE,
						 NULL);


		      XtManageChild(form);
		      XtManageChild(rc3);
		      





		      
		      XtAddCallback (ErrorLookup[checknum].viewsomewidNET, 
				     XmNvalueChangedCallback, (XtCallbackProc)toggle_view_some_NET,  mydata);
		      
		      XtAddCallback (ErrorLookup[checknum].viewallwidNET, 
				     XmNvalueChangedCallback, (XtCallbackProc)toggle_view_all_NET, mydata);
		      
		      XmToggleButtonSetState(ErrorLookup[checknum].viewsomewidNET,
					     (Boolean)ErrorLookup[checknum].viewsomeNET,
					     (Boolean)0);
		      XmToggleButtonSetState(ErrorLookup[checknum].viewallwidNET,
					     (Boolean)ErrorLookup[checknum].viewallNET,
					     (Boolean)0);





		      
		      XmStringFree (str);
		      
		      
		      
		      
		      
		      scrolloutline = XtVaCreateManagedWidget("subsuboutline",
							      xmOutlineWidgetClass,
							      checkhandle, 
							      XmNindentation,  20, 
							      XmNoutline,      TRUE,
								  XmNtranslations, XtParseTranslationTable (list_translations28),
							      
							      NULL);
		      
		      
		      mydata4  = (MyData *) (malloc(sizeof(MyData)));
		      if(mydata4==NULL){printf("myb: out of allocation memory!\n"); ExitWrapper(-1);}
		      mydata4->outlinewid = (XmOutlineWidget)scrolloutline;
		      mydata4->level     = 4;
		      mydata4->group_num = i;
		      mydata4->check_num = checknum;
		      mydata4->clonenum  = -1;
		      
		      XtAddCallback(left, 
				    XmNactivateCallback, (XtCallbackProc)NETToggleButtonHandleCB, 
				    (XtPointer) mydata4);
		      
		      
		      if(ErrorLookup[checknum].NETonoff==0)
			{
			  


			  XtUnmanageChild(scrolloutline);
			  XtVaSetValues(left, XmNlabelPixmap, plus_pix, NULL);
			}
		      else
			{
			  

			  
			  NETBuildSpecificCond(scrolloutline, checknum, -1, 500,0);


			  ErrorLookup[checknum].scrollwidmadeNET = 1;
			}
		      
		      XtVaSetValues(checkhandle, 
				    XmNsubWidget, scrolloutline, 
				    NULL);
		      
		    }

		  
		  
		  
		  
		  for(j=0;j<ErrorLookup[checknum].num_clones;j++)
		    {
		      cloneindex = GetCloneIndex(j+1,checknum);
		      
		      if(CloneErrorLookup[cloneindex].numberNets>0)
			{
			  
			  checkhandle = XtVaCreateManagedWidget("subhandle",
								xmHandleWidgetClass,
								outline,
								XmNtranslations, XtParseTranslationTable (list_translations28),
								
								NULL);


			  
			  sprintf(temp,"%s (%d) (Instantiation %d)\n(%s)",
				  ParseErrType(checknum),CloneErrorLookup[cloneindex].numberNets,j+2,
				  GetNetAnnotation(checknum,j+1));
			  
			  
			  str = XmStringCreateLtoR (temp, "mytag1");
			  
			  
			  mydata  = (MyData *) (malloc(sizeof(MyData)));
			  if(mydata==NULL){printf("myb: out of allocation memory!\n"); ExitWrapper(-1);}
			  
			  mydata->check_num = checknum;
			  mydata->clonenum  = cloneindex;
			  
			  
			  rc3 = XtVaCreateWidget ("rowcol",xmRowColumnWidgetClass, checkhandle, 
				  XmNtranslations, XtParseTranslationTable (list_translations28),
				  NULL);
			  
			  
			  form = XtVaCreateWidget ("form.error.editor", xmFormWidgetClass, rc3,
						   XmNfractionBase,  100,  
						   XmNtranslations,  XtParseTranslationTable (list_translations28),
						   NULL);
			  
			  left = XtVaCreateManagedWidget("left", xmPushButtonWidgetClass,
							 form,
							 XmNlabelType,       XmPIXMAP,
							 XmNlabelPixmap,     minus_pix,
							 XmNarrowDirection,  XmARROW_DOWN,
							 XmNshadowThickness, 0,
							 XmNtraversalOn,     False,
							 XmNtranslations,    XtParseTranslationTable (list_translations28),
							 NULL);
			  
			  tempwid = 
			    XtVaCreateManagedWidget ("the_test",
						     xmLabelWidgetClass, form,
						     XmNtopAttachment,    XmATTACH_FORM,
						     XmNtraversalOn,      True,
						     XmNbottomAttachment, XmATTACH_FORM,
						     XmNleftAttachment,   XmATTACH_POSITION,
						     XmNleftPosition,     4,
						     XmNrightAttachment,  XmATTACH_POSITION,
						     XmNrightPosition,    100,
						     XmNlabelString,      str,
						     XmNalignment,        XmALIGNMENT_BEGINNING,
						     XmNtranslations,     
						     XtParseTranslationTable (list_translations28),
						     XmNtraversalOn,     False,
						     NULL);
			  
			  XtManageChild(form);
			  
			  
			  form = XtVaCreateWidget ("form.error.editor", xmFormWidgetClass, rc3,
						   XmNfractionBase,  100,  
						   XmNtranslations,  XtParseTranslationTable (list_translations28),
						   NULL);
			  
			  CloneErrorLookup[cloneindex].viewallwidNET = 
			    XtVaCreateManagedWidget ("the_test",
						     xmToggleButtonWidgetClass, form,
						     XmNtopAttachment,    XmATTACH_FORM,
						     XmNtraversalOn,      True,
						     XmNbottomAttachment, XmATTACH_FORM,
						     XmNleftAttachment,   XmATTACH_POSITION,
						     XmNleftPosition,     5,
						     XmNlabelString,      STRING("Highlight All"),
						     XmNalignment,        XmALIGNMENT_BEGINNING,
						     XmNtranslations,     
						     XtParseTranslationTable (list_translations28),
						     XmNtraversalOn,      False,
						     TOGGLEINCLUDE,
						     NULL);
			  
			  CloneErrorLookup[cloneindex].viewsomewidNET = 
			    XtVaCreateManagedWidget ("the_test",
						     xmToggleButtonWidgetClass, form,
						     XmNtopAttachment,    XmATTACH_FORM,
						     XmNtraversalOn,      True,
						     XmNbottomAttachment, XmATTACH_FORM,
						     XmNleftAttachment,   XmATTACH_WIDGET,
						     XmNleftWidget,       CloneErrorLookup[cloneindex].viewallwidNET,
						     XmNlabelString,      STRING("Highlight Selected"),
						     XmNalignment,        XmALIGNMENT_BEGINNING,
						     XmNtranslations,     
						     XtParseTranslationTable (list_translations28),
						     XmNtraversalOn,      False,
						     TOGGLEINCLUDE,
						     NULL);



			  XtManageChild(form);
			  XtManageChild(rc3);
			  



			  
			  XtAddCallback (CloneErrorLookup[cloneindex].viewsomewidNET, 
					 XmNvalueChangedCallback, (XtCallbackProc)toggle_view_some_NET,  mydata);
			  
			  XtAddCallback (CloneErrorLookup[cloneindex].viewallwidNET, 
					 XmNvalueChangedCallback, (XtCallbackProc)toggle_view_all_NET, mydata);
			  
			  XmToggleButtonSetState(CloneErrorLookup[cloneindex].viewsomewidNET,
						 (Boolean)CloneErrorLookup[cloneindex].viewsomeNET,
						 (Boolean)0);
			  XmToggleButtonSetState(CloneErrorLookup[cloneindex].viewallwidNET,
						 (Boolean)CloneErrorLookup[cloneindex].viewallNET,
						 (Boolean)0);
			  
			  XmStringFree (str);


			  
			  
			  
			  
			  scrolloutline = XtVaCreateManagedWidget("subsuboutline",
								  xmOutlineWidgetClass,
								  checkhandle, 
								  XmNindentation,  20, 
								  XmNoutline,      TRUE,
								  XmNtranslations, XtParseTranslationTable (list_translations28),
								  
								  NULL);
			  
			  
			  mydata4  = (MyData *) (malloc(sizeof(MyData)));
			  if(mydata4==NULL){printf("myb: out of allocation memory!\n"); ExitWrapper(-1);}
			  mydata4->outlinewid = (XmOutlineWidget)scrolloutline;
			  mydata4->level     = 4;
			  mydata4->group_num = i;
			  mydata4->check_num = checknum;
			  mydata4->clonenum  = j+1;
			  
			  XtAddCallback(left, 
					XmNactivateCallback, (XtCallbackProc)NETToggleButtonHandleCB, 
					(XtPointer) mydata4);
			  
			  
			  if(CloneErrorLookup[cloneindex].NETonoff==0)
			    {
			      
			      XtUnmanageChild(scrolloutline);
			      XtVaSetValues(left, XmNlabelPixmap, plus_pix, NULL);
			    }
			  else
			    {
			      
			      			      
			      clonenum = GetCloneNumber(cloneindex,checknum);
			      
			      NETBuildSpecificCond(scrolloutline, checknum, clonenum, 500,0);
			      
			      CloneErrorLookup[cloneindex].scrollwidmadeNET = 1;
			    }
			  
			  
			  XtVaSetValues(checkhandle, 
					XmNsubWidget, scrolloutline, 
					NULL);
			  
			}
		    }
		}
	    

      
      
      
      
      



      




      form = XtVaCreateWidget ("form2", xmFormWidgetClass, rc,
			       XmNpaneMinimum,   25,
			       XmNpaneMaximum,   25,
			       XmNfractionBase,  100,  
			       NULL);

      net_zoom_b = XtVaCreateManagedWidget ("Center Zoom on Individual Networks",
					 xmToggleButtonWidgetClass, form,
					 XmNtraversalOn,      False,
					 XmNleftAttachment,   XmATTACH_FORM,
					 XmNrightAttachment,  XmATTACH_POSITION,
					 XmNrightPosition,    50,
					 XmNlabelString,      STRING("Zoom to individual networks"),
					 XmNtraversalOn,      False,
					 TOGGLETRANSLATE,     TOGGLEINCLUDE,
					 NULL);
      
      XtAddCallback (net_zoom_b, XmNvalueChangedCallback, net_toggled6, NULL);
      XtManageChild(net_zoom_b);

      XmToggleButtonSetState(net_zoom_b,(Boolean)CenterZoomOnNets,(Boolean)0);


      setB  = XtVaCreateManagedWidget("Set Zoom Pad Distance",xmPushButtonWidgetClass,form,
				      XmNleftAttachment,  XmATTACH_POSITION,
				      XmNleftPosition,    50,
				      XmNrightAttachment, XmATTACH_POSITION,
				      XmNrightPosition,   100,
				      XmNlabelString,     STRING("Set Zoom Pad Distance..."),
				      XmNtraversalOn,     False,
				      XmNtranslations, XtParseTranslationTable ( translations_global ) ,
				      NULL
				      ); 
      
      XtAddCallback (setB, XmNactivateCallback,
		     set_npad_distance, (XtPointer)NULL);

      XtManageChild(setB);
      XtManageChild(form);







    form = XtVaCreateWidget ("form", xmFormWidgetClass, rc,
			       XmNpaneMinimum,   35,
			       XmNpaneMaximum,   35,
			       XmNfractionBase,  100,
				   XmNtraversalOn,                 False,
			       NULL);


      button = XtVaCreateManagedWidget ("Help",xmPushButtonWidgetClass,form,
		            XmNtopAttachment,          XmATTACH_FORM,
		            XmNbottomAttachment,       XmATTACH_FORM,
					XmNlabelString,        STRING("Help"),
					XmNtraversalOn,                 False,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					NULL);
      XtAddCallback(button, XmNactivateCallback, RouteHelpCallback, (XtPointer)NULL);
      XtManageChild(button);


    network_route_menu = BuildNetRouteMenu (form, XmMENU_OPTION, "Network route drawing",network_route_type);

    XtVaSetValues(network_route_menu,
		             XmNtopAttachment,          XmATTACH_FORM,
	  	             XmNbottomAttachment,       XmATTACH_FORM,
					 XmNleftAttachment,         XmATTACH_WIDGET,
					 XmNleftWidget,             button,
		             NULL);

    XtManageChild (network_route_menu);
    XtManageChild(form);








      form = XtVaCreateWidget ("form2", xmFormWidgetClass, rc,
			       XmNpaneMinimum,   25,
			       XmNpaneMaximum,   25,
			       XmNfractionBase,  100,  
			       XmNtraversalOn,   False,
			       NULL);
      
      button  = XtVaCreateManagedWidget("s_all_error",xmPushButtonWidgetClass,form,
					XmNleftAttachment,  XmATTACH_POSITION,
					XmNleftPosition,    0,
					XmNrightAttachment, XmATTACH_POSITION,
					XmNrightPosition,   33,
					XmNlabelString,     STRING("Select All"),
					XmNtraversalOn,     False,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					NULL
					); 
      
      XtAddCallback(button, XmNactivateCallback,
		    select_all_error_NET, (XtPointer) 1);
      XtManageChild(button);
      
      button  = XtVaCreateManagedWidget("s_all_error",xmPushButtonWidgetClass,form,
					XmNleftAttachment,  XmATTACH_POSITION,
					XmNleftPosition,    33,
					XmNrightAttachment, XmATTACH_POSITION,
					XmNrightPosition,   66,
					XmNlabelString, STRING("De-Select All"),
					XmNtraversalOn,     False,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					NULL
					); 
      
      XtAddCallback(button, XmNactivateCallback,
		    select_all_error_NET, (XtPointer) 0);
      XtManageChild(button);
      


      Done  = XtVaCreateManagedWidget("Help5",xmPushButtonWidgetClass,form,
				      XmNleftAttachment,  XmATTACH_POSITION,
				      XmNleftPosition,    66,
				      XmNrightAttachment, XmATTACH_POSITION,
				      XmNrightPosition,   100,
				      XmNlabelString, STRING("Help"),
				      XmNtraversalOn,     False,
				      XmNtranslations, XtParseTranslationTable ( translations_global ) ,
				      NULL
				      ); 
      XtAddCallback(Done, XmNactivateCallback,
		    Help_errCallback_NET, (XtPointer) NULL);
      XtManageChild(Done);
      

      XtManageChild(form);







      form = XtVaCreateWidget ("form2", xmFormWidgetClass, rc,
			       XmNpaneMinimum,   25,
			       XmNpaneMaximum,   25,
			       XmNfractionBase,  100,  
			       XmNtraversalOn,   False,
			       NULL);

      
      Done  = XtVaCreateManagedWidget("Help5",xmPushButtonWidgetClass,form,
				      XmNleftAttachment,  XmATTACH_POSITION,
				      XmNleftPosition,    0,
				      XmNrightAttachment, XmATTACH_POSITION,
				      XmNrightPosition,   50,
				      XmNlabelString, STRING("Apply Changes/Refresh View"),
				      XmNtraversalOn,     False,
				      XmNtranslations, XtParseTranslationTable ( translations_global ) ,
				      NULL
				      ); 
      XtAddCallback(Done, XmNactivateCallback,
		    refreshCallback, (XtPointer) NULL);
      XtManageChild(Done);



      Done  = XtVaCreateManagedWidget("Done7",xmPushButtonWidgetClass,form,
				      XmNleftAttachment,  XmATTACH_POSITION,
				      XmNleftPosition,    50,
				      XmNrightAttachment, XmATTACH_POSITION,
				      XmNrightPosition,   100,
				      XmNlabelString, STRING("Done"),
				      XmNtraversalOn,     False,
				      XmNtranslations, XtParseTranslationTable ( translations_global ) ,
				      NULL
				      ); 
      
      XtAddCallback(Done, XmNactivateCallback,
		    die_callback, (XtPointer) 1017);
      XtManageChild(Done);
      XtManageChild(form);
      XtManageChild(rc);
      MyPopup(networkhead[Current_net_head]); 
      XtAddCallback(networkhead[Current_net_head],
		    XmNdestroyCallback,ShellDeath,(XtPointer)4069);


      XtAddEventHandler(networkhead[Current_net_head],StructureNotifyMask,False, 
			myResizeWidthHandler3,NULL);



      

      XtVaSetValues(vert_scroll[NETWORK_SCROLL],XmNincrement,30,NULL);
      dead_network=0;
    }
  else
    {
      ResetWidget(networkhead[Current_net_head]);
    }

}







void BuildSACArray()
{
  int i,j,k,changeattr=0,save_attr_type,totallen,secondlen;
  char *secondpart;
  char *tempdefn,*result1;
  



  
  
  result1  = (char *)malloc(SAC_MAX);
  if(result1==NULL)
  {
    printf("BSAR: out of memory\n");
	exit(-1);
  }

  tempdefn = (char *)malloc(SAC_MAX);
  if(tempdefn==NULL)
  {
    printf("BSAR2: out of memory\n");
	exit(-1);
  }

  
  if(SACARRAY!=NULL)
    {
      for(i=1;i<SACARRAY_INDICES;i++)
	{
	  free(SACARRAY[i].sac);
	  free(SACARRAY[i].sacname);
	  free(SACARRAY[i].lowdesc);
	  free(SACARRAY[i].desc);      
	  if(SACARRAY[i].lowenumlab!=NULL)
	    {
	      free(SACARRAY[i].lowenumlab);
	    }
	  if(SACARRAY[i].lowenumdef!=NULL)
	    {
	      free(SACARRAY[i].lowenumdef);
	    }
	  if(SACARRAY[i].enums!=NULL)
	    {
	      free(SACARRAY[i].enums);
	    }
	}
      free(SACARRAY);
      SACARRAY = NULL;
    }




  
  if(ATTRIBUTION_TYPE!=ATTRIBUTION_INFO_TYPE)
    {
      changeattr = 1;
      save_attr_type = ATTRIBUTION_TYPE;
      ATTRIBUTION_TYPE = ATTRIBUTION_INFO_TYPE;
      InitializeAttribution();
    }
  





  SACARRAY = (struct SACarray *) (malloc(sizeof(struct SACarray) * INsac_loop));
  SACARRAY_INDICES = INsac_loop;

  if(SACARRAY==NULL)
    {
      printf("alloc SACARRAY: out of memory!\n");
      ExitWrapper(-1);
    }

  for(k=1;k<INsac_loop;k++)
    {  

      sprintf(tempdefn,"%s",GetEACLabel(k));
      
      SACARRAY[k].sacname =    (char *) (malloc(strlen(tempdefn)+50));
      if(SACARRAY[k].sacname==NULL)
	{
	  printf("alloc SACARRAY[k].sacname: out of memory!\n");
	  ExitWrapper(-1);
	}
      
      SACARRAY[k].sac =    (char *) (malloc(strlen(tempdefn)+50));
      if(SACARRAY[k].sac==NULL)
	{
	  printf("alloc SACARRAY[k].sac: out of memory!\n");
	  ExitWrapper(-1);
	}
      
      sprintf(SACARRAY[k].sacname,"%s",tempdefn);
      sprintf(SACARRAY[k].sac,    "%s",tempdefn);
      

      sprintf(tempdefn,"%s",GetEACDefinition(k));

      

      secondpart = strstr(tempdefn,".Unit of Measure");

      if(secondpart!=NULL)
	  {
        totallen  = strlen(tempdefn);
        secondlen = strlen(secondpart);

        sprintf(result1,"%s",tempdefn);

        result1[totallen-secondlen+1] = '\0';

        strcat(result1,"\n\n");

        strcat(result1,&secondpart[1]);

		sprintf(tempdefn,"%s",result1);

	  }











      SACARRAY[k].desc =    (char *) (malloc(strlen(tempdefn)+50));
      if(SACARRAY[k].desc==NULL)
	{
	  printf("alloc SACARRAY[k].desc: out of memory!\n");
	  ExitWrapper(-1);
	}
      
      SACARRAY[k].lowdesc =    (char *) (malloc(strlen(tempdefn)+50));
      if(SACARRAY[k].lowdesc==NULL)
	{
	  printf("alloc SACARRAY[k].lowdesc: out of memory!\n");
	  ExitWrapper(-1);
	}
      
      sprintf(SACARRAY[k].desc,"%s",tempdefn);
      sprintf(SACARRAY[k].lowdesc,    "%s",tempdefn);
      

      
      sprintf(tempdefn,"%s",GetEACEnumDefinition(k));
      if(tempdefn==NULL)
	{
	  SACARRAY[k].enums = NULL;
	}
      else
	{
	  SACARRAY[k].enums =    (char *) (malloc(strlen(tempdefn)+50));
	  if(SACARRAY[k].enums==NULL)
	    {
	      printf("alloc SACARRAY[k].enums: out of memory!\n");
	      ExitWrapper(-1);
	    }
	  
	  sprintf(SACARRAY[k].enums,"%s",tempdefn);
	}


      sprintf(tempdefn,"%s",GetAllEEDef(k));
      if(tempdefn==NULL)
	{
	  SACARRAY[k].lowenumdef = NULL;
	}
      else
	{
	  SACARRAY[k].lowenumdef =    (char *) (malloc(strlen(tempdefn)+50));
	  if(SACARRAY[k].lowenumdef==NULL)
	    {
	      printf("alloc SACARRAY[k].lowenumdef: out of memory!\n");
	      ExitWrapper(-1);
	    }
	  
	  sprintf(SACARRAY[k].lowenumdef,"%s",tempdefn);
	}

      sprintf(tempdefn,"%s",GetAllEELab(k));
      if(tempdefn==NULL)
	{
	  SACARRAY[k].lowenumlab = NULL;
	}
      else
	{
	  SACARRAY[k].lowenumlab =    (char *) (malloc(strlen(tempdefn)+50));
	  if(SACARRAY[k].lowenumlab==NULL)
	    {
	      printf("alloc SACARRAY[k].lowenumlab: out of memory!\n");
	      ExitWrapper(-1);
	    }
	  
	  sprintf(SACARRAY[k].lowenumlab,"%s",tempdefn);
	}


      i = strlen(SACARRAY[k].lowenumlab);
      for(j=0;j<i;j++)
	{
	  if((SACARRAY[k].lowenumlab[j]<=90)&&(SACARRAY[k].lowenumlab[j]>=65))
	    {
	      
	      SACARRAY[k].lowenumlab[j] = SACARRAY[k].lowenumlab[j] + 32;
	    }
	}


       i = strlen(SACARRAY[k].lowenumdef);
      for(j=0;j<i;j++)
	{
	  if((SACARRAY[k].lowenumdef[j]<=90)&&(SACARRAY[k].lowenumdef[j]>=65))
	    {
	      
	      SACARRAY[k].lowenumdef[j] = SACARRAY[k].lowenumdef[j] + 32;
	    }
	}


       i = strlen(SACARRAY[k].lowdesc);
      for(j=0;j<i;j++)
	{
	  if((SACARRAY[k].lowdesc[j]<=90)&&(SACARRAY[k].lowdesc[j]>=65))
	    {
	      
	      SACARRAY[k].lowdesc[j] = SACARRAY[k].lowdesc[j] + 32;
	    }
	}
      
      i = strlen(SACARRAY[k].sacname);
      for(j=0;j<i;j++)
	{
	  if((SACARRAY[k].sacname[j]<=90)&&(SACARRAY[k].sacname[j]>=65))
	    {
	      
	      SACARRAY[k].sacname[j] = SACARRAY[k].sacname[j] + 32;
	    }
	}      
    }


  if(FIND_SAC_MAX==1)
    {
      int max = 0;
      for(i=1;i<INsac_loop;i++)
	{
	  if((int)(strlen(SACARRAY[i].enums))>max)
	    {
	      max = strlen(SACARRAY[i].enums);
	      printf("max found %d at %d %s\n",max,i,SACARRAY[i].sac);
	    }
	}
    }

  if(changeattr==1)
    {
      ATTRIBUTION_TYPE = save_attr_type;
      InitializeAttribution();
    }
  
  SACARRAYBUILT = 1;

  free(tempdefn);
  free(result1);
}



void BuildSCCArray()
{
  int i,j,k, changeattr=0,save_attr_type,totallen,secondlen;
  char *secondpart;
  char *tempdefn,*result1;


  

  result1  = (char *)malloc(SAC_MAX);
  if(result1==NULL)
  {
    printf("BSAR: out of memory\n");
	exit(-1);
  }

  tempdefn = (char *)malloc(SAC_MAX);
  if(tempdefn==NULL)
  {
    printf("BSAR2: out of memory\n");
	exit(-1);
  }



  if(SCCARRAY!=NULL)
    {
      for(i=1;i<SCCARRAY_INDICES;i++)
	{
	  free(SCCARRAY[i].scc);
	  free(SCCARRAY[i].sccname);
	  free(SCCARRAY[i].lowdesc);
	  free(SCCARRAY[i].desc);
	}
      free(SCCARRAY);
      SCCARRAY = NULL;
    }



  if(ATTRIBUTION_TYPE!=ATTRIBUTION_INFO_TYPE)
    {
      changeattr = 1;
      save_attr_type = ATTRIBUTION_TYPE;
      ATTRIBUTION_TYPE = ATTRIBUTION_INFO_TYPE;
      InitializeAttribution();
    }

  

  SCCARRAY = (struct SCCarray *) (malloc(sizeof(struct SCCarray) * INscc_loop));
  SCCARRAY_INDICES = INscc_loop;

  if(SCCARRAY==NULL)
    {
      printf("alloc SCCARRAY (2): out of memory!\n");
      ExitWrapper(-1);
    }
  
  for(k=1;k<INscc_loop;k++)
    {
      sprintf(tempdefn,"%s",GetECCLabel(k));
     

      SCCARRAY[k].scc = (char *) (malloc(strlen(tempdefn)+50));
      if(SCCARRAY[k].scc == NULL)
	{
	  printf("allocation memory has been exhausted, processing cannot continue\n");
	  ExitWrapper(-1);
	}
      sprintf(SCCARRAY[k].scc,   "%s",tempdefn);


      
      SCCARRAY[k].sccname = (char *) (malloc(strlen(tempdefn)+50));
      if(SCCARRAY[k].sccname == NULL)
	{
	  printf("allocation memory has been exhausted, processing cannot continue\n");
	  ExitWrapper(-1);
	}
      sprintf(SCCARRAY[k].sccname,   "%s",tempdefn);
      



      sprintf(tempdefn,"%s",GetECCDefinition(k));

      secondpart = strstr(tempdefn,"Amplifying Description:");

      if(secondpart!=NULL)
	  {
        totallen  = strlen(tempdefn);
        secondlen = strlen(secondpart);

        sprintf(result1,"%s",tempdefn);

		if(result1[totallen-secondlen+24]>=32)
		{
          
          result1[totallen-secondlen] = '\0';

          strcat(result1,"\n\nAmplifying Description:\n\n");

          strcat(result1,&secondpart[24]);

		  sprintf(tempdefn,"%s",result1);
		}

	  }








      SCCARRAY[k].desc = (char *) (malloc(strlen(tempdefn)+50));
      if(SCCARRAY[k].desc == NULL)
	{
	  printf("allocation memory has been exhausted, processing cannot continue\n");
	  ExitWrapper(-1);
	}
      sprintf(SCCARRAY[k].desc,   "%s",tempdefn);





      SCCARRAY[k].lowdesc = (char *) (malloc(strlen(tempdefn)+50));
      if(SCCARRAY[k].lowdesc == NULL)
	{
	  printf("allocation memory has been exhausted, processing cannot continue\n");
	  ExitWrapper(-1);
	}
      sprintf(SCCARRAY[k].lowdesc,   "%s",tempdefn);




      i = strlen(SCCARRAY[k].lowdesc);
      for(j=0;j<i;j++)
	{
	  if((SCCARRAY[k].lowdesc[j]<=90)&&(SCCARRAY[k].lowdesc[j]>=65))
	    {
	      
	      SCCARRAY[k].lowdesc[j] = SCCARRAY[k].lowdesc[j] + 32;
	    }
	}
      
      i = strlen(SCCARRAY[k].sccname);
      for(j=0;j<i;j++)
	{
	  if((SCCARRAY[k].sccname[j]<=90)&&(SCCARRAY[k].sccname[j]>=65))
	    {
	      
	      SCCARRAY[k].sccname[j] = SCCARRAY[k].sccname[j] + 32;
	    }
	}
    }
  SCCARRAYBUILT = 1;



  if(changeattr==1)
    {
      ATTRIBUTION_TYPE = save_attr_type;
      InitializeAttribution();
    }

  free(tempdefn);
  free(result1);
}




void clear_callback(Widget w, XtPointer client_data, XtPointer call_data)
{  
  XtVaSetValues(text_output2,XmNvalue,         "",NULL);
  XtVaSetValues(text_output2,XmNcursorPosition,0 ,NULL);
}



void ReDrawHighlightedStuff(Widget w, XtPointer client_data, XtPointer call_data)
{
  int i;
  int win=(int)client_data;

  if(win==0)
    {
      for(i=0;i<num_highlights;i++)
	{
	  if(i==HIGHLIGHTMAX)
	    {
	      break;
	    }

	  if(highlight_ends[i]<0)
	    {
	      XmTextSetHighlight(w,-1*highlight_starts[i],-1*highlight_ends[i],XmHIGHLIGHT_SECONDARY_SELECTED);
	    }
	  else
	    {
	      XmTextSetHighlight(w,highlight_starts[i],highlight_ends[i],XmHIGHLIGHT_SELECTED);
	    }
	}
    }
  else if(win==1)
    {
      for(i=0;i<num_highlights2;i++)
	{
	  if(i==HIGHLIGHTMAX)
	    {
	      break;
	    }
	  XmTextSetHighlight(w,highlight_starts2[i],highlight_ends2[i],XmHIGHLIGHT_SELECTED);
	}
    }
  else
    {
      printf("highlight:  bad win %d\n",win);
    }
  
  
  

  get_double(w, (XtPointer)NULL,(XtPointer)NULL);

}



void myMenuHandler(Widget w, XtPointer userData, XEvent *event, Boolean *continue_to_dispatch)
{
  
  
  

  static int oldx=0,oldy=0;

  XConfigureEvent *conf = (XConfigureEvent *)event;


  if(event->type==ConfigureNotify)
    {
      if((oldx!=conf->x)||(oldy!=conf->y))
	{
	  XtCallActionProc(cascade[0],"CleanupMenuBar",event,NULL,0); 
	  XtCallActionProc(cascade[1],"CleanupMenuBar",event,NULL,0); 
	  XtCallActionProc(cascade[2],"CleanupMenuBar",event,NULL,0); 
	  XtCallActionProc(cascade[3],"CleanupMenuBar",event,NULL,0); 
	  XtCallActionProc(cascade[4],"CleanupMenuBar",event,NULL,0); 
	  XtCallActionProc(cascade[5],"CleanupMenuBar",event,NULL,0); 
	  oldx = conf->x;
	  oldy = conf->y;
	}
    }
}



void myLogoHandler(Widget w, XtPointer userData, XEvent *event, Boolean *continue_to_dispatch)
{
  Dimension x,y;
  int imod,jmod,ix,iy;
  static Dimension oldx=0,oldy=0;
  


  if(event->type == ConfigureNotify)
    {
      if(input_source==0)
	{
	  XtVaGetValues (WW, XmNwidth, &x, XmNheight, &y, NULL);
	  
	  if(oldx==0)
	    {
	      oldx = x;
	      oldy = y;
	    }
	  else
	    {
	      if((abs(x-oldx)>50)||(abs(y-oldy)>50))
		{
		  oldx = x;
		  oldy = y;
		  imod = 0;
		  jmod = 0;
		  ix   = (int)x;
		  iy   = (int)y;
		  
		  
		  imod = (ix-930)/2;
		  imod = imod + 20;
		  if(imod<-100)
		    {
		      imod = -100; 
		    }

		  if(iy>700)
		    {
		      jmod = (iy-700)/2;
		      if(jmod<0)
			{
			  jmod = 0;
			}
		    }
		  
		  SetColorRight();
		  

		  XFillRectangle (mydisplay,pixmap, mygc, 
				  0, 0, width, height);
		  
		  PutImageOnPixmap(1,jmod,imod,pixmap);
		  
		  XCopyArea (mydisplay, pixmap, mywindow, mygc,
			     0, 0,width,height, 0, 0);
		  
		  SetColorRight();
		}
	    }
	}
    }
}




void myResizeHandler(Widget w, XtPointer userData, XEvent *event, Boolean *continue_to_dispatch)
{
  int MaxHeight = (int)userData;

  if(event->type == ConfigureNotify)  
    {
      XConfigureEvent *conf = (XConfigureEvent *)event;
      int new_height = conf->height;
      extern Widget chooseshape_dialog,choose_es1_dialog,choose_es2_dialog,choose_txt_dialog,
             choose_xml1_dialog,choose_xml2_dialog,choose_xml3_dialog;

	  if((MaxHeight==99999)&&(w==chooseshape_dialog))
	   {
		

		
		

	    return;
	   }
	  else if((MaxHeight==99998)&&(w==choose_es1_dialog))
	   {
		

		

	    return;
	   }
	  else if((MaxHeight==99997)&&(w==choose_es2_dialog))
	   {
		

		

	    return;
	   }
	  else if((MaxHeight==99996)&&(w==choose_txt_dialog))
	   {
		

		

	    return;
	   }



	  else if((MaxHeight==99995)&&(w==choose_xml1_dialog))
	   {
		

		

	    return;
	   }
	  else if((MaxHeight==99994)&&(w==choose_xml2_dialog))
	   {
		

		

	    return;
	   }
	  else if((MaxHeight==99993)&&(w==choose_xml3_dialog))
	   {
		

		

	    return;
	   }

      if(new_height>MaxHeight)
	{
	  XtVaSetValues(w, XmNheight, MaxHeight,  NULL);
	}
    }
}




void myResizeWidthHandler(Widget w, XtPointer userData, XEvent *event, Boolean *continue_to_dispatch)
{
  int MaxWidth = (int)userData;
  
  if(event->type == ConfigureNotify)  
    {
      XConfigureEvent *conf = (XConfigureEvent *)event;

      int new_width = conf->width;

      if(new_width>MaxWidth)
	{
	  XtVaSetValues(w, XmNwidth, MaxWidth,  NULL);
	}
    }
}









void MakeInfo(int type)
{
  int n,thewidth;
  Arg resources[20];
  Widget rowcol,form,button;
  
  

  thewidth = DisplayWidth(mydisplay,DefaultScreen(mydisplay));

  if(INFO_WINDOW==0)
    {
      n=0;
      
      XtSetArg(resources[n],  XmNminWidth,    50);           n++;  
      XtSetArg(resources[n],  XmNminHeight,   50);           n++;  
      
	  if((type==1)&&(thewidth>=800))
	  {
        XtSetArg(resources[n],  XmNwidth,    770);             n++;  
        XtSetArg(resources[n],  XmNheight,   500);             n++;  
	  }
	  else
	  {
        XtSetArg(resources[n],  XmNwidth,    600);             n++;  
        XtSetArg(resources[n],  XmNheight,   500);             n++;  
	  }
      
      
      XtSetArg(resources[n],  XmNdeleteResponse, XmDESTROY); n++;
      
      shellhead2 = 
	XtCreatePopupShell("Information",topLevelShellWidgetClass,drawing_a,resources,n);
      
      
      
      rowcol = XtVaCreateManagedWidget
	(
	 "XformWidget", xmPanedWindowWidgetClass, shellhead2,
	 XmNrubberPositioning, False,
	 XmNresizable,         True,
	 XmNseparatorOn,       False,
	 XmNsashHeight,        1,
	 NULL
	 );

      form = XtVaCreateWidget ("form178", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,  
			       NULL);      

      n = 0;
      XtSetArg(resources[n], XmNscrollBarDisplayPolicy, XmSTATIC);          n++;
      XtSetArg(resources[n], XmNrows,                   41);                n++;
      XtSetArg(resources[n], XmNcolumns,                80);                n++;
      XtSetArg(resources[n], XmNeditable,               False);             n++;
      XtSetArg(resources[n], XmNeditMode,               XmMULTI_LINE_EDIT); n++;
      XtSetArg(resources[n], XmNwordWrap,               True);              n++;
      XtSetArg(resources[n], XmNcursorPositionVisible,  False);             n++;
      XtSetArg(resources[n], XmNscrollHorizontal,       False);             n++; 
      XtSetArg(resources[n], XmNtraversalOn,            False);             n++;
      XtSetArg(resources[n], XmNleftAttachment,         XmATTACH_FORM);     n++;
      XtSetArg(resources[n], XmNrightAttachment,        XmATTACH_FORM);     n++;
      XtSetArg(resources[n], XmNtopAttachment,          XmATTACH_FORM);     n++;
      XtSetArg(resources[n], XmNbottomAttachment,       XmATTACH_FORM);     n++;
      XtSetArg(resources[n], XmNtranslations,  XtParseTranslationTable (list_translations11));  n++;

      text_output2 = XmCreateScrolledText(form, "text_output2", resources, n);

      XtAddCallback(text_output2,XmNmotionVerifyCallback,ReDrawHighlightedStuff,(XtPointer)0);
      XtAddCallback(text_output2,XmNfocusCallback,       ReDrawHighlightedStuff,(XtPointer)0);
      XtAddCallback(text_output2,XmNlosingFocusCallback, ReDrawHighlightedStuff,(XtPointer)0);


      XtManageChild (text_output2);
      XtManageChild(form);


      form = XtVaCreateWidget ("form179", xmFormWidgetClass, rowcol,
			       XmNpaneMinimum,   25,
			       XmNpaneMaximum,   25,
			       XmNfractionBase,  100,  
			       NULL);
      
      button  = XtVaCreateManagedWidget("SCR33",xmPushButtonWidgetClass,form,
					XmNlabelString, STRING("Done"),

					
					XmNbottomAttachment, XmATTACH_FORM,		    
					XmNrightAttachment,  XmATTACH_POSITION,
					XmNrightPosition,    99,
					XmNleftAttachment,   XmATTACH_POSITION,
					XmNleftPosition,     51,
					XmNtraversalOn,      False,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					NULL
					); 
     

      XtAddCallback(button, XmNactivateCallback, die_callback, (XtPointer) 1012);
      XtManageChild(button); 





      button  = XtVaCreateManagedWidget("SCR33",xmPushButtonWidgetClass,form,
					XmNlabelString, STRING("Clear"),

					
					XmNbottomAttachment, XmATTACH_FORM,		    
					XmNrightAttachment,  XmATTACH_POSITION,
					XmNrightPosition,    49,
					XmNleftAttachment,   XmATTACH_POSITION,
					XmNleftPosition,     1,
					XmNtraversalOn,      False,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					NULL
					); 
     
      XtAddCallback(button, XmNactivateCallback, clear_callback, (XtPointer) NULL);
      XtManageChild(button);
      XtManageChild(form);


      XtManageChild (rowcol);
      MyPopup(shellhead2);
      XtAddCallback(shellhead2,XmNdestroyCallback,ShellDeath,(XtPointer)212);       
      INFO_WINDOW = 1;

      XtVaGetValues(XtParent(text_output2),XmNverticalScrollBar,  &vert_scroll[INFO_SCROLL],NULL);
      
    }
}



void searchEDCS_callback(Widget w, XtPointer client_data, XtPointer call_data)
{ 
  char *value  = XmTextFieldGetString (search_w);
  char value2[1000];
  int   choice = (int)client_data;
  char  *sacnames;
  char  *fcodes;
  char  *attrcodes;
  char  *sacdefs;
  char  *sacenumdefs;
  char  *sacenumlabs;
  char  *sccnames;
  char  *sccdefs;
  char    headstring[1000];
  char    tempstring[500];
  int foundsacname    = 0;
  int foundsacdef     = 0;
  int foundsacenumdef = 0;
  int foundsacenumlab = 0;
  int foundsccname    = 0;
  int foundsccdef     = 0;
  int foundfcodes     = 0;
  int foundattrcodes  = 0;
  int i,j,k,changeattr=0,save_attr_type; 


  if(strlen(value)<1)
    {
      not_while_running(w,"Your search string must be at least 1 character long",
			1001,"Bad search string",1);
      XtFree(value);
      return;
    }


  sacnames    = (char *)malloc(SAC_MAX);
  fcodes      = (char *)malloc(SAC_MAX);
  attrcodes   = (char *)malloc(SAC_MAX);
  sacdefs     = (char *)malloc(SAC_MAX);
  sacenumdefs = (char *)malloc(SAC_MAX);
  sacenumlabs = (char *)malloc(SAC_MAX);
  sccnames    = (char *)malloc(SAC_MAX);
  sccdefs     = (char *)malloc(SAC_MAX);


  if(ATTRIBUTION_TYPE!=ATTRIBUTION_INFO_TYPE)
    {
      changeattr = 1;
      save_attr_type = ATTRIBUTION_TYPE;
      ATTRIBUTION_TYPE = ATTRIBUTION_INFO_TYPE;
      InitializeAttribution();
    }
  
  
  
  set_cursor(mydisplay,mywindow,WATCH);
  set_cursor(XtDisplay(sdcshead),XtWindow(sdcshead),WATCH);
  
  
  sacnames     [0]  = '\0';
  sacdefs      [0]  = '\0';
  sacenumdefs  [0]  = '\0';
  sacenumlabs  [0]  = '\0';
  sccnames     [0]  = '\0';
  sccdefs      [0]  = '\0';
  fcodes       [0]  = '\0';
  attrcodes    [0]  = '\0';

  
  
  if(INFO_WINDOW==0)
    {
      MakeInfo(2);
    }
  else
    {
      ResetWidget(shellhead2);
    }
  
  sprintf(headstring,"For the search string \"%s\",\n",value);
  infoprintbold(headstring);
  
  
  i = strlen(value);
  for(j=0;j<i;j++)
    {
      if((value[j]<=90)&&(value[j]>=65))
	{
	  
	  value[j] = value[j] + 32;
	}
    }
  sprintf(edcsstring,"%s",value);




  

  BuildSCCArray(); 


  if((choice<10)||(choice==999))
    {
      for(i=1;i<INscc_loop;i++)
	{
	  
	  if(((choice==1)||(choice==999))&&(NGA_TYPE==1))
	    {

	      sprintf(value2,"%s",GetECCCode(i));
	      k = strlen(value2);
	      for(j=0;j<k;j++)
		{
		  if((value2[j]<=90)&&(value2[j]>=65))
		    {
		      
		      value2[j] = value2[j] + 32;
		    }
		}

	      if(strstr(value2,edcsstring))
		{
		  foundfcodes++;
		  strcat(fcodes,"<");
		  strcat(fcodes,GetECCCode(i));
		  strcat(fcodes,": ");
		  strcat(fcodes,GetECCLabel(i));
		  strcat(fcodes,"> ");
		}
	      
	    }
		  


	  if((choice==1)||(choice==999))
	    {
	      if(strstr(SCCARRAY[i].sccname,edcsstring))
		{
		  foundsccname++;
		  strcat(sccnames,"<");
		  

		  if(NGA_TYPE==1)
		    {
		      strcat(sccnames,GetECCCode(i));
		      strcat(sccnames,": ");
		    }

		  
		  strcat(sccnames,SCCARRAY[i].scc);
		  strcat(sccnames,"> ");
		}
	    }
	  
	  if((choice==2)||(choice==999))
	    {
	      if(strstr(SCCARRAY[i].lowdesc,edcsstring))
		{
		  foundsccdef++;
		  strcat(sccdefs,"<");

		  if(NGA_TYPE==1)
		    {
		      strcat(sccdefs,GetECCCode(i));
		      strcat(sccdefs,": ");
		    }

		  strcat(sccdefs,SCCARRAY[i].scc);
		  strcat(sccdefs,"> ");
		}
	    }	  
	}
    }


  
  
  
  BuildSACArray();  
  
  for(i=1;i<INsac_loop;i++)
    {
      
      if(((choice==11)||(choice==999))&&(NGA_TYPE==1))
	{
	  
	  sprintf(value2,"%s",GetEACCode(i));
	  k = strlen(value2);
	  for(j=0;j<k;j++)
	    {
	      if((value2[j]<=90)&&(value2[j]>=65))
		{
	          
	          value2[j] = value2[j] + 32;
		}
	    }
	  
	  if(strstr(value2,edcsstring))
	    {
	      foundattrcodes++;
	      strcat(attrcodes,"<<");
	      strcat(attrcodes,GetEACCode(i));
	      strcat(attrcodes,": ");
	      strcat(attrcodes,GetEACLabel(i));
	      strcat(attrcodes,">> ");
	    }
	  
	}
      
          
      if((choice==11)||(choice==999))
	{
	  if(!strstr(SACARRAY[i].sacname,edcsstring)==0)
	    {
	      foundsacname++;
	      strcat(sacnames,"<<");

	      if(NGA_TYPE==1)
		{
		  strcat(sacnames,GetEACCode(i));
		  strcat(sacnames,": ");
		}

	      strcat(sacnames,SACARRAY[i].sac);
	      strcat(sacnames,">> ");
	    }
	}
      
      if((choice==12)||(choice==999))
	{
	  if(!strstr(SACARRAY[i].lowdesc,edcsstring)==0)
	    {
	      foundsacdef++;
	      strcat(sacdefs,"<<");

	      if(NGA_TYPE==1)
		{
		  strcat(sacdefs,GetEACCode(i));
		  strcat(sacdefs,": ");
		}

	      strcat(sacdefs,SACARRAY[i].sac);
	      strcat(sacdefs,">> ");
	    }
	}
      
      if((choice==13)||(choice==999))
	{
	  if(!strstr(SACARRAY[i].lowenumlab,edcsstring)==0)
	    {
	      foundsacenumlab++;
	      strcat(sacenumlabs,"<<");

	      if(NGA_TYPE==1)
		{
		  strcat(sacenumlabs,GetEACCode(i));
		  strcat(sacenumlabs,": ");
		}

	      strcat(sacenumlabs,SACARRAY[i].sac);
	      strcat(sacenumlabs,">> ");
	    }
	}
      
      if((choice==14)||(choice==999))
	{
	  if(!strstr(SACARRAY[i].lowenumdef,edcsstring)==0)
	    {
	      foundsacenumdef++;
	      strcat(sacenumdefs,"<<");

	      if(NGA_TYPE==1)
		{
		  strcat(sacenumdefs,GetEACCode(i));
		  strcat(sacenumdefs,": ");
		}

	      strcat(sacenumdefs,SACARRAY[i].sac);
	      strcat(sacenumdefs,">> ");
	    }
	}

    }


  if(foundfcodes>0)
    {
      sprintf(tempstring,"Found the search string in %d FCODE(s)\n",foundfcodes);
      infoprintunderline(tempstring);
    }
  
  if(foundsccname>0)
    {
      if(NGA_TYPE==1)
	{
	  sprintf(tempstring,"Found the search string in %d Feature Name(s)\n",foundsccname);
	}
      else
	{
	  sprintf(tempstring,"Found the search string in %d Classification Label(s)\n",foundsccname);
	}
      infoprintunderline(tempstring);
    }

  if(foundsccdef>0)
    {
      if(NGA_TYPE==1)
	{
	  sprintf(tempstring,"Found the search string in %d Feature definition(s)\n",foundsccdef);
	}
      else
	{
	  sprintf(tempstring,"Found the search string in %d Classification definition(s)\n",foundsccdef);
	}
      infoprintunderline(tempstring);
    }
  
  if(foundattrcodes>0)
    {
      sprintf(tempstring,"Found the search string in %d Attribute Code(s)\n",foundattrcodes);
      infoprintunderline(tempstring);
    }
  
  if(foundsacname>0)
    {
      sprintf(tempstring,"Found the search string in %d Attribute Label(s)\n",foundsacname);
      infoprintunderline(tempstring);
    }
  if(foundsacdef>0)
    {
      sprintf(tempstring,"Found the search string in %d Attribute definition(s)\n",foundsacdef);
      infoprintunderline(tempstring);
    }
  if(foundsacenumlab>0)
    {
      sprintf(tempstring,"Found the search string in the Enumerant label(s) of %d Attribute(s)\n",foundsacenumlab);
      infoprintunderline(tempstring);
    }
  if(foundsacenumdef>0)
    {
      sprintf(tempstring,"Found the search string in the Enumerant definition(s) of %d Attribute(s)\n",foundsacenumdef);
      infoprintunderline(tempstring);
    }


  infoprint("\n");


  if(foundfcodes>0)
    {
      infoprintunderline("FCODES containing the string:\n"); 
      infoprint(fcodes);
    }
  if(foundsccname>0)
    {
      infoprint("\n\n");
      
      if(NGA_TYPE==1)
	{
	  infoprintunderline("Feature names containing the string:\n"); 
	}
      else
	{
	  infoprintunderline("Classifiers with the string in their name:\n"); 
	}
      infoprint(sccnames);
    }


  if(foundsccdef>0)
    {
      infoprint("\n\n");

      
      if(NGA_TYPE==1)
	{
	  infoprintunderline("Feature definitions containing the string:\n"); 
	}
      else
	{
	  infoprintunderline("Classifiers with the string in their definition:\n"); 
	}
      infoprint(sccdefs);
    }
  
    
  
  if(foundattrcodes>0)
    {
      infoprint("\n\n");
      infoprintunderline("Attribute codes containing the string:\n"); 
      infoprint(attrcodes);
    }
  
  
  if(foundsacname>0)
    {
      infoprint("\n\n");
      infoprintunderline("Attributes with the string in their name:\n"); 
      infoprint(sacnames);
    }
  
  
  if(foundsacdef>0)
    {
      infoprint("\n\n");
      infoprintunderline("Attributes with the string in their definition:\n"); 
      infoprint(sacdefs);
    }
    
  if(foundsacenumlab>0)
    {
      infoprint("\n\n");
      infoprintunderline("Attributes whose Enumerants have the string in their labels:\n"); 
      infoprint(sacenumlabs);
    }
  
    
  if(foundsacenumdef>0)
    {
      infoprint("\n\n");
      infoprintunderline("Attributes whose Enumerants have the string in their definition:\n"); 
      infoprint(sacenumdefs);
    }
  
  
  if((foundfcodes+foundattrcodes+foundsccname+foundsccdef+foundsacname+foundsacdef+foundsacenumdef+foundsacenumlab)==0)
    {
      infoprint("no matches were found");
    }
  
  infoprint("\n\n");

  
  
  if(changeattr==1)
    {
      ATTRIBUTION_TYPE = save_attr_type;
      InitializeAttribution();
    }
  

  set_cursor(mydisplay,mywindow,GOOD);
  set_cursor(XtDisplay(sdcshead),XtWindow(sdcshead),ARROW);

  

  free(sacnames);
  free(fcodes);
  free(attrcodes);
  free(sacdefs);
  free(sacenumdefs);
  free(sacenumlabs);
  free(sccnames);
  free(sccdefs);

}





void CleanScreen()
{
  Dimension tmpwidth,tmpheight;
  
  

  


  
  


  if(NOT_ZOOMED==1)
    {
      set_color (drawing_a, "Black",(XtPointer)NULL);
      return;
    }


  XtVaGetValues (drawing_a, XmNwidth, &tmpwidth, XmNheight, &tmpheight, NULL);

  set_color (drawing_a, "White",(XtPointer)NULL);
  
  
  XFillRectangle (XtDisplay (drawing_a), pixmap,   mygc, 0, 0, 12,tmpheight); 
  
  
  XFillRectangle (XtDisplay (drawing_a), pixmap,   mygc, 0, tmpheight-12, tmpwidth, 12); 

  
  XFillRectangle (XtDisplay (drawing_a), pixmap,   mygc, 0, 0, tmpwidth, 62);  

  
  XFillRectangle(XtDisplay(drawing_a),pixmap,  mygc,tmpwidth-12,0,12,tmpheight); 
  


  XFillRectangle (XtDisplay (drawing_a), mywindow,  mygc,    0,         0,           12,     tmpheight); 
  XFillRectangle (XtDisplay (drawing_a), mywindow,  mygc,    0,     tmpheight-12,  tmpwidth,    12); 
  XFillRectangle (XtDisplay (drawing_a), mywindow,  mygc,    0,         0,         tmpwidth,    62); 
  XFillRectangle (XtDisplay (drawing_a), mywindow,  mygc,tmpwidth-12,   0,           12,     tmpheight); 


  set_color (drawing_a, "Black",(XtPointer)NULL);
}



void OldFlushScreen(int clean)
{
  if(clean==1){CleanScreen();}
}



void FlushMainScreen(int clean)
{
  int i,renderlevel,timelimit=2;
  long int end;

  
  if(clean==POLY_LIMIT)
    {
      
      
      end = time(NULL);
      if( (end-StartTime) < timelimit)
	{
	  
	  polycount = 0;
	  return;
	}
      clean = 1;
    }
  else if(clean==LINE_LIMIT)
    {
      
      
      end = time(NULL);
      if( (end-StartTime) < timelimit)
	{
	  
	  linecount = 0;
	  return;
	}
      clean = 1;
    }
  else if(clean==CIRCLE_LIMIT)
    {
      

      end = time(NULL);
      if( (end-StartTime) < timelimit)
	{
	  
	  circlecount = 0;
	  return;
	}
      clean = 1;
    }
  else if(clean==GRID_LIMIT)
    {
      

      end = time(NULL);

      if( (end-StartTime) < 1)
	{
	  
	  gridcount = 0;
	  return;
	}
      clean = 1;
    }



  if(clean==1){CleanScreen();}

  
  for(i=NUM_DRAWING_PIXMAPS-1;i>=0;i--)
  {
	  

      if(i==0)
	  {
		  renderlevel = 5;
	  }
	  else
	  {
		  renderlevel = i-1;
	  }
	  
	  if(LODS_USED[renderlevel]==1)
	    {
	      XSetClipMask(mydisplay,mygc,DRAWING_CLIPMAPS[renderlevel]);
	      
	      XCopyArea (mydisplay, DRAWING_PIXMAPS[renderlevel], pixmap, mygc,
			 0, 0, width, height, 0, 0);
	      
	      XCopyArea (mydisplay, DRAWING_PIXMAPS[renderlevel], mywindow, mygc,
			 0, 0, width, height, 0, 0);
	      
	      XSetClipMask(mydisplay,mygc,None);
	    }
	}
    

  circlecount = 0;
  linecount   = 0;
  polycount   = 0;
  gridcount   = 0;


  if(running==0)
    {
      StartTime = time(NULL);
    }

  SetColorRight();

}



void CombIntDrawingLayers(int geom)
{
  int i, doit;

  doit = 0;

  for(i=NUM_DRAWING_PIXMAPS-1;i>=0;i--)
    {
      if(LODS_USED[i]==1)
	  {
	   
	   doit = 1;
	   break;
	  }
    }

  if(doit==1)
    {
      FlushMainScreen(1);

      circlecount = 0;
      linecount   = 0;
      polycount   = 0;

	  PIXMAP_MODIFIER = 1; 
      ClearBitmaps(0);
      ClearDrawingPixmaps(0);
      ZeroPixmapFlags();  
	  PIXMAP_MODIFIER = 0;
    }

}


void WriteMetaFile()
{
  

  FILE *metafile;
  char filename[1000];
 
  sprintf(filename,"%smetatype.txt",importoutputdir);
  metafile = fopen(filename,"w");  
  if(metafile==NULL)
    {
      printf("place 1 couldnt open %s\n",filename);
      ExitWrapper(-1);
    }

  if(NGA_TYPE==0)
    {
      fprintf(metafile,"EDCS\n");
    }
  else
    {

      if(METATYPE==1)
	{
	  fprintf(metafile,"MGCP/NGA\n");
	}
      else if(METATYPE==2)
	{
	  fprintf(metafile,"ESRI\n");
	}
      else if(METATYPE==3)
	{
	  fprintf(metafile,"Intergraph\n");
	}
      else if(METATYPE==4)
	{
	  
	  fprintf(metafile,"MGCP\n");
	}
      else if(METATYPE==5)
	{
	  fprintf(metafile,"User-Defined\n");
	}
	  else
	  {
		XBell(mydisplay,50);
		printf("bad METATYPE %d\n",METATYPE);
  	    fprintf(metafile,"Error\n");
	  }
    }

  fprintf(metafile,"%s",PrintTime(EXTRACT_STARTTIME));
      
  fclose(metafile);
}




void WriteDynamicDefs()
{
  FILE *ddefs,*codes,*out;
  char filename[500],Sjunk[1000];
  int SCC,i,numsac,Ijunk;
  int newc,Inactfound;
  unsigned char defconfig,defstrat,defdomain;

  


  sprintf(filename,"%sdynamicdefs.txt",importoutputdir);
  if(DEBUG==1){printf("trying to open %s\n",filename);}
  ddefs = fopen(filename,"w");  
  if(ddefs==NULL)
    {
      printf("place 1 couldnt open %s\n",filename);
      ExitWrapper(-1);
    }

  sprintf(filename,"%sdynamicdefs.bin",importoutputdir);

  if(DEBUG==1){printf("trying to open %s\n",filename);}
  out = fopen(filename,"wb");  
  if(out==NULL)
    {
      printf("place 2 couldnt open %s\n",filename);
      ExitWrapper(-1);
    }
  
  sprintf(filename,"%scodesshort.bin",importoutputdir);

  if(DEBUG==1){printf("trying to open %s\n",filename);}
  codes = fopen(filename,"rb");  
  if(codes==NULL)
    {
      printf("place 3 couldnt open %s\n",filename);
      ExitWrapper(-1);
    }

  SetEndian(importoutputdir);


  SEEIT_fread_int(&SCC,codes);
  
  while(!feof(codes))
    {
      Inactfound = 0;
      
      SEEIT_fread_int(&numsac,  codes);
      SEEIT_fread_int(&newc,    codes);
      
      for(i=0;i<numsac;i++)
	{
	  SEEIT_fread_int(&Ijunk ,codes);
	  if(Ijunk==-3)  
	    {
	      SEEIT_fread_int(&Ijunk,  codes);
	      fread(&Sjunk[0], 1,Ijunk,codes);
		  Sjunk[Ijunk] = '\0';

	      if(strstr(Sjunk,"Inactive"))
		{
		  Inactfound = 1;
		}
	    }
	  else if(Ijunk==-1) 
	    {
	      SEEIT_fread_int(&Ijunk,  codes);
	      fread(&Sjunk[0], 1,Ijunk,codes);
	    }
	  else if(Ijunk==-2) 
	    {
	      SEEIT_fread_int(&Ijunk,  codes);
	      fread(&Sjunk[0], 1,Ijunk,codes);
	    }
	}

      defconfig = (unsigned char)newc;
      if(SCC>0)
	{
	  defstrat  = STRATS [SCC];
	  defdomain = DOMAINS[SCC];
	}
      else
	{
	  if(NGA_TYPE==1)
	    {
	      
	      defstrat  = S_SURF;
	      defdomain = D_ELEV;
	    }
	  else
	    {
	      defstrat  = 0;
	      defdomain = 0;
	    }
	}

      if(Inactfound==1)
	{
	  defstrat = 3;
	}

      fprintf(ddefs,"%d %d %d %d\n",SCC,newc,defstrat,defdomain);
      SEEIT_fwrite_int(&SCC,       out);
      fwrite(&defconfig, SzUC,1,out);
      fwrite(&defstrat , SzUC,1,out);
      fwrite(&defdomain, SzUC,1,out);


      SEEIT_fread_int(&SCC,codes);
    }
  
  fclose(ddefs);
  fclose(out);
  fclose(codes);
}





void BuildDynamicArrayOfScc(char fname[])
{
  FILE *headerbin,*ddefs;
  unsigned char UCjunk,newc,news,newd;
  int Ijunk,i,SCC;
  long int Ljunk,fileposn;
  double Djunk;
  char filename[1000];


  sprintf(filename,"%sheader.bin",fname);
  headerbin = fopen(filename,"rb");
  if(headerbin==NULL)
    {
      printf("unable to open %s\n",filename);
      ExitWrapper(-1);
    }



  fread(&UCjunk, SzUC,1,headerbin);
  SEEIT_fread_double(&Djunk,  headerbin);
  SEEIT_fread_double(&Djunk,  headerbin);
  SEEIT_fread_double(&Djunk,  headerbin);
  SEEIT_fread_double(&Djunk,  headerbin);
  SEEIT_fread_double(&Djunk,  headerbin);
  SEEIT_fread_double(&Djunk,  headerbin);
  SEEIT_fread_double(&Djunk,  headerbin);
  SEEIT_fread_double(&Djunk,  headerbin);

  SEEIT_fread_long(&Ljunk,  headerbin);
  SEEIT_fread_long(&Ljunk,  headerbin);
  SEEIT_fread_long(&Ljunk,  headerbin);
  SEEIT_fread_long(&Ljunk,  headerbin);
  SEEIT_fread_long(&Ljunk,  headerbin);
  SEEIT_fread_int (&Ijunk,  headerbin);
  
  SEEIT_fread_int(&Ijunk, headerbin);
  SEEIT_fread_int(&DYNAMIC_SCC_NUM,headerbin);
  fclose(headerbin);



  if(DYNAMIC_SCC_LIST_INNITTED==1)
    {
      free(DYNAMIC_SCC_LIST);
    }

  DYNAMIC_SCC_LIST = (struct SCCstoreint *) (malloc(sizeof(struct SCCstoreint) * DYNAMIC_SCC_NUM));
  if(DYNAMIC_SCC_LIST==NULL){printf("dsccl: out of allocation memory!\n"); ExitWrapper(-1);}

  DYNAMIC_SCC_LIST_INNITTED = 1;

  


  sprintf(filename,"%sdynamicdefs.bin",fname);
  ddefs = fopen(filename,"rb");
  if(ddefs==NULL)
    {
      printf("unable to open %s\n",filename);
      ExitWrapper(-1);
    }

  
  for(i=0;i<DYNAMIC_SCC_NUM;i++)
    {
      fileposn = ftell(ddefs);
      
      SEEIT_fread_int(&SCC ,ddefs);
      fread(&newc, SzUC,1,ddefs);
      fread(&news, SzUC,1,ddefs);
      fread(&newd, SzUC,1,ddefs);
     
      DYNAMIC_SCC_LIST[i].orig_position = i;
      sprintf(DYNAMIC_SCC_LIST[i].SCC,"%s",GetECCLabel(SCC));

      DYNAMIC_SCC_LIST[i].sccint = SCC;
      DYNAMIC_SCC_LIST[i].config  = newc;
      DYNAMIC_SCC_LIST[i].strat   = news;
      DYNAMIC_SCC_LIST[i].domain  = newd;
      
      DYNAMIC_SCC_LIST[i].listposn = fileposn;
    }
  fclose(ddefs);

  SortListbyDSCC(0,DYNAMIC_SCC_NUM-1);
}




void BadDB(int silent,char tester[])
{
  char message[1000];


  if(silent==1)
    {
      return;
    }


  if(!strcmp(tester,"tim_special"))
    {
      sprintf(message,"The selected GAIT project is from a different (incompatible) version\n\
of GAIT.  Please select a GAIT project created by GAIT %s",VersionStr);
    }
  else
    {
      sprintf(message,"Unable to open file for reading:\n\
%s\n\
Either you have not selected a valid GAIT project, or\n\
you do not have read permissions to this data.",tester);
    }


  short_non_fatal_error(message,"Unable to find file");
}



int TestShort(char testdirectory[])
{
  FILE *testfile;
  char tester[1000];
  unsigned char a,b,c,d;

  

  sprintf(tester,"%ssizes.bin",testdirectory);
  testfile = fopen(tester,"r");if(testfile==NULL){BadDB(0,tester); return 0;}
  else
    {
      fread(&d, SzUC,1,testfile);
      fread(&a, SzUC,1,testfile);
      fread(&b, SzUC,1,testfile);
      fread(&c, SzUC,1,testfile);

      if(a!=SzI){printf("1 int size mismatch! %d vs %d\n",a,SzI); ExitWrapper(-1);}
      if(b!=SzD){printf("double size mismatch! %d vs %d\n",b,SzD); ExitWrapper(-1);}
      if(c!=sizeof(long int)){printf("long int size mismatch! %d vs %d\n",c,(int)sizeof(long int)); ExitWrapper(-1);}

      if(d==0)
	{file_endianness = 0;}
      else if(d==1)
	{file_endianness = 1;}
      else
	{printf("bad endian value %d\n",(int)d); ExitWrapper(-1);}
       
      if(ENDIANDEBUG==1)
	{
	  printf("setting file endian to %d in testshort\n",file_endianness);
	}
      fclose(testfile);
    }
  return 1;
}



int BuildArrayOfScc(Widget w,char fname[])
{
  char filename[500],badtxt[500];
  FILE *codes, *temp;
  int index=0,i,j;
  long int fileposn;
  unsigned char defstrat,defdomain,newc;
  long int *fptrs;
  int SCC,numsac,Ijunk;
  char Sjunk[1000];
  extern char *GetECCLabel(int code);



  
  sprintf(filename,"%scodesshort.bin",fname);
  
  if(DEBUG==1){printf("trying to open %s\n",filename);}
  temp = fopen(filename,"rb");
  if(temp==NULL)
    {
      sprintf(badtxt,"Couldn't open %s\n",filename);
      non_fatal_error(w,badtxt,"Bad file name");
      return -1;
    }
  
  SCC_NUM=0;
  SEEIT_fread_int(&SCC,  temp);

  while(!feof(temp))
    {
      SCC_NUM++;
      SEEIT_fread_int(&numsac,  temp);
      SEEIT_fread_int(&Ijunk,   temp);

      for(i=0;i<numsac;i++)
	{
	  SEEIT_fread_int(&Ijunk,   temp);
	  if(Ijunk==-3)
	    {
	      SEEIT_fread_int(&Ijunk,  temp);
	      fread(&Sjunk[0], 1,Ijunk,temp);
	    }
	  else if(Ijunk==-1)
	    {
	      SEEIT_fread_int(&Ijunk,  temp);
	      fread(&Sjunk[0], 1,Ijunk,temp);
	    }
	  else if(Ijunk==-2)
	    {
	      SEEIT_fread_int(&Ijunk,  temp);
	      fread(&Sjunk[0], 1,Ijunk,temp);
	    }
	  
	}
      SEEIT_fread_int(&SCC, temp);
    }
  

  rewind(temp);
  fptrs = (long int *) (malloc( sizeof(long int) * (SCC_NUM+5)));
  if(fptrs==NULL){printf("fptrs: out of allocation memory!\n"); ExitWrapper(-1);}


  i = 0;
  fptrs[i] = ftell(temp); 

  SEEIT_fread_int(&SCC,     temp);
  while(!feof(temp))
    {
      SEEIT_fread_int(&numsac,   temp);
      SEEIT_fread_int(&Ijunk,    temp);
      
      for(j=0;j<numsac;j++)
	{
	  SEEIT_fread_int(&Ijunk,temp);
	  if(Ijunk==-3)
	    {
	      SEEIT_fread_int(&Ijunk, temp);
	      fread(&Sjunk[0], 1,Ijunk,temp);
	    }
	  else if(Ijunk==-1)
	    {
	      SEEIT_fread_int(&Ijunk,  temp);
	      fread(&Sjunk[0], 1,Ijunk,temp);
	    }
	  else if(Ijunk==-2)
	    {
	      SEEIT_fread_int(&Ijunk,  temp);
	      fread(&Sjunk[0], 1,Ijunk,temp);
	    }
	}
      i++;
      fptrs[i] = ftell(temp); 
      SEEIT_fread_int(&SCC, temp);
    }

  fclose(temp);


  sprintf(filename,"%sdynamicdefs.bin",fname);

  if(DEBUG==1){printf("trying to open %s\n",filename);}
  codes = fopen(filename,"rb");

  if(codes==NULL)
    {
      sprintf(badtxt,"Couldn't open %s\n",filename);
      non_fatal_error(w,badtxt,"Bad file name");
      return -1;
    }
  
  

  if(SCC_LIST_INNITTED==1)
    {
      free(SCC_LIST);
    }

  SCC_LIST = (struct SCCstoreint *) (malloc(sizeof(struct SCCstoreint) * SCC_NUM));
  if(SCC_LIST==NULL){printf("sccl: out of allocation memory!\n"); ExitWrapper(-1);}
  SCC_LIST_INNITTED = 1;

  

  fileposn = fptrs[0];

  index = 0;

  SEEIT_fread_int(&SCC,   codes);
  
  while(!feof(codes))
    {
      fread(&newc,     SzUC,1,codes);
      fread(&defstrat ,SzUC,1,codes);
      fread(&defdomain,SzUC,1,codes);

      SCC_LIST[index].orig_position = index;

      sprintf(SCC_LIST[index].SCC,"%s",GetECCLabel(SCC));
      SCC_LIST[index].sccint = SCC;
      SCC_LIST[index].config = newc;
      SCC_LIST[index].strat  = defstrat;
      SCC_LIST[index].domain = defdomain;

      
      SCC_LIST[index].listposn = fileposn;
      index++;
      fileposn = fptrs[index];
      SEEIT_fread_int(&SCC, codes);
    }

  fclose(codes);

  

  SortListbySCC(0,SCC_NUM-1);
  free(fptrs);
  if(DEBUG==1){printf("list sorted\n");}  
  return 1;
}




void FreeInfoList()
{
  struct InfoPrintContent *curr, *prev;
  struct AreaRing *currholes, *prevholes;
  int i;


  curr = InfoRoot;
  while(curr!=NULL)
    {
      prev = curr;
      curr = curr->next;

      
      if(prev->innerings != NULL)
	{
	  currholes = prev->innerings;
	  while(currholes != NULL)
            {
	      prevholes = currholes;
	      currholes = currholes->next;
	      free(prevholes->x);
	      free(prevholes->y);
	      free(prevholes->z);
	      free(prevholes);
            }
	}
      
      if(prev->IDstr!=NULL)
	{
	  free(prev->IDstr);
	}


      if(prev->numcoords>0)
	{
	  free(prev->X);
	  free(prev->Y);
	  free(prev->Z);
	}


      if(prev->numattr>0)
	{
	  for(i=0; i<prev->numattr; i++)
	    {
	      if(prev->A[i].code!=NULL)
		{
		  free(prev->A[i].code);
		}
	      if(prev->A[i].Label!=NULL)
		{
		  free(prev->A[i].Label);
		}
	      if(prev->A[i].value!=NULL)
		{
		  free(prev->A[i].value);
		}
	      if(prev->A[i].valueLabel!=NULL)
		{
		  free(prev->A[i].valueLabel);
		}
	      if(prev->A[i].SEDRISxtra!=NULL)
		{
		  free(prev->A[i].SEDRISxtra);
		}

	    }
	  if(prev->A!=NULL)
	    {
	      free(prev->A);
	    }
	}

      free(prev);
    }

  InfoRoot = NULL;
}



void ShellDeath2(Widget widget, XtPointer userData, XtPointer callData)
{
  
  int passdata = (int)userData;
 

  if((passdata>=1000)&&(passdata<5000))
    {
      shortmsg_up[passdata] = 0;
    }
}



void ShellDeath(Widget widget, XtPointer userData, XtPointer callData)
{

  


  int passdata = (int)userData;
  int i;
  extern Widget choose_es1_dialog,choose_es2_dialog,choose_txt_dialog,
	  choose_dialog,chooseshape_dialog,choosedata_dialog,choosebr_dialog,choosedp_dialog;
  extern int net_deader_head,net_deader_phead,PROFILE_WIN;


  if(passdata==115)
    {
      SAVE_SETTINGS_UP = 0;
    }
  else if(passdata==116)
    {
      SAVE_CREPORT_UP = 0;
    }
  else if(passdata==117)
    {
      LAYER_GEOM_UP = 0;
    }
  else if(passdata==118)
    {
      LAYER_FC_UP = 0;
    }
  else if(passdata==119)
    {
      LAYER_MGCP_UP = 0;
    }


  else if(  (passdata>=400)  && (passdata<=(400+CONDITION_DEFINITIONS)))
    {
      
      HELP_UP[passdata-400]=0;
    }
  else if(  (passdata>=8300)  && (passdata<=(8300+CONDITION_DEFINITIONS)))
    {
      
      deadfix[passdata-8300]=1;
    }


  else if(passdata==200)
    {
      deader_head=1;  
    }
  else if(passdata==201)
    {
      deader_phead=1; 
    }



  else if( passdata ==203 )
    {
      load_head=1;
    }
  
  else if(passdata==205) {dead_head4 = 1;}
  else if(passdata==206) {input_up   = 0;}
  
 
  else if(passdata==212) 
    {  
      INFO_WINDOW=0;
      realinfoprint("NULL", -1);
      num_highlights = 0;
    }
  else if(passdata==213) 
    {  
      dead_side=1;
    }
  else if(passdata==214) 
    {  
      
      LOS_WIN=0;
    }
  else if(passdata==215) 
    {  
      dead_head5=1;
    }
  else if(passdata==216) 
    {
      GRID_WIN=0;
    }
  else if(passdata==217) 
    {  
      ERR_INFO=0;
    }
  else if(passdata==218) 
    {  
      IMPORT_WIN=0;

  	  if(SHAPE_IMPORT_OUTPUT==1)
	  {
		HandleSuccessDos(chooseshape_dialog);
	  }

    }
  else if(passdata==219) 
    {  
      IMPORT_INPUT=0;
    }
  else if(passdata==222) 
    {  
      IMPORT_OUTPUT = 0;
    }
  else if(passdata==223) 
    {  
      CSD_UP = 0;
    }
 else if(passdata==227) 
    {
      MOD_UP = 0;
      BuildDynamicArrayOfScc(indirectory);
    }
 else if(passdata==228) 
    {  
      RUN_FORMAT_UP = 0;
    }
 else if(passdata==229) 
    {  
      ABNORMAL_LOAD_UP = 0;
    }
  else if(passdata==232) 
    {
      
      FORE_WIN=0;
    }
  else if(passdata==233) 
    {  
      dead_lod_head = 1;

      

      for(i=0;i<NumLODbands;i++)
	{
	  if(layers_up[i]==1)
	    {
	      XtDestroyWidget(toplevel[i]);
	    }
	}

      if(SAVE_TOPCHANGE>0)
	  {
	    

	    RebuildTopImage(0);
	  }

      refreshCallback((Widget)NULL,(XtPointer)NULL,(XtPointer)NULL);      
    }
  else if(passdata==234) 
    {  
      dead_lod_head2 = 1;

      

      for(i=0;i<NumLODbands;i++)
	{
	  if(layers_up[i]==1)
	    {
	      XtDestroyWidget(toplevel[i]);
	    }
	}
      
      if(SAVE_TOPCHANGE>0)
	{
	  
	  RebuildTopImage(0);
	}
      refreshCallback((Widget)NULL,(XtPointer)NULL,(XtPointer)NULL);
    }

  else if(passdata==255) 
    {  
      PATCH_WIN = 0;
    }
  else if(passdata==256) 
    {  
      PATCH_INPUT = 0;
    }
  else if(passdata==257) 
    {  
      STF_INPUT = 0;
    }
  else if(passdata==266) 
    {  
      browse5_up  = 0;
    }
  else if(passdata==274) 
    {  
      browse6_up  = 0;
    }
  else if(passdata==275) 
    {  
      browse7_up  = 0;
    }
  else if(passdata==279) 
    {  
      
	  
	  dead_shade = 1;
    }
  else if(passdata==288) 
    {  
      
      REC_WIN=0;
    }
  else if(passdata==291) 
    {
      SPEC_WIN=0;    
    }
  else if(passdata==293) 
    {
      browse8_up = 0;
    }
  else if(passdata==296) 
    {
      AOI_SAVE_UP = 0;
    }
  else if(passdata==297) 
    {
      AOI_LOAD_UP = 0;
    }
  else if(passdata==298) 
    {
      AOI_SHAPE_UP = 0;
    }
  else if(passdata==302)
    {
      los_result(zoom_pad_w,(XtPointer)9,(XtPointer)NULL);
      PAD_UP =0;
    }

  else if(passdata==303) 
    {  
      INDIR_WORK_UP = 0;
    }
  else if(passdata==304) 
    {
    }
  else if(passdata==305) 
    {  
      SHAPE_IMPORT_OUTPUT = 0;
	  FreeWidList(CHOOSESHAPE_BROWSE,1);
    }
  
  else if(passdata==306) 
    {  
      info_window_up = 0;
      FreeInfoList();
	  TransferCleanPixmap(); 
	  info_list = NULL;
    }

  else if(passdata==307) 
    {  
      INFO_PARAM_WIN = 0;
    }

  else if(passdata==308) 
    {  
      INFO_ATTR_WIN = 0;
    }
  else if(passdata==309)
  {
	  RUNNING_INFO = 0;
  }



  else if((passdata>=2000)&& (passdata<=2005))
    {
      if( Current_head == (passdata - 2000))
	{
	  dead_error=1;
	  
	  for(i=0;i<CLONE_DEFINITIONS;i++)
	    {
	      CloneErrorLookup[i].scrollwidmade = 0;
	    }
	  for(i=0;i<=CONDITION_DEFINITIONS;i++)
	    {
	      ErrorLookup[i].scrollwidmade = 0;
	    }
	}
      FreeHighlighter();
      
      DRAWING_ERRORS = 0;
      ABORT_ZOOM = 2;
	  TransferCleanPixmap(); 
    }




  else if(passdata==4000) 
    { 
      dead_head6=1;
    }
  else if(passdata==4001) 
    { 
      dead_folderhead=1;
      
      if(browse12_up==1)
	{
	  HandleSuccessDos(choose_dialog);
	}
    }
  else if(passdata==4002) 
    { 
      dead_datahead=1;

      if(browse26_up==1)
	{
	  HandleSuccessDos(choosedata_dialog);
	}
    }
  else if(passdata==4003) 
    {
      browse12_up = 0;
      FreeWidList(CHOOSEPROJ_BROWSE,1);
    }
  
  

  else if(passdata==4050)
    {
      FORMAT_BEGIN = 0;
    }
  else if(passdata==4051)
    {
      dead_zero_head = 1;
    }
  else if(passdata==4052)
    {
      dead_obhead[0] = 1;
	  TransferCleanPixmap(); 
     }
  else if(passdata==4053)
    {
      dead_obhead[1] = 1;
	  TransferCleanPixmap(); 
     }
  else if(passdata==4054)
    {
      dead_obhead[2] = 1;
	  TransferCleanPixmap(); 
    }
  else if(passdata==4055)
    {
      dead_obhead[3] = 1;
	  TransferCleanPixmap(); 
    }
  else if(passdata==4056)
    {
      dead_obhead[4] = 1;
	  TransferCleanPixmap(); 
    }
  else if(passdata==4057)
    {
      fcodefilter_up = 0;
    }
  else if(passdata==4058)
    {
      dead_checkfilter = 1;
    }
  else if(passdata==4059)
    {
      metabrowse_up = 0;
    }
  else if(passdata==4060) 
    {  
      dead_compare = 1;

      
      

      if(browse13_up==1)
	{
	  HandleSuccessDos(choose_es1_dialog);
	}
      if(browse14_up==1)
	{
	  HandleSuccessDos(choose_es2_dialog);
	}
      if(browse15_up==1)
	{
	  HandleSuccessDos(choose_txt_dialog);
	}

    }
  else if(passdata==4061) 
    {
      browse13_up = 0;
      FreeWidList(CHOOSE_ES1_BROWSE,1);
    }
  else if(passdata==4062) 
    {
      browse14_up = 0;
      FreeWidList(CHOOSE_ES2_BROWSE,1);
    }
  else if(passdata==4063)
    {
      browse15_up = 0;
      FreeWidList(CHOOSE_TXT_BROWSE,1);
    }
  else if(passdata==4064)
    {
      P_window = 0; 
    }
  else if(passdata==4065)
    {
      DEMO_UP=0; 
    }
  else if(passdata==4066) 
    {  
      
      
      load_reg   = 0;
      AOI_MODE   = 0;  
    }
  else if(passdata==4067) 
    {
      dead_sdcs = 1;
    }
 else if(passdata==4068) 
    {  
      ATT_DEMO_UP=0; 
    }
 else if(passdata==4069)
   {
     dead_network = 1; 
     
     for(i=0;i<CLONE_DEFINITIONS;i++)
       {
	 CloneErrorLookup[i].scrollwidmadeNET = 0;
       }
     for(i=0;i<=CONDITION_DEFINITIONS;i++)
       {
	 ErrorLookup[i].scrollwidmadeNET = 0;
       }
   }
  else if(passdata==4070) 
    {
      VPAD_UP = 0;
    }
  else if(passdata==4071)
    {
      input_up = 0;
    }
  else if(passdata==4072)
    {
      LOAD_SETTINGS_UP = 0;
    }
  else if(passdata==4073)
    {
      dead_head5 = 1;
    }
  else if(passdata==4074)
    {
      prev_up = 0;
    }
  else if(passdata==4075)
    {
      overwrite1_up = 0;
    }
  else if(passdata==4076)
    {
      overwrite3_up = 0;
    }
  else if(passdata==4077)
    {
      pref_up = 0;
    }
  else if(passdata==4078)
    {
      LAYERPREFS_UP = 0;
    }
  else if(passdata==4079)
    {
      pref2_up = 0;
    }
  else if(passdata==4080)
    {
      PPAD_UP = 0;
    }
  else if(passdata==4081)
    {
      browse26_up = 0;
      FreeWidList(CHOOSEDATA_BROWSE,1);
    }
  else if(passdata==4082)
    {  
      dead_xml = 1;

      
      
	  
    }
  else if(passdata==4083)
    {
      browse27_up = 0;
      FreeWidList(CHOOSE_XML1_BROWSE,1);
    }
  else if(passdata==4084)
    {
      browse28_up = 0;
      FreeWidList(CHOOSE_XML2_BROWSE,1);
    }
  else if(passdata==4085)
    {
      browse29_up = 0;
      FreeWidList(CHOOSE_XML3_BROWSE,1);
    }
  else if(passdata==4086)
    {
    }
  else if(passdata==4087)
    {
      CONTOUR_WIN = 0;
    }
  else if(passdata==4088)
    {
    }
  else if(passdata==4089)
    {
    }
  else if(passdata==4090)
    {
      browse30_up = 0;
      FreeWidList(ATTRFOLDER_BROWSE,1);
    }
  else if(passdata==4091) 
    {  
      browse30_up = 0;
    }
  else if(passdata==4092) 
    {  
      dead_dp = 1;

      if(browse31_up==1)
	{
	  HandleSuccessDos(choosedp_dialog);
	}

    }
  else if(passdata==4093) 
    {  
      browse31_up = 0;
      FreeWidList(CHOOSE_DP_BROWSE,1);
    }
  else if(passdata==4094) 
    {
      dead_browsefolderhead=1;

      EnterFileCallback(browsefolder_wid, (XtPointer)31, (XtPointer)31);

      if(browse32_up==1)
	{
	  HandleSuccessDos(choosebr_dialog);
	}


    }

  else if(passdata==4095)
    {  
      browse32_up = 1;
      FreeWidList(CHOOSEBROWSE_BROWSE,1);
    }
  else if(passdata==4096)
    {
      overwrite6_up = 0;
    }
  else if(passdata==4097)
    {
      dead_head7 = 1;
    }
  else if(passdata==4098)
    {
      net_deader_head=1;  
    }
  else if(passdata==4099)
    {
      net_deader_phead=1; 
    }
  else if(passdata==4100)
    {
      LOAD_NETSETTINGS_UP = 0;
    }
  else if(passdata==4101)
    {
      los_result(net_zoom_pad_w,(XtPointer)12,(XtPointer)NULL);
      NPAD_UP =0;
    }
  else if(passdata==4102)
    {
      dead_trexchoose = 1;
    }
  else if(passdata==4103)
    {
      PROFILE_WIN = 0;
    }







  

  else if (
	   (passdata>=9000) &&
	   (passdata<11000) 
	   )
    {
      HyperClassUp[passdata-9000] = 0;
    }
  else if (
	   (passdata>=11000) &&
	   (passdata<14000) 
	   )
    {
      HyperAttrUp[passdata-11000] = 0;
    }

  else if((passdata>=15000)&&(passdata<50000))
  {
    layers_up[passdata-15000] = 0;
  }



  if(DEBUG==1){printf("Done with shelldeath\n");}
  SetColorRight();

}






void set_cursor(Display *thedisplay,Window thewindow,int type)
{
  Cursor cursor;
  XSetWindowAttributes attrs;
  Pixmap hand_pix, hand_mask;
  XColor black_def;


  static char hand_bits[] = {
    (char)0x80, (char)0x01, (char)0x58, (char)0x0e, (char)0x64, (char)0x12, (char)0x64, (char)0x52, 
    (char)0x48, (char)0xb2, (char)0x48, (char)0x92, (char)0x16, (char)0x90, (char)0x19, (char)0x80,
    (char)0x11, (char)0x40, (char)0x02, (char)0x40, (char)0x04, (char)0x40, (char)0x04, (char)0x20,
    (char)0x08, (char)0x20, (char)0x10, (char)0x10, (char)0x20, (char)0x10, (char)0x20, (char)0x10};
  


  if(type==PIRATE)
    {
      cursor = XCreateFontCursor (thedisplay, XC_pirate);
    }
  else if((type==WATCH)||(type==WATCH2))
    {
      cursor = XCreateFontCursor (thedisplay, XC_watch);
    }
  else if(type==ARROW)
    {
      cursor = XCreateFontCursor (thedisplay, XC_left_ptr); 
    }
  else if((type==GOOD)||(type==GOOD2))
    {
      if(input_source==0)
	{
	  cursor = XCreateFontCursor (thedisplay, XC_left_ptr);
	}
      else if(ZOOM_MODE==1)
	{
	  cursor = XCreateFontCursor (thedisplay, XC_draped_box);
	}
      else  if(INFO_MODE==1)
	{
	  cursor = XCreateFontCursor (thedisplay, XC_question_arrow);
	}
      else  if(PROFILE_MODE==1)
	{
	  cursor = XCreateFontCursor (thedisplay, XC_crosshair);
	}
      else  if(FAN_MODE==1)
	{
	  cursor = XCreateFontCursor (thedisplay, XC_diamond_cross);
	}
      else if(DIST_MODE==1)
	{
	  cursor = XCreateFontCursor (thedisplay, XC_dotbox);
	}
      else if(CHECK_MODE==1)
	{
	  cursor = XCreateFontCursor (thedisplay, XC_plus);
	}
      else if(PAN_MODE==1)
	{
	  XParseColor(mydisplay,cmap,"Black",&black_def);

	  hand_pix = XCreatePixmapFromBitmapData (XtDisplay (WW),
						  RootWindowOfScreen (XtScreen (WW)),
						  hand_bits, 16,16, 1, 0, 1);
	  hand_mask = XCreatePixmapFromBitmapData (XtDisplay (WW),
						  RootWindowOfScreen (XtScreen (WW)),
						  hand_bits, 16,16, 1, 0, 1);



	  cursor = XCreatePixmapCursor (thedisplay, hand_pix, hand_mask,
					&black_def,&black_def,16,16);
	}
    }
  attrs.cursor =  cursor;
  XChangeWindowAttributes (thedisplay, thewindow, CWCursor, &attrs);





  
  
  XFlush (thedisplay);


}



void periodic_attr_redraw()
{
  extern int idle_redraw;
  static long int last_redraw=0,ThisTime;
  
  ThisTime = time(NULL);

  if((ThisTime-last_redraw)>0)
    {
      XmUpdateDisplay(drawing_a); 
      idle_redraw = 0;
      last_redraw = ThisTime;
    }
}


void periodic_redraw()
{
  XEvent event;
  extern int idle_redraw;
  static long int last_redraw=0,ThisTime;
  
  ThisTime = time(NULL);

  if((ThisTime-last_redraw)>0)
    {
      if(batch_mode==0)
	{
	  while(XCheckMaskEvent(mydisplay,
				ButtonPressMask|ButtonReleaseMask,&event))
	    {
	      XtDispatchEvent(&event);
	    }
	}
      XmUpdateDisplay(drawing_a); 
      idle_redraw = 0;
      last_redraw = ThisTime;
    }
}




void set_shift(int on)
{ 
  int start,end,i;


  
  
  
  

  if(on==-1)
    {
      on    = 0;
      start = 0;
      end   = 3;
    }
  else if(on==10)
    {
      on    = 1;
      start = 0;
      end   = 3;
    }
  else
    {
      start = 0;
      end   = 3;
    }


  for(i=start;i<=end;i++)
    {      
      if(on==1)
	{
	  XtSetSensitive(shift[i],True);
	}
      else if(on==0)
	{
	  XtSetSensitive(shift[i],False);
	}
      else 
	{
	  printf("Bad arg %d to set_shift\n",on);
	}
    }
}



void set_color(Widget widget,char * client_data,XtPointer call_data)
{
  if(!strcmp(client_data,"Blue"))
    {
      XSetForeground(XtDisplay(widget),mygc,mycolors[DRAW_COLOR_BLUE]);
      return;
    }
  else if(!strcmp(client_data,"Red"))
    {
      XSetForeground(XtDisplay(widget),mygc,mycolors[1]);
      return;
    }
  else if(!strcmp(client_data,"Black"))
    {
      XSetForeground(XtDisplay(widget),mygc,mycolors[DRAW_COLOR_BLACK]);
      return;
    }
  else if(!strcmp(client_data,"White"))
    {
      XSetForeground(XtDisplay(widget),mygc,mycolors[DRAW_COLOR_WHITE]);
      return;
    } 
  else if(!strcmp(client_data,"Green"))
    {
      XSetForeground(XtDisplay(widget),mygc,mycolors[DRAW_COLOR_LTGREEN]);
      return;
    } 
  else if(!strcmp(client_data,"Brown"))
    {
      XSetForeground(XtDisplay(widget),mygc,mycolors[DRAW_COLOR_BROWN]);
      return;
    } 
  else if(!strcmp(client_data,"Purple"))
    {
      XSetForeground(XtDisplay(widget),mygc,mycolors[DRAW_COLOR_PURPLE]);
      return;
    } 

  XBell(mydisplay,50);
  printf("Unable to set color to %s...this is bad.  continuing, but colors arent right.\n",client_data);
}




void SetNewPage()
{
  

  char temp[1000];
  int minindex,maxindex;
  int pagenum;


  pagenum = view_object_page;


  if(BODEBUG==1)
    {
      printf("here we set the page for the view by feature window to %d\n",pagenum);
    }


  override_location = 1;
  XtVaGetValues(ob_head[current_ob_head],XmNx,     &over_px1,   NULL);  
  XtVaGetValues(ob_head[current_ob_head],XmNy,     &over_py1,   NULL);  
  XtVaGetValues(ob_head[current_ob_head],XmNwidth, &over_width, NULL);  
  XtVaGetValues(ob_head[current_ob_head],XmNheight,&over_height,NULL);  


  over_px1 = over_px1 - 4;     
  over_py1 = over_py1 - 30;     
  if(over_px1<10)
    {
      over_px1 = 10;
    }
  if(over_py1<10)
    {
      over_py1 = 10;
    } 
  


  XtDestroyWidget(ob_head[current_ob_head]);
  dead_obhead[current_ob_head] = 1;

  current_ob_head = current_ob_head + 1;
  if(current_ob_head>4)
    {
      current_ob_head = 0;
    }



  ConditionObjectCallback((Widget)NULL,(XtPointer)pagenum,(XtPointer)NULL);
  override_location = 0;


  if(numobs==0)
    {
      return;
    }





  
  sprintf(temp,"%d",pagenum);
  XmTextFieldSetString(page_wid,temp);




  
  minindex = num_per_page*(pagenum-1) + 1;
  if(minindex<1)
    {
      XBell(mydisplay,50);
      printf("Error in 321: trying to set minindex to %d\n",minindex);
      minindex = 1;
    }
  maxindex = minindex + num_per_page - 1;
  if(maxindex>numobs)
    {
      maxindex = numobs;
    }


  sprintf(temp," (showing [%d-%d] of %d total)",minindex,maxindex,numobs);
  XtVaSetValues(topright, XmNlabelString, STRING(temp), NULL);

}














void print_result2(Widget text_w,XtPointer client_data,XtPointer call_data)
{
  char OLD[30],junk[100];
  char *value = XmTextFieldGetString (text_w);
  int i,bad=0,type=(int)client_data;
  int ToItest,ToJtest,FromItest,FromJtest;
  XmString t;
  double dtest;

  if(type==1)
    {sprintf(OLD,"%d",ToI);}
  else if(type==2)
    {sprintf(OLD,"%d",ToJ);}
  else if(type==3)
    {sprintf(OLD,"%d",FromI);}
  else if(type==4)
    {sprintf(OLD,"%d",FromJ);}
  else if(type==5)
    {sprintf(OLD,"%d",ENV_ROOT_NUM);}
  
  
  
  for(i=0;i<(int)(strlen(value));i++)
    {
      if((value[i]<'0')||(value[i]>'9'))
	{
	  XmTextFieldSetString(text_w,OLD);
	  bad = 1;

	  if(type==5)
	    {
	      return;
	    }
	}
    }
  
  if(bad==0)
    {
      if(type==1)
	{
	  sscanf(value,"%lf",&dtest);
	  ToItest = (int)dtest;
	  if((ToItest<=MaxXindex)&&(ToItest>=FromI))
	    {ToI=ToItest;}else{XmTextFieldSetString(text_w,OLD);}
	}
      else  if(type==2)
	{ 
	  sscanf(value,"%lf",&dtest);
	  ToJtest = (int)dtest;
	  if((ToJtest<=MaxYindex)&&(ToJtest>=FromJ))
	    {ToJ=ToJtest;}else{XmTextFieldSetString(text_w,OLD);}
	}
      else  if(type==3)
	{ 
	  sscanf(value,"%lf",&dtest);
	  FromItest = (int)dtest;
	  if((FromItest<=MaxXindex)&&(FromItest<=ToI))
	    {FromI=FromItest;}else{XmTextFieldSetString(text_w,OLD);}
	}
      else  if(type==4)
	{ 
	  sscanf(value,"%lf",&dtest);
	  FromJtest = (int)dtest;
	  if((FromJtest<=MaxYindex)&&(FromJtest<=ToJ))
	    {FromJ=FromJtest;}else{XmTextFieldSetString(text_w,OLD);}
	}
      else  if(type==5)
	{ 
	  sscanf(value,"%lf",&dtest);
	  ENV_ROOT_NUM = (int)dtest;

	  sprintf(junk,"%d",ENV_ROOT_NUM);

	  XtVaSetValues (env_root_area,
			 XmNlabelString, STRING(junk),
			 NULL);
	  return;
	}
    }
  
  if(DEBUG==1){printf("%d %d %d %d jj\n",ToI,ToJ,FromI,FromJ);}
  
  sprintf(junk,"Total number of regions to inspect: %d",(ToI-FromI+1)*(ToJ-FromJ+1));
  
  t = XmStringCreateLtoR (junk,XmSTRING_DEFAULT_CHARSET);
  
  XtVaSetValues (total_w,
		 XmNlabelString,    t,
		 NULL);
  
  sprintf(junk,"%d,%d",FromI,ToJ);
  
  t = XmStringCreateLtoR (junk,XmSTRING_DEFAULT_CHARSET);
  
  XtVaSetValues (text_ul,
		 XmNlabelString,    t,
		 NULL);
  
  sprintf(junk,"%d,%d",ToI,FromJ);
  
  t = XmStringCreateLtoR (junk,XmSTRING_DEFAULT_CHARSET);
  
  XtVaSetValues (text_lr,
		 XmNlabelString,    t,
		 NULL);
  
  XmStringFree (t);
  XtFree(value);
}



void cleanse_events()
{
  XEvent event;
  
  
  
  while(XCheckMaskEvent(XtDisplay(drawing_a),
			KeyPressMask     |
			 
			ButtonMotionMask |
			ButtonPressMask  |
			ButtonReleaseMask ,
			&event))
    {
      
    } 
}



void DrawGrid()
{
  int i;
  
  urx_zoom = llx_zoom+(1000.0/xunits)*IRegionSize;
  ury_zoom = lly_zoom+ (850.0/yunits)*IRegionSize;
  
  for(i=0;i<=xnum;i++)
    {
      MAPdrawline(-1,
		  (double)(i*RegionSize),
		  0.00,
		  (double)(i*RegionSize),
		  (double)((MaxYindex+1)*RegionSize),
		  COLOR_TAN,DRAW_NOW);
    } 
  for(i=0;i<=ynum;i++)
    {
      MAPdrawline(-1,
		  0.00,
		  (double)(i*RegionSize),		 
		  (double)((MaxXindex+1)*RegionSize),
		  (double)(i*RegionSize),
		  COLOR_TAN,DRAW_NOW);
    }


}




int AddBold(Widget thewin,int thispos,char message[])
{

  highlight_starts2[num_highlights2] = thispos;
  highlight_ends2[num_highlights2]   = thispos + (long int)(strlen (message))-1;
  num_highlights2++;


  XmTextInsert (thewin, thispos, message);
  thispos = thispos + (long int)(strlen (message));
  XtVaSetValues (thewin, XmNcursorPosition, thispos, NULL);
  XmTextShowPosition (thewin, thispos);
  
  XmTextSetHighlight(thewin,
		     highlight_starts2[num_highlights2],
		     highlight_ends2[num_highlights2],
		     XmHIGHLIGHT_SELECTED);

  return thispos;
}

int AddReg(Widget thewin,int thispos,char message[])
{
  
  XmTextInsert (thewin, thispos, message);
  thispos = thispos + (long int)(strlen (message));
  XtVaSetValues (thewin, XmNcursorPosition, thispos, NULL);
  XmTextShowPosition (thewin, thispos);

  return thispos;
}


char *GetGMType(int type)
{
  if(type==2)
  {
    return "Geomedia Access";
  }
  else
  {
	printf("bad type %d to GGMT\n",type);
  }

  XBell(mydisplay,50);
  return "Geomedia";
}

void OSErrorHandle(int errnum, char *errstr, int type)
{
  char errmsg[1000];


  switch(errnum)
    {
    case 1: 
      sprintf(errmsg,"%s: fatal error:\n failed to create instance. Aborting\n",GetGMType(type));
      break;
      
    case 2: 
      sprintf(errmsg,"%s: fatal error:\n put_Type call failed. Aborting\n",GetGMType(type));
      break;
      
    case 3: 
      sprintf(errmsg,"%s: fatal error:\n put_Location call failed with %s. Aborting\n",GetGMType(type),errstr);
      break;

    case 4: 
      sprintf(errmsg,"%s: fatal error:\n put_ConnectInfo call failed with %s. Aborting\n",GetGMType(type),errstr);
      break;
      
    case 5: 
      printf("%s: error:\n put_Mode call failed.\n",GetGMType(type));
      return;

    case 6: 
      sprintf(errmsg,"%s: fatal error:\n Connect call failed. Aborting\n",GetGMType(type));
      break;

    case 7: 
      sprintf(errmsg,"%s: fatal error:\n create MetadataServicecall failed. Aborting\n",GetGMType(type));
      break;
      
    case 8: 
      sprintf(errmsg,"%s: fatal error:\n putref_Connection call failed. Aborting\n",GetGMType(type));
      break;
      
    case 9: 
      sprintf(errmsg,"%s: fatal error:\n GetTables call failed. Aborting\n",GetGMType(type));
      break;

    case 10: 
      printf(errmsg,"%s: error:\n Disconnect call failed\n",GetGMType(type));
      return;

    case 11: 
      sprintf(errmsg,"%s: fatal error:\n MetadataService call failed. Aborting\n",GetGMType(type));
      break;

    case 12: 
      sprintf(errmsg,"%s: fatal error:\n putref_Connection call failed. Aborting\n",GetGMType(type));
      break;
      
    case 13: 
      sprintf(errmsg,"%s: fatal error:\n GetTables call failed. Aborting\n",GetGMType(type));
      break;

    case 14: 
      sprintf(errmsg,"%s: fatal error:\n CreateOriginatingPipe call failed. Aborting\n",GetGMType(type));
      break;

    case 15: 
      sprintf(errmsg,"%s: fatal error:\n put_Table call failed with %s. Aborting\n",GetGMType(type),errstr);
      break;

    case 16: 
      sprintf(errmsg,"%s: fatal error:\n get_OutputRecordset call failed with %s. Aborting\n",GetGMType(type),errstr);
      break;
      
    case 17: 
      sprintf(errmsg,"%s: fatal error:\n MoveFirst call failed with %s. Aborting\n",GetGMType(type),errstr);
      break;
      
    case 18: 
      sprintf(errmsg,"%s: fatal error:\n get_GFields call failed with %s. Aborting\n",GetGMType(type),errstr);
      break;
      
    case 19: 
      sprintf(errmsg,"%s: fatal error:\n get_Count call failed with %s. Aborting\n",GetGMType(type),errstr);
      break;
      
    case 20: 
      sprintf(errmsg,"%s: fatal error:\n get geometry object call failed with %s. Aborting\n",GetGMType(type),errstr);
      break;
      
    case 21: 
      sprintf(errmsg,"%s: fatal error:\n get_EOF call failed with %s. Aborting\n",GetGMType(type),errstr);
      break;
      
    case 22: 
      sprintf(errmsg,"%s: fatal error:\n get_Value call failed with %s. Aborting\n",GetGMType(type),errstr);
      break;
      
    case 23: 
      sprintf(errmsg,"%s: error:\n VariantClear call failed with %s.\n",GetGMType(type),errstr);
      return;

    case 24: 
      sprintf(errmsg,"%s: fatal error:\n Geom->get_Value call failed. Aborting.\n",GetGMType(type));
      break;
      
    case 25: 
      sprintf(errmsg,"%s: fatal error:\n Geom->get_Type call failed. Aborting\n",GetGMType(type));
      break;
      
    case 26: 
      sprintf(errmsg,"%s: fatal error:\n area gss->StorageToGeometry call failed. Aborting\n",GetGMType(type));
      break;
      
    case 27: 
      sprintf(errmsg,"%s: fatal error:\n area gss->StorageToGeometry 2 call failed. Aborting\n",GetGMType(type));
      break;
      
    case 28: 
      sprintf(errmsg,"%s: fatal error:\n get_Points area call failed. Aborting.\n",GetGMType(type));
      break;
      
    case 29: 
      sprintf(errmsg,"%s: fatal error:\n get_Count area call failed. Aborting\n",GetGMType(type));
      break;
      
    case 30: 
      sprintf(errmsg,"%s: fatal error:\n get_Value call failed. Aborting\n",GetGMType(type));
      break;
      
    case 31: 
      sprintf(errmsg,"%s: fatal error:\n get_Value call failed. Aborting\n",GetGMType(type));
      break;


    case 32: 
      sprintf(errmsg,"%s: fatal error:\n holy_geom->get_Exterior fatal call failed. Aborting\n",GetGMType(type));
      break;
      
    case 33: 
      sprintf(errmsg,"%s: fatal error:\n external_area_geom->get_Points call failed. Aborting\n",GetGMType(type));
      break;
      
    case 34: 
      sprintf(errmsg,"%s: fatal error:\n get_Count external area call failed. Aborting\n",GetGMType(type));
      break;
      
    case 35: 
      sprintf(errmsg,"%s: fatal error:\n Item 1 area external call failed. Aborting\n",GetGMType(type));
      break;
      
    case 36: 
      sprintf(errmsg,"%s: fatal error:\n Item 2 area external call failed. Aborting\n",GetGMType(type));
      break;
      
    case 37: 
      sprintf(errmsg,"%s: fatal error:\n Item 1 area internal call failed\n",GetGMType(type));
      break;
            
    case 38: 
      sprintf(errmsg,"%s: fatal error:\n internal_area_geom->get_Point call failed.\n",GetGMType(type));
      break;

    case 39: 
      sprintf(errmsg,"%s: fatal error:\n Item 2 area internal call failed.\n",GetGMType(type));
      break;
      
    case 40: 
      sprintf(errmsg,"%s: fatal error:\n Item 3 area internal call failed.\n",GetGMType(type));
      break;
      
    case 41: 
      sprintf(errmsg,"%s: fatal error:\n linear get_Value call failed.\n",GetGMType(type));
      break;
      
    case 42: 
      sprintf(errmsg,"%s: fatal error:\n linear StorageToGeometry call failed.\n",GetGMType(type));
      break;
      
    case 43: 
      sprintf(errmsg,"%s: fatal error:\n linear get_Points call failed.\n",GetGMType(type));
      break;
      
    case 44: 
      sprintf(errmsg,"%s: fatal error:\n linear get_Count call failed.\n",GetGMType(type));
      break;
      
    case 45: 
      sprintf(errmsg,"%s: fatal error:\n linear Item 1 call failed.\n",GetGMType(type));
      break;

    case 46: 
      sprintf(errmsg,"%s: fatal error:\n linear Item 2 call failed.\n",GetGMType(type));
      break;
      
    case 47: 
      sprintf(errmsg,"%s: fatal error:\n point get_Value call failed.\n",GetGMType(type));
      break;
      
    case 48: 
      sprintf(errmsg,"%s: fatal error:\n point StorageToGeometry call failed.\n",GetGMType(type));
      break;
      
    case 49: 
      sprintf(errmsg,"%s: fatal error:\n point get_Origin call failed.\n",GetGMType(type));
      break;
      
    case 50: 
      sprintf(errmsg,"%s: fatal error:\n MoveNext  call failed.\n",GetGMType(type));
      break;

    case 51: 
      sprintf(errmsg,"%s: fatal error:\n get_EOF 2 call failed.\n",GetGMType(type));
      break;

    case 52: 
      printf("%s: fatal error:\n lRS->Close 7 call failed.\n",GetGMType(type));
      return;

    case 53: 
      printf("%s: fatal error:\n lConn->Disconnect 1 call failed.\n",GetGMType(type));
      return;
      
    case 54: 
      sprintf(errmsg,"%s: fatal error:\n lRS->Close 2 call failed.\n",GetGMType(type));
      break;
      
    case 55: 
      printf("%s: fatal error:\n lConn->Disconnect 2 call failed.\n",GetGMType(type));
      return;

	case 56: 
      sprintf(errmsg,"%s: fatal error:\n get_Value call (2) failed with %s. Aborting\n",GetGMType(type),errstr);
      break;
      
    case 57: 
      sprintf(errmsg,"%s: error:\n VariantClear call (2) failed with %s.\n",GetGMType(type),errstr);
      return;

    case 58: 
      sprintf(errmsg,"%s: error:\n pts->get_Count failed.\n",GetGMType(type));
      return;


    default:
      printf("unexpected %s error code %d\n",GetGMType(type),errnum);
      return;
    }


 not_while_running(drawing_a,errmsg,1388,"Geomedia import failure",5);

}






void InfoCallback(Widget widget, XtPointer client_data, XtPointer callData)
{
  static Widget thishead;
  Widget rowcol,this_text_output,button,form;
  Arg resources[20];
  int thispos=0,n;
  int min,max,slidesize,increment,Pincrement;
  Dimension y1;
  
  
  if(HELP_UP[0]==1)
   { 
     ResetWidget(thishead);
     return;
   }    
  

  n=0;
  num_highlights2 = 0;
  

  XtSetArg(resources[n],  XmNheight,      720);          n++;  
  XtSetArg(resources[n],  XmNwidth,       800);          n++;  

  XtSetArg(resources[n],  XmNdeleteResponse, XmDESTROY); n++;


  thishead = 
    XtCreatePopupShell("Information",topLevelShellWidgetClass,drawing_a,resources,n);
  
  
  rowcol = XtVaCreateManagedWidget
    (
     "XformWidget", xmPanedWindowWidgetClass, thishead,
     XmNrubberPositioning, False,
     XmNresizable,         True,
     XmNseparatorOn,       False,
     XmNsashHeight,        1,
     NULL
     );


  form = XtVaCreateWidget ("form7", xmFormWidgetClass, rowcol,
			   XmNfractionBase,  100,  
			   NULL);
  
  n = 0;
  XtSetArg(resources[n], XmNtopAttachment,          XmATTACH_FORM);     n++;
  XtSetArg(resources[n], XmNbottomAttachment,       XmATTACH_FORM);     n++;
  XtSetArg(resources[n], XmNleftAttachment,         XmATTACH_POSITION); n++;
  XtSetArg(resources[n], XmNleftPosition,           0);                 n++;
  XtSetArg(resources[n], XmNrightAttachment,        XmATTACH_POSITION); n++;
  XtSetArg(resources[n], XmNrightPosition,          100);               n++;
  XtSetArg(resources[n], XmNscrollBarDisplayPolicy, XmSTATIC);          n++;
  XtSetArg(resources[n], XmNrubberPositioning,      False);             n++;
  XtSetArg(resources[n], XmNresizable,              True);              n++;
  XtSetArg(resources[n], XmNrows,                   40);                n++;
  XtSetArg(resources[n], XmNcolumns,                30);                n++;
  XtSetArg(resources[n], XmNeditable,               False);             n++;
  XtSetArg(resources[n], XmNeditMode,               XmMULTI_LINE_EDIT); n++;
  XtSetArg(resources[n], XmNwordWrap,               True);              n++;
  XtSetArg(resources[n], XmNcursorPositionVisible,  False);             n++;
  XtSetArg(resources[n], XmNscrollHorizontal,       False);             n++; 
  XtSetArg(resources[n], XmNtranslations,  XtParseTranslationTable (list_translations10));  n++;




  this_text_output = XmCreateScrolledText(form, "text_output2", resources, n);
  
  XtAddCallback(this_text_output,XmNmotionVerifyCallback,ReDrawHighlightedStuff,(XtPointer)1);
  XtAddCallback(this_text_output,XmNfocusCallback,       ReDrawHighlightedStuff,(XtPointer)1);
  XtAddCallback(this_text_output,XmNlosingFocusCallback, ReDrawHighlightedStuff,(XtPointer)1);
  
  XtManageChild (this_text_output);
  XtManageChild(form); 







  form = XtVaCreateWidget ("form7", xmFormWidgetClass, rowcol,
			   XmNpaneMinimum,  25,
			   XmNpaneMaximum,  25,			   XmNfractionBase,  100,  
			   NULL);
  

  button  = XtVaCreateManagedWidget("SCR33",xmPushButtonWidgetClass,form,
				    XmNlabelString, STRING("Done"),
				    
				    XmNrightAttachment,  XmATTACH_POSITION,
				    XmNrightPosition,    100,
				    XmNleftAttachment,   XmATTACH_POSITION,
				    XmNleftPosition,     1,
				    XmNtraversalOn,      False,
				    XmNtranslations, XtParseTranslationTable ( translations_global ) ,
				    NULL
				    ); 
  
  XtAddCallback(button, XmNactivateCallback, die_callback, (XtPointer) 1013);
  XtManageChild(button); 
  XtManageChild(form); 
  










  thispos = AddBold(this_text_output,thispos,"Condition type selection:\n");
  thispos = AddReg (this_text_output,thispos,"The toggle button labeled with each condition instace's name is used to toggle whether or not that condition instance will be computed when inspecting.\n\n");
  
  thispos = AddBold(this_text_output,thispos,"Definition:\n");
  thispos = AddReg (this_text_output,thispos,"Clicking the \"Definition\" button associated with an inspection instance will give a brief definition of that inspection.\n\n");
  
  thispos = AddBold(this_text_output,thispos,"Applicability:\n");
  thispos = AddReg (this_text_output,thispos,"Clicking the \"Applicability\" button associated with an inspection instance will allow you to set the data elements that inspection instance will be applied to when checking.\n\n");
  
  thispos = AddBold(this_text_output,thispos,"Tolerance:\n");
  thispos = AddReg (this_text_output,thispos,"Clicking the \"Tolerance\" button associated with an inspection instance will allow you to set any parameters associated with that inspection instance.\n\n");
  
  thispos = AddBold(this_text_output,thispos,"Create new Instantiation:\n");
  thispos = AddReg (this_text_output,thispos,"Clicking the \"Create new Instantiation\" button associated with an inspection instance will create a new instance of that inspection type.  This allows the same inspection type to be configured many different ways.  For instance, one could look for Road Undershoots and River Undershoots using 2 separate instances of the \"Line - Line Undershoot\" inspection.\n\n");

  thispos = AddBold(this_text_output,thispos,"De-Select all instances of this inspection:\n");
  thispos = AddReg (this_text_output,thispos,"Clicking the \"De-Select all instances of this inspection\" button associated with an inspection instance will de-activate (turn off) all instances of that inspection type.\n\n");  

  thispos = AddBold(this_text_output,thispos,"De-Select ALL:\n");
  thispos = AddReg (this_text_output,thispos,"Clicking the \"De-Select ALL\" button causes all inspection instances to be deactivated.\n\n");

  thispos = AddBold(this_text_output,thispos,"Revert to Defaults:\n");
  thispos = AddReg (this_text_output,thispos,"Clicking the \"Revert to Defaults\" button causes all inspection options to revert to their default state.\n\n");
  





  if(NGA_TYPE==1)
    {
      
  }
  else
    {
      thispos = AddBold(this_text_output,thispos,"Absolute Accuracy:\n");
      thispos = AddReg (this_text_output,thispos,"If set, computations will use the full precision in the data. If not set, only the number of decimal places deemed appropriate by SEE-IT will be used.\n\n");
    }

  thispos = AddBold(this_text_output,thispos,"All Regions:\n");
  thispos = AddReg (this_text_output,thispos,"Used to perform inspections for ALL regions in the project. If All Regions is NOT specified, the user must select regions to be inspected by drawing a rectangle containing them in the drawing window.\n\n");


  thispos = AddBold(this_text_output,thispos,"Load/Save settings:\n");
  thispos = AddReg (this_text_output,thispos,"Used to load and save inspection settings to file.\n\n");

  
  thispos = AddBold(this_text_output,thispos,"Mark results using exported shapefiles in project:\n");
  thispos = AddReg (this_text_output,thispos,"This option is used to instruct GAIT to:\n  1.  When inspecting a project, consider a set of previously exported shapefiles in some (possibly different) project.\n  2.  Attempt to determine if a previously marked IGNORE condition (in the exported shapefiles) has been discovered again when inspecting.\n  3.  If GAIT determines that there is enough similarity between a previously exported condition marked IGNORE in the exported shapefiles and a condition it has just discovered, GAIT will mark the newly discovered condition as IGNORE automatically."); 


  


  XtManageChild (rowcol);
  MyPopup(thishead);

  XtVaGetValues (thishead, XmNheight,   &y1, NULL);
  XtVaSetValues (thishead, XmNmaxHeight, y1, NULL);
  

  XtAddCallback(this_text_output,XmNdestroyCallback,ShellDeath,(XtPointer)(400));
  HELP_UP[0] = 1;
  




  XtVaGetValues(XtParent(this_text_output),XmNverticalScrollBar,  &vert_scroll[EXEHELP_SCROLL],NULL);
  
  XtVaGetValues(vert_scroll[EXEHELP_SCROLL],
		XmNminimum,      &min,
		XmNmaximum,      &max,
		XmNsliderSize,   &slidesize,
		XmNincrement,    &increment,
		XmNpageIncrement,&Pincrement,
		NULL);
  
  XmScrollBarSetValues(vert_scroll[EXEHELP_SCROLL],
		       min,
		       slidesize,
		       increment,
		       Pincrement,
		       1);





}











int find_col_index()
{
  XColor mycolor;
  int num1, num2, num3;

  
  
  mycolor.red   = 34567;
  mycolor.green = 12345;
  mycolor.blue  = 23456;
  
  if (!XAllocColor (mydisplay, cmap, &mycolor)) 
    {
      printf("couldn't XAlloc a color...continuing, but things may look screwey...\n"); 
    }

  num1 = mycolor.pixel;



  if(num1>256)
    {
      return 256;
    }
  
  mycolor.red   = 45678;
  mycolor.green = 23456;
  mycolor.blue  = 34567;
  
  if (!XAllocColor (mydisplay, cmap, &mycolor)) 
    {
      printf("couldn't XAlloc a color...continuing, but things may look screwey...\n"); 
    }
  num2 = mycolor.pixel;



  if(num2>256)
    {
      return 256;
    }
 
  if(num2<(num1+1))
    {
      return num1;
    }
  if(num2>(num1+1))
    {
      return num2;
    }

  
  mycolor.red   = 56789;
  mycolor.green = 45678;
  mycolor.blue  = 12345;
  
  if (!XAllocColor (mydisplay, cmap, &mycolor)) 
    {
      printf("couldn't XAlloc a color...continuing, but things may look screwey...\n"); 
    }
  num3 = mycolor.pixel;



  if(num3>256)
    {
      return 256;
    }
 
  if(num3==(num2+1))
    {
      return num1;
    }

  return num2;
}



void AllocateExtraColors()
{
  int i,startcol1,startcol2,startcol3;  
  double modifier = 0.0; 
  double modifier2 = -1.0; 
  XColor mycolor;
  extern int DrawColorFill,USE_GREY;


  if((DrawColorFill==0)&&(USE_GREY<=1))
  {
    return;
  }


  if((DrawColorFill==1)&&(ContourColorsAllocated==0))
  {
    printf("Allocating color contour colors\n");

    startcol1 = 0;
    startcol2 = 0;
    startcol3 = 128;
    for(i=0;i<SHADES_PER_BIN;i++)
	{
      mycolor.red   = 255*(startcol1 + (int)((255-startcol1)*(i/(SHADES_PER_BIN-modifier))));
      mycolor.green = 255*(startcol2 + (int)((255-startcol2)*(i/(SHADES_PER_BIN-modifier))));
      mycolor.blue  = 255*(startcol3 + (int)((255-startcol3)*(i/(SHADES_PER_BIN-modifier))));
 
      if (!XAllocColor (mydisplay, cmap, &mycolor)) 
	  {printf("couldn't XAlloc a color...continuing, but things may look screwey...\n"); }
      
      ColorBin1[i]   = mycolor.pixel;
	} 


    startcol1 = 0;
    startcol2 = 128;
    startcol3 = 0;
    for(i=0;i<SHADES_PER_BIN;i++)
	{
      mycolor.red   = 255*(startcol1 + (int)((255-startcol1)*(i/(SHADES_PER_BIN-modifier))));
      mycolor.green = 255*(startcol2 + (int)((255-startcol2)*(i/(SHADES_PER_BIN-modifier))));
      mycolor.blue  = 255*(startcol3 + (int)((255-startcol3)*(i/(SHADES_PER_BIN-modifier))));
 
      if (!XAllocColor (mydisplay, cmap, &mycolor)) 
	  {printf("couldn't XAlloc a color...continuing, but things may look screwey...\n"); }
      
      ColorBin2[i]   = mycolor.pixel;
	} 


    startcol1 = 128;
    startcol2 = 0;
    startcol3 = 0;
    for(i=0;i<SHADES_PER_BIN;i++)
	{ 
      mycolor.red   = 255*(startcol1 + (int)((255-startcol1)*(i/(SHADES_PER_BIN-modifier))));
      mycolor.green = 255*(startcol2 + (int)((255-startcol2)*(i/(SHADES_PER_BIN-modifier))));
      mycolor.blue  = 255*(startcol3 + (int)((255-startcol3)*(i/(SHADES_PER_BIN-modifier))));
 
      if (!XAllocColor (mydisplay, cmap, &mycolor)) 
	  {printf("couldn't XAlloc a color...continuing, but things may look screwey...\n"); }
      
      ColorBin3[i]   = mycolor.pixel;
	} 


    startcol1 = 128;
    startcol2 = 128; 
    startcol3 = 0;
    for(i=0;i<SHADES_PER_BIN;i++)
	{
      mycolor.red   = 255*(startcol1 + (int)((255-startcol1)*(i/(SHADES_PER_BIN-modifier2))));
      mycolor.green = 255*(startcol2 + (int)((255-startcol2)*(i/(SHADES_PER_BIN-modifier2))));
      mycolor.blue  = 255*(startcol3 + (int)((255-startcol3)*(i/(SHADES_PER_BIN-modifier2))));
 
      if (!XAllocColor (mydisplay, cmap, &mycolor)) 
	  {printf("couldn't XAlloc a color...continuing, but things may look screwey...\n"); }
      
      ColorBin4[i]   = mycolor.pixel;
	} 


    startcol1 = 128;
    startcol2 = 28;   
    startcol3 = 128;
    for(i=0;i<SHADES_PER_BIN;i++)
	{ 
      mycolor.red   = 255*(startcol1 + (int)((255-startcol1)*(i/(SHADES_PER_BIN-modifier2))));
      mycolor.green = 255*(startcol2 + (int)((255-startcol2)*(i/(SHADES_PER_BIN-modifier2))));
      mycolor.blue  = 255*(startcol3 + (int)((255-startcol3)*(i/(SHADES_PER_BIN-modifier2))));
	   
      if (!XAllocColor (mydisplay, cmap, &mycolor)) 
	  {printf("couldn't XAlloc a color...continuing, but things may look screwey...\n"); }
      
      ColorBin5[i]   = mycolor.pixel;
	} 
 
    ContourColorsAllocated = 1;
  }


  if((USE_GREY>1)&&(ExtraGraysAllocated==0))
  {

    for(i=0;i<=255;i+=8)
    {
      mycolor.red   = 255*i;
      mycolor.green = 0;
      mycolor.blue  = 0;
      if (!XAllocColor (mydisplay, cmap, &mycolor)) 
	  {printf("couldn't XAlloc a color...continuing, but things may look screwey...\n"); }

      col2[i]   = mycolor.pixel;
      col2[i+1] = mycolor.pixel;
      col2[i+2] = mycolor.pixel;
      col2[i+3] = mycolor.pixel;
      col2[i+4] = mycolor.pixel;
      col2[i+5] = mycolor.pixel;
      col2[i+6] = mycolor.pixel;
      col2[i+7] = mycolor.pixel;


      mycolor.red   = 0;
      mycolor.green = 255*i;
      mycolor.blue  = 0;
      if (!XAllocColor (mydisplay, cmap, &mycolor)) 
	  {printf("couldn't XAlloc a color...continuing, but things may look screwey...\n"); }

      col3[i]   = mycolor.pixel;
      col3[i+1] = mycolor.pixel;
      col3[i+2] = mycolor.pixel;
      col3[i+3] = mycolor.pixel;
      col3[i+4] = mycolor.pixel;
      col3[i+5] = mycolor.pixel;
      col3[i+6] = mycolor.pixel;
      col3[i+7] = mycolor.pixel;


      mycolor.red   = 0;
      mycolor.green = 0;
      mycolor.blue  = 255*i;
      if (!XAllocColor (mydisplay, cmap, &mycolor)) 
	  {printf("couldn't XAlloc a color...continuing, but things may look screwey...\n"); }

      col4[i]   = mycolor.pixel;
      col4[i+1] = mycolor.pixel;
      col4[i+2] = mycolor.pixel;
      col4[i+3] = mycolor.pixel;
      col4[i+4] = mycolor.pixel;
      col4[i+5] = mycolor.pixel;
      col4[i+6] = mycolor.pixel;
      col4[i+7] = mycolor.pixel;
	} 
    ExtraGraysAllocated = 1;
  }

}



void Greyit()
{
  int i;
  XColor mycolor;


  for(i=0;i<=255;i=i+8)
    {
      mycolor.red   = 255*i;
      mycolor.green = 255*i;
      mycolor.blue  = 255*i;
      
      if (!XAllocColor (mydisplay, cmap, &mycolor)) 
	{printf("couldn't XAlloc a color...continuing, but things may look screwey...\n"); }
      
      col[i]   = mycolor.pixel;
      col[i+1] = mycolor.pixel;
      col[i+2] = mycolor.pixel;
      col[i+3] = mycolor.pixel;
      col[i+4] = mycolor.pixel;
      col[i+5] = mycolor.pixel;
      col[i+6] = mycolor.pixel;
      col[i+7] = mycolor.pixel;
     }

  
  for(i=0;i<300;i++)
    {
      mycolors[i]= col[128];   
    }
  
  
  mycolor.red   = RED_R;
  mycolor.green = RED_G;
  mycolor.blue  = RED_B;
  
  if (!XAllocColor (mydisplay, cmap, &mycolor)) 
    {
      printf("couldn't XAlloc a color...continuing, but things may look screwey...\n"); 
    }
  mycolors[DRAW_COLOR_RED]   = mycolor.pixel;
  mycolors[2]   = mycolors[DRAW_COLOR_RED];
  mycolors[299] = mycolors[DRAW_COLOR_RED];
  
  



  mycolor.red   = MEDGREEN_R;
  mycolor.green = MEDGREEN_G;
  mycolor.blue  = MEDGREEN_B;
  
  if (!XAllocColor (mydisplay, cmap, &mycolor)) 
    {
      printf("couldn't XAlloc a color...continuing, but things may look screwey...\n"); 
    }
  mycolors[DRAW_COLOR_MEDGREEN] = mycolor.pixel;  
  mycolors[26] = mycolor.pixel;  
  




  mycolor.red   = LTGREEN_R;
  mycolor.green = LTGREEN_G;
  mycolor.blue  = LTGREEN_B;
  
  if (!XAllocColor (mydisplay, cmap, &mycolor)) 
    {
      printf("couldn't XAlloc a color...continuing, but things may look screwey...\n"); 
    }
  mycolors[DRAW_COLOR_LTGREEN] = mycolor.pixel;  
  



  mycolor.red   = YELLOW_R;
  mycolor.green = YELLOW_G;
  mycolor.blue  = YELLOW_B;
  
  if (!XAllocColor (mydisplay, cmap, &mycolor)) 
    {
      printf("couldn't XAlloc a color...continuing, but things may look screwey...\n"); 
    } 
  mycolors[DRAW_COLOR_YELLOW] = mycolor.pixel;
  



  mycolor.red   = DKCYAN_R;
  mycolor.green = DKCYAN_G;
  mycolor.blue  = DKCYAN_B;
  
  if (!XAllocColor (mydisplay, cmap, &mycolor)) 
    {
      printf("couldn't XAlloc a color...continuing, but things may look screwey...\n"); 
    }
  mycolors[DRAW_COLOR_DKCYAN] = mycolor.pixel;


  
  mycolor.red   = LTCYAN_R;
  mycolor.green = LTCYAN_G;
  mycolor.blue  = LTCYAN_B;
  
  if (!XAllocColor (mydisplay, cmap, &mycolor)) 
    {
      printf("couldn't XAlloc a color...continuing, but things may look screwey...\n"); 
    }
  mycolors[DRAW_COLOR_LTCYAN] = mycolor.pixel;
  
  for(i=31;i<=39;i++)
    {
      mycolors[i] = mycolors[DRAW_COLOR_LTCYAN];
    }
  


  mycolor.red   = PURPLE_R;
  mycolor.green = PURPLE_G;
  mycolor.blue  = PURPLE_B;
  
  if (!XAllocColor (mydisplay, cmap, &mycolor)) 
    {
      printf("couldn't XAlloc a color...continuing, but things may look screwey...\n"); 
    }
  mycolors[DRAW_COLOR_PURPLE] = mycolor.pixel;
  


  
  mycolors[DRAW_COLOR_BLACK] = col[0];


  
  
  mycolor.red   = LAVENDER_R;
  mycolor.green = LAVENDER_G;
  mycolor.blue  = LAVENDER_B;
  
  if (!XAllocColor (mydisplay, cmap, &mycolor)) 
    {
      printf("couldn't XAlloc a color...continuing, but things may look screwey...\n"); 
    }
  mycolors[DRAW_COLOR_LAVENDER] = mycolor.pixel;
  



  
  mycolor.red   = BROWN_R;
  mycolor.green = BROWN_G;
  mycolor.blue  = BROWN_B;
  
  if (!XAllocColor (mydisplay, cmap, &mycolor)) 
    {
      printf("couldn't XAlloc a color...continuing, but things may look screwey...\n"); 
    }
  mycolors[DRAW_COLOR_BROWN] = mycolor.pixel;





  mycolor.red   = ORANGE_R;
  mycolor.green = ORANGE_G;
  mycolor.blue  = ORANGE_B;
  
  if (!XAllocColor (mydisplay, cmap, &mycolor)) 
    {
      printf("couldn't XAlloc a color...continuing, but things may look screwey...\n"); 
    }
  mycolors[DRAW_COLOR_ORANGE]   = mycolor.pixel;

  
 



  
  mycolor.red   = TAN_R;
  mycolor.green = TAN_G;
  mycolor.blue  = TAN_B;
  
  if (!XAllocColor (mydisplay, cmap, &mycolor)) 
    {
      printf("couldn't XAlloc a color...continuing, but things may look screwey...\n"); 
    }
  mycolors[DRAW_COLOR_TAN] = mycolor.pixel;
  



  mycolor.red   = BLUE_R;
  mycolor.green = BLUE_G;
  mycolor.blue  = BLUE_B;
  
  if (!XAllocColor (mydisplay, cmap, &mycolor)) 
    {
      printf("couldn't XAlloc a color...continuing, but things may look screwey...\n"); 
    }
  mycolors[DRAW_COLOR_BLUE] = mycolor.pixel;
  mycolors[60] = mycolors[DRAW_COLOR_BLUE];
  mycolors[61] = mycolors[DRAW_COLOR_BLUE];
  mycolors[DRAW_COLOR_GRAY4] = col[100];
  mycolors[58] = mycolors[DRAW_COLOR_GRAY4];
  
  


  mycolor.red   = MAGENTA_R;
  mycolor.green = MAGENTA_G;
  mycolor.blue  = MAGENTA_B;
  
  if (!XAllocColor (mydisplay, cmap, &mycolor)) 
    {
      printf("couldn't XAlloc a color...continuing, but things may look screwey...\n"); 
    }
  
  mycolors[DRAW_COLOR_MAGENTA] = mycolor.pixel;




  mycolor.red   = SALMON_R;
  mycolor.green = SALMON_G;
  mycolor.blue  = SALMON_B;
  
  if (!XAllocColor (mydisplay, cmap, &mycolor)) 
    {
      printf("couldn't XAlloc a color...continuing, but things may look screwey...\n"); 
    }
  
  mycolors[DRAW_COLOR_SALMON] = mycolor.pixel;



  

  mycolor.red   = MEDGREEN2_R;
  mycolor.green = MEDGREEN2_G;
  mycolor.blue  = MEDGREEN2_B;
  
  if (!XAllocColor (mydisplay, cmap, &mycolor)) 
    {
      printf("couldn't XAlloc a color...continuing, but things may look screwey...\n"); 
    }
  mycolors[DRAW_COLOR_MEDGREEN2] = mycolor.pixel;
  

  mycolor.red   = WHITE_R;
  mycolor.green = WHITE_G;
  mycolor.blue  = WHITE_B;
  
  if (!XAllocColor (mydisplay, cmap, &mycolor)) 
    {
      printf("couldn't XAlloc a color...continuing, but things may look screwey...\n"); 
    }
  mycolors[DRAW_COLOR_WHITE] = mycolor.pixel;



  mycolors[DRAW_COLOR_GRAY64]  = col[64];
  mycolors[DRAW_COLOR_GRAY128] = col[128];
  mycolors[DRAW_COLOR_GRAY192] = col[192];


}


void realquitCallback(Widget widget, XtPointer userData, XtPointer callData)
{
  int i,axis,ADDER,config_num,layer_num;
  struct IMarkList *prev,*curr;
  struct IMarkSACList *prev2,*curr2;



  if(output_source==1)
  {
	
    zerooutCallback((Widget)NULL, (XtPointer)1, (XtPointer) 0);
  }




  DeleteAOIList();

   
  ScrubModelIndices(1,0);

   
  
  FreeMarkerList();

   
  
  ScrubALLEDCSMarkerLists(1,0);

   
  GetRidOfAllClones(0);




  if(DEBUG==1)
    {
      printf("freeing up memory...\n");
    }

  
  
  FreeMemoryAsExit(1);

  
  
  if(SCC_LIST_INNITTED==1)        
  {
    free(SCC_LIST);
  }


  if(DYNAMIC_SCC_LIST_INNITTED==1)
  {
    free(DYNAMIC_SCC_LIST);
  }
  

  
  
  if(LODS_INNITTED==1)
  {
    free(LOD);
  }
  

  
  if(SCCARRAYBUILT==1)
    {
      for(i=1;i<SCCARRAY_INDICES;i++)
	{
	  free(SCCARRAY[i].scc);
	  free(SCCARRAY[i].sccname);
	  free(SCCARRAY[i].lowdesc);
	  free(SCCARRAY[i].desc);
	}
      free(SCCARRAY);
    }

  
  if(SACARRAYBUILT==1)
    {
      for(i=1;i<SACARRAY_INDICES;i++)
	{
	  free(SACARRAY[i].sac);
	  free(SACARRAY[i].sacname);
	  free(SACARRAY[i].lowdesc);
	  free(SACARRAY[i].desc);      
	  if(SACARRAY[i].lowenumlab!=NULL)
	    {
	      free(SACARRAY[i].lowenumlab);
	    }
	  if(SACARRAY[i].lowenumdef!=NULL)
	    {
	      free(SACARRAY[i].lowenumdef);
	    }
	  if(SACARRAY[i].enums!=NULL)
	    {
	      free(SACARRAY[i].enums);
	    }
	}
      free(SACARRAY);
    }



  for(i=0;i<=CONDITION_DEFINITIONS;i++)
    {
      if(ErrorLookup[i].primaryEDCSstuff!=NULL)
	  { 
	   free(ErrorLookup[i].primaryEDCSstuff);
	   ErrorLookup[i].primaryEDCSstuff = NULL;
	  }  
      if(ErrorLookup[i].secondaryEDCSstuff!=NULL)
	  { 
	   free(ErrorLookup[i].secondaryEDCSstuff);
	   ErrorLookup[i].secondaryEDCSstuff = NULL;
	  }  
      if(ErrorLookup[i].tertiaryEDCSstuff!=NULL)
	  { 
	   free(ErrorLookup[i].tertiaryEDCSstuff);
	   ErrorLookup[i].tertiaryEDCSstuff = NULL;
	  }


      if(ErrorLookup[i].primaryFIDstuff!=NULL)
	  { 
	   free(ErrorLookup[i].primaryFIDstuff);
	   ErrorLookup[i].primaryFIDstuff = NULL;
	  }  
      if(ErrorLookup[i].secondaryFIDstuff!=NULL)
	  { 
	   free(ErrorLookup[i].secondaryFIDstuff);
	   ErrorLookup[i].secondaryFIDstuff = NULL;
	  }  
      if(ErrorLookup[i].tertiaryFIDstuff!=NULL)
	  { 
	   free(ErrorLookup[i].tertiaryFIDstuff);
	   ErrorLookup[i].tertiaryFIDstuff = NULL;
	  }
	  

      if(ErrorLookup[i].Annotation!=NULL)
	  { 
	  free(ErrorLookup[i].Annotation);
	  }  
    }


  if(CloneErrorLookup!=NULL)
    {
      for(i=0;i<CLONE_DEFINITIONS;i++)
	{
	  if(CloneErrorLookup[i].Annotation!=NULL)
	    {
	      free(CloneErrorLookup[i].Annotation);
	    }

	  if(CloneErrorLookup[i].primaryEDCSstuff!=NULL)
	    {
	      free(CloneErrorLookup[i].primaryEDCSstuff);
	      CloneErrorLookup[i].primaryEDCSstuff = NULL;
	    }
	  if(CloneErrorLookup[i].secondaryEDCSstuff!=NULL)
	    {
	      free(CloneErrorLookup[i].secondaryEDCSstuff);
	      CloneErrorLookup[i].secondaryEDCSstuff = NULL;
	    }
	  if(CloneErrorLookup[i].tertiaryEDCSstuff!=NULL)
	    {
	      free(CloneErrorLookup[i].tertiaryEDCSstuff);
	      CloneErrorLookup[i].tertiaryEDCSstuff = NULL;
	    }
	    
	  if(CloneErrorLookup[i].primaryFIDstuff!=NULL)
	    {
	      free(CloneErrorLookup[i].primaryFIDstuff);
	      CloneErrorLookup[i].primaryFIDstuff = NULL;
	    }
	  if(CloneErrorLookup[i].secondaryFIDstuff!=NULL)
	    {
	      free(CloneErrorLookup[i].secondaryFIDstuff);
	      CloneErrorLookup[i].secondaryFIDstuff = NULL;
	    }
	  if(CloneErrorLookup[i].tertiaryFIDstuff!=NULL)
	    {
	      free(CloneErrorLookup[i].tertiaryFIDstuff);
	      CloneErrorLookup[i].tertiaryFIDstuff = NULL;
	    }

	  
	  if(CloneErrorLookup[i].keepdismiss!=NULL)
	    {
	      free(CloneErrorLookup[i].keepdismiss);
	      CloneErrorLookup[i].keepdismiss = NULL;
	    }
	  
	  
	  for(axis=1;axis<=3;axis++)
	    {
	      for(ADDER=0;ADDER<=1;ADDER++)
		  {
		    for(config_num=0;config_num<NUM_C;config_num++)
		    {

		      if(CloneErrorLookup[i].IMarkRoot[axis][ADDER][config_num]!=NULL)
			  {
			    curr = CloneErrorLookup[i].IMarkRoot[axis][ADDER][config_num];
			    while(curr!=NULL)
			    {
			      prev = curr;
			      curr = curr->next;
			      free(prev);
			    }
			  } 


		      if(CloneErrorLookup[i].IMarkSACRoot[axis][ADDER][config_num]!=NULL)
			  {
			    curr2 = CloneErrorLookup[i].IMarkSACRoot[axis][ADDER][config_num];

			    while(curr2!=NULL)
			    {
			      prev2 = curr2;
			      curr2 = curr2->next;

				  if(prev2->EEindex==-2)
				  {
					if(prev2->saveval!=NULL)  
					{
                      free(prev2->saveval);
					}
				  }
			      free(prev2);
			    }
			  } 
			} 
		  } 
	    }

	  if(CloneErrorLookup[i].pos_list_made>0)
	    {
	      free(CloneErrorLookup[i].pos_list);
	      CloneErrorLookup[i].pos_list_made = 0;
	    }
	}
      free(CloneErrorLookup);
    }
  


 




  FreeLLTable();
     

  if(FidMarkTable!=NULL)
  {
    free(FidMarkTable);
    FidMarkTable = NULL;
  }

  
  XFreePixmap(mydisplay, pixmap);
  XFreePixmap(mydisplay, pixmap2);
  XFreePixmap(mydisplay, pixmap3);
  XFreePixmap(mydisplay, clean_pixmap);
  XFreePixmap(mydisplay, Profile_pix);
  XFreePixmap(mydisplay, ERROR_BITMAP);
  

  
  for(i=0;i<NUM_DRAWING_PIXMAPS;i++)
    {
      XFreePixmap(mydisplay, DRAWING_PIXMAPS[i]);
      XFreePixmap(mydisplay, DRAWING_CLIPMAPS[i]);
    }

  
  for(i=0;i<NUM_STIPMAPS;i++)
    {
      XFreePixmap(mydisplay, stipmapstypes[i]);
    }

  
  for(layer_num=0;layer_num<NumLODbands;layer_num++)
    {
      if(layer_colorpix[layer_num]!=123987517)
	{
	  XFreePixmap(mydisplay,layer_colorpix[layer_num]);
	}
    }

  
  XFreePixmap(mydisplay, stipmap_lgt);
  XFreePixmap(mydisplay, stipmap_avg);
  XFreePixmap(mydisplay, stipmap_hvy);
  
  if(DynLodMade==1)
    {
      free(LODindex_DYN);
    }
  
  XFreeColors(mydisplay,cmap,mycolors,300,XAllPlanes());


 if(ContourColorsAllocated==1)
  {
    XFreeColors(mydisplay,cmap,ColorBin1,SHADES_PER_BIN,XAllPlanes());
    XFreeColors(mydisplay,cmap,ColorBin2,SHADES_PER_BIN,XAllPlanes());
    XFreeColors(mydisplay,cmap,ColorBin3,SHADES_PER_BIN,XAllPlanes());
    XFreeColors(mydisplay,cmap,ColorBin4,SHADES_PER_BIN,XAllPlanes());
    XFreeColors(mydisplay,cmap,ColorBin5,SHADES_PER_BIN,XAllPlanes());
  }

  if(ExtraGraysAllocated==1)
  {
    printf("Freeing extra shades\n");

    XFreeColors(mydisplay,cmap,col2,300,XAllPlanes());
    XFreeColors(mydisplay,cmap,col3,300,XAllPlanes());
    XFreeColors(mydisplay,cmap,col4,300,XAllPlanes());
  }



















  XmFontListFree(fontlist);
  
  if(Drawpoints!=NULL)
    {
      free(Drawpoints);
    }
  
  if(XNEW4!=NULL)
    {
      free(XNEW4);
    }

  if(YNEW4!=NULL)
    {
      free(YNEW4);
    }
  


 if(layers_innitted==1)
    {
      free(layers_up);
      free(layer_colors);
      free(layer_colorwindows);
      free(layer_colorpix);
      free(toplevel);
      free(scale1);
      free(scale2);
      free(scale3);
      free(layer_text1);
      free(layer_text2);
      free(layer_text3);
    }

  
  XFreeGC(mydisplay,mygc);
  XFreeGC(mydisplay,mybitgc);



  
  ExitWrapper(1);
}



void Atom1Callback(Widget widget, XtPointer userData, XtPointer callData)
{
  
}

void Atom2Callback(Widget widget, XtPointer userData, XtPointer callData)
{
  
}



void RealChooseTrex(Widget parent,int select_num)
{
  user_trex_cell = select_num;

  

  ngainfileCallback(parent,(XtPointer)1,(XtPointer)NULL);

}



void chooseTrexCellCallback0(Widget widget, Widget parent, XtPointer callData)
{
  
  XtPopdown(XtParent(XtParent(XtParent(widget))));
  XtDestroyWidget(XtParent(XtParent(XtParent(widget))));
  RealChooseTrex(parent,0);
}
void chooseTrexCellCallback1(Widget widget, Widget parent, XtPointer callData)
{
  
  XtPopdown(XtParent(XtParent(XtParent(widget))));
  XtDestroyWidget(XtParent(XtParent(XtParent(widget))));
  RealChooseTrex(parent,1);
}
void chooseTrexCellCallback2(Widget widget, Widget parent, XtPointer callData)
{
  
  XtPopdown(XtParent(XtParent(XtParent(widget))));
  XtDestroyWidget(XtParent(XtParent(XtParent(widget))));
  RealChooseTrex(parent,2);
}
void chooseTrexCellCallback3(Widget widget, Widget parent, XtPointer callData)
{
  
  XtPopdown(XtParent(XtParent(XtParent(widget))));
  XtDestroyWidget(XtParent(XtParent(XtParent(widget))));
  RealChooseTrex(parent,3);
}



void quitCallback(Widget widget, XtPointer userData, XtPointer callData)
{
  
  Widget dialog;
  XmString mystring;


  dialog = XmCreateQuestionDialog (drawing_a, "Quit", NULL,(Cardinal)NULL);
  XtAddCallback (dialog, XmNokCallback, realquitCallback, NULL);
  
  if(NGA_TYPE==1)
    {
	  if((UnsavedConditions==1)&&(unsavedignore==0))
	  {
		mystring = XmStringCreateLtoR("Unsaved conditions exist.\n\nQuit GAIT?",XmSTRING_DEFAULT_CHARSET);

        XtVaSetValues (dialog,
		     XmNmessageString,     mystring,
		     XmNhelpLabelString,   STRING("Save Condition Report"),
		     XmNokLabelString,     STRING("Quit GAIT"),
		     XmNdialogTitle,       STRING("Quit?"),
		     NULL);

        XtAddCallback (dialog, XmNhelpCallback, SavereportCallback, NULL);
	  }
	  else if((UnsavedConditions==0)&&(unsavedignore==1))
	  {
		mystring = XmStringCreateLtoR("Unsaved retain/ignore settings exist.\n\nQuit GAIT?",XmSTRING_DEFAULT_CHARSET);

        XtVaSetValues (dialog,
		     XmNmessageString,     mystring,
		     XmNhelpLabelString,   STRING("Save Condition Report"),
		     XmNokLabelString,     STRING("Quit GAIT"),
		     XmNdialogTitle,       STRING("Quit?"),
		     NULL);

        XtAddCallback (dialog, XmNhelpCallback, SavereportCallback, NULL);
	  }
	  else if((UnsavedConditions==1)&&(unsavedignore==1))
	  {
		mystring = XmStringCreateLtoR("Unsaved conditions and retain/ignore settings exist.\n\nQuit GAIT?",XmSTRING_DEFAULT_CHARSET);

        XtVaSetValues (dialog,
		     XmNmessageString,     mystring,
		     XmNhelpLabelString,   STRING("Save Condition Report"),
		     XmNokLabelString,     STRING("Quit GAIT"),
		     XmNdialogTitle,       STRING("Quit?"),
		     NULL);

        XtAddCallback (dialog, XmNhelpCallback, SavereportCallback, NULL);
	  }
	  else
	  {
        XtUnmanageChild (XmMessageBoxGetChild (dialog, XmDIALOG_HELP_BUTTON));

        XtVaSetValues (dialog,
		     XmNmessageString,     STRING("Quit GAIT?"),
		     XmNcancelLabelString, STRING("No"),
		     XmNokLabelString,     STRING("Yes"),
		     XmNdialogTitle,       STRING("Quit?"),
		     NULL);
	  }
    }
  else
    {
      XtVaSetValues (dialog,
		     XmNmessageString,     STRING("Quit SEE-IT?"),
		     XmNcancelLabelString, STRING("No"),
		     XmNokLabelString,     STRING("Yes"),
		     XmNdialogTitle,       STRING("Quit?"),
		     NULL);
    }
  XtManageChild (dialog);
  XtPopup(XtParent(dialog),XtGrabNone);
}




void make_los_message(char ff[],int bb,char *cc,int dd)
{
  not_while_running(drawing_a,ff,bb,cc,dd);
}




void Help_fc_errCallback(Widget w,XtPointer data,XtPointer callData)
{
  not_while_running(w,"This window is used to select condition instances\n\
to filter (remove) from the \"View Conditions By Feature\" display.\n\
Selecting the \"Select for filtering out\" option associated with\n\
a condition instance \"marks\" it to be filtered out.  Selecting the\n\
\"Apply filters\" button on the \"View Conditions By Feature\" window\n\
applys these selections, removing conditions which were marked\n\
for filtering.",1390,"Condition Type Filtering Help",5);
}





void Help_errCallback(Widget w,XtPointer data,XtPointer callData)
{
  not_while_running(w,
"This window is used to highlight and describe conditions.\n\
The conditions to highlight/describe are selected/deselected\n\
from the list of conditions shown by clicking on them.  It is\n\
possible to view all or some of any conditions by clicking the\n\
\"Highlight All\" and \"Highlight Selected\" buttons associated with them.\n\n\
All conditions that are selected will be drawn red when the\n\
screen is refreshed by zooming or any other refreshes.\n\n\
If exactly 1 total condition is selected, and it is selected from\n\
the list of individual conditions associated with a condition\n\
type, and the \"Zoom to individual conditions\" is selected,\n\
then the screen will center on that condition.  How closely the\n\
condition is centered on is controlled by the \"Zoom Pad Distance\".\n\n\
If exactly 1 total condition is selected, and it is selected from\n\
the list of individual conditions associated with a condition\n\
type, and the \"Give detailed information about individual conditions\"\n\
is selected, then detailed information about that particular\n\
condition will be presented.\n\n\
Individual conditions may also be \"retained\" or \"ignored\" using\n\
available buttons and/or the keyboard left and right arrow keys.\n\
Retain/Ignore choices are written to exported condition shapefiles\n\
as part of the \"Export Shapefiles from current conditions\" process.\n\n\
***Short-cut to zoom-to any single condition:  double-click the condition\n",1023,"Condition Highlighting Help",5);
}



int PartitionbyID(int p,int r)
{
  char x[IDSIZE];
  int i,j;
  struct FixLine temp;
  
  sprintf(x,"%s",fixentries[p].object_id);
  i = p-1;
  j = r+1;
  while(1)
    {
      do{j=j-1;}
      while(strcmp(fixentries[j].object_id,x)>0);
      
      do{i=i+1;}
      while(strcmp(fixentries[i].object_id,x)<0);
      
      if(i<j)
	{
	  temp = fixentries[i];
	  fixentries[i] = fixentries[j];
	  fixentries[j] = temp;
	}
      else
	{
	  return j;
	}
    }
}


void SortListbyID(int p,int r)
{
  
  int q;
  if(p<r)
    {
      q = PartitionbyID(p,r);
      SortListbyID(p,q);
      SortListbyID(q+1,r);
    }
}



int PartitionbyMag(int p,int r)
{
  double x;
  int i,j;
  struct FixLine temp;
  
  x = fixentries[p].xpoint;
  i = p-1;
  j = r+1;
  while(1)
    {
      do{j=j-1;}
      while(fixentries[j].xpoint>x);
      
      do{i=i+1;}
      while(fixentries[i].xpoint<x);
      
      if(i<j)
	{
	  temp = fixentries[i];
	  fixentries[i] = fixentries[j];
	  fixentries[j] = temp;
	}
      else
	{
	  return j;
	}
    }
}


void SortListbyMag(int p,int r)
{
  
  int q;
  if(p<r)
    {
      q = PartitionbyMag(p,r);
      SortListbyMag(p,q);
      SortListbyMag(q+1,r);
    }
}










struct ConditionList * GetErrors(int errtype, int clonenum, int *numexpected)
{
  int ConditionFlags[CONDITION_ARRAY_SIZE],i,inlen,outlen;
  struct ConditionList * NEW_LIST=NULL;
  struct ConditionList * REAL_LIST=NULL;
  char scrubout[1000];
  char scrubin[1000];
  char message[500];
  int temp_endianness=file_endianness;
  struct AdditionalConditions * AdditionalConditionFlags=NULL;
  

  for(i=1;i<=CONDITION_DEFINITIONS;i++)
    {
      ConditionFlags[i] = 0;
    }

  if(clonenum==0)
    {
      ConditionFlags[errtype] = 1;
    }
  else
    {
      SEEIT_AddAdditionalFlag(&AdditionalConditionFlags,
			      errtype,
			      clonenum
			      );
    }
  
  sprintf(scrubin ,"%s",indirectory);
  sprintf(scrubout,"%s",outdirectory);
  inlen  = strlen(scrubin);
  outlen = strlen(scrubout);
  scrubin [inlen-1] = '\0';
  scrubout[outlen-1] = '\0';
  
  SEEIT_LoadConditionReport(scrubout);
  


  if(SEEIT_GetNumConditions(errtype,clonenum)!=*numexpected)
    {
      sprintf(message,"Unable to create patch file!  Expected %d %s, got %d\n",
	      *numexpected,ErrorLookup[errtype].name,SEEIT_GetNumConditions(errtype,clonenum));
      
      not_while_running(drawing_a,message,1024,"Failed to make patch file",5);

      file_endianness = temp_endianness;
      return NULL;
    } 


  ABORT_ZOOM = 0;
  
  NEW_LIST = 
    SEEIT_GetConditions(scrubout,ConditionFlags,0,0, AdditionalConditionFlags,1,0,0,NULL,-1);

  REAL_LIST = NEW_LIST;
  
  file_endianness = temp_endianness;
  return REAL_LIST;
}


char *IprintID(char *id)
{
  if((id==NULL)||(!strcmp(id,"STF Object ID Number Unavailable")))
    {
      return "<none>";
    }
  return id;
}


int closetogether(int System, double a, double b)
{
  double smallamount;

  if(Ctype()==1)
    {
      smallamount = .0000000000001;
    }
  else if(Ctype()==2)
    {
      smallamount = .00000001;
    }
  else
    {
      printf("close got bad coord system %d\n",System);
      ExitWrapper(-1);
    }

  if(fabs(a-b)<smallamount)
    {
      return 1;
    }
  return 0;
}


char * MakePatchStringSegment(struct ConditionList * curr)
{
  static char retstring[5000];
  char newstuff[1000];
  int i;
  double z1,z2;
  
  retstring[0] = '\0';
  
  
  if(curr->CONDITION_TYPE==VTEAR)
    {
      
      
      z1 = curr->poly1.z[0];
      
      if(closetogether(CoordinateSystem, curr->poly1.x[0],curr->poly2.x[0]) && 
	 closetogether(CoordinateSystem, curr->poly1.y[0],curr->poly2.y[0]))
	{
	  z2 = curr->poly2.z[0];
	}
      else if(closetogether(CoordinateSystem, curr->poly1.x[0], curr->poly2.x[1]) && 
	      closetogether(CoordinateSystem, curr->poly1.y[0], curr->poly2.y[1]))
	{
	  z2 = curr->poly2.z[1];
	}
      else
	{
	  z1 = 0;   
	  z2 = 0;  
	}
    }


  if(curr->num_areals>=1)    {strcat(retstring,IprintID(curr->areal1.IDENT));    strcat(retstring," ");}
  if(curr->num_areals>=2)    {strcat(retstring,IprintID(curr->areal2.IDENT));    strcat(retstring," ");}

  if(curr->num_polys>=1)     {strcat(retstring,IprintID(curr->poly1.IDENT));      strcat(retstring," ");}
  if(curr->num_polys>=2)     {strcat(retstring,IprintID(curr->poly2.IDENT));      strcat(retstring," ");}

  if(curr->num_lines>=1)     {strcat(retstring,IprintID(curr->linear1.IDENT));    strcat(retstring," ");}
  if(curr->num_lines>=2)     {strcat(retstring,IprintID(curr->linear2.IDENT));    strcat(retstring," ");}

  if(curr->num_points>=1)    {strcat(retstring,IprintID(curr->point1.IDENT));     strcat(retstring," ");}
  if(curr->num_points>=2)    {strcat(retstring,IprintID(curr->point2.IDENT));     strcat(retstring," ");}

  if(curr->num_circles>=1)   {strcat(retstring,IprintID(curr->circle1.IDENT));    strcat(retstring," ");}
  if(curr->num_circles>=2)   {strcat(retstring,IprintID(curr->circle2.IDENT));    strcat(retstring," ");}

  if(curr->num_gridpt>=1)    {strcat(retstring,IprintID(curr->gridobj1.IDENT));   strcat(retstring," ");}
  if(curr->num_gridpt>=2)    {strcat(retstring,IprintID(curr->gridobj2.IDENT));   strcat(retstring," ");}

  if(curr->num_piped>=1)     {strcat(retstring,IprintID(curr->piped1.IDENT));     strcat(retstring," ");}
  if(curr->num_piped>=2)     {strcat(retstring,IprintID(curr->piped2.IDENT));     strcat(retstring," ");}

  if(curr->num_cylinder>=1)  {strcat(retstring,IprintID(curr->cylinder1.IDENT));  strcat(retstring," ");}
  if(curr->num_cylinder>=2)  {strcat(retstring,IprintID(curr->cylinder2.IDENT));  strcat(retstring," ");}
  
  if(curr->AdditionalIDENT!=NULL)
    {strcat(retstring,IprintID(curr->AdditionalIDENT));  strcat(retstring," ");}


  if(curr->AdditionalPointUsed==1) 
    { 
      sprintf(newstuff,"%.10lf %.10lf ",curr->pointx,curr->pointy);
      strcat(retstring,newstuff);
    }

  if(curr->CONDITION_TYPE==VTEAR)
    {
      
      
      sprintf(newstuff,"%.10lf %.10lf %.10lf ",curr->poly1.x[0],curr->poly1.y[0], (z1+z2)/2.0 );
      strcat(retstring,newstuff);      
    }
  
  if(ErrorLookup[curr->CONDITION_TYPE].numthresholds>0)
    {
      sprintf(newstuff,"%.10lf ",curr->magnitude);
      strcat(retstring,newstuff);
    }    
  
  
  i = strlen(retstring);
  if(retstring[i-2]==' '){retstring[i-2] = '\0';}
  
  return retstring;
}



int GetCloneNumber(int cloneindex,int errnum)
{
  int index;
  int foundone=0;
  
  for(index=cloneindex;index>=0;index--)
    {
      if(CloneErrorLookup[index].CloneNumber==errnum)
	{
	  foundone++;
	}
    }

  return foundone;
}




void PatchCreateCallback(Widget w,MyData *mydata,XtPointer callData)
{
  XmString *thelist;
  char *tjunk;
  FILE *outfile;
  char message[1000];
  char aline[5000];
  char temp[IDSIZE];
  int num,i,len;
  int *fixcounts;
  int wroteone=0;
  int pointing_to,ignoring;
  int repair_num,ignored_errtype,ignored_repair_num,errtype;

  int fixtype   = mydata->check_num;
  int cloneindex  = mydata->clonenum;
  int clonenum;

  struct ConditionList * error_list=NULL;
  struct ConditionList * curr=NULL;
  char stuffstring[1000];

  clonenum = GetCloneNumber(cloneindex,fixtype);
  



  set_cursor(XtDisplay(fixhead[fixtype]),XtWindow(fixhead[fixtype]),WATCH);
  set_cursor(mydisplay,mywindow,WATCH);

  outfile = fopen("seeit-patch","w");
  if(outfile==NULL)
    {
      printf("unable to open patchfile patch\n");
      ExitWrapper(-1);
    }


  if((fixtype!=TVERT)&&(fixtype!=ELEVADJCHANGE))
    {
      
      fprintf(outfile,"%d\n",CoordinateSystem);
    }


  XtVaGetValues(FixList[fixtype],XmNitemCount,&num,NULL);
  XtVaGetValues(FixList[fixtype],XmNitems,&thelist,NULL);


  
  


  error_list = GetErrors(fixtype,clonenum,&num);
  if(error_list==NULL)
    {
      printf("NULL error list!\n");
      set_cursor(XtDisplay(fixhead[fixtype]),XtWindow(fixhead[fixtype]),GOOD);
      set_cursor(mydisplay,mywindow,GOOD);
      fclose(outfile);
      return;
    }




  curr = error_list;
  for(i=0;i<num;i++)
    {
      XmStringGetLtoR(thelist[i],"mytag1", &tjunk);
      len = strlen(tjunk);
      if((tjunk[len-2]=='1')||(tjunk[len-2]=='2')||(tjunk[len-2]=='3')||(tjunk[len-2]=='4'))
	{
	  

	  if(strlen(MakePatchStringSegment(curr))>1)
	    {
	      fprintf(outfile,"%s %c %s\n",
		      ParseErrName(fixtype),tjunk[len-2],MakePatchStringSegment(curr));
	      wroteone++;
	    }
	}
      XtFree(tjunk);
      curr=curr->next;  
    }
  fclose(outfile);
  
  
  SEEIT_FreeConditions(error_list);
  
  if((fixtype!=TVERT)&&(fixtype!=ELEVADJCHANGE))
    {
      
      
      if(wroteone>0)
	{
	  sprintf(stuffstring,"Patch file \"seeit-patch\" successfully created with %d conditions.\n\n\
If this condition type is repairable by SEE-IT, you may now use\n\
the \"Apply Patch File\" option under the \"Inspection\" menu to\n\
specify paramters for and execute a repair job.\n\n\
If this condition type is not repairable by SEE-IT, you may now use\n\
your own software with this patch file to attempt to repair an STF.",wroteone);
	}
      else
	{
	  sprintf(stuffstring,"Unable to create patch file, because none of the conditions are repairable.\n\
One possible reason for this is if they are Vertical Tears, and all involve\n\
T-Vertices, which must be repaired first.");
	}
      not_while_running(fixhead[fixtype],stuffstring,1025,"Patch file created",5);
      
      set_cursor(XtDisplay(fixhead[fixtype]),XtWindow(fixhead[fixtype]),GOOD);
      set_cursor(mydisplay,mywindow,GOOD);
      return;
    }


  
  
  outfile = fopen("seeit-patch","r");
  if(outfile==NULL)
    {
      printf("unable to open patchfile patch\n");
      ExitWrapper(-1);
    }
  
  fixentries = (struct FixLine *) (malloc(sizeof(struct FixLine) * wroteone));
  if(fixentries==NULL)
    {
      printf("alloc fixentries: out of memory!\n");
      ExitWrapper(-1);
    }
  
  fixcounts  = (int *) (malloc(sizeof(int) * wroteone));
  if(fixcounts==NULL)
    {
      printf("alloc fixcounts: out of memory!\n");
      ExitWrapper(-1);
    }
  
  
  fgets(aline,5000,outfile);
  i = 0;
  while(!feof(outfile))
    {
      if(fixtype==TVERT)
	{	 
	  sscanf(aline,"%s%d%s%s%lf%lf",
		 fixentries[i].errtype,&fixentries[i].fixtype,
		 fixentries[i].object_id,fixentries[i].object_id2,
		 &fixentries[i].xpoint,&fixentries[i].ypoint);
	}
      else if (fixtype==ELEVADJCHANGE)
	{
	  sscanf(aline,"%s%d%s%lf",
		 fixentries[i].errtype,&fixentries[i].fixtype,
		 fixentries[i].object_id,&fixentries[i].xpoint);   
	}
      else
	{
	  printf("repair errors:  bad fix type!  %d\n",fixtype);
	}

      fgets(aline,5000,outfile);
      i++;
    }

  fclose(outfile);




  if(DEBUG==1)
    {
      for(i=0;i<wroteone;i++)
	{
	  if(fixtype==TVERT)
	    {
	      printf("found entry %s %d %s %s %lf %lf\n",
		     fixentries[i].errtype,fixentries[i].fixtype,
		     fixentries[i].object_id,fixentries[i].object_id2,
		     fixentries[i].xpoint,fixentries[i].ypoint);
	    }
	  else
	    {
	      printf("found entry %s %d %s %lf\n",
		     fixentries[i].errtype,fixentries[i].fixtype,
		     fixentries[i].object_id,fixentries[i].xpoint);
	    }
	}
    }

  

  SortListbyID(0,wroteone-1);
  

  if(DEBUG==1)
    {
      printf("sorted list:\n");
      for(i=0;i<wroteone;i++)
	{	  
	  if(fixtype==TVERT)
	    {
	      printf("found entry %s %d %s %s %lf %lf\n",
		     fixentries[i].errtype,fixentries[i].fixtype,
		     fixentries[i].object_id,fixentries[i].object_id2,
		     fixentries[i].xpoint,fixentries[i].ypoint);
	    }
	  else
	    {
	      printf("found entry %s %d %s %lf\n",
		     fixentries[i].errtype,fixentries[i].fixtype,
		     fixentries[i].object_id,fixentries[i].xpoint);
	    }
	}
    }



  for(i=0;i<wroteone;i++)
    {
      fixcounts[i] = 1;
    }


  sprintf(temp,"%s",fixentries[0].object_id);
  pointing_to = 0;
  for(i=1;i<wroteone;i++)
    {
      if(!strcmp(fixentries[i].object_id,temp))
	{
	  fixcounts[pointing_to]++;
	}
      else
	{
	  sprintf(temp,"%s",fixentries[i].object_id);  
	  pointing_to = i;
	}
    }
  


  


  outfile = fopen("seeit-patch","w");
  if(outfile==NULL)
    {
      printf("unable to open patchfile patch\n");
      ExitWrapper(-1);
    }

  fprintf(outfile,"%d\n",CoordinateSystem);

  ignoring = 0;
  for(i=0;i<wroteone;i++)
    {	  
      if(ignoring==0)
	{
	  if((fixtype==TVERT)||(fixtype==ELEVADJCHANGE))
	    {	 
	      fprintf(outfile,"%s %d %d %s\n",
		      fixentries[i].errtype,fixcounts[i],fixentries[i].fixtype,
		      fixentries[i].object_id);
	      repair_num = fixentries[i].fixtype;
	    }
	  else
	    {
	      printf("repair:  bad fixtype %d\n",fixtype);
	    }
	  
	  if(fixcounts[i]>1)
	    {
	      ignoring=fixcounts[i]-1;
	    }
	  errtype = ParseErrNumberWrapper(fixentries[i].errtype,0,NULL);
	  repair_num = fixentries[i].fixtype;
	}     
      else
	{
	  ignoring--;
	  ignored_errtype = ParseErrNumberWrapper(fixentries[i].errtype,0,NULL);
	  ignored_repair_num = fixentries[i].fixtype;
	  
	  if( (ignored_errtype != errtype)||(ignored_repair_num != repair_num) )
	    {
	      sprintf(message,"Unable to create patch file.  Found the same object ID being\n\
repaired by 2 different repairs:\n\
Object ID: %s\n\
Repairs: %s (repair %d) and %s (repair %d)\n\
This is not allowed\n",fixentries[i].object_id,
		      ParseErrName(ignored_errtype),ignored_repair_num,
		      ParseErrName(errtype), repair_num);
	      not_while_running(fixhead[fixtype],message,1026,"Failed to make patch file",5);
	      free(fixentries);
	      free(fixcounts);
	      set_cursor(XtDisplay(fixhead[fixtype]),XtWindow(fixhead[fixtype]),GOOD);
	      set_cursor(mydisplay,mywindow,GOOD);
	      
	      fclose(outfile);
	      outfile = fopen("seeit-patch","w");
	      fclose(outfile);
	      return;
	    }
	}
      
      if(fixtype==TVERT)
	{	 
	  fprintf(outfile,"%.10lf %.10lf %s\n",
		  fixentries[i].xpoint,fixentries[i].ypoint,
		  fixentries[i].object_id2);
	}
      else if(fixtype==ELEVADJCHANGE)
	{
	  fprintf(outfile,"%.10lf\n",fixentries[i].xpoint);
	}
    }
  fclose(outfile);
  free(fixentries);
  free(fixcounts);



      not_while_running(fixhead[fixtype],"Patch file \"seeit-patch\" successfully created.\n\n\
If this condition type is repairable by SEE-IT, you may now use\n\
the \"Apply Patch File\" option under the \"Inspection\" menu to\n\
specify paramters for and execute a repair job.\n\n\
If this condition type is not repairable by SEE-IT, you may now use\n\
your own software with this patch file to attempt to repair an STF.",1027,"Patch file created",5);


  set_cursor(XtDisplay(fixhead[fixtype]),XtWindow(fixhead[fixtype]),GOOD);
  set_cursor(mydisplay,mywindow,GOOD);
}





      




void DrawPolyWithHoles(int num_external_verts, double *externalX, double *externalY, 
		       int color, int numholes, struct AreaRing *holes, int Lindex)
{
  Region exterior,hole;
  int numholesfound = 0,temp1=DRAW_VERTICES,tempc;
  struct AreaRing *temp;
  extern int DRAW_AREA_LABELS;
  

  RETURN_VERTS = 1;
  MAPdrawpoly(num_external_verts,externalX,externalY,color,0,1,1,Lindex);
  RETURN_VERTS = 0;

  if(num_hole_points<2)
    {
      return;
    }


  exterior = XPolygonRegion(hole_points,num_hole_points,EvenOddRule);
  free(hole_points);
  num_hole_points = 0;


  
  temp = holes;

  while(temp != NULL)
    {
      numholesfound = numholesfound + 1;
      if(numholesfound>numholes)
	{
	  XBell(mydisplay,50);
	  printf("Expected %d holes, got %d or more.  Aborting\n",numholes,numholesfound);
	  return;
	}

   
      RETURN_VERTS = 1;
      MAPdrawpoly(temp->numverts,temp->x,temp->y,color,0,1,1,Lindex);
      RETURN_VERTS = 0;

      

      if(num_hole_points>1)
	{
	  hole = XPolygonRegion(hole_points,num_hole_points,EvenOddRule);

	  XSubtractRegion(exterior,hole,exterior);

	  XDestroyRegion(hole);

	   free(hole_points);
       num_hole_points = 0;

	}

      temp = temp->next;
    }



  
  XSetRegion(mydisplay, mygc,    exterior);
  XSetRegion(mydisplay, mybitgc, exterior);
  


  

  tempc = DRAW_AREA_LABELS;  
  DRAW_AREA_LABELS = 0;
  
  DRAW_VERTICES = 0;
  MAPdrawpoly(num_external_verts,externalX,externalY,color,0,1,1,Lindex);
  

  DRAW_AREA_LABELS = tempc;




  
  XDestroyRegion(exterior);
  XSetClipMask(mydisplay,mygc,   None);
  XSetClipMask(mydisplay,mybitgc,None);



  
  
  DRAW_VERTICES = temp1;
  LINE_TYPE_ONLY = 2;
  MAPdrawpoly(num_external_verts,externalX,externalY,color,0,1,1,Lindex);
  DRAW_VERTICES = 0;
  temp = holes;
  while(temp != NULL)
    {
      MAPdrawpoly(temp->numverts,temp->x,temp->y,color,0,1,1,Lindex);
      temp = temp->next;
    }
  LINE_TYPE_ONLY = 0;
  DRAW_VERTICES = temp1;









}







void ClearDrawingPixmaps(int override)
{
  int i;
  
  XSetForeground(mydisplay,mygc,mycolors[DRAW_COLOR_WHITE]);
  
  for(i=0;i<NUM_DRAWING_PIXMAPS-PIXMAP_MODIFIER;i++)
    {
      if((LODS_USED[i]==1)||(override==1))
	{

      

	  XFillRectangle (XtDisplay (drawing_a), DRAWING_PIXMAPS[i], mygc, 
			  0, 0, width, height);
	}
    }
  SetColorRight();
}




void ClearErrorBitmap()
{  
  XSetForeground(mydisplay,mybitgc,BITBLACK);
  
  XFillRectangle (XtDisplay (drawing_a), ERROR_BITMAP, mybitgc, 
		  0, 0, width, height);
  
  
  XSetForeground(mydisplay,mybitgc,BITWHITE);
}


void ClearBitmaps(int override)
{
  int i;

  XSetForeground(mydisplay,mybitgc,BITBLACK);
  
  for(i=0;i<NUM_DRAWING_PIXMAPS-PIXMAP_MODIFIER;i++)
    {
      if((LODS_USED[i]==1)||(override==1))
	{
	  
	  XFillRectangle (XtDisplay (drawing_a), DRAWING_CLIPMAPS[i], mybitgc, 
			  0, 0, width, height);
	}
    }

  
  XSetForeground(mydisplay,mybitgc,BITWHITE);
}




void creditCallback(Widget widget, XtPointer userData, XtPointer callData)
{
 char message[2000];

  
  if(NGA_TYPE==1)
    {
      sprintf(message,"GAIT %s\n\n\
An Automated Inspection Tool for Geospatial Data\n\n\
Written by:\n\n\
               Robert Richbourg (IDA)\n\
               Tim Stone (IDA)",VersionStr);

      not_while_running(widget,message,1229,"GAIT Info",5);
    }
  else
    {
      sprintf(message,"SEE-IT %s\n\n\
An Automated Inspection Tool for Synthetic Environment\n\n\
Written by:\n\n\
               Robert Richbourg (IDA)\n\
               Tim Stone (IDA)",VersionStr);

      not_while_running(widget,message,1229,"SEE-IT Info",5);
    }
}



void MakeLayerDefaultsFiles(int attr_type, int geom)
{
  int i,domain;
  char idstr[100];
  unsigned short int default_r     [1000];
  unsigned short int default_g     [1000];
  unsigned short int default_b     [1000];

  ATTRIBUTION_TYPE = attr_type;

  if(attr_type==2)
    {
      sprintf(idstr,"d4");
    }
  else if(attr_type==4)
    {
      sprintf(idstr,"facc");
    }
  else if(attr_type==6)
    {
      sprintf(idstr,"vmap");
    }
  else if(attr_type==8)
    {
      sprintf(idstr,"mgcp");
    }
  else if(attr_type==12)
    {
      sprintf(idstr,"ufd1");
    }
  else if(attr_type==10)
    {
      sprintf(idstr,"ufd2");
    }
  else if(attr_type==14)
    {
      sprintf(idstr,"ufd3");
    }
  else if(attr_type==16)
    {
      sprintf(idstr,"ltds");
    }
  else if(attr_type==18)
    {
      sprintf(idstr,"utds");
    }
  else if(attr_type==20)
    {
      sprintf(idstr,"rtds");
    }
  else if(attr_type==22)
    {
      sprintf(idstr,"gtds");
    }

  
  InitializeAttribution();
  
  
  
  for(i=1;i<=GIFD_CLASS_NUM;i++)
    {
      domain = DOMAINS[i];
      
      if(geom==C_POFE)
	{
	  default_r     [i-1] = DOMAIN_R[domain];
	  default_g     [i-1] = DOMAIN_G[domain];
	  default_b     [i-1] = DOMAIN_B[domain];
	  
	  
	}

      if(geom==C_LINE)
	{
	  default_r     [i-1] = DOMAIN_R[domain];
	  default_g     [i-1] = DOMAIN_G[domain];
	  default_b     [i-1] = DOMAIN_B[domain];

	  
	}

      
      if(geom==C_AREA)
	{
	  default_r     [i-1] = DOMAIN_R[domain];
	  default_g     [i-1] = DOMAIN_G[domain];
	  default_b     [i-1] = DOMAIN_B[domain];

	  
	}
    }



  if(geom==C_POFE)
    {
      printf("unsigned short int %s_point_r[%d] = {\n",idstr,GIFD_CLASS_NUM);
      for(i=0;i<GIFD_CLASS_NUM;i++)
	{
	  printf("  %5d",default_r[i]);
	  if(i!=(GIFD_CLASS_NUM-1))
	    {
	      printf(",  /* %s R */\n",GetECCCode(i+1));
	    } 
	  else
	    {
	      printf("   /* %s R */\n",GetECCCode(i+1));
	    }
	}
      printf("};\n\n");


      printf("unsigned short int %s_point_g[%d] = {\n",idstr,GIFD_CLASS_NUM);
      for(i=0;i<GIFD_CLASS_NUM;i++)
	{
	  printf("  %5d",default_g[i]);
	  if(i!=(GIFD_CLASS_NUM-1))
	    {
	      printf(",  /* %s G */\n",GetECCCode(i+1));
	    }
	  else
	    {
	      printf("   /* %s G */\n",GetECCCode(i+1));
	    }
	}
      printf("};\n\n");


      printf("unsigned short int %s_point_b[%d] = {\n",idstr,GIFD_CLASS_NUM);
      for(i=0;i<GIFD_CLASS_NUM;i++)
	{
	  printf("  %5d",default_b[i]);
	  if(i!=(GIFD_CLASS_NUM-1))
	    {
	      printf(",  /* %s B */\n",GetECCCode(i+1));
	    }
	  else
	    {
	      printf("   /* %s B */\n",GetECCCode(i+1));
	    }
	}
      printf("};\n\n");
    }



  if(geom==C_LINE)
    {
      printf("unsigned short int %s_line_r[%d] = {\n",idstr,GIFD_CLASS_NUM);
      for(i=0;i<GIFD_CLASS_NUM;i++)
	{
	  printf("  %5d",default_r[i]);
	  if(i!=(GIFD_CLASS_NUM-1))
	    {
	      printf(",  /* %s R */\n",GetECCCode(i+1));
	    }
	  else
	    {
	      printf("   /* %s R */\n",GetECCCode(i+1));
	    }
	}
      printf("};\n\n");


      printf("unsigned short int %s_line_g[%d] = {\n",idstr,GIFD_CLASS_NUM);
      for(i=0;i<GIFD_CLASS_NUM;i++)
	{
	  printf("  %5d",default_g[i]);
	  if(i!=(GIFD_CLASS_NUM-1))
	    {
	      printf(",  /* %s G */\n",GetECCCode(i+1));
	    }
	  else
	    {
	      printf("   /* %s G */\n",GetECCCode(i+1));
	    }
	}
      printf("};\n\n");


      printf("unsigned short int %s_line_b[%d] = {\n",idstr,GIFD_CLASS_NUM);
      for(i=0;i<GIFD_CLASS_NUM;i++)
	{
	  printf("  %5d",default_b[i]);
	  if(i!=(GIFD_CLASS_NUM-1))
	    {
	      printf(",  /* %s B */\n",GetECCCode(i+1));
	    }
	  else
	    {
	      printf("   /* %s B */\n",GetECCCode(i+1));
	    }
	}
      printf("};\n\n");
    }


  if(geom==C_AREA)
    {
      printf("unsigned short int %s_area_r[%d] = {\n",idstr,GIFD_CLASS_NUM);
      for(i=0;i<GIFD_CLASS_NUM;i++)
	{
	  printf("  %5d",default_r[i]);
	  if(i!=(GIFD_CLASS_NUM-1))
	    {
	      printf(",  /* %s R */\n",GetECCCode(i+1));
	    }
	  else
	    {
	      printf("   /* %s R */\n",GetECCCode(i+1));
	    }
	}
      printf("};\n\n");


      printf("unsigned short int %s_area_g[%d] = {\n",idstr,GIFD_CLASS_NUM);
      for(i=0;i<GIFD_CLASS_NUM;i++)
	{
	  printf("  %5d",default_g[i]);
	  if(i!=(GIFD_CLASS_NUM-1))
	    {
	      printf(",  /* %s G */\n",GetECCCode(i+1));
	    }
	  else
	    {
	      printf("   /* %s G */\n",GetECCCode(i+1));
	    }
	}
      printf("};\n\n");


      printf("unsigned short int %s_area_b[%d] = {\n",idstr,GIFD_CLASS_NUM);
      for(i=0;i<GIFD_CLASS_NUM;i++)
	{
	  printf("  %5d",default_b[i]);
	  if(i!=(GIFD_CLASS_NUM-1))
	    {
	      printf(",  /* %s B */\n",GetECCCode(i+1));
	    }
	  else
	    {
	      printf("   /* %s B */\n",GetECCCode(i+1));
	    }
	}
      printf("};\n\n");
    }

}




void FixDifferentDomains(int verbose)
{


#if((USE_TDS+USE_GGDM+USE_UFD+USE_NFDD+USE_DFDD)==5)  


  int i,j,foundit=0;
  extern char *GetEECode(int attr_code, int enum_num);


  

  




  
  for(i=0;i<D4_CLASS_NUM;i++)
  { 
      
    for(j=0;j<FLDB_CLASS_NUM;j++)
	{
	  if(!strcmp(D4_class_codes[i],FLDB_class_codes[j]))
	  { 
	    if(D4DOMAINS[i+1]!=FLDBDOMAINS[j+1])
		{
	      if(verbose==1)
		  { 
		    printf("D4 %s does not match FLDB: %s %s\n",D4_class_codes[i],
			     ParseDName(D4DOMAINS[i+1]),ParseDName(FLDBDOMAINS[j+1]));
		  } 
		  FLDBDOMAINS[j+1] = D4DOMAINS[i+1];
		} 
	  }  
	}
      
    for(j=0;j<VMAP_CLASS_NUM;j++)
	{
	  if(!strcmp(D4_class_codes[i],VMAP_class_codes[j]))
	  {
	    if(D4DOMAINS[i+1]!=VMAPDOMAINS[j+1])
		{
		  if(verbose==1)
		  {
		    printf("D4 %s does not match VMAP: %s %s\n",D4_class_codes[i],
			     ParseDName(D4DOMAINS[i+1]),ParseDName(VMAPDOMAINS[j+1]));
		      
		  }
		  VMAPDOMAINS[j+1] = D4DOMAINS[i+1];
		}
	  } 
	}
      
    for(j=0;j<MGCP3_CLASS_NUM;j++)
	{
	  if(!strcmp(D4_class_codes[i],MGCP3_class_codes[j]))
	  { 
	    if(D4DOMAINS[i+1]!=MGCP3DOMAINS[j+1])
		{
		  if(verbose==1)
		  {
		    printf("D4 %s does not match MGCP: %s %s\n",D4_class_codes[i],
			     ParseDName(D4DOMAINS[i+1]),ParseDName(MGCP3DOMAINS[j+1]));
		      
		  }
		  MGCP3DOMAINS[j+1] = D4DOMAINS[i+1];
		} 
	  } 
	}

      
    for(j=0;j<MGCP4_CLASS_NUM;j++)
	{
	  if(!strcmp(D4_class_codes[i],MGCP4_class_codes[j]))
	  {
	    if(D4DOMAINS[i+1]!=MGCP4DOMAINS[j+1])
		{
		  if(verbose==1)
		  {
		    printf("D4 %s does not match MGCP4: %s %s\n",D4_class_codes[i],
			     ParseDName(D4DOMAINS[i+1]),ParseDName(MGCP4DOMAINS[j+1]));
		      
		  }
		  MGCP4DOMAINS[j+1] = D4DOMAINS[i+1];
		}
	  } 
	}

    for(j=0;j<UFD1_CLASS_NUM;j++)
	{
	  if(!strcmp(D4_class_codes[i],UFD1_class_codes[j]))
	  {
	    if(D4DOMAINS[i+1]!=UFD1DOMAINS[j+1])
		{
		  if(verbose==1)
		  {
		    printf("D4 %s does not match UFD1: %s %s\n",D4_class_codes[i],
			     ParseDName(D4DOMAINS[i+1]),ParseDName(UFD1DOMAINS[j+1]));
		  }
		  UFD1DOMAINS[j+1] = D4DOMAINS[i+1];
		}
	  } 
	}

    for(j=0;j<UFD2_CLASS_NUM;j++)
	{
	  if(!strcmp(D4_class_codes[i],UFD2_class_codes[j]))
	  {
	    if(D4DOMAINS[i+1]!=UFD2DOMAINS[j+1])
		{
		  if(verbose==1)
		  {
		      printf("D4 %s does not match UFD2: %s %s\n",D4_class_codes[i],
			     ParseDName(D4DOMAINS[i+1]),ParseDName(UFD2DOMAINS[j+1]));
		  }
		  UFD2DOMAINS[j+1] = D4DOMAINS[i+1];
		}
	  } 
	}
      
      
    for(j=0;j<UFD3_CLASS_NUM;j++)
	{
	  if(!strcmp(D4_class_codes[i],UFD3_class_codes[j]))
	  {
	    if(D4DOMAINS[i+1]!=UFD3DOMAINS[j+1])
		{
		  if(verbose==1)
		  {
		    printf("D4 %s does not match UFD3: %s %s\n",D4_class_codes[i],
			     ParseDName(D4DOMAINS[i+1]),ParseDName(UFD3DOMAINS[j+1]));
		  }
		  UFD3DOMAINS[j+1] = D4DOMAINS[i+1];
		}
	  } 
	}


    for(j=0;j<TDS4_CLASS_NUM;j++)
	{
	  if(!strcmp(D4_class_codes[i],TDS4_class_codes[j]))
	  {
	    if(D4DOMAINS[i+1]!=TDS4DOMAINS[j+1])
		{
		  if(verbose==1)
		  {
		    printf("D4 %s does not match TDS4: %s %s\n",D4_class_codes[i],
			     ParseDName(D4DOMAINS[i+1]),ParseDName(TDS4DOMAINS[j+1]));
		  }
		  TDS4DOMAINS[j+1] = D4DOMAINS[i+1];
		}
	  } 
	}
 

    for(j=0;j<TDS6_CLASS_NUM;j++)
	{
	  if(!strcmp(D4_class_codes[i],TDS6_class_codes[j]))
	  {
	    if(D4DOMAINS[i+1]!=TDS6DOMAINS[j+1])
		{
		  if(verbose==1)
		  {
		    printf("D4 %s does not match TDS6: %s %s\n",D4_class_codes[i],
			     ParseDName(D4DOMAINS[i+1]),ParseDName(TDS6DOMAINS[j+1]));
		  }
		  TDS6DOMAINS[j+1] = D4DOMAINS[i+1];
		}
	  } 
	}


    for(j=0;j<SAC_CLASS_NUM;j++)
	{
	  if(!strcmp(D4_class_codes[i],SAC_class_codes[j]))
	  {
	    if(D4DOMAINS[i+1]!=SACDOMAINS[j+1])
		{
		  if(verbose==1)
		  {
		    printf("D4 %s does not match AFD: %s %s\n",D4_class_codes[i],
			     ParseDName(D4DOMAINS[i+1]),ParseDName(SACDOMAINS[j+1]));
		  }
		  SACDOMAINS[j+1] = D4DOMAINS[i+1];
		}
	  } 
	}


    for(j=0;j<GGDM21_CLASS_NUM;j++)
	{
	  if(!strcmp(D4_class_codes[i],GGDM21_class_codes[j]))
	  {
	    if(D4DOMAINS[i+1]!=GGDM21DOMAINS[j+1])
		{
		  if(verbose==1)
		  {
		    printf("D4 %s does not match GGDM21: %s %s\n",D4_class_codes[i],
			     ParseDName(D4DOMAINS[i+1]),ParseDName(GGDM21DOMAINS[j+1]));
		  }
		  GGDM21DOMAINS[j+1] = D4DOMAINS[i+1];
		}
	  } 
	}


    for(j=0;j<GGDM22_U_CLASS_NUM;j++)
	{
	  if(!strcmp(D4_class_codes[i],GGDM22_U_class_codes[j]))
	  {
	    if(D4DOMAINS[i+1]!=GGDM22_UDOMAINS[j+1])
		{
		  if(verbose==1)
		  {
		    printf("D4 %s does not match GGDM22: %s %s\n",D4_class_codes[i],
			     ParseDName(D4DOMAINS[i+1]),ParseDName(GGDM22_UDOMAINS[j+1]));
		  }
		  GGDM22_UDOMAINS[j+1] = D4DOMAINS[i+1];
		} 
	  } 
	}


    for(j=0;j<GGDM3_CLASS_NUM;j++)
	{
	  if(!strcmp(D4_class_codes[i],GGDM3_class_codes[j]))
	  {
	    if(D4DOMAINS[i+1]!=GGDM3DOMAINS[j+1])
		{
		  if(verbose==1)
		  {
		    printf("D4 %s does not match GGDM3: %s %s\n",D4_class_codes[i],
			     ParseDName(D4DOMAINS[i+1]),ParseDName(GGDM3DOMAINS[j+1]));
		  }
		  GGDM3DOMAINS[j+1] = D4DOMAINS[i+1];
		}
	  } 
	}


    for(j=0;j<NFDD_CLASS_NUM;j++)
	{
	  if(!strcmp(D4_class_codes[i],NFDD_class_codes[j]))
	  {
	    if(D4DOMAINS[i+1]!=NFDDDOMAINS[j+1])
		{
		  if(verbose==1)
		  {
		    printf("D4 %s does not match NFDD: %s %s\n",D4_class_codes[i],
			     ParseDName(D4DOMAINS[i+1]),ParseDName(NFDDDOMAINS[j+1]));
		  }
		  NFDDDOMAINS[j+1] = D4DOMAINS[i+1];
		}
	  } 
	}


    for(j=0;j<DFDD_CLASS_NUM;j++)
	{
	  if(!strcmp(D4_class_codes[i],DFDD_class_codes[j]))
	  {
	    if(D4DOMAINS[i+1]!=DFDDDOMAINS[j+1])
		{
		  if(verbose==1)
		  {
		    printf("D4 %s does not match DFDD: %s %s\n",D4_class_codes[i],
			     ParseDName(D4DOMAINS[i+1]),ParseDName(DFDDDOMAINS[j+1]));
		  }
		  DFDDDOMAINS[j+1] = D4DOMAINS[i+1];
		}
	  } 
	}
  }  
  
  
  
  
  

  


  for(i=0;i<FLDB_CLASS_NUM;i++)
  {   
    for(j=0;j<VMAP_CLASS_NUM;j++)
	{
	  if(!strcmp(FLDB_class_codes[i],VMAP_class_codes[j]))
	  {
	    if(FLDBDOMAINS[i+1]!=VMAPDOMAINS[j+1])
		{
		  if(verbose==1)
		  {
		    printf("FLDB %s does not match VMAP: %s %s\n",FLDB_class_codes[i],
			     ParseDName(FLDBDOMAINS[i+1]),ParseDName(VMAPDOMAINS[j+1]));
		      
		  }
		  VMAPDOMAINS[j+1] = FLDBDOMAINS[i+1];
		}
	  } 
	}
      
    for(j=0;j<MGCP3_CLASS_NUM;j++)
	{
	  if(!strcmp(FLDB_class_codes[i],MGCP3_class_codes[j]))
	  { 
	    if(FLDBDOMAINS[i+1]!=MGCP3DOMAINS[j+1])
		{
		  if(verbose==1)
		  {
		    printf("FLDB %s does not match MGCP: %s %s\n",FLDB_class_codes[i],
			     ParseDName(FLDBDOMAINS[i+1]),ParseDName(MGCP3DOMAINS[j+1]));
		      
		  }
		  MGCP3DOMAINS[j+1] = FLDBDOMAINS[i+1];
		} 
	  } 
	}

      
    for(j=0;j<MGCP4_CLASS_NUM;j++)
	{
	  if(!strcmp(FLDB_class_codes[i],MGCP4_class_codes[j]))
	  {
	    if(FLDBDOMAINS[i+1]!=MGCP4DOMAINS[j+1])
		{
		  if(verbose==1)
		  {
		    printf("FLDB %s does not match MGCP4: %s %s\n",FLDB_class_codes[i],
			     ParseDName(FLDBDOMAINS[i+1]),ParseDName(MGCP4DOMAINS[j+1]));
		      
		  }
		  MGCP4DOMAINS[j+1] = FLDBDOMAINS[i+1];
		}
	  } 
	}

    for(j=0;j<UFD1_CLASS_NUM;j++)
	{
	  if(!strcmp(FLDB_class_codes[i],UFD1_class_codes[j]))
	  {
	    if(FLDBDOMAINS[i+1]!=UFD1DOMAINS[j+1])
		{
		  if(verbose==1)
		  {
		    printf("FLDB %s does not match UFD1: %s %s\n",FLDB_class_codes[i],
			     ParseDName(FLDBDOMAINS[i+1]),ParseDName(UFD1DOMAINS[j+1]));
		  }
		  UFD1DOMAINS[j+1] = FLDBDOMAINS[i+1];
		}
	  } 
	}

    for(j=0;j<UFD2_CLASS_NUM;j++)
	{
	  if(!strcmp(FLDB_class_codes[i],UFD2_class_codes[j]))
	  {
	    if(FLDBDOMAINS[i+1]!=UFD2DOMAINS[j+1])
		{
		  if(verbose==1)
		  {
		      printf("FLDB %s does not match UFD2: %s %s\n",FLDB_class_codes[i],
			     ParseDName(FLDBDOMAINS[i+1]),ParseDName(UFD2DOMAINS[j+1]));
		  }
		  UFD2DOMAINS[j+1] = FLDBDOMAINS[i+1];
		}
	  } 
	}
      
      
    for(j=0;j<UFD3_CLASS_NUM;j++)
	{
	  if(!strcmp(FLDB_class_codes[i],UFD3_class_codes[j]))
	  {
	    if(FLDBDOMAINS[i+1]!=UFD3DOMAINS[j+1])
		{
		  if(verbose==1)
		  {
		    printf("FLDB %s does not match UFD3: %s %s\n",FLDB_class_codes[i],
			     ParseDName(FLDBDOMAINS[i+1]),ParseDName(UFD3DOMAINS[j+1]));
		  }
		  UFD3DOMAINS[j+1] = FLDBDOMAINS[i+1];
		}
	  } 
	}


    for(j=0;j<TDS4_CLASS_NUM;j++)
	{
	  if(!strcmp(FLDB_class_codes[i],TDS4_class_codes[j]))
	  {
	    if(FLDBDOMAINS[i+1]!=TDS4DOMAINS[j+1])
		{
		  if(verbose==1)
		  {
		    printf("FLDB %s does not match TDS4: %s %s\n",FLDB_class_codes[i],
			     ParseDName(FLDBDOMAINS[i+1]),ParseDName(TDS4DOMAINS[j+1]));
		  }
		  TDS4DOMAINS[j+1] = FLDBDOMAINS[i+1];
		}
	  } 
	}
 

    for(j=0;j<TDS6_CLASS_NUM;j++)
	{
	  if(!strcmp(FLDB_class_codes[i],TDS6_class_codes[j]))
	  {
	    if(FLDBDOMAINS[i+1]!=TDS6DOMAINS[j+1])
		{
		  if(verbose==1)
		  {
		    printf("FLDB %s does not match TDS6: %s %s\n",FLDB_class_codes[i],
			     ParseDName(FLDBDOMAINS[i+1]),ParseDName(TDS6DOMAINS[j+1]));
		  }
		  TDS6DOMAINS[j+1] = FLDBDOMAINS[i+1];
		}
	  } 
	}


    for(j=0;j<SAC_CLASS_NUM;j++)
	{
	  if(!strcmp(FLDB_class_codes[i],SAC_class_codes[j]))
	  {
	    if(FLDBDOMAINS[i+1]!=SACDOMAINS[j+1])
		{
		  if(verbose==1)
		  {
		    printf("FLDB %s does not match AFD: %s %s\n",FLDB_class_codes[i],
			     ParseDName(FLDBDOMAINS[i+1]),ParseDName(SACDOMAINS[j+1]));
		  }
		  SACDOMAINS[j+1] = FLDBDOMAINS[i+1];
		}
	  } 
	}


    for(j=0;j<GGDM21_CLASS_NUM;j++)
	{
	  if(!strcmp(FLDB_class_codes[i],GGDM21_class_codes[j]))
	  {
	    if(FLDBDOMAINS[i+1]!=GGDM21DOMAINS[j+1])
		{
		  if(verbose==1)
		  {
		    printf("FLDB %s does not match GGDM21: %s %s\n",FLDB_class_codes[i],
			     ParseDName(FLDBDOMAINS[i+1]),ParseDName(GGDM21DOMAINS[j+1]));
		  }
		  GGDM21DOMAINS[j+1] = FLDBDOMAINS[i+1];
		}
	  } 
	}


    for(j=0;j<GGDM22_U_CLASS_NUM;j++)
	{
	  if(!strcmp(FLDB_class_codes[i],GGDM22_U_class_codes[j]))
	  {
	    if(FLDBDOMAINS[i+1]!=GGDM22_UDOMAINS[j+1])
		{
		  if(verbose==1)
		  {
		    printf("FLDB %s does not match GGDM22: %s %s\n",FLDB_class_codes[i],
			     ParseDName(FLDBDOMAINS[i+1]),ParseDName(GGDM22_UDOMAINS[j+1]));
		  }
		  GGDM22_UDOMAINS[j+1] = FLDBDOMAINS[i+1];
		} 
	  } 
	}


    for(j=0;j<GGDM3_CLASS_NUM;j++)
	{
	  if(!strcmp(FLDB_class_codes[i],GGDM3_class_codes[j]))
	  {
	    if(FLDBDOMAINS[i+1]!=GGDM3DOMAINS[j+1])
		{
		  if(verbose==1)
		  {
		    printf("FLDB %s does not match GGDM3: %s %s\n",FLDB_class_codes[i],
			     ParseDName(FLDBDOMAINS[i+1]),ParseDName(GGDM3DOMAINS[j+1]));
		  }
		  GGDM3DOMAINS[j+1] = FLDBDOMAINS[i+1];
		}
	  } 
	}


    for(j=0;j<NFDD_CLASS_NUM;j++)
	{
	  if(!strcmp(FLDB_class_codes[i],NFDD_class_codes[j]))
	  {
	    if(FLDBDOMAINS[i+1]!=NFDDDOMAINS[j+1])
		{
		  if(verbose==1)
		  {
		    printf("FLDB %s does not match NFDD: %s %s\n",FLDB_class_codes[i],
			     ParseDName(FLDBDOMAINS[i+1]),ParseDName(NFDDDOMAINS[j+1]));
		  }
		  NFDDDOMAINS[j+1] = FLDBDOMAINS[i+1];
		}
	  } 
	}


    for(j=0;j<DFDD_CLASS_NUM;j++)
	{
	  if(!strcmp(FLDB_class_codes[i],DFDD_class_codes[j]))
	  {
	    if(FLDBDOMAINS[i+1]!=DFDDDOMAINS[j+1])
		{
		  if(verbose==1)
		  {
		    printf("FLDB %s does not match DFDD: %s %s\n",FLDB_class_codes[i],
			     ParseDName(FLDBDOMAINS[i+1]),ParseDName(DFDDDOMAINS[j+1]));
		  }
		  DFDDDOMAINS[j+1] = FLDBDOMAINS[i+1];
		}
	  } 
	}
  }  


  
  

  


  for(i=0;i<VMAP_CLASS_NUM;i++)
  {   
      
    for(j=0;j<MGCP3_CLASS_NUM;j++)
	{
	  if(!strcmp(VMAP_class_codes[i],MGCP3_class_codes[j]))
	  { 
	    if(VMAPDOMAINS[i+1]!=MGCP3DOMAINS[j+1])
		{
		  if(verbose==1)
		  {
		    printf("VMAP %s does not match MGCP: %s %s\n",VMAP_class_codes[i],
			     ParseDName(VMAPDOMAINS[i+1]),ParseDName(MGCP3DOMAINS[j+1]));
		      
		  }
		  MGCP3DOMAINS[j+1] = VMAPDOMAINS[i+1];
		} 
	  } 
	}

      
    for(j=0;j<MGCP4_CLASS_NUM;j++)
	{
	  if(!strcmp(VMAP_class_codes[i],MGCP4_class_codes[j]))
	  {
	    if(VMAPDOMAINS[i+1]!=MGCP4DOMAINS[j+1])
		{
		  if(verbose==1)
		  {
		    printf("VMAP %s does not match MGCP4: %s %s\n",VMAP_class_codes[i],
			     ParseDName(VMAPDOMAINS[i+1]),ParseDName(MGCP4DOMAINS[j+1]));
		      
		  }
		  MGCP4DOMAINS[j+1] = VMAPDOMAINS[i+1];
		}
	  } 
	}

    for(j=0;j<UFD1_CLASS_NUM;j++)
	{
	  if(!strcmp(VMAP_class_codes[i],UFD1_class_codes[j]))
	  {
	    if(VMAPDOMAINS[i+1]!=UFD1DOMAINS[j+1])
		{
		  if(verbose==1)
		  {
		    printf("VMAP %s does not match UFD1: %s %s\n",VMAP_class_codes[i],
			     ParseDName(VMAPDOMAINS[i+1]),ParseDName(UFD1DOMAINS[j+1]));
		  }
		  UFD1DOMAINS[j+1] = VMAPDOMAINS[i+1];
		}
	  } 
	}

    for(j=0;j<UFD2_CLASS_NUM;j++)
	{
	  if(!strcmp(VMAP_class_codes[i],UFD2_class_codes[j]))
	  {
	    if(VMAPDOMAINS[i+1]!=UFD2DOMAINS[j+1])
		{
		  if(verbose==1)
		  {
		      printf("VMAP %s does not match UFD2: %s %s\n",VMAP_class_codes[i],
			     ParseDName(VMAPDOMAINS[i+1]),ParseDName(UFD2DOMAINS[j+1]));
		  }
		  UFD2DOMAINS[j+1] = VMAPDOMAINS[i+1];
		}
	  } 
	}
      
      
    for(j=0;j<UFD3_CLASS_NUM;j++)
	{
	  if(!strcmp(VMAP_class_codes[i],UFD3_class_codes[j]))
	  {
	    if(VMAPDOMAINS[i+1]!=UFD3DOMAINS[j+1])
		{
		  if(verbose==1)
		  {
		    printf("VMAP %s does not match UFD3: %s %s\n",VMAP_class_codes[i],
			     ParseDName(VMAPDOMAINS[i+1]),ParseDName(UFD3DOMAINS[j+1]));
		  }
		  UFD3DOMAINS[j+1] = VMAPDOMAINS[i+1];
		}
	  } 
	}


    for(j=0;j<TDS4_CLASS_NUM;j++)
	{
	  if(!strcmp(VMAP_class_codes[i],TDS4_class_codes[j]))
	  {
	    if(VMAPDOMAINS[i+1]!=TDS4DOMAINS[j+1])
		{
		  if(verbose==1)
		  {
		    printf("VMAP %s does not match TDS4: %s %s\n",VMAP_class_codes[i],
			     ParseDName(VMAPDOMAINS[i+1]),ParseDName(TDS4DOMAINS[j+1]));
		  }
		  TDS4DOMAINS[j+1] = VMAPDOMAINS[i+1];
		}
	  } 
	}
 

    for(j=0;j<TDS6_CLASS_NUM;j++)
	{
	  if(!strcmp(VMAP_class_codes[i],TDS6_class_codes[j]))
	  {
	    if(VMAPDOMAINS[i+1]!=TDS6DOMAINS[j+1])
		{
		  if(verbose==1)
		  {
		    printf("VMAP %s does not match TDS6: %s %s\n",VMAP_class_codes[i],
			     ParseDName(VMAPDOMAINS[i+1]),ParseDName(TDS6DOMAINS[j+1]));
		  }
		  TDS6DOMAINS[j+1] = VMAPDOMAINS[i+1];
		}
	  } 
	}


    for(j=0;j<SAC_CLASS_NUM;j++)
	{
	  if(!strcmp(VMAP_class_codes[i],SAC_class_codes[j]))
	  {
	    if(VMAPDOMAINS[i+1]!=SACDOMAINS[j+1])
		{
		  if(verbose==1)
		  {
		    printf("VMAP %s does not match AFD: %s %s\n",VMAP_class_codes[i],
			     ParseDName(VMAPDOMAINS[i+1]),ParseDName(SACDOMAINS[j+1]));
		  }
		  SACDOMAINS[j+1] = VMAPDOMAINS[i+1];
		}
	  } 
	}


    for(j=0;j<GGDM21_CLASS_NUM;j++)
	{
	  if(!strcmp(VMAP_class_codes[i],GGDM21_class_codes[j]))
	  {
	    if(VMAPDOMAINS[i+1]!=GGDM21DOMAINS[j+1])
		{
		  if(verbose==1)
		  {
		    printf("VMAP %s does not match GGDM21: %s %s\n",VMAP_class_codes[i],
			     ParseDName(VMAPDOMAINS[i+1]),ParseDName(GGDM21DOMAINS[j+1]));
		  }
		  GGDM21DOMAINS[j+1] = VMAPDOMAINS[i+1];
		}
	  } 
	}


    for(j=0;j<GGDM22_U_CLASS_NUM;j++)
	{
	  if(!strcmp(VMAP_class_codes[i],GGDM22_U_class_codes[j]))
	  {
	    if(VMAPDOMAINS[i+1]!=GGDM22_UDOMAINS[j+1])
		{
		  if(verbose==1)
		  {
		    printf("VMAP %s does not match GGDM22: %s %s\n",VMAP_class_codes[i],
			     ParseDName(VMAPDOMAINS[i+1]),ParseDName(GGDM22_UDOMAINS[j+1]));
		  }
		  GGDM22_UDOMAINS[j+1] = VMAPDOMAINS[i+1];
		} 
	  } 
	}


    for(j=0;j<GGDM3_CLASS_NUM;j++)
	{
	  if(!strcmp(VMAP_class_codes[i],GGDM3_class_codes[j]))
	  {
	    if(VMAPDOMAINS[i+1]!=GGDM3DOMAINS[j+1])
		{
		  if(verbose==1)
		  {
		    printf("VMAP %s does not match GGDM3: %s %s\n",VMAP_class_codes[i],
			     ParseDName(VMAPDOMAINS[i+1]),ParseDName(GGDM3DOMAINS[j+1]));
		  }
		  GGDM3DOMAINS[j+1] = VMAPDOMAINS[i+1];
		}
	  } 
	}


    for(j=0;j<NFDD_CLASS_NUM;j++)
	{
	  if(!strcmp(VMAP_class_codes[i],NFDD_class_codes[j]))
	  {
	    if(VMAPDOMAINS[i+1]!=NFDDDOMAINS[j+1])
		{
		  if(verbose==1)
		  {
		    printf("VMAP %s does not match NFDD: %s %s\n",VMAP_class_codes[i],
			     ParseDName(VMAPDOMAINS[i+1]),ParseDName(NFDDDOMAINS[j+1]));
		  }
		  NFDDDOMAINS[j+1] = VMAPDOMAINS[i+1];
		}
	  } 
	}


    for(j=0;j<DFDD_CLASS_NUM;j++)
	{
	  if(!strcmp(VMAP_class_codes[i],DFDD_class_codes[j]))
	  {
	    if(VMAPDOMAINS[i+1]!=DFDDDOMAINS[j+1])
		{
		  if(verbose==1)
		  {
		    printf("VMAP %s does not match DFDD: %s %s\n",VMAP_class_codes[i],
			     ParseDName(VMAPDOMAINS[i+1]),ParseDName(DFDDDOMAINS[j+1]));
		  }
		  DFDDDOMAINS[j+1] = VMAPDOMAINS[i+1];
		}
	  } 
	}
  }  




  

  



  for(i=0;i<MGCP3_CLASS_NUM;i++)
  {   
            
    for(j=0;j<MGCP4_CLASS_NUM;j++)
	{
	  if(!strcmp(MGCP3_class_codes[i],MGCP4_class_codes[j]))
	  {
	    if(MGCP3DOMAINS[i+1]!=MGCP4DOMAINS[j+1])
		{
		  if(verbose==1)
		  {
		    printf("MGCP3 %s does not match MGCP4: %s %s\n",MGCP3_class_codes[i],
			     ParseDName(MGCP3DOMAINS[i+1]),ParseDName(MGCP4DOMAINS[j+1]));
		      
		  }
		  MGCP4DOMAINS[j+1] = MGCP3DOMAINS[i+1];
		}
	  } 
	}

    for(j=0;j<UFD1_CLASS_NUM;j++)
	{
	  if(!strcmp(MGCP3_class_codes[i],UFD1_class_codes[j]))
	  {
	    if(MGCP3DOMAINS[i+1]!=UFD1DOMAINS[j+1])
		{
		  if(verbose==1)
		  {
		    printf("MGCP3 %s does not match UFD1: %s %s\n",MGCP3_class_codes[i],
			     ParseDName(MGCP3DOMAINS[i+1]),ParseDName(UFD1DOMAINS[j+1]));
		  }
		  UFD1DOMAINS[j+1] = MGCP3DOMAINS[i+1];
		}
	  } 
	}

    for(j=0;j<UFD2_CLASS_NUM;j++)
	{
	  if(!strcmp(MGCP3_class_codes[i],UFD2_class_codes[j]))
	  {
	    if(MGCP3DOMAINS[i+1]!=UFD2DOMAINS[j+1])
		{
		  if(verbose==1)
		  {
		      printf("MGCP3 %s does not match UFD2: %s %s\n",MGCP3_class_codes[i],
			     ParseDName(MGCP3DOMAINS[i+1]),ParseDName(UFD2DOMAINS[j+1]));
		  }
		  UFD2DOMAINS[j+1] = MGCP3DOMAINS[i+1];
		}
	  } 
	}
      
      
    for(j=0;j<UFD3_CLASS_NUM;j++)
	{
	  if(!strcmp(MGCP3_class_codes[i],UFD3_class_codes[j]))
	  {
	    if(MGCP3DOMAINS[i+1]!=UFD3DOMAINS[j+1])
		{
		  if(verbose==1)
		  {
		    printf("MGCP3 %s does not match UFD3: %s %s\n",MGCP3_class_codes[i],
			     ParseDName(MGCP3DOMAINS[i+1]),ParseDName(UFD3DOMAINS[j+1]));
		  }
		  UFD3DOMAINS[j+1] = MGCP3DOMAINS[i+1];
		}
	  } 
	}


    for(j=0;j<TDS4_CLASS_NUM;j++)
	{
	  if(!strcmp(MGCP3_class_codes[i],TDS4_class_codes[j]))
	  {
	    if(MGCP3DOMAINS[i+1]!=TDS4DOMAINS[j+1])
		{
		  if(verbose==1)
		  {
		    printf("MGCP3 %s does not match TDS4: %s %s\n",MGCP3_class_codes[i],
			     ParseDName(MGCP3DOMAINS[i+1]),ParseDName(TDS4DOMAINS[j+1]));
		  }
		  TDS4DOMAINS[j+1] = MGCP3DOMAINS[i+1];
		}
	  } 
	}
 

    for(j=0;j<TDS6_CLASS_NUM;j++)
	{
	  if(!strcmp(MGCP3_class_codes[i],TDS6_class_codes[j]))
	  {
	    if(MGCP3DOMAINS[i+1]!=TDS6DOMAINS[j+1])
		{
		  if(verbose==1)
		  {
		    printf("MGCP3 %s does not match TDS6: %s %s\n",MGCP3_class_codes[i],
			     ParseDName(MGCP3DOMAINS[i+1]),ParseDName(TDS6DOMAINS[j+1]));
		  }
		  TDS6DOMAINS[j+1] = MGCP3DOMAINS[i+1];
		}
	  } 
	}


    for(j=0;j<SAC_CLASS_NUM;j++)
	{
	  if(!strcmp(MGCP3_class_codes[i],SAC_class_codes[j]))
	  {
	    if(MGCP3DOMAINS[i+1]!=SACDOMAINS[j+1])
		{
		  if(verbose==1)
		  {
		    printf("MGCP3 %s does not match AFD: %s %s\n",MGCP3_class_codes[i],
			     ParseDName(MGCP3DOMAINS[i+1]),ParseDName(SACDOMAINS[j+1]));
		  }
		  SACDOMAINS[j+1] = MGCP3DOMAINS[i+1];
		}
	  } 
	}


    for(j=0;j<GGDM21_CLASS_NUM;j++)
	{
	  if(!strcmp(MGCP3_class_codes[i],GGDM21_class_codes[j]))
	  {
	    if(MGCP3DOMAINS[i+1]!=GGDM21DOMAINS[j+1])
		{
		  if(verbose==1)
		  {
		    printf("MGCP3 %s does not match GGDM21: %s %s\n",MGCP3_class_codes[i],
			     ParseDName(MGCP3DOMAINS[i+1]),ParseDName(GGDM21DOMAINS[j+1]));
		  }
		  GGDM21DOMAINS[j+1] = MGCP3DOMAINS[i+1];
		}
	  } 
	}


    for(j=0;j<GGDM22_U_CLASS_NUM;j++)
	{
	  if(!strcmp(MGCP3_class_codes[i],GGDM22_U_class_codes[j]))
	  {
	    if(MGCP3DOMAINS[i+1]!=GGDM22_UDOMAINS[j+1])
		{
		  if(verbose==1)
		  {
		    printf("MGCP3 %s does not match GGDM22: %s %s\n",MGCP3_class_codes[i],
			     ParseDName(MGCP3DOMAINS[i+1]),ParseDName(GGDM22_UDOMAINS[j+1]));
		  }
		  GGDM22_UDOMAINS[j+1] = MGCP3DOMAINS[i+1];
		} 
	  } 
	}


    for(j=0;j<GGDM3_CLASS_NUM;j++)
	{
	  if(!strcmp(MGCP3_class_codes[i],GGDM3_class_codes[j]))
	  {
	    if(MGCP3DOMAINS[i+1]!=GGDM3DOMAINS[j+1])
		{
		  if(verbose==1)
		  {
		    printf("MGCP3 %s does not match GGDM3: %s %s\n",MGCP3_class_codes[i],
			     ParseDName(MGCP3DOMAINS[i+1]),ParseDName(GGDM3DOMAINS[j+1]));
		  }
		  GGDM3DOMAINS[j+1] = MGCP3DOMAINS[i+1];
		}
	  } 
	}


    for(j=0;j<NFDD_CLASS_NUM;j++)
	{
	  if(!strcmp(MGCP3_class_codes[i],NFDD_class_codes[j]))
	  {
	    if(MGCP3DOMAINS[i+1]!=NFDDDOMAINS[j+1])
		{
		  if(verbose==1)
		  {
		    printf("MGCP3 %s does not match NFDD: %s %s\n",MGCP3_class_codes[i],
			     ParseDName(MGCP3DOMAINS[i+1]),ParseDName(NFDDDOMAINS[j+1]));
		  }
		  NFDDDOMAINS[j+1] = MGCP3DOMAINS[i+1];
		}
	  } 
	}


    for(j=0;j<DFDD_CLASS_NUM;j++)
	{
	  if(!strcmp(MGCP3_class_codes[i],DFDD_class_codes[j]))
	  {
	    if(MGCP3DOMAINS[i+1]!=DFDDDOMAINS[j+1])
		{
		  if(verbose==1)
		  {
		    printf("MGCP3 %s does not match DFDD: %s %s\n",MGCP3_class_codes[i],
			     ParseDName(MGCP3DOMAINS[i+1]),ParseDName(DFDDDOMAINS[j+1]));
		  }
		  DFDDDOMAINS[j+1] = MGCP3DOMAINS[i+1];
		}
	  } 
	}
  }  


  

  




  for(i=0;i<MGCP4_CLASS_NUM;i++)
  {   

    for(j=0;j<UFD1_CLASS_NUM;j++)
	{
	  if(!strcmp(MGCP4_class_codes[i],UFD1_class_codes[j]))
	  {
	    if(MGCP4DOMAINS[i+1]!=UFD1DOMAINS[j+1])
		{
		  if(verbose==1)
		  {
		    printf("MGCP4 %s does not match UFD1: %s %s\n",MGCP4_class_codes[i],
			     ParseDName(MGCP4DOMAINS[i+1]),ParseDName(UFD1DOMAINS[j+1]));
		  }
		  UFD1DOMAINS[j+1] = MGCP4DOMAINS[i+1];
		}
	  } 
	}

    for(j=0;j<UFD2_CLASS_NUM;j++)
	{
	  if(!strcmp(MGCP4_class_codes[i],UFD2_class_codes[j]))
	  {
	    if(MGCP4DOMAINS[i+1]!=UFD2DOMAINS[j+1])
		{
		  if(verbose==1)
		  {
		      printf("MGCP4 %s does not match UFD2: %s %s\n",MGCP4_class_codes[i],
			     ParseDName(MGCP4DOMAINS[i+1]),ParseDName(UFD2DOMAINS[j+1]));
		  }
		  UFD2DOMAINS[j+1] = MGCP4DOMAINS[i+1];
		}
	  } 
	}
      
      
    for(j=0;j<UFD3_CLASS_NUM;j++)
	{
	  if(!strcmp(MGCP4_class_codes[i],UFD3_class_codes[j]))
	  {
	    if(MGCP4DOMAINS[i+1]!=UFD3DOMAINS[j+1])
		{
		  if(verbose==1)
		  {
		    printf("MGCP4 %s does not match UFD3: %s %s\n",MGCP4_class_codes[i],
			     ParseDName(MGCP4DOMAINS[i+1]),ParseDName(UFD3DOMAINS[j+1]));
		  }
		  UFD3DOMAINS[j+1] = MGCP4DOMAINS[i+1];
		}
	  } 
	}


    for(j=0;j<TDS4_CLASS_NUM;j++)
	{
	  if(!strcmp(MGCP4_class_codes[i],TDS4_class_codes[j]))
	  {
	    if(MGCP4DOMAINS[i+1]!=TDS4DOMAINS[j+1])
		{
		  if(verbose==1)
		  {
		    printf("MGCP4 %s does not match TDS4: %s %s\n",MGCP4_class_codes[i],
			     ParseDName(MGCP4DOMAINS[i+1]),ParseDName(TDS4DOMAINS[j+1]));
		  }
		  TDS4DOMAINS[j+1] = MGCP4DOMAINS[i+1];
		}
	  } 
	}
 

    for(j=0;j<TDS6_CLASS_NUM;j++)
	{
	  if(!strcmp(MGCP4_class_codes[i],TDS6_class_codes[j]))
	  {
	    if(MGCP4DOMAINS[i+1]!=TDS6DOMAINS[j+1])
		{
		  if(verbose==1)
		  {
		    printf("MGCP4 %s does not match TDS6: %s %s\n",MGCP4_class_codes[i],
			     ParseDName(MGCP4DOMAINS[i+1]),ParseDName(TDS6DOMAINS[j+1]));
		  }
		  TDS6DOMAINS[j+1] = MGCP4DOMAINS[i+1];
		}
	  } 
	}


    for(j=0;j<SAC_CLASS_NUM;j++)
	{
	  if(!strcmp(MGCP4_class_codes[i],SAC_class_codes[j]))
	  {
	    if(MGCP4DOMAINS[i+1]!=SACDOMAINS[j+1])
		{
		  if(verbose==1)
		  {
		    printf("MGCP4 %s does not match AFD: %s %s\n",MGCP4_class_codes[i],
			     ParseDName(MGCP4DOMAINS[i+1]),ParseDName(SACDOMAINS[j+1]));
		  }
		  SACDOMAINS[j+1] = MGCP4DOMAINS[i+1];
		}
	  } 
	}


    for(j=0;j<GGDM21_CLASS_NUM;j++)
	{
	  if(!strcmp(MGCP4_class_codes[i],GGDM21_class_codes[j]))
	  {
	    if(MGCP4DOMAINS[i+1]!=GGDM21DOMAINS[j+1])
		{
		  if(verbose==1)
		  {
		    printf("MGCP4 %s does not match GGDM21: %s %s\n",MGCP4_class_codes[i],
			     ParseDName(MGCP4DOMAINS[i+1]),ParseDName(GGDM21DOMAINS[j+1]));
		  }
		  GGDM21DOMAINS[j+1] = MGCP4DOMAINS[i+1];
		}
	  } 
	}


    for(j=0;j<GGDM22_U_CLASS_NUM;j++)
	{
	  if(!strcmp(MGCP4_class_codes[i],GGDM22_U_class_codes[j]))
	  {
	    if(MGCP4DOMAINS[i+1]!=GGDM22_UDOMAINS[j+1])
		{
		  if(verbose==1)
		  {
		    printf("MGCP4 %s does not match GGDM22: %s %s\n",MGCP4_class_codes[i],
			     ParseDName(MGCP4DOMAINS[i+1]),ParseDName(GGDM22_UDOMAINS[j+1]));
		  }
		  GGDM22_UDOMAINS[j+1] = MGCP4DOMAINS[i+1];
		} 
	  } 
	}


    for(j=0;j<GGDM3_CLASS_NUM;j++)
	{
	  if(!strcmp(MGCP4_class_codes[i],GGDM3_class_codes[j]))
	  {
	    if(MGCP4DOMAINS[i+1]!=GGDM3DOMAINS[j+1])
		{
		  if(verbose==1)
		  {
		    printf("MGCP4 %s does not match GGDM3: %s %s\n",MGCP4_class_codes[i],
			     ParseDName(MGCP4DOMAINS[i+1]),ParseDName(GGDM3DOMAINS[j+1]));
		  }
		  GGDM3DOMAINS[j+1] = MGCP4DOMAINS[i+1];
		}
	  } 
	}


    for(j=0;j<NFDD_CLASS_NUM;j++)
	{
	  if(!strcmp(MGCP4_class_codes[i],NFDD_class_codes[j]))
	  {
	    if(MGCP4DOMAINS[i+1]!=NFDDDOMAINS[j+1])
		{
		  if(verbose==1)
		  {
		    printf("MGCP4 %s does not match NFDD: %s %s\n",MGCP4_class_codes[i],
			     ParseDName(MGCP4DOMAINS[i+1]),ParseDName(NFDDDOMAINS[j+1]));
		  }
		  NFDDDOMAINS[j+1] = MGCP4DOMAINS[i+1];
		}
	  } 
	}


    for(j=0;j<DFDD_CLASS_NUM;j++)
	{
	  if(!strcmp(MGCP4_class_codes[i],DFDD_class_codes[j]))
	  {
	    if(MGCP4DOMAINS[i+1]!=DFDDDOMAINS[j+1])
		{
		  if(verbose==1)
		  {
		    printf("MGCP4 %s does not match DFDD: %s %s\n",MGCP4_class_codes[i],
			     ParseDName(MGCP4DOMAINS[i+1]),ParseDName(DFDDDOMAINS[j+1]));
		  }
		  DFDDDOMAINS[j+1] = MGCP4DOMAINS[i+1];
		}
	  } 
	}
  }  


  

  

  
  for(i=0;i<UFD1_CLASS_NUM;i++)
  {   

    for(j=0;j<UFD2_CLASS_NUM;j++)
	{
	  if(!strcmp(UFD1_class_codes[i],UFD2_class_codes[j]))
	  {
	    if(UFD1DOMAINS[i+1]!=UFD2DOMAINS[j+1])
		{
		  if(verbose==1)
		  {
		      printf("UFD1 %s does not match UFD2: %s %s\n",UFD1_class_codes[i],
			     ParseDName(UFD1DOMAINS[i+1]),ParseDName(UFD2DOMAINS[j+1]));
		  }
		  UFD2DOMAINS[j+1] = UFD1DOMAINS[i+1];
		}
	  } 
	}
      
      
    for(j=0;j<UFD3_CLASS_NUM;j++)
	{
	  if(!strcmp(UFD1_class_codes[i],UFD3_class_codes[j]))
	  {
	    if(UFD1DOMAINS[i+1]!=UFD3DOMAINS[j+1])
		{
		  if(verbose==1)
		  {
		    printf("UFD1 %s does not match UFD3: %s %s\n",UFD1_class_codes[i],
			     ParseDName(UFD1DOMAINS[i+1]),ParseDName(UFD3DOMAINS[j+1]));
		  }
		  UFD3DOMAINS[j+1] = UFD1DOMAINS[i+1];
		}
	  } 
	}


    for(j=0;j<TDS4_CLASS_NUM;j++)
	{
	  if(!strcmp(UFD1_class_codes[i],TDS4_class_codes[j]))
	  {
	    if(UFD1DOMAINS[i+1]!=TDS4DOMAINS[j+1])
		{
		  if(verbose==1)
		  {
		    printf("UFD1 %s does not match TDS4: %s %s\n",UFD1_class_codes[i],
			     ParseDName(UFD1DOMAINS[i+1]),ParseDName(TDS4DOMAINS[j+1]));
		  }
		  TDS4DOMAINS[j+1] = UFD1DOMAINS[i+1];
		}
	  } 
	}
 

    for(j=0;j<TDS6_CLASS_NUM;j++)
	{
	  if(!strcmp(UFD1_class_codes[i],TDS6_class_codes[j]))
	  {
	    if(UFD1DOMAINS[i+1]!=TDS6DOMAINS[j+1])
		{
		  if(verbose==1)
		  {
		    printf("UFD1 %s does not match TDS6: %s %s\n",UFD1_class_codes[i],
			     ParseDName(UFD1DOMAINS[i+1]),ParseDName(TDS6DOMAINS[j+1]));
		  }
		  TDS6DOMAINS[j+1] = UFD1DOMAINS[i+1];
		}
	  } 
	}


    for(j=0;j<SAC_CLASS_NUM;j++)
	{
	  if(!strcmp(UFD1_class_codes[i],SAC_class_codes[j]))
	  {
	    if(UFD1DOMAINS[i+1]!=SACDOMAINS[j+1])
		{
		  if(verbose==1)
		  {
		    printf("UFD1 %s does not match AFD: %s %s\n",UFD1_class_codes[i],
			     ParseDName(UFD1DOMAINS[i+1]),ParseDName(SACDOMAINS[j+1]));
		  }
		  SACDOMAINS[j+1] = UFD1DOMAINS[i+1];
		}
	  } 
	}


    for(j=0;j<GGDM21_CLASS_NUM;j++)
	{
	  if(!strcmp(UFD1_class_codes[i],GGDM21_class_codes[j]))
	  {
	    if(UFD1DOMAINS[i+1]!=GGDM21DOMAINS[j+1])
		{
		  if(verbose==1)
		  {
		    printf("UFD1 %s does not match GGDM21: %s %s\n",UFD1_class_codes[i],
			     ParseDName(UFD1DOMAINS[i+1]),ParseDName(GGDM21DOMAINS[j+1]));
		  }
		  GGDM21DOMAINS[j+1] = UFD1DOMAINS[i+1];
		}
	  } 
	}


    for(j=0;j<GGDM22_U_CLASS_NUM;j++)
	{
	  if(!strcmp(UFD1_class_codes[i],GGDM22_U_class_codes[j]))
	  {
	    if(UFD1DOMAINS[i+1]!=GGDM22_UDOMAINS[j+1])
		{
		  if(verbose==1)
		  {
		    printf("UFD1 %s does not match GGDM22: %s %s\n",UFD1_class_codes[i],
			     ParseDName(UFD1DOMAINS[i+1]),ParseDName(GGDM22_UDOMAINS[j+1]));
		  }
		  GGDM22_UDOMAINS[j+1] = UFD1DOMAINS[i+1];
		} 
	  } 
	}


    for(j=0;j<GGDM3_CLASS_NUM;j++)
	{
	  if(!strcmp(UFD1_class_codes[i],GGDM3_class_codes[j]))
	  {
	    if(UFD1DOMAINS[i+1]!=GGDM3DOMAINS[j+1])
		{
		  if(verbose==1)
		  {
		    printf("UFD1 %s does not match GGDM3: %s %s\n",UFD1_class_codes[i],
			     ParseDName(UFD1DOMAINS[i+1]),ParseDName(GGDM3DOMAINS[j+1]));
		  }
		  GGDM3DOMAINS[j+1] = UFD1DOMAINS[i+1];
		}
	  } 
	}


    for(j=0;j<NFDD_CLASS_NUM;j++)
	{
	  if(!strcmp(UFD1_class_codes[i],NFDD_class_codes[j]))
	  {
	    if(UFD1DOMAINS[i+1]!=NFDDDOMAINS[j+1])
		{
		  if(verbose==1)
		  {
		    printf("UFD1 %s does not match NFDD: %s %s\n",UFD1_class_codes[i],
			     ParseDName(UFD1DOMAINS[i+1]),ParseDName(NFDDDOMAINS[j+1]));
		  }
		  NFDDDOMAINS[j+1] = UFD1DOMAINS[i+1];
		}
	  } 
	}


    for(j=0;j<DFDD_CLASS_NUM;j++)
	{
	  if(!strcmp(UFD1_class_codes[i],DFDD_class_codes[j]))
	  {
	    if(UFD1DOMAINS[i+1]!=DFDDDOMAINS[j+1])
		{
		  if(verbose==1)
		  {
		    printf("UFD1 %s does not match DFDD: %s %s\n",UFD1_class_codes[i],
			     ParseDName(UFD1DOMAINS[i+1]),ParseDName(DFDDDOMAINS[j+1]));
		  }
		  DFDDDOMAINS[j+1] = UFD1DOMAINS[i+1];
		}
	  } 
	}
  }  




  

  


  for(i=0;i<UFD2_CLASS_NUM;i++)
  {   
      
    for(j=0;j<UFD3_CLASS_NUM;j++)
	{
	  if(!strcmp(UFD2_class_codes[i],UFD3_class_codes[j]))
	  {
	    if(UFD2DOMAINS[i+1]!=UFD3DOMAINS[j+1])
		{
		  if(verbose==1)
		  {
		    printf("UFD2 %s does not match UFD3: %s %s\n",UFD2_class_codes[i],
			     ParseDName(UFD2DOMAINS[i+1]),ParseDName(UFD3DOMAINS[j+1]));
		  }
		  UFD3DOMAINS[j+1] = UFD2DOMAINS[i+1];
		}
	  } 
	}


    for(j=0;j<TDS4_CLASS_NUM;j++)
	{
	  if(!strcmp(UFD2_class_codes[i],TDS4_class_codes[j]))
	  {
	    if(UFD2DOMAINS[i+1]!=TDS4DOMAINS[j+1])
		{
		  if(verbose==1)
		  {
		    printf("UFD2 %s does not match TDS4: %s %s\n",UFD2_class_codes[i],
			     ParseDName(UFD2DOMAINS[i+1]),ParseDName(TDS4DOMAINS[j+1]));
		  }
		  TDS4DOMAINS[j+1] = UFD2DOMAINS[i+1];
		}
	  } 
	}
 

    for(j=0;j<TDS6_CLASS_NUM;j++)
	{
	  if(!strcmp(UFD2_class_codes[i],TDS6_class_codes[j]))
	  {
	    if(UFD2DOMAINS[i+1]!=TDS6DOMAINS[j+1])
		{
		  if(verbose==1)
		  {
		    printf("UFD2 %s does not match TDS6: %s %s\n",UFD2_class_codes[i],
			     ParseDName(UFD2DOMAINS[i+1]),ParseDName(TDS6DOMAINS[j+1]));
		  }
		  TDS6DOMAINS[j+1] = UFD2DOMAINS[i+1];
		}
	  } 
	}


    for(j=0;j<SAC_CLASS_NUM;j++)
	{
	  if(!strcmp(UFD2_class_codes[i],SAC_class_codes[j]))
	  {
	    if(UFD2DOMAINS[i+1]!=SACDOMAINS[j+1])
		{
		  if(verbose==1)
		  {
		    printf("UFD2 %s does not match AFD: %s %s\n",UFD2_class_codes[i],
			     ParseDName(UFD2DOMAINS[i+1]),ParseDName(SACDOMAINS[j+1]));
		  }
		  SACDOMAINS[j+1] = UFD2DOMAINS[i+1];
		}
	  } 
	}


    for(j=0;j<GGDM21_CLASS_NUM;j++)
	{
	  if(!strcmp(UFD2_class_codes[i],GGDM21_class_codes[j]))
	  {
	    if(UFD2DOMAINS[i+1]!=GGDM21DOMAINS[j+1])
		{
		  if(verbose==1)
		  {
		    printf("UFD2 %s does not match GGDM21: %s %s\n",UFD2_class_codes[i],
			     ParseDName(UFD2DOMAINS[i+1]),ParseDName(GGDM21DOMAINS[j+1]));
		  }
		  GGDM21DOMAINS[j+1] = UFD2DOMAINS[i+1];
		}
	  } 
	}


    for(j=0;j<GGDM22_U_CLASS_NUM;j++)
	{
	  if(!strcmp(UFD2_class_codes[i],GGDM22_U_class_codes[j]))
	  {
	    if(UFD2DOMAINS[i+1]!=GGDM22_UDOMAINS[j+1])
		{
		  if(verbose==1)
		  {
		    printf("UFD2 %s does not match GGDM22: %s %s\n",UFD2_class_codes[i],
			     ParseDName(UFD2DOMAINS[i+1]),ParseDName(GGDM22_UDOMAINS[j+1]));
		  }
		  GGDM22_UDOMAINS[j+1] = UFD2DOMAINS[i+1];
		} 
	  } 
	}


    for(j=0;j<GGDM3_CLASS_NUM;j++)
	{
	  if(!strcmp(UFD2_class_codes[i],GGDM3_class_codes[j]))
	  {
	    if(UFD2DOMAINS[i+1]!=GGDM3DOMAINS[j+1])
		{
		  if(verbose==1)
		  {
		    printf("UFD2 %s does not match GGDM3: %s %s\n",UFD2_class_codes[i],
			     ParseDName(UFD2DOMAINS[i+1]),ParseDName(GGDM3DOMAINS[j+1]));
		  }
		  GGDM3DOMAINS[j+1] = UFD2DOMAINS[i+1];
		}
	  } 
	}


    for(j=0;j<NFDD_CLASS_NUM;j++)
	{
	  if(!strcmp(UFD2_class_codes[i],NFDD_class_codes[j]))
	  {
	    if(UFD2DOMAINS[i+1]!=NFDDDOMAINS[j+1])
		{
		  if(verbose==1)
		  {
		    printf("UFD2 %s does not match NFDD: %s %s\n",UFD2_class_codes[i],
			     ParseDName(UFD2DOMAINS[i+1]),ParseDName(NFDDDOMAINS[j+1]));
		  }
		  NFDDDOMAINS[j+1] = UFD2DOMAINS[i+1];
		}
	  } 
	}


    for(j=0;j<DFDD_CLASS_NUM;j++)
	{
	  if(!strcmp(UFD2_class_codes[i],DFDD_class_codes[j]))
	  {
	    if(UFD2DOMAINS[i+1]!=DFDDDOMAINS[j+1])
		{
		  if(verbose==1)
		  {
		    printf("UFD2 %s does not match DFDD: %s %s\n",UFD2_class_codes[i],
			     ParseDName(UFD2DOMAINS[i+1]),ParseDName(DFDDDOMAINS[j+1]));
		  }
		  DFDDDOMAINS[j+1] = UFD2DOMAINS[i+1];
		}
	  } 
	}
  }  



  
 
  


  for(i=0;i<UFD3_CLASS_NUM;i++)
  {   

    for(j=0;j<TDS4_CLASS_NUM;j++)
	{
	  if(!strcmp(UFD3_class_codes[i],TDS4_class_codes[j]))
	  {
	    if(UFD3DOMAINS[i+1]!=TDS4DOMAINS[j+1])
		{
		  if(verbose==1)
		  {
		    printf("UFD3 %s does not match TDS4: %s %s\n",UFD3_class_codes[i],
			     ParseDName(UFD3DOMAINS[i+1]),ParseDName(TDS4DOMAINS[j+1]));
		  }
		  TDS4DOMAINS[j+1] = UFD3DOMAINS[i+1];
		}
	  } 
	}
 

    for(j=0;j<TDS6_CLASS_NUM;j++)
	{
	  if(!strcmp(UFD3_class_codes[i],TDS6_class_codes[j]))
	  {
	    if(UFD3DOMAINS[i+1]!=TDS6DOMAINS[j+1])
		{
		  if(verbose==1)
		  {
		    printf("UFD3 %s does not match TDS6: %s %s\n",UFD3_class_codes[i],
			     ParseDName(UFD3DOMAINS[i+1]),ParseDName(TDS6DOMAINS[j+1]));
		  }
		  TDS6DOMAINS[j+1] = UFD3DOMAINS[i+1];
		}
	  } 
	}


    for(j=0;j<SAC_CLASS_NUM;j++)
	{
	  if(!strcmp(UFD3_class_codes[i],SAC_class_codes[j]))
	  {
	    if(UFD3DOMAINS[i+1]!=SACDOMAINS[j+1])
		{
		  if(verbose==1)
		  {
		    printf("UFD3 %s does not match AFD: %s %s\n",UFD3_class_codes[i],
			     ParseDName(UFD3DOMAINS[i+1]),ParseDName(SACDOMAINS[j+1]));
		  }
		  SACDOMAINS[j+1] = UFD3DOMAINS[i+1];
		}
	  } 
	}


    for(j=0;j<GGDM21_CLASS_NUM;j++)
	{
	  if(!strcmp(UFD3_class_codes[i],GGDM21_class_codes[j]))
	  {
	    if(UFD3DOMAINS[i+1]!=GGDM21DOMAINS[j+1])
		{
		  if(verbose==1)
		  {
		    printf("UFD3 %s does not match GGDM21: %s %s\n",UFD3_class_codes[i],
			     ParseDName(UFD3DOMAINS[i+1]),ParseDName(GGDM21DOMAINS[j+1]));
		  }
		  GGDM21DOMAINS[j+1] = UFD3DOMAINS[i+1];
		}
	  } 
	}


    for(j=0;j<GGDM22_U_CLASS_NUM;j++)
	{
	  if(!strcmp(UFD3_class_codes[i],GGDM22_U_class_codes[j]))
	  {
	    if(UFD3DOMAINS[i+1]!=GGDM22_UDOMAINS[j+1])
		{
		  if(verbose==1)
		  {
		    printf("UFD3 %s does not match GGDM22: %s %s\n",UFD3_class_codes[i],
			     ParseDName(UFD3DOMAINS[i+1]),ParseDName(GGDM22_UDOMAINS[j+1]));
		  }
		  GGDM22_UDOMAINS[j+1] = UFD3DOMAINS[i+1];
		} 
	  } 
	}


    for(j=0;j<GGDM3_CLASS_NUM;j++)
	{
	  if(!strcmp(UFD3_class_codes[i],GGDM3_class_codes[j]))
	  {
	    if(UFD3DOMAINS[i+1]!=GGDM3DOMAINS[j+1])
		{
		  if(verbose==1)
		  {
		    printf("UFD3 %s does not match GGDM3: %s %s\n",UFD3_class_codes[i],
			     ParseDName(UFD3DOMAINS[i+1]),ParseDName(GGDM3DOMAINS[j+1]));
		  }
		  GGDM3DOMAINS[j+1] = UFD3DOMAINS[i+1];
		}
	  } 
	}


    for(j=0;j<NFDD_CLASS_NUM;j++)
	{
	  if(!strcmp(UFD3_class_codes[i],NFDD_class_codes[j]))
	  {
	    if(UFD3DOMAINS[i+1]!=NFDDDOMAINS[j+1])
		{
		  if(verbose==1)
		  {
		    printf("UFD3 %s does not match NFDD: %s %s\n",UFD3_class_codes[i],
			     ParseDName(UFD3DOMAINS[i+1]),ParseDName(NFDDDOMAINS[j+1]));
		  }
		  NFDDDOMAINS[j+1] = UFD3DOMAINS[i+1];
		}
	  } 
	}


    for(j=0;j<DFDD_CLASS_NUM;j++)
	{
	  if(!strcmp(UFD3_class_codes[i],DFDD_class_codes[j]))
	  {
	    if(UFD3DOMAINS[i+1]!=DFDDDOMAINS[j+1])
		{
		  if(verbose==1)
		  {
		    printf("UFD3 %s does not match DFDD: %s %s\n",UFD3_class_codes[i],
			     ParseDName(UFD3DOMAINS[i+1]),ParseDName(DFDDDOMAINS[j+1]));
		  }
		  DFDDDOMAINS[j+1] = UFD3DOMAINS[i+1];
		}
	  } 
	}
  }  



  
    
  


  for(i=0;i<TDS4_CLASS_NUM;i++)
  {   
 
    for(j=0;j<TDS6_CLASS_NUM;j++)
	{
	  if(!strcmp(TDS4_class_codes[i],TDS6_class_codes[j]))
	  {
	    if(TDS4DOMAINS[i+1]!=TDS6DOMAINS[j+1])
		{
		  if(verbose==1)
		  {
		    printf("TDS4 %s does not match TDS6: %s %s\n",TDS4_class_codes[i],
			     ParseDName(TDS4DOMAINS[i+1]),ParseDName(TDS6DOMAINS[j+1]));
		  }
		  TDS6DOMAINS[j+1] = TDS4DOMAINS[i+1];
		}
	  } 
	}


    for(j=0;j<SAC_CLASS_NUM;j++)
	{
	  if(!strcmp(TDS4_class_codes[i],SAC_class_codes[j]))
	  {
	    if(TDS4DOMAINS[i+1]!=SACDOMAINS[j+1])
		{
		  if(verbose==1)
		  {
		    printf("TDS4 %s does not match AFD: %s %s\n",TDS4_class_codes[i],
			     ParseDName(TDS4DOMAINS[i+1]),ParseDName(SACDOMAINS[j+1]));
		  }
		  SACDOMAINS[j+1] = TDS4DOMAINS[i+1];
		}
	  } 
	}


    for(j=0;j<GGDM21_CLASS_NUM;j++)
	{
	  if(!strcmp(TDS4_class_codes[i],GGDM21_class_codes[j]))
	  {
	    if(TDS4DOMAINS[i+1]!=GGDM21DOMAINS[j+1])
		{
		  if(verbose==1)
		  {
		    printf("TDS4 %s does not match GGDM21: %s %s\n",TDS4_class_codes[i],
			     ParseDName(TDS4DOMAINS[i+1]),ParseDName(GGDM21DOMAINS[j+1]));
		  }
		  GGDM21DOMAINS[j+1] = TDS4DOMAINS[i+1];
		}
	  } 
	}


    for(j=0;j<GGDM22_U_CLASS_NUM;j++)
	{
	  if(!strcmp(TDS4_class_codes[i],GGDM22_U_class_codes[j]))
	  {
	    if(TDS4DOMAINS[i+1]!=GGDM22_UDOMAINS[j+1])
		{
		  if(verbose==1)
		  {
		    printf("TDS4 %s does not match GGDM22: %s %s\n",TDS4_class_codes[i],
			     ParseDName(TDS4DOMAINS[i+1]),ParseDName(GGDM22_UDOMAINS[j+1]));
		  }
		  GGDM22_UDOMAINS[j+1] = TDS4DOMAINS[i+1];
		} 
	  } 
	}


    for(j=0;j<GGDM3_CLASS_NUM;j++)
	{
	  if(!strcmp(TDS4_class_codes[i],GGDM3_class_codes[j]))
	  {
	    if(TDS4DOMAINS[i+1]!=GGDM3DOMAINS[j+1])
		{
		  if(verbose==1)
		  {
		    printf("TDS4 %s does not match GGDM3: %s %s\n",TDS4_class_codes[i],
			     ParseDName(TDS4DOMAINS[i+1]),ParseDName(GGDM3DOMAINS[j+1]));
		  }
		  GGDM3DOMAINS[j+1] = TDS4DOMAINS[i+1];
		}
	  } 
	}


    for(j=0;j<NFDD_CLASS_NUM;j++)
	{
	  if(!strcmp(TDS4_class_codes[i],NFDD_class_codes[j]))
	  {
	    if(TDS4DOMAINS[i+1]!=NFDDDOMAINS[j+1])
		{
		  if(verbose==1)
		  {
		    printf("TDS4 %s does not match NFDD: %s %s\n",TDS4_class_codes[i],
			     ParseDName(TDS4DOMAINS[i+1]),ParseDName(NFDDDOMAINS[j+1]));
		  }
		  NFDDDOMAINS[j+1] = TDS4DOMAINS[i+1];
		}
	  } 
	}


    for(j=0;j<DFDD_CLASS_NUM;j++)
	{
	  if(!strcmp(TDS4_class_codes[i],DFDD_class_codes[j]))
	  {
	    if(TDS4DOMAINS[i+1]!=DFDDDOMAINS[j+1])
		{
		  if(verbose==1)
		  {
		    printf("TDS4 %s does not match DFDD: %s %s\n",TDS4_class_codes[i],
			     ParseDName(TDS4DOMAINS[i+1]),ParseDName(DFDDDOMAINS[j+1]));
		  }
		  DFDDDOMAINS[j+1] = TDS4DOMAINS[i+1];
		}
	  } 
	}
  }  


  
    
  


  for(i=0;i<TDS6_CLASS_NUM;i++)
  {   
    for(j=0;j<SAC_CLASS_NUM;j++)
	{
	  if(!strcmp(TDS6_class_codes[i],SAC_class_codes[j]))
	  {
	    if(TDS6DOMAINS[i+1]!=SACDOMAINS[j+1])
		{
		  if(verbose==1)
		  {
		    printf("TDS6 %s does not match AFD: %s %s\n",TDS6_class_codes[i],
			     ParseDName(TDS6DOMAINS[i+1]),ParseDName(SACDOMAINS[j+1]));
		  }
		  SACDOMAINS[j+1] = TDS6DOMAINS[i+1];
		}
	  } 
	}


    for(j=0;j<GGDM21_CLASS_NUM;j++)
	{
	  if(!strcmp(TDS6_class_codes[i],GGDM21_class_codes[j]))
	  {
	    if(TDS6DOMAINS[i+1]!=GGDM21DOMAINS[j+1])
		{
		  if(verbose==1)
		  {
		    printf("TDS6 %s does not match GGDM21: %s %s\n",TDS6_class_codes[i],
			     ParseDName(TDS6DOMAINS[i+1]),ParseDName(GGDM21DOMAINS[j+1]));
		  }
		  GGDM21DOMAINS[j+1] = TDS6DOMAINS[i+1];
		}
	  } 
	}


    for(j=0;j<GGDM22_U_CLASS_NUM;j++)
	{
	  if(!strcmp(TDS6_class_codes[i],GGDM22_U_class_codes[j]))
	  {
	    if(TDS6DOMAINS[i+1]!=GGDM22_UDOMAINS[j+1])
		{
		  if(verbose==1)
		  {
		    printf("TDS6 %s does not match GGDM22: %s %s\n",TDS6_class_codes[i],
			     ParseDName(TDS6DOMAINS[i+1]),ParseDName(GGDM22_UDOMAINS[j+1]));
		  }
		  GGDM22_UDOMAINS[j+1] = TDS6DOMAINS[i+1];
		} 
	  } 
	}


    for(j=0;j<GGDM3_CLASS_NUM;j++)
	{
	  if(!strcmp(TDS6_class_codes[i],GGDM3_class_codes[j]))
	  {
	    if(TDS6DOMAINS[i+1]!=GGDM3DOMAINS[j+1])
		{
		  if(verbose==1)
		  {
		    printf("TDS6 %s does not match GGDM3: %s %s\n",TDS6_class_codes[i],
			     ParseDName(TDS6DOMAINS[i+1]),ParseDName(GGDM3DOMAINS[j+1]));
		  }
		  GGDM3DOMAINS[j+1] = TDS6DOMAINS[i+1];
		}
	  } 
	}


    for(j=0;j<NFDD_CLASS_NUM;j++)
	{
	  if(!strcmp(TDS6_class_codes[i],NFDD_class_codes[j]))
	  {
	    if(TDS6DOMAINS[i+1]!=NFDDDOMAINS[j+1])
		{
		  if(verbose==1)
		  {
		    printf("TDS6 %s does not match NFDD: %s %s\n",TDS6_class_codes[i],
			     ParseDName(TDS6DOMAINS[i+1]),ParseDName(NFDDDOMAINS[j+1]));
		  }
		  NFDDDOMAINS[j+1] = TDS6DOMAINS[i+1];
		}
	  } 
	}


    for(j=0;j<DFDD_CLASS_NUM;j++)
	{
	  if(!strcmp(TDS6_class_codes[i],DFDD_class_codes[j]))
	  {
	    if(TDS6DOMAINS[i+1]!=DFDDDOMAINS[j+1])
		{
		  if(verbose==1)
		  {
		    printf("TDS6 %s does not match DFDD: %s %s\n",TDS6_class_codes[i],
			     ParseDName(TDS6DOMAINS[i+1]),ParseDName(DFDDDOMAINS[j+1]));
		  }
		  DFDDDOMAINS[j+1] = TDS6DOMAINS[i+1];
		}
	  } 
	}
  }  



  
    
  


  for(i=0;i<SAC_CLASS_NUM;i++)
  {   

    for(j=0;j<GGDM21_CLASS_NUM;j++)
	{
	  if(!strcmp(SAC_class_codes[i],GGDM21_class_codes[j]))
	  {
	    if(SACDOMAINS[i+1]!=GGDM21DOMAINS[j+1])
		{
		  if(verbose==1)
		  {
		    printf("AFD %s does not match GGDM21: %s %s\n",SAC_class_codes[i],
			     ParseDName(SACDOMAINS[i+1]),ParseDName(GGDM21DOMAINS[j+1]));
		  }
		  GGDM21DOMAINS[j+1] = SACDOMAINS[i+1];
		}
	  } 
	}


    for(j=0;j<GGDM22_U_CLASS_NUM;j++)
	{
	  if(!strcmp(SAC_class_codes[i],GGDM22_U_class_codes[j]))
	  {
	    if(SACDOMAINS[i+1]!=GGDM22_UDOMAINS[j+1])
		{
		  if(verbose==1)
		  {
		    printf("AFD %s does not match GGDM22: %s %s\n",SAC_class_codes[i],
			     ParseDName(SACDOMAINS[i+1]),ParseDName(GGDM22_UDOMAINS[j+1]));
		  }
		  GGDM22_UDOMAINS[j+1] = SACDOMAINS[i+1];
		} 
	  } 
	}


    for(j=0;j<GGDM3_CLASS_NUM;j++)
	{
	  if(!strcmp(SAC_class_codes[i],GGDM3_class_codes[j]))
	  {
	    if(SACDOMAINS[i+1]!=GGDM3DOMAINS[j+1])
		{
		  if(verbose==1)
		  {
		    printf("AFD %s does not match GGDM3: %s %s\n",SAC_class_codes[i],
			     ParseDName(SACDOMAINS[i+1]),ParseDName(GGDM3DOMAINS[j+1]));
		  }
		  GGDM3DOMAINS[j+1] = SACDOMAINS[i+1];
		}
	  } 
	}


    for(j=0;j<NFDD_CLASS_NUM;j++)
	{
	  if(!strcmp(SAC_class_codes[i],NFDD_class_codes[j]))
	  {
	    if(SACDOMAINS[i+1]!=NFDDDOMAINS[j+1])
		{
		  if(verbose==1)
		  {
		    printf("AFD %s does not match NFDD: %s %s\n",SAC_class_codes[i],
			     ParseDName(SACDOMAINS[i+1]),ParseDName(NFDDDOMAINS[j+1]));
		  }
		  NFDDDOMAINS[j+1] = SACDOMAINS[i+1];
		}
	  } 
	}


    for(j=0;j<DFDD_CLASS_NUM;j++)
	{
	  if(!strcmp(SAC_class_codes[i],DFDD_class_codes[j]))
	  {
	    if(SACDOMAINS[i+1]!=DFDDDOMAINS[j+1])
		{
		  if(verbose==1)
		  {
		    printf("AFD %s does not match DFDD: %s %s\n",SAC_class_codes[i],
			     ParseDName(SACDOMAINS[i+1]),ParseDName(DFDDDOMAINS[j+1]));
		  }
		  DFDDDOMAINS[j+1] = SACDOMAINS[i+1];
		}
	  } 
	}
  }  




  
    
  


  for(i=0;i<GGDM21_CLASS_NUM;i++)
  {   

    for(j=0;j<GGDM22_U_CLASS_NUM;j++)
	{
	  if(!strcmp(GGDM21_class_codes[i],GGDM22_U_class_codes[j]))
	  {
	    if(GGDM21DOMAINS[i+1]!=GGDM22_UDOMAINS[j+1])
		{
		  if(verbose==1)
		  {
		    printf("GGDM21 %s does not match GGDM22: %s %s\n",GGDM21_class_codes[i],
			     ParseDName(GGDM21DOMAINS[i+1]),ParseDName(GGDM22_UDOMAINS[j+1]));
		  }
		  GGDM22_UDOMAINS[j+1] = GGDM21DOMAINS[i+1];
		} 
	  } 
	}


    for(j=0;j<GGDM3_CLASS_NUM;j++)
	{
	  if(!strcmp(GGDM21_class_codes[i],GGDM3_class_codes[j]))
	  {
	    if(GGDM21DOMAINS[i+1]!=GGDM3DOMAINS[j+1])
		{
		  if(verbose==1)
		  {
		    printf("GGDM21 %s does not match GGDM3: %s %s\n",GGDM21_class_codes[i],
			     ParseDName(GGDM21DOMAINS[i+1]),ParseDName(GGDM3DOMAINS[j+1]));
		  }
		  GGDM3DOMAINS[j+1] = GGDM21DOMAINS[i+1];
		}
	  } 
	}


    for(j=0;j<NFDD_CLASS_NUM;j++)
	{
	  if(!strcmp(GGDM21_class_codes[i],NFDD_class_codes[j]))
	  {
	    if(GGDM21DOMAINS[i+1]!=NFDDDOMAINS[j+1])
		{
		  if(verbose==1)
		  {
		    printf("GGDM21 %s does not match NFDD: %s %s\n",GGDM21_class_codes[i],
			     ParseDName(GGDM21DOMAINS[i+1]),ParseDName(NFDDDOMAINS[j+1]));
		  }
		  NFDDDOMAINS[j+1] = GGDM21DOMAINS[i+1];
		}
	  } 
	}


    for(j=0;j<DFDD_CLASS_NUM;j++)
	{
	  if(!strcmp(GGDM21_class_codes[i],DFDD_class_codes[j]))
	  {
	    if(GGDM21DOMAINS[i+1]!=DFDDDOMAINS[j+1])
		{
		  if(verbose==1)
		  {
		    printf("GGDM21 %s does not match DFDD: %s %s\n",GGDM21_class_codes[i],
			     ParseDName(GGDM21DOMAINS[i+1]),ParseDName(DFDDDOMAINS[j+1]));
		  }
		  DFDDDOMAINS[j+1] = GGDM21DOMAINS[i+1];
		}
	  } 
	}
  }  

  
  
    
  


  for(i=0;i<GGDM22_U_CLASS_NUM;i++)
  {   

    for(j=0;j<GGDM3_CLASS_NUM;j++)
	{
	  if(!strcmp(GGDM22_U_class_codes[i],GGDM3_class_codes[j]))
	  {
	    if(GGDM22_UDOMAINS[i+1]!=GGDM3DOMAINS[j+1])
		{
		  if(verbose==1)
		  {
		    printf("GGDM22 %s does not match GGDM3: %s %s\n",GGDM22_U_class_codes[i],
			     ParseDName(GGDM22_UDOMAINS[i+1]),ParseDName(GGDM3DOMAINS[j+1]));
		  }
		  GGDM3DOMAINS[j+1] = GGDM22_UDOMAINS[i+1];
		}
	  } 
	}


    for(j=0;j<NFDD_CLASS_NUM;j++)
	{
	  if(!strcmp(GGDM22_U_class_codes[i],NFDD_class_codes[j]))
	  {
	    if(GGDM22_UDOMAINS[i+1]!=NFDDDOMAINS[j+1])
		{
		  if(verbose==1)
		  {
		    printf("GGDM22 %s does not match NFDD: %s %s\n",GGDM22_U_class_codes[i],
			     ParseDName(GGDM22_UDOMAINS[i+1]),ParseDName(NFDDDOMAINS[j+1]));
		  }
		  NFDDDOMAINS[j+1] = GGDM22_UDOMAINS[i+1];
		}
	  } 
	}


    for(j=0;j<DFDD_CLASS_NUM;j++)
	{
	  if(!strcmp(GGDM22_U_class_codes[i],DFDD_class_codes[j]))
	  {
	    if(GGDM22_UDOMAINS[i+1]!=DFDDDOMAINS[j+1])
		{
		  if(verbose==1)
		  {
		    printf("GGDM22 %s does not match DFDD: %s %s\n",GGDM22_U_class_codes[i],
			     ParseDName(GGDM22_UDOMAINS[i+1]),ParseDName(DFDDDOMAINS[j+1]));
		  }
		  DFDDDOMAINS[j+1] = GGDM22_UDOMAINS[i+1];
		}
	  } 
	}
  }  


  
    
  


  for(i=0;i<GGDM3_CLASS_NUM;i++)
  {   

    for(j=0;j<NFDD_CLASS_NUM;j++)
	{
	  if(!strcmp(GGDM3_class_codes[i],NFDD_class_codes[j]))
	  {
	    if(GGDM3DOMAINS[i+1]!=NFDDDOMAINS[j+1])
		{
		  if(verbose==1)
		  {
		    printf("GGDM3 %s does not match NFDD: %s %s\n",GGDM3_class_codes[i],
			     ParseDName(GGDM3DOMAINS[i+1]),ParseDName(NFDDDOMAINS[j+1]));
		  }
		  NFDDDOMAINS[j+1] = GGDM3DOMAINS[i+1];
		}
	  } 
	}


    for(j=0;j<DFDD_CLASS_NUM;j++)
	{
	  if(!strcmp(GGDM3_class_codes[i],DFDD_class_codes[j]))
	  {
	    if(GGDM3DOMAINS[i+1]!=DFDDDOMAINS[j+1])
		{
		  if(verbose==1)
		  {
		    printf("GGDM3 %s does not match DFDD: %s %s\n",GGDM3_class_codes[i],
			     ParseDName(GGDM3DOMAINS[i+1]),ParseDName(DFDDDOMAINS[j+1]));
		  }
		  DFDDDOMAINS[j+1] = GGDM3DOMAINS[i+1];
		}
	  } 
	}
  }  



  
    
  


  for(i=0;i<NFDD_CLASS_NUM;i++)
  {   

    for(j=0;j<DFDD_CLASS_NUM;j++)
	{
	  if(!strcmp(NFDD_class_codes[i],DFDD_class_codes[j]))
	  {
	    if(NFDDDOMAINS[i+1]!=DFDDDOMAINS[j+1])
		{
		  if(verbose==1)
		  {
		    printf("NFDD %s does not match DFDD: %s %s\n",NFDD_class_codes[i],
			     ParseDName(NFDDDOMAINS[i+1]),ParseDName(DFDDDOMAINS[j+1]));
		  }
		  DFDDDOMAINS[j+1] = NFDDDOMAINS[i+1];
		}
	  } 
	}
  }  



  
   

 


 if(verbose==0)
 {
   return;
 }






 for(i=0;i<GGDM3_CLASS_NUM;i++)
 { 
   for(j=0;j<GGDM22_U_CLASS_NUM;j++)
	{
	  if(!strcmp(GGDM3_class_codes[i],GGDM22_U_class_codes[j]))
	    {
	      if(GGDM3DOMAINS[i+1]!=GGDM22_UDOMAINS[j+1])
		  {
		    if(verbose==1)
		    {
		      printf("GGDM3 %s does not match GGDM22_U: %s %s\n",GGDM3_class_codes[i],
			     ParseDName(GGDM3DOMAINS[i+1]),ParseDName(GGDM22_UDOMAINS[j+1]));
		    }
		  GGDM22_UDOMAINS[j+1] = GGDM3DOMAINS[i+1];
		}
	  } 
	}
 }















  printf("\n\nGGDM3/GGDM22_U same FCODE different name:\n");
  
  for(i=0;i<GGDM3_CLASS_NUM;i++)
    {

      for(j=0;j<GGDM22_U_CLASS_NUM;j++)
	  { 
	    if(!strcmp(GGDM3_class_codes[i],GGDM22_U_class_codes[j]))
	    {
	      foundit = 1;

	      if(strcmp(GGDM3_class_names[i],GGDM22_U_class_names[j]))
		  {
		    printf("different fcode name %s:  GGDM22_U: %s  GGDM3: %s\n",
			 GGDM22_U_class_codes[j],
			 GGDM22_U_class_names[j],
			 GGDM3_class_names[i]
			 );
		  } 
	      break;
	    }
	  } 
  }



  printf("\n\nGGDM3/GGDM22_U same attr code different name:\n");
  
  for(i=0;i<GGDM3_ATTR_NUM;i++)
    {

      for(j=0;j<GGDM22_U_ATTR_NUM;j++)
	  { 
	    if(!strcmp(GGDM3_attr_codes[i],GGDM22_U_attr_codes[j]))
	    {
	      foundit = 1;

	      if(strcmp(GGDM3_attr_names[i],GGDM22_U_attr_names[j]))
		  {
		    printf("different attr name %s:  GGDM22_U: %s  GGDM3: %s\n",
			 GGDM22_U_attr_codes[j],
			 GGDM22_U_attr_names[j],
			 GGDM3_attr_names[i]
			 );
		  } 
	      break;
	    }
	  } 
  }




  

 







#endif 

}






int RoundInt(double inval)
{
  if(inval>=0)
    {
      return (int)(inval + 0.5);
    }
  return (int)(inval - 0.5);
}



int OneDegreeCheckOK(int *totalnum)
{
  FILE *tempfile;
  double Djunk;
  int minx,miny,maxx,maxy,i,x,y,num=0;
  unsigned int thistotal,insidetotal=0,outsidetotal=0,total=0;
  char filename[1000];
  extern double MinXcoord;
  extern double MaxXcoord;
  extern double MinYcoord;
  extern double MaxYcoord;
  extern double MinNativeX;
  extern double MinNativeY;
  extern double RoundToNearestWholeDegree(int XorY, double inval);


  

  *totalnum = 0;

  minx = RoundInt(RoundToNearestWholeDegree(1,MinXcoord)/100000.0 + Xtranslation);
  maxx = RoundInt(RoundToNearestWholeDegree(1,MaxXcoord)/100000.0 + Xtranslation);
  miny = RoundInt(RoundToNearestWholeDegree(2,MinYcoord)/100000.0 + Ytranslation);
  maxy = RoundInt(RoundToNearestWholeDegree(2,MaxYcoord)/100000.0 + Ytranslation);
  
  if(minx==maxx)
    {
	  if(minx>=0)
	  {
        minx = (int)MinNativeX;
        maxx = minx + 1;
	  }
	  else
	  {
        maxx = (int)MinNativeX;
        minx = maxx - 1;
	  }
    }
  if(miny==maxy)
    {
	  if(miny>=0)
	  {
        miny = (int)MinNativeY;
        maxy = miny + 1;
	  }
	  else
	  {
        maxy = (int)MinNativeY;
        miny = miny - 1;
	  }
    }					

  
  
  sprintf(filename,"%sgridspace.txt",indirectory);
  tempfile = fopen(filename,"r");
  if(tempfile==NULL)
    {
      printf("could not open %s\n",filename);
      ExitWrapper(-1);
    }
  fscanf(tempfile,"%lf",&Djunk);
  fscanf(tempfile,"%d",&num);
  
  

  if((num<=0)||(num>70000))
    {
      return 0;
    }
  
  for(i=0;i<num;i++)
    {
      fscanf(tempfile,"%d%d%d",&x,&y,&thistotal);
      
      if(
	 (x>=minx)&&
	 (y>=miny)&&
	 (x<maxx) &&  
	 (y<maxy)     
	 )
	{
	  insidetotal = insidetotal + thistotal;
	  
	}
      else
	{
	  outsidetotal = outsidetotal + thistotal;
	  
	}
      
      total = total + thistotal;
    }
  
  fclose(tempfile);


  


  
  if(total<10000)
  {
	return 1;
  }
  
  *totalnum = outsidetotal;
  
  if(
     (total<=0)           ||
     (outsidetotal>10000) ||
     
	 (outsidetotal > (total*.05))
     )
    {
      return 0;
    }
  
  return 1;
}



char *ParseDriveType(int type)
{
  #if(USE_DOS==1)
  if(type==DRIVE_CDROM)
    {
      return "CDROM:";
    }
  if(type==DRIVE_REMOVABLE)
    {
      return "REMOVABLE:";
    }
  if(type==DRIVE_FIXED)
    {
      return "FIXED:";
    }
  if(type==DRIVE_REMOTE)
    {
      return "REMOTE:";
    }  
  #endif
  return "";
}



#if(USE_DOS==1)
char *GetShortcutTarget(char *username,char *filename)
{ 
  FILE *ptr;
  int i,len;
  char cmd[1000],buf[1000];
  static char retval[1000];
  
  sprintf(cmd,"readshortcut -w -t \"/cygdrive/c/Documents and Settings/%s/Nethood/%s/target.lnk\"",username,filename);
  
  if((ptr=POPEN(cmd,"r"))!=NULL)
    {
      if(fgets(buf,1000,ptr)!=NULL)
	{
	  sprintf(retval,"%s",buf);
	  PCLOSE(ptr);
	  
	  
	  len = strlen(retval);  
	  for(i=0;i<len;i++)
	    {
	      if(retval[i]=='\n')
		{
		  retval[i] = '\0';
		  break;
		}
	    }
	  
	  return retval;
	}
      PCLOSE(ptr); 
    }
  return "!!!!****()()";
}
#endif



int GoodNetName(char *linkname, char *tempname)
{
  int len,i;
  
  
  
  if(!strcmp(tempname,"!!!!****()()"))
    {
      printf("could not open shortcut for network place \"%s\": Ignoring this network place\n",linkname);
      return 0;
    }
  
  
  
  len = strlen(tempname);
  for(i=0;i<len;i++)
    {
      if((tempname[i]==':')||(tempname[i]=='\\'))
	{
	  return 1;
	}
    }
  
  
  return 0;
}



#if(USE_DOS==1)

void GetNetLocs()
{
  FILE *ptr;
  char *cmd = "whoami";
  char cmd2[1024],buf[1024],username[1024],testpath[1000];
  int success=0,len,i;
  
  
  if((NumNetDrives>0)&&(NetDriveNames!=NULL))
    {
      for(i=0;i<NumNetDrives;i++)
	{
	  free(NetDriveNames[i]);
	  free(NetDrivePaths[i]);
	}
      free(NetDriveNames);
      free(NetDrivePaths);
      NetDriveNames = NULL;
      NetDrivePaths = NULL;
      NumNetDrives  = 0;
    }
  
  
  if((ptr=POPEN(cmd,"r"))!=NULL)
    {
      while(fgets(username,1000,ptr)!=NULL)
	{
	  success = 1;
	  break;
	}
      PCLOSE(ptr); 
    }
  
  if(success==1)
    {
      len = strlen(username);
      for(i=0;i<len;i++)
	{
	  if(username[i]=='\n')
	    {
	      username[i] = '\0';
	      break;
	    }
	}
      
      sprintf(cmd2,"ls \"/cygdrive/c/Documents and Settings/%s/Nethood\"",username);
      
      if((ptr=POPEN(cmd2,"r"))!=NULL)
	{
	  while(fgets(buf,1000,ptr)!=NULL)
	    {
	      len = strlen(buf);
	      for(i=0;i<len;i++)
		{
		  if(buf[i]=='\n')
		    {
		      buf[i] = '\0';
		      break;
		    }
		}
	      
	      sprintf(testpath,"%s",GetShortcutTarget(username,buf));
	      
	      if(GoodNetName(buf,testpath)==1)
		{
		  
		  if(NetDriveNames==NULL)
		    {
		      NetDriveNames = (char **)malloc(sizeof(char *));
		      NetDrivePaths = (char **)malloc(sizeof(char *));
		    }
		  else
		    {
		      NetDriveNames = (char **) realloc(NetDriveNames,(NumNetDrives+1)*sizeof(char *));
		      NetDrivePaths = (char **) realloc(NetDrivePaths,(NumNetDrives+1)*sizeof(char *));
		    }
		  
		  NetDriveNames[NumNetDrives] = (char *)malloc(strlen(buf)+100);
		  sprintf(NetDriveNames[NumNetDrives],"%s",buf);
		  
		  len = strlen(testpath);	
		  
		  NetDrivePaths[NumNetDrives] = (char *)malloc(len+100);
		  sprintf(NetDrivePaths[NumNetDrives],"%s",testpath);
		  
		  if(NetDrivePaths[NumNetDrives][len-1]=='\\')
		    {
		      NetDrivePaths[NumNetDrives][len-1] = '\0';
		    }
		  
		  NumNetDrives = NumNetDrives + 1;
		} 
	    }
	  PCLOSE(ptr); 
	}
      
      
      
      
      
      SortNetList(0,NumNetDrives-1);
      
    }
}



int DetermineNetworkDrive(int letter)
{
  FILE *ptr;
  char cmd[1000],buf[1000],targetstr[1000];
  
  sprintf(cmd,"net use");
  
  sprintf(targetstr,"%c:",letter);
  
  if((ptr=POPEN(cmd,"r"))!=NULL)
    {
      while(fgets(buf,1000,ptr)!=NULL)
	{
	  if(strstr(buf,targetstr))
	    {
	      PCLOSE(ptr);
	      return 1;
	    }
	}
      PCLOSE(ptr);
    }
  return 0;
}


int GetNetDiskOtherName(char *searchname,char *result)
{
  FILE *ptr;
  int good=0,i,len,foundstart=0;
  char cmd[1000],buf[1000];
  
  
  len = strlen(searchname);
  for(i=0;i<len;i++)
    {
      
      
      if((foundstart==0)&&(searchname[i]!='\\'))
	{
	  foundstart = 1;
	}
      
      if((foundstart==1)&&(searchname[i]=='\\'))
	{
	  return 0;
	}
    }
  
  
  sprintf(cmd,"net view %s",searchname);
  
  if((ptr=POPEN(cmd,"r"))!=NULL)
    {
      if(fgets(buf,1000,ptr)==NULL)
	{
	  PCLOSE(ptr);
	  
	  
	  printf("(1) Failed to get name for %s\n",searchname);
	  return 0;
	}
      
      if(strstr(buf,"Shared resources at"))
	{
	  
	  
	  while(fgets(buf,1000,ptr)!=NULL)
	    {
	      if(
		 (strstr(buf,"Share name"))  &&
		 (strstr(buf,"Type"))        &&
		 (strstr(buf,"Used as"))
		 )
		{
		  PCLOSE(ptr);
		  return 0;
		}
	      
	      if( (strstr(buf,"-------------------")) || (strstr(buf,"created by wizard")) )
		{
		  PCLOSE(ptr);
		  return 0;
		}
	      
	      
	      
	      len = strlen(buf);
	      for(i=0;i<len;i++)
		{
		  if( (buf[i]!=' ') && (buf[i]!='\n') )
		    {
		      good = 1;
		    }
		  if((good==1)&&(buf[i]=='\n'))
		    {
		      buf[i] = '\0';
		      sprintf(result,"%s",buf);
		      PCLOSE(ptr);
		      return 1;
		    }
		}
	    } 
	} 
      PCLOSE(ptr);
    } 
  
  
  printf("(2) Failed to get name for %s\n",searchname);
  
  return 0;
}


int GetNetDriveName(int letter,char *result)
{
  FILE *ptr;
  int datafound=0,lastslash,len,i,nonslash;
  char cmd[1000],buf[1000],ffore[1000],fore[1000],aft[1000],
    tempstr[1000],result2[1000];
  
  sprintf(cmd,"net use %c:",letter);
  
  if((ptr=POPEN(cmd,"r"))!=NULL)
    {
      while(fgets(buf,1000,ptr)!=NULL)
	{
	  if(strstr(buf,"Remote name"))
	    {
	      len = (int)strlen(buf);
	      for(i=11;i<len;i++)
		{
		  if(buf[i]=='\n')
		    {
		      break;
		    }
		  
		  if(datafound==0)
		    {
		      if(buf[i]!=' ')
			{
			  tempstr[datafound] = buf[i];
			  datafound = datafound + 1;
			}
		    }
		  else
		    {
		      tempstr[datafound] = buf[i];
		      datafound = datafound + 1;
		    }
		}
	      
	      tempstr[datafound] = '\0';
	      PCLOSE(ptr);
	      
	      
	      
	      len = strlen(tempstr);
	      lastslash = 0;
	      for(i=0;i<len;i++)
		{
		  if(tempstr[i]=='\\')
		    {
		      lastslash = i;
		    }
		}
	      
	      if(lastslash==0)
		{
		  return 0;
		}
	      
	      for(i=0;i<lastslash;i++)
		{
		  ffore[i] = tempstr[i];
		}
	      ffore[i] = '\0';
	      
	      nonslash = 0;
	      len = (int)strlen(ffore);
	      for(i=0;i<len;i++)
		{
		  if(ffore[i]!='\\')
		    {
		      nonslash = i;
		      break;
		    }
		}
	      
	      sprintf(fore,"%s",&ffore[nonslash]);
	      
	      len = strlen(tempstr);
	      for(i=lastslash+1;i<len;i++) 
		{
		  aft[i-(lastslash+1)] = tempstr[i];
		}
	      aft[i-(lastslash+1)] = '\0';
	      
	      if(strlen(aft)<1)
		{
		  sprintf(result,"%s",fore);
		  return 1;
		}
	      else
		{
		  
		  if(GetNetDiskOtherName(ffore,&result2[0])==1)
		    {
		      sprintf(result,"%s on '%s (%s)'",aft,result2,fore);
		    }
		  else
		    {
		      sprintf(result,"%s on '%s'",aft,fore);
		    }
		  return 1;
		}
	      
	      return 1;
	    }
	}
      PCLOSE(ptr);
    }
  return 0;
}





void GetDriveLetters()
{
  FILE *ptr;
  char *cmd = "ls /cygdrive", letter;
  char buf[1024],buf2[1000],buf3[2000],buf4[2000],tempresult[1000];
  unsigned long uljunk;
  int type,driveindex,i;

  
  for(i=0;i<DRIVE_MAX;i++)
    {
      DrivesAvailable[i] = -12345;
      DriveNames[i][0]   = '\0';
    }
  
  
  GetNetLocs();
  
  
  if((ptr=POPEN(cmd,"r"))!=NULL)
    {
      while(fgets(buf,1000,ptr)!=NULL)
	{
	  letter = toupper(buf[0]);
	  
	  driveindex = letter-65;
	  
	  sprintf(buf2,"%c:\\",buf[0]);
	  type = GetDriveType(buf2);
	  DrivesAvailable[driveindex] = type;
	  DriveNames[driveindex][0]   = '\0';
	  
	  if(GetVolumeInformation(buf2,
				  buf3, 
				  1024,
				  &uljunk,
				  &uljunk,
				  &uljunk,
				  buf4,
				  1024))
	    {
	      if(strlen(buf3)>0)
		{
		  sprintf(DriveNames[driveindex],"%s",buf3);
		
		  
		}
	    }
	}
    }
  PCLOSE(ptr); 
  
  
  
  
  
  for(i=0;i<DRIVE_MAX;i++)
    {
      if(DrivesAvailable[i]==-12345)
	{
	  continue;
	}
      
      if(DetermineNetworkDrive(65+i)==1)
	{
	  
	  if(GetNetDriveName(65+i,&tempresult[0])==1)
	    {
	      sprintf(DriveNames[i],"%s",tempresult);
	    }
	}
      else
	{
	  
	}
    }
}

#else

void GetDriveLetters()
{
  printf("Serious error in GDL\n");
  XBell(mydisplay,50);
}

#endif




void ReadWriteQACR2(char *readfile, char *writefile)
{
  FILE *infile, *outfile;
  int numbytes;
  char *wholebuf;


  infile = fopen(readfile,"rb");
  if(infile==NULL)
  {
	printf("could not open %s\n",readfile);
	return;
  }

  outfile = fopen(writefile,"wb");
  if(outfile==NULL)
  {
	printf("could not open %s\n",writefile);
	return;
  }

  wholebuf = (char *)malloc(2000000);

  numbytes  = fread(&wholebuf[0], 1,2000000,infile);

  fwrite(&wholebuf[24] ,1,numbytes-24,outfile);

  fclose(infile);
  fclose(outfile);
  free(wholebuf);
}




void ReadWriteQACR(char *readfile, char *writefile)
{
  FILE *infile, *outfile;
  int numbytes,otherval;
  char *wholebuf;


  infile = fopen(readfile,"rb");
  if(infile==NULL)
  {
	printf("could not open %s\n",readfile);
	return;
  }

  outfile = fopen(writefile,"wb");
  if(outfile==NULL)
  {
	printf("could not open %s\n",writefile);
	return;
  }

  wholebuf = (char *)malloc(2000000);

  numbytes  = fread(&wholebuf[0], 1,2000000,infile);

  otherval = 0;
  fwrite(&otherval ,1,SzI,outfile);
  otherval = 7;
  fwrite(&otherval ,1,SzI,outfile);
  otherval = 1;
  fwrite(&otherval ,1,SzI,outfile);
  otherval = 7;
  fwrite(&otherval ,1,SzI,outfile);
  otherval = 7;
  fwrite(&otherval ,1,SzI,outfile);
  otherval = 2;
  fwrite(&otherval ,1,SzI,outfile);

  fwrite(&wholebuf[0] ,1,numbytes,outfile);

  fclose(infile);
  fclose(outfile);
  free(wholebuf);
}



void ReWriteQACR()
{
  




}



void OpenFiles()
{
  
  
  
}




char *GetLastPart(char oldaline[])
{
  int len,startposn,i,j;
  char aline[1000];
  static char newline[1000];


  sprintf(aline,"%s",oldaline);

  if(aline==NULL)
    {
      printf("(1) Ignoring blank line in InputSpecFile\n");
      return NULL;
    }
  if(aline[0]==0)
    {
      printf("(2) Ignoring blank line in InputSpecFile\n");
      return NULL;
    }
  if(aline[1]==0)
    {
      printf("(3) Ignoring blank line in InputSpecFile\n");
      return NULL;
    }


  len = strlen(aline);


  for(i=0;i<len;i++)
  {
	if((aline[i]==10)||(aline[i]==13))
	  {
		aline[i]   = '\n';
		aline[i+1] = '\0';
		break;
	  }
  }

  len = strlen(aline);

  if(aline[len-2]!='"')
    {
      printf("(1) bad line in input file:  %s.  Ignoring this line %c %d\n",
	     aline,aline[len-1],len);

      for(i=0;i<len;i++)
	{
	  printf(" %d = %c\n",i,aline[i]);
	}

      return NULL;
    }


  startposn = -1;

  for(i=0;i<len-2;i++)
    {
      if(aline[i]=='"')
	{
	  startposn = i;
	}
    }

  if(startposn==-1)
    {
      printf("(3) bad line in input file:  %s.  Ignoring this line\n",aline);
      return NULL;
    }

  for(i=startposn+1,j=0;  i<len-2;  i++,j++)
    {
      newline[j] = aline[i];
    }
  newline[j] = '\0';

  return newline;
}






void TestDefaultCloneValues()
{

int errnum,i,cloneindex;

  for(errnum=1;errnum<=CONDITION_DEFINITIONS;errnum++)
  {
	if(SingleInstance(errnum))
	{
	  
      continue;
	}

 	CloneCallback((Widget)NULL,(XtPointer)errnum, (XtPointer)999);
  }


  for(errnum=1;errnum<=CONDITION_DEFINITIONS;errnum++)
  {
	if(SingleInstance(errnum))
	{
	  
      continue;
	}

	for(i=0;i<NUM_C;i++)
	{
      cloneindex = GetCloneIndex(1,errnum);
 
	  if(ErrorLookup[errnum].Config1[i]!=CloneErrorLookup[cloneindex].Config1[i])
	  {
		  printf("bad errnum %d (%s) config1 %d:  %d and %d\n",
			  errnum,ErrorLookup[errnum].name,i,ErrorLookup[errnum].Config1[i],
			  CloneErrorLookup[cloneindex].Config1[i]);
	  }
	  if(ErrorLookup[errnum].Config2[i]!=CloneErrorLookup[cloneindex].Config2[i])
	  {
		  printf("bad errnum %d (%s) config2 %d:  %d and %d\n",
			  errnum,ErrorLookup[errnum].name,i,ErrorLookup[errnum].Config2[i],
			  CloneErrorLookup[cloneindex].Config2[i]);
	  }
	  if(ErrorLookup[errnum].Config3[i]!=CloneErrorLookup[cloneindex].Config3[i])
	  {
		  printf("bad errnum %d (%s)config3 %d:  %d and %d\n",
			  errnum,ErrorLookup[errnum].name,i,ErrorLookup[errnum].Config3[i],
			  CloneErrorLookup[cloneindex].Config3[i]);
	  }
	}
  }
}


void TestAllChecks()
{
  int i,errnum,cloneindex,totala=0,totalb=0;


  for(errnum=1;errnum<=CONDITION_DEFINITIONS;errnum++)
  {
	if(SingleInstance(errnum))
	{
      continue;
	}

	  if(
		(ErrorLookup[errnum].checkapplies!=GAITcheck) &&
		(ErrorLookup[errnum].checkapplies!=GAITandSEEITcheck)
		)
	{
		continue;
	}

 	CloneCallback((Widget)NULL,(XtPointer)errnum, (XtPointer)999);
  }

  for(cloneindex=0;cloneindex<CLONE_DEFINITIONS;cloneindex++)
  {
	CloneErrorLookup[cloneindex].active = 1;
totala = totala + 1;
	for(i=0;i<NUM_C;i++)
	{
      if(CloneErrorLookup[cloneindex].Config1[i]!=2)
	  {
	    CloneErrorLookup[cloneindex].AllConfigOn[1][i]       = 1;
	    CloneErrorLookup[cloneindex].SpecifiedConfigOn[1][i] = 0;
	  } 
      if(CloneErrorLookup[cloneindex].Config2[i]!=2)
	  {
	    CloneErrorLookup[cloneindex].AllConfigOn[2][i]       = 1;
	    CloneErrorLookup[cloneindex].SpecifiedConfigOn[2][i] = 0;
	  } 
      if(CloneErrorLookup[cloneindex].Config3[i]!=2)
	  {
	    CloneErrorLookup[cloneindex].AllConfigOn[3][i]       = 1;
	    CloneErrorLookup[cloneindex].SpecifiedConfigOn[3][i] = 0;
	  } 
	} 
  }  


  for(errnum=1;errnum<=CONDITION_DEFINITIONS;errnum++)
  {
	if(SingleInstance(errnum))
	{
      continue;
	}

	if(
		(ErrorLookup[errnum].checkapplies!=GAITcheck) &&
		(ErrorLookup[errnum].checkapplies!=GAITandSEEITcheck)
		)
	{
		continue;
	}

	ErrorLookup[errnum].active = 1;
totalb = totalb+1;
	for(i=0;i<NUM_C;i++)
	{ 
      if(ErrorLookup[errnum].Config1[i]!=2)
	  {
	    ErrorLookup[errnum].AllConfigOn[1][i]       = 1;
	    ErrorLookup[errnum].SpecifiedConfigOn[1][i] = 0;
	  } 
      if(ErrorLookup[errnum].Config2[i]!=2)
	  {
	    ErrorLookup[errnum].AllConfigOn[2][i]       = 1;
	    ErrorLookup[errnum].SpecifiedConfigOn[2][i] = 0;
	  } 
      if(ErrorLookup[errnum].Config3[i]!=2)
	  {
	    ErrorLookup[errnum].AllConfigOn[3][i]       = 1;
	    ErrorLookup[errnum].SpecifiedConfigOn[3][i] = 0;
	  } 
	}
  }

printf("totala %d totalb %d\n",totala,totalb);

}





char * IGetNth(char aline[], int num, int silent)
{
  static char outname[10000];
  int i=0, j=0, k=0, index=0, num_comma=0, quotefound = 0, madeachange=0, len;


  


  len = strlen(aline);

  while(num_comma<num)
    {
      if(i>=len)
	{
	  if(silent==0)
	  {
        printf("input line: %s did not have enough fields\n",aline);
	  }
	  return "zzZZzz";
	}

      if(aline[i]=='"')
	{
	  quotefound = quotefound + 1;
	}

      if((aline[i]==',') && (quotefound%2==0))
	{
	  num_comma++;
	}

      i++;
    }




  

  quotefound = 0;

  while( 
	((aline[i]!=',' ) || (quotefound%2==1))   &&
	(aline[i]!='\0') && 
	(aline[i]!='\n')
	)
    {
       if(aline[i]=='"')
	{
	  quotefound = quotefound + 1;
	}

      outname[index] = aline[i];
      i++;
      index++;
    }

  
  outname[index] = '\0';
  i = strlen(outname);
  if((outname[0]==34)&&(outname[i-1]==34))
    {
      for(j=1;j<(i-1);j++)
	{
	  outname[j-1] = outname[j];
	}
      outname[j-1] = '\0';
    }



  

  madeachange = 1;
  while(madeachange==1)
    {
      i = strlen(outname);
      madeachange = 0;
      for(j=1;j<(i-1);j++)
	{
	  if((outname[j-1]==34) && (outname[j]==34))
	    {
	      for(k=j+1;k<i;k++)
		{
		  outname[k-1] = outname[k];
		}
	      outname[k-1] = '\0'; 
	      madeachange = 1;
	    }
	}
    }
  return outname;
}




void TestMasters()
{
  FILE *testfile;
  int i,j,k,lines_to_skip,bad_lines=0;
  char filename[1000];
  char *MasterProjects[16]=
  {
    "d4-all",
    "fldb-all",
    "vmap-all",
    "mgcp3-all", 
	"mgcp4-all",
	"ufd1-all",
	"ufd2-all",
	"ufd3-all",
	"ggdm21-all",
	"ggdm22-all",
	"ggdm3-all",
    "tds4-all",
    "tds6-all",
	"afd-all",
    "nfdd-all",
	"dfdd-all"	
  };

  char *MasterHeaders[7]=
  {
   "DFEG_master",
   "MGCP_master",
   "UFD1_master",
   "UFD3_master",
   "TDS_master",
   "AFD_master",
   "TREx_master"
  };

  extern void inputfileDialogCallback(Widget w, XtPointer userData,
			     XmFileSelectionBoxCallbackStruct *data);



  for(j=0;j<16;j++)
  {
sprintf(filename,"%d%d%d%d%d%d%d%d%d%d.txt",j,j,j,j,j,j,j,j,j,j);
testfile = fopen(filename,"w");
fprintf(testfile,"%s",MasterProjects[j]);
fclose(testfile);

    sprintf(project_to_open,"%s",MasterProjects[j]);
    printf("Opening %s\n",project_to_open);
    inputfileDialogCallback(drawing_a,(XtPointer)2,(XmFileSelectionBoxCallbackStruct *) NULL);
    printf("done opening project\n\n");

    printf("Generating masters\n");
    makedisconnectCallback((Widget) NULL,(XtPointer) NULL,(XtPointer) NULL);
    printf("Done\n");

    for(i=0;i<7;i++)
	{
      printf("reverting\n");
      revertCallback((Widget)NULL,(XtPointer)5,(XtPointer)5);

      sprintf(filename,"%sinspection_files\\%s.txt",indirectory,MasterHeaders[i]);
      printf("loading %s\n",filename);   
      lines_to_skip = FindEDCSInFile(filename);
      ApplyExecutionOptions(filename,0);
      bad_lines = DoBatchEDCSStuff((Widget)NULL,filename,lines_to_skip,1);
      printf("done with %d bad lines\n",bad_lines);

	  if(bad_lines>0)
	  {
		  exit(-1);
	  }



	  
     for(k=1;k<=CONDITION_DEFINITIONS;k++)
	  {
		if(ErrorLookup[k].active==0)
		{
          continue;
		}

        if(ErrorLookup[k].Annotation==NULL)
		{
          printf("NULL annotation on index %d (check %s)\n",k,ErrorLookup[k].name);
		}
		else
		{
          if(strlen(ErrorLookup[k].Annotation)<5)
		  {
            printf("Too short annotation (%s) on index %d (check %s)\n",ErrorLookup[k].Annotation,k,ErrorLookup[k].name);
		  }
		}
	  }
	} 
  }

  printf("\n\nFinished all\n\n");

}



int TestInputSpecFile()
{
  

  FILE *testfile;
  char command[1000];
  char localoutdir   [1000];



  


  
  sprintf(localoutdir   ,"\"%s\"",importoutputdir);

  



  testfile = fopen(importdirectory,"r");
  if(testfile!=NULL)
    {
      fclose(testfile);

      
      if(AppendInputSpec==0)
	{
	  testfile = fopen(importdirectory,"w");
	  if(testfile==NULL)
	    {
	      return 0;
	    }
	  fclose(testfile);
	  return 1;
	}

      return 1;
    }

  sprintf(command,"mkdir %s",localoutdir);
  system(command);

  testfile = fopen(importdirectory,"w");
  if(testfile!=NULL)
    {
      fclose(testfile);
      return 1;
    }

  return 0;
}




int FindD4List(char *shortname)
{
  char test1[500],test2[500],test3[500],test4[500],test5[500],test6[500],test7[500];
  char testa1[500],testa2[500],testa3[500],testa4[500],testa5[500],testa6[500],testa7[500];
  char testb1[500],testb2[500],testb3[500],testb4[500],testb5[500],testb6[500],testb7[500];

  int num_specialcases = 422;
  int i,j;
  
  char *specialcases[] = 
  {
    "ACCESS_ZONE"        , "FA005" ,
    "ACOUSTIC_STATION"   , "BK010" ,
    "ADMIN_AREA"         , "FA001" ,
    "ADMINISTRATIVE_BND" , "FA000" ,
    "AERIAL_CABLE_LINE"  , "AQ010" ,
    "AERIAL_CABLE_PYLON" , "AQ020" ,
    "AGGREGATE_FEATURE"  , "ZD022" ,
    "AIR_FAC_FUEL_STORE" , "GB111" ,
    "AIR_FAC_GARBAGE"    , "GB103" ,
    "AIR_FAC_LOCATION"   , "GB109" ,
    "AIR_FAC_ORDNANCE"   , "GB112" ,
    "AIR_FAC_P2P_COMM"   , "GB100" ,
    "AIR_FAC_REF_POINT"  , "GB047" ,
    "AIR_FAC_REFUELING"  , "GB108" ,
    "AIR_FAC_SECURITY"   , "GB113" ,
    "AIR_FAC_SEWAGE_DIS" , "GB104" ,
    "AIR_FAC_SPEC_VEH"   , "GB101" ,
    "AIR_FAC_START_UNIT" , "GB102" ,
    "AIR_FAC_TERRAIN"    , "GB107" ,
    "AIR_FAC_VEHICLES"   , "GB114" ,
    "AIR_FAC_WATER_SUP"  , "GB106" ,
    "AIR_FAC_WATER_TRAN" , "GB115" ,
    "AIR_OBSTRUCTION"    , "GB220" ,
    "AIR_WARNING_LIGHT"  , "GA065" ,
    "AIRCRAFT_BUNKER"    , "GB116" ,
    "AIRPORT_AIRFIELD"   , "GB005" ,
    "AIRPORT_ASSO_STRIP" , "GA400" ,
    "AIRPORT_LIGHTING"   , "GB010" ,
    "AIRSPACE"           , "GA005" ,
    "AIRSPACE_BND_SEG"   , "GA020" ,
    "AMUSEMENT_PARK"     , "AK030" ,
    "AMUSEMENT_PARK_ATT" , "AK020" ,
    "ANCHOR"             , "BB019" ,
    "ANCHORAGE"          , "BB010" ,
    "ANIMAL_SANCTUARY"   , "AL005" ,
    "APRON_HARDSTAND"    , "GB015" ,
    "AQUEDUCT"           , "BH010" ,
    "ARCHEOLOGICAL_SITE" , "AL012" ,
    "ARRESTING_GEAR"     , "GB020" ,
    "ARTIFACT_LOCATION"  , "ZD003" ,
    "ASPHALT_LAKE"       , "DA005" ,
    "ASSEMBLY_PLANT"     , "AE010" ,
    "ATHLETIC_FIELD"     , "AK040" ,
    "ATS_ROUTE_SEG_LEG"  , "GA010" ,
    "BACKSHORE_PREC_IHO" , "BA022" ,
    "BAMBOO_CANE"        , "EC010" ,
    "BARRIER"            , "AP041" ,
    "BASTION_RAMP_FORT"  , "AH010" ,
    "BEACH"              , "BA050" ,
    "BEACH_PROFILE"      , "BE050" ,
    "BEACON"             , "BC010" ,
    "BENCHMARK"          , "ZB020" ,
    "BERTH"              , "BB020" ,
    "BLAST_BARRIER"      , "GB025" ,
    "BLAST_FURNACE"      , "AC010" ,
    "BLUFF_CLIFF_ESCARP" , "DB010" ,
    "BOG"                , "BH015" ,
    "BOLLARD"            , "BB030" ,
    "BOTTOM_CHARACTER"   , "BF010" ,
    "BOUNDARY_MONUMENT"  , "ZB030" ,
    "BREAKERS"           , "BD010" ,
    "BREAKWATER"         , "BB041" ,
    "BRIDGE_OVERPASS"    , "AQ040" ,
    "BRIDGE_PIER"        , "AQ056" ,
    "BRIDGE_SPAN"        , "AQ045" ,
    "BRIDGE_SUPERSTRUCT" , "AQ050" ,
    "BRIDGE_TOWER"       , "AQ055" ,
    "BUILD_SUPERSTR_ADD" , "AL018" ,
    "BUILDING"           , "AL015" ,
    "BUILTUP_AREA"       , "AL020" ,
    "BUOY"               , "BC020" ,
    "CABLE"              , "AT005" ,
    "CAIRN"              , "AL025" ,
    "CALLINGIN_POINT"    , "BB050" ,
    "CAMP"               , "AI030" ,
    "CAMPGROUND"         , "AK060" ,
    "CANAL"              , "BH020" ,
    "CART_TRACK"         , "AP010" ,
    "CATALYTIC_CRACKER"  , "AC020" ,
    "CAUSEWAY"           , "AQ064" ,
    "CAVE"               , "DB030" ,
    "CEMETERY"           , "AL030" ,
    "CHAIN_WIRE"         , "BD074" ,
    "CHIMNEY_SMOKESTACK" , "AF010" ,
    "CISTERN"            , "BI010" ,
    "CLEARED_FIREBREAK"  , "EC040" ,
    "COAST_SHORELINE"    , "BA010" ,
    "COASTLINE"          , "BA011" ,
    "COMM_BUILDING"      , "AT050" ,
    "COMM_TOWER"         , "AT080" ,
    "COMPLEX_OUTLINE"    , "AL045" ,
    "COMPLEX_TERM_ROUTE" , "GA047" ,
    "CONSTRICT_EXPAND"   , "AQ058" ,
    "CONTACT_ZONE"       , "FA041" ,
    "CONTOUR_LINE_LAND"  , "CA010" ,
    "CONTROL_PT_STATION" , "ZB035" ,
    "CONTROL_TOWER"      , "AQ060" ,
    "CONVEYOR"           , "AF020" ,
    "COOLING_TOWER"      , "AF030" ,
    "COVERED_DRAINAGE"   , "SA060" ,
    "CRANE"              , "AF040" ,
    "CREVICE_CREVASSE"   , "DB060" ,
    "CRIB"               , "BD020" ,
    "CROPLAND"           , "EA010" ,
    "CROSSING"           , "AQ062" ,
    "CULVERT"            , "AQ065" ,
    "CURB"               , "AQ036" ,
    "CURRENT_DIAGRAM"    , "BG040" ,
    "CURRENT_FLOW"       , "BG010" ,
    "CUT"                , "DB070" ,
    "DAM_WEIR"           , "BI020" ,
    "DECONTAMINATE_PAD"  , "GB160" ,
    "DEPOT_STORAGE"      , "AM010" ,
    "DEPRESSION"         , "DB080" ,
    "DEPTH_AREA"         , "BE019" ,
    "DEPTH_CONTOUR"      , "BE015" ,
    "DEPTH_CURVE"        , "BE010" ,
    "DIAGNOSTIC_POINT"   , "ZB040" ,
    "DIR_OF_LAT_BUOYAGE" , "BC102" ,
    "DISCOLORED_WATER"   , "BD030" ,
    "DISK_DISH"          , "AT010" ,
    "DISPLACE_THRESHOLD" , "GB090" ,
    "DISPLAY_SIGN"       , "AL050" ,
    "DISPOSAL_SITE"      , "AB000" ,
    "DISTANCE_MARK"      , "ZB036" ,
    "DITCH"              , "BH030" ,
    "DOLPHIN"            , "BB080" ,
    "DRAGON_TEETH"       , "AL060" ,
    "DREDGE_DRAGLINE"    , "AF050" ,
    "DRIVE_IN_THEAT_SCR" , "AK080" ,
    "DRIVE_IN_THEATER"   , "AK070" ,
    "DROP_GATE"          , "AQ068" ,
    "DRYDOCK"            , "BB090" ,
    "EARLY_WARN_RADAR"   , "AT020" ,
    "EDDIES"             , "BD040" ,
    "EMBANKMENT_FILL"    , "DB090" ,
    "ENGINE_TEST_CELL"   , "AF060" ,
    "ENTRANCE_EXIT"      , "AQ090" ,
    "ESKER"              , "DB100" ,
    "FAIRGROUNDS"        , "AK090" ,
    "FAULT"              , "DB110" ,
    "FEED_LOT_STOCKYARD" , "AJ030" ,
    "FENCE"              , "AL070" ,
    "FERRY_CROSSING"     , "AQ070" ,
    "FERRY_SITE"         , "AQ080" ,
    "FILTRATION_BEDS"    , "BH040" ,
    "FIRE_HYDRANT"       , "BH171" ,
    "FIRING_RANGE"       , "FA015" ,
    "FISH_HATCHERY_FARM" , "BH050" ,
    "FISH_STAKES"        , "BB100" ,
    "FISH_TRAPS_WEIRS"   , "BB110" ,
    "FISHING_HARBOR"     , "BB105" ,
    "FISHING_PROME_PIER" , "AK190" ,
    "FLAGSTAFF_FLAGPOLE" , "AL073" ,
    "FLARE_PIPE"         , "AF070" ,
    "FLIGHT_OF_STEPS"    , "AQ150" ,
    "FLOOD_BARRAGE"      , "BI043" ,
    "FLUME"              , "BH060" ,
    "FOG_SIGNAL"         , "BC101" ,
    "FORD"               , "BH070" ,
    "FORESHORE_PREC_IHO" , "BA023" ,
    "FORTIFICATION"      , "AH050" ,
    "FOUL_GROUND"        , "BD050" ,
    "FOUNTAIN"           , "BH075" ,
    "GALLERY"            , "AL075" ,
    "GANTRY"             , "AL080" ,
    "GATE"               , "AP040" ,
    "GATE_NAUTICAL"      , "BI041" ,
    "GAUGING_STATION"    , "BI070" ,
    "GEN_MISC_FEATURE"   , "ZD019" ,
    "GEODETIC_POINT"     , "ZB060" ,
    "GEOGRAPHIC_INFO_PT" , "ZD012" ,
    "GEOMORPH_LINE"      , "ZD551" ,
    "GEOMORPH_LOC"       , "ZD550" ,
    "GEOPHYSICAL_GRID"   , "FA090" ,
    "GEOTHERMAL_FEATURE" , "DB115" ,
    "GLACIER"            , "BJ030" ,
    "GOLF_COURSE"        , "AK100" ,
    "GOLF_DRIVING_RANGE" , "AK101" ,
    "GRAIN_BIN_SILO"     , "AM020" ,
    "GRAIN_ELEVATOR"     , "AM030" ,
    "GRANDSTAND"         , "AK110" ,
    "GRASSLAND"          , "EB010" ,
    "GRIDIRON"           , "BB115" ,
    "GROIN"              , "BB043" ,
    "GROUND_SURF_ELEM"   , "DA010" ,
    "GULLY_GORGE"        , "DB200" ,
    "HARBOR"             , "BB005" ,
    "HEDGEROW"           , "EA020" ,
    "HELI_LANDING_PAD"   , "GB030" ,
    "HELIPORT"           , "GB035" ,
    "HOPPER"             , "AF080" ,
    "HOPS"               , "EA055" ,
    "HULL_TEST_AREA"     , "FC178" ,
    "HULL_TEST_BOTTOM"   , "FC180" ,
    "HULL_TEST_CORESITE" , "BF012" ,
    "HUMMOCK"            , "BH077" ,
    "HUT"                , "AL100" ,
    "ICE_CLIFF"          , "BJ040" ,
    "ICE_PEAK_NUNATAK"   , "BJ060" ,
    "ICE_SHELF"          , "BJ065" ,
    "INLAND_SHORELINE"   , "BH210" ,
    "INLAND_WATER"       , "BH000" ,
    "INLAND_WATER_ELEV"  , "CA035" ,
    "INS_ALIGNMENT_PAD"  , "GB170" ,
    "INTERCHANGE"        , "AP020" ,
    "INTL_DATE_LINE"     , "FA110" ,
    "ISLAND"             , "BA030" ,
    "ISOGONIC_LINES"     , "ZC050" ,
    "JETTY"              , "BB140" ,
    "KELP_SEAWEED"       , "BD060" ,
    "LAGOON_REEF_POOL"   , "BH190" ,
    "LAKE_POND"          , "BH080" ,
    "LAND_DEVOID_OF_VEG" , "EE020" ,
    "LAND_SUB_INUNDATE"  , "BH090" ,
    "LANDING_PLACE"      , "BB150" ,
    "LANDING_STAIRS"     , "BB151" ,
    "LANDSLIDE"          , "DB211" ,
    "LAUNCH_PAD"         , "GB040" ,
    "LEAD_RADIAL"        , "GA031" ,
    "LEADING_LINE"       , "BC100" ,
    "LIGHT"              , "BC040" ,
    "LIGHT_SECTOR"       , "BC060" ,
    "LIGHT_STANDARD"     , "AL110" ,
    "LIGHT_VESSEL_SHIP"  , "BC070" ,
    "LIGHTHOUSE"         , "BC050" ,
    "LOCK"               , "BI030" ,
    "LOG_BOOM"           , "BD071" ,
    "LOGGING_AREA"       , "EE010" ,
    "MAG_DISTURB_AREA"   , "ZC040" ,
    "MAGNETIC_STATION"   , "BK020" ,
    "MANHOLE_COVER"      , "AQ115" ,
    "MARITIME_AREA"      , "FC031" ,
    "MARITIME_LIMIT_BND" , "FC021" ,
    "MARITIME_STATION"   , "BB155" ,
    "MARKER"             , "BC055" ,
    "MARSH"              , "ED010" ,
    "MEASURED_DIST_LINE" , "FC100" ,
    "MILITARY_BASE"      , "SU001" ,
    "MINE"               , "AA010" ,
    "MINE_NAVAL"         , "BD001" ,
    "MINERAL_PILE"       , "AM040" ,
    "MISC_AIR_OBSTRUCT"  , "GB221" ,
    "MISC_OBSTACLE"      , "DB145" ,
    "MISC_SURFACE_DRAIN" , "BH200" ,
    "MISC_UNDERWATER"    , "BD005" ,
    "MISC_VEGETATION"    , "EE000" ,
    "MISSILE_SITE"       , "AL120" ,
    "MOAT"               , "BH100" ,
    "MOBILE_HOME_PARK"   , "AI020" ,
    "MOLE"               , "BB042" ,
    "MONUMENT"           , "AL130" ,
    "MOORING_MAST"       , "AQ110" ,
    "MOORING_RING"       , "BB160" ,
    "MORAINE"            , "BJ020" ,
    "MOUNTAIN_PASS"      , "DB150" ,
    "NAMED_LOCATION"     , "ZD040" ,
    "NATIVE_SETTLEMENT"  , "AL135" ,
    "NAVAIDS_AERO"       , "GA035" ,
    "NEARSHORE_PREC_IHO" , "BA021" ,
    "NONSITE_30_DATA"    , "GB105" ,
    "NURSERY"            , "EA030" ,
    "OASIS"              , "EC020" ,
    "OFF_ROUTE_RADIAL"   , "GA030" ,
    "OFFSHORE_LOAD_FAC"  , "BB170" ,
    "OIL_GAS_FACILITIES" , "AC040" ,
    "OIL_GAS_FIELD"      , "AA052" ,
    "ORCHARD_PLANTATION" , "EA040" ,
    "OVERFALLS_TIDE_RIP" , "BD080" ,
    "OVERHANG_STORE"     , "AL016" ,
    "OVERHEAD_OBS_LOC"   , "AL155" ,
    "OVERHEAD_WALKWAY"   , "AQ152" ,
    "OVERRUN_STOPWAY"    , "GB045" ,
    "OYSTER_MUSSEL_BED"  , "BB180" ,
    "PACK_ICE"           , "BJ070" ,
    "PARCEL"             , "IA040" ,
    "PARK"               , "AK120" ,
    "PARK_BENCH"         , "AK123" ,
    "PART_ACCELERATOR"   , "AL140" ,
    "PENSTOCK"           , "BH110" ,
    "PERCHES_STAKES"     , "BC080" ,
    "PICNIC_TABLE"       , "AK124" ,
    "PIER_WHARF_QUAY"    , "BB190" ,
    "PILE_PILING_POST"   , "BD100" ,
    "PIPE_CROSSING_PNT"  , "AL165" ,
    "PIPELINE_PIPE"      , "AQ113" ,
    "PLANTER"            , "AK140" ,
    "PLATFORM"           , "BD110" ,
    "PLAZA_CITY_SQUARE"  , "AL170" ,
    "POINT_OF_CHANGE"    , "ZD015" ,
    "POLAR_ICE"          , "BJ080" ,
    "POWER_PLANT"        , "AD010" ,
    "POWER_TRANS_LINE"   , "AT030" ,
    "POWER_TRANS_PYLON"  , "AT040" ,
    "PREC_RADAR_SIG_LOC" , "ZB070" ,
    "PROCESSING_PLANT"   , "AC000" ,
    "PUMPING_STATION"    , "AQ116" ,
    "QUARRY"             , "AA012" ,
    "QUARRY_MINE_WALL"   , "AA011" ,
    "RACE_TRACK"         , "AK130" ,
    "RADAR_REF_LINE"     , "FC130" ,
    "RADAR_SIGNIF_AREA"  , "AL095" ,
    "RADAR_TRANSMITTER"  , "AT045" ,
    "RAFT_FLOAT_BRIDGE"  , "AQ111" ,
    "RAILROAD"           , "AN010" ,
    "RAILROAD_TURNTABLE" , "AN075" ,
    "RAMP"               , "AL195" ,
    "RAMP_MARITIME"      , "BB220" ,
    "RANGE_CENTERLINE"   , "FC102" ,
    "RAPIDS"             , "BH120" ,
    "REEF"               , "BD120" ,
    "RESERVOIR"          , "BH130" ,
    "RESTRICTED_AREA"    , "FC036" ,
    "REVETMENT"          , "GB050" ,
    "RICE_FIELD"         , "BH135" ,
    "RIDGE_LINE"         , "CA020" ,
    "RIG_SUPERSTRUCTURE" , "AA040" ,
    "RIP_RAP"            , "BB225" ,
    "RIVER_STREAM"       , "BH140" ,
    "RIVER_VANISH_POINT" , "BH145" ,
    "ROAD"               , "AP030" ,
    "ROCK"               , "BD130" ,
    "ROCK_STRATA"        , "DB160" ,
    "ROUTE_AIR"          , "GA045" ,
    "ROUTE_MARITIME"     , "FC165" ,
    "ROUTE_MARKER"       , "AQ119" ,
    "RR_MARSHAL_YARD"    , "AN060" ,
    "RR_SIDING_SPUR"     , "AN050" ,
    "RUINS"              , "AL200" ,
    "RUNWAY"             , "GB055" ,
    "RUNWAY_RADAR_REF"   , "GB060" ,
    "SAFETY_FAIRWAY"     , "FC170" ,
    "SALT_EVAPORATOR"    , "BH155" ,
    "SALT_PAN"           , "BH150" ,
    "SAND_DUNE_HILLS"    , "DB170" ,
    "SCRUB_BRUSH_BUSH"   , "EB020" ,
    "SEAPLANE_AREA"      , "GB070" ,
    "SEAPLANE_BASE"      , "GB065" ,
    "SEAWALL"            , "BB230" ,
    "SEBKHA"             , "BH160" ,
    "SETTLEMENT"         , "AL105" ,
    "SETTLING_BASIN"     , "AC030" ,
    "SHANTY_TOWN"        , "AL208" ,
    "SHARP_CURVES"       , "AQ118" ,
    "SHED"               , "AL019" ,
    "SHORELINE"          , "BA024" ,
    "SHOULDER"           , "GB057" ,
    "SIDEWALK"           , "AQ035" ,
    "SKI_JUMP"           , "AK150" ,
    "SLIPWAY"            , "BB240" ,
    "SLOPE_POLYGON"      , "SA050" ,
    "SLUICE_GATE"        , "BI040" ,
    "SNAGS_STUMPS"       , "BD140" ,
    "SNOW_ICE_FIELD"     , "BJ100" ,
    "SNOW_ROCK_SHED"     , "AL210" ,
    "SOLAR_PANELS"       , "AD020" ,
    "SOUNDING"           , "BE020" ,
    "SPECIAL_AREA"       , "AL215" ,
    "SPECL_USE_AIRSPACE" , "GA015" ,
    "SPILLWAY"           , "BH165" ,
    "SPOT_ELEVATION"     , "CA030" ,
    "SPRING_WATER_HOLE"  , "BH170" ,
    "SS_SONAR_COVERAGE"  , "FC179" ,
    "STADIUM_AMPHI"      , "AK160" ,
    "STATION_MISC"       , "AQ125" ,
    "STATUE_PEDESTAL"    , "AK141" ,
    "STEEP_GRADE"        , "AQ120" ,
    "STORAGE_BUNKER"     , "AM060" ,
    "STORM_DRAIN"        , "AQ114" ,
    "STREET_LIGHTS"      , "AQ161" ,
    "STREET_SIGN"        , "AQ162" ,
    "SUBSTATION"         , "AD030" ,
    "SUBWAY"             , "SU002" ,
    "SWAMP"              , "ED020" ,
    "SWEPT_AREA"         , "FC177" ,
    "SWIMMING_POOL"      , "AK170" ,
    "TANK"               , "AM070" ,
    "TAXIWAY"            , "GB075" ,
    "TELEPHONE_LINE"     , "AT060" ,
    "TELEPHONE_PYLON"    , "AT070" ,
    "TENNIS_COURTS"      , "AK050" ,
    "TENT_DWELLINGS"     , "AL209" ,
    "TEST_AREA"          , "FA100" ,
    "TEXT_DESCRIPTION"   , "ZD045" ,
    "THEODOLITE_LINE"    , "FC101" ,
    "TIDE_DATA_POINT"    , "BG030" ,
    "TIDE_GAUGE"         , "BG020" ,
    "TIMBER_YARD"        , "AM031" ,
    "TOWER_NONCOMM"      , "AL240" ,
    "TRACK_LINE"         , "BE040" ,
    "TRACK_SWATH"        , "BE030" ,
    "TRAFFIC_LIGHTS"     , "AQ160" ,
    "TRAFFIC_SEP_SCHEME" , "FC041" ,
    "TRAIL"              , "AP050" ,
    "TRAINING_AREA"      , "FA165" ,
    "TREES"              , "EC030" ,
    "TRENCH"             , "AH020" ,
    "TUNDRA"             , "BJ110" ,
    "TUNNEL"             , "AQ130" ,
    "UNDERGROUND_BUNKER" , "AH060" ,
    "UNDERGROUND_DWELL"  , "AL250" ,
    "UNDERWATER_DANGER"  , "BD000" ,
    "VEHICLE_REST_AREA"  , "AQ135" ,
    "VEHICLE_STORAGE"    , "AQ140" ,
    "VINEYARDS"          , "EA050" ,
    "VOID_COLLECT_AREA"  , "ZD020" ,
    "VOLCANIC_DIKE"      , "DB190" ,
    "VOLCANO"            , "DB180" ,
    "WALL"               , "AL260" ,
    "WATER_EXCPT_INLAND" , "BA040" ,
    "WATER_INTAKE_TOWER" , "BI050" ,
    "WATER_TOWER"        , "AM080" ,
    "WATER_TURBULENCE"   , "BG012" ,
    "WATERFALL"          , "BH180" ,
    "WAYPOINT"           , "GA055" ,
    "WELL"               , "AA050" ,
    "WIND_INDICATOR"     , "GB080" ,
    "WINDMILL"           , "AJ050" ,
    "WINDMOTOR"          , "AJ051" ,
    "WRECK"              , "BD180" ,
    "WRECKING_YARD"      , "AB010" ,
    "ZOO_SAFARI_PARK"    , "AK180" 
  };


  for(i=0;i<(int)strlen(shortname);i++)
    {
      if ( (shortname[i]>='a')  && (shortname[i]<='z')  ) 
	{
	  shortname[i] = timtoupper2(shortname[i]);
	}
    }
  
  for(i=0;i<(num_specialcases*2);i=i+2)
    {
      sprintf(test1,"%s",  specialcases[i]);
      sprintf(test2,"%sP", specialcases[i]);
      sprintf(test3,"%sL", specialcases[i]);
      sprintf(test4,"%sA", specialcases[i]);
      sprintf(test5,"%s_P",specialcases[i]);
      sprintf(test6,"%s_L",specialcases[i]);
      sprintf(test7,"%s_A",specialcases[i]);

      sprintf(testa1,"GIFD.%s",  specialcases[i]);
      sprintf(testa2,"GIFD.%sP", specialcases[i]);
      sprintf(testa3,"GIFD.%sL", specialcases[i]);
      sprintf(testa4,"GIFD.%sA", specialcases[i]);
      sprintf(testa5,"GIFD.%s_P",specialcases[i]);
      sprintf(testa6,"GIFD.%s_L",specialcases[i]);
      sprintf(testa7,"GIFD.%s_A",specialcases[i]);

      sprintf(testb1,"GIFD_%s",  specialcases[i]);
      sprintf(testb2,"GIFD_%sP", specialcases[i]);
      sprintf(testb3,"GIFD_%sL", specialcases[i]);
      sprintf(testb4,"GIFD_%sA", specialcases[i]);
      sprintf(testb5,"GIFD_%s_P",specialcases[i]);
      sprintf(testb6,"GIFD_%s_L",specialcases[i]);
      sprintf(testb7,"GIFD_%s_A",specialcases[i]);




      if(
	 (!strcmp(shortname,test1)) ||
	 (!strcmp(shortname,test2)) ||
	 (!strcmp(shortname,test3)) ||
	 (!strcmp(shortname,test4)) ||
	 (!strcmp(shortname,test5)) ||
	 (!strcmp(shortname,test6)) ||
	 (!strcmp(shortname,test7)) ||
	 (!strcmp(shortname,testa1)) ||
	 (!strcmp(shortname,testa2)) ||
	 (!strcmp(shortname,testa3)) ||
	 (!strcmp(shortname,testa4)) ||
	 (!strcmp(shortname,testa5)) ||
	 (!strcmp(shortname,testa6)) ||
	 (!strcmp(shortname,testa7)) ||
	 (!strcmp(shortname,testb1)) ||
	 (!strcmp(shortname,testb2)) ||
	 (!strcmp(shortname,testb3)) ||
	 (!strcmp(shortname,testb4)) ||
	 (!strcmp(shortname,testb5)) ||
	 (!strcmp(shortname,testb6)) ||
	 (!strcmp(shortname,testb7)) 
	 )
	{
	  
	  
	  

	  for(j=0;j<(INscc_loop-1);j++)
	    {
	      if(!strcmp(gifd_class_codes[j],specialcases[i+1]))
		{
		  return j;
		}
	    }
	  return -100; 
	}
    }
  return -100;
}




int RealGetClassCodeFromName(char *newshortname)
{
  int i,j,start,len,end,insert;
  char teststring[1000],teststring2[1000];
  int othertest = 0;


  othertest = FindD4List(newshortname);
  if(othertest>=0)
    {
      return othertest;
    }
  
  
  start = 0;

  len = strlen(newshortname);
  end = len;


  


  
  insert=0;
  for(i=start;i<=end;i++)
    {
      if(
	 (  (newshortname[i]>='a')  && (newshortname[i]<='z')  )  ||
	 (  (newshortname[i]>='A')  && (newshortname[i]<='Z')  )  
	 )
	{
	  teststring[insert] = timtoupper2(newshortname[i]);
	  insert++;
	}

      else if (  (newshortname[i]>='0')  && (newshortname[i]<='9')  )
	{
	  
	  teststring[insert] = newshortname[i];
	  insert++;
	}
    }
  teststring[insert] = '\0';
  
  

  
  
  for(i=0;i<(INscc_loop-1);i++)
    {
      insert = 0;
      for(j=0;j<(int)strlen(gifd_class_names[i]);j++)
	{
	  if(
	     (  (gifd_class_names[i][j]>='a')  && (gifd_class_names[i][j]<='z')  )  ||
	     (  (gifd_class_names[i][j]>='A')  && (gifd_class_names[i][j]<='Z')  )
	     )
	    {
	      teststring2[insert] = timtoupper2(gifd_class_names[i][j]);
	      insert++;
	    }
	}
      teststring2[insert] = '\0';




      
      if(!strcmp(teststring,teststring2))
	{
	  return i;
	}
    }


  return -100;
}



int GetClassCodeFromName(char *newshortname)
{
  int test,len;
  char test1[1000];


  test = FindD4List(newshortname);
  if(test>=0)
  { 
    return test;
  }
  

  test = RealGetClassCodeFromName(newshortname);

  if(test>=0)
  {
    return test;
  }


  len = strlen(newshortname);


  if(   (TEMP_ATTRIBUTION_TYPE!=7)&&(TEMP_ATTRIBUTION_TYPE!=8)   )  
  {
    if(
       (newshortname[len-1]=='c') ||
       (newshortname[len-1]=='C') ||
       (newshortname[len-1]=='s') ||
       (newshortname[len-1]=='S') ||
       (newshortname[len-1]=='l') ||
       (newshortname[len-1]=='L') ||
       (newshortname[len-1]=='a') ||
       (newshortname[len-1]=='A') ||
       (newshortname[len-1]=='p') ||
       (newshortname[len-1]=='P') 
      )
    {
	  sprintf(test1,"%s",newshortname);
	  test1[len-1] = '\0';
	  
      test = RealGetClassCodeFromName(test1);

      if(test>=0)
	  { 
        return test;
	  } 
    }
  }
  else
  {
	 if(
       (newshortname[len-1]=='l') ||
       (newshortname[len-1]=='L') ||
       (newshortname[len-1]=='a') ||
       (newshortname[len-1]=='A') ||
       (newshortname[len-1]=='p') ||
       (newshortname[len-1]=='P') 
      )
    {
	  sprintf(test1,"%s",newshortname);
	  test1[len-1] = '\0';
	  
      test = RealGetClassCodeFromName(test1);

      if(test>=0)
	  { 
        return test;
	  } 
    }
  }

  return -100;
  
}





int GetClassCodeAsSubstring(char *shortname)
{  
  int i,insert;
  char teststring[1000];
  char newshortname[1000];

 
    
  
    
  sprintf(newshortname,"%s",shortname);
    
  insert=0;
  for(i=0;i<=(int)strlen(shortname);i++)
    {
      if(
	 (  (newshortname[i]>='a')  && (newshortname[i]<='z')  )  ||
	 (  (newshortname[i]>='A')  && (newshortname[i]<='Z')  )
	 )
	{
	  teststring[insert] = timtoupper2(newshortname[i]);
	  insert++;
	}
      else if((newshortname[i]>='0')  && (newshortname[i]<='9')) 
	{
	  teststring[insert] = newshortname[i];
	  insert++; 
	}
    }
  teststring[insert] = '\0';
  
    
    
    
  if(strlen(teststring)<5)
    {
      
      return -100;
    }
  
    
    
  for(i=1;i<INscc_loop;i++)
    {
      
      
      if(strstr(teststring,GetECCCode(i)))
	{
	  return i-1;
	}
      
      if(
	 (!strcmp(GetECCCode(i),"BB041")) &&
	 (strstr(teststring,"BB040"))
	 )
	{
	  return i-1;
	}
      
      if(
	 (!strcmp(GetECCCode(i),"ED020")) &&
	 (strstr(teststring,"BH095"))
	 )
	{
	  return i-1;
	}
    }
  return -100;
}



  
int CheckFileFCODEs(char *shape_to_import)
{
  
  char thistitle[15]; 
  char thiscode[500];
  TimDBFFieldType	eType; 
  int nDecimals,nWidth,class_code,i,j;
  TimDBFHandle hTimDBF;
  int total_count;
  int good_fcode = 0;
  int record_num=0;
  

  

  hTimDBF = TimDBFOpen(shape_to_import, "rb" );
  if( hTimDBF == NULL )
    {
      return -1;
    }
  
  if( TimDBFGetFieldCount(hTimDBF) == 0 )
    {
      TimDBFClose (hTimDBF);
      return -1;
    }


  total_count = TimDBFGetRecordCount(hTimDBF);
  if(total_count==0)
    {
      TimDBFClose (hTimDBF);
      return -1;
    }
  
  
  TimDBFClose (hTimDBF);
  
  return 0;




  for(i=0; i<TimDBFGetFieldCount(hTimDBF); i++)
    {
      eType = TimDBFGetFieldInfo(hTimDBF,i,thistitle,&nWidth,&nDecimals);
      

      if(
	 (!strcmp(thistitle,"FACC"))   ||
	 (!strcmp(thistitle,"F_CODE")) ||
	 (!strcmp(thistitle,"F_Code"))
	 )
	{
	  eType = TimDBFGetFieldInfo(hTimDBF,i,thistitle,&nWidth,&nDecimals);

	  if(eType==FTString)
	    {
	      
	      for(record_num=0;record_num<total_count;record_num++)
		{		  
		  thiscode[0] = '\0';
		  sprintf(thiscode,"%s",TimDBFReadStringAttribute(hTimDBF,record_num,i));
		  
		  if(thiscode[0]=='\0')
		    {
		      return 0;
		    }
		  else if(strlen(thiscode)<5)
		    {
		      return 0;
		    }
		  else
		    {
		      for(j=0;j<(int)strlen(thiscode);j++)
			{
			  thiscode[j] = timtoupper(thiscode[j]);
			}
		      
		      class_code = SilentConvertClassCode(thiscode);
		      
		      if(class_code==-100)
			{
			  return 0;
			}		      
		    }
		}
	      good_fcode = 1;
	    }
	  else
	    {
	      printf("found F_CODE of type not string.  Ignoring.\n");
	      return 0;
	    }
	}
    }
  return good_fcode;
}



int myunzip(char *filename,FILE *specfile,int *failnum,int *badshapenum)
{
  FILE *ptr;
  int addy,addy2,i,len,lastslash=-1,code_found,retval=0;
  char cmd[1000],buf[1000],lastpart[1000],thisname[1000],thisfullname[1000];
  
  *failnum = 0;
  *badshapenum = 0;
  
  
  
  
  len = strlen(filename);
  for(i=0;i<len;i++)
    {
      if(USE_DOS==1)
	{
	  if(filename[i]=='\\')
	    {
	      lastslash = i;
	    }
	}
      else
	{
	  if(filename[i]=='/')
	    {
	      lastslash = i;
	    }
	}
    }
  
  if(lastslash<0)
    {
      printf("error: couldn't find lastslash for %s\n",filename);
      return -1;
    }
  
  sprintf(lastpart,"%s",&filename[lastslash+1]);
  
  
  len = strlen(lastpart);
  
  if(len<5)
    {
	  
      return -1;
    }
  
  if(USE_DOS==1)
    {
      lastpart[len-4] = '\\';
    }
  else
    {
      lastpart[len-4] = '/';
    }
  lastpart[len-3] = '\0';
  

  

  sprintf(cmd,"unzip -Z -1 \"%s\"",filename);

  
  
  
      
   if((ptr=POPEN(cmd,"r"))!=NULL)
    { 
      while(fgets(buf,1000,ptr)!=NULL)
	  {  

	  len = strlen(buf);  
	  for(i=0;i<len;i++)
	    {
		  if(USE_DOS==1)
		  {
            if(buf[i]=='/')
			{
              buf[i] = '\\';
			}
		  }

	      if(buf[i]=='\n')
		{ 
		  buf[i] = '\0';
		  break;
		}  
	    } 
	  
	  
	  addy2 = (int)strstr(buf,lastpart);
	  
      
	  
	  if((addy2)||(1))
	    { 
	      addy = (int)buf;
	  
		  

	      sprintf(thisname,"%s",buf);


		  

		  sprintf(thisfullname,"%s",&buf[0]);

	      len = strlen(thisname);
	      
	      if(len<5)
		{ 
		  
		} 
	      
	      len = strlen(thisname);
	      if(len>=5)
		{ 
		  if(
		     (thisname[len-4]=='.')                              &&
		     ((thisname[len-3]=='s')  || (thisname[len-3]=='S'))  &&
		     ((thisname[len-2]=='h')  || (thisname[len-2]=='H'))  &&
		     ((thisname[len-1]=='p')  || (thisname[len-1]=='P'))
		     )
		    { 
		      thisname[len-4] = '\0';
		      
		      len = strlen(thisfullname);
		      thisfullname[len-4] = '\0';
		      
		      printf("  Zip-embedded shp file: %s in %s\n",thisfullname,filename);
		      
		      code_found = GetClassCodeAsSubstring(thisname);
		      
		      if(code_found==-100)
			{  
			  code_found = GetClassCodeFromName(thisname);
			}  
		      
		      if(code_found==-100)
			{ 
			  fprintf(specfile,"ZIPSHAPE ***** \"%s;%s\"\n",filename,thisfullname);
			  *failnum = *failnum + 1;
			  *badshapenum = *badshapenum + 1;
			} 
		      else
			{ 
			  fprintf(specfile,"ZIPSHAPE %s \"%s;%s\"\n",GetECCCode(code_found+1),filename,thisfullname);
		      retval = retval + 1; 
			} 
		    }
		}
	    }
	}
    PCLOSE(ptr); 
    }


 

 return retval;

}



int QASTZipfile(char *filename)
{
  int i,len,lastslash=-1;
  char lastpart[1000];


  
  
  len = strlen(filename);
  for(i=0;i<len;i++)
    {
      if(USE_DOS==1)
	{
	  if(filename[i]=='\\')
	    {
	      lastslash = i;
	    }
	}
      else
	{
	  if(filename[i]=='/')
	    {
	      lastslash = i;
	    }
	}
    }
  
  if(lastslash<0)
    {
      printf("qa error: couldn't find lastslash for %s\n",filename);
      return 0;
    }
  
  sprintf(lastpart,"%s",&filename[lastslash+1]);

  len = strlen(lastpart);

  if((len<11)||(len>14))
  {
    return 0;
  }

  if(
 	 ((timtoupper(lastpart[0 ])=='E')||(timtoupper(lastpart[0])=='W')) && 
	 ((timtoupper(lastpart[4 ])=='N')||(timtoupper(lastpart[4])=='S')) && 
     ((lastpart[1]>='0')&&(lastpart[1]<='9'))                          &&
     ((lastpart[2]>='0')&&(lastpart[2]<='9'))                          &&
     ((lastpart[3]>='0')&&(lastpart[3]<='9'))                          &&
     ((lastpart[5]>='0')&&(lastpart[5]<='9'))                          &&
     ((lastpart[6]>='0')&&(lastpart[6]<='9'))                          &&
	 (timtoupper(lastpart[7 ])=='.')                                   && 
	 (timtoupper(lastpart[8 ])=='Z')                                   && 
	 (timtoupper(lastpart[9 ])=='I')                                   && 
	 (timtoupper(lastpart[10])=='P')
	)
  {
    return 1;
  }

  return 0;
}




void BadTREX(Widget w,char *message)
{
  

  if(batch_mode==1)
  {
	printf("\n");
	printf("Cannot proceed with TREx project creation because:\n");
    printf("  %s\n",message);
    exit(-1);
  }

  not_while_running(w,message,1615,"Invalid TREx Folder",5);
}


int FindSlash(char *inval)
{
  int i,thislen;

  thislen = strlen(inval);

  for(i=0;i<thislen;i++)
  {
     if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
	 {
       if(inval[i]=='\\')
	   {
         return i;
	   }
	 }
	 else
	 {
       if(inval[i]=='/')
	   {
         return i;
	   }
	 }
  }

  printf("Error: could not FS for %s\n",inval);
  return 3;

}







int FindFile(int num_found, char **shapesfound,char *filename,int thislen)
{
  int i;
  char midname[1000];

  for(i=0;i<num_found;i++)
  {
    sprintf(midname,"%s",&shapesfound[i][thislen]);

	if(StringCaseInsensitiveMatch(filename,midname))
	{
	  return i;
	}
  }
  return -1;
}


int FindLatestFileWithPrefix(int num_found, char **shapesfound,char *prefix,char *suffix, int thislen)
{
  int i,prefixlen,suffixlen,len,latestdateindex=-1,printit=0;
  long int thisdate=-1,latestdate=-1;
  char midname[1000],testerprefix[1000],testersuffix[1000];
  extern int GetFileDate(char *filename);


  


  prefixlen = strlen(prefix);
  suffixlen = strlen(suffix);


  if(printit==1)printf("Looking for ancillary\n");
  if(printit==1)printf("...looking for prefix %s (len %d)\n",prefix,prefixlen);
  if(printit==1)printf("...looking for suffix %s (len %d)\n",suffix,suffixlen);



  for(i=0;i<num_found;i++)
  {
     sprintf(midname,"%s",&shapesfound[i][thislen]);

	 len = strlen(midname);


	 if(printit==1)printf("...examining %s (len %d)\n",midname,len);

	 if( len < (prefixlen+suffixlen) )
	 {
	   if(printit==1)printf("skipping because this len %d prefixlen %d suffixlen %d\n",len,prefixlen,suffixlen);
       continue;
	 }

	 sprintf(testerprefix,"%s",midname);
	 testerprefix[prefixlen] = '\0';

	 sprintf(testersuffix,"%s",&midname[len-suffixlen]);
	 testersuffix[suffixlen] = '\0';

	 if(printit==1)printf("......built prefix %s\n",testerprefix);
	 if(printit==1)printf("......built suffix %s\n",testersuffix);





 	 if(!strcmp(prefix,testerprefix))
	 {
 	   if(!strcmp(suffix,testersuffix))
	   { 

		 

		 if(printit==1)printf(" *** found match\n");

		 thisdate = GetFileDate(shapesfound[i]);

		 if(printit==1)printf(" ******got file date %ld from %s\n",thisdate,shapesfound[i]);

		 if(thisdate>latestdate)
		 {
           latestdate = thisdate;
		   latestdateindex = i;

		   if(printit==1)printf(" **********just set this file (%d) to latest\n",i);
		 }
	   } 
	 }
  }

  if(printit==1)
  {
    printf("returning index %d\n",latestdateindex);
    if(latestdateindex>=0)
	{ 
      printf("...that is %s\n",shapesfound[latestdateindex]);
	} 
  }

  return latestdateindex;
}



char *GetLastTrexPart(char *inname)
{
  int i,len,lastslash=-1;
  char filename[1000];
  static char lastpart[1000];


  sprintf(filename,"%s",inname);
  len = strlen(filename);
  if((filename[len-1]=='\\')||(filename[len-1]=='/'))
  {
	
	filename[len-1] = '\0';
  }


  
  
  len = strlen(filename);
  for(i=0;i<len;i++)
  { 
    if(USE_DOS==1)
	{
	  if(filename[i]=='\\')
	  {
	    lastslash = i;
	  }
	}
    else
	{
	  if(filename[i]=='/')
	  {
	    lastslash = i;
	  }
	}
  } 
  
  if(lastslash<0)
  {
    printf("error: couldn't find lastslash for %s\n",filename);
    return NULL;
  }
  
  sprintf(lastpart,"%s",&filename[lastslash+1]);

  return lastpart;
}


int IsLetter(int num)
{
  if((num>=65)&&(num<=90))
    {
      return 1;
    }
  return 0;
}

int IsNumber(int num)
{
  if((num>=48)&&(num<=57))
    {
      return 1;
    }
  return 0;
}



int GetTREXid(Widget w,char *trexfolder)
{
  char tempchar[2000],message[2000],smallchar[10];
  int latitude,longitude,verbose=0;

  


  sprintf(tempchar,"%s",GetLastTrexPart(trexfolder));

  if(tempchar==NULL)
  {
	sprintf(tempchar,"Unable to parse valid TREx package name from %s\n",trexfolder);
    not_while_running(w,tempchar,1616,"Invalid TREx project foldername",1);
	return 0;
  }

  if(strlen(tempchar)!=7)
  {
    sprintf(tempchar,"Unable to parse valid TREx package name from %s\n Expected 7 character name in form bDDcDDD (error: %d)",trexfolder,(int)strlen(tempchar));
    not_while_running(w,tempchar,1617,"Invalid TREx project foldername",1);
	return 0;
  }


  printf("Found TREx package folder with name: %s\n",tempchar);


  if((tempchar[0]!='n')&&(tempchar[0]!='N')&&(tempchar[0]!='s')&&(tempchar[0]!='S'))
  {
	sprintf(message,"Unable to parse valid TREx package name from %s\n  Expected form bDDcDDD with N or S in position 1, found %c",tempchar,tempchar[0]);
    not_while_running(w,message,1618,"Invalid TREx project foldername",1);
	return 0;
  }

  if((tempchar[3]!='e')&&(tempchar[3]!='E')&&(tempchar[3]!='w')&&(tempchar[3]!='W'))
  {
	sprintf(message,"Unable to parse valid TREx package name from %s\n  Expected form bDDcDDD with E or W in position 4, found %c",tempchar,tempchar[0]);
    not_while_running(w,message,1619,"Invalid TREx project foldername",1);
	return 0;
  }

  if(IsNumber(tempchar[1]==0))
  {
	sprintf(message,"Unable to parse valid TREx package name from %s\n  Expected form bDDcDDD with number in position 1, found %c",tempchar,tempchar[1]);
    not_while_running(w,message,1620,"Invalid TREx project foldername",1);
	return 0;
  }
  if(IsNumber(tempchar[2]==0))
  {
	sprintf(message,"Unable to parse valid TREx package name from %s\n  Expected form bDDcDDD with number in position 2, found %c",tempchar,tempchar[2]);
    not_while_running(w,message,1621,"Invalid TREx project foldername",1);
	return 0;
  }
  if(IsNumber(tempchar[4]==0))
  {
	sprintf(message,"Unable to parse valid TREx package name from %s\n  Expected form bDDcDDD with number in position 4, found %c",tempchar,tempchar[4]);
    not_while_running(w,message,1622,"Invalid TREx project foldername",1);
	return 0;
  }
  if(IsNumber(tempchar[5]==0))
  {
	sprintf(message,"Unable to parse valid TREx package name from %s\n  Expected form bDDcDDD with number in position 5, found %c",tempchar,tempchar[5]);
    not_while_running(w,message,1623,"Invalid TREx project foldername",1);
	return 0;
  }
  if(IsNumber(tempchar[6]==0))
  {
	sprintf(message,"Unable to parse valid TREx package name from %s\n  Expected form bDDcDDD with number in position 6, found %c",tempchar,tempchar[6]);
    not_while_running(w,message,1624,"Invalid TREx project foldername",1);
	return 0;
  }


  smallchar[0] = tempchar[1];
  smallchar[1] = tempchar[2];
  smallchar[2] = '\0';
  sscanf(smallchar,"%d",&latitude);

  smallchar[0] = tempchar[4];
  smallchar[1] = tempchar[5];
  smallchar[2] = tempchar[6];
  smallchar[3] = '\0';
  sscanf(smallchar,"%d",&longitude);

  if((tempchar[0]=='s')||(tempchar[0]=='S'))
  {
	latitude = latitude * -1;
  }
  if((tempchar[3]=='w')||(tempchar[3]=='W'))
  {
	longitude = longitude * -1;
  }

  if(verbose==1)
  {
	printf("have x %d y %d\n",longitude,latitude);
  }

  if((latitude<-90)||(latitude>89))
  {
	sprintf(message,"Unable to parse valid TREx package name from %s\n  Expected latitude -90 to 89, found %d",tempchar,latitude);
    not_while_running(w,message,1625,"Invalid TREx project foldername",1);
	return 0;
  }
  if((longitude<-180)||(longitude>179))
  {
	sprintf(message,"Unable to parse valid TREx package name from %s\n  Expected longitude -180 to 179, found %d",tempchar,longitude);
    not_while_running(w,message,1626,"Invalid TREx project foldername",1);
	return 0;
  }


  sprintf(trexid1,"%s",tempchar);

  if(abs(latitude)>=80)
  {
	
	if((abs(longitude)%4)!=0)
	{
  	  sprintf(message,"Unable to parse valid TREx package name from %s\n  Expected longitude (%d) to be multiple of 4 for latitude %d",tempchar,longitude,latitude);
      not_while_running(w,message,1627,"Invalid TREx project foldername",1);
 	  return 0;
	}

	

	if(longitude<0)
	{
	  sprintf(trexid2,"%c%c%c%c%03d",trexid1[0],trexid1[1],trexid1[2],trexid1[3],(longitude*-1)-1);
	  sprintf(trexid3,"%c%c%c%c%03d",trexid1[0],trexid1[1],trexid1[2],trexid1[3],(longitude*-1)-2);
	  sprintf(trexid4,"%c%c%c%c%03d",trexid1[0],trexid1[1],trexid1[2],trexid1[3],(longitude*-1)-3);
	}
	else
	{
	  sprintf(trexid2,"%c%c%c%c%03d",trexid1[0],trexid1[1],trexid1[2],trexid1[3],longitude+1);
	  sprintf(trexid3,"%c%c%c%c%03d",trexid1[0],trexid1[1],trexid1[2],trexid1[3],longitude+2);
	  sprintf(trexid4,"%c%c%c%c%03d",trexid1[0],trexid1[1],trexid1[2],trexid1[3],longitude+3);
	}
  }
  else if(abs(latitude)>=60)
  {
	
	if((abs(longitude)%2)!=0)
	{
  	  sprintf(message,"Unable to parse valid TREx package name from %s\n  Expected longitude (%d) to be multiple of 2 for latitude %d",tempchar,longitude,latitude);
      not_while_running(w,message,1628,"Invalid TREx project foldername",1);
 	  return 0;
	}

	

	if(longitude<0)
	{
	  sprintf(trexid2,"%c%c%c%c%03d",trexid1[0],trexid1[1],trexid1[2],trexid1[3],(longitude*-1)-1);
	}
	else
	{
	  sprintf(trexid2,"%c%c%c%c%03d",trexid1[0],trexid1[1],trexid1[2],trexid1[3],longitude+1);
	}
  }


  return 1;
}





int CheckTREX(Widget w, int num_found, char **shapesfound, FILE *infile)
{
  char midname[1000],newTDF[1000],saveTDR[1000],newTDR[1000],message[2000],
	  tester[1000],thisid[100],thisshortid[100],thisshortTILEid[100],
	  newTDFsave[1000],expect1[200],expect2[200],expect3[200],expect4[200],
	  temp[1000],save1[100],save2[100],save3[100],save4[100],thisANCid[100],
	  tempannotation[200],testa[1000],testb[1000],thisrawid[100];
  int i,thislen,thislen2,slashfound,thisindex,foundtdr=0,goodtiff=0,thislen3=0,
	  found1=0,found2=0,found3=0,found4=0,thispackage,version,ANC_DONE=0,
	  TDF_DONE=0,foundfinished=0;
  int verbose=0;
  extern int CREATING_TREX;
  extern int AddDtedFile(FILE *infile,char *dtedfile,char *lodoverride);




  if(CREATING_TREX==0)
  {
    return 0; 
  }

  trexid1[0] = '\0';
  trexid2[0] = '\0';
  trexid3[0] = '\0';
  trexid4[0] = '\0';


  if(GetTREXid(w,shapeimportoutputdir)==0)
  {
	if(batch_mode==1)
	{
      ExitWrapper(-1);
	}
	return -1; 
  }



  if(verbose==1){printf("have trexids: 1: %s 2: %s 3: %s 4: %s\n",trexid1,trexid2,trexid3,trexid4);}

  if(verbose==1){printf("num found %d\n",num_found);}


  sprintf(expect1,"TDF_%s",trexid1);
  sprintf(expect2,"TDF_%s",trexid2);
  sprintf(expect3,"TDF_%s",trexid3);
  sprintf(expect4,"TDF_%s",trexid4);


  thislen = strlen(shapeimportoutputdir);

  for(i=0;i<num_found;i++)
  {
     sprintf(midname,"%s",&shapesfound[i][thislen]);


     if(verbose==1){printf("assessing %s\n",midname);}


	 thislen2 = strlen(midname);
	 if(thislen2>=14)
	 {
	   if(!strncmp(midname,"TDF_",4))
	   {
         sprintf(newTDF,"%s",midname);
         sprintf(newTDFsave,"%s",midname);

		 slashfound = FindSlash(newTDFsave);

		 newTDFsave[slashfound] = '\0';


		 


		 newTDF[11] = '\0';

         if(
			 (StringCaseInsensitiveMatch(newTDF,expect1)==0) &&
			 (StringCaseInsensitiveMatch(newTDF,expect2)==0) &&
			 (StringCaseInsensitiveMatch(newTDF,expect3)==0) &&
			 (StringCaseInsensitiveMatch(newTDF,expect4)==0)
		   )
		 {
           sprintf(message,"Error: unexpected \"TDF_\" files/folders found:\n  %s\nwithin selected folder:\n%s",
				 newTDF,shapeimportoutputdir);
		   BadTREX(w,message);
		   return -1;
		 }

		 if(StringCaseInsensitiveMatch(newTDF,expect1)==1){found1 = 1; sprintf(save1,"%s",newTDFsave);}
	     if(StringCaseInsensitiveMatch(newTDF,expect2)==1){found2 = 1; sprintf(save2,"%s",newTDFsave);}
		 if(StringCaseInsensitiveMatch(newTDF,expect3)==1){found3 = 1; sprintf(save3,"%s",newTDFsave);}
		 if(StringCaseInsensitiveMatch(newTDF,expect4)==1){found4 = 1; sprintf(save4,"%s",newTDFsave);}
	   }


	   if(!strncmp(midname,"TDR_",4))
	   {
         sprintf(newTDR,"%s",midname);

		 slashfound = FindSlash(newTDR);

		 newTDR[slashfound] = '\0';
   
		 if(strlen(newTDR)==14)
		 {
		   if(foundtdr==1)
		   {
             if(StringCaseInsensitiveMatch(newTDR,saveTDR)==0)
			 {
               sprintf(message,"Error: multiple \"TDR_\" files/folders found:\n  %s\n  %s\nwithin selected folder:\n%s",
				 newTDR,saveTDR,shapeimportoutputdir);
			   BadTREX(w,message);
			   return -1;
			 } 
		   } 
		   else
		   { 
             sprintf(saveTDR,"%s",newTDR);
		   } 
		   foundtdr = 1;
		 }
	   }
	 }
  }

  if(strlen(trexid1)>0)
  {
    if(found1==0)
	{
     sprintf(message,"Error: No \"%s\" found in folder:\n%s",expect1,shapeimportoutputdir);
	 BadTREX(w,message);
	 return -1;
	}
  }
  if(strlen(trexid2)>0)
  {
    if(found2==0)
	{
     sprintf(message,"Error: No \"%s\" found in folder:\n%s",expect2,shapeimportoutputdir);
	 BadTREX(w,message);
	 return -1;
	}
  }
  if(strlen(trexid3)>0)
  {
    if(found3==0)
	{
     sprintf(message,"Error: No \"%s\" found in folder:\n%s",expect3,shapeimportoutputdir);
	 BadTREX(w,message);
	 return -1;
	}
  }
  if(strlen(trexid4)>0)
  {
    if(found4==0)
	{
     sprintf(message,"Error: No \"%s\" found in folder:\n%s",expect4,shapeimportoutputdir);
	 BadTREX(w,message);
	 return -1;
	}
  }


  if(foundtdr==0)
  {
     sprintf(message,"Error: No \"TDR_bDDcDDD_vv\" folder in folder:\n%s",shapeimportoutputdir);
	 


	

	sprintf(saveTDR,"TDR_%s",&save1[4]);
    saveTDR[14] = '\0';
	printf("No TDR found...generated name %s\n",saveTDR);
  }


  save1[14] = '\0';
  save2[14] = '\0';
  save3[14] = '\0';
  save4[14] = '\0';


  
  

  if(found1>0)
  {
	sprintf(testa,"%s",&saveTDR[4]);
	testa[7] = '\0';

	sprintf(testb,"%s",&save1[4]);
	testb[7] = '\0';

    if(StringCaseInsensitiveMatch(testa,testb)==0)
	{ 
      sprintf(message,"Error: %s does not match %s in folder:\n%s",saveTDR,save1,shapeimportoutputdir);
	  BadTREX(w,message);
	  return -1;
	}
	printf("finished package 1: %s\n",save1);
  }

  if(found2>0)
  {
	printf("finished package 2: %s\n",save2);
  }
  if(found3>0)
  {
	printf("finished package 3: %s\n",save3);
  }
  if(found4>0)
  {
	printf("finished package 4: %s\n",save4);
  }

  if(verbose==1){printf("saveTDR: %s\n",saveTDR);}



  sprintf(thisid,"%s",&saveTDR[4]);


  if(verbose==1){printf("thisid %s\n",thisid);}


  if(strlen(thisid)!=10)
  {
     sprintf(message,"Error: No \"TDF_bDDcDDD_vv\" folder in folder:\n%s",shapeimportoutputdir);
	 BadTREX(w,message);
	 return -1;
  }

  if(thisid[7]!='_')
  {
     sprintf(message,"Error: No \"TDF_bDDcDDD_vv\" folder in folder:\n%s",shapeimportoutputdir);
	 BadTREX(w,message);
	 return -1;
  }






  if((thisid[0]!='n')&&(thisid[0]!='N')&&(thisid[0]!='s')&&(thisid[0]!='S'))
  {
     sprintf(message,"Error: No \"TDF_{nNsS}DDcDDD_vv\" folder in folder:\n%s",shapeimportoutputdir);
	 BadTREX(w,message);
	 return -1;
  }

  if((thisid[3]!='e')&&(thisid[3]!='E')&&(thisid[3]!='w')&&(thisid[3]!='W'))
  {
     sprintf(message,"Error: No \"TDF_bDD{eEwW}DDD_vv\" folder in folder:\n%s",shapeimportoutputdir);
	 BadTREX(w,message);
	 return -1;
  }


  if(
	  (thisid[8]<'0')  || (thisid[8]>'9')||
	  (thisid[9]<'0')  || (thisid[9]>'9')||
	  ((thisid[8]=='0')&&(thisid[9]=='0'))  
    )
  {

	 if(foundtdr==1)
	 {
       sprintf(message,"Error: Invalid version \"%c%c\"\n for %s\n  (%s)",thisid[8],thisid[9],shapeimportoutputdir,saveTDR);
	 }
	 else if(found1==1)
	 {
       sprintf(message,"Error: Invalid version \"%c%c\"\n for %s\n  (%s)",thisid[8],thisid[9],shapeimportoutputdir,save1);
	 }
	 else if(found1==2)
	 {
       sprintf(message,"Error: Invalid version \"%c%c\"\n for %s\n  (%s)",thisid[8],thisid[9],shapeimportoutputdir,save2);
	 }
	 else if(found1==3)
	 {
       sprintf(message,"Error: Invalid version \"%c%c\"\n for %s\n  (%s)",thisid[8],thisid[9],shapeimportoutputdir,save3);
	 }
	 else if(found1==4)
	 {
       sprintf(message,"Error: Invalid version \"%c%c\"\n for %s\n  (%s)",thisid[8],thisid[9],shapeimportoutputdir,save4);
	 }
	 else
	 {
       sprintf(message,"Error: Invalid version \"%c%c\"\n for %s",thisid[8],thisid[9],shapeimportoutputdir);
	 }
	 BadTREX(w,message);
	 return -1;
  }

  if(verbose==1)
  {
	printf("\nFound TDR and TDF with id %s...add TIF files now\n\n",thisid);
	printf("...user_trex_cell %d\n",user_trex_cell);
  }



  for(thispackage=0;thispackage<4;thispackage++)
  {
    


	
	if(thispackage!=user_trex_cell)
	{
	  continue;
	}





	

	if(thispackage==0)
	{
      sprintf(thisid,"%s",&save1[4]);
	}
	else if(thispackage==1)
	{
	  if(found2==0)
	  {
		break; 
	  }
      sprintf(thisid,"%s",&save2[4]);
	}
	else if(thispackage==2)
	{
	  if(found3==0)
	  {
		break; 
	  }
      sprintf(thisid,"%s",&save3[4]);
	}
	else if(thispackage==3)
	{
	  if(found4==0)
	  {
		break; 
	  }
      sprintf(thisid,"%s",&save4[4]);
	}

    sprintf(thisshortid,"%s",thisid);
    thisshortid[7] = '\0';


    sprintf(thisshortTILEid,"%s",&save1[4]);
    thisshortTILEid[7] = '\0';



	if(verbose==1){printf("using thisid %s and thisshortid %s and thisshortTILEid %s for pass %d\n",thisid,thisshortid,thisshortTILEid,thispackage);}


 
    

	for(version=99;version>=1;version--)  
	{

      sprintf(thisid,"%s_%02d",thisshortid,version);


	  
	  sprintf(temp,"%s",&save1[4]);
      temp[7] = '\0';
      sprintf(thisrawid,"%s_%02d",temp,version);



      


      

      
if(version==ANC_DONE)
{
  printf("\n\nRE_DOING version %d for thispackage %d\n",version,thispackage);
}


      if((ANC_DONE==0)||(version==ANC_DONE))
	  {
        
		


		


		sprintf(temp,"%s",&save1[4]);
        temp[7] = '\0';
        sprintf(thisANCid,"%s_%02d",temp,version);


		

        if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
		{  
          sprintf(tester,"ANC_%s\\LAB\\LAB_%s",thisANCid,thisshortid);
		}  
        else
		{  
          sprintf(tester,"ANC_%s/LAB/LAB_%s",thisANCid,thisshortid);
		}  

        thisindex = FindLatestFileWithPrefix(num_found,shapesfound,tester,".shp",thislen);

        if(thisindex==-1)
		{ 
          thisindex = FindLatestFileWithPrefix(num_found,shapesfound,tester,".SHP",thislen);
	      if(thisindex>=0)
		  { 
            sprintf(message,"Error: LAB file with invalid extension \"SHP\" found (expected \"shp\")\n  %s\n",tester);
            not_while_running(w,message,1630,"Invalid LAB extension",1);   
		  } 
		} 

        if(thisindex>=0)
		{ 
          thislen3 = strlen(shapesfound[thisindex]);
          shapesfound[thisindex][thislen3-4]    = '\0';
 
          fprintf(infile,"SHAPE GB005 \"%s\"\n",shapesfound[thisindex]);
		  ANC_DONE = version;  
		} 
  



        if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
		{ 
          sprintf(tester,"ANC_%s\\SRT2f\\SRT2f_%s",thisANCid,thisshortTILEid); 
		} 
        else
		{ 
          sprintf(tester,"ANC_%s/SRT2f/SRT2f_%s",thisANCid,thisshortTILEid); 
		} 

        thisindex = FindLatestFileWithPrefix(num_found,shapesfound,tester,".tif",thislen);

        if(thisindex>=0)
		{ 
      	  sprintf(tempannotation,"SRTM Level 2_%d",thispackage);

          ANC_DONE = version;  

          if(AddGeoTiffFile(infile,shapesfound[thisindex],1,tempannotation)==1)
		  {  
            goodtiff++;
		  } 
		} 



        if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
		{ 
          sprintf(tester,"ANC_%s\\ASTGTM2\\ASTGTM2_%s",thisANCid,thisshortTILEid); 
		} 
        else
		{ 
          sprintf(tester,"ANC_%s/ASTGTM2/ASTGTM2_%s",thisANCid,thisshortTILEid); 
		} 

        thisindex = FindLatestFileWithPrefix(num_found,shapesfound,tester,".tif",thislen);

        if(thisindex>=0)
		{ 
	      sprintf(tempannotation,"ASTER GDEM v2_%d",thispackage);

          ANC_DONE = version;  

          if(AddGeoTiffFile(infile,shapesfound[thisindex],1,tempannotation)==1)
		  {  
            goodtiff++;
		  } 
		} 



        if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
		{ 
          sprintf(tester,"ANC_%s\\DTED1\\DTED1_%s",thisANCid,thisshortid);
		} 
        else
		{ 
          sprintf(tester,"ANC_%s/DTED1/DTED1_%s",thisANCid,thisshortid);
		} 

        thisindex = FindLatestFileWithPrefix(num_found,shapesfound,tester,".tif",thislen);

        if(thisindex>=0)
		{ 
	      sprintf(tempannotation,"DTED Level 1_%d",thispackage);

          ANC_DONE = version;  

          if(AddGeoTiffFile(infile,shapesfound[thisindex],1,tempannotation)==1)
		  {  
            goodtiff++;
		  } 
		} 




        if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
		{ 
          sprintf(tester,"ANC_%s\\AE\\AE_%s",thisANCid,thisshortid);
		} 
        else
		{ 
          sprintf(tester,"ANC_%s/AE/AE_%s",thisANCid,thisshortid);
		} 

        thisindex = FindLatestFileWithPrefix(num_found,shapesfound,tester,".tif",thislen);

        if(thisindex>=0)
		{ 
	      sprintf(tempannotation,"Active Earthscape_%d",thispackage);

          ANC_DONE = version;  

          if(AddGeoTiffFile(infile,shapesfound[thisindex],1,tempannotation)==1)
		  {  
            goodtiff++;
		  } 
		} 




        if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
		{ 
          sprintf(tester,"ANC_%s\\CDEM\\CDEM_%s",thisANCid,thisshortTILEid); 
		} 
        else
		{ 
          sprintf(tester,"ANC_%s/CDEM/CDEM_%s",thisANCid,thisshortTILEid); 
		} 

        thisindex = FindLatestFileWithPrefix(num_found,shapesfound,tester,".tif",thislen);

        if(thisindex>=0)
		{ 
	      sprintf(tempannotation,"CDEM_%d",thispackage);

          ANC_DONE = version;  

          if(AddGeoTiffFile(infile,shapesfound[thisindex],1,tempannotation)==1)
		  {  
            goodtiff++;
		  } 
		} 





        if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
		{ 
          sprintf(tester,"ANC_%s\\AW3D30\\AW3D30_%s",thisANCid,thisshortTILEid); 
		} 
        else
		{ 
          sprintf(tester,"ANC_%s/AW3D30/AW3D30_%s",thisANCid,thisshortTILEid); 
		} 

        thisindex = FindLatestFileWithPrefix(num_found,shapesfound,tester,".tif",thislen);

        if(thisindex>=0)
		{ 
	      sprintf(tempannotation,"AW3D30_%d",thispackage);

          ANC_DONE = version;  

          if(AddGeoTiffFile(infile,shapesfound[thisindex],1,tempannotation)==1)
		  {  
            goodtiff++;
		  } 
		} 



        if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
		{ 
          sprintf(tester,"ANC_%s\\PGC\\PGC_%s",thisANCid,thisshortTILEid); 
		} 
        else
		{ 
          sprintf(tester,"ANC_%s/PGC/PGC_%s",thisANCid,thisshortTILEid); 
		} 

        thisindex = FindLatestFileWithPrefix(num_found,shapesfound,tester,".tif",thislen);

        if(thisindex>=0)
		{ 
	      sprintf(tempannotation,"PGC_%d",thispackage);

          ANC_DONE = version;  

          if(AddGeoTiffFile(infile,shapesfound[thisindex],1,tempannotation)==1)
		  {  
            goodtiff++;
		  } 
		} 



        if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
		{ 
          sprintf(tester,"ANC_%s\\GSDE\\GSDE_%s",thisANCid,thisshortTILEid); 
		} 
        else
		{ 
          sprintf(tester,"ANC_%s/GSDE/GSDE_%s",thisANCid,thisshortTILEid); 
		} 

        thisindex = FindLatestFileWithPrefix(num_found,shapesfound,tester,".tif",thislen);

        if(thisindex>=0)
		{ 
	      sprintf(tempannotation,"GSDE_%d",thispackage);

          ANC_DONE = version;  

          if(AddGeoTiffFile(infile,shapesfound[thisindex],1,tempannotation)==1)
		  {  
            goodtiff++;
		  } 
		} 



        if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
		{ 
          sprintf(tester,"ANC_%s\\FINDEM10\\FINDEM10_%s",thisANCid,thisshortTILEid); 
		} 
        else
		{ 
          sprintf(tester,"ANC_%s/FINDEM10/FINDEM10_%s",thisANCid,thisshortTILEid); 
		} 

        thisindex = FindLatestFileWithPrefix(num_found,shapesfound,tester,".tif",thislen);

        if(thisindex>=0)
		{ 
	      sprintf(tempannotation,"FINDEM10_%d",thispackage);

          ANC_DONE = version;  

          if(AddGeoTiffFile(infile,shapesfound[thisindex],1,tempannotation)==1)
		  {  
            goodtiff++;
		  } 
		} 



        if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
		{ 
          sprintf(tester,"ANC_%s\\MGCPNDEM\\MGCPNDEM_%s",thisANCid,thisshortid);
		} 
        else
		{ 
          sprintf(tester,"ANC_%s/MGCPNDEM/MGCPNDEM_%s",thisANCid,thisshortid);
		} 

        thisindex = FindLatestFileWithPrefix(num_found,shapesfound,tester,".tif",thislen);

        if(thisindex>=0)
		{ 
	      sprintf(tempannotation,"MGCPNDEM_%d",thispackage);

          ANC_DONE = version;  

          if(AddGeoTiffFile(infile,shapesfound[thisindex],1,tempannotation)==1)
		  {  
            goodtiff++;
		  } 
		} 



        if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
		{ 
          sprintf(tester,"ANC_%s\\NORDEM10\\NORDEM10_%s",thisANCid,thisshortTILEid); 
		} 
        else
		{ 
          sprintf(tester,"ANC_%s/NORDEM10/NORDEM10_%s",thisANCid,thisshortTILEid); 
		} 

        thisindex = FindLatestFileWithPrefix(num_found,shapesfound,tester,".tif",thislen);

        if(thisindex>=0)
		{ 
	      sprintf(tempannotation,"NORDEM10_%d",thispackage);

          ANC_DONE = version;  

          if(AddGeoTiffFile(infile,shapesfound[thisindex],1,tempannotation)==1)
		  {  
            goodtiff++;
		  } 
		}
		



        if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
		{ 
          sprintf(tester,"ANC_%s\\NPDEM\\NPDEM_%s",thisANCid,thisshortTILEid); 
		} 
        else
		{ 
          sprintf(tester,"ANC_%s/NPDEM/NPDEM_%s",thisANCid,thisshortTILEid); 
		} 

        thisindex = FindLatestFileWithPrefix(num_found,shapesfound,tester,".tif",thislen);

        if(thisindex>=0)
		{ 
	      sprintf(tempannotation,"NPDEM_%d",thispackage);

          ANC_DONE = version;  

          if(AddGeoTiffFile(infile,shapesfound[thisindex],1,tempannotation)==1)
		  {  
            goodtiff++;
		  } 
		} 







        if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
		{ 
          sprintf(tester,"ANC_%s\\GMTED\\GMTED_%s_mn75",thisANCid,thisshortTILEid); 
		} 
        else
		{ 
          sprintf(tester,"ANC_%s/GMTED/GMTED_%s_mn75",thisANCid,thisshortTILEid); 
		} 


        thisindex = FindLatestFileWithPrefix(num_found,shapesfound,tester,".tif",thislen);

        if(thisindex>=0)
		{ 
	      sprintf(tempannotation,"GMTED mn75_%d",thispackage);

          ANC_DONE = version;  

          if(AddGeoTiffFile(infile,shapesfound[thisindex],1,tempannotation)==1)
		  {  
            goodtiff++;
		  } 
		} 



        if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
		{ 
          sprintf(tester,"ANC_%s\\GMTED\\GMTED_%s_mn300",thisANCid,thisshortTILEid); 
		} 
        else
		{ 
          sprintf(tester,"ANC_%s/GMTED/GMTED_%s_mn300",thisANCid,thisshortTILEid); 
		} 


        thisindex = FindLatestFileWithPrefix(num_found,shapesfound,tester,".tif",thislen);

        if(thisindex>=0)
		{  
	      sprintf(tempannotation,"GMTED mn300_%d",thispackage);

          ANC_DONE = version;  

          if(AddGeoTiffFile(infile,shapesfound[thisindex],1,tempannotation)==1)
		  {  
            goodtiff++;
		  } 
		} 






        if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
		{ 
          sprintf(tester,"ANC_%s\\ICESAT\\ICESAT_%s",thisANCid,thisshortid);
		} 
        else
		{ 
          sprintf(tester,"ANC_%s/ICESAT/ICESAT_%s",thisANCid,thisshortid);
		} 

        thisindex = FindLatestFileWithPrefix(num_found,shapesfound,tester,".shp",thislen);

        if(thisindex==-1)
		{ 
          thisindex = FindLatestFileWithPrefix(num_found,shapesfound,tester,".SHP",thislen);
	      if(thisindex>=0)
		  { 
            sprintf(message,"Error: ICESAT file with invalid extension \"SHP\" found (expected \"shp\")\n  %s\n",tester);
            not_while_running(w,message,1630,"Invalid ICESAT SHP extension",1);   
		  } 
		} 


        if(thisindex>=0)
		{ 
          thislen3 = strlen(shapesfound[thisindex]);
          shapesfound[thisindex][thislen3-4]    = '\0';

          fprintf(infile,"SHAPE_%d CA030 \"%s\"\n",thispackage,shapesfound[thisindex]);

          ANC_DONE = version;  
		} 

		if(ANC_DONE==version)
		{
		  printf("Found highest-version ANC was %d\n",version);
		}

      }  


      





	 




      





      

      
if(version==TDF_DONE)
{
  printf("\n\nRE_DOING TDF version %d for thispackage %d\n",version,thispackage);
}


      if((TDF_DONE==0)||(version==TDF_DONE))
	  {
        
		


		



		



	    if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
		{  
          sprintf(tester,"TDF_%s\\DEM\\TDF_%s_DEM.tif",thisid,thisid);
		}  
	    else
		{  
          sprintf(tester,"TDF_%s/DEM/TDF_%s_DEM.tif",thisid,thisid);
		} 

	    thisindex = FindFile(num_found,shapesfound,tester,thislen);

		if(thisindex>=0)
		{  
          thislen3 = strlen(shapesfound[thisindex]);
  	      shapesfound[thisindex][thislen3]    = '\0';

	      sprintf(tempannotation,"TREx DEM Finished_%d",thispackage);

		  TDF_DONE = version;  

	      if(AddGeoTiffFile(infile,shapesfound[thisindex],1,tempannotation)==1)
		  { 
	       goodtiff++;
		   foundfinished = 1;
		  }  
		}  



	    if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
		{  
          sprintf(tester,"TDF_%s\\AUXFILES\\TDF_%s_EDM.tif",thisid,thisid);
		}  
	    else
		{  
          sprintf(tester,"TDF_%s/AUXFILES/TDF_%s_EDM.tif",thisid,thisid);
		}  

	    thisindex = FindFile(num_found,shapesfound,tester,thislen);

		if(thisindex>=0)
		{  
          thislen3 = strlen(shapesfound[thisindex]);
  	      shapesfound[thisindex][thislen3]    = '\0';

	      sprintf(tempannotation,"Edit Data Mask_%d",thispackage);

		  TDF_DONE = version;  

	      if(AddGeoTiffFile(infile,shapesfound[thisindex],1,tempannotation)==1)
		  {  
	        goodtiff++;
		  }  
		}  



	    if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
		{  
          sprintf(tester,"TDF_%s\\AUXFILES\\TDF_%s_SDM.tif",thisid,thisid);
		}  
	    else
		{  
          sprintf(tester,"TDF_%s/AUXFILES/TDF_%s_SDM.tif",thisid,thisid);
		}  

	    thisindex = FindFile(num_found,shapesfound,tester,thislen);

		if(thisindex>=0)
		{  
          thislen3 = strlen(shapesfound[thisindex]);
  	      shapesfound[thisindex][thislen3]    = '\0';

	      sprintf(tempannotation,"Source Data Mask_%d",thispackage);

		  TDF_DONE = version;  

	      if(AddGeoTiffFile(infile,shapesfound[thisindex],1,tempannotation)==1)
		  {  
	        goodtiff++;
		  }  
		}  



	    if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
		{  
          sprintf(tester,"TDF_%s\\AUXFILES\\TDF_%s_HEM.tif",thisid,thisid);
		}  
	    else
		{  
          sprintf(tester,"TDF_%s/AUXFILES/TDF_%s_HEM.tif",thisid,thisid);
		}  

	    thisindex = FindFile(num_found,shapesfound,tester,thislen);

		if(thisindex>=0)
		{  
          thislen3 = strlen(shapesfound[thisindex]);
  	      shapesfound[thisindex][thislen3]    = '\0';

	      sprintf(tempannotation,"Height Error Map_%d",thispackage);

		  TDF_DONE = version;  

	      if(AddGeoTiffFile(infile,shapesfound[thisindex],1,tempannotation)==1)
		  {  
	        goodtiff++;
		  }  
		}   



	    if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
		{  
          sprintf(tester,"TDF_%s\\AUXFILES\\TDF_%s_WBM.tif",thisid,thisid);
		}  
	    else
		{  
          sprintf(tester,"TDF_%s/AUXFILES/TDF_%s_WBM.tif",thisid,thisid);
		}  

	    thisindex = FindFile(num_found,shapesfound,tester,thislen);

		if(thisindex>=0)
		{  
          thislen3 = strlen(shapesfound[thisindex]);
  	      shapesfound[thisindex][thislen3]    = '\0';

	      sprintf(tempannotation,"Water Body Mask_%d",thispackage);

		  TDF_DONE = version;  

	      if(AddGeoTiffFile(infile,shapesfound[thisindex],1,tempannotation)==1)
		  {  
	        goodtiff++;
		  }  
		}   

		




		if(TDF_DONE==version)
		{
		  printf("Found highest-version TDF was %d\n",version);
		}

      }  













     






      for(i=0;i<num_found;i++)
	  {  

        sprintf(midname,"%s",&shapesfound[i][thislen]);


		  

	      if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
		  {   
            sprintf(tester,"TDR_%s\\DEM\\TDR_%s_DEM.tif",thisrawid,thisrawid);
		  }   
	      else
		  {   
            sprintf(tester,"TDR_%s/DEM/TDR_%s_DEM.tif",thisrawid,thisrawid);
		  }   

	      if(StringCaseInsensitiveMatch(tester,midname))
		  {   
            thislen3 = strlen(shapesfound[i]);
  	        shapesfound[i][thislen3]    = '\0';


	        if(AddGeoTiffFile(infile,shapesfound[i],1,"TREx DEM Raw")==1) 
			{   
	          goodtiff++;
			}   
		  }   


	      if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
		  {   
            sprintf(tester,"TDR_%s\\AUXFILES\\TDR_%s_RLM.tif",thisrawid,thisrawid);
		  }   
	      else
		  {   
            sprintf(tester,"TDR_%s/AUXFILES/TDR_%s_RLM.tif",thisrawid,thisrawid);
		  }   
	      if(StringCaseInsensitiveMatch(tester,midname))
		  {   
            thislen3 = strlen(shapesfound[i]);
  	        shapesfound[i][thislen3]    = '\0';

	        if(AddGeoTiffFile(infile,shapesfound[i],1,"Reliability Mask")==1)
			{   
	         goodtiff++;
			}   
		  }   








	  












      }
    } 
  } 



  if(goodtiff==0) 
  {
    sprintf(message,"Error: Did not find the necessary TDF in %s",shapeimportoutputdir);
	BadTREX(w,message);
	return -1;
  }


  return 1; 
}



void AddTextToRC(Widget rc, char *thetext)
{
  Widget form,label1;

  form = XtVaCreateWidget ("formTR.MOD", xmFormWidgetClass, rc,
			       XmNfractionBase,  100,  
			       NULL);      
      
  label1 = XtVaCreateManagedWidget ("lab1",
					xmLabelWidgetClass, form,
					XmNlabelString, STRING(thetext),
					XmNtopAttachment,          XmATTACH_FORM,
					XmNbottomAttachment,       XmATTACH_FORM,
					XmNleftAttachment,         XmATTACH_POSITION,
					XmNleftPosition,           0,
					XmNrightAttachment,        XmATTACH_POSITION,
					XmNrightPosition,          100,
					LABELWTRANSLATE,
					NULL);
  XtManageChild(form);

}


Pixmap Bar_pix;

void redraw_bar(Widget graph, XtPointer client_data, XtPointer call_data)
{
  int type=(int)client_data;
  XmDrawingAreaCallbackStruct *cbs = 
    (XmDrawingAreaCallbackStruct *) call_data;

  if(type==1)
  {
    XCopyArea (cbs->event->xexpose.display,Bar_pix, cbs->window, mygc,
		 0, 0, 400,200, 0, 0);
  }
  else if(type==2)
  {
    XCopyArea (cbs->event->xexpose.display,Bar_pix, cbs->window, mygc,
		 0, 0, 500,125, 0, 0);
  }
  else
  {
	printf("Error: bad type %d to rbbp\n",type);
  }
}



void AskTrex(Widget parent,Widget w)
{
  Widget rc,form,button,Bar_draw;
  static Widget trexchoosehead;
  Arg resources[20];
  char message[1000],header[50];
  int n,numbuttons,startposn,endposn,spacer;
  Dimension Pwidth,Pheight;
  extern int overriding_modal;

  printf("Ask them if they want %s %s %s %s\n",trexid1,trexid2,trexid3,trexid4);

  


  if(dead_trexchoose==1)
  { 
    n=0;
    XtSetArg(resources[n],  XmNdeleteResponse,                          XmDESTROY);  n++;
    XtSetArg(resources[n],  XmNmaxWidth,                                      800);  n++;
	XtSetArg(resources[n],  XmNdialogStyle,    XmDIALOG_FULL_APPLICATION_MODAL);  n++;

    trexchoosehead = XtCreatePopupShell("Select TREx GeoCell",topLevelShellWidgetClass,w,resources,n);
      
    

    rc = XtVaCreateManagedWidget(
	 "XformWidget", xmPanedWindowWidgetClass, trexchoosehead,
	 XmNrubberPositioning, False,
	 XmNresizable,         True,
	 XmNseparatorOn,       False,
	 XmNsashHeight,        1,
	 NULL);
          
	numbuttons=0;

	if(strlen(trexid1)>4){numbuttons = numbuttons + 1;}
	if(strlen(trexid2)>4){numbuttons = numbuttons + 1;}
	if(strlen(trexid3)>4){numbuttons = numbuttons + 1;}
	if(strlen(trexid4)>4){numbuttons = numbuttons + 1;}



	AddTextToRC(rc,"Click the button below corresponding to the");
	AddTextToRC(rc,"GeoCell to use to create the GAIT project");

    XtVaCreateManagedWidget ("sep1",
				     xmSeparatorWidgetClass, rc,
				     NULL);

	sprintf(message,"GeoTile %s contains %d GeoCells:",
		GetLastTrexPart(shapeimportoutputdir),numbuttons);
	AddTextToRC(rc,message);







  if(numbuttons==2)
  {
    form = XtVaCreateWidget ("form", xmFormWidgetClass, rc,
			   XmNfractionBase,  100,  
			   NULL);
  
    Bar_draw = XtVaCreateManagedWidget ("Bar It",
				      xmDrawingAreaWidgetClass, form,
				      XmNunitType,     XmPIXELS,
				      XmNwidth,        400, 
				      XmNheight,       200, 
				      XmNresizePolicy, XmNONE,
				      NULL);

    XtAddCallback (Bar_draw, XmNexposeCallback, redraw_bar, (XtPointer)1);  
   
    XtManageChild(Bar_draw);  
    XtManageChild(form);
  }
  else if(numbuttons==4)
  {
    form = XtVaCreateWidget ("form", xmFormWidgetClass, rc,
			   XmNfractionBase,  100,  
			   NULL);
  
    Bar_draw = XtVaCreateManagedWidget ("Bar It",
				      xmDrawingAreaWidgetClass, form,
				      XmNunitType,     XmPIXELS,
				      XmNwidth,        500, 
				      XmNheight,       125, 
				      XmNresizePolicy, XmNONE,
				      NULL);

    XtAddCallback (Bar_draw, XmNexposeCallback, redraw_bar, (XtPointer)2);  
   
    XtManageChild(Bar_draw);  
    XtManageChild(form);
  }






	sprintf(message,"Select GeoCell:");
	AddTextToRC(rc,message);




    form = XtVaCreateWidget ("form170", xmFormWidgetClass, rc,
			       XmNpaneMinimum,   25,
			       XmNpaneMaximum,   25,
			       XmNseparatorOn,   False,
			       XmNfractionBase,  100,  
			       NULL);      

	startposn = 1;

    if(strlen(trexid1)>4)
	{
	  endposn = startposn + 100/numbuttons;
	  if(endposn>=100)
	  {
		endposn = 99;
	  }


      button  = XtVaCreateManagedWidget("SCR4",xmPushButtonWidgetClass,form,
					XmNlabelString,       STRING(trexid1),
					XmNtopAttachment,     XmATTACH_FORM,
					XmNbottomAttachment,  XmATTACH_FORM,		    
					XmNrightAttachment,   XmATTACH_POSITION,
					XmNrightPosition,     endposn,
					XmNleftAttachment,    XmATTACH_POSITION,
					XmNleftPosition,      startposn,
					XmNtraversalOn,       False,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					NULL
					); 
	  startposn = startposn + 100/numbuttons;
      
      XtAddCallback(button, XmNactivateCallback, (XtCallbackProc)chooseTrexCellCallback0, parent);
      XtManageChild(button); 
	}

    if(strlen(trexid2)>4)
	{
	  endposn = startposn + 100/numbuttons;
	  if(endposn>=100)
	  {
		endposn = 99;
	  }

      button  = XtVaCreateManagedWidget("SCR4",xmPushButtonWidgetClass,form,
					XmNlabelString,       STRING(trexid2),
					XmNtopAttachment,     XmATTACH_FORM,
					XmNbottomAttachment,  XmATTACH_FORM,		    
					XmNrightAttachment,   XmATTACH_POSITION,
					XmNrightPosition,     endposn,
					XmNleftAttachment,    XmATTACH_POSITION,
					XmNleftPosition,      startposn,
					XmNtraversalOn,       False,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					NULL
					); 
	  startposn = startposn + 100/numbuttons;
      
      XtAddCallback(button, XmNactivateCallback, (XtCallbackProc)chooseTrexCellCallback1, parent);
      XtManageChild(button); 
	}

    if(strlen(trexid3)>4)
	{
	  endposn = startposn + 100/numbuttons;
	  if(endposn>=100)
	  {
		endposn = 99;
	  }

      button  = XtVaCreateManagedWidget("SCR4",xmPushButtonWidgetClass,form,
					XmNlabelString,       STRING(trexid3),
					XmNtopAttachment,     XmATTACH_FORM,
					XmNbottomAttachment,  XmATTACH_FORM,		    
					XmNrightAttachment,   XmATTACH_POSITION,
					XmNrightPosition,     endposn,
					XmNleftAttachment,    XmATTACH_POSITION,
					XmNleftPosition,      startposn,
					XmNtraversalOn,       False,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					NULL
					); 
	  startposn = startposn + 100/numbuttons;
      
      XtAddCallback(button, XmNactivateCallback, (XtCallbackProc)chooseTrexCellCallback2, parent);
      XtManageChild(button); 
	}

    if(strlen(trexid4)>4)
	{
	  endposn = startposn + 100/numbuttons;
	  if(endposn>=100)
	  {
		endposn = 99;
	  }

      button  = XtVaCreateManagedWidget("SCR4",xmPushButtonWidgetClass,form,
					XmNlabelString,       STRING(trexid4),
					XmNtopAttachment,     XmATTACH_FORM,
					XmNbottomAttachment,  XmATTACH_FORM,		    
					XmNrightAttachment,   XmATTACH_POSITION,
					XmNrightPosition,     endposn,
					XmNleftAttachment,    XmATTACH_POSITION,
					XmNleftPosition,      startposn,
					XmNtraversalOn,       False,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					NULL
					); 
	  startposn = startposn + 100/numbuttons;
      
      XtAddCallback(button, XmNactivateCallback, (XtCallbackProc)chooseTrexCellCallback3, parent);
      XtManageChild(button); 
	}


    XtManageChild(form);


    XtManageChild(rc);


	overriding_modal = 1;
    MyPopup(trexchoosehead); 
    overriding_modal = 0;

      
    XtVaGetValues(trexchoosehead, XmNwidth,     &Pwidth, XmNheight, &Pheight, NULL);	  
    XtVaSetValues(trexchoosehead, XmNminHeight, Pheight, NULL);
    XtVaSetValues(trexchoosehead, XmNmaxHeight, Pheight, NULL);

    XtAddEventHandler(trexchoosehead,StructureNotifyMask,False, myResizeHandler, (XtPointer)((int)Pheight));
  

    XtAddCallback(trexchoosehead,XmNdestroyCallback,ShellDeath,(XtPointer)4102);
    dead_trexchoose=0;






set_color(Bar_draw,"White",(XtPointer)NULL);
  
Bar_pix = XCreatePixmap (XtDisplay (Bar_draw),
					RootWindowOfScreen (XtScreen (Bar_draw)), 500,200,
					DefaultDepthOfScreen (XtScreen (Bar_draw)));
XFillRectangle (XtDisplay (Bar_draw), Bar_pix,       mygc, 0, 0, 500,200);
      
set_color(Bar_draw,"Black",(XtPointer)NULL);

sprintf(header,"GeoCell");


if(numbuttons==2)
{
  spacer = 20;

  XDrawLine(mydisplay,Bar_pix,mygc,0,0,399,0);
  XDrawLine(mydisplay,Bar_pix,mygc,0,0,0,199);
  XDrawLine(mydisplay,Bar_pix,mygc,399,0,399,199);
  XDrawLine(mydisplay,Bar_pix,mygc,0,199,399,199);

  XDrawString(mydisplay,Bar_pix,mygc,50+spacer,90,header,(int)strlen(header));
  XDrawString(mydisplay,Bar_pix,mygc,50+spacer,110,trexid1,(int)strlen(trexid1));

  XDrawString(mydisplay,Bar_pix,mygc,250+spacer,90,header,(int)strlen(header));
  XDrawString(mydisplay,Bar_pix,mygc,250+spacer,110,trexid2,(int)strlen(trexid1));

  XDrawLine(mydisplay,Bar_pix,mygc,200,0,200,200);
}
else
{
  spacer = 10;

  XDrawLine(mydisplay,Bar_pix,mygc,0,0,499,0);
  XDrawLine(mydisplay,Bar_pix,mygc,0,0,0,124);
  XDrawLine(mydisplay,Bar_pix,mygc,499,0,499,124);
  XDrawLine(mydisplay,Bar_pix,mygc,0,124,500,124);

  XDrawString(mydisplay,Bar_pix,mygc,25+spacer,60,header,(int)strlen(header));
  XDrawString(mydisplay,Bar_pix,mygc,25+spacer,80,trexid1,(int)strlen(trexid1));

  XDrawString(mydisplay,Bar_pix,mygc,150+spacer,60,header,(int)strlen(header));
  XDrawString(mydisplay,Bar_pix,mygc,150+spacer,80,trexid2,(int)strlen(trexid2));

  XDrawString(mydisplay,Bar_pix,mygc,275+spacer,60,header,(int)strlen(header));
  XDrawString(mydisplay,Bar_pix,mygc,275+spacer,80,trexid3,(int)strlen(trexid3));

  XDrawString(mydisplay,Bar_pix,mygc,400+spacer,60,header,(int)strlen(header));
  XDrawString(mydisplay,Bar_pix,mygc,400+spacer,80,trexid4,(int)strlen(trexid4));

  XDrawLine(mydisplay,Bar_pix,mygc,125,0,125,124);
  XDrawLine(mydisplay,Bar_pix,mygc,250,0,250,124);
  XDrawLine(mydisplay,Bar_pix,mygc,375,0,375,124);
}








SetColorRight();




  }
  else
  {
    ResetWidget(trexchoosehead);
  }


}


void ngainfileCallback(Widget w,XtPointer data,XtPointer callData)
{
  Widget parent_wid;
  FILE *infile,*testfile=NULL;
  char message[5000],message2[1000],message3[1000],message4[1000],message5[1000],
	  message6[1000],message7[1000],message8[1000],message9[1000],aline[1000], 
	  shortname[1000],junk[1000],chk_string[1000];
  int num_found=0,old_num_found=0,maxlen=1000,i,thislen,num_failures=0,j,good,
    goodgeodatabase=0,goodgeomediaacc=0,type=0,code_found,dbftype,len2,
	goodshape=0,gooddted=0,goodtiff=0,goodnitf=0,badshape=0,nullshapes=0,diacritics_found=0,
	num_tables,len,badtables=0,goodtables=0,changeattr = 0,save_attr_type,bad,numtables,
	filetype,testval,failnum=0,badshapenum=0,numtrextiff=0,numtrexcell=0;
  int override=(int)data;
  char **shapesfound;
  char **oldstuff;
  extern int CREATING_TREX,TREX_TYPE;
  extern int AddDtedFile(FILE *infile,char *dtedfile,char *lodoverride);


#if((NGA_TYPE==1)&&(USE_DOS==1))
  int Ijunk,ijunk,ijunk2;
  extern int DoOSStuff(FILE *inspecfile,int BuildInputSpecFile,
		       char *OSname,char *DDname,char *inspecfilename,int type,
		       int addtolong,int addtoshort,
		       int *longitemsfound,int *shortitemsfound,
		       int *badtables, int *goodtables);
  extern void CoUninit();
#endif
  


  if(TEMP_ATTRIBUTION_TYPE==0)
  {
      not_while_running(XtParent(XtParent(XtParent(w))),"You must specify an attribution schema before you can build an\n\
Input Specification file.",1526,"No attribution schema specified",1);   
    return;
  }


  trexid1[0] = '\0';
  trexid2[0] = '\0';
  trexid3[0] = '\0';
  trexid4[0] = '\0';

  trexlongid1[0] = '\0';
  trexlongid2[0] = '\0';
  trexlongid3[0] = '\0';
  trexlongid4[0] = '\0';





  len = strlen(shapeimportoutputdir);
  
  if(batch_mode==0)
    {
	  if(DO_QAST==1)
	  {
        parent_wid=XtParent(XtParent(XtParent(w)));
	  }
	  else
	  {
        set_cursor(mydisplay,mywindow,WATCH);
        set_cursor(XtDisplay(GetImportShell()),XtWindow(GetImportShell()),WATCH);
        parent_wid=XtParent(XtParent(XtParent(w)));
	  }
    }


  
  if(import_source==0)
    {	  
      not_while_running(parent_wid,"You must specify a Project name before you can create an\n\
Input Specification file.",1210,"No project name",1);   
      
      set_cursor(mydisplay,mywindow,GOOD);
      set_cursor(XtDisplay(GetImportShell()),XtWindow(GetImportShell()),ARROW);
      return;
    }
  



  if(batch_mode==0)
    {      
      len2 = strlen(GAITProjectName);
      
      
      
      for(j=0;j<len2;j++)
	{
	  if(
	     ((GAITProjectName[j]>=65)  && (GAITProjectName[j]<=90))  ||
	     ((GAITProjectName[j]>=48)  && (GAITProjectName[j]<=57))  ||
	     ((GAITProjectName[j]>=97)  && (GAITProjectName[j]<=122)) ||
	     (GAITProjectName[j]=='-') || (GAITProjectName[j]=='_')
	     )
	    {
	      good = 1;
	    }
	  else
	    {
	      sprintf(message,"The Project Name you have entered is invalid because\n\
it contains the character \"%c\"\n\n\
Please enter a project name consisting of letters, numbers, \"-\", and \"_\"\n",
		      GAITProjectName[j]);
	      
	      
	      not_while_running(parent_wid,message,1418,"No project name",1);   
	      
	      set_cursor(mydisplay,mywindow,GOOD);
	      set_cursor(XtDisplay(GetImportShell()),XtWindow(GetImportShell()),ARROW);
	      return;
	    }
	}
      
      
  
      if((shape_source==0)||(len==0))
	{   
	  if(USE_DOS==1)
	    {
	      not_while_running(parent_wid,"You must specify an input source directory before you can create an\n\
Input Specification file.",1211,"No project name",1);   
	    }
	  else
	    {
	      not_while_running(parent_wid,"You must specify an input source folder before you can create an\n\
Input Specification file.",1212,"No project name",1);   
	    }
	  set_cursor(mydisplay,mywindow,GOOD);
	  set_cursor(XtDisplay(GetImportShell()),XtWindow(GetImportShell()),ARROW);
	  return;
	}
    }

  

  
  if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
    {
      if(shapeimportoutputdir[len-1]!='\\')
	{      
	  strcat(shapeimportoutputdir,"\\");
	}
    }
  else
    {
      if(shapeimportoutputdir[len-1]!='/')
	{      
	  strcat(shapeimportoutputdir,"/");
	}
    }
  
  
  
  if(TestInputSpecFile()==0)
    {
      sprintf(message,"Unable to create Input Specification File\n %s\n\
Either:\n\
   GAIT was unable to create the directory containing this file\n\
     or\n\
   You do not have permissions to modify this file\n\
     or\n\
   The file cannot be modified for some other reason\n\n\
This problem must be addressed before GAIT can create an\n\
Input Specification File.\n",importdirectory);
      
      if(batch_mode==1)
	{
	  printf("%s\n",message);
	  BATCH_FAIL = 1;
	  return;
	}
      
      
      not_while_running(parent_wid,message,1213,"Unable to create Input Specification File",1);  
      
      set_cursor(mydisplay,mywindow,GOOD);
      set_cursor(XtDisplay(GetImportShell()),XtWindow(GetImportShell()),ARROW);
      return;      
    }



  if(CREATING_TREX==1)
  {
	if(batch_mode==1)
	{
      if(TREX_TYPE==0)
	  {
        printf("\nError: GAIT_TREX_ANALYSIS_TYPE not set.\n");
		printf("  For TREx projects, this must be set to \"QC\", \"cQA\", or \"sQA\"\n\n");
		exit(1);
	  }
	}



	if(override==1)
	{
	  
	}
	else
	{

      user_trex_cell = 0; 

	  


      if(GetTREXid(w,shapeimportoutputdir)==0)
	  {  
	    if(batch_mode==1)
		{  
          ExitWrapper(-1);
		}  
	    printf("failed to GetTREXid\n");
	  }  
	  else
	  { 
	    printf("got TREXids: %s %s %s %s\n",trexid1,trexid2,trexid3,trexid4);
	  } 

	  numtrexcell = 0;
	  if(strlen(trexid1)>4){numtrexcell = numtrexcell + 1;}
	  if(strlen(trexid2)>4){numtrexcell = numtrexcell + 1;}
	  if(strlen(trexid3)>4){numtrexcell = numtrexcell + 1;}
	  if(strlen(trexid4)>4){numtrexcell = numtrexcell + 1;}

	  



	  if((batch_mode==1)&&(numtrexcell>1))
	  {
		

         if(user_trex_cell<0)
		 {
			printf("\nError: found multi-GeoCell TREx package but TREX_SUB_GEOCELL is not set\n");
			printf("  TREX_SUB_GEOCELL must be set to 1,2,3, or 4 for multi-GeoCell TREx packages\n");
			printf("  to indicate which GeoCell to make the GAIT project out of:\n");
			printf("  1: westernmost GeoCell, 2: next cell to the east, etc\n");
			exit(1);
		 }
		 if((user_trex_cell>1)&&(numtrexcell<3))
		 {
		    printf("\nError: found TREX_SUB_GEOCELL = %d\n",user_trex_cell+1);
			printf("  But, this package only contains %d GeoCells.\n",numtrexcell);
			printf("  For this package, TREX_SUB_GEOCELL must be 1 or 2\n");
			exit(1);
		 }
	  }
	  else
	  {
	    if((override==0)&&(numtrexcell>1))
		{  
	      AskTrex(w,XtParent(XtParent(XtParent(w))));
          set_cursor(mydisplay,mywindow,GOOD);
          set_cursor(XtDisplay(GetImportShell()),XtWindow(GetImportShell()),ARROW);
	      return;
		}  
	  }
	} 
  }



  if((CREATING_TREX==1)&&(batch_mode==1))
  {
	 
	 

	 if(user_trex_cell<0) 
	 {
	   user_trex_cell=0;
	 }

     if(GetTREXid(w,shapeimportoutputdir)==0)
	 {  
	   if(batch_mode==1)
	   {  
         ExitWrapper(-1);
	   }  
	   printf("failed to GetTREXid\n");
	 }  
	 else
	 { 
	   printf("got TREXids: %s %s %s %s\n",trexid1,trexid2,trexid3,trexid4);
	 } 

	 numtrexcell = 0;
	 if(strlen(trexid1)>4){numtrexcell = numtrexcell + 1;}
	 if(strlen(trexid2)>4){numtrexcell = numtrexcell + 1;}
	 if(strlen(trexid3)>4){numtrexcell = numtrexcell + 1;}
	 if(strlen(trexid4)>4){numtrexcell = numtrexcell + 1;}

	 


	 if((batch_mode==1)&&(user_trex_cell>=numtrexcell))
	 {
        
        
        

		printf("\nError: found TREX_SUB_GEOCELL = %d\n",user_trex_cell+1);
		if(numtrexcell==1)
		{
		  printf("  But, this package only contains %d GeoCell.\n",numtrexcell);
		  printf("  For this package, TREX_SUB_GEOCELL must be 1\n");
		}
		else if(numtrexcell==2)
		{
		  printf("  But, this package only contains %d GeoCells.\n",numtrexcell);
		  printf("  For this package, TREX_SUB_GEOCELL must be 1 or 2\n");
		}
		else if(numtrexcell==4)
		{
		  printf("  But, this package only contains %d GeoCells.\n",numtrexcell);
		  printf("  For this package, TREX_SUB_GEOCELL must be 1, 2, 3, or 4\n");
		}
		else
		{
		  printf("  Internal error: Found num TREx cell %d\n",numtrexcell);
		}

		exit(1);
	 }


	 if((batch_mode==1)&&(numtrexcell>1))
	 {
       if(user_trex_cell<0)
	   {
		  printf("\nError: found multi-GeoCell TREx package but TREX_SUB_GEOCELL is not set\n");
		  printf("  TREX_SUB_GEOCELL must be set to 1,2,3, or 4 for multi-GeoCell TREx packages\n");
		  printf("  to indicate which GeoCell to make the GAIT project out of:\n");
		  printf("  1: westernmost GeoCell, 2: next cell to the east, etc\n");
		  exit(1);
	   }
	 } 
  }

  
  
  
  
  bad = 0;
  infile = fopen(importdirectory,"r");
  
  if(infile!=NULL)
    {
      maxlen = 1000;
      fgets(aline,1000,infile);
      while(!feof(infile))
	{
	  sscanf(aline,"%s",chk_string);
	  if(
	     (strcmp(chk_string,"GEOTIFF" ))          && 
	     (strcmp(chk_string,"NITF" ))             && 
	     (strcmp(chk_string,"DTED" ))             && 
	     (strcmp(chk_string,"SHAPE"))             &&
	     (strcmp(chk_string,"ZIPSHAPE"))          &&
	     
	     (strcmp(chk_string,"GEODATABASE"))       &&
	     (strcmp(chk_string,"GEOMEDIAACC"))       &&
	     (strcmp(chk_string,"GEODATABASE_TABLE")) &&
	     (strcmp(chk_string,"GEOMEDIAACC_TABLE")) 
	     )
	    {
	      sprintf(message,"The file\n %s\n\
already exists, so GAIT tried to add specifications to the\n\
specifications already in this file.  However, the existing file was\n\
not a valid specifiation file.  GAIT has therefore aborted attempts\n\
to create a new file.  The following line was invalid: \n%s\n",importdirectory,aline);
	      not_while_running(parent_wid,message,1214,"Bad existing file",3);  
	      
	      if(batch_mode==1)
		{
		  printf("%s\n",message);
		  BATCH_FAIL = 1;
		  return;
		}
	      
	      set_cursor(mydisplay,mywindow,GOOD);
	      set_cursor(XtDisplay(GetImportShell()),XtWindow(GetImportShell()),ARROW);
	      return;
	    }
	  

	  
	  if(!strcmp(chk_string,"OBJECTSPACE"))
	    {
	      
	      
	      sscanf(aline,"%s%s%d",chk_string,junk,&numtables);
	      
	      
	      bad = 0;
	      old_num_found++;
	      fgets(aline,1000,infile);
	      if(feof(infile))
		{
		  bad = 1;
		}
	      if(bad==0)
		{
		  sscanf(aline,"%s",chk_string);
		  if(strcmp(chk_string,"OBJECTSPACE_OSFILE"))
		    {
		      bad = 1;
		    }
		  else
		    {
		      fgets(aline,1000,infile);
		      old_num_found++;
		      if(feof(infile))
			{
			  bad = 1;
			}
		      if(bad==0)
			{
			  sscanf(aline,"%s",chk_string);
			  if(strcmp(chk_string,"OBJECTSPACE_CONNECTSTRING"))
			    {
			      bad = 1;
			    }
			  else
			    {
			      for(i=0;i<numtables;i++)
				{
				  if(bad==1)
				    {
				      break;
				    }
				  fgets(aline,1000,infile);
				  old_num_found++;
				  sscanf(aline,"%s",chk_string);
				  if(feof(infile))
				    {
				      bad = 1;
				    }
				  else if(strcmp(chk_string,"OBJECTSPACETABLE"))
				    {
				      bad = 1;
				    }
				}
			    }
			}
		    }
		}
	    }
	  
	  if(bad==1)
	    {
	      sprintf(message,"The file\n %s\n\
already exists, so GAIT tried to add specifications to the\n\
specifications already in this file.  However, the existing file was\n\
not a valid specifiation file.  GAIT has therefore aborted attempts\n\
to create a new file.\n",importdirectory);
	      not_while_running(parent_wid,message,1214,"Bad existing file (2)",3);  
	      
	      if(batch_mode==1)
		{
		  printf("%s\n",message);
		  BATCH_FAIL = 1;
		  return;
		}
	      
	      set_cursor(mydisplay,mywindow,GOOD);
	      set_cursor(XtDisplay(GetImportShell()),XtWindow(GetImportShell()),ARROW);
	      return;
	    }
	  
	  
	  if((int)strlen(aline)>maxlen)
	    {
	      maxlen = strlen(aline);
	    }
	  fgets(aline,1000,infile);
	  old_num_found++;
	}
      rewind(infile);
      
      
      if(old_num_found>0)
	  {
       oldstuff = (char **)malloc(sizeof(char *)*old_num_found);
       if(oldstuff==NULL)
	   {
	     printf("oldstuff %d: out of memory!\n",old_num_found);
	     ExitWrapper(-1);
	   }
	  }
      
      
      for(i=0;i<old_num_found;i++)
	{
	  oldstuff[i] = (char *)malloc(sizeof(char)*maxlen + 10);
	  if(oldstuff[i]==NULL)
	    {
	      printf("oldstuff %d: out of memory!\n",old_num_found);
	      ExitWrapper(-1);
	    }
	}
      
      i=0;
      fgets(aline,1000,infile);
      while(!feof(infile))
	{
	  sprintf(oldstuff[i],"%s",aline);
	  fgets(aline,1000,infile);
	  i++;
	}
      fclose(infile);
    }
  
  
  
  




  maxlen = 0;

  printf("Here we build text file %s from directory %s\n",importdirectory,shapeimportoutputdir);


  if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
    {

      sprintf(message,"dir /s /b \"%s*.shp\" \"%s*.dt?\" \"%s*.mdb\" \"%s*.gdb\" \"%s*.NTF\" \"%s*.NSF\" \"%s*.hr?\" \"%s*.tif\" \"%s*.tiff\"  \"%s*.zip\" > \"%s\"",
	      shapeimportoutputdir,
	      shapeimportoutputdir,
	      shapeimportoutputdir,
	      shapeimportoutputdir,
	      shapeimportoutputdir,
	      shapeimportoutputdir,
	      shapeimportoutputdir,
	      shapeimportoutputdir,
	      shapeimportoutputdir,
	      shapeimportoutputdir,
	      importdirectory);

      printf("trying command %s\n",message);

      system(message);
    }
  else
    {
      sprintf(message, "find \"%s\" -name \"*.[sS][hH][pP]\" -print  > \"%s1\"",
	      shapeimportoutputdir,importdirectory);
      
      sprintf(message2, "find \"%s\" -name \"*.[dD][tT][0123]\" -print  > \"%s2\"",
	      shapeimportoutputdir,importdirectory);

      sprintf(message3, "find \"%s\" -name \"*.[tT][iI][fF]\" -print  > \"%s3\"",
	      shapeimportoutputdir,importdirectory);

      sprintf(message4, "find \"%s\" -name \"*.[tT][iI][fF][fF]\" -print  > \"%s4\"",
	      shapeimportoutputdir,importdirectory);

      sprintf(message5, "find \"%s\" -name \"*.[nN][tT][fF]\" -print  > \"%s5\"",
	      shapeimportoutputdir,importdirectory);

      sprintf(message6, "find \"%s\" -name \"*.[nN][sS][fF]\" -print  > \"%s6\"",
	      shapeimportoutputdir,importdirectory);

      sprintf(message7, "find \"%s\" -name \"*.[hH][rR][12345]\" -print  > \"%s7\"",
	      shapeimportoutputdir,importdirectory);

      sprintf(message8, "find \"%s\" -name \"*.[zZ][iI][pP]\" -print  > \"%s8\"",
	      shapeimportoutputdir,importdirectory);




      sprintf(message9,"cat \"%s1\" \"%s2\" \"%s3\" \"%s4\" \"%s5\" \"%s6\" \"%s7\" \"%s8\" > \"%s\"",
	      importdirectory,
	      importdirectory,
	      importdirectory,
	      importdirectory,
	      importdirectory,
	      importdirectory,
	      importdirectory,
	      importdirectory,
	      importdirectory);
      
      printf("trying command %s\n",message);
      system(message);
      printf("trying command %s\n",message2);
      system(message2);
      printf("trying command %s\n",message3);
      system(message3);
      printf("trying command %s\n",message4);
      system(message4);
      printf("trying command %s\n",message5);
      system(message5);
      printf("trying command %s\n",message6);
      system(message6);
      printf("trying command %s\n",message7);
      system(message7);
      printf("trying command %s\n",message8);
      system(message8);
      printf("trying command %s\n",message9);
      system(message9);
    }

  infile = fopen(importdirectory,"r");
  
  
  
  maxlen = 0;
  fgets(aline,1000,infile);
  while(!feof(infile))
    {
      if((int)strlen(aline)>maxlen)
	{
	  maxlen = strlen(aline);
	}
      fgets(aline,1000,infile);
      num_found++;
    }
  rewind(infile);
  
  
  if(num_found==0)
    {
      

      fclose(infile);

      infile = fopen(importdirectory,"w");
      if(infile==NULL)
	{
	  sprintf(message,"Cannot open %s for write!\n",importdirectory);
	  
	  if(batch_mode==1)
	    {
	      printf("%s\n",message);
	      BATCH_FAIL = 1;
	      return;
	    }
	  
	  not_while_running(parent_wid,message,1215,"Bad filename",3);  
	  set_cursor(mydisplay,mywindow,GOOD);
	  set_cursor(XtDisplay(GetImportShell()),XtWindow(GetImportShell()),ARROW);
	  return;
	}

      if(old_num_found>0)
	  {
       for(i=0;i<old_num_found;i++)
	   {
	    fprintf(infile,"%s",oldstuff[i]);
	   }
      
      
       for(i=0;i<old_num_found;i++)
	   {	  
	     free(oldstuff[i]);
	   }
       free(oldstuff);
      }
      
      sprintf(message,"Did not find any importable data in\n %s\n",shapeimportoutputdir);
      
	  fclose(infile);

      if(batch_mode==1)
	{
	  printf("%s\n",message);
	  BATCH_FAIL = 1;
	  return;
	}
      
      not_while_running(parent_wid,message,1216,"No importable data found",3);   
      set_cursor(mydisplay,mywindow,GOOD);
      set_cursor(XtDisplay(GetImportShell()),XtWindow(GetImportShell()),ARROW);
      return;
    }
  
  
  shapesfound = (char **)malloc(sizeof(char *)*num_found);
  if(shapesfound==NULL)
    {
      printf("shapesfound %d: out of memory!\n",num_found);
      ExitWrapper(-1);
    }
  
  
  
  
  for(i=0;i<num_found;i++)
    {
      shapesfound[i] = (char *)malloc(sizeof(char)*maxlen + 10);
      if(shapesfound[i]==NULL)
	{
	  printf("shapesfound %d: out of memory!\n",num_found);
	  ExitWrapper(-1);
	}
    }
  
  i=0;
  fgets(aline,1000,infile);
  while(!feof(infile))
    {
      sprintf(shapesfound[i],"%s",aline);


	  if(DO_QAST==1)
	  {
        

		if(QASTZipfile(shapesfound[i])==0)
		{

          

		  

          num_found = num_found - 1;
          fgets(aline,1000,infile);
		  continue;
		}
	  }



      thislen = strlen(shapesfound[i]);
      for(j=0;j<thislen;j++)
	{
	  if(
	     (shapesfound[i][j]==10)||
	     (shapesfound[i][j]==13)
	     )
	    {
	      shapesfound[i][j] = '\0';
	      break;
	    }	   
	}
      shapesfound[i][j] = '\0';
      
      
      fgets(aline,1000,infile);
      i++;
    }
  fclose(infile);

  
  
  infile = fopen(importdirectory,"w");
  if(infile==NULL)
    {
      sprintf(message,"Cannot open\n %s\n for write!\n",importdirectory);
      
      if(batch_mode==1)
	{
	  printf("%s\n",message);
	  BATCH_FAIL = 1;
	  return;
	}
      
      not_while_running(parent_wid,message,1217,"Bad filename",3);  
      set_cursor(mydisplay,mywindow,GOOD);
      set_cursor(XtDisplay(GetImportShell()),XtWindow(GetImportShell()),ARROW);
      return;
    }
  
  
  
  
  
  for(i=0;i<old_num_found;i++)
    {
      fprintf(infile,"%s",oldstuff[i]);
    }
  
  
  
  
  
  
  
  if(ATTRIBUTION_TYPE!=TEMP_ATTRIBUTION_TYPE)
    {
      changeattr = 1;
      save_attr_type = ATTRIBUTION_TYPE;
      ATTRIBUTION_TYPE = TEMP_ATTRIBUTION_TYPE;
      InitializeAttribution();
    }


  numtrextiff = CheckTREX(w,num_found,shapesfound,infile);


  if(numtrextiff==-1)
  {
    fclose(infile);
  
  
    if(changeattr==1)
    {
      ATTRIBUTION_TYPE = save_attr_type;
      InitializeAttribution();
    }

#if(USE_DOS==1)
  CoUninit();
#endif


    if(num_found>0)
	{ 
      for(i=0;i<num_found;i++)
	  { 
        free(shapesfound[i]);
	  } 
      free(shapesfound);
	} 

    if(old_num_found>0)
    {
      for(i=0;i<old_num_found;i++)
	  {
	    free(oldstuff[i]);
	  }
      free(oldstuff);
    }

    set_cursor(mydisplay,mywindow,GOOD);
    set_cursor(XtDisplay(GetImportShell()),XtWindow(GetImportShell()),ARROW);
    return;
  }


  for(i=0;i<num_found;i++)
    {
      
      GetShortName(shortname,shapesfound[i]);

	  if(CREATING_TREX==1)
	  {

        

		continue;
	  }

            
      thislen = strlen(shortname);
      
      if(thislen<4)
	{
	  printf("bad input (len) %s\n",shortname);
	  continue;
	}

     if(
	 (shortname[thislen-4]=='.')                                    &&
	 ( (shortname[thislen-3]=='z') || (shortname[thislen-3]=='Z') ) &&
	 ( (shortname[thislen-2]=='i') || (shortname[thislen-2]=='I') ) &&
	 ( (shortname[thislen-1]=='p') || (shortname[thislen-1]=='P') ) 
	 ) 
	 { 
       printf("got zip file %s (%s)\n",shortname,shapesfound[i]);

	   failnum = 0;
	   badshapenum = 0;

	   testval = myunzip(shapesfound[i],infile,&failnum,&badshapenum);

       if(failnum>0)
	   {
         num_failures = num_failures + failnum;
	   }
	   if(badshapenum>0)
	   {
         badshape = badshape + badshapenum;
	   }


	   if(testval>0)
	   {
         goodshape = goodshape + testval;
	   }
	 }
	 
      else if(
	 (shortname[thislen-4]=='.')                                    &&
	 ( (shortname[thislen-3]=='s') || (shortname[thislen-3]=='S') ) &&
	 ( (shortname[thislen-2]=='h') || (shortname[thislen-2]=='H') ) &&
	 ( (shortname[thislen-1]=='p') || (shortname[thislen-1]=='P') )
	 ) 
	{
	  
	  shortname[thislen-4] = '\0';
	  
	  
	  code_found = GetClassCodeAsSubstring(shortname);
	  
	  if(code_found==-100)
	    {
	      code_found = GetClassCodeFromName(shortname);
	    }
	  
	  
	  thislen = strlen(shapesfound[i]);
	  shapesfound[i][thislen-4]='\0';
	  
	  
	  
          diacritics_found = 0;
	  
	  diacritics_found = 0;
	  for(j=0;j<(int)strlen(shapesfound[i]);j++)
	    {
	      if(shapesfound[i][j]<0)
		{
		  diacritics_found = 1;
		}
	    }
	  
	  
	  
	  
	  
	  if((code_found==-100)&&(diacritics_found==0))
	    {
	      
	      dbftype = CheckFileFCODEs(shapesfound[i]);
	      
	      if (dbftype==-1)
		{
		  
		  nullshapes++;
		  
		  printf("found empty shapefile: %s\n",shapesfound[i]);
		}
	      
	      num_failures++;
	      fprintf(infile,"SHAPE ***** \"%s\"\n",shapesfound[i]);
	      badshape++;
	      
	    }
          else if (code_found==-100)
            {
	      
	      num_failures++;
	      fprintf(infile,"SHAPE ***** \"%s\"\n",shapesfound[i]);
	      badshape++;
	    }
	  else
	    {
	      dbftype = CheckFileFCODEs(shapesfound[i]);
	      
	      if (dbftype==-1)
		{
		  
		  nullshapes++;
		  printf("found empty shapefile: %s\n",shapesfound[i]);
		  
		}
	      
	      fprintf(infile,"SHAPE %s \"%s\"\n",GetECCCode(code_found+1),shapesfound[i]);
	      goodshape++;
	      
	    }
	}
      else if(
	      (shortname[thislen-4]=='.')                                    &&
	      ( (shortname[thislen-3]=='d') || (shortname[thislen-3]=='D') ) &&
	      ( (shortname[thislen-2]=='t') || (shortname[thislen-2]=='T') ) &&
	      (shortname[thislen-1]>=48)                                     &&
	      (shortname[thislen-1]<=51)
	      )
	{
	  
	  
	  
	  
	  
	  thislen = strlen(shapesfound[i]);
  	  shapesfound[i][thislen]    = '\0';
	  
	  if(AddDtedFile(infile,shapesfound[i],"qq")==1)
	    {
	      gooddted++;
	    }
	}
     else if(
	      (shortname[thislen-4]=='.')                                    &&
	      ( (shortname[thislen-3]=='t') || (shortname[thislen-3]=='T') ) &&
	      ( (shortname[thislen-2]=='i') || (shortname[thislen-2]=='I') ) &&
	      ( (shortname[thislen-1]=='f') || (shortname[thislen-1]=='F') )	      
	      )
	{
	  
	  
	  
	  
	  
	  thislen = strlen(shapesfound[i]);
  	  shapesfound[i][thislen]    = '\0';

	  if(AddGeoTiffFile(infile,shapesfound[i],1,NULL)==1)
	    {
	      goodtiff++;
	    }
	}
     else if(
		 (
	      (shortname[thislen-4]=='.')                                    &&
	      ( (shortname[thislen-3]=='n') || (shortname[thislen-3]=='N') ) &&
	      ( (shortname[thislen-2]=='t') || (shortname[thislen-2]=='T') ) &&
	      ( (shortname[thislen-1]=='f') || (shortname[thislen-1]=='F') )	      
	      )
		  ||
		 (
	      (shortname[thislen-4]=='.')                                    &&
	      ( (shortname[thislen-3]=='n') || (shortname[thislen-3]=='N') ) &&
	      ( (shortname[thislen-2]=='s') || (shortname[thislen-2]=='S') ) &&
	      ( (shortname[thislen-1]=='f') || (shortname[thislen-1]=='F') )	      
	      )
		  ||
		 (
	      (shortname[thislen-4]=='.')                                    &&
	      ( (shortname[thislen-3]=='h') || (shortname[thislen-3]=='h') ) &&
	      ( (shortname[thislen-2]=='r') || (shortname[thislen-2]=='r') ) &&
	      (shortname[thislen-1]>=49)                                     &&
	      (shortname[thislen-1]<=53)
	      )
		 )
	{
	  
	  
	  
	  
	  thislen = strlen(shapesfound[i]);
  	  shapesfound[i][thislen]    = '\0';

	  if(AddGeoTiffFile(infile,shapesfound[i],2,NULL)==1)
	    {
	      goodnitf++;
	    }
	}
	 else if(
		  
		      (
	           (shortname[thislen-4]=='.')                                    &&
	           ( (shortname[thislen-3]=='m') || (shortname[thislen-3]=='M') ) &&
	           ( (shortname[thislen-2]=='d') || (shortname[thislen-2]=='D') ) &&
	           ( (shortname[thislen-1]=='b') || (shortname[thislen-1]=='B') )
	          )

		  ||

		      (
	           (shortname[thislen-4]=='.')                                    &&
	           ( (shortname[thislen-3]=='g') || (shortname[thislen-3]=='G') ) &&
	           ( (shortname[thislen-2]=='d') || (shortname[thislen-2]=='D') ) &&
	           ( (shortname[thislen-1]=='b') || (shortname[thislen-1]=='B') )
	          )
			 )

	{
	  num_tables = 0;
	  
	  printf("found %s\n",shortname);
	  
 	  filetype = 0;

      if ( (strstr(shapesfound[i],".gdb")) || (strstr(shapesfound[i],".GDB")) )
	  {
	    filetype = 1;
	  }

	  if(filetype==0)
	  {
	    testfile = fopen(shapesfound[i],"r");
	  }
	  else
	  {
		testfile = NULL;
	  }


	  if((testfile==NULL)&&(filetype==0))
	    {
	      printf("failed to open %s for read.  ignoring\n",shapesfound[i]);
	    }
	  else
	    {
		  if(filetype==0)
		  {
	        fclose(testfile);
		  }

	      printf("adding %s to inputspecfile\n",shapesfound[i]);
	      
	      
#if((NGA_TYPE==1)&&(USE_DOS==1))


	      type = 1;
		  
		  if(filetype==1)
		  {
            num_tables = OpenGeoDatabase(0 ,shapesfound[i],1 , -1, -1,&ijunk,&ijunk2);
		  }
		  else
		  {
            num_tables = OpenGeoDatabase(1 ,shapesfound[i],1 , -1, -1,&ijunk,&ijunk2);
		  } 
		  

	      if((num_tables==0)&&(filetype==0))
		  {
		     type = 2;

		     if(DoOSStuff(infile,1,shapesfound[i],NULL,
	             NULL,type,0,0,&Ijunk,&Ijunk,&badtables,&goodtables)>0)
			 {
			   if((badtables+goodtables)>0)
			   {
                 goodgeomediaacc = goodgeomediaacc + 1;
				 type = 3;
			   }
			 }

		     if(badtables>0)
			 {
			   num_failures = num_failures + 1;
			 }
		  }
	      
#endif
	      
	      if((num_tables>0)&&(type==1))  
		{
	      goodgeodatabase = goodgeodatabase + 1;
	      fprintf(infile,"GEODATABASE NUM_TABLES %d\n",num_tables);
	      fprintf(infile,"GEODATABASE %s\n",shapesfound[i]);	  
		  
		  for(j=0;j<num_tables;j++)
		    {
		      code_found = -100;
		      code_found = GetClassCodeAsSubstring(tables_found[j]);
		      if(code_found==-100)
			  {
			    code_found = GetClassCodeFromName(tables_found[j]);
			  } 
		      
		      if(code_found==-100)
			  {
			    num_failures = num_failures + 1;
				  
			    if(type==1)
			    {
			      fprintf(infile,"GEODATABASE_TABLE ***** %s\n",
				      tables_found[j]);
			    }
				  
			    badtables = badtables + 1;
			  } 
		      else
			  { 
			    if(type==1)
			    {
			      fprintf(infile,"GEODATABASE_TABLE %s %s\n",
				      GetECCCode(code_found+1),tables_found[j]);
			    }

			    goodtables = goodtables + 1;
			  }
			  
		      free(tables_found[j]);
		  } 
		  } 
	      else if(type==2) 
		{
		  printf("  Found file %s but either:\n\
    it is not a geodatabase of a version readable by the installed version of ArcGIS\n\
    it is not a geomedia access database\n\
    it had no geometric tables.\n",
			 shapesfound[i]);
		}
	      
	    }
	}
      else
	{
	  
	  
	}
    }
  
  fclose(infile);
  
  
  if(changeattr==1)
    {
      ATTRIBUTION_TYPE = save_attr_type;
      InitializeAttribution();
    }

#if(USE_DOS==1)
  CoUninit();
#endif



  

  if(num_found>0)
  {
  for(i=0;i<num_found;i++)
    {
      free(shapesfound[i]);
    }
  free(shapesfound);
  }

  if(old_num_found>0)
    {
      for(i=0;i<old_num_found;i++)
	{
	  free(oldstuff[i]);
	}
      free(oldstuff);
    }


    


  if((goodshape+badshape +
	  goodgeodatabase    +
	  goodgeomediaacc    +
	  badtables          +
	  goodtables         +
	  goodtiff           +
	  goodnitf           +
	  numtrextiff        +
	  gooddted)==0)
  {
	  sprintf(message,"Did not find any importable data in \n%s",importdirectory);

	  if(batch_mode==1)
	{
	  printf("Did not find any importable data in the specified location(s)\n\n");
	  printf("done with non-gui mode\n\n");
	  ExitWrapper(-1);
	}
      
    not_while_running(parent_wid,message,1218,"No data found",3);  
    set_cursor(mydisplay,mywindow,GOOD);
    set_cursor(XtDisplay(GetImportShell()),XtWindow(GetImportShell()),ARROW);
    return;
  }
  





  if(num_failures==0)
    {
      if(old_num_found==0)
	{
	  sprintf(message,"File %s\n\
has been created, and contains:\n\
  %d shape\n\
  %d DTED\n\
  %d GeoTiff\n\
  %d NITF\n\
  %d Geodatabase\n\
  %d Geomedia Access Warehouse\n\
  %d TREX package\n\
specifications.\n\
This file is now suitable for use as an \"Input Specification File\" for importing\n\
feature/DTED data.\n",importdirectory,goodshape,gooddted,goodtiff,goodnitf,goodgeodatabase,
goodgeomediaacc,numtrextiff);
	}
      else
	{
	  sprintf(message,"File %s\n\
has been appended to, and contains:\n\
 %d shape\n\
 %d DTED\n\
 %d GeoTiff\n\
 %d NITF\n\
 %d Geodatabase\n\
 %d Geomedia Access Warehouse\n\
 %d TREX package\n\
 new specifications,\n\
in addition to the previously existing %d specification lines.\n\
This file is now suitable for use as an \"Input Specification File\" for importing\n\
feature/DTED data.\n\n\
Note that GAIT assumes the specifications previously existing in this file\n\
are valid, and did not thoroughly test them here.\n",
		  importdirectory,goodshape,gooddted,goodtiff,goodnitf,goodgeodatabase,
		  goodgeomediaacc,numtrextiff,old_num_found);
	}
      
      
   if(nullshapes>0)
	{
	  sprintf(message2,"\n\n%d of these Shapefiles contain zero shapes.",nullshapes);
	  strcat(message,message2);
	}
      
      if(batch_mode==1)
	{
	  printf("%s\n",message);
	  return;
	}


     
  	  if(DO_QAST==0)
	  {
        not_while_running(parent_wid,message,1218,"Successfully created input file",3);  
        set_cursor(mydisplay,mywindow,GOOD);
        set_cursor(XtDisplay(GetImportShell()),XtWindow(GetImportShell()),ARROW);
	  }

      return;
    }
  
  
  else
    {
      if(DO_QAST==1)
	  {
        
		QAST_IS = -1;
		return;
	  }



      if(old_num_found==0)
	{
	  sprintf(message,"File %s\n\
has been created, and contains %d feature, %d DTED, %d GeoTiff,\n\
%d NITF, and %d TREX specifications.\n\n\
%d of the %d Shapefile or Table names could not be automatically\n\
parsed to FCODEs.  This means that this file may need to be edited with\n\
a text editor to fill in the missing FCODE(s) before it can be used as\n\
as an \"Input Specification File\" for importing feature/DTED data.\n\n\
The missing FCODE(s) are represented in this file as \"*****\" symbols.\n\n\
After replacing all the \"*****\" with valid FCODEs, this file can be used\n\
as an \"Input Specification File\" for importing feature/DTED data.\n\n\
If there is FCODE data in the feature data itself, it is not necessary to\n\
edit this file, and it can be used now",
		  importdirectory,
		  goodshape+badshape+goodgeodatabase+goodgeomediaacc,
		  gooddted,goodtiff,goodnitf,
		  numtrextiff,
		  badshape+badtables,
		  goodshape+badshape+goodtables+badtables);

	}
      else
	{
	  sprintf(message,"File %s\n\
has been appended to, and contains %d feature, %d DTED, %d GeoTiff,\n\
%d NITF, and %d TREX new specifications,\n\
in addition to the previously existing %d specifications.\n\n\
%d of the %d Shapefile or Table names could not be automatically\n\
parsed to FCODEs.  This means that this file may need to be edited with\n\
a text editor to fill in the missing FCODE(s) before it can be used as\n\
as an \"Input Source...\" for importing feature/DTED data.\n\n\
The missing FCODE(s) are represented in this file as \"*****\" symbols.\n\n\
After replacing all the \"*****\" with valid FCODEs, this file can be used\n\
as an \"Input Specification File\" for importing feature/DTED data.\n\n\
If there is FCODE data in the feature data itself, it is not necessary to\n\
edit this file, and it can be used now.\n\n\
Note that GAIT assumes the specifications previously existing in this\n\
file are valid, and did not thoroughly test them here.\n",
		  importdirectory,
		  goodshape+badshape+goodgeodatabase+goodgeomediaacc,
		  gooddted,goodtiff,goodnitf,
          numtrextiff,
		  old_num_found,
		  badshape,
		  goodshape+badshape);
	}


      if(nullshapes>0)
	{
	  sprintf(message2,"\n\n%d of these Shapefiles contain zero shapes.",nullshapes);
	  strcat(message,message2);
	}


      if(batch_mode==1)
	{
	  printf("%s\n",message);
	  return;
	}
      else
	{
	  not_while_running(parent_wid,message,1219,"Created Input Specification File",3);  
	}
    }




  if(DO_QAST==0)
  {
    
	
    set_cursor(mydisplay,mywindow,GOOD);
    set_cursor(XtDisplay(GetImportShell()),XtWindow(GetImportShell()),ARROW);
  }

}






int GetZipFileList(char *filename,char **retlist, int noinsides)
{
  FILE *ptr;
  int addy,addy2,i,len,lastslash=-1,retval=0;
  char cmd[1000],buf[1000],lastpart[1000],thisname[1000];




  
  
  len = strlen(filename);
  for(i=0;i<len;i++)
    {
      if(USE_DOS==1)
	{
	  if(filename[i]=='\\')
	    {
	      lastslash = i;
	    }
	}
      else
	{
	  if(filename[i]=='/')
	    {
	      lastslash = i;
	    }
	}
    }
  
  if(lastslash<0)
    {
      printf("error: couldn't find lastslash for %s\n",filename);
      return -1;
    }
  
  sprintf(lastpart,"%s",&filename[lastslash+1]);
  
  
  len = strlen(lastpart);
  
  if(len<5)
    {
      printf("error: supposed zip file %s (%s) too short\n",filename,lastpart);
      return -1;
    }
  
  if(USE_DOS==1)
    {
      lastpart[len-4] = '\\';
    }
  else
    {
      lastpart[len-4] = '/';
    }
  lastpart[len-3] = '\0';

  if(noinsides==1)
  {
    lastpart[len-4] = '\0';
  }
  

  

  sprintf(cmd,"unzip -Z -1 \"%s\"",filename);

  
  
  
      
  if((ptr=POPEN(cmd,"r"))!=NULL)
  {
    while(fgets(buf,1000,ptr)!=NULL)
	{

	  

	  len = strlen(buf);

	  for(i=0;i<len;i++)
	  { 
		if(USE_DOS==1)
		{
          if(buf[i]=='/')
		  {
            buf[i] = '\\';
		  }
		}

	    if(buf[i]=='\n')
		{ 
		  buf[i] = '\0';
		  break;
		}   
	  }  

	  addy2 = (int)strstr(buf,lastpart);

	  if((addy2)||(noinsides==1))
	  { 
	    addy = (int)buf;
	     
		if(noinsides==1)
		{
	      sprintf(thisname,"%s",buf);
		}
		else
		{
	      sprintf(thisname,"%s",&buf[addy2-addy+strlen(lastpart)]);
		}

	    len = strlen(thisname);
	    if(len>=1)
		{
          retlist[retval] = (char *)malloc(len+10);
		  sprintf(retlist[retval],"%s",thisname);
		  retval = retval + 1;
		}
	  }
	} 

    PCLOSE(ptr); 

  } 

 
  

 return retval;

}




void FileNotPresent(char *filenotfound,char *zipname,char *foldername,int errnum, int isfolder)
{
  char message[2000];

  if(isfolder==1)
  {
    sprintf(message,"\
Error:\n\nDid not find folder %s\n\n\
in zipfile:  %s\n\
in folder:  %s\n\n\
This folder is required in this zipfile",
filenotfound,zipname,foldername);

  not_while_running(drawing_a,message,errnum,"Error: Missing folder",5);
  }
  else
  {
    sprintf(message,"\
Error:\n\nDid not find file %s\n\n\
in zipfile:  %s\n\
in folder:  %s\n\n\
This file is required in this zipfile",
filenotfound,zipname,foldername);

    not_while_running(drawing_a,message,errnum,"Error: Missing file",5);
  }
}



int CondReportIsPresent(char *thisfile,char **report_files,int num_reportfiles)
{ 
  int i;

  for(i=0;i<num_reportfiles;i++)
  {
    if(!strcmp(report_files[i],thisfile))
	{
      return i;
	}
  }
  return -1;
}


void CondReportPieceMissing(char *havefile,char *missingfile,int errnum)
{
  char message[1000];

  sprintf(message,"\
Error:  Missing Condition Report component file:\n\n\
Have file: %s\n\n\
But do not have required file: %s\n\n\
This is a necessary component of the condition report.",havefile,missingfile);

  not_while_running(drawing_a,message,errnum,"Error: Missing Condition Report Component",5);
}


int IsPresent(char *rootname,char **report_files,int num_reportfiles,int isfolder)
{ 
  char pathname[1000];
  int i;
  
  if(isfolder==1)
  {
    sprintf(pathname,"%s%s",rootname,MYSLASH);
  }
  else
  {
    sprintf(pathname,"%s",rootname);
  }

  for(i=0;i<num_reportfiles;i++)
  {
    if(!strcmp(report_files[i],pathname))
	{
      return i;
	}
  }
  return -1;
}


int CompareXML(char *topxmlname,char *command,char *insidexmlname,char *cellid,char *insidepath,char *folder)
{
  FILE *ptr;
  FILE *topxml;
  char *buf,*buf2;
  char message[1000];
  int i,len1,len2,linenum=0;


  buf = (char *)malloc(2000000);
  if(buf==NULL)
  {
    not_while_running(drawing_a,"Error: Out of memory!",1561,"Error: Out of memory!",5);
    return 0;
  }
  buf2 = (char *)malloc(2000000);
  if(buf2==NULL)
  {
    not_while_running(drawing_a,"Error: Out of memory!",1568,"Error: Out of memory!",5);
    return 0;
  }


  topxml = fopen(topxmlname,"r");
  if(topxml==NULL)
  {
    sprintf(buf,"Error:\n\nUnable to open:\n\n  %s\n",topxmlname);
    not_while_running(drawing_a,buf,1560,"Error: Could not open XML",5);
	free(buf);
	free(buf2);
    return 0;
  }


  if((ptr=POPEN(command,"r"))!=NULL)
  {
    while(fgets(buf,66000,ptr)!=NULL)
	{
      fgets(buf2,66000,topxml);


	  linenum = linenum + 1;

	  

	  if(strcmp(buf,buf2))
	  {
        len1 = strlen(buf);
		len2 = strlen(buf2);

		if(len1!=len2)
		{
          sprintf(message,"\
Error:  Found %s.xml in locations:\n\n\
  %s\n\
and\n\
  %s\n\n\
But these 2 files are not identical.\n\n\
Line %d in the files have different length (%d and %d)\n",
cellid,insidepath,folder,linenum,len1,len2);
		}
		else
		{
          for(i=0;i<len1;i++)
		  {
            if(buf[i]!=buf2[i])
			{
              break;
			}
		  }

          sprintf(message,"\
Error:  Found %s.xml in locations:\n\n\
  %s\n\
and\n\
  %s\n\n\
But these 2 files are not identical.\n\n\
Line %d in the file is different at column %d:\n\
  \"%c\"\n\
 and\n\
  \"%c\"",
cellid,insidepath,folder,linenum,i,buf[i],buf2[i]);
		}

	
        not_while_running(drawing_a,message,1562,"Error: XMLs not identical",5);

        
        free(buf);
        free(buf2);
        fclose(topxml);
		return 0;
	  }


	} 

    PCLOSE(ptr); 

  } 
  else
  {
    sprintf(buf,"Error:\n\nUnable to extract and read:\n\n  %s\n",insidexmlname);
    not_while_running(drawing_a,buf,1569,"Error: Could not open XML",5);
	free(buf);
	free(buf2);
	fclose(topxml);
    return 0;
  }

  free(buf);
  free(buf2);
  fclose(topxml);
  return 1;
}



int TestMGCPPackaging(Widget thisparent,char *folder, int verbose, char *xmlfolder)
{
  FILE *ptr;
  char *files_found[4096],*report_files[4096],*cell_files[4096];
  char cmd2[1024],buf[1024],firstint[5],secondint[5],cellid[10],message[1000],
	   warning1[100],XMLSFC[500],filesep[10];
  int i,j,k,len,num_files=0,fint=-999,sint=-999,cellidfile,reportfile,topxmlfile,
	  num_reportfiles,foundqacr,foundqacr2,versionnum,foundgaitversion,errnum,
	  isfolder,attribution_errors_folder,summary_files_folder,foundit,foundxml,
	  summary_file_num=3,attr_file_num=27,condreport_file_num=9,bad,exten,
	  condition_reports_folder,num_cellfiles,fcfound,fcxmlfound,fcxlsfound,
	  foundfirst,foundsecond,condfilesfound=0,madeachange=1,lastslash;


  char *summary_files[]={
	  "checkoptions.txt",
	  "checksummary.txt",
	  "contentsummary.txt"
  };
  char *condreport_files[]={
	  "condreport.bo",
	  "condreport.es",
	  "condreport.es2",
	  "condreport.lk",
	  "condreport.lk2",
	  "condreport.ns",
	  "condreport.nt",
	  "condreport.sm",
	  "condreport.vr"
  };
  char *attr_files[]={
	  "badattr.txt",
	  "badcase.txt",
	  "badcoord.txt",
	  "badfcode.txt",
	  "badhole.txt",
	  "badlen.txt",
	  "badmgcpfilename.txt",
	  "badshapes.txt",
	  "badtype.txt",
	  "blankattrval.txt",
	  "blankattrval.csv",
	  "blankG.txt",
	  "DependencyErr.txt",
	  "emptyshapes.txt",
	  "ID_FormatErr.txt",
	  "MetaDataErr.txt",
	  "mgcpmixednull.txt",
	  "MissingAttribute.txt",
	  "nofcodecolumn.txt",
	  "nullshp.txt",
	  "PickListErr.txt",
	  "ReqAttrNullValueErr.txt",
	  "UnexpectedAttr.txt",
	  "UnexpectedGeom.txt",
	  "unkcolumn.txt",
	  "unkcolumnG.txt",
	  "ValueRangeErr.txt"
  };

  extern char *PParseXML(char *filename);


  warning1[0] = '\0';

  printf("Test MGCP packaging against TRD %d for folder %s\n",DP_TRD_TYPE,folder);


  if(DP_TRD_TYPE==3)
  {
    sprintf(filesep," - ");
  }
  else if((DP_TRD_TYPE==4)||(DP_TRD_TYPE==41)||(DP_TRD_TYPE==42)||(DP_TRD_TYPE==43)||(DP_TRD_TYPE==44))
  {
    sprintf(filesep,"_");
  }
  else
  {
    printf("Bad Data Packaging TRD specified: %d\n",DP_TRD_TYPE);
	XBell(mydisplay,50);
	return 0;
  }


  


  if(strlen(folder)==0)
  {
    sprintf(message,"\
Error: No \"Folder Containing MGCP Packaged Cell\" entered.\n\n\
You must enter a folder containing an MGCP packaged cell.");

	not_while_running(thisparent,message,1587,"Error: Invalid folder path",5);
	return 0;
  }
  else if(strlen(folder)<2)
  {
    sprintf(message,"\
Error: You must enter a valid \"Folder Containing MGCP Packaged Cell\"\n\
The entry \"%s\" is too short to be a valid path.",folder);

	not_while_running(thisparent,message,1586,"Error: Invalid folder path",5);
	return 0;
  }



  if(USE_DOS==1)
  {
    sprintf(cmd2,"dir /b \"%s\"",folder);
  }
  else
  {
    sprintf(cmd2,"ls \"%s\"",folder);
  }

  if((ptr=POPEN(cmd2,"r"))!=NULL)
  {
    while(fgets(buf,1000,ptr)!=NULL)
	{
	  len = strlen(buf);
	  for(i=0;i<len;i++)
	  {
	    if(buf[i]=='\n')
		{
		  buf[i] = '\0';
          break;
		}
	  }
	  files_found[num_files] = (char *)malloc(strlen(buf)+10);
	  sprintf(files_found[num_files],"%s",buf);
	  num_files = num_files + 1;
	  if(num_files>4090)
	  {
        printf("extremely large number of files found in %s...only using first 4090\n",folder);
	  }
	}
	PCLOSE(ptr);
  }

  cellid[0] = '\0';
  cellidfile = -1;

  for(i=0;i<num_files;i++)
  {
	if(strlen(files_found[i])==11)
	{
	  if(
		 ((timtoupper(files_found[i][0 ])=='E')||(timtoupper(files_found[i][0])=='W')) && 
		 ((timtoupper(files_found[i][4 ])=='N')||(timtoupper(files_found[i][4])=='S')) && 
          ((files_found[i][1]>='0')&&(files_found[i][1]<='9'))                         &&
          ((files_found[i][2]>='0')&&(files_found[i][2]<='9'))                         &&
          ((files_found[i][3]>='0')&&(files_found[i][3]<='9'))                         &&
          ((files_found[i][5]>='0')&&(files_found[i][5]<='9'))                         &&
          ((files_found[i][6]>='0')&&(files_found[i][6]<='9'))                         &&
		  (timtoupper(files_found[i][7 ])=='.')                                        && 
		  (timtoupper(files_found[i][8 ])=='Z')                                        && 
		  (timtoupper(files_found[i][9 ])=='I')                                        && 
		  (timtoupper(files_found[i][10])=='P')
		)
	  {
		firstint [0] = files_found[i][1];
		firstint [1] = files_found[i][2];
		firstint [2] = files_found[i][3];
		firstint [3] = '\0';
		secondint[0] = files_found[i][5];
		secondint[1] = files_found[i][6];
		secondint[2] = '\0';

        sscanf(firstint, "%d",&fint);
        sscanf(secondint,"%d",&sint);

		if((fint>=0)&&(fint<=180)&&(sint>=0)&&(sint<=90))
		{
          if(
			  (
			    ( (timtoupper(files_found[i][0])=='E') && (fint>=0) && (fint<=179) ) 
			         ||
			    ( (timtoupper(files_found[i][0])=='W') && (fint>=1) && (fint<=180) ) 
			  )
			  &&
			  (
		        ( (timtoupper(files_found[i][4])=='N') && (sint>=0) && (sint<=89) ) 
			         ||
			    ( (timtoupper(files_found[i][4])=='S') && (sint>=1) && (sint<=90) ) 
              )
			)
		  {
             cellid[0] = timtoupper(files_found[i][0]);
			 cellid[1] = files_found[i][1];
			 cellid[2] = files_found[i][2];
			 cellid[3] = files_found[i][3];
			 cellid[4] = timtoupper(files_found[i][4]);
			 cellid[5] = files_found[i][5];
			 cellid[6] = files_found[i][6];
			 cellid[7] = '\0';

			 if(cellidfile<0)
			 {
			   cellidfile = i;
			 }
			 else
			 {
    sprintf(message,"\
Error: Found multiple <CELLID>.zip files in folder:\n\
  %s\n\n\
Found files:\n\
 %s\n\
   and\n\
 %s\n\n\
Exactly one <CELLID>.zip file may be present in the folder containing\n\
an MGCP packaged cell.\n",folder,files_found[cellidfile],files_found[i]);

	not_while_running(thisparent,message,1543,"Multiple <CELLID>.zip files found",5);
	return 0;
			 }
		  }
		} 
	  }
	} 
  } 


  if(cellid[0]=='\0')
  {
    sprintf(message,"\
Error: Did not find valid <CELLID>.zip file in folder:\n\
  %s\n\n\
Valid <CELLID>.zip filenames are:  <E/W><Longitude><N/S><Latitude>\n\n\
  <Longitude> is a 3 digit number from 180 to 001 for west cells,\n\
  and from 000 to 179 for east cells.\n\n\
  <Latitude> is a 2 digit number from 01 to 90 for south cells,\n\
  and from 00 to 89 for north cells.\n",folder);

	not_while_running(thisparent,message,1542,"No <CELLID>.zip file found",5);
	return 0;
  }



  reportfile = -1;

  for(i=1;i<=10000;i++)
  {
    sprintf(message,"%s_Reports_sub%d.zip",cellid,i);

	for(j=0;j<num_files;j++)
	{
      if(!strcmp(message,files_found[j]))
	  {
		if(reportfile>=0)
		{
          sprintf(message,"\
Error: Found multiple <CELLID>_Reports_subn.zip files in folder:\n\
  %s\n\n\
Found files:\n\
 %s\n\
   and\n\
 %s\n\n\
Exactly one <CELLID>_Reports_subn.zip file may be present in the folder containing\n\
an MGCP packaged cell.\n",folder,files_found[reportfile],files_found[j]);

	      not_while_running(thisparent,message,1544,"Multiple <CELLID>_Reports_subn.zip files found",5);
	
	      return 0;
		}
		reportfile = j;
	  }
	}
  }


  if(reportfile<0)
  {
    sprintf(message,"\
Error: Did not find valid <CELLID>_Reports_subn.zip file in folder:\n  %s\n",folder);

	not_while_running(thisparent,message,1545,"No <CELLID>_Reports_subn.zip file found",5);
	return 0;  
  }



  

  for(i=1;i<=10000;i++)
  { 
    sprintf(message,"_Reports_sub%d.zip",i);

	for(j=0;j<num_files;j++)
	{
      if(j==reportfile)
	  {
        continue;
	  }

      len = strlen(files_found[j]);

      if(len>=24)
	  {
        if(!strcmp(message,&files_found[j][7]))
		{
          printf("found potential additional report zipfile %s\n",files_found[j]);

          if(
		      ((timtoupper(files_found[j][0 ])=='E')||(timtoupper(files_found[j][0])=='W')) && 
		      ((timtoupper(files_found[j][4 ])=='N')||(timtoupper(files_found[j][4])=='S')) && 
              ((files_found[j][1]>='0')&&(files_found[j][1]<='9'))                          &&
              ((files_found[j][2]>='0')&&(files_found[j][2]<='9'))                          &&
              ((files_found[j][3]>='0')&&(files_found[j][3]<='9'))                          &&
              ((files_found[j][5]>='0')&&(files_found[j][5]<='9'))                          &&
              ((files_found[j][6]>='0')&&(files_found[j][6]<='9'))
		    )
		  {
		    firstint [0] = files_found[j][1];
		    firstint [1] = files_found[j][2];
		    firstint [2] = files_found[j][3];
		    firstint [3] = '\0';
		    secondint[0] = files_found[j][5];
		    secondint[1] = files_found[j][6];
		    secondint[2] = '\0';

            sscanf(firstint, "%d",&fint);
            sscanf(secondint,"%d",&sint);

		    if((fint>=0)&&(fint<=180)&&(sint>=0)&&(sint<=90))
			{ 
              if(
			      (
			        ( (timtoupper(files_found[j][0])=='E') && (fint>=0) && (fint<=179) ) 
			             ||
			        ( (timtoupper(files_found[j][0])=='W') && (fint>=1) && (fint<=180) ) 
			      )
			      &&
			      (
		            ( (timtoupper(files_found[j][4])=='N') && (sint>=0) && (sint<=89) ) 
			             ||
			        ( (timtoupper(files_found[j][4])=='S') && (sint>=1) && (sint<=90) ) 
                  )
			    )
			  {
                sprintf(message,"\
Error: Found multiple <CELLID>_Reports_subn.zip files in folder:\n\
  %s\n\n\
Found files:\n\
 %s\n\
   and\n\
 %s\n\nOnly files representing a single <CELLID> may be present in the folder to be checked",
 folder,files_found[reportfile],files_found[j]);

	            not_while_running(thisparent,message,1583,"Multiple <CELLID>_Reports_subn.zip files found",5);
				return 0;
			  }
			}
		  }
		}
	  }
	} 
  }










  topxmlfile = -1;

  sprintf(message,"%s.xml",cellid);

  for(i=0;i<num_files;i++)
  { 
    if(!strcmp(message,files_found[i]))
	{
      
	  topxmlfile = i;
	  break;
	}
  }


  if(topxmlfile>=0)
  {
    printf("...cellid: %s reportfile: %s cellzipfile %s top level xml: %s\n",
	    cellid,files_found[reportfile],files_found[cellidfile],files_found[topxmlfile]);
  }
  else
  {
    printf("...cellid: %s reportfile: %s cellzipfile %s\n",
	    cellid,files_found[reportfile],files_found[cellidfile]);
  }


  sprintf(QAST_REPORT,"%s",files_found[reportfile]);


  for(i=0;i<num_files;i++)
  {
	if(strlen(files_found[i])==11)
	{
	  if(
		 ((timtoupper(files_found[i][0 ])=='E')||(timtoupper(files_found[i][0])=='W')) && 
		 ((timtoupper(files_found[i][4 ])=='N')||(timtoupper(files_found[i][4])=='S')) && 
          ((files_found[i][1]>='0')&&(files_found[i][1]<='9'))                         &&
          ((files_found[i][2]>='0')&&(files_found[i][2]<='9'))                         &&
          ((files_found[i][3]>='0')&&(files_found[i][3]<='9'))                         &&
          ((files_found[i][5]>='0')&&(files_found[i][5]<='9'))                         &&
          ((files_found[i][6]>='0')&&(files_found[i][6]<='9'))                         &&
		  (timtoupper(files_found[i][7 ])=='.')                                        && 
		  (timtoupper(files_found[i][8 ])=='X')                                        && 
		  (timtoupper(files_found[i][9 ])=='M')                                        && 
		  (timtoupper(files_found[i][10])=='L')
		)
	  {
		firstint [0] = files_found[i][1];
		firstint [1] = files_found[i][2];
		firstint [2] = files_found[i][3];
		firstint [3] = '\0';
		secondint[0] = files_found[i][5];
		secondint[1] = files_found[i][6];
		secondint[2] = '\0';

        sscanf(firstint, "%d",&fint);
        sscanf(secondint,"%d",&sint);

		if((fint>=0)&&(fint<=180)&&(sint>=0)&&(sint<=90))
		{
          if(
			  (
			    ( (timtoupper(files_found[i][0])=='E') && (fint>=0) && (fint<=179) ) 
			         ||
			    ( (timtoupper(files_found[i][0])=='W') && (fint>=1) && (fint<=180) ) 
			  )
			  &&
			  (
		        ( (timtoupper(files_found[i][4])=='N') && (sint>=0) && (sint<=89) ) 
			         ||
			    ( (timtoupper(files_found[i][4])=='S') && (sint>=1) && (sint<=90) ) 
              )
			)
		  {

            if(i!=topxmlfile)
			{

              sprintf(message,"\
Error: Found mismatched <CELLID>.zip and <CELLID>.xml in folder:\n\
  %s\n\n\
Found files:\n\
 %s\n\
   and\n\
 %s\n\nOnly files representing a single <CELLID> may be present in the folder to be checked",
 folder,files_found[cellidfile],files_found[i]);

	          not_while_running(thisparent,message,1546,"Mismatched <CELLID>.zip and <CELLID>.xml files found",5);

		      return 0;
			}
		  }
		} 
	  }
	} 
  } 











  sprintf(cmd2,"%s%s%s",folder,MYSLASH,files_found[reportfile]);

  


  num_reportfiles = GetZipFileList(cmd2,report_files,1);


  while(madeachange==1)
  {

    madeachange = 0;

    for(i=0;i<num_reportfiles;i++)	
	{ 
      char newstr[1000];

	  len = strlen(report_files[i]);
	
	  for(j=0;j<len;j++)
	  { 
        if(report_files[i][j]==MYCHARSLASH)
		{ 
          sprintf(newstr,"%s",report_files[i]);
		  newstr[j+1] = '\0';

		  

		  for(k=0;k<num_reportfiles;k++)
		  { 
            if(!strcmp(newstr,report_files[k]))
			{ 
			  break;
			}
		  } 

		  if(k==num_reportfiles)
		  { 
		    

            report_files[num_reportfiles] = (char *)malloc(strlen(newstr)+10);
		    sprintf(report_files[num_reportfiles],"%s",newstr);
			num_reportfiles = num_reportfiles + 1;
			madeachange = 1;
		  }

  	  if(madeachange==1) break;

		} 

	  if(madeachange==1) break;

	  } 

	  if(madeachange==1) break;

	} 

  } 



 
  foundqacr = -1;

  sprintf(cmd2,"%s%sMGCP_QACR.doc",cellid,filesep);

  for(i=0;i<num_reportfiles;i++)
  {
    if(!strcmp(report_files[i],cmd2))
	{
      foundqacr = i;
	  break;
	}
  }


  foundqacr2 = -1;

  for(j=1;j<10000;j++)
  {
    sprintf(cmd2,"%s%sMGCP_QACR_sub%d.doc",cellid,filesep,j);

	if(foundqacr2>=0)
	{
      break;
	}

    for(i=0;i<num_reportfiles;i++)
	{
      if(!strcmp(report_files[i],cmd2))
	  {
        foundqacr2 = i;
	    break;
	  } 
	} 
  }


  if((foundqacr>=0)&&(foundqacr2>=0))
  {
    sprintf(message,"\
Error:\n\nFound both \"<CELLID>%sMGCP_QACR_subn.doc\" and \"<CELLID>%sMGCP_QACR.doc\"\n\n\
in zipfile:  %s\n\
in folder:  %s\n\n\
Found files:\n\
 %s\n\
   and\n\
 %s\n\nExactly 1 of these files must be present in this zipfile",
 filesep,filesep,
 files_found[reportfile],folder,report_files[foundqacr],report_files[foundqacr2]);

	not_while_running(thisparent,message,1548,"Error: Multiple QACR files found",5);

    return 0;
  }

  if((foundqacr<0)&&(foundqacr2<0))
  {
    sprintf(message,"\
Error:\n\nDid not find \"<CELLID>%sMGCP_QACR_subn.doc\" or \"<CELLID>%sMGCP_QACR.doc\"\n\n\
in zipfile:  %s\n\
in folder:  %s\n\n\
Exactly 1 of these files must be present in this zipfile",
    filesep,filesep,files_found[reportfile],folder);

    not_while_running(thisparent,message,1549,"Error: No QACR files found",5);

    return 0;
  }


  sscanf(VersionStr,"%d",&versionnum);


  if((versionnum<20)||(versionnum>50))
  {
    XBell(mydisplay,50);
    printf("Error getting GAIT version num: %d from %s\n",versionnum,VersionStr);
    versionnum = 50;
  }

  foundgaitversion = -1;

  for(j=16;j<=versionnum;j++)
  {
    sprintf(cmd2,"%s%sGAIT%d_Reports%s",cellid,filesep,j,MYSLASH);

    for(i=0;i<num_reportfiles;i++)
	{
      if(!strcmp(report_files[i],cmd2))
	  {


        if(foundgaitversion>=0)
		{
          sprintf(message,"\
Error:\n\nFound multiple \"<CELLID>%sGAITNN_Reports\" (NN: 16-%d)\n\n\
in zipfile:  %s\n\
in folder:  %s\n\n\
Found:\n\
  %s\n\
    and\n\
  %s\n\n\
Exactly 1 of these folders is required in this zipfile",
filesep,versionnum,files_found[reportfile],folder,report_files[foundgaitversion],report_files[i]);

          not_while_running(thisparent,message,1550,"Error: No GAITNN_Reports folder found",5);
	      return 0;
		}
		else
		{
          foundgaitversion = i;
		  sprintf(QAST_REPORTFOLDER,"%s",cmd2);
		}


        if( (DO_QAST==1) && (j!=versionnum) )
		{ 
          sprintf(message,"\
Error:\n\nFound that the Data Packgage used GAIT version %d.\n\n\
GAIT %d can only perform QA checking on Data Packages that used GAIT %d\n",
           j,versionnum,versionnum);

          not_while_running(thisparent,message,1599,"Error: Incompatible GAIT version for QA",5);
          return 0;
		} 



	  } 
	} 
  }


  if(foundgaitversion<0)
  {
    sprintf(message,"\
Error:\n\nDid not find \"<CELLID>%sGAITNN_Reports\" (NN: 16-%d)\n\n\
in zipfile:  %s\n\
in folder:  %s\n\n\
This folder is required in this zipfile",
    filesep,versionnum,files_found[reportfile],folder);

    not_while_running(thisparent,message,1551,"Error: No GAITNN_Reports folder found",5);
    return 0;
  }




  sprintf(cmd2,"%sattribution_errors",report_files[foundgaitversion]);
  errnum = 1552;
  isfolder = 1;
  attribution_errors_folder = IsPresent(cmd2,report_files,num_reportfiles,isfolder);
  if(attribution_errors_folder<0)
  {
    FileNotPresent(cmd2,files_found[reportfile],folder,errnum,isfolder);
	return 0;
  }
  
  sprintf(cmd2,"%ssummary_files",report_files[foundgaitversion]);
  errnum = 1553;
  isfolder = 1;
  summary_files_folder = IsPresent(cmd2,report_files,num_reportfiles,isfolder);
  if(summary_files_folder<0)
  {
    FileNotPresent(cmd2,files_found[reportfile],folder,errnum,isfolder);
	return 0;
  }

  sprintf(cmd2,"%scondition_reports",report_files[foundgaitversion]);
  errnum = 1554;
  isfolder = 1;
  condition_reports_folder = IsPresent(cmd2,report_files,num_reportfiles,isfolder);
  if(condition_reports_folder<0)
  {
    FileNotPresent(cmd2,files_found[reportfile],folder,errnum,isfolder);
	return 0;
  }


  


  for(i=0;i<summary_file_num;i++)
  {
    sprintf(cmd2,"%ssummary_files%s%s",report_files[foundgaitversion],MYSLASH,summary_files[i]);
    errnum = 1555; 
    isfolder = 0;
    condition_reports_folder = IsPresent(cmd2,report_files,num_reportfiles,isfolder);
    if(condition_reports_folder<0)
	{
      FileNotPresent(cmd2,files_found[reportfile],folder,errnum,isfolder);
	  return 0;
	}
  }

  for(i=0;i<attr_file_num;i++)
  {
    sprintf(cmd2,"%sattribution_errors%s%s",report_files[foundgaitversion],MYSLASH,attr_files[i]);
    errnum = 1556; 
    isfolder = 0;
    condition_reports_folder = IsPresent(cmd2,report_files,num_reportfiles,isfolder);
    if(condition_reports_folder<0)
	{
      FileNotPresent(cmd2,files_found[reportfile],folder,errnum,isfolder);
	  return 0;
	}
  }


  for(i=0;i<condreport_file_num;i++)
  {

    
    

    sprintf(cmd2,"%scondition_reports%s%s",report_files[foundgaitversion],MYSLASH,condreport_files[i]);
    errnum = 1557; 
    isfolder = 0;
    condition_reports_folder = IsPresent(cmd2,report_files,num_reportfiles,isfolder);
    if(condition_reports_folder<0)
	{
      sprintf(warning1,"\n\n\nWarning:\n\nDefault condition report name \"condreport\" not used.\n\n");
      break;
	}
  }



  condfilesfound = 0;

  for(i=0;i<num_reportfiles;i++)
  {  
    sprintf(cmd2,"%scondition_reports%s",report_files[foundgaitversion],MYSLASH);

	if(!strcmp(cmd2,report_files[i]))
	{
      continue;
	}

    if(strstr(report_files[i],cmd2))
	{
      condfilesfound = condfilesfound + 1;
	}
  }

  if(condfilesfound!=9)
  {
    sprintf(message,"\
Error:  Wrong number of files (%d) in condition_reports folder (expected 9)\n\n\
Expected a single condition report, consisting of 9 files with extensions:\n\n\
  .bo  .es  .es2  .lk  .lk2  .ns  .nt  .sm  .vr\n",condfilesfound);
   
    not_while_running(thisparent,message,1579,"Error: Too many condition report files",5);
	return 0;
  }


  if(warning1[0]=='\0')
  {
    sprintf(QAST_CONDREPORTNAME,"condreport");
  }
  else
  {
     

	 foundit = -1;

     for(i=0;i<num_reportfiles;i++)
	 { 
       sprintf(cmd2,"%scondition_reports%s",report_files[foundgaitversion],MYSLASH);

	   if(!strcmp(cmd2,report_files[i]))
	   {
         continue;
	   }

       if(strstr(report_files[i],cmd2))
	   {
         len = strlen(report_files[i]);
		 if(len>=5)
		 {
		   if(
		       (report_files[i][len-4]=='.') &&
		       (report_files[i][len-3]=='l') &&
		       (report_files[i][len-2]=='k') &&
		       (report_files[i][len-1]=='2')
			  )
		   {
             
             foundit = i;
		   }
		 }
	   }
	 }


    if(foundit>=0)
	{
      isfolder = foundit;
      len = strlen(report_files[foundit]);

	  sprintf(buf,"%s",report_files[foundit]);
	  


	  buf[len-3] = 'e';
	  buf[len-2] = 's';
	  buf[len-1] = '2';
	  buf[len  ] = '\0';

	  if(CondReportIsPresent(buf,report_files,num_reportfiles)<0)
	  {
        CondReportPieceMissing(report_files[isfolder],buf,1571);
        return 0;
	  }


	  buf[len-3] = 'b';
	  buf[len-2] = 'o';
	  buf[len-1] = '\0';

	  if(CondReportIsPresent(buf,report_files,num_reportfiles)<0)
	  {
        CondReportPieceMissing(report_files[isfolder],buf,1572);
        return 0;
	  }

	  buf[len-3] = 'e';
	  buf[len-2] = 's';
	  buf[len-1] = '\0';

	  if(CondReportIsPresent(buf,report_files,num_reportfiles)<0)
	  {
        CondReportPieceMissing(report_files[isfolder],buf,1573);
        return 0;
	  }


	  buf[len-3] = 'l';
	  buf[len-2] = 'k';
	  buf[len-1] = '\0';

	  if(CondReportIsPresent(buf,report_files,num_reportfiles)<0)
	  {
        CondReportPieceMissing(report_files[isfolder],buf,1574);
        return 0;
	  }


	  buf[len-3] = 'n';
	  buf[len-2] = 's';
	  buf[len-1] = '\0';

	  if(CondReportIsPresent(buf,report_files,num_reportfiles)<0)
	  {
        CondReportPieceMissing(report_files[isfolder],buf,1575);
        return 0;
	  }


	  buf[len-3] = 'n';
	  buf[len-2] = 't';
	  buf[len-1] = '\0';

	  if(CondReportIsPresent(buf,report_files,num_reportfiles)<0)
	  {
        CondReportPieceMissing(report_files[isfolder],buf,1576);
        return 0;
	  }


	  buf[len-3] = 's';
	  buf[len-2] = 'm';
	  buf[len-1] = '\0';

	  if(CondReportIsPresent(buf,report_files,num_reportfiles)<0)
	  {
        CondReportPieceMissing(report_files[isfolder],buf,1577);
        return 0;
	  }


	  buf[len-3] = 'v';
	  buf[len-2] = 'r';
	  buf[len-1] = '\0';

	  if(CondReportIsPresent(buf,report_files,num_reportfiles)<0)
	  {
        CondReportPieceMissing(report_files[isfolder],buf,1578);
        return 0;
	  }



	  sprintf(message,"%s",buf);
	  message[len-4] = '\0';

	  
	  lastslash = 0;
	  for(i=0;i<len;i++)
	  {
		if(message[i]==MYCHARSLASH)
		{
		  lastslash = i;
		}
	  }

	  sprintf(QAST_CONDREPORTNAME,"%s",&message[lastslash+1]);

	}
	else
	{
      sprintf(message,"\
Error:  Invalid or missing condition report in \"condition_reports\" folder:\n\n\
The \"condition_reports\" folder must contain a GAIT condition report, consisting\n\
of 9 files with different extensions, one of which is \".lk2\"\n\n\
There was no \".lk2\" file found in the condition_reports folder.");

      not_while_running(thisparent,message,1580,"Error: No \".lk2\" file in \"condition_reports\" folder",5);
      return 0;
	}

  }



  sprintf(cmd2,"%s%s%s",folder,MYSLASH,files_found[cellidfile]);
  sprintf(QAST_CELL,"%s",cmd2);


  num_cellfiles = GetZipFileList(cmd2,cell_files,1);


  foundxml = -1;

  sprintf(cmd2,"%s.xml",cellid);

  for(i=0;i<num_cellfiles;i++)
  {
    if(!strcmp(cell_files[i],cmd2))
	{
      foundxml = i;
	  break;
	}
  }


  if(foundxml<0)
  {
    isfolder = 0;
    FileNotPresent(cmd2,files_found[cellidfile],folder,1559,isfolder);
	return 0;
  }



  if((topxmlfile>=0)&&(foundxml>=0))
  {
    


    sprintf(buf,"%s%s%s.xml\n",folder,MYSLASH,cellid);

	

	
    sprintf(cmd2,"unzip -p \"%s%s%s\" \"%s.xml\"",
		folder,MYSLASH,files_found[cellidfile],
		cellid);

	

	sprintf(buf,"%s%s%s.xml",folder,MYSLASH,cellid); 
	if(CompareXML(buf,cmd2,buf,cellid,files_found[cellidfile],folder)==0)
	{
	  return 0;
	}


	
	
	

	sprintf(buf,"%s",PROJECTLOC);
	len = strlen(buf);
    if(USE_DOS==1)
    {
      if(buf[len-1]=='\\')
	  {
        buf[len-1] = '\0';
	  }
    }
    else
    {
      if(buf[len-1]=='/')
	  {
        buf[len-1] = '\0';
	  }
    }



	if(xmlfolder!=NULL)
	{
      sprintf(cmd2,"unzip -o -j -C \"%s%s%s\" \"%s.xml\" -d\"%s\" > NUL ",
		folder,MYSLASH,files_found[cellidfile],
		cellid,
		xmlfolder);
	  system(cmd2);

	  sprintf(cmd2,"%s%s%s.xml",xmlfolder,MYSLASH,cellid);

	  sprintf(QAST_XML,"%s",cmd2);

	}
	else
	{
      sprintf(cmd2,"unzip -o -j -C \"%s%s%s\" \"%s.xml\" -d\"%s\" > NUL ",
		folder,MYSLASH,files_found[cellidfile],
		cellid,
		buf);
	  system(cmd2);

	  sprintf(cmd2,"%s%s%s.xml",buf,MYSLASH,cellid);

	}


	printf("\n\n\nGetting (1) XMLSFC from %s\n",cmd2);


    if(FileExists(cmd2))
	{
	  sprintf(XMLSFC,"%s",PParseXML(cmd2));

	  

	  if(xmlfolder==NULL)
	  {
		
	    if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
		{  
	      sprintf(buf,"del \"%s\"",cmd2);
		}  
	    else
		{  
	      sprintf(buf,"rm \"%s\"",cmd2);
		}  
	    system(buf);
	  }

	}
	else
	{
      

      sprintf(message,"Error(1):  Could not extract XML: %s.xml\n\n From: \"%s%s%s\"\n\n To:  \"%s\"",
		  cellid,
		  folder,MYSLASH,files_found[cellidfile],
		  cmd2);

      not_while_running(thisparent,message,1601,"Error: Could not extract or open XML",5);
	  return 0;
	}
  }
  else
  {


    


    if(xmlfolder!=NULL)
	{
	  printf("SAVE XML to %s\n",xmlfolder);

      sprintf(cmd2,"unzip -o -j -C \"%s%s%s\" \"%s.xml\" -d\"%s\" > NUL ",
		folder,MYSLASH,files_found[cellidfile],
		cellid,
		xmlfolder);
	  system(cmd2);

	  sprintf(cmd2,"%s%s%s.xml",xmlfolder,MYSLASH,cellid);

	  sprintf(QAST_XML,"%s",cmd2);
	}
	else
	{

	  

	  sprintf(buf,"%s",PROJECTLOC);
	  len = strlen(buf);
      if(USE_DOS==1)
	  { 
        if(buf[len-1]=='\\')
		{ 
          buf[len-1] = '\0';
		} 
	  }
      else
	  {
        if(buf[len-1]=='/')
		{ 
          buf[len-1] = '\0';
		} 
	  } 


      sprintf(cmd2,"unzip -o -j -C \"%s%s%s\" \"%s.xml\" -d\"%s\" > NUL ",
		folder,MYSLASH,files_found[cellidfile],
		cellid,
		buf);
	  system(cmd2);

	  sprintf(cmd2,"%s%s%s.xml",buf,MYSLASH,cellid);
	}



	

     if(FileExists(cmd2))
	 { 
	  sprintf(XMLSFC,"%s",PParseXML(cmd2));

	  

	  if(xmlfolder==NULL)
	  {
		
	    if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
		{  
	      sprintf(buf,"del \"%s\"",cmd2);
		}  
	    else
		{  
	      sprintf(buf,"rm \"%s\"",cmd2);
		}  
	    system(buf);
	  }
	}
	else
	{
      

      sprintf(message,"Error(2):  Could not extract XML: %s.xml\n\n From: \"%s%s%s\"\n\n To:  \"%s\"",
		  cellid,
		  folder,MYSLASH,files_found[cellidfile],
		  cmd2);

      not_while_running(thisparent,message,1601,"Error: Could not extract or open XML",5);
	  return 0;
	}
  } 


  fcfound    = -1;
  fcxmlfound = -1;
  fcxlsfound = -1;


  for(i=0;i<num_cellfiles;i++)
  {
     if(i==foundxml)
	 {
       continue;
	 }

	 len = strlen(cell_files[i]);

	 if(len<4)
	 {
        sprintf(cmd2,"FC%s",MYSLASH);

		if(!strcmp(cell_files[i],cmd2))
		{

          if((DP_TRD_TYPE==4)||(DP_TRD_TYPE==41)||(DP_TRD_TYPE==42)||(DP_TRD_TYPE==43)||(DP_TRD_TYPE==44))
		  {
            

            sprintf(message,"Error:  Found \"FC\" folder in %s\n\n\
The FC folder is not allowed for TRD 4.",files_found[cellidfile]);

            not_while_running(thisparent,message,1588,"Error: FC not allowed for TRD 4",5);
			return 0;
		  }


          fcfound = i;
		}
		else
		{
            sprintf(message,"\
Error:  Unexpected file:\n\n\
  %s\n\n\
in zipfile:  %s\n\n\
Only shapefiles and an optional FC folder (containing one XML file and one\n\
optional XLS file) are allowed in the \"%s.zip\" file.\n\n\
The file \"%s\" is not allowed.",
cell_files[i],files_found[cellidfile],cellid,cell_files[i]);

            not_while_running(thisparent,message,1566,"Error: Unexpected file in <CELLID>.zip",5);
			return 0;
		}
	 }
	 else 
	 {
        if(
			(cell_files[i][0]=='F')     &&
			(cell_files[i][1]=='C')     &&
			(cell_files[i][2]==MYCHARSLASH)
		  )
		{
          if (
		       (cell_files[i][len-1]=='l') &&
		       (cell_files[i][len-2]=='m') &&
		       (cell_files[i][len-3]=='x') &&
		       (cell_files[i][len-4]=='.')
			 )
		  {
            if(fcxmlfound>=0)
			{
              sprintf(message,"\
Error:  Too many XML files found in FC folder:\n\n\
in zipfile:  %s\n\
in folder:  FC\n\n\
Only one \".xml\" file is allowed in the \"FC\" folder, but multiple were found:\n\n\
  %s\n\
     and\n\
  %s\n",files_found[cellidfile],cell_files[i],cell_files[fcxmlfound]);


          not_while_running(thisparent,message,1563,"Error: Too many XML files in FC folder",5);
          return 0;

			}
			else
			{
              fcxmlfound = i;

printf("COMPARE  XMLSFC %s to fcxml %s\n",XMLSFC,cell_files[fcxmlfound]);

			  

              sprintf(buf,"%s",&cell_files[fcxmlfound][3]);

			  if(strcmp(XMLSFC,buf))
			  {
                 sprintf(message,"\
Error:  SFC found in folder \"FC\":\n\
  %s\n\
does not match the SFCATR from the cell XML:\n\
  %s\n\
found in the cell XML:",buf,XMLSFC);

                 not_while_running(thisparent,message,1581,"Error: Mismatched SFC",5);
                 return 0;
			  }
			}
		  }
          else if (
		            (cell_files[i][len-1]=='s') &&
		            (cell_files[i][len-2]=='l') &&
		            (cell_files[i][len-3]=='x') &&
		            (cell_files[i][len-4]=='.')
			      )
		  {
            if(fcxlsfound>=0)
			{
              sprintf(message,"\
Error:  Too many XLS files found in FC folder:\n\n\
in zipfile:  %s\n\
in folder:  FC\n\n\
Only one \".xls\" file is allowed in the \"FC\" folder, but multiple were found:\n\n\
  %s\n\
     and\n\
  %s\n",files_found[cellidfile],cell_files[i],cell_files[fcxlsfound]);


          not_while_running(thisparent,message,1564,"Error: Too many XLS files in FC folder",5);
          return 0;
			}
			else
			{
              fcxlsfound = i;
			}
		  } 
		  else
		  {
              sprintf(message,"\
Error:  Unexpected file in FC folder:\n\n\
  %s\n\n\
in zipfile:  %s\n\
in folder:  FC\n\n\
Only one \".xml\" file and one optional \".xls\" file are allowed in the \"FC\" folder.\n\
The file \"%s\" is not allowed.",
&cell_files[i][3],files_found[cellidfile],&cell_files[i][3]);

            not_while_running(thisparent,message,1565,"Error: Unexpected file in FC folder",5);
            return 0;
		  }
		} 
		else
		{
          

          bad = 0;

          len = strlen(cell_files[i]);

          if((len==10)||(len==12))
		  {


			

			if(
                ((cell_files[i][0]!='P')&&(cell_files[i][0]!='A')&&(cell_files[i][0]!='L')) ||
				((cell_files[i][1]<'A')||(cell_files[i][1]>'Z'))                            ||
				((cell_files[i][2]<'A')||(cell_files[i][2]>'Z'))                            ||
				((cell_files[i][3]<'0')||(cell_files[i][3]>'9'))                            ||
				((cell_files[i][4]<'0')||(cell_files[i][4]>'9'))                            ||
				((cell_files[i][5]<'0')||(cell_files[i][5]>'9'))
			  )
			{
              bad = 1;
			}
            else if(len==12)
			{
              if(cell_files[i][6]!='_')
			  { 
                bad = 1;
			  } 
              if((cell_files[i][7]<'1')||(cell_files[i][7]>'9'))
			  { 
                bad = 1;
			  } 
			} 


            if(bad==0)
			  {
                exten = 0;
				if(
					(cell_files[i][len-4]=='.') &&
					(cell_files[i][len-3]=='s') &&
					(cell_files[i][len-2]=='h') &&
					(cell_files[i][len-1]=='p')
			      )
				{
                  exten = 1;
				}
				if( 
					(cell_files[i][len-4]=='.') &&
					(cell_files[i][len-3]=='s') &&
					(cell_files[i][len-2]=='h') &&
					(cell_files[i][len-1]=='x')
			      )
				{
                  exten = 2;
				}
				if( 
					(cell_files[i][len-4]=='.') &&
					(cell_files[i][len-3]=='d') &&
					(cell_files[i][len-2]=='b') &&
					(cell_files[i][len-1]=='f')
			      )
				{
                  exten = 3;
				}
				
				if(exten==0)
				{
                  bad = 1;
				}
				else
				{
                  

				  sprintf(buf,"%s",cell_files[i]);
				  sprintf(cmd2,"%s",cell_files[i]);

				  foundfirst  = 0;
				  foundsecond = 0;

				  if(exten==1) 
				  {
                    buf [len-3] = 'd';
                    buf [len-2] = 'b';
                    buf [len-1] = 'f';
                    cmd2[len-3] = 's';
                    cmd2[len-2] = 'h';
                    cmd2[len-1] = 'x';
				  }
				  else if(exten==2) 
				  {
                    buf [len-3] = 'd';
                    buf [len-2] = 'b';
                    buf [len-1] = 'f';
                    cmd2[len-3] = 's';
                    cmd2[len-2] = 'h';
                    cmd2[len-1] = 'p';
				  }
				  else if(exten==3) 
				  {
                    buf [len-3] = 's';
                    buf [len-2] = 'h';
                    buf [len-1] = 'p';
                    cmd2[len-3] = 's';
                    cmd2[len-2] = 'h';
                    cmd2[len-1] = 'x';
				  }

                  for(j=0;j<num_cellfiles;j++)
				  { 
                    if(!strcmp(cell_files[j],buf))
					{
                      foundfirst = 1;
					}
                    else if(!strcmp(cell_files[j],cmd2))
					{
                      foundsecond = 1;
					}
					if((foundfirst+foundsecond)==2)
					{
                      break;
					}
				  }

				  if(foundfirst==0)
				  {
                    sprintf(message,"\
Error:\n\n\
Found shapefile component:\n\
  %s\n\
in zipfile: %s\n\n\
But did not find corresponding file:\n\
  %s\n\n\
Note that these names are case-sensitive.\n\
  ",cell_files[i],files_found[cellidfile],buf);

				  }
				  else if(foundsecond==0)
				  {
                     sprintf(message,"\
Error:\n\n\
Found shapefile component:\n\
  %s\n\
in zipfile: %s\n\n\
But did not find corresponding file:\n\
  %s\n\n\
Note that these names are case-sensitive.\n\
  ",cell_files[i],files_found[cellidfile],cmd2);
				  }

				  if((foundfirst==0)||(foundsecond==0))
				  {
                    not_while_running(thisparent,message,1570,buf,5);
                    return 0;
				  }
				}
			  }
		  }
		  else
		  {
            bad = 1;
		  }


		  if((len!=10)&&(len!=12))
		  {
            bad = 1;
            printf(" Shapefile: %s\n",cell_files[i]);
		  }

		  if(bad==1)
		  {
            sprintf(message,"\
Error:  Unexpected file in zipfile %s:\n\n\
Unexpected file: %s\n\n\
The only files allowed in %s are:\n\n\
 * Shapefiles (of the form [PAL][FCODE]{_n}.[shp,shx,dbf])\n\
  (ie, PAL015.dbf, AAL015_2.dbf, etc)\n\
 * %s\n\
 * An \"FC\" folder (containing one \".xml\" file and one optional \".xls\" file)\n\n\
Note that these names are case-sensitive.",
            files_found[cellidfile],cell_files[i],files_found[cellidfile],cell_files[foundxml]);

			sprintf(buf,"Error: Unexpected file in %s",files_found[cellidfile]);

            not_while_running(thisparent,message,1567,buf,5);
            return 0;
		  }
		}
	 } 
  } 




  if((DP_TRD_TYPE<4)&&(fcxmlfound<0)) 
  {
	 




	 if(
		 (strcmp(XMLSFC,"MGCP_FeatureCatalogue_TRD1.0_20051231.xml")) &&
		 (strcmp(XMLSFC,"MGCP_FeatureCatalogue_TRD1.1_20061019.xml")) &&
		 (strcmp(XMLSFC,"MGCP_FeatureCatalogue_TRD2.0_20070328.xml")) &&
		 (strcmp(XMLSFC,"MGCP_FeatureCatalogue_TRD2.0_20070425.xml")) &&
		 (strcmp(XMLSFC,"MGCP_FeatureCatalogue_TRD3.0_20091103.xml"))
	   )
	 {
       sprintf(message,"\
Error:  No \"FC\" folder found in %s,\n\
indicating a SFC is not being used.\n\n\
However, the cell XML:\n\
  %s\n\
which is inside:\n\
  %s\n\
has SFCATR:\n\
 %s\n\
which indicates a SFC with that name is being used.",files_found[cellidfile],cell_files[foundxml],files_found[cellidfile],XMLSFC);

       not_while_running(thisparent,message,1582,"Error: SFC in XML but no FC folder",5);

       return 0;
	 }

  }


  



  


  if(verbose==0)
  {
    return 1;
  }

  if(topxmlfile>=0)
  {
    sprintf(message,"\
The folder:\n\
%s\n\n\
has been found to contain correctly packaged MGCP data for cell: %s%s",folder,cellid,warning1);

    not_while_running(thisparent,message,1548,"MGCP Packaging Correct",5);
  }
  else
  {
    if(USE_DOS==1)
	{
      sprintf(message,"\
The folder:\n\
%s\n\n\
has been found to contain correctly packaged MGCP data for cell: %s\n\n\
Note: The optional XML file at the toplevel was not found:\n\
 %s\\%s.xml%s",folder,cellid,folder,cellid,warning1);

      not_while_running(thisparent,message,1547,"MGCP Packaging Correct/No Optional XML",5);
	}
	else
	{
      sprintf(message,"\
The folder:\n\
%s\n\n\
has been found to contain correctly packaged MGCP data for cell: %s\n\n\
Note: The optional XML file at the toplevel was not found:\n\
 %s/%s.xml%s",folder,cellid,folder,cellid,warning1);

      not_while_running(thisparent,message,1547,"MGCP Packaging Correct/No Optional XML",5);
	}
  }


  for(i=0;i<num_files;i++)
  {
    free(files_found[i]);
  }

  for(i=0;i<num_reportfiles;i++)
  {
    free(report_files[i]);
  }

  for(i=0;i<num_cellfiles;i++)
  {
    free(cell_files[i]);
  }

  return 1;

}



void TestUTF()
{
  int i;

  unsigned char message[][200]=
  {
	  {76, 0xC2, 0xA2,             73},
	  {76, 0xE2, 0x82, 0xAC,       73},
	  {76, 0xF0, 0xA4, 0xAD, 0xA2, 73},
	  {76, 0xC2, 0xA2,    0xE2, 0x82, 0xAC,    0xF0, 0xA4, 0xAD, 0xA2,    73},

	  {0x6F, 0x6c, 0x92, 0x73, 0x68},
	  {0x92},

	  {76, 0xC0,  73},
  	  {76, 0xF0, 0xA4, 0xAD, 73},
  	  {76, 0xF0, 0xA4},


	  {0x41, 0xE2,0x89,0xA2,   0xCE,0x91,0x2E },
	  {0xED,0x95,0x9C,  0xEA,0xB5,0xAD,  0xEC,0x96,0xB4},
	  {0xE6,0x97,0xA5,  0xE6,0x9C,0xAC,  0xE8,0xAA,0x9E},
	  {0xEF,0xBB,0xBF,  0xF0,0xA3,0x8E,0xB4},
	  {0xF0,0xA3,0x8E,0xB4,  0xEF,0xBB,0xBF},

	  {0xc0, 0xaf                         },
	  {0xe0, 0x80, 0xaf                   }, 
	  {0xf0, 0x80, 0x80, 0xaf             },
	  {0xf8, 0x80, 0x80, 0x80, 0xaf       },
	  {0xfc, 0x80, 0x80, 0x80, 0x80, 0xaf },

	  {0xc1, 0xbf,                        },
	  {0xe0, 0x9f, 0xbf,                  }, 
	  {0xf0, 0x8f, 0xbf, 0xbf,            },  
	  {0xf8, 0x87, 0xbf, 0xbf, 0xbf       },  
	  {0xfc, 0x83, 0xbf, 0xbf, 0xbf, 0xbf },  

	  {0xC0, 0x8A                         },
	  {0xE0, 0x80, 0x8A                   },
	  {0xF0, 0x80, 0x80, 0x8A             },
	  {0xF8, 0x80, 0x80, 0x80, 0x8A       },
	  {0xFC, 0x80, 0x80, 0x80, 0x80, 0x8A }

  };

  char message2[][200]=
  {
	  {"cent symbol"},
	  {"euro symbol"},
	  {"chinese symbol"},
	  {"cent,euro,chinese symbol"},
	  {"Jorgen problem"},
	  {"Jorgen problem smaller"},
      {"Illegal char C0"},
	  {"byte present but not required continuation byte"},
	  {"required continuation byte not even present"},
	  {"A <not equal to> <alpha> ."},
	  {"the korean language"},
	  {"the japanese language"},
	  {"BOM then chinese stump of tree"},
	  {"chinese stump of tree then BOM"},
	  {"overlong 1"},
	  {"overlong 2"},
	  {"overlong 3"},
	  {"overlong 4"},
	  {"overlong 5"},
	  {"overlong 6"},
	  {"overlong 7"},
	  {"overlong 8"},
	  {"overlong 9"},
	  {"overlong 10"},
	  {"overlong 11"},
	  {"overlong 12"},
	  {"overlong 13"},
	  {"overlong 14"},
	  {"overlong 15"}   

  };

#define num_tests 29

  extern int GoodUTF (const unsigned char *instring,int record_num,char *attr_name,char *shape_to_import);


  for(i=0;i<num_tests;i++)
  {
    printf("trying (%s) %s\n",message2[i],message[i]);
    printf("...%d\n",GoodUTF(message[i],15,"SPECIAL","NO_SHAPEFILE"));
  }

}



void ListFonts()
{
  FILE *ptr;
  char cmd[1000],buf[1000];

  sprintf(cmd,"xlsfonts");
  
  if((ptr=POPEN(cmd,"r"))!=NULL)
  {
    while(fgets(buf,1000,ptr)!=NULL)
	{ 
	  if(strstr(buf,"10646"))
	  {
	    printf("%s",buf);
	  }
	}
  }	 
}


void TestVV()
{
  FILE *infile;
  char filename[1000],aline[1000],bline[1000],cline[1000];
  int i,thisint,insertindex,maxint=-1,foundunique=0,found[10000];
  extern char outattrdirectory[1000];

  extern int ShapeTestVV;

  if(ShapeTestVV==0)
  {
    return;
  }

  for(i=0;i<10000;i++)
  {
    found[i] = 0;
  }


  sprintf(filename,"%sDependencyErr.txt",outattrdirectory);

  infile = fopen(filename,"r");
  if(infile==NULL)
  {
    printf("could not open %s\n",filename);
  }

  fgets(aline,1000,infile);

  while(!feof(infile))
  {
    if(strstr(aline,"Feature identifier:"))
	{
      
	  sprintf(bline,"%s",&aline[20]);
	  
	  sscanf(bline,"%d",&thisint);
	  if(thisint>maxint)
	  {
        maxint = thisint;
	  }
	  
	  found[thisint] = found[thisint] + 1;
	}
	else if(strstr(aline,"Feature identifiers:"))
	{
      
	  sprintf(bline,"%s",&aline[22]);
	  

	  insertindex = 0;
	  for(i=0;i<(int)strlen(bline);i++)
	  {
        if((bline[i]>='0')&&(bline[i]<='9'))
		{
          cline[insertindex] = bline[i];
		  insertindex = insertindex + 1;
		}
		else
		{
		  if(insertindex>0)
		  {
            cline[insertindex] = '\0';
            
            sscanf(cline,"%d",&thisint);
            if(thisint>maxint)
			{
              maxint = thisint;
			} 
            
            found[thisint] = found[thisint] + 1;
		  }
		  insertindex = 0;
		}
	  }
	}
    fgets(aline,1000,infile);
  }
  fclose(infile);


  printf("Max featureid found: %d\n",maxint);
  for(i=0;i<=maxint;i++)
  {
    if(found[i]==0)
	{
      printf("did not find %d\n",i);
	}
	else if(found[i]>0)
	{
      if(found[i]>1)
	  {
		printf("found %d for %d\n",found[i],i);
	  }
	  foundunique = foundunique + 1;
	}
  }

  printf("found %d total unique\n",foundunique);
}




int GetTimeValues(int *year, int *month, int *day)
{
  long int thistime = time(NULL);
  char all[200],MonthChar[100],DayChar[100],junk[100],YearChar[100];
  int DayInt,MonthInt,YearInt;

  sprintf(all,"%s",ctime(&thistime));
 
  sscanf(all,"%s%s%s%s%s",DayChar,MonthChar,DayChar,junk,YearChar);

  sscanf(DayChar,"%d",&DayInt);
  if((DayInt>=1)&&(DayInt<=31))
  {
    *day = DayInt;
  }
  else
  {
    return 0;
  }


  if(!strcmp(MonthChar,"Jan"))      { MonthInt = 1; }
  else if(!strcmp(MonthChar,"Feb")) { MonthInt = 2; }
  else if(!strcmp(MonthChar,"Mar")) { MonthInt = 3; }
  else if(!strcmp(MonthChar,"Apr")) { MonthInt = 4; }
  else if(!strcmp(MonthChar,"May")) { MonthInt = 5; }
  else if(!strcmp(MonthChar,"Jun")) { MonthInt = 6; }
  else if(!strcmp(MonthChar,"Jul")) { MonthInt = 7; }
  else if(!strcmp(MonthChar,"Aug")) { MonthInt = 8; }
  else if(!strcmp(MonthChar,"Sep")) { MonthInt = 9; }
  else if(!strcmp(MonthChar,"Oct")) { MonthInt = 10; }
  else if(!strcmp(MonthChar,"Nov")) { MonthInt = 11; }
  else if(!strcmp(MonthChar,"Dec")) { MonthInt = 12; }
  else
  {
    return 0;
  }
  *month = MonthInt;


  sscanf(YearChar,"%d",&YearInt);
  *year = YearInt;

  

  return 1;
}









#define IAE_num 355

  char *IAE[IAE_num]=
  {



    "Aqueduct (BH010),,,ACC,CDA,LOC,NFN,NFI",
    ",,,Accurate,Unknown,Unknown,Any Text String,Any Text String",
    ",FUN,Fully Functional,,x,x,,",
    ",NAM,N/A,,,,x,x",
    ",NAM,UNK,,,,x,x",
    ",NAM,N_A,,,,x,x",
    ",NAM,OTH,,,,x,x",
    ",LOC,Below Ground Surface,x,,,,",





    "Berthing Structure (BB190),,,WLE,,,,,,,,,,,,,,,,,,,,,,",
    ",,,Always Submerged,,,,,,,,,,,,,,,,,,,,,,",
    ",FUN,Fully Functional,x,,,,,,,,,,,,,,,,,,,,,,",





    "Bridge (AQ040),,,WD1,WD1,WD1,WD1,WD1,VOI,TRS,TRS,TRS,TRS,TRS,TRS,NFN,NFI,MCC,MCC,MCC,MCC,MCC,MCC,MCC,MCC,MCC,MCC,MCC",
    ",,,Null/Empty,Unknown,Not Applicable,Other,Any Real Value,Any Text String,Unknown,Aeronautical,Canal,Maritime,Railway,Not Applicable,Any Text String,Any Text String,Asphalt,Brick,Clay,Gravel,Macadam,Masonry,Pebbles,Rubble,Sand,Soil,Stone",
    ",BSC,Unknown,,,,,,,,,,,,x,,,x,,x,x,x,,x,x,x,x,",
    ",BSC,Open Spandrel Arch,,,,,,,,,,,,x,,,x,,x,x,x,,x,x,x,x,",
    ",BSC,Cantilever,,,,,,,,,,,,x,,,x,x,x,x,x,x,x,x,x,x,x",
    ",BSC,Deck,,,,,,,,,,,,x,,,x,,x,x,x,,x,x,x,x,",
    ",BSC,Floating,,,,,,,,x,x,x,x,x,,,x,x,x,x,x,x,x,x,x,x,x",
    ",BSC,Girder,,,,,,,,,,,,x,,,x,x,x,x,x,x,x,x,x,x,x",
    ",BSC,Tower Suspension,,,,,,,,,,,x,x,,,x,x,x,x,x,x,x,x,x,x,x",
    ",BSC,Truss,,,,,,,,,,,,x,,,x,x,x,x,x,x,x,x,x,x,x",
    ",BSC,Suspension,,,,,,,,,,,x,x,,,x,x,x,x,x,x,x,x,x,x,x",
    ",BSC,Transporter,,,,,,,,,,,x,x,,,x,x,x,x,x,x,x,x,x,x,x",
    ",BSC,Slab,,,,,,,,,,,,x,,,x,x,x,x,x,x,x,x,x,x,x",
    ",BSC,Stringer Beam,,,,,,,,,,,,x,,,x,x,x,x,x,x,x,x,x,x,x",
    ",BSC,Bowstring-bridge,,,,,,,,,,,x,x,,,x,x,x,x,x,x,x,x,x,x,x",
    ",BSC,Closed Spandrel Arch,,,,,,,,,,,,x,,,x,,x,x,x,,x,x,x,x,",
    ",BSC,Cable Stayed,,,,,,,,,,,x,x,,,x,x,x,x,x,x,x,x,x,x,x",
    ",BSC,Other,,,,,,,,,,,,x,,,x,,x,x,x,,x,x,x,x,",
    ",FUN,Fully Functional,,,,,,,x,,,,,,,,,,,,,,,,,,",
    ",NAM,N/A,,,,,,,,,,,,,x,x,,,,,,,,,,,",
    ",NAM,UNK,,,,,,,,,,,,,x,x,,,,,,,,,,,",
    ",NAM,N_A,,,,,,,,,,,,,x,x,,,,,,,,,,,",
    ",NAM,OTH,,,,,,,,,,,,,x,x,,,,,,,,,,,",
    ",OHB,-32768.0,,,,,,x,,,,,,,,,,,,,,,,,,,",
    ",OHB,-32767.0,,,,,,x,,,,,,,,,,,,,,,,,,,",
    ",OHB,-32765.0,,,,,,x,,,,,,,,,,,,,,,,,,,",
    ",OHB,-32764.0,,,,,,x,,,,,,,,,,,,,,,,,,,",
    ",TRS,Unknown,x,,x,x,x,,,,,,,,,,,,,,,,,,,,",
    ",TRS,Aeronautical,x,x,,x,x,,,,,,,,,,,,,,,,,,,,",
    ",TRS,Aqueduct,x,x,,x,x,,,,,,,,,,,,,,,,,,,,",
    ",TRS,Bus,,,x,,,,,,,,,,,,,,,,,,,,,,",
    ",TRS,Canal,x,x,,x,x,,,,,,,,,,,,,,,,,,,,",
    ",TRS,Maritime,x,x,,x,x,,,,,,,,,,,,,,,,,,,,",
    ",TRS,Pedestrian,x,x,,x,x,,,,,,,,,,,,,,,,,,,,",
    ",TRS,Pipeline,x,x,,x,x,,,,,,,,,,,,,,,,,,,,",
    ",TRS,Road,,,x,,,,,,,,,,,,,,,,,,,,,,",
    ",TRS,Not Applicable,x,x,,x,x,,,,,,,,,,,,,,,,,,,,",
    ",TRS,Other,,,x,,,,,,,,,,,,,,,,,,,,,,",



    "General Building (AL015),,,VOI,NFN,NFI,HWT,HWT,HWT,HWT,HWT,HWT,HWT,HWT,HWT,HWT,HWT,HWT,HWT,HWT,HWT,HWT,,,,",
    ",,,Any Text String,Any Text String,Any Text String,Unknown,Cathedral,Chapel,Church,Marabout,Minaret,Religious Community,Mosque,Pagoda,Shrine,Tabernacle,Temple,Synagogue,Stupa,Not Applicable,Other,,,,",
    ",FFN,Unknown,,,,,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,,,,",
    ",FFN,Agriculture,,,,x,x,x,x,x,x,x,x,x,x,x,x,x,x,,x,,,,",
    ",FFN,Manufacturing,,,,x,x,x,x,x,x,x,x,x,x,x,x,x,x,,x,,,,",
    ",FFN,Oil-mill,,,,x,x,x,x,x,x,x,x,x,x,x,x,x,x,,x,,,,",
    ",FFN,Grain Milling,,,,x,x,x,x,x,x,x,x,x,x,x,x,x,x,,x,,,,",
    ",FFN,Sawmilling,,,,x,x,x,x,x,x,x,x,x,x,x,x,x,x,,x,,,,",
    ",FFN,Paper-mill,,,,x,x,x,x,x,x,x,x,x,x,x,x,x,x,,x,,,,",
    ",FFN,Petroleum Refining,,,,x,x,x,x,x,x,x,x,x,x,x,x,x,x,,x,,,,",
    ",FFN,Steel Mill,,,,x,x,x,x,x,x,x,x,x,x,x,x,x,x,,x,,,,",
    ",FFN,Motor Vehicle Manufacture,,,,x,x,x,x,x,x,x,x,x,x,x,x,x,x,,x,,,,",
    ",FFN,General Repair,,,,x,x,x,x,x,x,x,x,x,x,x,x,x,x,,x,,,,",
    ",FFN,Aircraft Repair,,,,x,x,x,x,x,x,x,x,x,x,x,x,x,x,,x,,,,",
    ",FFN,Motor Vehicle Repair,,,,x,x,x,x,x,x,x,x,x,x,x,x,x,x,,x,,,,",
    ",FFN,Utilities,,,,x,x,x,x,x,x,x,x,x,x,x,x,x,x,,x,,,,",
    ",FFN,Power Generation,,,,x,x,x,x,x,x,x,x,x,x,x,x,x,x,,x,,,,",
    ",FFN,Cooling,,,,x,x,x,x,x,x,x,x,x,x,x,x,x,x,,x,,,,",
    ",FFN,Water Treatment,,,,x,x,x,x,x,x,x,x,x,x,x,x,x,x,,x,,,,",
    ",FFN,Commerce,,,,x,x,x,x,x,x,x,x,x,x,x,x,x,x,,x,,,,",
    ",FFN,Petrol Sale,,,,x,x,x,x,x,x,x,x,x,x,x,x,x,x,,x,,,,",
    ",FFN,Market,,,,x,x,x,x,x,x,x,x,x,x,x,x,x,x,,x,,,,",
    ",FFN,Transport,,,,x,x,x,x,x,x,x,x,x,x,x,x,x,x,,x,,,,",
    ",FFN,Terminal,,,,x,x,x,x,x,x,x,x,x,x,x,x,x,x,,x,,,,",
    ",FFN,Signalling,,,,x,x,x,x,x,x,x,x,x,x,x,x,x,x,,x,,,,",
    ",FFN,Pumping,,,,x,x,x,x,x,x,x,x,x,x,x,x,x,x,,x,,,,",
    ",FFN,Maritime Pilotage,,,,x,x,x,x,x,x,x,x,x,x,x,x,x,x,,x,,,,",
    ",FFN,Harbour Control,,,,x,x,x,x,x,x,x,x,x,x,x,x,x,x,,x,,,,",
    ",FFN,Warehousing and Storage,,,,x,x,x,x,x,x,x,x,x,x,x,x,x,x,,x,,,,",
    ",FFN,Motor Vehicle Parking,,,,x,x,x,x,x,x,x,x,x,x,x,x,x,x,,x,,,,",
    ",FFN,Postal Activities,,,,x,x,x,x,x,x,x,x,x,x,x,x,x,x,,x,,,,",
    ",FFN,Accommodation,,,,x,x,x,x,x,x,,x,x,x,x,x,x,x,,x,,,,",
    ",FFN,Residence,,,,x,x,x,x,x,x,,x,x,x,x,x,x,x,,x,,,,",
    ",FFN,Restaurant,,,,x,x,x,x,x,x,x,x,x,x,x,x,x,x,,x,,,,",
    ",FFN,Print Publishing,,,,x,x,x,x,x,x,x,x,x,x,x,x,x,x,,x,,,,",
    ",FFN,Radio Broadcasting,,,,x,x,x,x,x,x,x,x,x,x,x,x,x,x,,x,,,,",
    ",FFN,Television Broadcasting,,,,x,x,x,x,x,x,x,x,x,x,x,x,x,x,,x,,,,",
    ",FFN,Telecommunications,,,,x,x,x,x,x,x,x,x,x,x,x,x,x,x,,x,,,,",
    ",FFN,Satellite Ground Control,,,,x,x,x,x,x,x,x,x,x,x,x,x,x,x,,x,,,,",
    ",FFN,Retail Banking,,,,x,x,x,x,x,x,x,x,x,x,x,x,x,x,,x,,,,",
    ",FFN,Scientific Research and Development,,,,x,x,x,x,x,x,x,x,x,x,x,x,x,x,,x,,,,",
    ",FFN,Observation Station,,,,x,x,x,x,x,x,x,x,x,x,x,x,x,x,,x,,,,",
    ",FFN,Weather Station,,,,x,x,x,x,x,x,x,x,x,x,x,x,x,x,,x,,,,",
    ",FFN,Wind Tunnel,,,,x,x,x,x,x,x,x,x,x,x,x,x,x,x,,x,,,,",
    ",FFN,Guard,,,,x,x,x,x,x,x,x,x,x,x,x,x,x,x,,x,,,,",
    ",FFN,Administration,,,,x,x,x,x,x,x,x,x,x,x,x,x,x,x,,x,,,,",
    ",FFN,Government,,,,x,x,x,x,x,x,x,x,x,x,x,x,x,x,,x,,,,",
    ",FFN,Palace,,,,x,x,x,x,x,x,x,x,x,x,x,x,x,x,,x,,,,",
    ",FFN,Diplomacy,,,,x,x,x,x,x,x,x,x,x,x,x,x,x,x,,x,,,,",
    ",FFN,Embassy,,,,x,x,x,x,x,x,x,x,x,x,x,x,x,x,,x,,,,",
    ",FFN,Defence Activities,,,,x,x,x,x,x,x,x,x,x,x,x,x,x,x,,x,,,,",
    ",FFN,Law Enforcement,,,,x,x,x,x,x,x,x,x,x,x,x,x,x,x,,x,,,,",
    ",FFN,Imprisonment,,,,x,x,x,x,x,x,x,x,x,x,x,x,x,x,,x,,,,",
    ",FFN,Firefighting,,,,x,x,x,x,x,x,x,x,x,x,x,x,x,x,,x,,,,",
    ",FFN,Education,,,,x,x,x,x,x,x,,x,x,x,x,x,x,x,,x,,,,",
    ",FFN,Higher Education,,,,x,x,x,x,x,x,x,x,x,x,x,x,x,x,,x,,,,",
    ",FFN,Institution,,,,x,x,x,x,x,x,,x,x,x,x,x,x,x,,x,,,,",
    ",FFN,Human Health Activities,,,,x,x,x,x,x,x,x,x,x,x,x,x,x,x,,x,,,,",
    ",FFN,In-patient Care,,,,x,x,x,x,x,x,x,x,x,x,x,x,x,x,,x,,,,",
    ",FFN,Social Work,,,,x,x,x,x,x,x,,x,x,x,x,x,x,x,,x,,,,",
    ",FFN,Theatre,,,,x,x,x,x,x,x,x,x,x,x,x,x,x,x,,x,,,,",
    ",FFN,Auditorium,,,,x,x,x,x,x,x,,x,x,x,x,x,x,x,,x,,,,",
    ",FFN,Community Centre,,,,x,x,x,x,x,x,,x,x,x,x,x,x,x,,x,,,,",
    ",FFN,Opera House,,,,x,x,x,x,x,x,x,x,x,x,x,x,x,x,,x,,,,",
    ",FFN,Library,,,,x,x,x,x,x,x,x,x,x,x,x,x,x,x,,x,,,,",
    ",FFN,Museum,,,,x,x,x,x,x,x,x,x,x,x,x,x,x,x,,x,,,,",
    ",FFN,Sports Centre,,,,x,x,x,x,x,x,x,x,x,x,x,x,x,x,,x,,,,",
    ",FFN,Animal Boarding,,,,x,x,x,x,x,x,x,x,x,x,x,x,x,x,,x,,,,",
    ",FFN,Religious Activities,,,,,,,,,,,,,,,,,,x,,,,,",
    ",FFN,Place of Worship,,,,,,,,,,,,,,,,,,x,,,,,",
    ",FFN,Yacht-club,,,,x,x,x,x,x,x,x,x,x,x,x,x,x,x,,x,,,,",
    ",FFN,Other,,,,x,x,x,x,x,x,x,x,x,x,x,x,x,x,,x,,,,",
    ",HGT,Null/Empty,x,,,,,,,,,,,,,,,,,,,,,,",
    ",HGT,Unknown,x,,,,,,,,,,,,,,,,,,,,,,",
    ",HGT,Not Applicable,x,,,,,,,,,,,,,,,,,,,,,,",
    ",HGT,Other,x,,,,,,,,,,,,,,,,,,,,,,",
    ",NAM,N/A,,x,x,,,,,,,,,,,,,,,,,,,,",
    ",NAM,UNK,,x,x,,,,,,,,,,,,,,,,,,,,",
    ",NAM,N_A,,x,x,,,,,,,,,,,,,,,,,,,,",
    ",NAM,OTH,,x,x,,,,,,,,,,,,,,,,,,,,",
    "Cableway (AT041),,,VOI,NFN,NFI,FUC,FUC,FUC,FUC,,,,,,,,,,,,,,,,",
    ",,,Any Text String,Any Text String,Any Text String,Unknown,Recreational,Transportation,Other,,,,,,,,,,,,,,,,",
    ",CAT,Chair-lift,,,,x,,,x,,,,,,,,,,,,,,,,",
    ",CAT,Aerial Tramway,,,,x,,,x,,,,,,,,,,,,,,,,",
    ",CAT,Gondola Lift,,,,x,,,x,,,,,,,,,,,,,,,,",
    ",CAT,Industrial Ropeway,,,,x,x,x,,,,,,,,,,,,,,,,,",
    ",CAT,Material Tramway,,,,x,x,,,,,,,,,,,,,,,,,,",
    ",CAT,Not Applicable,,,,x,x,x,x,,,,,,,,,,,,,,,,",
    ",CAT,Other,,,,x,,,,,,,,,,,,,,,,,,,",
    ",HGT,Null/Empty,x,,,,,,,,,,,,,,,,,,,,,,",
    ",HGT,Unknown,x,,,,,,,,,,,,,,,,,,,,,,",
    ",HGT,Not Applicable,x,,,,,,,,,,,,,,,,,,,,,,",
    ",HGT,Other,x,,,,,,,,,,,,,,,,,,,,,,",
    ",NAM,N/A,,x,x,,,,,,,,,,,,,,,,,,,,",
    ",NAM,UNK,,x,x,,,,,,,,,,,,,,,,,,,,",
    ",NAM,N_A,,x,x,,,,,,,,,,,,,,,,,,,,",
    ",NAM,OTH,,x,x,,,,,,,,,,,,,,,,,,,,",



    "Canal (BH020),,,CDA,HYP,HYP,HYP,HYP,NFN,NFI,,,,,,,,,,,,,,,,,",
    ",,,Unknown,Unknown,Perennial,Intermittent,Dry,Any Text String,Any Text String,,,,,,,,,,,,,,,,,",
    ",FUN,Unknown,,,x,x,x,,,,,,,,,,,,,,,,,,,",
    ",FUN,Under Construction,,x,,x,,,,,,,,,,,,,,,,,,,,",
    ",FUN,Abandoned,,x,,x,,,,,,,,,,,,,,,,,,,,",
    ",FUN,Destroyed,,x,,x,,,,,,,,,,,,,,,,,,,,",
    ",FUN,Dismantled,,x,,x,,,,,,,,,,,,,,,,,,,,",
    ",FUN,Fully Functional,x,x,,x,x,,,,,,,,,,,,,,,,,,,",
    ",FUN,Damaged,,x,,x,,,,,,,,,,,,,,,,,,,,",
    ",NAM,N/A,,,,,,x,x,,,,,,,,,,,,,,,,,",
    ",NAM,UNK,,,,,,x,x,,,,,,,,,,,,,,,,,",
    ",NAM,N_A,,,,,,x,x,,,,,,,,,,,,,,,,,",
    ",NAM,OTH,,,,,,x,x,,,,,,,,,,,,,,,,,",


    "Cart Track (AP010),,,NFN,NFI,,,,,,,,,,,,,,,,,,,,,",
    ",,,Any Text String,Any Text String,,,,,,,,,,,,,,,,,,,,,",
    ",NAM,N/A,x,x,,,,,,,,,,,,,,,,,,,,,",
    ",NAM,UNK,x,x,,,,,,,,,,,,,,,,,,,,,",
    ",NAM,N_A,x,x,,,,,,,,,,,,,,,,,,,,,",
    ",NAM,OTH,x,x,,,,,,,,,,,,,,,,,,,,,",


    "Causeway Structure (AQ063),,,WLE,WLE,WLE,WLE,WLE,WLE,WLE,WLE,,,,,,,,,,,,,,,",
    ",,,Unknown,Partly Submerged,Always Dry,Always Submerged,Covers and Uncovers,Floating,Not Applicable,Other,,,,,,,,,,,,,,,",
    ",TRS,Unknown,,,,,,,x,,,,,,,,,,,,,,,,",
    ",TRS,Aeronautical,x,x,x,x,x,x,x,x,,,,,,,,,,,,,,,",
    ",TRS,Aqueduct,x,x,x,x,x,x,x,x,,,,,,,,,,,,,,,",
    ",TRS,Bus,,,,,,,x,,,,,,,,,,,,,,,,",
    ",TRS,Canal,x,x,x,x,x,x,x,x,,,,,,,,,,,,,,,",
    ",TRS,Maritime,x,x,x,x,x,x,x,x,,,,,,,,,,,,,,,",
    ",TRS,Pedestrian,,,,,,,x,,,,,,,,,,,,,,,,",
    ",TRS,Pipeline,,,,,,,x,,,,,,,,,,,,,,,,",
    ",TRS,Railway,x,x,,x,x,x,x,x,,,,,,,,,,,,,,,",
    ",TRS,Road,,,,,,,x,,,,,,,,,,,,,,,,",
    ",TRS,Not Applicable,,,,,,,x,,,,,,,,,,,,,,,,",
    ",TRS,Other,,,,,,,x,,,,,,,,,,,,,,,,",
    "Crane (AF040),,,VOI,CRM,CRM,CRM,,,,,,,,,,,,,,,,,,,",
    ",,,Any Text String,Unknown,Fixed,Floating,,,,,,,,,,,,,,,,,,,",
    ",CRA,Bridge Crane,,x,x,x,,,,,,,,,,,,,,,,,,,",
    ",CRA,Container Crane,,x,x,x,,,,,,,,,,,,,,,,,,,",
    ",HGT,Null/Empty,x,,,,,,,,,,,,,,,,,,,,,,",
    ",HGT,Unknown,x,,,,,,,,,,,,,,,,,,,,,,",
    ",HGT,Not Applicable,x,,,,,,,,,,,,,,,,,,,,,,",
    ",HGT,Other,x,,,,,,,,,,,,,,,,,,,,,,",


    "Crop Land (EA010),,,CSP,CSP,DMT,DMT,DMT,DMT,FFP,,,,,,,,,,,,,,,,,,,,",
    ",,,Tea,Cotton,Null/Empty,Unknown,Not Applicable,Other,Regular,,,,,,,,,,,,,,,,,,,,",
    ",FMM,Fallow,x,,,,,,,,,,,,,,,,,,,,,,,,,,",
    ",FMM,Slash and Burn,x,x,,,,,x,,,,,,,,,,,,,,,,,,,,",
    ",FFP,Intermingled Trees,,,x,x,x,x,,,,,,,,,,,,,,,,,",





    "Extraction Mine (AA010),,,PPO,PPO,PPO,PPO,PPO,PPO,PPO,PPO,PPO,PPO,PPO,PPO,PPO,PPO,PPO,NFN,NFI,,,,,,",
    ",,,Unknown,Bauxite,Coal,Copper,Diamond,Gold,Iron,Lead,Manganese,Quartz,Salt,Silver,Uranium,Zinc,Other,Any Text String,Any Text String,,,,,,",
    ",MZN,Placer,,x,x,x,,,x,x,,x,x,x,x,x,,,,,,,,,",
    ",MZN,Peatery,x,x,x,x,x,x,x,x,x,x,x,x,x,x,,,,,,,,,",
    ",NAM,N/A,,,,,,,,,,,,,,,,x,x,,,,,,",
    ",NAM,UNK,,,,,,,,,,,,,,,,x,x,,,,,,",
    ",NAM,N_A,,,,,,,,,,,,,,,,x,x,,,,,,",
    ",NAM,OTH,,,,,,,,,,,,,,,,x,x,,,,,,",


    "Facility (AL010),,,NFN,NFI,,,,,,,,,,,,,,,,,,,,,",
    ",,,Any Text String,Any Text String,,,,,,,,,,,,,,,,,,,,,",
    ",NAM,N/A,x,x,,,,,,,,,,,,,,,,,,,,,",
    ",NAM,UNK,x,x,,,,,,,,,,,,,,,,,,,,,",
    ",NAM,N_A,x,x,,,,,,,,,,,,,,,,,,,,,",
    ",NAM,OTH,x,x,,,,,,,,,,,,,,,,,,,,,",

    "Groin (BB043),,,WID,,,,,,,,,,,,,",
    ",,,Unknown,,,,,,,,,,,,,",
    ",FUN,Fully Functional,x,,,,,,,,,,,,,",


    "Land Water Boundary (BA010),,,ACC,,,,,,,,,,,,,,,,,,,,,,",
    ",,,Accurate,,,,,,,,,,,,,,,,,,,,,,",
    ",SLT,Mangrove,x,,,,,,,,,,,,,,,,,,,,,,",
    "Mangrove Swamp (ED030),,,NFN,NFI,,,,,,,,,,,,,,,,,,,,,",
    ",,,Any Text String,Any Text String,,,,,,,,,,,,,,,,,,,,,",
    ",NAM,N/A,x,x,,,,,,,,,,,,,,,,,,,,,",
    ",NAM,UNK,x,x,,,,,,,,,,,,,,,,,,,,,",
    ",NAM,N_A,x,x,,,,,,,,,,,,,,,,,,,,,",
    ",NAM,OTH,x,x,,,,,,,,,,,,,,,,,,,,,",

    
    "Orchard (EA040),,,NFN,NFI,,,,,,,,,,,,,,,,,,,,,",
    ",,,Any Text String,Any Text String,,,,,,,,,,,,,,,,,,,,,",
    ",NAM,N/A,x,x,,,,,,,,,,,,,,,,,,,,,",
    ",NAM,UNK,x,x,,,,,,,,,,,,,,,,,,,,,",
    ",NAM,N_A,x,x,,,,,,,,,,,,,,,,,,,,,",
    ",NAM,OTH,x,x,,,,,,,,,,,,,,,,,,,,,",
	
	"Railway (AN010),,,RWC,RWC,RWC,RTA,RTA,RTA,RTA,RRC,RRC,RRC,RRC,NFN,NFI,LTN,LTN,GAW,GAW,,,,,,",
    ",,,High Speed Rail,Main Line,Branch-line,Single Arrangement,Double Arrangement,Multiple Arrangements,Juxtaposition,Carline,Underground Railway,Tramway,Funicular,Any Text String,Any Text String,Not Applicable,Other,Unknown,Any Real Value,,,,,,",
    ",FUN,Dismantled,,,,,,,,,,,,,,,,x,x,,,,,,",
    ",GAW,Any Real Value,,,,,,,,,,,,,,x,x,,,,,,,,",
    ",LOC,Unknown,,,,,,,,x,x,x,x,,,,,,,,,,,,",
    ",LOC,Below Ground Surface,,,,,,,,x,,x,x,,,,,,,,,,,,",
    ",LOC,On Surface,,,,,,,,,x,,,,,,,,,,,,,,",
    ",LOC,Above Surface,,,,,,,,,x,,,,,,,,,,,,,,",
    ",LTN,Unknown,,,,x,x,x,x,,,,,,,,,,,,,,,,",
    ",NAM,N/A,,,,,,,,,,,,x,x,,,,,,,,,,",
    ",NAM,UNK,,,,,,,,,,,,x,x,,,,,,,,,,",
    ",NAM,N_A,,,,,,,,,,,,x,x,,,,,,,,,,",
    ",NAM,OTH,,,,,,,,,,,,x,x,,,,,,,,,,",
    ",RGC,Narrow,x,,,,,,,,,,,,,,,,,,,,,,",
    ",RIR,Unknown,,,,,,,,,x,x,,,,,,,,,,,,,",
    ",RIR,Separated from road,,,,,,,,,,x,,,,,,,,,,,,,",
    ",RIR,In road,,,,,,,,,x,,,,,,,,,,,,,,",
    ",RRC,Carline,x,x,,,,,,,,,,,,,,,,,,,,,",
    ",RRC,Logging,x,x,,,,,,,,,,,,,,,,,,,,,",
    ",RRC,Tramway,x,x,,,,,,,,,,,,,,,,,,,,,",
    ",RRC,Funicular,x,x,,,,,,,,,,,,,,,,,,,,,",
    ",RRC,Automated Transit System,x,x,,,,,,,,,,,,,,,,,,,,,",
    ",RRC,Long-haul,,,x,,,,,,,,,,,,,,,,,,,,",


    "Railway Sidetrack (AN050),,,RSA,GAW,GAW,,,,,,,,,,,,,,,,,,,,,",
    ",,,Unknown,Unknown,Any Real Value,,,,,,,,,,,,,,,,,,,,,",
    ",FUN,Dismantled,,x,x,,,,,,,,,,,,,,,,,,,,,",
    ",FUN,Fully Functional,x,,,,,,,,,,,,,,,,,,,,,,,",


    "Recreational Pier (AK190),,,NFN,NFI,,,,,,,,,,,,,,,,,,,,,",
    ",,,Any Text String,Any Text String,,,,,,,,,,,,,,,,,,,,,",
    ",NAM,N/A,x,x,,,,,,,,,,,,,,,,,,,,,",
    ",NAM,UNK,x,x,,,,,,,,,,,,,,,,,,,,,",
    ",NAM,N_A,x,x,,,,,,,,,,,,,,,,,,,,,",
    ",NAM,OTH,x,x,,,,,,,,,,,,,,,,,,,,,",

    "Reef (BD120),,,WLE,NFN,NFI,,,,,,,,,,,,,,,,,,,,",
    ",,,Unknown,Any Text String,Any Text String,,,,,,,,,,,,,,,,,,,,",
    ",COD,Limits and Information Known,x,,,,,,,,,,,,,,,,,,,,,,",
    ",NAM,N/A,,x,x,,,,,,,,,,,,,,,,,,,,",
    ",NAM,UNK,,x,x,,,,,,,,,,,,,,,,,,,,",
    ",NAM,N_A,,x,x,,,,,,,,,,,,,,,,,,,,",
    ",NAM,OTH,,x,x,,,,,,,,,,,,,,,,,,,,",

    "River (BH140),,,CDA,CDA,HYP,HYP,HYP,HYP,NFN,NFI,TID,TID,,,,,,,,,,,,,",
    ",,,Unknown,Covered,Unknown,Perennial,Intermittent,Dry,Any Text String,Any Text String,Unknown,Tidal/Tidal Fluctuating,,,,,,,,,,,,,",
    ",WST,Unknown,,,,,,,,,,x,,,,,,,,,,,,,",
    ",WST,Dissipating,,,,,,,,,,x,,,,,,,,,,,,,",
    ",WST,Disappearing,,,,,,,,,,x,,,,,,,,,,,,,",
    ",WST,Other,,,,,,,,,,x,,,,,,,,,,,,,",       
    ",WCC,Wadi,x,x,x,x,,,,,x,x,,,,,,,,,,,,,",
    ",TID,Unknown,,,,,x,x,,,,,,,,,,,,,,,,,",
    ",TID,Tidal/Tidal Fluctuating,,,x,,x,x,,,,,,,,,,,,,,,,,",
    ",NAM,N/A,,,,,,,x,x,,,,,,,,,,,,,,,",
    ",NAM,UNK,,,,,,,x,x,,,,,,,,,,,,,,,",
    ",NAM,N_A,,,,,,,x,x,,,,,,,,,,,,,,,",
    ",NAM,OTH,,,,,,,x,x,,,,,,,,,,,,,,,",


    "Road (AP030),,,WTC,WTC,WTC,WTC,WTC,WD1,WD1,WD1,WD1,RST,RST,RST,NFN,NFI,MES,LTN,LOC,LOC,,,,,,",
    ",,,Unknown,All-weather,Fair-weather,Winter Only,Closed in Winter,Unknown,Not Applicable,Other,Any Real Value,Unknown,Loose/Unpaved,Temporary,Any Text String,Any Text String,With Median,Unknown,Unknown,On Waterbody Bottom,,,,,,",
    ",FUN,Under Construction,,,,,,,x,x,,,,,,,,,,,,,,,,",
    ",FUN,Fully Functional,,,,,,x,,,,,,,,,,x,,,,,,,,",
    ",SEP,Present,,,,,,,,,,,,,,,,,,x,,,,,,",
    ",HCT,Primary Route,x,,,x,x,,,,,,,x,,,,,,,,,,,,",
    ",HCT,National Motorway,x,,x,x,x,,,,,x,x,x,,,,,x,x,,,,,,",
    ",LOC,On Waterbody Bottom,,,,,,,,,,,,,,,x,,,,,,,,,",
    ",NAM,N/A,,,,,,,,,,,,,x,x,,,,,,,,,,",
    ",NAM,UNK,,,,,,,,,,,,,x,x,,,,,,,,,,",
    ",NAM,N_A,,,,,,,,,,,,,x,x,,,,,,,,,,",
    ",NAM,OTH,,,,,,,,,,,,,x,x,,,,,,,,,,",
    ",RST,Hard/Paved,x,,x,x,,,,,,,,,,,,,,,,,,,,",
    ",RST,Loose/Unpaved,,,,x,,,,,,,,,,,,,,,,,,,,",
    ",RST,Temporary,x,x,,x,x,,,,,,,,,,,,,,,,,,,",

    "Sand Dunes (DB170),,,NFN,NFI,SDO,SDO,SDO,SDO,,,,,,,,,,,,,,,,,",
    ",,,Any Text String,Any Text String,Null/Empty,Unknown,Other,Any Real Value,,,,,,,,,,,,,,,,,",
    ",SDT,Dome,,,x,x,x,x,,,,,,,,,,,,,,,,,",
    ",SDT,Star,,,x,x,x,x,,,,,,,,,,,,,,,,,",
    ",NAM,N/A,x,x,,,,,,,,,,,,,,,,,,,,,",
    ",NAM,UNK,x,x,,,,,,,,,,,,,,,,,,,,,",
    ",NAM,N_A,x,x,,,,,,,,,,,,,,,,,,,,,",
    ",NAM,OTH,x,x,,,,,,,,,,,,,,,,,,,,,",

    "Swamp (ED020),,,NFN,NFI,TID,TID,TRE,TRE,TRE,VEG,VEG,VEG,VEG,VEG,,,,,,,,,,,",
    ",,,Any Text String,Any Text String,Unknown,Non-Tidal,Unknown,Deciduous,Mixed,Unknown,Wood,Herb and Brush,Brush,Other,,,,,,,,,,,",
    ",VSP,Cypress,,,,,x,x,x,x,,x,x,x,,,,,,,,,,,",
    ",VSP,Nipa,,,x,x,x,x,x,x,x,,,x,,,,,,,,,,,",
    ",VSP,Other,,,,,x,,,,,,,,,,,,,,,,,,",
    ",NAM,N/A,x,x,,,,,,,,,,,,,,,,,,,,,",
    ",NAM,UNK,x,x,,,,,,,,,,,,,,,,,,,,,",
    ",NAM,N_A,x,x,,,,,,,,,,,,,,,,,,,,,",
    ",NAM,OTH,x,x,,,,,,,,,,,,,,,,,,,,,",
    "Transportation Station (AQ125),,,NFN,NFI,TUC,TUC,TUC,TUC,TUC,,,,,,,,,,,,,,,,",
    ",,,Any Text String,Any Text String,Unknown,Cargo,Passenger,General,Other,,,,,,,,,,,,,,,,",
    ",TRS,Bus,,,x,x,,,,,,,,,,,,,,,,,,,",
    ",TRS,Pedestrian,,,x,x,,x,x,,,,,,,,,,,,,,,,",
    ",TRS,Pipeline,,,x,x,x,x,,,,,,,,,,,,,,,,,",
    ",TRS,Not Applicable,,,x,x,x,x,x,,,,,,,,,,,,,,,,",
    ",NAM,N/A,x,x,,,,,,,,,,,,,,,,,,,,,",
    ",NAM,UNK,x,x,,,,,,,,,,,,,,,,,,,,,",
    ",NAM,N_A,x,x,,,,,,,,,,,,,,,,,,,,,",
    ",NAM,OTH,x,x,,,,,,,,,,,,,,,,,,,,,",
    "Tunnel (AQ130),,,NFN,NFI,,,,,,,,,,,,,,,,,,,,,",
    ",,,Any Text String,Any Text String,,,,,,,,,,,,,,,,,,,,,",
    ",NAM,N/A,x,x,,,,,,,,,,,,,,,,,,,,,",
    ",NAM,UNK,x,x,,,,,,,,,,,,,,,,,,,,,",
    ",NAM,N_A,x,x,,,,,,,,,,,,,,,,,,,,,",
    ",NAM,OTH,x,x,,,,,,,,,,,,,,,,,,,,,",


    "Well (AA050),,,WFT,WFT,WFT,WFT,WFT,WFT,SCC,SCC,SCC,SCC,SCC,SCC,SCC,PPO,PPO,PPO,PPO,PPO,NFN,NFI,,,",
    ",,,Unknown,Walled-in,Artesian,Dug,Drilled,Other,Unknown,Alkaline,Mineral,Potable,Salty,Not Applicable,Other,Unknown,Gas,Oil,Water,Multiple,Any Text String,Any Text String,,,",
    ",HYP,Unknown,,,,,,,,,,,,,,,x,x,,x,,,,,",
    ",HYP,Perennial,,,,,,,,,,,,,,x,x,x,,x,,,,,",
    ",HYP,Intermittent,,,,,,,,,,,,,,x,x,x,,x,,,,,",
    ",HYP,Dry,,,,,,,,,,,,,,x,x,x,,x,,,,,",
    ",HYP,Not Applicable,,,,,,,,,,,,,,x,,,x,,,,,,",
    ",NAM,N/A,,,,,,,,,,,,,,,,,,,x,x,,,",
    ",NAM,UNK,,,,,,,,,,,,,,,,,,,x,x,,,",
    ",NAM,N_A,,,,,,,,,,,,,,,,,,,x,x,,,",
    ",NAM,OTH,,,,,,,,,,,,,,,,,,,x,x,,,",
    ",PPO,Unknown,,,x,x,,,,x,x,x,x,x,x,,,,,,,,,,",
    ",PPO,Gas,,,x,x,,,x,x,x,x,x,,x,,,,,,,,,,",
    ",PPO,Oil,,,x,x,,,x,x,x,x,x,,x,,,,,,,,,,",
    ",PPO,Water,,,,,,,,,,,,x,,,,,,,,,,,",
    ",PPO,Multiple,,,x,x,,,x,x,x,x,x,,x,,,,,,,,,,",


    "Wood (EC030),,,NFN,NFI,TRE,TRE,TRE,,,,,,,,,,,,,,,,,,",
    ",,,Any Text String,Any Text String,Unknown,Deciduous,Mixed,,,,,,,,,,,,,,,,,,",
    ",VSP,Casuarina,,,,,x,,,,,,,,,,,,,,,,,,",
    ",VSP,Conifer,,,,x,x,,,,,,,,,,,,,,,,,,",
    ",VSP,Cypress,,,,x,x,,,,,,,,,,,,,,,,,,",
    ",VSP,Eucalyptus,,,,,x,,,,,,,,,,,,,,,,,,",
    ",VSP,Filao,,,,,x,,,,,,,,,,,,,,,,,,",
    ",VSP,Palm,,,,x,x,,,,,,,,,,,,,,,,,,",
    ",VSP,Umbrella Thorn,,,,,x,,,,,,,,,,,,,,,,,,",
    ",VSP,Other,,,x,,,,,,,,,,,,,,,,,,,,",
    ",NAM,N/A,x,x,,,,,,,,,,,,,,,,,,,,,",
    ",NAM,UNK,x,x,,,,,,,,,,,,,,,,,,,,,",
    ",NAM,N_A,x,x,,,,,,,,,,,,,,,,,,,,,",
    ",NAM,OTH,x,x,,,,,,,,,,,,,,,,,,,,,"
  };


















#define TDS_IAE_num 1015

  char *TDS_IAE[TDS_IAE_num]=
  {
"Aqueduct (BH010),,,SBB,SBB,RLE,RLE,RLE,RLE,RLE,LMC,LMC,CDA,CDA,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",,,No Information,True,No Information,Raised,Level,Depressed,Not Applicable,No Information,True,No Information,False,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",ATC,Underground,,X,X,X,X,X,,X,X,X,X,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",ATC,Underwater,,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",ATC,Surface,,,X,,,X,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",ATC,Qanat,,X,X,X,X,,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",CWT,No Information,,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",CWT,True,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",RLE,No Information,,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",RLE,Level,X,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",RLE,Depressed,X,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",RLE,Not Applicable,,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
"Bridge (AQ040),,,BOT,BOT,BOT,BOT,BOT,BOT,BOT,BOT,BOT,BSC,BSC,BSC,BSC,BSC,BSC,BSC,BSC,BSC,BSC,BSC,BSC,BSC,VCM,VCM,VCM,VCM,VCM,VCM,VCM,VCM,,,,,,,,",
",,,No Information,Bascule,Swing-Bridge,Lift-Bridge,Retractable,Submersible,Drawbridge,Opening,Other,Cantilever,Floating,Girder,Tower Suspension,Truss,Suspension,Transporter,Slab,Stringer Beam,Bowstring-bridge,Covered,Cable Stayed,Trestle,Aluminum,Brick,Iron,Masonry,Metal,Stone,Treated Timber,Wood,,,,,,,,",
",TRS,Aqueduct,,,,,,,,,,,X,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",TRS,Canal,,,,,,X,,,,,X,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",TRS,Pipeline,,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",TRS,Railway,,,,,,,,,,,,,X,,X,X,,,X,,X,,,,,,,,,,,,,,,,,",
",TRS,Taxiway,,X,X,X,X,X,X,X,,X,X,,X,X,X,X,,,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,",
",TRS,Runway,,X,X,X,X,X,X,X,,X,X,,X,X,X,X,,,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,",
",VCM,Aluminum,,,,,,,,,,,,X,X,,X,X,X,X,X,,X,,,,,,,,,,,,,,,,,",
",VCM,Brick,,X,X,X,X,X,X,X,,,,X,X,,X,X,X,X,X,,X,,,,,,,,,,,,,,,,,",
",VCM,Iron,,,,,,,,,,,,X,X,,X,X,X,X,X,,X,,,,,,,,,,,,,,,,,",
",VCM,Masonry,,X,X,X,X,X,X,X,,,,X,X,,X,X,X,X,X,,X,,,,,,,,,,,,,,,,,",
",VCM,Stone,,X,X,X,X,X,X,X,,,,X,X,,X,X,X,X,X,,X,,,,,,,,,,,,,,,,,",
",VCM,Treated Timber,,X,X,X,X,X,X,X,,,,X,X,,X,X,X,X,X,,X,,,,,,,,,,,,,,,,,",
",VCM,Wood,,X,X,X,X,X,X,X,,,,X,X,,X,X,X,X,X,,X,,,,,,,,,,,,,,,,,",
",BSC,No Information,,,,,,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",BSC,Open Spandrel Arch,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",BSC,Cantilever,,,,,,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",BSC,Floating,,X,X,X,,X,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",BSC,Tower Suspension,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",BSC,Truss,,,,,,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",BSC,Suspension,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",BSC,Transporter,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",BSC,Slab,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",BSC,Bowstring-bridge,,,,,,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",BSC,Covered,,,,,,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",BSC,Closed Spandrel Arch,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",BSC,Cable Stayed,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",BSC,Arch,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",BSC,Trestle,,X,,,,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",BSC,Other,,,,,,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
"Building (AL013),,,ZI037_RFA,ZI037_RFA,ZI037_RFA,ZI037_RFA,ZI037_RFA,ZI037_RFA,ZI037_RFA,ZI037_RFA,ZI037_RFA,ZI037_RFA,ZI037_RFA,ZI037_RFA,ZI037_RFA,ZI037_RFA,ZI037_RFA,ZI037_RFA,ZI037_RFA,ZI037_RFA,,,,,,,,,,,,,,,,,,,,",
",,,Cathedral,Chapel,Church,Marabout,Minaret,Mission,Mosque,Pagoda,Religious Community,Seminary,Shrine,Stupa,Synagogue,Tabernacle,Temple,Convent,Monastery,Noviciate,,,,,,,,,,,,,,,,,,,,",
",FFN,Agriculture,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Growing of Crops,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Raising of Animals,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Grazing,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Mixed Farming,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Hunting,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Forestry and/or Logging,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Silviculture,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Forest Warden,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Fishing,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Aquaculture,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Mining and Quarrying,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Solid Mineral Fuel Mining,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Petroleum and/or Gas Extraction,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Metal Ore Mining,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Chemical Mining,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Mineral Mining,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Gas Oil Separation,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Ore Dressing,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Manufacturing,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Food Product Manufacture,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Food Processing,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Meat Processing,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Seafood Processing,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Fruit and/or Vegetable Processing,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Oil-mill,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Grain Milling,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Baking,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Sugar Manufacture,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Sugar Milling,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Sugar Refining,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Confection Manufacture,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Pasta Manufacture,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Prepared Meal Manufacture,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Animal Feed Manufacture,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Ice Manufacture,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Beverage Manufacture,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Spirit Distillery,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Winery,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Brewing,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Soft Drink Manufacture,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Tobacco Product Manufacture,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,\"Textile, Apparel and Leather Manufacture\",X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Textile Manufacture,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Apparel Manufacture,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Leather Product Manufacture,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Footwear Manufacturing,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Wood-based Manufacturing,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Sawmilling,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Wooden Construction Product Manufacture,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Paper-mill,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Printing,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Petroleum and Coal Products Manufacturing,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Coke Manufacture,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Petroleum Refining,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Chemical Manufacture,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Medicinal Product Manufacture,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Rubber Product Manufacture,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Plastic Product Manufacture,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Nonmetallic Mineral Product Manufacturing,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Glass Product Manufacture,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Refractory Product Manufacture,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Clay Product Manufacture,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Ceramic Product Manufacture,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Cement Mill,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Cement Product Manufacture,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Stone Product Manufacture,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Primary Metal Manufacturing,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Steel Mill,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Metal Refining,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Foundry,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Metal Product Manufacturing,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Structural Metal Product Manufacture,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Munitions Manufacture,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Fabricated Metal Product Manufacture,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Electronic Equipment Manufacture,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Electrical Equipment Manufacture,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Machinery Manufacture,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Transportation Equipment Manufacturing,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Motor Vehicle Manufacture,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Ship Construction,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Railway Vehicle Manufacture,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Aircraft Manufacture,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Military Vehicle Manufacture,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Furniture Manufacture,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Miscellaneous Manufacturing,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Jewellery Manufacture,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Musical Instrument Manufacture,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Sports Goods Manufacture,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Game and/or Toy Manufacture,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Medical and/or Dental Equipment Manufacture,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,General Repair,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Fabricated Metal Product Repair,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Electronic Equipment Repair,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Electrical Equipment Repair,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Machinery Repair,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Ship Repair,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Aircraft Repair,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Railway Vehicle Repair,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Motor Vehicle Repair,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Utilities,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Power Generation,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Climate Control,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Cooling,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Heating,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Water Supply,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Water Collection,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Water Treatment,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Water Distribution,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Sewerage,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Sewerage Screening,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Restroom,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Waste Treatment and Disposal,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Materials Recovery,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Commerce,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Wholesale Merchant,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Retail Sale,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Specialized Store,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Non-specialized Store,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Convenience Store,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Petrol Sale,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Propane Sale,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Sales Yard,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Precious Metal Merchant,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Market,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Grocery,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Pharmacy,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Pet-shop,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Transport,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Terminal,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Station,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Stop,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Transfer Hub,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Signalling,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Transport System Maintenance,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Navigation,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Railway Transport,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Railway Passenger Transport,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Pedestrian Transport,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Road Transport,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Road Passenger Transport,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Road Freight Transport,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Pipeline Transport,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Pumping,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Water Transport,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Inland Waters Transport,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Canal Transport,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Port Control,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Maritime Pilotage,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Pilot Station,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Harbour Control,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Air Transport,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Air Traffic Control,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Transportation Support,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Warehousing and Storage,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Motor Vehicle Parking,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Cargo Handling,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Customs Checkpoint,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Inspection Station,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Inspection,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Postal Activities,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Short-term Accommodation,X,X,X,X,X,,X,X,,,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,,,,",
",FFN,Long-term Accommodation,X,X,X,X,X,,X,X,,,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,,,,",
",FFN,Accommodation,X,X,X,X,X,,X,X,,,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,,,,",
",FFN,Hotel,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Resort,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Motel,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Guest-house,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Hostel,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Dormitory,X,X,X,X,X,,X,X,,,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,,,,",
",FFN,Vacation Cottage,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Dependents Housing,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Communal Bath,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Residence,X,X,X,X,X,,X,X,,,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,,,,",
",FFN,Food Service,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Restaurant,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Bar,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Dining Hall,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Banquet Hall,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Convention Centre,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Publishing and Broadcasting,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Print Publishing,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Cinema,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Radio Broadcasting,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Television Broadcasting,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Telecommunications,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Retail Telecommunications,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Wired Telecommunications,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Main Telephone Exchange,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Branch Telephone Exchange,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Wired Repeater,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Wireless Telecommunications,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Mobile Phone Service,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Wireless Repeater,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Satellite Telecommunications,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Satellite Ground Control,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Information Service,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Public Records,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Financial Services,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Central Banking,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Retail Banking,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Insurance,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Financial Market Administration,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Security Brokerage,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Fund Management,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Real Estate Activities,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,\"Professional, Scientific and Technical\",X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Legal Activities,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Accounting,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Head Office,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Business Management,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Architecture Consulting,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Engineering Design,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Surveying,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Scientific Research and Development,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Observation Station,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Weather Station,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Nuclear Research Centre,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Wind Tunnel,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Advertising,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Photography,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Veterinary,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Business and Personal Support Services,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Motor Vehicle Rental,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Employment Agency,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Travel Agency,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Security Enforcement,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Guard,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Custodial Service,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Landscaping Service,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Office Administration,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Call Centre,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Public Administration,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Headquarters,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Administration,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Government,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Local Government,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Subnational Government,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,National Government,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Palace,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Capitol,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Executive Activities,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Legislative Activities,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Polling Station,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Civil Activities,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Diplomacy,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Diplomatic Mission,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Embassy,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Consul,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Maritime Defense,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,\"Public Order, Safety and Security Services\",X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Public Order,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Safety,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Security Services,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Defence Activities,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Armory,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Military Reserve Activities,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Military Recruitment,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,CBRNE Civilian Support,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Judicial Activities,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Law Enforcement,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Immigration Control,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Imprisonment,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Juvenile Corrections,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Firefighting,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Rescue and Paramedical Services,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Emergency Operations,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Civil Intelligence,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Education,X,X,X,X,X,,X,X,,,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,,,,",
",FFN,Primary Education,X,X,X,X,X,,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Secondary Education,X,X,X,X,X,,X,X,,,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,,,,",
",FFN,Higher Education,X,X,X,X,X,,X,X,,,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,,,,",
",FFN,Vocational Education,X,X,X,X,X,,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Institution,X,X,X,X,X,,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Human Health Activities,X,X,X,X,X,,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,In-patient Care,X,X,X,X,X,,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Out-patient Care,X,X,X,X,X,,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Urgent Medical Care,X,X,X,X,X,,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Human Tissue Repository,X,X,X,X,X,,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Public Health Activities,X,X,X,X,X,,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Leprosy Care,X,X,X,X,X,,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Intermediate Care,X,X,X,X,X,,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Psychiatric In-patient Care,X,X,X,X,X,,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Residential Care,X,X,X,X,X,,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Emergency Shelter,X,X,X,X,X,,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Homeless Shelter,X,X,X,X,X,,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Refugee Shelter,X,X,X,X,X,,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Emergency Youth Shelter,X,X,X,X,X,,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Day Care,X,X,X,X,X,,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Social Work,X,X,X,X,X,,X,X,,,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,,,,",
",FFN,Emergency Relief Services,X,X,X,X,X,,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,\"Cultural, Arts and Entertainment\",X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Theatre,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Auditorium,X,X,X,X,X,,X,X,,,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,,,,",
",FFN,Community Centre,X,X,X,X,X,,X,X,,,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,,,,",
",FFN,Opera House,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Night Club,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,\"Sports, Amusement and Recreation\",X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Library,X,X,X,X,X,,X,X,,,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,,,,",
",FFN,Museum,X,X,X,X,X,,X,X,,,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,,,,",
",FFN,Aquarium ,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Botanical and/or Zoological Reserve Activities,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Gambling,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Sports Centre,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Fitness Centre,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Shooting Range,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Animal Boarding,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Recreation,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Amusement,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Hobbies and/or Leisure Activities,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Islamic Prayer Hall,X,X,X,,,,,X,,,,X,X,X,,X,,,,,,,,,,,,,,,,,,,,,,",
",FFN,Membership Organization,X,X,X,X,X,X,X,X,,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Club,X,X,X,X,X,X,X,X,,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Yacht-club,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Laundry,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Beauty Treatment,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Funeral Services,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Cremation,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Mortuary Services,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Adult Entertainment,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Storage of Human Remains,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Meeting Place,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Death Care Services,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Other,X,X,X,X,X,X,X,X,,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",ZI037_REL,Buddhism,X,X,X,X,X,,X,,,,,,X,X,,X,,,,,,,,,,,,,,,,,,,,,,",
",ZI037_REL,Islam,X,X,X,,,,,X,,,,X,X,X,,X,,,,,,,,,,,,,,,,,,,,,,",
",ZI037_REL,Roman Catholic,,,,X,X,,X,X,,,,X,X,,,,,,,,,,,,,,,,,,,,,,,,,",
",ZI037_REL,Christian,,,,X,X,,X,X,,,,X,X,,,,,,,,,,,,,,,,,,,,,,,,,",
",ZI037_REL,Judaism,X,X,X,X,X,,X,X,,,,X,,X,,X,,,,,,,,,,,,,,,,,,,,,,",
",ZI037_REL,Orthodox,,,,X,X,,X,X,,,,X,X,,,,,,,,,,,,,,,,,,,,,,,,,",
",ZI037_REL,Protestant,,,,X,X,,X,X,,,,X,X,,,,,,,,,,,,,,,,,,,,,,,,,",
",ZI037_REL,Shinto,X,X,X,X,X,,X,,,,,X,X,X,,X,,,,,,,,,,,,,,,,,,,,,,",
",ZI037_REL,Hinduism,X,X,X,X,X,,X,,,,,X,X,X,,X,,,,,,,,,,,,,,,,,,,,,,",
",ZI037_REL,Shia,X,X,X,,,,,X,,,,X,X,X,,X,,,,,,,,,,,,,,,,,,,,,,",
",ZI037_REL,Sunni,X,X,X,,,,,X,,,,X,X,X,,X,,,,,,,,,,,,,,,,,,,,,,",
",ZI037_REL,Nestorian,,,,X,X,,X,X,,,,X,X,,,,,,,,,,,,,,,,,,,,,,,,,",
",ZI037_REL,Chaldean,,,,X,X,,X,X,,,,X,X,,,,,,,,,,,,,,,,,,,,,,,,,",
"Canal (BH020),,,LOC,LOC,LOC,SBB,SBB,RLE,RLE,RLE,RLE,RLE,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",,,No Information,Below Ground Surface,On Surface,No Information,True,No Information,Raised,Level,Depressed,Not Applicable,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",CWT,No Information,,,,,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",CWT,False,,X,,,,,,,,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",CWT,True,X,,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",RLE,No Information,,,,,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",RLE,Raised,,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",RLE,Level,,X,,X,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",RLE,Depressed,,X,,X,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
"Cart Track (AP010),,,LOC,LOC,LOC,LOC,SBB,SBB,RLE,RLE,RLE,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",,,No Information,On Waterbody Bottom,Below Ground Surface,On Surface,No Information,True,Raised,Level,Depressed,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",CWT,No Information,,,,,,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",CWT,False,,,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",CWT,True,X,X,,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",RLE,No Information,,,,,,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",RLE,Raised,,X,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",RLE,Level,,,X,,X,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",RLE,Depressed,,X,X,,X,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",ZI016_WTC,No Information,,,,,,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",ZI016_WTC,All-weather,,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",ZI016_WTC,Fair-weather,,,,,,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",ZI016_WTC,Winter Only,,,,,,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",ZI016_WTC,Limited All-weather,,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",ZI016_WTC,Closed in Winter,,,,,,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",ZI016_WTC,Other,,,,,,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",SBB,True,,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
"Extraction Mine (AA010),,,LOC,LOC,LOC,UMA,UMA,UMA,UMA,UMA,MZN,MZN,MZN,MZN,MZN,MZN,MZN,MZN,MZN,MZN,MZN,MZN,FFN,FFN,FFN,FFN,FFN,FFN,FFN,FFN,FFN,,,,,,,,,",
",,,No Information,Below Ground Surface,On Surface,No Information,Drift,Slop,Shaft,Not Applicable,No Information,Borrow-pit,Opencast,Placer,Prospect,Area Strip-mine,Peatery,Below Surface,Quarry,Contour Strip-mine,Dredge,Other,No Information,Mining and Quarrying,Solid Mineral Fuel Mining,Metal Ore Mining,Chemical Mining,Peat Extraction,Salt Extraction,Mineral Mining,Other,,,,,,,,,",
",PPO,No Information,,,,,,,,,,,,,,,X,,,,,,,,,,,X,X,,,,,,,,,,,",
",PPO,Basalt,,,,,,,,,,X,,X,,,X,,X,,X,,,,X,X,X,X,X,,,,,,,,,,,",
",PPO,Bauxite,,,,,,,,,,X,,X,,,X,,X,,X,,,,X,,X,X,X,X,,,,,,,,,,",
",PPO,Clay,,,,,,,,,,,,X,,,X,X,X,,,,,,X,X,X,X,X,,,,,,,,,,,",
",PPO,Coal,,,,,,,,,,X,,X,,,X,,X,,X,,,,,X,X,X,X,,,,,,,,,,,",
",PPO,Copper,,,,,,,,,,X,,X,,,X,,X,,X,,,,X,,X,X,X,X,,,,,,,,,,",
",PPO,Diamond,,,,,,,,,,X,,,,,X,,X,,X,,,,X,X,X,X,X,,,,,,,,,,,",
",PPO,Diatomaceous,,,,,,,,,,,,X,,,X,,X,,X,,,,X,X,X,X,X,,,,,,,,,,,",
",PPO,Dolomite,,,,,,,,,,X,,X,,,X,,X,,X,,,,X,X,X,X,X,,,,,,,,,,,",
",PPO,Gold,,,,,,,,,,X,,,,,X,,X,,X,,,,X,,X,X,X,X,,,,,,,,,,",
",PPO,Granite,,,,,,,,,,X,,X,,,X,,,,X,,,,X,X,X,X,X,,,,,,,,,,,",
",PPO,Gravel,,,,,,,,,,,,X,,,X,X,,,,,,,X,X,X,X,X,,,,,,,,,,,",
",PPO,Iron,,,,,,,,,,X,,X,,,X,,X,,X,,,,X,,X,X,X,X,,,,,,,,,,",
",PPO,Lead,,,,,,,,,,X,,X,,,X,,X,,X,,,,X,,X,X,X,X,,,,,,,,,,",
",PPO,Manganese,,,,,,,,,,X,,,,,X,,X,,X,,,,X,,,X,X,X,,,,,,,,,,",
",PPO,Marble,,,,,,,,,,X,,X,,,X,,,,X,,,,X,X,X,X,X,,,,,,,,,,,",
",PPO,Porphyry,,,,,,,,,,X,,X,,,X,,,,X,,,,X,X,X,X,X,,,,,,,,,,,",
",PPO,Pumice,,,,,,,,,,X,,X,,,X,,,,,,,,X,X,X,X,X,,,,,,,,,,,",
",PPO,Quartz,,,,,,,,,,,,X,,,X,,,,X,,,,X,X,X,X,X,,,,,,,,,,,",
",PPO,Rock,,,,,,,,,,,,X,,,X,,,,,,,,X,X,X,X,X,,,,,,,,,,,",
",PPO,Salt,,,,,,,,,,X,,X,,,X,,X,,X,,X,X,X,X,X,X,,X,X,,,,,,,,,",
",PPO,Sand,,,,,,,,,,,,X,,,X,X,,,,,,,X,X,X,X,X,X,,,,,,,,,,",
",PPO,Sandstone,,,,,,,,,,X,,X,,,X,,,,X,,,,X,X,X,X,X,,,,,,,,,,,",
",PPO,Silver,,,,,,,,,,X,,,,,X,,X,,X,,,,X,,X,X,X,X,,,,,,,,,,",
",PPO,Stone,,,,,,,,,,X,,X,,,X,,,,,,,,X,X,X,X,X,X,,,,,,,,,,",
",PPO,Travertine,,,,,,,,,,X,,X,,,X,,,,X,,,,X,X,X,X,X,,,,,,,,,,,",
",PPO,Uranium,,,,,,,,,,X,,X,,,X,,X,,X,,,,,,X,X,X,X,,,,,,,,,,",
",PPO,Zinc,,,,,,,,,,X,,X,,,X,,X,,X,,,,X,,X,X,X,X,,,,,,,,,,",
",PPO,Chalk,,,,,,,,,,X,,X,,,X,,,,X,,,,X,X,X,X,X,,,,,,,,,,,",
",PPO,Chromium,,,,,,,,,,X,,X,,,X,,X,,X,,,,X,,X,X,X,X,,,,,,,,,,",
",PPO,Nickel,,,,,,,,,,X,,X,,,X,,X,,X,,,,X,,X,X,X,X,,,,,,,,,,",
",PPO,Tin,,,,,,,,,,X,,X,,,X,,X,,X,,,,X,,X,X,X,X,,,,,,,,,,",
",PPO,Fluorite,,,,,,,,,,X,,X,,,X,,X,,X,,,,X,X,X,X,X,,,,,,,,,,,",
",PPO,Phosphate,,,,,,,,,,X,,X,,,X,,X,,X,,,,X,X,,X,X,X,,,,,,,,,,",
",PPO,Vanadium,,,,,,,,,,X,,X,,,X,,X,,X,,,,X,,X,X,X,X,,,,,,,,,,",
",PPO,Mica,,,,,,,,,,X,,X,,,X,,X,,X,,,,X,,X,X,X,X,,,,,,,,,,",
",PPO,Selenium,,,,,,,,,,X,,X,,,X,,X,,X,,,,X,X,X,X,X,,,,,,,,,,,",
",PPO,Other,,,,,,,,,,,,,,,,,,,,,,,,,,,X,,,,,,,,,,,",
",FFN,No Information,,,,,,,,,,,,,,,X,,,,,,,,,,,,,,,,,,,,,,,",
",FFN,Mining and Quarrying,,,,,,,,,,,,,,,X,,,,,,,,,,,,,,,,,,,,,,,",
",FFN,Solid Mineral Fuel Mining,,,,,,,,,,X,,,,,X,,X,,,,,,,,,,,,,,,,,,,,,",
",FFN,Metal Ore Mining,,,,,,,,,,X,,,,,X,,X,,,,,,,,,,,,,,,,,,,,,",
",FFN,Chemical Mining,,,,,,,,,,X,,,,,X,,X,,,,,,,,,,,,,,,,,,,,,",
",FFN,Peat Extraction,X,X,,X,X,X,X,,X,X,X,X,X,X,,X,X,X,X,X,,,,,,,,,,,,,,,,,,",
",FFN,Salt Extraction,,,,,,,,,,X,,X,,,X,,X,,X,,,,,,,,,,,,,,,,,,,",
",FFN,Mineral Mining,,,,,,,,,,X,,,,,X,,,,,,,,,,,,,,,,,,,,,,,",
",FFN,Other,,,,,,,,,,,,,,,X,,,,,,,,,,,,,,,,,,,,,,,",
",MZN,No Information,,,,X,X,X,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",MZN,Borrow-pit,,,,X,X,X,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",MZN,Opencast,,,,X,X,X,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",MZN,Placer,,,,X,X,X,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",MZN,Prospect,,,,X,X,X,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",MZN,Area Strip-mine,,,,X,X,X,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",MZN,Peatery,,,,X,X,X,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",MZN,Below Surface,X,,X,,,,,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",MZN,Quarry,,,,X,X,X,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",MZN,Contour Strip-mine,,,,X,X,X,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",MZN,Dredge,,,,X,X,X,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",MZN,Other,,,,X,X,X,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",UMA,No Information,,,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",UMA,Drift,X,,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",UMA,Slope,X,,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",UMA,Shaft,X,,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",UMA,Not Applicable,X,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
"Facility (AL010),,,ZI037_RFA,ZI037_RFA,ZI037_RFA,ZI037_RFA,ZI037_RFA,ZI037_RFA,ZI037_RFA,ZI037_RFA,ZI037_RFA,ZI037_RFA,ZI037_RFA,ZI037_RFA,ZI037_RFA,ZI037_RFA,ZI037_RFA,ZI037_RFA,ZI037_RFA,ZI037_RFA,ZI037_REL,ZI037_REL,ZI037_REL,ZI037_REL,ZI037_REL,ZI037_REL,ZI037_REL,ZI037_REL,ZI037_REL,ZI037_REL,,,,,,,,,,",
",,,Cathedral,Chapel,Church,Marabout,Minaret,Mission,Mosque,Pagoda,Religious Community,Seminary,Shrine,Stupa,Synagogue,Tabernacle,Temple,Convent,Monastery,Noviciate,Buddhism,Roman Catholic,Christian,Judaism,Orthodox,Protestant,Shinto,Hinduism,Nestorian,Chaldean,,,,,,,,,,",
",FFN,Agriculture,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Growing of Crops,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Raising of Animals,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Grazing,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Mixed Farming,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Hunting,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Forestry and/or Logging,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Silviculture,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Forest Warden,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Fishing,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Aquaculture,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Mining and Quarrying,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Solid Mineral Fuel Mining,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Petroleum and/or Gas Extraction,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Metal Ore Mining,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Chemical Mining,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Mineral Mining,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Gas Oil Separation,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Ore Dressing,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Manufacturing,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Food Product Manufacture,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Food Processing,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Meat Processing,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Seafood Processing,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Fruit and/or Vegetable Processing,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Oil-mill,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Grain Milling,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Baking,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Sugar Manufacture,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Sugar Milling,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Sugar Refining,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Confection Manufacture,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Pasta Manufacture,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Prepared Meal Manufacture,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Animal Feed Manufacture,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Ice Manufacture,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Beverage Manufacture,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Spirit Distillery,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Winery,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Brewing,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Soft Drink Manufacture,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Tobacco Product Manufacture,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,\"Textile, Apparel and Leather Manufacture\",X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Textile Manufacture,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Apparel Manufacture,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Leather Product Manufacture,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Footwear Manufacturing,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Wood-based Manufacturing,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Sawmilling,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Wooden Construction Product Manufacture,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Paper-mill,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Printing,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Petroleum and Coal Products Manufacturing,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Coke Manufacture,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Petroleum Refining,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Chemical Manufacture,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Medicinal Product Manufacture,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Rubber Product Manufacture,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Plastic Product Manufacture,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Nonmetallic Mineral Product Manufacturing,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Glass Product Manufacture,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Refractory Product Manufacture,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Clay Product Manufacture,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Ceramic Product Manufacture,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Cement Mill,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Cement Product Manufacture,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Stone Product Manufacture,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Primary Metal Manufacturing,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Steel Mill,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Metal Refining,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Foundry,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Metal Product Manufacturing,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Structural Metal Product Manufacture,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Munitions Manufacture,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Fabricated Metal Product Manufacture,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Electronic Equipment Manufacture,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Electrical Equipment Manufacture,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Machinery Manufacture,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Transportation Equipment Manufacturing,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Motor Vehicle Manufacture,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Ship Construction,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Railway Vehicle Manufacture,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Aircraft Manufacture,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Military Vehicle Manufacture,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Furniture Manufacture,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Miscellaneous Manufacturing,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Jewellery Manufacture,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Musical Instrument Manufacture,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Sports Goods Manufacture,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Game and/or Toy Manufacture,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Medical and/or Dental Equipment Manufacture,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,General Repair,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Fabricated Metal Product Repair,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Electronic Equipment Repair,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Electrical Equipment Repair,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Machinery Repair,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Ship Repair,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Aircraft Repair,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Railway Vehicle Repair,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Motor Vehicle Repair,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Utilities,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Power Generation,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Climate Control,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Cooling,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Heating,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Water Supply,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Water Collection,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Water Treatment,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Water Distribution,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Sewerage,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Sewerage Screening,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Restroom,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Waste Treatment and Disposal,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Materials Recovery,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Commerce,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Wholesale Merchant,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Retail Sale,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Specialized Store,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Non-specialized Store,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Convenience Store,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Petrol Sale,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Propane Sale,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Sales Yard,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Precious Metal Merchant,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Market,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Grocery,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Pharmacy,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Pet-shop,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Transport,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Terminal,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Station,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Stop,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Transfer Hub,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Signalling,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Transport System Maintenance,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Navigation,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Railway Transport,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Railway Passenger Transport,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Pedestrian Transport,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Road Transport,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Road Passenger Transport,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Road Freight Transport,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Pipeline Transport,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Pumping,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Water Transport,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Inland Waters Transport,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Canal Transport,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Port Control,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Maritime Pilotage,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Pilot Station,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Harbour Control,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Air Transport,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Air Traffic Control,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Transportation Support,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Warehousing and Storage,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Motor Vehicle Parking,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Cargo Handling,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Customs Checkpoint,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Inspection Station,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Inspection,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Postal Activities,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Short-term Accommodation,X,X,X,X,X,,X,X,,,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,,,,",
",FFN,Long-term Accommodation,X,X,X,X,X,,X,X,,,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,,,,",
",FFN,Accommodation,X,X,X,X,X,,X,X,,,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,,,,",
",FFN,Hotel,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Resort,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Motel,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Guest-house,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Hostel,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Dormitory,X,X,X,X,X,,X,X,,,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,,,,",
",FFN,Vacation Cottage,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Dependents Housing,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Communal Bath,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Residence,X,X,X,X,X,,X,X,,,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,,,,",
",FFN,Food Service,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Restaurant,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Bar,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Dining Hall,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Banquet Hall,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Convention Centre,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Publishing and Broadcasting,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Print Publishing,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Cinema,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Radio Broadcasting,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Television Broadcasting,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Telecommunications,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Retail Telecommunications,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Wired Telecommunications,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Main Telephone Exchange,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Branch Telephone Exchange,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Wired Repeater,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Wireless Telecommunications,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Mobile Phone Service,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Wireless Repeater,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Satellite Telecommunications,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Satellite Ground Control,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Information Service,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Public Records,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Financial Services,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Central Banking,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Retail Banking,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Insurance,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Financial Market Administration,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Security Brokerage,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Fund Management,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Real Estate Activities,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,\"Professional, Scientific and Technical\",X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Legal Activities,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Accounting,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Head Office,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Business Management,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Architecture Consulting,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Engineering Design,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Surveying,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Scientific Research and Development,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Observation Station,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Weather Station,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Nuclear Research Centre,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Wind Tunnel,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Advertising,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Photography,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Veterinary,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Business and Personal Support Services,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Motor Vehicle Rental,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Employment Agency,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Travel Agency,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Security Enforcement,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Guard,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Custodial Service,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Landscaping Service,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Office Administration,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Call Centre,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Public Administration,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Headquarters,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Administration,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Government,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Local Government,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Subnational Government,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,National Government,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Palace,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Capitol,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Executive Activities,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Legislative Activities,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Polling Station,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Civil Activities,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Diplomacy,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Diplomatic Mission,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Embassy,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Consul,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Maritime Defense,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,\"Public Order, Safety and Security Services\",X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Public Order,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Safety,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Security Services,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Defence Activities,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Armory,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Military Reserve Activities,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Military Recruitment,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,CBRNE Civilian Support,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Judicial Activities,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Law Enforcement,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Immigration Control,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Imprisonment,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Juvenile Corrections,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Firefighting,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Rescue and Paramedical Services,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Emergency Operations,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Civil Intelligence,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Education,X,X,X,X,X,,X,X,,,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,,,,",
",FFN,Primary Education,X,X,X,X,X,,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Secondary Education,X,X,X,X,X,,X,X,,,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,,,,",
",FFN,Higher Education,X,X,X,X,X,,X,X,,,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,,,,",
",FFN,Vocational Education,X,X,X,X,X,,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Institution,X,X,X,X,X,,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Human Health Activities,X,X,X,X,X,,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,In-patient Care,X,X,X,X,X,,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Out-patient Care,X,X,X,X,X,,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Urgent Medical Care,X,X,X,X,X,,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Human Tissue Repository,X,X,X,X,X,,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Public Health Activities,X,X,X,X,X,,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Leprosy Care,X,X,X,X,X,,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Intermediate Care,X,X,X,X,X,,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Psychiatric In-patient Care,X,X,X,X,X,,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Residential Care,X,X,X,X,X,,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Emergency Shelter,X,X,X,X,X,,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Homeless Shelter,X,X,X,X,X,,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Refugee Shelter,X,X,X,X,X,,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Emergency Youth Shelter,X,X,X,X,X,,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Day Care,X,X,X,X,X,,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Social Work,X,X,X,X,X,,X,X,,,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,,,,",
",FFN,Emergency Relief Services,X,X,X,X,X,,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,\"Cultural, Arts and Entertainment\",X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Theatre,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Auditorium,X,X,X,X,X,,X,X,,,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,,,,",
",FFN,Community Centre,X,X,X,X,X,,X,X,,,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,,,,",
",FFN,Opera House,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Night Club,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,\"Sports, Amusement and Recreation\",X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Library,X,X,X,X,X,,X,X,,,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,,,,",
",FFN,Museum,X,X,X,X,X,,X,X,,,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,,,,",
",FFN,Aquarium ,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Botanical and/or Zoological Reserve Activities,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Gambling,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Sports Centre,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Fitness Centre,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Shooting Range,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Animal Boarding,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Recreation,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Amusement,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Hobbies and/or Leisure Activities,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Islamic Prayer Hall,X,X,X,,,,,X,,,,X,X,X,,X,,,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,",
",FFN,Membership Organization,X,X,X,X,X,X,X,X,,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Club,X,X,X,X,X,X,X,X,,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Yacht-club,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Laundry,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Beauty Treatment,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Funeral Services,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Cremation,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Mortuary Services,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Adult Entertainment,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Storage of Human Remains,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Meeting Place,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Death Care Services,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Other,X,X,X,X,X,X,X,X,,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,",
",ZI037_REL,Buddhism,X,X,X,X,X,,X,,,,,,X,X,,X,,,,,,,,,,,,,,,,,,,,,,",
",ZI037_REL,Islam,X,X,X,,,,,X,,,,X,X,X,,X,,,,,,,,,,,,,,,,,,,,,,",
",ZI037_REL,Roman Catholic,,,,X,X,,X,X,,,,X,X,,,,,,,,,,,,,,,,,,,,,,,,,",
",ZI037_REL,Christian,,,,X,X,,X,X,,,,X,X,,,,,,,,,,,,,,,,,,,,,,,,,",
",ZI037_REL,Judaism,X,X,X,X,X,,X,X,,,,X,,X,,X,,,,,,,,,,,,,,,,,,,,,,",
",ZI037_REL,Orthodox,,,,X,X,,X,X,,,,X,X,,,,,,,,,,,,,,,,,,,,,,,,,",
",ZI037_REL,Protestant,,,,X,X,,X,X,,,,X,X,,,,,,,,,,,,,,,,,,,,,,,,,",
",ZI037_REL,Shinto,X,X,X,X,X,,X,,,,,X,X,X,,X,,,,,,,,,,,,,,,,,,,,,,",
",ZI037_REL,Hinduism,X,X,X,X,X,,X,,,,,X,X,X,,X,,,,,,,,,,,,,,,,,,,,,,",
",ZI037_REL,Shia,X,X,X,,,,,X,,,,X,X,X,,X,,,,,,,,,,,,,,,,,,,,,,",
",ZI037_REL,Sunni,X,X,X,,,,,X,,,,X,X,X,,X,,,,,,,,,,,,,,,,,,,,,,",
",ZI037_REL,Nestorian,,,,X,X,,X,X,,,,X,X,,,,,,,,,,,,,,,,,,,,,,,,,",
",ZI037_REL,Chaldean,,,,X,X,,X,X,,,,X,X,,,,,,,,,,,,,,,,,,,,,,,,,",
"Inland Waterbody (BH082),,,MNS,MNS,MNS,IWT,IWT,IWT,IWT,IWT,IWT,IWT,DMD,DMD,AZC,AZC,TID,TID,YWQ,YWQ,FFN,FFN,FFN,FFN,FFN,FFN,FFN,FFN,FFN,,,,,,,,,,,",
",,,No Information,False,True,Lake,Pond,Undifferentiated Water Body,Reservoir,Basin,Water-hole,Landlocked Sea,No Information,True,No Information,True,False,True,Potable,Contaminated,Fishing,Aquaculture,Power Generation,Water Collection,Commerce,Navigation,Water Transport,Recreation,Yacht-club,,,,,,,,,,,",
",ZI024_HYP,Intermittent,,,,,,,,,,,,,,,,,,,,X,,,,,,,X,,,,,,,,,,,",
",ZI024_HYP,Dry,,,,,,,,,,,,X,,,,X,X,,X,X,X,X,X,X,X,X,X,,,,,,,,,,,",
",FFN,Water Collection,,,,,,,,,,X,,,,,,,,X,,,,,,,,,,,,,,,,,,,,",
",FFN,Commerce,,,,,,,,,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",FFN,Navigation,,,,,,,,X,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",FFN,Water Transport,,,,,,,,X,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",FFN,Recreation,,,,,,,,,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",FFN,Yacht-club,,,,,,,,X,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",ZI024_SCC,Alkaline,,,,,,,X,X,X,X,,,,,,,X,,,,,,,,,,,,,,,,,,,,,",
",ZI024_SCC,Mineral,,,,,,,,,,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",ZI024_SCC,Saline,,,,,,,X,X,X,,,,,,,,X,,,,,,,,,,,,,,,,,,,,,",
",ZI024_SCC,Fresh,,,,,,,,,,X,,,,,,X,,,,,,,,,,,,,,,,,,,,,,",
",ZI024_SCC,Brackish,,,,,,,X,,X,,,,,,,,X,,,,,,,,,,,,,,,,,,,,,",
",ZI024_SCC,Seawater,,,,X,X,X,X,X,X,,,,,,X,,X,,,,,,,,,,,,,,,,,,,,,",
",ZI024_SCC,Brine,,,,,,,X,X,X,,,,,,,,X,,,,,,,,,,,,,,,,,,,,,",
",ZI024_SCC,Not Applicable,,,,,,,X,,,X,,,,,,,X,,,,,,,,,,,,,,,,,,,,,",
",YWQ,Potable,,,,,,,,,,X,,,,,,X,,,,,,,,,,,,,,,,,,,,,,",
",TID,No Information,,,,X,X,X,X,X,X,X,,X,,X,,,,,,,,,,,,,,,,,,,,,,,,",
",TID,True,,,,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,,,,,",
",AZC,No Information,,,X,,,,X,X,X,X,,X,,,,,,,,,,,,,,,,,,,,,,,,,,",
",AZC,False,,,X,,,,X,X,,,,X,,,,,,,,,,,,,,,,,,,,,,,,,,",
",AZC,True,,,,,,,,,X,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",DMD,No Information,,,,,,,X,,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",DMD,False,,,,,,,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",DMD,True,,,,,,,,,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",IWT,Lake,X,,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",IWT,Pond,X,,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",IWT,Basin,X,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",IWT,Water-hole,X,,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",IWT,Landlocked Sea,X,,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
"Penstock (BH110),,,SPT,SPT,LOC,LOC,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",,,No Information,True,Below Ground Surface,Above Surface,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",RLE,Raised,,,X,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",RLE,Level,,,X,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",RLE,Depressed,,,X,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",LOC,Below Ground Surface,X,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
"Pipeline (AQ113),,,OWO,OWO,SBB,SBB,SBB,SPT,SPT,RLE,RLE,RLE,RLE,FLO,FLO,RTA,RTA,RTA,RTA,RTA,CWT,,,,,,,,,,,,,,,,,,,",
",,,No Information,True,No Information,False,True,No Information,True,No Information,Raised,Level,Depressed,No Information,True,No Information,Single Arrangement,Double Arrangement,Multiple Arrangements,Other,True,,,,,,,,,,,,,,,,,,,",
",LOC,On Waterbody Bottom,X,X,,,,X,X,,,,,X,X,,,,,,,,,,,,,,,,,,,,,,,,,",
",LOC,Below Waterbody Bottom,X,X,,,X,X,X,,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,,,,,,",
",LOC,Below Ground Surface,X,X,,,X,X,X,,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,,,,,,",
",LOC,On Surface,,,,,,,,,,,,X,X,,,,,,X,,,,,,,,,,,,,,,,,,,",
",LOC,Above Surface,,,,,,,,,X,X,X,,,,,,,,X,,,,,,,,,,,,,,,,,,,",
",LOC,Above Waterbody Bottom,X,X,,,,X,X,,X,X,X,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",CWT,No Information,,X,,,X,,X,,,,,,X,,,,,,,,,,,,,,,,,,,,,,,,,",
",CWT,True,X,X,X,,X,X,X,X,X,X,,X,X,,,,,,,,,,,,,,,,,,,,,,,,,",
",NPL,-999999,,,,,,,,,,,,,,,X,X,X,,,,,,,,,,,,,,,,,,,,,",
",NPL,1,,,,,,,,,,,,,,X,,X,X,X,,,,,,,,,,,,,,,,,,,,",
",NPL,2,,,,,,,,,,,,,,X,X,,X,X,,,,,,,,,,,,,,,,,,,,",
",NPL,>=3,,,,,,,,,,,,,,X,X,X,,X,,,,,,,,,,,,,,,,,,,,",
",FLO,True,,,,,,,,X,X,,X,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",RLE,No Information,,X,,,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",RLE,Level,,X,X,,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",RLE,Depressed,,X,X,,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",SPT,True,,,X,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
"Pumping Station (AQ116),,,PPO,PPO,PPO,PPO,PPO,PPO,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",,,Chemical,Gas,Petrol,Petroleum,Sewage,Water,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",FFN,Petroleum and/or Gas Extraction,X,,,,X,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",FFN,Petroleum Refining,X,X,,,X,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",FFN,Utilities,X,X,X,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
"Railway (AN010),,,LOC,LOC,LOC,LOC,SBB,SBB,RLE,RLE,RLE,RLE,RTA,RTA,RTA,RTA,RTA,CWT,RWC,RWC,RRC,RRC,RRC,RRC,ZI017_RGC,ZI017_RGC,ZI017_RGC,ZI017_RGC,,,,,,,,,,,,",
",,,No Information,On Waterbody Bottom,Below Ground Surface,On Surface,No Information,True,No Information,Raised,Level,Depressed,No Information,Single Arrangement,Double Arrangement,Multiple Arrangements,Other,True,High Spped Rail,Main Line,Logging,Marine Railway,Funicular,Long-haul,No Information,Broad,Narrow,Standard,,,,,,,,,,,,",
",ZI017_RIR,No Information,,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",ZI017_RIR,True,,X,,,,,,,,,,,,,,,X,,X,X,X,X,,,,,,,,,,,,,,,,",
",ZI017_GAW,-999999,,,,,,,,,,,,,,,,,,,,,,,,X,X,X,,,,,,,,,,,,",
",ZI017_GAW,>1.435 meters,,,,,,,,,,,,,,,,,,,,,,,X,,X,X,,,,,,,,,,,,",
",ZI017_GAW,<1.435 meters,,,,,,,,,,,,,,,,,X,,,,,,X,X,,X,,,,,,,,,,,,",
",ZI017_GAW,=1.435 meters,,,,,,,,,,,,,,,,,,,,,,,X,X,X,,,,,,,,,,,,,",
",ZI017_RGC,Narrow,,,,,,,,,,,,,,,,,X,,,,,,,,,,,,,,,,,,,,,",
",RRC,Rail Rapid Transit,,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",RRC,Marine Railway,,,X,,X,X,,X,,,,,,,,,X,X,,,,,,,,,,,,,,,,,,,,",
",RRC,Tramway,,X,,,,,,,,,,,,,,,X,X,,,,,,,,,,,,,,,,,,,,",
",RRC,Funicular,,X,X,,,,,,,,,,,,,X,X,X,,,,,,,,,,,,,,,,,,,,",
",RRC,Museum,,X,,,,,,,,,,,,,,,X,X,,,,,,,,,,,,,,,,,,,,",
",RRC,Automated Transit System,,X,,,,,,,,,,,,,,,X,X,,,,,,,,,,,,,,,,,,,,",
",RRC,Long-haul,,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",RWC,High Speed Rail,,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",RWC,Main Line,,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",RWC,Branch-line,,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",CWT,No Information,,,,X,,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",CWT,False,,X,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",CWT,True,X,X,,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",LTN,-999999,,,,,,,,,,,,X,X,X,,,,,,,,,,,,,,,,,,,,,,,,",
",LTN,1,,,,,,,,,,,X,,X,X,X,,,,,,,,,,,,,,,,,,,,,,,",
",LTN,2,,,,,,,,,,,X,X,,X,X,,,,,,,,,,,,,,,,,,,,,,,",
",LTN,>=3,,,,,,,,,,,X,X,X,,X,,,,,,,,,,,,,,,,,,,,,,,",
",RLE,No Information,,,,,,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",RLE,Raised,,,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",RLE,Level,,,X,,X,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",RLE,Depressed,,,X,,X,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",RLE,Not Applicable,,,,,X,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",SBB,True,X,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
"Railway Sidetrack (AN050),,,LOC,LOC,LOC,LOC,SBB,SBB,RLE,RLE,RLE,RLE,ZI017_RGC,ZI017_RGC,ZI017_RGC,ZI017_RGC,,,,,,,,,,,,,,,,,,,,,,,,",
",,,No Information,On Waterbody Bottom,Below Ground Surface,On Surface,No Information,True,No Information,Raised,Level,Depressed,No Information,Broad,Narrow,Standard,,,,,,,,,,,,,,,,,,,,,,,,",
",ZI017_GAW,-999999,,,,,,,,,,,,X,X,X,,,,,,,,,,,,,,,,,,,,,,,,",
",ZI017_GAW,>1.435 meters,,,,,,,,,,,X,,X,X,,,,,,,,,,,,,,,,,,,,,,,,",
",ZI017_GAW,<1.435 meters,,,,,,,,,,,X,X,,X,,,,,,,,,,,,,,,,,,,,,,,,",
",ZI017_GAW,=1.435 meters,,,,,,,,,,,X,X,X,,,,,,,,,,,,,,,,,,,,,,,,,",
",CWT,No Information,,,,X,,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",CWT,False,,X,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",CWT,True,X,X,,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",RLE,No Information,,,,,,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",RLE,Raised,,,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",RLE,Level,,,X,,X,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",RLE,Depressed,,,X,,X,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",RLE,Not Applicable,,,,,X,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",SBB,True,X,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",

"River (BH140),,,LOC,LOC,CDA,CDA,TID,TID,YWQ,WCC,WCC,WCC,NVS,NVS,NVS,NVS,NVS",
",,,Below Ground Surface,On Surface,No Information,True,No Information,True,Potable,Chanalized Stream,Braided Stream,Wadi,No Information,Navigable and Operational,Navigable,Navigable with Periodic Restrictions,Other",
",ZI024_HYP,Perennial,,,,,,,,,,X,,,,,",
",ZI024_HYP,Intermittent,,,,,,,,,,,,X,X,,",
",ZI024_HYP,Dry,,,,,,X,X,X,,,X,X,X,X,X",
",NVS,No Information,,,,,,,,,,X,,,,,",
",NVS,Navigable and Operational,X,,,X,,,,,X,X,,,,,",
",NVS,Navigable but Abandoned,X,,,X,,,,,X,X,,,,,",
",NVS,Navigable,X,,,X,,,,,X,X,,,,,",
",NVS,Navigable with Periodic Restrictions,X,,,X,,,,,X,X,,,,,",
",NVS,Other,,,,,,,,,,X,,,,,",
",WCC,Wadi,,,X,X,,,X,,,,,,,,",
",YWQ,Potable,,,,,X,X,,,,,,,,,",
",CDA,False,X,,,,,,,,,,,,,,",
",CDA,True,,X,,,,,,,,,,,,,",


"Road (AP030),,,LOC,LOC,LOC,LOC,SBB,SBB,RLE,RLE,RLE,RLE,ZI016_ROC,ZI016_ROC,ZI016_ROC,ZI016_ROC,ZI016_ROC,ZI016_ROC,ZI016_ROC,ZI016_ROC,ZI016_ROC,ZI016_ROC,ZI016_ROC,ZI016_ROC,ZI016_ROC,ZI016_ROC,ZI016_ROC,ZI016_ROC,ZI016_ROC,ZI016_ROC,ZI016_ROC,ZI016_WTC,ZI016_WTC,ZI016_WTC,ZI016_WTC,RTY,RTY,RTY,RTY,MES",
",,,No Information,On Waterbody Bottom,Below Ground Surface,On Surface,No Information,True,No Information,Raised,Level,Depressed,No Information,Unimproved,Stabilized Earth,Flexible Pavement,Aggregate,Macadam,Bound Surface,Rigid Pavement,Concrete,Asphalt,Asphalt over Concrete,Cobble-stone,Brick,Metal,Wood,Corduroy,Wood Plank,Ice,Snow,No Information,Fair-weather,Winter Only,Limited All-weather,No Information,Road,Street,Other,True",
",RIN_ROI,National Motorway,,,,,,,,,,,,X,X,X,X,X,X,,,,,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,",
",CWT,No Information,,,,X,,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",CWT,False,,,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",CWT,True,X,X,,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",SEP,No Information,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,X",
",SEP,False,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,X",
",RTY,Motorway,,,,,,,,,,,X,X,X,X,X,X,X,,,,,X,X,X,X,X,X,X,X,X,X,X,X,,,,,",
",RTY,Limited Access Motorway,,,,,,,,,,,X,X,X,X,X,X,X,,,,,X,X,X,X,X,X,X,X,X,X,X,X,,,,,",
",ZI016_WTC,No Information,,,,,,,,,,,,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,",
",ZI016_WTC,All-weather,,,,,,,,,,,,X,,,,,,,,,,,,,,,,X,X,,,,,,,,,",
",ZI016_WTC,Fair-weather,,,,,,X,,,,,,,,,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,",
",ZI016_WTC,Winter Only,,,,,,,,,,,,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,,,,,,,,,,,",
",ZI016_WTC,Limited All-weather,,,,,,,,,,,,X,,,,,,,X,X,X,,,,,,,X,X,,,,,,,,,",
",ZI016_WTC,Closed in Winter,,,,,,,,,,,,,,,,,,,,,,,,,,,,X,X,,,,,,,,,",
",ZI016_ROC,Unimproved,,,,,,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",ZI016_ROC,Stabilized Earth,,,,,,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",ZI016_ROC,Flexible Pavement,,,,,,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",ZI016_ROC,Ice,,,,,,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",ZI016_ROC,Snow,,,,,,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",RLE,No Information,,,,,,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",RLE,Raised,,X,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",RLE,Level,,,X,,X,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",RLE,Depressed,,X,X,,X,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",RLE,Not Applicable,,,,X,X,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",SBB,True,X,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",


"Shoreline Construction (BB081),,,FLO,FLO,WLE,WLE,WLE,WLE,WLE,WLE,WLE,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",,,No Information,True,No Information,Partly Submerged,Always Dry,Always Submerged,Covers and Uncovers,Awash at Low Water,Awash at Chart Datum,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",PWC,Pier,,,X,X,,,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",PWC,Wharf,,,X,X,,,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",PWC,Quay,,,X,X,,,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",PWC,Breakwater,X,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",PWC,Groin,X,X,,,,,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",PWC,Mole,X,X,,,,,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",PWC,Recreational Pier,,,,X,,X,X,X,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",PWC,Training Wall,X,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",PWC,Riprap,X,X,,,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",PWC,Revetment (Marine),X,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",PWC,Seawall,X,X,,,,,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",PWC,Promenade,,,,X,,X,X,X,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",WLE,Always Submerged,X,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",WLE,Covers and Uncovers,X,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",WLE,Awash at Low Water,X,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",WLE,Awash at Chart Datum,X,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
"Swamp (ED020),,,VSP,VSP,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",,,Mangrove,Nipa,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",TID,No Information,X,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",TID,False,X,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",TRE,No Information,,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",TRE,Deciduous,,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",TRE,Mixed,,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",TRE,Other,,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
"Trail (AP050),,,LOC,LOC,LOC,LOC,SBB,SBB,RLE,RLE,RLE,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",,,No Information,On Waterbody Bottom,Below Ground Surface,On Surface,No Information,True,No Information,Raised,Level,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",CWT,No Information,,,,,,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",CWT,False,,,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",CWT,True,X,X,,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",RLE,No Information,,,,,,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",RLE,Raised,,,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",RLE,Level,,,X,,X,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",RLE,Depressed,,,X,,X,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
"Tunnel (AQ130),,,TRS,TRS,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",,,Pedestrian,Road,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",TRA,False,X,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
"Water Race (BH065),,,LOC,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",,,Below Ground Surface,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",RLE,Raised,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",RLE,Level,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",RLE,Depressed,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
"Water Well (BH230),,,ZI024_SCC,ZI024_SCC,ZI024_SCC,ZI024_SCC,ZI024_SCC,ZI024_SCC,ZI024_SCC,LMC,LMC,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",,,No Information,Alkaline,Saline,Brackish,Seawater,Brine,Not Applicable,No Information,False,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",PCF,Construction,,,,,,,,X,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",PCF,Unmaintained,,,,,,,,X,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",PCF,Damaged,,,,,,,,X,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",PCF,Dismantled,,,,,,,,X,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",PCF,Destroyed,,,,,,,,X,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
",ZI024_YWQ,Potable,X,X,X,X,X,X,X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"
  };







int NAMValuePresent(char *fcode, int geomtype, char *attrval)
{
  char cleancode[1000];
  int fcode_index;
  int i,Ival,thistype,thisecc,thisgeom,retval=0;
  double Dval;
  extern int LONG_ATTR_NAM;

  if(!strcmp(fcode,"qqQQqq"))
    {
      
      

      return 0;
    }


  fcode_index = GetNum(fcode);

  if(fcode_index<0)
  {
    printf("Error:  Could not look up fcode %s\n",fcode);
  }

  

  for(i=0;i<LLFidTableCount;i++)
  { 

    if(LLFidTable[i]<0)
      {
	continue;
      } 


    thisecc  = SCCtable[CrsWlk[LLFidTable[i]].LtoSmapping].ECC;
    thisgeom =          CrsWlk[LLFidTable[i]].geomtype;
    
    if(thisecc!=fcode_index)
      {
	continue;
      }
    if(thisgeom!=geomtype)
      {
	continue;
      }
    
    thistype = GetLongAttrVal(LONG_ATTR_NAM,i,&Ival,&Dval,&cleancode[0]);


    if(thistype==C_TYPE)
      {
	if(!strcmp(cleancode,attrval))
	  {
	    retval = 1;
	    break;
	  }
      }
  }

  
  return retval;
}


int SpecialGetLongAttrVal(int type,int uniqueid,int *Ival,double *Dval,char *Cval)
{
  short int thisid;

  
  sprintf(Cval,"Error");
  *Ival = -123456;
  *Dval = -123456;
  
  thisid = Scache_types[uniqueid];
  
  
  if(thisid==0)
    {
      return NOTYPE;
    }
  else if(thisid>0)
    {	  
      sprintf(Cval,"%s",Scache_chars[uniqueid]);

      return C_TYPE;
    }
  else if(thisid==-1)
    {
      *Ival = (int)Scache_nums[uniqueid];
      return I_TYPE;
    }
  else if(thisid==-2)
    {
      *Dval = Scache_nums[uniqueid];
      return D_TYPE;
    }      
  else
    {
      printf("error in GLAV11: got bad id %d for %d\n",thisid,uniqueid);
      return NOTYPE;
    }

  return NOTYPE;
}



int HGTValuePresent(char *fcode, int geomtype, char *attrval)
{
  char cleancode[1000];
  int fcode_index;
  int i,Ival,thistype,thisecc,thisgeom,retval=0;
  double Dval,passedval;
  extern int LONG_ATTR_HGT;


  sscanf(attrval,"%lf",&passedval);


  fcode_index = GetNum(fcode);
  
  if(fcode_index<0)
    {
      printf("Error:  Could not look up fcode %s\n",fcode);
    }
  
  
  
  for(i=0;i<LLFidTableCount;i++)
    { 
      
      if(LLFidTable[i]<0)
	{
	  continue;
	} 
      
      
      thisecc  = SCCtable[CrsWlk[LLFidTable[i]].LtoSmapping].ECC;
      thisgeom =          CrsWlk[LLFidTable[i]].geomtype;
      
      if(thisecc!=fcode_index)
	{
	  continue;
	}
      if(thisgeom!=geomtype)
	{
	  continue;
	}
      
      thistype = SpecialGetLongAttrVal(LONG_ATTR_HGT,i,&Ival,&Dval,&cleancode[0]);
      
      
      if(thistype==D_TYPE)
	{
	  if(Dval==passedval)
	    {
	      retval = 1;
	      break;
	    }
	}
    }

  return retval;

}



void TestEnum(char *attrcode,char *attrval)
{
  int i,eaccode;

  

  eaccode = GetAttrIndex(attrcode);

  for(i=0;i<gifd_attr_enum_count[eaccode-1];i++)
  {
    

	if(!strcmp(attrval,GetEELabel(eaccode,i)))
	{
      return;
	}
  }

  printf("***Did not find %s %s\n",attrcode,attrval);

}




int ValuePresent(char *fcode,char *attrcode,char *attrval, int line_bridge_found, int line_road_found,int line_rail_found, int line_sidetrack_found)
{
  int foundit;
  char sendval[200];
  double Dtest;
  extern int FIND_ENUM,FIND_STRING,FIND_REAL;
  extern int FindAttr(double dval,int passtype,char *geometry,char *charSCC, char *charSAC, char *targetvalue);

  

  if((!strcmp(attrcode,"NFN"))||(!strcmp(attrcode,"NFI"))||(!strcmp(attrcode,"VOI")))
  {
    if(strcmp(attrval,"Any Text String"))
	{
      printf("Error: Got %s with %s\n",attrcode,attrval);
	  exit(-1);
	}

    foundit = 100 * FindAttr(-33.0,FIND_STRING,"(POINT)", fcode, attrcode, attrval);  

    foundit = foundit   +   10 * FindAttr(-33.0,FIND_STRING,"(LINE)", fcode, attrcode, attrval);  

    return foundit + FindAttr(-33.0,FIND_STRING,"(AREA)", fcode, attrcode, attrval);

  } 

  if(!strcmp(attrval,"Any Text String"))
  {
    printf("Got Any Text String for %s %s\n",fcode,attrcode);
	exit(-1);
  }


  if(!strcmp(attrcode,"NAM"))
  {
    foundit = 100 * NAMValuePresent(fcode,C_POFE,attrval);

    foundit = foundit   +   10 * NAMValuePresent(fcode,C_LINE,attrval);

    return foundit +  NAMValuePresent(fcode,C_AREA,attrval);
  } 

  if(!strcmp(attrcode,"HGT"))
  {

    sprintf(sendval,"%s",attrval);

	if(
		(!strcmp(attrval,"Null/Empty")) ||
		(!strcmp(attrval,"-32768.0"))   ||
		(!strcmp(attrval,"-32768"))
	  )
	{
      sprintf(sendval,"-32768.0");
	} 
	else if(
		     (!strcmp(attrval,"Unknown")) ||
		     (!strcmp(attrval,"-32767.0"))||
		     (!strcmp(attrval,"-32767"))
		   )
	{
      sprintf(sendval,"-32767.0");
	}
	else if(
		     (!strcmp(attrval,"Not Applicable")) ||
		     (!strcmp(attrval,"-32765.0"))       ||
		     (!strcmp(attrval,"-32765"))
		   )
	{
      sprintf(sendval,"-32765.0");
	}
	else if(
		     (!strcmp(attrval,"Other"))    ||
		     (!strcmp(attrval,"-32764.0")) ||
		     (!strcmp(attrval,"-32764"))
		   )
	{
      sprintf(sendval,"-32764.0");
	}
    else if(!strcmp(attrval,"Any Real Value"))
	{
      return 111;
	}
	else
	{
      printf("Bad val %s to VP3\n",attrval);
	  exit(-1);
	}


    foundit = 100 * HGTValuePresent(fcode,C_POFE,sendval);

    foundit = foundit   +   10 * HGTValuePresent(fcode,C_LINE,sendval);

    return foundit +  HGTValuePresent(fcode,C_AREA,sendval);
  } 


  if(
	  (!strcmp(attrcode,"LTN"))       ||
	  (!strcmp(attrcode,"NPL"))       ||  
	  (!strcmp(attrcode,"SDO"))       ||
	  (!strcmp(attrcode,"ZI017_GAW")) ||  
	  (!strcmp(attrcode,"OHB"))

	)
  {
    
	if(
		(!strcmp(attrval,"Null/Empty")) ||
		(!strcmp(attrval,"-32768"))     ||
		(!strcmp(attrval,"-32768.0"))
	  )
	{
      Dtest = -32768.0;
	} 
	else if(
		     (!strcmp(attrval,"Unknown")) ||
		     (!strcmp(attrval,"-32767"))  ||
		     (!strcmp(attrval,"-32767.0"))
		   )
	{
      Dtest = -32767.0;
	}
	else if(
		     (!strcmp(attrval,"Not Applicable")) ||
		     (!strcmp(attrval,"-32765"))         ||
		     (!strcmp(attrval,"-32765.0"))
		   )
	{
      Dtest = -32765.0;
	}
	else if(
		     (!strcmp(attrval,"Other"))  ||
		     (!strcmp(attrval,"-32764")) ||
		     (!strcmp(attrval,"-32764.0"))
		   )
	{
      Dtest = -32764.0;
	}
    else if(
		     (!strcmp(attrcode,"SDO")) &&
			 (!strcmp(attrval,"Any Real Value"))
		   )
	{
      return 001; 
	}
	else if(
		      ((!strcmp(attrcode,"LTN"))       && (!strcmp(attrval,"-999999.0"))) ||
		      ((!strcmp(attrcode,"LTN"))       && (!strcmp(attrval,"1")))         ||
		      ((!strcmp(attrcode,"LTN"))       && (!strcmp(attrval,"2")))         ||
		      ((!strcmp(attrcode,"NPL"))       && (!strcmp(attrval,"-999999.0"))) ||
		      ((!strcmp(attrcode,"NPL"))       && (!strcmp(attrval,"1")))         ||
		      ((!strcmp(attrcode,"NPL"))       && (!strcmp(attrval,"2")))         ||
		      ((!strcmp(attrcode,"ZI017_GAW")) && (!strcmp(attrval,"-999999.0"))) ||
		      ((!strcmp(attrcode,"ZI017_GAW")) && (!strcmp(attrval,"1.435")))
			)
	{
	  sscanf(attrval,"%lf",&Dtest);
	}
	else
	{
	  printf("Bad val %s to PLVV1\n",attrval);
	}


    foundit = 100 * FindAttr(Dtest,FIND_REAL,"(POINT)", fcode, attrcode, attrval);

    foundit = foundit   +   10 * FindAttr(Dtest,FIND_REAL,"(LINE)", fcode, attrcode, attrval);

    return foundit +  FindAttr(Dtest,FIND_REAL,"(AREA)", fcode, attrcode, attrval);
  }

  if(!strcmp(attrcode,"GAW"))
  {
    if(!strcmp(fcode,"Railway"))
	{
      if(line_rail_found==0)
	  {
        return 0;
	  }
	}
    if(!strcmp(fcode,"Railway Sidetrack"))
	{
      if(line_sidetrack_found==0)
	  {
        return 0;
	  }
	}

    if(!strcmp(attrval,"Any Real Value"))
	{
      return 111;
	}
	else if(!strcmp(attrval,"Unknown"))
	{
      foundit = 100 * FindAttr(32767.0,FIND_REAL,"(POINT)", fcode, attrcode, attrval);

      foundit = foundit   +   10 * FindAttr(32767.0,FIND_REAL,"(LINE)", fcode, attrcode, attrval);

      return foundit + FindAttr(32767.0,FIND_REAL,"(AREA)", fcode, attrcode, attrval);
	}

	printf("Error: GAW %s\n",attrval);
	exit(-1);
  }


  if(!strcmp(attrcode,"WID"))
  {
    if(!strcmp(attrval,"Unknown"))
	{
      Dtest = -32767.0;
	}
	else
	{
      printf("Bad WV %s\n",attrval);
	  return 0;
	}

    foundit = 100 * FindAttr(Dtest,FIND_REAL,"(POINT)", fcode, attrcode, attrval);

    foundit = foundit   +   10 * FindAttr(Dtest,FIND_REAL,"(LINE)", fcode, attrcode, attrval);

    return foundit + FindAttr(Dtest,FIND_REAL,"(AREA)", fcode, attrcode, attrval);
  }





  if(!strcmp(attrcode,"DMT"))
  {
    if(!strcmp(attrval,"Null/Empty"))
	{
      Dtest = -32768.0;
	}
    else if(!strcmp(attrval,"Unknown"))
	{
      Dtest = -32767.0;
	}
    else if(!strcmp(attrval,"Not Applicable"))
	{
      Dtest = -32765.0;
	}
    else if(!strcmp(attrval,"Other"))
	{
      Dtest = -32764.0;
	}
	else
	{
      printf("Bad WVD %s\n",attrval);
	  return 0;
	}

    foundit = 100 * FindAttr(Dtest,FIND_REAL,"(POINT)", fcode, attrcode, attrval);

    foundit = foundit   +   10 * FindAttr(Dtest,FIND_REAL,"(LINE)", fcode, attrcode, attrval);

    return foundit + FindAttr(Dtest,FIND_REAL,"(AREA)", fcode, attrcode, attrval);
  }






  if(!strcmp(attrcode,"WD1"))
  {
	if(!strcmp(attrval,"Null/Empty"))
	{
      Dtest = -32768.0;
	} 
	else if(!strcmp(attrval,"Unknown"))
	{
      Dtest = -32767.0;
	}
	else if(!strcmp(attrval,"Not Applicable"))
	{
      Dtest = -32765.0;
	}
	else if(!strcmp(attrval,"Other"))
	{
      Dtest = -32764.0;
	}
	else if(!strcmp(attrval,"Any Real Value"))
	{
	  
	  

	  if(!strcmp(fcode,"Bridge"))
	  {
	    if(line_bridge_found>0)
		{
          return 10;  
		} 
	  } 
	  else if(!strcmp(fcode,"Road"))
	  {
	    if(line_road_found>0)
		{
          return 10;  
		} 
	  } 
	  else
	  {
        printf("Error:  Bad FCS %s\n",fcode);
		exit(-1);
	  } 

	  return 0;
	   
	}
	else
	{
      printf("Bad WD1 value %s\n",attrval);
	  exit(1);
	} 

    foundit = 100 * FindAttr(Dtest,FIND_REAL,"(POINT)", fcode, attrcode, attrval);

    foundit = foundit   +   10 * FindAttr(Dtest,FIND_REAL,"(LINE)", fcode, attrcode, attrval);

    return foundit + FindAttr(Dtest,FIND_REAL,"(AREA)", fcode, attrcode, attrval);
  } 


  

  foundit = 100 * FindAttr(-1,FIND_ENUM,"(POINT)", fcode, attrcode, attrval);

  foundit = foundit   +   10 * FindAttr(-1,FIND_ENUM,"(LINE)", fcode, attrcode, attrval);

  return foundit + FindAttr(-1,FIND_ENUM,"(AREA)", fcode, attrcode, attrval);

 }




char timtoupper(char inchar)
{
  if( (inchar >='a') && (inchar <='z') )
    {
      return (inchar-32);
    }
  return inchar;
}


char timtoupper2(char inchar)
{
  if( (inchar >='a') && (inchar <='z') )
    {
      return (inchar-32);
    }
  if( (inchar >='A') && (inchar <='Z') )
    {
      return (inchar);
    }

  
  return ';';
}







int IsRealVOI(char *tester)
{
  int i,numquotes,len;

  
  
  
  

  len = strlen(tester);

  if(len>35)
  {
	
    return 1;
  }

  numquotes=0;
  if(len==15)
  {
	
	if(
		(tester[0]!='"')  ||
		(tester[1]!='"')  ||
		(tester[13]!='"') ||
		(tester[14]!='"')
	  )
	{
	  return 0;
	}
  }


  if( (len==12) || (len==13) || (len==15) )
  {

	
	for(i=0;i<len;i++)
	{
      if(IsLetter(timtoupper(tester[i])))
	  {
		break;
	  }
	}

	if(i>=len)
	{
	  return 0;
	}


	for(i=0;i<len;i++)
	{
      if(IsNumber(timtoupper(tester[i])))
	  {
		break;
	  }
	}

	if(i>=len)
	{
	  return 0;
	}

	

    return 1;
  }
  return 0;
}


int GenerateVOIInfo()
{
  int i,j;

  

  for(i=0;i<NumberOfAttributesEntries;i++)
  { 
    if(!strcmp(GetEACCode(MdlNames2[i].code),"VOI"))
	{
      for(j=0;j<MdlNames2[i].count;j++)
	  {
	    if(MdlNames2[i].values[j].uniqueoccurrences>0)
		{
		  if(MdlNames2[i].values[j].type==2)
		  {
			if(IsRealVOI(MdlNames2[i].values[j].label))
			{
	          
			  return 1;
			}
		  }
		}
	  }
	}
  }

  return 0;
}


int GenerateVVInfo()
{
  int i,j,thisindex,thatindex,insertindex2=0,insertindex4=0,retval=0;
  double tempval,LOW_LIMIT=0.0,HIGH_LIMIT=900.0,WD1multiplier=1.0;
  extern int bridge_wid_val_found,bridge_wd1_val_found;
  extern void FreeShareSegData(); 
  extern void SortReals(double sortarray[],int p,int r);

  bridge_wid_val_found = 0;
  bridge_wd1_val_found = 0;


  if(
	 (ATTRTYPE_D4()) ||  
	 (ATTRTYPE_FACC()) ||  
	 (ATTRTYPE_VMAP()) ||  
	 (ATTRTYPE_UFD2())||  
	 (ATTRTYPE_UFD1())||  
	 (ATTRTYPE_UFD3())    
	)
  {
	
	WD1multiplier = 10.0;
  }


  

  

  for(i=0;i<NumberOfModels;i++)
  {
    if((!strcmp(MdlNames[i].name,"(LINE)")) && (!strcmp(GetECCCode(MdlNames[i].code),"AQ040")))
	{
	  
	  for(j=0;j<MdlNames[i].numattributes;j++)
	  {
	    thisindex = MdlNames[i].AttrIndices[j];
	    thatindex = MdlNames[i].ValueIndices[j];

	    if(!strcmp(GetEACCode(MdlNames2[thisindex].code),"WID"))
		{
		  
		  if(
			  (MdlNames2[thisindex].values[thatindex].type==0) ||
			  (MdlNames2[thisindex].values[thatindex].type==1)
			)
		  {
			tempval = (double)MdlNames2[thisindex].values[thatindex].value;
			if((tempval>LOW_LIMIT)&&(tempval<HIGH_LIMIT))
			{
			  bridge_wid_val_found = bridge_wid_val_found + 1;
			}
		  }
		}

	    if(!strcmp(GetEACCode(MdlNames2[thisindex].code),"WD1"))
		{
		  
		  if(
			  (MdlNames2[thisindex].values[thatindex].type==0) ||
			  (MdlNames2[thisindex].values[thatindex].type==1)
			)
		  {
			tempval = (double)MdlNames2[thisindex].values[thatindex].value;
			if((tempval>LOW_LIMIT)&&(tempval<(HIGH_LIMIT*WD1multiplier)))
			{
			  bridge_wd1_val_found = bridge_wd1_val_found + 1;
			}
		  }
		}
	  }
	}
  }


  global_bridge_wid = (double *)malloc(SzD*(bridge_wid_val_found+5));
  global_bridge_wd1 = (double *)malloc(SzD*(bridge_wd1_val_found+5));

  

  insertindex2 = 0;
  insertindex4 = 0;

  for(i=0;i<NumberOfModels;i++)
  {
    if((!strcmp(MdlNames[i].name,"(LINE)")) && (!strcmp(GetECCCode(MdlNames[i].code),"AQ040")))
	{
	  
	  for(j=0;j<MdlNames[i].numattributes;j++)
	  {
	    thisindex = MdlNames[i].AttrIndices[j];
	    thatindex = MdlNames[i].ValueIndices[j];

	    if(!strcmp(GetEACCode(MdlNames2[thisindex].code),"WID"))
		{
		  
		  if(
			  (MdlNames2[thisindex].values[thatindex].type==0) ||
			  (MdlNames2[thisindex].values[thatindex].type==1)
			)
		  {
			tempval = (double)MdlNames2[thisindex].values[thatindex].value;
			if((tempval>LOW_LIMIT)&&(tempval<HIGH_LIMIT))
			{
			  global_bridge_wid[insertindex2] = tempval;
			  insertindex2 = insertindex2 + 1;
			}
		  }
		}

	    if(!strcmp(GetEACCode(MdlNames2[thisindex].code),"WD1"))
		{
		  
		  if(
			  (MdlNames2[thisindex].values[thatindex].type==0) ||
			  (MdlNames2[thisindex].values[thatindex].type==1)
			)
		  {
			tempval = (double)MdlNames2[thisindex].values[thatindex].value;
			if((tempval>LOW_LIMIT)&&(tempval<(HIGH_LIMIT*WD1multiplier)))
			{
			  global_bridge_wd1[insertindex4] = tempval;
			  insertindex4 = insertindex4 + 1;
			}
		  }
		}
	  }
	}
  }

  if(insertindex2!=bridge_wid_val_found)
  {
	
	printf("error: insertindex2!=bridge_wid_val_found %d %d\n",insertindex2,bridge_wid_val_found);
    FreeShareSegData();
    return 0;
  }
  if(insertindex4!=bridge_wd1_val_found)
  {
	
	printf("error: insertindex4!=bridge_wd1_val_found %d %d\n",insertindex4,bridge_wd1_val_found);
    FreeShareSegData();
    return 0;
  }


  

  SortReals(global_bridge_wid,0,bridge_wid_val_found-1);
  SortReals(global_bridge_wd1,0,bridge_wd1_val_found-1);



  



  

  for(i=0;i<bridge_wd1_val_found;i++)
  {
	if(bridge_wid_val_found>0)
	{
	  if(global_bridge_wid[0]<global_bridge_wd1[i])
	  { 
	    retval = retval + 1;
	  } 
	}
  }
  return retval;
}


int ChangeGeomType(char *inval)
{
  if(!strcmp(inval,"(POINT)"))
  {
    return C_POFE;
  }
  if(!strcmp(inval,"(LINE)"))
  {
    return C_LINE;
  }
  if(!strcmp(inval,"(AREA)"))
  {
    return C_AREA;
  }

  printf("Error: CGT got %s\n",inval);
  return C_POFE;
}


char *ChangeGeomType2(char *inval)
{
  if(!strcmp(inval,"(POINT)"))
  {
    return "C_POFE";
  }
  if(!strcmp(inval,"(LINE)"))
  {
    return "C_LINE";
  }
  if(!strcmp(inval,"(AREA)"))
  {
    return "C_AREA";
  }

  printf("Error: CGT2 got %s\n",inval);
  return "C_POFE";
}



void SpecialTestMinMaxHGT(double theval)
{
  if((theval>=0)&&(theval<=4.999))
  {
	FoundHGTrange = 1;
  }
}


int Process_TDS_IAE(FILE *outfile,char *htempfilename,char *tempfilename,
 int point_tower_found,
 int area_tower_found,
 int point_transStation_found,
 int area_transStation_found,
 int point_building_found,
 int area_building_found)
{

#define maxattrs 50
#define maxattrlen 50

  FILE *htempfile,*tempfile,*nfnfile;
  char first[500],fcode[500],thisattr[500],attrvals[maxattrs][maxattrlen],
	  thisrowattr[100],thisrowvalue[100],isx[100],aline[1000],
	  cleancode[1000],cleancode2[1000],cleancode3[1000],
	  cleancode4[1000],cleancode5[1000],cleancode6[1000],
	  message[1000],tempstr[100];
  unsigned char valuepresent[maxattrs];
  unsigned char valuepresent2[maxattrs];
  unsigned char valuepresent3[maxattrs];

  int TDS_IAEDEBUG=0;

  int i,j,k,len,rowvaluepresent,rowvaluepresent2,rowvaluepresent3,thisrowattrint,
	  thisrowattrint2,thisrowattrint3,numattrs=0,finishedattrs=0,SILENT=1,VERBOSE=0,
	  wroteheader,lcindex=1,numinstances=0,thislen,countedthisrow=0,firstextra=0,
	  totalchecks=0,numnfnchecks,numlines=0,geom1=0,geom2=0,docheck1,docheck2,docheck3;
  int rowattrs[50],rowattrs2[50],rowattrs3[50],point_underground1=0,point_underground2=0,
	  point_underground3=0,area_underground1=0,area_underground2=0,area_underground3=0;
  int do_points=1,do_lines=1,do_areas=1;
  int line_bridge_found    = 0;
  int line_road_found      = 0; 
  int line_rail_found      = 0;
  int line_sidetrack_found = 0;
  int type = 1; 
  double djunk,minVal,maxVal1,maxVal2,maxVal3,smalljunkflag=-999;
  double minVal1a,minVal2a,minVal3a,maxVal1a,maxVal2a,maxVal3a;
  double smallover1,smallover2,smallover3,minHGT,maxHGT;
  double largeunder1,largeunder2,largeunder3;
  double minPointBuildingBNF=100,maxPointBuildingBNF=10,minAreaBuildingBNF=100,maxAreaBuildingBNF=10; 


  extern int LONG_ATTR_NAM;
  extern int FIND_ENUM,FIND_STRING,FIND_REAL;
  extern int DoNFI();
  extern int NFN_CheckType();
  extern char *GetNFN();
  extern char * GetNGACname(int num);
  extern char *GetBuildingName(int english);
  extern int HGT_Getter(char *attrcode,char *geomstring,char *fcode,double *minVAL,double *maxVAL);



  htempfile = fopen(htempfilename,"w");
  if(htempfile==NULL)
  {
    printf("Error: could not open %s for write\n",htempfilename);
	return 0;
  }

  tempfile = fopen(tempfilename,"w");
  if(tempfile==NULL)
  {
    printf("Error: could not open %s for write\n",tempfilename);
	return 0;
  }



  numnfnchecks = 0;

  if((DoNFI())&&(NFN_CheckType()==2))
  {
     

	 sprintf(cleancode,"%snfn.sf2",indirectory);
	 nfnfile = fopen(cleancode,"rt");
	 if(nfnfile!=NULL)
	 {
       fgets(cleancode,1000,nfnfile);
       numlines = 0;
		
       while(!feof(nfnfile))
	   {
         numlines = numlines + 1;
         fgets(cleancode,1000,nfnfile);
	   }

	   fclose(nfnfile);

	   if((numlines%8)==0)
	   {
         numnfnchecks = numlines/8;


	   } 
	 } 
  } 




  if(numnfnchecks>0)
  {
	 sprintf(cleancode,"%snfn.sf2",indirectory);
	 nfnfile = fopen(cleancode,"rt");
	 if(nfnfile!=NULL)
	 {
       fgets(cleancode,1000,nfnfile);  

       while(!feof(nfnfile))
	   {
         fgets(message,1000,nfnfile);     
         sscanf(message,"%d\n",&geom1);   

         fgets(cleancode2,1000,nfnfile);  

         fgets(message,1000,nfnfile);     
         sscanf(message,"%d\n",&geom2);   

         fgets(cleancode3,1000,nfnfile);  
         fgets(cleancode4,1000,nfnfile);  
         fgets(cleancode5,1000,nfnfile);  
         fgets(cleancode6,1000,nfnfile);  

	     if((geom1!=1)&&(geom1!=4)&&(geom1!=5))
		 {
           printf("Error3: gm1 %d\n",geom1);
           break;
		 }
		 if((geom2!=1)&&(geom2!=4)&&(geom2!=5))
		 {
           printf("Error3: gm2 %d\n",geom2);
		   break;
		 }

		 thislen = strlen(cleancode);  if(cleancode [thislen-1]<=32){cleancode [thislen-1]='\0';}; if(cleancode [thislen-2]<=32){cleancode [thislen-2]='\0';}
		 thislen = strlen(cleancode2); if(cleancode2[thislen-1]<=32){cleancode2[thislen-1]='\0';}; if(cleancode2[thislen-2]<=32){cleancode2[thislen-2]='\0';}
		 
		 thislen = strlen(cleancode4); if(cleancode4[thislen-1]<=32){cleancode4[thislen-1]='\0';}; if(cleancode4[thislen-2]<=32){cleancode4[thislen-2]='\0';}
		 thislen = strlen(cleancode5); if(cleancode5[thislen-1]<=32){cleancode5[thislen-1]='\0';}; if(cleancode5[thislen-2]<=32){cleancode5[thislen-2]='\0';}
		 thislen = strlen(cleancode6); if(cleancode6[thislen-1]<=32){cleancode6[thislen-1]='\0';}; if(cleancode6[thislen-2]<=32){cleancode6[thislen-2]='\0';}

		 

         fprintf(htempfile,"VVTERR2WAY %d C_PRIMARY C_ALL_POFE off\n",lcindex);
         fprintf(htempfile,"VVTERR2WAY %d C_PRIMARY C_SOME_POFE on\n",lcindex);
         fprintf(htempfile,"VVTERR2WAY %d C_PRIMARY C_ALL_LINE off\n",lcindex);
         fprintf(htempfile,"VVTERR2WAY %d C_PRIMARY C_SOME_LINE on\n",lcindex);
         fprintf(htempfile,"VVTERR2WAY %d C_PRIMARY C_ALL_AREA off\n",lcindex);
         fprintf(htempfile,"VVTERR2WAY %d C_PRIMARY C_SOME_AREA on\n",lcindex);

         fprintf(htempfile,"VVTERR2WAY %d C_SECONDARY C_ALL_POFE off\n",lcindex);
         fprintf(htempfile,"VVTERR2WAY %d C_SECONDARY C_SOME_POFE on\n",lcindex);
         fprintf(htempfile,"VVTERR2WAY %d C_SECONDARY C_ALL_LINE off\n",lcindex);
         fprintf(htempfile,"VVTERR2WAY %d C_SECONDARY C_SOME_LINE on\n",lcindex);
         fprintf(htempfile,"VVTERR2WAY %d C_SECONDARY C_ALL_AREA off\n",lcindex);
         fprintf(htempfile,"VVTERR2WAY %d C_SECONDARY C_SOME_AREA on\n",lcindex);

         fprintf(htempfile,"VVTERR2WAY %d ANNOTATION \"%s %s and %s %s with %s = %s but %s = %s and %s\"\n",
		   lcindex,CNAMES[geom1],cleancode,CNAMES[geom2],cleancode2,GetNFN(),cleancode4,GetLongCode(LONG_ATTR_NAM),cleancode5,cleancode6);



		 fprintf(tempfile,"VVTERR2WAY %d PRIMARY %s %s STRING %s on %s\n",
				   lcindex,MakeCleanCode(cleancode),MakeCleanCode2(GetEACLabel(GetAttrIndex(GetNFN()))),cleancode4,GetNGACname(geom1));

		 fprintf(tempfile,"VVTERR2WAY %d SECONDARY %s %s STRING %s on %s\n",
				   lcindex,MakeCleanCode(cleancode),MakeCleanCode2(GetEACLabel(GetAttrIndex(GetLongCode(LONG_ATTR_NAM)))),cleancode5,GetNGACname(geom1));


		 fprintf(tempfile,"VVTERR2WAY %d PRIMARY %s %s STRING %s on %s\n",
				   lcindex,MakeCleanCode(cleancode2),MakeCleanCode2(GetEACLabel(GetAttrIndex(GetNFN()))),cleancode4,GetNGACname(geom2));

		 fprintf(tempfile,"VVTERR2WAY %d SECONDARY %s %s STRING %s on %s\n",
				   lcindex,MakeCleanCode(cleancode2),MakeCleanCode2(GetEACLabel(GetAttrIndex(GetLongCode(LONG_ATTR_NAM)))),cleancode6,GetNGACname(geom2));



         lcindex = lcindex + 1;

         fgets(cleancode,1000,nfnfile);  
	   } 
	 }
     fclose(nfnfile);
  } 














  for(i=0;i<TDS_IAE_num;i++)
  {
	if(ATTRTYPE_TDS6()==0)
	{
	  break;
	}


    if(TDS_IAEDEBUG==1)
	{ 
       printf("Processing %s\n",TDS_IAE[i]);
	} 
	sprintf(first,"%s",IGetNth(TDS_IAE[i],0,VERBOSE));


	if(strlen(first)>2)
	{

if(TDS_IAEDEBUG==1)
{
printf("Have new feature type %s\n",first);
}

	  finishedattrs = 0;

	  sprintf(fcode,"%s",first);

	  len = strlen(fcode);
	  for(j=1;j<len;j++)
	  {
        if(fcode[j]=='(')
		{
          fcode[j-1] = '\0';
		  break;
		}
	  }

	  for(j=0;j<maxattrs;j++)
	  {
        rowattrs [j] = -1;
        rowattrs2[j] = -1;
        rowattrs3[j] = -1;
	  }

	  numattrs = 0;

	  for(j=0;j<maxattrs;j++)
	  {
        sprintf(thisattr,"%s",IGetNth(TDS_IAE[i],j+3,SILENT));
		if(!strcmp(thisattr,"zzZZzz"))
		{
		  
          numattrs = j;
		  break;
		}

		if(strlen(thisattr)>1)
		{
		  rowattrs[j] = GetAttrIndex(thisattr);

		  

		  sprintf(tempstr,"%s2",thisattr);
		  rowattrs2[j] = SilentGetAttrIndex(tempstr);

		  if(rowattrs2[j]>=0)
		  {
		    sprintf(tempstr,"%s3",thisattr);
		    rowattrs3[j] = SilentGetAttrIndex(tempstr);
		  }
		  else
		  {
		    rowattrs3[j] = rowattrs2[j];
		  }
		}
		else
		{
		  
          numattrs = j;
		  break;
		}
	  }


	  finishedattrs = 1; 

	} 
	else
	{
      if(finishedattrs==1)
	  {
        
		finishedattrs = 2;

	    for(j=0;j<numattrs;j++)
		{ 
          if(
			  (rowattrs[j]>=0)  ||
			  (rowattrs2[j]>=0) ||
			  (rowattrs3[j]>=0)
			)
		  {
            sprintf(attrvals[j],"%s",IGetNth(TDS_IAE[i],j+3,SILENT));
		  } 
		} 

	    for(j=0;j<numattrs;j++)
		{
		  valuepresent [j] = 0;
		  valuepresent2[j] = 0;
		  valuepresent3[j] = 0;

		  if(rowattrs[j]>=0)
		  {
			valuepresent[j] = ValuePresent(fcode,GetEACCode(rowattrs[j]),attrvals[j],line_bridge_found,line_road_found,line_rail_found,line_sidetrack_found);
		  }
		  if(rowattrs2[j]>=0)
		  {
			valuepresent2[j] = ValuePresent(fcode,GetEACCode(rowattrs2[j]),attrvals[j],line_bridge_found,line_road_found,line_rail_found,line_sidetrack_found);
		  }
		  if(rowattrs3[j]>=0)
		  {
			valuepresent3[j] = ValuePresent(fcode,GetEACCode(rowattrs3[j]),attrvals[j],line_bridge_found,line_road_found,line_rail_found,line_sidetrack_found);
		  }
		} 
	  } 
	  else
	  {
        sprintf(thisrowattr,"%s",IGetNth(TDS_IAE[i],1,SILENT));
        sprintf(thisrowvalue,"%s",IGetNth(TDS_IAE[i],2,SILENT));

		thisrowattrint = GetAttrIndex(thisrowattr);

		sprintf(tempstr,"%s2",thisrowattr);
		thisrowattrint2 = SilentGetAttrIndex(tempstr);

		if(thisrowattrint2>=0)
		{
		  sprintf(tempstr,"%s3",thisrowattr);
		  thisrowattrint3 = SilentGetAttrIndex(tempstr);
		}
		else
		{
		  thisrowattrint3 = thisrowattrint2;
		}



		countedthisrow = 0;
		rowvaluepresent  = 0;
		rowvaluepresent2 = 0;
		rowvaluepresent3 = 0;

		if(thisrowattrint<0)
		{
          printf("Error:  %s not a valid attribute\n",thisrowattr);
		  exit(-1);
		}



		if(
			(!strcmp(GetEACCode(thisrowattrint),"LTN"))       ||
			(!strcmp(GetEACCode(thisrowattrint),"NPL"))       ||
			(!strcmp(GetEACCode(thisrowattrint),"ZI017_GAW"))
		  )
		{
		  
		  if(
			  (!strcmp(thisrowvalue,"No Information")) ||
			  (!strcmp(thisrowvalue,"-999999"))
			 )
		  {
	        rowvaluepresent = ValuePresent(fcode,GetEACCode(thisrowattrint),"-999999.0",line_bridge_found,line_road_found,line_rail_found,line_sidetrack_found);
		  }
		  else if(
			       (!strcmp(thisrowvalue,"1")) ||
			       (!strcmp(thisrowvalue,"2"))
				  )
		  {
	        rowvaluepresent = ValuePresent(fcode,GetEACCode(thisrowattrint),thisrowvalue,line_bridge_found,line_road_found,line_rail_found,line_sidetrack_found);
		  }
		  else if(strstr(thisrowvalue,"=1.435"))
		  {
	        rowvaluepresent = ValuePresent(fcode,GetEACCode(thisrowattrint),"1.435",line_bridge_found,line_road_found,line_rail_found,line_sidetrack_found);

            

		  }
		  else
		  {

			if(!strcmp(thisrowvalue,">=3"))
			{
		      

			  maxVal1 = -9999999;
              maxVal2 = -9999999;
              maxVal3 = -9999999;

	          if(NUM_Getter(GetEACCode(thisrowattrint),"(POINT)",fcode,&minVal,&maxVal1,-9999999,9999999,0,&smalljunkflag,-999,&djunk,-999)>0)
			  { 
				if(TDS_IAEDEBUG==1)
				{
			      printf("for point %s...found range of %s...%lf to %lf\n",fcode,GetEACCode(thisrowattrint),minVal,maxVal1);
				}
				if(maxVal1>=3.0)
				{
				  rowvaluepresent = 100;
				}
			  } 
	          if(NUM_Getter(GetEACCode(thisrowattrint),"(LINE)",fcode,&minVal,&maxVal2,-9999999,9999999,0,&smalljunkflag,-999,&djunk,-999)>0)
			  { 
			    if(TDS_IAEDEBUG==1)
				{
				  printf("for line %s...found range of %s...%lf to %lf\n",fcode,GetEACCode(thisrowattrint),minVal,maxVal2);
				}
				if(maxVal2>=3.0)
				{
				  rowvaluepresent = rowvaluepresent + 10;
				}
			  } 
	          if(NUM_Getter(GetEACCode(thisrowattrint),"(AREA)",fcode,&minVal,&maxVal3,-9999999,9999999,0,&smalljunkflag,-999,&djunk,-999)>0)
			  { 
			    if(TDS_IAEDEBUG==1)
				{
				  printf("for area %s...found range of %s...%lf to %lf\n",fcode,GetEACCode(thisrowattrint),minVal,maxVal3);
				}
				if(maxVal3>=3.0)
				{
				  rowvaluepresent = rowvaluepresent + 1;
				}
			  } 

			  if(TDS_IAEDEBUG==1)
			  {
			    printf("*** have rowvaluepresent %d and maxVal %lf %lf %lf\n",rowvaluepresent,maxVal1,maxVal2,maxVal3);
			  }
			}





			else if(
				     (strstr(thisrowvalue,">1.435")) ||
				     (strstr(thisrowvalue,"<1.435"))
				   )
			{
              

			  minVal1a = -9999999;
              minVal2a = -9999999;
              minVal3a = -9999999;

			  maxVal1a = -9999999;
              maxVal2a = -9999999;
              maxVal3a = -9999999;

			  smallover1 = 1234567;
			  smallover2 = 1234567;
			  smallover3 = 1234567;

			  largeunder1 = -1234567;
			  largeunder2 = -1234567;
			  largeunder3 = -1234567;



	          if(NUM_Getter(GetEACCode(thisrowattrint),"(POINT)",fcode,&minVal1a,&maxVal1a,-999998,9999999,0,&smallover1,1.435,&largeunder1,1.435)>0)
			  { 
				if(TDS_IAEDEBUG==1)
				{
			      printf("for point %s...found range of %s...%lf to %lf\n",fcode,GetEACCode(thisrowattrint),minVal1a,maxVal1a);
				}
				if( (strstr(thisrowvalue,">1.435")) && (maxVal1a>1.435) )
				{
				  rowvaluepresent = 100;
				}
				if( (strstr(thisrowvalue,"<1.435")) && (minVal1a<1.435) )
				{
				  rowvaluepresent = 100;
				}
			  } 
	          if(NUM_Getter(GetEACCode(thisrowattrint),"(LINE)",fcode,&minVal2a,&maxVal2a,-999998,9999999,0,&smallover2,1.435,&largeunder2,1.435)>0)
			  { 
			    if(TDS_IAEDEBUG==1)
				{
				  printf("for line %s...found range of %s...%lf to %lf\n",fcode,GetEACCode(thisrowattrint),minVal2a,maxVal2a);
				}
				if( (strstr(thisrowvalue,">1.435")) && (maxVal2a>1.435) )
				{
				  rowvaluepresent = rowvaluepresent + 10;
				}
				if( (strstr(thisrowvalue,"<1.435")) && (minVal2a<1.435) )
				{
				  rowvaluepresent = rowvaluepresent + 10;
				}
			  } 
	          if(NUM_Getter(GetEACCode(thisrowattrint),"(AREA)",fcode,&minVal3a,&maxVal3a,-999998,9999999,0,&smallover3,1.435,&largeunder3,1.435)>0)
			  { 
			    if(TDS_IAEDEBUG==1)
				{
				  printf("for area %s...found range of %s...%lf to %lf\n",fcode,GetEACCode(thisrowattrint),minVal3a,maxVal3a);
				}
				if( (strstr(thisrowvalue,">1.435")) && (maxVal3a>1.435) )
				{
				  rowvaluepresent = rowvaluepresent + 1;
				}
				if( (strstr(thisrowvalue,"<1.435")) && (minVal3a<1.435) )
				{
				  rowvaluepresent = rowvaluepresent + 1;
				}
			  } 

			  if(TDS_IAEDEBUG==1)
			  {
			    printf("*** for %s %s %s have rowvaluepresent %d and minval %.18lf %.18lf %.18lf maxVal %lf %lf %lf  smallest over %lf %lf %lf largest under %lf %lf %lf\n",
					fcode,GetEACCode(thisrowattrint),thisrowvalue,
					rowvaluepresent,
					minVal1a,minVal2a,minVal3a,
					maxVal1a,maxVal2a,maxVal3a,
					smallover1,smallover2,smallover3,
					largeunder1,largeunder2,largeunder3);
			  }
			}

		    else
			{
			  printf("unexpecgted value %s to PRDRD\n",thisrowvalue);
			  rowvaluepresent = 0;
			}
		  }
		}
		else
		{
          rowvaluepresent  = 0;
          rowvaluepresent2 = 0;
          rowvaluepresent3 = 0;

          if(thisrowattrint>0)
		  {
	        rowvaluepresent = ValuePresent(fcode,GetEACCode(thisrowattrint),thisrowvalue,line_bridge_found,line_road_found,line_rail_found,line_sidetrack_found);
		  }
          if(thisrowattrint2>0)
		  {
	        rowvaluepresent2 = ValuePresent(fcode,GetEACCode(thisrowattrint2),thisrowvalue,line_bridge_found,line_road_found,line_rail_found,line_sidetrack_found);
		  }
          if(thisrowattrint3>0)
		  {
	        rowvaluepresent3 = ValuePresent(fcode,GetEACCode(thisrowattrint3),thisrowvalue,line_bridge_found,line_road_found,line_rail_found,line_sidetrack_found);
		  }
		}





		

		

if(do_points==1)
{				
		wroteheader = 0;

		if(
			
			(rowvaluepresent==100) ||(rowvaluepresent==101) ||(rowvaluepresent==110) ||(rowvaluepresent==111)  ||
			(rowvaluepresent2==100)||(rowvaluepresent2==101)||(rowvaluepresent2==110)||(rowvaluepresent2==111) ||
			(rowvaluepresent3==100)||(rowvaluepresent3==101)||(rowvaluepresent3==110)||(rowvaluepresent3==111)
		  )
		{
          for(j=0;j<numattrs;j++)
		  {
            if(
				(rowattrs [j]>=0) ||
				(rowattrs2[j]>=0) ||
				(rowattrs3[j]>=0) 
			  )
			{ 
              sprintf(isx,"%s",IGetNth(TDS_IAE[i],j+3,SILENT));

			  if(strlen(isx)>0)
			  {
                if(
					(valuepresent[j]==100) ||(valuepresent[j]==101) ||(valuepresent[j]==110) ||(valuepresent[j]==111)  ||
					(valuepresent2[j]==100)||(valuepresent2[j]==101)||(valuepresent2[j]==110)||(valuepresent2[j]==111) ||
					(valuepresent3[j]==100)||(valuepresent3[j]==101)||(valuepresent3[j]==110)||(valuepresent3[j]==111)
					)
				{
                    

					if(type==1)
				   { 
					   if(wroteheader==0)
					   {
                        fprintf(htempfile,"VVTERR2WAY %d C_PRIMARY C_ALL_POFE off\n",lcindex);
                        fprintf(htempfile,"VVTERR2WAY %d C_PRIMARY C_SOME_POFE on\n",lcindex);
                        fprintf(htempfile,"VVTERR2WAY %d C_SECONDARY C_ALL_LINE off\n",lcindex);
                        fprintf(htempfile,"VVTERR2WAY %d C_SECONDARY C_SOME_LINE on\n",lcindex);
                        fprintf(htempfile,"VVTERR2WAY %d C_SECONDARY C_ALL_AREA off\n",lcindex);
                        fprintf(htempfile,"VVTERR2WAY %d C_SECONDARY C_SOME_AREA on\n",lcindex);

						
                        fprintf(htempfile,"VVTERR2WAY %d ANNOTATION \"Illogical Attribute/Enumeration (IAE): Point %s with \"%s\" = \"%s\" and ",
					 	  lcindex,fcode,GetEACCode(thisrowattrint),thisrowvalue);

						

						firstextra=1;

						for(k=j;k<numattrs;k++)
						{
						  if(
							  (rowattrs[k]>=0) ||
							  (rowattrs2[k]>=0) ||
							  (rowattrs3[k]>=0)
							)
						  {
                            sprintf(isx,"%s",IGetNth(TDS_IAE[i],k+3,SILENT));

			                if(strlen(isx)>0)
							{ 
                              if(
								  (valuepresent[k]==100) ||(valuepresent[k]==101) ||(valuepresent[k]==110) ||(valuepresent[k]==111)  ||
								  (valuepresent2[k]==100)||(valuepresent2[k]==101)||(valuepresent2[k]==110)||(valuepresent2[k]==111) ||
								  (valuepresent3[k]==100)||(valuepresent3[k]==101)||(valuepresent3[k]==110)||(valuepresent3[k]==111)
								  )
							  {
								 
								 if(firstextra==1)
								 {
								   fprintf(htempfile,"\"%s\" = \"%s\"",GetEACCode(rowattrs[k]),attrvals[k]);
								   firstextra = 0;
								 }
								 else
								 {
	 							   fprintf(htempfile," or \"%s\" = \"%s\"",GetEACCode(rowattrs[k]),attrvals[k]);
								 }
							  }
							} 
						  } 
						}

						fprintf(htempfile,"\"\n");

                        lcindex = lcindex + 1;
						wroteheader = 1;
					   }

                       

					   
				   } 

					if(type==1)
				   { 
					 if(countedthisrow==0)  
					 { 

					   

					   if (
						   (!strcmp(GetEACCode(thisrowattrint),"LTN"))       ||  
						   (!strcmp(GetEACCode(thisrowattrint),"NPL"))       ||
						   (!strcmp(GetEACCode(thisrowattrint),"ZI017_GAW"))
						  )

					   { 




						   if(IsNumeric(thisrowvalue)==0)
						   {

							if(!strcmp(thisrowvalue,">=3"))
							{
							  if(maxVal1>=3.0) 
							  {
                                fprintf(tempfile,"VVTERR2WAY %d PRIMARY %s %s RANGE 3.0 %lf on C_POFE\n",
						          lcindex-1,
						          MakeCleanCode(fcode),
						          MakeCleanCode2(GetEACLabel(thisrowattrint)),
						          maxVal1);
							  }
							}
							else if(strstr(thisrowvalue,"=1.435"))
							{
                                fprintf(tempfile,"VVTERR2WAY %d PRIMARY %s %s RANGE 1.435 1.435 on C_POFE\n",
						          lcindex-1,
						          MakeCleanCode(fcode),
						          MakeCleanCode2(GetEACLabel(thisrowattrint)));
							}
							else if(strstr(thisrowvalue,">1.435"))
							{
                                fprintf(tempfile,"VVTERR2WAY %d PRIMARY %s %s RANGE %lf %lf on C_POFE\n",
						          lcindex-1,
						          MakeCleanCode(fcode),
						          MakeCleanCode2(GetEACLabel(thisrowattrint)),
								  smallover1,maxVal1a);
							}
							else if(strstr(thisrowvalue,"<1.435"))
							{
                                fprintf(tempfile,"VVTERR2WAY %d PRIMARY %s %s RANGE %lf %lf on C_POFE\n",
						          lcindex-1,
						          MakeCleanCode(fcode),
						          MakeCleanCode2(GetEACLabel(thisrowattrint)),
								  minVal1a,largeunder1);
							}
							else
							{
                             printf("Error in parsing IVL1d point %s %s:  %s\n\n\n",MakeCleanCode(fcode),MakeCleanCode2(GetEACLabel(thisrowattrint)),thisrowvalue);
							}
						   }
						   else
						   {
                             fprintf(tempfile,"VVTERR2WAY %d PRIMARY %s %s RANGE %s %s on C_POFE\n",
						       lcindex-1,
						       MakeCleanCode(fcode),
						       MakeCleanCode2(GetEACLabel(thisrowattrint)),
						       thisrowvalue,thisrowvalue);
						   } 
					   } 
					   else
					   { 

			             if((rowvaluepresent==100) ||(rowvaluepresent==101) ||(rowvaluepresent==110) ||(rowvaluepresent==111))
						 {
                           fprintf(tempfile,"VVTERR2WAY %d PRIMARY %s %s LABEL %s on C_POFE\n",
						      lcindex-1,
						      MakeCleanCode(fcode),
						      MakeCleanCode2(GetEACLabel(thisrowattrint)),
						      MakeCleanCode3(thisrowvalue));
						 }
			             if((rowvaluepresent2==100)||(rowvaluepresent2==101)||(rowvaluepresent2==110)||(rowvaluepresent2==111))
						 {
                           fprintf(tempfile,"VVTERR2WAY %d PRIMARY %s %s LABEL %s on C_POFE\n",
						      lcindex-1,
						      MakeCleanCode(fcode),
						      MakeCleanCode2(GetEACLabel(thisrowattrint2)),
						      MakeCleanCode3(thisrowvalue));
						 }
			             if((rowvaluepresent3==100)||(rowvaluepresent3==101)||(rowvaluepresent3==110)||(rowvaluepresent3==111))
						 {
                           fprintf(tempfile,"VVTERR2WAY %d PRIMARY %s %s LABEL %s on C_POFE\n",
						      lcindex-1,
						      MakeCleanCode(fcode),
						      MakeCleanCode2(GetEACLabel(thisrowattrint3)),
						      MakeCleanCode3(thisrowvalue));
						 }
					   } 
					 } 
 


			         if(!strcmp(GetEACCode(rowattrs[j]),"NPL")) 
					 {
					   printf("Secondary NPL (1) %d...problem\n",lcindex-1);
					 }
				     else if(!strcmp(GetEACCode(rowattrs[j]),"LTN")) 
					 {
					   printf("Secondary LTN (1) %d...problem\n",lcindex-1);
					 }
				     else if(!strcmp(GetEACCode(rowattrs[j]),"ZI017_GAW")) 
					 {
					   printf("Secondary ZI017_GAW (1) %d...problem\n",lcindex-1);
					 }
					 else
					 {

					   if((valuepresent[j]==100)||(valuepresent[j]==101)||(valuepresent[j]==110)||(valuepresent[j]==111))
					   {
                          fprintf(tempfile,"VVTERR2WAY %d SECONDARY %s %s LABEL %s on C_POFE\n",
						     lcindex-1,
						     MakeCleanCode(fcode),
						     MakeCleanCode2(GetEACLabel(rowattrs[j])),
						     MakeCleanCode3(attrvals[j]));
					   }
					   if((valuepresent2[j]==100)||(valuepresent2[j]==101)||(valuepresent2[j]==110)||(valuepresent2[j]==111))
					   {
                          fprintf(tempfile,"VVTERR2WAY %d SECONDARY %s %s LABEL %s on C_POFE\n",
						     lcindex-1,
						     MakeCleanCode(fcode),
						     MakeCleanCode2(GetEACLabel(rowattrs2[j])),
						     MakeCleanCode3(attrvals[j]));
					   }
					   if((valuepresent3[j]==100)||(valuepresent3[j]==101)||(valuepresent3[j]==110)||(valuepresent3[j]==111))
					   {
                          fprintf(tempfile,"VVTERR2WAY %d SECONDARY %s %s LABEL %s on C_POFE\n",
						     lcindex-1,
						     MakeCleanCode(fcode),
						     MakeCleanCode2(GetEACLabel(rowattrs3[j])),
						     MakeCleanCode3(attrvals[j]));
					   }
					 }
				   } 
				   
                   if(countedthisrow==0)
				   { 
				      numinstances = numinstances + 1;
				   } 
                   countedthisrow = 1;
				} 
			  } 
			} 
		  } 
		}

		
}



if(do_lines==1)
{
		
				
		wroteheader = 0;
		countedthisrow = 0;

		if(
             
			(rowvaluepresent==10) ||(rowvaluepresent==11) ||(rowvaluepresent==110) ||(rowvaluepresent==111)   ||
			(rowvaluepresent2==10)||(rowvaluepresent2==11)||(rowvaluepresent2==110)||(rowvaluepresent2==111)  ||
			(rowvaluepresent3==10)||(rowvaluepresent3==11)||(rowvaluepresent3==110)||(rowvaluepresent3==111)
		  )
		{
          for(j=0;j<numattrs;j++)
		  {
            if(rowattrs[j]>=0)
			{ 
              sprintf(isx,"%s",IGetNth(TDS_IAE[i],j+3,SILENT));

			  if(strlen(isx)>0)
			  {
                if(
					(valuepresent[j]==10) ||(valuepresent[j]==11) ||(valuepresent[j]==110) ||(valuepresent[j]==111)  ||
					(valuepresent2[j]==10)||(valuepresent2[j]==11)||(valuepresent2[j]==110)||(valuepresent2[j]==111) ||
					(valuepresent3[j]==10)||(valuepresent3[j]==11)||(valuepresent3[j]==110)||(valuepresent3[j]==111) 
					)
				{
 	               

					if(type==1)
				   { 
					   if(wroteheader==0)
					   {
                        fprintf(htempfile,"VVTERR2WAY %d C_PRIMARY C_ALL_POFE off\n",lcindex);
                        fprintf(htempfile,"VVTERR2WAY %d C_PRIMARY C_SOME_POFE on\n",lcindex);
                        fprintf(htempfile,"VVTERR2WAY %d C_SECONDARY C_ALL_LINE off\n",lcindex);
                        fprintf(htempfile,"VVTERR2WAY %d C_SECONDARY C_SOME_LINE on\n",lcindex);
                        fprintf(htempfile,"VVTERR2WAY %d C_SECONDARY C_ALL_AREA off\n",lcindex);
                        fprintf(htempfile,"VVTERR2WAY %d C_SECONDARY C_SOME_AREA on\n",lcindex);

						
                        fprintf(htempfile,"VVTERR2WAY %d ANNOTATION \"Illogical Attribute/Enumeration (IAE): Line %s with \"%s\" = \"%s\" and ",
					 	  lcindex,fcode,GetEACCode(thisrowattrint),thisrowvalue);

						

						firstextra=1;

						for(k=j;k<numattrs;k++)
						{
						  if(rowattrs[k]>=0)
						  {
                            sprintf(isx,"%s",IGetNth(TDS_IAE[i],k+3,SILENT));

			                if(strlen(isx)>0)
							{ 
                              if(
								  (valuepresent[k]==10) ||(valuepresent[k]==11) ||(valuepresent[k]==110) ||(valuepresent[k]==111)  ||
								  (valuepresent2[k]==10)||(valuepresent2[k]==11)||(valuepresent2[k]==110)||(valuepresent2[k]==111) ||
								  (valuepresent3[k]==10)||(valuepresent3[k]==11)||(valuepresent3[k]==110)||(valuepresent3[k]==111)
								  
								  )
							  {
								 
								 if(firstextra==1)
								 {
								   fprintf(htempfile,"\"%s\" = \"%s\"",GetEACCode(rowattrs[k]),attrvals[k]);
								   firstextra = 0;
								 }
								 else
								 {
	 							   fprintf(htempfile," or \"%s\" = \"%s\"",GetEACCode(rowattrs[k]),attrvals[k]);
								 }
							  }
							} 
						  } 
						}

						fprintf(htempfile,"\"\n");

                        lcindex = lcindex + 1;
						wroteheader = 1;
					   }

                       

					   
				   } 


					if(type==1)
				   { 
					 if(countedthisrow==0)  
					 { 

					   

					   if (
						   (!strcmp(GetEACCode(thisrowattrint),"LTN"))       || 
						   (!strcmp(GetEACCode(thisrowattrint),"NPL"))       ||
						   (!strcmp(GetEACCode(thisrowattrint),"ZI017_GAW"))
						  )
					   { 




						   if(IsNumeric(thisrowvalue)==0)
						   {

							if(!strcmp(thisrowvalue,">=3"))
							{
							  if(maxVal2>=3.0) 
							  {
                                fprintf(tempfile,"VVTERR2WAY %d PRIMARY %s %s RANGE 3.0 %lf on C_LINE\n",
						          lcindex-1,
						          MakeCleanCode(fcode),
						          MakeCleanCode2(GetEACLabel(thisrowattrint)),
						          maxVal2);
							  }
							}
							else if(strstr(thisrowvalue,"=1.435"))
							{
                                fprintf(tempfile,"VVTERR2WAY %d PRIMARY %s %s RANGE 1.435 1.435 on C_LINE\n",
						          lcindex-1,
						          MakeCleanCode(fcode),
						          MakeCleanCode2(GetEACLabel(thisrowattrint)));
							}
							else if(strstr(thisrowvalue,">1.435"))
							{
                                fprintf(tempfile,"VVTERR2WAY %d PRIMARY %s %s RANGE %lf %lf on C_LINE\n",
						          lcindex-1,
						          MakeCleanCode(fcode),
						          MakeCleanCode2(GetEACLabel(thisrowattrint)),
								  smallover2,maxVal2a);
							}
							else if(strstr(thisrowvalue,"<1.435"))
							{
                                fprintf(tempfile,"VVTERR2WAY %d PRIMARY %s %s RANGE %lf %lf on C_LINE\n",
						          lcindex-1,
						          MakeCleanCode(fcode),
						          MakeCleanCode2(GetEACLabel(thisrowattrint)),
								  minVal2a,largeunder2);
							}

							else
							{
                             printf("Error in parsing IVL1e line %s %s:  %s\n\n\n",MakeCleanCode(fcode),MakeCleanCode2(GetEACLabel(thisrowattrint)),thisrowvalue);
							}
						   }
						   else
						   {
                             fprintf(tempfile,"VVTERR2WAY %d PRIMARY %s %s RANGE %s %s on C_LINE\n",
						       lcindex-1,
						       MakeCleanCode(fcode),
						       MakeCleanCode2(GetEACLabel(thisrowattrint)),
						       thisrowvalue,thisrowvalue);
						   } 
					   } 
					   else
					   { 
			              if((rowvaluepresent==10) ||(rowvaluepresent==11) ||(rowvaluepresent==110) ||(rowvaluepresent==111))
						  {
                            fprintf(tempfile,"VVTERR2WAY %d PRIMARY %s %s LABEL %s on C_LINE\n",
						      lcindex-1,
						      MakeCleanCode(fcode),
						      MakeCleanCode2(GetEACLabel(thisrowattrint)),
						      MakeCleanCode3(thisrowvalue));
						  }
			              if((rowvaluepresent2==10)||(rowvaluepresent2==11)||(rowvaluepresent2==110)||(rowvaluepresent2==111))
						  {
                            fprintf(tempfile,"VVTERR2WAY %d PRIMARY %s %s LABEL %s on C_LINE\n",
						      lcindex-1,
						      MakeCleanCode(fcode),
						      MakeCleanCode2(GetEACLabel(thisrowattrint2)),
						      MakeCleanCode3(thisrowvalue));
						  }
			              if((rowvaluepresent3==10)||(rowvaluepresent3==11)||(rowvaluepresent3==110)||(rowvaluepresent3==111))
						  {
                            fprintf(tempfile,"VVTERR2WAY %d PRIMARY %s %s LABEL %s on C_LINE\n",
						      lcindex-1,
						      MakeCleanCode(fcode),
						      MakeCleanCode2(GetEACLabel(thisrowattrint3)),
						      MakeCleanCode3(thisrowvalue));
						  }
					   } 
					 } 
 

			         if(!strcmp(GetEACCode(rowattrs[j]),"NPL"))
					 {
					   printf("Secondary NPL (2) %d...problem\n",lcindex-1);
					 }
				     else if(!strcmp(GetEACCode(rowattrs[j]),"LTN"))
					 {
					   printf("Secondary LTN (2) %d...problem\n",lcindex-1);
					 }
				     else if(!strcmp(GetEACCode(rowattrs[j]),"ZI017_GAW")) 
					 {
					   printf("Secondary ZI017_GAW (2) %d...problem\n",lcindex-1);
					 }
					 else
					 {

					   if((valuepresent[j]==10) ||(valuepresent[j]==11) ||(valuepresent[j]==110) ||(valuepresent[j]==111))
					   {
                        fprintf(tempfile,"VVTERR2WAY %d SECONDARY %s %s LABEL %s on C_LINE\n",
						  lcindex-1,
						  MakeCleanCode(fcode),
						  MakeCleanCode2(GetEACLabel(rowattrs[j])),
						  MakeCleanCode3(attrvals[j]));
					   }

					   if((valuepresent2[j]==10)||(valuepresent2[j]==11)||(valuepresent2[j]==110)||(valuepresent2[j]==111))
					   {
                        fprintf(tempfile,"VVTERR2WAY %d SECONDARY %s %s LABEL %s on C_LINE\n",
						  lcindex-1,
						  MakeCleanCode(fcode),
						  MakeCleanCode2(GetEACLabel(rowattrs2[j])),
						  MakeCleanCode3(attrvals[j]));
					   }

					   if((valuepresent3[j]==10)||(valuepresent3[j]==11)||(valuepresent3[j]==110)||(valuepresent3[j]==111))
					   {
                        fprintf(tempfile,"VVTERR2WAY %d SECONDARY %s %s LABEL %s on C_LINE\n",
						  lcindex-1,
						  MakeCleanCode(fcode),
						  MakeCleanCode2(GetEACLabel(rowattrs3[j])),
						  MakeCleanCode3(attrvals[j]));
					   }
					 }
					 
				   } 
				   
                   if(countedthisrow==0)
				   { 
				      numinstances = numinstances + 1;
				   } 
                   countedthisrow = 1;
				} 
			  } 
			} 
		  } 
		}

		
}








if(do_areas==1)
{


		
				
		wroteheader = 0;
		countedthisrow = 0;

		if(
            
			(rowvaluepresent==1) ||(rowvaluepresent==11) ||(rowvaluepresent==101) ||(rowvaluepresent==111)  ||
			(rowvaluepresent2==1)||(rowvaluepresent2==11)||(rowvaluepresent2==101)||(rowvaluepresent2==111) ||
			(rowvaluepresent3==1)||(rowvaluepresent3==11)||(rowvaluepresent3==101)||(rowvaluepresent3==111)
		  ) 
		{
          for(j=0;j<numattrs;j++)
		  {
            if(rowattrs[j]>=0)
			{ 
              sprintf(isx,"%s",IGetNth(TDS_IAE[i],j+3,SILENT));

			  if(strlen(isx)>0)
			  {
                if(
					(valuepresent[j]==1) ||(valuepresent[j]==11) ||(valuepresent[j]==101) ||(valuepresent[j]==111)  ||
					(valuepresent2[j]==1)||(valuepresent2[j]==11)||(valuepresent2[j]==101)||(valuepresent2[j]==111) ||
					(valuepresent3[j]==1)||(valuepresent3[j]==11)||(valuepresent3[j]==101)||(valuepresent3[j]==111)
				  )
				{

 	           


					if(type==1)
				   { 
					   if(wroteheader==0)
					   {
                        fprintf(htempfile,"VVTERR2WAY %d C_PRIMARY C_ALL_POFE off\n",lcindex);
                        fprintf(htempfile,"VVTERR2WAY %d C_PRIMARY C_SOME_POFE on\n",lcindex);
                        fprintf(htempfile,"VVTERR2WAY %d C_SECONDARY C_ALL_LINE off\n",lcindex);
                        fprintf(htempfile,"VVTERR2WAY %d C_SECONDARY C_SOME_LINE on\n",lcindex);
                        fprintf(htempfile,"VVTERR2WAY %d C_SECONDARY C_ALL_AREA off\n",lcindex);
                        fprintf(htempfile,"VVTERR2WAY %d C_SECONDARY C_SOME_AREA on\n",lcindex);

						
                        fprintf(htempfile,"VVTERR2WAY %d ANNOTATION \"Illogical Attribute/Enumeration (IAE): Area %s with \"%s\" = \"%s\" and ",
					 	  lcindex,fcode,GetEACCode(thisrowattrint),thisrowvalue);

						

						firstextra=1;

						for(k=j;k<numattrs;k++)
						{
						  if(rowattrs[k]>=0)
						  {
                            sprintf(isx,"%s",IGetNth(TDS_IAE[i],k+3,SILENT));

			                if(strlen(isx)>0)
							{ 

                              if(
								  (valuepresent[k]==1) ||(valuepresent[k]==11) ||(valuepresent[k]==101) ||(valuepresent[k]==111)  ||
								  (valuepresent2[k]==1)||(valuepresent2[k]==11)||(valuepresent2[k]==101)||(valuepresent2[k]==111) ||
								  (valuepresent3[k]==1)||(valuepresent3[k]==11)||(valuepresent3[k]==101)||(valuepresent3[k]==111)
								)
							  {
								 
								 if(firstextra==1)
								 {
								   fprintf(htempfile,"\"%s\" = \"%s\"",GetEACCode(rowattrs[k]),attrvals[k]);
								   firstextra = 0;
								 }
								 else
								 {
	 							   fprintf(htempfile," or \"%s\" = \"%s\"",GetEACCode(rowattrs[k]),attrvals[k]);
								 }
							  }
							} 
						  } 
						}

						fprintf(htempfile,"\"\n");

                        lcindex = lcindex + 1;
						wroteheader = 1;
					   
					   }

                       

					   
				   } 

				   
					if(type==1)
				   { 
					 if(countedthisrow==0)  
					 { 

					   
					   if (
						   (!strcmp(GetEACCode(thisrowattrint),"LTN"))      ||  
						   (!strcmp(GetEACCode(thisrowattrint),"NPL"))      ||
						   (!strcmp(GetEACCode(thisrowattrint),"ZI017_GAW"))
						  )
					   { 



						  if(IsNumeric(thisrowvalue)==0)
						  {

							if(!strcmp(thisrowvalue,">=3"))
							{
							  if(maxVal3>=3.0) 
							  {
                                fprintf(tempfile,"VVTERR2WAY %d PRIMARY %s %s RANGE 3.0 %lf on C_AREA\n",
						          lcindex-1,
						          MakeCleanCode(fcode),
						          MakeCleanCode2(GetEACLabel(thisrowattrint)),
						          maxVal3);
							  }
							}
							else if(strstr(thisrowvalue,"=1.435"))
							{
                                fprintf(tempfile,"VVTERR2WAY %d PRIMARY %s %s RANGE 1.435 1.435 on C_AREA\n",
						          lcindex-1,
						          MakeCleanCode(fcode),
						          MakeCleanCode2(GetEACLabel(thisrowattrint)));
							}
							else if(strstr(thisrowvalue,">1.435"))
							{
                                fprintf(tempfile,"VVTERR2WAY %d PRIMARY %s %s RANGE %lf %lf on C_AREA\n",
						          lcindex-1,
						          MakeCleanCode(fcode),
						          MakeCleanCode2(GetEACLabel(thisrowattrint)),
								  smallover3,maxVal3a);
							}
							else if(strstr(thisrowvalue,"<1.435"))
							{
                                fprintf(tempfile,"VVTERR2WAY %d PRIMARY %s %s RANGE %lf %lf on C_AREA\n",
						          lcindex-1,
						          MakeCleanCode(fcode),
						          MakeCleanCode2(GetEACLabel(thisrowattrint)),
								  minVal3a,largeunder3);
							}


							else
							{
                             printf("Error in parsing IVL1a area %s %s:  %s\n\n\n",MakeCleanCode(fcode),MakeCleanCode2(GetEACLabel(thisrowattrint)),thisrowvalue);
							}
						  } 
						  else
						  {
                            fprintf(tempfile,"VVTERR2WAY %d PRIMARY %s %s RANGE %s %s on C_AREA\n",
						      lcindex-1,
						      MakeCleanCode(fcode),
						      MakeCleanCode2(GetEACLabel(thisrowattrint)),
						      thisrowvalue,thisrowvalue);
						  } 
					   } 
					   else
					   { 
			              if((rowvaluepresent==1) ||(rowvaluepresent==11) ||(rowvaluepresent==101) ||(rowvaluepresent==111))
						  {
                            fprintf(tempfile,"VVTERR2WAY %d PRIMARY %s %s LABEL %s on C_AREA\n",
						      lcindex-1,
						      MakeCleanCode(fcode),
						      MakeCleanCode2(GetEACLabel(thisrowattrint)),
						      MakeCleanCode3(thisrowvalue));
						  }
			              if((rowvaluepresent2==1)||(rowvaluepresent2==11)||(rowvaluepresent2==101)||(rowvaluepresent2==111))
						  {
                            fprintf(tempfile,"VVTERR2WAY %d PRIMARY %s %s LABEL %s on C_AREA\n",
						      lcindex-1,
						      MakeCleanCode(fcode),
						      MakeCleanCode2(GetEACLabel(thisrowattrint2)),
						      MakeCleanCode3(thisrowvalue));
						  }
			              if((rowvaluepresent3==1)||(rowvaluepresent3==11)||(rowvaluepresent3==101)||(rowvaluepresent3==111))
						  {
                            fprintf(tempfile,"VVTERR2WAY %d PRIMARY %s %s LABEL %s on C_AREA\n",
						      lcindex-1,
						      MakeCleanCode(fcode),
						      MakeCleanCode2(GetEACLabel(thisrowattrint3)),
						      MakeCleanCode3(thisrowvalue));
						  }
					   } 
					 } 
 

			         if(!strcmp(GetEACCode(rowattrs[j]),"NPL"))
					 {
					   printf("Secondary NPL (3) %d...problem\n",lcindex-1);
					 }
				     else if(!strcmp(GetEACCode(rowattrs[j]),"LTN"))
					 {
					   printf("Secondary LTN (3) %d...problem\n",lcindex-1);
					 }
				     else if(!strcmp(GetEACCode(rowattrs[j]),"ZI017_GAW")) 
					 {
					   printf("Secondary ZI017_GAW (3) %d...problem\n",lcindex-1);
					 }
					 else
					 {

					   if((valuepresent[j]==1) ||(valuepresent[j]==11) ||(valuepresent[j]==101) ||(valuepresent[j]==111))
					   {
                         fprintf(tempfile,"VVTERR2WAY %d SECONDARY %s %s LABEL %s on C_AREA\n",
						   lcindex-1,
						   MakeCleanCode(fcode),
						   MakeCleanCode2(GetEACLabel(rowattrs[j])),
						   MakeCleanCode3(attrvals[j]));
					   }

					   if((valuepresent2[j]==1)||(valuepresent2[j]==11)||(valuepresent2[j]==101)||(valuepresent2[j]==111))
					   {
                         fprintf(tempfile,"VVTERR2WAY %d SECONDARY %s %s LABEL %s on C_AREA\n",
						   lcindex-1,
						   MakeCleanCode(fcode),
						   MakeCleanCode2(GetEACLabel(rowattrs2[j])),
						   MakeCleanCode3(attrvals[j]));
					   }

					   if((valuepresent3[j]==1)||(valuepresent3[j]==11)||(valuepresent3[j]==101)||(valuepresent3[j]==111))
					   {
                         fprintf(tempfile,"VVTERR2WAY %d SECONDARY %s %s LABEL %s on C_AREA\n",
						   lcindex-1,
						   MakeCleanCode(fcode),
						   MakeCleanCode2(GetEACLabel(rowattrs3[j])),
						   MakeCleanCode3(attrvals[j]));
					   }
					 }
					
				   } 
				   
                   if(countedthisrow==0)
				   { 
				      numinstances = numinstances + 1;
				   } 
                   countedthisrow = 1;
				} 
			  } 
			} 
		  } 
		}

		


	  }
	} 
  } 



}


  fclose(htempfile);
  fclose(tempfile);



  







  docheck1 = 0; 
  docheck2 = 0; 
  docheck3 = 0; 


  if((point_tower_found+area_tower_found)>0)
  {
    docheck1 = 1;
  }

  if((point_transStation_found+area_transStation_found)>0)
  {
	

	if(FindAttr(-1,FIND_ENUM,"(POINT)", "Transportation Station", "TRS",  "Underground Railway")) {point_underground1 = 1;docheck2 = 1;}
	if(FindAttr(-1,FIND_ENUM,"(POINT)", "Transportation Station", "TRS2", "Underground Railway")) {point_underground2 = 1;docheck2 = 1;}
	if(FindAttr(-1,FIND_ENUM,"(POINT)", "Transportation Station", "TRS3", "Underground Railway")) {point_underground3 = 1;docheck2 = 1;}

	if(FindAttr(-1,FIND_ENUM,"(AREA)",  "Transportation Station", "TRS",  "Underground Railway")) {area_underground1  = 1;docheck2 = 1;}
	if(FindAttr(-1,FIND_ENUM,"(AREA)",  "Transportation Station", "TRS2", "Underground Railway")) {area_underground2  = 1;docheck2 = 1;}
	if(FindAttr(-1,FIND_ENUM,"(AREA)",  "Transportation Station", "TRS3", "Underground Railway")) {area_underground3  = 1;docheck2 = 1;}    
  }

  if(point_building_found>0)
  {
    if(NUM_Getter("BNF","(POINT)","Building",&minPointBuildingBNF,&maxPointBuildingBNF,2.0,200.0,0,&smalljunkflag,-999,&djunk,-999)>0)
	{
      docheck3 = 1;
	}
  }

  if(area_building_found>0)
  {
	if(NUM_Getter("BNF","(AREA)","Building",&minAreaBuildingBNF,&maxAreaBuildingBNF,2.0,200.0,0,&smalljunkflag,-999,&djunk,-999)>0)
	{
      docheck3 = 1;
	}
  }


  totalchecks = docheck1 + docheck2 + docheck3 + numnfnchecks + numinstances;





  if(totalchecks>0)
  {
    fprintf(outfile,"UNIQUE_CHECKS 1\n");
    fprintf(outfile,"VVTERR2WAY %d\n",totalchecks);


    tempfile = fopen(htempfilename,"r");
    if(tempfile==NULL)
	{ 
      printf("Error: could not (2) open %s for read\n",htempfilename);
	  return 0;
	} 

    fgets(aline,1000,tempfile);

    while(!feof(tempfile))
	{
      fprintf(outfile,"%s",aline);
      fgets(aline,1000,tempfile);
	}

	fclose(tempfile);



	j = numnfnchecks + numinstances + 1;

	if(docheck1>0)
	{
	  fprintf(outfile,"VVTERR2WAY %d C_PRIMARY C_ALL_POFE off\n",j);
      fprintf(outfile,"VVTERR2WAY %d C_PRIMARY C_SOME_POFE on\n",j);
      fprintf(outfile,"VVTERR2WAY %d C_PRIMARY C_ALL_LINE off\n",j);
      fprintf(outfile,"VVTERR2WAY %d C_PRIMARY C_SOME_LINE on\n",j);
      fprintf(outfile,"VVTERR2WAY %d C_PRIMARY C_ALL_AREA off\n",j);
      fprintf(outfile,"VVTERR2WAY %d C_PRIMARY C_SOME_AREA on\n",j);
	  fprintf(outfile,"VVTERR2WAY %d C_SECONDARY C_ALL_POFE off\n",j);
      fprintf(outfile,"VVTERR2WAY %d C_SECONDARY C_SOME_POFE on\n",j);
      fprintf(outfile,"VVTERR2WAY %d C_SECONDARY C_ALL_LINE off\n",j);
      fprintf(outfile,"VVTERR2WAY %d C_SECONDARY C_SOME_LINE on\n",j);
      fprintf(outfile,"VVTERR2WAY %d C_SECONDARY C_ALL_AREA off\n",j);
      fprintf(outfile,"VVTERR2WAY %d C_SECONDARY C_SOME_AREA on\n",j);

      fprintf(outfile,"VVTERR2WAY %d ANNOTATION \"Tower without ZI018_WIT=\"No Information\" and no TTC=\"Telecommunication Tower\"\"\n",j);
	  j = j + 1;
	}

	if(docheck2>0)
	{
	  fprintf(outfile,"VVTERR2WAY %d C_PRIMARY C_ALL_POFE off\n",j);
      fprintf(outfile,"VVTERR2WAY %d C_PRIMARY C_SOME_POFE on\n",j);
      fprintf(outfile,"VVTERR2WAY %d C_PRIMARY C_ALL_LINE off\n",j);
      fprintf(outfile,"VVTERR2WAY %d C_PRIMARY C_SOME_LINE on\n",j);
      fprintf(outfile,"VVTERR2WAY %d C_PRIMARY C_ALL_AREA off\n",j);
      fprintf(outfile,"VVTERR2WAY %d C_PRIMARY C_SOME_AREA on\n",j);
	  fprintf(outfile,"VVTERR2WAY %d C_SECONDARY C_ALL_POFE off\n",j);
      fprintf(outfile,"VVTERR2WAY %d C_SECONDARY C_SOME_POFE on\n",j);
      fprintf(outfile,"VVTERR2WAY %d C_SECONDARY C_ALL_LINE off\n",j);
      fprintf(outfile,"VVTERR2WAY %d C_SECONDARY C_SOME_LINE on\n",j);
      fprintf(outfile,"VVTERR2WAY %d C_SECONDARY C_ALL_AREA off\n",j);
      fprintf(outfile,"VVTERR2WAY %d C_SECONDARY C_SOME_AREA on\n",j);

      fprintf(outfile,"VVTERR2WAY %d ANNOTATION \"Transportation Station with TRS=\"Underground Railway\" and LUN not \"True\"\"\n",j);
	  j = j + 1;
	}
    if(docheck3>0)
	{  
	  fprintf(outfile,"VVTERR2WAY %d C_PRIMARY C_ALL_POFE off\n",j);
      fprintf(outfile,"VVTERR2WAY %d C_PRIMARY C_SOME_POFE on\n",j);
      fprintf(outfile,"VVTERR2WAY %d C_PRIMARY C_ALL_LINE off\n",j);
      fprintf(outfile,"VVTERR2WAY %d C_PRIMARY C_SOME_LINE on\n",j);
      fprintf(outfile,"VVTERR2WAY %d C_PRIMARY C_ALL_AREA off\n",j);
      fprintf(outfile,"VVTERR2WAY %d C_PRIMARY C_SOME_AREA on\n",j);
	  fprintf(outfile,"VVTERR2WAY %d C_SECONDARY C_ALL_POFE off\n",j);
      fprintf(outfile,"VVTERR2WAY %d C_SECONDARY C_SOME_POFE on\n",j);
      fprintf(outfile,"VVTERR2WAY %d C_SECONDARY C_ALL_LINE off\n",j);
      fprintf(outfile,"VVTERR2WAY %d C_SECONDARY C_SOME_LINE on\n",j);
      fprintf(outfile,"VVTERR2WAY %d C_SECONDARY C_ALL_AREA off\n",j);
      fprintf(outfile,"VVTERR2WAY %d C_SECONDARY C_SOME_AREA on\n",j);

      fprintf(outfile,"VVTERR2WAY %d ANNOTATION \"Building features with BNF>=2 and HGT=[0,5)\"\n",j);
      j = j + 1;
	}



    fprintf(outfile,"ATTRATTRATTR\n");

    tempfile = fopen(tempfilename,"r");
    if(tempfile==NULL)
	{ 
      printf("Error: could not (2) open %s for read\n",tempfilename);
	  return 0;
	} 

    fgets(aline,1000,tempfile);

    while(!feof(tempfile))
	{
      fprintf(outfile,"%s",aline);
      fgets(aline,1000,tempfile);
	}

	fclose(tempfile);


	j = numnfnchecks + numinstances + 1;

	if(docheck1>0)
	{
	  if(point_tower_found>0)
	  { 
        fprintf(outfile,"VVTERR2WAY %d PRIMARY Tower ANY on C_POFE\n",j);

	    if(FindAttr(-1,FIND_ENUM,"(POINT)", "Tower", "ZI018_WIT",  "No Information"))
		{
	      fprintf(outfile,"VVTERR2WAY %d PRIMARY Tower %s LABEL NoInformation off C_POFE\n",
		      j,MakeCleanCode(GetEACLabel(GetAttrIndex("ZI018_WIT"))));
		} 


        fprintf(outfile,"VVTERR2WAY %d SECONDARY Tower ANY on C_POFE\n",j);

	    if(FindAttr(-1,FIND_ENUM,"(POINT)", "Tower", "TTC",  "Telecommunication Tower"))
		{
	      fprintf(outfile,"VVTERR2WAY %d SECONDARY Tower %s LABEL TelecommunicationTower off C_POFE\n",
		      j,MakeCleanCode(GetEACLabel(GetAttrIndex("TTC"))));
		} 
	    if(FindAttr(-1,FIND_ENUM,"(POINT)", "Tower", "TTC2",  "Telecommunication Tower"))
		{
	      fprintf(outfile,"VVTERR2WAY %d SECONDARY Tower %s LABEL TelecommunicationTower off C_POFE\n",
		      j,MakeCleanCode(GetEACLabel(GetAttrIndex("TTC2"))));
		} 
	    if(FindAttr(-1,FIND_ENUM,"(POINT)", "Tower", "TTC3",  "Telecommunication Tower"))
		{
	      fprintf(outfile,"VVTERR2WAY %d SECONDARY Tower %s LABEL TelecommunicationTower off C_POFE\n",
		      j,MakeCleanCode(GetEACLabel(GetAttrIndex("TTC3"))));
		} 
	  } 

	  if(area_tower_found>0)
	  { 
        fprintf(outfile,"VVTERR2WAY %d PRIMARY Tower ANY on C_AREA\n",j);

	    if(FindAttr(-1,FIND_ENUM,"(AREA)", "Tower", "ZI018_WIT",  "No Information"))
		{
	      fprintf(outfile,"VVTERR2WAY %d PRIMARY Tower %s LABEL NoInformation off C_AREA\n",
		      j,MakeCleanCode(GetEACLabel(GetAttrIndex("ZI018_WIT"))));
		} 


        fprintf(outfile,"VVTERR2WAY %d SECONDARY Tower ANY on C_AREA\n",j);

	    if(FindAttr(-1,FIND_ENUM,"(AREA)", "Tower", "TTC",  "Telecommunication Tower"))
		{
	      fprintf(outfile,"VVTERR2WAY %d SECONDARY Tower %s LABEL TelecommunicationTower off C_AREA\n",
		      j,MakeCleanCode(GetEACLabel(GetAttrIndex("TTC"))));
		} 
	    if(FindAttr(-1,FIND_ENUM,"(AREA)", "Tower", "TTC2",  "Telecommunication Tower"))
		{
	      fprintf(outfile,"VVTERR2WAY %d SECONDARY Tower %s LABEL TelecommunicationTower off C_AREA\n",
		      j,MakeCleanCode(GetEACLabel(GetAttrIndex("TTC2"))));
		} 
	    if(FindAttr(-1,FIND_ENUM,"(AREA)", "Tower", "TTC3",  "Telecommunication Tower"))
		{
	      fprintf(outfile,"VVTERR2WAY %d SECONDARY Tower %s LABEL TelecommunicationTower off C_AREA\n",
		      j,MakeCleanCode(GetEACLabel(GetAttrIndex("TTC3"))));
		} 

	  } 

	  j = j + 1;
	}

	if(docheck2>0)
	{
      if(point_transStation_found>0)
	  {
        if(point_underground1>0)
		{
	  	  fprintf(outfile,"VVTERR2WAY %d PRIMARY TransportationStation TransportationSystemType LABEL UndergroundRailway on C_POFE\n",j);
		}
        if(point_underground2>0)
		{
	  	  fprintf(outfile,"VVTERR2WAY %d PRIMARY TransportationStation TransportationSystemType2 LABEL UndergroundRailway on C_POFE\n",j);
		}
        if(point_underground3>0)
		{
	  	  fprintf(outfile,"VVTERR2WAY %d PRIMARY TransportationStation TransportationSystemType3 LABEL UndergroundRailway on C_POFE\n",j);
		}


        fprintf(outfile,"VVTERR2WAY %d SECONDARY TransportationStation ANY on C_POFE\n",j);

	    if(FindAttr(-1,FIND_ENUM,"(POINT)", "Transportation Station", "LUN",  "True"))
		{
	      fprintf(outfile,"VVTERR2WAY %d SECONDARY TransportationStation %s LABEL True off C_POFE\n",
		      j,MakeCleanCode(GetEACLabel(GetAttrIndex("LUN"))));
		} 
	  }


      if(area_transStation_found>0)
	  {
        if(area_underground1>0)
		{
	  	  fprintf(outfile,"VVTERR2WAY %d PRIMARY TransportationStation TransportationSystemType LABEL UndergroundRailway on C_AREA\n",j);
		}
        if(area_underground2>0)
		{
	  	  fprintf(outfile,"VVTERR2WAY %d PRIMARY TransportationStation TransportationSystemType2 LABEL UndergroundRailway on C_AREA\n",j);
		}
        if(area_underground3>0)
		{
	  	  fprintf(outfile,"VVTERR2WAY %d PRIMARY TransportationStation TransportationSystemType3 LABEL UndergroundRailway on C_AREA\n",j);
		}


        fprintf(outfile,"VVTERR2WAY %d SECONDARY TransportationStation ANY on C_AREA\n",j);

	    if(FindAttr(-1,FIND_ENUM,"(AREA)", "Transportation Station", "LUN",  "True"))
		{
	      fprintf(outfile,"VVTERR2WAY %d SECONDARY TransportationStation %s LABEL True off C_AREA\n",
		      j,MakeCleanCode(GetEACLabel(GetAttrIndex("LUN"))));
		} 
	  }

	  j = j + 1;
	}


	if(docheck3>0)
	{
	  if((minPointBuildingBNF>=2)&&(minPointBuildingBNF<=200)&&(minPointBuildingBNF<=maxPointBuildingBNF)) 
	  {  
         fprintf(outfile,"VVTERR2WAY %d PRIMARY %s %s RANGE 2.0 200.0 on C_POFE\n",j,
		    	 	     GetBuildingName(0),MakeCleanCode2(GetEACLabel(GetAttrIndex("BNF"))));

	     FoundHGTrange = 0;

	     if(HGT_Getter("HGT","(POINT)",GetBuildingName(1),&minHGT,&maxHGT)>0)
		 { 
		 
		   if(FoundHGTrange>0)
		   { 
		     fprintf(outfile,"VVTERR2WAY %d SECONDARY %s %s RANGE 0.0 4.999 on C_POFE\n",j,
			         GetBuildingName(0),
			         MakeCleanCode2(GetEACLabel(GetAttrIndex("HGT"))));
		   } 
		 }
	  }

	  if((minAreaBuildingBNF>=2)&&(minAreaBuildingBNF<=200)&&(minAreaBuildingBNF<=maxAreaBuildingBNF)) 
	  {  
        fprintf(outfile,"VVTERR2WAY %d PRIMARY %s %s RANGE 2.0 200.0 on C_AREA\n",j,
		    	 	     GetBuildingName(0),MakeCleanCode2(GetEACLabel(GetAttrIndex("BNF"))));

	    FoundHGTrange = 0;

	    if(HGT_Getter("HGT","(AREA)",GetBuildingName(1),&minHGT,&maxHGT)>0)
		{ 

	      if(FoundHGTrange>0)
		  { 
		    fprintf(outfile,"VVTERR2WAY %d SECONDARY %s %s RANGE 0.0 4.999 on C_AREA\n",j,
			         GetBuildingName(0),
		 	         MakeCleanCode2(GetEACLabel(GetAttrIndex("HGT"))));
		  } 
		}
	  } 
      j = j + 1;
	}
  
  }
  else
  {
	fprintf(outfile,"Data not available to specify this check\n");
  }


  

  return numinstances;
}





int ProcessIAE(FILE *outfile,char *htempfilename,char *tempfilename,int cindex,int type, 
			   int line_bridge_found, 
			   int line_road_found, 
			   int line_rail_found, 
			   int line_sidetrack_found,
			   int line_con35road,
               int area_ffp0crop,
               int area_ffp2crop,
               int area_ffp3crop,
               int area_ffp5crop,
               int area_ffp6crop,
               int area_ffp999crop,
 	           int line_mes1001road,
 	           int line_sep1001road,
 		       int line_ltn1road,
 		       int line_rta1rail,
 		       int line_rta2rail,
 		       int line_rta3rail,
 		       int line_rta4rail,
 		       int line_ltn1rail,
 		       int line_ltn2rail,
 		       int line_ltn3rail,
		       int line_rgc1rail,
 		       int line_rgc2rail,
 		       int line_rgc3rail,
 		       int line_gaw1435rail,
 		       int line_rgc1sidetrack,
 		       int line_rgc2sidetrack,
 		       int line_rgc3sidetrack,
 		       int line_gaw1435sidetrack,
			   int area_cropland_found)
{
#define maxattrs 50
#define maxattrlen 50

  FILE *htempfile,*tempfile;
  char first[500],fcode[500],thisattr[500],attrvals[maxattrs][maxattrlen],
	  thisrowattr[100],thisrowvalue[100],isx[100],tempisx[100],aline[1000],
	  test2[500];
  unsigned char valuepresent[maxattrs];
  int rowattrs[50];
  int i,j,k,len,rowvaluepresent,thisrowattrint,numattrs=0,finishedattrs=0,SILENT=1,VERBOSE=0,
	  alldoneTextline,alldoneWD1line,alldoneTextarea,alldoneWD1area,wroteheader,lcindex=1,
	  numinstances=0,countedthisrow=0,totalchecks=0,firstextra=0,areaCropDMT0=0,docheck1a,
	  docheck1,docheck2,docheck3,docheck4,docheck4a,docheck4b,docheck4c,docheck5,docheck6,
	  docheck7,docheck8,docheck9,docheck10,docheck11,docheck11a,docheck12,docheck12a,foundit,
	  docheck12b,docheck13,docheck14,docheck15,alldoneTextpoint,areaCropDMTlow=0,lookahead,
	  thisindex,thatindex,lastichecked,found0,found4,found5,found7,found8,addedalready,
	  areaCropDMT_over_0=0;

  int IAEDEBUG=0;

  double Djunk,djunk,minRailGAW,maxRailGAW,minSideTrackGAW,maxSideTrackGAW,minCropDMT,maxCropDMT,
	  junk1,junk2,lowDMT1,lowDMT2;
  extern int FIND_ENUM,FIND_STRING,FIND_REAL;
  extern int bridge_wid_val_found,bridge_wd1_val_found;
  extern int FindAttr(double dval,int passtype,char *geometry,char *charSCC, char *charSAC, char *targetvalue);
  extern char *GetRoadName(int english);
  extern char *GetRailName(int english);
  extern char *GetSideTrackName(int english);
  extern char *GetCropLandName(int english);
  extern int GenerateShareSegInfo(int *retval1, int *retval2, int *retval3, int *retval4, int generate_extra);
  extern char *GetBridgeName(int english);
  extern char *GetDMTName(int english);
  extern void FreeShareSegData(); 


  

  
			  

  if(NUM_Getter("DMT","(AREA)",GetCropLandName(1),&junk1,&junk2,0.0,0.0,1,&Djunk,-999,&djunk,-999)>0)
  {
    areaCropDMT0 = 1;
  }

  if(NUM_Getter("DMT","(AREA)",GetCropLandName(1),&lowDMT1,&lowDMT2,0.0,0.9999,1,&Djunk,-999,&djunk,-999)>0)
  {
    areaCropDMTlow = 1;
  }


  if(NUM_Getter("DMT","(AREA)",GetCropLandName(1),&junk1,&junk2,0.0001,200.0,1,&Djunk,-999,&djunk,-999)>0)
  {
	
    areaCropDMT_over_0 = 1;
  }



  htempfile = fopen(htempfilename,"w");
  if(htempfile==NULL)
  {
    printf("Error: could not open %s for write\n",htempfilename);
	return 0;
  }

  tempfile = fopen(tempfilename,"w");
  if(tempfile==NULL)
  {
    printf("Error: could not open %s for write\n",tempfilename);
	return 0;
  }



  

  docheck1a  = 0;
  docheck1   = 0;
  docheck2   = 0;
  docheck3   = 0;
  docheck4   = 0;
  docheck4a  = 0;
  docheck4b  = 0;
  docheck4c  = 0;
  docheck5   = 0;
  docheck6   = 0;
  docheck7   = 0;
  docheck8   = 0;
  docheck9   = 0;
  docheck10  = 0;
  docheck11  = 0;
  docheck11a = 0;
  docheck12  = 0;
  docheck12a = 0;
  docheck12b = 0; 
  docheck13  = 0;
  docheck14  = 0;
  docheck15  = 0;




  if(NUM_Getter("GAW","(LINE)",GetRailName(1),&minRailGAW,&maxRailGAW,-9999999,9999999,1,&Djunk,-999,&djunk,-999)>0)
  {
	
  }
  else
  {
    minRailGAW = 99999999;
    maxRailGAW = -99999999;
  }

  if(NUM_Getter("GAW","(LINE)",GetSideTrackName(1),&minSideTrackGAW,&maxSideTrackGAW,-9999999,9999999,1,&Djunk,-999,&djunk,-999)>0)
  {
	
  }
  else
  {
    minSideTrackGAW = 99999999;
    maxSideTrackGAW = -99999999;
  }

  if(NUM_Getter("DMT","(AREA)",GetCropLandName(1),&minCropDMT,&maxCropDMT,-9999999,9999999,1,&Djunk,-999,&djunk,-999)>0)
  {
     
  }
  else
  {
    minCropDMT = 99999999;
    maxCropDMT = -99999999;
  }



  docheck1a = GenerateVOIInfo();


  if(ATTRTYPE_MGCP4()==1)
  {
    if(line_rta1rail>0)
	{ 
      docheck1 = 1;
	} 
    if(line_rta2rail>0)
	{ 
      docheck2 = 1;
	} 
    if((line_rta3rail>0)&&  ( (line_ltn1rail+line_ltn2rail)>0 )   )
	{ 
      docheck3 = 1;
	} 
    if((line_rta4rail>0)&&(line_ltn1rail>0))
	{ 
      docheck4 = 1;
	} 

    if(line_ltn1rail>0)
	{ 
     docheck4a = 1;
	} 
    if(line_ltn2rail>0)
	{ 
     docheck4b = 1;
	} 
    if(line_ltn3rail>0)
	{ 
     docheck4c = 1;
	} 

    if((line_rgc1rail>0)&&(minRailGAW<=1.435))
	{ 
      docheck5 = 1;
	} 
    if((line_rgc2rail>0)&&(maxRailGAW>=1.435))
	{ 
      docheck6 = 1;
	} 
    if(line_rgc3rail>0)
	{ 
      docheck7 = 1;
	} 
    if((line_rgc1sidetrack>0)&&(minSideTrackGAW<=1.435))
	{ 
      docheck8 = 1;
	} 
    if((line_rgc2sidetrack>0)&&(maxSideTrackGAW>=1.435))
	{ 
      docheck9 = 1;
	} 
    if(line_rgc3sidetrack>0)
	{ 
      docheck10 = 1;
	} 
    if((line_mes1001road>0)&&(line_ltn1road>0))
	{ 
      docheck11 = 1;
	} 
    if((line_sep1001road>0)&&(line_ltn1road>0))
	{ 
      docheck11a = 1;
	} 
    if((area_ffp5crop>0)&&(maxCropDMT>25))
	{ 
      docheck12 = 1;
	} 

    if((area_ffp5crop>0)&&(areaCropDMTlow>0))
	{ 
      docheck12a = 1;
	} 

    if((areaCropDMT_over_0>0)&&(area_ffp6crop>0))
	{ 
      docheck12b = 1;
	} 


    if(area_cropland_found>0)
	{ 
	  if((area_ffp0crop + area_ffp2crop + area_ffp5crop + area_ffp6crop + area_ffp999crop)>0)
	  { 
        docheck13 = 1;
	  } 
	} 


    docheck14 = GenerateVVInfo();


    if((area_ffp3crop>0)&&(maxCropDMT>=25))
	{ 
      docheck15 = 1;
	} 



  } 




  if(docheck1a>0)
  {
	fprintf(htempfile,"VVTERR2WAY %d C_PRIMARY C_ALL_POFE off\n",lcindex);
    fprintf(htempfile,"VVTERR2WAY %d C_PRIMARY C_SOME_POFE on\n",lcindex);
    fprintf(htempfile,"VVTERR2WAY %d C_SECONDARY C_ALL_LINE off\n",lcindex);
    fprintf(htempfile,"VVTERR2WAY %d C_SECONDARY C_SOME_LINE on\n",lcindex);
    fprintf(htempfile,"VVTERR2WAY %d C_SECONDARY C_ALL_AREA off\n",lcindex);
    fprintf(htempfile,"VVTERR2WAY %d C_SECONDARY C_SOME_AREA on\n",lcindex);

    fprintf(htempfile,"VVTERR2WAY %d ANNOTATION \"Features with actual VOI but sentinel HGT\"\n",lcindex);

	

	lastichecked = -1;

    for(i=0;i<NumberOfModels;i++)
    {
	  found0 = 0;
	  found4 = 0;
	  found5 = 0;
	  found7 = 0;
	  found8 = 0;
	  addedalready = 0;

	  for(j=0;j<MdlNames[i].numattributes;j++)
	  {	    
	    thisindex = MdlNames[i].AttrIndices[j];
	    thatindex = MdlNames[i].ValueIndices[j];

        if(!strcmp(GetEACCode(MdlNames2[thisindex].code),"VOI"))
		{
		  if(MdlNames2[thisindex].values[thatindex].type==2)
		  {
			if(IsRealVOI(MdlNames2[thisindex].values[thatindex].label))
			{
			  


			  


			  if(i!=lastichecked)
			  {
				

			    if(HGTValuePresent(GetECCLabel(MdlNames[i].code),ChangeGeomType(MdlNames[i].name),"0.0"))
				{ 
				  found0 = 1;
				} 
			    if(HGTValuePresent(GetECCLabel(MdlNames[i].code),ChangeGeomType(MdlNames[i].name),"-32764.0"))
				{ 
				  found4 = 1;
				} 
			    if(HGTValuePresent(GetECCLabel(MdlNames[i].code),ChangeGeomType(MdlNames[i].name),"-32765.0"))
				{ 
				  found5 = 1;
				} 
			    if(HGTValuePresent(GetECCLabel(MdlNames[i].code),ChangeGeomType(MdlNames[i].name),"-32767.0"))
				{ 
				  found7 = 1;
				} 
			    if(HGTValuePresent(GetECCLabel(MdlNames[i].code),ChangeGeomType(MdlNames[i].name),"-32768.0"))
				{ 
				  found8 = 1;
				} 
				lastichecked = i;
			  }

			  if((found0+found4+found5+found7+found8)==0)
			  {
				
				break;
			  }
			  else
			  {
                 fprintf(tempfile,"VVTERR2WAY %d PRIMARY %s %s STRING %s on %s\n",
						           lcindex,
						           MakeCleanCode(GetECCLabel(MdlNames[i].code)),
						           MakeCleanCode2(GetEACLabel(GetAttrIndex("VOI"))),
						           MdlNames2[thisindex].values[thatindex].label,
								   ChangeGeomType2(MdlNames[i].name));

				 if(addedalready==0)
				 {
				   if(found0>0)
				   { 
	                fprintf(tempfile,"VVTERR2WAY %d SECONDARY %s %s RANGE 0 0 on %s\n",
						      lcindex,
				  			  MakeCleanCode(GetECCLabel(MdlNames[i].code)),
			                  MakeCleanCode2(GetEACLabel(GetAttrIndex("HGT"))),
							  ChangeGeomType2(MdlNames[i].name));
				   } 
				   if(found4>0)
				   { 
	                fprintf(tempfile,"VVTERR2WAY %d SECONDARY %s %s RANGE -32764 -32764 on %s\n",
						      lcindex,
				  			  MakeCleanCode(GetECCLabel(MdlNames[i].code)),
			                  MakeCleanCode2(GetEACLabel(GetAttrIndex("HGT"))),
							  ChangeGeomType2(MdlNames[i].name));
				   } 
				   if(found5>0)
				   { 
	                fprintf(tempfile,"VVTERR2WAY %d SECONDARY %s %s RANGE -32765 -32765 on %s\n",
						      lcindex,
				  			  MakeCleanCode(GetECCLabel(MdlNames[i].code)),
			                  MakeCleanCode2(GetEACLabel(GetAttrIndex("HGT"))),
							  ChangeGeomType2(MdlNames[i].name));
				   } 
				   if(found7>0)
				   { 
	                fprintf(tempfile,"VVTERR2WAY %d SECONDARY %s %s RANGE -32767 -32767 on %s\n",
						      lcindex,
				  			  MakeCleanCode(GetECCLabel(MdlNames[i].code)),
			                  MakeCleanCode2(GetEACLabel(GetAttrIndex("HGT"))),
							  ChangeGeomType2(MdlNames[i].name));
				   } 
				   if(found8>0)
				   { 
	                fprintf(tempfile,"VVTERR2WAY %d SECONDARY %s %s RANGE -32768 -32768 on %s\n",
						      lcindex,
				  			  MakeCleanCode(GetECCLabel(MdlNames[i].code)),
			                  MakeCleanCode2(GetEACLabel(GetAttrIndex("HGT"))),
							  ChangeGeomType2(MdlNames[i].name));
				   }
				   
				   addedalready = 1;

				 }
			  }
			}
		  }
		}
	  }
	}




	lcindex = lcindex + 1;

  }



  if(docheck1>0)
  {
	fprintf(htempfile,"VVTERR2WAY %d C_PRIMARY C_ALL_POFE off\n",lcindex);
    fprintf(htempfile,"VVTERR2WAY %d C_PRIMARY C_SOME_POFE on\n",lcindex);
    fprintf(htempfile,"VVTERR2WAY %d C_SECONDARY C_ALL_LINE off\n",lcindex);
    fprintf(htempfile,"VVTERR2WAY %d C_SECONDARY C_SOME_LINE on\n",lcindex);
    fprintf(htempfile,"VVTERR2WAY %d C_SECONDARY C_ALL_AREA off\n",lcindex);
    fprintf(htempfile,"VVTERR2WAY %d C_SECONDARY C_SOME_AREA on\n",lcindex);

    fprintf(htempfile,"VVTERR2WAY %d ANNOTATION \"Illogical Attribute/Enumeration (IAE): Line %s with \"RTA\" = \"Single Arrangement\" and \"LTN\" not equal to \"1\"\"\n",
					 	  lcindex,GetRailName(1));

    if(line_rta1rail>0)
	{ 
	  fprintf(tempfile,"VVTERR2WAY %d PRIMARY %s LinearFeatureArrangement LABEL SingleArrangement on C_LINE\n",lcindex,GetRailName(0));
	}

	if(line_rail_found>0)
	{
      fprintf(tempfile,"VVTERR2WAY %d SECONDARY %s ANY on C_LINE\n",lcindex,GetRailName(0));

      if(line_ltn1rail>0)
	  {
        fprintf(tempfile,"VVTERR2WAY %d SECONDARY %s TrackorLaneCount RANGE 1.0 1.0 off C_LINE\n",
		  lcindex,GetRailName(0));
	  }
	}

	lcindex = lcindex + 1;
  }


  if(docheck2>0)
  {
	fprintf(htempfile,"VVTERR2WAY %d C_PRIMARY C_ALL_POFE off\n",lcindex);
    fprintf(htempfile,"VVTERR2WAY %d C_PRIMARY C_SOME_POFE on\n",lcindex);
    fprintf(htempfile,"VVTERR2WAY %d C_SECONDARY C_ALL_LINE off\n",lcindex);
    fprintf(htempfile,"VVTERR2WAY %d C_SECONDARY C_SOME_LINE on\n",lcindex);
    fprintf(htempfile,"VVTERR2WAY %d C_SECONDARY C_ALL_AREA off\n",lcindex);
    fprintf(htempfile,"VVTERR2WAY %d C_SECONDARY C_SOME_AREA on\n",lcindex);

    fprintf(htempfile,"VVTERR2WAY %d ANNOTATION \"Illogical Attribute/Enumeration (IAE): Line %s with \"RTA\" = \"Double Arrangement\" and \"LTN\" not equal to \"2\"\"\n",
					 	  lcindex,GetRailName(1));

    if(line_rta2rail>0)
	{ 
	  fprintf(tempfile,"VVTERR2WAY %d PRIMARY %s LinearFeatureArrangement LABEL DoubleArrangement on C_LINE\n",lcindex,GetRailName(0));
	}

	if(line_rail_found>0)
	{
      fprintf(tempfile,"VVTERR2WAY %d SECONDARY %s ANY on C_LINE\n",lcindex,GetRailName(0));

      if(line_ltn2rail>0)
	  {
        fprintf(tempfile,"VVTERR2WAY %d SECONDARY %s TrackorLaneCount RANGE 2.0 2.0 off C_LINE\n",
		  lcindex,GetRailName(0));
	  }
	}

	lcindex = lcindex + 1;
  }


  if(docheck3>0)
  {
	fprintf(htempfile,"VVTERR2WAY %d C_PRIMARY C_ALL_POFE off\n",lcindex);
    fprintf(htempfile,"VVTERR2WAY %d C_PRIMARY C_SOME_POFE on\n",lcindex);
    fprintf(htempfile,"VVTERR2WAY %d C_SECONDARY C_ALL_LINE off\n",lcindex);
    fprintf(htempfile,"VVTERR2WAY %d C_SECONDARY C_SOME_LINE on\n",lcindex);
    fprintf(htempfile,"VVTERR2WAY %d C_SECONDARY C_ALL_AREA off\n",lcindex);
    fprintf(htempfile,"VVTERR2WAY %d C_SECONDARY C_SOME_AREA on\n",lcindex);

    fprintf(htempfile,"VVTERR2WAY %d ANNOTATION \"Illogical Attribute/Enumeration (IAE): Line %s with \"RTA\" = \"Multiple Arrangements\" and \"LTN\" equal to \"1\" or \"2\"\"\n",
					 	  lcindex,GetRailName(1));

    if(line_rta3rail>0)
	{ 
	  fprintf(tempfile,"VVTERR2WAY %d PRIMARY %s LinearFeatureArrangement LABEL MultipleArrangements on C_LINE\n",lcindex,GetRailName(0));
	}

    if(line_ltn1rail>0)
	{
      fprintf(tempfile,"VVTERR2WAY %d SECONDARY %s TrackorLaneCount RANGE 1.0 1.0 on C_LINE\n",
		  lcindex,GetRailName(0));
	}

    if(line_ltn2rail>0)
	{
      fprintf(tempfile,"VVTERR2WAY %d SECONDARY %s TrackorLaneCount RANGE 2.0 2.0 on C_LINE\n",
		  lcindex,GetRailName(0));
	}


	lcindex = lcindex + 1;
  }

  if(docheck4>0)
  {
	fprintf(htempfile,"VVTERR2WAY %d C_PRIMARY C_ALL_POFE off\n",lcindex);
    fprintf(htempfile,"VVTERR2WAY %d C_PRIMARY C_SOME_POFE on\n",lcindex);
    fprintf(htempfile,"VVTERR2WAY %d C_SECONDARY C_ALL_LINE off\n",lcindex);
    fprintf(htempfile,"VVTERR2WAY %d C_SECONDARY C_SOME_LINE on\n",lcindex);
    fprintf(htempfile,"VVTERR2WAY %d C_SECONDARY C_ALL_AREA off\n",lcindex);
    fprintf(htempfile,"VVTERR2WAY %d C_SECONDARY C_SOME_AREA on\n",lcindex);

    fprintf(htempfile,"VVTERR2WAY %d ANNOTATION \"Illogical Attribute/Enumeration (IAE): Line %s with \"RTA\" = \"Juxtaposition\" and \"LTN\" equal to \"1\"\"\n",
					 	  lcindex,GetRailName(1));

    if(line_rta4rail>0)
	{ 
	  fprintf(tempfile,"VVTERR2WAY %d PRIMARY %s LinearFeatureArrangement LABEL Juxtaposition on C_LINE\n",lcindex,GetRailName(0));
	}

    if(line_ltn1rail>0)
	{
      fprintf(tempfile,"VVTERR2WAY %d SECONDARY %s TrackorLaneCount RANGE 1.0 1.0 on C_LINE\n",
		  lcindex,GetRailName(0));
	}

	lcindex = lcindex + 1;
  }


  if(docheck4a>0)
  {
	fprintf(htempfile,"VVTERR2WAY %d C_PRIMARY C_ALL_POFE off\n",lcindex);
    fprintf(htempfile,"VVTERR2WAY %d C_PRIMARY C_SOME_POFE on\n",lcindex);
    fprintf(htempfile,"VVTERR2WAY %d C_SECONDARY C_ALL_LINE off\n",lcindex);
    fprintf(htempfile,"VVTERR2WAY %d C_SECONDARY C_SOME_LINE on\n",lcindex);
    fprintf(htempfile,"VVTERR2WAY %d C_SECONDARY C_ALL_AREA off\n",lcindex);
    fprintf(htempfile,"VVTERR2WAY %d C_SECONDARY C_SOME_AREA on\n",lcindex);

    fprintf(htempfile,"VVTERR2WAY %d ANNOTATION \"Illogical Attribute/Enumeration (IAE): Line %s with \"LTN\" equal to \"1\" and \"RTA\" not equal to \"Single Arrangement\"\"\n",
					 	  lcindex,GetRailName(1));

    if(line_ltn1rail>0)
	{
      fprintf(tempfile,"VVTERR2WAY %d PRIMARY %s TrackorLaneCount RANGE 1.0 1.0 on C_LINE\n",
		  lcindex,GetRailName(0));
	}


	if(line_rail_found>0)
	{
      fprintf(tempfile,"VVTERR2WAY %d SECONDARY %s ANY on C_LINE\n",lcindex,GetRailName(0));
	}

    if(line_rta1rail>0)
	{ 
	  fprintf(tempfile,"VVTERR2WAY %d SECONDARY %s LinearFeatureArrangement LABEL SingleArrangement off C_LINE\n",lcindex,GetRailName(0));
	}

	lcindex = lcindex + 1;
  }


  if(docheck4b>0)
  {
	fprintf(htempfile,"VVTERR2WAY %d C_PRIMARY C_ALL_POFE off\n",lcindex);
    fprintf(htempfile,"VVTERR2WAY %d C_PRIMARY C_SOME_POFE on\n",lcindex);
    fprintf(htempfile,"VVTERR2WAY %d C_SECONDARY C_ALL_LINE off\n",lcindex);
    fprintf(htempfile,"VVTERR2WAY %d C_SECONDARY C_SOME_LINE on\n",lcindex);
    fprintf(htempfile,"VVTERR2WAY %d C_SECONDARY C_ALL_AREA off\n",lcindex);
    fprintf(htempfile,"VVTERR2WAY %d C_SECONDARY C_SOME_AREA on\n",lcindex);

    fprintf(htempfile,"VVTERR2WAY %d ANNOTATION \"Illogical Attribute/Enumeration (IAE): Line %s with \"LTN\" equal to \"2\" and \"RTA\" not equal to \"Double Arrangement\" or \"Juxtaposition\"\"\n",
					 	  lcindex,GetRailName(1));

    if(line_ltn2rail>0)
	{
      fprintf(tempfile,"VVTERR2WAY %d PRIMARY %s TrackorLaneCount RANGE 2.0 2.0 on C_LINE\n",
		  lcindex,GetRailName(0));
	}

	if(line_rail_found>0)
	{
      fprintf(tempfile,"VVTERR2WAY %d SECONDARY %s ANY on C_LINE\n",lcindex,GetRailName(0));
	}

    if(line_rta2rail>0)
	{ 
	  fprintf(tempfile,"VVTERR2WAY %d SECONDARY %s LinearFeatureArrangement LABEL DoubleArrangement off C_LINE\n",lcindex,GetRailName(0));
	}
    if(line_rta4rail>0)
	{ 
	  fprintf(tempfile,"VVTERR2WAY %d SECONDARY %s LinearFeatureArrangement LABEL Juxtaposition off C_LINE\n",lcindex,GetRailName(0));
	}


	lcindex = lcindex + 1;
  }



  if(docheck4c>0)
  {
	fprintf(htempfile,"VVTERR2WAY %d C_PRIMARY C_ALL_POFE off\n",lcindex);
    fprintf(htempfile,"VVTERR2WAY %d C_PRIMARY C_SOME_POFE on\n",lcindex);
    fprintf(htempfile,"VVTERR2WAY %d C_SECONDARY C_ALL_LINE off\n",lcindex);
    fprintf(htempfile,"VVTERR2WAY %d C_SECONDARY C_SOME_LINE on\n",lcindex);
    fprintf(htempfile,"VVTERR2WAY %d C_SECONDARY C_ALL_AREA off\n",lcindex);
    fprintf(htempfile,"VVTERR2WAY %d C_SECONDARY C_SOME_AREA on\n",lcindex);

    fprintf(htempfile,"VVTERR2WAY %d ANNOTATION \"Illogical Attribute/Enumeration (IAE): Line %s with \"LTN\" equal to \"3\" and \"RTA\" not equal to \"Multiple Arrangements\" or \"Juxtaposition\"\"\n",
					 	  lcindex,GetRailName(1));

    if(line_ltn3rail>0)
	{
      fprintf(tempfile,"VVTERR2WAY %d PRIMARY %s TrackorLaneCount RANGE 3.0 3.0 on C_LINE\n",
		  lcindex,GetRailName(0));
	}

	if(line_rail_found>0)
	{
      fprintf(tempfile,"VVTERR2WAY %d SECONDARY %s ANY on C_LINE\n",lcindex,GetRailName(0));
	}

    if(line_rta3rail>0)
	{ 
	  fprintf(tempfile,"VVTERR2WAY %d SECONDARY %s LinearFeatureArrangement LABEL MultipleArrangements off C_LINE\n",lcindex,GetRailName(0));
	}
    if(line_rta4rail>0)
	{ 
	  fprintf(tempfile,"VVTERR2WAY %d SECONDARY %s LinearFeatureArrangement LABEL Juxtaposition off C_LINE\n",lcindex,GetRailName(0));
	}


	lcindex = lcindex + 1;
  }








  if(docheck5>0)
  {
	fprintf(htempfile,"VVTERR2WAY %d C_PRIMARY C_ALL_POFE off\n",lcindex);
    fprintf(htempfile,"VVTERR2WAY %d C_PRIMARY C_SOME_POFE on\n",lcindex);
    fprintf(htempfile,"VVTERR2WAY %d C_SECONDARY C_ALL_LINE off\n",lcindex);
    fprintf(htempfile,"VVTERR2WAY %d C_SECONDARY C_SOME_LINE on\n",lcindex);
    fprintf(htempfile,"VVTERR2WAY %d C_SECONDARY C_ALL_AREA off\n",lcindex);
    fprintf(htempfile,"VVTERR2WAY %d C_SECONDARY C_SOME_AREA on\n",lcindex);

    fprintf(htempfile,"VVTERR2WAY %d ANNOTATION \"Illogical Attribute/Enumeration (IAE): Line %s with \"RGC\" = \"Broad\" and \"GAW\" less than or equal to \"1.435\"\"\n",
					 	  lcindex,GetRailName(1));

    if(line_rgc1rail>0)
	{ 
	  fprintf(tempfile,"VVTERR2WAY %d PRIMARY %s RailwayGaugeClassification LABEL Broad on C_LINE\n",lcindex,GetRailName(0));
	}

    if(minRailGAW<=1.435)
	{
      fprintf(tempfile,"VVTERR2WAY %d SECONDARY %s RailwayGauge RANGE %lf 1.435 on C_LINE\n",
		  lcindex,GetRailName(0),minRailGAW);
	}

	lcindex = lcindex + 1;
  }

  if(docheck6>0)
  {
	fprintf(htempfile,"VVTERR2WAY %d C_PRIMARY C_ALL_POFE off\n",lcindex);
    fprintf(htempfile,"VVTERR2WAY %d C_PRIMARY C_SOME_POFE on\n",lcindex);
    fprintf(htempfile,"VVTERR2WAY %d C_SECONDARY C_ALL_LINE off\n",lcindex);
    fprintf(htempfile,"VVTERR2WAY %d C_SECONDARY C_SOME_LINE on\n",lcindex);
    fprintf(htempfile,"VVTERR2WAY %d C_SECONDARY C_ALL_AREA off\n",lcindex);
    fprintf(htempfile,"VVTERR2WAY %d C_SECONDARY C_SOME_AREA on\n",lcindex);

    fprintf(htempfile,"VVTERR2WAY %d ANNOTATION \"Illogical Attribute/Enumeration (IAE): Line %s with \"RGC\" = \"Narrow\" and \"GAW\" greater than or equal to \"1.435\"\"\n",
					 	  lcindex,GetRailName(1));

    if(line_rgc2rail>0)
	{ 
	  fprintf(tempfile,"VVTERR2WAY %d PRIMARY %s RailwayGaugeClassification LABEL Narrow on C_LINE\n",lcindex,GetRailName(0));
	}

    if(maxRailGAW>=1.435)
	{
      fprintf(tempfile,"VVTERR2WAY %d SECONDARY %s RailwayGauge RANGE 1.435 %lf on C_LINE\n",
		  lcindex,GetRailName(0),maxRailGAW);
	}

	lcindex = lcindex + 1;
  }

  if(docheck7>0)
  {
	fprintf(htempfile,"VVTERR2WAY %d C_PRIMARY C_ALL_POFE off\n",lcindex);
    fprintf(htempfile,"VVTERR2WAY %d C_PRIMARY C_SOME_POFE on\n",lcindex);
    fprintf(htempfile,"VVTERR2WAY %d C_SECONDARY C_ALL_LINE off\n",lcindex);
    fprintf(htempfile,"VVTERR2WAY %d C_SECONDARY C_SOME_LINE on\n",lcindex);
    fprintf(htempfile,"VVTERR2WAY %d C_SECONDARY C_ALL_AREA off\n",lcindex);
    fprintf(htempfile,"VVTERR2WAY %d C_SECONDARY C_SOME_AREA on\n",lcindex);

    fprintf(htempfile,"VVTERR2WAY %d ANNOTATION \"Illogical Attribute/Enumeration (IAE): Line %s with \"RGC\" = \"Standard\" and \"GAW\" not equal to \"1.435\"\"\n",
					 	  lcindex,GetRailName(1));

    if(line_rgc3rail>0)
	{ 
	  fprintf(tempfile,"VVTERR2WAY %d PRIMARY %s RailwayGaugeClassification LABEL Standard on C_LINE\n",lcindex,GetRailName(0));
	}

	if(line_rail_found>0)
	{
      fprintf(tempfile,"VVTERR2WAY %d SECONDARY %s ANY on C_LINE\n",lcindex,GetRailName(0));
	}

    if(line_gaw1435rail>0)
	{
      fprintf(tempfile,"VVTERR2WAY %d SECONDARY %s RailwayGauge RANGE 1.435 1.435 off C_LINE\n",
		  lcindex,GetRailName(0));
	}

	lcindex = lcindex + 1;
  }

 



  if(docheck8>0)
  {
	fprintf(htempfile,"VVTERR2WAY %d C_PRIMARY C_ALL_POFE off\n",lcindex);
    fprintf(htempfile,"VVTERR2WAY %d C_PRIMARY C_SOME_POFE on\n",lcindex);
    fprintf(htempfile,"VVTERR2WAY %d C_SECONDARY C_ALL_LINE off\n",lcindex);
    fprintf(htempfile,"VVTERR2WAY %d C_SECONDARY C_SOME_LINE on\n",lcindex);
    fprintf(htempfile,"VVTERR2WAY %d C_SECONDARY C_ALL_AREA off\n",lcindex);
    fprintf(htempfile,"VVTERR2WAY %d C_SECONDARY C_SOME_AREA on\n",lcindex);

    fprintf(htempfile,"VVTERR2WAY %d ANNOTATION \"Illogical Attribute/Enumeration (IAE): Line %s with \"RGC\" = \"Broad\" and \"GAW\" less than or equal to \"1.435\"\"\n",
					 	  lcindex,GetSideTrackName(1));

    if(line_rgc1sidetrack>0)
	{ 
	  fprintf(tempfile,"VVTERR2WAY %d PRIMARY %s RailwayGaugeClassification LABEL Broad on C_LINE\n",lcindex,GetSideTrackName(0));
	}

    if(minSideTrackGAW<=1.435)
	{
      fprintf(tempfile,"VVTERR2WAY %d SECONDARY %s RailwayGauge RANGE %lf 1.435 on C_LINE\n",
		  lcindex,GetSideTrackName(0),minSideTrackGAW);
	}

	lcindex = lcindex + 1;
  }

  if(docheck9>0)
  {
	fprintf(htempfile,"VVTERR2WAY %d C_PRIMARY C_ALL_POFE off\n",lcindex);
    fprintf(htempfile,"VVTERR2WAY %d C_PRIMARY C_SOME_POFE on\n",lcindex);
    fprintf(htempfile,"VVTERR2WAY %d C_SECONDARY C_ALL_LINE off\n",lcindex);
    fprintf(htempfile,"VVTERR2WAY %d C_SECONDARY C_SOME_LINE on\n",lcindex);
    fprintf(htempfile,"VVTERR2WAY %d C_SECONDARY C_ALL_AREA off\n",lcindex);
    fprintf(htempfile,"VVTERR2WAY %d C_SECONDARY C_SOME_AREA on\n",lcindex);

    fprintf(htempfile,"VVTERR2WAY %d ANNOTATION \"Illogical Attribute/Enumeration (IAE): Line %s with \"RGC\" = \"Narrow\" and \"GAW\" greater than or equal to \"1.435\"\"\n",
					 	  lcindex,GetSideTrackName(1));

    if(line_rgc2sidetrack>0)
	{ 
	  fprintf(tempfile,"VVTERR2WAY %d PRIMARY %s RailwayGaugeClassification LABEL Narrow on C_LINE\n",lcindex,GetSideTrackName(0));
	}

    if(maxSideTrackGAW>=1.435)
	{
      fprintf(tempfile,"VVTERR2WAY %d SECONDARY %s RailwayGauge RANGE 1.435 %lf on C_LINE\n",
		  lcindex,GetSideTrackName(0),maxSideTrackGAW);
	}

	lcindex = lcindex + 1;
  }

  if(docheck10>0)
  {
	fprintf(htempfile,"VVTERR2WAY %d C_PRIMARY C_ALL_POFE off\n",lcindex);
    fprintf(htempfile,"VVTERR2WAY %d C_PRIMARY C_SOME_POFE on\n",lcindex);
    fprintf(htempfile,"VVTERR2WAY %d C_SECONDARY C_ALL_LINE off\n",lcindex);
    fprintf(htempfile,"VVTERR2WAY %d C_SECONDARY C_SOME_LINE on\n",lcindex);
    fprintf(htempfile,"VVTERR2WAY %d C_SECONDARY C_ALL_AREA off\n",lcindex);
    fprintf(htempfile,"VVTERR2WAY %d C_SECONDARY C_SOME_AREA on\n",lcindex);

    fprintf(htempfile,"VVTERR2WAY %d ANNOTATION \"Illogical Attribute/Enumeration (IAE): Line %s with \"RGC\" = \"Standard\" and \"GAW\" not equal to \"1.435\"\"\n",
					 	  lcindex,GetSideTrackName(1));

    if(line_rgc3sidetrack>0)
	{ 
	  fprintf(tempfile,"VVTERR2WAY %d PRIMARY %s RailwayGaugeClassification LABEL Standard on C_LINE\n",lcindex,GetSideTrackName(0));
	}

	if(line_sidetrack_found>0)
	{
      fprintf(tempfile,"VVTERR2WAY %d SECONDARY %s ANY on C_LINE\n",lcindex,GetSideTrackName(0));
	}

    if(line_gaw1435sidetrack>0)
	{
      fprintf(tempfile,"VVTERR2WAY %d SECONDARY %s RailwayGauge RANGE 1.435 1.435 off C_LINE\n",
		  lcindex,GetSideTrackName(0));
	}

	lcindex = lcindex + 1;
  }




  if(docheck11>0)
  {
	fprintf(htempfile,"VVTERR2WAY %d C_PRIMARY C_ALL_POFE off\n",lcindex);
    fprintf(htempfile,"VVTERR2WAY %d C_PRIMARY C_SOME_POFE on\n",lcindex);
    fprintf(htempfile,"VVTERR2WAY %d C_SECONDARY C_ALL_LINE off\n",lcindex);
    fprintf(htempfile,"VVTERR2WAY %d C_SECONDARY C_SOME_LINE on\n",lcindex);
    fprintf(htempfile,"VVTERR2WAY %d C_SECONDARY C_ALL_AREA off\n",lcindex);
    fprintf(htempfile,"VVTERR2WAY %d C_SECONDARY C_SOME_AREA on\n",lcindex);

    fprintf(htempfile,"VVTERR2WAY %d ANNOTATION \"Illogical Attribute/Enumeration (IAE): Line %s with \"MES\" = \"With Median\" and \"LTN\" equal to \"1\"\"\n",
					 	  lcindex,GetRoadName(1));

    if(line_mes1001road>0)
	{ 
	  fprintf(tempfile,"VVTERR2WAY %d PRIMARY %s MedianPresent LABEL WithMedian on C_LINE\n",lcindex,GetRoadName(0));
	}

    if(line_ltn1road>0)
	{
      fprintf(tempfile,"VVTERR2WAY %d SECONDARY %s TrackorLaneCount RANGE 1.0 1.0 on C_LINE\n",
		  lcindex,GetRoadName(0));
	}

	lcindex = lcindex + 1;
  }



  if(docheck11a>0)
  {
	fprintf(htempfile,"VVTERR2WAY %d C_PRIMARY C_ALL_POFE off\n",lcindex);
    fprintf(htempfile,"VVTERR2WAY %d C_PRIMARY C_SOME_POFE on\n",lcindex);
    fprintf(htempfile,"VVTERR2WAY %d C_SECONDARY C_ALL_LINE off\n",lcindex);
    fprintf(htempfile,"VVTERR2WAY %d C_SECONDARY C_SOME_LINE on\n",lcindex);
    fprintf(htempfile,"VVTERR2WAY %d C_SECONDARY C_ALL_AREA off\n",lcindex);
    fprintf(htempfile,"VVTERR2WAY %d C_SECONDARY C_SOME_AREA on\n",lcindex);

    fprintf(htempfile,"VVTERR2WAY %d ANNOTATION \"Illogical Attribute/Enumeration (IAE): Line %s with \"SEP\" = \"Present\" and \"LTN\" equal to \"1\"\"\n",
					 	  lcindex,GetRoadName(1));

    if(line_sep1001road>0)
	{ 
	  fprintf(tempfile,"VVTERR2WAY %d PRIMARY %s Divided LABEL Present on C_LINE\n",lcindex,GetRoadName(0));
	}

    if(line_ltn1road>0)
	{
      fprintf(tempfile,"VVTERR2WAY %d SECONDARY %s TrackorLaneCount RANGE 1.0 1.0 on C_LINE\n",
		  lcindex,GetRoadName(0));
	}

	lcindex = lcindex + 1;
  }



  if(docheck12>0)
  {
	fprintf(htempfile,"VVTERR2WAY %d C_PRIMARY C_ALL_POFE off\n",lcindex);
    fprintf(htempfile,"VVTERR2WAY %d C_PRIMARY C_SOME_POFE on\n",lcindex);
    fprintf(htempfile,"VVTERR2WAY %d C_SECONDARY C_ALL_LINE off\n",lcindex);
    fprintf(htempfile,"VVTERR2WAY %d C_SECONDARY C_SOME_LINE on\n",lcindex);
    fprintf(htempfile,"VVTERR2WAY %d C_SECONDARY C_ALL_AREA off\n",lcindex);
    fprintf(htempfile,"VVTERR2WAY %d C_SECONDARY C_SOME_AREA on\n",lcindex);

    fprintf(htempfile,"VVTERR2WAY %d ANNOTATION \"Illogical Attribute/Enumeration (IAE): Area %s with \"FFP\" = \"Intermingled Trees\" and \"DMT\" greater than \"25\"\"\n",
					 	  lcindex,GetCropLandName(1));

    if(area_ffp5crop>0)
	{ 
	  fprintf(tempfile,"VVTERR2WAY %d PRIMARY %s FarmingPattern LABEL IntermingledTrees on C_AREA\n",lcindex,GetCropLandName(0));
	}

    if(maxCropDMT>25)
	{
      fprintf(tempfile,"VVTERR2WAY %d SECONDARY %s %s RANGE 25.0 %lf on C_AREA\n",
		  lcindex,GetCropLandName(0),GetDMTName(0),maxCropDMT);
	}


	

    if(NUM_Getter("DMT","(AREA)",GetCropLandName(1),&djunk,&djunk,25.0,25.0,1,&Djunk,-999,&djunk,-999)>0)
	{
      fprintf(tempfile,"VVTERR2WAY %d SECONDARY %s %s RANGE 25.0 25.0 off C_AREA\n",
		  lcindex,GetCropLandName(0),GetDMTName(0));
	}



	lcindex = lcindex + 1;
  }








    if(docheck12a>0)
  {
	fprintf(htempfile,"VVTERR2WAY %d C_PRIMARY C_ALL_POFE off\n",lcindex);
    fprintf(htempfile,"VVTERR2WAY %d C_PRIMARY C_SOME_POFE on\n",lcindex);
    fprintf(htempfile,"VVTERR2WAY %d C_SECONDARY C_ALL_LINE off\n",lcindex);
    fprintf(htempfile,"VVTERR2WAY %d C_SECONDARY C_SOME_LINE on\n",lcindex);
    fprintf(htempfile,"VVTERR2WAY %d C_SECONDARY C_ALL_AREA off\n",lcindex);
    fprintf(htempfile,"VVTERR2WAY %d C_SECONDARY C_SOME_AREA on\n",lcindex);

    fprintf(htempfile,"VVTERR2WAY %d ANNOTATION \"Illogical Attribute/Enumeration (IAE): Area %s with \"FFP\" = \"Intermingled Trees\" and \"DMT\" less than 1\"\n",
					 	  lcindex,GetCropLandName(1));

    if(area_ffp5crop>0)
	{ 
	  fprintf(tempfile,"VVTERR2WAY %d PRIMARY %s FarmingPattern LABEL IntermingledTrees on C_AREA\n",lcindex,GetCropLandName(0));
	}

    if(areaCropDMTlow>0)
	{
      fprintf(tempfile,"VVTERR2WAY %d SECONDARY %s %s RANGE %lf %lf on C_AREA\n",
		  lcindex,GetCropLandName(0),GetDMTName(0),lowDMT1,lowDMT2);
	}

	lcindex = lcindex + 1;
  }


  if(docheck12b>0)
  {
	fprintf(htempfile,"VVTERR2WAY %d C_PRIMARY C_ALL_POFE off\n",lcindex);
    fprintf(htempfile,"VVTERR2WAY %d C_PRIMARY C_SOME_POFE on\n",lcindex);
    fprintf(htempfile,"VVTERR2WAY %d C_SECONDARY C_ALL_LINE off\n",lcindex);
    fprintf(htempfile,"VVTERR2WAY %d C_SECONDARY C_SOME_LINE on\n",lcindex);
    fprintf(htempfile,"VVTERR2WAY %d C_SECONDARY C_ALL_AREA off\n",lcindex);
    fprintf(htempfile,"VVTERR2WAY %d C_SECONDARY C_SOME_AREA on\n",lcindex);

    fprintf(htempfile,"VVTERR2WAY %d ANNOTATION \"Illogical Attribute/Enumeration (IAE): Area %s with \"DMT\">0 and \"FFP\"=Treeless\"\n",
					 	  lcindex,GetCropLandName(1));



	if(areaCropDMT_over_0>0)
	{
      fprintf(tempfile,"VVTERR2WAY %d PRIMARY %s %s RANGE 0.0001 200.0 on C_AREA\n",
		  lcindex,GetCropLandName(0),GetDMTName(0));
	}



    if(area_ffp6crop>0)
	{ 
	  fprintf(tempfile,"VVTERR2WAY %d SECONDARY %s FarmingPattern LABEL Treeless on C_AREA\n",lcindex,GetCropLandName(0));
	}

	lcindex = lcindex + 1;
  }




  if(docheck13>0)
  {
	fprintf(htempfile,"VVTERR2WAY %d C_PRIMARY C_ALL_POFE off\n",lcindex);
    fprintf(htempfile,"VVTERR2WAY %d C_PRIMARY C_SOME_POFE on\n",lcindex);
    fprintf(htempfile,"VVTERR2WAY %d C_SECONDARY C_ALL_LINE off\n",lcindex);
    fprintf(htempfile,"VVTERR2WAY %d C_SECONDARY C_SOME_LINE on\n",lcindex);
    fprintf(htempfile,"VVTERR2WAY %d C_SECONDARY C_ALL_AREA off\n",lcindex);
    fprintf(htempfile,"VVTERR2WAY %d C_SECONDARY C_SOME_AREA on\n",lcindex);

    fprintf(htempfile,"VVTERR2WAY %d ANNOTATION \"Illogical Attribute/Enumeration (IAE): Area %s with \"FFP\" = \"Unknown\", \"Regular\", \"Treeless\", or \"Other\" and \"DMT\" not equal to \"0\"\"\n",
					 	  lcindex,GetCropLandName(1));

    if(area_ffp0crop>0)
	{ 
	  fprintf(tempfile,"VVTERR2WAY %d PRIMARY %s FarmingPattern LABEL Unknown on C_AREA\n",lcindex,GetCropLandName(0));
	}
    if(area_ffp2crop>0)
	{ 
	  fprintf(tempfile,"VVTERR2WAY %d PRIMARY %s FarmingPattern LABEL Regular on C_AREA\n",lcindex,GetCropLandName(0));
	}
    if(area_ffp6crop>0)
	{ 
	  fprintf(tempfile,"VVTERR2WAY %d PRIMARY %s FarmingPattern LABEL Treeless on C_AREA\n",lcindex,GetCropLandName(0));
	}
    if(area_ffp999crop>0)
	{ 
	  fprintf(tempfile,"VVTERR2WAY %d PRIMARY %s FarmingPattern LABEL Other on C_AREA\n",lcindex,GetCropLandName(0));
	}


	if(area_cropland_found>0)
	{
	  fprintf(tempfile,"VVTERR2WAY %d SECONDARY %s ANY on C_AREA\n",lcindex,GetCropLandName(0));
	}
    
	if(areaCropDMT0>0)
	{
      fprintf(tempfile,"VVTERR2WAY %d SECONDARY %s %s RANGE 0.0 0.0 off C_AREA\n",
		  lcindex,GetCropLandName(0),GetDMTName(0));
	}

	lcindex = lcindex + 1;
  }



  if(docheck14>0)
  {
    for(i=0;i<bridge_wd1_val_found;i++)
	{ 
	  firstextra = 0;

	  if(bridge_wid_val_found>0)
	  { 
	    if(global_bridge_wid[0]<global_bridge_wd1[i])
		{  
	      fprintf(htempfile,"VVTERR2WAY %d C_PRIMARY C_ALL_POFE off\n",lcindex);
          fprintf(htempfile,"VVTERR2WAY %d C_PRIMARY C_SOME_POFE on\n",lcindex);
          fprintf(htempfile,"VVTERR2WAY %d C_SECONDARY C_ALL_LINE off\n",lcindex);
          fprintf(htempfile,"VVTERR2WAY %d C_SECONDARY C_SOME_LINE on\n",lcindex);
          fprintf(htempfile,"VVTERR2WAY %d C_SECONDARY C_ALL_AREA off\n",lcindex);
          fprintf(htempfile,"VVTERR2WAY %d C_SECONDARY C_SOME_AREA on\n",lcindex);

          fprintf(htempfile,"VVTERR2WAY %d ANNOTATION \"Illogical Attribute/Enumeration (IAE): Line %s with \"WD1\" = \"%lf\" and smaller \"WID\"\"\n",
					 	  lcindex,GetBridgeName(1),global_bridge_wd1[i]);

          fprintf(tempfile,"VVTERR2WAY %d PRIMARY %s %s RANGE %lf %lf on C_LINE\n",
		    lcindex,
			GetBridgeName(0),
			MakeCleanCode2(GetEACLabel(GetAttrIndex("WD1"))),
			global_bridge_wd1[i],global_bridge_wd1[i]);

		  for(j=1;j<bridge_wid_val_found;j++)
		  {
			if((global_bridge_wid[j]>=global_bridge_wd1[i]))
			{
			  

              fprintf(tempfile,"VVTERR2WAY %d SECONDARY %s %s RANGE %lf %lf on C_LINE\n",
		        lcindex,
			    GetBridgeName(0),
			    MakeCleanCode2(GetEACLabel(GetAttrIndex("WID"))),
			    global_bridge_wid[0],global_bridge_wid[j-1]);
			  break;
			}

			if(
				((global_bridge_wid[j]>=global_bridge_wd1[i])) ||
                (j==bridge_wid_val_found-1)
			  )
			{
			  

              fprintf(tempfile,"VVTERR2WAY %d SECONDARY %s %s RANGE %lf %lf on C_LINE\n",
		        lcindex,
			    GetBridgeName(0),
			    MakeCleanCode2(GetEACLabel(GetAttrIndex("WID"))),
			    global_bridge_wid[0],global_bridge_wid[j]);
			  break;
			}

		  }

	      lcindex = lcindex + 1;
		}  
	  } 
	} 
  }



  if(docheck15>0)
  {
	fprintf(htempfile,"VVTERR2WAY %d C_PRIMARY C_ALL_POFE off\n",lcindex);
    fprintf(htempfile,"VVTERR2WAY %d C_PRIMARY C_SOME_POFE on\n",lcindex);
    fprintf(htempfile,"VVTERR2WAY %d C_SECONDARY C_ALL_LINE off\n",lcindex);
    fprintf(htempfile,"VVTERR2WAY %d C_SECONDARY C_SOME_LINE on\n",lcindex);
    fprintf(htempfile,"VVTERR2WAY %d C_SECONDARY C_ALL_AREA off\n",lcindex);
    fprintf(htempfile,"VVTERR2WAY %d C_SECONDARY C_SOME_AREA on\n",lcindex);

    fprintf(htempfile,"VVTERR2WAY %d ANNOTATION \"Illogical Attribute/Enumeration (IAE): Area %s with \"FFP\" = \"Terraced\" and \"DMT\" greater than or equal to \"25\"\"\n",
					 	  lcindex,GetCropLandName(1));

    if(area_ffp3crop>0)
	{ 
	  fprintf(tempfile,"VVTERR2WAY %d PRIMARY %s FarmingPattern LABEL Terraced on C_AREA\n",lcindex,GetCropLandName(0));
	}

    if(maxCropDMT>=25)
	{
      fprintf(tempfile,"VVTERR2WAY %d SECONDARY %s %s RANGE 25.0 %lf on C_AREA\n",
		  lcindex,GetCropLandName(0),GetDMTName(0),maxCropDMT);
	}

	lcindex = lcindex + 1;
  }



















  for(i=0;i<IAE_num;i++)
  {
	if(ATTRTYPE_MGCP4()==0)
	{
	  break;
	}


if(IAEDEBUG==1)
{
  printf("Processing %s\n",IAE[i]);
}

	sprintf(first,"%s",IGetNth(IAE[i],0,VERBOSE));

	if(strlen(first)>2)
	{

if(IAEDEBUG==1)
{
printf("Have new feature type %s\n",first);
}

	  finishedattrs = 0;

	  sprintf(fcode,"%s",first);

	  len = strlen(fcode);
	  for(j=1;j<len;j++)
	  {
        if(fcode[j]=='(')
		{
          fcode[j-1] = '\0';
		  break;
		}
	  }

	  for(j=0;j<maxattrs;j++)
	  {
        rowattrs[j] = -1;
	  }

	  numattrs = 0;

	  for(j=0;j<maxattrs;j++)
	  {
        sprintf(thisattr,"%s",IGetNth(IAE[i],j+3,SILENT));
		if(!strcmp(thisattr,"zzZZzz"))
		{
		  
          numattrs = j;
		  break;
		}

		if(strlen(thisattr)>1)
		{
		  rowattrs[j] = GetAttrIndex(thisattr);
if(IAEDEBUG==1)
{
		   printf("Have attribute %d:  %s = %s (%s / EAC #%d)\n",j,thisattr,GetEACLabel(rowattrs[j]),GetEACCode(rowattrs[j]),rowattrs[j]);
}
		}
		else
		{
		  
          numattrs = j;
		  break;
		}
	  }

if(IAEDEBUG==1)
{	
	  for(j=0;j<numattrs;j++)
	  {
		 if(rowattrs[j]>=0)
		 {
		   printf("For fcode %s, have attr %d: %s (%s / EAC #%d)\n",fcode,j,GetEACLabel(rowattrs[j]),GetEACCode(rowattrs[j]),rowattrs[j]);
		 }
	  }
}

	  finishedattrs = 1; 

	} 
	else
	{
      if(finishedattrs==1)
	  {
        
		finishedattrs = 2;

	    for(j=0;j<numattrs;j++)
		{ 
          if(rowattrs[j]>=0)
		  {
            sprintf(attrvals[j],"%s",IGetNth(IAE[i],j+3,SILENT));
		  } 
		}

	    for(j=0;j<numattrs;j++)
		{
		  if(rowattrs[j]>=0)
		  {
			valuepresent[j] = ValuePresent(fcode,GetEACCode(rowattrs[j]),attrvals[j],line_bridge_found,line_road_found,line_rail_found,line_sidetrack_found);

if(IAEDEBUG==1)
{
printf("For fcode %s, have attr %d: %s (%s / value \"%s\")  (present in this data: %d)\n",fcode,j,GetEACLabel(rowattrs[j]),GetEACCode(rowattrs[j]),attrvals[j],valuepresent[j]);
}

		  }
		} 
	  }
	  else
	  {
        sprintf(thisrowattr,"%s",IGetNth(IAE[i],1,SILENT));
        sprintf(thisrowvalue,"%s",IGetNth(IAE[i],2,SILENT));

		thisrowattrint = GetAttrIndex(thisrowattr);

		countedthisrow = 0;
		alldoneTextline  = 0;  
		alldoneWD1line   = 0;  
		alldoneTextarea  = 0;
		alldoneTextpoint = 0;
		alldoneWD1area   = 0;  

		if(thisrowattrint<0)
		{
          printf("Error:  %s not a valid attribute\n",thisrowattr);
		  exit(-1);
		}



		rowvaluepresent = ValuePresent(fcode,GetEACCode(thisrowattrint),thisrowvalue,line_bridge_found,line_road_found,line_rail_found,line_sidetrack_found);

if(IAEDEBUG==1)
{
	printf("..........This is a data row involving %s - %s (valuepresent: %d)\n",thisrowattr,thisrowvalue,rowvaluepresent);
}  









		

		
				
		wroteheader = 0;

		if((rowvaluepresent==100)||(rowvaluepresent==101)||(rowvaluepresent==110)||(rowvaluepresent==111))   
		{
          for(j=0;j<numattrs;j++)
		  {
            if(rowattrs[j]>=0)
			{ 
              sprintf(isx,"%s",IGetNth(IAE[i],j+3,SILENT));

			  if(strlen(isx)>0)
			  {
                if((valuepresent[j]==100)||(valuepresent[j]==101)||(valuepresent[j]==110)||(valuepresent[j]==111))
				{
 	               

				   
					if(type==1)
				   { 
					   if(wroteheader==0)
					   {
                        fprintf(htempfile,"VVTERR2WAY %d C_PRIMARY C_ALL_POFE off\n",lcindex);
                        fprintf(htempfile,"VVTERR2WAY %d C_PRIMARY C_SOME_POFE on\n",lcindex);
                        fprintf(htempfile,"VVTERR2WAY %d C_SECONDARY C_ALL_LINE off\n",lcindex);
                        fprintf(htempfile,"VVTERR2WAY %d C_SECONDARY C_SOME_LINE on\n",lcindex);
                        fprintf(htempfile,"VVTERR2WAY %d C_SECONDARY C_ALL_AREA off\n",lcindex);
                        fprintf(htempfile,"VVTERR2WAY %d C_SECONDARY C_SOME_AREA on\n",lcindex);
                        fprintf(htempfile,"VVTERR2WAY %d ANNOTATION \"Illogical Attribute/Enumeration (IAE): Point %s with \"%s\" = \"%s\" and ",
					 	  lcindex,fcode,GetEACCode(thisrowattrint),thisrowvalue);

						

						firstextra=1;

						for(k=j;k<numattrs;k++)
						{
						  if(rowattrs[k]>=0)
						  {
                            sprintf(isx,"%s",IGetNth(IAE[i],k+3,SILENT));

			                if(strlen(isx)>0)
							{ 
                              if((valuepresent[k]==100)||(valuepresent[k]==101)||(valuepresent[k]==110)||(valuepresent[k]==111))
							  {
								 if(firstextra==1)
								 {
								   fprintf(htempfile,"\"%s\"=\"%s\"",GetEACCode(rowattrs[k]),attrvals[k]);
								   firstextra = 0;
								 }
								 else
								 {
	 							   fprintf(htempfile," or \"%s\"=\"%s\"",GetEACCode(rowattrs[k]),attrvals[k]);
								 }
							  }
							} 
						  } 
						}

						fprintf(htempfile,"\"\n");

                        lcindex = lcindex + 1;
						wroteheader = 1;
					   }

                       

					   
				   } 

				   
					if(type==1)
				   { 
					 if(countedthisrow==0)  
					 { 

					   

					   if(!strcmp(GetEACCode(thisrowattrint),"NAM"))
					   { 
                             fprintf(tempfile,"VVTERR2WAY %d PRIMARY %s %s STRING \"%s\" on C_POFE\n",
						      lcindex-1,
						      MakeCleanCode(fcode),
						      MakeCleanCode2(GetEACLabel(thisrowattrint)),
						      thisrowvalue 
						      );
					   } 
                       else if(!strcmp(GetEACCode(thisrowattrint),"OHB"))
					   {
                         fprintf(tempfile,"VVTERR2WAY %d PRIMARY %s %s RANGE %s %s on C_POFE\n",
						      lcindex-1,
						      MakeCleanCode(fcode),
						      MakeCleanCode2(GetEACLabel(thisrowattrint)),
							  thisrowvalue,thisrowvalue
						      );
					   }
					   else if(
						        (!strcmp(GetEACCode(thisrowattrint),"HGT")) ||
						        (!strcmp(GetEACCode(thisrowattrint),"LTN"))
							  )
					   { 
						    if(!strcmp(thisrowvalue,"Unknown"))
							{
                             fprintf(tempfile,"VVTERR2WAY %d PRIMARY %s %s RANGE -32767.0 -32767.0 on C_POFE\n",
						      lcindex-1,
						      MakeCleanCode(fcode),
						      MakeCleanCode2(GetEACLabel(thisrowattrint))
						      );
							}
						    else if(!strcmp(thisrowvalue,"Null/Empty"))
							{
                             fprintf(tempfile,"VVTERR2WAY %d PRIMARY %s %s RANGE -32768.0 -32768.0 on C_POFE\n",
						      lcindex-1,
						      MakeCleanCode(fcode),
						      MakeCleanCode2(GetEACLabel(thisrowattrint))
						      );
							}
						    else if(!strcmp(thisrowvalue,"Not Applicable"))
							{
                             fprintf(tempfile,"VVTERR2WAY %d PRIMARY %s %s RANGE -32765.0 -32765.0 on C_POFE\n",
						      lcindex-1,
						      MakeCleanCode(fcode),
						      MakeCleanCode2(GetEACLabel(thisrowattrint))
						      );
							}
						    else if(!strcmp(thisrowvalue,"Other"))
							{
                             fprintf(tempfile,"VVTERR2WAY %d PRIMARY %s %s RANGE -32764.0 -32764.0 on C_POFE\n",
						      lcindex-1,
						      MakeCleanCode(fcode),
						      MakeCleanCode2(GetEACLabel(thisrowattrint))
						      );
							}
							else
							{
							 if(IsNumeric(thisrowvalue)==0)
							 {
                               printf("Error in parsing IVL1b point %s %s:  %s\n\n\n",MakeCleanCode(fcode),MakeCleanCode2(GetEACLabel(thisrowattrint)),thisrowvalue);
							 }
							 else
							 {
                               fprintf(tempfile,"VVTERR2WAY %d PRIMARY %s %s RANGE %s %s on C_POFE\n",
						        lcindex-1,
						        MakeCleanCode(fcode),
						        MakeCleanCode2(GetEACLabel(thisrowattrint)),
						        thisrowvalue,thisrowvalue);
							 }
							}
					   } 
					   else if(
						        (!strcmp(GetEACCode(thisrowattrint),"GAW")) &&
						        (!strcmp(thisrowvalue,"Any Real Value"))
							  )
					   {
                              fprintf(tempfile,"VVTERR2WAY %d PRIMARY %s ANY on C_POFE\n",lcindex-1,MakeCleanCode(fcode)); 

						      if(FindAttr(-32768.0,FIND_REAL,"(POINT)",fcode, GetEACCode(thisrowattrint),"unused")) 
							  {  
                                fprintf(tempfile,"VVTERR2WAY %d PRIMARY %s %s RANGE -32768.0 -32768.0 off C_POFE\n",
						         lcindex-1,
						         MakeCleanCode(fcode),
						         MakeCleanCode2(GetEACLabel(thisrowattrint)));
							  }  
						      if(FindAttr(-32767.0,FIND_REAL,"(POINT)",fcode, GetEACCode(thisrowattrint),"unused")) 
							  {  
                                fprintf(tempfile,"VVTERR2WAY %d PRIMARY %s %s RANGE -32767.0 -32767.0 off C_POFE\n",
						         lcindex-1,
						         MakeCleanCode(fcode),
						         MakeCleanCode2(GetEACLabel(thisrowattrint)));
							  }  
						      if(FindAttr(-32765.0,FIND_REAL,"(POINT)",fcode, GetEACCode(thisrowattrint),"unused")) 
							  {  
                                fprintf(tempfile,"VVTERR2WAY %d PRIMARY %s %s RANGE -32765.0 -32765.0 off C_POFE\n",
						         lcindex-1,
						         MakeCleanCode(fcode),
						         MakeCleanCode2(GetEACLabel(thisrowattrint)));
							  }  
						      if(FindAttr(-32764.0,FIND_REAL,"(POINT)",fcode, GetEACCode(thisrowattrint),"unused")) 
							  {  
                                fprintf(tempfile,"VVTERR2WAY %d PRIMARY %s %s RANGE -32764.0 -32764.0 off C_POFE\n",
						         lcindex-1,
						         MakeCleanCode(fcode),
						         MakeCleanCode2(GetEACLabel(thisrowattrint)));
							  }  
					   }
					   else
					   { 
                             fprintf(tempfile,"VVTERR2WAY %d PRIMARY %s %s LABEL %s on C_POFE\n",
						       lcindex-1,
						       MakeCleanCode(fcode),
						       MakeCleanCode2(GetEACLabel(thisrowattrint)),
						       MakeCleanCode3(thisrowvalue));
					   } 
					 } 
 
					 if(!strcmp(attrvals[j],"Any Text String"))
					 { 
						  

						  if(alldoneTextpoint==0)
						  {
							
                            fprintf(tempfile,"VVTERR2WAY %d SECONDARY %s ANY on C_POFE\n",lcindex-1,MakeCleanCode(fcode));
							alldoneTextpoint = 1;
						  }


						  if(FindAttr(-1.0,FIND_STRING,"(POINT)",fcode, GetEACCode(rowattrs[j]),"\"N/A\"")) 
						  {
                            fprintf(tempfile,"VVTERR2WAY %d SECONDARY %s %s STRING \"N/A\" off C_POFE\n",
						     lcindex-1,
						     MakeCleanCode(fcode),
						     MakeCleanCode2(GetEACLabel(rowattrs[j])));
						  }
                          if(FindAttr(-1.0,FIND_STRING,"(POINT)",fcode, GetEACCode(rowattrs[j]),"\"OTH\"")) 
						  {
                            fprintf(tempfile,"VVTERR2WAY %d SECONDARY %s %s STRING \"OTH\" off C_POFE\n",
						     lcindex-1,
						     MakeCleanCode(fcode),
						     MakeCleanCode2(GetEACLabel(rowattrs[j])));
						  }
                          if(FindAttr(-1.0,FIND_STRING,"(POINT)",fcode, GetEACCode(rowattrs[j]),"\"N_A\"")) 
						  {
                            fprintf(tempfile,"VVTERR2WAY %d SECONDARY %s %s STRING \"N_A\" off C_POFE\n",
						     lcindex-1,
						     MakeCleanCode(fcode),
						     MakeCleanCode2(GetEACLabel(rowattrs[j])));
						  }
                          if(FindAttr(-1.0,FIND_STRING,"(POINT)",fcode, GetEACCode(rowattrs[j]),"\"UNK\"")) 
						  {
                            fprintf(tempfile,"VVTERR2WAY %d SECONDARY %s %s STRING \"UNK\" off C_POFE\n",
						     lcindex-1,
						     MakeCleanCode(fcode),
						     MakeCleanCode2(GetEACLabel(rowattrs[j])));
						  }

					 } 
					 else
					 { 

						 if(!strcmp(GetEACCode(rowattrs[j]),"GAW"))
						 {
							if(!strcmp(attrvals[j],"Any Real Value"))
							{

                              fprintf(tempfile,"VVTERR2WAY %d SECONDARY %s ANY on C_POFE\n",lcindex-1,MakeCleanCode(fcode)); 

						      if(FindAttr(-32768.0,FIND_REAL,"(POINT)",fcode, GetEACCode(rowattrs[j]),"unused")) 
							  {  
                                fprintf(tempfile,"VVTERR2WAY %d SECONDARY %s %s RANGE -32768.0 -32768.0 off C_POFE\n",
						         lcindex-1,
						         MakeCleanCode(fcode),
						         MakeCleanCode2(GetEACLabel(rowattrs[j])));
							  }  
						      if(FindAttr(-32765.0,FIND_REAL,"(POINT)",fcode, GetEACCode(rowattrs[j]),"unused")) 
							  {  
                                fprintf(tempfile,"VVTERR2WAY %d SECONDARY %s %s RANGE -32765.0 -32765.0 off C_POFE\n",
						         lcindex-1,
						         MakeCleanCode(fcode),
						         MakeCleanCode2(GetEACLabel(rowattrs[j])));
							  }  
						      if(FindAttr(-32764.0,FIND_REAL,"(POINT)",fcode, GetEACCode(rowattrs[j]),"unused")) 
							  {  
                                fprintf(tempfile,"VVTERR2WAY %d SECONDARY %s %s RANGE -32764.0 -32764.0 off C_POFE\n",
						         lcindex-1,
						         MakeCleanCode(fcode),
						         MakeCleanCode2(GetEACLabel(rowattrs[j])));
							  }  
							}
						 }





						 else if(!strcmp(GetEACCode(rowattrs[j]),"LTN"))
						 {
						
							if(!strcmp(attrvals[j],"Not Applicable"))
							{  
                              fprintf(tempfile,"VVTERR2WAY %d SECONDARY %s %s RANGE -32765.0 -32765.0 on C_POFE\n",
						        lcindex-1,
						        MakeCleanCode(fcode),
						        MakeCleanCode2(GetEACLabel(rowattrs[j])));  
							}
							else if(!strcmp(attrvals[j],"Other"))
							{
                              fprintf(tempfile,"VVTERR2WAY %d SECONDARY %s %s RANGE -32764.0 -32764.0 on C_POFE\n",
						        lcindex-1,
						        MakeCleanCode(fcode),
						        MakeCleanCode2(GetEACLabel(rowattrs[j])));  
							}
							else if(!strcmp(attrvals[j],"Unknown"))
							{
                              fprintf(tempfile,"VVTERR2WAY %d SECONDARY %s %s RANGE -32767.0 -32767.0 on C_POFE\n",
						        lcindex-1,
						        MakeCleanCode(fcode),
						        MakeCleanCode2(GetEACLabel(rowattrs[j])));  
							}
							else
							{
							  printf("bad LTNVV %s\n",attrvals[j]);
							  exit(-1);
							}
						 }





						 else if(!strcmp(GetEACCode(rowattrs[j]),"HGT"))
						 {
							if(!strcmp(attrvals[j],"Any Real Value"))
							{




                              fprintf(tempfile,"VVTERR2WAY %d SECONDARY %s ANY on C_POFE\n",lcindex-1,MakeCleanCode(fcode)); 

						      if(HGTValuePresent(fcode,C_POFE,"-32765.0"))
							  {
                                  fprintf(tempfile,"VVTERR2WAY %d SECONDARY %s %s RANGE -32765.0 -32765.0 off C_POFE\n",
						           lcindex-1,
						           MakeCleanCode(fcode),
						           MakeCleanCode2(GetEACLabel(rowattrs[j]))); 
							  }

							} 
						 } 



						 else if(!strcmp(GetEACCode(rowattrs[j]),"WID"))
						 {
                           if(!strcmp(attrvals[j],"Unknown"))
						   {
                             fprintf(tempfile,"VVTERR2WAY %d SECONDARY %s %s RANGE -32767.0 -32767.0 on C_POFE\n",
						       lcindex-1,
						       MakeCleanCode(fcode),
						       MakeCleanCode2(GetEACLabel(rowattrs[j])));
						   }
						   else
						   {
							 printf("Error: unexpected %s at WDU\n",attrvals[j]);
						   }
						 }

						 else if(!strcmp(GetEACCode(rowattrs[j]),"DMT"))
						 {
                           if(!strcmp(attrvals[j],"Null/Empty"))
						   {
                             fprintf(tempfile,"VVTERR2WAY %d SECONDARY %s %s RANGE -32768.0 -32768.0 on C_POFE\n",
						       lcindex-1,
						       MakeCleanCode(fcode),
						       MakeCleanCode2(GetEACLabel(rowattrs[j])));
						   }
                           else if(!strcmp(attrvals[j],"Unknown"))
						   {
                             fprintf(tempfile,"VVTERR2WAY %d SECONDARY %s %s RANGE -32767.0 -32767.0 on C_POFE\n",
						       lcindex-1,
						       MakeCleanCode(fcode),
						       MakeCleanCode2(GetEACLabel(rowattrs[j])));
						   }
                           else if(!strcmp(attrvals[j],"Not Applicable"))
						   {
                             fprintf(tempfile,"VVTERR2WAY %d SECONDARY %s %s RANGE -32765.0 -32765.0 on C_POFE\n",
						       lcindex-1,
						       MakeCleanCode(fcode),
						       MakeCleanCode2(GetEACLabel(rowattrs[j])));
						   }
                           else if(!strcmp(attrvals[j],"Other"))
						   {
                             fprintf(tempfile,"VVTERR2WAY %d SECONDARY %s %s RANGE -32764.0 -32764.0 on C_POFE\n",
						       lcindex-1,
						       MakeCleanCode(fcode),
						       MakeCleanCode2(GetEACLabel(rowattrs[j])));
						   }
						   else
						   {
							 printf("Error: unexpected %s at WDU\n",attrvals[j]);
						   }
						 }



						 else if(!strcmp(GetEACCode(rowattrs[j]),"WD1"))
						 {




							
						 } 
						 else
						 {
                            fprintf(tempfile,"VVTERR2WAY %d SECONDARY %s %s LABEL %s on C_POFE\n",
						     lcindex-1,
						     MakeCleanCode(fcode),
						     MakeCleanCode2(GetEACLabel(rowattrs[j])),
						     MakeCleanCode3(attrvals[j]));
						 }
					 } 
				   } 
				   
                   if(countedthisrow==0)
				   { 
				      numinstances = numinstances + 1;
				   } 
                   countedthisrow = 1;
				} 
			  } 
			} 
		  } 
		}

		






		
				
		wroteheader = 0;
		countedthisrow = 0;

		if((rowvaluepresent==10)||(rowvaluepresent==11)||(rowvaluepresent==110)||(rowvaluepresent==111))   
		{
          for(j=0;j<numattrs;j++)
		  {
            if(rowattrs[j]>=0)
			{ 
              sprintf(isx,"%s",IGetNth(IAE[i],j+3,SILENT));

			  if(strlen(isx)>0)
			  {
                if((valuepresent[j]==10)||(valuepresent[j]==11)||(valuepresent[j]==110)||(valuepresent[j]==111))
				{
 	               

				   
					if(type==1)
				   { 
					   if(wroteheader==0)
					   {
                        fprintf(htempfile,"VVTERR2WAY %d C_PRIMARY C_ALL_POFE off\n",lcindex);
                        fprintf(htempfile,"VVTERR2WAY %d C_PRIMARY C_SOME_POFE on\n",lcindex);
                        fprintf(htempfile,"VVTERR2WAY %d C_SECONDARY C_ALL_LINE off\n",lcindex);
                        fprintf(htempfile,"VVTERR2WAY %d C_SECONDARY C_SOME_LINE on\n",lcindex);
                        fprintf(htempfile,"VVTERR2WAY %d C_SECONDARY C_ALL_AREA off\n",lcindex);
                        fprintf(htempfile,"VVTERR2WAY %d C_SECONDARY C_SOME_AREA on\n",lcindex);
                        fprintf(htempfile,"VVTERR2WAY %d ANNOTATION \"Illogical Attribute/Enumeration (IAE): Line %s with \"%s\" = \"%s\" and ",
					 	  lcindex,fcode,GetEACCode(thisrowattrint),thisrowvalue);

						

						firstextra=1;

						for(k=j;k<numattrs;k++)
						{
						  if(rowattrs[k]>=0)
						  {
                            sprintf(isx,"%s",IGetNth(IAE[i],k+3,SILENT));

			                if(strlen(isx)>0)
							{ 
                              if((valuepresent[k]==10)||(valuepresent[k]==11)||(valuepresent[k]==110)||(valuepresent[k]==111))
							  {
								 if(firstextra==1)
								 {
								   fprintf(htempfile,"\"%s\"=\"%s\"",GetEACCode(rowattrs[k]),attrvals[k]);
								   firstextra = 0;
								 }
								 else
								 {
	 							   fprintf(htempfile," or \"%s\"=\"%s\"",GetEACCode(rowattrs[k]),attrvals[k]);
								 }
							  }
							} 
						  } 
						}

						fprintf(htempfile,"\"\n");

                        lcindex = lcindex + 1;
						wroteheader = 1;
					   }

                       

					   
				   } 

				   
					if(type==1)
				   { 
					 if(countedthisrow==0)  
					 { 

					   

					   if(!strcmp(GetEACCode(thisrowattrint),"NAM"))
					   { 
                             fprintf(tempfile,"VVTERR2WAY %d PRIMARY %s %s STRING \"%s\" on C_LINE\n",
						      lcindex-1,
						      MakeCleanCode(fcode),
						      MakeCleanCode2(GetEACLabel(thisrowattrint)),
						      thisrowvalue 
						      );
					   } 
                       else if(!strcmp(GetEACCode(thisrowattrint),"OHB"))
					   {
                             fprintf(tempfile,"VVTERR2WAY %d PRIMARY %s %s RANGE %s %s on C_LINE\n",
						      lcindex-1,
						      MakeCleanCode(fcode),
						      MakeCleanCode2(GetEACLabel(thisrowattrint)),
							  thisrowvalue,thisrowvalue
						      );
					   }
                       else if(
						        (!strcmp(GetEACCode(thisrowattrint),"HGT")) ||
						        (!strcmp(GetEACCode(thisrowattrint),"LTN"))
							  )
					   { 
						    if(!strcmp(thisrowvalue,"Unknown"))
							{
                             fprintf(tempfile,"VVTERR2WAY %d PRIMARY %s %s RANGE -32767.0 -32767.0 on C_LINE\n",
						      lcindex-1,
						      MakeCleanCode(fcode),
						      MakeCleanCode2(GetEACLabel(thisrowattrint))
						      );
							}
						    else if(!strcmp(thisrowvalue,"Null/Empty"))
							{
                             fprintf(tempfile,"VVTERR2WAY %d PRIMARY %s %s RANGE -32768.0 -32768.0 on C_LINE\n",
						      lcindex-1,
						      MakeCleanCode(fcode),
						      MakeCleanCode2(GetEACLabel(thisrowattrint))
						      );
							}
						    else if(!strcmp(thisrowvalue,"Not Applicable"))
							{
                             fprintf(tempfile,"VVTERR2WAY %d PRIMARY %s %s RANGE -32765.0 -32765.0 on C_LINE\n",
						      lcindex-1,
						      MakeCleanCode(fcode),
						      MakeCleanCode2(GetEACLabel(thisrowattrint))
						      );
							}
						    else if(!strcmp(thisrowvalue,"Other"))
							{
                             fprintf(tempfile,"VVTERR2WAY %d PRIMARY %s %s RANGE -32764.0 -32764.0 on C_LINE\n",
						      lcindex-1,
						      MakeCleanCode(fcode),
						      MakeCleanCode2(GetEACLabel(thisrowattrint))
						      );
							}
							else
							{
							 if(IsNumeric(thisrowvalue)==0)
							 {
                               printf("Error in parsing IVL1c line %s %s:  %s\n\n\n",MakeCleanCode(fcode),MakeCleanCode2(GetEACLabel(thisrowattrint)),thisrowvalue);
							 }
							 else
							 {
                               fprintf(tempfile,"VVTERR2WAY %d PRIMARY %s %s RANGE %s %s on C_LINE\n",
						        lcindex-1,
						        MakeCleanCode(fcode),
						        MakeCleanCode2(GetEACLabel(thisrowattrint)),
						        thisrowvalue,thisrowvalue);
							 }
							}
					   } 
					   else if(
						        (!strcmp(GetEACCode(thisrowattrint),"GAW")) &&
						        (!strcmp(thisrowvalue,"Any Real Value"))
							  )
					   {
                              fprintf(tempfile,"VVTERR2WAY %d PRIMARY %s ANY on C_LINE\n",lcindex-1,MakeCleanCode(fcode)); 

						      if(FindAttr(-32768.0,FIND_REAL,"(LINE)",fcode, GetEACCode(thisrowattrint),"unused")) 
							  {  
                                fprintf(tempfile,"VVTERR2WAY %d PRIMARY %s %s RANGE -32768.0 -32768.0 off C_LINE\n",
						         lcindex-1,
						         MakeCleanCode(fcode),
						         MakeCleanCode2(GetEACLabel(thisrowattrint)));
							  }  
						      if(FindAttr(-32767.0,FIND_REAL,"(LINE)",fcode, GetEACCode(thisrowattrint),"unused")) 
							  {  
                                fprintf(tempfile,"VVTERR2WAY %d PRIMARY %s %s RANGE -32767.0 -32767.0 off C_LINE\n",
						         lcindex-1,
						         MakeCleanCode(fcode),
						         MakeCleanCode2(GetEACLabel(thisrowattrint)));
							  }  
						      if(FindAttr(-32765.0,FIND_REAL,"(LINE)",fcode, GetEACCode(thisrowattrint),"unused")) 
							  {  
                                fprintf(tempfile,"VVTERR2WAY %d PRIMARY %s %s RANGE -32765.0 -32765.0 off C_LINE\n",
						         lcindex-1,
						         MakeCleanCode(fcode),
						         MakeCleanCode2(GetEACLabel(thisrowattrint)));
							  }  
						      if(FindAttr(-32764.0,FIND_REAL,"(LINE)",fcode, GetEACCode(thisrowattrint),"unused")) 
							  {  
                                fprintf(tempfile,"VVTERR2WAY %d PRIMARY %s %s RANGE -32764.0 -32764.0 off C_LINE\n",
						         lcindex-1,
						         MakeCleanCode(fcode),
						         MakeCleanCode2(GetEACLabel(thisrowattrint)));
							  }  
					   }
					   else
					   { 
                             fprintf(tempfile,"VVTERR2WAY %d PRIMARY %s %s LABEL %s on C_LINE\n",
						       lcindex-1,
						       MakeCleanCode(fcode),
						       MakeCleanCode2(GetEACLabel(thisrowattrint)),
						       MakeCleanCode3(thisrowvalue));
					   } 
					 } 
 
					 if(!strcmp(attrvals[j],"Any Text String"))
					 { 
						  

						  if(alldoneTextline==0)
						  {
							
                            fprintf(tempfile,"VVTERR2WAY %d SECONDARY %s ANY on C_LINE\n",lcindex-1,MakeCleanCode(fcode));
							alldoneTextline = 1;
						  }


						  if(FindAttr(-1.0,FIND_STRING,"(LINE)",fcode, GetEACCode(rowattrs[j]),"\"N/A\"")) 
						  {
                            fprintf(tempfile,"VVTERR2WAY %d SECONDARY %s %s STRING \"N/A\" off C_LINE\n",
						     lcindex-1,
						     MakeCleanCode(fcode),
						     MakeCleanCode2(GetEACLabel(rowattrs[j])));
						  }
                          if(FindAttr(-1.0,FIND_STRING,"(LINE)",fcode, GetEACCode(rowattrs[j]),"\"OTH\"")) 
						  {
                            fprintf(tempfile,"VVTERR2WAY %d SECONDARY %s %s STRING \"OTH\" off C_LINE\n",
						     lcindex-1,
						     MakeCleanCode(fcode),
						     MakeCleanCode2(GetEACLabel(rowattrs[j])));
						  }
                          if(FindAttr(-1.0,FIND_STRING,"(LINE)",fcode, GetEACCode(rowattrs[j]),"\"N_A\"")) 
						  {
                            fprintf(tempfile,"VVTERR2WAY %d SECONDARY %s %s STRING \"N_A\" off C_LINE\n",
						     lcindex-1,
						     MakeCleanCode(fcode),
						     MakeCleanCode2(GetEACLabel(rowattrs[j])));
						  }
                          if(FindAttr(-1.0,FIND_STRING,"(LINE)",fcode, GetEACCode(rowattrs[j]),"\"UNK\"")) 
						  {
                            fprintf(tempfile,"VVTERR2WAY %d SECONDARY %s %s STRING \"UNK\" off C_LINE\n",
						     lcindex-1,
						     MakeCleanCode(fcode),
						     MakeCleanCode2(GetEACLabel(rowattrs[j])));
						  }

					 } 
					 else
					 { 

						 if(!strcmp(GetEACCode(rowattrs[j]),"GAW"))
						 {
							if(!strcmp(attrvals[j],"Any Real Value"))
							{

                              fprintf(tempfile,"VVTERR2WAY %d SECONDARY %s ANY on C_LINE\n",lcindex-1,MakeCleanCode(fcode)); 

						      if(FindAttr(-32768.0,FIND_REAL,"(LINE)",fcode, GetEACCode(rowattrs[j]),"unused")) 
							  {  
                                fprintf(tempfile,"VVTERR2WAY %d SECONDARY %s %s RANGE -32768.0 -32768.0 off C_LINE\n",
						         lcindex-1,
						         MakeCleanCode(fcode),
						         MakeCleanCode2(GetEACLabel(rowattrs[j])));
							  }  
						      if(FindAttr(-32765.0,FIND_REAL,"(LINE)",fcode, GetEACCode(rowattrs[j]),"unused")) 
							  {  
                                fprintf(tempfile,"VVTERR2WAY %d SECONDARY %s %s RANGE -32765.0 -32765.0 off C_LINE\n",
						         lcindex-1,
						         MakeCleanCode(fcode),
						         MakeCleanCode2(GetEACLabel(rowattrs[j])));
							  }  
						      if(FindAttr(-32764.0,FIND_REAL,"(LINE)",fcode, GetEACCode(rowattrs[j]),"unused")) 
							  {  
                                fprintf(tempfile,"VVTERR2WAY %d SECONDARY %s %s RANGE -32764.0 -32764.0 off C_LINE\n",
						         lcindex-1,
						         MakeCleanCode(fcode),
						         MakeCleanCode2(GetEACLabel(rowattrs[j])));
							  }  
							}
						 }





						 else if(!strcmp(GetEACCode(rowattrs[j]),"LTN"))
						 {
						
							if(!strcmp(attrvals[j],"Not Applicable"))
							{  
                              fprintf(tempfile,"VVTERR2WAY %d SECONDARY %s %s RANGE -32765.0 -32765.0 on C_LINE\n",
						        lcindex-1,
						        MakeCleanCode(fcode),
						        MakeCleanCode2(GetEACLabel(rowattrs[j])));  
							}
							else if(!strcmp(attrvals[j],"Other"))
							{
                              fprintf(tempfile,"VVTERR2WAY %d SECONDARY %s %s RANGE -32764.0 -32764.0 on C_LINE\n",
						        lcindex-1,
						        MakeCleanCode(fcode),
						        MakeCleanCode2(GetEACLabel(rowattrs[j])));  
							}
							else if(!strcmp(attrvals[j],"Unknown"))
							{
                              fprintf(tempfile,"VVTERR2WAY %d SECONDARY %s %s RANGE -32767.0 -32767.0 on C_LINE\n",
						        lcindex-1,
						        MakeCleanCode(fcode),
						        MakeCleanCode2(GetEACLabel(rowattrs[j])));  
							}
							else
							{
							  printf("bad LTNVV %s\n",attrvals[j]);
							  exit(-1);
							}
						 }





						 else if(!strcmp(GetEACCode(rowattrs[j]),"HGT"))
						 {
							if(!strcmp(attrvals[j],"Any Real Value"))
							{




                              fprintf(tempfile,"VVTERR2WAY %d SECONDARY %s ANY on C_LINE\n",lcindex-1,MakeCleanCode(fcode)); 

						      if(HGTValuePresent(fcode,C_LINE,"-32765.0"))
							  {
                                  fprintf(tempfile,"VVTERR2WAY %d SECONDARY %s %s RANGE -32765.0 -32765.0 off C_LINE\n",
						           lcindex-1,
						           MakeCleanCode(fcode),
						           MakeCleanCode2(GetEACLabel(rowattrs[j]))); 
							  }

							} 
						 } 



						 else if(!strcmp(GetEACCode(rowattrs[j]),"WID"))
						 {
                           if(!strcmp(attrvals[j],"Unknown"))
						   {
                             fprintf(tempfile,"VVTERR2WAY %d SECONDARY %s %s RANGE -32767.0 -32767.0 on C_LINE\n",
						       lcindex-1,
						       MakeCleanCode(fcode),
						       MakeCleanCode2(GetEACLabel(rowattrs[j])));
						   }
						   else
						   {
							 printf("Error: unexpected %s at WDU\n",attrvals[j]);
						   }
						 }



						 else if(!strcmp(GetEACCode(rowattrs[j]),"DMT"))
						 {
                           if(!strcmp(attrvals[j],"Null/Empty"))
						   {
                             fprintf(tempfile,"VVTERR2WAY %d SECONDARY %s %s RANGE -32768.0 -32768.0 on C_LINE\n",
						       lcindex-1,
						       MakeCleanCode(fcode),
						       MakeCleanCode2(GetEACLabel(rowattrs[j])));
						   }
                           else if(!strcmp(attrvals[j],"Unknown"))
						   {
                             fprintf(tempfile,"VVTERR2WAY %d SECONDARY %s %s RANGE -32767.0 -32767.0 on C_LINE\n",
						       lcindex-1,
						       MakeCleanCode(fcode),
						       MakeCleanCode2(GetEACLabel(rowattrs[j])));
						   }
                           else if(!strcmp(attrvals[j],"Not Applicable"))
						   {
                             fprintf(tempfile,"VVTERR2WAY %d SECONDARY %s %s RANGE -32765.0 -32765.0 on C_LINE\n",
						       lcindex-1,
						       MakeCleanCode(fcode),
						       MakeCleanCode2(GetEACLabel(rowattrs[j])));
						   }
                           else if(!strcmp(attrvals[j],"Other"))
						   {
                             fprintf(tempfile,"VVTERR2WAY %d SECONDARY %s %s RANGE -32764.0 -32764.0 on C_LINE\n",
						       lcindex-1,
						       MakeCleanCode(fcode),
						       MakeCleanCode2(GetEACLabel(rowattrs[j])));
						   }
						   else
						   {
							 printf("Error: unexpected %s at WDU2\n",attrvals[j]);
						   }
						 }




						 else if(!strcmp(GetEACCode(rowattrs[j]),"WD1"))
						 {

                            if(!strcmp(fcode,"Road"))
							{
							  

                              if(!strcmp(attrvals[j],"Unknown"))
							  {
                                fprintf(tempfile,"VVTERR2WAY %d SECONDARY %s %s RANGE -32767.0 -32767.0 on C_LINE\n",
						          lcindex-1,
						          MakeCleanCode(fcode),
						          MakeCleanCode2(GetEACLabel(rowattrs[j])));
							  } 
                              if(!strcmp(attrvals[j],"Not Applicable"))
							  {
                                fprintf(tempfile,"VVTERR2WAY %d SECONDARY %s %s RANGE -32765.0 -32765.0 on C_LINE\n",
						          lcindex-1,
						          MakeCleanCode(fcode),
						          MakeCleanCode2(GetEACLabel(rowattrs[j])));
							  } 
                              if(!strcmp(attrvals[j],"Other"))
							  {
                                fprintf(tempfile,"VVTERR2WAY %d SECONDARY %s %s RANGE -32764.0 -32764.0 on C_LINE\n",
						          lcindex-1,
						          MakeCleanCode(fcode),
						          MakeCleanCode2(GetEACLabel(rowattrs[j])));
							  } 
							}

							else if(!strcmp(attrvals[j],"Any Real Value"))
							{




                              if(alldoneWD1line==0)
							  { 
                                fprintf(tempfile,"VVTERR2WAY %d SECONDARY %s ANY on C_LINE\n",lcindex-1,MakeCleanCode(fcode));
							    alldoneWD1line = 1;
							  } 


							  


							  if(!strcmp(fcode,"Road"))
							  {
							
                                

							  }
							  else if(!strcmp(fcode,"Bridge"))
							  {

                                sprintf(tempisx,"%s",IGetNth(IAE[i],j+3 -4 ,SILENT)); 
							    if(strlen(tempisx)<1)
								{ 
								  
						          if(FindAttr(-32768.0,FIND_REAL,"(LINE)",fcode, GetEACCode(rowattrs[j]),"unused")) 
								  {   
                                    fprintf(tempfile,"VVTERR2WAY %d SECONDARY %s %s RANGE -32768.0 -32768.0 off C_LINE\n",
						             lcindex-1,
						             MakeCleanCode(fcode),
						             MakeCleanCode2(GetEACLabel(rowattrs[j])));
								  }   
								} 

                                sprintf(tempisx,"%s",IGetNth(IAE[i],j+3 -3 ,SILENT)); 
							    if(strlen(tempisx)<1)
								{ 
								  
                                  if(FindAttr(-32767.0,FIND_REAL,"(LINE)",fcode, GetEACCode(rowattrs[j]),"unused")) 
								  {   
                                    fprintf(tempfile,"VVTERR2WAY %d SECONDARY %s %s RANGE -32767.0 -32767.0 off C_LINE\n",
						             lcindex-1,
						             MakeCleanCode(fcode),
						             MakeCleanCode2(GetEACLabel(rowattrs[j])));
								  }   
								} 

                                sprintf(tempisx,"%s",IGetNth(IAE[i],j+3 -2 ,SILENT)); 
							    if(strlen(tempisx)<1)
								{ 
								  
                                  if(FindAttr(-32765.0,FIND_REAL,"(LINE)",fcode, GetEACCode(rowattrs[j]),"unused")) 
								  {   
                                    fprintf(tempfile,"VVTERR2WAY %d SECONDARY %s %s RANGE -32765.0 -32765.0 off C_LINE\n",
						             lcindex-1,
						             MakeCleanCode(fcode),
						             MakeCleanCode2(GetEACLabel(rowattrs[j])));
								  }  
								} 

                                sprintf(tempisx,"%s",IGetNth(IAE[i],j+3 -1 ,SILENT)); 
							    if(strlen(tempisx)<1)
								{ 
								  
                                  if(FindAttr(-32764.0,FIND_REAL,"(LINE)",fcode, GetEACCode(rowattrs[j]),"unused")) 
								  {   
                                    fprintf(tempfile,"VVTERR2WAY %d SECONDARY %s %s RANGE -32764.0 -32764.0 off C_LINE\n",
						             lcindex-1,
						             MakeCleanCode(fcode),
						             MakeCleanCode2(GetEACLabel(rowattrs[j])));
								  }   
								} 
							  }
							  else
							  {
								printf("unhandled feature type for WD1 %s\n",fcode);
							  }

							} 
							else
							{
							  

							  foundit = 0;
							  for(lookahead=j+1;lookahead<numattrs;lookahead++)
							  {
								if(rowattrs[j]!=rowattrs[lookahead])
								{
								  break;  
								}

								test2[0] = '\0';
								sprintf(test2,"%s",IGetNth(IAE[i],lookahead+3,SILENT)); 

								

								if( (!strcmp(attrvals[lookahead],"Any Real Value")) && (strlen(test2)>0) )
								{
								  
								  foundit = 1;
								  break;
								}
								
							  } 
							 
							  if(foundit==0)
							  {
								  

                                 if(!strcmp(attrvals[j],"Null/Empty"))
								 {  
                                  fprintf(tempfile,"VVTERR2WAY %d SECONDARY %s %s RANGE -32768.0 -32768.0 on C_LINE\n",
						            lcindex-1,
						            MakeCleanCode(fcode),
						            MakeCleanCode2(GetEACLabel(rowattrs[j])));
								 }   
                                 if(!strcmp(attrvals[j],"Unknown"))
								 {  
                                  fprintf(tempfile,"VVTERR2WAY %d SECONDARY %s %s RANGE -32767.0 -32767.0 on C_LINE\n",
						            lcindex-1,
						            MakeCleanCode(fcode),
						            MakeCleanCode2(GetEACLabel(rowattrs[j])));
								 }   
                                 if(!strcmp(attrvals[j],"Not Applicable"))
								 {  
                                  fprintf(tempfile,"VVTERR2WAY %d SECONDARY %s %s RANGE -32765.0 -32765.0 on C_LINE\n",
						            lcindex-1,
						            MakeCleanCode(fcode),
						            MakeCleanCode2(GetEACLabel(rowattrs[j])));
								 }   
                                 if(!strcmp(attrvals[j],"Other"))
								 {  
                                  fprintf(tempfile,"VVTERR2WAY %d SECONDARY %s %s RANGE -32764.0 -32764.0 on C_LINE\n",
						            lcindex-1,
						            MakeCleanCode(fcode),
						            MakeCleanCode2(GetEACLabel(rowattrs[j])));
								 }   
							  }

							}
						 } 
						 else
						 {
                            fprintf(tempfile,"VVTERR2WAY %d SECONDARY %s %s LABEL %s on C_LINE\n",
						     lcindex-1,
						     MakeCleanCode(fcode),
						     MakeCleanCode2(GetEACLabel(rowattrs[j])),
						     MakeCleanCode3(attrvals[j]));
						 }
					 } 
				   } 
				   
                   if(countedthisrow==0)
				   { 
				      numinstances = numinstances + 1;
				   } 
                   countedthisrow = 1;
				} 
			  } 
			} 
		  } 
		}

		





		
				
		wroteheader = 0;
		countedthisrow = 0;

		if((rowvaluepresent==1)||(rowvaluepresent==11)||(rowvaluepresent==101)||(rowvaluepresent==111)) 
		{
          for(j=0;j<numattrs;j++)
		  {
            if(rowattrs[j]>=0)
			{ 
              sprintf(isx,"%s",IGetNth(IAE[i],j+3,SILENT));

			  if(strlen(isx)>0)
			  {
                if((valuepresent[j]==1)||(valuepresent[j]==11)||(valuepresent[j]==101)||(valuepresent[j]==111))
				{

 	           


				   
					if(type==1)
				   { 
					   if(wroteheader==0)
					   {
                        fprintf(htempfile,"VVTERR2WAY %d C_PRIMARY C_ALL_POFE off\n",lcindex);
                        fprintf(htempfile,"VVTERR2WAY %d C_PRIMARY C_SOME_POFE on\n",lcindex);
                        fprintf(htempfile,"VVTERR2WAY %d C_SECONDARY C_ALL_LINE off\n",lcindex);
                        fprintf(htempfile,"VVTERR2WAY %d C_SECONDARY C_SOME_LINE on\n",lcindex);
                        fprintf(htempfile,"VVTERR2WAY %d C_SECONDARY C_ALL_AREA off\n",lcindex);
                        fprintf(htempfile,"VVTERR2WAY %d C_SECONDARY C_SOME_AREA on\n",lcindex);

                        fprintf(htempfile,"VVTERR2WAY %d ANNOTATION \"Illogical Attribute/Enumeration (IAE): Area %s with \"%s\" = \"%s\" and ",
					 	  lcindex,fcode,GetEACCode(thisrowattrint),thisrowvalue);

						

						firstextra=1;

						for(k=j;k<numattrs;k++)
						{
						  if(rowattrs[k]>=0)
						  {
                            sprintf(isx,"%s",IGetNth(IAE[i],k+3,SILENT));

			                if(strlen(isx)>0)
							{ 

                              if((valuepresent[k]==1)||(valuepresent[k]==11)||(valuepresent[k]==101)||(valuepresent[k]==111))
							  {
								 if(firstextra==1)
								 {
								   fprintf(htempfile,"\"%s\"=\"%s\"",GetEACCode(rowattrs[k]),attrvals[k]);
								   firstextra = 0;
								 }
								 else
								 {
	 							   fprintf(htempfile," or \"%s\"=\"%s\"",GetEACCode(rowattrs[k]),attrvals[k]);
								 }
							  }
							} 
						  } 
						}

						fprintf(htempfile,"\"\n");

                        lcindex = lcindex + 1;
						wroteheader = 1;
					   
					   }

                       

					   
				   } 

				   
					if(type==1)
				   { 
					 if(countedthisrow==0)  
					 { 

					   

					   if(!strcmp(GetEACCode(thisrowattrint),"NAM"))
					   { 
                             fprintf(tempfile,"VVTERR2WAY %d PRIMARY %s %s STRING \"%s\" on C_AREA\n",
						      lcindex-1,
						      MakeCleanCode(fcode),
						      MakeCleanCode2(GetEACLabel(thisrowattrint)),
						      thisrowvalue 
						      );
					   } 
                       else if(!strcmp(GetEACCode(thisrowattrint),"OHB"))
					   {
                             fprintf(tempfile,"VVTERR2WAY %d PRIMARY %s %s RANGE %s %s on C_AREA\n",
						      lcindex-1,
						      MakeCleanCode(fcode),
						      MakeCleanCode2(GetEACLabel(thisrowattrint)),
							  thisrowvalue,thisrowvalue
						      );
					   }
                       else if(
						        (!strcmp(GetEACCode(thisrowattrint),"HGT")) ||
						        (!strcmp(GetEACCode(thisrowattrint),"LTN"))
							  )
					   { 
						    if(!strcmp(thisrowvalue,"Unknown"))
							{
                             fprintf(tempfile,"VVTERR2WAY %d PRIMARY %s %s RANGE -32767.0 -32767.0 on C_AREA\n",
						      lcindex-1,
						      MakeCleanCode(fcode),
						      MakeCleanCode2(GetEACLabel(thisrowattrint))
						      );
							}
						    else if(!strcmp(thisrowvalue,"Null/Empty"))
							{
                             fprintf(tempfile,"VVTERR2WAY %d PRIMARY %s %s RANGE -32768.0 -32768.0 on C_AREA\n",
						      lcindex-1,
						      MakeCleanCode(fcode),
						      MakeCleanCode2(GetEACLabel(thisrowattrint))
						      );
							}
						    else if(!strcmp(thisrowvalue,"Not Applicable"))
							{
                             fprintf(tempfile,"VVTERR2WAY %d PRIMARY %s %s RANGE -32765.0 -32765.0 on C_AREA\n",
						      lcindex-1,
						      MakeCleanCode(fcode),
						      MakeCleanCode2(GetEACLabel(thisrowattrint))
						      );
							}
						    else if(!strcmp(thisrowvalue,"Other"))
							{
                             fprintf(tempfile,"VVTERR2WAY %d PRIMARY %s %s RANGE -32764.0 -32764.0 on C_AREA\n",
						      lcindex-1,
						      MakeCleanCode(fcode),
						      MakeCleanCode2(GetEACLabel(thisrowattrint))
						      );
							}
							else
							{
							 if(IsNumeric(thisrowvalue)==0)
							 {
                               printf("Error in parsing IVL2:  %s\n\n\n",thisrowvalue);
							 }
							 else
							 {
                               fprintf(tempfile,"VVTERR2WAY %d PRIMARY %s %s RANGE %s %s on C_AREA\n",
						        lcindex-1,
						        MakeCleanCode(fcode),
						        MakeCleanCode2(GetEACLabel(thisrowattrint)),
						        thisrowvalue,thisrowvalue);
							 }
							}
					   } 
					   else if(
						        (!strcmp(GetEACCode(thisrowattrint),"GAW")) &&
						        (!strcmp(thisrowvalue,"Any Real Value"))
							  )
					   {
                              fprintf(tempfile,"VVTERR2WAY %d PRIMARY %s ANY on C_AREA\n",lcindex-1,MakeCleanCode(fcode)); 

						      if(FindAttr(-32768.0,FIND_REAL,"(AREA)",fcode, GetEACCode(thisrowattrint),"unused")) 
							  {  
                                fprintf(tempfile,"VVTERR2WAY %d PRIMARY %s %s RANGE -32768.0 -32768.0 off C_AREA\n",
						         lcindex-1,
						         MakeCleanCode(fcode),
						         MakeCleanCode2(GetEACLabel(thisrowattrint)));
							  }  
						      if(FindAttr(-32767.0,FIND_REAL,"(AREA)",fcode, GetEACCode(thisrowattrint),"unused")) 
							  {  
                                fprintf(tempfile,"VVTERR2WAY %d PRIMARY %s %s RANGE -32767.0 -32767.0 off C_AREA\n",
						         lcindex-1,
						         MakeCleanCode(fcode),
						         MakeCleanCode2(GetEACLabel(thisrowattrint)));
							  }  
						      if(FindAttr(-32765.0,FIND_REAL,"(AREA)",fcode, GetEACCode(thisrowattrint),"unused")) 
							  {  
                                fprintf(tempfile,"VVTERR2WAY %d PRIMARY %s %s RANGE -32765.0 -32765.0 off C_AREA\n",
						         lcindex-1,
						         MakeCleanCode(fcode),
						         MakeCleanCode2(GetEACLabel(thisrowattrint)));
							  }  
						      if(FindAttr(-32764.0,FIND_REAL,"(AREA)",fcode, GetEACCode(thisrowattrint),"unused")) 
							  {  
                                fprintf(tempfile,"VVTERR2WAY %d PRIMARY %s %s RANGE -32764.0 -32764.0 off C_AREA\n",
						         lcindex-1,
						         MakeCleanCode(fcode),
						         MakeCleanCode2(GetEACLabel(thisrowattrint)));
							  }  
					   }
					   else
					   { 
                             fprintf(tempfile,"VVTERR2WAY %d PRIMARY %s %s LABEL %s on C_AREA\n",
						       lcindex-1,
						       MakeCleanCode(fcode),
						       MakeCleanCode2(GetEACLabel(thisrowattrint)),
						       MakeCleanCode3(thisrowvalue));
					   } 
					 } 
 
					 if(!strcmp(attrvals[j],"Any Text String"))
					 { 
						  

						  if(alldoneTextarea==0)
						  {
							
                            fprintf(tempfile,"VVTERR2WAY %d SECONDARY %s ANY on C_AREA\n",lcindex-1,MakeCleanCode(fcode));
							alldoneTextarea = 1;
						  }


						  if(FindAttr(-1.0,FIND_STRING,"(AREA)",fcode, GetEACCode(rowattrs[j]),"\"N/A\"")) 
						  {
                            fprintf(tempfile,"VVTERR2WAY %d SECONDARY %s %s STRING \"N/A\" off C_AREA\n",
						     lcindex-1,
						     MakeCleanCode(fcode),
						     MakeCleanCode2(GetEACLabel(rowattrs[j])));
						  }
                          if(FindAttr(-1.0,FIND_STRING,"(AREA)",fcode, GetEACCode(rowattrs[j]),"\"OTH\"")) 
						  {
                            fprintf(tempfile,"VVTERR2WAY %d SECONDARY %s %s STRING \"OTH\" off C_AREA\n",
						     lcindex-1,
						     MakeCleanCode(fcode),
						     MakeCleanCode2(GetEACLabel(rowattrs[j])));
						  }
                          if(FindAttr(-1.0,FIND_STRING,"(AREA)",fcode, GetEACCode(rowattrs[j]),"\"N_A\"")) 
						  {
                            fprintf(tempfile,"VVTERR2WAY %d SECONDARY %s %s STRING \"N_A\" off C_AREA\n",
						     lcindex-1,
						     MakeCleanCode(fcode),
						     MakeCleanCode2(GetEACLabel(rowattrs[j])));
						  }
                          if(FindAttr(-1.0,FIND_STRING,"(AREA)",fcode, GetEACCode(rowattrs[j]),"\"UNK\"")) 
						  {
                            fprintf(tempfile,"VVTERR2WAY %d SECONDARY %s %s STRING \"UNK\" off C_AREA\n",
						     lcindex-1,
						     MakeCleanCode(fcode),
						     MakeCleanCode2(GetEACLabel(rowattrs[j])));
						  }

					 } 
					 else
					 { 

						 if(!strcmp(GetEACCode(rowattrs[j]),"GAW"))
						 {
							if(!strcmp(attrvals[j],"Any Real Value"))
							{

                              fprintf(tempfile,"VVTERR2WAY %d SECONDARY %s ANY on C_AREA\n",lcindex-1,MakeCleanCode(fcode)); 

						      if(FindAttr(-32768.0,FIND_REAL,"(AREA)",fcode, GetEACCode(rowattrs[j]),"unused")) 
							  {  
                                fprintf(tempfile,"VVTERR2WAY %d SECONDARY %s %s RANGE -32768.0 -32768.0 off C_AREA\n",
						         lcindex-1,
						         MakeCleanCode(fcode),
						         MakeCleanCode2(GetEACLabel(rowattrs[j])));
							  }  
						      if(FindAttr(-32765.0,FIND_REAL,"(AREA)",fcode, GetEACCode(rowattrs[j]),"unused")) 
							  {  
                                fprintf(tempfile,"VVTERR2WAY %d SECONDARY %s %s RANGE -32765.0 -32765.0 off C_AREA\n",
						         lcindex-1,
						         MakeCleanCode(fcode),
						         MakeCleanCode2(GetEACLabel(rowattrs[j])));
							  }  
						      if(FindAttr(-32764.0,FIND_REAL,"(AREA)",fcode, GetEACCode(rowattrs[j]),"unused")) 
							  {  
                                fprintf(tempfile,"VVTERR2WAY %d SECONDARY %s %s RANGE -32764.0 -32764.0 off C_AREA\n",
						         lcindex-1,
						         MakeCleanCode(fcode),
						         MakeCleanCode2(GetEACLabel(rowattrs[j])));
							  }  
							}
						 }





						 else if(!strcmp(GetEACCode(rowattrs[j]),"LTN"))
						 {
						
							if(!strcmp(attrvals[j],"Not Applicable"))
							{  
                              fprintf(tempfile,"VVTERR2WAY %d SECONDARY %s %s RANGE -32765.0 -32765.0 on C_AREA\n",
						        lcindex-1,
						        MakeCleanCode(fcode),
						        MakeCleanCode2(GetEACLabel(rowattrs[j])));  
							}
							else if(!strcmp(attrvals[j],"Other"))
							{
                              fprintf(tempfile,"VVTERR2WAY %d SECONDARY %s %s RANGE -32764.0 -32764.0 on C_AREA\n",
						        lcindex-1,
						        MakeCleanCode(fcode),
						        MakeCleanCode2(GetEACLabel(rowattrs[j])));  
							}
							else if(!strcmp(attrvals[j],"Unknown"))
							{
                              fprintf(tempfile,"VVTERR2WAY %d SECONDARY %s %s RANGE -32767.0 -32767.0 on C_AREA\n",
						        lcindex-1,
						        MakeCleanCode(fcode),
						        MakeCleanCode2(GetEACLabel(rowattrs[j])));  
							}
							else
							{
							  printf("bad LTNVV %s\n",attrvals[j]);
							  exit(-1);
							}
						 }


						 else if(!strcmp(GetEACCode(rowattrs[j]),"SDO"))
						 {
							if(!strcmp(attrvals[j],"Any Real Value"))
							{

                              fprintf(tempfile,"VVTERR2WAY %d SECONDARY %s ANY on C_AREA\n",lcindex-1,MakeCleanCode(fcode)); 

						      if(FindAttr(-32765.0,FIND_REAL,"(AREA)",fcode, GetEACCode(rowattrs[j]),"unused")) 
							  {  
                                fprintf(tempfile,"VVTERR2WAY %d SECONDARY %s %s RANGE -32765.0 -32765.0 off C_AREA\n",
						         lcindex-1,
						         MakeCleanCode(fcode),
						         MakeCleanCode2(GetEACLabel(rowattrs[j])));
							  }  
							}
						 }



						 else if(!strcmp(GetEACCode(rowattrs[j]),"HGT"))
						 {
							if(!strcmp(attrvals[j],"Any Real Value"))
							{




                              fprintf(tempfile,"VVTERR2WAY %d SECONDARY %s ANY on C_AREA\n",lcindex-1,MakeCleanCode(fcode)); 

						      if(HGTValuePresent(fcode,C_AREA,"-32765.0"))
							  {
                                  fprintf(tempfile,"VVTERR2WAY %d SECONDARY %s %s RANGE -32765.0 -32765.0 off C_AREA\n",
						           lcindex-1,
						           MakeCleanCode(fcode),
						           MakeCleanCode2(GetEACLabel(rowattrs[j]))); 
							  }

							} 
						 } 






						 else if(!strcmp(GetEACCode(rowattrs[j]),"WID"))
						 {
                           if(!strcmp(attrvals[j],"Unknown"))
						   {
                             fprintf(tempfile,"VVTERR2WAY %d SECONDARY %s %s RANGE -32767.0 -32767.0 on C_AREA\n",
						       lcindex-1,
						       MakeCleanCode(fcode),
						       MakeCleanCode2(GetEACLabel(rowattrs[j])));
						   }
						   else
						   {
							 printf("Error: unexpected %s at WDU\n",attrvals[j]);
						   }
						 }


						 else if(!strcmp(GetEACCode(rowattrs[j]),"DMT"))
						 {
                           if(!strcmp(attrvals[j],"Null/Empty"))
						   {
                             fprintf(tempfile,"VVTERR2WAY %d SECONDARY %s %s RANGE -32768.0 -32768.0 on C_AREA\n",
						       lcindex-1,
						       MakeCleanCode(fcode),
						       MakeCleanCode2(GetEACLabel(rowattrs[j])));
						   }
                           else if(!strcmp(attrvals[j],"Unknown"))
						   {
                             fprintf(tempfile,"VVTERR2WAY %d SECONDARY %s %s RANGE -32767.0 -32767.0 on C_AREA\n",
						       lcindex-1,
						       MakeCleanCode(fcode),
						       MakeCleanCode2(GetEACLabel(rowattrs[j])));
						   }
                           else if(!strcmp(attrvals[j],"Not Applicable"))
						   {
                             fprintf(tempfile,"VVTERR2WAY %d SECONDARY %s %s RANGE -32765.0 -32765.0 on C_AREA\n",
						       lcindex-1,
						       MakeCleanCode(fcode),
						       MakeCleanCode2(GetEACLabel(rowattrs[j])));
						   }
                           else if(!strcmp(attrvals[j],"Other"))
						   {
                             fprintf(tempfile,"VVTERR2WAY %d SECONDARY %s %s RANGE -32764.0 -32764.0 on C_AREA\n",
						       lcindex-1,
						       MakeCleanCode(fcode),
						       MakeCleanCode2(GetEACLabel(rowattrs[j])));
						   }
						   else
						   {
							 printf("Error: unexpected %s at WDU2\n",attrvals[j]);
						   }
						 }





						 else if(!strcmp(GetEACCode(rowattrs[j]),"WD1"))
						 {
                            
						 }


						 else 
						 {
                            fprintf(tempfile,"VVTERR2WAY %d SECONDARY %s %s LABEL %s on C_AREA\n",
						     lcindex-1,
						     MakeCleanCode(fcode),
						     MakeCleanCode2(GetEACLabel(rowattrs[j])),
						     MakeCleanCode3(attrvals[j]));
						 }


					 } 
				   } 
				   
                   if(countedthisrow==0)
				   { 
				      numinstances = numinstances + 1;
				   } 
                   countedthisrow = 1;
				} 
			  } 
			} 
		  } 
		}

		


	  }
	}
  }





  

  fclose(htempfile);
  fclose(tempfile);






  totalchecks = docheck1a + docheck1   + docheck2   + docheck3   + 
	            docheck4  + docheck4a  + docheck4b  + docheck4c  +
                docheck5  + docheck6   + docheck7   + docheck8   +
                docheck9  + docheck10  + docheck11  + docheck11a +
				docheck12 + docheck12a + docheck12b + docheck13  + 
				docheck14 + docheck15  + numinstances;

  if(totalchecks>0)
  {
    fprintf(outfile,"UNIQUE_CHECKS 1\n");
    fprintf(outfile,"VVTERR2WAY %d\n",totalchecks);


    tempfile = fopen(htempfilename,"r");
    if(tempfile==NULL)
	{ 
      printf("Error: could not (2) open %s for read\n",htempfilename);
	  return 0;
	} 

    fgets(aline,1000,tempfile);

    while(!feof(tempfile))
	{
      fprintf(outfile,"%s",aline);
      fgets(aline,1000,tempfile);
	}

	fclose(tempfile);

    fprintf(outfile,"ATTRATTRATTR\n");

    tempfile = fopen(tempfilename,"r");
    if(tempfile==NULL)
	{ 
      printf("Error: could not (2) open %s for read\n",tempfilename);
	  return 0;
	} 

    fgets(aline,1000,tempfile);

    while(!feof(tempfile))
	{
      fprintf(outfile,"%s",aline);
      fgets(aline,1000,tempfile);
	}

	fclose(tempfile);
  }
  else
  {
	fprintf(outfile,"Data not available to specify this check\n");
  }






FreeShareSegData();

return numinstances;

}







void CacheHGTData()
{
  FILE *infofile,*datafile;
  int i,Ival,type;
  extern int LONG_ATTR_HGT;

  

  

  type = LONG_ATTR_HGT;
  
  infofile = GetLongAttrFilePtr(1,type);
  
  if(infofile==NULL)
    {
      return;
    } 
  
  datafile = GetLongAttrFilePtr(2,type);
  
  if(datafile==NULL)
    { 
      fclose(infofile);
      return;
    } 

  


  Scache_types = (short int *)malloc(sizeof(short int)*LLFidTableCount);
  Scache_posns = (long int *) malloc(sizeof(long int) *LLFidTableCount);
  Scache_nums  = (double *)   malloc(SzD*LLFidTableCount);
  Scache_chars = (char **)    malloc(sizeof(char *)*LLFidTableCount);


  for(i=0;i<LLFidTableCount;i++)
    {
      SEEIT_fread_short (&Scache_types[i],infofile);
      
      
      SEEIT_fread_long  (&Scache_posns[i],infofile);

      Scache_chars[i] = NULL;
      
      if(LLFidTable[i]<0)
	  {
	    
	  Scache_types[i] = 0;
	  }
    }
  

  for(i=0;i<LLFidTableCount;i++)
    {
      if(Scache_types[i]>0)
	{
	  Scache_chars[i] = (char *)malloc(Scache_types[i]+3);
	  
      fseek(datafile,Scache_posns[i],SEEK_SET);
 

	  fread(&Scache_chars[i][0],Scache_types[i],1,datafile);
	  Scache_chars[i][Scache_types[i]] = '\0';
	}
      else if(Scache_types[i]==-1)
	{
      fseek(datafile,Scache_posns[i],SEEK_SET);
	  SEEIT_fread_int(&Ival,datafile);
	  Scache_nums[i] = Ival;
	}
      else if(Scache_types[i]==-2)
	{
      fseek(datafile,Scache_posns[i],SEEK_SET);
	  SEEIT_fread_double(&Scache_nums[i],datafile);
	}	
    }


  fclose(infofile);
  fclose(datafile);

  


}




void FreeSpecialHGTCache()
{
  int i;

  free(Scache_types);
  free(Scache_posns);
  free(Scache_nums);
  for(i=0;i<LLFidTableCount;i++)
    {
      if(Scache_chars[i]!=NULL)
	  {
        free(Scache_chars[i]);
	  }
    }
  free(Scache_chars);

  Scache_types = NULL;
  Scache_posns = NULL;
  Scache_nums  = NULL;
  Scache_chars = NULL;

}



void EstablishVVCaching(int type)
{
  static int temp;
  extern int LONG_ATTR_NAM,free_global_char_type;

  if(type==1)
    {
      temp = free_global_char_type;
      free_global_char_type = 0;

      BuildLLTable(1,LLFidTableCount);
      Begin_LongFiles(LONG_ATTR_NAM);
      
      
      
      SpecialHGTCache = 1;
      CacheHGTData();
    }
  else if(type==2)
    {
      FreeSpecialHGTCache();
      SpecialHGTCache = 0;
      
      
      End_LongFiles(LONG_ATTR_NAM);
      FreeLLTable(); 

      free_global_char_type = temp;
    }
  else
    {
      printf("bad type to EVVC %d\n",type);
      exit(-1);
    }
  
}




void MakeNAMFile()
{
  char cleancode[1000],cleancode2[1000];
  int i,Ival,thistype,thisecc,thisgeom,temp=0,maxnum=100000,insertindex=0;
  double Dval;
  char **mynames;
  extern int free_global_char_type;
  extern int LONG_ATTR_NAM;


  mynames = (char **)malloc(maxnum * sizeof (char *));
  if(mynames==NULL)
  {
    printf("Error: out of memory MNF %d\n",(int)sizeof(char *)*maxnum);
	exit(-1);
  }


  BuildLLTable(1,LLFidTableCount);
  Begin_LongFiles(LONG_ATTR_NAM);
  temp = free_global_char_type;
  free_global_char_type = 0;

  for(i=0;i<LLFidTableCount;i++) 
  {
	if(i>maxnum)
	{
      break;
	}

    if(LLFidTable[i]<0)
	{
	  continue;
	}

    thistype = GetLongAttrVal(LONG_ATTR_NAM,i,&Ival,&Dval,&cleancode[0]);

	thisecc  = SCCtable[CrsWlk[LLFidTable[i]].LtoSmapping].ECC;
	thisgeom =          CrsWlk[LLFidTable[i]].geomtype;

    if(thistype==C_TYPE)
	{
       sprintf(cleancode2,"%s (%s):........%s",GetECCLabel(thisecc),GetShortGeomName(thisgeom),cleancode);

	   mynames[insertindex] = (char *)malloc(strlen(cleancode2)+10);
       if(mynames[insertindex]==NULL)
	   {
	     printf("Error: out of memory MNF2 %d\n",(int)strlen(cleancode2)+10);
		 printf("%s\n",cleancode2);
	     exit(-1);
	   }
	   sprintf(mynames[insertindex],"%s",cleancode2);
	   insertindex = insertindex + 1;
	}

  }  

  FreeLLTable(); 
  End_LongFiles(LONG_ATTR_NAM);
  free_global_char_type = temp;


  for(i=0;i<insertindex;i++)
  {
    printf("index %d: %s\n",i,mynames[i]);
  }

  for(i=0;i<insertindex;i++)
  {
    free(mynames[i]);
  }
  free(mynames);

}



int GetFileDate(char *filename)
{
  #include <sys/stat.h>
  
  #if(USE_DOS==1)
  extern int stat(const char *path, struct _stat* buf);
  struct _stat attrib;
  #else
  extern int stat(const char *path, struct stat* buf);
  struct stat attrib;
  #endif

  long int thetime,thetime2;

  struct tm* clock;

  if( stat(filename,&attrib) != 0 )
  {
	printf("Unable to get file date for %s\n",filename);
	printf("Reason:\n");
	perror(0);
	if(USE_DOS==0)
	{
	  printf("Possible problem: mounting an external filesystem without using the noserverino flag\n");
	}
	return 100;
  } 


  clock = gmtime(&(attrib.st_mtime));

  thetime = mktime(clock);
  thetime2 = thetime;

  

  return thetime2;

}





void GetUTCValues(long int rawtime, 
				  int *utc_year,int *utc_month,int *utc_day,
		          int *utc_hour,int *utc_min,int *utc_sec)
{
  struct tm *ptm;

  

  ptm = gmtime(&rawtime);

  *utc_year  = ptm->tm_year+1900;
  *utc_month = ptm->tm_mon+1;
  *utc_day   = ptm->tm_mday;
  *utc_hour  = ptm->tm_hour;
  *utc_min   = ptm->tm_min;
  *utc_sec   = ptm->tm_sec;

}


void SaveTime(long int thistime)
{
  FILE *outfile;
  char outfilename[1000];
  
  

  sprintf(outfilename,     "%sst.bin",outdirectory);

  outfile = fopen(outfilename,"w");
  if(outfile==NULL)
    {
      printf("Fatal error: unable to open %s for write!\n",outfilename);
      ExitWrapper(-1);
    }

  fprintf(outfile,"%ld\n",thistime);

  fclose(outfile);

}


long int ReadSavedTime()
{
  FILE *infile;
  char infilename[1000];
  long int retval;
  
  sprintf(infilename,     "%sst.bin",outdirectory);

  infile = fopen(infilename,"r");
  if(infile==NULL)
    {
      printf("Error: unable to open %s for read!\n",infilename);
	  return 0;
    }

  fscanf(infile,"%ld",&retval);

  fclose(infile);

  return retval;

}




char *GetTRExHeader()
{
  FILE *savetrexfile;
  char intrexidname[1000];
  static char retval[30];

  

  if(SLASHTYPE==NONDOS_TYPE)
  { 
    sprintf(intrexidname,"%sinternal_data/tidf.bin",indirectory);
  }
  else
  {
    sprintf(intrexidname,"%sinternal_data\\tidf.bin",indirectory);
  }

  savetrexfile = fopen(intrexidname,"r");
  if(savetrexfile==NULL)
  {
    printf("Error: Unable to open %s for read\n",intrexidname);
	return "error";
  }

  fgets(intrexidname,1000,savetrexfile);

  fclose(savetrexfile);

  if(strlen(intrexidname)<16)
  {
    sprintf(retval,"TDF_%s_%s_",intrexidname,GetTRExType(indirectory));
	return retval;
  }
  
  printf("Error reading TREx id\n:");
  if(strlen(intrexidname)>0)
  {
    printf("...%s (%d)\n",intrexidname,(int)strlen(intrexidname));
  }
  else
  {
	printf("...blank\n");
  }

  return "error";
}


char *GetTRExFileName()
{
  int utc_year,utc_month,utc_day,utc_hour,utc_min,utc_sec;
  long int thistime;
  static char retval[200];

  

  thistime = ReadSavedTime();


  GetUTCValues(thistime,
	&utc_year,&utc_month,&utc_day,
    &utc_hour,&utc_min,&utc_sec);

  sprintf(retval,"%sTREx_Reports%s%s%d%02d%02dT%02d%02d%02d",
	         indirectory,
			 GetSlash(),
			 GetTRExHeader(),
			 utc_year,
	         utc_month,
	         utc_day,
	         utc_hour,
	         utc_min,
	         utc_sec);

  return retval;
}





void RemoveTRExFiles(int type)
{
  
  return;
}




void NoExcel()
{
  not_while_running(drawing_a,"Unable to initialize Excel.  Cannot create TREx checklist.",1637,"No Excel",5);
}


void helpCallback(Widget widget, XtPointer userData, XtPointer callData)
{
  char message[2000];












  








  
  


  

  

  



  



  
  
  
  

  

  
  

  
  

























  
















 


















  




  



  

  

  







  







  if(NGA_TYPE==1)
    {


	  
      sprintf(message,"   Welcome to GAIT.\n\n\
Typical use of GAIT involves the following:\n\n\
1) Import data files in importable formats to create a\n\
GAIT project (File menu).  Then choose the resulting\n\
GAIT project as the input source (File menu).\n\n\
2) Select regions to analyze.  You can choose to analyze\n\
*all* regions by selecting the \"All Regions\" toggle button\n\
in the \"Inspection Options...\" menu.  For simplicity, the\n\
project is conceptually cut into regions.\n\n\
Alternatively, you may select a subset of the project to\n\
analyze by selecting a rectangular group of regions from the\n\
main window.\n\n\
3) Select checks to perform.  To do this, select \"Inspection Options...\"\n\
(Inspection menu) and activate the checks you wish to perform.\n\n\
Many inspection parameters may also be modified using the\n\
\"Inspection Options...\" menu.\n\n\
After these steps are done, you can\n\"Begin Inspecting Using Current Inspection Options\" (Inspection menu).");
    }
  else
    {
      sprintf(message,"              Welcome to SEE-IT.\n\n\
Typical use of SEE-IT involves the following:\n\n\
1) Import and format a SEDRIS (.stf) database (File menu).\n\
Then choose the resulting SEE-IT format database as the\n\
input source (File menu).\n\n\
2) Select regions to analyze.  You can choose to analyze\n\
*all* regions by selecting the \"All Regions\" toggle button\n\
in the \"Inspection Options...\" menu.  For simplicity, the\n\
database is conceptually cut into regions.\n\n\
Alternatively, you may select a subset of the database to\n\
analyze by selecting a rectangular group of regions from the\n\
main window.\n\n\
3) Select checks to perform.  To do this, select \"Inspection Options...\"\n\
(Inspection menu) and activate the checks you wish to perform.\n\n\
Many inspection parameters may also be modified using the\n\
\"Inspection Options...\" menu.\n\n\
After these steps are done, you can\n\"Begin Inspecting Using Current Inspection Options\" (Inspection menu).");
    }

  not_while_running(drawing_a,message,1028,"Instructions",5);
}





void folderhelpCallback(Widget widget, XtPointer userData, XtPointer callData)
{
  char message[1000];
  
      sprintf(message,"This window is used to choose a GAIT project folder.\n\
This is the folder that will be used to:\n\n\
    Store GAIT projects that are created (via Create GAIT Project...)\n\
    Look for GAIT projects to open (via Open GAIT Project...)\n\n\
The GAIT_PROJECTS environment variable can also be used to specify this\n\
folder.\n\n\
To choose a project folder, either type the full path to the folder in\n\
this window and click \"Done\" or use the \"Browse...\" button to browse\n\
the folders on the filesystem.");

not_while_running(widget,message,1387,"GAIT Project Folder Help",5);

}


void browsefolderhelpCallback(Widget widget, XtPointer userData, XtPointer callData)
{

  not_while_running(widget,"\
This window can be used to specify a folder on the filesystem\n\
which GAIT file browsers will open to automatically.\n\n\
This path should be set before using any GAIT file browsers.\n\
If GAIT file browsers are used before setting this path, this path\n\
will have no effect as the windows will remember their saved settings.\n\n\
If GAIT file browsers are used before setting this path, it is possible\n\
to use the \"Re-Set Any Existing Browsers\" button to destroy and re-set\n\
the memory of any individual browsers that have already been instantiated.",
1589,"GAIT Browse Folder Help",5);

}


void savehelpCallback(Widget widget, XtPointer userData, XtPointer callData)
{
  char message[1000];
  
  sprintf(message,"This window is used to specify a name to use to save the current\n\
inspection settings.  The name may consist of of letters, numbers,\n\
\"_\", and \"-\" characters.  The name will be automatically appended\n\
with \".txt\" to form a filename and the file will be saved in the current\n\
project's \"inspection_files\" folder.  The settings will then be\n\
available via the \"Load Settings...\" button on the \"Inspection Options\" menu.");
  
  not_while_running(widget,message,1423,"Save Settings Help",5);
  
}

void saveaoihelpCallback(Widget widget, XtPointer userData, XtPointer callData)
{
  char message[1000];
  
  sprintf(message,"This window is used to specify a name to use to save the current\n\
ponts of interest.  The name may consist of of letters, numbers,\n\
\"_\", and \"-\" characters.  The name will be automatically appended\n\
with \".txt\" to form a filename and the file will be saved in the current\n\
project's \"points_of_interest_files\" folder.  The settings will then be\n\
available via the \"Load Locations...\" button.");
  
  not_while_running(widget,message,1432,"Save Locations Help",5);
  
}




void saveCRhelpCallback(Widget widget, XtPointer userData, XtPointer callData)
{
  char message[1000];
  
  sprintf(message,"\
This window can be used to save a condition report representing the\n\
current conditions and networks using the name the user specifies.\n\n\
To save a condition report, enter a name and then click \"Save/Done\".\n\n\
The name may consist of letters, numbers, \"_\", and \"-\" characters.\n\n\
Condition reports are stored in the project's \"condition_reports\" folder.\n\n\
Saved condition reports may be loaded via the \"Load Condition Report...\"\n\
item on the \"File\" menu.");
  
  not_while_running(widget,message,1030,"Save Condition Report Help",5);
  
}











int GetTotalNonIndiv()
{
  int errnum,cloneindex;
  int total;
  struct BOList *curr;

  total = 0;


  if(dead_error==0)
    {

      for(errnum=1;errnum<=CONDITION_DEFINITIONS;errnum++)
	{
	  if(total>0)
	    {
	      break;
	    }
	  if(ErrorLookup[errnum].viewall==1)
	    {
	      total = total + ErrorLookup[errnum].number;
	    }
	}
      
      
      for(cloneindex=0;cloneindex<CLONE_DEFINITIONS;cloneindex++)
	{      
	  if(total>0)
	    {
	      break;
	    }
	  if(CloneErrorLookup[cloneindex].viewall==1)
	    {
	      total = total + CloneErrorLookup[cloneindex].number;
	    }
	}
    }


  if(dead_obhead[current_ob_head]==0)
    {
      
      
      
      curr = BOOnList;
      while(curr!=NULL)
	{
	  if(total>0)
	    {
	      break;
	    }
	  if(curr->viewall==1)
	    {
	      total = 1000;  
	    }
	  curr = curr->next;
	}
    }

  if(BODEBUG==1)
    {
      printf("TOTAL non-indiv %d\n",total);
    }

  return total;
}





int GetTotalIndiv(int *errindex, int *begin, int *end, int *cindex)
{
  int errnum,cloneindex,total,num,pos_count;
  int *pos_list;
  struct BOList *curr;

  

  total = 0;
  
  if(dead_error==0)
    {
      
      for(errnum=1;errnum<=CONDITION_DEFINITIONS;errnum++)
	{
	  if(total>1)
	    {
	      break;
	    }
	  if( (ErrorLookup[errnum].viewsome==1) && (ErrorLookup[errnum].scrollwidmade==1) )
	    {	 
	      XtVaGetValues(ErrorLookup[errnum].scrollwid,XmNselectedItemCount,&num,NULL);
	      if(num>0)
		{
		  XmListGetSelectedPos(ErrorLookup[errnum].scrollwid,&pos_list,&pos_count);
		  total     = total + num;
		  *errindex = errnum;
		  *begin    = pos_list[0];
		  *end      = pos_list[0];
		  *cindex   = -1;
		}
	    }
	}
      
      
      
      
      for(cloneindex=0;cloneindex<CLONE_DEFINITIONS;cloneindex++)
	{      
	  if(total>1)
	    {
	      break;
	    }
	  if( 
	     (CloneErrorLookup[cloneindex].viewsome==1)      && 
	     (CloneErrorLookup[cloneindex].scrollwidmade==1) 
	     )
	    {
	      XtVaGetValues(CloneErrorLookup[cloneindex].scrollwid,XmNselectedItemCount,&num,NULL);
	      if(num>0)
		{
		  XmListGetSelectedPos(CloneErrorLookup[cloneindex].scrollwid,&pos_list,&pos_count);
		  total     = total + num;
		  *errindex = errnum;
		  *begin    = pos_list[0];
		  *end      = pos_list[0];
		  *cindex   = cloneindex;
		}
	    }
	}
    }
     
 
      
  if(dead_obhead[current_ob_head]==0)
    {
      
      
      curr = BOOnList;
      while(curr!=NULL)
	{
	  if(total>1)
	    {
	      break;
	    }
	  if(curr->viewsome==1)
	    {
	      total   = total + curr->selectcount;
	      if(total==1)
		{
		  *errindex = curr->errnum;
		  *begin    = curr->speclist[0];
		  *end      = curr->speclist[0];
		  if(curr->instance==1)
		    {
		      *cindex = -1;
		    }
		  else
		    {
		      *cindex = GetCloneIndex(curr->instance-1,curr->errnum);
		    }
		}
	    }
	  curr = curr->next;
	}
    }

  if(BODEBUG==1)
    {
      printf("TOTAL indiv %d\n",total);
    }

  return total;
}



int DrawErrorsNew(int DrawAll, int errindex, int cloneindex,
		  int SingleBegin, int SingleEnd, 
		  int notxt,
		  int INDICESTODRAW[],
		  int numindices)
{
  
  int ConditionFlags[CONDITION_ARRAY_SIZE];
  struct ConditionList * NEW_LIST=NULL;
  int i,outlen,old[3];
  int SpecificConditionBegin = 0;
  int SpecificConditionEnd   = 0;
  extern int file_endianness;
  char scrubout[1000];
  int foundone=0,temp_endianness=file_endianness;
  struct AdditionalConditions * AdditionalConditionFlags=NULL;
  
  
    
  

  old[0] = SHOW_POLY_VERTICES;
  old[1] = SHOW_LINE_VERTICES;
  old[2] = SHOW_END_VERTICES;
  SHOW_POLY_VERTICES = 0;
  SHOW_LINE_VERTICES = 0;
  SHOW_END_VERTICES  = 0;



  
  foundone = 0;
  
  for(i=1;i<=CONDITION_DEFINITIONS;i++)
    {
      ConditionFlags[i] = 0;
    }
  
  
  if(DrawAll==1)
    {
      
      
      for(i=1;i<=CONDITION_DEFINITIONS;i++)
	{
	  if(ErrorLookup[i].number>0)
	    {
	      ConditionFlags[i] = ErrorLookup[i].viewall;
	      
	      if(ConditionFlags[i]==1)
		{
		  foundone++;
		}
	    }
	  else
	    {
	      ConditionFlags[i] = 0;
	    }
	}
      
      for(i=0;i<CLONE_DEFINITIONS;i++)
	{
	  if(CloneErrorLookup[i].number>0)
	    {
	      if(CloneErrorLookup[i].viewall==1)
		{
	          
		  
	          SEEIT_AddAdditionalFlag(&AdditionalConditionFlags,
					  CloneErrorLookup[i].CloneNumber, 
					  GetCloneNumber(i,CloneErrorLookup[i].CloneNumber)
					  );
		  
	          foundone++;
		}
	    }
	}
      
      
      
      sprintf(scrubout,"%s",outdirectory);
      outlen = strlen(scrubout);
      scrubout[outlen-1] = '\0';
      
      SEEIT_LoadConditionReport(scrubout);
      
      
      ABORT_ZOOM = 0;
      
      NEW_LIST =
	SEEIT_GetConditions(scrubout,
			    ConditionFlags,
			    SpecificConditionBegin,
			    SpecificConditionEnd,
			    AdditionalConditionFlags, 
			    0,                  
			    1,                  
			    1,                  
			    NULL,
			    -1
			    );
      
      
      if(NEW_LIST!=NULL)
	{
	  not_while_running(drawing_a,"An error has occured in the SEE-IT condition report API:\nNon-NULL error list returned",1370,"Error",5);
	  
	  printf("Non-NULL list\n");
	  SHOW_POLY_VERTICES = old[0];
	  SHOW_LINE_VERTICES = old[1];
	  SHOW_END_VERTICES  = old[2];
	  return -1;
	}

    }
  else if(SingleBegin>0)
    {
      
      
      if(BODEBUG==1)
	{
	  printf("Draw specific errors %d-%d for errnum (%d) cloneindex (%d) notext %d\n",
		 SingleBegin,SingleEnd,errindex,cloneindex,notxt); 
	}

      if(cloneindex<0)
	{
	  ConditionFlags[errindex] = 1;
	}
      else
	{
	  SEEIT_AddAdditionalFlag(&AdditionalConditionFlags,
				  CloneErrorLookup[cloneindex].CloneNumber, 
				  GetCloneNumber(cloneindex,CloneErrorLookup[cloneindex].CloneNumber)
				  );
	}
      
      
      sprintf(scrubout,"%s",outdirectory);
      outlen = strlen(scrubout);
      scrubout[outlen-1] = '\0';
      
      SEEIT_LoadConditionReport(scrubout);
  
      ABORT_ZOOM = 0;
      
      NEW_LIST =
	SEEIT_GetConditions(scrubout,
			    ConditionFlags,
			    SingleBegin,
			    SingleEnd,
			    AdditionalConditionFlags, 
			    0,                  
			    notxt,              
			    notxt,              
			    NULL,
			    -1
			    );
      
      
      
      if((notxt==0)&&(NEW_LIST!=NULL)&&(DetailedInfo==1))
	{
	  not_while_running(drawing_a,NEW_LIST->Message,-2,ParseErrType(NEW_LIST->CONDITION_TYPE),5);
	 
	  SEEIT_FreeConditions(NEW_LIST);
	}
      else if(NEW_LIST!=NULL)
	{
	  not_while_running(drawing_a,"An error has occured in the SEE-IT condition report API:\nNon-NULL error list returned",1370,"Error",5);
	  
	  printf("Non-NULL list\n");
	  SHOW_POLY_VERTICES = old[0];
	  SHOW_LINE_VERTICES = old[1];
	  SHOW_END_VERTICES  = old[2];
	  return -1;
	}
      
    }
  else
    {
      


      if(cloneindex<0)
	{
	  ConditionFlags[errindex] = 1;
	}
      else
	{
	  SEEIT_AddAdditionalFlag(&AdditionalConditionFlags,
				  CloneErrorLookup[cloneindex].CloneNumber, 
				  GetCloneNumber(cloneindex,CloneErrorLookup[cloneindex].CloneNumber)
				  );
	}
      
      
      sprintf(scrubout,"%s",outdirectory);
      outlen = strlen(scrubout);
      scrubout[outlen-1] = '\0';
      
      SEEIT_LoadConditionReport(scrubout);

      ABORT_ZOOM = 0;
      
      NEW_LIST =
	SEEIT_GetConditions(scrubout,
			    ConditionFlags,
			    SingleBegin,
			    SingleEnd,
			    AdditionalConditionFlags, 
			    0,                  
			    notxt,              
			    notxt,              
			    INDICESTODRAW,
			    numindices
			    );
      
      
      
      if((notxt==0)&&(NEW_LIST!=NULL)&&(DetailedInfo==1))
	{
	  not_while_running(drawing_a,NEW_LIST->Message,-2,ParseErrType(NEW_LIST->CONDITION_TYPE),5);
	 
	  SEEIT_FreeConditions(NEW_LIST);
	}
      else if(NEW_LIST!=NULL)
	{
	  not_while_running(drawing_a,"\
An error has occured in the SEE-IT condition report API:\nNon-NULL error list returned",1370,"Error",5);
	  
	  printf("Non-NULL list\n");
	  SHOW_POLY_VERTICES = old[0];
	  SHOW_LINE_VERTICES = old[1];
	  SHOW_END_VERTICES  = old[2];
	  return -1;
	}
    }


  SHOW_POLY_VERTICES = old[0];
  SHOW_LINE_VERTICES = old[1];
  SHOW_END_VERTICES  = old[2];


  file_endianness = temp_endianness;
  
  SEEIT_FreeAdditionalFlags(AdditionalConditionFlags);
  AdditionalConditionFlags = NULL;
  SEEIT_FreeConditionReportMemory();
  return foundone;
  
}





void DrawBOHelper(int errnum, int instance, int count, int notxt)
{
  int cloneindex;


  

  if(instance==1)
    {
      DrawErrorsNew(0, errnum,-1,
		    0, 0,          
		    notxt,
		    SPECNUM,
		    count);
    }
  else
    {
      cloneindex = GetCloneIndex(instance-1,errnum);
      
      DrawErrorsNew(0, errnum,cloneindex,
		    0, 0,             
		    notxt,
		    SPECNUM,
		    count);
    }
}



void ALLOC_SPECNUM(int sizetoalloc)
{
  
  if(specalloced<sizetoalloc)
    {
      if(specalloced>0)
	{
	  free(SPECNUM);
	}
      
      SPECNUM = (int *)malloc(SzI * sizetoalloc);
      if(SPECNUM==NULL)
	{
	  printf("specnum failed to alloc %d\n",sizetoalloc);
	  ExitWrapper(-1);
	} 
      specalloced = sizetoalloc;
    }
}



int DrawBO(int notxt)
{
  char filename[1000],message[1000];
  FILE *bofile;
  int i,j,ECC1,LLindex1,thisnum,errnum,num_errs,instance,ECC2,LLindex2,
    specnum,totalread,page_num,foundone;
  char geomtype;
  double magnitude,idindex, sortid;
  struct BOList *curr;
  int retval;


  retval = 0;

  if(BODEBUG==1)
    {
      printf("Drawing BO:\n");
    }
  
  sprintf(filename,"%scondreport.bo2",outdirectory);
  bofile = fopen(filename,"rb");
  if(bofile==NULL)
    {
      sprintf(message,"Error: Unable to open for reading:\n %s\nCan not continue.",
	      filename);	 
      not_while_running(drawing_a,message,1389,"Can not open By Feature file",1);
      return 1000;
    }
  
  

  curr = BOOnList;
  while(curr!=NULL)
    {
      if(curr->viewall==1)
	{
	  


	  retval = 1000;

	  if(BODEBUG==1)
	    {
	      printf("found viewall1 for ob %d err %d instance %d\n",
		     curr->ob_num,curr->errnum,curr->instance);
	    }
	  
	  page_num = curr->ob_num/num_per_page + 1;
	  if(curr->ob_num%num_per_page==0)
	    {
	      page_num = page_num -1;
	    }
	  
	  if(BODEBUG==1)
	    {
	      printf("page %d fileposn %ld\n",page_num,pageptrs[page_num]);
	    }

	  
	  fseek(bofile,pageptrs[page_num],SEEK_SET);
	  

	  for(i=1;i<=num_per_page;i++)
	    {	      
	      SEEIT_fread_char  (&geomtype,bofile);
          SEEIT_fread_double(&sortid,  bofile); 
	      SEEIT_fread_double(&idindex, bofile);
	      SEEIT_fread_int   (&ECC1,    bofile);
	      SEEIT_fread_int   (&LLindex1,bofile);
	      SEEIT_fread_int   (&thisnum, bofile);
      
	      totalread = 0;
	      

	      while(totalread<thisnum)
		{
		  SEEIT_fread_int(&errnum,   bofile);
		  SEEIT_fread_int(&num_errs, bofile);
		  SEEIT_fread_int(&instance, bofile);
		  instance = instance + 1;
	  
		  foundone = 0;

		  ALLOC_SPECNUM(num_errs);

		  for(j=0;j<num_errs;j++)
		    {
		      SEEIT_fread_double(&magnitude,bofile);
		      SEEIT_fread_int   (&ECC2,     bofile);
		      SEEIT_fread_int   (&LLindex2, bofile);
		      SEEIT_fread_int   (&specnum,  bofile);

		      if(
			 (   ( (num_per_page*(page_num-1))+i  )==curr->ob_num)      &&
			 (errnum==curr->errnum) &&
			 (instance==curr->instance)
			 )
			{
			  foundone = 1;
			  SPECNUM[j] = specnum;
			}
		      totalread = totalread + 1;
		    }
		  
		  if(foundone==1)
		    {
		      DrawBOHelper(errnum,instance,num_errs,notxt);
		    }
		}
	    }
	}
      else if(curr->viewsome==1)
	{
	  if(curr->selectcount>0)
	    {
	      

	      retval = retval + curr->selectcount;


	      ALLOC_SPECNUM(curr->selectcount);

	      for(i=0;i<curr->selectcount;i++)
		{
		  SPECNUM[i] = curr->speclist[i];
		}
	      DrawBOHelper(curr->errnum,curr->instance,curr->selectcount,notxt);
	    }
	}
      curr = curr->next;
    }
  fclose(bofile);

  return retval; 
}







int DrawReg(int notxt)
{
  int errnum,num,index,k,foundsome,StartIndex,EndIndex,junk,cloneindex;
  int retval;
  
  
  retval = 0;



  foundsome = DrawErrorsNew(1, -1, -1, -1, -1, 0,NULL,-1);

  if(foundsome>0)
    {
      retval = 1000;
    }




  
 
  for(errnum=1;errnum<=CONDITION_DEFINITIONS;errnum++)
    {
      if( (ErrorLookup[errnum].viewsome==1) && (ErrorLookup[errnum].pos_list_made>0) )
	{
	  
	  
	  

	  num = ErrorLookup[errnum].pos_list_made;

	  if(num>0)
	    {
	      

	      StartIndex = ErrorLookup[errnum].pos_list[0];
	      EndIndex   = ErrorLookup[errnum].pos_list[0];

	      for(k=1;k<num;k++)
		{
		  index = ErrorLookup[errnum].pos_list[k];
		  if(index!=EndIndex+1)
		    {
		      
			  
		      junk = DrawErrorsNew(0, errnum, -1, StartIndex, EndIndex, notxt,NULL,-1);
		      
		      retval = retval + EndIndex - StartIndex + 1;
		      
		      StartIndex = index;
		      EndIndex   = index;
		    }
		  else
		    {
		      EndIndex = index;
		    }
		}
	      junk = DrawErrorsNew(0, errnum, -1, StartIndex, EndIndex, notxt, NULL, -1);
	      retval = retval + EndIndex - StartIndex + 1;
	    }
	}
    }



  
  
  for(cloneindex=0;cloneindex<CLONE_DEFINITIONS;cloneindex++)
    {
      
      if( 
	 (CloneErrorLookup[cloneindex].viewsome==1)      && 
	 (CloneErrorLookup[cloneindex].pos_list_made>0) 
	 )
	{
	  
	  
	  

	  num = CloneErrorLookup[cloneindex].pos_list_made;

	  if(num>0)
	    {
	      

	      StartIndex = CloneErrorLookup[cloneindex].pos_list[0];
	      EndIndex   = CloneErrorLookup[cloneindex].pos_list[0];

	      for(k=1;k<num;k++)
		{
		  index = CloneErrorLookup[cloneindex].pos_list[k];
		  if(index!=EndIndex+1)
		    {
		      

		      junk = 
			DrawErrorsNew(0,CloneErrorLookup[cloneindex].CloneNumber,cloneindex,StartIndex,EndIndex,notxt, NULL, -1);

		      retval = retval + EndIndex - StartIndex + 1;

		      StartIndex = index;
		      EndIndex   = index;
		    }
		  else
		    {
		      EndIndex = index;
		    }
		}
	      junk = DrawErrorsNew(0,CloneErrorLookup[cloneindex].CloneNumber,cloneindex,
				   StartIndex,EndIndex,notxt,NULL,-1);

	      retval = retval + EndIndex - StartIndex + 1;
	      
	    }
	}
    }
  return retval;
}




void SetCenterNetZoom()
{
  

  CenterZoomOnNets = 1;

  XmToggleButtonSetState(net_zoom_b,(Boolean)CenterZoomOnNets,(Boolean)0);
}




int AnyNetworkAll()
{
  int i;

  

  for(i=1;i<=CONDITION_DEFINITIONS;i++)
    {
      if(IsNetCheck(i))
	{
	  if(ErrorLookup[i].viewallNET==1)
	    {
	      if(ErrorLookup[i].numberNets>0)  
		{
		  return 1;
		}
	    }
	}
    }
  

  for(i=0;i<CLONE_DEFINITIONS;i++)
  {
      if(IsNetCheck(CloneErrorLookup[i].CloneNumber))
	{
	  if(CloneErrorLookup[i].viewallNET==1)
	    {
	      if(CloneErrorLookup[i].numberNets>0)  
		{
		  return 1;
		}
	    }
	}
  }

  return 0;
}



void quick_network(Widget w,XtPointer userData,XtPointer call_data)
{
  int i,errnum = (int)userData;
  int totalchecks=0,totalconds=0,totalhighlighted=0;

  
  if(QUICKDEBUG==1)
    {
      printf("quickie...should call choose_specific_error on errnum %d\n",errnum);
    }



  

 NETGetGlobalTotals(&totalchecks,&totalconds,&totalhighlighted);
 
 if(totalhighlighted==1)
   {
     printf("*** only 1\n");
   }
 
 
 if(totalhighlighted==1)
 { 
    

    if(AnyNetworkAll()==0) 
	{
	  if(ErrorLookup[errnum].viewsomeNET==1)
	  {
		if(ErrorLookup[errnum].NETpos_list_made==1)
		{
		  return;
		}
	  }
	}
 }




  for(i=1;i<=CONDITION_DEFINITIONS;i++)
  {
    ErrorLookup[i].viewsomeNET = 0;
    ErrorLookup[i].viewallNET  = 0;
    
    if(ErrorLookup[i].numberNets>0)
      {
	
	XmToggleButtonSetState(ErrorLookup[i].viewallwidNET, (Boolean)0,(Boolean)0);
	XmToggleButtonSetState(ErrorLookup[i].viewsomewidNET,(Boolean)0,(Boolean)0);
      }
  }

  for(i=0;i<CLONE_DEFINITIONS;i++)
  {
     CloneErrorLookup[i].viewsomeNET = 0;
     CloneErrorLookup[i].viewallNET  = 0;

     if(CloneErrorLookup[i].numberNets>0)
       {
	 
	 XmToggleButtonSetState(CloneErrorLookup[i].viewallwidNET, (Boolean)0,(Boolean)0);
	 XmToggleButtonSetState(CloneErrorLookup[i].viewsomewidNET,(Boolean)0,(Boolean)0);
       }
  }

  
  XmToggleButtonSetState(ErrorLookup[errnum].viewsomewidNET,(Boolean)1,(Boolean)0);
  ErrorLookup[errnum].viewsomeNET = 1;

  
  SetCenterNetZoom();


  choose_specific_network((Widget)NULL,userData,call_data);

  
}




void quick_network2(Widget w,XtPointer userData,XtPointer call_data)
{
  int i,cloneindex = (int)userData;
  int totalchecks=0,totalconds=0,totalhighlighted=0;
  
  
  


  NETGetGlobalTotals(&totalchecks,&totalconds,&totalhighlighted);
 
  
 
 if(totalhighlighted==1)
   {
     

     if(AnyNetworkAll()==0) 
       {     
	 if(cloneindex>=0)
	   {
	     
	     if(CloneErrorLookup[cloneindex].viewsomeNET==1)
	       {
		 if(CloneErrorLookup[cloneindex].NETpos_list_made==1)
		   {
		     return;
		   }
	       }
	   }
       }
   }
 

 for(i=1;i<=CONDITION_DEFINITIONS;i++)
   {
     ErrorLookup[i].viewsomeNET = 0;
     ErrorLookup[i].viewallNET  = 0;
     
     if(ErrorLookup[i].numberNets>0)
       {
	 
	 XmToggleButtonSetState(ErrorLookup[i].viewallwidNET, (Boolean)0,(Boolean)0);
	 XmToggleButtonSetState(ErrorLookup[i].viewsomewidNET,(Boolean)0,(Boolean)0);
       }
   }
 
 for(i=0;i<CLONE_DEFINITIONS;i++)
   {
     CloneErrorLookup[i].viewsomeNET = 0;
     CloneErrorLookup[i].viewallNET  = 0;
     
     if(CloneErrorLookup[i].numberNets>0)
       {
	 
	 XmToggleButtonSetState(CloneErrorLookup[i].viewallwidNET, (Boolean)0,(Boolean)0);
	 XmToggleButtonSetState(CloneErrorLookup[i].viewsomewidNET,(Boolean)0,(Boolean)0);
       }
   }


  XmToggleButtonSetState(CloneErrorLookup[cloneindex].viewsomewidNET,(Boolean)1,(Boolean)0);
  CloneErrorLookup[cloneindex].viewsomeNET = 1;

  SetCenterNetZoom();

  choose_specific_network2((Widget)NULL,userData,call_data);

  

}



void InitRoutingProgress(int type)
{
  
  XmString t;
  Arg args[15];
  int n=0;
  XmString pic = XmStringCreateLocalized ("Stop Computing Route");  



  if(type==2)
  {
	if(ROUTING_INFO==1)
	{
      
      XtVaSetValues(routing_info, XmNcancelLabelString, STRING("OK")  ,NULL);
	}
	return;
  }


  

 
  t = XmStringCreateLtoR ("Computing route...",XmSTRING_DEFAULT_CHARSET);

  XtSetArg(args[n], XmNautoUnmanage,      False);                                           n++;
  XtSetArg(args[n], XmNcancelLabelString, pic);                                             n++;
  XtSetArg(args[n], XmNmessageString,     t);                                               n++;
  XtSetArg(args[n], XmNdialogTitle,       STRING("Routing Progress"));                      n++;		
  XtSetArg(args[n], XmNtranslations,      XtParseTranslationTable ( translations_global )); n++;
  XtSetArg(args[n], XmNdialogStyle,       XmDIALOG_PRIMARY_APPLICATION_MODAL);              n++;
  XtSetArg(args[n], XmNdeleteResponse,    XmDESTROY);                                       n++;  

  routing_info = XmCreateInformationDialog (drawing_a, "Routing Progress", args, n);
  
  XtUnmanageChild (XmMessageBoxGetChild (routing_info, XmDIALOG_OK_BUTTON));
  XtUnmanageChild (XmMessageBoxGetChild (routing_info, XmDIALOG_HELP_BUTTON));
  

  XtAddCallback (routing_info, XmNcancelCallback, exitCallback, (XtPointer)58);



  XtManageChild (routing_info);
  XtPopup  (XtParent(routing_info), XtGrabNone);  
  ROUTING_INFO=1;
  XmStringFree (t);
  XmStringFree (pic);

}




int route_time_update(int type, char *inmessage)
{
  XmString t;
  int len;
  char message[1000];
  static long int last_redraw=0,ThisTime;

  ThisTime = time(NULL);

  if(ROUTING_INFO==0)
  {
	return ABORT_ROUTING;
  }

  if( ((ThisTime-last_redraw)>0) || (type==2) )
  {

	len = strlen(inmessage);
	if(len>5)
	{
	  
	  if(inmessage[len-1]<32)
	  {
		inmessage[len-1] = '\0';
	  }
	}

	if(type==2)
	{
	  sprintf(message,"Computing Routing...");
	}
	else
	{
	  sprintf(message,"Route planning:\n\nFound a partial path within: %s of the goal\n\nWhen this distance reaches 0, a solution has been found",inmessage);
	}

	t = XmStringCreateLtoR (message,"mytag1");
	  
	XtVaSetValues (routing_info,
			 XmNmessageString, t,
			 NULL);
	XmStringFree (t);


    real_periodic_redraw();
    last_redraw = ThisTime;
    XmUpdateDisplay(drawing_a);
  }


  return ABORT_ROUTING;
}



void KillRouting()
{
  extern void SummarizeRoutePlanningResults();

  if(ROUTING_INFO==1)
  {
    XtPopdown(XtParent(routing_info));
	XtDestroyWidget(routing_info);
	ROUTING_INFO = 0;
  }

  SummarizeRoutePlanningResults();

}



void DrawNetworksWrapper(int errnum,int clonenum, int start, int stop)
{
  int i;
  char netname[1000];

  
  extern int DrawSubnetFeatures(char * fname, int TgtCheck,int TgtCnumber, int TgtIndexStart, int TgtIndexStop);


  sprintf(netname,"%scondreport.nt",outdirectory);


  

  

  



  
  for(i=start;i<=stop;i++)
  {
	if(ABORT_ROUTING==1)
	{
	  break;
	}
	if(ABORT_ZOOM>0)
	{
	  break;
	}

    DrawSubnetFeatures(netname,errnum,clonenum,i,i);
  }

}




void DrawNetworks()
{
  int num,index,k,StartIndex,EndIndex,cloneindex;
  int errnum,clonenum;

 

  if(dead_network==1)
    {
      return;
    }
  

  ABORT_ROUTING = 0;
  DRAWING_NETWORKS = 1;


  
  if(NetRouteType>0)
  {
	InitRoutingProgress(1);
  }


  

  for(errnum=1;errnum<=CONDITION_DEFINITIONS;errnum++)
    {
      if(ABORT_ZOOM>0)
	{
	  DRAWING_NETWORKS = 0;
	  KillRouting();
	  return;
	}

      if( (ErrorLookup[errnum].viewallNET==1) &&(ErrorLookup[errnum].numberNets>0) )
	{
	  
	  DrawNetworksWrapper(errnum,0,1,ErrorLookup[errnum].numberNets);
	}
    }

  for(cloneindex=0;cloneindex<CLONE_DEFINITIONS;cloneindex++)
    {
      if(ABORT_ZOOM>0)
	{
	  DRAWING_NETWORKS = 0;
	  KillRouting();
	  return;
	}

      if(
	 (CloneErrorLookup[cloneindex].viewallNET  == 1) &&
	 (CloneErrorLookup[cloneindex].numberNets  >  0) 
	 )
	{
	  clonenum = GetCloneNumber(cloneindex,CloneErrorLookup[cloneindex].CloneNumber);

	  
	  DrawNetworksWrapper(CloneErrorLookup[cloneindex].CloneNumber,clonenum,
			     1,CloneErrorLookup[cloneindex].numberNets);
	}
    }




  
  
  for(errnum=1;errnum<=CONDITION_DEFINITIONS;errnum++)
    {
      if(ABORT_ZOOM>0)
	{
	  DRAWING_NETWORKS = 0;
	  KillRouting();
	  return;
	}

      if( (ErrorLookup[errnum].viewsomeNET==1) && (ErrorLookup[errnum].NETpos_list_made>0) )
	{
	  
	  
	  num = ErrorLookup[errnum].NETpos_list_made;
	  
	  if(num>0)
	    {
	      StartIndex = ErrorLookup[errnum].NETpos_list[0];
	      EndIndex   = ErrorLookup[errnum].NETpos_list[0];
	      
	      for(k=1;k<num;k++)
		{
		  index = ErrorLookup[errnum].NETpos_list[k];
		  if(index!=EndIndex+1)
		    {
		      
		     
		      

		      DrawNetworksWrapper(errnum,0,StartIndex,EndIndex);

		      StartIndex = index;
		      EndIndex   = index;
		    }
		  else
		    {
		      EndIndex = index;
		    }
		}

	      
	      
	      DrawNetworksWrapper(errnum,0,StartIndex,EndIndex);
	    }
	}
    }



  
  
  for(cloneindex=0;cloneindex<CLONE_DEFINITIONS;cloneindex++)
    {
      if(ABORT_ZOOM>0)
	{
	  DRAWING_NETWORKS = 0;
	  KillRouting();
	  return;
	}
      
      if( 
	 (CloneErrorLookup[cloneindex].viewsomeNET==1)      && 
	 (CloneErrorLookup[cloneindex].NETpos_list_made>0) 
	 )
	{
	  
	  
	  num = CloneErrorLookup[cloneindex].NETpos_list_made;

	  if(num>0)
	    {
	      StartIndex = CloneErrorLookup[cloneindex].NETpos_list[0];
	      EndIndex   = CloneErrorLookup[cloneindex].NETpos_list[0];

	      for(k=1;k<num;k++)
		{
		  index = CloneErrorLookup[cloneindex].NETpos_list[k];
		  if(index!=EndIndex+1)
		    {
		      

		      errnum   = CloneErrorLookup[cloneindex].CloneNumber;
		      clonenum = GetCloneNumber(cloneindex,errnum);

		      

		      DrawNetworksWrapper(errnum,clonenum,StartIndex,EndIndex);

		      StartIndex = index;
		      EndIndex   = index;
		    }
		  else
		    {
		      EndIndex = index;
		    }
		}

	      errnum   = CloneErrorLookup[cloneindex].CloneNumber;
	      clonenum = GetCloneNumber(cloneindex,errnum);
	      
	      

	      DrawNetworksWrapper(errnum,clonenum,StartIndex,EndIndex);

	    }
	}
    }
  DRAWING_NETWORKS = 0;

  KillRouting();

}




void AddHighlightCondition(short int x,short int y, int errnum, int instance, int condnum, int fileposn)
{
  struct CondHighlight *temp;


  if(x<INFO_BUFFER)
    {
      return;
    }
  if(y<INFO_BUFFER)
    {
      return;
    }
  if(x>=1000)
    {
      return;
    }
  if(y>=850)
    {
      return;
    }

    
  if(x%2==0)
    {
      x = x/2;
    }
  else
    {
      x = (x-1)/2;	      
    }
  if(y%2==0)
    {
      y = y/2;
    }
  else
    {
      y = (y-1)/2;	      
    }
	  

  if((x>=500)||(y>=425))
    {
      XBell(mydisplay,50);
      printf(" AH violation %d %d\n",x,y);
      return;
    }
  else if(DRAWING_ERRORS==0)
    {
	  
	  printf("abnormal return (1) due to abnormal destruction of conditions found window\n");
      return;
    }
  else if(MasterStacker==NULL)
    {
	  
	  printf("abnormal return (2) due to abnormal destruction of conditions found window\n");
      return;
    }

  
  if(MasterStacker[x][y]<MAX_STACK)  
    {
      if(MasterStacker[x][y]>0)
	{
	  
	  if(
	     (MasterHighlighter[x][y]->errnum  ==errnum)   &&
	     (MasterHighlighter[x][y]->instance==instance) &&
	     (MasterHighlighter[x][y]->condnum ==condnum) 
	     )
	    {
	      return;
	    }
	  
	  
	  
	  
	}
      
      
      temp = (struct CondHighlight *)malloc(sizeof(struct CondHighlight));
      if(temp==NULL)
	{
	  printf("Out of memory when trying to allocate AddHighlightCondition\n");
	  ExitWrapper(-1);
	}
      
      
      popmem = popmem + sizeof(struct CondHighlight);
      
      
      temp->errnum                        = errnum;
      temp->instance                      = instance;
      temp->condnum                       = condnum;
	  temp->fileposn                      = fileposn;
      temp->next                          = MasterHighlighter[x][y];
      MasterHighlighter[x][y] = temp;
      MasterStacker    [x][y] = MasterStacker[x][y] + 1;

      totalALL = totalALL + 1;
      
      
      
      
    }
  else
    {
      
    }


  

}




int FreeHighlighterList(int i,int j)
{
  
  
  int numfreed=0;
  struct CondHighlight *curr;
  struct CondHighlight *prev;


  curr = MasterHighlighter[i][j];
  prev = curr;

  while(curr!=NULL)
    {
      prev = curr;
      curr = curr->next;
      free(prev);
      numfreed = numfreed + 1;
    }

  if(numfreed!=MasterStacker[i][j])
    {
      XBell(mydisplay,50);
      printf("for index %d %d freed %d but expected %d\n",i,j,numfreed,MasterStacker[i][j]);
    }

  MasterHighlighter[i][j] = NULL;
  MasterStacker    [i][j] = 0;

  return numfreed;
}




void FreeHighlighter()
{
  int i,j;
  int totalfreed = 0;

  
  
  if(POPDEBUG==1)
  {
    printf("freeing highlighter\n");
  }

  if(MasterHighlighter!=NULL)
    {
      
      for(i=0;i<500;i++)  
	{
	  for(j=0;j<425;j++)  
	    {
	      if(MasterHighlighter[i][j]!=NULL)
		{
		  totalfreed = totalfreed + FreeHighlighterList(i,j);
		}
	    }
	  free(MasterHighlighter[i]);
	  free(MasterStacker[i]);
	}
      free(MasterHighlighter);
      MasterHighlighter = NULL;
    }

  if(MasterStacker!=NULL)
    {
      free(MasterStacker);
      MasterStacker = NULL;
    }

  if(POPDEBUG==1)
  {
    printf("done....freed %d/%d\n",totalfreed,totalALL);
  }
  totalALL = 0;
}


void AllocateHighlighter()
{  
  int i,j;
  
  if(MasterHighlighter!=NULL)
    {
      

      if(POPDEBUG==1)
	{
	  printf("traversing highlighter\n");
	}
      for(i=0;i<500;i++)  
	{
	  for(j=0;j<425;j++)  
	    {
	      if(MasterHighlighter[i][j]!=NULL)
		{
		  FreeHighlighterList(i,j);
		}
	    }
	}
      if(POPDEBUG==1)
	{
	  printf("done\n");
	}
      return;
    }

  
  if(POPDEBUG==1)
    {
      printf("allocating highlighter\n");
    }

  MasterHighlighter = (struct CondHighlight ***)malloc(sizeof(struct CondHighlight *) * 500);  
  if(MasterHighlighter==NULL)
    {
      printf("Out of memory when trying to allocate highlighter %d\n",(int)sizeof(struct CondHighlight *) * 500);
      ExitWrapper(-1);
    }

  MasterStacker = (unsigned char **)malloc(sizeof(unsigned char *) * 500);  
  if(MasterStacker==NULL)
    {
      printf("Out of memory when trying to allocate stacker %d\n",SzUC * 500);
      ExitWrapper(-1);
    }


  popmem = popmem + sizeof(struct CondHighlight *) * 500;
  popmem = popmem + sizeof(unsigned char *) * 500;

  
  for(i=0;i<500;i++)  
    {
      MasterHighlighter[i] = (struct CondHighlight **)malloc(sizeof(struct CondHighlight *) * 425);  
      if(MasterHighlighter[i]==NULL)
	{
	  printf("Out of memory when trying to allocate highlighter[%d] %d\n",
		 i,(int)sizeof(struct CondHighlight *) * 425);
	  ExitWrapper(-1);
	}
      
      MasterStacker[i] = (unsigned char *)malloc(SzUC * 425);  
      if(MasterStacker[i]==NULL)
	{
	  printf("Out of memory when trying to allocate stacker[%d] %d\n",
		 i,SzUC * 425);
	  ExitWrapper(-1);
	}
      

      popmem = popmem + (sizeof(struct CondHighlight *) * 425) + (SzUC * 425);

      for(j=0;j<425;j++)
	{
	  MasterHighlighter[i][j] = NULL;
	  MasterStacker    [i][j] = 0;
	}
    }
  
  if(POPDEBUG==1)
    {
      printf("done\n");
      printf("popmem now %d (%lf)\n",popmem,(double)popmem/1048576.0);
  }
}



void MyDrawErrors()
{
  static int LOCALBUSY = 0;
  int totaldrawn=0;
  int totalbodrawn=0;
  

  if(
     (dead_error==1)                    &&
     (dead_obhead[current_ob_head]==1)  
     )  
    {
      DrawNetworks();
      return;
    }
    
  

  if(LOCALBUSY==1)
    {
      printf("(1) Draw action ignored due to being too busy\n");
      return;
    }
  
  LOCALBUSY = 1;


  
  


  DRAWING_ERRORS = 1;



  AllocateHighlighter();



  if(dead_error==0)
    {
      totaldrawn = DrawReg(1); 

      if(BODEBUG==1)
	{
	  printf("Drew %d in reg error pass\n",totaldrawn);
	}
    }



  if(dead_obhead[current_ob_head]==0)
    {
      
      totalbodrawn = DrawBO(1);

      if(BODEBUG==1)
	{
	  printf("Drew %d in bo error pass\n",totalbodrawn);
	}
    }

  
  


  if((totaldrawn==1)&&(DetailedInfo==1))
    {
      
      totaldrawn = DrawReg(0); 
    }

  if((totalbodrawn==1)&&(DetailedInfo==1))
    {
      
      totaldrawn = DrawBO(0);
    }


  DRAWING_ERRORS = 0;

  DrawNetworks();

  LOCALBUSY = 0;

  if(POPDEBUG==1)
    {
      printf("after allocating %d (%d %lf), popmem now %d (%lf)\n",
	     totalALL,totalALL*12,(double)totalALL*(12.0/1048576.0),
	     popmem,(double)popmem/1048576.0);
    }

}




void AllocArrays(int errnum, int axis, int clonenum, int cloneindex)
{
  int i;
  extern int SACfull;


  if( (clonenum==0) && (axis==1) && (ErrorLookup[errnum].primaryEDCSstuff==NULL))
    {
      ErrorLookup[errnum].primaryEDCSstuff = 
	(unsigned char *) malloc (SzUC * SACfull);
      
      if(ErrorLookup[errnum].primaryEDCSstuff==NULL)
	{
	  printf("malloc prim1:  couldnt malloc %d\n",SzUC * SACfull);
	  ExitWrapper(-1);
	}
      
      for(i=0;i<SACfull;i++)
	{
	  ErrorLookup[errnum].primaryEDCSstuff[i] = 0;
	}
    }
  else if( (clonenum>0) && (axis==1) && (CloneErrorLookup[cloneindex].primaryEDCSstuff==NULL))
    {
      CloneErrorLookup[cloneindex].primaryEDCSstuff = 
	(unsigned char *) malloc (SzUC * SACfull);
      
      if(CloneErrorLookup[cloneindex].primaryEDCSstuff==NULL)
	{
	  printf("malloc prim2:  couldnt malloc %d\n",SzUC * SACfull);
	  ExitWrapper(-1);
	}
      
      for(i=0;i<SACfull;i++)
	{
	  CloneErrorLookup[cloneindex].primaryEDCSstuff[i] = 0;
	}
    }




  else if( (clonenum==0) && (axis==2) && (ErrorLookup[errnum].secondaryEDCSstuff==NULL))
    {
      ErrorLookup[errnum].secondaryEDCSstuff = 
	(unsigned char *) malloc (SzUC * SACfull);
      
      if(ErrorLookup[errnum].secondaryEDCSstuff==NULL)
	{
	  printf("malloc prim3:  couldnt malloc %d\n",SzUC * SACfull);
	  ExitWrapper(-1);
	}
      
      for(i=0;i<SACfull;i++)
	{
	  ErrorLookup[errnum].secondaryEDCSstuff[i] = 0;
	}
    }
  else if( (clonenum>0) && (axis==2) && (CloneErrorLookup[cloneindex].secondaryEDCSstuff==NULL))
    {
      CloneErrorLookup[cloneindex].secondaryEDCSstuff = 
	(unsigned char *) malloc (SzUC * SACfull);
      
      if(CloneErrorLookup[cloneindex].secondaryEDCSstuff==NULL)
	{
	  printf("malloc prim4:  couldnt malloc %d\n",SzUC * SACfull);
	  ExitWrapper(-1);
	}
      
      for(i=0;i<SACfull;i++)
	{
	  CloneErrorLookup[cloneindex].secondaryEDCSstuff[i] = 0;
	}
    }


  else if( (clonenum==0) && (axis==3) && (ErrorLookup[errnum].tertiaryEDCSstuff==NULL))
    {
      ErrorLookup[errnum].tertiaryEDCSstuff = 
	(unsigned char *) malloc (SzUC * SACfull);
      
      if(ErrorLookup[errnum].tertiaryEDCSstuff==NULL)
	{
	  printf("malloc prim5:  couldnt malloc %d\n",SzUC * SACfull);
	  ExitWrapper(-1);
	}
      
      for(i=0;i<SACfull;i++)
	{
	  ErrorLookup[errnum].tertiaryEDCSstuff[i] = 0;
	}
    }
  else if( (clonenum>0) && (axis==3) && (CloneErrorLookup[cloneindex].tertiaryEDCSstuff==NULL))
    {
      CloneErrorLookup[cloneindex].tertiaryEDCSstuff = 
	(unsigned char *) malloc (SzUC * SACfull);
      
      if(CloneErrorLookup[cloneindex].tertiaryEDCSstuff==NULL)
	{
	  printf("malloc prim6:  couldnt malloc %d\n",SzUC * SACfull);
	  ExitWrapper(-1);
	}
      
      for(i=0;i<SACfull;i++)
	{
	  CloneErrorLookup[cloneindex].tertiaryEDCSstuff[i] = 0;
	}
    }
}





void AllocArrays2(int errnum, int axis, int clonenum, int cloneindex)
{
  int i;

  

  if( (clonenum==0) && (axis==1) && (ErrorLookup[errnum].primaryFIDstuff==NULL))
    {
      ErrorLookup[errnum].primaryFIDstuff = 
	(unsigned char *) malloc (SzUC * LLFidTableCount);
      
      if(ErrorLookup[errnum].primaryFIDstuff==NULL)
	{
	  printf("malloc prim7:  couldnt malloc %d\n",SzUC * LLFidTableCount);
	  ExitWrapper(-1);
	}
      
      for(i=0;i<LLFidTableCount;i++)
	{
	  ErrorLookup[errnum].primaryFIDstuff[i] = 0;
	}
    }
  else if( (clonenum>0) && (axis==1) && (CloneErrorLookup[cloneindex].primaryFIDstuff==NULL))
    {
      CloneErrorLookup[cloneindex].primaryFIDstuff = 
	(unsigned char *) malloc (SzUC * LLFidTableCount);
      
      if(CloneErrorLookup[cloneindex].primaryFIDstuff==NULL)
	{
	  printf("malloc prim8:  couldnt malloc %d\n",SzUC * LLFidTableCount);
	  ExitWrapper(-1);
	}
      
      for(i=0;i<LLFidTableCount;i++)
	{
	  CloneErrorLookup[cloneindex].primaryFIDstuff[i] = 0;
	}
    }




  else if( (clonenum==0) && (axis==2) && (ErrorLookup[errnum].secondaryFIDstuff==NULL))
    {
      ErrorLookup[errnum].secondaryFIDstuff = 
	(unsigned char *) malloc (SzUC * LLFidTableCount);
      
      if(ErrorLookup[errnum].secondaryFIDstuff==NULL)
	{
	  printf("malloc prim9:  couldnt malloc %d\n",SzUC * LLFidTableCount);
	  ExitWrapper(-1);
	}
      
      for(i=0;i<LLFidTableCount;i++)
	{
	  ErrorLookup[errnum].secondaryFIDstuff[i] = 0;
	}
    }
  else if( (clonenum>0) && (axis==2) && (CloneErrorLookup[cloneindex].secondaryFIDstuff==NULL))
    {
      CloneErrorLookup[cloneindex].secondaryFIDstuff = 
	(unsigned char *) malloc (SzUC * LLFidTableCount);
      
      if(CloneErrorLookup[cloneindex].secondaryFIDstuff==NULL)
	{
	  printf("malloc prim10:  couldnt malloc %d\n",SzUC * LLFidTableCount);
	  ExitWrapper(-1);
	}
      
      for(i=0;i<LLFidTableCount;i++)
	{
	  CloneErrorLookup[cloneindex].secondaryFIDstuff[i] = 0;
	}
    }


  else if( (clonenum==0) && (axis==3) && (ErrorLookup[errnum].tertiaryFIDstuff==NULL))
    {
      ErrorLookup[errnum].tertiaryFIDstuff = 
	(unsigned char *) malloc (SzUC * LLFidTableCount);
      
      if(ErrorLookup[errnum].tertiaryFIDstuff==NULL)
	{
	  printf("malloc prim11:  couldnt malloc %d\n",SzUC * LLFidTableCount);
	  ExitWrapper(-1);
	}
      
      for(i=0;i<LLFidTableCount;i++)
	{
	  ErrorLookup[errnum].tertiaryFIDstuff[i] = 0;
	}
    }
  else if( (clonenum>0) && (axis==3) && (CloneErrorLookup[cloneindex].tertiaryFIDstuff==NULL))
    {
      CloneErrorLookup[cloneindex].tertiaryFIDstuff = 
	(unsigned char *) malloc (SzUC * LLFidTableCount);
      
      if(CloneErrorLookup[cloneindex].tertiaryFIDstuff==NULL)
	{
	  printf("malloc prim12:  couldnt malloc %d\n",SzUC * LLFidTableCount);
	  ExitWrapper(-1);
	}
      
      for(i=0;i<LLFidTableCount;i++)
	{
	  CloneErrorLookup[cloneindex].tertiaryFIDstuff[i] = 0;
	}
    }
}





void SetIndex(int errnum, int axis, int ADDER, int Lindex, int clonenum, int cloneindex, int geomtype)
{
  
  
  
  int thisgeomtype;
  
  thisgeomtype = CrsWlk[Lindex].geomtype;
  
  
  
  AllocArrays(errnum, axis, clonenum, cloneindex);
  
  if(clonenum==0)
    {
      if(axis==1)
	{
	  if(ErrorLookup[errnum].Config1[thisgeomtype]!=2)
	    {
	      if(ADDER==1)
		{
		  ErrorLookup[errnum].primaryEDCSstuff[Lindex] = 1;
		}
	      else
		{
		  ErrorLookup[errnum].primaryEDCSstuff[Lindex] = 2;
		}
	    }
	}
      else if(axis==2)
	{
	  if(ErrorLookup[errnum].Config2[thisgeomtype]!=2)
	    {
	      if(ADDER==1)
		{
		  ErrorLookup[errnum].secondaryEDCSstuff[Lindex] = 1;
		}
	      else
		{
		  ErrorLookup[errnum].secondaryEDCSstuff[Lindex] = 2;
		}
	    }
	}
      else if(axis==3)
	{
	  if(ErrorLookup[errnum].Config3[thisgeomtype]!=2)
	    {
	      if(ADDER==1)
		{
		  ErrorLookup[errnum].tertiaryEDCSstuff[Lindex] = 1;
		}
	      else
		{
		  ErrorLookup[errnum].tertiaryEDCSstuff[Lindex] = 2;
		}
	    }
	}
    }
  else
    {
      if(axis==1)
	{
	  if(CloneErrorLookup[cloneindex].Config1[thisgeomtype]!=2)
	    {
	      if(ADDER==1)
		{
		  CloneErrorLookup[cloneindex].primaryEDCSstuff[Lindex] = 1;
		}
	      else
		{
		  CloneErrorLookup[cloneindex].primaryEDCSstuff[Lindex] = 2;
		}
	    }
	}
      else if(axis==2)
	{
	  if(CloneErrorLookup[cloneindex].Config2[thisgeomtype]!=2)
	    {
	      if(ADDER==1)
		{
		  CloneErrorLookup[cloneindex].secondaryEDCSstuff[Lindex] = 1;
		}
	      else
		{
		  CloneErrorLookup[cloneindex].secondaryEDCSstuff[Lindex] = 2;
		}
	    }
	}
      else if(axis==3)
	{
	  if(CloneErrorLookup[cloneindex].Config3[thisgeomtype]!=2)
	    {
	      if(ADDER==1)
		{
		  CloneErrorLookup[cloneindex].tertiaryEDCSstuff[Lindex] = 1;
		}
	      else
		{
		  CloneErrorLookup[cloneindex].tertiaryEDCSstuff[Lindex] = 2;
		}
	    }
	}
    }
}


void SetIndex2(int errnum, int axis, int ADDER, int FID, int clonenum, int cloneindex, int geomtype)
{

  

  
 
  

  AllocArrays2(errnum, axis, clonenum, cloneindex);

  if(clonenum==0)
    {
      if(axis==1)
	{
	  if(ErrorLookup[errnum].Config1[geomtype]!=2)
	    {
	      if(ADDER==1)
		{
		  ErrorLookup[errnum].primaryFIDstuff[FID] = 1;
		}
	      else
		{
		  ErrorLookup[errnum].primaryFIDstuff[FID] = 2;
		}
	    }
	}
      else if(axis==2)
	{
	  if(ErrorLookup[errnum].Config2[geomtype]!=2)
	    {
	      if(ADDER==1)
		{
		  ErrorLookup[errnum].secondaryFIDstuff[FID] = 1;
		}
	      else
		{
		  ErrorLookup[errnum].secondaryFIDstuff[FID] = 2;
		}
	    }
	}
      else if(axis==3)
	{
	  if(ErrorLookup[errnum].Config3[geomtype]!=2)
	    {
	      if(ADDER==1)
		{
		  ErrorLookup[errnum].tertiaryFIDstuff[FID] = 1;
		}
	      else
		{
		  ErrorLookup[errnum].tertiaryFIDstuff[FID] = 2;
		}
	    }
	}
    }
  else
    {
      if(axis==1)
	{
	  if(CloneErrorLookup[cloneindex].Config1[geomtype]!=2)
	    {
	      if(ADDER==1)
		{
		  CloneErrorLookup[cloneindex].primaryFIDstuff[FID] = 1;
		}
	      else
		{
		  CloneErrorLookup[cloneindex].primaryFIDstuff[FID] = 2;
		}
	    }
	}
      else if(axis==2)
	{
	  if(CloneErrorLookup[cloneindex].Config2[geomtype]!=2)
	    {
	      if(ADDER==1)
		{
		  CloneErrorLookup[cloneindex].secondaryFIDstuff[FID] = 1;
		}
	      else
		{
		  CloneErrorLookup[cloneindex].secondaryFIDstuff[FID] = 2;
		}
	    }
	}
      else if(axis==3)
	{
	  if(CloneErrorLookup[cloneindex].Config3[geomtype]!=2)
	    {
	      if(ADDER==1)
		{
		  CloneErrorLookup[cloneindex].tertiaryFIDstuff[FID] = 1;
		}
	      else
		{
		  CloneErrorLookup[cloneindex].tertiaryFIDstuff[FID] = 2;
		}
	    }
	}
    }
}





typedef struct LA_nodeTag {
  struct LA_nodeTag *left;    
  struct LA_nodeTag *right;   
  struct LA_nodeTag *parent;  
  nodeColor color;            
  char *key;                  
  int *FIDs;                  
  int numFIDs;                
} LA_nodeType_LIST;

#define LA_NILL &LA_sentinel         
LA_nodeType_LIST LA_sentinel = { LA_NILL, LA_NILL, 0, BLACK, NULL,NULL,-1};

LA_nodeType_LIST *LA_root = LA_NILL; 
int la_nodes_freed=0;





void LA_RealFreeTree(LA_nodeType_LIST *node)
{  
   
  if((node->left!=LA_NILL)&&(node->right!=LA_NILL))
    {
      LA_RealFreeTree(node->left);
      LA_RealFreeTree(node->right);
      la_nodes_freed++;
      free(node->key);
      free(node->FIDs);
      free(node);
    } 
  else if(node->left!=LA_NILL)
    {
      LA_RealFreeTree(node->left);
      la_nodes_freed++;
      free(node->key);
      free(node->FIDs);
      free(node);  
    }
  else if(node->right!=LA_NILL)
    {
      LA_RealFreeTree(node->right);
      la_nodes_freed++;
      free(node->key);
      free(node->FIDs);
      free(node);
    }
  else if(node!=LA_NILL)
    {
      la_nodes_freed++;
      free(node->key);
      free(node->FIDs);
      free(node);
    }  
}


void LA_FreeTree()
{
  LA_RealFreeTree(LA_root);
  LA_root = LA_NILL;
  
  la_nodes_freed=0;
}


void LA_rotateLeft(LA_nodeType_LIST **thisroot, LA_nodeType_LIST *x) 
{
  
  LA_nodeType_LIST *y = x->right;
  
  x->right = y->left;
  if (y->left != LA_NILL) y->left->parent = x;
  
  if (y != LA_NILL) y->parent = x->parent;
  if (x->parent) 
    {
      if (x == x->parent->left)
	x->parent->left = y;
      else
	x->parent->right = y;
    } 
  else 
    {      
      *thisroot = y;
    }
  
  y->left = x;
  if (x != LA_NILL) x->parent = y;
}


void LA_rotateRight(LA_nodeType_LIST **thisroot, LA_nodeType_LIST *x) 
{
  
  LA_nodeType_LIST *y = x->left;
  
  
  x->left = y->right;
  if (y->right != LA_NILL) y->right->parent = x;
  
  if (y != LA_NILL) y->parent = x->parent;
  if (x->parent) 
    {
      if (x == x->parent->right)
	x->parent->right = y;
      else
	x->parent->left = y;
    }
  else 
    {
      *thisroot = y;
    }
  
  y->right = x;
  if (x != LA_NILL) x->parent = y;
}

void LA_insertFixup(LA_nodeType_LIST **thisroot, LA_nodeType_LIST *x) 
{
  
  
  while (x != *thisroot && x->parent->color == RED) 
    {
      
      if (x->parent == x->parent->parent->left) 
	{
	  LA_nodeType_LIST *y = x->parent->parent->right;
	  if (y->color == RED) 
	    {	      
	      
	      x->parent->color = BLACK;
	      y->color = BLACK;
	      x->parent->parent->color = RED;
	      x = x->parent->parent;
            } 
	  else 
	    {
	      
	      if (x == x->parent->right) 
		{
		  
		  x = x->parent;
		  LA_rotateLeft(thisroot, x);
		}                
	      x->parent->color = BLACK;
	      x->parent->parent->color = RED;
	      LA_rotateRight(thisroot, x->parent->parent);
            }
        }
      else 
	{
	  
	  LA_nodeType_LIST *y = x->parent->parent->left;
	  if (y->color == RED) 
	    {
	      
	      x->parent->color = BLACK;
	      y->color = BLACK;
	      x->parent->parent->color = RED;
	      x = x->parent->parent;
	    }
	  else 
	    {
	      
	      if (x == x->parent->left) 
		{
		  x = x->parent;
		  LA_rotateRight(thisroot, x);
		}
	      x->parent->color = BLACK;
	      x->parent->parent->color = RED;
	      LA_rotateLeft(thisroot, x->parent->parent);
            }
        }
    }
  (*thisroot)->color = BLACK;
}


statusEnum LA_insert(LA_nodeType_LIST **thisroot, char *key,int FID) 
{
  LA_nodeType_LIST *current, *parent, *x;
  
  
  
  
  current = *thisroot;
  parent = 0;
  while (current != LA_NILL) 
    {
      if (compEQ(key, current->key)) 
	  {
	   
       current->numFIDs = current->numFIDs + 1;
       current->FIDs = (int *)realloc(current->FIDs, current->numFIDs * SzI);
	   current->FIDs[current->numFIDs-1] = FID;

	   return STATUS_DUPLICATE_KEY;
	  }
      parent = current;
      current = compLT(key, current->key) ?
	  current->left : current->right;
    }
  
  
  if ((x = (LA_nodeType_LIST *)malloc (sizeof(*x))) == 0)
    return STATUS_MEM_EXHAUSTED;
  x->parent = parent;
  x->left = LA_NILL;
  x->right = LA_NILL;
  x->color = RED;
  
  
  x->key  = (char *) (malloc( strlen(key) + 2 )); 
  if(x->key==NULL){printf("r-insert: out of memory!\n"); ExitWrapper(-1);}
  sprintf(x->key,"%s",key);
  
  x->FIDs = (int *)malloc(SzI);
  x->FIDs[0] = FID;
  x->numFIDs = 1;

  
  
  
  if(parent) 
    {
      if(compLT(key, parent->key))
	parent->left = x;
      else
	parent->right = x;
    } 
  else 
    {
      *thisroot = x;
    }
  LA_insertFixup(thisroot, x);
  return STATUS_OK;
}


statusEnum LA_find(LA_nodeType_LIST **thisroot, char *key, int *return_num, int **return_vals) 
{
  
  LA_nodeType_LIST *current = *thisroot;
  
  
  while(current != LA_NILL) 
    {
      if(compEQ(key, current->key)) 
	{
	  *return_num  = current->numFIDs;
	  *return_vals = current->FIDs;
	  return STATUS_KEY_FOUND;
	}
      else
	{	  
	  current = compLT (key, current->key) ?
	    current->left : current->right;
	}
    }
  return STATUS_KEY_NOT_FOUND;
}




void InsertLAKey(char *key, int FID)
{
  statusEnum status;

  status = LA_insert(&LA_root,key,FID);
 
  if (status  == STATUS_DUPLICATE_KEY) 
  {
	 
  }
  else if(status  == STATUS_MEM_EXHAUSTED) 
  {
	  printf("out of memory trying to build LA_tree!\n");
	  ExitWrapper(-1);
  }
}

void BuildLongAttrTree(int attrtype)
{
  char tempnum[500];
  int i;

  extern short int *cache_types;
  extern double    *cache_nums;
  extern char     **cache_chars;

  

  

  if(LA_root!=LA_NILL)
  {
	  printf("error: found non-null LA_root\n");
	  LA_FreeTree();
  }


  for(i=0;i<LLFidTableCount;i++)
  {
	  if(cache_types[i]>0)
	  {
		sprintf(tempnum,"\"%s\"",cache_chars[i]);
        InsertLAKey(tempnum,i);

		free(cache_chars[i]);
		cache_chars[i] = NULL;

		
	  }
	  else if(cache_types[i]==-1)
	  {
		sprintf(tempnum,"%d",(int)cache_nums[i]);
        InsertLAKey(tempnum,i);
	  }
	  else if(cache_types[i]==-2)
	  {
		sprintf(tempnum,"%lf",cache_nums[i]);
        InsertLAKey(tempnum,i);
	  }
  }

 

}





void SetFidMarkTable(int attrtype, char *onval, int ecc, char *geom,
					 int errnum, int axis, int ADDER, int clonenum, int cloneindex)
{
  statusEnum status;
  int *foundvals;
  int i,len,targetvaluetype,geomtype,lindex,foundgeom,foundecc,foundnum,viewonly;
  static int alreadycached = -1;
  extern int free_global_char_type;
  extern short int *cache_types;


  if((errnum+axis+ADDER)==0)
  {
	viewonly = 1;
  }
  else
  {
	viewonly = 0;
  }


  if((alreadycached==-1)&&(attrtype!=-999))
  {
	
  }

  if(attrtype==-999)
  {
	  

	if(alreadycached!=-1)
	{
	  LA_FreeTree();
      End_LongFiles(alreadycached);
	  alreadycached = -1;
    }
	return;
  }

  
  


  free_global_char_type = 0;


  if(ecc>=0)
    {
      
      geomtype = GetGeom(geom);
    }

  if(onval!=NULL)
    {
      


      targetvaluetype = NOTYPE;
      if(onval[0]=='"')
	  {
	   targetvaluetype = C_TYPE;
	  }
      else
	  {
	   len = strlen(onval);
	   for(i=0;i<len;i++)
	    {
	      if(onval[i]=='.')
		  {
		   targetvaluetype = D_TYPE;
		   break;
		  }
	    }
	   if(targetvaluetype==NOTYPE)
	    {
	      targetvaluetype = I_TYPE;
	    }
	  }
    }


  
  
 
  if(alreadycached==-1)
  {
	

    Begin_LongFiles(attrtype);
	alreadycached = attrtype;

	BuildLongAttrTree(alreadycached);
  }
  else if(alreadycached!=attrtype)
  {
	
	LA_FreeTree();
	End_LongFiles(alreadycached);
    Begin_LongFiles(attrtype);
	alreadycached = attrtype;

	BuildLongAttrTree(alreadycached);
  }

  

  if(onval!=NULL)
  {
    
   
	status = LA_find(&LA_root,onval,&foundnum,&foundvals);

    if (status  != STATUS_KEY_FOUND) 
	{
	  printf("Error: was unable to locate an attribute value for display.\n");
	  printf("This may be due to it having carriage return and/or newline in it, which may make it display poorly here.\n");
	  printf(" Attribute: %s\n",onval);
	} 
    else
	{ 
	  for(i=0;i<foundnum;i++)
	  {
	 
		if(ecc>=0)
		{
		  lindex    = LLFidTable[foundvals[i]];
	      foundecc  = SCCtable[CrsWlk[lindex].LtoSmapping].ECC;
	      foundgeom = CrsWlk[lindex].geomtype;
		  if((foundecc==ecc)&&(foundgeom==geomtype))
		  {
		    if(viewonly==1)
			{
		      FidMarkTable[foundvals[i]] = 1;
			}
			else
			{
	          SetIndex2(errnum,axis,ADDER,foundvals[i],clonenum,cloneindex,geomtype);
			}
		  }
		}
		else
		{
		  if(viewonly==1)
		  {
		    FidMarkTable[foundvals[i]] = 1;
		  }
		  else
		  {
	        SetIndex2(errnum,axis,ADDER,foundvals[i],clonenum,cloneindex,geomtype);
		  }
		}
	  }
	}

    free_global_char_type = 1;
	return;
  }



  for(i=0;i<LLFidTableCount;i++)
    {

	  

	  if(cache_types[i]==0)
	  {
		  continue;
	  }

      if(ecc>=0)
	  {
	   

	   

	   lindex    = LLFidTable[i];
	   foundecc  = SCCtable[CrsWlk[lindex].LtoSmapping].ECC;
	   foundgeom = CrsWlk[lindex].geomtype;

	   if((foundecc==ecc)&&(foundgeom==geomtype))
	    {
		  if(viewonly==1)
		  {
	        FidMarkTable[i] = 1;
		  }
		  else
		  {
	        SetIndex2(errnum,axis,ADDER,i,clonenum,cloneindex,geomtype);
		  }
	    }
	  }
    }
  
  free_global_char_type = 1;


}


void SetAllFidMarks(int attrtype)
{
  FILE *infofile;
  short int thisid;
  int num=0;
  long int seekposn;

  

  infofile = GetLongAttrFilePtr(1,attrtype);

  if(infofile==NULL)
  {
	printf("error: could not open infofile for %s\n",GetLongCode(attrtype));
	return;
  }

  SEEIT_fread_short (&thisid,infofile);
  while(!feof(infofile))
  {
	if(thisid!=0)
	{
      FidMarkTable[num] = 1;
	}

   num = num + 1;
   SEEIT_fread_long  (&seekposn,infofile);
   SEEIT_fread_short (&thisid,infofile);
  }
  fclose(infofile);

   
}





void PrintFIDMarkTable()
{
  int errnum,fid;

  return;

  for(errnum=0;errnum<=CONDITION_DEFINITIONS;errnum++)
  {
	      
	 if(ErrorLookup[errnum].primaryFIDstuff!=NULL)
	 {
	   for(fid=0;fid<=LLFidTableCount;fid++)
	   {
		  if(ErrorLookup[errnum].primaryFIDstuff[fid]==1)
		  {
		    printf("Check %s fidnum %d: %d\n",ErrorLookup[errnum].name,fid,ErrorLookup[errnum].primaryFIDstuff[fid]);
		  }
	   }    
	 }
  } 
}



void CreateLongListEntries(int errnum,int axis, int ADDER, int batch, int clonenum, int cloneindex, int geomtype)
{
  int i,ii,j,k,index,SCC,SAC,EEC,num,thisindex,thatindex,Lindex,type,
    viewonly,done;
  struct IMarkList *temp;
  struct IMarkSACList *cfl;

  extern int SACfull;

  





  if(errnum+axis+ADDER==0)
    {
      viewonly = 1;
    }
  else
    {
      viewonly = 0;
    }


  
  
  if(viewonly==1)
    {
      FreeMarkerList();
    }
  else
    {
      if ((clonenum==0) && (axis==1) && (ErrorLookup[errnum].primaryEDCSstuff==NULL))
	{
	  ErrorLookup[errnum].primaryEDCSstuff = 
	    (unsigned char *) malloc (SzUC * SACfull);

	  if(ErrorLookup[errnum].primaryEDCSstuff==NULL)
	    {
	      printf("malloc prim13:  couldnt malloc %d\n",SzUC * SACfull);
	      ExitWrapper(-1);
	    }

	  for(i=0;i<SACfull;i++)
	    {
	      ErrorLookup[errnum].primaryEDCSstuff[i] = 0;
	    }
	}
      else if ((clonenum>0) && (axis==1) && (CloneErrorLookup[cloneindex].primaryEDCSstuff==NULL))
	{
	  CloneErrorLookup[cloneindex].primaryEDCSstuff = 
	    (unsigned char *) malloc (SzUC * SACfull);

	  if(CloneErrorLookup[cloneindex].primaryEDCSstuff==NULL)
	    {
	      printf("malloc prim14:  couldnt malloc %d\n",SzUC * SACfull);
	      ExitWrapper(-1);
	    }

	  for(i=0;i<SACfull;i++)
	    {
	      CloneErrorLookup[cloneindex].primaryEDCSstuff[i] = 0;
	    }
	}

      else if((clonenum==0) && (axis==2) && (ErrorLookup[errnum].secondaryEDCSstuff==NULL))
	{
	  ErrorLookup[errnum].secondaryEDCSstuff = 
	    (unsigned char *) malloc (SzUC * SACfull);

	  if(ErrorLookup[errnum].secondaryEDCSstuff==NULL)
	    {
	      printf("malloc prim15:  couldnt malloc %d\n",SzUC * SACfull);
	      ExitWrapper(-1);
	    }

	  for(i=0;i<SACfull;i++)
	    {
	      ErrorLookup[errnum].secondaryEDCSstuff[i] = 0;
	    }
	}
      else if((clonenum>0) && (axis==2) && (CloneErrorLookup[cloneindex].secondaryEDCSstuff==NULL))
	{
	  CloneErrorLookup[cloneindex].secondaryEDCSstuff = 
	    (unsigned char *) malloc (SzUC * SACfull);

	  if(CloneErrorLookup[cloneindex].secondaryEDCSstuff==NULL)
	    {
	      printf("malloc prim16:  couldnt malloc %d\n",SzUC * SACfull);
	      ExitWrapper(-1);
	    }

	  for(i=0;i<SACfull;i++)
	    {
	      CloneErrorLookup[cloneindex].secondaryEDCSstuff[i] = 0;
	    }
	}



      else if((clonenum==0) && (axis==3) && (ErrorLookup[errnum].tertiaryEDCSstuff==NULL))
	{
	  ErrorLookup[errnum].tertiaryEDCSstuff = 
	    (unsigned char *) malloc (SzUC * SACfull);
	  
	  if(ErrorLookup[errnum].tertiaryEDCSstuff==NULL)
	    {
	      printf("malloc prim17:  couldnt malloc %d\n",SzUC * SACfull);
	      ExitWrapper(-1);
	    }

	  for(i=0;i<SACfull;i++)
	    {
	      ErrorLookup[errnum].tertiaryEDCSstuff[i] = 0;
	    }
	}
      else if((clonenum>0) && (axis==3) && (CloneErrorLookup[cloneindex].tertiaryEDCSstuff==NULL))
	{
	  CloneErrorLookup[cloneindex].tertiaryEDCSstuff = 
	    (unsigned char *) malloc (SzUC * SACfull);
	  
	  if(CloneErrorLookup[cloneindex].tertiaryEDCSstuff==NULL)
	    {
	      printf("malloc prim18:  couldnt malloc %d\n",SzUC * SACfull);
	      ExitWrapper(-1);
	    }

	  for(i=0;i<SACfull;i++)
	    {
	      CloneErrorLookup[cloneindex].tertiaryEDCSstuff[i] = 0;
	    }
	}




      



      
    }





  
  
  if(clonenum==0)
    {
      temp = ErrorLookup[errnum].IMarkRoot[axis][ADDER][geomtype];
    }
  else
    {
      temp = CloneErrorLookup[cloneindex].IMarkRoot[axis][ADDER][geomtype];
    }


  while(temp!=NULL)
    {
      index = temp->origSCCindex;
      
      
      
      for(i=0;i<MdlNames[index].references;i++)
	{
	  Lindex = MdlNames[index].indices[i];
	  
	  if(viewonly==1)
	    {
	      CrsWlk[Lindex].toggle = 1;
	    }
	  else
	    {
	      SetIndex(errnum,axis,ADDER,Lindex,clonenum,cloneindex,geomtype);
	    }
	}
      temp=temp->next;
    }








  
  
  if(clonenum==0)
    {
      cfl = ErrorLookup[errnum].IMarkSACRoot[axis][ADDER][geomtype];
    }
  else
    {
      cfl = CloneErrorLookup[cloneindex].IMarkSACRoot[axis][ADDER][geomtype];
    }

  while(cfl!=NULL)
    {


      SCC = cfl->SCCindex;
      SAC = cfl->SACindex;
      EEC = cfl->EEindex;
      
      if(SCC==-1)  
	{
	  if(EEC==-1)
	    {
	      
	      

	      if(viewonly==1)
		{
		  

		  type = GetLongAttrType(MdlNames2[SAC].code,1);
		  if(type>=0)
		    {
		      printf("turn on all values for viewonly for %s\n",GetEACLabel(MdlNames2[SAC].code));
		      
			  
              SetAllFidMarks(type);
		    }
		}
	      else
		{
		  
		}
	    

	      for(i=0;i<MdlNames2[SAC].count;i++)
		{
		  for(j=0;j<MdlNames2[SAC].values[i].LLindexcount;j++)
		    {
		      Lindex = MdlNames2[SAC].values[i].LongListIndices[j];

		      if(viewonly==1)
			{
			  CrsWlk[Lindex].toggle = 1;
			}
		      else
			{
			  SetIndex(errnum,axis,ADDER,Lindex,clonenum,cloneindex,geomtype);
			}
		    }

		}
	    } 
	  else 
	    {
	      

	      done = 0;

	      
	      type = GetLongAttrType(MdlNames2[SAC].code,1);
	      if(type>=0)
		{
		  if(EEC!=-2)
		    {
		      printf("error: got long attribute with EEC %d (not -2)\n",EEC);
		    }

		  
		  SetFidMarkTable(type,cfl->saveval,-1,NULL,errnum,axis,ADDER,clonenum,cloneindex);
		   
		  done = 1;
		}



	      if(done==0)
		{		  
		  if(MdlNames2[SAC].values[EEC].uniqueoccurrences > 0)
		    {		  
		      for(j=0;j<MdlNames2[SAC].values[EEC].LLindexcount;j++)
			{
			  Lindex = MdlNames2[SAC].values[EEC].LongListIndices[j];
			  
			  if(viewonly==1)
			    {
			      CrsWlk[Lindex].toggle = 1;
			    }
			  else
			    {
			      SetIndex(errnum,axis,ADDER,Lindex,clonenum,cloneindex,geomtype);
			    }
			}
		      
		      
		      for(j=0;j<MdlNames2[SAC].values[EEC].UniqueLLindexcount;j++)
			{
			  Lindex = MdlNames2[SAC].values[EEC].UniqueLLindices[j];
			  
			  if(viewonly==1)
			    {
			      CrsWlk[Lindex].toggle = 1;
			    }
			  else
			    {
			      SetIndex(errnum,axis,ADDER,Lindex,clonenum,cloneindex,geomtype);
			    }
			}
		      
		    }
		}
	    }
	}
      else
	{
	  

	  type = GetLongAttrType(GetCode(SCC,SAC),1);
	  
	  if(EEC==-1)
	    {
	      


	      if(type>=0)
		{

		      SetFidMarkTable(type,NULL,
				      MdlNames[SCC].code,
				      MdlNames[SCC].name,
					  errnum,axis,ADDER,clonenum,cloneindex);

		}
	      else
		{
		  
		  index = MdlNames[SCC].UniqueAttr[SAC];
		  
		  for(i=0;i<MdlNames[SCC].numattributes;i++)
		    {
		      thisindex = MdlNames[SCC].AttrIndices[i];
		      thatindex = MdlNames[SCC].ValueIndices[i];
		      
		      if(thisindex==index)
			{
			  for(k=0;k<MdlNames2[index].values[thatindex].LLindexcount;k++)
			    {
			      Lindex = MdlNames2[index].values[thatindex].LongListIndices[k];
			      
			      for(ii=0;ii<MdlNames[SCC].references;ii++)
				{
				  if( MdlNames[SCC].indices[ii] == Lindex)
				    {
				      break;
				    }
				}
			      if(ii<MdlNames[SCC].references)
				{			      
				  if(viewonly==1)
				    {
				      CrsWlk[Lindex].toggle = 1;
				    }
				  else
				    {
				      SetIndex(errnum,axis,ADDER,Lindex,clonenum,cloneindex,geomtype);
				    }
				}
			    }
			}
		    }
		}
	    }
	  else
	    {
	      
	      if(type>=0)
		{
		  
		  
		  if(EEC!=-2)
		    {
		      printf("error:  got EEC %d (expected -2) for %s %s\n",
			     EEC,
			     GetECCLabel(MdlNames[SCC].code),
			     GetEACLabel(GetCode(SCC,SAC)));
		    }
		  
		      SetFidMarkTable(type,cfl->saveval,
				      MdlNames[SCC].code,
				      MdlNames[SCC].name,
					  errnum,axis,ADDER,clonenum,cloneindex);


		}
	      else
		{
		  
		  
		  
		  index = MdlNames[SCC].UniqueAttr[SAC];
		  num = -1;
		  
		  for(i=0;i<MdlNames[SCC].numattributes;i++)
		    {
		      thisindex = MdlNames[SCC].AttrIndices[i];
		      
		      if(thisindex==index)
			{
			  thatindex = MdlNames[SCC].ValueIndices[i];
			  
			  num++;
			  
			  if(num==EEC)
			    {
			      
			      
			      for(k=0;k<MdlNames2[index].values[thatindex].LLindexcount;k++)
				{
				  Lindex = MdlNames2[index].values[thatindex].LongListIndices[k];
				  
				  for(ii=0;ii<MdlNames[SCC].references;ii++)
				    {
				      if( MdlNames[SCC].indices[ii] == Lindex)
					{
					  break;
					}
				    }
				  if(ii<MdlNames[SCC].references)
				    {				  
				      if(viewonly==1)
					{
					  CrsWlk[MdlNames2[index].values[thatindex].LongListIndices[k]].toggle = 1;
					}
				      else
					{
					  SetIndex(errnum,axis,ADDER,Lindex,clonenum,cloneindex,geomtype);
					}
				    }
				}
			    }
			}
		    }
		}
	    }
	}
      cfl=cfl->next;
    }



  PrintFIDMarkTable();




  if(batch==0)
    {

      if(viewonly==1)
	{
	  AddToMarkerList(); 
	}
      
    }
}



int BadESName()
{
  static char newname[1000];
  int len;

  sprintf(newname,"%s",esname);

  len = strlen(newname);
  if(
     (newname[len-3]!= '.') ||
     (newname[len-2]!= 'e') ||
     (newname[len-1]!= 's')
     )
    {
      return 1;
    }
  return 0;
}



void SetESName()
{
  
  
  
}

void SetSMName()
{
  static char newname[1000];
  int len;

  sprintf(newname,"%s",esname);
  len = strlen(newname);
  newname[len-3]= '.';
  newname[len-2]= 's';
  newname[len-1]= 'm';
  newname[len]  = '\0';

  sprintf(smname,"%s",newname);
}



void SetVRName()
{
  static char newname[1000];
  int len;

  sprintf(newname,"%s",esname);
  len = strlen(newname);
  newname[len-3]= '.';
  newname[len-2]= 'v';
  newname[len-1]= 'r';
  newname[len]  = '\0';

  sprintf(vrname,"%s",newname);
}


void SetBOName()
{
  static char newname[1000];
  int len;

  sprintf(newname,"%s",esname);
  len = strlen(newname);
  newname[len-3]= '.';
  newname[len-2]= 'b';
  newname[len-1]= 'o';
  newname[len]  = '\0';

  sprintf(boname,"%s",newname);
}

void SetNTName()
{
  static char newname[1000];
  int len;

  sprintf(newname,"%s",esname);
  len = strlen(newname);
  newname[len-3]= '.';
  newname[len-2]= 'n';
  newname[len-1]= 't';
  newname[len]  = '\0';

  sprintf(ntname,"%s",newname);
}


void SetLKName()
{
  static char newname[1000];
  int len;

  sprintf(newname,"%s",esname);
  len = strlen(newname);
  newname[len-3]= '.';
  newname[len-2]= 'l';
  newname[len-1]= 'k';
  newname[len]  = '\0';

  sprintf(lkname,"%s",newname);
}



void SetNSName()
{
  static char newname[1000];
  int len;

  sprintf(newname,"%s",esname);
  len = strlen(newname);
  newname[len-3]= '.';
  newname[len-2]= 'n';
  newname[len-1]= 's';
  newname[len]  = '\0';


  sprintf(nsname,"%s",newname);
}







void ReallocPolyPoints(int numtoalloc)
{
  if(polyptsallocced>0)
    {
      PolyPoints = (XPoint *) realloc(PolyPoints,sizeof(XPoint) * (numtoalloc));
    }
  else
    {
      PolyPoints = (XPoint *) malloc(sizeof(XPoint) * (numtoalloc));
    }
  
  if(PolyPoints==NULL)
    {
      printf("PolyPoints: out of memory!\n");
      ExitWrapper(-1);
    }

  polyptsallocced = numtoalloc;
}



void AllocArealPixmaps()
{
  areal_pixmap1      = XCreatePixmap (XtDisplay (drawing_a),
				      RootWindowOfScreen (XtScreen (drawing_a)), pix_wid1, pix_wid1,
				      DefaultDepthOfScreen (XtScreen (drawing_a)));

  areal_pixmap2      = XCreatePixmap (XtDisplay (drawing_a),
				      RootWindowOfScreen (XtScreen (drawing_a)), pix_wid2, pix_wid2,
				      DefaultDepthOfScreen (XtScreen (drawing_a)));

  areal_pixmap3      = XCreatePixmap (XtDisplay (drawing_a),
				      RootWindowOfScreen (XtScreen (drawing_a)), pix_wid3, pix_wid3,
				      DefaultDepthOfScreen (XtScreen (drawing_a)));

  areal_pixmap4      = XCreatePixmap (XtDisplay (drawing_a),
				      RootWindowOfScreen (XtScreen (drawing_a)), pix_wid4, pix_wid4,
				      DefaultDepthOfScreen (XtScreen (drawing_a)));

  areal_pixmap5      = XCreatePixmap (XtDisplay (drawing_a),
				      RootWindowOfScreen (XtScreen (drawing_a)), pix_wid5, pix_wid5,
				      DefaultDepthOfScreen (XtScreen (drawing_a)));
}


void FreeArealPixmaps()
{
  XFreePixmap(mydisplay,areal_pixmap1);
  XFreePixmap(mydisplay,areal_pixmap2);
  XFreePixmap(mydisplay,areal_pixmap3);
  XFreePixmap(mydisplay,areal_pixmap4);
  XFreePixmap(mydisplay,areal_pixmap5);
}



void ScalePolygon(int lwidth, int lheight, short int *Xpt, short int *Ypt, int numpoints)
{  
  

  int i,j;
  Pixmap areal_pixmap;
  XImage *myimage;
  int addindex;
  

  int pix_wid;

  if((lwidth<pix_wid1)&&(lheight<pix_wid1))
    {
      pix_wid = pix_wid1;
      areal_pixmap = areal_pixmap1;
    }
  else if((lwidth<pix_wid2)&&(lheight<pix_wid2))
    {
      pix_wid = pix_wid2;
      areal_pixmap = areal_pixmap2;
    }
  else if((lwidth<pix_wid3)&&(lheight<pix_wid3))
    {
      pix_wid = pix_wid3;
      areal_pixmap = areal_pixmap3;
    }
  else if((lwidth<pix_wid4)&&(lheight<pix_wid4))
    {
      pix_wid = pix_wid4;
      areal_pixmap = areal_pixmap4;
    }
  else if((lwidth<pix_wid5)&&(lheight<pix_wid5))
    {
      pix_wid = pix_wid5;
      areal_pixmap = areal_pixmap5;
    }
  else
    {
      printf("Error! ScalePolygon called with %d %d\n",lwidth,lheight);
      return;
    }



  


  if((lwidth<1)||(lheight<1))
    {
      printf("Error! ScalePolygon called with %d %d\n",lwidth,lheight);
      return;
    }


  XSetFillRule(mydisplay,mygc,WindingRule);


 
  
  XSetForeground(mydisplay,mygc,mycolors[DRAW_COLOR_WHITE]);
  
  
  XFillRectangle (mydisplay, areal_pixmap,  mygc, 0, 0,pix_wid, pix_wid);
  
  
  
  XSetForeground(mydisplay,mygc,mycolors[DRAW_COLOR_BLACK]);  
  
  

  if(polyptsallocced<numpoints)
    {
      ReallocPolyPoints(numpoints+10);
    }
    
  

  PolyPoints[0].x = Xpt[0];
  PolyPoints[0].y = Ypt[0];
  addindex = 1;
  
  for(i=1;i<numpoints;i++)
    {
      if(
	 (PolyPoints[addindex-1].x != Xpt[i]) || 
	 (PolyPoints[addindex-1].y != Ypt[i])
	 )
	{
	  PolyPoints[addindex].x = Xpt[i];
	  PolyPoints[addindex].y = Ypt[i];
	  addindex = addindex  + 1;
	}
    }



  


  
  PolyPoints[addindex].x = PolyPoints[0].x;
  PolyPoints[addindex].y = PolyPoints[0].y;
  XDrawLines(mydisplay,areal_pixmap,mygc,PolyPoints,addindex+1,CoordModeOrigin);   


  XFillPolygon(mydisplay,areal_pixmap,mygc,PolyPoints,addindex,Nonconvex,CoordModeOrigin);

  




  
  
  myimage = XGetImage(mydisplay,areal_pixmap,0,0,lwidth,lheight,XAllPlanes(),ZPixmap);
  

  for(i=0;i<lheight;i++)
    {      
      for(j=0;j<lwidth;j++)
	{
	  if((XGetPixel(myimage,j,i))==mycolors[DRAW_COLOR_BLACK]) 
	    {
	      PolyPixels[j][i] = 1;
	    }
	  else
	    {
	      PolyPixels[j][i] = 0;
	    }
	}
    }


  XDestroyImage(myimage);




  

}









void die_callback(Widget w,XtPointer client_data,XtPointer call_data)
{
  

  char *junk,*junk2,*junk3,*junk4,*priorvalue,junk5[100];
  int bad=0,ToItest,ToJtest,FromItest,FromJtest,i,xmodifier=0,ymodifier=0,oldaz,oldangle;
  double oldex;

  if(DEBUG==1){printf("die_callback received %d\n",(int)client_data);}
 
  if(
     ( (int) client_data == 12 ) ||
     ( (int) client_data == 17 )
     )
    {
      junk  = XmTextFieldGetString (text_w2);
      junk2 = XmTextFieldGetString (text_w3);
      junk3 = XmTextFieldGetString (text_w4);
      junk4 = XmTextFieldGetString (text_w5);
    }
  if( (int)client_data ==113)
    {
      SetESName();
      SetNSName();
      SetLKName();
      SetBOName();
      SetNTName();
      SetSMName();
      SetVRName();
  
      dead_head5=1;
    }
  if( (int)client_data ==114){IMPORT_WIN=0;}
  if( (int)client_data ==115)
    {
      dead_head6=1;
    }

  if(
     ( (int)client_data ==12 ) ||
     ( (int)client_data ==17 )
     )
    {
             
      
      for(i=0;i<(int)(strlen(junk));i++){if((junk[i]<'0')||(junk[i]>'9')){bad=1;}}
      for(i=0;i<(int)(strlen(junk2));i++){if((junk2[i]<'0')||(junk2[i]>'9')){bad=1;}}
      for(i=0;i<(int)(strlen(junk3));i++){if((junk3[i]<'0')||(junk3[i]>'9')){bad=1;}}
      for(i=0;i<(int)(strlen(junk4));i++){if((junk4[i]<'0')||(junk4[i]>'9')){bad=1;}}
      
      
      if(bad==0)
	{
	  sscanf(junk,"%d",&ToItest);
	  sscanf(junk2,"%d",&ToJtest);
	  sscanf(junk3,"%d",&FromItest);
	  sscanf(junk4,"%d",&FromJtest);
	  
	  urx_zoom = llx_zoom+(1000.0/xunits)*IRegionSize;
	  ury_zoom = lly_zoom+(850.0/yunits)*IRegionSize;
	  
	  if( (int)(urx_zoom/IRegionSize) != (int)(llx_zoom/IRegionSize) )
	    {
	      
	      xmodifier=1;
	    }
	  if( (int)(ury_zoom/IRegionSize) != (int)(lly_zoom/IRegionSize) )
	    {
	      
	      ymodifier=1;
	    }

	  if(
	     (ToItest<=MaxXindex)&&
	     (ToItest>=FromItest)&&
	     (ToJtest<=MaxYindex)&&
	     (ToJtest>=FromJtest)&&
	     (FromItest<=MaxXindex)&&
	     (FromItest<=ToItest)&&
	     (FromJtest<=MaxYindex)&&
	     (FromJtest<=ToJtest)
	     )
	    {
	      ToI=ToItest;
	      ToJ=ToJtest ;
	      FromI=FromItest;
	      FromJ=FromJtest ;
	    }
	  else
	    {
	      bad=1;
	      if(DEBUG==1)
		{
		  printf("Got BAD values %d %d %d %d with %d %d\n",
			 FromItest,FromJtest,ToItest,ToJtest,xnum,ynum);
		  printf("%d %d %d %d\n",MaxXindex,MaxYindex,xmodifier,ymodifier);
		}
	    }
	}

      if(bad==0)   
	{
	  load_head = 1;
	}
      else
	{
	  not_while_running(w,"These values were not acceptable.  Check to make sure:\n\
1) They are within the bounds of the data.\n\
2) The lower left point is to the lower left of the upper right point.\n\
3) These regions are shown on the screen currently.\n\n\
Resetting values to the last acceptable values.",1033,"Bad Values",1);
	  
	  sprintf(junk5,"%d",ToI);
	  XmTextFieldSetString(text_w2,junk5);
	  sprintf(junk5,"%d",ToJ);
	  XmTextFieldSetString(text_w3,junk5);
	  sprintf(junk5,"%d",FromI);
	  XmTextFieldSetString(text_w4,junk5);
	  sprintf(junk5,"%d",FromJ);
	  XmTextFieldSetString(text_w5,junk5);
	  XtFree(junk);
	  XtFree(junk2);
	  XtFree(junk3);
	  XtFree(junk4);
	  return;
	}
      XtFree(junk);
      XtFree(junk2);
      XtFree(junk3);
      XtFree(junk4);
    }
  if( (int)client_data==13 )
    {
      dead_head4=1;
      dead_head3=1;
      dead_other_head3=1;
      
    }
  if((int)client_data==14)
    {
      dead_side=1;
    }
  if((int)client_data==16)
    {
       oldaz    = ZoomSunAzimuth;
       oldangle = ZoomSunAngle;
       oldex    = ZoomVertExag;

       if(
		 (fore_result(sun_az_w_z,   (XtPointer)20,(XtPointer)NULL)==1) &&
         (fore_result(sun_angle_w_z,(XtPointer)21,(XtPointer)NULL)==1) &&
         (fore_result(vert_ex_w_z,  (XtPointer)22,(XtPointer)NULL)==1)
		 )
	  {
	    XtPopdown(XtParent(XtParent(XtParent(w))));

        if(
           (oldaz    != ZoomSunAzimuth)  ||
           (oldangle != ZoomSunAngle  )  ||
           (oldex    != ZoomVertExag  )  ||
	       (NEED_SHADE_REDRAW==1      )
          )
		{
          set_cursor(
		     XtDisplay(XtParent(XtParent(XtParent(sun_az_w_z)))),
		     XtWindow (XtParent(XtParent(XtParent(sun_az_w_z)))),WATCH);

          
          RebuildTopImage(6);
          refreshCallback((Widget)NULL,(XtPointer)NULL,(XtPointer)NULL);

	      NEED_SHADE_REDRAW = 0;

          set_cursor(
		     XtDisplay(XtParent(XtParent(XtParent(sun_az_w_z)))),
		     XtWindow (XtParent(XtParent(XtParent(sun_az_w_z)))),ARROW);
		}

        dead_shade = 1;
	  }
	  else
	  {
        
        return;
	  }
    }
  if((int)client_data==1000)
    {
      P_window=0; 
    }
  if((int)client_data==1001)
    {
      DEMO_UP=0; 
    }

  

  if((int)client_data==1003)
    {
      
      
      load_reg=0;
      AOI_MODE=0;
      BUSY=1;
      set_cursor(mydisplay,mywindow,WATCH);

      if(NOT_ZOOMED==1)
	{
	  
	  
	  XCopyArea (mydisplay, pixmap2, pixmap, mygc,
		     0, 0, width, height, 0, 0);
          
	  XCopyArea (mydisplay, pixmap, mywindow, mygc,
		     0, 0, width, height, 0, 0);
          ShowRegionMarkers();

	  FlushMainScreen(1); 

	  if(ABORT_ZOOM>0)  
	    {
	      MyDrawErrors();
	    }
	}    
      BUSY=0;
      set_cursor(mydisplay,mywindow,GOOD);
    }

  if((int)client_data==1004)
    {
      
      dead_error=1;
    }  
  if((int)client_data==1005)
    {
    }
  if((int)client_data==1006)
    {
      CSD_UP = 0;
      
      ReallySaveDefaultsCallback2((Widget)NULL,(XtPointer)1,(XtPointer)1);
    }
 if((int)client_data==1007)
    {
      MOD_UP = 0;
      BuildDynamicArrayOfScc(indirectory);
    }
 if((int)client_data==1008)
    {
      dead_sdcs = 1;
    }
 if((int)client_data==1010)
    {
      PATCH_WIN = 0;
    }
 if((int)client_data==1011)
    {
      ATT_DEMO_UP = 0;
    }
 if((int)client_data==1012)
    {
      INFO_WINDOW = 0;
    }
 if((int)client_data==1013)
    {
      HELP_UP[0] = 0;
    }
 if((int)client_data==1014)
   {
     EnterFileCallback(folder_wid, (XtPointer)12, (XtPointer)12);
     dead_folderhead=1;
   }
 if((int)client_data==1015)
   {
     dead_checkfilter=1;
   }  
 if( (int)client_data ==1016)
    {
      EnterFileCallback(sum1_wid, (XtPointer)13,(XtPointer)NULL);
      EnterFileCallback(sum2_wid, (XtPointer)14,(XtPointer)NULL);
      EnterFileCallback(sum3_wid, (XtPointer)15,(XtPointer)NULL);
      dead_compare = 1;
    }
 if( (int)client_data ==1017)
   {
     dead_network = 1;
   }
 if( (int)client_data ==1018)
   {
     input_up = 0;
   }
 if( (int)client_data ==1019)
   {
     LOAD_SETTINGS_UP = 0;
   }
 if( (int)client_data ==1020)
   {
     dead_head5 = 1;
   }
 if( (int)client_data ==1021)
   {
     prev_up = 0;
   }
 if( (int)client_data ==1022)
   {
     AOI_SAVE_UP = 0;
   }
 if( (int)client_data ==1023)
   {
     AOI_LOAD_UP = 0;
   }
 if( (int)client_data ==1024)
   {
     XtDestroyWidget(run_format_dialog);
     return;
   }
 if( (int)client_data ==1025)
   {
     XtDestroyWidget (XtParent(XtParent(XtParent(w))));
     return;
   }
 if( (int)client_data ==1026)
   {
     pref_up = 0;
   }
 if( (int)client_data ==1027)
   {
     pref2_up = 0;
   }

 if( (int)client_data ==1028)
    {
      EnterFileCallback(savelayer_wid, (XtPointer)24,(XtPointer)NULL);
 
      LAYERPREFS_UP = 0;
    }
 if( (int)client_data ==1029)
   {
     AOI_SHAPE_UP = 0;
   }
 if((int)client_data==1030)
   {
     EnterFileCallback(data_wid, (XtPointer)26, (XtPointer)26);
     dead_datahead=1;
   }
 if( (int)client_data ==1031)
    {
      EnterFileCallback(xml1_wid, (XtPointer)27,(XtPointer)NULL);
      EnterFileCallback(xml2_wid, (XtPointer)28,(XtPointer)NULL);
      EnterFileCallback(xml3_wid, (XtPointer)29,(XtPointer)NULL);
      dead_xml = 1;
    }
 if( (int)client_data ==1032)
    {
      EnterFileCallback(dp1_wid, (XtPointer)30,(XtPointer)NULL);
      dead_dp = 1;
    }
 if((int)client_data==1033)
   {
     priorvalue = XmTextFieldGetString (browsefolder_wid);

     EnterFileCallback(browsefolder_wid, (XtPointer)31, (XtPointer)31);


	 if(!strcmp(SpecialLoc,"<not specified>"))
	 {
	   

	   if(strcmp(priorvalue,SpecialLoc))
	   {
         return;
	   }
	 }

     dead_browsefolderhead=1;
   }
 if( (int)client_data ==1034)
   {
     dead_head7 = 1;
   }
 if( (int)client_data ==1035)
   {
     LOAD_NETSETTINGS_UP = 0;
   }



 if(  ((int)client_data>=8300)  && ((int)client_data<=(8300+CONDITION_DEFINITIONS)))
   {
     
     deadfix[(int)client_data-8300]=1;
   }


 if((int)client_data==17)
   {
     

     XtPopdown(Select_head);
   }
 
 
 XtDestroyWidget (XtParent(XtParent(XtParent(w))));
  
 
 if((int)client_data==17)
   {
     
     ExecuteCallback(drawing_a, (XtPointer)0, (XtPointer)0);
   }
}


int SetNUNANPO()
{
  return PossibleForNUNANPO(ATTRIBUTION_TYPE-1);
}


void Read_SAVE_TOPCHANGE()
{
  FILE *outfile;
  char filename[1000];
  int num=999;
  
  
  
  
  sprintf(filename,"%saddt.bin",indirectory);
  outfile = fopen(filename,"r");
  if(outfile==NULL)
    {
      

      
      SAVE_TOPCHANGE = 1;
      return;
    }
  
  fscanf(outfile,"%d\n",&num);
  fclose(outfile);
  
  if((num>=0)&&(num<=2))
    {
      SAVE_TOPCHANGE = num;
    }
}







void Record_SAVE_TOPCHANGE(int type)
{
  FILE *outfile;
  char filename[1000];

  

  SAVE_TOPCHANGE = type;

  sprintf(filename,"%saddt.bin",indirectory);
  outfile = fopen(filename,"w");
  if(outfile==NULL)
    {
      XBell(mydisplay,50);
      printf("could not open %s for write\n",filename);
      return;
    }
  
  fprintf(outfile,"%d\n",SAVE_TOPCHANGE);
  fclose(outfile);

}



void Record_TREX_Change(int num)
{
  FILE *outfile;
  char filename[1000];

  sprintf(filename,"%saddtt.bin",indirectory);
  outfile = fopen(filename,"w");
  if(outfile==NULL)
    {
      XBell(mydisplay,50);
      printf("could not open %s for write\n",filename);
      return;
    }

  fprintf(outfile,"%d\n",num);
  fclose(outfile);
}


int Read_TREX_Change()
{
  FILE *outfile;
  int num;
  char filename[1000];

  sprintf(filename,"%saddtt.bin",indirectory);
  outfile = fopen(filename,"r");
  if(outfile==NULL)
  { 
    Record_TREX_Change(0);
    return 1;
  }
  
  fscanf(outfile,"%d\n",&num);
  fclose(outfile);
  
  Record_TREX_Change(0);

  return num;
}



void RebuildTopImage(int type)
{
  

  int saveC;

  if(type==0)
    {
      if(SAVE_TOPCHANGE==1)
	  {
	    Relief(0);
        Record_SAVE_TOPCHANGE(0);
	  } 
      else if(SAVE_TOPCHANGE==2)
	  { 
        

        saveC = DrawContourLines;
        DrawContourLines = 0;
	    Relief(2);
        DrawContourLines = saveC;

        Record_SAVE_TOPCHANGE(0);

        if(DrawContourLines==1)
		{ 
          
		  SAVE_TOPCHANGE = 1;
		} 
	  } 
	  else
	  {
        Record_SAVE_TOPCHANGE(0);
	  }
    }
  else
    {
      if((type==3)||(type==4)) 
	{
	  Record_SAVE_TOPCHANGE(2);
	}
      else if(SAVE_TOPCHANGE==0)
	{
	  Record_SAVE_TOPCHANGE(1);
	}
    }


  if(ATTRTYPE_TREX())
  {
	
    Record_TREX_Change(1);
  }

}




void exitCallback(Widget w, XtPointer userData, XtPointer callData)
{
  XmString thestring;
  char *text;
  int dieflag = (int)userData;
  extern Widget shapename_w,param_net_head,param2_net_head;
  extern int net_head_in_use,net_deader_head,net_deader_phead,PROFILE_WIN;

  if(dieflag==1)
    {
      XtDestroyWidget(w);
    }
  else if(dieflag==2)
    {
      if(DEBUG==1){printf("reset toggle checker\n"); }
      
      
      EnterFileCallback(previousresults, (XtPointer)21, (XtPointer)21);


      if(head_in_use==0)
	{
	  deader_head=1; 
	  XtDestroyWidget(param_head);
	}
      if(head_in_use==1)
	{
	  deader_phead=1; 
	  XtDestroyWidget(param2_head);
	}


    }
  else if(dieflag==3) 
    {
      LOS_WIN=0;
      los_result(text_obs,    (XtPointer)1,(XtPointer)NULL);
      los_result(text_tgt,    (XtPointer)2,(XtPointer)NULL);

	  if(DO_FAN()==1)
	  {
        los_result(text_angle,  (XtPointer)3,(XtPointer)NULL);
        los_result(text_quality,(XtPointer)4,(XtPointer)NULL);
	  }

      XtDestroyWidget(XtParent(XtParent(XtParent(w))));
    }  
  else if(dieflag==4) 
    { 
      
      if(fore_result(fore_grid_s,  (XtPointer)4, (XtPointer)4)==0)
	{
	  return;
	}
      if(fore_result(fore_grid_xa, (XtPointer)2, (XtPointer)2)==0)
	{
	  return;
	}
      if(fore_result(fore_grid_ya, (XtPointer)3, (XtPointer)3)==0)
	{
	  return;
	}

      if(fore_result(shapename_w, (XtPointer)35, (XtPointer)35)==0)
	{
	  return;
	}

      FORE_WIN = 0;
      XtDestroyWidget(XtParent(XtParent(XtParent(w))));
    }
  else if(dieflag==6) 
    {
      REC_WIN=0;
      los_result(text_llx, (XtPointer)5,(XtPointer)NULL);
      los_result(text_lly, (XtPointer)6,(XtPointer)NULL);
      los_result(text_urx, (XtPointer)7,(XtPointer)NULL);
      los_result(text_ury, (XtPointer)8,(XtPointer)NULL);
      XtDestroyWidget(XtParent(XtParent(XtParent(w))));
    }  
  else if(dieflag==7) 
    {
      
      XtPopdown(XtParent(XtParent(XtParent(w))));
      XtDestroyWidget(XtParent(XtParent(XtParent(w))));
      dead_lod_head = 1;
    }
  else if(dieflag==8) 
    {
      XtDestroyWidget (w);
      FAN_INFO=0;
    }
  else if(dieflag==9) 
    {
      XtDestroyWidget (XtParent(XtParent(XtParent(w))));
      ERR_INFO=0;
    }
  else if(dieflag==10) 
    {
      XtDestroyWidget (XtParent(XtParent(XtParent(w))));
      
      if     (head2_in_use==1){dead_head3 = 1;}
      else if(head2_in_use==2){dead_other_head3 = 1;}
    }
  else if(dieflag==11) 
    {
      SAVE_SETTINGS_UP = 0;
      XtDestroyWidget(XtParent(XtParent(w)));
    }
  else if(dieflag==12) 
    {
      XtDestroyWidget(XtParent(XtParent(w)));
      LOAD_SETTINGS_UP = 0;
    }
  else if(dieflag==14) 
    {
      input_up = 0;
      XtDestroyWidget(XtParent(XtParent(w))); 
    }
  else if(dieflag==15) 
    {
      IMPORT_INPUT = 0;
    }
  else if(dieflag==16) 
    {
      PATCH_INPUT = 0;
    }
  else if(dieflag==17) 
    {
      STF_INPUT = 0;
    }
  else if(dieflag==18) 
    {
      ABORT_EXTRACT= 1; 
      FORMAT_BEGIN = 0; 
    }
  else if(dieflag==19) 
    {
      ABORT_CONCAT= 1;  
    }
  else if(dieflag==20) 
    {
      FORMAT_BEGIN = 0;
      
      XtDestroyWidget(XtParent(XtParent(w))); 

      
      
      IMPORT_WIN=0;

      if(NGA_TYPE==1)
	{
	  ImportGAITButtonCallback((Widget) NULL,(XtPointer)NULL,(XtPointer) NULL);
	}
      else
	{
	  ImportSEEITButtonCallback((Widget) NULL,(XtPointer)NULL,(XtPointer) NULL);
	}
    }
  else if(dieflag==21) 
    {
      IMPORT_OUTPUT = 0;
      XtDestroyWidget(XtParent(XtParent(w)));
    }
  else if(dieflag==22) 
    {
      DO_DESCRIBE = 0;
    }
  else if(dieflag==24) 
    {
	  

	  if(running==0)
	  {
		

 		  XtVaGetValues(running_info,XmNcancelLabelString,&thestring,NULL);

          XmStringGetLtoR(thestring,
		  (XmStringCharSet) XmSTRING_DEFAULT_CHARSET, &text);

          if(strstr(text,"Stop Drawing Conditions"))
		  {
			ABORT_ZOOM = 1;
			if(RUNNING_INFO==1)
			{
  		      XtVaSetValues(running_info,XmNcancelLabelString,STRING("OK"),NULL);
			}
			else
			{
			  printf("unexpected RUNNING_INFO %d at place 1\n",RUNNING_INFO);
			}
		  }
		  else if(strstr(text,"OK"))
		  {
			if(RUNNING_INFO==1)
			{
			  XtDestroyWidget(running_info);
			}
			else
			{
			  printf("unexpected RUNNING_INFO %d at place 2\n",RUNNING_INFO);
			}

	        RUNNING_INFO=0;
            STOP_FLAG=1;
		  }
		  else
		  {
			printf("\n\nerror: unexpected string for summary window <%s>\n\n",text);
	        RUNNING_INFO=0;
            STOP_FLAG=1;
		  }
	  }
	  else
	  {
	    XtDestroyWidget(running_info);
	    RUNNING_INFO=0;
        STOP_FLAG=1;
	  } 
  }
  else if(dieflag==25) 
    {
      if(FIX_RUNNING==1)
	{  
	  XtDestroyWidget(fix_running);
	  FIX_RUNNING=0;
	}
      STOP_FIX_FLAG=1;
    }
  else if(dieflag==27) 
    {
      SPEC_WIN=0;
      XtDestroyWidget(XtParent(XtParent(XtParent(w))));
    } 
  else if(dieflag==29) 
    {
      XtDestroyWidget(XtParent(XtParent(w)));
      AOI_LOAD_UP=0;
    }
  else if(dieflag==30) 
    {
    }
  else if(dieflag==31) 
    {
    }
  else if(dieflag==32) 
    {
      ABORT_ZOOM = 1; 
    }
  else if(dieflag==33) 
    {
      ABORT_ZOOM = 2; 
    }
  else if(dieflag==34) 
    {
      
      XtDestroyWidget(XtParent(XtParent(XtParent(w))));
    }
  else if(dieflag==35) 
    {
      
      SHAPE_IMPORT_OUTPUT = 0;
      XtDestroyWidget(XtParent(XtParent(w)));
    }
  else if(dieflag==36) 
    {
      XtDestroyWidget(XtParent(XtParent(XtParent(w))));
    }
  else if(dieflag==37) 
    {
      fore_result(fore_ver,     (XtPointer)23,(XtPointer)23);
      fore_result(fore_ver2,     (XtPointer)26,(XtPointer)26);
      XtDestroyWidget(XtParent(XtParent(XtParent(w))));
    }
  else if(dieflag==38) 
    {
      XtDestroyWidget(XtParent(XtParent(XtParent(w))));
    }
  else if(dieflag==39) 
    {
      XtDestroyWidget(w);
    }
  else if(dieflag==40) 
    {
      AOI_LOAD_UP = 0;
      XtDestroyWidget(XtParent(XtParent(w)));
    }
  else if(dieflag==41) 
    {
      dead_zero_head = 1;
      XtDestroyWidget(XtParent(XtParent(w)));
    }
  else if(dieflag==42)
    {
      dead_obhead[current_ob_head]=1; 
      XtDestroyWidget(XtParent(XtParent(XtParent(w))));
    }
  else if(dieflag==43)
    {
      metabrowse_up = 0;
      XtDestroyWidget(XtParent(XtParent(w)));
    }
  else if(dieflag==44)
    {
      SAVE_CREPORT_UP = 0;
      XtDestroyWidget(XtParent(XtParent(w)));
    }
  else if(dieflag==45)
    {
      LAYER_GEOM_UP = 0;
      XtDestroyWidget(XtParent(XtParent(w)));
    }
  else if(dieflag==46)
    {
      LAYER_FC_UP = 0;
      XtDestroyWidget(XtParent(XtParent(w)));
    }
   else if(dieflag==47)
    {
      LAYER_MGCP_UP = 0;
      XtDestroyWidget(XtParent(XtParent(w)));
    }
    else if(dieflag==48)
    {
      HandleSuccessDos(XtParent(XtParent(XtParent(w))));
      
    }
    else if(dieflag==49)
    {
      XtDestroyWidget(xml_running);
    }
    else if(dieflag==50)
    {
      GRID_WIN = 0;
      XtDestroyWidget(XtParent(XtParent(XtParent(w))));
    }
    else if(dieflag==51)
    {
    }
    else if(dieflag==52)
    {
      CONTOUR_WIN = 0;
      if(fore_result(fore_con,     (XtPointer)1, (XtPointer)1)==0)
	  { 
	    return;
	  }
      RebuildTopImage(6);
      refreshCallback((Widget)NULL,(XtPointer)NULL,(XtPointer)NULL);
      XtDestroyWidget(XtParent(XtParent(XtParent(w))));
    }
    else if(dieflag==53)
    {
    }
  else if(dieflag==54) 
    {
      
      browse30_up = 0;
      XtDestroyWidget(XtParent(XtParent(w)));
    }
  else if(dieflag==55)
    {
      if(net_head_in_use==0)
	  { 
	    net_deader_head=1; 
	    XtDestroyWidget(param_net_head);
	  } 
      if(net_head_in_use==1)
	  { 
	    net_deader_phead=1; 
	    XtDestroyWidget(param2_net_head);
	  } 
    }
  else if(dieflag==56) 
  {
    XtDestroyWidget(XtParent(XtParent(w))); 
  }
  else if(dieflag==57)
  { 
    PROFILE_WIN = 0;
    XtDestroyWidget(XtParent(XtParent(XtParent(w))));
  }
  else if(dieflag==58) 
  {
    XtDestroyWidget(routing_info);
    ROUTING_INFO=0;
    ABORT_ROUTING=1;
  }
  else if(dieflag==59) 
  {   
    XtDestroyWidget(XtParent(XtParent(w))); 
  }
}






void redraw_net(Widget graph, XtPointer client_data, XtPointer call_data)
{
  XmDrawingAreaCallbackStruct *cbs = 
    (XmDrawingAreaCallbackStruct *) call_data;
  int temp;
  
  if(DEBUG==1){printf("redraw net got %d\n",(int)client_data);}
  
  

  temp = (int)client_data;
  

  if(temp==1000)  
    {
      XCopyArea (cbs->event->xexpose.display, Profile_pix, cbs->window, mygc,
		 0, 0, 620,300, 0, 0);
    }
  else if(temp==1001) 
    {
      XCopyArea (cbs->event->xexpose.display, Demo_pix, cbs->window, mygc,
		 0, 0, 620,300, 0, 0);
    }
  else if(temp==1002) 
    {
      XCopyArea (cbs->event->xexpose.display, Att_Demo_pix, cbs->window, mygc,
		 0, 0, 620,600, 0, 0);
    }
  else if(temp>=5000)
    {
      XCopyArea (cbs->event->xexpose.display,layer_colorpix[temp-5000], cbs->window, mygc,
		 0, 0, 450,100, 0, 0);
    }
}





void do_logo()
{  
  if(logo_done==0)
    {
      read_logo(); 
      logo_done=1;
    }

  XCopyArea (mydisplay, pixmap, mywindow, mygc,
	     0, 0,width,height, 0, 0);

}



void redraw(Widget drawing_a,XtPointer client_data,XtPointer call_data)
{
  XmDrawingAreaCallbackStruct *cbs = 
    (XmDrawingAreaCallbackStruct *) call_data;

  XCopyArea (cbs->event->xexpose.display, pixmap, cbs->window, mygc,
	     0, 0, width, height, 0, 0);
}




double mydmax(double first, double second)
{
  if(first>second) {return first;}
  return second;
}




void RevertFCArrows()
{
  int i;
  

  for(i=0;i<NUMCHECKGROUPS;i++)
    {
      FCOnOff2[i] = 0;
    }

  for(i=0;i<=CONDITION_DEFINITIONS;i++)
    {
      FCOnOff3[i] = 0;
    }

  FCOnOff1 = 1;
}





void RevertBOSelected()
{
  struct BOList *curr,*prev;

 
  curr = BOOnList;
  prev = curr;

  while(curr!=NULL)
    {
      prev = curr;
      curr = curr->next;

      if(prev->speclist!=NULL)
	{
	  free(prev->speclist);
	}
      if(prev->selectlist!=NULL)
	{
	  free(prev->selectlist);
	}
      free(prev);
    }
  BOOnList = NULL;

}


void RevertBOArrows()
{
  struct BOLevelList *curr,*prev;
  
  curr =  BOLevelListRoot;
  
  prev = curr;
  
  while(curr!=NULL)
    {
      prev = curr;
      curr = curr->next;
      free(prev);
    }
  BOLevelListRoot = NULL;



  
  RevertBOSelected();
}




void ResetBOoptions()
{
  int i;

  if(BODEBUG==1)
    {
      printf("Resetting BO,arrows,selected\n");
    }

  if(alloced_boonoff2>0)
    {
      free(BOOnOff2);
      alloced_boonoff2 = 0;
    }

  for(i=1;i<=CONDITION_DEFINITIONS;i++)
    {
      ErrorLookup[i].scrollwidmade  = 0;
      ErrorLookup[i].filterout      = 0;
    }


  for(i=0;i<CLONE_DEFINITIONS;i++)
    {
      CloneErrorLookup[i].scrollwidmade  = 0;
    }

  view_object_page =  1;

  RevertBOArrows();
  RevertFCArrows();
}




void UpdateKeepDismiss(struct ConditionList *conds)
{
  
  
  struct ConditionList *curr;
  int cloneindex;

  curr = conds;
  
  while(curr!=NULL)
    {
      if(curr->CONDITION_INSTANCE==0)
	{
	  if(curr->retainignore!=ErrorLookup[curr->CONDITION_TYPE].keepdismiss[curr->ordinal_num])
	    {
	      
	    }

	  curr->retainignore = ErrorLookup[curr->CONDITION_TYPE].keepdismiss[curr->ordinal_num];
	}
      else
	{
	  cloneindex = GetCloneIndex(curr->CONDITION_INSTANCE,curr->CONDITION_TYPE);

	  if(curr->retainignore!=CloneErrorLookup[cloneindex].keepdismiss[curr->ordinal_num])
	    {
	      
	    }

	  curr->retainignore = CloneErrorLookup[cloneindex].keepdismiss[curr->ordinal_num];

	}
      curr = curr->next;
    }
}






int ValidFile(char *first, char *second)
{
  char testfile[1000];
  FILE *openme;

  if(second!=NULL)
    {
      sprintf(testfile,"%s%s",first,second);
    }
  else
    {
      sprintf(testfile,"%s",first);
    }

  openme = fopen(testfile,"r");
  if(openme!=NULL)
    {
      fclose(openme);
      return 1;
    }

  return 0;

}


void RemoveAnnotations(int nettype)
{
  int i;

  

  for(i=0; i<=CONDITION_DEFINITIONS; i++)
   {
	 if(IsNetCheck(i)==nettype)
	 {
       if(ErrorLookup[i].Annotation!=NULL)
	   {
	     free(ErrorLookup[i].Annotation);
	     ErrorLookup[i].Annotation = NULL;
	   }
	 }
  }
}



void zerooutCallback(Widget w, XtPointer userData, XtPointer callData)
{
  int i;
  int silent=(int)userData;
  char diecommand[1000];
  static int LOCALBUSY = 0;
  int nettype = (int)callData;

  
  if(LOCALBUSY==1)
    {
      printf("Button click ignored due to being busy\n");
      return;
    }

  LOCALBUSY = 1;
  
  if(nettype==0)
  {
    UnsavedConditions = 0;
    unsavedignore     = 0;
  }


  

  if((USE_DOS==0)||(SLASHTYPE==NONDOS_TYPE))
    {
      if(output_source==1)
	{
	  if(nettype==0)
	  {
	    if(ValidFile(outdirectory,"condreport.lk"))
	    {
	      sprintf(diecommand,"rm -f \"%s\"condreport.lk",outdirectory);
	      system(diecommand);
	    }
	  }

	  if(nettype==0)
	  {
	  if(ValidFile(outdirectory,"condreport.ns"))
	    {
	      sprintf(diecommand,"rm -f \"%s\"condreport.ns",outdirectory);
	      system(diecommand);
	    }
	  }

	  if(nettype==0)
	  {
	  if(ValidFile(outdirectory,"condreport.es"))
	    {
	      sprintf(diecommand,"rm -f \"%s\"condreport.es",outdirectory);
	      system(diecommand);
	    }
	  }

	  if(nettype==0)
	  {
	  if(ValidFile(outdirectory,"condreport.es2"))
	    {
	      sprintf(diecommand,"rm -f \"%s\"condreport.es2",outdirectory);
	      system(diecommand);
	    }
	  }
	  
	  if(nettype==0)
	  {
	  if(ValidFile(outdirectory,"condreport.bo"))
	    {
	      sprintf(diecommand,"rm -f \"%s\"condreport.bo",outdirectory);
	      system(diecommand);
	    }
	  }

	  
	  if(nettype==0)
	  {
	  if(ValidFile(outdirectory,"condreport.bo2"))
	    {
	      sprintf(diecommand,"rm -f \"%s\"condreport.bo2",outdirectory);
	      system(diecommand);
	    }
	  }

	  if(nettype==0)
	  {
	  if(ValidFile(outdirectory,"condreport.lk2"))
	    {
	      sprintf(diecommand,"rm -f \"%s\"condreport.lk2",outdirectory);
	      system(diecommand);
	    }
	  }

	  if(nettype==1)
	  {
	  if(ValidFile(outdirectory,"condreport.nt"))
	    {
	      sprintf(diecommand,"rm -f \"%s\"condreport.nt",outdirectory);
	      system(diecommand);
	    }
	  }

	  if(nettype==0)
	  {
	  if(ValidFile(outdirectory,"condreport.sm"))
	    {
	      sprintf(diecommand,"rm -f \"%s\"condreport.sm",outdirectory);
	      system(diecommand);
	    }
	  }

	  
	}

	  if(nettype==0)
	  {
        if(ValidFile(errtypelog,NULL))
		{ 
	      sprintf(diecommand,"rm -f \"%s\"",errtypelog);
	      system(diecommand);
		} 
	  } 
    }
  else
    {
      if(output_source==1)
	{
	  if(nettype==0)
	  {
	  if(ValidFile(outdirectory,"condreport.lk"))
	    {
	      sprintf(diecommand,"del \"%scondreport.lk\"",outdirectory);
	      system(diecommand);
	    }
	  }
	  
	  if(nettype==0)
	  {
	  if(ValidFile(outdirectory,"condreport.ns"))
	    {
	      sprintf(diecommand,"del \"%scondreport.ns\"",outdirectory);
	      system(diecommand);
	    }
	  }

	  if(nettype==0)
	  {
	  if(ValidFile(outdirectory,"condreport.es"))
	    {
	      sprintf(diecommand,"del \"%scondreport.es\"",outdirectory);
	      system(diecommand);
	    }
	  }

	  if(nettype==0)
	  {
	  if(ValidFile(outdirectory,"condreport.es2"))
	    {
	      sprintf(diecommand,"del \"%scondreport.es2\"",outdirectory);
	      system(diecommand);
	    }
	  }

	  if(nettype==0)
	  {
	  if(ValidFile(outdirectory,"condreport.bo"))
	    {
	      sprintf(diecommand,"del \"%scondreport.bo\"",outdirectory);
	      system(diecommand);
	    }
	  }

	  if(nettype==0)
	  {
	  if(ValidFile(outdirectory,"condreport.bo2"))
	    {
	      sprintf(diecommand,"del \"%scondreport.bo2\"",outdirectory);
	      system(diecommand);
	    }
	  }

	  if(nettype==0)
	  {
	  if(ValidFile(outdirectory,"condreport.lk2"))
	    {
	      sprintf(diecommand,"del \"%scondreport.lk2\"",outdirectory);
	      system(diecommand);
	    }
	  }
	  
	  if(nettype==1)
	  {
	  if(ValidFile(outdirectory,"condreport.nt"))
	    {
	      sprintf(diecommand,"del \"%scondreport.nt\"",outdirectory);
	      system(diecommand);
	    }
	  }

	  if(nettype==0)
	  {
	  if(ValidFile(outdirectory,"condreport.sm"))
	    {
	      sprintf(diecommand,"del \"%scondreport.sm\"",outdirectory);
	      system(diecommand);
	    }
	  }

	  
	}

	  if(nettype==0)
	  {
      if(ValidFile(errtypelog,NULL))
	  {
	  sprintf(diecommand,"del \"%s\"",errtypelog);
	  system(diecommand);
	  } 
	  }
    }


  if(nettype==1)
  {
    sprintf(diecommand,"%snetworkdata.bin",outdirectory);
    ZeroNetworkFile(diecommand);
    NumNetsLoaded = 0;
  }



  for(i=0; i<=CONDITION_DEFINITIONS; i++)
    {
      if(IsNetCheck(i)!=nettype)
	  {
        continue;
	  }

      ErrorLookup[i].numberNets  = 0;
      ErrorLookup[i].number      = 0;
      ErrorLookup[i].viewall     = 0;
      ErrorLookup[i].viewsome    = 0;
      ErrorLookup[i].viewallNET  = 0;
      ErrorLookup[i].viewsomeNET = 0;
    }

  for(i=0; i<CLONE_DEFINITIONS; i++)
    {
      if(IsNetCheck(CloneErrorLookup[i].CloneNumber)!=nettype)
	  {
        continue;
	  }
      CloneErrorLookup[i].numberNets  = 0;
      CloneErrorLookup[i].number      = 0;
      CloneErrorLookup[i].viewall     = 0;
      CloneErrorLookup[i].viewsome    = 0;
      CloneErrorLookup[i].viewallNET  = 0;
      CloneErrorLookup[i].viewsomeNET = 0;
    }



  
  
  if((dead_error==0)&&(nettype==0))
    {
	  



      

      XtRemoveCallback(errorhead[Current_head],XmNdestroyCallback,ShellDeath,(XtPointer)(2000+Current_head));


      XtPopdown(errorhead[Current_head]);

      XtDestroyWidget(errorhead[Current_head]);
      dead_error=1;
      Current_head++;
      if(Current_head==3){Current_head=0;}
    }


  if((dead_network==0)&&(nettype==1))
    {
      
      XtDestroyWidget(networkhead[Current_net_head]);
      dead_network = 1;
    }


  if(silent==0)
    {
      

      if(head_in_use==0)
        {
          not_while_running(param_head,"Conditions Removed.",1041,"Successful Condition Removal",5);
        }
      else if(head_in_use==1)
	{
          not_while_running(param2_head,"Conditions Removed.",1041,"Successful Condition Removal",5);
        }

      XtDestroyWidget(XtParent(XtParent(w))); 
    }


  
  MakeSen((Widget)NULL,(XEvent *)NULL,(String *)NULL,(int *)NULL);
  ResetBOoptions();

  LOCALBUSY = 0;
}





void show_vertices(Widget widget,XtPointer client_data,XtPointer call_data)
{  
  int type=(int)client_data;

  if(type==10001)
    {
      SHOW_POLY_VERTICES=!SHOW_POLY_VERTICES;
    }
  else if(type==10002)
    {
      SHOW_LINE_VERTICES=!SHOW_LINE_VERTICES;
    }
  else if(type==10003)
    {
      SHOW_END_VERTICES=!SHOW_END_VERTICES;
    }
  else
    {      
      printf("bad data to show_vert: %d\n",type);
    }
}




void toggle_combo(Widget widget,MyData *mydata,XtPointer call_data)
{  
  int i;
  XmString empty_item[1];
  XmString *sac_names;
  char temp[500];
  int cloneindex=-1;
  int errnum   = mydata->check_num;
  int axis     = mydata->axis;
  int ADDER    = mydata->ADDER;
  int clonenum = mydata->clonenum;
  int geomtype = 0;


  if(NGA_TYPE==1)
    {
      geomtype = mydata->geomtype;
    }




  if(clonenum>0)
    {
      cloneindex = GetCloneIndex(clonenum,errnum);
    }


  if(clonenum==0)
    {
      ErrorLookup[errnum].DO_EDCS_COMBO[axis][ADDER][geomtype]=!ErrorLookup[errnum].DO_EDCS_COMBO[axis][ADDER][geomtype];
      
      XmListDeselectAllItems(ErrorLookup[errnum].list_w [axis][ADDER][geomtype]);
      XmListDeselectAllItems(ErrorLookup[errnum].EAlist [axis][ADDER][geomtype]);
      XmListDeselectAllItems(ErrorLookup[errnum].EAVlist[axis][ADDER][geomtype]);
    }
  else
    {
      CloneErrorLookup[cloneindex].DO_EDCS_COMBO[axis][ADDER][geomtype]=!CloneErrorLookup[cloneindex].DO_EDCS_COMBO[axis][ADDER][geomtype];
      
      XmListDeselectAllItems(CloneErrorLookup[cloneindex].list_w [axis][ADDER][geomtype]);
      XmListDeselectAllItems(CloneErrorLookup[cloneindex].EAlist [axis][ADDER][geomtype]);
      XmListDeselectAllItems(CloneErrorLookup[cloneindex].EAVlist[axis][ADDER][geomtype]);
    }

  
  
  if(
     ((clonenum==0) && (     ErrorLookup[errnum]    .DO_EDCS_COMBO[axis][ADDER][geomtype]==1))  ||
     ((clonenum>0)  && (CloneErrorLookup[cloneindex].DO_EDCS_COMBO[axis][ADDER][geomtype]==1))  
     )
    {

	  if(clonenum==0)
	  {
        if(NGA_TYPE==1)
		{ 
	    XtVaSetValues(ErrorLookup[errnum].EAstring3,XmNlabelString,     STRING("Attributes for SELECTED Feature Type"),NULL);
	    XtVaSetValues(ErrorLookup[errnum].EAstring2,XmNlabelString,     STRING("(No attribute selected):")  ,NULL);
	    XtVaSetValues(ErrorLookup[errnum].EAstring1,XmNlabelString,     STRING("(No Feature Type selected):")  ,NULL);
		} 
        else
		{ 
	    XtVaSetValues(ErrorLookup[errnum].EAstring3,XmNlabelString,     STRING("Attributes for SELECTED Classifier"),NULL);
	    XtVaSetValues(ErrorLookup[errnum].EAstring2,XmNlabelString,     STRING("(No attribute selected):")  ,NULL);
	    XtVaSetValues(ErrorLookup[errnum].EAstring1,XmNlabelString,     STRING("(No Classifier selected):")  ,NULL);
		} 
	  }
	  else
	  {
        if(NGA_TYPE==1)
		{ 
	    XtVaSetValues(CloneErrorLookup[cloneindex].EAstring3,XmNlabelString,     STRING("Attributes for SELECTED Feature Type"),NULL);
	    XtVaSetValues(CloneErrorLookup[cloneindex].EAstring2,XmNlabelString,     STRING("(No attribute selected):")  ,NULL);
	    XtVaSetValues(CloneErrorLookup[cloneindex].EAstring1,XmNlabelString,     STRING("(No Feature Type selected):")  ,NULL);
		} 
        else
		{ 
	    XtVaSetValues(CloneErrorLookup[cloneindex].EAstring3,XmNlabelString,     STRING("Attributes for SELECTED Classifier"),NULL);
	    XtVaSetValues(CloneErrorLookup[cloneindex].EAstring2,XmNlabelString,     STRING("(No attribute selected):")  ,NULL);
	    XtVaSetValues(CloneErrorLookup[cloneindex].EAstring1,XmNlabelString,     STRING("(No Classifier selected):")  ,NULL);
		} 
	  }


      if(clonenum==0)
	{

      XtOverrideTranslations(ErrorLookup[errnum].list_w[axis][ADDER][geomtype],
					   XtParseTranslationTable(list_translations62));


	  XtVaSetValues(ErrorLookup[errnum].list_w[axis][ADDER][geomtype]   ,XmNselectionPolicy, XmSINGLE_SELECT              ,NULL);


      XtOverrideTranslations(ErrorLookup[errnum].list_w[axis][ADDER][geomtype],
					   XtParseTranslationTable(list_translations62));



	  
	  empty_item[0] =  XmStringCreate("                                                                                                                                            ","mytag1");
	  
	  XtVaSetValues (ErrorLookup[errnum].EAlist[axis][ADDER][geomtype],
			 XmNitems,             empty_item,
			 XmNitemCount,         1,
			 NULL);
	  
	  XtVaSetValues (ErrorLookup[errnum].EAVlist[axis][ADDER][geomtype],
			 XmNitems,             empty_item,
			 XmNitemCount,         1,
			 NULL);
	}
      else
	{
	  

      XtOverrideTranslations(CloneErrorLookup[cloneindex].list_w[axis][ADDER][geomtype],
					   XtParseTranslationTable(list_translations62));

	  XtVaSetValues(CloneErrorLookup[cloneindex].list_w[axis][ADDER][geomtype]   ,
			XmNselectionPolicy, XmSINGLE_SELECT              ,NULL);
	  
      XtOverrideTranslations(CloneErrorLookup[cloneindex].list_w[axis][ADDER][geomtype],
					   XtParseTranslationTable(list_translations62));


	  
	  empty_item[0] =  XmStringCreate("                                                                                                                                            ","mytag1");
	  
	  XtVaSetValues (CloneErrorLookup[cloneindex].EAlist[axis][ADDER][geomtype],
			 XmNitems,             empty_item,
			 XmNitemCount,         1,
			 NULL);
	  
	  XtVaSetValues (CloneErrorLookup[cloneindex].EAVlist[axis][ADDER][geomtype],
			 XmNitems,             empty_item,
			 XmNitemCount,         1,
			 NULL);
	}
    }
  else
    {

	  if(clonenum==0)
	  {
        XtVaSetValues(ErrorLookup[errnum].EAstring3,XmNlabelString,     STRING("Attributes found"),      NULL);
        XtVaSetValues(ErrorLookup[errnum].EAstring2,XmNlabelString,     STRING("(No attribute selected):"),  NULL);
      
        sprintf(temp,"(%d definitions found):",NumberOfAttributesEntries);
        XtVaSetValues(ErrorLookup[errnum].EAstring1,XmNlabelString,     STRING(temp),  NULL);
	  }
	  else
	  {
        XtVaSetValues(CloneErrorLookup[cloneindex].EAstring3,XmNlabelString,     STRING("Attributes found"),      NULL);
        XtVaSetValues(CloneErrorLookup[cloneindex].EAstring2,XmNlabelString,     STRING("(No attribute selected):"),  NULL);
      
        sprintf(temp,"(%d definitions found):",NumberOfAttributesEntries);
        XtVaSetValues(CloneErrorLookup[cloneindex].EAstring1,XmNlabelString,     STRING(temp),  NULL);
	  }

      if(clonenum==0)
	{

      XtOverrideTranslations(ErrorLookup[errnum].list_w[axis][ADDER][geomtype],
					   XtParseTranslationTable(list_translations16b));

	  XtVaSetValues(ErrorLookup[errnum].list_w[axis][ADDER][geomtype]   ,
			XmNselectionPolicy, XmEXTENDED_SELECT,             NULL);


      XtOverrideTranslations(ErrorLookup[errnum].list_w[axis][ADDER][geomtype],
					   XtParseTranslationTable(list_translations16b));


	  
	  empty_item[0] =  XmStringCreate("                                                                                                                                            ","mytag1");

	  XtVaSetValues (ErrorLookup[errnum].EAVlist[axis][ADDER][geomtype],
			 XmNitems,             empty_item,
			 XmNitemCount,         1,
			 NULL);
	}
      else
	{
	  

      XtOverrideTranslations(CloneErrorLookup[cloneindex].list_w[axis][ADDER][geomtype],
					   XtParseTranslationTable(list_translations16b));

	  XtVaSetValues(CloneErrorLookup[cloneindex].list_w[axis][ADDER][geomtype]   ,
			XmNselectionPolicy, XmEXTENDED_SELECT,             NULL);

      XtOverrideTranslations(CloneErrorLookup[cloneindex].list_w[axis][ADDER][geomtype],
					   XtParseTranslationTable(list_translations16b));


	  
	  empty_item[0] =  XmStringCreate("                                                                                                                                            ","mytag1");
	  
	  XtVaSetValues (CloneErrorLookup[cloneindex].EAVlist[axis][ADDER][geomtype],
			 XmNitems,             empty_item,
			 XmNitemCount,         1,
			 NULL);
	}

      
      
      
      
      sac_names =  (XmString *) (malloc(sizeof(XmString *) * NumberOfAttributesEntries));
      if(sac_names==NULL){printf("mne1: out of allocation memory!\n"); ExitWrapper(-1);}
      
      for(i=0;i<NumberOfAttributesEntries;i++)
	{
	  

	  sprintf(temp,"%s: %s (%.0lf)",
		  GetEACCode(MdlNames2[i].code),
		  GetEACLabel(MdlNames2[i].code),
		  MdlNames2[i].occurrences);

	  sac_names[i] = XmStringCreate(temp,"mytag1");

	}	  
   
    
      if(clonenum==0)
	{
	  XtVaSetValues (ErrorLookup[errnum].EAlist[axis][ADDER][geomtype],
			 XmNitems,             sac_names,
			 XmNitemCount,         NumberOfAttributesEntries,
			 NULL);
	}
      else
	{
	  XtVaSetValues (CloneErrorLookup[cloneindex].EAlist[axis][ADDER][geomtype],
			 XmNitems,             sac_names,
			 XmNitemCount,         NumberOfAttributesEntries,
			 NULL);
	}


      for (i = 0; i <  NumberOfAttributesEntries; i++)
	{
	  XmStringFree (sac_names[i]);
	}
      free(sac_names);
    }
}





void info_sac_tog(Widget widget,XtPointer client_data,XtPointer call_data)
{  
  if(InfoSac[(int)client_data]==0)
    {
      InfoSac[(int)client_data]=1;
    }
  else
    {
      InfoSac[(int)client_data]=0;
    } 
}








void VCGetGlobalTotals(int *totalchecks,int *totalconds, int *totalhighlighted)
{
  int errnum,cloneindex;
  
  *totalconds       = 0;
  *totalchecks      = 0;
  *totalhighlighted = 0;
  

  for(errnum=1;errnum<=CONDITION_DEFINITIONS;errnum++)
    {
      if(ErrorLookup[errnum].number>0)
	{
	  *totalchecks = *totalchecks + 1;
      *totalconds  = *totalconds + ErrorLookup[errnum].number;

	  if(ErrorLookup[errnum].viewall==1)
	    {
          *totalhighlighted = *totalhighlighted + ErrorLookup[errnum].number;
	    }
	  else if(ErrorLookup[errnum].viewsome==1)
	    {
	      *totalhighlighted = *totalhighlighted + ErrorLookup[errnum].pos_list_made;
          
	    }
	}
    }	
  
  for(cloneindex=0;cloneindex<CLONE_DEFINITIONS;cloneindex++)
    {	
      if(CloneErrorLookup[cloneindex].number>0)
	{
	  *totalchecks = *totalchecks + 1;
      *totalconds  = *totalconds + CloneErrorLookup[cloneindex].number;

	  if(CloneErrorLookup[cloneindex].viewall==1)
	    {
          *totalhighlighted = *totalhighlighted + CloneErrorLookup[cloneindex].number;
	    }
	  else if(CloneErrorLookup[cloneindex].viewsome==1)
	    {
	      *totalhighlighted = *totalhighlighted + CloneErrorLookup[cloneindex].pos_list_made;
	    }
	}
    }
}





int GetTotalSelected(int errnum, int cloneindex)
{
  



  if(errnum>=0)
    {
      if(ErrorLookup[errnum].viewall==1)
	  {
        return ErrorLookup[errnum].number;
	  }
      else if(ErrorLookup[errnum].viewsome==1)
	  {
	   return ErrorLookup[errnum].pos_list_made;
	  } 
      else
	{
	  return 0;
	}
    }
  else
    {
      if(CloneErrorLookup[cloneindex].viewall==1)
	{
      return CloneErrorLookup[cloneindex].number;
	}
      else if(CloneErrorLookup[cloneindex].viewsome==1)
	{
	  return CloneErrorLookup[cloneindex].pos_list_made;
	}
      else
	{
	  return 0;
	}
    }
  printf("error in rtEE\n");
  return 0;
}



void VCGetTotals(int groupnum,int *totalchecks, int *totalconds, int *totalselected)
{
  int errnum,cloneindex,clonenum;
  
  for(errnum=1;errnum<=CONDITION_DEFINITIONS;errnum++)
    {
      if(ErrorLookup[errnum].mygroup==groupnum)
	{
	  if(ErrorLookup[errnum].number>0)
	    {
	      *totalselected = *totalselected + GetTotalSelected(errnum,-1);
	      *totalchecks   = *totalchecks   + 1;
          *totalconds    = *totalconds    + ErrorLookup[errnum].number;
	    }
	  
	  for(clonenum=1;clonenum<=ErrorLookup[errnum].num_clones;clonenum++)
	    {
	      cloneindex = GetCloneIndex(clonenum,errnum);
	      
	      if(CloneErrorLookup[cloneindex].number>0)
		{
		  *totalselected = *totalselected + GetTotalSelected(-1,cloneindex);
		  *totalchecks   = *totalchecks   + 1;
          *totalconds    = *totalconds    + CloneErrorLookup[cloneindex].number;
		}
	    }
	}
    }  
}



void VCGetTotal(int errnum, int *totalconds, int *totalchecks, int *totalhighlighted)
{
  int cloneindex,clonenum;
  
  *totalconds       = 0;
  *totalchecks      = 0;
  *totalhighlighted = 0;
  
  if(ErrorLookup[errnum].number>0)
    {
      *totalchecks = *totalchecks + 1;
      *totalconds  = *totalconds + ErrorLookup[errnum].number;

      if(ErrorLookup[errnum].viewall==1)
	{
      *totalhighlighted = *totalhighlighted + ErrorLookup[errnum].number;
	}
      else if(ErrorLookup[errnum].viewsome==1)
	{
	  *totalhighlighted = *totalhighlighted + ErrorLookup[errnum].pos_list_made;
	}
      
    }
  
  for(clonenum=1;clonenum<=ErrorLookup[errnum].num_clones;clonenum++)
    {
      cloneindex = GetCloneIndex(clonenum,errnum);
      
      if(CloneErrorLookup[cloneindex].number>0)
	{
	  *totalchecks = *totalchecks + 1;
      *totalconds  = *totalconds + CloneErrorLookup[cloneindex].number;
	  
	  if(CloneErrorLookup[cloneindex].viewall==1)
	    {
          *totalhighlighted = *totalhighlighted + CloneErrorLookup[cloneindex].number;
	    }
	  else if(CloneErrorLookup[cloneindex].viewsome==1)
	    {
	      *totalhighlighted = *totalhighlighted + CloneErrorLookup[cloneindex].pos_list_made;
	    }
	}
    }  
}




int IsNetCheck(int checknum)
{
  return (checknum==NETWORKCHECK);
}


void GetNetGlobalTotals(int *totalactive,int *totalchecks)
{
  int cloneindex;

  *totalactive = 0;
  *totalchecks = 0;
  
    
  *totalactive = *totalactive + ErrorLookup[NETWORKCHECK].active;
  *totalchecks = *totalchecks + 1;

  for(cloneindex=0;cloneindex<CLONE_DEFINITIONS;cloneindex++)
    {	      
      if(IsNetCheck(CloneErrorLookup[cloneindex].CloneNumber))
	  {
        *totalactive = *totalactive + CloneErrorLookup[cloneindex].active;
        *totalchecks = *totalchecks + 1;
	  }
    }
}






void GetGlobalTotals(int *totalactive,int *totalchecks)
{
  int errnum,cloneindex;
  int useit;

  *totalactive = 0;
  *totalchecks = 0;
  
    
  for(errnum=1;errnum<=CONDITION_DEFINITIONS;errnum++)
    {
      useit = 0;

	  if(ErrorLookup[errnum].mygroup==DEM_GROUP)
	  {
        continue;
	  }

      if(ErrorLookup[errnum].checkapplies==GAITandSEEITcheck)
	{
	  useit = 1;
	}
      else if ( (NGA_TYPE==1)  && (ErrorLookup[errnum].checkapplies==GAITcheck) )
	{
      useit = 1;
	}
      else if ( (NGA_TYPE==0)  && (ErrorLookup[errnum].checkapplies==SEEITcheck) )
	{
	  useit = 1;
	}
      if(useit==1)
	{
	  *totalactive = *totalactive + ErrorLookup[errnum].active;
	  *totalchecks = *totalchecks + 1;
	}
    }	
  
  
  
  for(cloneindex=0;cloneindex<CLONE_DEFINITIONS;cloneindex++)
    {
	  if(IsNetCheck(CloneErrorLookup[cloneindex].CloneNumber)==0)
	  {
		
        *totalactive = *totalactive + CloneErrorLookup[cloneindex].active;
        *totalchecks = *totalchecks + 1;
	  }
    }
}




void GetTotals(int groupnum,int *totalactive,int *totalchecks)
{
  int errnum,cloneindex,clonenum,useit;
  

  for(errnum=1;errnum<=CONDITION_DEFINITIONS;errnum++)
    {
      useit = 0;
      
      if(ErrorLookup[errnum].checkapplies==GAITandSEEITcheck)
	{
	  useit = 1;
	}
      else if ( (NGA_TYPE==1)  && (ErrorLookup[errnum].checkapplies==GAITcheck) )
	{
	  useit = 1;
	}
      else if ( (NGA_TYPE==0)  && (ErrorLookup[errnum].checkapplies==SEEITcheck) )
	{
	  useit = 1;
	}
      
      if(useit==1)
	{
	  if(ErrorLookup[errnum].mygroup==groupnum)
	    {
	      if(ErrorLookup[errnum].active==1)
		{
		  *totalactive = *totalactive + 1;
		}
	      *totalchecks = *totalchecks + 1;
	      
	      for(clonenum=1;clonenum<=ErrorLookup[errnum].num_clones;clonenum++)
		{
		  cloneindex = GetCloneIndex(clonenum,errnum);
		  
		  if(CloneErrorLookup[cloneindex].active==1)
		    {
		      *totalactive = *totalactive + 1;
		    }
		  *totalchecks = *totalchecks + 1;
		}
	    }
	}  
    }
}










int GetActiveNum(int checknum)
{
  int i;
  int total;

  total = 0;

  if(ErrorLookup[checknum].active==1)
    {
      total = total + 1;
    }
  

  for(i=0;i<CLONE_DEFINITIONS;i++)
    {
      if(
	 (CloneErrorLookup[i].active==1) &&
	 (CloneErrorLookup[i].CloneNumber==checknum)
	 )
	{
	  total = total + 1;
	}
    }

  return total;
}


void toggled4(Widget widget,XtPointer client_data,XtPointer call_data)
{  
  int checknum = (int)client_data;
  int oldval=ErrorLookup[checknum].UseBorderConds;
  int newval;

  ResetMasterRun();

  if(oldval==0)
  {
    newval = 1;
  }
  else if(oldval==1)
  {
    newval = 0;
  }
  else
  {
    XBell(mydisplay,50);
    printf("Bad value %d for CN %d to TG4\n",oldval,checknum);
	return;
  }

  

  ErrorLookup[checknum].UseBorderConds = newval;
}

void toggledC4(Widget widget,XtPointer client_data,XtPointer call_data)
{ 
  int cloneindex = (int)client_data;
  int checknum   = CloneErrorLookup[cloneindex].CloneNumber;
  int oldval     = CloneErrorLookup[cloneindex].UseBorderConds;
  int newval;

  ResetMasterRun();

  if(oldval==0)
  {
    newval = 1;
  }
  else if(oldval==1)
  {
    newval = 0;
  }
  else
  {
    XBell(mydisplay,50);
    printf("Bad value %d for CN %d to TGC4\n",oldval,checknum);
	return;
  }

  

  CloneErrorLookup[cloneindex].UseBorderConds = newval;
}



void UpdateNetTotal()
{
  int totalactive = 0;
  int totalchecks = 0;
  char thislabel[1000];
  extern Widget NetGlobalTotals;


  if(NetModifyMasterRun==1)
  {
    ResetMasterRun();
  }


  GetNetGlobalTotals(&totalactive,&totalchecks);
     
  sprintf(thislabel," (%d/%d active)",totalactive,totalchecks);

  XtVaSetValues(NetGlobalTotals, XmNlabelString, STRING(thislabel), NULL);  
}


void toggled3(Widget widget,XtPointer client_data,XtPointer call_data)
{  
  int totalactive = 0;
  int totalchecks = 0;
  int checknum = (int)client_data;
  int checkgroup;
  char thislabel[1000];
  extern struct CheckGroupNames CGN[NUMCHECKGROUPS];

  if(TOGGLEDEBUG==1){printf("found that that was error type %d\n",checknum);}
  


  if(ErrorLookup[checknum].active==0)
    {
      ErrorLookup[checknum].active=1;
    }
  else
    {
      ErrorLookup[checknum].active=0;
    } 


  if(IsNetCheck(checknum))
  {
    UpdateNetTotal();
    return;
  }


  ResetMasterRun();


  checkgroup = ErrorLookup[checknum].mygroup;
  
  GetTotals(checkgroup,&totalactive,&totalchecks);
  
  sprintf(thislabel,"%s (%d/%d active)",
	  CGN[checkgroup].name,
	  totalactive,
	  totalchecks);
  

  XtVaSetValues(CGN[checkgroup].topwid, XmNlabelString, STRING(thislabel), NULL);

  
  
  sprintf(thislabel,"%s (%d/%d active)",
	  ParseErrType(checknum),
	  GetActiveNum(checknum),
	  ErrorLookup [checknum].num_clones + 1);
  XtVaSetValues(ErrorLookup[checknum].topwid, XmNlabelString, STRING(thislabel), NULL);  

  
  totalactive = 0;
  totalchecks = 0;
  GetGlobalTotals(&totalactive,&totalchecks);     
  sprintf(thislabel," (%d/%d active)",totalactive,totalchecks);
  XtVaSetValues(GlobalTotals, XmNlabelString, STRING(thislabel), NULL);
}




void toggledC3(Widget widget,MyData * client_data,XtPointer call_data)
{  
  int totalactive = 0;
  int totalchecks = 0;
  int checknum = client_data->check_num;
  int clonenum = client_data->clonenum;
  int cloneindex;
  int checkgroup;
  char thislabel[1000];
  extern struct CheckGroupNames CGN[NUMCHECKGROUPS];


  cloneindex = GetCloneIndex(clonenum,checknum);



  if(TOGGLEDEBUG==1){printf("found that that was error type %d\n",cloneindex);}
  
  if(CloneErrorLookup[cloneindex].active==0)
    {
      CloneErrorLookup[cloneindex].active=1;
    }
  else
    {
      CloneErrorLookup[cloneindex].active=0;
    } 


  if(IsNetCheck(checknum))
  {
    UpdateNetTotal();
    return;
  }


  ResetMasterRun();


  checkgroup = ErrorLookup[checknum].mygroup;
  
  GetTotals(checkgroup,&totalactive,&totalchecks);
  
  sprintf(thislabel,"%s (%d/%d active)",
	  CGN[checkgroup].name,
	  totalactive,
	  totalchecks);
  
  XtVaSetValues(CGN[checkgroup].topwid, XmNlabelString, STRING(thislabel), NULL);

  
  
  
  sprintf(thislabel,"%s (%d/%d active)",
	  ParseErrType(checknum),
	  GetActiveNum(checknum),
	  ErrorLookup [checknum].num_clones + 1);
  
  XtVaSetValues(ErrorLookup[checknum].topwid, XmNlabelString, STRING(thislabel), NULL);


  
  totalactive = 0;
  totalchecks = 0;
  GetGlobalTotals(&totalactive,&totalchecks);     
  sprintf(thislabel," (%d/%d active)",totalactive,totalchecks);
  XtVaSetValues(GlobalTotals, XmNlabelString, STRING(thislabel), NULL);

}





void select_layers_by_mgcp(Widget w, XtPointer userData, XtPointer callData)
{

  static Widget dialog;
  Widget rc,form,button;
  Arg resources[15];
  char temp[1000];
  int n=0,foundone=0,i;
  

  if(LAYER_MGCP_UP==1)
    {
      ResetWidget(dialog);
      return;
    }

  for(i=0;i<3;i++)
  {
    if(MGCPFound(i)==1)
	 {
	  foundone = 1;
	  break;
	 }
  }

  if(foundone==0)
  {
	  not_while_running(w,"This project does not contain any area features\n\
in the MGCP Landcover, Activity, or Other categories.",
		  1471,"No area data in MGCP categories",5);
	  return;
  }

  n=0;
  XtSetArg(resources[n],  XmNdeleteResponse, XmDESTROY); n++;

  dialog = XtCreatePopupShell("Select AREA layers by MGCP category",topLevelShellWidgetClass,w,resources,n);  
  
  rc = XtVaCreateManagedWidget
    (
     "XformWidget", xmPanedWindowWidgetClass, dialog,
     XmNrubberPositioning, False,
     XmNresizable,         True,
     XmNseparatorOn,       False,
     XmNsashHeight,        1,
     NULL
     );
  



  for(i=0;i<3;i++)
    {

      if(MGCPFound(i)==1)
	{
	  form = XtVaCreateWidget ("form17g", xmFormWidgetClass, rc,
				   XmNpaneMinimum,   25,
				   XmNpaneMaximum,   25,
				   XmNseparatorOn,   False,
				   XmNfractionBase,  100,  
				   NULL);      

	  sprintf(temp,"Select all Area \"%s\" layers",MGCPNAME[i]);
	  
	  button  = XtVaCreateManagedWidget("SCR4",xmPushButtonWidgetClass,form,
					    XmNlabelString,       STRING(temp),
					    XmNtopAttachment,     XmATTACH_FORM,
					    XmNbottomAttachment,  XmATTACH_FORM,
					    XmNrightAttachment,   XmATTACH_POSITION,
					    XmNrightPosition,     50,
					    XmNleftAttachment,    XmATTACH_POSITION,
					    XmNleftPosition,      1,
					    XmNtraversalOn,       False,
					    XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					    NULL
					    );
	  
	  XtAddCallback(button, XmNactivateCallback, layermgcp_onCallback, (XtPointer)i);
	  XtManageChild(button);
	  
	  sprintf(temp,"De-Select all Area \"%s\" layers",MGCPNAME[i]);
	  
	  button  = XtVaCreateManagedWidget("SCR4",xmPushButtonWidgetClass,form,
					    XmNlabelString,       STRING(temp),
					    XmNtopAttachment,     XmATTACH_FORM,
					    XmNbottomAttachment,  XmATTACH_FORM,
					    XmNrightAttachment,   XmATTACH_POSITION,
					    XmNrightPosition,     99,
					    XmNleftAttachment,    XmATTACH_POSITION,
					    XmNleftPosition,      51,
					    XmNtraversalOn,       False,
					    XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					    NULL
					    );
	  
	  XtAddCallback(button, XmNactivateCallback, layermgcp_offCallback, (XtPointer)i);
	  XtManageChild(button);
	  
	  XtManageChild(form);
	  
	}
    }

  
  
  form = XtVaCreateWidget ("form17h", xmFormWidgetClass, rc,
			   XmNpaneMinimum,   25,
			   XmNpaneMaximum,   25,
			   XmNseparatorOn,   False,
			   XmNfractionBase,  100,  
			   NULL);      
  
  button  = XtVaCreateManagedWidget("SCR4",xmPushButtonWidgetClass,form,
				    XmNlabelString,       STRING("Help"),
				    XmNtopAttachment,     XmATTACH_FORM,
				    XmNbottomAttachment,  XmATTACH_FORM,
				    XmNrightAttachment,   XmATTACH_POSITION,
				    XmNrightPosition,     33,
				    XmNleftAttachment,    XmATTACH_POSITION,
				    XmNleftPosition,      1,
				    XmNtraversalOn,       False,
				    XmNtranslations, XtParseTranslationTable ( translations_global ) ,
				    NULL
				    );
  
  XtAddCallback(button, XmNactivateCallback, layermgcphelpCallback, (XtPointer) NULL);
  XtManageChild(button);
  
  
  
  button  = XtVaCreateManagedWidget("SCR3",xmPushButtonWidgetClass,form,
				    XmNlabelString,       STRING("Cancel"),
				    XmNtopAttachment,     XmATTACH_FORM,
				    XmNbottomAttachment,  XmATTACH_FORM,
				    XmNrightAttachment,   XmATTACH_POSITION,
				    XmNrightPosition,     66,
				    XmNleftAttachment,    XmATTACH_POSITION,
				    XmNleftPosition,      33,
				    XmNtraversalOn,       False,
				    XmNtranslations, XtParseTranslationTable ( translations_global ) ,
				    NULL
				    );
  
  XtAddCallback(button, XmNactivateCallback, die_callback, (XtPointer) 46);
  XtManageChild(button);



  button  = XtVaCreateManagedWidget("SCR4",xmPushButtonWidgetClass,form,
				    XmNlabelString,       STRING("Done"),
				    XmNtopAttachment,     XmATTACH_FORM,
				    XmNbottomAttachment,  XmATTACH_FORM,
				    XmNrightAttachment,   XmATTACH_POSITION,
				    XmNrightPosition,     99,
				    XmNleftAttachment,    XmATTACH_POSITION,
				    XmNleftPosition,      66,
				    XmNtraversalOn,       False,
				    XmNtranslations, XtParseTranslationTable ( translations_global ) ,
				    NULL
				    ); 
  
  XtAddCallback(button, XmNactivateCallback, die_callback, (XtPointer) 47);
  XtManageChild(button);
  XtManageChild(form);


  XtManageChild(rc);
  MyPopup(dialog); 
  
    
  XtAddCallback(dialog,XmNdestroyCallback,ShellDeath,(XtPointer)119);
  
  LAYER_MGCP_UP = 1;

}










void toggle_view_all_bo(Widget widget,struct BOList *mydata,XtPointer call_data)
{
  int errnum     = mydata->errnum;
  int instance   = mydata->instance;
  int ob_num     = mydata->ob_num;
  Widget allwid  = mydata->allwid;
  Widget somewid = mydata->somewid;
  struct BOList *curr,*prev;
  int foundit;
 

  
  


  foundit = 0;
  curr = BOOnList;
  while(curr!=NULL)
    {
      if(
	 (curr->errnum  ==errnum)   &&
	 (curr->instance==instance) &&
	 (curr->ob_num  ==ob_num)
	 )
	{
	  foundit = 1;

	  if(BODEBUG==1)
	    {
	      printf("all found %d %d %d in list\n",ob_num,errnum,instance);
	    }
	  
	  if(curr->viewall==1)
	    {
	      if(BODEBUG==1)
		{
		  printf("found viewall was on\n");
		}

	      if(curr->selectcount==0)
		{
		  
		  if(curr==BOOnList)
		    {
		      BOOnList = BOOnList->next;
		      free(curr);
		      break; 
		    }
		  else
		    {
		      prev->next = curr->next;
		      free(curr);
		      break;
		    }
		}
	      else
		{
		  if(BODEBUG==1)
		    {
		      printf("NOT removing it because selectcount==%d\n",curr->selectcount);
		    }
		  curr->viewall = 0;
		}
	    }
	  else if(curr->viewsome==1)
	    {
	      curr->viewsome = 0;
	      curr->viewall  = 1;
	      XmToggleButtonSetState(curr->somewid,0,(Boolean)0);
	      XmToggleButtonSetState(curr->allwid, 1,(Boolean)0);
	    }
	  else 
	    {
	      curr->viewsome = 0;
	      curr->viewall  = 1;
	    }
	}
      prev = curr;
      curr = curr->next;
    }





  if(foundit==0)
    {
      curr = (struct BOList *)malloc(sizeof(struct BOList));
      curr->ob_num      = mydata->ob_num;
      curr->errnum      = mydata->errnum;
      curr->instance    = mydata->instance;
      curr->viewsome    = 0;
      curr->viewall     = 1;
      curr->allwid      = allwid;
      curr->somewid     = somewid;
      curr->selectcount = 0;
      curr->selectlist  = NULL;
      curr->speclist    = NULL;
      curr->next        = BOOnList;
      BOOnList          = curr;
    }


  if(BODEBUG==1)
    {
      printf("list is now:\n");
      curr = BOOnList;
      while(curr!=NULL)
	{
	  printf("ob %d err %d instance %d  all/some %d/%d\n",
		 curr->ob_num,curr->errnum,curr->instance,curr->viewall,curr->viewsome);
	  curr = curr->next;
	}
    }
}





void toggle_view_some_bo(Widget widget,struct BOList *mydata,XtPointer call_data)
{
  int errnum     = mydata->errnum;
  int instance   = mydata->instance;
  int ob_num     = mydata->ob_num;
  Widget allwid  = mydata->allwid;
  Widget somewid = mydata->somewid;
  struct BOList *curr,*prev;
  int foundit;


  


  foundit = 0;
  curr = BOOnList;
  while(curr!=NULL)
    {
      if(
	 (curr->errnum  ==errnum)   &&
	 (curr->instance==instance) &&
	 (curr->ob_num  ==ob_num)
	 )
	{
	  foundit = 1;

	  if(BODEBUG==1)
	    {
	      printf("found %d %d %d in list\n",ob_num,errnum,instance);
	    }

	  if(curr->viewsome==1)
	    {
	      if(BODEBUG==1)
		{
		  printf("found viewsome was on\n");
		}

	      if(curr->selectcount==0)
		{
		  
		  if(curr==BOOnList)
		    {
		      BOOnList = BOOnList->next;
		      free(curr);
		      break;
		    }
		  else
		    {
		      prev->next = curr->next;
		      free(curr);
		      break;
		    }
		}
	      else
		{
		  if(BODEBUG==1)
		    {
		      printf("NOT removing it because selectcount==%d\n",curr->selectcount);
		    }

		  curr->viewsome = 0;
		}
	    }
	  else if(curr->viewall==1)
	    {
	      curr->viewsome = 1;
	      curr->viewall  = 0;
	      XmToggleButtonSetState(curr->somewid,1,(Boolean)0);
	      XmToggleButtonSetState(curr->allwid, 0,(Boolean)0);
	    }
	  else 
	    {
	      curr->viewsome = 1;
	      curr->viewall  = 0;
	    }
	}
      prev = curr;
      curr = curr->next;
    }




  if(foundit==0)
    {
      curr = (struct BOList *)malloc(sizeof(struct BOList));
      curr->ob_num      = mydata->ob_num;
      curr->errnum      = mydata->errnum;
      curr->instance    = mydata->instance;
      curr->viewsome    = 1;
      curr->viewall     = 0;
      curr->allwid      = allwid;
      curr->somewid     = somewid;
      curr->selectcount = 0;
      curr->speclist    = NULL;
      curr->next        = BOOnList;
      BOOnList          = curr;
    }


  if(BODEBUG==1)
    {
      printf("list is now:\n");
      curr = BOOnList;
      while(curr!=NULL)
	{
	  printf("ob %d err %d instance %d  some/all %d/%d\n",
		 curr->ob_num,curr->errnum,curr->instance,curr->viewsome,curr->viewall);
	  curr = curr->next;
	}
    }

}






void FCGetGlobalTotals(int *totalchecks,int *totalconds, int *totalSchecks,int *totalSconds)
{
  int errnum,cloneindex;
  
  *totalconds   = 0;
  *totalchecks  = 0;
  *totalSchecks = 0;
  *totalSconds  = 0;
  
  
  for(errnum=1;errnum<=CONDITION_DEFINITIONS;errnum++)
    {
      if(ErrorLookup[errnum].totalBO > 0)
	{
	  *totalchecks = *totalchecks + 1;
	  *totalconds  = *totalconds  + ErrorLookup[errnum].totalBO;

	  if(ErrorLookup[errnum].filterout==1)
	    {
	      *totalSchecks = *totalSchecks + 1;
	      *totalSconds  = *totalSconds  + ErrorLookup[errnum].totalBO;
	    }
	}
    }	
  
  for(cloneindex=0;cloneindex<CLONE_DEFINITIONS;cloneindex++)
    {	
      if(CloneErrorLookup[cloneindex].totalBO > 0)
	{
	  *totalchecks = *totalchecks + 1;
	  *totalconds  = *totalconds  + CloneErrorLookup[cloneindex].totalBO;

	  if(CloneErrorLookup[cloneindex].filterout==1)
	    {
	      *totalSchecks = *totalSchecks + 1;
	      *totalSconds  = *totalSconds  + CloneErrorLookup[cloneindex].totalBO;
	    }
	}
    }
}







void FCGetTotal(int errnum, int *totalconds, int *totalchecks, int *totalSchecks, int *totalSconds)
{
  int cloneindex,clonenum;
  extern struct CheckGroupNames CGN[NUMCHECKGROUPS];
  
  *totalconds       = 0;
  *totalchecks      = 0;
  

  if(ErrorLookup[errnum].totalBO>0)
    {
      *totalchecks = *totalchecks + 1;
      *totalconds  = *totalconds  + ErrorLookup[errnum].totalBO;

      if(ErrorLookup[errnum].filterout==1)
	{
	  *totalSchecks = *totalSchecks + 1;
	  *totalSconds  = *totalSconds  + ErrorLookup[errnum].totalBO;
	}
    }
  

  for(clonenum=1;clonenum<=ErrorLookup[errnum].num_clones;clonenum++)
    {
      cloneindex = GetCloneIndex(clonenum,errnum);
      
      if(CloneErrorLookup[cloneindex].totalBO>0)
	{
	  *totalchecks = *totalchecks + 1;
	  *totalconds  = *totalconds  + CloneErrorLookup[cloneindex].totalBO;
	  
	  if(CloneErrorLookup[cloneindex].filterout==1)
	    {
	      *totalSchecks = *totalSchecks + 1;
	      *totalSconds  = *totalSconds  + CloneErrorLookup[cloneindex].totalBO;
	    }
	}
    }  
}






void FCGetTotals(int groupnum,int *totalchecks, int *totalconds,int *totalSchecks,int *totalSconds)
{
  int errnum,cloneindex,clonenum;
  extern struct CheckGroupNames CGN[NUMCHECKGROUPS];
  
    
  
  for(errnum=1;errnum<=CONDITION_DEFINITIONS;errnum++)
    {
      if(ErrorLookup[errnum].mygroup==groupnum)
	{
	  if(ErrorLookup[errnum].totalBO>0)
	    {
	      *totalchecks   = *totalchecks   + 1;
	      *totalconds    = *totalconds    + ErrorLookup[errnum].totalBO;

	      if(ErrorLookup[errnum].filterout==1)
		{
		  *totalSchecks = *totalSchecks + 1;
		  *totalSconds  = *totalSconds  + ErrorLookup[errnum].totalBO;
		}
	    }
	  
	  for(clonenum=1;clonenum<=ErrorLookup[errnum].num_clones;clonenum++)
	    {
	      cloneindex = GetCloneIndex(clonenum,errnum);
	      
	      if(CloneErrorLookup[cloneindex].totalBO>0)
		{
		  *totalchecks   = *totalchecks   + 1;
		  *totalconds    = *totalconds    + CloneErrorLookup[cloneindex].totalBO;

		  if(CloneErrorLookup[cloneindex].filterout==1)
		    {
		      *totalSchecks = *totalSchecks + 1;
		      *totalSconds  = *totalSconds  + CloneErrorLookup[cloneindex].totalBO;
		    }
		}
	    }
	}
    }  
}







void UpdateAllFCTotals()
{
  int totalchecks      = 0;
  int totalconds       = 0;
  int totalSchecks     = 0;
  int totalSconds      = 0;
  int i,errnum;
  char temp[1000];
  extern struct CheckGroupNames CGN[NUMCHECKGROUPS];



  



  FCGetGlobalTotals(&totalchecks,&totalconds,&totalSchecks,&totalSconds);
  
  if(totalchecks==1)
    {
      sprintf(temp," (%d/%d instance (%d/%d conditions) marked for filtering)",
	      totalSchecks,totalchecks,totalSconds,totalconds);
    }
  else
    {
      sprintf(temp," (%d/%d instances (%d/%d conditions) marked for filtering)",
	      totalSchecks,totalchecks,totalSconds,totalconds);
    }

  XtVaSetValues(FCGlobalTotals,XmNlabelString, STRING(temp),NULL);





  


  for(i=0;i<NUMCHECKGROUPS;i++)
    {
      totalconds   = 0;
      totalchecks  = 0;
      totalSchecks = 0;
      totalSconds  = 0;
      
      FCGetTotals(i,&totalchecks,&totalconds,&totalSchecks,&totalSconds);
      
      if(totalchecks>0)
	{
	  sprintf(temp,"%s (%d/%d instances (%d/%d conditions) marked for filtering)",
		  CGN[i].name,
		  totalSchecks,
		  totalchecks,
		  totalSconds,
		  totalconds);

	  XtVaSetValues(CGN[i].FCgrouplevel,XmNlabelString, STRING(temp),NULL);
	}
    }



  
  
  
  for(errnum=1;errnum<=CONDITION_DEFINITIONS;errnum++)
    {		  
      totalconds   = 0;
      totalchecks  = 0;
      totalSchecks = 0;
      totalSconds  = 0;
 
      FCGetTotal(errnum, &totalconds, &totalchecks, &totalSchecks, &totalSconds);
      
      if(totalconds==0)
	{
	  
	  continue;
	}
      
      sprintf(temp,"%s (%d/%d instances (%d/%d conditions) marked for filtering)",
	      ParseErrType(errnum),
	      totalSchecks,
	      totalchecks,
	      totalSconds,
	      totalconds);

      
      XtVaSetValues(ErrorLookup[errnum].FCchecktype,XmNlabelString, STRING(temp),NULL); 
    }

}





void check_filter_callback(Widget widget,MyData *mydata,XtPointer call_data)
{
  int errnum     = mydata->check_num;
  int cloneINDEX = mydata->clonenum;
  
  if(cloneINDEX==-1)
    {
      if(ErrorLookup[errnum].filterout==0)
	{
	  ErrorLookup[errnum].filterout=1;
	}
      else
	{
	  ErrorLookup[errnum].filterout=0;
	}
    }
  else
    {
      if(CloneErrorLookup[cloneINDEX].filterout==0)
	{
	  CloneErrorLookup[cloneINDEX].filterout=1;
	}
      else
	{
	  CloneErrorLookup[cloneINDEX].filterout=0;
	}
    }
  UpdateAllFCTotals();
}









void toggle_view_some(Widget widget,MyData *mydata,XtPointer call_data)
{
  int errnum     = mydata->check_num;
  int cloneINDEX = mydata->clonenum;
  
  if(cloneINDEX==-1)
    {
      if(ErrorLookup[errnum].viewsome==0)
	{
	  ErrorLookup[errnum].viewsome=1;

	  if(ErrorLookup[errnum].viewall==1)
	    {
	      XmToggleButtonSetState(ErrorLookup[errnum].viewallwid,0,(Boolean)0);
	      ErrorLookup[errnum].viewall = 0;
	    }
	}
      else
	{
	  ErrorLookup[errnum].viewsome=0;
	}
    }
  else
    {
      if(CloneErrorLookup[cloneINDEX].viewsome==0)
	{
	  CloneErrorLookup[cloneINDEX].viewsome=1;
	  
	  if(CloneErrorLookup[cloneINDEX].viewall==1)
	    {
	      XmToggleButtonSetState(CloneErrorLookup[cloneINDEX].viewallwid,0,(Boolean)0);
	      CloneErrorLookup[cloneINDEX].viewall = 0;
	    }
	}
      else
	{
	  CloneErrorLookup[cloneINDEX].viewsome=0;
	}
    }

  UpdateAllTotals();

}



void toggle_view_all(Widget widget,MyData *mydata,XtPointer call_data)
{
  int errnum     = mydata->check_num;
  int cloneINDEX = mydata->clonenum;

  if(cloneINDEX==-1)
    {
      if(ErrorLookup[errnum].viewall==0)
	{
	  ErrorLookup[errnum].viewall=1;

	  if(ErrorLookup[errnum].viewsome==1)
	    {
	      XmToggleButtonSetState(ErrorLookup[errnum].viewsomewid,0,(Boolean)0);
	      ErrorLookup[errnum].viewsome = 0;
	    }
	}
      else
	{
	  ErrorLookup[errnum].viewall=0;
	} 
    }
  else
    {
      if(CloneErrorLookup[cloneINDEX].viewall==0)
	{
	  CloneErrorLookup[cloneINDEX].viewall=1;

	  if(CloneErrorLookup[cloneINDEX].viewsome==1)
	    {
	      XmToggleButtonSetState(CloneErrorLookup[cloneINDEX].viewsomewid,0,(Boolean)0);
	      CloneErrorLookup[cloneINDEX].viewsome = 0;
	    }
	}
      else
	{
	  CloneErrorLookup[cloneINDEX].viewall=0;
	}
    }

  UpdateAllTotals();

}










void TogLODCallback(Widget widget,XtPointer client_data,XtPointer call_data)
{
  int index=(int)client_data;


  if(LODindex[LODindex_DYN[index].other_index].active==0)
    {
      LODindex[LODindex_DYN[index].other_index].active=1;
      if(LODDEBUG==1){printf("just turned LOD %d ON\n",index);}
    }
  else
    {
      LODindex[LODindex_DYN[index].other_index].active=0;
      if(LODDEBUG==1){printf("just turned LOD %d OFF\n",index);}
    }

  RebuildTopImage(5);

}



void TogDiscreteCallback(Widget widget,XtPointer client_data,XtPointer call_data)
{
  int index=(int)client_data;

  if(LODindex_DYN[index].do_discrete==0)
    {
      LODindex_DYN[index].do_discrete=1;
    }
  else
    {
      LODindex_DYN[index].do_discrete=0;
    }

  
  RebuildTopImage(5);

}



void TogOutlineCallback(Widget widget,XtPointer client_data,XtPointer call_data)
{
  int index=(int)client_data;

  if(LODindex_DYN[index].do_outline==0)
    {
      LODindex_DYN[index].do_outline=1;
    }
  else
    {
      LODindex_DYN[index].do_outline=0;
    }


}


void toggled(Widget widget,XtPointer client_data,XtPointer call_data)
{
  int type = (int)client_data;

  XmToggleButtonCallbackStruct *state = 
    (XmToggleButtonCallbackStruct *) call_data;
  
  
 
  if(type==1)
  {
    DOALLCELLS = state->set;           


    if(DOALLCELLS==1)
	{
      load_modules=1;	      
	} 
    else if(DOALLCELLS==0)
	{ 
      load_modules = 0;	      
	      	    
	  not_while_running(XtParent(widget),"You must now select a rectangular area on the map while\n\
in Localized Inspection mode before you may begin inspecting.",1426,"Select Regions Reminder",5);
	} 
  }
}


void revertCallback(Widget widget, XtPointer client_data, XtPointer callData)
{
  int i,j,k;
  int type=(int)client_data;
  extern Widget param_net_head,param2_net_head;
  extern int net_head_in_use,net_deader_head,net_deader_phead;


  if((type==6)||(type==7)||(type==8)||(type==9)) 
  {
	if(NetModifyMasterRun==1)
	{ 
      ResetMasterRun();
	} 
  }
  else
  {
    ResetMasterRun();
  }


  if(type==2)
    {
      set_cursor(mydisplay,mywindow,WATCH);
      if(widget!=NULL)
	{
	  set_cursor(XtDisplay(widget),XtWindow(widget),WATCH);
	}
      if((head_in_use==0)&&(deader_head==0))
	{
	  set_cursor(XtDisplay(param_head),XtWindow(param_head),WATCH);
	}
      else if((head_in_use==1)&&(deader_phead==0))
	{
	  set_cursor(XtDisplay(param2_head),XtWindow(param2_head),WATCH);
	}      
    }
  
  
  if((type==2)||(type==5))
    {
      RemoveAnnotations(0);
	 

      zerooutCallback((Widget)NULL, (XtPointer)1, (XtPointer) 0);
      ScrubALLEDCSMarkerLists(0,0); 
      
      
      GetRidOfAllClones(0);
      TurnOffAllChecks(0);
      RevertArrows(0);
      ScrubModelIndices(0,0);
      
      for(i=1; i<=CONDITION_DEFINITIONS; i++)
	  { 
	    if(IsNetCheck(i)==0)
		{ 
	      SetDefaultParticipants (i, 0, 0);
	      SetDefaultSensitivities(i, 0, 0);

	      for(j=0;j<NUM_C;j++)
		  {  
	        for(k=0;k<(3+1);k++)
			{  
	          ErrorLookup[i].AllConfigOn[k][j]       = 0;
	          ErrorLookup[i].SpecifiedConfigOn[k][j] = 1;
			}  
		  }  
		} 
	  } 
      
      for(i=1;i<=CONDITION_DEFINITIONS;i++)
	  {
	    if(IsNetCheck(i)==0)
		{
	     ErrorLookup[i].active           = 0;
	     ErrorLookup[i].scrollwidmade    = 0;
	     ErrorLookup[i].scrollwidmadeNET = 0;
	     ErrorLookup[i].filterout        = 0;
	     ErrorLookup[i].NETonoff         = cond_start_onoff;
	     ErrorLookup[i].VConoff          = cond_start_onoff;
	     ErrorLookup[i].onoff            = cond_start_onoff;
	     ErrorLookup[i].masteronoff      = -1;
	     ErrorLookup[i].viewall          = 0;
	     ErrorLookup[i].viewsome         = 0;
	     ErrorLookup[i].viewallNET       = 0;
	     ErrorLookup[i].viewsomeNET      = 0;
	     ErrorLookup[i].pos_list_made    = 0;
	     ErrorLookup[i].NETpos_list_made = 0;
	     ErrorLookup[i].numberNets       = 0;
	  
	     if( ErrorLookup[i].Annotation!=NULL)
		 { 
	      free(ErrorLookup[i].Annotation);
	      ErrorLookup[i].Annotation = NULL;
		 } 
		} 
	  }
      if(type==5)
	{
	  return;
	}
    }


  else if(type==3)
    {
      

      for(i=1;i<=CONDITION_DEFINITIONS;i++)
	  {
        if(IsNetCheck(i)==0)
		{ 
	      ErrorLookup[i].active   = 0;
	      ErrorLookup[i].viewall  = 0;
	      ErrorLookup[i].viewsome = 0;
		} 
	  }	
	  
      for(i=0;i<CLONE_DEFINITIONS;i++)
	  {
        if(IsNetCheck(CloneErrorLookup[i].CloneNumber)==0)
		{
	      CloneErrorLookup[i].active   = 0;
	      CloneErrorLookup[i].viewall  = 0;
	      CloneErrorLookup[i].viewsome = 0;
		}	 
	  }
    }
  else if(type==4)
    {
      
	  
      for(i=1;i<=CONDITION_DEFINITIONS;i++)
	  {
	    if(ErrorLookup[i].masteronoff==0)
		{
          printf("Abnormally setting %s to unfilled\n",ParseErrName(i));
          ErrorLookup[i].masteronoff = -1;
		} 
	  } 
    }
  else if(type==6)
  {
    
  }

  else if((type==7)||(type==9))
  {
	

    RemoveAnnotations(1); 

    zerooutCallback((Widget)NULL, (XtPointer)1, (XtPointer) 1);  


    ScrubALLEDCSMarkerLists(0,1); 


    GetRidOfAllClones(1);
    TurnOffAllChecks(1);
    RevertArrows(1);
    ScrubModelIndices(0,1);
    
	
    for(i=1; i<=CONDITION_DEFINITIONS; i++)
	{ 
      if(IsNetCheck(i)==1)
	  {
	    SetDefaultParticipants (i, 0, 0);
	    SetDefaultSensitivities(i, 0, 0);

	    for(j=0;j<NUM_C;j++)
		{ 
	      for(k=0;k<(3+1);k++)
		  { 
	        ErrorLookup[i].AllConfigOn[k][j]       = 0;
	        ErrorLookup[i].SpecifiedConfigOn[k][j] = 1;
		  } 
		} 
	  } 
	}

    for(i=1;i<=CONDITION_DEFINITIONS;i++)
	{ 
      if(IsNetCheck(i)==1)
	  {
	    ErrorLookup[i].active           = 0;
	    ErrorLookup[i].scrollwidmade    = 0;
	    ErrorLookup[i].scrollwidmadeNET = 0;
	    ErrorLookup[i].filterout        = 0;
	    ErrorLookup[i].NETonoff         = cond_start_onoff;
	    ErrorLookup[i].VConoff          = cond_start_onoff;
	    ErrorLookup[i].onoff            = cond_start_onoff;
	    ErrorLookup[i].masteronoff      = -1;
	    ErrorLookup[i].viewall          = 0;
	    ErrorLookup[i].viewsome         = 0;
	    ErrorLookup[i].viewallNET       = 0;
	    ErrorLookup[i].viewsomeNET      = 0;
	    ErrorLookup[i].pos_list_made    = 0;
	    ErrorLookup[i].NETpos_list_made = 0;
	    ErrorLookup[i].numberNets       = 0;
	   
	    if( ErrorLookup[i].Annotation!=NULL)
		{ 
	      free(ErrorLookup[i].Annotation);
	      ErrorLookup[i].Annotation = NULL;
		}  
	  }   
	}  
    if(type==9)
	{
	  return;
	}
  } 
  else if(type==8)
    {
      

      for(i=1;i<=CONDITION_DEFINITIONS;i++)
	  {
        if(IsNetCheck(i)==1)
		{ 
	      ErrorLookup[i].active   = 0;
	      ErrorLookup[i].viewall  = 0;
	      ErrorLookup[i].viewsome = 0;
		} 
	  }	
	  
      for(i=0;i<CLONE_DEFINITIONS;i++)
	  {
        if(IsNetCheck(CloneErrorLookup[i].CloneNumber)==1)
		{
	      CloneErrorLookup[i].active   = 0;
	      CloneErrorLookup[i].viewall  = 0;
	      CloneErrorLookup[i].viewsome = 0;
		}	 
	  }
    }
  else
  { 
    printf("revert callback got bad value %d\n",(int)client_data);
  }



  if((type==6)||(type==7)||(type==8))
  {
    

    if((net_head_in_use==0)&&(net_deader_head==0))
	{
      XtPopdown(param_net_head);
      XtDestroyWidget(param_net_head);
      net_deader_head=1;
      net_head_in_use=1;
      NETmodifyCallback(drawing_a,client_data,callData);
    }
    else if((net_head_in_use==1)&&(net_deader_phead==0))
    {
      XtPopdown(param2_net_head);
      XtDestroyWidget(param2_net_head);
      net_deader_phead=1;
      net_head_in_use=0;
      NETmodifyCallback(drawing_a,client_data,callData);
    }
  }
  else if(NO_EXE_REBUILD==0) 
  {
    

    if((head_in_use==0)&&(deader_head==0))
	{
      XtPopdown(param_head);
      XtDestroyWidget(param_head);
      deader_head=1;
      head_in_use=1;
      modifyCallback(drawing_a,client_data,callData);
    }
    else if((head_in_use==1)&&(deader_phead==0))
    {
      XtPopdown(param2_head);
      XtDestroyWidget(param2_head);
      deader_phead=1;
      head_in_use=0;
      modifyCallback(drawing_a,client_data,callData);
    }
  }

  set_cursor(mydisplay,mywindow,GOOD);
}





int GetTotalEntries()
{
  

  int total = 0;
  int i;
  
  for(i=1;i<=CONDITION_DEFINITIONS;i++)
    {      
      if(ErrorLookup[i].number>0)
	{
	  total = total + 1;
	}
    }
    
  for(i=0;i<CLONE_DEFINITIONS;i++)
    {	    
      if(CloneErrorLookup[i].number>0)
	{
	  total = total + 1;
	}
    }
  
  return total;
}



void SaveKeepDismiss()
{
  char filename[1000];
  int totalentries,errnum,instance,i,j,clonenum,totalfound=0,negnum=-1;
  long int fileposn;
  FILE *test;
  
  sprintf(filename,"%s2",lkname);
  
  
  printf("saving keep/dismiss (%s)\n",filename);
    
  
  test = fopen(filename,"wb");
  if(test==NULL)
    {      
      XBell(mydisplay,50);
      printf("error: cannot open file %s for write.  Condition report not saved\n",
	     filename);
      return;
    }
  

  totalentries = GetTotalEntries();


  if(totalentries<1)
    {
      
      fclose(test);
      return;
    }
  

  

  SEEIT_fwrite_int(&totalentries, test);
  
  fileposn = SzI + (totalentries*(SzI*3 + SzL));
  instance = 1;
  totalfound = 0;
  

  for(errnum=1;errnum<=CONDITION_DEFINITIONS;errnum++)
    {
      if(ErrorLookup[errnum].number>0)
	{
	  SEEIT_fwrite_int (&errnum,                     test);
	  SEEIT_fwrite_int (&instance,                   test);
	  SEEIT_fwrite_int (&ErrorLookup[errnum].number, test);
	  SEEIT_fwrite_long(&fileposn,                   test);
	  totalfound = totalfound + 1;

	  fileposn   = fileposn + (SzUC+SzI) * ErrorLookup[errnum].number;
	}
    }
  
  
  for(i=0;i<CLONE_DEFINITIONS;i++)
    {	    
      if(CloneErrorLookup[i].number>0)
	{
	  clonenum = GetCloneNumber(i,CloneErrorLookup[i].CloneNumber);
	  clonenum = clonenum + 1;

	  SEEIT_fwrite_int (&CloneErrorLookup[i].CloneNumber, test);
	  SEEIT_fwrite_int (&clonenum,                        test);
	  SEEIT_fwrite_int (&CloneErrorLookup[i].number,      test);
	  SEEIT_fwrite_long(&fileposn,                        test);
	  totalfound = totalfound + 1;

	  fileposn   = fileposn + (SzUC+SzI) * CloneErrorLookup[i].number;
	}
    }


  if(totalfound!=totalentries)
    {
      XBell(mydisplay,50);
      printf("error: totalfound!=totalentries %d %d.  Condition report not saved\n",
	     totalfound,totalentries);
      fclose(test);
      return;
    }


  for(errnum=1;errnum<=CONDITION_DEFINITIONS;errnum++)
    {
      if(ErrorLookup[errnum].number>0)
	  { 
	    for(i=0;i<ErrorLookup[errnum].number;i++)
		{ 
	     fwrite(&ErrorLookup[errnum].keepdismiss[i+1],SzUC,1,test);

		 if(ErrorLookup[errnum].groupnums==NULL)
		 {
           SEEIT_fwrite_int(&negnum,test);
		 }
		 else
		 {
           SEEIT_fwrite_int(&ErrorLookup[errnum].groupnums[i],test);
		 }
		}
	  } 
    }

  for(i=0;i<CLONE_DEFINITIONS;i++)
    {
      if(CloneErrorLookup[i].number>0)
	  { 
	    for(j=0;j<CloneErrorLookup[i].number;j++)
		{ 
	     fwrite(&CloneErrorLookup[i].keepdismiss[j+1],SzUC,1,test);

		 if(CloneErrorLookup[i].groupnums==NULL)
		 {
          SEEIT_fwrite_int(&negnum,test);
		 }
		 else
		 {
           SEEIT_fwrite_int(&CloneErrorLookup[i].groupnums[j],test);
		 }
		} 
	  } 
    }
  
  fclose(test);

}



char *ScrubName(char *toscrub)
{
  static char retval[5000];
  int len;

  sprintf(retval,"%s",toscrub);
  len = strlen(retval);
  
  if(len>3)
    {
      retval[len-3] = '\0';
    }

  return retval;
}



void clobberCallback(Widget w, XtPointer userData, XtPointer callData)
{  
  int i;
  
  char message[5000],command2[5000],condname[5000],targetfile[5000];
  FILE *test;
  FILE * lookup;
  Widget wid;
  int result, ZeroValue = 0,j,cloneindex,TtlConds;
 
  wid = (Widget) userData;
  
  i=1;
  

  set_cursor(mydisplay,mywindow,WATCH);
  if(w!=NULL)
    {
      set_cursor(XtDisplay(wid),XtWindow(wid),WATCH);
    }

  
  if((USE_DOS==0)||(SLASHTYPE==NONDOS_TYPE))
    {
      sprintf(command2,"cp \"%s\" \"%s\"",unsortlog,nsname);
    }
  else
    {
      sprintf(command2,"copy \"%s\" \"%s\"",unsortlog,nsname);
    }
    
  result = system(command2);
  
  if(result<0)
    {
      sprintf(message,"system copy command: %s\n\
returned %d\n (failure)",command2,result);
      
      not_while_running(w,message,1042,"File copy failed",1);

      set_cursor(mydisplay,mywindow,GOOD);
      if(w!=NULL)
	{
	  set_cursor(XtDisplay(wid),XtWindow(wid),ARROW);
	}
      return;
    }
  
  test = fopen(nsname,"r");
  if(test==NULL)
    {
      sprintf(message,"\nUnable to create file %s\n",nsname);
      not_while_running(drawing_a,message,1043,"Failed to save condition report ",5);

      set_cursor(mydisplay,mywindow,GOOD);
      if(w!=NULL)
	{
	  set_cursor(XtDisplay(wid),XtWindow(wid),ARROW);
	}
      return;
    }
  fclose(test);
  




  sprintf(targetfile,"%scondsummary.bin",outdirectory);

  if((USE_DOS==0)||(SLASHTYPE==NONDOS_TYPE))
    {
      sprintf(command2,"cp \"%s\" \"%s\"",targetfile,smname);
    }
  else
    {
      sprintf(command2,"copy \"%s\" \"%s\"",targetfile,smname);
    }
    
  result = system(command2);
  
  if(result<0)
    {
      sprintf(message,"system copy command: %s\n\
returned %d\n (failure)",command2,result);
      
      not_while_running(w,message,1042,"File copy failed",1);

      set_cursor(mydisplay,mywindow,GOOD);
      if(w!=NULL)
	{
	  set_cursor(XtDisplay(wid),XtWindow(wid),ARROW);
	}
      return;
    }
  
  test = fopen(smname,"r");
  if(test==NULL)
    {
      sprintf(message,"\nUnable to create file %s\n",nsname);
      not_while_running(drawing_a,message,1043,"Failed to save condition report ",5);

      set_cursor(mydisplay,mywindow,GOOD);
      if(w!=NULL)
	{
	  set_cursor(XtDisplay(wid),XtWindow(wid),ARROW);
	}
      return;
    }
  fclose(test);
  









  if((USE_DOS==0)||(SLASHTYPE==NONDOS_TYPE))
    {
      sprintf(command2,"cp \"%sobjsorted.bin\" \"%s\"",outdirectory,boname);
    }
  else
    {
      sprintf(command2,"copy \"%sobjsorted.bin\" \"%s\"",outdirectory,boname);
    }
  
  result = system(command2);
  




  if((USE_DOS==0)||(SLASHTYPE==NONDOS_TYPE))
    {
      sprintf(command2,"cp \"%scondreport.vr\" \"%s\"",outdirectory,vrname);
    }
  else
    {
      sprintf(command2,"copy \"%scondreport.vr\" \"%s\"",outdirectory,vrname);
    }
  
  result = system(command2);
  





  if((USE_DOS==0)||(SLASHTYPE==NONDOS_TYPE))
    {
      sprintf(command2,"cp \"%snetworkdata.bin\" \"%s\"",outdirectory,ntname);
    }
  else
    {
      sprintf(command2,"copy \"%snetworkdata.bin\" \"%s\"",outdirectory,ntname);
    }
  
  result = system(command2);
  









  


  lookup = fopen(lkname,"wb");
  if(lookup==NULL)
    {      
      sprintf(message,"\nUnable to create file %s\n",lkname);
      not_while_running(drawing_a,message,1044,"Failed to save condition report ",5);

      set_cursor(mydisplay,mywindow,GOOD);
      if(w!=NULL)
	{
	  set_cursor(XtDisplay(wid),XtWindow(wid),ARROW);
	}
      return;
    }
  


  
  ZeroValue = 0;

  TtlConds = CONDITION_DEFINITIONS + CLONE_DEFINITIONS;
  SEEIT_fwrite_int(&TtlConds, lookup);
  
  for(i=1;i<=CONDITION_DEFINITIONS;i++)
    {
      SEEIT_fwrite_int(&i, lookup); 
      SEEIT_fwrite_int(&ZeroValue, lookup);  
      
      SEEIT_fwrite_int (&ErrorLookup[i].number  ,lookup); 


      SEEIT_fwrite_int (&ErrorLookup[i].maxgroupid  ,lookup);
      SEEIT_fwrite_long(&ErrorLookup[i].fileposn,lookup); 
      
      for(j=1; j<=ErrorLookup[i].num_clones; j++)
	{
	  cloneindex = GetCloneIndex(j,i);
	  
	  SEEIT_fwrite_int(&i, lookup); 
	  SEEIT_fwrite_int(&j, lookup); 
	  
	  SEEIT_fwrite_int (&CloneErrorLookup[cloneindex].number, lookup); 
	  SEEIT_fwrite_int (&CloneErrorLookup[cloneindex].maxgroupid, lookup); 
	  SEEIT_fwrite_long(&CloneErrorLookup[cloneindex].fileposn,lookup);
	}
    }
  fclose(lookup);
      


  sprintf(condname,"%s",esname);

  sprintf(message,"Saved conditions to files:\n\
%s.[multiple extensions]",ScrubName(esname));
  savesettings(0,1);
  not_while_running(drawing_a,message,1045,"Successful Clobber",5);
  

  SaveKeepDismiss();

  UnsavedConditions = 0;
  unsavedignore     = 0;

  set_cursor(mydisplay,mywindow,GOOD);
  if(w!=NULL)
    {
      set_cursor(XtDisplay(wid),XtWindow(wid),ARROW);
    }
}




void CountIgnored(int *ignore_num, int *retain_num,char filename[], int silent)
{
  FILE *test;
  long int fileposn;
  int i,errnum,instance,number,totalretained=0,totalignored=0,totalentries,
	  totalnum=0,groupnum,lastgroupnum;
  unsigned char retained;

  *ignore_num = -1;
  *retain_num = -1;

  test = fopen(filename,"rb");
  if(test==NULL)
    {
      if(silent==0)
	{
	  XBell(mydisplay,50);
	  printf("error: cannot open file %s for read.\n",filename);
	}
      return;
    }


  SEEIT_fread_int(&totalentries,test); 
  
  for(i=0;i<totalentries;i++)
    {
      SEEIT_fread_int (&errnum,   test);
      SEEIT_fread_int (&instance, test);
      SEEIT_fread_int (&number,   test);
      SEEIT_fread_long(&fileposn, test);
      
      totalnum = totalnum + number;
    }

  lastgroupnum = -1;  

  for(i=0;i<totalnum;i++) 
    {
      retained = -1;
      
      fread(&retained,SzUC,1,test);
      SEEIT_fread_int (&groupnum,   test);


      if((retained!=0)&&(retained!=1))
	{
	  XBell(mydisplay,50);
	  printf("bad retained value %d\n",retained);
	  fclose(test);
	  *ignore_num = -1;
	  *retain_num = -1;
	  return;
	}
	  if(groupnum>-1)
	  {
		if(groupnum!=lastgroupnum)
		{
		  if((int)retained==1)
		  {
            totalretained = totalretained + 1;
		  }
		  else
		  {
           totalignored = totalignored + 1;
		  }

		  lastgroupnum = groupnum;
		}
	  }
	  else
	  {
	    if((int)retained==1)
		{ 
           totalretained = totalretained + 1;
		} 
	    else 
		{ 
          totalignored = totalignored + 1;
		} 
	  }
    }

  fclose(test);

  *retain_num = totalretained;
  *ignore_num = totalignored;
}



int getspace(int total)
{

  if(total<10)
    {
      return 1;
    }
  else  if(total<100)
    {
      return 2;
    }
  else  if(total<1000)
    {
      return 3;
    }
  else  if(total<10000)
    {
      return 4;
    }
  else  if(total<100000)
    {
      return 5;
    }
  else  if(total<1000000)
    {
      return 6;
    }
  else  if(total<10000000)
    {
      return 7;
    }
  else  if(total<100000000)
    {
      return 8;
    }
  else  if(total<1000000000)
    {
      return 9;
    }

  return 10;
}



void reallyloadCallback(Widget w, XtPointer userData, XtPointer callData)
{
  FILE *loadfile,*test,*lookup;
  double djunk;
  int i,ijunk,oldtotal=0,totalnets,total=0,j,ignore_num=0,retain_num=0,cloneindex,clonenum,
    TtlConds,checknum,space1,space2;
  char command[1000],command2[1000],command3[1000],unsortnewname[1000],sendname[1000],
    unsortname[1000],lookname[1000],message[1000],message2[1000],dbname[1000],esfile[1000];
  unsigned char endianness;

  
  
  

    
  



  zerooutCallback((Widget)NULL, (XtPointer)1, (XtPointer) 0);

  
  for(i=1;i<=CONDITION_DEFINITIONS;i++)
    {
      oldtotal = oldtotal + ErrorLookup[i].number;
    }
  
  
  

  
  sprintf(esfile,"%s",esname);
  loadfile = fopen(esfile,"rb");
  if(loadfile==NULL)
    {
      sprintf(message,"Could not open %s for read\n",esfile);
      
      not_while_running(w,message,1046,"Illegal Manuever",1);
      ABNORMAL_LOAD_UP = 0;
      return;
    }
  fread(&endianness,SzUC,1,loadfile);
  
  SEEIT_fread_double(&djunk,loadfile);
  SEEIT_fread_double(&djunk,loadfile);
  SEEIT_fread_int   (&ijunk,loadfile);
  SEEIT_fread_int   (&ijunk,loadfile);
  fread(&dbname[0],SzUC,ijunk,loadfile);
  fclose(loadfile);
  
  
  
  
  
  loadfile = fopen(nsname,"r");  
  if(loadfile==NULL)
    {
      sprintf(message,"Could not open %s fo read\n",nsname);
      
      not_while_running(w,message,1047,"Illegal Manuever",1);
      ABNORMAL_LOAD_UP = 0;
      return;
    }
  fclose(loadfile);
  




  
  for(i=1;i<=CONDITION_DEFINITIONS;i++)
    {
      ErrorLookup[i].viewall     = 0;
      ErrorLookup[i].viewsome    = 0;
      ErrorLookup[i].viewallNET  = 0;
      ErrorLookup[i].viewsomeNET = 0;
    }
  for(i=0;i<CLONE_DEFINITIONS;i++)
    {
      CloneErrorLookup[i].viewall     = 0;
      CloneErrorLookup[i].viewsome    = 0;
      CloneErrorLookup[i].viewallNET  = 0;
      CloneErrorLookup[i].viewsomeNET = 0;
    }


  


  if(oldtotal==0)  
    {
      
      
      
      
      sprintf(unsortnewname,"%serrtypes.bin",outdirectory);      
      sprintf(unsortname,"%s",nsname);
      sprintf(lookname,"%s",lkname);
      
      
      
      
      if((USE_DOS==0)||(SLASHTYPE==NONDOS_TYPE))
	{
	  sprintf(command,"cp \"%s\" \"%scondreport.lk\"",lkname,outdirectory);
	}
      else
	{
	  sprintf(command,"copy \"%s\" \"%s\"condreport.lk",lkname,outdirectory);
	}
      system(command);
      




      

      
      
      
      sprintf(unsortnewname,"%snotsorted.bin",outdirectory);
      if((USE_DOS==0)||(SLASHTYPE==NONDOS_TYPE))
	{
	  sprintf(command,"cp \"%s\" \"%s\"",unsortname,unsortnewname);
	}
      else
	{
	  sprintf(command,"copy \"%s\" \"%s\"",unsortname,unsortnewname);
	}
      system(command);
      
      
      test = fopen(unsortnewname,"r");
      if(test==NULL)
	{
	  sprintf(message,"Could not open %s for read\n",unsortnewname);
	  
	  not_while_running(w,message,1049,"Illegal Manuever",1);
	  ABNORMAL_LOAD_UP = 0;
	  return;
	}
      fclose(test);
      
      


      
      
  

      
      if((USE_DOS==0)||(SLASHTYPE==NONDOS_TYPE))
	{
	  sprintf(command,"cp \"%s2\" \"%scondreport.lk2\"",lkname,outdirectory);
	}
      else
	{
	  sprintf(command,"copy \"%s2\" \"%s\"condreport.lk2",lkname,outdirectory);
	}
      system(command);
      


      if((USE_DOS==0)||(SLASHTYPE==NONDOS_TYPE))
	{
	  sprintf(command,"cp \"%s\" \"%scondreport.vr\"",vrname,outdirectory);
	}
      else
	{
	  sprintf(command,"copy \"%s\" \"%s\"condreport.vr",vrname,outdirectory);
	}
      system(command);

printf("just did %s\n",command);
      

      

      if((USE_DOS==0)||(SLASHTYPE==NONDOS_TYPE))
	{
	  sprintf(command,"cp \"%s\" \"%scondreport.es\"",esname,outdirectory);
	}
      else
	{
	  sprintf(command,"copy \"%s\" \"%s\"condreport.es",esname,outdirectory);
	}
      system(command);
  
  




      if((USE_DOS==0)||(SLASHTYPE==NONDOS_TYPE))
	{
	  sprintf(command,"cp \"%s\" \"%scondreport.ns\"",nsname,outdirectory);
	}
      else
	{
	  sprintf(command,"copy \"%s\" \"%s\"condreport.ns",nsname,outdirectory);
	}
      system(command);
  
 






      
     if((USE_DOS==0)||(SLASHTYPE==NONDOS_TYPE))
	{
	  sprintf(command,"cp \"%s\" \"%scondreport.sm\""  ,smname,outdirectory);
	  sprintf(command2,"cp \"%s\" \"%scondsummary.bin\"",smname,outdirectory);
	}
      else
	{
	  sprintf(command,"copy \"%s\" \"%s\"condreport.sm"  ,smname,outdirectory);
	  sprintf(command2,"copy \"%s\" \"%s\"condsummary.bin",smname,outdirectory);
	}
      system(command);
      system(command2);
 



      
      if((USE_DOS==0)||(SLASHTYPE==NONDOS_TYPE))
	{
	  sprintf(command, "cp \"%s\" \"%scondreport.nt\""  ,ntname,outdirectory);
	  sprintf(command2,"cp \"%s\" \"%snetworkdata.bin\"",ntname,outdirectory);
	}
      else
	{
	  sprintf(command, "copy \"%s\" \"%s\"condreport.nt"  ,ntname,outdirectory);
	  sprintf(command2,"copy \"%s\" \"%s\"networkdata.bin",ntname,outdirectory);
	}
      system(command);
      system(command2);





      
      if((USE_DOS==0)||(SLASHTYPE==NONDOS_TYPE))
	{
	  sprintf(command, "cp \"%s\" \"%scondreport.bo\"", boname,outdirectory);
	  sprintf(command2,"cp \"%s\" \"%scondreport.bo2\"",boname,outdirectory);
	  sprintf(command3,"cp \"%s\" \"%sobjsorted.bin\"", boname,outdirectory);
	}
      else
	{
	  sprintf(command, "copy \"%s\" \"%s\"condreport.bo", boname,outdirectory);
	  sprintf(command2,"copy \"%s\" \"%s\"condreport.bo2",boname,outdirectory);
	  sprintf(command3,"copy \"%s\" \"%s\"objsorted.bin", boname,outdirectory);
	}
      system(command);
      system(command2);
      system(command3);



  
 




      
      
      lookup = fopen(lookname,"rb");
      if(lookup==NULL)
	{
	  printf("\ncould not open %s for read\n",lookname);
	  realquitCallback((Widget) NULL, (XtPointer) NULL, (XtPointer) NULL);
	  ExitWrapper(-1);
	}


      SEEIT_fread_int(&TtlConds, lookup);

      
      for(i=1;i<=TtlConds;i++)
	{
	  SEEIT_fread_int(&checknum, lookup);   
	  SEEIT_fread_int(&clonenum, lookup);   
	  
	  if(clonenum<1)
	    {
	      SEEIT_fread_int (&ErrorLookup[checknum].number  ,lookup); 
	      SEEIT_fread_int (&ErrorLookup[checknum].maxgroupid  ,lookup); 
	      SEEIT_fread_long(&ErrorLookup[checknum].fileposn,lookup); 
          total = total +   ErrorLookup[checknum].number;
	    }
	  else
	    {	
	      for(j=ErrorLookup[checknum].num_clones; j<clonenum; j++)
		{
		  
		  CloneCallback((Widget)NULL,(XtPointer)checknum,(XtPointer)999);
		}
	      

	      cloneindex = GetCloneIndex(clonenum,checknum);
	      
	      SEEIT_fread_int (&CloneErrorLookup[cloneindex].number, lookup); 
	      SEEIT_fread_int (&CloneErrorLookup[cloneindex].maxgroupid, lookup); 
	      SEEIT_fread_long(&CloneErrorLookup[cloneindex].fileposn,lookup);
          total = total +   CloneErrorLookup[cloneindex].number;
	    }
	}
      fclose(lookup);

    
      totalnets = GetNetworkCount(1,-1,-1);

      if(total>0)
	{
	  sprintf(sendname,"%s2",lkname);
	  CountIgnored(&ignore_num,&retain_num,sendname,0);
	}



      
      if((total+totalnets)==0)
	{
	  sprintf(message,"The selected condition report was empty.");
	}
      else
	{
	  sprintf(message,"Saved conditions loaded from files:\n\n\
%s.[multiple extensions]\n\n\
Project name these conditions were computed from:\n\
%s\n\n",ScrubName(unsortname),dbname);
	  
	  if(total>0)
	    {
	      if((ignore_num>=0)&&(retain_num>=0)&&(ignore_num<=total)&&(retain_num<=total))
		  {
		   space1 = getspace(total);
		  
		   if(retain_num>ignore_num)
		    {
		      sprintf(message2,"%.2lf",100.0*((double)retain_num/(double)total));
		    }
		   else
		    {
		      sprintf(message2,"%.2lf",100.0*((double)ignore_num/(double)total));
		    }
		  
		  space2 = strlen(message2);
		  		  
                  sprintf(message2,"Total conditions present : %*d\n\n",space1,total);
		  strcat(message,message2);

		  sprintf(message2,"Total retained conditions: %*d (%*.2lf%%)\n",
			  space1,retain_num,space2,100.0*((double)retain_num/(double)total));
		  strcat(message,message2);
		  
		  sprintf(message2,"Total ignored conditions : %*d (%*.2lf%%)\n\n",
			  space1,ignore_num,space2,100.0*((double)ignore_num/(double)total));
		  strcat(message,message2);

		  sprintf(message2,"Total networks present   : %*d\n",space1,totalnets);
		  strcat(message,message2);
		}
	      else
		{
		  
		  sprintf(message2,"Total conditions present : %d\n\n",total);
		  strcat(message,message2);

		  sprintf(message2,"Total networks present: %d\n",totalnets);
		  strcat(message,message2);
		}
	    }
	  else if(totalnets>0)
	    {
	      
	      sprintf(message2,"Total networks present: %d\n",totalnets);
	      strcat(message,message2);
	    }
	}


      sprintf(globalmessage,"%s",message);
  

     ABNORMAL_LOAD_UP = 0;
      
      
      MakeSen((Widget)NULL,(XEvent *)NULL,(String *)NULL,(int *)NULL);

      ResetBOoptions();


      return;
    }
  


  


}









void BadCR(char *badfile)
{
  char message[1000];
  
  sprintf(message,"Unable to load condition report:\n\
The file %s\n\
could not be opened.",badfile);
  
  not_while_running(drawing_a,message,1053,"Failed to load condition report",1);
  
}





int setoptionsabnormallyCallback(Widget w)
{
  int needrebuild=0;
  char message[500];
  FILE *testfile;
  extern void RebuildExeWindow(int nettype);

  SetESName();
  SetNSName();
  SetLKName();
  SetBOName();
  SetNTName();
  SetSMName();
  SetVRName();
  

  
  sprintf(message,"%s2",esname);  


  testfile = fopen(boname,"r");
  if(testfile==NULL)
    {
      BadCR(boname); 
      ABNORMAL_LOAD_UP = 0;
      return 0;
    }
  else
    {
      fclose(testfile);
    }


  testfile = fopen(ntname,"r");
  if(testfile==NULL)
    {
      BadCR(ntname); 
      ABNORMAL_LOAD_UP = 0;
      return 0;
    }
  else
    {
      fclose(testfile);
    }
   

  testfile = fopen(esname,"r");
  if(testfile==NULL)
    {
      BadCR(esname);  
      ABNORMAL_LOAD_UP = 0; 
      return 0;
    }
  else
    {
      fclose(testfile);
    }


  testfile = fopen(nsname,"r");
  if(testfile==NULL)
    {
      BadCR(nsname);  
      ABNORMAL_LOAD_UP = 0; 
      return 0;
    }
  else
    {
      fclose(testfile);
    }
  

  testfile = fopen(lkname,"r");
  if(testfile==NULL)
    {
      BadCR(lkname);  
      ABNORMAL_LOAD_UP = 0; 
      return 0;
    }
  else
    {
      fclose(testfile);
    }
  

  testfile = fopen(message,"r");
  if(testfile==NULL)
    {
      BadCR(message); 
      ABNORMAL_LOAD_UP = 0; 
      return 0;
    }
  else
    {
      fclose(testfile);
    }





  set_cursor(mydisplay,mywindow,WATCH);
  set_cursor(XtDisplay(w),XtWindow(w),WATCH);



  


  if(((head_in_use==0)&&(deader_head==0))||
      ((head_in_use==1)&&(deader_phead==0)))
  {
	
    needrebuild = 1;
  } 



  NO_EXE_REBUILD = 1; 

  revertCallback((Widget)NULL,(XtPointer)2,(XtPointer)2);


  set_cursor(mydisplay,mywindow,WATCH);
  set_cursor(XtDisplay(w),XtWindow(w),WATCH);

  loadExeOptionsfile(message,0);

  set_cursor(mydisplay,mywindow,WATCH);
  set_cursor(XtDisplay(w),XtWindow(w),WATCH);

  reallyloadCallback(w,(XtPointer)NULL,(XtPointer)NULL);

  set_cursor(mydisplay,mywindow,WATCH);
  set_cursor(XtDisplay(w),XtWindow(w),WATCH);

  NO_EXE_REBUILD = 0;

  

  if(needrebuild==1)
  {
    RebuildExeWindow(0);
  }



  ABNORMAL_LOAD_UP = 0;	

  
  

  
  return 1;
}



void BatchSaveResults()
{
  char command2[1000],message[1000];
  FILE * lookup;
  FILE *test;
  int i,j,result,TtlConds,cloneindex,ZeroValue = 0;


  
  


  
  if((USE_DOS==0)||(SLASHTYPE==NONDOS_TYPE))
    {
      sprintf(command2,"cp \"%s\" \"%s\"",unsortlog,nsname);
    }
  else
    {
      sprintf(command2,"copy \"%s\" \"%s\"",unsortlog,nsname);
    }
  
  result = system(command2);
  
  if((result<0)&&(batch_mode==0))
    {
      sprintf(message,"system copy command: %s\n\
returned %d\n (failure)\n",command2,result);

      printf("%s\n",message);
      ExitWrapper(-1);
      
    }
  
  
  
  if((USE_DOS==0)||(SLASHTYPE==NONDOS_TYPE))
    {
      sprintf(command2,"cp \"%scondsummary.bin\" \"%s\"",outdirectory,smname);
    }
  else
    {
      sprintf(command2,"copy \"%scondsummary.bin\" \"%s\"",outdirectory,smname);
    }
  
  result = system(command2);
  
  


  if((result<0)&&(batch_mode==0))
    {
      sprintf(message,"system copy command: %s\n\
returned %d\n (failure)\n",command2,result);
 
      printf("%s\n",message);
      ExitWrapper(-1);
    }
      




  





  
  
  if((USE_DOS==0)||(SLASHTYPE==NONDOS_TYPE))
    {
      sprintf(command2,"cp \"%sobjsorted.bin\" \"%s\"",outdirectory,boname);
    }
  else
    {
      sprintf(command2,"copy \"%sobjsorted.bin\" \"%s\"",outdirectory,boname);
    }
  
  result = system(command2);
  
  
  if((result<0)&&(batch_mode==0))
    {
      sprintf(message,"system copy command: %s\n\
returned %d\n (failure)\n",command2,result);
      
      printf("%s\n",message);
      ExitWrapper(-1);
    }
  




  
  
  if((USE_DOS==0)||(SLASHTYPE==NONDOS_TYPE))
    {
      sprintf(command2,"cp \"%snetworkdata.bin\" \"%s\"",outdirectory,ntname);
    }
  else
    {
      sprintf(command2,"copy \"%snetworkdata.bin\" \"%s\"",outdirectory,ntname);
    }
  
  result = system(command2);
  
  
  if((result<0)&&(batch_mode==0))
    {
      sprintf(message,"system copy command: %s\n\
returned %d\n (failure)\n",command2,result);
      
      printf("%s\n",message);
      ExitWrapper(-1);
    }
  









  
  
  
  test = fopen(nsname,"r");
  if(test==NULL)
    {
      sprintf(message,"\nUnable to create file %s\n\
command failed: %s\n",nsname,command2);
      
      printf("%s\n",message);
      ExitWrapper(-1);
    }
  fclose(test);
  
      

  
  
  
  
  lookup = fopen(lkname,"wb");
  if(lookup==NULL)
    {
      sprintf(message,"\nUnable to create file %s\n",lkname);
      if(batch_mode==1)
	{
	  printf("%s\n",message);
	  ExitWrapper(-1);
	}
    }
  
  
  ZeroValue = 0;
  
  
  TtlConds = CONDITION_DEFINITIONS + CLONE_DEFINITIONS;
  SEEIT_fwrite_int(&TtlConds, lookup);
  
  
  for(i=1;i<=CONDITION_DEFINITIONS;i++)
    {
      SEEIT_fwrite_int(&i, lookup); 
      SEEIT_fwrite_int(&ZeroValue, lookup);  
      
      SEEIT_fwrite_int (&ErrorLookup[i].number  ,lookup); 
      SEEIT_fwrite_int (&ErrorLookup[i].maxgroupid ,lookup);
      SEEIT_fwrite_long(&ErrorLookup[i].fileposn,lookup); 
      
      for(j=1; j<=ErrorLookup[i].num_clones; j++)
	{
	  cloneindex = GetCloneIndex(j,i);
	  
	  SEEIT_fwrite_int(&i, lookup); 
	  SEEIT_fwrite_int(&j, lookup); 
	  
	  SEEIT_fwrite_int (&CloneErrorLookup[cloneindex].number, lookup); 
	  SEEIT_fwrite_int (&CloneErrorLookup[cloneindex].maxgroupid, lookup); 
	  SEEIT_fwrite_long(&CloneErrorLookup[cloneindex].fileposn,lookup);
	}
    }
  fclose(lookup);
  
  
  savesettings(1,1);

  sprintf(lkname,"%scondreport.lk",indirectory);
  SaveKeepDismiss();

  printf("Saved condition report to %s\n",indirectory);
}




void LoadKeepDismiss()
{
  char filename[1000];
  FILE *test;
  int i,j,Ijunk,totalentries,cloneindex;
  int *errnums,*instances,*numbers;
  long int *fileposns;
  
  
  if(GetTotalEntries()==0)
    {
      
      return;
    }


  sprintf(filename,"%s2",lkname);

  test = fopen(filename,"rb");
  if(test==NULL)
    {      
      XBell(mydisplay,50);
      printf("error: cannot open file %s for read.\n",filename);
      return;
    }


  ResetKeepDismiss(1);


  SEEIT_fread_int(&totalentries,test);

  errnums   = (int *)     malloc(SzI * totalentries);
  instances = (int *)     malloc(SzI * totalentries);
  numbers   = (int *)     malloc(SzI * totalentries);
  fileposns = (long int *)malloc(SzL * totalentries);


  for(i=0;i<totalentries;i++)
    {
      SEEIT_fread_int (&errnums  [i], test);
      SEEIT_fread_int (&instances[i], test);
      SEEIT_fread_int (&numbers  [i], test);
      SEEIT_fread_long(&fileposns[i], test);
    }



  for(i=0;i<totalentries;i++)
    {
      fseek(test,fileposns[i],SEEK_SET);
      if(instances[i]==1)
	{
	  cloneindex = -1;
	}
      else
	{
	  cloneindex = GetCloneIndex(instances[i]-1,errnums[i]);
	}


      if(numbers[i]>0)
	{
	  for(j=0;j<numbers[i];j++)
	  {
	    if(cloneindex<0)
		{
	      fread(&ErrorLookup[errnums[i]].keepdismiss[j+1],SzUC,1,test);
		  SEEIT_fread_int(&Ijunk,test);
	    }
	    else
	    {
	      fread(&CloneErrorLookup[cloneindex].keepdismiss[j+1],SzUC,1,test);
		  SEEIT_fread_int(&Ijunk,test);
	    }
	  }
	}
    }

  if(totalentries>0)
    {
      free(errnums);
      free(instances);
      free(numbers);
      free(fileposns);
    }
}







void ResetKeepDismiss(int value)
{
  int i,j;

  

  for(i=1;i<=CONDITION_DEFINITIONS;i++)
    {
      if(ErrorLookup[i].keepdismiss!=NULL)
	{
	  free(ErrorLookup[i].keepdismiss);
	  ErrorLookup[i].keepdismiss = NULL;
	}
      
      if(ErrorLookup[i].number>0)
	{
	  ErrorLookup[i].keepdismiss = (unsigned char *)malloc(SzUC * (ErrorLookup[i].number+5));
	  
	  for(j=0;j<ErrorLookup[i].number+5;j++)
	    {
	      ErrorLookup[i].keepdismiss[j] = value;
	    }
	}
    }
  
  
  for(i=0;i<CLONE_DEFINITIONS;i++)
    {	    
      if(CloneErrorLookup[i].keepdismiss!=NULL)
	{
	  free(CloneErrorLookup[i].keepdismiss);
	  CloneErrorLookup[i].keepdismiss = NULL;
	}
      
      if(CloneErrorLookup[i].number>0)
	{
	  CloneErrorLookup[i].keepdismiss = (unsigned char *)malloc(SzUC * (CloneErrorLookup[i].number+5));

	  for(j=0;j<CloneErrorLookup[i].number+5;j++)
	    {
	      CloneErrorLookup[i].keepdismiss[j] = value;
	    }
	}
    }
}




void SetNumNets(int type)
{
  FILE *infile;
  int errnum,clonenumber,count,i,cloneindex;
  char testfile[1000],title[1000];
  

  if(type==1)
    {
      sprintf(testfile,"%scondreport.nt",outdirectory);
      infile = fopen(testfile,"rb");
      if(infile==NULL)
	{
	  printf("error: tried to read %s but it did not exist\n",testfile);
	  XBell(mydisplay,50);
	  NumNetsLoaded = 0;
	  return;
	}
    }
  else if(type==2)
    {
      
      
      sprintf(testfile,"%snetworkdata.bin",outdirectory);
      infile = fopen(testfile,"rb");
      if(infile==NULL)
	{
	  NetsPresent = 0;
	  return;
	}
      SEEIT_fread_int(&NetsPresent,infile);

      fclose(infile);
      return;
    }
  

  for(i=1;i<=CONDITION_DEFINITIONS;i++)
    {
      ErrorLookup[i].numberNets = 0;
    }
  for(i=0;i<CLONE_DEFINITIONS;i++)
    {
      CloneErrorLookup[i].numberNets = 0;
    }
  
  SEEIT_fread_int(&NumNetsLoaded,infile);



  


  for(i=0; i<NumNetsLoaded; i++)
    {
      SEEIT_fread_int(&errnum,     infile);
      SEEIT_fread_int(&clonenumber,infile);
      SEEIT_fread_int(&count,      infile);
      fread(&title[0],1000,1,      infile);

      if(clonenumber<0)
	{
	  XBell(mydisplay,50);
	  printf("\n\nread bad cnumber from network file %d\n",clonenumber);
	  break;
	}
      else if((errnum<1)||(errnum>CONDITION_DEFINITIONS))
	{
	  XBell(mydisplay,50);
	  printf("\n\nread bad errnum from network file %d should be [%d-%d]\n",
		 errnum,1,CONDITION_DEFINITIONS);
	  break;
	}
      else if(clonenumber==0)
	{
	  ErrorLookup[errnum].numberNets = count;
	}
      else
	{
	  cloneindex = GetCloneIndex(clonenumber,errnum);
	  CloneErrorLookup[cloneindex].numberNets = count;
	}
    }
  
  fclose(infile);
  
  
  if((NumNetsLoaded<0)||(NumNetsLoaded>100000))
    {
      XBell(mydisplay,50);
      printf("\n\nReset NumNetsLoaded to 0 because found %d\n",NumNetsLoaded);
      NumNetsLoaded = 0;
    }
}





void reporthandleCallback(Widget w, XtPointer userData, XtPointer callData)
{
  char message[5000], command2[5000],bo2name[5000];
  FILE * test;
  FILE * lookup;
  int i,j,n=0,result,type = (int)userData;
  int TtlConds,ZeroValue,cloneindex,NumberOfErrors=0;
  Arg args[20];
  XmString mystring;
  Widget dialog;
  extern int ADDNETS,NETS_ONLY;



  if(NGA_TYPE==1)
    {
      if(input_source==0)
	{
	  sprintf(message,"You must select a GAIT project\n\
before you can load or save conditions for it.");
	  not_while_running(w,message,1054,"Illegal Manuever",1);
	  return;
	}
    }
  else
    {
      if(input_source==0)
	{
	  sprintf(message,"You must select an input source data directory\n\
before you can load or save conditions to/from that directory.");
	  not_while_running(w,message,1055,"Illegal Manuever",1);
	  return;
	}
    }

    
  if(output_source==0)
    {
      sprintf(message,"You must select an output source data directory\n\
before you can load or save conditions.");
      not_while_running(w,message,1056,"Illegal Manuever",1);
      return;
    }




  if(type==3)  
    {

	  if(
		 (ADDNETS==0)   &&  
		 (NETS_ONLY==0)     
        )
	  {
		
	  }


      sprintf(esname, "%scondreport.es", outdirectory);
      sprintf(nsname, "%scondreport.ns", outdirectory);
      sprintf(lkname, "%scondreport.lk", outdirectory);
      sprintf(boname, "%scondreport.bo", outdirectory);
      sprintf(bo2name,"%scondreport.bo2",outdirectory);
      sprintf(smname, "%scondreport.sm", outdirectory);
      sprintf(ntname, "%scondreport.nt", outdirectory);
      sprintf(vrname, "%scondreport.vr", outdirectory);
    }
  else
    {
      if(batch_mode==0)
	{

	  SetESName();
	  
	  if(BadESName()==1)
	    {	      
	      not_while_running(w,"Invalid file name selected.\nThe filename must end in \".es\"",
				1371,"Bad file name",1);
	      return;
	    }
	  
	  SetNSName();
	  SetLKName();
	  SetBOName();
	  SetSMName();
	  SetNTName();
	  SetVRName();
	}
    }




  if(
     (type==1)||
     (type==3)
     )
    {
      
      if(type==1)
	{
	  if((NGA_TYPE==1)&&(input_source==0))
	    {
	      if(input_source==0)
		{
		  sprintf(message,"You must select a GAIT project\n\
before you can execute, which you must do before\n\
you can save the result of executions.");
		  not_while_running(w,message,1057,"Illegal Manuever",1);
		  return;
		}
	    }
	  else if(input_source==0)
	    {
	      sprintf(message,"You must select an input source data directory\n\
before you can execute, which you must do before\n\
you can save the result of executions.");
	      not_while_running(w,message,1058,"Illegal Manuever",1);
	      return;
	    }
	}
      
      if(output_source==0)
	{
	  sprintf(message,"You must select an output source data directory\n\
before you can execute, which you must do before\n\
you can save the result of executions.");
	  not_while_running(w,message,1059,"Illegal Manuever",1);
	  return;
	}





      
      NumberOfErrors = 0;
      
      for(i=1;i<=CONDITION_DEFINITIONS;i++)
	{
	  if(ErrorLookup[i].number>0)
	    {
	      NumberOfErrors = NumberOfErrors + ErrorLookup[i].number;
	    }
	}

      for(i=0;i<CLONE_DEFINITIONS;i++)
	{
	  if(CloneErrorLookup[i].number>0)
	    {
	      NumberOfErrors = NumberOfErrors + CloneErrorLookup[i].number;
	    }
	}
      

     SetNumNets(2); 


    
      



      i=1;


      if((type==1)&&(batch_mode==0))
	{
	  test = fopen(nsname,"r");
	  if(test!=NULL)
	    {
	      mystring = XmStringCreateLtoR("Saved results already\n\
exist.  Do you wish to overwrite them?\n",XmSTRING_DEFAULT_CHARSET);
	      
	      XtSetArg(args[n], XmNautoUnmanage,      True);                                       n++;
	      XtSetArg(args[n], XmNdialogTitle,  STRING("File Clobber Warning"));                  n++;
	      XtSetArg(args[n], XmNmessageString,mystring);                                        n++;
	      XtSetArg(args[n], XmNtranslations, XtParseTranslationTable ( translations_global )); n++;

	      
	      dialog = XmCreateWarningDialog (w, "File Clobber Warning", args, n);
	      XtUnmanageChild (XmMessageBoxGetChild (dialog, XmDIALOG_HELP_BUTTON));
	      
	      XtAddCallback (dialog, XmNokCallback, clobberCallback, w);

	      XtManageChild (dialog);
	      XtPopup  (XtParent(dialog), XtGrabNone);
	      XmStringFree(mystring);
	      fclose(test);
	      return;
	    }
	}




      set_cursor(mydisplay,mywindow,WATCH);
      if(w!=NULL)
	{
	  set_cursor(XtDisplay(w),XtWindow(w),WATCH);
	}



      if((USE_DOS==0)||(SLASHTYPE==NONDOS_TYPE))
	{
	  sprintf(command2,"cp \"%s\" \"%s\"",unsortlog,nsname);
	}
      else
	{
	  sprintf(command2,"copy \"%s\" \"%s\"",unsortlog,nsname);
	}

      result = system(command2);

      if((result<0)&&(batch_mode==0))
	{
	  sprintf(message,"system copy command: %s\n\
returned %d\n (failure)\n",command2,result);
	  
	  not_while_running(w,message,1060,"File copy failed",1);
	  
	  
	  set_cursor(mydisplay,mywindow,GOOD);
	  if(w!=NULL)
	    {
	      set_cursor(XtDisplay(w),XtWindow(w),ARROW);
	    }
	  return;
	}
      




      
      if((USE_DOS==0)||(SLASHTYPE==NONDOS_TYPE))
	{
	  sprintf(command2,"cp \"%scondsummary.bin\" \"%s\"",outdirectory,smname);
	}
      else
	{
	  sprintf(command2,"copy \"%scondsummary.bin\" \"%s\"",outdirectory,smname);
	}
      
      result = system(command2);




      if((result<0)&&(batch_mode==0))
	{
	  sprintf(message,"system copy command: %s\n\
returned %d\n (failure)\n",command2,result);
	  
	  not_while_running(w,message,1060,"File copy failed",1);
	  
	  
	  set_cursor(mydisplay,mywindow,GOOD);
	  if(w!=NULL)
	    {
	      set_cursor(XtDisplay(w),XtWindow(w),ARROW);
	    }
	  return;
	}
      



      if(type==1)
	{
	  
 
	  
	  if((USE_DOS==0)||(SLASHTYPE==NONDOS_TYPE))
	    {
	      sprintf(command2,"cp \"%scondreport.vr\" \"%s\"",outdirectory,vrname);
	    }
	  else
	    {
	      sprintf(command2,"copy \"%scondreport.vr\" \"%s\"",outdirectory,vrname);
	    }
	  
	  result = system(command2);
	  
	  
	  if((result<0)&&(batch_mode==0))
	    {
	      sprintf(message,"system copy command: %s\n\
returned %d\n (failure)\n",command2,result);
	      
	      not_while_running(w,message,1060,"File copy failed",1);
	      
	      
	      set_cursor(mydisplay,mywindow,GOOD);
	      if(w!=NULL)
		  { 
		  set_cursor(XtDisplay(w),XtWindow(w),ARROW);
		  }
 
	      return;
	     }

         UnsavedConditions = 0; 

		 unsavedignore = 0;
	  } 




      
      
      if((USE_DOS==0)||(SLASHTYPE==NONDOS_TYPE))
	{
	  sprintf(command2,"cp \"%sobjsorted.bin\" \"%s\"",outdirectory,boname);
	}
      else
	{
	  sprintf(command2,"copy \"%sobjsorted.bin\" \"%s\"",outdirectory,boname);
	}
      
      result = system(command2);




      if((result<0)&&(batch_mode==0))
	{
	  sprintf(message,"system copy command: %s\n\
returned %d\n (failure)\n",command2,result);
	  
	  not_while_running(w,message,1060,"File copy failed",1);

      
	  set_cursor(mydisplay,mywindow,GOOD);
	  if(w!=NULL)
	    {
	      set_cursor(XtDisplay(w),XtWindow(w),ARROW);
	    }
	  return;
	}





     
      
      if((USE_DOS==0)||(SLASHTYPE==NONDOS_TYPE))
	{
	  sprintf(command2,"cp \"%snetworkdata.bin\" \"%s\"",outdirectory,ntname);
	}
      else
	{
	  sprintf(command2,"copy \"%snetworkdata.bin\" \"%s\"",outdirectory,ntname);
	}
      
      result = system(command2);



      if((result<0)&&(batch_mode==0))
	{
	  sprintf(message,"system copy command: %s\n\
returned %d\n (failure)\n",command2,result);
	  
	  not_while_running(w,message,1060,"File copy failed",1);

      
	  set_cursor(mydisplay,mywindow,GOOD);
	  if(w!=NULL)
	    {
	      set_cursor(XtDisplay(w),XtWindow(w),ARROW);
	    }
	  return;
	}







      if(type==3)
	{
	  
	  
	  
	  SetNumNets(1);
	  
	  if((USE_DOS==0)||(SLASHTYPE==NONDOS_TYPE))
	    {
	      sprintf(command2,"cp \"%sobjsorted.bin\" \"%s\"",outdirectory,bo2name);
	    }
	  else
	    {
	      sprintf(command2,"copy \"%sobjsorted.bin\" \"%s\"",outdirectory,bo2name);
	    }
	  
	  result = system(command2);
	  
	  if((result<0)&&(batch_mode==0))
	    {
	      sprintf(message,"system copy command: %s\n\
returned %d\n (failure)\n",command2,result);
	      
	      not_while_running(w,message,1060,"File copy failed",1);
	      
      
	      set_cursor(mydisplay,mywindow,GOOD);
	      if(w!=NULL)
		{
		  set_cursor(XtDisplay(w),XtWindow(w),ARROW);
		}
	      return;
	    }
	}













      
      
      test = fopen(nsname,"r");
      if(test==NULL)
	{
	  sprintf(message,"\nUnable to create file %s\n\
command failed: %s\n",nsname,command2);

	  if(batch_mode==1)
	    {
	      printf("%s\n",message);
	      ExitWrapper(-1);
	    }

	  not_while_running(drawing_a,message,1061,"Failed to save condition report ",5);

      
	  set_cursor(mydisplay,mywindow,GOOD);
	  if(w!=NULL)
	    {
	      set_cursor(XtDisplay(w),XtWindow(w),ARROW);
	    }
	  
	  return;
	}
      fclose(test);
      
      

      
      


      lookup = fopen(lkname,"wb");
      if(lookup==NULL)
	{
	  sprintf(message,"\nUnable to create file %s\n",lkname);
	  if(batch_mode==1)
	    {
	      printf("%s\n",message);
	      ExitWrapper(-1);
	    }
	  not_while_running(drawing_a,message,1062,"Failed to save condition report ",5);

      
	  set_cursor(mydisplay,mywindow,GOOD);
	  if(w!=NULL)
	    {
	      set_cursor(XtDisplay(w),XtWindow(w),ARROW);
	    }
	  return;
	}


      ZeroValue = 0;

          
      TtlConds = CONDITION_DEFINITIONS + CLONE_DEFINITIONS;
      SEEIT_fwrite_int(&TtlConds, lookup);

      
      for(i=1;i<=CONDITION_DEFINITIONS;i++)
	{
	  SEEIT_fwrite_int(&i, lookup); 
	  SEEIT_fwrite_int(&ZeroValue, lookup);  
	  
	  SEEIT_fwrite_int (&ErrorLookup[i].number  ,lookup); 
	  SEEIT_fwrite_int (&ErrorLookup[i].maxgroupid ,lookup); 
	  SEEIT_fwrite_long(&ErrorLookup[i].fileposn,lookup); 
	  


	  for(j=1; j<=ErrorLookup[i].num_clones; j++)
	    {
	      cloneindex = GetCloneIndex(j,i);

	      SEEIT_fwrite_int(&i, lookup); 
	      SEEIT_fwrite_int(&j, lookup); 
	      
	      SEEIT_fwrite_int (&CloneErrorLookup[cloneindex].number, lookup); 
	      SEEIT_fwrite_int (&CloneErrorLookup[cloneindex].maxgroupid, lookup); 
	      SEEIT_fwrite_long(&CloneErrorLookup[cloneindex].fileposn,lookup);
	    }
	}
      fclose(lookup);

      
      savesettings(0,type);

      SaveKeepDismiss();

      set_cursor(mydisplay,mywindow,GOOD);
      if(w!=NULL)
	{
	  set_cursor(XtDisplay(w),XtWindow(w),ARROW);
	}
      
      if(type==1)
	{
	  if(DO_QAST==0)
	  {
	    sprintf(message,"Saved conditions to files:\n%s.[multiple extensions]",
		    ScrubName(esname));
	    if(batch_mode==1)
		{
	      printf("%s\n",message);
	      return;
	    }
	    not_while_running(drawing_a,message,1063,"Successful Save",5);
	  }
	}
      else
	{
	  
	  sprintf(esname,"%scondreport.es",indirectory);
	  sprintf(boname,"%scondreport.bo",indirectory);
	  sprintf(nsname,"%scondreport.ns",indirectory);
	  sprintf(lkname,"%scondreport.lk",indirectory);
	  sprintf(smname,"%scondreport.sm",indirectory);
	  sprintf(ntname,"%scondreport.nt",indirectory);
	  sprintf(vrname,"%scondreport.vr",indirectory);
	  return;
	}
    }


  
  else if((int)userData==2)
    {
      


      set_cursor(mydisplay,mywindow,WATCH);
      if(w!=NULL)
	{
	  set_cursor(XtDisplay(w),XtWindow(w),WATCH);
	}

      if(setoptionsabnormallyCallback(w)==0)
	{
	  set_cursor(mydisplay,mywindow,GOOD);
	  if(w!=NULL)
	    {
	      set_cursor(XtDisplay(w),XtWindow(w),ARROW);
	    }
	  return;
	}


      set_cursor(mydisplay,mywindow,WATCH);
      if(w!=NULL)
	{
	  set_cursor(XtDisplay(w),XtWindow(w),WATCH);
	}


      
      ResetBOoptions();

      

      LoadKeepDismiss();

      SetNumNets(1);
      
      not_while_running(drawing_a,globalmessage,1050,"Successful Load",5);
      
      
      set_cursor(mydisplay,mywindow,GOOD);
      if(w!=NULL)
	{
	  set_cursor(XtDisplay(w),XtWindow(w),ARROW);
	}
      	
      return;
    }
  else
    {
      printf("\n\nreporthandler exception: %d\n\n",(int)userData);
      XBell(mydisplay,50);
    }
  
}





 


void MakeBottomMessage()
{
  char help1[500];
  XmString message2;
  int SAVE_DTP;
 
  SAVE_DTP = DIGITS_TO_PRINT;
  DIGITS_TO_PRINT = 15;

  sprintf(help1,"%s Current extents: %s",
	  help3,
	  MakeUString((980.0*IRegionSize)/xunits,(780.0*IRegionSize)/yunits));
  
  message2 = XmStringCreate (help1, "TAG5");
  XtVaSetValues(TEXT_HELP,XmNfontList, fontlist,NULL);
  XtVaSetValues(TEXT_HELP,XmNlabelString,message2,NULL);
  XmStringFree(message2);

  DIGITS_TO_PRINT = SAVE_DTP;
}



void GetLoadModules(int *lowx, int *highx, int *lowy, int *highy)
{
  

  *lowx = (int)(llx_zoom/RegionSize);
  *lowy = (int)(lly_zoom/RegionSize);

  *highx = (int)(urx_zoom/RegionSize);
  *highy = (int)(ury_zoom/RegionSize);

  
  if(*lowx  < MinXindex){*lowx  = MinXindex;}
  if(*lowy  < MinYindex){*lowy  = MinYindex;}
  if(*highx > MaxXindex){*highx = MaxXindex;}
  if(*highy > MaxYindex){*highy = MaxYindex;}
}





void ZeroOutPixArray()
{
  int x,y;

  for(x=0;x<1050;x++)
    {
      for(y=0;y<900;y++)
	{
	  PixArray[x][y] = 0;
	}
    }
}




void ResetZoom()
{
  ABORT_ZOOM = 0;
}


int AbortZoom()
{
  long int ThisTime;
  static long int last_redraw=0;

  
  ThisTime = time(NULL);
  
  if((ThisTime-last_redraw)>0)
    {
      real_periodic_redraw();
      last_redraw = ThisTime;
    }

  if(ABORT_ZOOM>0)
    {
      return 1;
    }

  return 0;
}



int AbortConditionDraw()
{
  long int ThisTime;
  static long int last_redraw=0;

  if(DRAWING_ERRORS==0)
    {
      return 0;
    }
  
  ThisTime = time(NULL);
  
  if((ThisTime-last_redraw)>0)
    {
      real_periodic_redraw();
      last_redraw = ThisTime;
    }

  if(ABORT_ZOOM>0)
    {
      ABORT_ZOOM = 0;
      return 1;
    }

  return 0;
}






void SaveCleanPixmap()
{
  CleanScreen();
  XCopyArea (mydisplay, pixmap, clean_pixmap, mygc, 0, 0, width, height, 0, 0);
}


void TransferCleanPixmap()
{
  CleanScreen();
  XCopyArea (mydisplay, clean_pixmap, pixmap,   mygc,  0, 0, width, height, 0, 0);
  XCopyArea (mydisplay, pixmap,  mywindow, mygc,  0, 0, width, height, 0, 0);
  CleanScreen();
}




void MakePixmap3()
{
  XCopyArea (mydisplay, pixmap, pixmap3, mygc, 0, 0, width, height, 0, 0);
}



double CheckRange(double newvalue,int min,int max,int slidesize)
{
  if(newvalue<min)
  {
	newvalue = min;
  }
  if(newvalue>(max-slidesize))
  {
	newvalue = max-slidesize;
  }
  return newvalue;
}


void SetScrollBarToValues(double xset, double yset)
{
  int min,max,slidesize,increment,Pincrement;
  double newvalue;
  extern Widget draw_h_scroll;

  XtVaGetValues(draw_h_scroll,
		XmNminimum,      &min,
		XmNmaximum,      &max,
		XmNsliderSize,   &slidesize,
		XmNincrement,    &increment,
		XmNpageIncrement,&Pincrement,
		NULL);
 
  
  newvalue = xset*( (max-slidesize)-min );

   
  newvalue = CheckRange(newvalue,min,max,slidesize);
  
  XmScrollBarSetValues(draw_h_scroll,
		       (int)newvalue,
		       slidesize,
		       30,
		       Pincrement,
		       1);

  XtVaGetValues(vert_scroll[DRAWING_A_SCROLL],
		XmNminimum,      &min,
		XmNmaximum,      &max,
		XmNsliderSize,   &slidesize,
		XmNincrement,    &increment,
		XmNpageIncrement,&Pincrement,
		NULL);
  
  
  newvalue = (1.0-yset)*( (max-slidesize)-min );

   
  newvalue = CheckRange(newvalue,min,max,slidesize);

  XmScrollBarSetValues(vert_scroll[DRAWING_A_SCROLL],
		       (int)newvalue,
		       slidesize,
		       30,
		       Pincrement,
		       1);

}




void TurnOnAll(int setval, int *sen1, int *sen2, int set1, int set2)
{
  int i;

  
  
  
  
  *sen1 = XtIsSensitive(toolbar[0]);
  *sen2 = XtIsSensitive(toolbar[1]);
  
  
  for(i=0;i<TOOLNUM;i++) 
    {
      if((i!=TOOLBAR_CLASS)&&(i!=9))
	{
	  
	  XtSetSensitive(toolbar[i],setval);
	}
    } 
  
  
  
  XtSetSensitive(cascade[0],setval); 
  XtSetSensitive(cascade[1],setval); 
  XtSetSensitive(cascade[2],setval); 
  XtSetSensitive(cascade[3],setval); 
  XtSetSensitive(cascade[4],setval); 
  XtSetSensitive(cascade[5],setval); 
  
  
  if(setval==1)
    {
      XtSetSensitive(toolbar[0],set1);
      XtSetSensitive(toolbar[1],set2);
    }
  

  if((setval==0)||(NOT_ZOOMED==1))
  {
    
	set_shift(-1);
  }
  else
  {
    
	set_shift(10);
  }

  
  if(NOT_ZOOMED==1)
  { 
    XtSetSensitive(toolbar[6],False);      
  }

}



void ZeroPixmapFlags()
{
  int i;

  for(i=0;i<NUM_DRAWING_PIXMAPS-PIXMAP_MODIFIER;i++)
    {
      LODS_USED[i] = 0;
    }
}



void FillInRenderOrder()
{
  int layer_num;

  

  for(layer_num=0;layer_num<NumLODbands;layer_num++)
    {
      LODindex[LODindex_DYN[layer_num].other_index].other_index = layer_num;
    }
}



void DrawAll()
{
  int lx,ux,ly,uy;
  int sen1,sen2,ijunk;

  sen1 = 0;
  sen2 = 0;



  FillInRenderOrder();

  TurnOnAll(0,&sen1,&sen2,0,0);

  GetLoadModules(&lx,&ux,&ly,&uy);
  
  


  circlecount       = 0;
  linecount         = 0;
  polycount         = 0;
  gridcount         = 0;
  DRAW_ONLY         = 1;
  ABORT_ZOOM        = 0;


  StartTime = time(NULL);  


  set_cursor(mydisplay,mywindow,WATCH);
  BUSY=1;


  ZeroOutPixArray();



  

  ClearBitmaps(0);       
  ClearDrawingPixmaps(0);
  ZeroPixmapFlags();    


  POINT_LABELS_DRAWN = 0;
  LINE_LABELS_DRAWN = 0;
  AREA_LABELS_DRAWN = 0;
  GRID_LABELS_DRAWN = 0;
  RememberLabelPixel(10000,10000);

  DrawRegionContent(lx, ux, ly, uy);

  RememberLabelPixel(10000,10000);
  POINT_LABELS_DRAWN = 0;
  LINE_LABELS_DRAWN = 0;
  AREA_LABELS_DRAWN = 0;
  GRID_LABELS_DRAWN = 0;

  FlushMainScreen(!(
	  DrawUserGrid  + DrawOneDegreeGrid  + DrawHalfDegreeGrid  + DrawQuarterDegreeGrid+
	  DrawUserGridL + DrawOneDegreeGridL + DrawHalfDegreeGridL + DrawQuarterDegreeGridL));

  SaveCleanPixmap();  


  ShowRegionMarkers();


  if(info_window_up==1)
    {
      
      choose_specific_info((Widget)NULL,(XtPointer)NULL,(XtPointer)0);
    }


  cleanse_events();
  DrawTopGrid();
  

  if(ABORT_ZOOM==0)  
    {
      MyDrawErrors();
    }



  if(ZOOM_MODE==1)
    {
      MakeBottomMessage();
    }


  
  ClearBitmaps(0);        
  ClearDrawingPixmaps(0); 
  ZeroPixmapFlags();      


  OldFlushScreen(!(
	  DrawUserGrid  + DrawOneDegreeGrid  + DrawHalfDegreeGrid  + DrawQuarterDegreeGrid+
	  DrawUserGridL + DrawOneDegreeGridL + DrawHalfDegreeGridL + DrawQuarterDegreeGridL));

  SetColorRight();

  set_cursor(mydisplay,mywindow,GOOD);
  DRAW_ONLY = 0;
  BUSY=0;
  ABORT_ZOOM = 0;


  TurnOnAll(1,&ijunk,&ijunk,sen1,sen2);
}





void SetLabelsToDefault(int set)
{
  int i;
  char thestr[100];


  if(set==1)
    {
      CURRENT_ZOOM = 0;
      SAVED_VIEWS = 0;
    }


  for(i=0;i<ZOOM_REMEMBER_NUM;i++)
    {
      if(i==0)
	{
	  sprintf(thestr,"Restore current/latest zoom");
	}
      else if(i==1)
	{
	  sprintf(thestr,"Restore view from 1 zoom ago");
	}
      else
	{
	  sprintf(thestr,"Restore view from %d zooms ago",i);
	}
      
      XtVaSetValues(stackwids[i],XmNlabelString,STRING(thestr),NULL);
      XtSetSensitive(stackwids[i],False);
    }
}







void SetLabels()
{
 
  if(CURRENT_ZOOM==SAVED_VIEWS-1)
    {
      
      XtSetSensitive(toolbar[0],False);
    }
  else
    {
      
      XtSetSensitive(toolbar[0],True);
    }


  if(CURRENT_ZOOM==0)
    {
      
      XtSetSensitive(toolbar[1],False);
    }
  else
    {
      
      XtSetSensitive(toolbar[1],True);
    }

}





void SAVE_ZOOM_STATE(double xscroll,double yscroll)
{
  int i;


  



  if((SAVE_UNI[CURRENT_ZOOM]<0)&&(NOT_ZOOMED==1))
    {
      
      return;
    }






  

  for(i=CURRENT_ZOOM;i<=ZOOM_REMEMBER_NUM;i++)
    {
      SAVE_LLX[i-CURRENT_ZOOM] = SAVE_LLX[i];
      SAVE_LLY[i-CURRENT_ZOOM] = SAVE_LLY[i];
      SAVE_URX[i-CURRENT_ZOOM] = SAVE_URX[i];
      SAVE_URY[i-CURRENT_ZOOM] = SAVE_URY[i];
      SAVE_UNI[i-CURRENT_ZOOM] = SAVE_UNI[i];
      SAVE_XSB[i-CURRENT_ZOOM] = SAVE_XSB[i];
      SAVE_YSB[i-CURRENT_ZOOM] = SAVE_YSB[i];
    }
  SAVED_VIEWS = SAVED_VIEWS - CURRENT_ZOOM;


  CURRENT_ZOOM = 0;


  for(i=ZOOM_REMEMBER_NUM;i>0;i--)
    {
      SAVE_LLX[i] = SAVE_LLX[i-1];
      SAVE_LLY[i] = SAVE_LLY[i-1];
      SAVE_URX[i] = SAVE_URX[i-1];
      SAVE_URY[i] = SAVE_URY[i-1];
      SAVE_UNI[i] = SAVE_UNI[i-1];
      SAVE_XSB[i] = SAVE_XSB[i-1];
      SAVE_YSB[i] = SAVE_YSB[i-1];
    }

  
  SAVED_VIEWS++;
  if(SAVED_VIEWS>ZOOM_REMEMBER_NUM)
    {
      SAVED_VIEWS = ZOOM_REMEMBER_NUM;
    }
  
  
  if(NOT_ZOOMED==1)
    {
      SAVE_UNI[0] = -1; 
    }
  else
    {
      SAVE_LLX[0] = llx_zoom;
      SAVE_LLY[0] = lly_zoom;
      SAVE_URX[0] = urx_zoom;
      SAVE_URY[0] = ury_zoom;
      SAVE_UNI[0] = xunits;
      SAVE_XSB[1] = xscroll;  
      SAVE_YSB[1] = yscroll;
    }



  


  SetLabelsToDefault(0); 

  SetLabels();



  

  for(i=0;i<SAVED_VIEWS;i++)
    {
      XtSetSensitive(stackwids[i],True);
    }
  for(i=SAVED_VIEWS;i<ZOOM_REMEMBER_NUM;i++)
    {
      XtSetSensitive(stackwids[i],False);
    }




  if(SAVED_VIEWS>1)
    {
      XtSetSensitive(toolbar[0],True);
    }
  else
    {
      XtSetSensitive(toolbar[0],False);
    }

}






void ZoomStackCallback(Widget w, XtPointer userData, XtPointer callData)
{
  int stacknum = (int)userData;
  String temp="zoom_out";
  int junk;
  int temp_mode=0;


  


  if(SAVE_UNI[stacknum]>0)
    {
      llx_zoom = SAVE_LLX[stacknum];
      lly_zoom = SAVE_LLY[stacknum];
      urx_zoom = SAVE_URX[stacknum];
      ury_zoom = SAVE_URY[stacknum];
      xunits   = SAVE_UNI[stacknum];
      yunits   = xunits;
      NOT_ZOOMED = 0;
    }
  
  



  

  MakePixmap3();
  
  set_color (drawing_a, "White",(XtPointer)NULL);

  XFillRectangle (XtDisplay (drawing_a), mywindow, mygc, 0, 0, width, height);
  XFillRectangle (XtDisplay (drawing_a), pixmap, mygc, 0, 0, width, height);
  
  if(GRID==1)
    {
      DrawGrid();
    }
  
  XFlush(mydisplay);
  SetColorRight();


  CURRENT_ZOOM = stacknum;
  SetLabels();



  if(SAVE_UNI[stacknum]<0)
    {
      
      
      
      

      if(ZOOM_MODE==0)
	{
	  if(PROFILE_MODE==1)   {PROFILE_MODE = 0; temp_mode = 1;}
	  else if(FAN_MODE==1)  {FAN_MODE     = 0; temp_mode = 2;}
	  else if(INFO_MODE==1) {INFO_MODE    = 0; temp_mode = 3;}
	  else if(DIST_MODE==1) {DIST_MODE    = 0; temp_mode = 4;}
	  else if(CHECK_MODE==1){CHECK_MODE   = 0; temp_mode = 5;}
	  else if(PAN_MODE==1)  {PAN_MODE     = 0; temp_mode = 6;}
	  else if(LOS==1)       {LOS          = 0; temp_mode = 7;}
 	  ZOOM_MODE=1;
	}
 
      junk = 1;
      ADD_HIST = 0;
      draw(drawing_a,NULL,&temp,&junk);
      ADD_HIST = 1;


      if(temp_mode>0)
	{
	  if(temp_mode==1)     {PROFILE_MODE = 1;}
	  else if(temp_mode==2){FAN_MODE     = 1;}
	  else if(temp_mode==3){INFO_MODE    = 1;}
	  else if(temp_mode==4){DIST_MODE    = 1;}
	  else if(temp_mode==5){CHECK_MODE   = 1;}
	  else if(temp_mode==6){PAN_MODE     = 1;}
	  else if(temp_mode==7){LOS          = 1;}
	  ZOOM_MODE=0;
	}
    }
  else
    {
      DrawAll();
    }

  set_shift(10);
  
  if(ZOOM_MODE==1)
    {
      MakeBottomMessage();
    }  



  if(NOT_ZOOMED==1)
    {
      if(PAN_MODE==1)
	{
	  
	  modeCallback(drawing_a,(XtPointer)1,(XtPointer)1);
	}
      XtSetSensitive(modes[1],False);
    }
  else
    {
      XtSetSensitive(modes[1],True);
    }

  SetScrollBarToValues(SAVE_XSB[stacknum],SAVE_YSB[stacknum]);
}







void AddSilentStuff(char *message, int type)
{ 
  

  
  static char save1[1000];
  char lastmessage[2000],silentname[1000];

  

  sprintf(silentname,"%sbatchsilent.txt",importoutputdir);
  silentfile = fopen(silentname,"wt"); 
  if(silentfile==NULL)
    {
      printf("could not open %s for write\n",silentname);
      return;
    }



  
  if(type==1)
    {
      sprintf(lastmessage,"%s\n*****\n",message);
    }
  else if(type==2)
    {
      sprintf(save1,"%s",message);
      sprintf(lastmessage,"%s\n*****\n",save1);
    }
  else if(type==3)
    {
      sprintf(lastmessage,"%s\n*****\n%s\n*****\n",save1,message);
    }
  else
    {
      printf("unexpected type %d to Add SilentS\n",type);
      ExitWrapper(-1);
    }
  
  fprintf(silentfile,"%s\n",lastmessage);
  fclose(silentfile);
}


void update_shape_import(char *allshapes,char *curr_file,int files_done, 
			 int dbfdone,int dbftotal,
			 int points_done,int linears_done,int areals_done,
			 unsigned int gptsdone,
			 int DONE, int extra_type,int extra1, int extra2, int badstuff,
			 int badstuff2,int nullshapes, int zeroparts, int baddbf)
{
  char message[2000];
  char extrastr[1000];
  char extrastr2[1000];
  char temp[1000],tempjunk[1000];
  XmString t;
  static long int last_redraw=0,ThisTime;
  static int save_files_done;
  static int save_dbfdone;
  static int save_dbftotal;
  static char save_allshapes[3000];
  static char save_curr_file[3000];
  static char savefile      [3000];
  static char saveallshapes [3000];
  int specialredraw;
  
  
  

  
  specialredraw = 0;
  
  sprintf(savefile,"%s",curr_file);
  
  
  
  sprintf(saveallshapes,"%s",allshapes);
  




  if(files_done>=0)
    {
      save_files_done = files_done;
      save_dbfdone    = dbfdone;
      save_dbftotal   = dbftotal;	  
      sprintf(save_allshapes,"%s",allshapes);
      sprintf(save_curr_file,"%s",curr_file);
    }

  
  if(DONE==1)
    {
      

      EXTRACT_POINTS_DONE  = points_done;
      EXTRACT_LINEARS_DONE = linears_done;
      EXTRACT_AREALS_DONE  = areals_done;
      EXTRACT_GRIDS_DONE   = gptsdone;
      EXTRACT_EXTRA_STR[0] = '\0';
      EXTRACT_STARTTIME    = StartTime;
      sprintf(EXTRACT_TIME,"%s",PrintTime(StartTime));


	  if(zeroparts>0)
	  {
	   sprintf(tempjunk,"Total features ignored due to having 0 parts: %d\n",zeroparts);
	   strcat(EXTRACT_EXTRA_STR,tempjunk);
	  }



      if(badstuff>0)
	{
	  sprintf(tempjunk,"Total features ignored due to bad FCODE: %d\n",badstuff);
	  strcat(EXTRACT_EXTRA_STR,tempjunk);
	}      
      if(badstuff2>0)
	{
	  sprintf(tempjunk,"Total features ignored due to invalid coordinates: %d\n",badstuff2);
	  strcat(EXTRACT_EXTRA_STR,tempjunk);
	}
      
      if(nullshapes>0)
	{
	  sprintf(tempjunk,"Total features ignored due to being NULL: %d\n",nullshapes);
	  strcat(EXTRACT_EXTRA_STR,tempjunk);
	}

      if(baddbf>0)
	{
	  sprintf(tempjunk,"Total shapefiles ignored due to invalid (truncated) DBF: %d\n",baddbf);
	  strcat(EXTRACT_EXTRA_STR,tempjunk);
	}
 
  }
  
  
  ThisTime = time(NULL);
  
  if(
     ((ThisTime-last_redraw)>0)||
     (DONE==1)                 ||
     (files_done==-999)        ||
     (specialredraw==1)        ||
     (FORCE_REDRAW==1)
     )
    {
      if(zeroparts>0)
	  {
	     sprintf(extrastr,"Total features ignored due to having 0 parts: %d\n",zeroparts);
	  }
      else
	  {  
	    extrastr[0] = '\0';
	  } 
 

	  if(badstuff>0)
	{
	  sprintf(tempjunk,"Total features ignored due to bad FCODE: %d\n",badstuff);
	  strcat(extrastr,tempjunk);
	}
      
      if(badstuff2>0)
	{
	  sprintf(tempjunk,"Total features ignored due to invalid coordinates: %d\n",badstuff2);
	  strcat(extrastr,tempjunk);
	}
      
      if(nullshapes>0)
	{
	  sprintf(tempjunk,"Total features ignored due to being NULL: %d\n",nullshapes);
	  strcat(extrastr,tempjunk);
	}

      if(baddbf>0)
	{
	  sprintf(tempjunk,"Total shapefiles ignored due to invalid (truncated) DBF: %d\n",baddbf);
	  strcat(extrastr,tempjunk);
	}
      
      
      
      
      if(extra_type==1)
	{
	  sprintf(extrastr2,"Writing attribution               : %d/%d\n",extra1,extra2);     
	  strcat(extrastr,extrastr2);
	}
      else if(extra_type==2)
	{
	  sprintf(extrastr2,"Freeing Memory                    : %d/%d\n",extra1,extra2);
	  strcat(extrastr,extrastr2);
	}
      
      
      if(dbfdone<0)
	{
	  
	  sprintf(temp,"\n\n");
	}
      else
	{
	  sprintf(temp,"DBF entries for current file      : %d/%d\n\n",
		  save_dbfdone,save_dbftotal);
	}
      
      if(files_done==-999)
	{
	  sprintf(message,"%s",allshapes);
	}
      else if(DONE==0)
	{
      	  
	  sprintf(message,"Importing data in:\n %s\n\
Current file/table                : %s\n\
Files/Tables Completed            : %d\n\n\
%sPoint Features                    : %d\n\
Line Features                     : %d\n\
Area Features                     : %d\n\
%ss                             : %u\n\n\
%s\n\
Elapsed time: %s\n",
		  save_allshapes,save_curr_file,save_files_done,temp,
		  points_done,linears_done,areals_done,
		  GetECCLabel(0),gptsdone,
		  extrastr,PrintTime(StartTime));
	  
	  }
      else if(DONE==1)
	{
	  
      if(zeroparts>0)
	  {
	   sprintf(extrastr,"Total features ignored due to having 0 parts: %d\n",zeroparts);
	  }
     else
	 {
	  extrastr[0] = '\0';
	 }
 

	  if(badstuff>0)
	    {
	      sprintf(tempjunk,"Total features ignored due to bad FCODE: %d\n",badstuff);
	      strcat(extrastr,tempjunk);
	    }
	  
	  if(badstuff2>0)
	    {
	      sprintf(tempjunk,"Total features ignored due to invalid coordinates: %d\n",badstuff2);
	      strcat(extrastr,tempjunk);
	    }
	  
	  if(nullshapes>0)
	    {
	      sprintf(tempjunk,"Total features ignored due to being NULL: %d\n",nullshapes);
	      strcat(extrastr,tempjunk);
	    }
	  
	  sprintf(message,"DONE importing data in:\n %s\n\
Files/Tables Completed           : %d\n\n\
Point Features                   : %d\n\
Line Features                    : %d\n\
Area Features                    : %d\n\
%ss                            : %u\n\n\
%s\n\
Elapsed time: %s\n",
		  save_allshapes,save_files_done,
		  points_done,linears_done,areals_done,
		  GetECCLabel(0),gptsdone,extrastr,
		  PrintTime(StartTime));
	}
      else
	{
	  printf("update concat got bad done value %d\n",DONE);
	  ExitWrapper(-1);
	}
    

      if(batchsilent==1)
	{
	  if((ThisTime-last_redraw)>1)
	    {
	      AddSilentStuff(message,1);
	      last_redraw = ThisTime;
	    }
	}
	  else
	  {
        t = XmStringCreateLtoR (message,XmSTRING_DEFAULT_CHARSET);
        XtVaSetValues(extract_dialog,XmNmessageString,t,NULL); 
        
        real_periodic_redraw();
        last_redraw = ThisTime;
      
        XmUpdateDisplay(extract_dialog);
        XmUpdateDisplay(drawing_a);
	  }
    }
}


int GetMaxShapeNum()
{
  if(ATTRTYPE_TREX())
  {
	
    return MAX_SHAPE_NUM/4; 
  }

  return MAX_SHAPE_NUM;
}


int MakeConsolidatedShape()
{
  FILE *outfile;
  struct AdditionalConditions * AdditionalConditionFlags=NULL;
  int ConditionFlags[CONDITION_ARRAY_SIZE];
  struct ConditionList * NEW_LIST=NULL;
  int i,outlen,thispasstotal,thispassindex,startindex,endindex;
  char scrubout[1000],testname[1000];



  int foundone = 0;



  extern int lines_found_export,points_found_export;

  

  if(batch_mode==0)
    {
      set_cursor(mydisplay,mywindow,WATCH);
      BUSY = 1;
    }
  
  
  for(i=1;i<=CONDITION_DEFINITIONS;i++)
    {
      ErrorLookup[i].wroteout = 0;
    }
  
  for(i=0;i<CLONE_DEFINITIONS;i++)
    {
      CloneErrorLookup[i].wroteout = 0;
    }
  
  
  thispassindex = 0;
  
  
  while(1)
  {
      
      
      for(i=1;i<=CONDITION_DEFINITIONS;i++)
	{
	  ConditionFlags[i] = 0;
	}
      
      thispasstotal = 0;
      foundone      = 0;
      startindex    = 0;
      endindex      = 0;
      
      
      for(i=1;i<=CONDITION_DEFINITIONS;i++)
	{
	  if(
	     (ErrorLookup[i].number>0)     &&
	     (ErrorLookup[i].wroteout==0)  &&
	     ( (thispasstotal+ErrorLookup[i].number) < GetMaxShapeNum())
	     )
	    {
	      ConditionFlags[i] = 1;
	      ErrorLookup[i].wroteout = -1; 
	      thispasstotal = thispasstotal + ErrorLookup[i].number;
  	      foundone = foundone + 1;
	    }
	}

      for(i=0;i<CLONE_DEFINITIONS;i++)
	{
	  if(
	     (CloneErrorLookup[i].number>0)     &&
	     (CloneErrorLookup[i].wroteout==0)  &&
	     ( (thispasstotal+CloneErrorLookup[i].number) < GetMaxShapeNum())
	     )
	    {
	      CloneErrorLookup[i].wroteout = -1; 
	      
	      SEEIT_AddAdditionalFlag(&AdditionalConditionFlags,
				      CloneErrorLookup[i].CloneNumber, 
				      GetCloneNumber(i,CloneErrorLookup[i].CloneNumber)
				      );	  

          

          thispasstotal = thispasstotal + CloneErrorLookup[i].number;

	      foundone = foundone + 1;
	    }
	}
      
      
      if(foundone==0)
	{ 
	  
	  
	  for(i=1;i<=CONDITION_DEFINITIONS;i++)
	    { 
	      if(
		 (ErrorLookup[i].number>0)     &&
		 (ErrorLookup[i].wroteout>=0)
		 )
		{
		  foundone = 1;
	  	  ConditionFlags[i] = 1;
		  startindex = ErrorLookup[i].wroteout + 1;
		  endindex   = startindex + GetMaxShapeNum();
		  
		  if(endindex>=ErrorLookup[i].number)
		    {
		      endindex = ErrorLookup[i].number;
		      ErrorLookup[i].wroteout = -1;
		    }
		  else
		    {
		      ErrorLookup[i].wroteout = endindex;
		    }
		  
		  break;
		}
	    }
	}

      
      if(foundone==0)
	{ 
	  
	  
	  	  
	  for(i=0;i<CLONE_DEFINITIONS;i++)
	    {
	      if(
		 (CloneErrorLookup[i].number>0)     &&
		 (CloneErrorLookup[i].wroteout>=0)  
		 )
		{
		  foundone = 1;
		  		  
		  SEEIT_AddAdditionalFlag(&AdditionalConditionFlags,
					  CloneErrorLookup[i].CloneNumber, 
					  GetCloneNumber(i,CloneErrorLookup[i].CloneNumber)
					  );	  

		  startindex = CloneErrorLookup[i].wroteout + 1;
		  endindex   = startindex + GetMaxShapeNum();

		  if(endindex>=CloneErrorLookup[i].number)
		    {
		      endindex = CloneErrorLookup[i].number;
		      CloneErrorLookup[i].wroteout = -1;
		    }
		  else
		    {
		      CloneErrorLookup[i].wroteout = endindex;
		    }
		  break;
		}
	    }
      	}
      

	  if(foundone==0)
	  {
		  
		  break;
	  }

      sprintf(scrubout,"%s",outdirectory);
      outlen = strlen(scrubout);
      scrubout[outlen-1] = '\0';
      




      
      SEEIT_LoadConditionReport(scrubout);
      
      ABORT_ZOOM = 0;
      
      NEW_LIST =
	SEEIT_GetConditions(scrubout,
			    ConditionFlags,
			    startindex,
			    endindex,
			    AdditionalConditionFlags, 
			    1,  
			    1,  
			    0,  
			    NULL,
			    -1
			    );
      
      
      
      
      if(NEW_LIST==NULL)
	{
	  if(batch_mode==0)
	    {
	      not_while_running(drawing_a,"An error has occured in the condition report API:\nNULL error list returned",
				1068,"Error",5);
	      
	      printf("NULL list 2\n");
	      set_cursor(mydisplay,mywindow,GOOD);  
	    }
	  else
	    {
	      printf("An error has occured in the condition report API:\nNULL error list returned");
	    }
	  
	  BUSY = 0;
	  return 0;
	}
      

    thispassindex = thispassindex + 1;

	
	if(ATTRTYPE_TREX())
	{
      RemoveTRExFiles(1); 
	}


	if(SLASHTYPE==NONDOS_TYPE)
	{
	  if(ATTRTYPE_TREX())
	  {
		sprintf(testname,"%s_%d",GetTRExFileName(),thispassindex);
	  }
      else
	  {
		sprintf(testname,"%sexported_shapefiles/%s%d",indirectory,shape_out_name,thispassindex);
	  }
	}
    else
	{
	  if(ATTRTYPE_TREX())
	  {
        sprintf(testname,"%s_%d",GetTRExFileName(),thispassindex);
	  }
	  else
	  {
        sprintf(testname,"%sexported_shapefiles\\%s%d",indirectory,shape_out_name,thispassindex);
	  }
	}


    UpdateKeepDismiss(NEW_LIST);


      


    SEEIT_ExportShapefile(NEW_LIST, testname);

    if(INCLUDE_PROJECTION>0)
	{
	  if(lines_found_export>0)
	  { 
        sprintf(scrubout,"%sLN.prj",testname);
		outfile = fopen(scrubout,"w");
		if(outfile==NULL)
		{
          XBell(mydisplay,50);
		  printf("Error: Could not open %s for write\n",scrubout);
		}
		else
		{
		  fprintf(outfile,"GEOGCS[\"GCS_WGS_1984\",DATUM[\"D_WGS_1984\",SPHEROID[\"WGS_1984\",6378137.0,298.257223563]],PRIMEM[\"Greenwich\",0.0],UNIT[\"Degree\",0.0174532925199433]]\n");
		  fclose(outfile);
		}
	  } 
	  if(points_found_export>0)
	  { 
        sprintf(scrubout,"%sPT.prj",testname);
		outfile = fopen(scrubout,"w");
		if(outfile==NULL)
		{
          XBell(mydisplay,50);
		  printf("Error: Could not open %s for write\n",scrubout);
		}
		else
		{
		  fprintf(outfile,"GEOGCS[\"GCS_WGS_1984\",DATUM[\"D_WGS_1984\",SPHEROID[\"WGS_1984\",6378137.0,298.257223563]],PRIMEM[\"Greenwich\",0.0],UNIT[\"Degree\",0.0174532925199433]]\n");
		  fclose(outfile);
		}
	  } 
	}


    SEEIT_FreeConditions(NEW_LIST);
    SEEIT_FreeAdditionalFlags(AdditionalConditionFlags);
    AdditionalConditionFlags = NULL;
    SEEIT_FreeConditionReportMemory();

  }


  if(batch_mode==0)
    {
      set_cursor(mydisplay,mywindow,GOOD);  
    }

  BUSY = 0;
  return thispassindex;
}






void BadOut(char tester[])
{
  char message[1000];
  
  if(USE_DOS==1)
  {
  sprintf(message,"Unable to open files for writing in folder:\n\n\
%s\n\n\
Check that this is a valid folder name and that\n\
you have write permissions and try again.\n",tester);
  }
  else
  {
  sprintf(message,"Unable to open files for writing in directory:\n\n\
%s\n\n\
Check that this is a valid directory name and that\n\
you have write permissions and try again.\n",tester);
  }
  
  if(batch_mode==1)
    {
      printf("%s",message);
    }
  else
    {
      short_non_fatal_error(message,"Unable to write");
    }
}



int TestOut(char *testdir)
{
  FILE *testfile;
  char tester[1000];
  char command[500];
  
  
  sprintf(tester,"%sGAITtesttempfile.msg",testdir);
  
  testfile = fopen(tester,"w");
  if(testfile==NULL)
    {
      
      
      sprintf(command,"mkdir \"%s\"\n",testdir);
      
      system(command);
      
      testfile = fopen(tester,"w");
      if(testfile==NULL)
	{
	  BadOut(testdir); 
	  return 0;
	}
      else
	{
	  fclose(testfile);
	  if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
	    {
	      sprintf(command,"del \"%s\"",tester);
	    }
	  else
	    {
	      sprintf(command,"rm \"%s\"",tester);
	    }
	  system(command);
	}
    }
  else
    {
      fclose(testfile);
      if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
	{
	  sprintf(command,"del \"%s\"",tester);
	}
      else
	{
	  sprintf(command,"rm \"%s\"",tester);
	}       
      system(command);
    }


  return 1;
}


int IsDirectory(char *filename)
{

#if(USE_DOS==1)
DWORD dwAttrib = GetFileAttributes(filename);
return (dwAttrib == FILE_ATTRIBUTE_DIRECTORY);
#else
DIR *dir = opendir(filename);
if(dir)
{
  closedir(dir);
  return 1;
}
return 0;
#endif

}



int UpdateProjectLoc(char *testloc)
{
  
  char tester[5000];
#if(USE_DOS==1)
  DWORD attrs;
#endif

  if(USE_DOS==1)
    {
      sprintf(tester,"%s\\",testloc);
    }
  else
    {
      sprintf(tester,"%s/",testloc);
    }


  



  if(TestOut(tester)==1)
  { 
    
  }
  else
  {
    
    return 0;
  }



  #if(USE_DOS==1)
 attrs = GetFileAttributes(testloc);
 if(attrs & FILE_ATTRIBUTE_DIRECTORY)
 {
  if(attrs & FILE_ATTRIBUTE_HIDDEN)
  {
	sprintf(tester,"The folder:  \n\n%s\n\ncannot be used as a project folder because it is a \"hidden\" folder.\n",testloc);
	not_while_running(drawing_a,tester,1473,"Hidden folder selected",5);
    return 0;
  }
  if(attrs & FILE_ATTRIBUTE_SYSTEM)
  {
 	sprintf(tester,"The folder:  \n\n%s\n\ncannot be used as a project folder because it is a \"system\" folder.\n",testloc);
	not_while_running(drawing_a,tester,1474,"System folder selected",5);
	return 0;
  }
 }
#endif
  
  
  if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
    {
      sprintf(tester,"%s\\ProjectPreferences\\",testloc);
    }
  else
    {
      sprintf(tester,"%s/ProjectPreferences/",testloc);
    }



  if(TestOut(tester)==0)
    {
      
      return 0;
    }
  


  
  
  
  
  if(import_output_source==1)
    {
      if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
	{
	  sprintf(importdirectory,"%s\\%s\\InputSpecFile.txt",testloc,GAITProjectName);
	  sprintf(importoutputdir,"%s\\%s\\",testloc,GAITProjectName);
	}
      else
	{
	  sprintf(importdirectory,"%s/%s/InputSpecFile.txt",testloc,GAITProjectName);
	  sprintf(importoutputdir,"%s/%s/",testloc,GAITProjectName);
	}
    }
  
  
  
  if(IMPORT_WIN==1)
    {
      if(import_output_source==1)
	{
	  XtVaSetValues(terrain_to_import,    XmNlabelString,STRING(importdirectory),NULL);
	}
    }
  return 1;  
}


void SetProjToggles()
{   
  XmToggleButtonSetState(proj_folder_button1,(Boolean)COPY_PROJECT_FOLDER,(Boolean)0);
  XmToggleButtonSetState(proj_folder_button2,(Boolean)COPY_PROJECT_FOLDER2,(Boolean)0);
}


void toggle_copy_project_folder(Widget widget,XtPointer client_data,XtPointer call_data)
{
  if(COPY_PROJECT_FOLDER==1)
  {
    COPY_PROJECT_FOLDER = 0;
  }
  else 
  {
    COPY_PROJECT_FOLDER  = 1;
	if(COPY_PROJECT_FOLDER2==1)
	{
      COPY_PROJECT_FOLDER2 = 0;
	}
  }
  SetProjToggles();
}

void toggle_copy_project_folder2(Widget widget,XtPointer client_data,XtPointer call_data)
{
  if(COPY_PROJECT_FOLDER2==1)
  {
    COPY_PROJECT_FOLDER2 = 0;
  }
  else 
  {
    COPY_PROJECT_FOLDER2  = 1;
	if(COPY_PROJECT_FOLDER==1)
	{
      COPY_PROJECT_FOLDER = 0;
	}
  }
  SetProjToggles();
}



void FolderCallback(Widget w, XtPointer userData, XtPointer callData)
{
  Widget rc,form,button, browse_button,label1;
  static Widget folderhead;
  Arg resources[20];
  int n;
  Dimension Pwidth,Pheight;
  

  

  set_cursor(mydisplay,mywindow,WATCH);

 
  if(dead_folderhead==1)
    {
      n=0;
      XtSetArg(resources[n],  XmNdeleteResponse, XmDESTROY); n++;
      XtSetArg(resources[n],  XmNmaxWidth,    800);          n++;

      folderhead = XtCreatePopupShell("Select Project Folder",topLevelShellWidgetClass,w,resources,n);
      
      

      rc = XtVaCreateManagedWidget
	(
	 "XformWidget", xmPanedWindowWidgetClass, folderhead,
	 XmNrubberPositioning, False,
	 XmNresizable,         True,
	 XmNseparatorOn,       False,
	 XmNsashHeight,        1,
	 NULL
	 );
         
    
      form = XtVaCreateWidget ("form7", xmFormWidgetClass, rc,
			       XmNpaneMinimum,     35,
			       XmNpaneMaximum,     35,
			       XmNseparatorOn,   False,
			       XmNfractionBase,  60,  
			       NULL);
      

      label1 = XtVaCreateManagedWidget ("GAIT project folder:",
					xmLabelWidgetClass,  form,
					XmNrightAttachment,  XmATTACH_POSITION,
					XmNrightPosition,    17,
					XmNleftAttachment,   XmATTACH_POSITION,
					XmNleftPosition,     0,
					XmNalignment,        XmALIGNMENT_CENTER,
					XmNtopAttachment,    XmATTACH_FORM,
					XmNbottomAttachment, XmATTACH_FORM,
					LABELWTRANSLATE,
					NULL);
      
      
      folder_wid = XtVaCreateManagedWidget ("text_w",
					    xmTextFieldWidgetClass, form,	  
					    XmNvalue,               PROJECTLOC,
					    XmNtraversalOn,         True,
					    XmNrightAttachment,     XmATTACH_POSITION,
					    XmNrightPosition,       50,
					    XmNleftAttachment,      XmATTACH_POSITION,
					    XmNleftPosition,        17,
					    XmNtopAttachment,       XmATTACH_FORM,
					    XmNbottomAttachment,    XmATTACH_FORM,
                        XmNtranslations,        XtParseTranslationTable ( translations_paste ) ,
					    NULL);
      
      XtAddCallback (folder_wid, XmNactivateCallback,
		     EnterFileCallback, (XtPointer)12);
      
      browse_button  = XtVaCreateManagedWidget("Browse...",xmPushButtonWidgetClass,form,
					       XmNlabelString,      STRING("Browse..."),
					       XmNorientation,      XmVERTICAL,
					       XmNleftAttachment,   XmATTACH_POSITION,
					       XmNleftPosition,     50,
					       XmNrightAttachment,  XmATTACH_POSITION,
					       XmNrightPosition,    59,
					       XmNtopAttachment,    XmATTACH_FORM,
					       XmNbottomAttachment, XmATTACH_FORM,
					       XmNtraversalOn,      False,
					       XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					       NULL
					       ); 
      
      XtAddCallback(browse_button, XmNactivateCallback,
		    BrowseCallback, (XtPointer) CHOOSEPROJ_BROWSE);
      XtManageChild(browse_button); 
      XtManageChild(form);







      form = XtVaCreateWidget ("form170", xmFormWidgetClass, rc,
			       XmNpaneMinimum,   25,
			       XmNpaneMaximum,   25,
			       XmNseparatorOn,   False,
			       XmNfractionBase,  100,  
			       NULL);      


      proj_folder_button1 = 
       XtVaCreateManagedWidget ("the_test203",
				 xmToggleButtonWidgetClass, form,
				 XmNtopAttachment,          XmATTACH_FORM,
				 XmNbottomAttachment,       XmATTACH_FORM,
				 XmNleftAttachment,         XmATTACH_POSITION,
				 XmNleftPosition,           1,
				 XmNrightAttachment,        XmATTACH_POSITION,
				 XmNrightPosition,          99,
				 XmNlabelString,            STRING("Also use this path for the Input Data Folder (\"Create GAIT Project\" window)"),
                 XmNalignment,              XmALIGNMENT_BEGINNING,
				 TOGGLETRANSLATE,           TOGGLEINCLUDE,
				 NULL);
      
      XtManageChild (proj_folder_button1);
      XmToggleButtonSetState(proj_folder_button1,(Boolean)COPY_PROJECT_FOLDER,(Boolean)0);
      XtAddCallback (proj_folder_button1, XmNvalueChangedCallback, toggle_copy_project_folder, (XtPointer)NULL);

      XtManageChild(form);




      form = XtVaCreateWidget ("form170", xmFormWidgetClass, rc,
			       XmNpaneMinimum,   25,
			       XmNpaneMaximum,   25,
			       XmNseparatorOn,   False,
			       XmNfractionBase,  100,  
			       NULL);      

      proj_folder_button2 = 
       XtVaCreateManagedWidget ("the_test203",
				 xmToggleButtonWidgetClass, form,
				 XmNtopAttachment,          XmATTACH_FORM,
				 XmNbottomAttachment,       XmATTACH_FORM,
				 XmNleftAttachment,         XmATTACH_POSITION,
				 XmNleftPosition,           1,
				 XmNrightAttachment,        XmATTACH_POSITION,
				 XmNrightPosition,          99,
				 XmNlabelString,            STRING("Use the folder containing this folder for the Input Data Folder"),
                 XmNalignment,              XmALIGNMENT_BEGINNING,
				 TOGGLETRANSLATE,           TOGGLEINCLUDE,
				 NULL);
      
      XtManageChild (proj_folder_button2);
      XmToggleButtonSetState(proj_folder_button2,(Boolean)COPY_PROJECT_FOLDER2,(Boolean)0);
      XtAddCallback (proj_folder_button2, XmNvalueChangedCallback, toggle_copy_project_folder2, (XtPointer)NULL);

      XtManageChild(form);



      
      form = XtVaCreateWidget ("form170", xmFormWidgetClass, rc,
			       XmNpaneMinimum,   25,
			       XmNpaneMaximum,   25,
			       XmNseparatorOn,   False,
			       XmNfractionBase,  100,  
			       NULL);      


      button  = XtVaCreateManagedWidget("SCR4",xmPushButtonWidgetClass,form,
					XmNlabelString,       STRING("Help"),
					XmNtopAttachment,     XmATTACH_FORM,
					XmNbottomAttachment,  XmATTACH_FORM,		    
					XmNrightAttachment,   XmATTACH_POSITION,
					XmNrightPosition,     49,
					XmNleftAttachment,    XmATTACH_POSITION,
					XmNleftPosition,      1,
					XmNtraversalOn,       False,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					NULL
					); 
      
      XtAddCallback(button, XmNactivateCallback, folderhelpCallback, (XtPointer) NULL);
      XtManageChild(button); 


      button  = XtVaCreateManagedWidget("SCR3",xmPushButtonWidgetClass,form,
					XmNlabelString,       STRING("Apply/Done"),
					XmNtopAttachment,     XmATTACH_FORM,
					XmNbottomAttachment,  XmATTACH_FORM,		    
					XmNrightAttachment,   XmATTACH_POSITION,
					XmNrightPosition,     99,
					XmNleftAttachment,    XmATTACH_POSITION,
					XmNleftPosition,      51,
					XmNtraversalOn,       False,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					NULL
					); 
      
      XtAddCallback(button, XmNactivateCallback, die_callback, (XtPointer) 1014);
      XtManageChild(button); 

      XtManageChild(form);


      XtManageChild(rc);
      MyPopup(folderhead); 
      
      
      XtVaGetValues(folderhead, XmNwidth,     &Pwidth, XmNheight, &Pheight, NULL);	  
      XtVaSetValues(folderhead, XmNminHeight, Pheight, NULL);
      XtVaSetValues(folderhead, XmNmaxHeight, Pheight, NULL);

      XtAddEventHandler(folderhead,StructureNotifyMask,False, myResizeHandler, (XtPointer)((int)Pheight));
  

      XtAddCallback(folderhead,XmNdestroyCallback,ShellDeath,(XtPointer)4001);
      dead_folderhead=0;
    }
  else
    {
      ResetWidget(folderhead);
    }

  set_cursor(mydisplay,mywindow,GOOD);

}




void ResetBrowsersCallback(Widget w, XtPointer userData, XtPointer callData)
{
  extern Widget choose_dialog,chooseshape_dialog,choose_es1_dialog,choose_es2_dialog,choose_txt_dialog,
	  choose_xml1_dialog,choose_xml2_dialog,choose_xml3_dialog,chooseattr_dialog,choosedp_dialog,
	  choosebr_dialog;

  if(SHAPE_IMPORT_OUTPUT>0)
  {
    XtDestroyWidget(chooseshape_dialog);
    FreeWidList(CHOOSESHAPE_BROWSE,1);
	SHAPE_IMPORT_OUTPUT = 0;
  }

  if(browse12_up>0)
  {
    XtDestroyWidget(choose_dialog);
    FreeWidList(CHOOSEPROJ_BROWSE,1);
	browse12_up = 0;
  }

  if(browse13_up>0)
  {
    XtDestroyWidget(choose_es1_dialog);
    FreeWidList(CHOOSE_ES1_BROWSE,1);
    browse13_up = 0;
  }

  if(browse14_up>0)
  {
    XtDestroyWidget(choose_es2_dialog);
    FreeWidList(CHOOSE_ES2_BROWSE,1);
    browse13_up = 0;
  }

  if(browse15_up>0)
  {
    XtDestroyWidget(choose_txt_dialog);
    FreeWidList(CHOOSE_TXT_BROWSE,1);
    browse15_up = 0;
  }

  if(browse27_up>0)
  {
    XtDestroyWidget(choose_xml1_dialog);
    FreeWidList(CHOOSE_XML1_BROWSE,1);
    browse27_up = 0;
  }

  if(browse28_up>0)
  {
    XtDestroyWidget(choose_xml2_dialog);
    FreeWidList(CHOOSE_XML1_BROWSE,1);
    browse28_up = 0;
  }

  if(browse29_up>0)
  {
    XtDestroyWidget(choose_xml3_dialog);
    FreeWidList(CHOOSE_XML1_BROWSE,1);
    browse29_up = 0;
  }

  if(browse30_up>0)
  {
    XtDestroyWidget(chooseattr_dialog);
    FreeWidList(ATTRFOLDER_BROWSE,1);
    browse30_up = 0;
  }

  if(browse31_up>0)
  {
    XtDestroyWidget(choosedp_dialog);
    FreeWidList(CHOOSE_DP_BROWSE,1);
    browse31_up = 0;
  }

  if(browse32_up>0)
  {
    XtDestroyWidget(choosebr_dialog);
    FreeWidList(CHOOSEBROWSE_BROWSE,1);
    browse32_up = 0;
  }


}




void BrowseFolderCallback(Widget w, XtPointer userData, XtPointer callData)
{
  Widget rc,form,button, browse_button,label1;
  static Widget browsefolderhead;
  Arg resources[20];
  int n;
  Dimension Pwidth,Pheight;


  

  set_cursor(mydisplay,mywindow,WATCH);

 
  if(dead_browsefolderhead==1)
    {
      n=0;
      XtSetArg(resources[n],  XmNdeleteResponse, XmDESTROY); n++;
      XtSetArg(resources[n],  XmNmaxWidth,    800);          n++;

      browsefolderhead = XtCreatePopupShell("Select Browse Folder",topLevelShellWidgetClass,w,resources,n);

      rc = XtVaCreateManagedWidget
	(
	 "XformWidget", xmPanedWindowWidgetClass, browsefolderhead,
	 XmNrubberPositioning, False,
	 XmNresizable,         True,
	 XmNseparatorOn,       False,
	 XmNsashHeight,        1,
	 NULL
	 );
         
    
      form = XtVaCreateWidget ("form7", xmFormWidgetClass, rc,
			       XmNpaneMinimum,     35,
			       XmNpaneMaximum,     35,
			       XmNseparatorOn,   False,
			       XmNfractionBase,  60,  
			       NULL);
      

      label1 = XtVaCreateManagedWidget ("GAIT browse folder:",
					xmLabelWidgetClass,  form,
					XmNrightAttachment,  XmATTACH_POSITION,
					XmNrightPosition,    17,
					XmNleftAttachment,   XmATTACH_POSITION,
					XmNleftPosition,     0,
					XmNalignment,        XmALIGNMENT_CENTER,
					XmNtopAttachment,    XmATTACH_FORM,
					XmNbottomAttachment, XmATTACH_FORM,
					LABELWTRANSLATE,
					NULL);
      
      
      browsefolder_wid = XtVaCreateManagedWidget ("text_w",
					    xmTextFieldWidgetClass, form,	  
					    XmNvalue,               SpecialLoc,
					    XmNtraversalOn,         True,
					    XmNrightAttachment,     XmATTACH_POSITION,
					    XmNrightPosition,       50,
					    XmNleftAttachment,      XmATTACH_POSITION,
					    XmNleftPosition,        17,
					    XmNtopAttachment,       XmATTACH_FORM,
					    XmNbottomAttachment,    XmATTACH_FORM,
                        XmNtranslations,        XtParseTranslationTable ( translations_paste ) ,
					    NULL);
      
      XtAddCallback (browsefolder_wid, XmNactivateCallback,
		     EnterFileCallback, (XtPointer)31);
      
      browse_button  = XtVaCreateManagedWidget("Browse...",xmPushButtonWidgetClass,form,
					       XmNlabelString,      STRING("Browse..."),
					       XmNorientation,      XmVERTICAL,
					       XmNleftAttachment,   XmATTACH_POSITION,
					       XmNleftPosition,     50,
					       XmNrightAttachment,  XmATTACH_POSITION,
					       XmNrightPosition,    59,
					       XmNtopAttachment,    XmATTACH_FORM,
					       XmNbottomAttachment, XmATTACH_FORM,
					       XmNtraversalOn,      False,
					       XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					       NULL
					       ); 
      
      XtAddCallback(browse_button, XmNactivateCallback,
		    BrowseCallback, (XtPointer) CHOOSEBROWSE_BROWSE);
      XtManageChild(browse_button); 
      XtManageChild(form);



      form = XtVaCreateWidget ("form170", xmFormWidgetClass, rc,
			       XmNpaneMinimum,   25,
			       XmNpaneMaximum,   25,
			       XmNseparatorOn,   False,
			       XmNfractionBase,  100,  
			       NULL);      
      
      button  = XtVaCreateManagedWidget("SCR4",xmPushButtonWidgetClass,form,
					XmNlabelString,       STRING("Re-Set Any Existing Browsers"),
					XmNtopAttachment,     XmATTACH_FORM,
					XmNbottomAttachment,  XmATTACH_FORM,		    
					XmNrightAttachment,   XmATTACH_POSITION,
					XmNrightPosition,     99,
					XmNleftAttachment,    XmATTACH_POSITION,
					XmNleftPosition,      1,
					XmNtraversalOn,       False,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					NULL
					); 
      
      XtAddCallback(button, XmNactivateCallback, ResetBrowsersCallback, (XtPointer) NULL);
      XtManageChild(button); 
      
      XtManageChild(form);



      
      form = XtVaCreateWidget ("form170", xmFormWidgetClass, rc,
			       XmNpaneMinimum,   25,
			       XmNpaneMaximum,   25,
			       XmNseparatorOn,   False,
			       XmNfractionBase,  100,  
			       NULL);      
      button  = XtVaCreateManagedWidget("SCR3",xmPushButtonWidgetClass,form,
					XmNlabelString,       STRING("Done"),
					XmNtopAttachment,     XmATTACH_FORM,
					XmNbottomAttachment,  XmATTACH_FORM,		    
					XmNrightAttachment,   XmATTACH_POSITION,
					XmNrightPosition,     99,
					XmNleftAttachment,    XmATTACH_POSITION,
					XmNleftPosition,      51,
					XmNtraversalOn,       False,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					NULL
					); 
      
      XtAddCallback(button, XmNactivateCallback, die_callback, (XtPointer) 1033);
      XtManageChild(button);

      
      button  = XtVaCreateManagedWidget("SCR4",xmPushButtonWidgetClass,form,
					XmNlabelString,       STRING("Help"),
					XmNtopAttachment,     XmATTACH_FORM,
					XmNbottomAttachment,  XmATTACH_FORM,		    
					XmNrightAttachment,   XmATTACH_POSITION,
					XmNrightPosition,     49,
					XmNleftAttachment,    XmATTACH_POSITION,
					XmNleftPosition,      1,
					XmNtraversalOn,       False,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					NULL
					); 
      
      XtAddCallback(button, XmNactivateCallback, browsefolderhelpCallback, (XtPointer) NULL);
      XtManageChild(button); 
      
      XtManageChild(form);
      XtManageChild(rc);
      MyPopup(browsefolderhead); 
      
      
      XtVaGetValues(browsefolderhead, XmNwidth,     &Pwidth, XmNheight, &Pheight, NULL);	  
      XtVaSetValues(browsefolderhead, XmNminHeight, Pheight, NULL);
      XtVaSetValues(browsefolderhead, XmNmaxHeight, Pheight, NULL);

      XtAddEventHandler(browsefolderhead,StructureNotifyMask,False, myResizeHandler, (XtPointer)((int)Pheight));
  

      XtAddCallback(browsefolderhead,XmNdestroyCallback,ShellDeath,(XtPointer)4094);
      dead_browsefolderhead=0;
    }
  else
    {
      ResetWidget(browsefolderhead);
    }


  set_cursor(mydisplay,mywindow,GOOD);


}





void FolderCallback2(Widget w, XtPointer userData, XtPointer callData)
{
  Widget rc,form,button, browse_button,label1;
  static Widget folderhead;
  Arg resources[20];
  int n;
  Dimension Pwidth,Pheight;

  

  set_cursor(mydisplay,mywindow,WATCH);


  if(dead_datahead==1)
    {
      n=0;
      XtSetArg(resources[n],  XmNdeleteResponse, XmDESTROY); n++;
      XtSetArg(resources[n],  XmNmaxWidth,    800);          n++;

      folderhead = XtCreatePopupShell("Select Data Folder",topLevelShellWidgetClass,w,resources,n);
      
      

      rc = XtVaCreateManagedWidget
	(
	 "XformWidget", xmPanedWindowWidgetClass, folderhead,
	 XmNrubberPositioning, False,
	 XmNresizable,         True,
	 XmNseparatorOn,       False,
	 XmNsashHeight,        1,
	 NULL
	 );
         
    
      form = XtVaCreateWidget ("form7", xmFormWidgetClass, rc,
			       XmNpaneMinimum,     35,
			       XmNpaneMaximum,     35,
			       XmNseparatorOn,   False,
			       XmNfractionBase,  60,  
			       NULL);
      

      label1 = XtVaCreateManagedWidget ("GAIT project folder:",
					xmLabelWidgetClass,  form,
					XmNrightAttachment,  XmATTACH_POSITION,
					XmNrightPosition,    17,
					XmNleftAttachment,   XmATTACH_POSITION,
					XmNleftPosition,     0,
					XmNalignment,        XmALIGNMENT_CENTER,
					XmNtopAttachment,    XmATTACH_FORM,
					XmNbottomAttachment, XmATTACH_FORM,
					LABELWTRANSLATE,
					NULL);
      
      
      data_wid = XtVaCreateManagedWidget ("text_w",
					    xmTextFieldWidgetClass, form,	  
					    XmNvalue,               DATALOC,
					    XmNtraversalOn,         True,
					    XmNrightAttachment,     XmATTACH_POSITION,
					    XmNrightPosition,       50,
					    XmNleftAttachment,      XmATTACH_POSITION,
					    XmNleftPosition,        17,
					    XmNtopAttachment,       XmATTACH_FORM,
					    XmNbottomAttachment,    XmATTACH_FORM,
                        XmNtranslations,        XtParseTranslationTable ( translations_paste ) ,
					    NULL);
      
      XtAddCallback (data_wid, XmNactivateCallback,
		     EnterFileCallback, (XtPointer)26);
      
      browse_button  = XtVaCreateManagedWidget("Browse...",xmPushButtonWidgetClass,form,
					       XmNlabelString,      STRING("Browse..."),
					       XmNorientation,      XmVERTICAL,
					       XmNleftAttachment,   XmATTACH_POSITION,
					       XmNleftPosition,     50,
					       XmNrightAttachment,  XmATTACH_POSITION,
					       XmNrightPosition,    59,
					       XmNtopAttachment,    XmATTACH_FORM,
					       XmNbottomAttachment, XmATTACH_FORM,
					       XmNtraversalOn,      False,
					       XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					       NULL
					       ); 
      
      XtAddCallback(browse_button, XmNactivateCallback,
		    BrowseCallback, (XtPointer) CHOOSEDATA_BROWSE);
      XtManageChild(browse_button);
      XtManageChild(form);


      
      form = XtVaCreateWidget ("form170", xmFormWidgetClass, rc,
			       XmNpaneMinimum,   25,
			       XmNpaneMaximum,   25,
			       XmNseparatorOn,   False,
			       XmNfractionBase,  100,  
			       NULL);      
      button  = XtVaCreateManagedWidget("SCR3",xmPushButtonWidgetClass,form,
					XmNlabelString,       STRING("Done"),
					XmNtopAttachment,     XmATTACH_FORM,
					XmNbottomAttachment,  XmATTACH_FORM,		    
					XmNrightAttachment,   XmATTACH_POSITION,
					XmNrightPosition,     99,
					XmNleftAttachment,    XmATTACH_POSITION,
					XmNleftPosition,      51,
					XmNtraversalOn,       False,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					NULL
					); 
      
      XtAddCallback(button, XmNactivateCallback, die_callback, (XtPointer) 1030);
      XtManageChild(button);

      
      button  = XtVaCreateManagedWidget("SCR4",xmPushButtonWidgetClass,form,
					XmNlabelString,       STRING("Help"),
					XmNtopAttachment,     XmATTACH_FORM,
					XmNbottomAttachment,  XmATTACH_FORM,		    
					XmNrightAttachment,   XmATTACH_POSITION,
					XmNrightPosition,     49,
					XmNleftAttachment,    XmATTACH_POSITION,
					XmNleftPosition,      1,
					XmNtraversalOn,       False,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					NULL
					); 
      
      XtAddCallback(button, XmNactivateCallback, folderhelpCallback, (XtPointer) NULL);
      XtManageChild(button); 
      
      XtManageChild(form);
      XtManageChild(rc);
      MyPopup(folderhead); 
      
      
      XtVaGetValues(folderhead, XmNwidth,     &Pwidth, XmNheight, &Pheight, NULL);	  
      XtVaSetValues(folderhead, XmNminHeight, Pheight, NULL);
      XtVaSetValues(folderhead, XmNmaxHeight, Pheight, NULL);

      XtAddEventHandler(folderhead,StructureNotifyMask,False, myResizeHandler, (XtPointer)((int)Pheight));
  

      XtAddCallback(folderhead,XmNdestroyCallback,ShellDeath,(XtPointer)4002);
      dead_datahead=0;
    }
  else
    {
      ResetWidget(folderhead);
    }

  set_cursor(mydisplay,mywindow,GOOD);

}





void ResetMBWidget(Widget w)
{
  

  Widget parent;
  Position px1,py1;

  parent = XtParent(w);

  XtVaGetValues(parent,XmNx,&px1,NULL);  
  XtVaGetValues(parent,XmNy,&py1,NULL);  

  if(USE_DOS==1)
    {
      px1 = px1 - 1; 
      py1 = py1 - 1;      
	}

  

  if(px1<10)
    {
      px1 = 10;
    }
  if(py1<10)
    {
      py1 = 10;
    } 

  XtUnmanageChild(w);
  XtManageChild(w);

  XtVaSetValues(parent,XmNx,px1,NULL);  
  XtVaSetValues(parent,XmNy,py1,NULL);   
}


void ResetWidget(Widget w)
{
  

  Position px1,py1;


  XtVaGetValues(w,XmNx,&px1,NULL);  
  XtVaGetValues(w,XmNy,&py1,NULL);  


  if(USE_DOS==1) 
    {
      px1 = px1 - 4;
      py1 = py1 - 30;
    }

  

  if(px1<10)
    {
      px1 = 10;
    }
  if(py1<10)
    {
      py1 = 10;
    } 

  XtVaSetValues(w,XmNx,px1,NULL);  
  XtVaSetValues(w,XmNy,py1,NULL);  

  XtPopdown(w);
  XtPopup(w,XtGrabNone);  
}


char *MakeSMName(char inname[])
{
  static char smname[1000];
  int len;
  
  len = strlen(inname);
  sprintf(smname,"%s",inname);
  smname[len-2] = 's';
  smname[len-1] = 'm';

  return smname;
}

char *MakeVRName(char inname[])
{
  static char vmname[1000];
  int len;
  
  len = strlen(inname);
  sprintf(vmname,"%s",inname);
  vmname[len-2] = 'v';
  vmname[len-1] = 'r';

  return vmname;
}


int VerifyCondReport(Widget w,char inesname[])
{
  int bad=0;
  int len;
  FILE *tempfile;
  char tempnsname [1000];
  char templkname [1000];
  char tempsmname [1000];
  char tempboname [1000];
  char tempntname [1000];
  char tempvrname [1000];
  char templk2name[1000];
  char errmsg     [1000];


  len = strlen(inesname);
  
  if(inesname[len-3]!='.')
    {
      sprintf(errmsg,"Error:  Bad ES filename entered:\n  %s\n\nThe filename given does not end in \".es\"\n",inesname);
      
      
      not_while_running(w,errmsg,1402,"Bad Input",1);   

      return 0;
    }

  printf("root %s\n",inesname);

  sprintf(tempnsname,"%s",inesname);
  tempnsname[len-2] = 'n';
  tempnsname[len-1] = 's';

  
  sprintf(tempvrname,"%s",inesname);
  tempnsname[len-2] = 'v';
  tempnsname[len-1] = 'r';
  
  sprintf(templkname,"%s",inesname);
  templkname[len-2] = 'l';
  templkname[len-1] = 'k';
  
  sprintf(templk2name,"%s2",templkname);
  

  sprintf(tempsmname,"%s",inesname);
  tempsmname[len-2] = 's';
  tempsmname[len-1] = 'm';
  
  sprintf(tempboname,"%s",inesname);
  tempboname[len-2] = 'b';
  tempboname[len-1] = 'o';

  sprintf(tempntname,"%s",inesname);
  tempntname[len-2] = 'n';
  tempntname[len-1] = 't';
  
  
  tempfile = fopen(inesname,"rb");
  if(tempfile==NULL)
    {
      bad = 1;
      sprintf(errmsg,"Error:  Bad ES filename entered:\nThe file is not readable or does not exist\n");
    }
  else
    {
      fclose(tempfile);
    }
  
  

  if(bad==0)
  {
    tempfile = fopen(templkname,"rb");
    if(tempfile==NULL)
    {
      bad = 1;
      sprintf(errmsg,"Error:  Bad LK filename entered:\nThe file:\n %s\n is not readable or does not exist\n",templkname);
    }
    else
    {
      fclose(tempfile);
    }
  }


  if(bad==0)
  {
    tempfile = fopen(tempvrname,"rb");
    if(tempfile==NULL)
    {
      bad = 1;
      sprintf(errmsg,"Error:  Bad VR filename entered:\nThe file:\n %s\n is not readable or does not exist\n",tempvrname);
    }
    else
    {
      fclose(tempfile);
    }
  }


  if(bad==0)
  {
    tempfile = fopen(tempsmname,"rb");
    if(tempfile==NULL)
    {
      bad = 1;
      sprintf(errmsg,"Error:  Bad SM filename entered:\nThe file:\n %s\n is not readable or does not exist\n",tempsmname);
    }
    else
    {
      fclose(tempfile);
    }
  }
  
  
  if(bad==0)
  {
    tempfile = fopen(tempboname,"rb");
    if(tempfile==NULL)
    {
      bad = 1;
      sprintf(errmsg,"Error:  Bad BO filename entered:\nThe file:\n %s\n is not readable or does not exist\n",tempboname);
    }
    else
    {
      fclose(tempfile);
    }
  }


  if(bad==0)
  {
    tempfile = fopen(tempntname,"rb");
    if(tempfile==NULL)
    {
      bad = 1;
      sprintf(errmsg,"Error:  Bad NT filename entered:\nThe file:\n %s\n is not readable or does not exist\n",tempntname);
    }
    else
    {
      fclose(tempfile);
    }
  }

  
  if(bad==0)
  {
    tempfile = fopen(templk2name,"rb");
    if(tempfile==NULL)
    {
      bad = 1;
      sprintf(errmsg,"Error:  Bad LK2 filename entered:\nThe file:\n %s\n is not readable or does not exist\n",templk2name);
    }
    else
    {
      fclose(tempfile);
    }
  }


  if(bad==1)
    {
      not_while_running(w,errmsg,1402,"Bad Input",1);   
      
      return 0;
    }
  
  return 1;

}


char *GetMasterType(char *filename)
{
  FILE *tempfile;
  int len1,len2,numchecks;
  char test1[1000],test2[1000];
  static char retval[500];

  retval[0] = '\0';


  tempfile = fopen(filename,"r");
  if(tempfile==NULL)
  {
    return retval;
  }

  
  if(feof(tempfile)){fclose(tempfile); return retval;}


  SEEIT_fread_int   (&numchecks,tempfile);
  if(feof(tempfile)){fclose(tempfile); return retval;}

  if(numchecks!=CONDITION_DEFINITIONS)
  {
    fclose(tempfile); return retval;
  }


  SEEIT_fread_int   (&len1,     tempfile);
  if(feof(tempfile)){fclose(tempfile); return retval;}

  SEEIT_fread_int   (&len2,     tempfile);	
  if(feof(tempfile)){fclose(tempfile); return retval;}

  if((len1<0)||(len2<0)||(len1>500)||(len2>500))
  {	
	fclose(tempfile); return retval;
  }

  fread(&test1[0],len1,1,       tempfile);
  if(feof(tempfile)){fclose(tempfile); return retval;}
  test1[len1] = '\0';

  fread(&test2[0],len2,1,       tempfile);
  test2[len2] = '\0';


  fclose(tempfile);

  sprintf(retval,"%s",test2);

  return retval;
 
}

char *GetMasterType2(char *filename)
{
  FILE *tempfile;
  int len1,len2,numchecks;
  char test1[1000],test2[1000];
  static char retval[500];

  retval[0] = '\0';


  tempfile = fopen(filename,"r");
  if(tempfile==NULL)
  {
    return retval;
  }

  
  if(feof(tempfile)){fclose(tempfile); return retval;}


  SEEIT_fread_int   (&numchecks,tempfile);
  if(feof(tempfile)){fclose(tempfile); return retval;}

  if(numchecks!=CONDITION_DEFINITIONS)
  {
    fclose(tempfile); return retval;
  }


  SEEIT_fread_int   (&len1,     tempfile);
  if(feof(tempfile)){fclose(tempfile); return retval;}

  SEEIT_fread_int   (&len2,     tempfile);	
  if(feof(tempfile)){fclose(tempfile); return retval;}

  if((len1<0)||(len2<0)||(len1>500)||(len2>500))
  {	
	fclose(tempfile); return retval;
  }

  fread(&test1[0],len1,1,       tempfile);
  if(feof(tempfile)){fclose(tempfile); return retval;}
  test1[len1] = '\0';

  fread(&test2[0],len2,1,       tempfile);
  test2[len2] = '\0';


  fclose(tempfile);

  sprintf(retval,"%s",test2);

  return retval;
 
}




void SummarizeCallback(Widget w, XtPointer userData, XtPointer callData)
{
  int type = (int)userData;
  int bad  = 0;
  char errmsg     [1000];
  char smname     [1000];
  char sm2name    [1000];
  char *retstr;
  FILE *outfile;

  EnterFileCallback(sum1_wid, (XtPointer)13,(XtPointer)NULL);
  EnterFileCallback(sum2_wid, (XtPointer)14,(XtPointer)NULL);
  EnterFileCallback(sum3_wid, (XtPointer)15,(XtPointer)NULL);







  if(type==1)
    {
      if(strlen(Sum1ESname)<3)
	{
	  sprintf(errmsg,"Error:  Bad ES filename entered for \"First ES filename\":\n  %s\n\nThe filename given is not long enough\n",Sum1ESname);
	  bad = 1;
	}
    }
  else if(type==2)
    {
      if(strlen(Sum2ESname)<3)
	{
	  sprintf(errmsg,"Error:  Bad ES filename entered for \"Second ES filename\":\n  %s\n\nThe filename given is not long enough\n",Sum2ESname);
	  bad = 1;
	}
    }
  else if(type==3)
    {
      if(strlen(Sum1ESname)<3)
	{
	  sprintf(errmsg,"Error:  Bad ES filename entered for \"First ES filename\":\n  %s\n\nThe filename given is not long enough\n",Sum1ESname);
	  bad = 1;
	}
      else if(strlen(Sum2ESname)<3)
	{
	  sprintf(errmsg,"Error:  Bad ES filename entered for \"Second ES filename\":\n  %s\n\nThe filename given is not long enough\n",Sum2ESname);
	  bad = 1;
	}
    }


  if(bad==1)
    {
      not_while_running(w,errmsg,1402,"Bad Input",1);   
      return;
    }





  
  if(type==1)
    {
      
      if(VerifyCondReport(w,Sum1ESname)==0)
	{
	  return;
	}

      sprintf(smname,"%s",MakeSMName(Sum1ESname));
      
      if(INFO_WINDOW==0)
	{
	  MakeInfo(2);
	}
      else
	{
	  ResetWidget(shellhead2);
	}

      retstr = CompareInspectionResults(smname,NULL,GetMasterType(MakeVRName(Sum1ESname)),NULL,COMPARE_VERBOSITY);      
      infoprint(retstr);
      infoprint("\n\n");
    }
  else if(type==2)
    {
      
      if(VerifyCondReport(w,Sum2ESname)==0)
	{
	  return;
	}
      sprintf(smname,"%s",MakeSMName(Sum2ESname));

      if(INFO_WINDOW==0)
	{
	  MakeInfo(2);
	}
      else
	{
	  ResetWidget(shellhead2);
	}
      
      retstr = CompareInspectionResults(smname,NULL,GetMasterType(MakeVRName(Sum2ESname)),NULL,COMPARE_VERBOSITY);      
      infoprint(retstr);
      infoprint("\n\n");
    }
  else if(type==3)
    {
      
      if(VerifyCondReport(w,Sum2ESname)==0)
	{
	  return;
	}

      sprintf(smname, "%s",MakeSMName(Sum1ESname));
      sprintf(sm2name,"%s",MakeSMName(Sum2ESname));

      if(INFO_WINDOW==0)
	{
	  MakeInfo(2);
	}
      else
	{
	  ResetWidget(shellhead2);
	}
      
      retstr = CompareInspectionResults(smname,sm2name,GetMasterType(MakeVRName(Sum1ESname)),GetMasterType2(MakeVRName(Sum2ESname)),COMPARE_VERBOSITY);      
      infoprint(retstr);
      infoprint("\n\n");
    }


  if(SAVE_COMPARE_FILE==1)
    {
      

      if(Sum3ESname[0] == '\0')
	{
	  sprintf(errmsg,"Could not save results to file because \nno file name has been entered!\n");
	  
	  not_while_running(w,errmsg,1403,"Bad Input",1);
	  return;
	}


      outfile = fopen(Sum3ESname,"w");
      if(outfile==NULL)
	{
	  sprintf(errmsg,"Could not save results to:\n %s\n because the file could not be opened for writing\n",
		  Sum3ESname);
	  
	  not_while_running(w,errmsg,1403,"Bad Input",1);
	  return;
	}
      fprintf(outfile,"%s",retstr);
      fclose(outfile);
    }
  free(retstr);
}





Widget BuildVerboseMenu(Widget parent,int menu_type,char *menu_title,MenuItem *items)
{
  Widget menu, cascade, widget;
  int i,n=0;
  XmString str;
  Arg args[5];
  
  menu = XmCreatePulldownMenu (parent, "_pulldown", NULL, 0);
  
  str = XmStringCreateLocalized (menu_title);
  XtSetArg (args[n], XmNsubMenuId,   menu);  n++;
  XtSetArg (args[n], XmNlabelString,  str);  n++;
  XtSetArg (args[n], XmNtranslations, XtParseTranslationTable ( translations_global )); n++;
  
  cascade = XmCreateOptionMenu (parent, menu_title, args, n);
  XmStringFree (str);
  
  for (i = 0; items[i].label != NULL; i++) 
    {
      widget = XtVaCreateManagedWidget (items[i].label,
					*items[i].cclass, menu,
					NULL);
      
      if((i+1)==COMPARE_VERBOSITY)
	{
	  XtVaSetValues(cascade,				
			XmNmenuHistory, widget,
			NULL);
	}

      if (items[i].callback)
	XtAddCallback (widget,
		       (items[i].cclass == &xmToggleButtonWidgetClass ||
			items[i].cclass == &xmToggleButtonWidgetClass) ?
		       XmNvalueChangedCallback : 
		       XmNactivateCallback,      
		       (XtCallbackProc)items[i].callback, items[i].callback_data);
    }
  return menu_type == XmMENU_POPUP ? menu : cascade;
}


void toggle_leave_windows(Widget widget,XtPointer client_data,XtPointer call_data)
{
  QAST_LEAVEWINDOWS = !QAST_LEAVEWINDOWS;
}


void toggle_use_packageloc(Widget widget,XtPointer client_data,XtPointer call_data)
{
  QAST_USEPACKAGELOCATION = !QAST_USEPACKAGELOCATION;
}


void toggle_save_file(Widget widget,XtPointer client_data,XtPointer call_data)
{
  SAVE_COMPARE_FILE = !SAVE_COMPARE_FILE;
}


void verbosity_cb(Widget menu_item,XtPointer client_data,XtPointer call_data)
{
  int item_no = (int) client_data;
  
  COMPARE_VERBOSITY = item_no;
}



void ReportXMLProgress(Widget w,int progresslevel, char *current_shape, char *savefilename, int curr, int total, int shpnum)
{
  char newmessage[1000];
  static long int last_redraw=0,ThisTime;
  extern int GLOBAL_TIME,alldatafiles;

  

  if(batch_mode==1)
  {
	return;
  }


  ThisTime = time(NULL);


  GLOBAL_TIME =  ThisTime-StartTime;


  
  periodic_redraw();

  if(progresslevel==-1)
  {
    sprintf(newmessage,"Processing XML %s\n",XML1name);
  }
  else if(progresslevel==-3)
  {
    sprintf(newmessage,"Completed validation of:\n  XML:  %s\n\nValidation results written to file:\n  %s\n\nTotal time: %s",
		XML1name,savefilename,PrintTime(StartTime));

    not_while_running(w,newmessage,1497,"XML Validation Complete",5);
	return;
  }
  else if(progresslevel>0)
  {
    sprintf(newmessage,"\
Validating XML:  %s\n\n\
  Completed processing of XML file.  Now processing shapefiles.\n\n\
Completed processing of %d/%d shapefiles\n\n\
  Current shapefile:  %s\n\
  Features complete in current shapefile: %d/%d\n\n\
Elapsed Time:           %s",XML1name,shpnum,alldatafiles,current_shape,curr,total,PrintTime(StartTime));
  }


  not_while_running(drawing_a,newmessage,-5,"XML Validation",5);

  
  XmUpdateDisplay(drawing_a);

  last_redraw = ThisTime;

}


void XMLwrapperCallback(Widget w, XtPointer userData, XtPointer callData)
{
  Widget parent_wid;
  FILE *testfile;
  int len,do_xsd=0,success=0,junk,junk1,junk2;
  char message[1000],savefilename[1000],XSDname[1000];


  if(batch_mode==0)
  {
    EnterFileCallback(xml1_wid, (XtPointer)27,(XtPointer)NULL);
    EnterFileCallback(xml2_wid, (XtPointer)28,(XtPointer)NULL);
    EnterFileCallback(xml3_wid, (XtPointer)29,(XtPointer)NULL);
	parent_wid = XtParent(XtParent(XtParent(w)));
  }
  else
  {
	parent_wid = NULL;
  }


  if((XML_TRD_TYPE==1)||(XML_TRD_TYPE==2))
  {
    if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
	{
      sprintf(XSDname,"%sMGCP_XSD\\TRD2_XSD\\mgcp\\mgcp.xsd",GAIT_HOME_DIR);
	}
    else
	{
      sprintf(XSDname,"%sMGCP_XSD/TRD2_XSD/mgcp/mgcp.xsd",GAIT_HOME_DIR);
	}
  }
  else if(XML_TRD_TYPE==3)
  {
    if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
	{
      sprintf(XSDname,"%sMGCP_XSD\\TRD3_XSD\\mgcp\\mgcp.xsd",GAIT_HOME_DIR);
	}
    else
	{
      sprintf(XSDname,"%sMGCP_XSD/TRD3_XSD/mgcp/mgcp.xsd",GAIT_HOME_DIR);
	}
  }
  else if(XML_TRD_TYPE==4)
  {
    if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
	{
      sprintf(XSDname,"%sMGCP_XSD\\TRD4_XSD\\mgcp\\mgcp.xsd",GAIT_HOME_DIR);
	}
    else
	{
      sprintf(XSDname,"%sMGCP_XSD/TRD4_XSD/mgcp/mgcp.xsd",GAIT_HOME_DIR);
	}
  }
  else if(XML_TRD_TYPE==41)
  {
    if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
	{
      sprintf(XSDname,"%sMGCP_XSD\\TRD41_XSD\\mgcp\\mgcp.xsd",GAIT_HOME_DIR);
	}
    else
	{
      sprintf(XSDname,"%sMGCP_XSD/TRD41_XSD/mgcp/mgcp.xsd",GAIT_HOME_DIR);
	}
  }
  else if((XML_TRD_TYPE==42)||(XML_TRD_TYPE==43))
  {
    if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
	{
      sprintf(XSDname,"%sMGCP_XSD\\TRD42_XSD\\mgcp\\mgcp.xsd",GAIT_HOME_DIR);
	}
    else
	{
      sprintf(XSDname,"%sMGCP_XSD/TRD42_XSD/mgcp/mgcp.xsd",GAIT_HOME_DIR);
	}
  }
  else if(XML_TRD_TYPE==44)
  {
    if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
	{
      sprintf(XSDname,"%sMGCP_XSD\\TRD44_XSD\\mgcp\\mgcp.xsd",GAIT_HOME_DIR);
	}
    else
	{
      sprintf(XSDname,"%sMGCP_XSD/TRD44_XSD/mgcp/mgcp.xsd",GAIT_HOME_DIR);
	}
  }
  else
  {
    printf("Internal error: bad DN4: %d\n",XML_TRD_TYPE);
	return;
  }



  len = strlen(XML1name);

  if(len<4)
  {
	if(len==0)
	{
	  sprintf(message,"You must enter the name of the XML file to be validated");
	}
	else
	{
	  sprintf(message,"The XML file entered does not end in \".xml\":\n%s",XML1name);
	}
    not_while_running(parent_wid,message,1491,"Bad XML filename",1);
	return;
  }
  if(
	  (strcmp(&XML1name[len-4],".xml")) &&
	  (strcmp(&XML1name[len-4],".XML"))
	)
  {
	sprintf(message,"The XML file entered does not end in \".xml\":\n%s",XML1name);
    not_while_running(parent_wid,message,1492,"Bad XML filename",1);
	return;
  }


  testfile = fopen(XML1name,"r");
  if(testfile==NULL)
  {
	sprintf(message,"Could not open for reading:\n%s",XML1name);
    not_while_running(parent_wid,message,1488,"Couldnt open file",1);
	return;
  }
  fclose(testfile);


  if(XML2name!=NULL)
  {
	if(strlen(XML2name)>5)
	{
      testfile = fopen(XML2name,"r");
      if(testfile==NULL)
	  { 
	    sprintf(message,"Could not open for reading:\n%s",XML2name);
        not_while_running(parent_wid,message,1488,"Couldnt open file",1);
	    return;
	  }  
      fclose(testfile);
	} 
  }


  len = strlen(XSDname);

  if(len>0)
  {
    if(len<4)
	{ 
	  sprintf(message,"The XSD file entered does not end in \".xsd\":\n%s",XSDname);
      not_while_running(parent_wid,message,1493,"Bad XSD filename",1);
	  return;
	}
    if(
	    (strcmp(&XSDname[len-4],".xsd")) &&
	    (strcmp(&XSDname[len-4],".XSD"))
      )
	{ 
	  sprintf(message,"The XSD file entered does not end in \".xsd\":\n%s",XSDname);
      not_while_running(parent_wid,message,1494,"Bad XSD filename",1);
	  return;
	} 


    testfile = fopen(XSDname,"r");
    if(testfile==NULL)
	{
	  sprintf(message,"Could not open for reading:\n%s\n",XSDname);
      not_while_running(parent_wid,message,1489,"Couldnt open file",1);
	  do_xsd = 0;
	} 
	else
	{
      fclose(testfile);
	  do_xsd = 1;
	}
  }



  len = strlen(XML3name);

  if(len>0)
  {
    if(
	    (strcmp(&XML3name[len-4],".txt")) &&
	    (strcmp(&XML3name[len-4],".TXT"))
      )
	{ 
	  sprintf(message,"The text file entered does not end in \".txt\":\n%s",XML3name);
      not_while_running(parent_wid,message,1495,"Bad text result filename",1);
	  return;
	} 

    testfile = fopen(XML3name,"wt");
    if(testfile==NULL)
	{
	  sprintf(message,"Could not open for writing:\n%s\nTo use the default name, enter nothing in this field",XML3name);
      not_while_running(parent_wid,message,1490,"Couldnt open output file",1);
	  return;
	} 
    fclose(testfile);
	sprintf(savefilename,"%s",XML3name);
  }
  else
  {
    sprintf(savefilename,"%s",XML1name);
    len = strlen(XML1name);

	sprintf(&savefilename[len-4],"results.txt");

    testfile = fopen(savefilename,"wt");
    if(testfile==NULL)
	{
	  sprintf(message,"Could not open for writing:\n%s\nYou may need to enter an output filename where you have permissions to write",savefilename);
      not_while_running(parent_wid,message,1496,"Couldnt open output file",1);
	  return;
	} 
    fclose(testfile);
  }


  StartTime = time(NULL);


  if(XML_TRD_TYPE==1)
  {
	XML_RUNNING = 0;

	ReportXMLProgress(parent_wid,-1,"",savefilename,-1,-1,alldatafiles);
    
	success = ParseXML2(1,do_xsd,XML1name,XSDname,XML2name,savefilename,&junk,&junk1,&junk2,-1);

	if(XML_RUNNING==1)
	{
	  XtDestroyWidget(xml_running);
	}
	XML_RUNNING = 0;

	if(success==1)
	{
	  ReportXMLProgress(parent_wid,-3,"",savefilename,-1,-1,alldatafiles);
	}
	else
	{
      if(strlen(GErr)>0)
	  {
        sprintf(message,"%s",GErr);
	  }
      else
	  {
        sprintf(message,"Failed to validate XML...see console window for more details\n");
	  }
      not_while_running(parent_wid,message,1500,"Failed to validate XML",1);
	}
  }
  else if(XML_TRD_TYPE==2)
  {
	XML_RUNNING = 0;

	ReportXMLProgress(parent_wid,-1,"",savefilename,-1,-1,alldatafiles);
    
	success = ParseXML2(2,do_xsd,XML1name,XSDname,XML2name,savefilename,&junk,&junk1,&junk2,-1);

	if(XML_RUNNING==1)
	{
	  XtDestroyWidget(xml_running);
	}
	XML_RUNNING = 0;

	if(success==1)
	{
	  ReportXMLProgress(parent_wid,-3,"",savefilename,-1,-1,alldatafiles);
	}
	else
	{
      if(strlen(GErr)>0)
	  {
        sprintf(message,"%s",GErr);
	  }
      else
	  {
        sprintf(message,"Failed to validate XML...see console window for more details\n");
	  }
      not_while_running(parent_wid,message,1500,"Failed to validate XML",1);
	}
  }
  else if(XML_TRD_TYPE==3)
  {
	XML_RUNNING = 0;

	ReportXMLProgress(parent_wid,-1,"",savefilename,-1,-1,alldatafiles);

    success = ParseXML2(3,do_xsd,XML1name,XSDname,XML2name,savefilename,&junk,&junk1,&junk2,-1);

	if(XML_RUNNING==1)
	{
	  XtDestroyWidget(xml_running);
	}
	XML_RUNNING = 0;

	if(success==1)
	{
	  ReportXMLProgress(parent_wid,-3,"",savefilename,-1,-1,alldatafiles);
	}
	else
	{
      if(strlen(GErr)>0)
	  {
        sprintf(message,"%s",GErr);
	  }
      else
	  {
        sprintf(message,"Failed to validate XML...see console window for more details\n");
	  }
      not_while_running(parent_wid,message,1500,"Failed to validate XML",1);
	}
  }
  else if((XML_TRD_TYPE==4)||(XML_TRD_TYPE==41)||(XML_TRD_TYPE==42)||(XML_TRD_TYPE==43)||(XML_TRD_TYPE==44))
  {
	XML_RUNNING = 0;

	if(batch_mode==0)
	{
	  ReportXMLProgress(parent_wid,-1,"",savefilename,-1,-1,alldatafiles);
	}

    success = ParseXML2(XML_TRD_TYPE,do_xsd,XML1name,XSDname,XML2name,savefilename,&junk,&junk1,&junk2,-1);

	if(XML_RUNNING==1)
	{
	  XtDestroyWidget(xml_running);
	}
	XML_RUNNING = 0;

	if(success==1)
	{
	   if(batch_mode==0)
	   {  
	     ReportXMLProgress(parent_wid,-3,"",savefilename,-1,-1,alldatafiles);
	   }
	 }
	else
	{
      if(strlen(GErr)>0)
	  {
        sprintf(message,"%s",GErr);
	  }
      else
	  {
        sprintf(message,"Failed to validate XML...see console window for more details\n");
	  }
      not_while_running(parent_wid,message,1500,"Failed to validate XML",1);
	}
  }
  else
  {
    XBell(mydisplay,50);
	printf("Error: DTD2: %d\n",XML_TRD_TYPE);
  }

}




Widget BuildXMLMenu(Widget parent,int menu_type,char *menu_title,MenuItem *items)
{
  Widget menu, cascade, widget;
  int i,n=0;
  XmString str;
  Arg args[5];
  
  menu = XmCreatePulldownMenu (parent, "_pulldown", NULL, 0);
  
  str = XmStringCreateLocalized (menu_title);
  XtSetArg (args[n], XmNsubMenuId, menu);  n++;
  XtSetArg (args[n], XmNlabelString, str); n++;
  XtSetArg (args[n], XmNtranslations, XtParseTranslationTable ( translations_global )); n++;

  cascade = XmCreateOptionMenu (parent, menu_title, args, n);
  XmStringFree (str);
  

  for (i = 0; items[i].label != NULL; i++) 
    {
      widget = XtVaCreateManagedWidget (items[i].label,
					*items[i].cclass, menu,
					NULL);
    
      if (   
		  ((i+1)==XML_TRD_TYPE)        || 
		  ((i==4)&&(XML_TRD_TYPE==41)) || 
		  ((i==5)&&(XML_TRD_TYPE==42)) || 
		  ((i==6)&&(XML_TRD_TYPE==43)) || 
		  ((i==7)&&(XML_TRD_TYPE==44))
		  )
	{
	  XtVaSetValues(cascade,				
			XmNmenuHistory, widget,
			NULL);
	}

      if (items[i].callback)
	XtAddCallback (widget,
		       (items[i].cclass == &xmToggleButtonWidgetClass ||
			items[i].cclass == &xmToggleButtonWidgetClass) ?
		       XmNvalueChangedCallback : 
		       XmNactivateCallback,      
		       (XtCallbackProc)items[i].callback, items[i].callback_data);
    }

  return menu_type == XmMENU_POPUP ? menu : cascade;
}




Widget BuildDPMenu(Widget parent,int menu_type,char *menu_title,MenuItem *items)
{
  Widget menu, cascade, widget;
  int i,n=0;
  XmString str;
  Arg args[5];
  
  menu = XmCreatePulldownMenu (parent, "_pulldown", NULL, 0);
  
  str = XmStringCreateLocalized (menu_title);
  XtSetArg (args[n], XmNsubMenuId, menu);  n++;
  XtSetArg (args[n], XmNlabelString, str); n++;
  XtSetArg (args[n], XmNtranslations, XtParseTranslationTable ( translations_global )); n++;

  cascade = XmCreateOptionMenu (parent, menu_title, args, n);
  XmStringFree (str);
  

  for (i = 0; items[i].label != NULL; i++) 
    {
      widget = XtVaCreateManagedWidget (items[i].label,
					*items[i].cclass, menu,
					NULL);
    
      if (
		  ((i==0)&&(DP_TRD_TYPE==3))  ||
		  ((i==1)&&(DP_TRD_TYPE==4))  ||
		  ((i==2)&&(DP_TRD_TYPE==41)) ||
		  ((i==3)&&(DP_TRD_TYPE==42)) ||
		  ((i==4)&&(DP_TRD_TYPE==43)) ||
		  ((i==5)&&(DP_TRD_TYPE==44))
		 )
	{
	  XtVaSetValues(cascade,				
			XmNmenuHistory, widget,
			NULL);
	}

      if (items[i].callback)
	XtAddCallback (widget,
		       (items[i].cclass == &xmToggleButtonWidgetClass ||
			items[i].cclass == &xmToggleButtonWidgetClass) ?
		       XmNvalueChangedCallback : 
		       XmNactivateCallback,      
		       (XtCallbackProc)items[i].callback, items[i].callback_data);
    }

  return menu_type == XmMENU_POPUP ? menu : cascade;
}





int BadShapeInput()
{
  
  
  
  char aline[1000],message[1000],part1[1000],part2[1000],part3[1000],try1[1000];
  FILE *testfile,*testfile2;
  int linenum,i,totallen,numquotes;
  int found_diacritics=0,num_tables=0,type=0;
  
  printf("testing (3) %s\n",importdirectory);

  testfile = fopen(importdirectory,"r");
  if(testfile==NULL)
    {
      sprintf(message,"Cannot open file %s!\n",importdirectory);
      not_while_running(drawing_a,message,1135,"Bad Input File",1);
      return 1;
    }
  
  
  fgets(aline,1000,testfile);
  if(feof(testfile))
    {
      sprintf(message,"File %s\ncontains no specifications.",importdirectory);
      not_while_running(drawing_a,message,1135,"Bad Input File",1);
      return 1;
    }
  
  
  linenum = 1;
  while(!feof(testfile))
    {
      for(i=0;i<1000;i++)
	{
	  part1[i] = '\0';
	  part2[i] = '\0';
	  part3[i] = '\0';
	}
      
      
      sscanf(aline,"%s%s%s",part1,part2,part3);
      
      
      
      
	  if(
	      (strcmp(part1,"GEOTIFF" ))          &&
	      (strcmp(part1,"NITF" ))             &&
	      (strcmp(part1,"DTED" ))             &&
	      (strcmp(part1,"SHAPE"))             &&
	      (strcmp(part1,"SHAPE_0"))           &&
	      (strcmp(part1,"SHAPE_1"))           &&
	      (strcmp(part1,"SHAPE_2"))           &&
	      (strcmp(part1,"SHAPE_3"))           &&
	      (strcmp(part1,"ZIPSHAPE"))          &&
	      (strcmp(part1,"OBJECTSPACE"))       &&
	      (strcmp(part1,"GEODATABASE"))       &&
	      (strcmp(part1,"GEOMEDIAACC"))       &&
	      (strcmp(part1,"GEODATABASE_TABLE")) &&
	      (strcmp(part1,"GEOMEDIAACC_TABLE")) 
		  )
	  {
        sprintf(message,"Error in input source file %s,\n line %d!\n\n\
Expected one of:\n\
SHAPE, GEODATABASE, GEODATABASE_TABLE, GEOMEDIAACC, GEOMEDIAACC_TABLE,\n\
OBJECTSPACE, DTED, GEOTIFF, NITF, or ZIPSHAPE, but got:  %s\n\n\
GAIT cannot import this input source file until this problem is corrected.",
		  importdirectory,linenum,part1);
	  
	  not_while_running(drawing_a,message,1381,"Bad Input File",1);
	  return 1;	  
	  }


      if(
	 (!strcmp(part1,"OBJECTSPACE_OSFILE"))||
	 (!strcmp(part1,"OBJECTSPACE_CONNECTSTRING"))||
	 (!strcmp(part1,"OBJECTSPACETABLE"))
	 )
	{
	  sprintf(message,"Error in input source file %s,\n line %d!\n\n\
Expected SHAPE, DTED, or OBJECTSPACE, got %s\n\n\
GAIT cannot import this input source file until this problem is corrected.\n\n\
This problem often occurs when there is a mismatch between the number\n\
of OBJECTSPACETABLE lines expected and the number found.",
		  importdirectory,linenum,part1);
	  
	  not_while_running(drawing_a,message,1381,"Bad Input File",1);
	  return 1;
	}
      
      if(
	 (strcmp(part1,"OBJECTSPACE"))  &&
	 (strcmp(part1,"GEODATABASE"))  &&
	 (strcmp(part1,"GEOMEDIAACC"))
	 )
	{
	  sprintf(part3,"%s",GetLastPart(aline));
	}
      
      
      
      
      found_diacritics = 0;
      for(i=0;i<(int)strlen(part3);i++)
	{
	  if(part3[i]<0)
	    {
	      found_diacritics = 1;
	    }
	}
      
      
      
      if(
		  (
		    (!strcmp(part1,"SHAPE"))   || 
		    (!strcmp(part1,"SHAPE_0")) || 
		    (!strcmp(part1,"SHAPE_1")) || 
		    (!strcmp(part1,"SHAPE_2")) || 
		    (!strcmp(part1,"SHAPE_3")) || 
		    (!strcmp(part1,"ZIPSHAPE")))  &&
		   (found_diacritics==0))
	{
	 
	  if(!strcmp(part1,"SHAPE_0"))
	  {
		sprintf(part1,"SHAPE");
		global_trex_shape_layer = 0;
	  }
	  if(!strcmp(part1,"SHAPE_1"))
	  {
		sprintf(part1,"SHAPE");
		global_trex_shape_layer = 1;
	  }
	  if(!strcmp(part1,"SHAPE_2"))
	  {
		sprintf(part1,"SHAPE");
		global_trex_shape_layer = 2;
	  }
	  if(!strcmp(part1,"SHAPE_3"))
	  {
		sprintf(part1,"SHAPE");
		global_trex_shape_layer = 3;
	  }
		  



	  if(strcmp(part2,"*****"))
	    {
	      if(SilentConvertClassCode(part2)==-100)
		{
		  sprintf(message,"Error in input source file %s,\n line %d!\n\n\
\"%s\" is not a valid FCODE.\n\n\
GAIT cannot import this input source file until this problem is corrected",
			  importdirectory,linenum,part2);
		  
		  not_while_running(drawing_a,message,1136,"Bad Input File",1);
		  return 1;
		}
	    }
	  

	  if(!strcmp(part1,"SHAPE"))
	  {
	    
	    sprintf(try1,"%s.shp",part3); 
	    testfile2 = fopen(try1,"r");
	    if(testfile2==NULL)
	    {
	      sprintf(try1,"%s.SHP",part3); 
	      testfile2 = fopen(try1,"r");
	      if(testfile2==NULL)
		  {
		    sprintf(message,"Error in input source file %s,\n line %d!\n\n\
\"%s\" is not a valid Shapefile root name\n\
This means GAIT could not open either of:\n\
\"%s.shp\"\n\
\"%s.SHP\"\n\
Either neither of these files exist, or you do not have\n\
permissions to read them.\n\n\
GAIT cannot import this input source file until this problem is corrected",
			  importdirectory,linenum,part3,part3,part3);
		  
		  not_while_running(drawing_a,message,1137,"Bad Input File",1);
		  return 1;
		  
		}
	      else
		{
		  fclose(testfile2);
		}
	    }
	  else
	    {
	      fclose(testfile2);
	    }
	  
	  
	  
	  
	  sprintf(try1,"%s.shx",part3); 
	  testfile2 = fopen(try1,"r");
	  if(testfile2==NULL)
	    {
	      sprintf(try1,"%s.SHX",part3); 
	      testfile2 = fopen(try1,"r");
	      if(testfile2==NULL)
		{
		  sprintf(message,"Error in input source file %s,\n line %d!\n\n\
\"%s\" is not a valid Shapefile root name\n\
This means GAIT could not open either of:\n\
\"%s.shx\"\n\
\"%s.SHX\"\n\
Either neither of these files exist, or you do not have\n\
permissions to read them.\n\n\
GAIT cannot import this input source file until this problem is corrected",
			  importdirectory,linenum,part3,part3,part3);
		  
		  not_while_running(drawing_a,message,1138,"Bad Input File",1);
		  return 1;
		  
		}
	      else
		{
		  fclose(testfile2);
		}
	    }
	  else
	    {
	      fclose(testfile2);
	    }
	  
	  
	  
	  
	  sprintf(try1,"%s.dbf",part3); 
	  testfile2 = fopen(try1,"r");
	  if(testfile2==NULL)
	    {
	      sprintf(try1,"%s.DBF",part3); 
	      testfile2 = fopen(try1,"r");
	      if(testfile2==NULL)
		{
		  sprintf(message,"Error in input source file %s,\n line %d!\n\n\
\"%s\" is not a valid Shapefile root name\n\
This means GAIT could not open either of:\n\
\"%s.dbf\"\n\
\"%s.DBF\"\n\
Either neither of these files exist, or you do not have\n\
permissions to read them.\n\n\
GAIT cannot import this input source file until this problem is corrected",
			  importdirectory,linenum,part3,part3,part3);
		  
		  not_while_running(drawing_a,message,1139,"Bad Input File",1);
		  return 1;
		  
		}
	      else
		{
		  fclose(testfile2);
		}
	    }
	  else
	    {
	      fclose(testfile2);
	    }
	  }
	}
      else if (!strcmp(part1,"DTED"))
	{

      

      if(aline[5]!='"')
	  {
	      sprintf(message,"Error in input source file %s,\n line %d!\n\n\
The layer identifier for DTED must be in quotes.\n\n\
GAIT cannot import this input source file until this problem is corrected",
		      importdirectory,linenum);
	      
	      not_while_running(drawing_a,message,1441,"Bad Input File",1);
	      return 1;
	  }

      numquotes = 0;
      for(i=0;i<(int)strlen(aline);i++)
	  {
	    if(aline[i]=='"')
		{
			numquotes = numquotes + 1;
		}
	  }

	   if(numquotes!=4)
	  {
	      sprintf(message,"Error in input source file %s,\n line %d!\n\n\
The layer identifier and filename for DTED must be in quotes,\n\
and quotes may not be used inside the layer identifier or filename.\n\n\
GAIT cannot import this input source file until this problem is corrected",
		      importdirectory,linenum);
	      
	      not_while_running(drawing_a,message,1442,"Bad Input File",1);
	      return 1;
	  }


      numquotes = 0;
      for(i=0;i<(int)strlen(aline);i++)
	  {
	    if(aline[i]=='"')
		{
			numquotes = numquotes + 1;
			if(numquotes==2)
			{
				if((aline[i+1]!=' ')||(aline[i+2]!='"'))
				{
	      sprintf(message,"Error in input source file %s,\n line %d!\n\n\
Line must be of the form DTED \"<layer>\" \"<path>.dt[0123]\"\n\
GAIT cannot import this input source file until this problem is corrected",
		      importdirectory,linenum);
	      
	      not_while_running(drawing_a,message,1443,"Bad Input File",1);
	      return 1;
				}
			}
		}
	  }



	  if(strlen(part3)<5)
	    {
	      sprintf(message,"Error in input source file %s,\n line %d!\n\n\
\"%s\" is not a valid DTED file name\n\
Valid DTED file names end in \".dt0\", \".dt1\", \".dt2\", or \".dt3\"\n\n\
GAIT cannot import this input source file until this problem is corrected",
		      importdirectory,linenum,part3);
	      
	      not_while_running(drawing_a,message,1140,"Bad Input File",1);
	      return 1;
	    }
	  
	  
	  testfile2 = fopen(part3,"r");
	  if(testfile2==NULL)
	    {
	      sprintf(message,"Error in input source file %s,\n line %d!\n\n\
GAIT was unable to open DTED file name:\n\
\"%s\"\n\
Either the file does not exist, or you do not have\n\
permissions to read it.\n\n\
GAIT cannot import this input source file until this problem is corrected",
		      importdirectory,linenum,part3);
	      
	      not_while_running(drawing_a,message,1141,"Bad Input File",1);
	      return 1;
	    }
	  else
	    {
	      fclose(testfile2);
	    }
	  
	  
	  
	  totallen = strlen(part3);
	  if(
	     ((part3[totallen-1]!= '0') &&
	      (part3[totallen-1]!= '1') &&
	      (part3[totallen-1]!= '2') && 
	      (part3[totallen-1]!= '3')
	      )
	     ||
	     ((part3[totallen-2]!= 'T') && (part3[totallen-2]!= 't'))
	     ||
	     ((part3[totallen-3]!= 'D') && (part3[totallen-3]!= 'd'))
	     ||
	     (part3[totallen-4]!= '.') 
	     )
	    {
	      sprintf(message,"Error in input source file %s,\n line %d!\n\n\
\"%s\" is not a valid DTED file name\n\
Valid DTED file names end in \".dt0\", \".dt1\", \".dt2\", or \".dt3\"\n\n\
GAIT cannot import this input source file until this problem is corrected",
		      importdirectory,linenum,part3);
	      
	      not_while_running(drawing_a,message,1142,"Bad Input File",1);
	      return 1;
	    }
	}
      
      else if(
	      (!strcmp(part1,"GEODATABASE")) ||
	      (!strcmp(part1,"GEOMEDIAACC"))
	      )
	{
	  if(!strcmp(part1,"GEODATABASE"))
	    {
	      type = 1;
	    }
	  else if(!strcmp(part1,"GEOMEDIAACC"))
	    {
	      type = 2;
	    }
	  
	  printf("found %s\n",part1);
	  
	  sscanf(aline,"%s%s%d",part1,part2,&num_tables);
	  if(strcmp(part2,"NUM_TABLES"))
	    {
	      sprintf(message,"Error in input source file %s,\n line %d!\n\n\
Expected NUM_TABLES, got %s\n\n\
GAIT cannot import this input source file until this problem is corrected",
		      importdirectory,linenum,part2);
	      
	      not_while_running(drawing_a,message,1377,"Bad Input File",1);
	      return 1;
	    }
	  
	  
	  fgets(aline,1000,testfile);
	  linenum++;
	  
	  sscanf(aline,"%s",part1);
	  
	  if(type==1)
	    {
	      if(strcmp(part1,"GEODATABASE"))
		{
		  sprintf(message,"Error in input source file %s,\n line %d!\n\n\
Expected GEODATABASE, got %s\n\n\
GAIT cannot import this input source file until this problem is corrected",
			  importdirectory,linenum,part1);
		  
		  not_while_running(drawing_a,message,1378,"Bad Input File",1);
		  return 1;
		}
	    }
	  else if(type==2)
	    {
	      if(strcmp(part1,"GEOMEDIAACC"))
		{
		  sprintf(message,"Error in input source file %s,\n line %d!\n\n\
Expected GEOMEDIAACC, got %s\n\n\
GAIT cannot import this input source file until this problem is corrected",
			  importdirectory,linenum,part1);
		  
		  not_while_running(drawing_a,message,1378,"Bad Input File",1);
		  return 1;
		}
	    }
	  
	  
	  for(i=0;i<num_tables;i++)
	    {
	      
	      fgets(aline,1000,testfile);
	      
	      
	      if(feof(testfile))
		{
		  if(type==1)
		    {
		      sprintf(message,"Error in input source file %s,\n line %d!\n\n\
Expected %d GEODATABASE_TABLE entries, got %d\n\n\
GAIT cannot import this input source file until this problem is corrected",
			      importdirectory,linenum,num_tables,i);
		    }
		  else if(type==2)
		    {
		      sprintf(message,"Error in input source file %s,\n line %d!\n\n\
Expected %d GEOMEDIAACC_TABLE entries, got %d\n\n\
GAIT cannot import this input source file until this problem is corrected",
			      importdirectory,linenum,num_tables,i);
		    }
		  
		  not_while_running(drawing_a,message,1408,"Bad Input File",1);
		  
		  return 1;
		}
	      
	      
	      
	      sscanf(aline,"%s%s%s",part1,part2,part3);
	      if(type==1)
		{
		  if(strcmp(part1,"GEODATABASE_TABLE"))
		    {
		      sprintf(message,"Error in input source file %s,\n line %d!\n\n\
Expected GEODATABASE_TABLE, got %s.\n\n\
GAIT cannot import this input source file until this problem is corrected",
			      importdirectory,linenum,part1);
		      
		      not_while_running(drawing_a,message,1385,"Bad Input File",1);
		      return 1;
		    }
		}
	      else if(type==2)
		{
		  if(strcmp(part1,"GEOMEDIAACC_TABLE"))
		    {
		      sprintf(message,"Error in input source file %s,\n line %d!\n\n\
Expected GEOMEDIAACC_TABLE, got %s.\n\n\
GAIT cannot import this input source file until this problem is corrected",
			      importdirectory,linenum,part1);
		      
		      not_while_running(drawing_a,message,1385,"Bad Input File",1);
		      return 1;
		    }
		}
	      
	      
	      
	      if(strcmp(part2,"*****"))
		{
		  if(SilentConvertClassCode(part2)==-100)
		    {
		      sprintf(message,"Error in input source file %s,\n line %d!\n\n\
\"%s\" is not a valid FCODE.\n\n\
GAIT cannot import this input source file until this problem is corrected",
			      importdirectory,linenum,part2);
		      
		      not_while_running(drawing_a,message,1386,"Bad Input File",1);
		      return 1;
		    }
		}
	      
	      
	      linenum++;
	      
	    }
	  
	}
      
      else if(!strcmp(part1,"OBJECTSPACE"))
	{
	  sscanf(aline,"%s%s%d",part1,part2,&num_tables);
	  if(strcmp(part2,"NUM_TABLES"))
	    {
	      sprintf(message,"Error in input source file %s,\n line %d!\n\n\
Expected NUM_TABLES, got %s\n\n\
GAIT cannot import this input source file until this problem is corrected",
		      importdirectory,linenum,part2);
	      
	      not_while_running(drawing_a,message,1377,"Bad Input File",1);
	      return 1;
	    }
	  
	  
	  fgets(aline,1000,testfile);
	  linenum++;
	  sscanf(aline,"%s",part1);
	  
	  if(strcmp(part1,"OBJECTSPACE_OSFILE"))
	    {
	      sprintf(message,"Error in input source file %s,\n line %d!\n\n\
Expected OBJECTSPACE_OSFILE, got %s\n\n\
GAIT cannot import this input source file until this problem is corrected",
		      importdirectory,linenum,part1);
	      
	      not_while_running(drawing_a,message,1378,"Bad Input File",1);
	      return 1;
	    }
	  
	  fgets(aline,1000,testfile);
	  linenum++;
	  sscanf(aline,"%s",part1);
	  if(strcmp(part1,"OBJECTSPACE_CONNECTSTRING"))
	    {
	      sprintf(message,"Error in input source file %s,\n line %d!\n\n\
Expected OBJECTSPACE_CONNECTSTRING, got %s\n\n\
GAIT cannot import this input source file until this problem is corrected",
		      importdirectory,linenum,part1);

	      not_while_running(drawing_a,message,1379,"Bad Input File",1);
	      return 1;
	    }
	  
	  
	  for(i=0;i<num_tables;i++)
	    {
	      
	      fgets(aline,1000,testfile);
	      
	      
	      if(feof(testfile))
		{
		  
		  sprintf(message,"Error in input source file %s,\n line %d!\n\n\
Expected %d OBJECTSPACETABLE entries, got %d\n\n\
GAIT cannot import this input source file until this problem is corrected",
			  importdirectory,linenum,num_tables,i);
		  return 1;
		}



	      sscanf(aline,"%s%s%s",part1,part2,part3);
	      if(strcmp(part1,"OBJECTSPACETABLE"))
		{
		  sprintf(message,"Error in input source file %s,\n line %d!\n\n\
Expected OBJECTSPACETABLE, got %s.\n\n\
GAIT cannot import this input source file until this problem is corrected",
			   importdirectory,linenum,part1);
		  
		  not_while_running(drawing_a,message,1385,"Bad Input File",1);
		  return 1;
		}
	      
	      
	      
	      if(strcmp(part2,"*****"))
		{
		  if(SilentConvertClassCode(part2)==-100)
		    {
		      sprintf(message,"Error in input source file %s,\n line %d!\n\n\
\"%s\" is not a valid FCODE.\n\n\
GAIT cannot import this input source file until this problem is corrected",
			      importdirectory,linenum,part2);
		      
		      not_while_running(drawing_a,message,1386,"Bad Input File",1);
		      return 1;
		    }
		}
	      
	      
	      linenum++;
	      
	    }
	  
	  
	}












      else if(!strcmp(part1,"GEOTIFF"))
	{
	  



      

      if(aline[8]!='"')
	  {
	      sprintf(message,"Error in input source file %s,\n line %d!\n\n\
The layer identifier for GEOTIFF must be in quotes.\n\n\
GAIT cannot import this input source file until this problem is corrected",
		      importdirectory,linenum);
	      
	      not_while_running(drawing_a,message,1444,"Bad Input File",1);
	      return 1;
	  }

      numquotes = 0;
      for(i=0;i<(int)strlen(aline);i++)
	  {
	    if(aline[i]=='"')
		{
			numquotes = numquotes + 1;
		}
	  }

	   if(numquotes!=4)
	  {
	      sprintf(message,"Error in input source file %s,\n line %d!\n\n\
The layer identifier and filename for GEOTIFF must be in quotes,\n\
and quotes may not be used inside the layer identifier or filename.\n\n\
GAIT cannot import this input source file until this problem is corrected",
		      importdirectory,linenum);
	      
	      not_while_running(drawing_a,message,1445,"Bad Input File",1);
	      return 1;
	  }


      numquotes = 0;
      for(i=0;i<(int)strlen(aline);i++)
	  {
	    if(aline[i]=='"')
		{
			numquotes = numquotes + 1;
			if(numquotes==2)
			{
				if((aline[i+1]!=' ')||(aline[i+2]!='"'))
				{
	      sprintf(message,"Error in input source file %s,\n line %d!\n\n\
Line must be of the form GEOTIFF \"<layer>\" \"<path>\"\n\
GAIT cannot import this input source file until this problem is corrected",
		      importdirectory,linenum);
	      
	      not_while_running(drawing_a,message,1446,"Bad Input File",1);
	      return 1;
				}
			}
		}
	  }
	 }




      else if(!strcmp(part1,"NITF"))
	{
	  



      

      if(aline[5]!='"')
	  {
	      sprintf(message,"Error in input source file %s,\n line %d!\n\n\
The layer identifier for NITF must be in quotes.\n\n\
GAIT cannot import this input source file until this problem is corrected",
		      importdirectory,linenum);
	      
	      not_while_running(drawing_a,message,1444,"Bad Input File",1);
	      return 1;
	  }

      numquotes = 0;
      for(i=0;i<(int)strlen(aline);i++)
	  {
	    if(aline[i]=='"')
		{
			numquotes = numquotes + 1;
		}
	  }

	   if(numquotes!=4)
	  {
	      sprintf(message,"Error in input source file %s,\n line %d!\n\n\
The layer identifier and filename for NITF must be in quotes,\n\
and quotes may not be used inside the layer identifier or filename.\n\n\
GAIT cannot import this input source file until this problem is corrected",
		      importdirectory,linenum);
	      
	      not_while_running(drawing_a,message,1445,"Bad Input File",1);
	      return 1;
	  }


      numquotes = 0;
      for(i=0;i<(int)strlen(aline);i++)
	  {
	    if(aline[i]=='"')
		{
			numquotes = numquotes + 1;
			if(numquotes==2)
			{
				if((aline[i+1]!=' ')||(aline[i+2]!='"'))
				{
	      sprintf(message,"Error in input source file %s,\n line %d!\n\n\
Line must be of the form NITF \"<layer>\" \"<path>\"\n\
GAIT cannot import this input source file until this problem is corrected",
		      importdirectory,linenum);
	      
	      not_while_running(drawing_a,message,1446,"Bad Input File",1);
	      return 1;
				}
			}
		}
	  }
	 }



	  else
	  {
         printf("BAD LINE %s\n",aline);  
	  }
      
      fgets(aline,1000,testfile);
      linenum++;
    }
  
  
  fclose(testfile);
  return 0;
}




void xml_trd_cb(Widget menu_item,XtPointer client_data,XtPointer call_data)
{
  int item_no = (int) client_data;
  
  XML_TRD_TYPE = item_no;

}

void dp_trd_cb(Widget menu_item,XtPointer client_data,XtPointer call_data)
{
  int item_no = (int) client_data;
  
  DP_TRD_TYPE = item_no;
}

void XMLCallback(Widget w, XtPointer userData, XtPointer callData)
{
  static Widget xmlhead;
  Widget rc,form,button, browse_button,label1;
  Arg resources[20];
  char title[21][100];
  int n,lines,i;
  Dimension Pheight;

  MenuItem trd_type[] = {
    {"TRD1",   &xmPushButtonWidgetClass,'!', NULL, NULL, (void (*)())xml_trd_cb, (XtPointer)1,  (MenuItem *) NULL},
    {"TRD2",   &xmPushButtonWidgetClass,'!', NULL, NULL, (void (*)())xml_trd_cb, (XtPointer)2,  (MenuItem *) NULL},
    {"TRD3",   &xmPushButtonWidgetClass,'!', NULL, NULL, (void (*)())xml_trd_cb, (XtPointer)3,  (MenuItem *) NULL},
    {"TRD4.0", &xmPushButtonWidgetClass,'!', NULL, NULL, (void (*)())xml_trd_cb, (XtPointer)4,  (MenuItem *) NULL},
    {"TRD4.1", &xmPushButtonWidgetClass,'!', NULL, NULL, (void (*)())xml_trd_cb, (XtPointer)41, (MenuItem *) NULL},
    {"TRD4.2", &xmPushButtonWidgetClass,'!', NULL, NULL, (void (*)())xml_trd_cb, (XtPointer)42, (MenuItem *) NULL},
    {"TRD4.3", &xmPushButtonWidgetClass,'!', NULL, NULL, (void (*)())xml_trd_cb, (XtPointer)43, (MenuItem *) NULL},
    {"TRD4.4", &xmPushButtonWidgetClass,'!', NULL, NULL, (void (*)())xml_trd_cb, (XtPointer)44, (MenuItem *) NULL},
    {NULL},
  };

  if(dead_xml==1)
    {
      n=0;
      XtSetArg(resources[n],  XmNdeleteResponse, XmDESTROY); n++;
      XtSetArg(resources[n],  XmNmaxWidth,       820);       n++;  
      
      xmlhead = XtCreatePopupShell("Validate MGCP Cell XML",
				    topLevelShellWidgetClass,w,resources,n);


      rc = XtVaCreateWidget ("rowcol",xmRowColumnWidgetClass, xmlhead, NULL);


      sprintf(title[0],  "This window is used to Validate MGCP Cell Metadata files");
      title[1][0] = '\0';
      title[2][0] = '\0';
      sprintf(title[3],  "You must enter the full path to the XML file in the \"MGCP Cell XML file\" area");
      title[4][0] = '\0';
      title[5][0] = '\0';
      sprintf(title[6],  "The \"Refinement TXT file\" is optional, and, if supplied, enables the ability to specify");
      sprintf(title[7],  "a refined set of valid pick-list values to check.  For instance, there are many valid country");
      sprintf(title[8],  "codes, but this file could be used to allow only 1 of these valid codes to be acceptable.");
      title[9][0]  = '\0';
      title[10][0] = '\0';
      sprintf(title[11], "The optional \"Text File to Save Results\", if entered, will be used to save the");
      sprintf(title[12], "validation results.  If this file is not specified, the results will be saved to a file");
	  sprintf(title[13], "named: <XMLNAME>results.txt (ie, E000N00results.txt) in the same folder as the XML file");
      title[14][0] = '\0';
      title[15][0] = '\0';
      sprintf(title[16], "Cell shapefiles are also optional, and will be used if found in the same folder as the");
	  sprintf(title[17], "XML file or in a folder with the XML file named <CELLID> (ie, E000N00).  Providing cell");
	  sprintf(title[18], "shapefiles enables additional validation (feature counts, subregion feature content, etc)");
      title[19][0] = '\0';
      title[20][0] = '\0';

	  lines = 21;

      for(i=0;i<lines;i++)
	{
	  form = XtVaCreateWidget ("form7", xmFormWidgetClass, rc,
				   XmNfractionBase,  100,  
				   NULL);
	  
	  label1 = XtVaCreateManagedWidget (title[i],
					    xmLabelWidgetClass,  form,
					    XmNrightAttachment,  XmATTACH_POSITION,
					    XmNrightPosition,    99,
					    XmNleftAttachment,   XmATTACH_POSITION,
					    XmNleftPosition,     0,
					    XmNalignment,        XmALIGNMENT_CENTER,
					    XmNtopAttachment,    XmATTACH_FORM,
					    XmNbottomAttachment, XmATTACH_FORM,
					    LABELWTRANSLATE,
					    NULL);
	  XtManageChild(form);

	}







      form = XtVaCreateWidget ("form7", xmFormWidgetClass, rc,
			       XmNfractionBase,  100,  
			       NULL);


      label1 = XtVaCreateManagedWidget ("MGCP Cell XML file:",
					xmLabelWidgetClass,  form,
					XmNrightAttachment,  XmATTACH_POSITION,
					XmNrightPosition,    30,
					XmNleftAttachment,   XmATTACH_POSITION,
					XmNleftPosition,     0,
					XmNalignment,        XmALIGNMENT_CENTER,
					XmNtopAttachment,    XmATTACH_FORM,
					XmNbottomAttachment, XmATTACH_FORM,
					LABELWTRANSLATE,
					NULL);


      xml1_wid = XtVaCreateManagedWidget ("text_w",
					  xmTextFieldWidgetClass, form,	  
					  XmNvalue,               XML1name,
					  XmNtraversalOn,         True,
					  XmNrightAttachment,     XmATTACH_POSITION,
					  XmNrightPosition,       82,
					  XmNleftAttachment,      XmATTACH_POSITION,
					  XmNleftPosition,        30,
                      XmNtranslations,        XtParseTranslationTable ( translations_paste ) ,
					  NULL);
      
      XtAddCallback (xml1_wid, XmNactivateCallback,
		     EnterFileCallback, (XtPointer)27);



      browse_button  = XtVaCreateManagedWidget("Browse...",xmPushButtonWidgetClass,form,
					       XmNlabelString,      STRING("Browse..."),
					       XmNorientation,      XmVERTICAL,
					       XmNleftAttachment,   XmATTACH_POSITION,
					       XmNleftPosition,     82,
					       XmNrightAttachment,  XmATTACH_POSITION,
					       XmNrightPosition,    97,
					       XmNtopAttachment,    XmATTACH_FORM,
					       XmNbottomAttachment, XmATTACH_FORM,
					       XmNtraversalOn,      False,
					       XmNtranslations, XtParseTranslationTable ( translations_global ),
					       NULL
					       ); 

      XtAddCallback(browse_button, XmNactivateCallback,
		    BrowseCallback, (XtPointer) CHOOSE_XML1_BROWSE);
      XtManageChild(browse_button); 

      XtManageChild(form);





      form = XtVaCreateWidget ("form7", xmFormWidgetClass, rc,
			       XmNfractionBase,  100,  
			       NULL);
      

      label1 = XtVaCreateManagedWidget ("Refinement TXT file:",
					xmLabelWidgetClass,  form,
					XmNrightAttachment,  XmATTACH_POSITION,
					XmNrightPosition,    30,
					XmNleftAttachment,   XmATTACH_POSITION,
					XmNleftPosition,     0,
					XmNalignment,        XmALIGNMENT_CENTER,
					XmNtopAttachment,    XmATTACH_FORM,
					XmNbottomAttachment, XmATTACH_FORM,
					LABELWTRANSLATE,
					NULL);


      xml2_wid = XtVaCreateManagedWidget ("text_w",
					  xmTextFieldWidgetClass, form,	  
					  XmNvalue,               XML2name,
					  XmNtraversalOn,         True,
					  XmNrightAttachment,     XmATTACH_POSITION,
					  XmNrightPosition,       82,
					  XmNleftAttachment,      XmATTACH_POSITION,
					  XmNleftPosition,        30,
                      XmNtranslations,        XtParseTranslationTable ( translations_paste ) ,
					  NULL);

      XtAddCallback (xml2_wid, XmNactivateCallback,
		     EnterFileCallback, (XtPointer)28);
      
      browse_button  = XtVaCreateManagedWidget("Browse...",xmPushButtonWidgetClass,form,
					       XmNlabelString,      STRING("Browse..."),
					       XmNorientation,      XmVERTICAL,
					       XmNleftAttachment,   XmATTACH_POSITION,
					       XmNleftPosition,     82,
					       XmNrightAttachment,  XmATTACH_POSITION,
					       XmNrightPosition,    97,
					       XmNtopAttachment,    XmATTACH_FORM,
					       XmNbottomAttachment, XmATTACH_FORM,
					       XmNtraversalOn,      False,
					       XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					       NULL
					       ); 
      
      XtAddCallback(browse_button, XmNactivateCallback,
		    BrowseCallback, (XtPointer) CHOOSE_XML2_BROWSE);
      XtManageChild(browse_button); 

      XtManageChild(form);





      form = XtVaCreateWidget ("form7", xmFormWidgetClass, rc,
			       XmNfractionBase,  100,  
			       NULL);

      
      label1 = XtVaCreateManagedWidget ("Text File to Save Results:",
					xmLabelWidgetClass,  form,
					XmNrightAttachment,  XmATTACH_POSITION,
					XmNrightPosition,    30,
					XmNleftAttachment,   XmATTACH_POSITION,
					XmNleftPosition,     0,
					XmNalignment,        XmALIGNMENT_CENTER,
					XmNtopAttachment,    XmATTACH_FORM,
					XmNbottomAttachment, XmATTACH_FORM,
					LABELWTRANSLATE,
					NULL);
      
      
      xml3_wid = XtVaCreateManagedWidget ("text_w",
					  xmTextFieldWidgetClass, form,	  
					  XmNvalue,               XML3name,
					  XmNtraversalOn,         True,
					  XmNrightAttachment,     XmATTACH_POSITION,
					  XmNrightPosition,       82,
					  XmNleftAttachment,      XmATTACH_POSITION,
					  XmNleftPosition,        30,
                      XmNtranslations,        XtParseTranslationTable ( translations_paste ) ,
					  NULL);
      
      XtAddCallback (xml3_wid, XmNactivateCallback,
		     EnterFileCallback, (XtPointer)29);
      
      browse_button  = XtVaCreateManagedWidget("Browse...",xmPushButtonWidgetClass,form,
					       XmNlabelString,      STRING("Browse..."),
					       XmNorientation,      XmVERTICAL,
					       XmNleftAttachment,   XmATTACH_POSITION,
					       XmNleftPosition,     82,
					       XmNrightAttachment,  XmATTACH_POSITION,
					       XmNrightPosition,    97,
					       XmNtopAttachment,    XmATTACH_FORM,
					       XmNbottomAttachment, XmATTACH_FORM,
					       XmNtraversalOn,      False,
					       XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					       NULL
					       ); 
      
      XtAddCallback(browse_button, XmNactivateCallback,
		    BrowseCallback, (XtPointer) CHOOSE_XML3_BROWSE);
      XtManageChild(browse_button); 

      XtManageChild(form);




      form = XtVaCreateWidget ("form17a", xmFormWidgetClass, rc,
			       XmNfractionBase,  100,  
			       NULL);      

	  button = BuildXMLMenu (form, XmMENU_OPTION, "Validate Against:", trd_type);

      XtVaSetValues(button,
		    XmNtopAttachment,    XmATTACH_FORM,
		    XmNbottomAttachment, XmATTACH_FORM,
		    XmNrightAttachment,  XmATTACH_POSITION,
		    XmNrightPosition,    33,
		    XmNleftAttachment,   XmATTACH_POSITION,
		    XmNleftPosition,     1,
		    NULL);
	  
	  XtManageChild (button);
      


      button  = XtVaCreateManagedWidget("SCR3",xmPushButtonWidgetClass,form,
					XmNlabelString,      STRING("Perform Validation"),
					XmNtopAttachment,    XmATTACH_FORM,
					XmNbottomAttachment, XmATTACH_FORM,
					XmNrightAttachment,  XmATTACH_POSITION,
					XmNrightPosition,    66,
					XmNleftAttachment,   XmATTACH_POSITION,
					XmNleftPosition,     34,
					XmNtraversalOn,      False,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					NULL
					); 
      
      XtAddCallback(button, XmNactivateCallback, XMLwrapperCallback, (XtPointer)NULL);
      XtManageChild(button); 
      


      button  = XtVaCreateManagedWidget("SCR3",xmPushButtonWidgetClass,form,
					XmNlabelString,      STRING("Done"),
					XmNtopAttachment,    XmATTACH_FORM,
					XmNbottomAttachment, XmATTACH_FORM,		    
					XmNrightAttachment,  XmATTACH_POSITION,
					XmNrightPosition,    99,
					XmNleftAttachment,   XmATTACH_POSITION,
					XmNleftPosition,     67,
					XmNtraversalOn,      False,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					NULL
					); 
      
      XtAddCallback(button, XmNactivateCallback, die_callback, (XtPointer) 1031);
      XtManageChild(button); 
      XtManageChild(form);


      XtManageChild(rc);
      MyPopup(xmlhead); 
      XtAddCallback(xmlhead,XmNdestroyCallback,ShellDeath,(XtPointer)4082);
      

      dead_xml = 0;


      XtVaGetValues(xmlhead, XmNheight,    &Pheight,   NULL);	  
      XtVaSetValues(xmlhead, XmNminHeight,  Pheight, NULL);
      XtVaSetValues(xmlhead, XmNmaxHeight,  Pheight, NULL);

      XtAddEventHandler(xmlhead,StructureNotifyMask,False, myResizeHandler, (XtPointer)((int)Pheight));

    }
  else
    {
      ResetWidget(xmlhead);
    }
}



char *Delname()
{
  if(USE_DOS==1)
  {
    return "del";
  }
  return "rm";
}


Widget GetTopShell(Widget w)
{
  while (w && !XmIsDialogShell(w) )
  {
    w = XtParent(w);
  }

  return w;
}



int InspectXML(Widget w, char *xmlfile, char *qastfolder, int *err1, int *err2, int *err3)
{
  Widget parent;
  int success,len,myerr1=0,myerr2=0,myerr3=0,versionnum=-1;
  char XSDname[1000],savefilename[1000],message[1000];

  

  

  sprintf(message,"%s \"%s%s*.shp\"",Delname(),qastfolder,MYSLASH);
  system(message);
  sprintf(message,"%s \"%s%s*.shx\"",Delname(),qastfolder,MYSLASH);
  system(message);
  sprintf(message,"%s \"%s%s*.dbf\"",Delname(),qastfolder,MYSLASH);
  system(message);

  if(batch_mode==1)
  {
	parent = NULL;
  }
  else
  {
	parent = XtParent(XtParent(XtParent(w)));
  }


  


  



  sprintf(message,"Unzipping shapefiles\n\n From:\n  %s\n To:\n  %s\n\nPlease be patient.",QAST_CELL,qastfolder);

  not_while_running(parent,message,1597,"Unzipping",5);


  real_periodic_redraw();

 

  printf("Extract everything from %s into %s\n",QAST_CELL,qastfolder);

  sprintf(message,"unzip -o -j -C \"%s\" \"*.[dsx][bhm][fxpl]\" -d\"%s\" > NUL ",
		QAST_CELL,qastfolder);

  

  system(message);




  if(batch_mode==0)
  {
    XtPopdown(GetTopShell(QAST_unzip));
    XtDestroyWidget(QAST_unzip);
  }



  sprintf(savefilename,"%s",xmlfile);
  len = strlen(xmlfile);
  sprintf(&savefilename[len-4],"results.txt");

  

  



  XML_RUNNING = 0;

  ReportXMLProgress(w,-1,"",savefilename,-1,-1,alldatafiles);


  if(DP_TRD_TYPE==3)
  {
    if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
	{
      sprintf(XSDname,"%sMGCP_XSD\\TRD3_XSD\\mgcp\\mgcp.xsd",GAIT_HOME_DIR);
	}
    else
	{
      sprintf(XSDname,"%sMGCP_XSD/TRD3_XSD/mgcp/mgcp.xsd",GAIT_HOME_DIR);
	}
  }
  else if(DP_TRD_TYPE==4)
  {
    if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
	{
      sprintf(XSDname,"%sMGCP_XSD\\TRD4_XSD\\mgcp\\mgcp.xsd",GAIT_HOME_DIR);
	}
    else
	{
      sprintf(XSDname,"%sMGCP_XSD/TRD4_XSD/mgcp/mgcp.xsd",GAIT_HOME_DIR);
	}
  }
  else if(DP_TRD_TYPE==41)
  {
    if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
	{
      sprintf(XSDname,"%sMGCP_XSD\\TRD41_XSD\\mgcp\\mgcp.xsd",GAIT_HOME_DIR);
	}
    else
	{
      sprintf(XSDname,"%sMGCP_XSD/TRD41_XSD/mgcp/mgcp.xsd",GAIT_HOME_DIR);
	}
  }
  else if((DP_TRD_TYPE==42)||(DP_TRD_TYPE==43))
  {
    if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
	{
      sprintf(XSDname,"%sMGCP_XSD\\TRD42_XSD\\mgcp\\mgcp.xsd",GAIT_HOME_DIR);
	}
    else
	{
      sprintf(XSDname,"%sMGCP_XSD/TRD42_XSD/mgcp/mgcp.xsd",GAIT_HOME_DIR);
	}
  }
  else if(DP_TRD_TYPE==44)
  {
    if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
	{
      sprintf(XSDname,"%sMGCP_XSD\\TRD44_XSD\\mgcp\\mgcp.xsd",GAIT_HOME_DIR);
	}
    else
	{
      sprintf(XSDname,"%sMGCP_XSD/TRD44_XSD/mgcp/mgcp.xsd",GAIT_HOME_DIR);
	}
  }
  else
  {
    printf("Bad DTT %d to IX\n",DP_TRD_TYPE);
  }

  sscanf(VersionStr,"%d",&versionnum);


  if((versionnum<20)||(versionnum>50))
  {
    XBell(mydisplay,50);
    printf("Error getting GAIT version num: %d from %s\n",versionnum,VersionStr);
    versionnum = -1;
  }

  success = ParseXML2(DP_TRD_TYPE,1,xmlfile,XSDname, "",savefilename,&myerr1,&myerr2,&myerr3,versionnum);

  *err1 = myerr1;
  *err2 = myerr2;
  *err3 = myerr3;


  if(XML_RUNNING==1)
  {
	XtDestroyWidget(xml_running);
  }

  XML_RUNNING = 0;

  if(success==1)
  {
    ReportXMLProgress(w,-3,"",savefilename,-1,-1,alldatafiles);
  }
  else
  {
    if(strlen(GErr)>0)
	{
      sprintf(message,"%s",GErr);
	}
    else
	{
      sprintf(message,"Failed to validate XML...see console window for more details\n");
	}
    not_while_running(w,message,1500,"Failed to validate XML",1);
	return 0;
  }
  return 1;
}



int CompareConditions(Widget w, char *packagefolder, char *qastfolder, int *probs)
{

  FILE *outfile;
  int verbosity=1; 
  char *retstr;
  char CreatedESName[1000];
  char PackageESName[1000];
  char SaveFile     [1000];
  char smname       [1000];
  char sm2name      [1000];


  *probs = 0;


  




  printf("Extract %s%s%s* from %s into %s\n",packagefolder,MYSLASH,QAST_REPORTFOLDER,QAST_REPORT,qastfolder);

  sprintf(smname,"unzip -o -C \"%s%s%s\" \"%s*\" -d\"%s\" > NUL ",packagefolder,MYSLASH,QAST_REPORT,QAST_REPORTFOLDER,qastfolder);

  printf("Trying %s\n",smname);

  system(smname);



  sprintf(CreatedESName,"%scondition_reports%scondreport.es",indirectory,MYSLASH);
  sprintf(PackageESName,"%sQA%s%scondition_reports%s%s.es",indirectory,MYSLASH,QAST_REPORTFOLDER,MYSLASH,QAST_CONDREPORTNAME);
  sprintf(SaveFile,     "%sQA%s%scondition_comparison.txt",indirectory,MYSLASH,QAST_REPORTFOLDER);


 
    printf("CreatedESName: %s\n",CreatedESName);
    printf("PackageESName: %s\n",PackageESName);
    printf("SaveFile: %s\n",SaveFile);


  
  if(VerifyCondReport(w,CreatedESName)==0)
  {
    return 0;
  }
  if(VerifyCondReport(w,PackageESName)==0)
  {
    return 0;
  }




  outfile = fopen(SaveFile,"w");
  if(outfile==NULL)
  {
	 printf("Could not save results to:\n %s\n because the file could not be opened for writing\n",
		  SaveFile);
	  
	 return 0;
  } 


  

  if(!strcmp(ProcessGAITCondReport(PackageESName,9),".."))
  {
	fprintf(outfile,"Unable to read incompatible condition report from previous version of GAIT:\n %s\n",PackageESName);
	fprintf(outfile,"Unable to compare created condition report with packaged condition report\n");
	*probs = *probs + 1;
	fclose(outfile);
	return 1;
  }


  sprintf(smname, "%s",MakeSMName(CreatedESName));
  sprintf(sm2name,"%s",MakeSMName(PackageESName));

  retstr = CompareInspectionResults(smname,sm2name,GetMasterType(MakeVRName(CreatedESName)),GetMasterType2(MakeVRName(PackageESName)),verbosity);
    
  fprintf(outfile,"%s",retstr);

  fclose(outfile);



  outfile = fopen(SaveFile,"r");
  if(outfile==NULL)
  {
	printf("******Could not re-open:\n %s\n\n",
		  SaveFile);
	  
	 return 0;
  }

  fgets(smname,1000,outfile);
  while(!feof(outfile))
  { 
    

	if(smname[0]=='*')
	{
      *probs = *probs + 1;
	}
    fgets(smname,1000,outfile);
  }


  fclose(outfile);

  free(retstr);

  return 1;
}




char *CompareFiles(char *filename)
{
  FILE *first,*second;
  int i,len,line=0;
  char aline[1000],bline[1000],firstfile[1000],secondfile[1000];
  static char message[1000];

  

  sprintf(firstfile,"%sQA%s%ssummary_files%s%s",indirectory,MYSLASH,QAST_REPORTFOLDER,MYSLASH,filename);
  first = fopen(firstfile,"r");
  if(first==NULL)
  {
    sprintf(message,"\n Error: Unable (1) to open %s for read\n",firstfile);
	return message;
  }

  sprintf(secondfile,"%ssummary_files%s%s",indirectory,MYSLASH,filename);
  second = fopen(secondfile,"r");
  if(second==NULL)
  {
    sprintf(message,"\n Error: Unable (2) to open %s for read\n",secondfile);
	fclose(first);
	return message;
  }


  

  fgets(aline,1000,first);
  fgets(bline,1000,second);
  line = 1;

  while(!feof(first))
  {
    if(feof(second))
	{
      sprintf(message,"\n\
 Error when comparing \"%s\" from package to created file:\n\
  The file from the package has fewer lines than the created file.\n\
   Packaged file: %s\n\
   Created file : %s\n",filename,firstfile,secondfile);

	  fclose(first);
	  fclose(second);
	  return message;
	}

	len = strlen(aline);
	for(i=0;i<len;i++)
	{
      if((aline[i]<32)||(aline[i]>126))
	  {
        aline[i] = '\0';
		break;
	  }
	}


	len = strlen(bline);
	for(i=0;i<len;i++)
	{
      if((bline[i]<32)||(bline[i]>126))
	  {
        bline[i] = '\0';
		break;
	  }
	}

	
	if(strcmp(aline,bline))
	{
	  if(
		  (strcmp(filename,"checksummary.txt")) ||
		  (line<5)                              ||  
		  (line>7)
		)
	  {

        if(
		    (strcmp(filename,"checksummary.txt"))      ||
		    (strncmp(aline,"Inspection Time     ",20))     
          )
		{

          if(
		      (strcmp(filename,"contentsummary.txt"))      ||
		      (strncmp(aline,"Project: ",9))     
            )
		  { 
            sprintf(message,"\n\
 Error when comparing \"%s\" from package to created file:\n\
  The files are different at line %d.\n",filename,line);

	        fclose(first);
	        fclose(second);
	        return message;
		  }  
		}  
	  } 
	}

    fgets(aline,1000,first);
    fgets(bline,1000,second);
	line = line + 1;
  }


  if(!feof(second))
  {
    sprintf(message,"\
Error when comparing \"%s\" from package to created file:\n\
 The file from the package has more lines than the created file.\n\
  Packaged file: %s\n\
  Created file : %s\n",filename,firstfile,secondfile);

	fclose(first);
	fclose(second);
	return message;
  }



  fclose(first);
  fclose(second);
  return "OK";
}

  




void QAST_showfileCallback(Widget w,XtPointer data,XtPointer callData)
{
  FILE *errfile;
  int totallen=0,lines=0,len,type=(int)data;
  char resultfile[1000],aline[1000],hugestring[10000];


  if(type==1)
  {
    
    sprintf(resultfile,"%s",QAST_XML);
    len = strlen(resultfile);
    sprintf(&resultfile[len-4],"results.txt");
  }
  else if(type==2)
  {
	
    sprintf(resultfile,"%sQA%s%scondition_comparison.txt",indirectory,MYSLASH,QAST_REPORTFOLDER);
  }



  printf("display file %s\n",resultfile);
  

  errfile = fopen(resultfile,"r");
  if(errfile==NULL)
  {
    sprintf(aline,"Error: Could not open:\n  %s\n\nThis file should have been placed in this location during\nthe QA process",resultfile);
    not_while_running(w,aline,1601,"XML cannot be opened",1);   	
	return;
  }

  if(INFO_WINDOW==0)
  {
    MakeInfo(1);
  }
  else
  {
    ResetWidget(shellhead2);
  }
  
  hugestring[0] = '\0';

  if(type==1)
  {
    strcat(hugestring,"The following are the XML results from the QA, stored in file:\n  ");
  }
  else if(type==2)
  {
    strcat(hugestring,"The following are the condition comparison results from the QA, stored in file:\n  ");
  }

  strcat(hugestring,resultfile);
  strcat(hugestring,"\n\n");


  fgets(aline,1000,errfile);
  lines = lines + 1;
	  
  while(!feof(errfile))
  {
    strcat(hugestring,aline);
	      
    totallen = totallen + strlen(aline);
	      
	if(totallen>9000)
	{
	  infoprint(hugestring);
	  totallen = 0;
	  hugestring[0] = '\0';
	}

	if(lines>10000)
	{
      break;
	}
	fgets(aline,1000,errfile);
	lines = lines + 1;
  }

  if(lines>10000)
  {
    hugestring[0] = '\0';
	sprintf(hugestring,"\n\nAborting output after 10,000 lines...see file for full list of errors:\n  %s\n\n",resultfile);
    infoprint(hugestring);
  }
  else
  {
    infoprint(hugestring);
  }

  fclose(errfile);

}





void PostQASTMessage(Widget parent_wid, int didcompare, int didxml)
{
  Widget QAST_dialog;
  Arg args[15];
  Dimension thisy;
  int n=0,newy;


  XtSetArg(args[n], XmNdeleteResponse,    XmDESTROY);                                       n++;  
  XtSetArg(args[n], XmNautoUnmanage,      False);                                           n++;
  XtSetArg(args[n], XmNwordWrap,          True);                                            n++; 
  XtSetArg(args[n], XmNscrollHorizontal,  False);                                           n++; 
  XtSetArg(args[n], XmNokLabelString,     STRING("Show XML Results"));                      n++;
  XtSetArg(args[n], XmNcancelLabelString, STRING("Show Condition Comparison Results"));     n++;
  XtSetArg(args[n], XmNhelpLabelString,   STRING("OK"));                                    n++;
  XtSetArg(args[n], XmNmessageString,     TempQASTbigmessage);                              n++;
  XtSetArg(args[n], XmNdialogTitle,       STRING("QA Results"));                            n++;		
  XtSetArg(args[n], XmNtranslations,      XtParseTranslationTable ( translations_global )); n++;
  XtSetArg(args[n], XmNeditable,          True);                                            n++; 

  QAST_dialog = XmCreateInformationDialog (parent_wid, "QA Results", args, n);

  XtManageChild(QAST_dialog);

  XtAddCallback (QAST_dialog, XmNhelpCallback,   exitCallback, (XtPointer)39);
 
  if(didxml==0)
  {
    XtUnmanageChild (XmMessageBoxGetChild (QAST_dialog, XmDIALOG_OK_BUTTON));
  }
  else
  {
    XtAddCallback (QAST_dialog, XmNokCallback,     QAST_showfileCallback, (XtPointer)1);
  }

  if(didcompare==0)
  {
    XtUnmanageChild (XmMessageBoxGetChild (QAST_dialog, XmDIALOG_CANCEL_BUTTON));
  }
  else
  {
    XtAddCallback (QAST_dialog, XmNcancelCallback, QAST_showfileCallback, (XtPointer)2);
  }



  XtVaGetValues(QAST_dialog,XmNy,&thisy,NULL);  

  if(  
	  (thisy+XtHeight(QAST_dialog))>
	  (DisplayHeight(mydisplay,DefaultScreen(mydisplay))-DOS_HEIGHT_MODIFIER)
	)
  {
	newy = DisplayHeight(mydisplay,DefaultScreen(mydisplay))-
		XtHeight(QAST_dialog)-DOS_HEIGHT_MODIFIER;

	if(newy<0)
	{
      
	   newy = 25; 
	}
    XtVaSetValues(QAST_dialog,XmNy,newy,NULL);  
  }
}




void AddQASTString(char *message,int bold)
{
  XmString t;

  if(bold==999)
  {
    TempQASTbigmessage = XmStringCreateLtoR (message,"mytag2");
	return;
  }

  if(bold==1)
  {
    t = XmStringCreateLtoR (message,"mytag1");
  }
  else
  {
    t = XmStringCreateLtoR (message,"mytag2");
  }

  TempQASTbigmessage = XmStringConcat(TempQASTbigmessage,t);
}



char *GetFirstBad(char *filename)
{
  FILE *infile;
  static char aline[1000];

  infile = fopen(filename,"r");
  if(infile==NULL)
  {
    return "Error - Cannot open file";
  }


  fgets(aline,1000,infile);
  while(!feof(infile))
  {
    if(strstr(aline,"*****"))
	{
      fclose(infile);
      return aline;
	}

    fgets(aline,1000,infile);
  }


  fclose(infile);
  return "Error - Could not locate bad line";
  
}


void DPOverWriteCallback(Widget w,XtPointer data,XtPointer callData)
{

  XtPopdown(XtParent(XtParent(w)));
  XtDestroyWidget(XtParent(XtParent(w)));

  FORCE_DP_OVERWRITE = 1;

  DPwrapperCallback(w,(XtPointer)2,(XtPointer)NULL);

  FORCE_DP_OVERWRITE = 0;
}


void AskDPOverWrite(char *projname)
{
  Widget dialog,temp_w,rowcol;
  Arg args[20];
  XmString t;
  char message[1000];
  int n=0;

  sprintf(message,"The project \"%s\" already exists.\n\nDo you want to overwrite it?\n",projname);
  
  t = XmStringCreateLtoR (message,XmSTRING_DEFAULT_CHARSET);
  
  n = 0;
  XtSetArg(args[n], XmNdeleteResponse, XmDESTROY);                   n++;
  
  dialog = XtCreatePopupShell("Import",topLevelShellWidgetClass,
			      drawing_a,args,n);
  
  rowcol = XtVaCreateWidget ("rowcol",
			     xmRowColumnWidgetClass,  dialog, NULL);
  
  
  XtSetArg(args[n], XmNautoUnmanage,      True);                                        n++;
  XtSetArg(args[n], XmNcancelLabelString, STRING("No/Cancel"));                         n++;
  XtSetArg(args[n], XmNokLabelString,     STRING("Yes (Begin Importing/Overwriting)")); n++;
  XtSetArg(args[n], XmNmessageString,     t);                                           n++;
  XtSetArg(args[n], XmNdialogTitle,       STRING("Overwrite?"));                        n++;
  XtSetArg(args[n], XmNdialogType,        XmDIALOG_QUESTION);                           n++;
  
  
  temp_w = XmCreateMessageBox (rowcol,"mymessagebox",args,n);
  
  XtUnmanageChild (XmMessageBoxGetChild (temp_w, XmDIALOG_HELP_BUTTON));
  XtAddCallback (temp_w, XmNokCallback, DPOverWriteCallback,(XtPointer)NULL);
  XtAddCallback (temp_w, XmNcancelCallback, exitCallback, (XtPointer)56);  
  
  XtManageChild(temp_w);
  XtManageChild(rowcol);
  XtManageChild(dialog);
  
  MyPopup (dialog);
        
  XmStringFree (t);
}




void DPwrapperCallback(Widget w, XtPointer userData, XtPointer callData)
{
  FILE *outfile;
  Widget parent_wid,other_parent_wid;
  int type=(int)userData,len,good=0,i,ii,lines_to_skip,bad_lines,success,attr_save,
	  numcompareprobs=0,numxmlprobs1=0,numxmlprobs2=0,numxmlprobs3=0,fail=0,
	  didcompare=0,didxml=0,nt_save;
  char message[1000],testdir[1000],testdir2[1000],testdir3[1000],testdir4[1000],
	  filename[1000],testdir5[1000],qastfolder[1000],bigmessage[10000],TEMPPROJECTLOC[2000];
  extern int NUNANPO_TYPE;
  extern  FILE *batchsavefile;
  extern void ReOpenBatchSaveFile(char *savefile);

  if(batch_mode==1)
  {
	parent_wid = NULL;
	other_parent_wid = NULL;
  }
  else if(dead_dp==0)
  {
	
    parent_wid = XtParent(XtParent(XtParent(dphead)));
    other_parent_wid = XtParent(XtParent(XtParent(w)));
  }
  else
  {
    parent_wid = drawing_a;
    other_parent_wid = XtParent(XtParent(XtParent(w)));
  }


  bigmessage[0] = '\0';
  QAST_XML[0]   = '\0';
  sprintf(TEMPPROJECTLOC,"%s","q");

  if(type==1)
  {
	DO_QAST = 0;

	if(batch_mode==0)
	{
      EnterFileCallback(dp1_wid, (XtPointer)30,(XtPointer)30);
	}

    TestMGCPPackaging(parent_wid,dp1name,1,NULL);
  }
  else if(type==2)
  {
	DO_QAST = 1;

	if(batch_mode==0)
	{
      EnterFileCallback(dp1_wid, (XtPointer)30,(XtPointer)30);
      EnterFileCallback(dp2_wid, (XtPointer)32,(XtPointer)32);
	}

    len = strlen(dp2name);
      
	if(len==0)
	{
      not_while_running(parent_wid,"You must enter a project name before attempting partial QA.",1593,"No project name",1);   	
	  DO_QAST = 0;
	  return;
	}


    for(i=0;i<len;i++)
	{
	  if(
	     ((dp2name[i]>=65)  && (dp2name[i]<=90))  ||
	     ((dp2name[i]>=48)  && (dp2name[i]<=57))  ||
	     ((dp2name[i]>=97)  && (dp2name[i]<=122)) ||
	     (dp2name[i]=='-') || (dp2name[i]=='_')
	     )
	    {
	      good = 1;
	    }
	  else
	    {
	      sprintf(message,"The Project Name you have entered is invalid because\n\
it contains the character \"%c\"\n\n\
Please enter a project name consisting of letters, numbers, \"-\", and \"_\"\n",
		      dp2name[i]);

	      not_while_running(parent_wid,message,1592,"Invalid project name",1);   

          DO_QAST = 0;
	      return;
	    }
	}


    if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
	{
	  sprintf(testdir,"%s\\%s\\",PROJECTLOC,dp2name);
	}
	else
	{
	  sprintf(testdir,"%s/%s/",PROJECTLOC,dp2name);
	}


	if(FORCE_DP_OVERWRITE==0)
	{
	  if(TestDB(testdir,1)==1)  
	  { 
        AskDPOverWrite(dp2name);
	    return;
	  } 
	}



	sprintf(message,"QA results for package in folder:\n  ");
	AddQASTString(message,999);
	strcat(bigmessage,message);
	sprintf(message,"%s\n\n",dp1name);
	AddQASTString(message,1);
	strcat(bigmessage,message);




	



	if(QAST_USEPACKAGELOCATION==1)
	{
      sprintf(TEMPPROJECTLOC,"%s",PROJECTLOC);
	  sprintf(PROJECTLOC,"%s",dp1name);
	}


    if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
	{
	  sprintf(testdir,"%s\\%s\\",PROJECTLOC,dp2name);
	}
	else
	{
	  sprintf(testdir,"%s/%s/",PROJECTLOC,dp2name);
	}



	sprintf(message,"GAIT project to be created for QA purposes:\n  %s\n\n",testdir);
    AddQASTString(message,0);
	strcat(bigmessage,message);




    sprintf(testdir2,"%s",importoutputdir);
    if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
      {
	sprintf(importoutputdir,"%s\\%s\\",PROJECTLOC,dp2name);
      }
    else
      {
	sprintf(importoutputdir,"%s/%s/",PROJECTLOC,dp2name);
      }
    
 
	

	

	if(MakeOutStuff(testdir)==0)
	{ 
	  printf("cannot make output directory inside %s\n",testdir);
	  ExitWrapper(-1);
	}
 
	sprintf(qastfolder,"%sQA",testdir);

	printf("QA folder %s\n",qastfolder);

    printf("Perform QA for %s.  Use project name %s\n",dp1name,dp2name);

    if(TestMGCPPackaging(other_parent_wid,dp1name,0,qastfolder)==1)
	{
	   if(strcmp(QAST_CONDREPORTNAME,"condreport"))
	   {
         sprintf(message,"Data Packaging inspection:       ");
         AddQASTString(message,0);
         strcat(bigmessage,message);

         sprintf(message,"Successful");
         AddQASTString(message,1);
         strcat(bigmessage,message);

         sprintf(message,"\n  Warning:\n   Default condition report name \"condreport\" not used.\n    Condition report name \"%s\" used instead.\n\n",QAST_CONDREPORTNAME);
         AddQASTString(message,0);
         strcat(bigmessage,message);
	   }
	   else
	   {
         sprintf(message,"Data Packaging inspection:       ");
         AddQASTString(message,0);
         strcat(bigmessage,message);

         sprintf(message,"Successful\n");
         AddQASTString(message,1);
         strcat(bigmessage,message);
	   }


       printf("Data packaging OK.  Continue to project creation.\n");

	   

	   sprintf(testdir, "%s",importdirectory);
	   sprintf(testdir2,"%s",importoutputdir);
	   sprintf(testdir3,"%s",shapeimportoutputdir);
	   sprintf(testdir4,"%s",GAITProjectName);
	   sprintf(testdir5,"%s",layer_pref_file);


	   sprintf(layer_pref_file,"Default (MGCP)");


       if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
	   {
	     sprintf(importdirectory,"%s\\%s\\InputSpecFile.txt",PROJECTLOC,dp2name);
	     sprintf(importoutputdir,"%s\\%s\\",PROJECTLOC,dp2name);
	     sprintf(shapeimportoutputdir,"%s",dp1name);
		 sprintf(GAITProjectName,"%s",dp2name);
	   }
       else
	   { 
	     sprintf(importdirectory,"%s/%s/InputSpecFile.txt",PROJECTLOC,dp2name);
	     sprintf(importoutputdir,"%s/%s/",PROJECTLOC,dp2name);
	     sprintf(shapeimportoutputdir,"%s",dp1name);
		 sprintf(GAITProjectName,"%s",dp2name);
	   }


       attr_save = TEMP_ATTRIBUTION_TYPE;
       nt_save   = NUNANPO_TYPE;

	   NUNANPO_TYPE = 0;

       if(DP_TRD_TYPE==3)
	   {
         TEMP_ATTRIBUTION_TYPE = 7;
	   }
	   else
	   {
         TEMP_ATTRIBUTION_TYPE = 8;
	   }

	   STOP_FLAG = 0;
	   ABORT_EXTRACT = 0;

	   if(TestDB(importoutputdir,1)==1)
	   {
          printf("Project %s already exists\n",importoutputdir);
	   }
	   else
	   {
          printf("Project %s does not already exist\n",importoutputdir);
	   }



	   


       import_source = 1;
       shape_source  = 1;

	   i = AppendInputSpec;
	   AppendInputSpec = 0;

	   QAST_IS = 1;
       ngainfileCallback(parent_wid,(XtPointer)NULL,(XtPointer)NULL);

	   if(QAST_IS<0)
	   {
         

         sprintf(testdir,"\
QA process failed due to finding unrecognized shapefiles in the data package.\n\n\
See %s\n\n\
The first line with an unrecognized shapefile is:\n %s",importdirectory,GetFirstBad(importdirectory));

         not_while_running(parent_wid,testdir,1596,"QA Process Failed: Unrecognized shapefile found",5);

         UnsavedConditions = 0;
         UnsavedConditions = 0;

		 
         ABORT_EXTRACT = 0;
         DO_QAST = 0;

		 if(QAST_USEPACKAGELOCATION==1)
		 { 
	       if(strlen(TEMPPROJECTLOC)>2)  {sprintf(PROJECTLOC,"%s",TEMPPROJECTLOC);}
		 } 

		 return;
	   }

       AppendInputSpec = i;


       

	   TYPE = 3; 
       Import3Callback((Widget) NULL,(XtPointer) NULL,(XtPointer)1);
       printf("done importing data\n");


	   if(ABORT_EXTRACT==1)
	   { 
          not_while_running(parent_wid,"QA process aborted during project creation",1596,"QA Process Aborted",5);

          UnsavedConditions = 0;
          UnsavedConditions = 0;

		  
          ABORT_EXTRACT = 0;
          DO_QAST = 0;

          if(QAST_USEPACKAGELOCATION==1)
		  { 
	        if(strlen(TEMPPROJECTLOC)>2)  {sprintf(PROJECTLOC,"%s",TEMPPROJECTLOC);}
		  } 

		  return;
	   } 
       else
	   {



         SetEndian(indirectory);

         

         sprintf(indirectory,"%s",importoutputdir);

         printf("have in directory %s\n",indirectory);
  
         input_source  = 1;
         output_source = 1;
  
         if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
		 {   
          sprintf(esname,"%scondition_reports\\condreport.es",indirectory);
          sprintf(nsname,"%scondition_reports\\condreport.ns",indirectory);
          sprintf(lkname,"%scondition_reports\\condreport.lk",indirectory);
          sprintf(boname,"%scondition_reports\\condreport.bo",indirectory);
          sprintf(smname,"%scondition_reports\\condreport.sm",indirectory);
          sprintf(ntname,"%scondition_reports\\condreport.nt",indirectory);
          sprintf(vrname,"%scondition_reports\\condreport.vr",indirectory);
		 }   
         else
		 {   
          sprintf(esname,"%scondition_reports/condreport.es",indirectory);
          sprintf(nsname,"%scondition_reports/condreport.ns",indirectory);
          sprintf(lkname,"%scondition_reports/condreport.lk",indirectory);
          sprintf(boname,"%scondition_reports/condreport.bo",indirectory);
          sprintf(smname,"%scondition_reports/condreport.sm",indirectory);
          sprintf(ntname,"%scondition_reports/condreport.nt",indirectory);
          sprintf(vrname,"%scondition_reports/condreport.vr",indirectory);
		 }   
      

         


         printf("Generating MGCP_master.txt\n");
         GetRidOfAllClones(0);
         TurnOffAllChecks(0);

	     if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
		 {   
	       sprintf(filename,"%sinspection_files\\MGCP_master.txt",indirectory);
		 }  
         else
		 {   
	       sprintf(filename,"%sinspection_files/MGCP_master.txt",indirectory);
		 }   

         printf("loading %s\n",filename);
         lines_to_skip = FindEDCSInFile(filename);
         ApplyExecutionOptions(filename,0);
         bad_lines = DoBatchEDCSStuff((Widget)NULL,filename,lines_to_skip,1);
         printf("done\n");
	     sprintf(masterrun,"MGCP_master");


         printf("executing analyses...(%s)\n",masterrun);

         success = ICheckRegion(0,MaxXindex,0,MaxYindex);

		 

         ResetKeepDismiss(0);  
         ResetBOoptions();


	     for(ii=1;ii<=CONDITION_DEFINITIONS;ii++)
		 { 
	       if(ErrorLookup[ii].number>0)
		   {
		     ErrorLookup[ii].viewall  = 1;
		     ErrorLookup[ii].viewsome = 0;
		   } 
	       else
		   { 
		     ErrorLookup[ii].viewall  = 0;
		     ErrorLookup[ii].viewsome = 0;
		   } 
		 } 
	    for(ii=0;ii<CLONE_DEFINITIONS;ii++)
		{
	      if(CloneErrorLookup[ii].number>0)
		  {
		    CloneErrorLookup[ii].viewall  = 1;
		    CloneErrorLookup[ii].viewsome = 0;
		  } 
	      else
		  { 
		    CloneErrorLookup[ii].viewall  = 0;
		    CloneErrorLookup[ii].viewsome = 0;
		  } 
		} 


         if(success==0)
		 {   
           ExitWrapper(-1);
		 } 


         
		   if(RUNNING_INFO==1)
		   {  
             XtPopdown(GetTopShell(running_info));
	         XtDestroyWidget(running_info);
	         RUNNING_INFO=0;
		   } 



         if(STOP_FLAG==1)
		 { 
           not_while_running(parent_wid,"QA Process Aborted",1595,"QA process aborted during inspections",5);
		   UnsavedConditions = 0;
		   UnsavedConditions = 0;

		   
           STOP_FLAG = 0;
           DO_QAST = 0;

           if(QAST_USEPACKAGELOCATION==1)
		   { 
	         if(strlen(TEMPPROJECTLOC)>2)  {sprintf(PROJECTLOC,"%s",TEMPPROJECTLOC);}
		   } 

		   return;

		 } 
         else
		 { 

	       if(NGA_TYPE==1)
		   {   
             WriteSummaryReport(1);
		   }   
  
           
		   
           printf("saving interim cond report\n");
           reporthandleCallback((Widget)NULL, (XtPointer)3, (XtPointer)NULL );      
           


           
           printf("writing condition report...\n");

           
           if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
		   {   
             sprintf(esname,"%scondition_reports\\condreport.es",indirectory);
             sprintf(nsname,"%scondition_reports\\condreport.ns",indirectory);
             sprintf(lkname,"%scondition_reports\\condreport.lk",indirectory);
             sprintf(boname,"%scondition_reports\\condreport.bo",indirectory);
             sprintf(smname,"%scondition_reports\\condreport.sm",indirectory);
             sprintf(ntname,"%scondition_reports\\condreport.nt",indirectory);
             sprintf(vrname,"%scondition_reports\\condreport.vr",indirectory);
		   }  
           else
		   {   
             sprintf(esname,"%scondition_reports/condreport.es",indirectory);
             sprintf(nsname,"%scondition_reports/condreport.ns",indirectory);
             sprintf(lkname,"%scondition_reports/condreport.lk",indirectory);
             sprintf(boname,"%scondition_reports/condreport.bo",indirectory);
             sprintf(smname,"%scondition_reports/condreport.sm",indirectory);
             sprintf(ntname,"%scondition_reports/condreport.nt",indirectory);
             sprintf(vrname,"%scondition_reports/condreport.vr",indirectory);
		   }   


           reporthandleCallback((Widget)NULL, (XtPointer)1, (XtPointer)NULL );      


           
           printf("writing shapefiles...\n");
           MakeAllShapefiles((Widget)NULL,0,0);
           printf("Saved shapefile conditions to: %sexported_shapefiles\n\n",indirectory);


		 } 
	   }  


       ABORT_EXTRACT = 0;


	   
	   success = InspectXML(parent_wid,QAST_XML,qastfolder,&numxmlprobs1,&numxmlprobs2,&numxmlprobs3);

	   if(success==0)
	   {
		 fail = 1;
		 didxml = 0;
         sprintf(message,"Cell Metadata (XML) inspection:     ");
         AddQASTString(message,0);
         strcat(bigmessage,message);

         sprintf(message,"Internal error - see console\n");
         AddQASTString(message,1);
         strcat(bigmessage,message);

	   }
	   else if((numxmlprobs1+numxmlprobs2+numxmlprobs3)>0)
	   {
		 fail = 1;
		 didxml = 1;
         sprintf(message,"Cell Metadata (XML) inspection:  ");
         AddQASTString(message,0);
         strcat(bigmessage,message);

         sprintf(message,"Unsuccessful\n\n");
         AddQASTString(message,1);
         strcat(bigmessage,message);

         sprintf(message,"  See report file: %s",QAST_XML);
         len = strlen(message);
         sprintf(&message[len-4],"results.txt\n\n");


         AddQASTString(message,0);
         strcat(bigmessage,message);

         if(numxmlprobs1>0)
		 {
           sprintf(message,"Schema (XSD) errors: Some found.\n");
		 }
		 else
		 {
           sprintf(message,"Schema (XSD) errors: None found.\n");
		 }

         AddQASTString(message,0);
         strcat(bigmessage,message);


         if(numxmlprobs2>0)
		 {
           sprintf(message,"Non-schema errors  : Some found.\n");
		 }
		 else
		 {
           sprintf(message,"Non-schema errors  : None found.\n");
		 }

         AddQASTString(message,0);
         strcat(bigmessage,message);

         if(numxmlprobs3>0)
		 {
           sprintf(message,"Shapefile errors   : Some found.\n\n");
		 }
		 else
		 {
           sprintf(message,"Shapefile errors   : None found.\n\n");
		 }
         AddQASTString(message,0);
         strcat(bigmessage,message);
	   }
	   else
	   {
		 didxml = 1;
         sprintf(message,"Cell Metadata (XML) inspection:  ");
         AddQASTString(message,0);
         strcat(bigmessage,message);

         sprintf(message,"Successful\n");
         AddQASTString(message,1);
         strcat(bigmessage,message);
	   }


	   if(success==1)
	   {
	     
	     success = CompareConditions(parent_wid,dp1name,qastfolder,&numcompareprobs);
	   }


	   didcompare = 0;

	   if(success==1)
	   {
         didcompare = 1;

		 if((success==1)&&(numcompareprobs>0))
		 {
           fail = 1;

           sprintf(message,"Condition Report comparison:     ");
	       AddQASTString(message,0);
           strcat(bigmessage,message);

           sprintf(message,"Unsuccessful\n\n");
	       AddQASTString(message,1);
           strcat(bigmessage,message);

           sprintf(message,"\
 Error:  The packaged condition report and the created condition reports are not the same:\n\
  Packaged condition report:\n   %s%s%s%s\n\
  Created condition report:\n   %scondition_reports%scondreport\n\
  Comparison file showing %d difference%s:\n   %sQA%s%scondition_comparison.txt\n\n",
dp1name,MYSLASH,QAST_REPORTFOLDER,QAST_CONDREPORTNAME,
indirectory,MYSLASH,
numcompareprobs,MakePlural(numcompareprobs),indirectory,MYSLASH,QAST_REPORTFOLDER);
	       AddQASTString(message,0);
           strcat(bigmessage,message);


		   
		 }
		 else
		 {
           sprintf(message,"Condition Report comparison:     ");
		   AddQASTString(message,0);
           strcat(bigmessage,message);

           sprintf(message,"Successful\n");
		   AddQASTString(message,1);
           strcat(bigmessage,message);
		 }
	   }
	   else
	   {
         sprintf(message,"Condition Report comparison:     Internal error - see console\n");
         AddQASTString(message,0);
         strcat(bigmessage,message);
	   }


	   if(success==1)
	   {
         sprintf(message,"%s",CompareFiles("checksummary.txt"));
		 if(!strcmp(message,"OK"))
		 {
           sprintf(message,"%s",CompareFiles("contentsummary.txt"));
		   if(strcmp(message,"OK"))
		   {
             fail = 1;
             sprintf(filename,"Summary file comparisons:        ");
             AddQASTString(filename,0);
             strcat(bigmessage,filename);

             sprintf(filename,"Unsuccessful\n");
             AddQASTString(filename,1);
             strcat(bigmessage,filename);

             AddQASTString(message,0);
             strcat(bigmessage,message);
		   }
		   else
		   {
             sprintf(message, "Summary file comparisons:        ");
             AddQASTString(message,0);
             strcat(bigmessage,message);

             sprintf(message, "Successful\n");
             AddQASTString(message,1);
             strcat(bigmessage,message);
		   }
		 }
		 else
		 {
            fail = 1;
            sprintf(filename, "Summary file comparisons:        ");
            AddQASTString(filename,0);
            strcat(bigmessage,filename);

            sprintf(filename, "Unsuccessful\n");
            AddQASTString(filename,1);
            strcat(bigmessage,filename);

            AddQASTString(message,0);
            strcat(bigmessage,message);
		 }
	   }


       

	   sprintf(importdirectory,     "%s",testdir);
	   sprintf(importoutputdir,     "%s",testdir2);
	   sprintf(shapeimportoutputdir,"%s",testdir3);
	   sprintf(GAITProjectName,     "%s",testdir4);
	   sprintf(layer_pref_file,     "%s",testdir5);
       TEMP_ATTRIBUTION_TYPE        = attr_save;
       NUNANPO_TYPE                 = nt_save;

	   DO_QAST = 0;




	} 
	else
	{
	  sprintf(importoutputdir,     "%s",testdir2);

      printf("Failed at data packaging.\n");

      sprintf(message,"Data Packaging inspection:       ");
      AddQASTString(message,0);
      strcat(bigmessage,message);

      sprintf(message,"Unsuccessful\n\n");
      AddQASTString(message,1);
      strcat(bigmessage,message);

      sprintf(message,"QA cannot proceed with unsuccessful data packaging.");
      AddQASTString(message,0);
      strcat(bigmessage,message);

      DO_QAST = 0;

	  fail = 1;
 	}

	if(fail==1)
	{
      sprintf(message,"\n\nOverall QA process:   ");
      AddQASTString(message,0);
      strcat(bigmessage,message);

      sprintf(message,"Unsuccessful");
      AddQASTString(message,1);
      strcat(bigmessage,message);
	}
	else
	{
      sprintf(message,"\n\nOverall QA process:   ");
      AddQASTString(message,0);
      strcat(bigmessage,message);

      sprintf(message,"Successful");
      AddQASTString(message,1);
      strcat(bigmessage,message);

	}


	sprintf(message,"%s%sQA_results.txt",qastfolder,MYSLASH);
    outfile = fopen(message,"w");
	if(outfile==NULL)
	{
   	  sprintf(message,"\n\nFailed to save this text to:\n  %s%sQA_results.txt",qastfolder,MYSLASH);
	  AddQASTString(message,0);
	}
	else
	{
      fprintf(outfile,"%s",bigmessage);
	  fclose(outfile);
		
	  sprintf(message,"\n\nThis information has been saved to:\n  %s%sQA_results.txt",qastfolder,MYSLASH);
	  AddQASTString(message,0);
	}


    if(batch_mode==1)
	{ 
	  printf("\n\n");
	  printf("Partial QA process complete.");
	  printf("%s\n\n",message);

	  if(batchsavefile!=NULL)
	  {
		ReOpenBatchSaveFile((char *)callData);
		if(batchsavefile!=NULL)
		{
		  fprintf(batchsavefile,"%s\n\n",bigmessage);
		}
	  }
      return;
	} 
	else
	{
	  PostQASTMessage(parent_wid,didcompare,didxml);
	}

  }
  else
  {
    printf("Internal error: DWCB (%d)\n",type);
	XBell(mydisplay,50);
	DO_QAST = 0;

    if(QAST_USEPACKAGELOCATION==1)
	{ 
	  if(strlen(TEMPPROJECTLOC)>2)  {sprintf(PROJECTLOC,"%s",TEMPPROJECTLOC);}
	} 

	return;
  }

  if(QAST_USEPACKAGELOCATION==1)
  { 
	if(strlen(TEMPPROJECTLOC)>2)  {sprintf(PROJECTLOC,"%s",TEMPPROJECTLOC);}
  }
}



void DPCallback(Widget w, XtPointer userData, XtPointer callData)
{
  Widget rc,form,button, browse_button,label1;
  Arg resources[20];
  char title[19][100];
  int n,lines,i;
  Dimension Pheight;

  MenuItem trd_type[] = {
    {"TRD3",   &xmPushButtonWidgetClass,'!', NULL, NULL, (void (*)())dp_trd_cb, (XtPointer)3,  (MenuItem *) NULL},
    {"TRD4.0", &xmPushButtonWidgetClass,'!', NULL, NULL, (void (*)())dp_trd_cb, (XtPointer)4,  (MenuItem *) NULL},
    {"TRD4.1", &xmPushButtonWidgetClass,'!', NULL, NULL, (void (*)())dp_trd_cb, (XtPointer)41, (MenuItem *) NULL},
    {"TRD4.2", &xmPushButtonWidgetClass,'!', NULL, NULL, (void (*)())dp_trd_cb, (XtPointer)42, (MenuItem *) NULL},
    {"TRD4.3", &xmPushButtonWidgetClass,'!', NULL, NULL, (void (*)())dp_trd_cb, (XtPointer)43, (MenuItem *) NULL},
    {"TRD4.4", &xmPushButtonWidgetClass,'!', NULL, NULL, (void (*)())dp_trd_cb, (XtPointer)44, (MenuItem *) NULL},
    {NULL},
  };

  

  if(dead_dp==1)
    {
      n=0;
      XtSetArg(resources[n],  XmNdeleteResponse, XmDESTROY); n++;
      
      dphead = XtCreatePopupShell("Validate MGCP Data Packaging/Perform QA",
				    topLevelShellWidgetClass,w,resources,n);


      rc = XtVaCreateWidget ("rowcol",xmRowColumnWidgetClass, dphead, NULL);


      sprintf(title[0],  "This window is used to validate MGCP Data Packaging and/or Perform a partial QA");
      title[1][0] = '\0';
      title[2][0] = '\0';
      sprintf(title[3],  "To use this capability, you must:          ");
      title[4][0] = '\0';
	  sprintf(title[5],  " 1) Enter the full path to the folder containing a single MGCP packaged ");
      sprintf(title[6],  "    cell in the \"Folder Containing MGCP Packaged Cell\" area            ");
      sprintf(title[7],  " 2) Select the MGCP TRD version to validate against                      ");
      sprintf(title[8],  " 3) Click the \"Check Data Packaging\" or \"Perform Partial QA\" button. ");
      title[9][0] = '\0';
      sprintf(title[10],"    \"Perform Partial QA\" consists of:                                  ");
      sprintf(title[11],"        a) Check Data Packaging.  If Data Packaging is correct:          ");
      sprintf(title[12],"           b) Validate XML                                               ");
      sprintf(title[13],"           c) Create GAIT project and run the MGCP Master Profile        ");
      sprintf(title[14],"                Compare resulting condition report and attribution errors");
      sprintf(title[15],"                with those in the supplied package                       ");
      title[16][0] = '\0';
      title[17][0] = '\0';
      title[18][0] = '\0';


	  lines = 19;


      for(i=0;i<lines;i++)
	{
	  form = XtVaCreateWidget ("form7", xmFormWidgetClass, rc,
				   XmNfractionBase,  100,  
				   NULL);
	  
	  label1 = XtVaCreateManagedWidget (title[i],
					    xmLabelWidgetClass,  form,
					    XmNrightAttachment,  XmATTACH_POSITION,
					    XmNrightPosition,    99,
					    XmNleftAttachment,   XmATTACH_POSITION,
					    XmNleftPosition,     0,
					    XmNalignment,        XmALIGNMENT_CENTER,
					    XmNtopAttachment,    XmATTACH_FORM,
					    XmNbottomAttachment, XmATTACH_FORM,
					    LABELWTRANSLATE,
					    NULL);
	  XtManageChild(form);

	}







      form = XtVaCreateWidget ("form7", xmFormWidgetClass, rc,
			       XmNfractionBase,  100,  
			       NULL);


      label1 = XtVaCreateManagedWidget ("Folder Containing MGCP Packaged Cell:",
					xmLabelWidgetClass,  form,
					XmNrightAttachment,  XmATTACH_POSITION,
					XmNrightPosition,    40,
					XmNleftAttachment,   XmATTACH_POSITION,
					XmNleftPosition,     0,
					XmNalignment,        XmALIGNMENT_BEGINNING,
					XmNtopAttachment,    XmATTACH_FORM,
					XmNbottomAttachment, XmATTACH_FORM,
					LABELWTRANSLATE,
					NULL);


      dp1_wid = XtVaCreateManagedWidget ("text_w",
					  xmTextFieldWidgetClass, form,	  
					  XmNvalue,               dp1name,
					  XmNtraversalOn,         True,
					  XmNrightAttachment,     XmATTACH_POSITION,
					  XmNrightPosition,       80,
					  XmNleftAttachment,      XmATTACH_POSITION,
					  XmNleftPosition,        40,
                      XmNtranslations,        XtParseTranslationTable ( translations_paste ) ,
					  NULL);

      XtAddCallback (dp1_wid, XmNactivateCallback,
		     EnterFileCallback, (XtPointer)30);



      browse_button  = XtVaCreateManagedWidget("Browse...",xmPushButtonWidgetClass,form,
					       XmNlabelString,      STRING("Browse..."),
					       XmNorientation,      XmVERTICAL,
					       XmNleftAttachment,   XmATTACH_POSITION,
					       XmNleftPosition,     81,
					       XmNrightAttachment,  XmATTACH_POSITION,
					       XmNrightPosition,    99,
					       XmNtopAttachment,    XmATTACH_FORM,
					       XmNbottomAttachment, XmATTACH_FORM,
					       XmNtraversalOn,      False,
					       XmNtranslations, XtParseTranslationTable ( translations_global ),
					       NULL
					       ); 

      XtAddCallback(browse_button, XmNactivateCallback,
		    BrowseCallback, (XtPointer) CHOOSE_DP_BROWSE);
      XtManageChild(browse_button); 

      XtManageChild(form);




















      form = XtVaCreateWidget ("form7", xmFormWidgetClass, rc,
			       XmNfractionBase,  100,  
			       NULL);


      label1 = XtVaCreateManagedWidget ("Project name to use when creating project for QA:",
					xmLabelWidgetClass,  form,
					XmNleftAttachment,   XmATTACH_FORM,
					XmNtopAttachment,    XmATTACH_FORM,
					XmNbottomAttachment, XmATTACH_FORM,
					LABELWTRANSLATE,
					NULL);


      dp2_wid = XtVaCreateManagedWidget ("text_w",
					  xmTextFieldWidgetClass, form,
					  XmNvalue,               dp2name,
					  XmNtraversalOn,         True,
					  XmNrightAttachment,     XmATTACH_POSITION,
					  XmNrightPosition,       99,
					  XmNleftAttachment,      XmATTACH_WIDGET,
					  XmNleftWidget,          label1,
                      XmNtranslations,        XtParseTranslationTable ( translations_paste ) ,
					  NULL);

      XtAddCallback (dp2_wid, XmNactivateCallback,
		     EnterFileCallback, (XtPointer)30);

 
      XtManageChild(form);






     form = XtVaCreateWidget ("form17a", xmFormWidgetClass, rc,
			       XmNfractionBase,  100,  
			       NULL);      

     button = 
      XtVaCreateManagedWidget ("the_test203",
				 xmToggleButtonWidgetClass, form,
				 XmNtopAttachment,          XmATTACH_FORM,
				 XmNbottomAttachment,       XmATTACH_FORM,
				 XmNleftAttachment,         XmATTACH_POSITION,
				 XmNleftPosition,           1,
				 XmNrightAttachment,        XmATTACH_POSITION,
				 XmNrightPosition,          99,
				 XmNlabelString,            STRING("Leave progress windows available during QA"),
                 XmNalignment,              XmALIGNMENT_BEGINNING,
				 TOGGLETRANSLATE,           TOGGLEINCLUDE,
				 NULL);
      
      XtManageChild (button);
      XmToggleButtonSetState(button,(Boolean)QAST_LEAVEWINDOWS,(Boolean)0);
      XtAddCallback (button, XmNvalueChangedCallback, toggle_leave_windows, (XtPointer)NULL);

	  XtManageChild (form);




     form = XtVaCreateWidget ("form17a", xmFormWidgetClass, rc,
			       XmNfractionBase,  100,  
			       NULL);      

     button = 
      XtVaCreateManagedWidget ("the_test203a",
				 xmToggleButtonWidgetClass, form,
				 XmNtopAttachment,          XmATTACH_FORM,
				 XmNbottomAttachment,       XmATTACH_FORM,
				 XmNleftAttachment,         XmATTACH_POSITION,
				 XmNleftPosition,           1,
				 XmNrightAttachment,        XmATTACH_POSITION,
				 XmNrightPosition,          99,
				 XmNlabelString,            STRING("Use package folder location to create GAIT project for QA"),
                 XmNalignment,              XmALIGNMENT_BEGINNING,
				 TOGGLETRANSLATE,           TOGGLEINCLUDE,
				 NULL);
      
      XtManageChild (button);
      XmToggleButtonSetState(button,(Boolean)QAST_USEPACKAGELOCATION,(Boolean)0);
      XtAddCallback (button, XmNvalueChangedCallback, toggle_use_packageloc, (XtPointer)NULL);

	  XtManageChild (form);




 
      form = XtVaCreateWidget ("form17a", xmFormWidgetClass, rc,
			       XmNfractionBase,  100,  
			       NULL);      

	  button = BuildDPMenu (form, XmMENU_OPTION, "Validate Against:", trd_type);

      XtVaSetValues(button,
		    XmNtopAttachment,    XmATTACH_FORM,
		    XmNbottomAttachment, XmATTACH_FORM,
		    XmNrightAttachment,  XmATTACH_POSITION,
		    XmNrightPosition,    30,
		    XmNleftAttachment,   XmATTACH_POSITION,
		    XmNleftPosition,     1,
		    NULL);
	  
	  XtManageChild (button);






      button  = XtVaCreateManagedWidget("SCR3",xmPushButtonWidgetClass,form,
					XmNlabelString,      STRING("Check Data Packaging"),
					XmNtopAttachment,    XmATTACH_FORM,
					XmNbottomAttachment, XmATTACH_FORM,
					XmNrightAttachment,  XmATTACH_POSITION,
					XmNrightPosition,    60,
					XmNleftAttachment,   XmATTACH_POSITION,
					XmNleftPosition,     30,
					XmNtraversalOn,      False,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					NULL
					);

      XtAddCallback(button, XmNactivateCallback, DPwrapperCallback, (XtPointer)1);
      XtManageChild(button);

      button  = XtVaCreateManagedWidget("SCR3",xmPushButtonWidgetClass,form,
					XmNlabelString,      STRING("Perform Partial QA"),
					XmNtopAttachment,    XmATTACH_FORM,
					XmNbottomAttachment, XmATTACH_FORM,
					XmNrightAttachment,  XmATTACH_POSITION,
					XmNrightPosition,    90,
					XmNleftAttachment,   XmATTACH_POSITION,
					XmNleftPosition,     60,
					XmNtraversalOn,      False,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					NULL
					);

      XtAddCallback(button, XmNactivateCallback, DPwrapperCallback, (XtPointer)2);
      XtManageChild(button); 



      button  = XtVaCreateManagedWidget("SCR3",xmPushButtonWidgetClass,form,
					XmNlabelString,      STRING("Done"),
					XmNtopAttachment,    XmATTACH_FORM,
					XmNbottomAttachment, XmATTACH_FORM,
					XmNrightAttachment,  XmATTACH_POSITION,
					XmNrightPosition,    99,
					XmNleftAttachment,   XmATTACH_POSITION,
					XmNleftPosition,     90,
					XmNtraversalOn,      False,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					NULL
					);

      XtAddCallback(button, XmNactivateCallback, die_callback, (XtPointer) 1032);
      XtManageChild(button); 
      XtManageChild(form);


      XtManageChild(rc);
      MyPopup(dphead); 
      XtAddCallback(dphead,XmNdestroyCallback,ShellDeath,(XtPointer)4092);
      

      dead_dp = 0;



      XtVaGetValues(dphead, XmNheight,    &Pheight,   NULL);	  
      XtVaSetValues(dphead, XmNminHeight,  Pheight, NULL);
      XtVaSetValues(dphead, XmNmaxHeight,  Pheight, NULL);


      XtAddEventHandler(dphead,StructureNotifyMask,False, myResizeHandler, (XtPointer)((int)Pheight));

    }
  else
    {
      ResetWidget(dphead);
    }
}














void CompareReportCallback(Widget w, XtPointer userData, XtPointer callData)
{
  static Widget summaryhead;
  Widget rc,form,button, browse_button,label1,verbosity_menu;
  Arg resources[20];
  char title[20][100];
  int n,lines=12,i;
  Dimension Pheight;

  MenuItem verbosity_type[] = {
    {"Low: Basic Counts",
     &xmPushButtonWidgetClass,'!', NULL, NULL, (void (*)())verbosity_cb, (XtPointer)1, (MenuItem *) NULL},
    {"Medium: Add Counts by Condition Type",
     &xmPushButtonWidgetClass,'!', NULL, NULL, (void (*)())verbosity_cb, (XtPointer)2, (MenuItem *) NULL},
    {"High: Add Parameters by Condition Type",  
     &xmPushButtonWidgetClass,'!', NULL, NULL, (void (*)())verbosity_cb, (XtPointer)3, (MenuItem *) NULL},
    {"Complete: Add Counts by Feature Code",
     &xmPushButtonWidgetClass,'!', NULL, NULL, (void (*)())verbosity_cb, (XtPointer)4, (MenuItem *) NULL},
    {NULL},
  };



  if(dead_compare==1)
    {
      n=0;
      XtSetArg(resources[n],  XmNdeleteResponse, XmDESTROY); n++;
      XtSetArg(resources[n],  XmNmaxWidth,       800);       n++;  
      
      summaryhead = XtCreatePopupShell("Compare/Summarize Condition Report(s)",
				    topLevelShellWidgetClass,w,resources,n);
      
      rc = XtVaCreateWidget ("rowcol",xmRowColumnWidgetClass, summaryhead, NULL);
      
      
      
      sprintf(title[0], "This window is used to Compare and/or Summarize condition reports.");
      title[1][0] = '\0';
      sprintf(title[2], "To Summarize a condition report, enter it's .es file name and select");
      sprintf(title[3], "the appropriate \"Summarize\" button below.");
      title[4][0] = '\0';
      sprintf(title[5], "To Compare 2 condition reports, enter both of their .es filenames");
      sprintf(title[6], "below and then click the \"Compare Condition Reports\" button.");
      title[7][0] = '\0';
      sprintf(title[8], "To save the results of Comparing or Summarizing to a text file, enter a filename");
      sprintf(title[9], "in the \"Save to Text File\" area and select the \"Save Results to Text File\"");
      sprintf(title[10],"option (this file will be overwritten if it exists).");
      title[11][0] = '\0';



      for(i=0;i<lines;i++)
	{
	  form = XtVaCreateWidget ("form7", xmFormWidgetClass, rc,
				   XmNfractionBase,  100,  
				   NULL);
	  
	  label1 = XtVaCreateManagedWidget (title[i],
					    xmLabelWidgetClass,  form,
					    XmNrightAttachment,  XmATTACH_POSITION,
					    XmNrightPosition,    99,
					    XmNleftAttachment,   XmATTACH_POSITION,
					    XmNleftPosition,     0,
					    XmNalignment,        XmALIGNMENT_CENTER,
					    XmNtopAttachment,    XmATTACH_FORM,
					    XmNbottomAttachment, XmATTACH_FORM,
					    LABELWTRANSLATE,
					    NULL);
	  XtManageChild(form);

	}







      form = XtVaCreateWidget ("form7", xmFormWidgetClass, rc,
			       XmNfractionBase,  100,  
			       NULL);


      label1 = XtVaCreateManagedWidget ("First ES filename:",
					xmLabelWidgetClass,  form,
					XmNrightAttachment,  XmATTACH_POSITION,
					XmNrightPosition,    25,
					XmNleftAttachment,   XmATTACH_POSITION,
					XmNleftPosition,     0,
					XmNalignment,        XmALIGNMENT_CENTER,
					XmNtopAttachment,    XmATTACH_FORM,
					XmNbottomAttachment, XmATTACH_FORM,
					LABELWTRANSLATE,
					NULL);


      sum1_wid = XtVaCreateManagedWidget ("text_w",
					  xmTextFieldWidgetClass, form,	  
					  XmNvalue,               Sum1ESname,
					  XmNtraversalOn,         True,
					  XmNrightAttachment,     XmATTACH_POSITION,
					  XmNrightPosition,       82,
					  XmNleftAttachment,      XmATTACH_POSITION,
					  XmNleftPosition,        25,
                      XmNtranslations,        XtParseTranslationTable ( translations_paste ) ,
					  NULL);
      
      XtAddCallback (sum1_wid, XmNactivateCallback,
		     EnterFileCallback, (XtPointer)13);
      
      

      
      browse_button  = XtVaCreateManagedWidget("Browse...",xmPushButtonWidgetClass,form,
					       XmNlabelString,      STRING("Browse..."),
					       XmNorientation,      XmVERTICAL,
					       XmNleftAttachment,   XmATTACH_POSITION,
					       XmNleftPosition,     82,
					       XmNrightAttachment,  XmATTACH_POSITION,
					       XmNrightPosition,    97,
					       XmNtopAttachment,    XmATTACH_FORM,
					       XmNbottomAttachment, XmATTACH_FORM,
					       XmNtraversalOn,      False,
					       XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					       NULL
					       ); 
      
      XtAddCallback(browse_button, XmNactivateCallback,
		    BrowseCallback, (XtPointer) CHOOSE_ES1_BROWSE);
      XtManageChild(browse_button); 

      XtManageChild(form);









      form = XtVaCreateWidget ("form7", xmFormWidgetClass, rc,
			       XmNfractionBase,  100,  
			       NULL);
      

      label1 = XtVaCreateManagedWidget ("Second ES filename:",
					xmLabelWidgetClass,  form,
					XmNrightAttachment,  XmATTACH_POSITION,
					XmNrightPosition,    25,
					XmNleftAttachment,   XmATTACH_POSITION,
					XmNleftPosition,     0,
					XmNalignment,        XmALIGNMENT_CENTER,
					XmNtopAttachment,    XmATTACH_FORM,
					XmNbottomAttachment, XmATTACH_FORM,
					LABELWTRANSLATE,
					NULL);


      sum2_wid = XtVaCreateManagedWidget ("text_w",
					  xmTextFieldWidgetClass, form,	  
					  XmNvalue,               Sum2ESname,
					  XmNtraversalOn,         True,
					  XmNrightAttachment,     XmATTACH_POSITION,
					  XmNrightPosition,       82,
					  XmNleftAttachment,      XmATTACH_POSITION,
					  XmNleftPosition,        25,
                      XmNtranslations,        XtParseTranslationTable ( translations_paste ) ,
					  NULL);
      
      XtAddCallback (sum2_wid, XmNactivateCallback,
		     EnterFileCallback, (XtPointer)14);
      
      browse_button  = XtVaCreateManagedWidget("Browse...",xmPushButtonWidgetClass,form,
					       XmNlabelString,      STRING("Browse..."),
					       XmNorientation,      XmVERTICAL,
					       XmNleftAttachment,   XmATTACH_POSITION,
					       XmNleftPosition,     82,
					       XmNrightAttachment,  XmATTACH_POSITION,
					       XmNrightPosition,    97,
					       XmNtopAttachment,    XmATTACH_FORM,
					       XmNbottomAttachment, XmATTACH_FORM,
					       XmNtraversalOn,      False,
					       XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					       NULL
					       ); 
      
      XtAddCallback(browse_button, XmNactivateCallback,
		    BrowseCallback, (XtPointer) CHOOSE_ES2_BROWSE);
      XtManageChild(browse_button); 

      XtManageChild(form);











      form = XtVaCreateWidget ("form7", xmFormWidgetClass, rc,
			       XmNfractionBase,  100,  
			       NULL);

      
      label1 = XtVaCreateManagedWidget ("Save to Text File:",
					xmLabelWidgetClass,  form,
					XmNrightAttachment,  XmATTACH_POSITION,
					XmNrightPosition,    25,
					XmNleftAttachment,   XmATTACH_POSITION,
					XmNleftPosition,     0,
					XmNalignment,        XmALIGNMENT_CENTER,
					XmNtopAttachment,    XmATTACH_FORM,
					XmNbottomAttachment, XmATTACH_FORM,
					LABELWTRANSLATE,
					NULL);
      
      
      sum3_wid = XtVaCreateManagedWidget ("text_w",
					  xmTextFieldWidgetClass, form,	  
					  XmNvalue,               Sum3ESname,
					  XmNtraversalOn,         True,
					  XmNrightAttachment,     XmATTACH_POSITION,
					  XmNrightPosition,       82,
					  XmNleftAttachment,      XmATTACH_POSITION,
					  XmNleftPosition,        25,
                      XmNtranslations,        XtParseTranslationTable ( translations_paste ) ,
					  NULL);
      
      XtAddCallback (sum3_wid, XmNactivateCallback,
		     EnterFileCallback, (XtPointer)15);
      
      browse_button  = XtVaCreateManagedWidget("Browse...",xmPushButtonWidgetClass,form,
					       XmNlabelString,      STRING("Browse..."),
					       XmNorientation,      XmVERTICAL,
					       XmNleftAttachment,   XmATTACH_POSITION,
					       XmNleftPosition,     82,
					       XmNrightAttachment,  XmATTACH_POSITION,
					       XmNrightPosition,    97,
					       XmNtopAttachment,    XmATTACH_FORM,
					       XmNbottomAttachment, XmATTACH_FORM,
					       XmNtraversalOn,      False,
					       XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					       NULL
					       ); 
      
      XtAddCallback(browse_button, XmNactivateCallback,
		    BrowseCallback, (XtPointer) CHOOSE_TXT_BROWSE);
      XtManageChild(browse_button); 

      XtManageChild(form);





      form = XtVaCreateWidget ("form17a", xmFormWidgetClass, rc,
			       XmNfractionBase,  100,  
			       NULL);      
      
      button = 
	XtVaCreateManagedWidget ("the_test203",
				 xmToggleButtonWidgetClass, form,
				 XmNtopAttachment,          XmATTACH_FORM,
				 XmNbottomAttachment,       XmATTACH_FORM,
				 XmNleftAttachment,         XmATTACH_POSITION,
				 XmNleftPosition,           1,
				 XmNrightAttachment,        XmATTACH_POSITION,
				 XmNrightPosition,          45,
				 XmNlabelString,            STRING("Save Results to Text File"),
				 TOGGLETRANSLATE,     TOGGLEINCLUDE,
				 NULL);
      
      XtManageChild (button);
      XmToggleButtonSetState(button,(Boolean)SAVE_COMPARE_FILE,(Boolean)0);
      
      XtAddCallback (button, XmNvalueChangedCallback, toggle_save_file, (XtPointer)NULL);
      
      XtManageChild(form);
      




      form = XtVaCreateWidget ("form17b", xmFormWidgetClass, rc,
			       XmNfractionBase,  100,  
			       NULL);      

      verbosity_menu = BuildVerboseMenu (form, XmMENU_OPTION, "Description Detail:",verbosity_type);
      
      XtVaSetValues(verbosity_menu,
		    XmNtopAttachment,    XmATTACH_FORM,
		    XmNbottomAttachment, XmATTACH_FORM,
		    XmNrightAttachment,  XmATTACH_POSITION,
		    XmNrightPosition,    75,
		    XmNleftAttachment,   XmATTACH_POSITION,
		    XmNleftPosition,     1,
		    NULL);
      
      XtManageChild (verbosity_menu);

      XtManageChild(form);
      




      
      form = XtVaCreateWidget ("form17c", xmFormWidgetClass, rc,
			       XmNfractionBase,  100,  
			       NULL);      
      button  = XtVaCreateManagedWidget("SCR1",xmPushButtonWidgetClass,form,
					XmNlabelString,      STRING("Summarize First Condition Report"),
					XmNtopAttachment,    XmATTACH_FORM,
					XmNbottomAttachment, XmATTACH_FORM,
					XmNrightAttachment,  XmATTACH_POSITION,
					XmNrightPosition,    49,
					XmNleftAttachment,   XmATTACH_POSITION,
					XmNleftPosition,     1,
					XmNtraversalOn,      False,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					NULL
					);
      
      XtAddCallback(button, XmNactivateCallback, SummarizeCallback, (XtPointer) 1);
      XtManageChild(button); 
      

      button  = XtVaCreateManagedWidget("SCR2",xmPushButtonWidgetClass,form,
					XmNlabelString,      STRING("Summarize Second Condition Report"),
					XmNtopAttachment,    XmATTACH_FORM,
					XmNbottomAttachment, XmATTACH_FORM,		    
					XmNrightAttachment,  XmATTACH_POSITION,
					XmNrightPosition,    99,
					XmNleftAttachment,   XmATTACH_POSITION,
					XmNleftPosition,     51,
					XmNtraversalOn,      False,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					NULL
					); 
      
      XtAddCallback(button, XmNactivateCallback, SummarizeCallback, (XtPointer) 2);
      XtManageChild(button); 
      XtManageChild(form);




      
      form = XtVaCreateWidget ("form17d", xmFormWidgetClass, rc,
			       XmNfractionBase,  100,  
			       NULL);      

      button  = XtVaCreateManagedWidget("SCR3",xmPushButtonWidgetClass,form,
					XmNlabelString,      STRING("Compare Condition Reports"),
					XmNtopAttachment,    XmATTACH_FORM,
					XmNbottomAttachment, XmATTACH_FORM,
					XmNrightAttachment,  XmATTACH_POSITION,
					XmNrightPosition,    49,
					XmNleftAttachment,   XmATTACH_POSITION,
					XmNleftPosition,     1,
					XmNtraversalOn,      False,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					NULL
					); 
      
      XtAddCallback(button, XmNactivateCallback, SummarizeCallback, (XtPointer) 3);
      XtManageChild(button); 
      


      button  = XtVaCreateManagedWidget("SCR3",xmPushButtonWidgetClass,form,
					XmNlabelString,      STRING("Done"),
					XmNtopAttachment,    XmATTACH_FORM,
					XmNbottomAttachment, XmATTACH_FORM,		    
					XmNrightAttachment,  XmATTACH_POSITION,
					XmNrightPosition,    99,
					XmNleftAttachment,   XmATTACH_POSITION,
					XmNleftPosition,     51,
					XmNtraversalOn,      False,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					NULL
					); 
      
      XtAddCallback(button, XmNactivateCallback, die_callback, (XtPointer) 1016);
      XtManageChild(button); 
      XtManageChild(form);


      XtManageChild(rc);
      MyPopup(summaryhead); 
      XtAddCallback(summaryhead,XmNdestroyCallback,ShellDeath,(XtPointer)4060);
      

      dead_compare = 0;


      XtVaGetValues(summaryhead, XmNheight,    &Pheight,   NULL);	  
      XtVaSetValues(summaryhead, XmNminHeight,  Pheight, NULL);
      XtVaSetValues(summaryhead, XmNmaxHeight,  Pheight, NULL);

      XtAddEventHandler(summaryhead,StructureNotifyMask,False, myResizeHandler, (XtPointer)((int)Pheight));

    }
  else
    {
      ResetWidget(summaryhead);
    }
}



void savetemp2Callback(Widget w, XtPointer userData, XtPointer callData)
{
  EnterFileCallback(savecond_wid, (XtPointer)19,(XtPointer)19);
}


void savePrefCallback(Widget w, XtPointer userData, XtPointer callData)
{
  
  EnterFileCallback(savepref_wid, (XtPointer)33,(XtPointer)33);
}


void OverWritePrefs(Widget w,XtPointer data,XtPointer callData)
{
  XtDestroyWidget(XtParent(XtParent(w)));

  RealSavePrefs();
}





void LoadPrefCallback(Widget w, Widget list_w, XtPointer callData)
{
  XmString *selectlist;
  FILE *outfile;
  char *text;
  char filename[1000],message[1000];
  int totalobjs;
 
  XtVaGetValues(list_w,
		XmNselectedItemCount,&totalobjs,
		XmNselectedItems    ,&selectlist,
		NULL);


  if(totalobjs!=1)
    {
      sprintf(message,"No preference set selected in the list.\nClick one to select it for loading.");
      
      not_while_running(w,message,1452,"Select Preferences Help",5);
      
      return;
    }

  XmStringGetLtoR(selectlist[0],
		  (XmStringCharSet) XmSTRING_DEFAULT_CHARSET, &text);


  printf("*** Load %s\n",text);


  if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
  {
    sprintf(filename,"%s\\ProjectPreferences\\%s",PROJECTLOC,text);
  }
  else
  {
    sprintf(filename,"%s/ProjectPreferences/%s",PROJECTLOC,text);
  }


  outfile = fopen(filename,"r");
  if(outfile==NULL)
  {
    sprintf(message,"Couldnt open file for reading:\n%s",filename); 
    not_while_running(drawing_a,message,1604,"Couldnt open preference file for reading",1);
    return;
  }


  ProcessEnvVars(outfile,2);


  if(GAITProjectName[0]!='\0')
  {
    

    if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
	{
	  sprintf(importdirectory,"%s\\%s\\InputSpecFile.txt",PROJECTLOC,GAITProjectName);
	  sprintf(importoutputdir,"%s\\%s\\",PROJECTLOC,GAITProjectName);
	}
    else
	{
	  sprintf(importdirectory,"%s/%s/InputSpecFile.txt",PROJECTLOC,GAITProjectName);
	  sprintf(importoutputdir,"%s/%s/",PROJECTLOC,GAITProjectName);
	}

    import_source        = 1;
    import_output_source = 1;
  }


  fclose(outfile);


  XtDestroyWidget(XtParent(XtParent(XtParent(w))));

}



void RealSavePrefs()
{
  FILE *outfile;
  char tester[1000],message[1000];


  

  if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
  {
    sprintf(tester,"%s\\ProjectPreferences\\%s.txt",PROJECTLOC,SavePrefName);
  }
  else
  {
    sprintf(tester,"%s/ProjectPreferences/%s.txt",PROJECTLOC,SavePrefName);
  }

  printf("***Save prefs to %s\n",tester);

  outfile = fopen(tester,"w");
  if(outfile==NULL)
  {
    sprintf(message,"Couldnt open file for writing:\n%s",tester); 
    not_while_running(drawing_a,message,1603,"Couldnt open preference file for writing",1);
    return;
  }


  ProcessEnvVars(outfile,1);


  fclose(outfile);
  XtDestroyWidget(allpref_dialog);

}


void SavereportCallback(Widget w, XtPointer userData, XtPointer callData)
{
  static Widget dialog;
  Widget rc,form,button,label1;
  Arg resources[15];
  int n=0;  
  
  
  if(SAVE_CREPORT_UP==1)
    {
      ResetWidget(dialog);
      return;
    }


  n=0;
  XtSetArg(resources[n],  XmNdeleteResponse, XmDESTROY); n++;
  XtSetArg(resources[n],  XmNmaxWidth,       800);       n++;
  

  dialog = XtCreatePopupShell("Save Condition Report",topLevelShellWidgetClass,w,resources,n);

  
  rc = XtVaCreateManagedWidget
    (
     "XformWidget", xmPanedWindowWidgetClass, dialog,
     XmNrubberPositioning, False,
     XmNresizable,         True,
     XmNseparatorOn,       False,
     XmNsashHeight,        1,
     NULL
     );
  
  form = XtVaCreateWidget ("form7", xmFormWidgetClass, rc,
			   XmNpaneMinimum,     35,
			   XmNpaneMaximum,     35,
			   XmNseparatorOn,     False,
			   XmNfractionBase,    100,  
			   NULL);
  
  
  label1 = XtVaCreateManagedWidget ("Enter name for condition report:",
				    xmLabelWidgetClass,  form,
				    XmNrightAttachment,  XmATTACH_POSITION,
				    XmNrightPosition,    50,
				    XmNleftAttachment,   XmATTACH_POSITION,
				    XmNleftPosition,     0,
				    XmNalignment,        XmALIGNMENT_CENTER,
				    XmNtopAttachment,    XmATTACH_FORM,
				    XmNbottomAttachment, XmATTACH_FORM,
				    LABELWTRANSLATE,
				    NULL);
  XtManageChild(label1);
  
  
  
  savecond_wid = XtVaCreateManagedWidget ("text_w",
					  xmTextFieldWidgetClass, form,	  
					  XmNvalue,               SaveReportName,
					  XmNmaxLength,           24,
					  XmNtraversalOn,         True,
					  XmNrightAttachment,     XmATTACH_POSITION,
					  XmNrightPosition,       99,
					  XmNleftAttachment,      XmATTACH_POSITION,
					  XmNleftPosition,        51,
					  XmNtopAttachment,       XmATTACH_FORM,
					  XmNbottomAttachment,    XmATTACH_FORM,
                      XmNtranslations,        XtParseTranslationTable ( translations_paste ) ,
					  NULL);
  
  XtAddCallback (savecond_wid, XmNactivateCallback,
		 EnterFileCallback, (XtPointer)19);  
  XtManageChild(savecond_wid);
  XtManageChild(form);

  

  

  
  
  form = XtVaCreateWidget ("form17e", xmFormWidgetClass, rc,
			   XmNpaneMinimum,   35,
			   XmNpaneMaximum,   35,
			   XmNseparatorOn,   False,
			   XmNfractionBase,  100,  
			   NULL);      

  button  = XtVaCreateManagedWidget("SCR4",xmPushButtonWidgetClass,form,
				    XmNlabelString,       STRING("Help"),
					XmNdefaultButtonShadowThickness, 1,
				    XmNtopAttachment,                XmATTACH_FORM,
				    XmNbottomAttachment,             XmATTACH_FORM,
				    XmNrightAttachment,              XmATTACH_POSITION,
				    XmNrightPosition,                99,
				    XmNleftAttachment,               XmATTACH_POSITION,
				    XmNleftPosition,                 66,
				    XmNtraversalOn,                  False,
				    XmNtranslations, XtParseTranslationTable ( translations_global ) ,
				    NULL
				    );
  
  XtAddCallback(button, XmNactivateCallback, saveCRhelpCallback, (XtPointer) NULL);
  XtManageChild(button);
  
  

  button  = XtVaCreateManagedWidget("SCR3",xmPushButtonWidgetClass,form,
				    XmNlabelString,       STRING("Cancel"),
					XmNdefaultButtonShadowThickness, 1,  
				    XmNtopAttachment,                XmATTACH_FORM,
				    XmNbottomAttachment,             XmATTACH_FORM,
				    XmNrightAttachment,              XmATTACH_POSITION,
				    XmNrightPosition,                66,
				    XmNleftAttachment,               XmATTACH_POSITION,
				    XmNleftPosition,                 33,
				    XmNtraversalOn,                  False,
				    XmNtranslations, XtParseTranslationTable ( translations_global ) ,
				    NULL
				    );
  
  XtAddCallback(button, XmNactivateCallback, die_callback, (XtPointer) 44);
  XtManageChild(button);



  button  = XtVaCreateManagedWidget("SCR4",xmPushButtonWidgetClass,form,
				    XmNlabelString,                  STRING("Save/Done"),
				    XmNtopAttachment,                XmATTACH_FORM,
				    XmNbottomAttachment,             XmATTACH_FORM,
				    XmNrightAttachment,              XmATTACH_POSITION,
				    XmNrightPosition,                33,
				    XmNleftAttachment,               XmATTACH_POSITION,
				    XmNleftPosition,                 1,
					XmNshowAsDefault,                True,
					XmNdefaultButtonShadowThickness, 1,
				    XmNtraversalOn,                  False,
				    XmNtranslations, XtParseTranslationTable ( translations_global ) ,
				    NULL
				    ); 
  
  XtAddCallback(button, XmNactivateCallback, savetemp2Callback, (XtPointer) NULL);
  XtManageChild(button); 
  XtManageChild(form);


  XtVaSetValues(rc,
			XmNdefaultButton, button,
			NULL);
 

  XtManageChild(rc);
  MyPopup(dialog); 
      
  XtAddCallback(dialog,XmNdestroyCallback,ShellDeath,(XtPointer)116);
  
  SAVE_CREPORT_UP = 1;

}




void PrefsCallback(Widget w, XtPointer userData, XtPointer callData)
{
  static Widget dialog;
  int num,i;
  char startdirectory[1000];


  if(dead_head7==0)
    {
      ResetWidget(dialog);
      return;
    }


  if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
    {
      sprintf(startdirectory,"%s\\ProjectPreferences\\",PROJECTLOC);
    }
  else
    {
      sprintf(startdirectory,"%s/ProjectPreferences/",PROJECTLOC);
    }

  
  num = GetFolders(startdirectory,11,1);
  
  if(num==0)
    {
      printf("No preferences were found in:\n  %s",startdirectory);
    }
  else
    {
      SortFileList(0,num-1,7);
    }



       


  allpref_dialog = MakePicker(NULL,8,num,-1,-1); 
  dialog      = allpref_dialog;



  dead_head7 = 0;  

  if(num>0)
  {
    for(i=0;i<num;i++)
	{
       free(TempFileList[i]);
    }
    free(TempFileList);
  }
  TempFileList = NULL;
}




int GetNumNets(char *condname)
{
  FILE *infile;
  char netname[1000],title[2000];
  int numfound,totalnets,i,Ijunk;
  
  if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
    {
      sprintf(netname,"%scondition_reports\\%s.nt",indirectory,condname);
    }
  else
    {
      sprintf(netname,"%scondition_reports/%s.nt",indirectory,condname);
    }


  infile = fopen(netname,"rb");
  if(infile==NULL)
    {
      XBell(mydisplay,50);
      printf("could not open %s for read\n",netname);
      return 0;
    }
  else
    {
      numfound = 0;
      SEEIT_fread_int(&totalnets,infile);
      
      for(i=0; i<totalnets; i++)
	{
	  SEEIT_fread_int(&Ijunk, infile);
	  SEEIT_fread_int(&Ijunk, infile);
	  SEEIT_fread_int(&Ijunk, infile);
	  fread(&title[0],1000,1, infile);
	  
	  numfound = numfound + Ijunk;
	}
      fclose(infile);
    }

  return numfound;
}



int GetNumConds(char *condname)
{
  FILE *infile;
  char crname[1000];
  long int Ljunk;
  int i,Ijunk1,numconds,total=0,Ijunk2,Ijunk3,Ijunk4;
  
  

  
  if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
    {
      sprintf(crname,"%scondition_reports\\%s.lk",indirectory,condname);
    }
  else
    {
      sprintf(crname,"%scondition_reports/%s.lk",indirectory,condname);
    }
  
  
  infile = fopen(crname,"rb");
  if(infile==NULL)
    {
      XBell(mydisplay,50);
      printf("could not open %s for read\n",crname);
      return 0;
    }


  SEEIT_fread_int(&numconds, infile);
  

  for(i=1;i<=numconds;i++)
    {
      SEEIT_fread_int (&Ijunk1, infile);  
      SEEIT_fread_int (&Ijunk2, infile);  
      SEEIT_fread_int (&Ijunk3  ,infile); 
      SEEIT_fread_int (&Ijunk4  ,infile); 
      SEEIT_fread_long(&Ljunk,infile);

      total = total + Ijunk3;
    }
  fclose(infile);

  return total;
}




char *PadSpaces(int maxlen, int thislen)
{
  int i;
  static char result[100];

  result[0] = '\0';

  for(i=0;i<(maxlen-thislen);i++)
    {
      result[i] = ' ';
    }
  result[i] = '\0';
  return result;
}


char *PadSpaces2(int maxlen, int thislen)
{
  int i;
  static char result[100];

  result[0] = '\0';

  for(i=0;i<(maxlen-thislen);i++)
    {
      result[i] = ' ';
    }
  result[i] = '\0';
  return result;
}





void GetNumFeat(char *name,int *nfeat,unsigned int *ngrid,int *is2D, int *is3D)
{
  FILE *headfile;
  char temp[1000], message[2000];
  double MINYREAD, MINXREAD, MAXYREAD, MAXXREAD, MINY_P_READ, MINX_P_READ, MAXY_P_READ, MAXX_P_READ;
  long int POINT_POINTSREAD, LINEAR_POINTSREAD, AREAL_POINTSREAD;
  unsigned int GRIDPOINTSREAD,TERRAINPOLYSREAD;
  int GRIDSREAD, coordflag, num_long_entries,num_short_entries, num_line_features=0, 
    num_area_features=0,tempint = 0,num_point_features=0;
  unsigned char a,b,c,d;
  int temp2d, temp3d;
  

  temp2d = 0;
  temp3d = 0;
  *nfeat = 0;
  *ngrid = 0;
  *is2D  = 0;
  *is3D  = 0;
  
  if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
    {
      sprintf(temp,"%s\\%s\\header.txt",PROJECTLOC,name);
    }
  else
    {
      sprintf(temp,"%s/%s/header.txt",PROJECTLOC,name);
    }
  
  headfile = fopen(temp,"r");
  if(headfile==NULL)
    {
      sprintf(message,"Couldnt open %s for read.\n",temp); 
      not_while_running(drawing_a,message,1265,"Couldnt open file",1);
      return;
    }
  
  fscanf(headfile,"%d %lf %lf %lf %lf %lf %lf %lf %lf %u %u %ld %ld %ld %d %d %d\n",
	 &coordflag,
	 &MINXREAD,&MINYREAD,&MAXXREAD,&MAXYREAD,
	 &MINX_P_READ,&MINY_P_READ,&MAXX_P_READ,&MAXY_P_READ,
	 &TERRAINPOLYSREAD,
	 &GRIDPOINTSREAD,&POINT_POINTSREAD,&LINEAR_POINTSREAD,&AREAL_POINTSREAD,&GRIDSREAD,
	 &num_long_entries,&num_short_entries);
  
  fclose(headfile);
  

  *ngrid = GRIDPOINTSREAD;
 

  tempint = 0;
  if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
    {
      sprintf(temp,"%s\\%s\\linearinfo.txt",PROJECTLOC,name);
    }
  else
    {
      sprintf(temp,"%s/%s/linearinfo.txt",PROJECTLOC,name);
    }
  headfile = fopen(temp,"r");
  if(headfile==NULL)
    {
      printf("Couldnt open %s for read.\n",temp); 
      return;
    }
  
  fscanf(headfile,"%d",&tempint);
  while(!feof(headfile))
    {
      num_line_features = num_line_features + tempint;
      fscanf(headfile,"%d",&tempint);
    }
  fclose(headfile);
  

  *nfeat = *nfeat + num_line_features;






  tempint = 0;
  if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
    {
      sprintf(temp,"%s\\%s\\arealinfo.txt",PROJECTLOC,name);
    }
  else
    {
      sprintf(temp,"%s/%s/arealinfo.txt",PROJECTLOC,name);
    }
  headfile = fopen(temp,"r");
  if(headfile==NULL)
    {
      printf("Couldnt open %s for read.\n",temp); 
      return;
    }
  
  fscanf(headfile,"%d",&tempint);
  while(!feof(headfile))
    {
      num_area_features = num_area_features + tempint;
      fscanf(headfile,"%d",&tempint);
    }
  fclose(headfile);


  *nfeat = *nfeat + num_area_features;






  tempint = 0;
  if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
    {
      sprintf(temp,"%s\\%s\\pointinfo.txt",PROJECTLOC,name);
    }
  else
    {
      sprintf(temp,"%s/%s/pointinfo.txt",PROJECTLOC,name);
    }
  headfile = fopen(temp,"r");
  if(headfile==NULL)
    {
      printf("Couldnt open %s for read.\n",temp); 
      return;
    }
  
  fscanf(headfile,"%d",&tempint);
  while(!feof(headfile))
    {
      num_point_features = num_point_features + tempint;
      fscanf(headfile,"%d",&tempint);
    }
  fclose(headfile);


  *nfeat = *nfeat + num_point_features;








  

  if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
    {
      sprintf(temp,"%s\\%s\\sizes.bin",PROJECTLOC,name);
    }
  else
    {
      sprintf(temp,"%s/%s/sizes.bin",PROJECTLOC,name);
    }

  headfile = fopen(temp,"rb");
  if(headfile==NULL)
    {
      return;
    }
  else
    {
      fread(&d, SzUC,1,headfile);
      fread(&a, SzUC,1,headfile);
      fread(&b, SzUC,1,headfile);
      fread(&c, SzUC,1,headfile);
       
      SEEIT_fread_int(&temp2d,headfile);
      if(temp2d>0)
	{
	  *is2D = 1;
	}
      SEEIT_fread_int(&temp3d,headfile);
      if(temp3d>0)
	{
	  *is3D = 1;
	}
      SEEIT_fread_int(&temp2d,headfile);
      if(temp2d>0)
	{
	  *is2D = 1;
	}
      SEEIT_fread_int(&temp3d,headfile);
      if(temp3d>0)
	{
	  *is3D = 1;
	}
      SEEIT_fread_int(&temp2d,headfile);
      if(temp2d>0)
	{
	  *is2D = 1;
	}
      SEEIT_fread_int(&temp3d,headfile);
      if(temp3d>0)
	{
	  *is3D = 1;
	}
    }

  fclose(headfile);

  if(*ngrid>0)
    {
      *is3D = 1;
    }

}




char * GetAttrType(char *proj_name)
{
  FILE *testfile;
  unsigned char a;
  char testloc[1000],message[1000];
  int thisattr,Ijunk;
  static char retval[250];


  if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
    {
      sprintf(testloc,"%s\\%s\\attrsch.bin",PROJECTLOC,proj_name);
    }
  else
    {
      sprintf(testloc,"%s/%s/attrsch.bin",PROJECTLOC,proj_name);
    }
  
  testfile = fopen(testloc,"rb");
  if(testfile==NULL)
    {
      return "Unknown";
    }
  
  fread(&a, SzUC,1,testfile);
  
  thisattr = (int)a;
  
  fclose(testfile);







  if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
  { 
    sprintf(testloc,"%s\\%s\\multiinfo.txt",PROJECTLOC,proj_name);
  }
  else
  {
    sprintf(testloc,"%s/%s/multiinfo.txt",PROJECTLOC,proj_name);
  }

  testfile = fopen(testloc,"r");
  if(testfile==NULL)
    {
      sprintf(message,"Couldnt open %s for read.\n",testloc); 
      not_while_running(drawing_a,message,1265,"Couldnt open file",1);
      return "Error-See Console";
    }
  
  fscanf(testfile,"%d",&Ijunk);   
  fscanf(testfile,"%d",&Ijunk);   
  fscanf(testfile,"%d",&Ijunk);   
  fscanf(testfile,"%d",&Ijunk);   
  fscanf(testfile,"%d",&Ijunk);   
  fscanf(testfile,"%d",&Ijunk);   
  fscanf(testfile,"%d",&Ijunk);   
  fscanf(testfile,"%d",&Ijunk);   
  fscanf(testfile,"%d",&Ijunk);   
  fscanf(testfile,"%d",&Ijunk);   
  fscanf(testfile,"%d",&Ijunk);   
  fscanf(testfile,"%d",&Ijunk);   
  fscanf(testfile,"%d",&Ijunk);   

  fclose(testfile);



  OVERRIDING_ATTRINS = Ijunk;

  sprintf(retval,"%s",ParseAttributionType(thisattr));

  OVERRIDING_ATTRINS = -1;

  return retval;
}



int GetNumAOI(char *aoi_name)
{
  FILE *testfile;
  char aline[1000];
  char testloc[1000];
  int lines=0;
  
  if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
    {
      sprintf(testloc,"%s\\points_of_interest_files\\%s",indirectory,aoi_name);
    }
  else
    {
      sprintf(testloc,"%s/points_of_interest_files/%s",indirectory,aoi_name);
    }
  
  testfile = fopen(testloc,"r");
  if(testfile==NULL)
    {
      return 0;
    }
  

  fgets(aline,1000,testfile);
  
  if(feof(testfile))
    {
      fclose(testfile);
      return 0;
    }

  
  fgets(aline,1000,testfile);
  while(!feof(testfile))
    {
      lines = lines + 1;
      fgets(aline,1000,testfile);

      if(lines>=1000000)
	{
	  break;
	}
    }

  fclose(testfile);
  return lines;
  
}





void ModifyAOIList(int num)
{
  int i,maxlen=0,thislen;
  int aoipad,numaoi;
  char temp[1000];


  
  for(i=0;i<num;i++)
    {
      thislen = strlen(GAITAOIList[i]);
      if(thislen>maxlen)
	{
	  maxlen = thislen;
	}
    }



  for(i=0;i<num;i++)
    {
      sprintf(temp,"%s",GAITAOIList[i]);
      numaoi = GetNumAOI(temp);
    }


  aoipad = getspace(numaoi);
  
  
  for(i=0;i<num;i++)
    {
      sprintf(temp,"%s",GAITAOIList[i]);
      
      numaoi = GetNumAOI(temp);
      
      sprintf(GAITAOIList[i],"%s %s (%*d locations)",
	      temp,
	      PadSpaces(maxlen,strlen(GAITAOIList[i])),
	      aoipad,numaoi);
      
    }
}





char *Print23D(int is2D, int is3D)
{

  if((is2D>0)&&(is3D>0))
    {
      return "(2&3D)";
    }
  else if(is2D>0)
    {
      return " (2D) ";
    }
  else if(is3D>0)
    {
      return " (3D) ";
    }
  else
    {
      
      return "       ";
    }
}


void ModifyProjList(int num, int *foundfeat, int *foundgrid)
{
  int i,maxlen=0,maxalen=0,thislen,maxfeat=0,maxgrid=0;
  int featpad,gridpad;
  char temp[1000];
  unsigned int ngrid=0;
  int nfeat=0;
  int is2D=0,is3D=0;

  *foundfeat = 0;
  *foundgrid = 0;

  for(i=0;i<num;i++)
    {
      thislen = strlen(GAITProjList[i]);
      if(thislen>maxlen)
	{
	  maxlen = thislen;
	}

      thislen = strlen(GetAttrType(GAITProjList[i]));
      if(thislen>maxalen)
	{
	  maxalen = thislen;
	}
    }



  for(i=0;i<num;i++)
    {
      sprintf(temp,"%s",GAITProjList[i]);
      GetNumFeat(temp,&nfeat,&ngrid,&is2D,&is3D);
      if(nfeat>0)
	{
	  *foundfeat = 1;
	}
      if(ngrid>0)
	{
	  *foundgrid = 1;
	}
      if(nfeat>maxfeat)
	{
	  maxfeat = nfeat;
	}
      if((int)ngrid>maxgrid)
	{
	  maxgrid = ngrid;
	}

    }



  featpad = getspace(maxfeat);
  gridpad = getspace(maxgrid);


  
  for(i=0;i<num;i++)
    {
      sprintf(temp,"%s",GAITProjList[i]);

      GetNumFeat(temp,&nfeat,&ngrid,&is2D,&is3D);

      if((*foundfeat>0)&&(*foundgrid>0))
	{
	  sprintf(GAITProjList[i],"%s %s (%*d features, %*u posts) (%s) %s%s",
		  temp,
		  PadSpaces(maxlen,strlen(GAITProjList[i])),
		  featpad,nfeat,
		  gridpad,ngrid,
		  GetAttrType(GAITProjList[i]),
		  PadSpaces2(maxalen,strlen(GetAttrType(GAITProjList[i]))),
		  Print23D(is2D,is3D));
	}
      else if(*foundfeat>0)
	{
	  sprintf(GAITProjList[i],"%s %s (%*d features) (%s) %s%s",
		  temp,
		  PadSpaces(maxlen,strlen(GAITProjList[i])),
		  featpad,nfeat,
		  GetAttrType(GAITProjList[i]),
		  PadSpaces2(maxalen,strlen(GetAttrType(GAITProjList[i]))),
		  Print23D(is2D,is3D));
	}
      else if(*foundgrid>0)
	{
	  sprintf(GAITProjList[i],"%s %s (%*u posts) (%s) %s%s",
		  temp,
		  PadSpaces(maxlen,strlen(GAITProjList[i])),
		  gridpad,ngrid,
		  GetAttrType(GAITProjList[i]),
		  PadSpaces2(maxalen,strlen(GetAttrType(GAITProjList[i]))),
		  Print23D(is2D,is3D));
	}
      else
	{
	  XBell(mydisplay,50);
	  printf("error!  found project %s with no feature or grid data\n",GAITProjList[i]);
	}
    }
}







void ModifyCondList(int num)
{
  int i,maxlen=0,maxconds=0,maxnets=0,thislen,condpad,netpad,numconds,numnets,condnum,
    retained,ignored;
  char temp[1000],sendname[1000];
  
  

  for(i=0;i<num;i++)
    {
      thislen = strlen(GAITCondList[i]);
      if(thislen>maxlen)
	{
	  maxlen = thislen;
	}

      numconds = GetNumConds(GAITCondList[i]);
      if(numconds>maxconds)
	{
	  maxconds = numconds;
	}

      numnets = GetNumNets(GAITCondList[i]);
      if(numnets>maxnets)
	{
	  maxnets = numnets;
	}
    }

  condpad = getspace(maxconds);
  netpad  = getspace(maxnets);



  for(i=0;i<num;i++)
    {
      
      condnum = GetNumConds(GAITCondList[i]);
      
      if(condnum>0)
	{
	  if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
	    {
	      sprintf(sendname,"%scondition_reports\\%s.lk2",indirectory,GAITCondList[i]);
	    }
	  else
	    {
	      sprintf(sendname,"%scondition_reports/%s.lk2",indirectory,GAITCondList[i]);
	    }
	  
	  CountIgnored(&ignored,&retained,sendname,0);
	}
      else
	{
	  retained = 0;
	  ignored  = 0;
	}

      if((maxnets>0)&&(maxconds>0))
	{
	  sprintf(temp,"%s",GAITCondList[i]);
	  sprintf(GAITCondList[i],"%s %s (%*d conditions [%*d retained, %*d ignored], %*d networks)",
		  temp,
		  PadSpaces(maxlen,strlen(GAITCondList[i])),
		  condpad,condnum,
		  condpad,retained,
		  condpad,ignored,
		  netpad,GetNumNets(GAITCondList[i]));
	}
      else if(maxconds>0)
	{
	  sprintf(temp,"%s",GAITCondList[i]);
	  sprintf(GAITCondList[i],"%s %s (%*d conditions [%*d retained, %*d ignored])",
		  temp,
		  PadSpaces(maxlen,strlen(GAITCondList[i])),
		  condpad,condnum,
		  condpad,retained,
		  condpad,ignored);
	}
      else if(maxnets>0)
	{
	  sprintf(temp,"%s",GAITCondList[i]);
	  sprintf(GAITCondList[i],"%s %s (0 conditions, %*d networks)",
		  temp,
		  PadSpaces(maxlen,strlen(GAITCondList[i])),
		  netpad,GetNumNets(GAITCondList[i]));
	}
      else
	{
	  sprintf(temp,"%s",GAITCondList[i]);
	  sprintf(GAITCondList[i],"%s %s (0 conditions, 0 networks)",
		  temp,PadSpaces(maxlen,strlen(GAITCondList[i])));
	}
    }
}





void LoadreportCallback(Widget w, XtPointer userData, XtPointer callData)
{
  static Widget dialog;
  int num,i;
  char startdirectory[1000],message[1000];


  if(dead_head5==0)
    {
      ResetWidget(dialog);
      return;
    }


  if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
    {
      sprintf(startdirectory,"%scondition_reports\\",indirectory);
    }
  else
    {
      sprintf(startdirectory,"%scondition_reports/",indirectory);
    }
  
  num = GetFolders(startdirectory,3,1);
  
  if(num==0)
    {
      sprintf(message,"No condition reports were found in the current GAIT project.\n");
      
      not_while_running(w,message,1414,"No Condition Reports Found",1);   
      return;
    }
  else
    {
      

      SortCondList(0,num-1,3);

      
    }



  ModifyCondList(num);




       

  cond_dialog = MakePicker(NULL,3,num,-1,-1); 
  dialog      = cond_dialog;

  dead_head5 = 0;  
  
  for(i=0;i<num;i++)
    {
      free(GAITCondList[i]);
    }
  free(GAITCondList);
  GAITCondList = NULL;
}








void DescCallback(Widget w, XtPointer userData, XtPointer callData)
{
  static Widget dialog[CONDITION_ARRAY_SIZE];
  Widget parent_wid,temp_w,rowcol;
  XmString t,t1,t2,t3,t4;
  Arg args[15];
  char message1[2000],message2[2000];
  int errnum,i=0,n = 0;
  
  errnum = (int)userData;
  
  if(HELP_UP[errnum]==1)
    {
      ResetWidget(dialog[errnum]);
      return;
    }
  else
    {
      if(DEBUG==1){printf("got %d\n",errnum);}
      
	  if(IsNetCheck(errnum)==1)
	  {
        sprintf(message1,"Network Creation");
	  }
	  else
	  {
        sprintf(message1,"%s",ErrorLookup[errnum].name);
	  }
      
      while(message1[i]!='\0')
	{
	  if(message1[i]=='\n')
	    {message1[i]=' ';}
	  i++;
	}
     
	  if(IsNetCheck(errnum)==1)
	  {
        sprintf(message2,"This capability creates networks of features for viewing.");
	  }
	  else
	  {
        sprintf(message2,"%s",ErrorLookup[errnum].description);
	  }
      
      t = XmStringCreateLtoR (message2,"mytag2");
      t1= XmStringCreateLtoR (message1,"mytag1");
      t3= XmStringCreateLtoR (":\n\n","mytag1");
      
      t2 = XmStringConcat(t1,t3);
      t4 = XmStringConcat(t2,t);
      
      
      
      
      
      if(XtIsComposite(w))
	{
	  parent_wid = w;
	}
      else
	{
	  parent_wid = XtParent(w);
	  i = 1;
	  while(i<10)
	    {
	      if(XtIsComposite(parent_wid))
		{
		  break;
		}
	      else
		{
		  parent_wid = XtParent(parent_wid);
		}
	      i++;
	    }
	}
      
      
      n=0;
      XtSetArg(args[n], XmNdeleteResponse,      XmDESTROY);     n++;
      
      
      dialog[errnum]  = XtCreatePopupShell("Information",topLevelShellWidgetClass,
					   parent_wid,args,n);
      
      rowcol = XtVaCreateWidget ("rowcol",
				 xmRowColumnWidgetClass,  dialog[errnum], NULL);
      
      n = 0;
      XtSetArg(args[n], XmNdialogTitle,   STRING("Information"));    n++;		
      XtSetArg(args[n], XmNdialogType,    XmDIALOG_INFORMATION);     n++;		
      XtSetArg(args[n], XmNmessageString, t4);                       n++;		
      
      temp_w = XmCreateMessageBox (rowcol,"mymessagebox",args,n);
      
      XtAddCallback (temp_w, XmNokCallback, kill_help_callback, userData);
      
      
      XtUnmanageChild (XmMessageBoxGetChild (temp_w, XmDIALOG_CANCEL_BUTTON));
      XtUnmanageChild (XmMessageBoxGetChild (temp_w, XmDIALOG_HELP_BUTTON));
      
      
      XtManageChild(temp_w);
      XtManageChild(rowcol);
      XtManageChild(dialog[errnum]);
      
      MyPopup (dialog[errnum]);
      
      
      XtAddCallback(dialog[errnum],XmNdestroyCallback,ShellDeath,(XtPointer)(400+errnum));
      HELP_UP[errnum]=1;
    } 
}


Widget SpecialBuildMenu(Widget parent,SpecialMenuItem *items,int numitems,unsigned char selection)
{
  Widget menu, cascade, widget;
  int i,n=0;
  Arg args[5];
  
  menu = XmCreatePulldownMenu (parent, "_pulldown", NULL, 0);

  XtSetArg (args[n], XmNsubMenuId, menu); n++;
  XtSetArg (args[n], XmNtranslations, XtParseTranslationTable ( translations_global )); n++;

  cascade = XmCreateOptionMenu (parent, "", args, n);
  
  for (i = 0; i<numitems; i++) 
    {
      widget = XtVaCreateManagedWidget (items[i].label,
					*items[i].cclass, menu,
					NULL);
      if((i==selection)||  ((selection==5)&&(i==4))  )
	{
	  XtVaSetValues(cascade,				
			XmNmenuHistory, widget,
			NULL);
	}
      XtAddCallback (widget,
		     XmNactivateCallback,  (XtCallbackProc)items[i].callback, 
		     (XtPointer)items[i].callback_data);
    }
  return cascade;
}


void toggle_C1_actor(Widget widget,XtPointer client_data,XtPointer call_data)
{
  int errnum,element;
  
  errnum  = ((int)client_data)/1000;
  element = ((int)client_data)%1000;
  if(ACTORDEBUG==1){printf("found that that was error number %d, element %d...for config1\n",errnum,element);}
  
  if(ErrorLookup[errnum].Config1[element]==0)
    {
      ErrorLookup[errnum].Config1[element]=1;
    }
  else
    {
      ErrorLookup[errnum].Config1[element]=0;
    }
}


void toggle_S1_actor(Widget widget,XtPointer client_data,XtPointer call_data)
{
  int errnum,element;
  
  errnum  = ((int)client_data)/1000;
  element = ((int)client_data)%1000;
  if(ACTORDEBUG==1){printf("found that that was error number %d, element %d...for strat1\n",errnum,element);}
  
  if(ErrorLookup[errnum].Stratum1[element]==0)
    {
      ErrorLookup[errnum].Stratum1[element]=1;
    }
  else
    {
      ErrorLookup[errnum].Stratum1[element]=0;
    }
}





















void all_D1_actors(Widget widget,XtPointer client_data,XtPointer call_data)
{
  int errnum = (int)client_data;
  int i;
  
  for(i=0;i<NUM_D;i++)
    {
      if(ErrorLookup[errnum].Domain1[i]==0)
	{
	  ErrorLookup[errnum].Domain1[i] = 1;
	  XmToggleButtonSetState(ErrorLookup[errnum].WidDomain1[i], 1    ,(Boolean)0);
	}
    }
}


void all_D2_actors(Widget widget,XtPointer client_data,XtPointer call_data)
{
  int errnum = (int)client_data;
  int i;
  
  for(i=0;i<NUM_D;i++)
    {
      if(ErrorLookup[errnum].Domain2[i]==0)
	{
	  ErrorLookup[errnum].Domain2[i] = 1;
	  XmToggleButtonSetState(ErrorLookup[errnum].WidDomain2[i], 1    ,(Boolean)0);
	}
    }
}


void all_D3_actors(Widget widget,XtPointer client_data,XtPointer call_data)
{
  int errnum = (int)client_data;
  int i;
  
  for(i=0;i<NUM_D;i++)
    {
      if(ErrorLookup[errnum].Domain3[i]==0)
	{
	  ErrorLookup[errnum].Domain3[i] = 1;
	  XmToggleButtonSetState(ErrorLookup[errnum].WidDomain3[i], 1    ,(Boolean)0);
	}
    }
}







void all_D1_actors_off(Widget widget,XtPointer client_data,XtPointer call_data)
{
  int errnum = (int)client_data;
  int i;
  
  for(i=0;i<NUM_D;i++)
    {
      if(ErrorLookup[errnum].Domain1[i]==1)
	{
	  ErrorLookup[errnum].Domain1[i] = 0;
	  XmToggleButtonSetState(ErrorLookup[errnum].WidDomain1[i], 0    ,(Boolean)0);
	}
    }
}


void all_D2_actors_off(Widget widget,XtPointer client_data,XtPointer call_data)
{
  int errnum = (int)client_data;
  int i;
  
  for(i=0;i<NUM_D;i++)
    {
      if(ErrorLookup[errnum].Domain2[i]==1)
	{
	  ErrorLookup[errnum].Domain2[i] = 0;
	  XmToggleButtonSetState(ErrorLookup[errnum].WidDomain2[i], 0    ,(Boolean)0);
	}
    }
}


void all_D3_actors_off(Widget widget,XtPointer client_data,XtPointer call_data)
{
  int errnum = (int)client_data;
  int i;
  
  for(i=0;i<NUM_D;i++)
    {
      if(ErrorLookup[errnum].Domain3[i]==1)
	{
	  ErrorLookup[errnum].Domain3[i] = 0;
	  XmToggleButtonSetState(ErrorLookup[errnum].WidDomain3[i], 0    ,(Boolean)0);
	}
    }
}









void all_S1_actors(Widget widget,XtPointer client_data,XtPointer call_data)
{
  int errnum = (int)client_data;
  int i;
  
  for(i=0;i<NUM_S;i++)
    {
      if(ErrorLookup[errnum].Stratum1[i]==0)
	{
	  ErrorLookup[errnum].Stratum1[i] = 1;
	  if(i!=(NUM_S-1))
	    {
	      XmToggleButtonSetState(ErrorLookup[errnum].WidStratum1[i], 1    ,(Boolean)0);
	    }
	}
    }
}


void all_S2_actors(Widget widget,XtPointer client_data,XtPointer call_data)
{
  int errnum = (int)client_data;
  int i;
  
  for(i=0;i<NUM_S;i++)
    {
      if(ErrorLookup[errnum].Stratum2[i]==0)
	{
	  ErrorLookup[errnum].Stratum2[i] = 1;
	  if(i!=(NUM_S-1))
	    {
	      XmToggleButtonSetState(ErrorLookup[errnum].WidStratum2[i], 1    ,(Boolean)0);
	    }
	}
    }
}


void all_S3_actors(Widget widget,XtPointer client_data,XtPointer call_data)
{
  int errnum = (int)client_data;
  int i;
  
  for(i=0;i<NUM_S;i++)
    {
      if(ErrorLookup[errnum].Stratum3[i]==0)
	{
	  ErrorLookup[errnum].Stratum3[i] = 1;
	  if(i!=(NUM_S-1))
	    {
	      XmToggleButtonSetState(ErrorLookup[errnum].WidStratum3[i], 1    ,(Boolean)0);
	    }
	}
    }
}





void all_S1_actors_off(Widget widget,XtPointer client_data,XtPointer call_data)
{
  int errnum = (int)client_data;
  int i;
  
  for(i=0;i<NUM_S;i++)
    {
      if(ErrorLookup[errnum].Stratum1[i]==1)
	{
	  ErrorLookup[errnum].Stratum1[i] = 0;
	  if(i!=(NUM_S-1))
	    {
	      XmToggleButtonSetState(ErrorLookup[errnum].WidStratum1[i], 0    ,(Boolean)0);
	    }
	}
    }
}


void all_S2_actors_off(Widget widget,XtPointer client_data,XtPointer call_data)
{
  int errnum = (int)client_data;
  int i;
  
  for(i=0;i<NUM_S;i++)
    {
      if(ErrorLookup[errnum].Stratum2[i]==1)
	{
	  ErrorLookup[errnum].Stratum2[i] = 0;
	  if(i!=(NUM_S-1))
	    {
	      XmToggleButtonSetState(ErrorLookup[errnum].WidStratum2[i], 0    ,(Boolean)0);
	    }
	}
    }
}


void all_S3_actors_off(Widget widget,XtPointer client_data,XtPointer call_data)
{
  int errnum = (int)client_data;
  int i;
  
  for(i=0;i<NUM_S;i++)
    {
      if(ErrorLookup[errnum].Stratum3[i]==1)
	{
	  ErrorLookup[errnum].Stratum3[i] = 0;
	  if(i!=(NUM_S-1))
	    {
	      XmToggleButtonSetState(ErrorLookup[errnum].WidStratum3[i], 0    ,(Boolean)0);
	    }
	}
    }
}






























void toggle_D1_actor(Widget widget,XtPointer client_data,XtPointer call_data)
{
  int errnum,element;
  int stuff = (int)client_data;

  errnum  = stuff/1000;
  element = stuff%1000;

  if(ACTORDEBUG==1){printf("found that that was error number %d, element %d...for domain1\n",errnum,element);}

  if(ErrorLookup[errnum].Domain1[element]==0)
    {
      ErrorLookup[errnum].Domain1[element]=1;
    }
  else
    {
      ErrorLookup[errnum].Domain1[element]=0;
    }
}

void toggle_C2_actor(Widget widget,XtPointer client_data,XtPointer call_data)
{
  int errnum,element;

  errnum  = ((int)client_data)/1000;
  element = ((int)client_data)%1000;
  if(ACTORDEBUG==1){printf("found that that was error number %d, element %d...for config2\n",errnum,element);}

  if(ErrorLookup[errnum].Config2[element]==0)
    {
      ErrorLookup[errnum].Config2[element]=1;
    }
  else
    {
      ErrorLookup[errnum].Config2[element]=0;
    }
}

void toggle_S2_actor(Widget widget,XtPointer client_data,XtPointer call_data)
{
  int errnum,element;

  errnum  = ((int)client_data)/1000;
  element = ((int)client_data)%1000;
  if(ACTORDEBUG==1){printf("found that that was error number %d, element %d...for strat2\n",errnum,element);}

  if(ErrorLookup[errnum].Stratum2[element]==0)
    {
      ErrorLookup[errnum].Stratum2[element]=1;
    }
  else
    {
      ErrorLookup[errnum].Stratum2[element]=0;
    }
}

void toggle_D2_actor(Widget widget,XtPointer client_data,XtPointer call_data)
{
  int errnum,element;

  errnum  = ((int)client_data)/1000;
  element = ((int)client_data)%1000;

  if(ACTORDEBUG==1){printf("found that that was error number %d, element %d...for domain2\n",errnum,element);}

  if(ErrorLookup[errnum].Domain2[element]==0)
    {
      ErrorLookup[errnum].Domain2[element]=1;
    }
  else
    {
      ErrorLookup[errnum].Domain2[element]=0;
    }
}

void toggle_C3_actor(Widget widget,XtPointer client_data,XtPointer call_data)
{
  int errnum,element;

  errnum  = ((int)client_data)/1000;
  element = ((int)client_data)%1000;
  if(ACTORDEBUG==1){printf("found that that was error number %d, element %d...for config3\n",errnum,element);}

  if(ErrorLookup[errnum].Config3[element]==0)
    {
      ErrorLookup[errnum].Config3[element]=1;
    }
  else
    {
      ErrorLookup[errnum].Config3[element]=0;
    }
}


void toggle_S3_actor(Widget widget,XtPointer client_data,XtPointer call_data)
{
  int errnum,element;

  errnum  = ((int)client_data)/1000;
  element = ((int)client_data)%1000;
  if(ACTORDEBUG==1){printf("found that that was error number %d, element %d...for strat3\n",errnum,element);}

  if(ErrorLookup[errnum].Stratum3[element]==0)
    {
      ErrorLookup[errnum].Stratum3[element]=1;
    }
  else
    {
      ErrorLookup[errnum].Stratum3[element]=0;
    }
}



void toggle_D3_actor(Widget widget,XtPointer client_data,XtPointer call_data)
{
  int errnum,element;

  errnum  = ((int)client_data)/1000;
  element = ((int)client_data)%1000;

  if(ACTORDEBUG==1){printf("found that that was error number %d, element %d...for domain3\n",errnum,element);}

  if(ErrorLookup[errnum].Domain3[element]==0)
    {
      ErrorLookup[errnum].Domain3[element]=1;
    }
  else
    {
      ErrorLookup[errnum].Domain3[element]=0;
    }
}







void all_Clone_actors_onoff(Widget w, MyData *userData, XtPointer callData)
{
  int errnum   = userData->check_num;
  int clonenum = userData->clonenum;
  int CSD      = userData->csdstuff;
  int value    = userData->element;
  int index, foundone=0,i;


  if(CLONEDEBUG==1)
    {
      printf("ALL clone errnum %d clonenum %d CSD %d on/off: %d\n",errnum,clonenum,CSD,value);
    }

  for(index=0;index<CLONE_DEFINITIONS;index++)
    {
      if(CloneErrorLookup[index].CloneNumber==errnum)
	{
	  foundone++;
	  if(foundone==clonenum)
	    {
	      break;
	    }
	}
    }
  if(index==CLONE_DEFINITIONS)
    {
      printf("bad news in clone 1, %d %d %d\n",errnum,foundone,clonenum);
    }
  else
    {
      switch(CSD)
	{
	case 2:
	  for(i=0;i<NUM_S;i++)
	    {
	      CloneErrorLookup[index].Stratum1[i] = value;
	      XmToggleButtonSetState(CloneErrorLookup[index].WidStratum1[i], (Boolean)value    ,(Boolean)0);
	    }
	  break;

	case 3:
	  for(i=0;i<NUM_D;i++)
	    {
	      CloneErrorLookup[index].Domain1[i] = value;
	      XmToggleButtonSetState(CloneErrorLookup[index].WidDomain1[i], (Boolean)value    ,(Boolean)0);
	    }
	  break;

	case 12:
	  for(i=0;i<NUM_S;i++)
	    {
	      CloneErrorLookup[index].Stratum2[i] = value;
	      XmToggleButtonSetState(CloneErrorLookup[index].WidStratum2[i], (Boolean)value    ,(Boolean)0);
	    }
	  break;

	case 13:
	  for(i=0;i<NUM_D;i++)
	    {
	      CloneErrorLookup[index].Domain2[i] = value;
	      XmToggleButtonSetState(CloneErrorLookup[index].WidDomain2[i], (Boolean)value    ,(Boolean)0);
	    }
	  break;

	case 22:
	  for(i=0;i<NUM_S;i++)
	    {
	      CloneErrorLookup[index].Stratum3[i] = value;
	      XmToggleButtonSetState(CloneErrorLookup[index].WidStratum3[i], (Boolean)value    ,(Boolean)0);
	    }
	  break;

	case 23:
	  for(i=0;i<NUM_D;i++)
	    {
	      CloneErrorLookup[index].Domain3[i] = value;
	      XmToggleButtonSetState(CloneErrorLookup[index].WidDomain3[i], 
			  (Boolean)value    ,(Boolean)0);
	    }
	  break;
	default:
	  printf("bad csd for all onoff %d %d %d %d\n",errnum,clonenum,CSD,value);
	}
    }

}






void toggle_Clones(Widget w, MyData *userData, XtPointer callData)
{
  int errnum   = userData->check_num;
  int clonenum = userData->clonenum;
  int CSD      = userData->csdstuff;
  int element  = userData->element;
  int index,foundone=0;

  if(CLONEDEBUG==1)
    {
      printf("Toggle errnum %d clonenum %d CSD %d element %d\n",errnum,clonenum,CSD,element);
    }

  for(index=0;index<CLONE_DEFINITIONS;index++)
    {
      if(CloneErrorLookup[index].CloneNumber==errnum)
	{
	  foundone++;
	  if(foundone==clonenum)
	    {
	      break;
	    }
	}
    }
  if(index==CLONE_DEFINITIONS)
    {
      printf("bad news in clone 2, %d %d %d\n",errnum,foundone,clonenum);
    }
  else
    {
      switch(CSD)
	{
	case 1:
	  if( CloneErrorLookup[index].Config1[element]==0)
	    {
	      CloneErrorLookup[index].Config1[element] = 1;
	    }
	  else
	    {
	      CloneErrorLookup[index].Config1[element] = 0;
	    }
	  break;
	case 2:
	  if( CloneErrorLookup[index].Stratum1[element]==0)
	    {
	      CloneErrorLookup[index].Stratum1[element] = 1;
	    }
	  else
	    {
	      CloneErrorLookup[index].Stratum1[element] = 0;
	    }
	  break;
	case 3:
	  if( CloneErrorLookup[index].Domain1[element]==0)
	    {
	      CloneErrorLookup[index].Domain1[element] = 1;
	    }
	  else
	    {
	      CloneErrorLookup[index].Domain1[element] = 0;
	    }
	  break;
	case 11:
	  if( CloneErrorLookup[index].Config2[element]==0)
	    {
	      CloneErrorLookup[index].Config2[element] = 1;
	    }
	  else
	    {
	      CloneErrorLookup[index].Config2[element] = 0;
	    }
	  break;
	case 12:
	  if( CloneErrorLookup[index].Stratum2[element]==0)
	    {
	      CloneErrorLookup[index].Stratum2[element] = 1;
	    }
	  else
	    {
	      CloneErrorLookup[index].Stratum2[element] = 0;
	    }
	  break;
	case 13:
	  if( CloneErrorLookup[index].Domain2[element]==0)
	    {
	      CloneErrorLookup[index].Domain2[element] = 1;
	    }
	  else
	    {
	      CloneErrorLookup[index].Domain2[element] = 0;
	    }
	  break;
	case 21:
	  if( CloneErrorLookup[index].Config3[element]==0)
	    {
	      CloneErrorLookup[index].Config3[element] = 1;
	    }
	  else
	    {
	      CloneErrorLookup[index].Config3[element] = 0;
	    }
	  break;
	case 22:
	  if( CloneErrorLookup[index].Stratum3[element]==0)
	    {
	      CloneErrorLookup[index].Stratum3[element] = 1;
	    }
	  else
	    {
	      CloneErrorLookup[index].Stratum3[element] = 0;
	    }
	  break;
	case 23:
	  if( CloneErrorLookup[index].Domain3[element]==0)
	    {
	      CloneErrorLookup[index].Domain3[element] = 1;
	    }
	  else
	    {
	      CloneErrorLookup[index].Domain3[element] = 0;
	    }
	  break;
	default:
	  printf("bad csd %d\n",CSD);
	  break;
	}
    }
}


int SetButtonProperly(Widget widget, int errnum, int element, int clonenum, int CSD)
{
  int set=0,index;
  int foundone=0;

  if(clonenum==0)
    {
      switch(CSD)
	{
	case 1:
	  XmToggleButtonSetState(widget,(Boolean)ErrorLookup[errnum].Config1[element],(Boolean)0);
	  set = ErrorLookup[errnum].Config1[element];
	  break;
	case 2:
	  XmToggleButtonSetState(widget,(Boolean)ErrorLookup[errnum].Stratum1[element],(Boolean)0);
	  set = ErrorLookup[errnum].Stratum1[element];
	  break;
	case 3:
	  XmToggleButtonSetState(widget,(Boolean)ErrorLookup[errnum].Domain1[element],(Boolean)0);
	  set = ErrorLookup[errnum].Domain1[element];
	  break;
	case 11:
	  XmToggleButtonSetState(widget,(Boolean)ErrorLookup[errnum].Config2[element],(Boolean)0);
	  set = ErrorLookup[errnum].Config2[element];
	  break;
	case 12:
	  XmToggleButtonSetState(widget,(Boolean)ErrorLookup[errnum].Stratum2[element],(Boolean)0);
	  set = ErrorLookup[errnum].Stratum2[element];
	  break;
	case 13:
	  XmToggleButtonSetState(widget,(Boolean)ErrorLookup[errnum].Domain2[element],(Boolean)0);
	  set = ErrorLookup[errnum].Domain2[element];
	  break;
	case 21:
	  XmToggleButtonSetState(widget,(Boolean)ErrorLookup[errnum].Config3[element],(Boolean)0);
	  set = ErrorLookup[errnum].Config3[element];
	  break;
	case 22:
	  XmToggleButtonSetState(widget,(Boolean)ErrorLookup[errnum].Stratum3[element],(Boolean)0);
	  set = ErrorLookup[errnum].Stratum3[element];
	  break;
	case 23:
	  XmToggleButtonSetState(widget,(Boolean)ErrorLookup[errnum].Domain3[element],(Boolean)0);
	  set = ErrorLookup[errnum].Domain3[element];
	  break;
	default:
	  printf("bad csd %d\n",CSD);
	  break;
	}
    }
  else
    {
      for(index=0;index<CLONE_DEFINITIONS;index++)
	{
	  if(CloneErrorLookup[index].CloneNumber==errnum)
	    {
	      foundone++;
	      if(foundone==clonenum)
		{
		  break;
		}
	    }
	}
      if(index==CLONE_DEFINITIONS)
	{
	  printf("bad news in clone 3, %d %d %d\n",errnum,foundone,clonenum);
	}
      else
	{
	  switch(CSD)
	    {
	    case 1:
	      XmToggleButtonSetState(widget,(Boolean)CloneErrorLookup[index].Config1[element],(Boolean)0);
	      set = CloneErrorLookup[index].Config1[element];
	      break;
	    case 2:
	      XmToggleButtonSetState(widget,(Boolean)CloneErrorLookup[index].Stratum1[element],(Boolean)0);
	      set = CloneErrorLookup[index].Stratum1[element];
	      break;
	    case 3:
	      XmToggleButtonSetState(widget,(Boolean)CloneErrorLookup[index].Domain1[element],(Boolean)0);
	      set = CloneErrorLookup[index].Domain1[element];
	      break;
	    case 11:
	      XmToggleButtonSetState(widget,(Boolean)CloneErrorLookup[index].Config2[element],(Boolean)0);
	      set = CloneErrorLookup[index].Config2[element];
	      break;
	    case 12:
	      XmToggleButtonSetState(widget,(Boolean)CloneErrorLookup[index].Stratum2[element],(Boolean)0);
	      set = CloneErrorLookup[index].Stratum2[element];
	      break;
	    case 13:
	      XmToggleButtonSetState(widget,(Boolean)CloneErrorLookup[index].Domain2[element],(Boolean)0);
	      set = CloneErrorLookup[index].Domain2[element];
	      break;
	    case 21:
	      XmToggleButtonSetState(widget,(Boolean)CloneErrorLookup[index].Config3[element],(Boolean)0);
	      set = CloneErrorLookup[index].Config3[element];
	      break;
	    case 22:
	      XmToggleButtonSetState(widget,(Boolean)CloneErrorLookup[index].Stratum3[element],(Boolean)0);
	      set = CloneErrorLookup[index].Stratum3[element];
	      break;
	    case 23:
	      XmToggleButtonSetState(widget,(Boolean)CloneErrorLookup[index].Domain3[element],(Boolean)0);
	      set = CloneErrorLookup[index].Domain3[element];
	      break;
	    default:
	      printf("bad csd %d\n",CSD);
	      break;
	    }
	}
    }
  
  return set;
}


Widget SpecialBuildToggleMenu(Widget parent,SpecialMenuItem *items,
			      int numitems,int errnum,int CSD,int *max,int clonenum)
{
  Widget menu, cascade, widget;
  int i,n=0,set=0,done=0,backup=0,this_element,this_errnum;
  Arg args[5];
  MyData *mydata;


  menu = XmCreatePulldownMenu (parent, "_pulldown", NULL, 0);

  


  XtSetArg (args[n], XmNsubMenuId, menu); n++;
  XtSetArg (args[n], XmNtranslations, XtParseTranslationTable ( translations_global )); n++;


  cascade = XmCreateOptionMenu (parent, "", args, n);

  if(CLONEDEBUG==1)
    {
      printf("here? %d %d %d %d\n",errnum,clonenum,CSD,numitems);
    }  

  for (i = 0; i<numitems; i++) 
    {
      this_errnum  = ((int)items[i].callback_data)/1000;
      this_element = ((int)items[i].callback_data)%1000;

      if(CSD==1)
	{
	  if(i<NUM_C)
	    {
	      if(ErrorLookup[errnum].Config1[i]==2){continue;}
	    }
	  if((int)(strlen(items[i].label))>*max){*max=strlen(items[i].label);}
	  widget = XtVaCreateManagedWidget (items[i].label,
					    *items[i].cclass, menu,
					    NULL);
 	  if(clonenum==0)
	    {
	      XtAddCallback (widget, XmNvalueChangedCallback, toggle_C1_actor,(XtPointer)items[i].callback_data);
	    }
	  else
	    {
	      mydata  = (MyData *) (malloc(sizeof(MyData)));
	      if(mydata==NULL){printf("myb: out of allocation memory!\n"); ExitWrapper(-1);}

	      mydata->check_num = this_errnum;
	      mydata->clonenum  = clonenum;
	      mydata->csdstuff  = CSD;
	      mydata->element   = this_element;

	      XtAddCallback (widget, XmNvalueChangedCallback, (XtCallbackProc)toggle_Clones,mydata);
	    }

	  set = SetButtonProperly(widget, errnum, this_element, clonenum, CSD);
	}

      if(CSD==2)
	{
	  if(i<NUM_S)
	    {
	      if(ErrorLookup[errnum].Stratum1[i]==2){continue;}
	    }
	  if((int)(strlen(items[i].label))>*max){*max=strlen(items[i].label);}
	  widget = XtVaCreateManagedWidget (items[i].label,
					    *items[i].cclass, menu,
					    NULL);
 	  if(
	     (i!=(numitems-1)) &&
	     (i!=(numitems-2)) 
	     )
	    {
	      if(clonenum==0)
		{
		  XtAddCallback (widget, XmNvalueChangedCallback, toggle_S1_actor,(XtPointer)items[i].callback_data);

		  ErrorLookup[errnum].WidStratum1[i] = widget;
		}
	      else
		{
		  mydata  = (MyData *) (malloc(sizeof(MyData)));
		  if(mydata==NULL){printf("myb: out of allocation memory!\n"); ExitWrapper(-1);}
		  
		  mydata->check_num = this_errnum;
		  mydata->clonenum  = clonenum;
		  mydata->csdstuff  = CSD;
		  mydata->element   = this_element;
		  
		  XtAddCallback (widget, XmNvalueChangedCallback, (XtCallbackProc)toggle_Clones,mydata);
		  CloneErrorLookup[GetCloneIndex(clonenum,errnum)].WidStratum1[i] = widget;

		}
	      set = SetButtonProperly(widget, errnum, this_element, clonenum, CSD);
	    }
	  else if (i==(numitems-2))
	    {
	      if(clonenum==0)
		{
		  XtAddCallback (widget, XmNactivateCallback, all_S1_actors,(XtPointer)items[i].callback_data);

		  ErrorLookup[errnum].WidStratum1[i] = widget;
		}
	      else
		{
		  mydata  = (MyData *) (malloc(sizeof(MyData)));
		  if(mydata==NULL){printf("myb: out of allocation memory!\n"); ExitWrapper(-1);}
		  
		  mydata->check_num = errnum;
		  mydata->clonenum  = clonenum;
		  mydata->csdstuff  = CSD;
		  mydata->element   = 1;
		  
		  XtAddCallback (widget, XmNactivateCallback, (XtCallbackProc)all_Clone_actors_onoff,mydata);

		  CloneErrorLookup[GetCloneIndex(clonenum,errnum)].WidStratum1[i] = widget;
		}
	    }
	  else
	    {
	      if(clonenum==0)
		{
		  XtAddCallback (widget, XmNactivateCallback, all_S1_actors_off,(XtPointer)items[i].callback_data);

		  ErrorLookup[errnum].WidStratum1[i] = widget;
		}
	      else
		{
		  mydata  = (MyData *) (malloc(sizeof(MyData)));
		  if(mydata==NULL){printf("myb: out of allocation memory!\n"); ExitWrapper(-1);}
		  
		  mydata->check_num = errnum;
		  mydata->clonenum  = clonenum;
		  mydata->csdstuff  = CSD;
		  mydata->element   = 0;

		  XtAddCallback (widget, XmNactivateCallback, (XtCallbackProc)all_Clone_actors_onoff,mydata);

		  CloneErrorLookup[GetCloneIndex(clonenum,errnum)].WidStratum1[i] = widget;
	        }
	    }
	}


      if(CSD==3)
	{
	  if(i<NUM_D)
	    {
	      if(ErrorLookup[errnum].Domain1[i]==2){continue;}
	    }
	  if((int)(strlen(items[i].label))>*max){*max=strlen(items[i].label);}
	  widget = XtVaCreateManagedWidget (items[i].label,
					*items[i].cclass, menu,
					NULL);

 	  if(
	     (i!=(numitems-1)) &&
	     (i!=(numitems-2)) 
	     )
	    {
	      if(clonenum==0)
		{
		  XtAddCallback (widget, XmNvalueChangedCallback, toggle_D1_actor,(XtPointer)items[i].callback_data);
		  ErrorLookup[errnum].WidDomain1[i] = widget;
		}
	      else
		{
		  mydata  = (MyData *) (malloc(sizeof(MyData)));
		  if(mydata==NULL){printf("myb: out of allocation memory!\n"); ExitWrapper(-1);}
		  
		  mydata->check_num = this_errnum;
		  mydata->clonenum  = clonenum;
		  mydata->csdstuff  = CSD;
		  mydata->element   = this_element;
		  
		  XtAddCallback (widget, XmNvalueChangedCallback, (XtCallbackProc)toggle_Clones,mydata);
		  CloneErrorLookup[GetCloneIndex(clonenum,errnum)].WidDomain1[i] = widget;

		}
	      set = SetButtonProperly(widget, errnum, this_element, clonenum, CSD);
	    }
	  else if(i==(numitems-2)) 
	    {
	      if(clonenum==0)
		{
		  XtAddCallback (widget, XmNactivateCallback, all_D1_actors,(XtPointer)items[i].callback_data);
		  ErrorLookup[errnum].WidDomain1[i] = widget;
		}
	      else
		{
		  mydata  = (MyData *) (malloc(sizeof(MyData)));
		  if(mydata==NULL){printf("myb: out of allocation memory!\n"); ExitWrapper(-1);}
		  
		  mydata->check_num = errnum;
		  mydata->clonenum  = clonenum;
		  mydata->csdstuff  = CSD;
		  mydata->element   = 1;

		  XtAddCallback (widget, XmNactivateCallback, (XtCallbackProc)all_Clone_actors_onoff,mydata);
		  CloneErrorLookup[GetCloneIndex(clonenum,errnum)].WidDomain1[i] = widget;
		}
	    }
	  else
	    {
	      if(clonenum==0)
		{
		  XtAddCallback (widget, XmNactivateCallback, all_D1_actors_off,(XtPointer)items[i].callback_data);
		  ErrorLookup[errnum].WidDomain1[i] = widget;
		}
	      else
		{
		  mydata  = (MyData *) (malloc(sizeof(MyData)));
		  if(mydata==NULL){printf("myb: out of allocation memory!\n"); ExitWrapper(-1);}
		  
		  mydata->check_num = errnum;
		  mydata->clonenum  = clonenum;
		  mydata->csdstuff  = CSD;
		  mydata->element   = 0;
		  
		  XtAddCallback (widget, XmNactivateCallback, (XtCallbackProc)all_Clone_actors_onoff,mydata);
		  CloneErrorLookup[GetCloneIndex(clonenum,errnum)].WidDomain1[i] = widget;
		}
	    }
	}
      

      
      if(CSD==11)
	{
	  if(ErrorLookup[errnum].Config2[i]==2){continue;}
	  if((int)(strlen(items[i].label))>*max){*max=strlen(items[i].label);}
	  widget = XtVaCreateManagedWidget (items[i].label,
					*items[i].cclass, menu,
					NULL);
 	  if(clonenum==0)
	    {
	      XtAddCallback (widget, XmNvalueChangedCallback, toggle_C2_actor,(XtPointer)items[i].callback_data);
	    }
	  else
	    {
	      mydata  = (MyData *) (malloc(sizeof(MyData)));
	      if(mydata==NULL){printf("myb: out of allocation memory!\n"); ExitWrapper(-1);}
	      
	      mydata->check_num = this_errnum;
	      mydata->clonenum  = clonenum;
	      mydata->csdstuff  = CSD;
	      mydata->element   = this_element;
	      
	      XtAddCallback (widget, XmNvalueChangedCallback, (XtCallbackProc)toggle_Clones,mydata);
	    }
	  set = SetButtonProperly(widget, errnum, this_element, clonenum, CSD);
	}
      if(CSD==12)
	{
	  if(i<NUM_S)
	    {
	      if(ErrorLookup[errnum].Stratum2[i]==2){continue;}
	    }
	  if((int)(strlen(items[i].label))>*max){*max=strlen(items[i].label);}
	  widget = XtVaCreateManagedWidget (items[i].label,
					*items[i].cclass, menu,
					NULL);
 	  if(
	     (i!=(numitems-1)) &&
	     (i!=(numitems-2))
	     )
	    {
	      if(clonenum==0)
		{
		  XtAddCallback (widget, XmNvalueChangedCallback, toggle_S2_actor,(XtPointer)items[i].callback_data);
		  ErrorLookup[errnum].WidStratum2[i] = widget;
		}
	      else
		{
		  mydata  = (MyData *) (malloc(sizeof(MyData)));
		  if(mydata==NULL){printf("myb: out of allocation memory!\n"); ExitWrapper(-1);}
		  
		  mydata->check_num = this_errnum;
		  mydata->clonenum  = clonenum;
		  mydata->csdstuff  = CSD;
		  mydata->element   = this_element;
		  
		  XtAddCallback (widget, XmNvalueChangedCallback, (XtCallbackProc)toggle_Clones,mydata);
		  CloneErrorLookup[GetCloneIndex(clonenum,errnum)].WidStratum2[i] = widget;
		}
	      set = SetButtonProperly(widget, errnum, this_element, clonenum, CSD);
	    }
	  else if (i==(numitems-2))
	    {
	      if(clonenum==0)
		{
		  XtAddCallback (widget, XmNactivateCallback, all_S2_actors,(XtPointer)items[i].callback_data);
		  ErrorLookup[errnum].WidStratum2[i] = widget;
		}
	      else
		{
		  mydata  = (MyData *) (malloc(sizeof(MyData)));
		  if(mydata==NULL){printf("myb: out of allocation memory!\n"); ExitWrapper(-1);}
		  
		  mydata->check_num = errnum;
		  mydata->clonenum  = clonenum;
		  mydata->csdstuff  = CSD;
		  mydata->element   = 1;

		  XtAddCallback (widget, XmNactivateCallback, (XtCallbackProc)all_Clone_actors_onoff,mydata);
		  CloneErrorLookup[GetCloneIndex(clonenum,errnum)].WidStratum2[i] = widget;
		}
	    }
	  else
	    {
	      if(clonenum==0)
		{
		  XtAddCallback (widget, XmNactivateCallback, all_S2_actors_off,(XtPointer)items[i].callback_data);
		  ErrorLookup[errnum].WidStratum2[i] = widget;
		}
	      else
		{
		  mydata  = (MyData *) (malloc(sizeof(MyData)));
		  if(mydata==NULL){printf("myb: out of allocation memory!\n"); ExitWrapper(-1);}
		  
		  mydata->check_num = errnum;
		  mydata->clonenum  = clonenum;
		  mydata->csdstuff  = CSD;
		  mydata->element   = 0;

		  XtAddCallback (widget, XmNactivateCallback, (XtCallbackProc)all_Clone_actors_onoff,mydata);
		  CloneErrorLookup[GetCloneIndex(clonenum,errnum)].WidStratum2[i] = widget;
		}
	    }
	}
      if(CSD==13)
	{
	  if(i<NUM_D)
	    {
	      if(ErrorLookup[errnum].Domain2[i]==2){continue;}
	    }
	  if((int)(strlen(items[i].label))>*max){*max=strlen(items[i].label);}
	  widget = XtVaCreateManagedWidget (items[i].label,
					*items[i].cclass, menu,
					NULL);
	  
 	  if(
	     (i!=(numitems-1)) &&
	     (i!=(numitems-2))
	     )
	    {
	      if(clonenum==0)
		{
		  XtAddCallback (widget, XmNvalueChangedCallback, toggle_D2_actor,(XtPointer)items[i].callback_data);
		  ErrorLookup[errnum].WidDomain2[i] = widget;
		}
	      else
		{
		  mydata  = (MyData *) (malloc(sizeof(MyData)));
		  if(mydata==NULL){printf("myb: out of allocation memory!\n"); ExitWrapper(-1);}
		  
		  mydata->check_num = this_errnum;
		  mydata->clonenum  = clonenum;
		  mydata->csdstuff  = CSD;
		  mydata->element   = this_element;
		  
		  XtAddCallback (widget, XmNvalueChangedCallback, (XtCallbackProc)toggle_Clones,mydata);
		  CloneErrorLookup[GetCloneIndex(clonenum,errnum)].WidDomain2[i] = widget;
		}
	      set = SetButtonProperly(widget, errnum, this_element, clonenum, CSD);
	    }
	  else if (i==(numitems-2))
	    {
	      if(clonenum==0)
		{
		  XtAddCallback (widget, XmNactivateCallback, all_D2_actors,(XtPointer)items[i].callback_data);
		  ErrorLookup[errnum].WidDomain2[i] = widget;
		}
	      else
		{
		  mydata  = (MyData *) (malloc(sizeof(MyData)));
		  if(mydata==NULL){printf("myb: out of allocation memory!\n"); ExitWrapper(-1);}
		  
		  mydata->check_num = errnum;
		  mydata->clonenum  = clonenum;
		  mydata->csdstuff  = CSD;
		  mydata->element   = 1;
				  
		  XtAddCallback (widget, XmNactivateCallback, (XtCallbackProc)all_Clone_actors_onoff,mydata);
		  CloneErrorLookup[GetCloneIndex(clonenum,errnum)].WidDomain2[i] = widget;
		}
	    }
	  else
	    {
	      if(clonenum==0)
		{
		  XtAddCallback (widget, XmNactivateCallback, all_D2_actors_off,(XtPointer)items[i].callback_data);
		  ErrorLookup[errnum].WidDomain2[i] = widget;
		}
	      else
		{
		  mydata  = (MyData *) (malloc(sizeof(MyData)));
		  if(mydata==NULL){printf("myb: out of allocation memory!\n"); ExitWrapper(-1);}
		  
		  mydata->check_num = errnum;
		  mydata->clonenum  = clonenum;
		  mydata->csdstuff  = CSD;
		  mydata->element   = 0;

		  XtAddCallback (widget, XmNactivateCallback, (XtCallbackProc)all_Clone_actors_onoff,mydata);
		  CloneErrorLookup[GetCloneIndex(clonenum,errnum)].WidDomain2[i] = widget;
		}
	    }
	}

      
      if(CSD==21)
	{
	  if(ErrorLookup[errnum].Config3[i]==2){continue;}
	  if((int)(strlen(items[i].label))>*max){*max=strlen(items[i].label);}
	  widget = XtVaCreateManagedWidget (items[i].label,
					*items[i].cclass, menu,
					NULL);
 	  if(clonenum==0)
	    {
	      XtAddCallback (widget, XmNvalueChangedCallback, toggle_C3_actor,(XtPointer)items[i].callback_data);
	    }
	  else
	    {
	      mydata  = (MyData *) (malloc(sizeof(MyData)));
	      if(mydata==NULL){printf("myb: out of allocation memory!\n"); ExitWrapper(-1);}
	      
	      mydata->check_num = this_errnum;
	      mydata->clonenum  = clonenum;
	      mydata->csdstuff  = CSD;
	      mydata->element   = this_element;
	      
	      XtAddCallback (widget, XmNvalueChangedCallback, (XtCallbackProc)toggle_Clones,mydata);
	    }
	  set = SetButtonProperly(widget, errnum, this_element, clonenum, CSD);
	}

      if(CSD==22)
	{
	  if(i<NUM_S)
	    {
	      if(ErrorLookup[errnum].Stratum3[i]==2){continue;}
	    }
	  if((int)(strlen(items[i].label))>*max){*max=strlen(items[i].label);}
	  widget = XtVaCreateManagedWidget (items[i].label,
					*items[i].cclass, menu,
					NULL);
 	  if(
	     (i!=(numitems-1)) &&
	     (i!=(numitems-2))
	     )
	    {
	      if(clonenum==0)
		{
		  XtAddCallback (widget, XmNvalueChangedCallback, toggle_S3_actor,(XtPointer)items[i].callback_data);
		  ErrorLookup[errnum].WidStratum3[i] = widget;
		}
	      else
		{
		  mydata  = (MyData *) (malloc(sizeof(MyData)));
		  if(mydata==NULL){printf("myb: out of allocation memory!\n"); ExitWrapper(-1);}
		  
		  mydata->check_num = this_errnum;
		  mydata->clonenum  = clonenum;
		  mydata->csdstuff  = CSD;
		  mydata->element   = this_element;
		  
		  XtAddCallback (widget, XmNvalueChangedCallback, (XtCallbackProc)toggle_Clones,mydata);
		  CloneErrorLookup[GetCloneIndex(clonenum,errnum)].WidStratum3[i] = widget;
		}
	      set = SetButtonProperly(widget, errnum, this_element, clonenum, CSD);
	    }
	  else if (i==(numitems-2))
	    {
	      if(clonenum==0)
		{
		  XtAddCallback (widget, XmNactivateCallback, all_S3_actors,(XtPointer)items[i].callback_data);
		  ErrorLookup[errnum].WidStratum3[i] = widget;
		}
	      else
		{
		  mydata  = (MyData *) (malloc(sizeof(MyData)));
		  if(mydata==NULL){printf("myb: out of allocation memory!\n"); ExitWrapper(-1);}
		  
		  mydata->check_num = errnum;
		  mydata->clonenum  = clonenum;
		  mydata->csdstuff  = CSD;
		  mydata->element   = 1;

		  XtAddCallback (widget, XmNactivateCallback, (XtCallbackProc)all_Clone_actors_onoff,mydata);
		  CloneErrorLookup[GetCloneIndex(clonenum,errnum)].WidStratum3[i] = widget;
		}
	    }
	  else 
	    {
	      if(clonenum==0)
		{
		  XtAddCallback (widget, XmNactivateCallback, all_S3_actors_off,(XtPointer)items[i].callback_data);
		  ErrorLookup[errnum].WidStratum3[i] = widget;
		}
	      else
		{
		  mydata  = (MyData *) (malloc(sizeof(MyData)));
		  if(mydata==NULL){printf("myb: out of allocation memory!\n"); ExitWrapper(-1);}
		  
		  mydata->check_num = errnum;
		  mydata->clonenum  = clonenum;
		  mydata->csdstuff  = CSD;
		  mydata->element   = 0;

		  XtAddCallback (widget, XmNactivateCallback, (XtCallbackProc)all_Clone_actors_onoff,mydata);
		  CloneErrorLookup[GetCloneIndex(clonenum,errnum)].WidStratum3[i] = widget;
		}
	    }
	}


      if(CSD==23)
	{
	  if(i<NUM_D)
	    {
	      if(ErrorLookup[errnum].Domain3[i]==2){continue;}
	    }
	  if((int)(strlen(items[i].label))>*max){*max=strlen(items[i].label);}
	  widget = XtVaCreateManagedWidget (items[i].label,
					    *items[i].cclass, menu,
					    NULL);
 	  if(
	     (i!=(numitems-1)) &&
	     (i!=(numitems-2))
	     )
	    {
	      if(clonenum==0)
		{
		  XtAddCallback (widget, XmNvalueChangedCallback, toggle_D3_actor,(XtPointer)items[i].callback_data);
		  ErrorLookup[errnum].WidDomain3[i] = widget;
		}
	      else
		{
		  mydata  = (MyData *) (malloc(sizeof(MyData)));
		  if(mydata==NULL){printf("myb: out of allocation memory!\n"); ExitWrapper(-1);}
		  
		  mydata->check_num = this_errnum;
		  mydata->clonenum  = clonenum;
		  mydata->csdstuff  = CSD;
		  mydata->element   = this_element;
		  
		  XtAddCallback (widget, XmNvalueChangedCallback, (XtCallbackProc)toggle_Clones,mydata);
		  CloneErrorLookup[GetCloneIndex(clonenum,errnum)].WidDomain3[i] = widget;
		}
	      set = SetButtonProperly(widget, errnum, this_element, clonenum, CSD);
	    }
	  else if (i==(numitems-2))
	    {
	      if(clonenum==0)
		{
		  XtAddCallback (widget, XmNactivateCallback, all_D3_actors,(XtPointer)items[i].callback_data);
		  ErrorLookup[errnum].WidDomain3[i] = widget;
		}
	      else
		{
		  mydata  = (MyData *) (malloc(sizeof(MyData)));
		  if(mydata==NULL){printf("myb: out of allocation memory!\n"); ExitWrapper(-1);}
		  
		  mydata->check_num = errnum;
		  mydata->clonenum  = clonenum;
		  mydata->csdstuff  = CSD;
		  mydata->element   = 1;

		  XtAddCallback (widget, XmNactivateCallback, (XtCallbackProc)all_Clone_actors_onoff,mydata);
		  CloneErrorLookup[GetCloneIndex(clonenum,errnum)].WidDomain3[i] = widget;
		}
	    }
	  else
	    {
	      if(clonenum==0)
		{
		  XtAddCallback (widget, XmNactivateCallback, all_D3_actors_off,(XtPointer)items[i].callback_data);
		  ErrorLookup[errnum].WidDomain3[i] = widget;
		}
	      else
		{
		  mydata  = (MyData *) (malloc(sizeof(MyData)));
		  if(mydata==NULL){printf("myb: out of allocation memory!\n"); ExitWrapper(-1);}
		  
		  mydata->check_num = errnum;
		  mydata->clonenum  = clonenum;
		  mydata->csdstuff  = CSD;
		  mydata->element   = 0;
		  
		  XtAddCallback (widget, XmNactivateCallback, (XtCallbackProc)all_Clone_actors_onoff,mydata);
		  CloneErrorLookup[GetCloneIndex(clonenum,errnum)].WidDomain3[i] = widget;
		}
	    }
	}
      
      if((done==0)&&(set==1))
	{
	  
	  XtVaSetValues(cascade,				
			XmNmenuHistory, widget,
			NULL);
	  done = 1;
	}
      else if((done==0)&&(backup==0))
	{
	  
	  XtVaSetValues(cascade,				
			XmNmenuHistory, widget,
			NULL);
	  backup = 1;
	}
    }
  return cascade;
}











Widget SpecialBuildToggleMenu2(Widget parent,SpecialMenuItem *items,int numitems,int errnum,int axis,int CSD)
{
  Widget menu, cascade, widget;
  int i,n=0;
  Arg args[5];
  
  menu = XmCreatePulldownMenu (parent, "_pulldown", NULL, 0);
  XtVaSetValues (menu, XmNtearOffModel, XmTEAR_OFF_ENABLED, NULL);

  XtSetArg (args[n], XmNsubMenuId, menu); n++;
  XtSetArg (args[n], XmNtranslations, XtParseTranslationTable ( translations_global )); n++;

  cascade = XmCreateOptionMenu (parent, "", args, n);
  
  for (i = 0; i<numitems; i++) 
    {
      if((axis==1)&&(CSD==1))if(ErrorLookup[errnum].Config1[i] ==2){continue;}
      if((axis==1)&&(CSD==2))if(ErrorLookup[errnum].Stratum1[i]==2){continue;}
      if((axis==1)&&(CSD==3))if(ErrorLookup[errnum].Domain1[i] ==2){continue;}

      if((axis==2)&&(CSD==1))if(ErrorLookup[errnum].Config2[i] ==2){continue;}
      if((axis==2)&&(CSD==2))if(ErrorLookup[errnum].Stratum2[i]==2){continue;}
      if((axis==2)&&(CSD==3))if(ErrorLookup[errnum].Domain2[i] ==2){continue;}

      if((axis==3)&&(CSD==1))if(ErrorLookup[errnum].Config3[i] ==2){continue;}
      if((axis==3)&&(CSD==2))if(ErrorLookup[errnum].Stratum3[i]==2){continue;}
      if((axis==3)&&(CSD==3))if(ErrorLookup[errnum].Domain3[i] ==2){continue;}

      widget = XtVaCreateManagedWidget (items[i].label,
					*items[i].cclass, menu,
					NULL);
      XtAddCallback (widget, XmNvalueChangedCallback, (XtCallbackProc)items[i].callback,(XtPointer)items[i].callback_data);
      XmToggleButtonSetState(widget,(Boolean)True,(Boolean)0);
    }
  return cascade;
}







void FACCCallback2(Widget w,XtPointer data,XtPointer callData)
{
  char filename[500],message[50000],thisname[1000];
  FILE *codes;
  int namelen,numsac,i,SCC,type,sac,thislen,leftoff=0,j,maxlen=45;
  char polyflag[500];
  extern char *GetECCLabel(int code);
  extern char *GetEACLabel(int code);
  
  sprintf(filename,"%scodesshort.bin",indirectory);
  
  codes = fopen(filename,"rb");
  if(codes==NULL)
    {
      printf("place 7 couldnt open %s\n",filename);
      ExitWrapper(-1);
    }
  fseek(codes,(long int)data,SEEK_SET);


  

  
  
  SEEIT_fread_int(&SCC,     codes);
  SEEIT_fread_int(&numsac,  codes);
  SEEIT_fread_int(&type,    codes);
  
  sprintf(message,"Assigned attributes for %s are:\n\n",
	  GetECCLabel(SCC));

  
  if(numsac==0)
    {
      strcat(message,"NO EACs assigned.");
    }
  else if(numsac<40)
    {
      

      for(i=0;i<numsac;i++)
	{
	  
	  
	  SEEIT_fread_int(&sac,codes);
	  
	  if(sac==-3)
	    {
	      SEEIT_fread_int(&namelen ,codes);
	      fread(&polyflag,1, namelen,codes);
	      polyflag[namelen]='\0';
	      strcat(message,"polygon flag: ");
	      strcat(message,polyflag);
	      strcat(message,"\n");      
	    }
	  else if(sac==-1)
	    {
	      SEEIT_fread_int(&namelen ,codes);
	      fread(&polyflag,1, namelen,codes);
	      polyflag[namelen]='\0';
	      if(NGA_TYPE==1)
		{
		  strcat(message,"Layer Identifier: ");
		}
	      else
		{
		  strcat(message,"LOD Identifier: ");
		}
	      strcat(message,polyflag);
	      strcat(message,"\n");      
	    }
	  else
	    {				
	      strcat(message,GetEACLabel(sac));
	      strcat(message,"\n");      
	    }      
	}
    }
  else
    {
      for(i=0;i<numsac;i++)
	{
	  

	  SEEIT_fread_int(&sac,codes);
	  
	  sprintf(thisname,"%s",GetEACLabel(sac));



	  if(sac==-3)
	    {
	      
	      SEEIT_fread_int(&namelen ,codes);
	      fread(&polyflag,1, namelen,codes);
	      polyflag[namelen]='\0';
	      continue;
	    }
	  else if(sac==-1)
	    {
	      
	      SEEIT_fread_int(&namelen ,codes);
	      fread(&polyflag,1, namelen,codes);
	      polyflag[namelen]='\0';
	      continue;
	    }



	  if(leftoff==0)
	    {
	      
	      
	      thislen = strlen(thisname);


	      if(thislen<maxlen)
		{
		  strcat(message,thisname);
		  
		  for(j=thislen;j<=maxlen;j++)
		    {
		      strcat(message," ");
		      leftoff = 1;
		    }
		}
	    }
	  else
	    {
	      
	      thislen = strlen(thisname);
	      if(thislen<maxlen)
		{
		  strcat(message,thisname);
		  strcat(message,"\n");      
		  leftoff = 0;
		}
	    }
	}
      
      
            
      fseek(codes,(long int)data,SEEK_SET);
      SEEIT_fread_int(&SCC,     codes);
      SEEIT_fread_int(&numsac,  codes);
      SEEIT_fread_int(&type,    codes);
    
      if(leftoff==1)
	{
	  strcat(message,"\n");      
	}



      for(i=0;i<numsac;i++)
	{
	  

	  SEEIT_fread_int(&sac,codes);
	  
	  if(sac==-3)
	    {
	      SEEIT_fread_int(&namelen ,codes);
	      fread(&polyflag,1, namelen,codes);
	      polyflag[namelen]='\0';
	      strcat(message,"polygon flag: ");
	      strcat(message,polyflag);
	      strcat(message,"\n");      
	    }
	  else if(sac==-1)
	    {
	      SEEIT_fread_int(&namelen ,codes);
	      fread(&polyflag,1, namelen,codes);
	      polyflag[namelen]='\0';
	      if(NGA_TYPE==1)
		{
		  strcat(message,"Layer Identifier: ");
		}
	      else
		{
		  strcat(message,"LOD Identifier: ");
		}
	      strcat(message,polyflag);
	      strcat(message,"\n");      
	    }
	  else
	    {
	      sprintf(thisname,"%s",GetEACLabel(sac));
	      
	      thislen = strlen(thisname);

	      if(thislen>=maxlen)
		{
		  strcat(message,thisname);
		  strcat(message,"\n");      
		}
	    }
	}

      
    }
  fclose(codes);
    
  not_while_running(w,message,1072,"EACs assigned",5); 
}




int MY_SENS_UP(MyData *userData, int set)
{
  static int errnum [100];
  static int clonenum[100];
  static int index=0;
  int i,j;
  
  if(set==1)
    {
      if(CLONEDEBUG==1)
	{
	  printf("ADDING %d %d\n",userData->clonenum,userData->check_num);
	}
      
      clonenum[index] = userData->clonenum;
      errnum  [index] = userData->check_num;
      index++;
    }
  else if(set==0)
    {
      if(CLONEDEBUG==1)
	{
	  printf("checking for %d %d\n",userData->clonenum,userData->check_num);
	}
      
      for(i=0;i<index;i++)
	{
	  if(
	     (clonenum[i]==userData->clonenum) &&
	     (errnum  [i]==userData->check_num)
	     )
	    {
	      if(CLONEDEBUG==1)
		{
		  printf("FOUND\n");
		}
	      return 1;
	    }
	}
      if(CLONEDEBUG==1)
	{
	  printf("NOT FOUND\n");
	}
      return 0;
    }
  else if(set==-1)
    {
      if(CLONEDEBUG==1)
	{
	  printf("KILLING %d %d\n",userData->clonenum,userData->check_num);
	}

      
      for(i=0;i<index;i++)
	{
	  if(
	     (clonenum[i]==userData->clonenum) &&
	     (errnum  [i]==userData->check_num)
	     )
	    {
	      for(j=i;j<index-1;j++)
		{
		  clonenum[j] = clonenum[j+1];
		  errnum  [j] = errnum  [j+1];
		}
	      index--;
	      if(CLONEDEBUG==1)
		{
		  printf("KILLED\n");
		}
	      return 1;
	    }
	}
      return 0;
    }
  return 1;
}






int MY_ACTOR_UP(MyData *userData, int set)
{
  static int errnum [100];
  static int clonenum[100];
  static int index=0;
  int i,j;

  if(set==1)
    {
      if(CLONEDEBUG==1)
	{
	  printf("ADDING %d %d\n",userData->clonenum,userData->check_num);
	}
      
      clonenum[index] = userData->clonenum;
      errnum  [index] = userData->check_num;
      index++;
    }
  else if(set==0)
    {
      if(CLONEDEBUG==1)
	{
	  printf("checking for %d %d\n",userData->clonenum,userData->check_num);
	}
      
      for(i=0;i<index;i++)
	{
	  if(
	     (clonenum[i]==userData->clonenum) &&
	     (errnum  [i]==userData->check_num)
	     )
	    {
	      if(CLONEDEBUG==1)
		{
		  printf("FOUND\n");
		}
	      return 1;
	    }
	}
      if(CLONEDEBUG==1)
	{
	  printf("NOT FOUND\n");
	}
      return 0;
    }
  else if(set==-1)
    {
      if(CLONEDEBUG==1)
	{
	  printf("KILLING %d %d\n",userData->clonenum,userData->check_num);
	}

      
      for(i=0;i<index;i++)
	{
	  if(
	     (clonenum[i]==userData->clonenum) &&
	     (errnum  [i]==userData->check_num)
	     )
	    {
	      for(j=i;j<index-1;j++)
		{
		  clonenum[j] = clonenum[j+1];
		  errnum[j]   = errnum[j+1];
		}
	      index--;
	      if(CLONEDEBUG==1)
		{
		  printf("KILLED\n");
		}
	      return 1;
	    }
	}
      return 0;
    }
  return 1;
}




int MY_ANN_UP(MyData *userData, int set)
{
  static int errnum [100];
  static int clonenum[100];
  static int index=0;
  int i,j;

  if(set==1)
    {
      
      clonenum[index] = userData->clonenum;
      errnum  [index] = userData->check_num;
      index++;
    }
  else if(set==0)
    {
      
      for(i=0;i<index;i++)
	{
	  if(
	     (clonenum[i]==userData->clonenum) &&
	     (errnum  [i]==userData->check_num)
	     )
	    {
	      if(CLONEDEBUG==1)
		{
		  printf("FOUND\n");
		}
	      return 1;
	    }
	}
      if(CLONEDEBUG==1)
	{
	  printf("NOT FOUND\n");
	}
      return 0;
    }
  else if(set==-1)
    {
      if(CLONEDEBUG==1)
	{
	  printf("KILLING %d %d\n",userData->clonenum,userData->check_num);
	}

      
      for(i=0;i<index;i++)
	{
	  if(
	     (clonenum[i]==userData->clonenum) &&
	     (errnum  [i]==userData->check_num)
	     )
	    {
	      for(j=i;j<index-1;j++)
		{
		  clonenum[j] = clonenum[j+1];
		  errnum[j]   = errnum[j+1];
		}
	      index--;
	      if(CLONEDEBUG==1)
		{
		  printf("KILLED\n");
		}
	      return 1;
	    }
	}
      return 0;
    }
  return 1;
}






void ModelDeath(Widget widget, MyData * userData, XtPointer callData)
{
  if(CLONEDEBUG==1)
    {
      printf("KILL %d %d %d %d %d\n",
	     userData->clonenum,userData->check_num,userData->axis,userData->ADDER,userData->type);
    }
  MY_MODEL_UP(userData,-1);
}


void ActorDeath(Widget widget, MyData * userData, XtPointer callData)
{
  if(CLONEDEBUG==1)
    {
      printf("KILL %d %d\n",userData->clonenum,userData->check_num);
    }
  MY_ACTOR_UP(userData,-1);
}


void SensDeath(Widget widget, MyData * userData, XtPointer callData)
{
  if(CLONEDEBUG==1)
    {
      printf("KILL %d %d\n",userData->clonenum,userData->check_num);
    }
  MY_SENS_UP(userData,-1);
}


void AnnDeath(Widget widget, MyData * userData, XtPointer callData)
{
  if(CLONEDEBUG==1)
    {
      printf("KILL %d %d\n",userData->clonenum,userData->check_num);
    }
  MY_ANN_UP(userData,-1);
}




void AnnotateCallback(Widget w, MyData *userData, XtPointer callData)
{
  int errnum   = userData->check_num;
  int clonenum = userData->clonenum;
  int cloneindex = -1;
  int i,n=0;
  char save_annot[510],temp[500];
  Widget annot_head,form,button,rowcol,sep,text_w;
  Arg resources[20];
  

 if(clonenum>0)
    {
      cloneindex = GetCloneIndex(clonenum,errnum);
    }
  else
    {
      cloneindex = -1;
    }




  if(MY_ANN_UP(userData,0)==1)
    {
      if(clonenum>0)
	{
          ResetWidget(CloneErrorLookup[cloneindex].annot_head);
        }
      else
        {
          ResetWidget(ErrorLookup[errnum].annot_head);
        } 
    }
  else
    {
      if(clonenum>0)
	{
	  cloneindex = GetCloneIndex(clonenum,errnum);
	  
	  
	  
	  if(CloneErrorLookup[cloneindex].Annotation==NULL)
	    {
	      sprintf(save_annot,"<none>");
	    }
	  else
	    {
	      sprintf(save_annot,"%s",CloneErrorLookup[cloneindex].Annotation);
	    }
	}
      else
	{
	  
	  
	  if(ErrorLookup[errnum].Annotation==NULL)
	    {
	      sprintf(save_annot,"<none>");
	    }
	  else
	    {
	      sprintf(save_annot,"%s",ErrorLookup[errnum].Annotation);
	    }
	}
      
      
      
      
      XtSetArg(resources[n],  XmNdeleteResponse, XmDESTROY); n++; 

      if(clonenum>0)
	{
	  sprintf(temp,"User annotation for condition: %s (additional #%d)",
		  ErrorLookup[errnum].name,clonenum);
	}
      else
	{
	  sprintf(temp,"User annotation for condition: %s",ErrorLookup[errnum].name);	
	}

      i=0;
      while(temp[i]!='\0')
	{
	  if(temp[i]=='\n')
	    {temp[i]=' ';}
	  i++;
	}
      
      
      annot_head = XtCreatePopupShell
	(temp,topLevelShellWidgetClass,XtParent(XtParent(XtParent(w))),resources,n);
      
      rowcol = XtVaCreateWidget ("rowcol",
				 xmRowColumnWidgetClass, annot_head, NULL);
      
      
      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,  
			       NULL);
      
      XtVaCreateManagedWidget ("",
			       xmLabelWidgetClass, form,
			       XmNtopAttachment,    XmATTACH_FORM,
			       XmNbottomAttachment, XmATTACH_FORM,
			       XmNrightAttachment,  XmATTACH_POSITION,
			       XmNrightPosition,    100,
			       XmNleftAttachment,   XmATTACH_POSITION,
			       XmNleftPosition,     0,
			       XmNalignment,        XmALIGNMENT_CENTER,
			       XmNlabelString,      STRING("Annotation:"),
			       LABELWTRANSLATE,
			       NULL);
      XtManageChild(form);
      
      
      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,  
			       NULL);
      
      
      sprintf(temp,"%s",save_annot);

      text_w = XtVaCreateManagedWidget ("text_w",
					    xmTextFieldWidgetClass, form,	  
					    XmNvalue, temp,
					    XmNtraversalOn,      True,
					    XmNrightAttachment,  XmATTACH_POSITION,
					    XmNrightPosition,    100,
					    XmNleftAttachment,   XmATTACH_POSITION,
					    XmNleftPosition,     0,
					    XmNmaxLength,        500,
                        XmNtranslations,     XtParseTranslationTable ( translations_paste ) ,
					    NULL);
      
      XtAddCallback (text_w, XmNactivateCallback,
		     (XtCallbackProc)print_annot_result, userData);

      XtManageChild(form);
      

      sep = XtVaCreateManagedWidget ("sep1",
				     xmSeparatorWidgetClass, rowcol,
				     NULL);
      
      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  10,
			       NULL);
      XtVaCreateManagedWidget ("Hit return",
			       xmLabelWidgetClass, form,
			       XmNtopAttachment,    XmATTACH_FORM,
			       XmNbottomAttachment, XmATTACH_FORM,
			       XmNrightAttachment,  XmATTACH_FORM,
			       XmNleftAttachment,   XmATTACH_FORM,
			       XmNalignment,        XmALIGNMENT_CENTER,
			       XmNlabelString, STRING("Hit return or \"done\" to make changes take effect."),
			       LABELWTRANSLATE,
			       NULL);
      XtManageChild( form);
      


      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,
			       NULL);
      button = XtVaCreateManagedWidget("Help", xmPushButtonWidgetClass, form,
					   XmNlabelString, STRING("Help"),
					   XmNleftAttachment,   XmATTACH_POSITION,
					   XmNleftPosition,     30,
					   XmNrightAttachment,   XmATTACH_POSITION,
					   XmNrightPosition,     50,
					   XmNtraversalOn,  False,
				           XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					   NULL);
      XtAddCallback(button, XmNactivateCallback, help_ann_callback, (XtPointer)(errnum+1000));
      XtManageChild(button);

      
      n = 0;  
      userData->wid_to_pass = text_w;

      button = XtVaCreateManagedWidget("Done",xmPushButtonWidgetClass, form,
				       XmNlabelString,      STRING("Done"),
				       XmNleftAttachment,   XmATTACH_POSITION,
				       XmNleftPosition,     50,
				       XmNrightAttachment,  XmATTACH_POSITION,
				       XmNrightPosition,    70,
				       XmNtraversalOn,      False,
				       XmNtranslations, XtParseTranslationTable ( translations_global ) ,
				       NULL);
      
      XtAddCallback(button, XmNactivateCallback, (XtCallbackProc)kill_annot_callback, userData);      
      XtManageChild(button);
      
      XtManageChild(form);
      XtManageChild (rowcol);
      
      XtAddCallback(annot_head,XmNdestroyCallback,(XtCallbackProc)AnnDeath,userData);       
      
      MY_ANN_UP(userData,1);
      MyPopup(annot_head); 

      if(clonenum>0)
	{
          CloneErrorLookup[cloneindex].annot_head = annot_head;
        }
      else
        {
          ErrorLookup[errnum].annot_head = annot_head;
        }
    }  
}







void toggle_all_point_nonclone(Widget widget,XtPointer client_data,XtPointer call_data)
{  
  int errnum = (int)client_data;
  int axis;

  axis = errnum/1000;
  errnum = errnum%1000;


  
  if(ErrorLookup[errnum].AllConfigOn[axis][C_POFE]==1)
    {
      XmToggleButtonSetState(ErrorLookup[errnum].allconfig[axis][C_POFE],1,(Boolean)0);

      
    }
  else
    {
      ErrorLookup[errnum].AllConfigOn[axis][C_POFE] = 1;

      

      if(ErrorLookup[errnum].SpecifiedConfigOn[axis][C_POFE]==1)
	{
	  ErrorLookup[errnum].SpecifiedConfigOn[axis][C_POFE] = 0;
	  
	  XmToggleButtonSetState(ErrorLookup[errnum].specifiedconfig[axis][C_POFE],
				 (Boolean)ErrorLookup[errnum].SpecifiedConfigOn[axis][C_POFE],(Boolean)0);	  
	}
    }


  if((Total2DPoint+Total3DPoint)<=0)
  {
    XtSetSensitive(ErrorLookup[errnum].allconfiginclude[axis][C_POFE],False);
  }
  else
  {
    XtSetSensitive(ErrorLookup[errnum].allconfiginclude[axis][C_POFE],
		 !ErrorLookup[errnum].AllConfigOn[axis][C_POFE]);
  }
}



void toggle_some_point_nonclone(Widget widget,XtPointer client_data,XtPointer call_data)
{  
  int errnum = (int)client_data;
  int axis;

  axis = errnum/1000;
  errnum = errnum%1000;

  
  if(ErrorLookup[errnum].SpecifiedConfigOn[axis][C_POFE]==1)
    {

      XmToggleButtonSetState(ErrorLookup[errnum].specifiedconfig[axis][C_POFE],1,(Boolean)0);
      
      
    }
  else
    {
      ErrorLookup[errnum].SpecifiedConfigOn[axis][C_POFE] = 1;

      

      if(ErrorLookup[errnum].AllConfigOn[axis][C_POFE]==1)
	{
	  ErrorLookup[errnum].AllConfigOn[axis][C_POFE] = 0;
	  
	  XmToggleButtonSetState(ErrorLookup[errnum].allconfig[axis][C_POFE],
				 (Boolean)ErrorLookup[errnum].AllConfigOn[axis][C_POFE],(Boolean)0);	  
	}
    }


  if((Total2DPoint+Total3DPoint)<=0)
  {
    XtSetSensitive(ErrorLookup[errnum].allconfiginclude[axis][C_POFE],False);
  }
  else
  {
    XtSetSensitive(ErrorLookup[errnum].allconfiginclude[axis][C_POFE],
		 !ErrorLookup[errnum].AllConfigOn[axis][C_POFE]);
  }
}




void toggle_all_linear_nonclone(Widget widget,XtPointer client_data,XtPointer call_data)
{  
  int errnum = (int)client_data;
  int axis;

  axis = errnum/1000;
  errnum = errnum%1000;

  
  if(ErrorLookup[errnum].AllConfigOn[axis][C_LINE]==1)
    {
     XmToggleButtonSetState(ErrorLookup[errnum].allconfig[axis][C_LINE],1,(Boolean)0);

     
    }
  else
    {
      ErrorLookup[errnum].AllConfigOn[axis][C_LINE] = 1;

      

      if(ErrorLookup[errnum].SpecifiedConfigOn[axis][C_LINE]==1)
	{
	  ErrorLookup[errnum].SpecifiedConfigOn[axis][C_LINE] = 0;
	  
	  XmToggleButtonSetState(ErrorLookup[errnum].specifiedconfig[axis][C_LINE],
				 (Boolean)ErrorLookup[errnum].SpecifiedConfigOn[axis][C_LINE],(Boolean)0);	  
	}
    }


  if((Total2DLine+Total3DLine)<=0)
  {
    XtSetSensitive(ErrorLookup[errnum].allconfiginclude[axis][C_LINE],False);
  }
  else
  {
    XtSetSensitive(ErrorLookup[errnum].allconfiginclude[axis][C_LINE],
		 !ErrorLookup[errnum].AllConfigOn[axis][C_LINE]);
  }

}



void toggle_some_linear_nonclone(Widget widget,XtPointer client_data,XtPointer call_data)
{  
  int errnum = (int)client_data;
  int axis;

  axis = errnum/1000;
  errnum = errnum%1000;

  
  if(ErrorLookup[errnum].SpecifiedConfigOn[axis][C_LINE]==1)
    {
      XmToggleButtonSetState(ErrorLookup[errnum].specifiedconfig[axis][C_LINE],1,(Boolean)0);

      
    }
  else
    {
      ErrorLookup[errnum].SpecifiedConfigOn[axis][C_LINE] = 1;

      

      if(ErrorLookup[errnum].AllConfigOn[axis][C_LINE]==1)
	{
	  ErrorLookup[errnum].AllConfigOn[axis][C_LINE] = 0;
	  
	  XmToggleButtonSetState(ErrorLookup[errnum].allconfig[axis][C_LINE],
				 (Boolean)ErrorLookup[errnum].AllConfigOn[axis][C_LINE],(Boolean)0);	  
	}
    }

  if((Total2DLine+Total3DLine)<=0)
  {
    XtSetSensitive(ErrorLookup[errnum].allconfiginclude[axis][C_LINE],False);
  }
  else
  {
    XtSetSensitive(ErrorLookup[errnum].allconfiginclude[axis][C_LINE],
		 !ErrorLookup[errnum].AllConfigOn[axis][C_LINE]);
  }
}





void toggle_all_areal_nonclone(Widget widget,XtPointer client_data,XtPointer call_data)
{  
  int errnum = (int)client_data;
  int axis;

  axis = errnum/1000;
  errnum = errnum%1000;

  
  if(ErrorLookup[errnum].AllConfigOn[axis][C_AREA]==1)
    {
      XmToggleButtonSetState(ErrorLookup[errnum].allconfig[axis][C_AREA],1,(Boolean)0);

      
    }
  else
    {
      ErrorLookup[errnum].AllConfigOn[axis][C_AREA] = 1;

      

      if(ErrorLookup[errnum].SpecifiedConfigOn[axis][C_AREA]==1)
	{
	  ErrorLookup[errnum].SpecifiedConfigOn[axis][C_AREA] = 0;
	  
	  XmToggleButtonSetState(ErrorLookup[errnum].specifiedconfig[axis][C_AREA],
				 (Boolean)ErrorLookup[errnum].SpecifiedConfigOn[axis][C_AREA],(Boolean)0);	  
	}
    }

  if((Total2DArea+Total3DArea)<=0)
  {
    XtSetSensitive(ErrorLookup[errnum].allconfiginclude[axis][C_AREA],False);
  }
  else
  {
    XtSetSensitive(ErrorLookup[errnum].allconfiginclude[axis][C_AREA],
		 !ErrorLookup[errnum].AllConfigOn[axis][C_AREA]);
  }
}



void toggle_some_areal_nonclone(Widget widget,XtPointer client_data,XtPointer call_data)
{  
  int errnum = (int)client_data;
  int axis;

  axis = errnum/1000;
  errnum = errnum%1000;

  
  if(ErrorLookup[errnum].SpecifiedConfigOn[axis][C_AREA]==1)
    {
      XmToggleButtonSetState(ErrorLookup[errnum].specifiedconfig[axis][C_AREA],1,(Boolean)0);

      
    }
  else
    {
      ErrorLookup[errnum].SpecifiedConfigOn[axis][C_AREA] = 1;

      

      if(ErrorLookup[errnum].AllConfigOn[axis][C_AREA]==1)
	{
	  ErrorLookup[errnum].AllConfigOn[axis][C_AREA] = 0;
	  
	  XmToggleButtonSetState(ErrorLookup[errnum].allconfig[axis][C_AREA],
				 (Boolean)ErrorLookup[errnum].AllConfigOn[axis][C_AREA],(Boolean)0);	  
	}
    }

  if((Total2DArea+Total3DArea)<=0)
  {
    XtSetSensitive(ErrorLookup[errnum].allconfiginclude[axis][C_AREA],False);
  }
  else
  {
    XtSetSensitive(ErrorLookup[errnum].allconfiginclude[axis][C_AREA],
		 !ErrorLookup[errnum].AllConfigOn[axis][C_AREA]);
  }
}





void toggle_all_grid_nonclone(Widget widget,XtPointer client_data,XtPointer call_data)
{  
  int errnum = (int)client_data;
  int axis;

  axis = errnum/1000;
  errnum = errnum%1000;

  
  if(ErrorLookup[errnum].AllConfigOn[axis][C_GRID]==1)
    {
      XmToggleButtonSetState(ErrorLookup[errnum].allconfig[axis][C_GRID],1,(Boolean)0);

      
    }
  else
    {
      ErrorLookup[errnum].AllConfigOn[axis][C_GRID] = 1;

      

      if(ErrorLookup[errnum].SpecifiedConfigOn[axis][C_GRID]==1)
	{
	  ErrorLookup[errnum].SpecifiedConfigOn[axis][C_GRID] = 0;
	  
	  XmToggleButtonSetState(ErrorLookup[errnum].specifiedconfig[axis][C_GRID],
				 (Boolean)ErrorLookup[errnum].SpecifiedConfigOn[axis][C_GRID],(Boolean)0);	  
	}
    }
  
  if(!strcmp(GetVariousPeices(4),"0"))
  {
    XtSetSensitive(ErrorLookup[errnum].allconfiginclude[axis][C_GRID],False);
  }
  else
  {
    XtSetSensitive(ErrorLookup[errnum].allconfiginclude[axis][C_GRID],
		 !ErrorLookup[errnum].AllConfigOn[axis][C_GRID]);
  }
}



void toggle_some_grid_nonclone(Widget widget,XtPointer client_data,XtPointer call_data)
{  
  int errnum = (int)client_data;
  int axis;

  axis = errnum/1000;
  errnum = errnum%1000;

  
  if(ErrorLookup[errnum].SpecifiedConfigOn[axis][C_GRID]==1)
    {
      XmToggleButtonSetState(ErrorLookup[errnum].specifiedconfig[axis][C_GRID],1,(Boolean)0);
      
    }
  else
    {
      ErrorLookup[errnum].SpecifiedConfigOn[axis][C_GRID] = 1;

      

      if(ErrorLookup[errnum].AllConfigOn[axis][C_GRID]==1)
	{
	  ErrorLookup[errnum].AllConfigOn[axis][C_GRID] = 0;
	  
	  XmToggleButtonSetState(ErrorLookup[errnum].allconfig[axis][C_GRID],
				 (Boolean)ErrorLookup[errnum].AllConfigOn[axis][C_GRID],(Boolean)0);	  
	}
    }

  if(!strcmp(GetVariousPeices(4),"0"))
  {
    XtSetSensitive(ErrorLookup[errnum].allconfiginclude[axis][C_GRID],False);
  }
  else
  {
    XtSetSensitive(ErrorLookup[errnum].allconfiginclude[axis][C_GRID],
		 !ErrorLookup[errnum].AllConfigOn[axis][C_GRID]);
  }
}





void toggle_all_point_clone(Widget widget,XtPointer client_data,XtPointer call_data)
{  
  int cloneindex = (int)client_data;
  int axis;

  axis = cloneindex/1000;
  cloneindex = cloneindex%1000;

  ResetMasterRun();


  if(CloneErrorLookup[cloneindex].AllConfigOn[axis][C_POFE]==1)
    {
      XmToggleButtonSetState(CloneErrorLookup[cloneindex].allconfig[axis][C_POFE],1,(Boolean)0);
      
      
    }
  else
    {
      CloneErrorLookup[cloneindex].AllConfigOn[axis][C_POFE] = 1;

      

      if(CloneErrorLookup[cloneindex].SpecifiedConfigOn[axis][C_POFE]==1)
	{
	  CloneErrorLookup[cloneindex].SpecifiedConfigOn[axis][C_POFE] = 0;
	  
	  XmToggleButtonSetState(CloneErrorLookup[cloneindex].specifiedconfig[axis][C_POFE],
				 (Boolean)CloneErrorLookup[cloneindex].SpecifiedConfigOn[axis][C_POFE],(Boolean)0);	  
	}
    }

  if((Total2DPoint+Total3DPoint)<=0)
  {
    XtSetSensitive(CloneErrorLookup[cloneindex].allconfiginclude[axis][C_POFE],False);
  }
  else
  {
    XtSetSensitive(CloneErrorLookup[cloneindex].allconfiginclude[axis][C_POFE],
		 !CloneErrorLookup[cloneindex].AllConfigOn[axis][C_POFE]);
  }
}



void toggle_some_point_clone(Widget widget,XtPointer client_data,XtPointer call_data)
{  
  int cloneindex = (int)client_data;
  int axis;

  axis = cloneindex/1000;
  cloneindex = cloneindex%1000;

  ResetMasterRun();
  
  if(CloneErrorLookup[cloneindex].SpecifiedConfigOn[axis][C_POFE]==1)
    {
      XmToggleButtonSetState(CloneErrorLookup[cloneindex].specifiedconfig[axis][C_POFE],1,(Boolean)0);

      
    }
  else
    {
      CloneErrorLookup[cloneindex].SpecifiedConfigOn[axis][C_POFE] = 1;

      

      if(CloneErrorLookup[cloneindex].AllConfigOn[axis][C_POFE]==1)
	{
	  CloneErrorLookup[cloneindex].AllConfigOn[axis][C_POFE] = 0;
	  
	  XmToggleButtonSetState(CloneErrorLookup[cloneindex].allconfig[axis][C_POFE],
				 (Boolean)CloneErrorLookup[cloneindex].AllConfigOn[axis][C_POFE],(Boolean)0);	  
	}
    }

  if((Total2DPoint+Total3DPoint)<=0)
  {
    XtSetSensitive(CloneErrorLookup[cloneindex].allconfiginclude[axis][C_POFE],False);
  }
  else
  {
    XtSetSensitive(CloneErrorLookup[cloneindex].allconfiginclude[axis][C_POFE],
		 !CloneErrorLookup[cloneindex].AllConfigOn[axis][C_POFE]);
  }
}




void toggle_all_linear_clone(Widget widget,XtPointer client_data,XtPointer call_data)
{  
  int cloneindex = (int)client_data;
  int axis;

  axis = cloneindex/1000;
  cloneindex = cloneindex%1000;


  ResetMasterRun();

  
  if(CloneErrorLookup[cloneindex].AllConfigOn[axis][C_LINE]==1)
    {
      XmToggleButtonSetState(CloneErrorLookup[cloneindex].allconfig[axis][C_LINE],1,(Boolean)0);
      
      
    }
  else
    {
      CloneErrorLookup[cloneindex].AllConfigOn[axis][C_LINE] = 1;

      

      if(CloneErrorLookup[cloneindex].SpecifiedConfigOn[axis][C_LINE]==1)
	{
	  CloneErrorLookup[cloneindex].SpecifiedConfigOn[axis][C_LINE] = 0;
	  
	  XmToggleButtonSetState(CloneErrorLookup[cloneindex].specifiedconfig[axis][C_LINE],
				 (Boolean)CloneErrorLookup[cloneindex].SpecifiedConfigOn[axis][C_LINE],(Boolean)0);	  
	}
    }

  if((Total2DLine+Total3DLine)<=0)
  {
    XtSetSensitive(CloneErrorLookup[cloneindex].allconfiginclude[axis][C_LINE],False);
  }
  else
  {
    XtSetSensitive(CloneErrorLookup[cloneindex].allconfiginclude[axis][C_LINE],
		 !CloneErrorLookup[cloneindex].AllConfigOn[axis][C_LINE]);
  }
}



void toggle_some_linear_clone(Widget widget,XtPointer client_data,XtPointer call_data)
{  
  int cloneindex = (int)client_data;
  int axis;

  axis = cloneindex/1000;
  cloneindex = cloneindex%1000;

  ResetMasterRun();
  
  if(CloneErrorLookup[cloneindex].SpecifiedConfigOn[axis][C_LINE]==1)
    {
      XmToggleButtonSetState(CloneErrorLookup[cloneindex].specifiedconfig[axis][C_LINE],1,(Boolean)0);

      
    }
  else
    {
      CloneErrorLookup[cloneindex].SpecifiedConfigOn[axis][C_LINE] = 1;

      

      if(CloneErrorLookup[cloneindex].AllConfigOn[axis][C_LINE]==1)
	{
	  CloneErrorLookup[cloneindex].AllConfigOn[axis][C_LINE] = 0;
	  
	  XmToggleButtonSetState(CloneErrorLookup[cloneindex].allconfig[axis][C_LINE],
				 (Boolean)CloneErrorLookup[cloneindex].AllConfigOn[axis][C_LINE],(Boolean)0);	  
	}
    }

  if((Total2DLine+Total3DLine)<=0)
  {
    XtSetSensitive(CloneErrorLookup[cloneindex].allconfiginclude[axis][C_LINE],False);
  }
  else
  {
    XtSetSensitive(CloneErrorLookup[cloneindex].allconfiginclude[axis][C_LINE],
		 !CloneErrorLookup[cloneindex].AllConfigOn[axis][C_LINE]);
  }
}





void toggle_all_areal_clone(Widget widget,XtPointer client_data,XtPointer call_data)
{  
  int cloneindex = (int)client_data;
  int axis;

  axis = cloneindex/1000;
  cloneindex = cloneindex%1000;

  ResetMasterRun();
  
  if(CloneErrorLookup[cloneindex].AllConfigOn[axis][C_AREA]==1)
    {
      XmToggleButtonSetState(CloneErrorLookup[cloneindex].allconfig[axis][C_AREA],1,(Boolean)0);

      
    }
  else
    {
      CloneErrorLookup[cloneindex].AllConfigOn[axis][C_AREA] = 1;

      

      if(CloneErrorLookup[cloneindex].SpecifiedConfigOn[axis][C_AREA]==1)
	{
	  CloneErrorLookup[cloneindex].SpecifiedConfigOn[axis][C_AREA] = 0;
	  
	  XmToggleButtonSetState(CloneErrorLookup[cloneindex].specifiedconfig[axis][C_AREA],
				 (Boolean)CloneErrorLookup[cloneindex].SpecifiedConfigOn[axis][C_AREA],(Boolean)0);	  
	}
    }


  if((Total2DArea+Total3DArea)<=0)
  {
    XtSetSensitive(CloneErrorLookup[cloneindex].allconfiginclude[axis][C_AREA],False);
  }
  else
  {
    XtSetSensitive(CloneErrorLookup[cloneindex].allconfiginclude[axis][C_AREA],
		 !CloneErrorLookup[cloneindex].AllConfigOn[axis][C_AREA]);
  }
}



void toggle_some_areal_clone(Widget widget,XtPointer client_data,XtPointer call_data)
{  
  int cloneindex = (int)client_data;
  int axis;

  axis = cloneindex/1000;
  cloneindex = cloneindex%1000;

  ResetMasterRun();
  
  if(CloneErrorLookup[cloneindex].SpecifiedConfigOn[axis][C_AREA]==1)
    {
      XmToggleButtonSetState(CloneErrorLookup[cloneindex].specifiedconfig[axis][C_AREA],1,(Boolean)0);
      
    }
  else
    {
      CloneErrorLookup[cloneindex].SpecifiedConfigOn[axis][C_AREA] = 1;

      

      if(CloneErrorLookup[cloneindex].AllConfigOn[axis][C_AREA]==1)
	{
	  CloneErrorLookup[cloneindex].AllConfigOn[axis][C_AREA] = 0;
	  
	  XmToggleButtonSetState(CloneErrorLookup[cloneindex].allconfig[axis][C_AREA],
				 (Boolean)CloneErrorLookup[cloneindex].AllConfigOn[axis][C_AREA],(Boolean)0);	  
	}
    }


  if((Total2DArea+Total3DArea)<=0)
  {
    XtSetSensitive(CloneErrorLookup[cloneindex].allconfiginclude[axis][C_AREA],False);
  }
  else
  {
    XtSetSensitive(CloneErrorLookup[cloneindex].allconfiginclude[axis][C_AREA],
		 !CloneErrorLookup[cloneindex].AllConfigOn[axis][C_AREA]);
  }
}




void reset_layer_color(Widget pb, XtPointer client_data, XtPointer call_data)
{ 
  int layer_num = (int)client_data;
  int domain,thiscolor=-1;
  extern int NewTrexColor;

  if(LODindex_DYN[layer_num].geom==C_GRID)
  {
	if(ATTRTYPE_TREX())
	{
      thiscolor = AssignTREXColor(LODindex_DYN[layer_num].other_index);
	}
	else
	{
	  
	  LODindex[layer_num].rcolor = 0;
	  LODindex[layer_num].gcolor = 0;
	  LODindex[layer_num].bcolor = 0;
	  LODindex[layer_num].color  = mycolors[DRAW_COLOR_BLACK];
	}
  }
  else
  {

	if((NewTrexColor==1)&&(ATTRTYPE_TREX())&&(!strcmp(GetECCCode(LODindex_DYN[layer_num].ECC),"GB005")))
	{
		

		thiscolor = DRAW_COLOR_ORANGE;

        LODindex[LODindex_DYN[layer_num].other_index].rcolor = ORANGE_R;
        LODindex[LODindex_DYN[layer_num].other_index].gcolor = ORANGE_G;
        LODindex[LODindex_DYN[layer_num].other_index].bcolor = ORANGE_B;
        LODindex[LODindex_DYN[layer_num].other_index].color  = mycolors[DRAW_COLOR_ORANGE];
	}
	else
	{
      domain = DOMAINS[LODindex_DYN[layer_num].ECC];

      LODindex[LODindex_DYN[layer_num].other_index].rcolor = DOMAIN_R[domain];
      LODindex[LODindex_DYN[layer_num].other_index].gcolor = DOMAIN_G[domain];
      LODindex[LODindex_DYN[layer_num].other_index].bcolor = DOMAIN_B[domain];
      LODindex[LODindex_DYN[layer_num].other_index].color  = mycolors[DOMAIN_DEFAULT_COLOR[domain]];
	}
  }



  

  if(thiscolor==-1)
  {
    new_value2(pb,  
	     (XtPointer) (layer_num*1000 + DOMAIN_DEFAULT_COLOR[domain]),
	     (XtPointer) (layer_num*1000 + DOMAIN_DEFAULT_COLOR[domain])
	     );
  }
  else
  {
    new_value2(pb,  
	     (XtPointer) (layer_num*1000 + thiscolor),
	     (XtPointer) (layer_num*1000 + thiscolor)
	     );
  }

  
  
  apply_layer_callback(drawing_a,(XtPointer)layer_num,(XtPointer)layer_num);


  SetColorRight();
}


void toggle_all_grid_clone(Widget widget,XtPointer client_data,XtPointer call_data)
{  
  int cloneindex = (int)client_data;
  int axis;

  axis = cloneindex/1000;
  cloneindex = cloneindex%1000;

  ResetMasterRun();
  
  if(CloneErrorLookup[cloneindex].AllConfigOn[axis][C_GRID]==1)
    {
      XmToggleButtonSetState(CloneErrorLookup[cloneindex].allconfig[axis][C_GRID],1,(Boolean)0);
      
      
    }
  else
    {
      CloneErrorLookup[cloneindex].AllConfigOn[axis][C_GRID] = 1;

      

      if(CloneErrorLookup[cloneindex].SpecifiedConfigOn[axis][C_GRID]==1)
	{
	  CloneErrorLookup[cloneindex].SpecifiedConfigOn[axis][C_GRID] = 0;
	  
	  XmToggleButtonSetState(CloneErrorLookup[cloneindex].specifiedconfig[axis][C_GRID],
				 (Boolean)CloneErrorLookup[cloneindex].SpecifiedConfigOn[axis][C_GRID],(Boolean)0);	  
	}
    }

  if(!strcmp(GetVariousPeices(4),"0"))
  {
    XtSetSensitive(CloneErrorLookup[cloneindex].allconfiginclude[axis][C_GRID],False);
  }
  else
  {
    XtSetSensitive(CloneErrorLookup[cloneindex].allconfiginclude[axis][C_GRID],
		 !CloneErrorLookup[cloneindex].AllConfigOn[axis][C_GRID]);
  }

}



void toggle_some_grid_clone(Widget widget,XtPointer client_data,XtPointer call_data)
{  
  int cloneindex = (int)client_data;
  int axis;

  axis = cloneindex/1000;
  cloneindex = cloneindex%1000;

  ResetMasterRun();
  
  if(CloneErrorLookup[cloneindex].SpecifiedConfigOn[axis][C_GRID]==1)
    {
      XmToggleButtonSetState(CloneErrorLookup[cloneindex].specifiedconfig[axis][C_GRID],1,(Boolean)0);

      
    }
  else
    {
      CloneErrorLookup[cloneindex].SpecifiedConfigOn[axis][C_GRID] = 1;

      

      if(CloneErrorLookup[cloneindex].AllConfigOn[axis][C_GRID]==1)
	{
	  CloneErrorLookup[cloneindex].AllConfigOn[axis][C_GRID] = 0;
	  
	  XmToggleButtonSetState(CloneErrorLookup[cloneindex].allconfig[axis][C_GRID],
				 (Boolean)CloneErrorLookup[cloneindex].AllConfigOn[axis][C_GRID],(Boolean)0);	  
	}
    }


  if(!strcmp(GetVariousPeices(4),"0"))
  {
    XtSetSensitive(CloneErrorLookup[cloneindex].allconfiginclude[axis][C_GRID],False);
  }
  else
  {
    XtSetSensitive(CloneErrorLookup[cloneindex].allconfiginclude[axis][C_GRID],
		 !CloneErrorLookup[cloneindex].AllConfigOn[axis][C_GRID]);
  }
}









void NGAActorCallback(Widget w, MyData *userData, XtPointer callData)
{
  XmString tempXS,str;
  int n=0,i=0,j=0,k,l;
  Arg resources[20];
  Widget form,rowcol,label1,button,button5,actorhead,sep;
  char title[2000];
  MyData *mydata;
  int errnum     = userData->check_num;
  int clonenum   = userData->clonenum;
  int override   = (int)callData;
  int cloneindex = -1;
  int point1,point2,point3,point4,point5,point6,point7,point8,point9,formtotal;
  Dimension Pwidth,Pheight;


  if(clonenum>0)
    {
      cloneindex = GetCloneIndex(clonenum,errnum);
    }


  tempXS = XmStringCreateLtoR (" ","mytag1");


  if(NGA_TYPE==1)
    {
      for(i=0;i<=CONDITION_DEFINITIONS;i++)
	{
	  for(j=1;j<=3;j++)
	    {
	      for(k=0;k<=1;k++)
		{
		  for(l=0;l<NUM_C;l++)
		    {
		      ErrorLookup[i].DO_EDCS_COMBO[j][k][l] = 1;
		    }
		}
	    }
	}


      for(i=0;i<CLONE_DEFINITIONS;i++)
	{
	  for(j=1;j<=3;j++)
	    {
	      for(k=0;k<=1;k++)
		{
		  for(l=0;l<NUM_C;l++)
		    {
		      CloneErrorLookup[i].DO_EDCS_COMBO[j][k][l] = 1;
		    }
		}
	    }
	}
    }


  if((MY_ACTOR_UP(userData,0)==1)&&(override!=17))
    {	   
	  if(clonenum==0)
	{
	  ResetWidget(ErrorLookup[errnum].CSD);
	}
      else
	{
	  ResetWidget(CloneErrorLookup[cloneindex].CSD);
	}
    }
  else
    {
      


      n=0;
      XtSetArg(resources[n],  XmNdeleteResponse, XmDESTROY); n++; 
      
      if(clonenum==0)
	{
	  sprintf(title,"Selection of data to be checked for:  %s",ErrorLookup[errnum].name);
	}
      else
	{
	  sprintf(title,"Selection of data to be checked for:  %s (additional #%d)",
		  ErrorLookup[errnum].name,clonenum);
	}

      i = 0;
      while(title[i]!='\0')
	{
	  if(title[i]=='\n')
	    {title[i]=' ';}
	  i++;
	}

      
      actorhead = XtCreatePopupShell
	(title,topLevelShellWidgetClass,w,resources,n);
	
      
      rowcol = XtVaCreateWidget ("rowcol",
				 xmRowColumnWidgetClass, actorhead, NULL);
      
      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,  
			       NULL);      
      







      sprintf(title,"%s",ErrorLookup[errnum].description);
      
      str = XmStringCreateLtoR (title, "mytag1");
	
      label1 = XtVaCreateManagedWidget ("lab1",
					xmLabelWidgetClass, form,
					XmNlabelString,            str,
					XmNtopAttachment,          XmATTACH_FORM,
					XmNbottomAttachment,       XmATTACH_FORM,
					XmNleftAttachment,         XmATTACH_POSITION,
					XmNleftPosition,           0,
					XmNrightAttachment,        XmATTACH_POSITION,
					XmNrightPosition,          100,
					LABELWTRANSLATE,
					NULL);
      XtManageChild(form);
      



      for(j=1;j<=ErrorLookup[errnum].participants;j++)
	{
	  
	  sep = XtVaCreateManagedWidget ("sep1",
					 xmSeparatorWidgetClass, rowcol,
					 NULL);


	  if((errnum!=VVTERR3WAY)&&(errnum!=LLNONODEINT)&&(errnum!=CNODE_ZBUST))  
	  {

	  form = XtVaCreateWidget ("form.error.editor", xmFormWidgetClass, rowcol,
				   XmNfractionBase,  107,  
				   NULL);
	  
	  
	  if(j==1)
	    {	  
	      label1 = XtVaCreateManagedWidget ("lab1",
						xmLabelWidgetClass, form,
						XmNlabelString, STRING("Primary Participants:"),
						XmNtopAttachment,       XmATTACH_FORM,
						XmNbottomAttachment,    XmATTACH_FORM,
						XmNleftAttachment,      XmATTACH_POSITION,
						XmNleftPosition,        0,
						XmNrightAttachment,     XmATTACH_POSITION,
						XmNrightPosition,       100,
						LABELWTRANSLATE,
						NULL);
	    }
	  else if(j==2)
	    {	  
	      label1 = XtVaCreateManagedWidget ("lab1",
						xmLabelWidgetClass, form,
						XmNlabelString, STRING("Secondary Participants:"),
						XmNtopAttachment,       XmATTACH_FORM,
						XmNbottomAttachment,    XmATTACH_FORM,
						XmNleftAttachment,      XmATTACH_POSITION,
						XmNleftPosition,        0,
						XmNrightAttachment,     XmATTACH_POSITION,
						XmNrightPosition,       100,
						LABELWTRANSLATE,
						NULL);
	    }
	  else if(j==3)
	    {	  
	      label1 = XtVaCreateManagedWidget ("lab1",
						xmLabelWidgetClass, form,
						XmNlabelString, STRING("Tertiary Participants:"),
						XmNtopAttachment,       XmATTACH_FORM,
						XmNbottomAttachment,    XmATTACH_FORM,
						XmNleftAttachment,      XmATTACH_POSITION,
						XmNleftPosition,        0,
						XmNrightAttachment,     XmATTACH_POSITION,
						XmNrightPosition,       100,
						LABELWTRANSLATE,
						NULL);
	    }
	  else
	    {
	      printf("bad number of participants for condition number %d (%d)\n",
		     errnum,ErrorLookup[errnum].participants);
	    }

	  XtManageChild(form);
	  }




	  formtotal = 65;


	

	  if((errnum!=VVTERR3WAY)&&(errnum!=LLNONODEINT)&&(errnum!=CNODE_ZBUST))
	    {
	      form = XtVaCreateWidget ("form.actor.errors", xmFormWidgetClass, rowcol,
				       XmNfractionBase,  65,  
				       NULL);
	      
	      
	      label1 = XtVaCreateManagedWidget ("lab1",
						xmLabelWidgetClass, form,
						XmNlabelString, STRING("Number of"),
						XmNtopAttachment,      XmATTACH_FORM,
						XmNbottomAttachment,   XmATTACH_FORM,
						XmNleftAttachment,     XmATTACH_POSITION,
						XmNleftPosition,       55,
						XmNrightAttachment,    XmATTACH_POSITION,
						XmNrightPosition,      65,
						LABELWTRANSLATE,
						NULL);

	      XtManageChild(form);
	    }


	  form = XtVaCreateWidget ("form.actor.errors", xmFormWidgetClass, rowcol,
				   XmNfractionBase,  65,  
				   NULL);


	  label1 = XtVaCreateManagedWidget ("lab1",
					    xmLabelWidgetClass, form,
					    XmNlabelString, STRING("All"),
					    XmNtopAttachment,       XmATTACH_FORM,
					    XmNbottomAttachment,    XmATTACH_FORM,
					    XmNleftAttachment,      XmATTACH_POSITION,
					    XmNleftPosition,        15,
					    XmNrightAttachment,     XmATTACH_POSITION,
					    XmNrightPosition,       18,
					    LABELWTRANSLATE,
					    NULL);

	  label1 = XtVaCreateManagedWidget ("lab1",
					    xmLabelWidgetClass, form,
					    XmNlabelString, STRING("Specified"),
					    XmNtopAttachment,      XmATTACH_FORM,
					    XmNbottomAttachment,   XmATTACH_FORM,
					    XmNleftAttachment,     XmATTACH_POSITION,
					    XmNleftPosition,       19,
					    XmNrightAttachment,    XmATTACH_POSITION,
					    XmNrightPosition,      29,
					    LABELWTRANSLATE,
					    NULL);

	  label1 = XtVaCreateManagedWidget ("lab1",
					    xmLabelWidgetClass, form,
					    XmNlabelString, STRING("Specifications"),
					    XmNtopAttachment,      XmATTACH_FORM,
					    XmNbottomAttachment,   XmATTACH_FORM,
					    XmNleftAttachment,     XmATTACH_POSITION,
					    XmNleftPosition,       55,
					    XmNrightAttachment,    XmATTACH_POSITION,
					    XmNrightPosition,      65,
					    LABELWTRANSLATE,
					    NULL);


	  XtManageChild(form);
           




	  point1 = 15;

	  point2 = 15;
	  point3 = 18;

	  point4 = 22;
	  point5 = 25;

	  point6 = 28;
	  point7 = 55;

	  point8 = 58;
	  point9 = 62;



	  if(	     
	     ((j==1)&&(ErrorLookup[errnum].Config1[C_POFE]!=2))  ||
	     ((j==2)&&(ErrorLookup[errnum].Config2[C_POFE]!=2))  ||
	     ((j==3)&&(ErrorLookup[errnum].Config3[C_POFE]!=2))
	     )
	    {
	      
	      
	      
	      form = XtVaCreateWidget ("form.error.editor", xmFormWidgetClass, rowcol,
				       XmNfractionBase,  65,  
				       NULL);
	      
	      
	      
	      label1 = XtVaCreateManagedWidget ("lab1",
						xmLabelWidgetClass, form,
						XmNlabelString, STRING("Point Features:"),
						XmNtopAttachment,       XmATTACH_FORM,
						XmNbottomAttachment,    XmATTACH_FORM,
						XmNleftAttachment,      XmATTACH_POSITION,
						XmNleftPosition,        0,
						XmNrightAttachment,     XmATTACH_POSITION,
						XmNrightPosition,       point1,
						LABELWTRANSLATE,
						NULL);
	      XtManageChild (label1);
	      
	      
	      if(clonenum==0)
		{

		  ErrorLookup[errnum].allconfig[j][C_POFE] = 
		    XtVaCreateManagedWidget ("the_test",
					     xmToggleButtonWidgetClass, form,
					     XmNtopAttachment,          XmATTACH_FORM,
					     XmNbottomAttachment,       XmATTACH_FORM,
					     XmNleftAttachment,         XmATTACH_POSITION,
					     XmNleftPosition,           point2,
					     XmNrightAttachment,        XmATTACH_POSITION,
					     XmNrightPosition,          point3,
					     XmNlabelString,            tempXS,
					     TOGGLETRANSLATE,     TOGGLEINCLUDE,
					     NULL);
		  
		  XmToggleButtonSetState(ErrorLookup[errnum].allconfig[j][C_POFE],
					 (Boolean)ErrorLookup[errnum].AllConfigOn[j][C_POFE],(Boolean)0);
		  
		  
		  XtAddCallback (ErrorLookup[errnum].allconfig[j][C_POFE], 
				 XmNvalueChangedCallback, toggle_all_point_nonclone, (XtPointer)(errnum+j*1000));
		  
		  XtManageChild (ErrorLookup[errnum].allconfig[j][C_POFE]);
		  
		  if((Total2DPoint+Total3DPoint)<=0)
		  {
            XtSetSensitive(ErrorLookup[errnum].allconfig[j][C_POFE],False);
		  }

		  
		  ErrorLookup[errnum].specifiedconfig[j][C_POFE] = 
		    XtVaCreateManagedWidget ("the_test",
					     xmToggleButtonWidgetClass, form,
					     XmNtopAttachment,          XmATTACH_FORM,
					     XmNbottomAttachment,       XmATTACH_FORM,
					     XmNleftAttachment,         XmATTACH_POSITION,
					     XmNleftPosition,           point4,
					     XmNrightAttachment,        XmATTACH_POSITION,
					     XmNrightPosition,          point5,
					     XmNlabelString,            tempXS,
					     TOGGLETRANSLATE,     TOGGLEINCLUDE,
					     NULL);
		  
		  
		  XmToggleButtonSetState(ErrorLookup[errnum].specifiedconfig[j][C_POFE],
					 (Boolean)ErrorLookup[errnum].SpecifiedConfigOn[j][C_POFE],(Boolean)0);
		  
		  
		  
		  XtAddCallback (ErrorLookup[errnum].specifiedconfig[j][C_POFE], 
				 XmNvalueChangedCallback, toggle_some_point_nonclone, (XtPointer)(errnum+j*1000));
		  
		  XtManageChild (ErrorLookup[errnum].specifiedconfig[j][C_POFE]);




		  

		  ErrorLookup[errnum].allconfiginclude[j][C_POFE] = 
		    XtVaCreateManagedWidget ("Help4",
					     xmPushButtonWidgetClass, form,
					     XmNtraversalOn,      False,
					     XmNleftAttachment,   XmATTACH_POSITION,
					     XmNleftPosition,     point6,
					     XmNrightAttachment,  XmATTACH_POSITION,
					     XmNrightPosition,    point7,
					     XmNlabelString,      STRING("Specify Point Features to Include..."),
					     XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					     NULL);
		  
		  mydata  = (MyData *) (malloc(sizeof(MyData)));
		  if(mydata==NULL){printf("myb: out of allocation memory!\n"); ExitWrapper(-1);}
		  
		  mydata->check_num = userData->check_num;
		  mydata->clonenum  = userData->clonenum;
		  mydata->element   = j;
		  mydata->geomtype  = C_POFE;
		  
		  XtAddCallback(ErrorLookup[errnum].allconfiginclude[j][C_POFE], XmNactivateCallback, 
				(XtCallbackProc)ModelButton3Callback, mydata);	      
		  XtManageChild (ErrorLookup[errnum].allconfiginclude[j][C_POFE]);
		  
		  
		  
		  
		  if (
			  (ErrorLookup[errnum].AllConfigOn[j][C_POFE]==1) ||
			  ((Total2DPoint+Total3DPoint)<=0)
			 )
		    {
		      XtSetSensitive(ErrorLookup[errnum].allconfiginclude[j][C_POFE],False);
		    }


		}
	      else
		{


		  CloneErrorLookup[cloneindex].allconfig[j][C_POFE] = 
		    XtVaCreateManagedWidget ("the_test",
					     xmToggleButtonWidgetClass, form,
					     XmNtopAttachment,          XmATTACH_FORM,
					     XmNbottomAttachment,       XmATTACH_FORM,
					     XmNleftAttachment,         XmATTACH_POSITION,
					     XmNleftPosition,           point2,
					     XmNrightAttachment,        XmATTACH_POSITION,
					     XmNrightPosition,          point3,
					     XmNlabelString,            tempXS,
					     TOGGLETRANSLATE,     TOGGLEINCLUDE,
					     NULL);
		  
		  XmToggleButtonSetState(CloneErrorLookup[cloneindex].allconfig[j][C_POFE],
					 (Boolean)CloneErrorLookup[cloneindex].AllConfigOn[j][C_POFE],(Boolean)0);
		  
		  
		  XtAddCallback (CloneErrorLookup[cloneindex].allconfig[j][C_POFE], 
				 XmNvalueChangedCallback, toggle_all_point_clone, (XtPointer)(cloneindex+j*1000));
		  
		  XtManageChild (CloneErrorLookup[cloneindex].allconfig[j][C_POFE]);

  		  if((Total2DPoint+Total3DPoint)<=0)
		  {
            XtSetSensitive(CloneErrorLookup[cloneindex].allconfig[j][C_POFE],False);
		  }

		  
		  CloneErrorLookup[cloneindex].specifiedconfig[j][C_POFE] = 
		    XtVaCreateManagedWidget ("the_test",
					     xmToggleButtonWidgetClass, form,
					     XmNtopAttachment,          XmATTACH_FORM,
					     XmNbottomAttachment,       XmATTACH_FORM,
					     XmNleftAttachment,         XmATTACH_POSITION,
					     XmNleftPosition,           point4,
					     XmNrightAttachment,        XmATTACH_POSITION,
					     XmNrightPosition,          point5,
					     XmNlabelString,            tempXS,
					     TOGGLETRANSLATE,     TOGGLEINCLUDE,
					     NULL);
		  
		  
		  XmToggleButtonSetState(CloneErrorLookup[cloneindex].specifiedconfig[j][C_POFE],
					 (Boolean)CloneErrorLookup[cloneindex].SpecifiedConfigOn[j][C_POFE],(Boolean)0);
		  
		  
		  
		  XtAddCallback (CloneErrorLookup[cloneindex].specifiedconfig[j][C_POFE], 
				 XmNvalueChangedCallback, toggle_some_point_clone, (XtPointer)(cloneindex+j*1000));
		  
		  XtManageChild (CloneErrorLookup[cloneindex].specifiedconfig[j][C_POFE]);



		  CloneErrorLookup[cloneindex].allconfiginclude[j][C_POFE] = 
		    XtVaCreateManagedWidget ("Help4",
					     xmPushButtonWidgetClass, form,
					     XmNtraversalOn,      False,
					     XmNleftAttachment,   XmATTACH_POSITION,
					     XmNleftPosition,     point6,
					     XmNrightAttachment,  XmATTACH_POSITION,
					     XmNrightPosition,    point7,
					     XmNlabelString,      STRING("Specify Point Features to Include..."),
					     XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					     NULL);
		  
		  mydata  = (MyData *) (malloc(sizeof(MyData)));
		  if(mydata==NULL){printf("myb: out of allocation memory!\n"); ExitWrapper(-1);}
		  
		  mydata->check_num = userData->check_num;
		  mydata->clonenum  = userData->clonenum;
		  mydata->element   = j;
		  mydata->geomtype  = C_POFE;
		  
		  XtAddCallback(CloneErrorLookup[cloneindex].allconfiginclude[j][C_POFE], XmNactivateCallback, 
				(XtCallbackProc)ModelButton3Callback, mydata);	      
		  XtManageChild (CloneErrorLookup[cloneindex].allconfiginclude[j][C_POFE]);
		  
		  
		  
		  
		  if(
			  (CloneErrorLookup[cloneindex].AllConfigOn[j][C_POFE]==1)||
			  ((Total2DPoint+Total3DPoint)<=0)
			 )
		    {
		      XtSetSensitive(CloneErrorLookup[cloneindex].allconfiginclude[j][C_POFE],False);
		    }		  
		}
	      


	      if(clonenum==0)
		{
		  sprintf(title,"%s",PadSpecial(
			  ErrorLookup[errnum].model_index[j][1][C_POFE] +
			  ErrorLookup[errnum].sac_index[j][1][C_POFE]));


		  ErrorLookup[errnum].specwidget[j][1][C_POFE] = 
		    XtVaCreateManagedWidget ("lab1",
					     xmLabelWidgetClass, form,
					     XmNlabelString, STRING(title),
					     XmNtopAttachment,       XmATTACH_FORM,
					     XmNbottomAttachment,    XmATTACH_FORM,

					     XmNleftAttachment,      XmATTACH_WIDGET,
						 XmNleftWidget,          ErrorLookup[errnum].allconfiginclude[j][C_POFE],


					     LABELWTRANSLATE,
					     NULL);
		  XtManageChild (label1);
		}
	      else
		{
		  sprintf(title,"%s",PadSpecial(
			  CloneErrorLookup[cloneindex].model_index[j][1][C_POFE] +
			  CloneErrorLookup[cloneindex].sac_index[j][1][C_POFE]));

		  CloneErrorLookup[cloneindex].specwidget[j][1][C_POFE] = 
		    XtVaCreateManagedWidget ("lab1",
					     xmLabelWidgetClass, form,
					     XmNlabelString, STRING(title),
					     XmNtopAttachment,       XmATTACH_FORM,
					     XmNbottomAttachment,    XmATTACH_FORM,

					     XmNleftAttachment,      XmATTACH_WIDGET,
						 XmNleftWidget,          CloneErrorLookup[cloneindex].allconfiginclude[j][C_POFE],
						 

					     LABELWTRANSLATE,
					     NULL);
		  XtManageChild (label1);
		}


	      XtManageChild(form);





	      form = XtVaCreateWidget ("form.error.editor", xmFormWidgetClass, rowcol,
				       XmNfractionBase,  65,  
				       NULL);
	      
	      

	      button5 = XtVaCreateManagedWidget ("Help4",
						 xmPushButtonWidgetClass, form,
						 XmNtopAttachment,    XmATTACH_FORM,
						 XmNtraversalOn,      False,
						 XmNbottomAttachment, XmATTACH_FORM,
						 XmNleftAttachment,   XmATTACH_POSITION,
						 XmNleftPosition,     point6,
						 XmNrightAttachment,  XmATTACH_POSITION,
						 XmNrightPosition,    point7,
						 XmNlabelString,      STRING("Specify Point Features to Exclude..."),
						 XmNtranslations, XtParseTranslationTable ( translations_global ) ,
						 NULL);
	      

	      mydata  = (MyData *) (malloc(sizeof(MyData)));
	      if(mydata==NULL){printf("myb: out of allocation memory!\n"); ExitWrapper(-1);}
	      
	      mydata->check_num = userData->check_num;
	      mydata->clonenum  = userData->clonenum;
	      mydata->element   = j;
	      mydata->geomtype  = C_POFE;
	      
	      XtAddCallback(button5, XmNactivateCallback, (XtCallbackProc)ModelButton2Callback, mydata);
	      XtManageChild (button5);


          if((Total2DPoint+Total3DPoint)<=0)
		  {
		    XtSetSensitive(button5,False);
		  }
		  


      
	      if(clonenum==0)
		{
		  sprintf(title,"%s",PadSpecial(
			  ErrorLookup[errnum].model_index[j][0][C_POFE] +
			  ErrorLookup[errnum].sac_index[j][0][C_POFE]));
		  
		  
		  ErrorLookup[errnum].specwidget[j][0][C_POFE] = 
		    XtVaCreateManagedWidget ("lab1",
					     xmLabelWidgetClass, form,
					     XmNlabelString, STRING(title),
					     XmNtopAttachment,       XmATTACH_FORM,
					     XmNbottomAttachment,    XmATTACH_FORM,

					     XmNleftAttachment,      XmATTACH_WIDGET,
						 XmNleftWidget,          button5,

					     LABELWTRANSLATE,
					     NULL);
		  XtManageChild (label1);
		}
	      else
		{
		  sprintf(title,"%s",PadSpecial(
			  CloneErrorLookup[cloneindex].model_index[j][0][C_POFE] +
			  CloneErrorLookup[cloneindex].sac_index[j][0][C_POFE]));

		  CloneErrorLookup[cloneindex].specwidget[j][0][C_POFE] = 
		    XtVaCreateManagedWidget ("lab1",
					     xmLabelWidgetClass, form,
					     XmNlabelString, STRING(title),
					     XmNtopAttachment,       XmATTACH_FORM,
					     XmNbottomAttachment,    XmATTACH_FORM,

					     XmNleftAttachment,      XmATTACH_WIDGET,
						 XmNleftWidget,          button5,

					     LABELWTRANSLATE,
					     NULL);
		  XtManageChild (label1);
		}
  
	      XtManageChild(form);



	      
	    }
	  	  	

	  if(
	     ((j==1)&&(ErrorLookup[errnum].Config1[C_LINE]!=2))  ||
	     ((j==2)&&(ErrorLookup[errnum].Config2[C_LINE]!=2))  ||
	     ((j==3)&&(ErrorLookup[errnum].Config3[C_LINE]!=2))  
	     )
	    {
	      
	      
	      
	      form = XtVaCreateWidget ("form.error.editor", xmFormWidgetClass, rowcol,
				       XmNfractionBase,  65,  
				       NULL);
	      
	      
	      
	      label1 = XtVaCreateManagedWidget ("lab1",
						xmLabelWidgetClass, form,
						XmNlabelString, STRING("Line Features:"),
						XmNtopAttachment,       XmATTACH_FORM,
						XmNbottomAttachment,    XmATTACH_FORM,
						XmNleftAttachment,      XmATTACH_POSITION,
						XmNleftPosition,        0,
						XmNrightAttachment,     XmATTACH_POSITION,
						XmNrightPosition,       point1,
						LABELWTRANSLATE,
						NULL);
	      XtManageChild (label1);
	      

	      if(clonenum==0)
		{	      

		  ErrorLookup[errnum].allconfig[j][C_LINE] = 
		    XtVaCreateManagedWidget ("the_test",
					     xmToggleButtonWidgetClass, form,
					     XmNtopAttachment,          XmATTACH_FORM,
					     XmNbottomAttachment,       XmATTACH_FORM,
					     XmNleftAttachment,         XmATTACH_POSITION,
					     XmNleftPosition,           point2,
					     XmNrightAttachment,        XmATTACH_POSITION,
					     XmNrightPosition,          point3,
					     XmNlabelString,            tempXS,
					     TOGGLETRANSLATE,     TOGGLEINCLUDE,
					     NULL);
		  
		  XmToggleButtonSetState(ErrorLookup[errnum].allconfig[j][C_LINE],
					 (Boolean)ErrorLookup[errnum].AllConfigOn[j][C_LINE],(Boolean)0);
		  
		  
		  XtAddCallback (ErrorLookup[errnum].allconfig[j][C_LINE], 
				 XmNvalueChangedCallback, toggle_all_linear_nonclone, (XtPointer)(errnum+j*1000));
		  
		  XtManageChild (ErrorLookup[errnum].allconfig[j][C_LINE]);
		  

		  if((Total2DLine+Total3DLine)<=0)
		  {
            XtSetSensitive(ErrorLookup[errnum].allconfig[j][C_LINE],False);
		  }


		  ErrorLookup[errnum].specifiedconfig[j][C_LINE] = 
		    XtVaCreateManagedWidget ("the_test",
					     xmToggleButtonWidgetClass, form,
					     XmNtopAttachment,          XmATTACH_FORM,
					     XmNbottomAttachment,       XmATTACH_FORM,
					     XmNleftAttachment,         XmATTACH_POSITION,
					     XmNleftPosition,           point4,
					     XmNrightAttachment,        XmATTACH_POSITION,
					     XmNrightPosition,          point5,
					     XmNlabelString,            tempXS,
					     TOGGLETRANSLATE,     TOGGLEINCLUDE,
					     NULL);
		  
		  
		  XmToggleButtonSetState(ErrorLookup[errnum].specifiedconfig[j][C_LINE],
					 (Boolean)ErrorLookup[errnum].SpecifiedConfigOn[j][C_LINE],(Boolean)0);
		  
		  
		  
		  XtAddCallback (ErrorLookup[errnum].specifiedconfig[j][C_LINE], 
				 XmNvalueChangedCallback, toggle_some_linear_nonclone, (XtPointer)(errnum+j*1000));
		  
		  XtManageChild (ErrorLookup[errnum].specifiedconfig[j][C_LINE]);
		  



		  ErrorLookup[errnum].allconfiginclude[j][C_LINE] = 
		    XtVaCreateManagedWidget ("Help4",
					     xmPushButtonWidgetClass, form,
					     XmNtraversalOn,      False,
					     XmNleftAttachment,   XmATTACH_POSITION,
					     XmNleftPosition,     point6,
					     XmNrightAttachment,  XmATTACH_POSITION,
					     XmNrightPosition,    point7,
					     XmNlabelString,      STRING("Specify Line Features to Include..."),
					     XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					     NULL);
		  
		  mydata  = (MyData *) (malloc(sizeof(MyData)));
		  if(mydata==NULL){printf("myb: out of allocation memory!\n"); ExitWrapper(-1);}
		  
		  mydata->check_num = userData->check_num;
		  mydata->clonenum  = userData->clonenum;
		  mydata->element   = j;
		  mydata->geomtype  = C_LINE;
		  
		  XtAddCallback(ErrorLookup[errnum].allconfiginclude[j][C_LINE], XmNactivateCallback, 
				(XtCallbackProc)ModelButton3Callback, mydata);
		  
		  XtManageChild (ErrorLookup[errnum].allconfiginclude[j][C_LINE]);
		  
		  
		  
		  if (
			  (ErrorLookup[errnum].AllConfigOn[j][C_LINE]==1)||
			  ((Total2DLine+Total3DLine)<=0)
			 )
		    {
		      XtSetSensitive(ErrorLookup[errnum].allconfiginclude[j][C_LINE],False);
		    }
		  
		  
		}
	      else
		{

		  CloneErrorLookup[cloneindex].allconfig[j][C_LINE] = 
		    XtVaCreateManagedWidget ("the_test",
					     xmToggleButtonWidgetClass, form,
					     XmNtopAttachment,          XmATTACH_FORM,
					     XmNbottomAttachment,       XmATTACH_FORM,
					     XmNleftAttachment,         XmATTACH_POSITION,
					     XmNleftPosition,           point2,
					     XmNrightAttachment,        XmATTACH_POSITION,
					     XmNrightPosition,          point3,
					     XmNlabelString,            tempXS,
					     TOGGLETRANSLATE,     TOGGLEINCLUDE,
					     NULL);
		  
		  XmToggleButtonSetState(CloneErrorLookup[cloneindex].allconfig[j][C_LINE],
					 (Boolean)CloneErrorLookup[cloneindex].AllConfigOn[j][C_LINE],(Boolean)0);
		  
		  
		  XtAddCallback (CloneErrorLookup[cloneindex].allconfig[j][C_LINE], 
				 XmNvalueChangedCallback, toggle_all_linear_clone, (XtPointer)(cloneindex+j*1000));
		  
		  XtManageChild (CloneErrorLookup[cloneindex].allconfig[j][C_LINE]);
		  
		  
		  if((Total2DLine+Total3DLine)<=0)
		  {
            XtSetSensitive(CloneErrorLookup[cloneindex].allconfig[j][C_LINE],False);
		  }
		  
		  
		  CloneErrorLookup[cloneindex].specifiedconfig[j][C_LINE] = 
		    XtVaCreateManagedWidget ("the_test",
					     xmToggleButtonWidgetClass, form,
					     XmNtopAttachment,          XmATTACH_FORM,
					     XmNbottomAttachment,       XmATTACH_FORM,
					     XmNleftAttachment,         XmATTACH_POSITION,
					     XmNleftPosition,           point4,
					     XmNrightAttachment,        XmATTACH_POSITION,
					     XmNrightPosition,          point5,
					     XmNlabelString,            tempXS,
					     TOGGLETRANSLATE,     TOGGLEINCLUDE,
					     NULL);
		  
		  
		  XmToggleButtonSetState(CloneErrorLookup[cloneindex].specifiedconfig[j][C_LINE],
					 (Boolean)CloneErrorLookup[cloneindex].SpecifiedConfigOn[j][C_LINE],(Boolean)0);
		  
		  
		  
		  XtAddCallback (CloneErrorLookup[cloneindex].specifiedconfig[j][C_LINE], 
				 XmNvalueChangedCallback, toggle_some_linear_clone, (XtPointer)(cloneindex+j*1000));
		  
		  XtManageChild (CloneErrorLookup[cloneindex].specifiedconfig[j][C_LINE]);
 



		  CloneErrorLookup[cloneindex].allconfiginclude[j][C_LINE] = 
		    XtVaCreateManagedWidget ("Help4",
					     xmPushButtonWidgetClass, form,
					     XmNtraversalOn,      False,
					     XmNleftAttachment,   XmATTACH_POSITION,
					     XmNleftPosition,     point6,
					     XmNrightAttachment,  XmATTACH_POSITION,
					     XmNrightPosition,    point7,
					     XmNlabelString,      STRING("Specify Line Features to Include..."),
					     XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					     NULL);
		  
		  mydata  = (MyData *) (malloc(sizeof(MyData)));
		  if(mydata==NULL){printf("myb: out of allocation memory!\n"); ExitWrapper(-1);}
		  
		  mydata->check_num = userData->check_num;
		  mydata->clonenum  = userData->clonenum;
		  mydata->element   = j;
		  mydata->geomtype  = C_LINE;
		  
		  XtAddCallback(CloneErrorLookup[cloneindex].allconfiginclude[j][C_LINE], XmNactivateCallback, 
				(XtCallbackProc)ModelButton3Callback, mydata);
		  
		  XtManageChild (CloneErrorLookup[cloneindex].allconfiginclude[j][C_LINE]);
		  
		  
		  
		  if (
			  (CloneErrorLookup[cloneindex].AllConfigOn[j][C_LINE]==1)||
			  ((Total2DLine+Total3DLine)<=0)
			 )
		    {
		      XtSetSensitive(CloneErrorLookup[cloneindex].allconfiginclude[j][C_LINE],False);
		    }
		}
	      







	      if(clonenum==0)
		{
		  sprintf(title,"%s",PadSpecial(
			  ErrorLookup[errnum].model_index[j][1][C_LINE] +
			  ErrorLookup[errnum].sac_index[j][1][C_LINE]));
		  
		  
		  ErrorLookup[errnum].specwidget[j][1][C_LINE] = 
		    XtVaCreateManagedWidget ("lab1",
					     xmLabelWidgetClass, form,
					     XmNlabelString, STRING(title),
					     XmNtopAttachment,       XmATTACH_FORM,
					     XmNbottomAttachment,    XmATTACH_FORM,

						 XmNleftAttachment,      XmATTACH_WIDGET,
					     XmNleftWidget,          ErrorLookup[errnum].allconfiginclude[j][C_LINE],


					     LABELWTRANSLATE,
					     NULL);
		  XtManageChild (label1);
		}
	      else
		{
		  sprintf(title,"%s",PadSpecial(
			  CloneErrorLookup[cloneindex].model_index[j][1][C_LINE] +
			  CloneErrorLookup[cloneindex].sac_index[j][1][C_LINE]));

		  CloneErrorLookup[cloneindex].specwidget[j][1][C_LINE] = 
		    XtVaCreateManagedWidget ("lab1",
					     xmLabelWidgetClass, form,
					     XmNlabelString, STRING(title),
					     XmNtopAttachment,       XmATTACH_FORM,
					     XmNbottomAttachment,    XmATTACH_FORM,

						 XmNleftAttachment,      XmATTACH_WIDGET,
					     XmNleftWidget,          CloneErrorLookup[cloneindex].allconfiginclude[j][C_LINE],

					     LABELWTRANSLATE,
					     NULL);
		  XtManageChild (label1);
		}
	      


	      XtManageChild (form);
	      




	      
	      
	      form = XtVaCreateWidget ("form.error.editor", xmFormWidgetClass, rowcol,
				       XmNfractionBase,  65,  
				       NULL);
	      

	      
	      button5 = XtVaCreateManagedWidget ("Help4",
						 xmPushButtonWidgetClass, form,
						 XmNtopAttachment,    XmATTACH_FORM,
						 XmNtraversalOn,      False,
						 XmNbottomAttachment, XmATTACH_FORM,
						 XmNleftAttachment,   XmATTACH_POSITION,
						 XmNleftPosition,     point6,
						 XmNrightAttachment,  XmATTACH_POSITION,
						 XmNrightPosition,    point7,
						 XmNlabelString,      STRING("Specify Line Features to Exclude..."),
						 XmNtranslations, XtParseTranslationTable ( translations_global ) ,
						 NULL);
	      
	      
	      mydata  = (MyData *) (malloc(sizeof(MyData)));
	      if(mydata==NULL){printf("myb: out of allocation memory!\n"); ExitWrapper(-1);}
	      
	      mydata->check_num = userData->check_num;
	      mydata->clonenum  = userData->clonenum;
	      mydata->element   = j;
	      mydata->geomtype  = C_LINE;
		      
	      XtAddCallback(button5, XmNactivateCallback, (XtCallbackProc)ModelButton2Callback, mydata);
	      XtManageChild (button5);

          if((Total2DLine+Total3DLine)<=0)
		  {
		    XtSetSensitive(button5,False);
		  }


	      if(clonenum==0)
		{
		  sprintf(title,"%s",PadSpecial(
			  ErrorLookup[errnum].model_index[j][0][C_LINE] +
			  ErrorLookup[errnum].sac_index[j][0][C_LINE]));
		  
		  
		  ErrorLookup[errnum].specwidget[j][0][C_LINE] = 
		    XtVaCreateManagedWidget ("lab1",
					     xmLabelWidgetClass, form,
					     XmNlabelString, STRING(title),
					     XmNtopAttachment,       XmATTACH_FORM,
					     XmNbottomAttachment,    XmATTACH_FORM,

					     XmNleftAttachment,      XmATTACH_WIDGET,
						 XmNleftWidget,          button5,

					     LABELWTRANSLATE,
					     NULL);
		  XtManageChild (label1);
		}
	      else
		{
		  sprintf(title,"%s",PadSpecial(
			  CloneErrorLookup[cloneindex].model_index[j][0][C_LINE] +
			  CloneErrorLookup[cloneindex].sac_index[j][0][C_LINE]));

		  CloneErrorLookup[cloneindex].specwidget[j][0][C_LINE] = 
		    XtVaCreateManagedWidget ("lab1",
					     xmLabelWidgetClass, form,
					     XmNlabelString, STRING(title),
					     XmNtopAttachment,       XmATTACH_FORM,
					     XmNbottomAttachment,    XmATTACH_FORM,

					     XmNleftAttachment,      XmATTACH_WIDGET,
						 XmNleftWidget,          button5,
						 
					     LABELWTRANSLATE,
					     NULL);
		  XtManageChild (label1);
		}




	      
	      XtManageChild(form);
	      
	    }








	  
	  
	  if(
	     ((j==1)&&(ErrorLookup[errnum].Config1[C_AREA]!=2))  ||
	     ((j==2)&&(ErrorLookup[errnum].Config2[C_AREA]!=2))  ||
	     ((j==3)&&(ErrorLookup[errnum].Config3[C_AREA]!=2))  
	     )
	    {
	      
	      
	      
	      form = XtVaCreateWidget ("form.error.editor", xmFormWidgetClass, rowcol,
				       XmNfractionBase,  65,  
				       NULL);
	      
	      
	      
	      label1 = XtVaCreateManagedWidget ("lab1",
						xmLabelWidgetClass, form,
						XmNlabelString, STRING("Area Features:"),
						XmNtopAttachment,       XmATTACH_FORM,
						XmNbottomAttachment,    XmATTACH_FORM,
						XmNleftAttachment,      XmATTACH_POSITION,
						XmNleftPosition,        0,
						XmNrightAttachment,     XmATTACH_POSITION,
						XmNrightPosition,       point1,
						LABELWTRANSLATE,
						NULL);
	      XtManageChild (label1);
	      

	      
	      if(clonenum==0)
		{
		  
		  ErrorLookup[errnum].allconfig[j][C_AREA] = 
		    XtVaCreateManagedWidget ("the_test",
					     xmToggleButtonWidgetClass, form,
					     XmNtopAttachment,          XmATTACH_FORM,
					     XmNbottomAttachment,       XmATTACH_FORM,
					     XmNleftAttachment,         XmATTACH_POSITION,
					     XmNleftPosition,           point2,
					     XmNrightAttachment,        XmATTACH_POSITION,
					     XmNrightPosition,          point3,
					     XmNlabelString,            tempXS,
					     TOGGLETRANSLATE,     TOGGLEINCLUDE,
					     NULL);
		  
		  XmToggleButtonSetState(ErrorLookup[errnum].allconfig[j][C_AREA],
					 (Boolean)ErrorLookup[errnum].AllConfigOn[j][C_AREA],(Boolean)0);
		  
		  
		  XtAddCallback (ErrorLookup[errnum].allconfig[j][C_AREA], 
				 XmNvalueChangedCallback, toggle_all_areal_nonclone, (XtPointer)(errnum+j*1000));
		  
		  XtManageChild (ErrorLookup[errnum].allconfig[j][C_AREA]);
		  
		  
		  if((Total2DArea+Total3DArea)<=0)
		  {
            XtSetSensitive(ErrorLookup[errnum].allconfig[j][C_AREA],False);
		  }
		  
		  
		  ErrorLookup[errnum].specifiedconfig[j][C_AREA] = 
		    XtVaCreateManagedWidget ("the_test",
					     xmToggleButtonWidgetClass, form,
					     XmNtopAttachment,          XmATTACH_FORM,
					     XmNbottomAttachment,       XmATTACH_FORM,
					     XmNleftAttachment,         XmATTACH_POSITION,
					     XmNleftPosition,           point4,
					     XmNrightAttachment,        XmATTACH_POSITION,
					     XmNrightPosition,          point5,
					     XmNlabelString,            tempXS,
					     TOGGLETRANSLATE,     TOGGLEINCLUDE,
					     NULL);
		  
		  
		  XmToggleButtonSetState(ErrorLookup[errnum].specifiedconfig[j][C_AREA],
					 (Boolean)ErrorLookup[errnum].SpecifiedConfigOn[j][C_AREA],(Boolean)0);
		  
		  
		  
		  XtAddCallback (ErrorLookup[errnum].specifiedconfig[j][C_AREA], 
				 XmNvalueChangedCallback, toggle_some_areal_nonclone, (XtPointer)(errnum+j*1000));
		  
		  XtManageChild (ErrorLookup[errnum].specifiedconfig[j][C_AREA]);
		  


		  ErrorLookup[errnum].allconfiginclude[j][C_AREA] = 
		    XtVaCreateManagedWidget ("Help4",
					     xmPushButtonWidgetClass, form,
					     XmNtopAttachment,    XmATTACH_FORM,
					     XmNtraversalOn,      False,
					     XmNbottomAttachment, XmATTACH_FORM,
					     XmNleftAttachment,   XmATTACH_POSITION,
					     XmNleftPosition,     point6,
					     XmNrightAttachment,  XmATTACH_POSITION,
					     XmNrightPosition,    point7,
					     XmNlabelString,      STRING("Specify Area Features to Include..."),
					     XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					     NULL);
		  
		  mydata  = (MyData *) (malloc(sizeof(MyData)));
		  if(mydata==NULL){printf("myb: out of allocation memory!\n"); ExitWrapper(-1);}
		  
		  mydata->check_num = userData->check_num;
		  mydata->clonenum  = userData->clonenum;
		  mydata->element   = j;
		  mydata->geomtype  = C_AREA;
		  
		  XtAddCallback(ErrorLookup[errnum].allconfiginclude[j][C_AREA], XmNactivateCallback, 
				(XtCallbackProc)ModelButton3Callback, mydata);
		  
		  XtManageChild (ErrorLookup[errnum].allconfiginclude[j][C_AREA]);
		  
		  
		  
		  if (
			  (ErrorLookup[errnum].AllConfigOn[j][C_AREA]==1)||
			  ((Total2DArea+Total3DArea)<=0)
			 )
		    {
		      XtSetSensitive(ErrorLookup[errnum].allconfiginclude[j][C_AREA],False);
		    }

		}
	      else
		{

		  CloneErrorLookup[cloneindex].allconfig[j][C_AREA] = 
		    XtVaCreateManagedWidget ("the_test",
					     xmToggleButtonWidgetClass, form,
					     XmNtopAttachment,          XmATTACH_FORM,
					     XmNbottomAttachment,       XmATTACH_FORM,
					     XmNleftAttachment,         XmATTACH_POSITION,
					     XmNleftPosition,           point2,
					     XmNrightAttachment,        XmATTACH_POSITION,
					     XmNrightPosition,          point3,
					     XmNlabelString,            tempXS,
					     TOGGLETRANSLATE,     TOGGLEINCLUDE,
					     NULL);
		  
		  XmToggleButtonSetState(CloneErrorLookup[cloneindex].allconfig[j][C_AREA],
					 (Boolean)CloneErrorLookup[cloneindex].AllConfigOn[j][C_AREA],(Boolean)0);
		  
		  
		  XtAddCallback (CloneErrorLookup[cloneindex].allconfig[j][C_AREA], 
				 XmNvalueChangedCallback, toggle_all_areal_clone, (XtPointer)(cloneindex+j*1000));
		  
		  XtManageChild (CloneErrorLookup[cloneindex].allconfig[j][C_AREA]);


		  if((Total2DArea+Total3DArea)<=0)
		  {
            XtSetSensitive(CloneErrorLookup[cloneindex].allconfig[j][C_AREA],False);
		  }


		  CloneErrorLookup[cloneindex].specifiedconfig[j][C_AREA] = 
		    XtVaCreateManagedWidget ("the_test",
					     xmToggleButtonWidgetClass, form,
					     XmNtopAttachment,          XmATTACH_FORM,
					     XmNbottomAttachment,       XmATTACH_FORM,
					     XmNleftAttachment,         XmATTACH_POSITION,
					     XmNleftPosition,           point4,
					     XmNrightAttachment,        XmATTACH_POSITION,
					     XmNrightPosition,          point5,
					     XmNlabelString,            tempXS,
					     TOGGLETRANSLATE,     TOGGLEINCLUDE,
					     NULL);
		  
		  
		  XmToggleButtonSetState(CloneErrorLookup[cloneindex].specifiedconfig[j][C_AREA],
					 (Boolean)CloneErrorLookup[cloneindex].SpecifiedConfigOn[j][C_AREA],(Boolean)0);
		  
		  
		  
		  XtAddCallback (CloneErrorLookup[cloneindex].specifiedconfig[j][C_AREA], 
				 XmNvalueChangedCallback, toggle_some_areal_clone, (XtPointer)(cloneindex+j*1000));
		  
		  XtManageChild (CloneErrorLookup[cloneindex].specifiedconfig[j][C_AREA]);
		  


		  CloneErrorLookup[cloneindex].allconfiginclude[j][C_AREA] = 
		    XtVaCreateManagedWidget ("Help4",
					     xmPushButtonWidgetClass, form,
					     XmNtopAttachment,    XmATTACH_FORM,
					     XmNtraversalOn,      False,
					     XmNbottomAttachment, XmATTACH_FORM,
					     XmNleftAttachment,   XmATTACH_POSITION,
					     XmNleftPosition,     point6,
					     XmNrightAttachment,  XmATTACH_POSITION,
					     XmNrightPosition,    point7,
					     XmNlabelString,      STRING("Specify Area Features to Include..."),
					     XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					     NULL);
		  
		  mydata  = (MyData *) (malloc(sizeof(MyData)));
		  if(mydata==NULL){printf("myb: out of allocation memory!\n"); ExitWrapper(-1);}
		  
		  mydata->check_num = userData->check_num;
		  mydata->clonenum  = userData->clonenum;
		  mydata->element   = j;
		  mydata->geomtype  = C_AREA;
		  
		  XtAddCallback(CloneErrorLookup[cloneindex].allconfiginclude[j][C_AREA], XmNactivateCallback, 
				(XtCallbackProc)ModelButton3Callback, mydata);
		  
		  XtManageChild (CloneErrorLookup[cloneindex].allconfiginclude[j][C_AREA]);
		  
		  
		  
		  if(
			  (CloneErrorLookup[cloneindex].AllConfigOn[j][C_AREA]==1)||
			  ((Total2DArea+Total3DArea)<=0)
			 )
		    {
		      XtSetSensitive(CloneErrorLookup[cloneindex].allconfiginclude[j][C_AREA],False);
		    }
		  
		}
	      


	    



	      if(clonenum==0)
		{
		  sprintf(title,"%s",PadSpecial(
			  ErrorLookup[errnum].model_index[j][1][C_AREA] +
			  ErrorLookup[errnum].sac_index[j][1][C_AREA]));
		  
		  
		  ErrorLookup[errnum].specwidget[j][1][C_AREA] = 
		    XtVaCreateManagedWidget ("lab1",
					     xmLabelWidgetClass, form,
					     XmNlabelString, STRING(title),
					     XmNtopAttachment,       XmATTACH_FORM,
					     XmNbottomAttachment,    XmATTACH_FORM,

					     XmNleftAttachment,      XmATTACH_WIDGET,
						 XmNleftWidget,          ErrorLookup[errnum].allconfiginclude[j][C_AREA],


					     LABELWTRANSLATE,
					     NULL);
		  XtManageChild (label1);
		}
	      else
		{
		  sprintf(title,"%s",PadSpecial(
			  CloneErrorLookup[cloneindex].model_index[j][1][C_AREA] +
			  CloneErrorLookup[cloneindex].sac_index[j][1][C_AREA]));

		  CloneErrorLookup[cloneindex].specwidget[j][1][C_AREA] = 
		    XtVaCreateManagedWidget ("lab1",
					     xmLabelWidgetClass, form,
					     XmNlabelString, STRING(title),
					     XmNtopAttachment,       XmATTACH_FORM,
					     XmNbottomAttachment,    XmATTACH_FORM,

					     XmNleftAttachment,      XmATTACH_WIDGET,
						 XmNleftWidget,          CloneErrorLookup[cloneindex].allconfiginclude[j][C_AREA],


					     LABELWTRANSLATE,
					     NULL);
		  XtManageChild (label1);
		}
	      








	      XtManageChild (form);
	      
	      
	      form = XtVaCreateWidget ("form.error.editor", xmFormWidgetClass, rowcol,
				       XmNfractionBase,  65,  
				       NULL);

	      
	      
	      button5 = XtVaCreateManagedWidget ("Help4",
						 xmPushButtonWidgetClass, form,
						 XmNtopAttachment,    XmATTACH_FORM,
						 XmNtraversalOn,      False,
						 XmNbottomAttachment, XmATTACH_FORM,
						 XmNleftAttachment,   XmATTACH_POSITION,
						 XmNleftPosition,     point6,
						 XmNrightAttachment,  XmATTACH_POSITION,
						 XmNrightPosition,    point7,
						 XmNlabelString,      STRING("Specify Area Features to Exclude..."),
						 XmNtranslations, XtParseTranslationTable ( translations_global ) ,
						 NULL);
	      
	      
	      mydata  = (MyData *) (malloc(sizeof(MyData)));
	      if(mydata==NULL){printf("myb: out of allocation memory!\n"); ExitWrapper(-1);}
	      
	      mydata->check_num = userData->check_num;
	      mydata->clonenum  = userData->clonenum;
	      mydata->element   = j;
	      mydata->geomtype  = C_AREA;
	      
	      XtAddCallback(button5, XmNactivateCallback, (XtCallbackProc)ModelButton2Callback, mydata);
	      XtManageChild (button5);
	      
          if((Total2DArea+Total3DArea)<=0)
		  {
		    XtSetSensitive(button5,False);
		  }

	      if(clonenum==0)
		{
		  sprintf(title,"%s",PadSpecial(
			  ErrorLookup[errnum].model_index[j][0][C_AREA] +
			  ErrorLookup[errnum].sac_index[j][0][C_AREA]));
		  
		  
		  ErrorLookup[errnum].specwidget[j][0][C_AREA] = 
		    XtVaCreateManagedWidget ("lab1",
					     xmLabelWidgetClass, form,
					     XmNlabelString, STRING(title),
					     XmNtopAttachment,       XmATTACH_FORM,
					     XmNbottomAttachment,    XmATTACH_FORM,

					     XmNleftAttachment,      XmATTACH_WIDGET,
						 XmNleftWidget,          button5,
						 
					     LABELWTRANSLATE,
					     NULL);
		  XtManageChild (label1);
		}
	      else
		{
		  sprintf(title,"%s",PadSpecial(
			  CloneErrorLookup[cloneindex].model_index[j][0][C_AREA] +
			  CloneErrorLookup[cloneindex].sac_index[j][0][C_AREA]));

		  CloneErrorLookup[cloneindex].specwidget[j][0][C_AREA] = 
		    XtVaCreateManagedWidget ("lab1",
					     xmLabelWidgetClass, form,
					     XmNlabelString, STRING(title),
					     XmNtopAttachment,       XmATTACH_FORM,
					     XmNbottomAttachment,    XmATTACH_FORM,

					     XmNleftAttachment,      XmATTACH_WIDGET,
						 XmNleftWidget,          button5,

					     LABELWTRANSLATE,
					     NULL);
		  XtManageChild (label1);
		}


	      XtManageChild(form);
	      
	    }
	  


	  if(
	     ((j==1)&&(ErrorLookup[errnum].Config1[C_GRID]!=2))  ||
	     ((j==2)&&(ErrorLookup[errnum].Config2[C_GRID]!=2))  ||
	     ((j==3)&&(ErrorLookup[errnum].Config3[C_GRID]!=2))  
	     )
	    {
	      
	      
	      
	      form = XtVaCreateWidget ("form.error.editor", xmFormWidgetClass, rowcol,
				       XmNfractionBase,  65,  
				       NULL);
	      
	      
	      
	      label1 = XtVaCreateManagedWidget ("lab1",
						xmLabelWidgetClass, form,
						XmNlabelString, STRING("Gridded Data:"),
						XmNtopAttachment,       XmATTACH_FORM,
						XmNbottomAttachment,    XmATTACH_FORM,
						XmNleftAttachment,      XmATTACH_POSITION,
						XmNleftPosition,        0,
						XmNrightAttachment,     XmATTACH_POSITION,
						XmNrightPosition,       point1,
						LABELWTRANSLATE,
						NULL);
	      XtManageChild (label1);
	      
	      
	      if(clonenum==0)
		{
		  
		  ErrorLookup[errnum].allconfig[j][C_GRID] = 
		    XtVaCreateManagedWidget ("the_test",
					     xmToggleButtonWidgetClass, form,
					     XmNtopAttachment,          XmATTACH_FORM,
					     XmNbottomAttachment,       XmATTACH_FORM,
					     XmNleftAttachment,         XmATTACH_POSITION,
					     XmNleftPosition,           point2,
					     XmNrightAttachment,        XmATTACH_POSITION,
					     XmNrightPosition,          point3,
					     XmNlabelString,            tempXS,
					     TOGGLETRANSLATE,     TOGGLEINCLUDE,
					     NULL);
		  
		  XmToggleButtonSetState(ErrorLookup[errnum].allconfig[j][C_GRID],
					 (Boolean)ErrorLookup[errnum].AllConfigOn[j][C_GRID],(Boolean)0);
		  
		  
		  XtAddCallback (ErrorLookup[errnum].allconfig[j][C_GRID], 
				 XmNvalueChangedCallback, toggle_all_grid_nonclone, (XtPointer)(errnum+j*1000));
		  
		  XtManageChild (ErrorLookup[errnum].allconfig[j][C_GRID]);


		  if(!strcmp(GetVariousPeices(4),"0"))
		  {
            XtSetSensitive(ErrorLookup[errnum].allconfig[j][C_GRID],False);
		  }


		  ErrorLookup[errnum].specifiedconfig[j][C_GRID] = 
		    XtVaCreateManagedWidget ("the_test",
					     xmToggleButtonWidgetClass, form,
					     XmNtopAttachment,          XmATTACH_FORM,
					     XmNbottomAttachment,       XmATTACH_FORM,
					     XmNleftAttachment,         XmATTACH_POSITION,
					     XmNleftPosition,           point4,
					     XmNrightAttachment,        XmATTACH_POSITION,
					     XmNrightPosition,          point5,
					     XmNlabelString,            tempXS,
					     TOGGLETRANSLATE,     TOGGLEINCLUDE,
					     NULL);
		  
		  
		  XmToggleButtonSetState(ErrorLookup[errnum].specifiedconfig[j][C_GRID],
					 (Boolean)ErrorLookup[errnum].SpecifiedConfigOn[j][C_GRID],(Boolean)0);
		  
		  
		  
		  XtAddCallback (ErrorLookup[errnum].specifiedconfig[j][C_GRID], 
				 XmNvalueChangedCallback, toggle_some_grid_nonclone, (XtPointer)(errnum+j*1000));
	      
		  XtManageChild (ErrorLookup[errnum].specifiedconfig[j][C_GRID]);


		  ErrorLookup[errnum].allconfiginclude[j][C_GRID] = 
		    XtVaCreateManagedWidget ("Help4",
					     xmPushButtonWidgetClass, form,
					     XmNtraversalOn,      False,
					     XmNleftAttachment,   XmATTACH_POSITION,
					     XmNleftPosition,     point6,
					     XmNrightAttachment,  XmATTACH_POSITION,
					     XmNrightPosition,    point7,
					     XmNlabelString,      STRING("Specify Gridded Data to Include..."),
					     XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					     NULL);
		  
		  mydata  = (MyData *) (malloc(sizeof(MyData)));
		  if(mydata==NULL){printf("myb: out of allocation memory!\n"); ExitWrapper(-1);}
		  
		  mydata->check_num = userData->check_num;
		  mydata->clonenum  = userData->clonenum;
		  mydata->element   = j;
		  mydata->geomtype  = C_GRID;
		  
		  XtAddCallback(ErrorLookup[errnum].allconfiginclude[j][C_GRID], XmNactivateCallback, 
				(XtCallbackProc)ModelButton3Callback, mydata);
		  
		  XtManageChild (ErrorLookup[errnum].allconfiginclude[j][C_GRID]);
		  
		  
		  if (
			  (ErrorLookup[errnum].AllConfigOn[j][C_GRID]==1)||
			  (!strcmp(GetVariousPeices(4),"0"))
			 )
		    {
		      XtSetSensitive(ErrorLookup[errnum].allconfiginclude[j][C_GRID],False);
		    }
		  		  
		}
	      else
		{
		  CloneErrorLookup[cloneindex].allconfig[j][C_GRID] = 
		    XtVaCreateManagedWidget ("the_test",
					     xmToggleButtonWidgetClass, form,
					     XmNtopAttachment,          XmATTACH_FORM,
					     XmNbottomAttachment,       XmATTACH_FORM,
					     XmNleftAttachment,         XmATTACH_POSITION,
					     XmNleftPosition,           point2,
					     XmNrightAttachment,        XmATTACH_POSITION,
					     XmNrightPosition,          point3,
					     XmNlabelString,            tempXS,
					     TOGGLETRANSLATE,     TOGGLEINCLUDE,
					     NULL);
		  
		  XmToggleButtonSetState(CloneErrorLookup[cloneindex].allconfig[j][C_GRID],
					 (Boolean)CloneErrorLookup[cloneindex].AllConfigOn[j][C_GRID],(Boolean)0);
		  
		  
		  XtAddCallback (CloneErrorLookup[cloneindex].allconfig[j][C_GRID], 
				 XmNvalueChangedCallback, toggle_all_grid_clone, (XtPointer)(cloneindex+j*1000));
		  
		  XtManageChild (CloneErrorLookup[cloneindex].allconfig[j][C_GRID]);
		  
		  
		  if(!strcmp(GetVariousPeices(4),"0"))
		  {
            XtSetSensitive(CloneErrorLookup[cloneindex].allconfig[j][C_GRID],False);
		  }
		  
		  
		  CloneErrorLookup[cloneindex].specifiedconfig[j][C_GRID] = 
		    XtVaCreateManagedWidget ("the_test",
					     xmToggleButtonWidgetClass, form,
					     XmNtopAttachment,          XmATTACH_FORM,
					     XmNbottomAttachment,       XmATTACH_FORM,
					     XmNleftAttachment,         XmATTACH_POSITION,
					     XmNleftPosition,           point4,
					     XmNrightAttachment,        XmATTACH_POSITION,
					     XmNrightPosition,          point5,
					     XmNlabelString,            tempXS,
					     TOGGLETRANSLATE,     TOGGLEINCLUDE,
					     NULL);
		  
		  
		  XmToggleButtonSetState(CloneErrorLookup[cloneindex].specifiedconfig[j][C_GRID],
					 (Boolean)CloneErrorLookup[cloneindex].SpecifiedConfigOn[j][C_GRID],(Boolean)0);
		  
		  
		  
		  XtAddCallback (CloneErrorLookup[cloneindex].specifiedconfig[j][C_GRID], 
				 XmNvalueChangedCallback, toggle_some_grid_clone, (XtPointer)(cloneindex+j*1000));
	      
		  XtManageChild (CloneErrorLookup[cloneindex].specifiedconfig[j][C_GRID]);



		  CloneErrorLookup[cloneindex].allconfiginclude[j][C_GRID] = 
		    XtVaCreateManagedWidget ("Help4",
					     xmPushButtonWidgetClass, form,
					     XmNtraversalOn,      False,
					     XmNleftAttachment,   XmATTACH_POSITION,
					     XmNleftPosition,     point6,
					     XmNrightAttachment,  XmATTACH_POSITION,
					     XmNrightPosition,    point7,
					     XmNlabelString,      STRING("Specify Gridded Data to Include..."),
					     XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					     NULL);
		  
		  mydata  = (MyData *) (malloc(sizeof(MyData)));
		  if(mydata==NULL){printf("myb: out of allocation memory!\n"); ExitWrapper(-1);}
		  
		  mydata->check_num = userData->check_num;
		  mydata->clonenum  = userData->clonenum;
		  mydata->element   = j;
		  mydata->geomtype  = C_GRID;
		  
		  XtAddCallback(CloneErrorLookup[cloneindex].allconfiginclude[j][C_GRID], XmNactivateCallback, 
				(XtCallbackProc)ModelButton3Callback, mydata);
		  
		  XtManageChild (CloneErrorLookup[cloneindex].allconfiginclude[j][C_GRID]);
		  
		  
		  if (CloneErrorLookup[cloneindex].AllConfigOn[j][C_GRID]==1)
		    {
		      XtSetSensitive(CloneErrorLookup[cloneindex].allconfiginclude[j][C_GRID],False);
		    }

		}
	      
	      
	      

	      if(clonenum==0)
		{
		  sprintf(title,"%s",PadSpecial(
			  ErrorLookup[errnum].model_index[j][1][C_GRID] +
			  ErrorLookup[errnum].sac_index[j][1][C_GRID]));
		  
		  
		  ErrorLookup[errnum].specwidget[j][1][C_GRID] = 
		    XtVaCreateManagedWidget ("lab1",
					     xmLabelWidgetClass, form,
					     XmNlabelString, STRING(title),
					     XmNtopAttachment,       XmATTACH_FORM,
					     XmNbottomAttachment,    XmATTACH_FORM,

					     XmNleftAttachment,      XmATTACH_WIDGET,
						 XmNleftWidget,          ErrorLookup[errnum].allconfiginclude[j][C_GRID],


					     LABELWTRANSLATE,
					     NULL);
		  XtManageChild (label1);
		}
	      else
		{
		  sprintf(title,"%s",PadSpecial(
			  CloneErrorLookup[cloneindex].model_index[j][1][C_GRID] +
			  CloneErrorLookup[cloneindex].sac_index[j][1][C_GRID]));

		  CloneErrorLookup[cloneindex].specwidget[j][1][C_GRID] = 
		    XtVaCreateManagedWidget ("lab1",
					     xmLabelWidgetClass, form,
					     XmNlabelString, STRING(title),
					     XmNtopAttachment,       XmATTACH_FORM,
					     XmNbottomAttachment,    XmATTACH_FORM,

					     XmNleftAttachment,      XmATTACH_WIDGET,
						 XmNleftWidget,          CloneErrorLookup[cloneindex].allconfiginclude[j][C_GRID],


					     LABELWTRANSLATE,
					     NULL);
		  XtManageChild (label1);
		}


	      XtManageChild (form);
	      
	      
	      form = XtVaCreateWidget ("form.error.editor", xmFormWidgetClass, rowcol,
				       XmNfractionBase,  65,  
				       NULL);
	      
	      
	      
	      button5 = XtVaCreateManagedWidget ("Help4",
						 xmPushButtonWidgetClass, form,
						 XmNtopAttachment,    XmATTACH_FORM,
						 XmNtraversalOn,      False,
						 XmNbottomAttachment, XmATTACH_FORM,
						 XmNleftAttachment,   XmATTACH_POSITION,
						 XmNleftPosition,     point6,
						 XmNrightAttachment,  XmATTACH_POSITION,
						 XmNrightPosition,    point7,
						 XmNlabelString,      STRING("Specify Gridded Data to Exclude..."),
						 XmNtranslations, XtParseTranslationTable ( translations_global ) ,
						 NULL);
	      
	      
	      mydata  = (MyData *) (malloc(sizeof(MyData)));
	      if(mydata==NULL){printf("myb: out of allocation memory!\n"); ExitWrapper(-1);}
	      
	      mydata->check_num = userData->check_num;
	      mydata->clonenum  = userData->clonenum;
	      mydata->element   = j;
	      mydata->geomtype  = C_GRID;

	      XtAddCallback(button5, XmNactivateCallback, (XtCallbackProc)ModelButton2Callback, mydata);
	      XtManageChild (button5);
	      

          if(!strcmp(GetVariousPeices(4),"0"))
		  {
            XtSetSensitive(button5,False);
		  }



	      if(clonenum==0)
		{
		  sprintf(title,"%s",PadSpecial(
			  ErrorLookup[errnum].model_index[j][0][C_GRID] +
			  ErrorLookup[errnum].sac_index[j][0][C_GRID]));
		  
		  
		  ErrorLookup[errnum].specwidget[j][0][C_GRID] = 
		    XtVaCreateManagedWidget ("lab1",
					     xmLabelWidgetClass, form,
					     XmNlabelString, STRING(title),
					     XmNtopAttachment,       XmATTACH_FORM,
					     XmNbottomAttachment,    XmATTACH_FORM,

 					     XmNleftAttachment,      XmATTACH_WIDGET,
						 XmNleftWidget,          button5,


					     LABELWTRANSLATE,
					     NULL);
		  XtManageChild (label1);
		}
	      else
		{
		  sprintf(title,"%s",PadSpecial(
			  CloneErrorLookup[cloneindex].model_index[j][0][C_GRID] +
			  CloneErrorLookup[cloneindex].sac_index[j][0][C_GRID]));

		  CloneErrorLookup[cloneindex].specwidget[j][0][C_GRID] = 
		    XtVaCreateManagedWidget ("lab1",
					     xmLabelWidgetClass, form,
					     XmNlabelString, STRING(title),
					     XmNtopAttachment,       XmATTACH_FORM,
					     XmNbottomAttachment,    XmATTACH_FORM,

					     XmNleftAttachment,      XmATTACH_WIDGET,
						 XmNleftWidget,          button5,


					     LABELWTRANSLATE,
					     NULL);
		  XtManageChild (label1);
		}



	      XtManageChild(form);
	      
	    }
	}


      sep = XtVaCreateManagedWidget ("sep1",
				     xmSeparatorWidgetClass, rowcol,
				     NULL);


      form = XtVaCreateWidget ("form.error.editor", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,  
			       NULL);
      
      button = XtVaCreateManagedWidget ("Help4",
					xmPushButtonWidgetClass, form,
					XmNtopAttachment,    XmATTACH_FORM,
					XmNtraversalOn,      False,
					XmNbottomAttachment, XmATTACH_FORM,
					XmNleftAttachment,   XmATTACH_POSITION,
					XmNleftPosition,     0,
					XmNrightAttachment,  XmATTACH_POSITION,
					XmNrightPosition,    50,
					XmNlabelString,      STRING("Help"),
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					NULL);
      XtAddCallback (button, XmNactivateCallback,
		     help_actor_callback, (XtPointer)errnum);


      button = XtVaCreateManagedWidget ("Help4",
					xmPushButtonWidgetClass, form,
					XmNtopAttachment,    XmATTACH_FORM,
					XmNtraversalOn,      False,
					XmNbottomAttachment, XmATTACH_FORM,
					XmNleftAttachment,   XmATTACH_POSITION,
					XmNleftPosition,     50,
					XmNrightAttachment,  XmATTACH_POSITION,
					XmNrightPosition,    100,
					XmNlabelString,      STRING("Done"),
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					NULL);
      XtAddCallback (button, XmNactivateCallback,
		     kill_actor_callback, (XtPointer)errnum);






      XtManageChild(form);
      
      
      XtManageChild(rowcol);
      
      MyPopup  (actorhead);

      XtAddCallback(actorhead,XmNdestroyCallback,(XtCallbackProc)ActorDeath,userData);       


      XtVaGetValues(actorhead, XmNwidth,     &Pwidth, XmNheight, &Pheight, NULL);	  
      XtVaSetValues(actorhead, XmNminWidth,  Pwidth,  NULL);
      XtVaSetValues(actorhead, XmNmaxWidth,  Pwidth,  NULL);
      XtVaSetValues(actorhead, XmNminHeight, Pheight, NULL);
      XtVaSetValues(actorhead, XmNmaxHeight, Pheight, NULL);
      
      XtAddEventHandler(actorhead,StructureNotifyMask,False, myResizeHandler, (XtPointer)((int)Pheight));

      if(cloneindex<0)
	{
	  ErrorLookup[errnum].CSD = actorhead;
	}
      else
	{
	  CloneErrorLookup[cloneindex].CSD = actorhead;
	}

      MY_ACTOR_UP(userData,1);
    }
}









void ActorCallback(Widget w, MyData *userData, XtPointer callData)
{
  int n=0,i=0,j=0,firstmax=0,secondmax=0,thirdmax=0,wasted;
  Arg resources[20];
  Widget form,rowcol,label1,C_menu,S_menu,D_menu,button,button5,actorhead;
  char title[200],temp[50];
  SpecialMenuItem C[NUM_C],S[NUM_S+2],D[NUM_D+2];
  XmString str;
  MyData *mydata;
  int errnum     = userData->check_num;
  int clonenum   = userData->clonenum;
  int override   = (int)callData;
  int cloneindex = -1;

  if(clonenum>0)
    {
      cloneindex = GetCloneIndex(clonenum,errnum);
    }


  for(i=0;i<NUM_C;i++)
    {
      sprintf(C[i].label ,"%s",CNAME[i]); 
      C[i].cclass = &xmToggleButtonWidgetClass;
      C[i].callback_data = (errnum*1000) + i;
    }

  
  sprintf(S[0].label,"Unassigned");    S[0].cclass=&xmToggleButtonWidgetClass; S[0].callback_data=(errnum*1000) + 0;
  sprintf(S[1].label,"Applique");      S[1].cclass=&xmToggleButtonWidgetClass; S[1].callback_data=(errnum*1000) + 1;
  sprintf(S[2].label,"Coverage");      S[2].cclass=&xmToggleButtonWidgetClass; S[2].callback_data=(errnum*1000) + 2;
  sprintf(S[3].label,"Sub-Surface");   S[3].cclass=&xmToggleButtonWidgetClass; S[3].callback_data=(errnum*1000) + 4;
  sprintf(S[4].label,"Surface");       S[4].cclass=&xmToggleButtonWidgetClass; S[4].callback_data=(errnum*1000) + 5;
  sprintf(S[5].label,"Select All");    S[5].cclass=&xmPushButtonWidgetClass;   S[5].callback_data=errnum;
  sprintf(S[6].label,"De-Select All"); S[6].cclass=&xmPushButtonWidgetClass;   S[6].callback_data=errnum;
  
 


  sprintf(D[0].label ,"Unassigned");    D[0].cclass=&xmToggleButtonWidgetClass; D[0].callback_data =(errnum*1000) + 0;
  sprintf(D[1].label ,"Air Mobility");  D[1].cclass=&xmToggleButtonWidgetClass; D[1].callback_data =(errnum*1000) + 1;
  sprintf(D[2].label ,"Air Obstacle");  D[2].cclass=&xmToggleButtonWidgetClass; D[2].callback_data =(errnum*1000) + 2;
  sprintf(D[3].label ,"Boundary");      D[3].cclass=&xmToggleButtonWidgetClass; D[3].callback_data =(errnum*1000) + 3; 
  sprintf(D[4].label ,"Bridging");      D[4].cclass=&xmToggleButtonWidgetClass; D[4].callback_data =(errnum*1000) + 4;
  sprintf(D[5].label ,"Cultural");      D[5].cclass=&xmToggleButtonWidgetClass; D[5].callback_data =(errnum*1000) + 5;
  sprintf(D[6].label ,"Inland Water");  D[6].cclass=&xmToggleButtonWidgetClass; D[6].callback_data =(errnum*1000) + 6;
  sprintf(D[7].label ,"Land Mobility"); D[7].cclass=&xmToggleButtonWidgetClass; D[7].callback_data =(errnum*1000) + 7;
  sprintf(D[8].label ,"Land Obstacle"); D[8].cclass=&xmToggleButtonWidgetClass; D[8].callback_data =(errnum*1000) + 8;
  sprintf(D[9].label ,"Military Use");  D[9].cclass=&xmToggleButtonWidgetClass; D[9].callback_data =(errnum*1000) + 9;
  sprintf(D[10].label,"Open Water");    D[10].cclass= &xmToggleButtonWidgetClass; D[10].callback_data=(errnum*1000) + 10;
  sprintf(D[11].label,"Terrain");       D[11].cclass= &xmToggleButtonWidgetClass; D[11].callback_data=(errnum*1000) + 11;
  sprintf(D[12].label,"Vegetation");    D[12].cclass= &xmToggleButtonWidgetClass; D[12].callback_data=(errnum*1000) + 12;
  sprintf(D[13].label,"Maritime Mobility"); D[13].cclass= &xmToggleButtonWidgetClass;D[13].callback_data=(errnum*1000)+13;
  sprintf(D[14].label,"Maritime Obstacle"); D[14].cclass= &xmToggleButtonWidgetClass;D[14].callback_data=(errnum*1000)+14;
  sprintf(D[15].label,"Maritime Culture");  D[15].cclass= &xmToggleButtonWidgetClass;D[15].callback_data=(errnum*1000)+15;
  sprintf(D[16].label,"Weather");       D[16].cclass= &xmToggleButtonWidgetClass; D[16].callback_data=(errnum*1000) + 16;
  sprintf(D[17].label,"Space");         D[17].cclass= &xmToggleButtonWidgetClass; D[17].callback_data=(errnum*1000) + 17;
  sprintf(D[18].label,"Descriptive");   D[18].cclass= &xmToggleButtonWidgetClass; D[18].callback_data=(errnum*1000) + 18;
  sprintf(D[19].label,"Select All");    D[19].cclass= &xmPushButtonWidgetClass;   D[19].callback_data=errnum;
  sprintf(D[20].label,"De-Select All"); D[20].cclass= &xmPushButtonWidgetClass;   D[20].callback_data=errnum;
 


  if((MY_ACTOR_UP(userData,0)==0) || (override==17))
    {
      

      n=0;
      XtSetArg(resources[n],  XmNdeleteResponse, XmDESTROY); n++; 
      
      if(clonenum==0)
	{
	  sprintf(title,"Selection of data to be checked for:  %s",ErrorLookup[errnum].name);
	}
      else
	{
	  sprintf(title,"Selection of data to be checked for:  %s (additional #%d)",
		  ErrorLookup[errnum].name,clonenum);
	}


      while(title[i]!='\0')
	{
	  if(title[i]=='\n')
	    {title[i]=' ';}
	  i++;
	}

      
      actorhead = XtCreatePopupShell
	(title,topLevelShellWidgetClass,w,resources,n);
	
      
      rowcol = XtVaCreateWidget ("rowcol",
				 xmRowColumnWidgetClass, actorhead, NULL);
      
      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,  
			       NULL);      
      
      sprintf(title,"CSD to be checked for %s:",ErrorLookup[errnum].name);

      label1 = XtVaCreateManagedWidget ("lab1",
					xmLabelWidgetClass, form,
					XmNlabelString, STRING(title),
					XmNtopAttachment,          XmATTACH_FORM,
					XmNbottomAttachment,       XmATTACH_FORM,
					XmNleftAttachment,         XmATTACH_POSITION,
					XmNleftPosition,           0,
					XmNrightAttachment,        XmATTACH_POSITION,
					XmNrightPosition,          100,
					LABELWTRANSLATE,
					NULL);
      XtManageChild(form);
      
      form = XtVaCreateWidget ("form.actor.errors", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  107,  
			       NULL);
    
   
     label1 = XtVaCreateManagedWidget ("lab1",
					xmLabelWidgetClass, form,
					XmNlabelString, STRING("Configuration"),
					XmNtopAttachment,       XmATTACH_FORM,
					XmNbottomAttachment,    XmATTACH_FORM,
					XmNleftAttachment,     XmATTACH_POSITION,
					XmNleftPosition,       10,
					XmNrightAttachment,     XmATTACH_POSITION,
					XmNrightPosition,       43,
				       LABELWTRANSLATE,
					NULL);
      label1 = XtVaCreateManagedWidget ("lab1",
					xmLabelWidgetClass, form,
					XmNlabelString, STRING("Stratum"),
					XmNtopAttachment,      XmATTACH_FORM,
					XmNbottomAttachment,   XmATTACH_FORM,
					XmNleftAttachment,     XmATTACH_POSITION,
					XmNleftPosition,       43,
					XmNrightAttachment,    XmATTACH_POSITION,
					XmNrightPosition,      59,
					LABELWTRANSLATE,
					NULL);
      
      if(NGA_TYPE==1)
	{
	  label1 = XtVaCreateManagedWidget ("lab1",
					    xmLabelWidgetClass, form,
					    XmNlabelString, STRING("Functional Category"),
					    XmNtopAttachment,      XmATTACH_FORM,
					    XmNbottomAttachment,   XmATTACH_FORM,
					    XmNleftAttachment,     XmATTACH_POSITION,
					    XmNleftPosition,       59,
					    XmNrightAttachment,    XmATTACH_POSITION,
					    XmNrightPosition,      81,
					    LABELWTRANSLATE,
					    NULL);
	}
      else
	{
	  label1 = XtVaCreateManagedWidget ("lab1",
					    xmLabelWidgetClass, form,
					    XmNlabelString, STRING("Domain"),
					    XmNtopAttachment,      XmATTACH_FORM,
					    XmNbottomAttachment,   XmATTACH_FORM,
					    XmNleftAttachment,     XmATTACH_POSITION,
					    XmNleftPosition,       59,
					    XmNrightAttachment,    XmATTACH_POSITION,
					    XmNrightPosition,      81,
					    LABELWTRANSLATE,
					    NULL);
	}


      XtManageChild(form);
           
      for(j=1;j<=ErrorLookup[errnum].participants;j++)
	{
	  
	  form = XtVaCreateWidget ("form.error.editor", xmFormWidgetClass, rowcol,
				   XmNfractionBase,  107,  
				   NULL);
	  
	  
	  if(j==1)
	    {	  
	      label1 = XtVaCreateManagedWidget ("lab1",
						xmLabelWidgetClass, form,
						XmNlabelString, STRING("Primary:"),
						XmNtopAttachment,       XmATTACH_FORM,
						XmNbottomAttachment,    XmATTACH_FORM,
						XmNleftAttachment,      XmATTACH_FORM,
						XmNrightAttachment,     XmATTACH_POSITION,
						XmNrightPosition,       10,
						LABELWTRANSLATE,
						NULL);
	    }
	  else if(j==2)
	    {	  
	      label1 = XtVaCreateManagedWidget ("lab1",
						xmLabelWidgetClass, form,
						XmNlabelString, STRING("Secondary:"),
						XmNtopAttachment,       XmATTACH_FORM,
						XmNbottomAttachment,    XmATTACH_FORM,
						XmNleftAttachment,      XmATTACH_FORM,
						XmNrightAttachment,     XmATTACH_POSITION,
						XmNrightPosition,       10,
						LABELWTRANSLATE,
						NULL);
	    }
	  else if(j==3)
	    {	  
	      label1 = XtVaCreateManagedWidget ("lab1",
						xmLabelWidgetClass, form,
						XmNlabelString, STRING("Tertiary:"),
						XmNtopAttachment,       XmATTACH_FORM,
						XmNbottomAttachment,    XmATTACH_FORM,
						XmNleftAttachment,      XmATTACH_FORM,
						XmNrightAttachment,     XmATTACH_POSITION,
						XmNrightPosition,       10,
						LABELWTRANSLATE,
						NULL);
	    }
	  else
	    {
	      printf("bad number of participants for condition number %d (%d)\n",
		     errnum,ErrorLookup[errnum].participants);
	    }

	  firstmax  = 0;
	  secondmax = 0;
	  thirdmax  = 0;

  
	  C_menu = SpecialBuildToggleMenu (form,C,NUM_C  ,errnum,1+((j-1)*10),&firstmax ,clonenum);
	  S_menu = SpecialBuildToggleMenu (form,S,NUM_S+2-1,errnum,2+((j-1)*10),&secondmax,clonenum);
	  D_menu = SpecialBuildToggleMenu (form,D,NUM_D+2,errnum,3+((j-1)*10),&thirdmax ,clonenum);



	  firstmax  = firstmax + 7; 
	  secondmax = secondmax+ 7;
	  thirdmax  = thirdmax + 7;

	  wasted = (33-firstmax)/2; 
	  XtVaSetValues(C_menu,  
			XmNleftAttachment,  XmATTACH_POSITION,
			XmNleftPosition,    10+wasted,
			XmNrightAttachment,  XmATTACH_POSITION,
			XmNrightPosition,    43,
			XmNtopAttachment,    XmATTACH_FORM,
			XmNbottomAttachment, XmATTACH_FORM,
			NULL);
	  XtManageChild (C_menu);

	  
	  wasted = (16-secondmax)/2;
	  XtVaSetValues(S_menu,  
			XmNleftAttachment,   XmATTACH_POSITION,
			XmNleftPosition,     43+wasted,
			XmNrightAttachment,  XmATTACH_POSITION,
			XmNrightPosition,    59,
			XmNtopAttachment,    XmATTACH_FORM,
			XmNbottomAttachment, XmATTACH_FORM,
			NULL);
	  XtManageChild (S_menu);
	  
	  wasted = (22-thirdmax)/2; 
	  XtVaSetValues(D_menu,  
			XmNleftAttachment,   XmATTACH_POSITION,
			XmNleftPosition,     59+wasted,
			XmNrightAttachment,  XmATTACH_POSITION,
			XmNrightPosition,    81,
			XmNtopAttachment,    XmATTACH_FORM,
			XmNbottomAttachment, XmATTACH_FORM,
			NULL);
	  XtManageChild (D_menu);

	  if(NGA_TYPE==1)
	    {
	      sprintf(temp,"exclusions...");
	    }
	  else
	    {
	      sprintf(temp,"EDCS\nexclusions...");
	    }

	  str = XmStringCreateLtoR (temp, "mytag1");
	  
	  button5 = XtVaCreateManagedWidget ("Help4",
					     xmPushButtonWidgetClass, form,
					     XmNtopAttachment,    XmATTACH_FORM,
					     XmNtraversalOn,      False,
					     XmNbottomAttachment, XmATTACH_FORM,
					     XmNleftAttachment,   XmATTACH_POSITION,
					     XmNleftPosition,     81,
					     XmNrightAttachment,  XmATTACH_POSITION,
					     XmNrightPosition,    94,
					     XmNlabelString,      str,
					     XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					     NULL);


	  mydata  = (MyData *) (malloc(sizeof(MyData)));
	  if(mydata==NULL){printf("myb: out of allocation memory!\n"); ExitWrapper(-1);}
	  
	  mydata->check_num = userData->check_num;
	  mydata->clonenum  = userData->clonenum;
	  mydata->element   = j;

	  XtAddCallback(button5, XmNactivateCallback, (XtCallbackProc)ModelButton2Callback, mydata);
	  XtManageChild (button5);
	 
	  if(NGA_TYPE==1)
	    {
	      sprintf(temp,"inclusions...");
	    }
	  else
	    {
	      sprintf(temp,"EDCS\ninclusions...");
	    }

	  str = XmStringCreateLtoR (temp, "mytag1");
	
	  button5 = XtVaCreateManagedWidget ("Help4",
					     xmPushButtonWidgetClass, form,
					     XmNtopAttachment,    XmATTACH_FORM,
					     XmNtraversalOn,      False,
					     XmNbottomAttachment, XmATTACH_FORM,
					     XmNleftAttachment,   XmATTACH_POSITION,
					     XmNleftPosition,     94,
					     XmNrightAttachment,  XmATTACH_POSITION,
					     XmNrightPosition,    107,
					     XmNlabelString,      str,
					     XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					     NULL);

	  mydata  = (MyData *) (malloc(sizeof(MyData)));
	  if(mydata==NULL){printf("myb: out of allocation memory!\n"); ExitWrapper(-1);}
	  
	  mydata->check_num = userData->check_num;
	  mydata->clonenum  = userData->clonenum;
	  mydata->element   = j;

	  XtAddCallback(button5, XmNactivateCallback, (XtCallbackProc)ModelButton3Callback, mydata);

	  XtManageChild (button5);
     
	  XtManageChild(form);
	}

      form = XtVaCreateWidget ("form.error.editor", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,  
			       NULL);
      
      button = XtVaCreateManagedWidget ("Help4",
					xmPushButtonWidgetClass, form,
					XmNtopAttachment,    XmATTACH_FORM,
					XmNtraversalOn,      False,
					XmNbottomAttachment, XmATTACH_FORM,
					XmNleftAttachment,   XmATTACH_POSITION,
					XmNleftPosition,     40,
					XmNrightAttachment,  XmATTACH_POSITION,
					XmNrightPosition,    60,
					XmNlabelString,      STRING("Done"),
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					NULL);
      XtAddCallback (button, XmNactivateCallback,
		     kill_actor_callback, (XtPointer)errnum);
      XtManageChild(form);
      
      
      XtManageChild(rowcol);
      
      MyPopup  (actorhead);
      XtAddCallback(actorhead,XmNdestroyCallback,(XtCallbackProc)ActorDeath,userData);       


      if(cloneindex<0)
	{
	  ErrorLookup[errnum].CSD = actorhead;
	}
      else
	{
	  CloneErrorLookup[cloneindex].CSD = actorhead;
	}


      MY_ACTOR_UP(userData,1);
    }
}






int GetCloneIndex(int clonenum,int errnum)
{
  int index;
  int foundone=0;
  
  for(index=0;index<CLONE_DEFINITIONS;index++)
    {
      if(CloneErrorLookup[index].CloneNumber==errnum)
	{
	  foundone++;
	  if(foundone==clonenum)
	    {
	      return index;
	    }
	}
    }

  if(CLONEDEBUG==1)
    {
      printf("bad news in clone 5, %d %d %d\n",errnum,foundone,clonenum);
    }

  printf("\nfailed to find cloneindex for %d %d\n",clonenum,errnum);
  printf("...<instance %d of inspection %s>\n",clonenum+1,ErrorLookup[errnum].name);


  return 0;
}





double GetSens(int clonenum,int errnum, int tolnum)
{
  int index;
  int foundone=0;


  if(clonenum==0)
  {
      if(tolnum==1)
	{
	  return ErrorLookup[errnum].sensitivity;
	}
      else if(tolnum==2)
	{
	  return ErrorLookup[errnum].sensitivity2;
	}
      else if(tolnum==3)
	{
	  return ErrorLookup[errnum].sensitivity3;
	}
      else if(tolnum==4)
	{
	  return ErrorLookup[errnum].sensitivity4;
	}
      else if(tolnum==5)
	{
	  return ErrorLookup[errnum].sensitivity5;
	}
      else if(tolnum==6)
	{
	  return ErrorLookup[errnum].sensitivity6;
	}
      else
	{
      XBell(mydisplay,50);
	  printf("BAD combo GS1 %d\n",tolnum);
	}      
  }




  for(index=0;index<CLONE_DEFINITIONS;index++)
    {
      if(CloneErrorLookup[index].CloneNumber==errnum)
	{
	  foundone++;
	  if(foundone==clonenum)
	    {
	      break;
	    }
	}
    }
  if(index==CLONE_DEFINITIONS)
    {
      printf("bad news in clone, %d %d %d\n",errnum,foundone,clonenum);
    }
  else
    {
      if(tolnum==1)
	{
	  return CloneErrorLookup[index].sensitivity;
	}
      else if(tolnum==2)
	{
	  return CloneErrorLookup[index].sensitivity2;
	}
      else if(tolnum==3)
	{
	  return CloneErrorLookup[index].sensitivity3;
	}
      else if(tolnum==4)
	{
	  return CloneErrorLookup[index].sensitivity4;
	}
      else if(tolnum==5)
	{
	  return CloneErrorLookup[index].sensitivity5;
	}
      else if(tolnum==6)
	{
	  return CloneErrorLookup[index].sensitivity6;
	}
      else
	{
      XBell(mydisplay,50);
	  printf("BAD combo %d\n",tolnum);
	}      
    }
  return 0;
}






void SensitivityCallback(Widget w, MyData *userData, XtPointer callData)
{
  int n=0,i=0,full,extra,tolerancenum,leftpos,rightpos;
  char temp[1000],tempstr[1000];
  Widget rowcol,form,exitbutton,sep,sens_head,text_sen_w,text_sen2_w;
  Arg resources[20];
  static int tempnum,bignum;
  int errnum   = userData->check_num;
  int clonenum = userData->clonenum;
  int cloneindex;

  if(CLONEDEBUG==1)
    {
      printf("have clonenum %d with check %d\n",clonenum,errnum);
    }

  tempnum = errnum;
  bignum = tempnum + 1000;

  if(clonenum>0)
    {
      cloneindex = GetCloneIndex(clonenum,errnum);
    }
  else
    {
      cloneindex = -1;
    }

  if(MY_SENS_UP(userData,0)==1)
    {
      if(cloneindex<0)
        {
          ResetWidget(ErrorLookup[errnum].sens_head);
        }
      else
        {
          ResetWidget(CloneErrorLookup[cloneindex].sens_head);
        }
    }
  else
    {
      XtSetArg(resources[n],  XmNdeleteResponse, XmDESTROY); n++; 
      
	  if(IsNetCheck(errnum))
	  {
	    sprintf(temp,"Parameter modification for network creation/viewing");
	  }
	  else
	  {
	    sprintf(temp,"Parameter modification for condition: %s",ErrorLookup[errnum].name);
	  }

      i=0;
      while(temp[i]!='\0')
	{
	  if(temp[i]=='\n')
	    {temp[i]=' ';}
	  i++;
	}

      
      sens_head = XtCreatePopupShell
	(temp,topLevelShellWidgetClass,XtParent(XtParent(XtParent(w))),resources,n);
      
      rowcol = XtVaCreateWidget ("rowcol",
				 xmRowColumnWidgetClass, sens_head, NULL);
      

      
   if(ErrorLookup[errnum].numthresholds>0)
	{
      full = (int)ErrorLookup[errnum].numthresholds/2;
	  extra = ErrorLookup[errnum].numthresholds%2;
	  tolerancenum = 1;


	  for(i=0;i<full;i++)
	  {
        form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,  
			       NULL);

        sprintf(tempstr,"%s Tolerance (units: %s):",GetToleranceNumName(tolerancenum),GetToleranceUnits(tolerancenum,errnum));

        XtVaCreateManagedWidget ("",
				       xmLabelWidgetClass, form,
				       XmNtopAttachment,    XmATTACH_FORM,
				       XmNbottomAttachment, XmATTACH_FORM,
				       XmNrightAttachment,  XmATTACH_POSITION,
				       XmNrightPosition,    50,
				       XmNleftAttachment,   XmATTACH_POSITION,
				       XmNleftPosition,     0,
				       XmNalignment,        XmALIGNMENT_CENTER,
				       XmNlabelString,      STRING(tempstr),
				       LABELWTRANSLATE,
				       NULL);

		tolerancenum = tolerancenum + 1;

        sprintf(tempstr,"%s Tolerance (units: %s):",GetToleranceNumName(tolerancenum),GetToleranceUnits(tolerancenum,errnum));

        XtVaCreateManagedWidget ("",
				       xmLabelWidgetClass, form,
				       XmNtopAttachment,    XmATTACH_FORM,
				       XmNbottomAttachment, XmATTACH_FORM,
				       XmNrightAttachment,  XmATTACH_POSITION,
				       XmNrightPosition,    100,
				       XmNleftAttachment,   XmATTACH_POSITION,
				       XmNleftPosition,     50,
				       XmNalignment,        XmALIGNMENT_CENTER,
				       XmNlabelString,      STRING(tempstr),
				       LABELWTRANSLATE,
				       NULL);

		tolerancenum = tolerancenum + 1;

        XtManageChild(form);




		

        if(
			(((tolerancenum-2)==1)&&(ErrorLookup[errnum].tol_desc1!=NULL)) ||
			(((tolerancenum-2)==3)&&(ErrorLookup[errnum].tol_desc3!=NULL)) ||
			(((tolerancenum-2)==5)&&(ErrorLookup[errnum].tol_desc5!=NULL)) ||
			(((tolerancenum-1)==2)&&(ErrorLookup[errnum].tol_desc2!=NULL)) ||
			(((tolerancenum-1)==4)&&(ErrorLookup[errnum].tol_desc4!=NULL)) ||
			(((tolerancenum-1)==6)&&(ErrorLookup[errnum].tol_desc6!=NULL))
		  )
		{
          form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,  
			       NULL);

		  if(((tolerancenum-2)==1)&&(ErrorLookup[errnum].tol_desc1!=NULL))
		  {
            XtVaCreateManagedWidget ("",
				       xmLabelWidgetClass, form,
				       XmNtopAttachment,    XmATTACH_FORM,
				       XmNbottomAttachment, XmATTACH_FORM,
				       XmNrightAttachment,  XmATTACH_POSITION,
				       XmNrightPosition,    50,
				       XmNleftAttachment,   XmATTACH_POSITION,
				       XmNleftPosition,     0,
				       XmNalignment,        XmALIGNMENT_CENTER,
				       XmNlabelString,      STRING(ErrorLookup[errnum].tol_desc1),
				       LABELWTRANSLATE,
				       NULL);
		  }
		  if(((tolerancenum-2)==3)&&(ErrorLookup[errnum].tol_desc3!=NULL))
		  {
            XtVaCreateManagedWidget ("",
				       xmLabelWidgetClass, form,
				       XmNtopAttachment,    XmATTACH_FORM,
				       XmNbottomAttachment, XmATTACH_FORM,
				       XmNrightAttachment,  XmATTACH_POSITION,
				       XmNrightPosition,    50,
				       XmNleftAttachment,   XmATTACH_POSITION,
				       XmNleftPosition,     0,
				       XmNalignment,        XmALIGNMENT_CENTER,
				       XmNlabelString,      STRING(ErrorLookup[errnum].tol_desc3),
				       LABELWTRANSLATE,
				       NULL);
		  }
		  if(((tolerancenum-2)==5)&&(ErrorLookup[errnum].tol_desc5!=NULL))
		  {
            XtVaCreateManagedWidget ("",
				       xmLabelWidgetClass, form,
				       XmNtopAttachment,    XmATTACH_FORM,
				       XmNbottomAttachment, XmATTACH_FORM,
				       XmNrightAttachment,  XmATTACH_POSITION,
				       XmNrightPosition,    50,
				       XmNleftAttachment,   XmATTACH_POSITION,
				       XmNleftPosition,     0,
				       XmNalignment,        XmALIGNMENT_CENTER,
				       XmNlabelString,      STRING(ErrorLookup[errnum].tol_desc5),
				       LABELWTRANSLATE,
				       NULL);
		  }
		  if(((tolerancenum-1)==2)&&(ErrorLookup[errnum].tol_desc2!=NULL))
		  {
            XtVaCreateManagedWidget ("",
				       xmLabelWidgetClass, form,
				       XmNtopAttachment,    XmATTACH_FORM,
				       XmNbottomAttachment, XmATTACH_FORM,
				       XmNrightAttachment,  XmATTACH_POSITION,
				       XmNrightPosition,    100,
				       XmNleftAttachment,   XmATTACH_POSITION,
				       XmNleftPosition,     50,
				       XmNalignment,        XmALIGNMENT_CENTER,
				       XmNlabelString,      STRING(ErrorLookup[errnum].tol_desc2),
				       LABELWTRANSLATE,
				       NULL);
		  }
		  if(((tolerancenum-1)==4)&&(ErrorLookup[errnum].tol_desc4!=NULL))
		  {
            XtVaCreateManagedWidget ("",
				       xmLabelWidgetClass, form,
				       XmNtopAttachment,    XmATTACH_FORM,
				       XmNbottomAttachment, XmATTACH_FORM,
				       XmNrightAttachment,  XmATTACH_POSITION,
				       XmNrightPosition,    100,
				       XmNleftAttachment,   XmATTACH_POSITION,
				       XmNleftPosition,     50,
				       XmNalignment,        XmALIGNMENT_CENTER,
				       XmNlabelString,      STRING(ErrorLookup[errnum].tol_desc4),
				       LABELWTRANSLATE,
				       NULL);
		  }
		  if(((tolerancenum-1)==6)&&(ErrorLookup[errnum].tol_desc6!=NULL))
		  {
            XtVaCreateManagedWidget ("",
				       xmLabelWidgetClass, form,
				       XmNtopAttachment,    XmATTACH_FORM,
				       XmNbottomAttachment, XmATTACH_FORM,
				       XmNrightAttachment,  XmATTACH_POSITION,
				       XmNrightPosition,    100,
				       XmNleftAttachment,   XmATTACH_POSITION,
				       XmNleftPosition,     50,
				       XmNalignment,        XmALIGNMENT_CENTER,
				       XmNlabelString,      STRING(ErrorLookup[errnum].tol_desc6),
				       LABELWTRANSLATE,
				       NULL);
		  }


          XtManageChild(form);
		}

		



		

        form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,  
			       NULL);

	    sprintf(temp,"%lf",GetSens(clonenum,errnum,tolerancenum-2));

	    
        text_sen_w = XtVaCreateManagedWidget ("text_w",
						xmTextFieldWidgetClass, form,	  
						XmNvalue,           temp,
						XmNtraversalOn,     True,
						XmNrightAttachment, XmATTACH_POSITION,
						XmNrightPosition,   50,
						XmNleftAttachment,  XmATTACH_POSITION,
						XmNleftPosition,    0,
						XmNmaxLength,       15,
                        XmNtranslations,    XtParseTranslationTable ( translations_paste ) ,
						NULL);

		userData->Swid_to_pass[tolerancenum-2] = text_sen_w;

		if((tolerancenum-2)==1)
		{
	      XtAddCallback (text_sen_w, XmNactivateCallback,
			     (XtCallbackProc)print_first_result, userData);
		}
		if((tolerancenum-2)==3)
		{
	      XtAddCallback (text_sen_w, XmNactivateCallback,
			     (XtCallbackProc)print_third_result, userData);
		}
		if((tolerancenum-2)==5)
		{
	      XtAddCallback (text_sen_w, XmNactivateCallback,
			     (XtCallbackProc)print_fifth_result, userData);
		}
	    


   	     sprintf(temp,"%lf",GetSens(clonenum,errnum,tolerancenum-1));
	 
         text_sen2_w = XtVaCreateManagedWidget ("text_w",
						     xmTextFieldWidgetClass, form,	  
						     XmNvalue,           temp,
						     XmNtraversalOn,     True,
						     XmNrightAttachment, XmATTACH_POSITION,
						     XmNrightPosition,   100,
						     XmNleftAttachment,  XmATTACH_POSITION,
						     XmNleftPosition,    50,
						     XmNmaxLength,       15,
                             XmNtranslations,    XtParseTranslationTable ( translations_paste ) ,
						     NULL);

		 userData->Swid_to_pass[tolerancenum-1] = text_sen2_w;

		if((tolerancenum-1)==2)
		{
	      XtAddCallback (text_sen2_w, XmNactivateCallback,
			     (XtCallbackProc)print_second_result, userData);
		}
		if((tolerancenum-1)==4)
		{
	      XtAddCallback (text_sen2_w, XmNactivateCallback,
			     (XtCallbackProc)print_fourth_result, userData);
		}
		if((tolerancenum-1)==6)
		{
	      XtAddCallback (text_sen2_w, XmNactivateCallback,
			     (XtCallbackProc)print_sixth_result, userData);
		}
		

         XtManageChild(form);

		





	  }

	  if(extra==1)
	  {

        if(tolerancenum==1)
		{
          leftpos = 0;
		  rightpos = 100;
		}
		else
		{
          leftpos = 0;
		  rightpos = 50;
		}

        form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,  
			       NULL);
	 
        sprintf(tempstr,"%s Tolerance (units: %s):",GetToleranceNumName(tolerancenum),GetToleranceUnits(tolerancenum,errnum));

        XtVaCreateManagedWidget ("",
				       xmLabelWidgetClass, form,
				       XmNtopAttachment,    XmATTACH_FORM,
				       XmNbottomAttachment, XmATTACH_FORM,
				       XmNrightAttachment,  XmATTACH_POSITION,
				       XmNrightPosition,    rightpos,
				       XmNleftAttachment,   XmATTACH_POSITION,
				       XmNleftPosition,     leftpos,
				       XmNalignment,        XmALIGNMENT_CENTER,
				       XmNlabelString,      STRING(tempstr),
				       LABELWTRANSLATE,
				       NULL);
       XtManageChild(form);



       if(
			((tolerancenum==1)&&(ErrorLookup[errnum].tol_desc1!=NULL)) ||
			((tolerancenum==3)&&(ErrorLookup[errnum].tol_desc3!=NULL)) ||
			((tolerancenum==5)&&(ErrorLookup[errnum].tol_desc5!=NULL))
		  )
		{
          form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,  
			       NULL);

		  if(tolerancenum==1)
		  {
            XtVaCreateManagedWidget ("",
				       xmLabelWidgetClass, form,
				       XmNtopAttachment,    XmATTACH_FORM,
				       XmNbottomAttachment, XmATTACH_FORM,
				       XmNrightAttachment,  XmATTACH_POSITION,
				       XmNrightPosition,    rightpos,
				       XmNleftAttachment,   XmATTACH_POSITION,
				       XmNleftPosition,     leftpos,
				       XmNalignment,        XmALIGNMENT_CENTER,
				       XmNlabelString,      STRING(ErrorLookup[errnum].tol_desc1),
				       LABELWTRANSLATE,
				       NULL);
		  }
		  else if(tolerancenum==3)
		  {
            XtVaCreateManagedWidget ("",
				       xmLabelWidgetClass, form,
				       XmNtopAttachment,    XmATTACH_FORM,
				       XmNbottomAttachment, XmATTACH_FORM,
				       XmNrightAttachment,  XmATTACH_POSITION,
				       XmNrightPosition,    rightpos,
				       XmNleftAttachment,   XmATTACH_POSITION,
				       XmNleftPosition,     leftpos,
				       XmNalignment,        XmALIGNMENT_CENTER,
				       XmNlabelString,      STRING(ErrorLookup[errnum].tol_desc3),
				       LABELWTRANSLATE,
				       NULL);
		  }
		  else if(tolerancenum==5)
		  {
            XtVaCreateManagedWidget ("",
				       xmLabelWidgetClass, form,
				       XmNtopAttachment,    XmATTACH_FORM,
				       XmNbottomAttachment, XmATTACH_FORM,
				       XmNrightAttachment,  XmATTACH_POSITION,
				       XmNrightPosition,    rightpos,
				       XmNleftAttachment,   XmATTACH_POSITION,
				       XmNleftPosition,     leftpos,
				       XmNalignment,        XmALIGNMENT_CENTER,
				       XmNlabelString,      STRING(ErrorLookup[errnum].tol_desc5),
				       LABELWTRANSLATE,
				       NULL);
		  }

          XtManageChild(form);
	   }






       form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,  
			       NULL);

	   sprintf(temp,"%lf",GetSens(clonenum,errnum,tolerancenum));
	
       text_sen_w = XtVaCreateManagedWidget ("text_w",
						    xmTextFieldWidgetClass, form,	  
						    XmNvalue,            temp,
						    XmNtraversalOn,      True,
						    XmNrightAttachment,  XmATTACH_POSITION,
						    XmNrightPosition,    rightpos,
						    XmNleftAttachment,   XmATTACH_POSITION,
						    XmNleftPosition,     leftpos,
						    XmNmaxLength,        15,
                            XmNtranslations,     XtParseTranslationTable ( translations_paste ) ,
						    NULL);

       userData->Swid_to_pass[tolerancenum] = text_sen_w;
	      
       if(tolerancenum==1)
	   {
          XtAddCallback (text_sen_w, XmNactivateCallback,
			     (XtCallbackProc)print_first_result, userData);
	   }
       if(tolerancenum==3)
	   {
         XtAddCallback (text_sen_w, XmNactivateCallback,
			     (XtCallbackProc)print_third_result, userData);
	   }
       if(tolerancenum==5)
	   {
         XtAddCallback (text_sen_w, XmNactivateCallback,
			     (XtCallbackProc)print_fifth_result, userData);
	   }

       XtManageChild(form);
	  }

	}
      else
	{
	  printf("oop! got %d for err num %d\n",ErrorLookup[errnum].numthresholds,errnum);
	}



      sep = XtVaCreateManagedWidget ("sep1",
				     xmSeparatorWidgetClass, rowcol,
				     NULL);


      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,
			       NULL);
      exitbutton = XtVaCreateManagedWidget("Help", xmPushButtonWidgetClass, form,
					   XmNlabelString, STRING("Help"),
					   XmNleftAttachment,   XmATTACH_POSITION,
					   XmNleftPosition,     0,
					   XmNrightAttachment,  XmATTACH_POSITION,
					   XmNrightPosition,    50,
					   XmNtraversalOn,      False,
					   XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					   NULL);
      XtAddCallback(exitbutton, XmNactivateCallback, help_sense_callback, (XtPointer)errnum);
      XtManageChild(exitbutton);

      n = 0;  

      exitbutton = XtVaCreateManagedWidget("Done",xmPushButtonWidgetClass, form,
					   XmNlabelString,      STRING("Apply/Done"),
					   XmNleftAttachment,   XmATTACH_POSITION,
					   XmNleftPosition,     50,
					   XmNrightAttachment,  XmATTACH_POSITION,
					   XmNrightPosition,    99,
					   XmNtraversalOn,      False,
					   XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					   NULL);
      

      XtAddCallback(exitbutton, XmNactivateCallback, (XtCallbackProc)kill_sense_callback,userData);



      XtManageChild(exitbutton);

      XtManageChild(form);
      XtManageChild (rowcol);
      
      XtAddCallback(sens_head,XmNdestroyCallback,(XtCallbackProc)SensDeath,userData);       

      MY_SENS_UP(userData,1);
      MyPopup(sens_head); 

      

      if(cloneindex<0)
	{
	  ErrorLookup[errnum].sens_head = sens_head;
	}
      else
	{
	  CloneErrorLookup[cloneindex].sens_head = sens_head;
	}
    }
}











void savesettings(int batch,int type)
{
  unsigned char endian;
  char dir[500];
  FILE *savefile;
  FILE *savefile2;
  char message[500];
  int i,j,k,len,TtlConds,ZeroValue,cloneindex,annotlen;


    

  


  if(type==1)
    {
      sprintf(dir,"%s2",esname);
    }
  else
    {
      sprintf(dir,"%scondreport.es2",outdirectory);
    }


  if(DEBUG==1){printf("save file is %s\n",dir);}

  

  savefile = fopen(dir,"w");
  if(savefile==NULL)
    {
      if(batch==0)
	{
	  sprintf(message,"Could not open %s for write",dir);
	  not_while_running(drawing_a,message,1073,"Couldnt open file",1);
	  return;
	}
      else
	{
	  printf("Could not open %s for write",dir);
	  ExitWrapper(-1);
	}
    }


  

  SaveAllSettingsFiles(savefile,0,0);
  fclose(savefile);








  
  if(type==1)
    {
      sprintf(dir,"%s",esname);
    }
  else
    {
      sprintf(dir,"%scondreport.es",outdirectory);
    }
  

  savefile2 = fopen(dir,"wb");
  if(savefile2==NULL)
    {
      if(batch==0)
	{
	  sprintf(message,"Could not open %s for write",dir);
	  not_while_running(drawing_a,message,1074,"Couldnt open file",1);
	  return;
	}
      else
	{
	  printf("Could not open %s for write",dir);
	  ExitWrapper(-1);
	}
    }


  
  endian = file_endianness;
  


  

  fwrite(&endian, SzUC,1,savefile2); 

  SEEIT_fwrite_double(&Xtranslation    ,savefile2);
  SEEIT_fwrite_double(&Ytranslation    ,savefile2);
  SEEIT_fwrite_int   (&CoordinateSystem,savefile2);

  len = strlen(indirectory)+1;

  SEEIT_fwrite_int(&len,savefile2);
  fwrite(&indirectory,SzUC,len,savefile2);



  TtlConds = CONDITION_DEFINITIONS + CLONE_DEFINITIONS;
  SEEIT_fwrite_int(&TtlConds, savefile2);

  ZeroValue = 0;

  for(i=1;i<=CONDITION_DEFINITIONS;i++)
    {      
      SEEIT_fwrite_int(&i, savefile2);         
      SEEIT_fwrite_int(&ZeroValue, savefile2); 
      SEEIT_fwrite_int(&ErrorLookup[i].numthresholds,savefile2);

      if(ErrorLookup[i].numthresholds>=1)
	{
	  SEEIT_fwrite_double(&ErrorLookup[i].sensitivity,savefile2);
	}
      if(ErrorLookup[i].numthresholds==2)
	{
	  SEEIT_fwrite_double(&ErrorLookup[i].sensitivity2 ,savefile2);
	}


      annotlen = 0;
      if(ErrorLookup[i].Annotation==NULL)
	{
	  SEEIT_fwrite_int(&annotlen, savefile2);  
	}
      else
	{
	  annotlen = strlen(ErrorLookup[i].Annotation);
	  SEEIT_fwrite_int(&annotlen, savefile2);  
	  fwrite(ErrorLookup[i].Annotation,SzUC,annotlen,savefile2);
	}


      SEEIT_fwrite_int(&ErrorLookup[i].active,savefile2);

      for(j=0;j<NUM_C;j++)
	{
	  fwrite(&ErrorLookup[i].Config1[j]  ,SzUC,1,savefile2);
	  fwrite(&ErrorLookup[i].Config2[j]  ,SzUC,1,savefile2);
	  fwrite(&ErrorLookup[i].Config3[j]  ,SzUC,1,savefile2);
	}
      for(j=0;j<NUM_S;j++)
	{
	  fwrite(&ErrorLookup[i].Stratum1[j]  ,SzUC,1,savefile2);
	  fwrite(&ErrorLookup[i].Stratum2[j]  ,SzUC,1,savefile2);
	  fwrite(&ErrorLookup[i].Stratum3[j]  ,SzUC,1,savefile2);
	}
      for(j=0;j<NUM_D;j++)
	{
	  fwrite(&ErrorLookup[i].Domain1[j]  ,SzUC,1,savefile2);
	  fwrite(&ErrorLookup[i].Domain2[j]  ,SzUC,1,savefile2);
	  fwrite(&ErrorLookup[i].Domain3[j]  ,SzUC,1,savefile2);
	}


      if(ErrorLookup[i].num_clones > 0)
        {
	  for(k=1; k<=ErrorLookup[i].num_clones; k++)
	    {
	      cloneindex = GetCloneIndex(k,i);

	      SEEIT_fwrite_int(&CloneErrorLookup[cloneindex].CloneNumber, savefile2);	      
	      SEEIT_fwrite_int(&k, savefile2);	      
	      SEEIT_fwrite_int(&ErrorLookup[i].numthresholds,savefile2);
	      
	      if(ErrorLookup[i].numthresholds>=1)
		{
		  SEEIT_fwrite_double(&CloneErrorLookup[cloneindex].sensitivity,savefile2);
		}
	      if(ErrorLookup[i].numthresholds==2)
		{
		  SEEIT_fwrite_double(&CloneErrorLookup[cloneindex].sensitivity2 ,savefile2);
		}


	      annotlen = 0;
	      if(CloneErrorLookup[cloneindex].Annotation==NULL)
		{
		  SEEIT_fwrite_int(&annotlen, savefile2);  
		}
	      else
		{
		  annotlen = strlen(CloneErrorLookup[cloneindex].Annotation);
		  SEEIT_fwrite_int(&annotlen, savefile2);  
		  fwrite(CloneErrorLookup[cloneindex].Annotation,SzUC,annotlen,savefile2);
		}

	      
	      SEEIT_fwrite_int(&CloneErrorLookup[cloneindex].active,savefile2);
	      
	      for(j=0;j<NUM_C;j++)
		{
		  fwrite(&CloneErrorLookup[cloneindex].Config1[j]  ,SzUC,1,savefile2);
		  fwrite(&CloneErrorLookup[cloneindex].Config2[j]  ,SzUC,1,savefile2);
		  fwrite(&CloneErrorLookup[cloneindex].Config3[j]  ,SzUC,1,savefile2);
		}
	      for(j=0;j<NUM_S;j++)
		{
		  fwrite(&CloneErrorLookup[cloneindex].Stratum1[j]  ,SzUC,1,savefile2);
		  fwrite(&CloneErrorLookup[cloneindex].Stratum2[j]  ,SzUC,1,savefile2);
		  fwrite(&CloneErrorLookup[cloneindex].Stratum3[j]  ,SzUC,1,savefile2);
		}
	      for(j=0;j<NUM_D;j++)
		{
		  fwrite(&CloneErrorLookup[cloneindex].Domain1[j]  ,SzUC,1,savefile2);
		  fwrite(&CloneErrorLookup[cloneindex].Domain2[j]  ,SzUC,1,savefile2);
		  fwrite(&CloneErrorLookup[cloneindex].Domain3[j]  ,SzUC,1,savefile2);
		}
	    }
	}
    }
  
  fclose(savefile2);
}



char * GetNGACname(int num)
{
  static char junk[100];

  if(NGA_TYPE==0)
    {
      return "";
    }


  if(num==0){return "C_NONE";}
  else if(num==1){return "C_AREA";}
  else if(num==2){return "C_DILI";}
  else if(num==3){return "C_FOMO";}
  else if(num==4){return "C_LINE";}
  else if(num==5){return "C_POFE";}
  else if(num==6){return "C_POMO";}
  else if(num==7){return "C_POLY";}
  else if(num==8){return "C_DYMO";}
  else if(num==9){return "C_GRID";}
  else if(num==10){return "C_COVS";}
  else if(num==11){return "C_COVP";}
  else if(num==12){return "C_MOLI";}
  else if(num==13){return "C_MLPF";}
  else if(num==14){return "C_MLLF";}
  else if(num==15){return "C_MLAF";}
  else 
    {
      printf("bad cname %d\n",num);
    }

  sprintf(junk,"unknown config %d\n",num);
  return junk;
}


char * ParseCALLName(int num)
{
  static char junk[100];

  if(num==0){return "C_NONE";}
  else if(num==1){return "C_ALL_AREA";}
  else if(num==4){return "C_ALL_LINE";}
  else if(num==5){return "C_ALL_POFE";}
  else if(num==6){return "C_ALL_POMO";}
  else if(num==9){return "C_ALL_GRID";}
  else 
    {
      printf("bad cname %d\n",num);
    }

  sprintf(junk,"unknown config %d\n",num);
  return junk;
}

char * ParseCSOMEName(int num)
{
  static char junk[100];

  if(num==0){return "C_NONE";}
  else if(num==1){return "C_SOME_AREA";}
  else if(num==4){return "C_SOME_LINE";}
  else if(num==5){return "C_SOME_POFE";}
  else if(num==6){return "C_SOME_POMO";}
  else if(num==9){return "C_SOME_GRID";}
  else 
    {
      printf("bad cname %d\n",num);
    }

  sprintf(junk,"unknown config %d\n",num);
  return junk;
}




char * ParseCName(int num)
{
  static char junk[100];

  if(num==0){return "C_NONE";}
  else if(num==1){return "C_AREA";}
  else if(num==2){return "C_DILI";}
  else if(num==3){return "C_FOMO";}
  else if(num==4){return "C_LINE";}
  else if(num==5){return "C_POFE";}
  else if(num==6){return "C_POMO";}
  else if(num==7){return "C_POLY";}
  else if(num==8){return "C_DYMO";}
  else if(num==9){return "C_GRID";}
  else if(num==10){return "C_COVS";}
  else if(num==11){return "C_COVP";}
  else if(num==12){return "C_MOLI";}
  else if(num==13){return "C_MLPF";}
  else if(num==14){return "C_MLLF";}
  else if(num==15){return "C_MLAF";}
  else 
    {
      printf("bad cname %d\n",num);
    }

  sprintf(junk,"unknown config %d\n",num);
  return junk;
}




 


char * ParseSName(int num)
{
  static char junk[100];

  if(num==0){return"S_NONE";}
  else if(num==1){return"S_APPL";}
  else if(num==2){return"S_COVE";}
  else if(num==4){return"S_SUBS";}
  else if(num==5){return"S_SURF";}
  else
    {
      printf("bad sname %d\n",num);
    }

  sprintf(junk,"unknown stratum %d\n",num);
  return junk;
}


char *ParseDName(int num)
{
  static char junk[100];

  if(NGA_TYPE==1)
    {
      if(num==0){return"D_AERO";}
      else if(num==1){return"D_AITO";}
      else if(num==2){return"D_BOUN";}
      else if(num==3){return"D_DAQU";}
      else if(num==4){return"D_DEST";}
      else if(num==5){return"D_ELEV";}
      else if(num==6){return"D_GRTR";}
      else if(num==7){return"D_INWA";}
      else if(num==8){return"D_MALI";}
      else if(num==9){return"D_OCEN";}
      else if(num==10){return"D_PHYS";}
      else if(num==11){return"D_POPU";}
      else if(num==12){return"D_POAN";}
      else if(num==13){return"D_SLPO";}
      else if(num==14){return"D_SUMA";}
      else if(num==15){return"D_UTAN";}
      else if(num==16){return"D_VEGE";}
      else if(num==17){return"D_GENE";}
      else if(num==18){return"D_GREL";}
      else
	{
	  printf("Bad dname %d\n",num);
	  ExitWrapper(-1);
	}
    }
  else
    {
      if(num==0){return"D_NONE";}
      else if(num==1){return"D_AIMO";}
      else if(num==2){return"D_AIOB";}
      else if(num==3){return"D_BOUN";}
      else if(num==4){return"D_BRID";}
      else if(num==5){return"D_CULT";}
      else if(num==6){return"D_INWA";}
      else if(num==7){return"D_LAMO";}
      else if(num==8){return"D_LAOB";}
      else if(num==9){return"D_MIUS";}
      else if(num==10){return"D_OPWA";}
      else if(num==11){return"D_TERR";}
      else if(num==12){return"D_VEGE";}
      else if(num==13){return"D_MAMO";}
      else if(num==14){return"D_MAOB";}
      else if(num==15){return"D_MACU";}
      else if(num==16){return"D_WEAT";}
      else if(num==17){return"D_SPAC";}
      else if(num==18){return"D_DESC";}
      else
	{
	  printf("Bad dname %d\n",num);
	}
      sprintf(junk,"unknown identifier %d\n",num);
      return junk;
    }

  
  return "should never see this";

}



int GetCode(int SCC, int SAC)
{
  
  return MdlNames2[MdlNames[SCC].UniqueAttr[SAC]].code;
  
  
  
}


void MemTest(double *tester,char *message)
{
  if(tester==NULL)
    {
      printf("%s: out of memory!\n",message);
      ExitWrapper(-1);
    }
}

void MemTest2(int *tester,char *message)
{
  if(tester==NULL)
    {
      printf("%s: out of memory!\n",message);
      ExitWrapper(-1);
    }
}



int PartitionTheInts(int p,int r)
{
  int temp;
  int i,j;
  double Dtemp;
  double x;

  x = Iintvalues[p];
  i = p-1;
  j = r+1;
  while(1)
    {
      do{j=j-1;}
      while(Iintvalues[j]>x);

      do{i=i+1;}
      while(Iintvalues[i]<x);
    
      if(i<j)
	{
	  Dtemp = Iintvalues[i];
	  Iintvalues[i] = Iintvalues[j];
	  Iintvalues[j] = Dtemp;


	  
	  temp = Iintindices[i];
	  Iintindices[i] = Iintindices[j];
	  Iintindices[j] = temp;
	}
      else
	{
	  return j;
	}
    }
}




void SortTheInts(int p,int r)
{
  

  int q;
  if(p<r)
    {
      q = PartitionTheInts(p,r);
      SortTheInts(p,q);
      SortTheInts(q+1,r);
    }
}








int PartitionHighlighter(int p,int r)
{
  int temp,x;
  int i,j;
  double Dtemp;

  
  x = HIGH_ERRNUM[p];
  i = p-1;
  j = r+1;
  while(1)
    {
      do{j=j-1;}
      while(HIGH_ERRNUM[j]>x);

      do{i=i+1;}
      while(HIGH_ERRNUM[i]<x);
    
      if(i<j)
	{
	  temp = HIGH_ERRNUM[i];
	  HIGH_ERRNUM[i] = HIGH_ERRNUM[j];
	  HIGH_ERRNUM[j] = temp;

	  temp = HIGH_ECC1[i];
	  HIGH_ECC1[i] = HIGH_ECC1[j];
	  HIGH_ECC1[j] = temp;

	  temp = HIGH_ECC2[i];
	  HIGH_ECC2[i] = HIGH_ECC2[j];
	  HIGH_ECC2[j] = temp;

	  temp = HIGH_INSTANCE[i];
	  HIGH_INSTANCE[i] = HIGH_INSTANCE[j];
	  HIGH_INSTANCE[j] = temp;

	  temp = HIGH_CONDNUM[i];
	  HIGH_CONDNUM[i] = HIGH_CONDNUM[j];
	  HIGH_CONDNUM[j] = temp;

	  Dtemp = HIGH_MAG[i];
	  HIGH_MAG[i] = HIGH_MAG[j];
	  HIGH_MAG[j] = Dtemp;
	}
      else
	{
	  return j;
	}
    }
}




int PartitionHighlighter2(int p,int r)
{
  int temp,x;
  int i,j;
  double Dtemp;

  
  x = HIGH_CONDNUM[p];
  i = p-1;
  j = r+1;
  while(1)
    {
      do{j=j-1;}
      while(HIGH_CONDNUM[j]>x);

      do{i=i+1;}
      while(HIGH_CONDNUM[i]<x);
    
      if(i<j)
	{
	  temp = HIGH_ECC1[i];
	  HIGH_ECC1[i] = HIGH_ECC1[j];
	  HIGH_ECC1[j] = temp;

	  temp = HIGH_ECC2[i];
	  HIGH_ECC2[i] = HIGH_ECC2[j];
	  HIGH_ECC2[j] = temp;

	  temp = HIGH_INSTANCE[i];
	  HIGH_INSTANCE[i] = HIGH_INSTANCE[j];
	  HIGH_INSTANCE[j] = temp;

	  temp = HIGH_CONDNUM[i];
	  HIGH_CONDNUM[i] = HIGH_CONDNUM[j];
	  HIGH_CONDNUM[j] = temp;

	  Dtemp = HIGH_MAG[i];
	  HIGH_MAG[i] = HIGH_MAG[j];
	  HIGH_MAG[j] = Dtemp;
	}
      else
	{
	  return j;
	}
    }
}




void SortHighlighter(int p,int r, int pass)
{
  
  
  int q;
  if(p<r)
    {
      if(pass==1)
	{
	  q = PartitionHighlighter(p,r);
	}
      else
	{
	  q = PartitionHighlighter2(p,r);
	}
      SortHighlighter(p,q,pass);
      SortHighlighter(q+1,r,pass);
    }
}




int PartitionTheFloats(int p,int r)
{
  int temp;
  int i,j;
  double Dtemp;
  double x;

  x = Ifloatvalues[p];
  i = p-1;
  j = r+1;
  while(1)
    {
      do{j=j-1;}
      while(Ifloatvalues[j]>x);

      do{i=i+1;}
      while(Ifloatvalues[i]<x);
    
      if(i<j)
	{
	  Dtemp = Ifloatvalues[i];
	  Ifloatvalues[i] = Ifloatvalues[j];
	  Ifloatvalues[j] = Dtemp;


	  
	  temp = Ifloatindices[i];
	  Ifloatindices[i] = Ifloatindices[j];
	  Ifloatindices[j] = temp;
	}
      else
	{
	  return j;
	}
    }
}




void SortTheFloats(int p,int r)
{
  

  int q;
  if(p<r)
    {
      q = PartitionTheFloats(p,r);
      SortTheFloats(p,q);
      SortTheFloats(q+1,r);
    }
}



char * MakeCleanCode(char *oldcode)
{
  static char retcode[1000];
  int i,len,insertindex;


  len = strlen(oldcode);
  insertindex = 0;

  for(i=0;i<len;i++)
    {
      

      if((oldcode[i]>='A')&&(oldcode[i]<='Z'))
	{
	  retcode[insertindex]=oldcode[i];
	  insertindex++;
	}
      if((oldcode[i]>='a')&&(oldcode[i]<='z'))
	{
	  retcode[insertindex]=oldcode[i];
	  insertindex++;
	}
      if((oldcode[i]>='0')&&(oldcode[i]<='9'))
	{
	  retcode[insertindex]=oldcode[i];
	  insertindex++;
	}
      if(oldcode[i]==' ')
	{
	  retcode[insertindex]='_';
	  insertindex++;
	}
    }
  retcode[insertindex] = '\0';
  return retcode;
}




char * MakeCleanCode2(char *oldcode)
{
  static char retcode[1000];
  int i,len,insertindex;


  len = strlen(oldcode);
  insertindex = 0;

  for(i=0;i<len;i++)
    {
      

      if((oldcode[i]>='A')&&(oldcode[i]<='Z'))
	{
	  retcode[insertindex]=oldcode[i];
	  insertindex++;
	}
      if((oldcode[i]>='a')&&(oldcode[i]<='z'))
	{
	  retcode[insertindex]=oldcode[i];
	  insertindex++;
	}
       if((oldcode[i]>='0')&&(oldcode[i]<='9'))
	{
	  retcode[insertindex]=oldcode[i];
	  insertindex++;
	}
      if(oldcode[i]==' ')
	{
	  retcode[insertindex]='_';
	  insertindex++;
	}
    }
  retcode[insertindex] = '\0';
  return retcode;
}



char * MakeCleanCode3(char *oldcode)
{
  static char retcode[1000];
  int i,len,insertindex;

  len = strlen(oldcode);
  insertindex = 0;

  for(i=0;i<len;i++)
    {
      

      if((oldcode[i]>='A')&&(oldcode[i]<='Z'))
	{
	  retcode[insertindex]=oldcode[i];
	  insertindex++;
	}
      if((oldcode[i]>='a')&&(oldcode[i]<='z'))
	{
	  retcode[insertindex]=oldcode[i];
	  insertindex++;
	}
      if((oldcode[i]>='0')&&(oldcode[i]<='9'))
	{
	  retcode[insertindex]=oldcode[i];
	  insertindex++;
	}
      if(oldcode[i]==' ')
	{
	  retcode[insertindex]='_';
	  insertindex++;
	}
    }
  retcode[insertindex] = '\0';

  return retcode;
}





void HandleNumericValues(FILE *savefile,int errnum,int axis,int ADDER,int clonenum,
			 struct IMarkSACList *cflRoot,int maxnum, int config_num)
{
  int i,numpairs,duplicate,thispair;
  int numint=0;
  int numfloat=0;
  struct IMarkSACList *cflS;
  double lowval,lastval;
  int *SCCindices;
  int *SACindices;
  int *IFloatStartPoints;
  int *IIntStartPoints;

  




  


  SCCindices = (int *)malloc(SzI * maxnum);
  MemTest2(SCCindices,"intindices");

  SACindices = (int *)malloc(SzI * maxnum);
  MemTest2(SACindices,"intindices");

  IFloatStartPoints = (int *)malloc(SzI * maxnum);
  MemTest2(IFloatStartPoints,"floatstartpoints");

  IIntStartPoints = (int *)malloc(SzI * maxnum);
  MemTest2(IIntStartPoints,"intstartpoints");


  numpairs = 0;

  cflS = cflRoot;
  while(cflS!=NULL)
    {
      duplicate = 0;
      for(i=0;i<numpairs;i++)
	{
	  if(
	     (SCCindices[i]==cflS->SCCindex)  &&
	     (SACindices[i]==cflS->SACindex)  
	     )
	    {
	      duplicate = 1;
	      break;
	    }
	}

      if(duplicate==0)
	{
	  SCCindices[numpairs] = cflS->SCCindex;
	  SACindices[numpairs] = cflS->SACindex;
	  numpairs++;
	}

      cflS = cflS->next;
    }




  


  Iintvalues = (double *)malloc(SzD * maxnum);
  MemTest(Iintvalues,"intvalues");
  
  Iintindices = (int *)malloc(SzI * maxnum);
  MemTest2(Iintindices,"intindices");

  Ifloatvalues = (double *)malloc(SzD * maxnum);
  MemTest(Ifloatvalues,"floatvalues");

  Ifloatindices = (int *)malloc(SzI * maxnum);
  MemTest2(Ifloatindices,"floatindices");


  for(thispair=0;thispair<numpairs;thispair++)
    {
      

      numint = 0;
      numfloat = 0;

      cflS = cflRoot;
      while(cflS!=NULL)
	{
	  if(
	     (cflS->SCCindex==SCCindices[thispair]) &&
	     (cflS->SACindex==SACindices[thispair]) &&
	     (cflS->SCCindex>=0)  
	     )
	    {
	      GetEDCSInfo(cflS->SCCindex,cflS->SACindex,cflS->EEindex,errnum,axis,ADDER);

		  if(cflS->EEindex==-2)
		  {

			  

			  if(strstr(cflS->saveval,"."))
			  {
	            sscanf(cflS->saveval,"%lf",&Ifloatvalues [numfloat]);
                Ifloatindices[numfloat] = cflS->EEindex;
		        numfloat++;
			  }
			  else if(cflS->saveval[0]=='"')
			  {
                

				

		        fprintf(savefile,"%s %d %s %s %s STRING %s %s %s\n",
			     ParseErrName(errnum),
			     clonenum+1,
			     ParseAxisName(axis),
			     MakeCleanCode(GetECCLabel(MdlNames[SCCindices[thispair]].code)),
			     MakeCleanCode2(GetEACLabel(GetCode(SCCindices[thispair],SACindices[thispair]))),
			     cflS->saveval,
			     GetADDType(ADDER),
			     GetNGACname(config_num));

			  }
			  else
			  {
	            sscanf(cflS->saveval,"%lf",&Iintvalues [numint]);
                Iintindices[numint] = cflS->EEindex;
		        numint++;
			  }

		  }


	      else if(edcsstruct.type==0)
		{
		  Iintvalues [numint] = edcsstruct.value;
		  Iintindices[numint] = cflS->EEindex;
		  numint++;
		}
	      else if(edcsstruct.type==1)
		{
		  Ifloatvalues [numfloat] = edcsstruct.value;
		  Ifloatindices[numfloat] = cflS->EEindex;
		  numfloat++;
		}
	    }
	  cflS = cflS->next;
	}
      
      
      if(numint>0)
	{
	  SortTheInts(0,numint-1);
	  
	  IIntStartPoints[0] = 1;
	  for(i=1;i<numint;i++)
	    {
	      if(Iintindices[i]!=(Iintindices[i-1]+1))
		{
		  IIntStartPoints[i] = 1;
		}
	      else
		{
		  IIntStartPoints[i] = 0;
		}
	    }

	  
	  
	}
      


      if(numfloat>0)
	{
	  SortTheFloats(0,numfloat-1);
	  
	  IFloatStartPoints[0] = 1;
	  for(i=1;i<numfloat;i++)
	    {
	      if(Ifloatindices[i]!=(Ifloatindices[i-1]+1))  
		{
		  IFloatStartPoints[i] = 1;
		}
	      else
		{
		  IFloatStartPoints[i] = 0;
		}
	    }

	  
	}
      
      


    

      


      
      IIntStartPoints[numint] = 1;
      Iintvalues[numint] = 999999999;

      if(numint>0)
	  {
        lowval = Iintvalues[0];
        lastval = lowval;
	  }

	  

      

      for(i=1;i<=numint;i++)
	{
	  if(IIntStartPoints[i]==1)
	    {
	      if(NGA_TYPE==1)
		{
		  fprintf(savefile,"%s %d %s %s %s RANGE %lf %lf %s %s\n",
			  ParseErrName(errnum),
			  clonenum+1,
			  ParseAxisName(axis),
			  MakeCleanCode (GetECCLabel(MdlNames[SCCindices[thispair]].code)),
			  MakeCleanCode2(GetEACLabel(GetCode(SCCindices[thispair],SACindices[thispair]))),
			  lowval,
			  lastval,
			  GetADDType(ADDER),
			  GetNGACname(config_num));
		}
	      else
		{
		  fprintf(savefile,"%s %d %s %s %s RANGE %lf %lf %s\n",
			  ParseErrName(errnum),
			  clonenum+1,
			  ParseAxisName(axis),
			  GetECCLabel(MdlNames[SCCindices[thispair]].code),
			  GetEACLabel(GetCode(SCCindices[thispair],SACindices[thispair])),
			  lowval,
			  lastval,
			  GetADDType(ADDER));
		}
	      lowval = Iintvalues[i];
	      lastval = lowval;
	    }
	  else
	    {
	      lastval = Iintvalues[i];
	    }
	}








      


      
      IFloatStartPoints[numfloat] = 1;
      Ifloatvalues     [numfloat] = 999999999; 

      
	  if(numfloat>0)
	  {
        lowval = Ifloatvalues[0];
        lastval = lowval;
	  }


      

      for(i=1;i<=numfloat;i++)
	{
	  if(IFloatStartPoints[i]==1)
	    {
	      if(NGA_TYPE==1)
		{
		  fprintf(savefile,"%s %d %s %s %s RANGE %lf %lf %s %s\n",
			  ParseErrName(errnum),
			  clonenum+1,
			  ParseAxisName(axis),
			  MakeCleanCode(GetECCLabel(MdlNames[SCCindices[thispair]].code)),
			  MakeCleanCode2(GetEACLabel(GetCode(SCCindices[thispair],SACindices[thispair]))),
			  lowval,
			  lastval,
			  GetADDType(ADDER),
			  GetNGACname(config_num));
		}
	      else
		{
		  fprintf(savefile,"%s %d %s %s %s RANGE %lf %lf %s\n",
			  ParseErrName(errnum),
			  clonenum+1,
			  ParseAxisName(axis),
			  GetECCLabel(MdlNames[SCCindices[thispair]].code),
			  GetEACLabel(GetCode(SCCindices[thispair],SACindices[thispair])),
			  lowval,
			  lastval,
			  GetADDType(ADDER));
		}
	      lowval = Ifloatvalues[i];
	      lastval = lowval;
	    }
	  else
	    {
	      lastval = Ifloatvalues[i];
	    }
	}
    }


  free(Iintvalues);
  free(Iintindices);
  free(Ifloatvalues);
  free(Ifloatindices);
  free(IFloatStartPoints);
  free(SCCindices);
  free(SACindices);
  free(IIntStartPoints);
}



char *AddGridStuff(char *label)
{

  if(NGA_TYPE==1)
  {
    if(strstr(label,"(GRID)"))
	{
      return MakeCleanCode2(label);
	}
  }
  return "";
}


char *GetOnOff(int onoff)
{
  if(onoff==1)
  {
    return "ON";
  }
  else if(onoff==0)
  {
    return "OFF";
  }
  else
  {
    XBell(mydisplay,50);
    printf("error in GONOF: %d\n",onoff);
	return "OFF";
  }
}


int CheckApplies(int errnum, int nettype)
{

  if(nettype==1)
  {
    if(IsNetCheck(errnum))
	{
      return 1;
	}

	return 0;
  }


  if(ErrorLookup[errnum].checkapplies==GAITandSEEITcheck)
  {
    return 1;
  }

  if((NGA_TYPE==1)&&(ErrorLookup[errnum].checkapplies==GAITcheck))
  {
    return 1;
  }

  if((NGA_TYPE==0)&&(ErrorLookup[errnum].checkapplies==SEEITcheck))
  {
    return 1;
  }

  return 0;

}


void SaveAllSettingsFiles(FILE *savefile, int onlyifon, int nettype)
{
  

  struct IMarkList *cfl;
  struct IMarkSACList *cflS;
  int uniq_checks = 0,errtype,i,j,k,clonenum,cloneindex;
  int errnum,axis,ADDER,config_num,geomtype;




  uniq_checks = 0;


  

  for(i=1;i<=CONDITION_DEFINITIONS;i++)
  {
    if(CheckApplies(i,nettype))
	{ 
      uniq_checks = uniq_checks + 1;
	}  
  }


  fprintf(savefile,"UNIQUE_CHECKS %d\n",uniq_checks);
  for(i=1;i<=CONDITION_DEFINITIONS;i++)
  { 
    if(CheckApplies(i,nettype))
	{
      if(ErrorLookup[i].num_clones>0)
	  {
	    fprintf(savefile,"%s %d\n",ParseErrName(i),ErrorLookup[i].num_clones+1); 
	  } 
	  else
	  { 
        fprintf(savefile,"%s 1\n",ParseErrName(i));
	  } 
	} 
  }


  

  for(i=0;i<CLONE_DEFINITIONS;i++)
  { 
    if(CheckApplies(CloneErrorLookup[i].CloneNumber,nettype))
	{
      if(CloneErrorLookup[i].active==0)
	  { 
	    errtype = CloneErrorLookup[i].CloneNumber;

	    fprintf(savefile,"%s %d off\n",
		  ParseErrName(errtype),GetCloneNumber(i,errtype)+1);
	  } 
	} 
  }



  

  for(i=1;i<=CONDITION_DEFINITIONS;i++)
  { 
    if(CheckApplies(i,nettype))
	{
	  if(ErrorLookup[i].active==0)
	  { 
	    fprintf(savefile,"%s 1 off\n",ParseErrName(i));
	  } 
	} 
  }




  


  
  for(i=1;i<=CONDITION_DEFINITIONS;i++)
  {
    errtype = i;
	

	if(CheckApplies(i,nettype)==0)
	{
      continue;
	}


    if(NGA_TYPE==1)
	{

	  for(geomtype=1;geomtype<NUM_C;geomtype++)
	  {

		axis = 1;
		if((ErrorLookup[i].Config1[geomtype]!=2)&&(ErrorLookup[i].AllConfigOn[axis][geomtype]==1))
		{
		  fprintf(savefile,"%s 1 C_PRIMARY %s on\n",ParseErrName(errtype),ParseCALLName(geomtype));
		}
		else if((ErrorLookup[i].Config1[geomtype]!=2)&&(ErrorLookup[i].AllConfigOn[axis][geomtype]==0))
		{
		  fprintf(savefile,"%s 1 C_PRIMARY %s off\n",ParseErrName(errtype),ParseCALLName(geomtype));
		}
		  
		if((ErrorLookup[i].Config1[geomtype]!=2)&&(ErrorLookup[i].SpecifiedConfigOn[axis][geomtype]==1))
		{
		  fprintf(savefile,"%s 1 C_PRIMARY %s on\n",ParseErrName(errtype),ParseCSOMEName(geomtype));
		}
		else if((ErrorLookup[i].Config1[geomtype]!=2)&&(ErrorLookup[i].SpecifiedConfigOn[axis][geomtype]==0))
		{
		  fprintf(savefile,"%s 1 C_PRIMARY %s off\n",ParseErrName(errtype),ParseCSOMEName(geomtype));
		}

		if(ErrorLookup[i].participants>=2)
		{
		  axis = 2;
		  if((ErrorLookup[i].Config2[geomtype]!=2)&&(ErrorLookup[i].AllConfigOn[axis][geomtype]==1))
		  {
			fprintf(savefile,"%s 1 C_SECONDARY %s on\n",ParseErrName(errtype),ParseCALLName(geomtype));
		  }
		  else if((ErrorLookup[i].Config2[geomtype]!=2)&&(ErrorLookup[i].AllConfigOn[axis][geomtype]==0))
		  {
			fprintf(savefile,"%s 1 C_SECONDARY %s off\n",ParseErrName(errtype),ParseCALLName(geomtype));
		  }
		      
		  if((ErrorLookup[i].Config2[geomtype]!=2)&&(ErrorLookup[i].SpecifiedConfigOn[axis][geomtype]==1))
		  {
			fprintf(savefile,"%s 1 C_SECONDARY %s on\n",ParseErrName(errtype),ParseCSOMEName(geomtype));
		  }
		  else if((ErrorLookup[i].Config2[geomtype]!=2)&&(ErrorLookup[i].SpecifiedConfigOn[axis][geomtype]==0))
		  {
			fprintf(savefile,"%s 1 C_SECONDARY %s off\n",ParseErrName(errtype),ParseCSOMEName(geomtype));
		  }
		}
		  
		if(ErrorLookup[i].participants>=3)
		{
		  axis = 3;
		  if((ErrorLookup[i].Config3[geomtype]!=2)&&(ErrorLookup[i].AllConfigOn[axis][geomtype]==1))
		  {
			fprintf(savefile,"%s 1 C_TERTIARY %s on\n",ParseErrName(errtype),ParseCALLName(geomtype));
		  }
		  else if((ErrorLookup[i].Config3[geomtype]!=2)&&(ErrorLookup[i].AllConfigOn[axis][geomtype]==0))
		  {
            fprintf(savefile,"%s 1 C_TERTIARY %s off\n",ParseErrName(errtype),ParseCALLName(geomtype));
		  }
		      
		  if((ErrorLookup[i].Config3[geomtype]!=2)&&(ErrorLookup[i].SpecifiedConfigOn[axis][geomtype]==1))
		  {
			fprintf(savefile,"%s 1 C_TERTIARY %s on\n",ParseErrName(errtype),ParseCSOMEName(geomtype));
		  }
		  else if((ErrorLookup[i].Config3[geomtype]!=2)&&(ErrorLookup[i].SpecifiedConfigOn[axis][geomtype]==0))
		  {
			fprintf(savefile,"%s 1 C_TERTIARY %s off\n",ParseErrName(errtype),ParseCSOMEName(geomtype));
		  }
		}



	    


	    for(k=0;k<ErrorLookup[i].num_clones;k++)
		{
		  cloneindex = GetCloneIndex(k+1,i);
		  
		  if((onlyifon==0) || (CloneErrorLookup[cloneindex].active==1))
		  {
		    axis = 1;
		    if((CloneErrorLookup[cloneindex].Config1[geomtype]!=2)&&
			   (CloneErrorLookup[cloneindex].AllConfigOn[axis][geomtype]==1))
			{
			  fprintf(savefile,"%s %d C_PRIMARY %s on\n",ParseErrName(errtype),k+2,
				  ParseCALLName(geomtype));
			}
		    else if((CloneErrorLookup[cloneindex].Config1[geomtype]!=2)&&
			        (CloneErrorLookup[cloneindex].AllConfigOn[axis][geomtype]==0))
			{
			  fprintf(savefile,"%s %d C_PRIMARY %s off\n",ParseErrName(errtype),k+2,
				  ParseCALLName(geomtype));
			}
		      
		    if((CloneErrorLookup[cloneindex].Config1[geomtype]!=2)&&
			   (CloneErrorLookup[cloneindex].SpecifiedConfigOn[axis][geomtype]==1))
			{
			  fprintf(savefile,"%s %d C_PRIMARY %s on\n",ParseErrName(errtype),k+2,
				  ParseCSOMEName(geomtype));
			}
		    else if((CloneErrorLookup[cloneindex].Config1[geomtype]!=2)&&
			        (CloneErrorLookup[cloneindex].SpecifiedConfigOn[axis][geomtype]==0))
			{
			  fprintf(savefile,"%s %d C_PRIMARY %s off\n",ParseErrName(errtype),k+2,
				  ParseCSOMEName(geomtype));
			}
		 		      
		      
		    if(ErrorLookup[i].participants>=2)
			{
			  axis = 2;
			  if((CloneErrorLookup[cloneindex].Config2[geomtype]!=2)&&
			     (CloneErrorLookup[cloneindex].AllConfigOn[axis][geomtype]==1))
			  {
			    fprintf(savefile,"%s %d C_SECONDARY %s on\n",ParseErrName(errtype),k+2,
				      ParseCALLName(geomtype));
			  }
			  else if((CloneErrorLookup[cloneindex].Config2[geomtype]!=2)&&
				      (CloneErrorLookup[cloneindex].AllConfigOn[axis][geomtype]==0))
			  {
			    fprintf(savefile,"%s %d C_SECONDARY %s off\n",ParseErrName(errtype),k+2,
				      ParseCALLName(geomtype));
			  }
			  
			  if((CloneErrorLookup[cloneindex].Config2[geomtype]!=2)&&
			     (CloneErrorLookup[cloneindex].SpecifiedConfigOn[axis][geomtype]==1))
			  {
			    fprintf(savefile,"%s %d C_SECONDARY %s on\n",ParseErrName(errtype),k+2,
				      ParseCSOMEName(geomtype));
			  }
			  else if((CloneErrorLookup[cloneindex].Config2[geomtype]!=2)&&
				      (CloneErrorLookup[cloneindex].SpecifiedConfigOn[axis][geomtype]==0))
			  {
			    fprintf(savefile,"%s %d C_SECONDARY %s off\n",ParseErrName(errtype),k+2,
				      ParseCSOMEName(geomtype));
			  }
			}
		      
		    if(ErrorLookup[i].participants>=3)
			{
			  axis = 3;
			  if((CloneErrorLookup[cloneindex].Config3[geomtype]!=2)&&
			     (CloneErrorLookup[cloneindex].AllConfigOn[axis][geomtype]==1))
			  {
			    fprintf(savefile,"%s %d C_TERTIARY %s on\n",ParseErrName(errtype),k+2,
				      ParseCALLName(geomtype));
			  }
			  else if((CloneErrorLookup[cloneindex].Config3[geomtype]!=2)&&
				      (CloneErrorLookup[cloneindex].AllConfigOn[axis][geomtype]==0))
			  { 
			    fprintf(savefile,"%s %d C_TERTIARY %s off\n",ParseErrName(errtype),k+2,
				      ParseCALLName(geomtype));
			  }
			  
			  if((CloneErrorLookup[cloneindex].Config3[geomtype]!=2)&&
			     (CloneErrorLookup[cloneindex].SpecifiedConfigOn[axis][geomtype]==1))
			  {
			    fprintf(savefile,"%s %d C_TERTIARY %s on\n",ParseErrName(errtype),k+2,
				      ParseCSOMEName(geomtype));
			  }
			  else if((CloneErrorLookup[cloneindex].Config3[geomtype]!=2)&&
				      (CloneErrorLookup[cloneindex].SpecifiedConfigOn[axis][geomtype]==0))
			  { 
			    fprintf(savefile,"%s %d C_TERTIARY %s off\n",ParseErrName(errtype),k+2,
				      ParseCSOMEName(geomtype));
			  }
			} 
		  } 
		} 
	  }
	}
      else if(NGA_TYPE==0)
	{	
	  if((onlyifon==0) || (ErrorLookup[i].active==1))
	    {
	      
	      
	      
	      for(j=0;j<NUM_C;j++)
		{
		  if(ErrorLookup[i].Config1[j]==0)
		    {
		      fprintf(savefile,"%s 1 C_PRIMARY %s off\n",ParseErrName(errtype),ParseCName(j));
		    }
		  else if(ErrorLookup[i].Config1[j]==1)
		    {
		      fprintf(savefile,"%s 1 C_PRIMARY %s on\n",ParseErrName(errtype),ParseCName(j));
		    }
		  
		  if(ErrorLookup[i].participants>=2)
		    {
		      if(ErrorLookup[i].Config2[j]==0)
			{
			  fprintf(savefile,"%s 1 C_SECONDARY %s off\n",ParseErrName(errtype),ParseCName(j));
			}
		      else if(ErrorLookup[i].Config2[j]==1)
			{
			  fprintf(savefile,"%s 1 C_SECONDARY %s on\n",ParseErrName(errtype),ParseCName(j));
			}
		    }	  
		  
		  if(ErrorLookup[i].participants>=3)
		    {
		      if(ErrorLookup[i].Config3[j]==0)
			{
			  fprintf(savefile,"%s 1 C_TERTIARY %s off\n",ParseErrName(errtype),ParseCName(j));
			}
		      else if(ErrorLookup[i].Config3[j]==1)
			{
			  fprintf(savefile,"%s 1 C_TERTIARY %s on\n",ParseErrName(errtype),ParseCName(j));
			}
		    }
		}
	    } 
	  
	  
	  
	  
	  
	  for(k=0;k<ErrorLookup[i].num_clones;k++)
	    {
	      cloneindex = GetCloneIndex(k+1,i);
	      
	      if((onlyifon==0) || (CloneErrorLookup[cloneindex].active==1))
		{
		  for(j=0;j<NUM_C;j++)
		    {
		      if(CloneErrorLookup[cloneindex].Config1[j]==0)
			{
			  fprintf(savefile,"%s %d C_PRIMARY %s off\n",ParseErrName(errtype),k+2,ParseCName(j));
			}
		      else if(CloneErrorLookup[cloneindex].Config1[j]==1)
			{
			  fprintf(savefile,"%s %d C_PRIMARY %s on\n",ParseErrName(errtype),k+2,ParseCName(j));
			}
		      
		      if(ErrorLookup[i].participants>=2)
			{
			  if(CloneErrorLookup[cloneindex].Config2[j]==0)
			    {
			      fprintf(savefile,"%s %d C_SECONDARY %s off\n",ParseErrName(errtype),k+2,ParseCName(j));
			    }
			  else if(CloneErrorLookup[cloneindex].Config2[j]==1)
			    {
			      fprintf(savefile,"%s %d C_SECONDARY %s on\n",ParseErrName(errtype),k+2,ParseCName(j));
			    }
			}	  
		      
		      if(ErrorLookup[i].participants>=3)
			{
			  if(CloneErrorLookup[cloneindex].Config3[j]==0)
			    {
			      fprintf(savefile,"%s %d C_TERTIARY %s off\n",ParseErrName(errtype),k+2,ParseCName(j));
			    }
			  else if(CloneErrorLookup[cloneindex].Config3[j]==1)
			    {
			      fprintf(savefile,"%s %d C_TERTIARY %s on\n",ParseErrName(errtype),k+2,ParseCName(j));
			    }
			}
		    }
		}
	    }
	  
	  
	  
	  
	  if((onlyifon==0) || (ErrorLookup[i].active==1))
	    {
	      
	      
	      
	      for(j=0;j<NUM_S;j++)
		{
		  if(j==S_INAC)
		    {
		      continue;
		    }

		  if(ErrorLookup[i].Stratum1[j]==0)
		    {
		      fprintf(savefile,"%s 1 S_PRIMARY %s off\n",ParseErrName(errtype),ParseSName(j));
		    }
		  else if(ErrorLookup[i].Stratum1[j]==1)
		    {
		      fprintf(savefile,"%s 1 S_PRIMARY %s on\n",ParseErrName(errtype),ParseSName(j));
		    }
		  
		  if(ErrorLookup[i].participants>=2)
		    {
		      if(ErrorLookup[i].Stratum2[j]==0)
			{
			  fprintf(savefile,"%s 1 S_SECONDARY %s off\n",ParseErrName(errtype),ParseSName(j));
			}
		      else if(ErrorLookup[i].Stratum2[j]==1)
			{
			  fprintf(savefile,"%s 1 S_SECONDARY %s on\n",ParseErrName(errtype),ParseSName(j));
			}
		    }	  
		  
		  if(ErrorLookup[i].participants>=3)
		    {
		      if(ErrorLookup[i].Stratum3[j]==0)
			{
			  fprintf(savefile,"%s 1 S_TERTIARY %s off\n",ParseErrName(errtype),ParseSName(j));
			}
		      else if(ErrorLookup[i].Stratum3[j]==1)
			{
			  fprintf(savefile,"%s 1 S_TERTIARY %s on\n",ParseErrName(errtype),ParseSName(j));
			}
		    }
		}
	    }
	  
	  
	  
	  
	  
	  
	  for(k=0;k<ErrorLookup[i].num_clones;k++)
	    {
	      cloneindex = GetCloneIndex(k+1,i);
	      
	      if((onlyifon==0) || (CloneErrorLookup[cloneindex].active==1))
		{
		  
		  for(j=0;j<NUM_S;j++)
		    {
		      if(j==S_INAC)
			{
			  continue;
			}

		      if(CloneErrorLookup[cloneindex].Stratum1[j]==0)
			{
			  fprintf(savefile,"%s %d S_PRIMARY %s off\n",ParseErrName(errtype),k+2,ParseSName(j));
			}
		      else if(CloneErrorLookup[cloneindex].Stratum1[j]==1)
			{
			  fprintf(savefile,"%s %d S_PRIMARY %s on\n",ParseErrName(errtype),k+2,ParseSName(j));
			}
		      
		      if(ErrorLookup[i].participants>=2)
			{
			  if(CloneErrorLookup[cloneindex].Stratum2[j]==0)
			    {
			      fprintf(savefile,"%s %d S_SECONDARY %s off\n",ParseErrName(errtype),k+2,ParseSName(j));
			    }
			  else if(CloneErrorLookup[cloneindex].Stratum2[j]==1)
			    {
			      fprintf(savefile,"%s %d S_SECONDARY %s on\n",ParseErrName(errtype),k+2,ParseSName(j));
			    }
			}	  
		      
		      if(ErrorLookup[i].participants>=3)
			{
			  if(CloneErrorLookup[cloneindex].Stratum3[j]==0)
			    {
			      fprintf(savefile,"%s %d S_TERTIARY %s off\n",ParseErrName(errtype),k+2,ParseSName(j));
			    }
			  else if(CloneErrorLookup[cloneindex].Stratum3[j]==1)
			    {
			      fprintf(savefile,"%s %d S_TERTIARY %s on\n",ParseErrName(errtype),k+2,ParseSName(j));
			    }
			}
		    }
		}
	    }
	  
	  
	  
	  
	  
	  
	  
	  
	  
	  if((onlyifon==0) || (ErrorLookup[i].active==1))
	    {
	      
	      for(j=0;j<NUM_D;j++)
		{
		  if(ErrorLookup[i].Domain1[j]==0)
		    {
		      fprintf(savefile,"%s 1 D_PRIMARY %s off\n",ParseErrName(errtype),ParseDName(j));
		    }
		  else if(ErrorLookup[i].Domain1[j]==1)
		    {
		      fprintf(savefile,"%s 1 D_PRIMARY %s on\n",ParseErrName(errtype),ParseDName(j));
		    }
		  
		  if(ErrorLookup[i].participants>=2)
		    {
		      if(ErrorLookup[i].Domain2[j]==0)
			{
			  fprintf(savefile,"%s 1 D_SECONDARY %s off\n",ParseErrName(errtype),ParseDName(j));
			}
		      else if(ErrorLookup[i].Domain2[j]==1)
			{
			  fprintf(savefile,"%s 1 D_SECONDARY %s on\n",ParseErrName(errtype),ParseDName(j));
			}
		    }	  
		  
		  if(ErrorLookup[i].participants>=3)
		    {
		      if(ErrorLookup[i].Domain3[j]==0)
			{
			  fprintf(savefile,"%s 1 D_TERTIARY %s off\n",ParseErrName(errtype),ParseDName(j));
			}
		      else if(ErrorLookup[i].Domain3[j]==1)
			{
			  fprintf(savefile,"%s 1 D_TERTIARY %s on\n",ParseErrName(errtype),ParseDName(j));
			}
		    }
		}
	    }
	  
	  
	  
	  
	  
	  for(k=0;k<ErrorLookup[i].num_clones;k++)
	    {
	      cloneindex = GetCloneIndex(k+1,i);
	      
	      if((onlyifon==0) || (CloneErrorLookup[cloneindex].active==1))
		{    
		  for(j=0;j<NUM_D;j++)
		    {
		      if(CloneErrorLookup[cloneindex].Domain1[j]==0)
			{
			  fprintf(savefile,"%s %d D_PRIMARY %s off\n",ParseErrName(errtype),k+2,ParseDName(j));
			}
		      else if(CloneErrorLookup[cloneindex].Domain1[j]==1)
			{
			  fprintf(savefile,"%s %d D_PRIMARY %s on\n",ParseErrName(errtype),k+2,ParseDName(j));
			}
		      
		      if(ErrorLookup[i].participants>=2)
			{
			  if(CloneErrorLookup[cloneindex].Domain2[j]==0)
			    {
			      fprintf(savefile,"%s %d D_SECONDARY %s off\n",ParseErrName(errtype),k+2,ParseDName(j));
			    }
			  else if(CloneErrorLookup[cloneindex].Domain2[j]==1)
			    {
			      fprintf(savefile,"%s %d D_SECONDARY %s on\n",ParseErrName(errtype),k+2,ParseDName(j));
			    }
			}	  
		      
		      if(ErrorLookup[i].participants>=3)
			{
			  if(CloneErrorLookup[cloneindex].Domain3[j]==0)
			    {
			      fprintf(savefile,"%s %d D_TERTIARY %s off\n",ParseErrName(errtype),k+2,ParseDName(j));
			    }
			  else if(CloneErrorLookup[cloneindex].Domain3[j]==1)
			    {
			      fprintf(savefile,"%s %d D_TERTIARY %s on\n",ParseErrName(errtype),k+2,ParseDName(j));
			    }
			}
		    }
		}
	    }
	}


      





      


      

      if((onlyifon==0) || (ErrorLookup[i].active==1))
	{
	  
	  if(ErrorLookup[i].UseBorderConds!=2)
	    {
	      fprintf(savefile,"%s 1 INCLUDE_BOUNDARY_CONDITIONS %s\n",ParseErrName(errtype),GetOnOff(ErrorLookup[i].UseBorderConds));
	    }

	  if(ErrorLookup[i].numthresholds>0)
	    {
	      fprintf(savefile,"%s 1 TOLERANCE_PRIMARY %lf\n",ParseErrName(errtype),ErrorLookup[i].sensitivity);
	    }
	  if(ErrorLookup[i].numthresholds>1)
	    {
	      fprintf(savefile,"%s 1 TOLERANCE_SECONDARY %lf\n",ParseErrName(errtype),ErrorLookup[i].sensitivity2);
	    }
	  if(ErrorLookup[i].numthresholds>2)
	    {
	      fprintf(savefile,"%s 1 TOLERANCE_TERTIARY %lf\n",ParseErrName(errtype),ErrorLookup[i].sensitivity3);
	    }
	  if(ErrorLookup[i].numthresholds>3)
	    {
	      fprintf(savefile,"%s 1 TOLERANCE_QUATERNARY %lf\n",ParseErrName(errtype),ErrorLookup[i].sensitivity4);
	    }
	  if(ErrorLookup[i].numthresholds>4)
	    {
	      fprintf(savefile,"%s 1 TOLERANCE_QUINARY %lf\n",ParseErrName(errtype),ErrorLookup[i].sensitivity5);
	    }
	  if(ErrorLookup[i].numthresholds>5)
	    {
	      fprintf(savefile,"%s 1 TOLERANCE_SENARY %lf\n",ParseErrName(errtype),ErrorLookup[i].sensitivity6);
	    }

	  if(ErrorLookup[i].mygroup==DEM_GROUP)
	  {
        if(ErrorLookup[i].use_sen1==0)
		{
	      fprintf(savefile,"%s 1 TOLERANCE_PRIMARY_OFF\n",ParseErrName(errtype));
		}
        if(ErrorLookup[i].use_sen2==0)
		{
	      fprintf(savefile,"%s 1 TOLERANCE_SECONDARY_OFF\n",ParseErrName(errtype));
		}
        if(ErrorLookup[i].use_sen3==0)
		{
	      fprintf(savefile,"%s 1 TOLERANCE_TERTIARY_OFF\n",ParseErrName(errtype));
		}
        if(ErrorLookup[i].use_sen4==0)
		{
	      fprintf(savefile,"%s 1 TOLERANCE_QUATERNARY_OFF\n",ParseErrName(errtype));
		}
        if(ErrorLookup[i].use_sen5==0)
		{
	      fprintf(savefile,"%s 1 TOLERANCE_QUINARY_OFF\n",ParseErrName(errtype));
		}
        if(ErrorLookup[i].use_sen6==0)
		{
	      fprintf(savefile,"%s 1 TOLERANCE_SENARY_OFF\n",ParseErrName(errtype));
		}
	  }

	}
	 
 
	  
      
      
      for(k=0;k<ErrorLookup[errtype].num_clones;k++)
	{
	  cloneindex = GetCloneIndex(k+1,errtype);
	  
	  if((onlyifon==0) || (CloneErrorLookup[cloneindex].active==1))
	    {	  
	      if(ErrorLookup[errtype].UseBorderConds!=2)
		  {
          fprintf(savefile,"%s %d INCLUDE_BOUNDARY_CONDITIONS %s\n",
			  ParseErrName(errtype),k+2,GetOnOff(CloneErrorLookup[cloneindex].UseBorderConds));
		  }
	      if(ErrorLookup[errtype].numthresholds>0)
		  { 
		  fprintf(savefile,"%s %d TOLERANCE_PRIMARY %lf\n",
			  ParseErrName(errtype),k+2,CloneErrorLookup[cloneindex].sensitivity);
		  } 
	      if(ErrorLookup[errtype].numthresholds>1)
		  { 
		  fprintf(savefile,"%s %d TOLERANCE_SECONDARY %lf\n",
			  ParseErrName(errtype),k+2,CloneErrorLookup[cloneindex].sensitivity2);
		  } 
	      if(ErrorLookup[errtype].numthresholds>2)
		  { 
		  fprintf(savefile,"%s %d TOLERANCE_TERTIARY %lf\n",
			  ParseErrName(errtype),k+2,CloneErrorLookup[cloneindex].sensitivity3);
		  } 
	      if(ErrorLookup[errtype].numthresholds>3)
		  { 
		  fprintf(savefile,"%s %d TOLERANCE_QUATERNARY %lf\n",
			  ParseErrName(errtype),k+2,CloneErrorLookup[cloneindex].sensitivity4);
		  } 
	      if(ErrorLookup[errtype].numthresholds>4)
		  { 
		  fprintf(savefile,"%s %d TOLERANCE_QUINARY %lf\n",
			  ParseErrName(errtype),k+2,CloneErrorLookup[cloneindex].sensitivity5);
		  } 
	      if(ErrorLookup[errtype].numthresholds>5)
		  { 
		  fprintf(savefile,"%s %d TOLERANCE_SENARY %lf\n",
			  ParseErrName(errtype),k+2,CloneErrorLookup[cloneindex].sensitivity6);
		  } 


	      if(ErrorLookup[errtype].mygroup==DEM_GROUP)
		  { 
            if(CloneErrorLookup[cloneindex].use_sen1==0)
			{ 
	          fprintf(savefile,"%s %d TOLERANCE_PRIMARY_OFF\n",ParseErrName(errtype),k+2);
			} 
            if(CloneErrorLookup[cloneindex].use_sen2==0)
			{ 
	          fprintf(savefile,"%s %d TOLERANCE_SECONDARY_OFF\n",ParseErrName(errtype),k+2);
			} 
            if(CloneErrorLookup[cloneindex].use_sen3==0)
			{ 
	          fprintf(savefile,"%s %d TOLERANCE_TERTIARY_OFF\n",ParseErrName(errtype),k+2);
			} 
            if(CloneErrorLookup[cloneindex].use_sen4==0)
			{ 
	          fprintf(savefile,"%s %d TOLERANCE_QUATERNARY_OFF\n",ParseErrName(errtype),k+2);
			} 
            if(CloneErrorLookup[cloneindex].use_sen5==0)
			{ 
	          fprintf(savefile,"%s %d TOLERANCE_QUINARY_OFF\n",ParseErrName(errtype),k+2);
			} 
            if(CloneErrorLookup[cloneindex].use_sen6==0)
			{ 
	          fprintf(savefile,"%s %d TOLERANCE_SENARY_OFF\n",ParseErrName(errtype),k+2);
			} 
		  } 
	    }
	}


	  
	
  
      
	  
      if((onlyifon==0) || (ErrorLookup[i].active==1))
	{
	  if(ErrorLookup[errtype].Annotation!=NULL)
	    {
	      fprintf(savefile,"%s 1 ANNOTATION \"%s\"\n",
		      ParseErrName(errtype),ErrorLookup[errtype].Annotation);
	    }
	}
	  


      
      
      for(k=0;k<ErrorLookup[errtype].num_clones;k++)
	{
	  cloneindex = GetCloneIndex(k+1,errtype);

	  if((onlyifon==0) || (CloneErrorLookup[cloneindex].active==1))
	    {	      
	      if(CloneErrorLookup[cloneindex].Annotation!=NULL)
		{
		  fprintf(savefile,"%s %d ANNOTATION \"%s\"\n",
			  ParseErrName(i),k+2,CloneErrorLookup[cloneindex].Annotation);
		}
	    }
	}
    }



  


  

  

  fprintf(savefile,"ATTRATTRATTR\n");




  


  for(errnum=1;errnum<=CONDITION_DEFINITIONS;errnum++)
    {

	  if(CheckApplies(errnum,nettype))
	  {		

	    for(axis=1;axis<=3;axis++)
		{ 
	      for(ADDER=0;ADDER<=1;ADDER++)
		  { 
	        for(config_num=0;config_num<NUM_C;config_num++)
			{ 
		      if((onlyifon==0) || (ErrorLookup[errnum].active==1))
			  { 
		      
		        if(ErrorLookup[errnum].IMarkRoot[axis][ADDER][config_num]!=NULL)
				{ 
			      cfl = ErrorLookup[errnum].IMarkRoot[axis][ADDER][config_num];
			      while(cfl!=NULL)
				  { 
			        if(NGA_TYPE==1)
					{ 
				      fprintf(savefile,"%s 1 %s %s%s ANY %s %s\n",
					   ParseErrName(errnum),
					   ParseAxisName(axis),
					   MakeCleanCode(GetECCLabel(MdlNames[cfl->origSCCindex].code)),AddGridStuff(MdlNames[cfl->origSCCindex].name),
					   GetADDType(ADDER),
					   GetNGACname(config_num));
					} 
			        else
					{ 
				      fprintf(savefile,"%s 1 %s %s%s ANY %s %s\n",
					   ParseErrName(errnum),
					   ParseAxisName(axis),
					   GetECCLabel(MdlNames[cfl->origSCCindex].code),AddGridStuff(MdlNames[cfl->origSCCindex].name),
					   GetADDType(ADDER),
					   GetNGACname(config_num));
					} 
			        cfl=cfl->next;
				  } 
				} 
			  } 
			} 

	        if(ErrorLookup[errnum].num_clones>0)
			{ 
		      for(clonenum=1;clonenum<=ErrorLookup[errnum].num_clones;clonenum++)
			  { 
		      
		        for(config_num=0;config_num<NUM_C;config_num++)
				{ 
			  
			      cloneindex = GetCloneIndex(clonenum,errnum);
			  
			      if((onlyifon==0) || (CloneErrorLookup[cloneindex].active==1))
				  { 
			      
			        if(CloneErrorLookup[cloneindex].IMarkRoot[axis][ADDER][config_num]!=NULL)
					{ 
				      cfl = CloneErrorLookup[cloneindex].IMarkRoot[axis][ADDER][config_num];
				      while(cfl!=NULL)
					  { 
				        if(NGA_TYPE==1)
						{ 
					      fprintf(savefile,"%s %d %s %s%s ANY %s %s\n",
						   ParseErrName(errnum),
						   clonenum+1,
						   ParseAxisName(axis),
						   MakeCleanCode(GetECCLabel(MdlNames[cfl->origSCCindex].code)),AddGridStuff(MdlNames[cfl->origSCCindex].name),
						   GetADDType(ADDER),
						   GetNGACname(config_num));
						}
				        else
						{ 
					      fprintf(savefile,"%s %d %s %s%s ANY %s %s\n",
						   ParseErrName(errnum),
						   clonenum+1,
						   ParseAxisName(axis),
						   GetECCLabel(MdlNames[cfl->origSCCindex].code),AddGridStuff(MdlNames[cfl->origSCCindex].name),
						   GetADDType(ADDER),
						   GetNGACname(config_num));
						} 
				        cfl=cfl->next;
					  } 
					} 
				  } 
				} 
			  } 
			} 
		  } 
		} 
	  } 
  }

  


  for(errnum=1;errnum<=CONDITION_DEFINITIONS;errnum++)
    {
	  if(CheckApplies(errnum,nettype))
	  {		
        for(axis=1;axis<=3;axis++)
		{ 
	      for(ADDER=0;ADDER<=1;ADDER++)
		  { 
	        for(config_num=0;config_num<NUM_C;config_num++)
			{ 
		  
		      if((onlyifon==0) || (ErrorLookup[errnum].active==1))
			  { 
		      
		        if(ErrorLookup[errnum].IMarkSACRoot[axis][ADDER][config_num]!=NULL)
				{ 
			      HandleNumericValues(savefile,errnum,axis,ADDER,0,
					      ErrorLookup[errnum].IMarkSACRoot[axis][ADDER][config_num],
					      ErrorLookup[errnum].sac_index[axis][ADDER][config_num] + 5,
					      config_num);			  
			  
			      cflS = ErrorLookup[errnum].IMarkSACRoot[axis][ADDER][config_num];
			      while(cflS!=NULL)
				  { 
			      
			        if(cflS->SCCindex>=0)  
					{ 
				      if(cflS->EEindex<0)
					  { 
					    
					  } 
				  
				      
				      GetEDCSInfo(cflS->SCCindex,cflS->SACindex,cflS->EEindex,errnum,axis,ADDER);
				      
				      if(
					     (edcsstruct.type==0) ||
					     (edcsstruct.type==1)
					    )
					  { 
					    
					  } 
				      else if(edcsstruct.type==2)
					  { 
					    fprintf(savefile,"%s 1 %s %s %s STRING %s %s %s\n",
						  ParseErrName(errnum),
						  ParseAxisName(axis),
						  MakeCleanCode(GetECCLabel(MdlNames[cflS->SCCindex].code)),
						  MakeCleanCode2(GetEACLabel(GetCode(cflS->SCCindex,cflS->SACindex))),
						  edcsstruct.label,  
						  GetADDType(ADDER),
						  GetNGACname(config_num));
					  
					  } 
				      else if(edcsstruct.type==3)   
					  { 
					   
					    if(NGA_TYPE==1)
						{
					      fprintf(savefile,"%s 1 %s %s %s LABEL %s %s %s\n",
						      ParseErrName(errnum),
						      ParseAxisName(axis),
						      MakeCleanCode(GetECCLabel(MdlNames[cflS->SCCindex].code)),
						      MakeCleanCode2(GetEACLabel(GetCode(cflS->SCCindex,cflS->SACindex))),
						      MakeCleanCode3(GetEELabel(GetCode(cflS->SCCindex,cflS->SACindex),(int)edcsstruct.value)),
						      GetADDType(ADDER),
						      GetNGACname(config_num));
					    }
					    else
					    {
					      fprintf(savefile,"%s 1 %s %s %s LABEL %s %s %s\n",
						      ParseErrName(errnum),
						      ParseAxisName(axis),
						      GetECCLabel(MdlNames[cflS->SCCindex].code),
						      GetEACLabel(GetCode(cflS->SCCindex,cflS->SACindex)),
						      GetEELabel(GetCode(cflS->SCCindex,cflS->SACindex),(int)edcsstruct.value),
						      GetADDType(ADDER),
						      GetNGACname(config_num));
					    }
					  } 
				      else if(edcsstruct.type==4)  
					  { 
					    fprintf(savefile,"%s 1 %s %s %s LABEL %s %s %s\n",
						  ParseErrName(errnum),
						  ParseAxisName(axis),
						  GetECCLabel(MdlNames[cflS->SCCindex].code),
						  GetEACLabel(GetCode(cflS->SCCindex,cflS->SACindex)),
						  GetEMLabel((int)edcsstruct.value),
						  GetADDType(ADDER),
						  GetNGACname(config_num));
					  
					  } 
				      else if(
					          (edcsstruct.type==5) ||
					          (edcsstruct.type==6) ||
					          (edcsstruct.type==7) 
					         )
					  { 
					    fprintf(savefile,"%s 1 %s %s %s RANGE %lf %lf %s %s\n",
						   ParseErrName(errnum),
						   ParseAxisName(axis),
						   GetECCLabel(MdlNames[cflS->SCCindex].code),
						   GetEACLabel(GetCode(cflS->SCCindex,cflS->SACindex)),
						   edcsstruct.value,
						   edcsstruct.value2,
						   GetADDType(ADDER),
						   GetNGACname(config_num));
					  }  
					}  
			        else
					{ 
				       
					} 
			        cflS=cflS->next;
				  } 
			  } 
		   } 
		} 
	      
	      if(ErrorLookup[errnum].num_clones>0)
		{
		  for(clonenum=1;clonenum<=ErrorLookup[errnum].num_clones;clonenum++)
		    {
		      for(config_num=0;config_num<NUM_C;config_num++)
			{
			  cloneindex = GetCloneIndex(clonenum,errnum);
			  
			  if((onlyifon==0) || (CloneErrorLookup[cloneindex].active==1))
			    {
			      
			      if(CloneErrorLookup[cloneindex].IMarkSACRoot[axis][ADDER][config_num]!=NULL)
				{
				  
				  HandleNumericValues(savefile,errnum,axis,ADDER,clonenum,
						      CloneErrorLookup[cloneindex].IMarkSACRoot[axis][ADDER][config_num],
						      CloneErrorLookup[cloneindex].sac_index[axis][ADDER][config_num] + 5,
						      config_num);
				  
				  
				  cflS = CloneErrorLookup[cloneindex].IMarkSACRoot[axis][ADDER][config_num];
				  while(cflS!=NULL)
				    {
				      if(cflS->SCCindex>=0)
					{
					  GetEDCSInfo(cflS->SCCindex,cflS->SACindex,cflS->EEindex,errnum,axis,ADDER);
					  
					  
					  if(
					     (edcsstruct.type==0) ||
					     (edcsstruct.type==1)
					     )
					    {
					    }
				      else if(edcsstruct.type==2)
					{
					  fprintf(savefile,"%s %d %s %s %s STRING %s %s %s\n",
						  ParseErrName(errnum),
						  clonenum+1,
						  ParseAxisName(axis),
						  MakeCleanCode(GetECCLabel(MdlNames[cflS->SCCindex].code)),
						  MakeCleanCode2(GetEACLabel(GetCode(cflS->SCCindex,cflS->SACindex))),
						  edcsstruct.label,  
						  GetADDType(ADDER),
						  GetNGACname(config_num));
					  
					}
					  else if(edcsstruct.type==3)
					    {
					      if(NGA_TYPE==1)
						{
						  fprintf(savefile,"%s %d %s %s %s LABEL %s %s %s\n",
							  ParseErrName(errnum),
							  clonenum+1,
							  ParseAxisName(axis),
							  MakeCleanCode(GetECCLabel(MdlNames[cflS->SCCindex].code)),
							  MakeCleanCode2(GetEACLabel(GetCode(cflS->SCCindex,cflS->SACindex))),
							  MakeCleanCode3(GetEELabel(GetCode(cflS->SCCindex,cflS->SACindex),(int)edcsstruct.value)),
							  GetADDType(ADDER),
							  GetNGACname(config_num));
						}
					      else
						{
						  fprintf(savefile,"%s %d %s %s %s LABEL %s %s %s\n",
							  ParseErrName(errnum),
							  clonenum+1,
							  ParseAxisName(axis),
							  GetECCLabel(MdlNames[cflS->SCCindex].code),
							  GetEACLabel(GetCode(cflS->SCCindex,cflS->SACindex)),
							  GetEELabel(GetCode(cflS->SCCindex,cflS->SACindex),(int)edcsstruct.value),
							  GetADDType(ADDER),
							  GetNGACname(config_num));
						}
					    }
					  else if(edcsstruct.type==4)
					    {
					      fprintf(savefile,"%s %d %s %s %s LABEL %s %s %s\n",
						      ParseErrName(errnum),
						      clonenum+1,
						      ParseAxisName(axis),
						      GetECCLabel(MdlNames[cflS->SCCindex].code),
						      GetEACLabel(GetCode(cflS->SCCindex,cflS->SACindex)),
						      GetEMLabel((int)edcsstruct.value),
						      GetADDType(ADDER),
						      GetNGACname(config_num));
					      
					    }
					  else if(
						  (edcsstruct.type==5) ||
						  (edcsstruct.type==6) ||
						  (edcsstruct.type==7) 
						  )
					    {
					      fprintf(savefile,"%s %d %s %s %s RANGE %lf %lf %s %s\n",
						      ParseErrName(errnum),
						      clonenum+1,
						      ParseAxisName(axis),
						      GetECCLabel(MdlNames[cflS->SCCindex].code),
						      GetEACLabel(GetCode(cflS->SCCindex,cflS->SACindex)),
						      edcsstruct.value,
						      edcsstruct.value2,
						      GetADDType(ADDER),
						      GetNGACname(config_num));
					    }
					}
				      cflS=cflS->next;
				    }
				  }
			    }
			} 
			} 
			}
		} 
		} 
	} 
    } 
}


void GetNumConditionsByAnnotation(char *annotation,int *checkfound,int *checkcount)
{
  int i;

  

  for(i=1;i<=CONDITION_DEFINITIONS;i++)
  {
    if(ErrorLookup[i].Annotation!=NULL)
	{
	  if(!strcmp(ErrorLookup[i].Annotation,annotation))
	  {
		*checkfound = 1;
		*checkcount = ErrorLookup[i].number;

		
		return;
	  }
	}
  } 

  for(i=0;i<CLONE_DEFINITIONS;i++)
  {
    if(CloneErrorLookup[i].Annotation!=NULL)
	{
	  if(!strcmp(CloneErrorLookup[i].Annotation,annotation))
	  {
		*checkfound = 1;
		*checkcount = CloneErrorLookup[i].number;

		
		return;
	  }
	}
  }
}


void GetRidOfAllClones(int nettype)
{
  int i,j,k,l,insertindex,keeper = 0;

  struct CloneErrorTable *TempCloneErrorLookup;


  

  for(i=0;i<CLONE_DEFINITIONS;i++)
  {
     if(IsNetCheck(CloneErrorLookup[i].CloneNumber)!=nettype)
	 {
       
	   keeper = keeper + 1;
	 }
  }
	  

  
	  
  TempCloneErrorLookup = (struct CloneErrorTable *)malloc(keeper * sizeof(struct CloneErrorTable));

  insertindex = 0;
  for(i=0;i<CLONE_DEFINITIONS;i++)
  {
     if(IsNetCheck(CloneErrorLookup[i].CloneNumber)!=nettype)
	 {
       TempCloneErrorLookup[insertindex] = CloneErrorLookup[i];
	   insertindex = insertindex + 1;
	 }
  }




  
  
  for(i=0;i<CLONE_DEFINITIONS;i++)
  { 
    if(IsNetCheck(CloneErrorLookup[i].CloneNumber)==nettype)
	{
      for(j=0;j<3+1;j++)
	  {
	    for(k=0;k<2;k++)
	    {
	      for(l=0;l<NUM_C;l++)
		  {
		    ScrubEDCSMarkerList (-1,j,k,1,i,l);
		    ScrubEDCSMarkerList2(-1,j,k,1,i,l);
		  } 
		} 
	  } 
    } 
  }

  for(i=1;i<=CONDITION_DEFINITIONS;i++)
    {
      if(IsNetCheck(i)==nettype)
	  {
        ErrorLookup[i].num_clones = 0;
	  }
    }


  for(i=0;i<CLONE_DEFINITIONS;i++)
    {

      if(IsNetCheck(CloneErrorLookup[i].CloneNumber)!=nettype)
	  {
        continue;
	  }

	  if(CloneErrorLookup[i].Annotation!=NULL)
	  {
	   free(CloneErrorLookup[i].Annotation);
	  }

      if(CloneErrorLookup[i].primaryEDCSstuff!=NULL)
	  {
	   free(CloneErrorLookup[i].primaryEDCSstuff);
	   CloneErrorLookup[i].primaryEDCSstuff = NULL;
	  }  
      if(CloneErrorLookup[i].secondaryEDCSstuff!=NULL)
	  { 
	   free(CloneErrorLookup[i].secondaryEDCSstuff);
	   CloneErrorLookup[i].secondaryEDCSstuff = NULL;
	  }  
      if(CloneErrorLookup[i].tertiaryEDCSstuff!=NULL)
	  { 
	   free(CloneErrorLookup[i].tertiaryEDCSstuff);
	   CloneErrorLookup[i].tertiaryEDCSstuff = NULL;
	  }  


     if(CloneErrorLookup[i].primaryFIDstuff!=NULL)
	  {
	   free(CloneErrorLookup[i].primaryFIDstuff);
	   CloneErrorLookup[i].primaryFIDstuff = NULL;
	  }  
      if(CloneErrorLookup[i].secondaryFIDstuff!=NULL)
	  { 
	   free(CloneErrorLookup[i].secondaryFIDstuff);
	   CloneErrorLookup[i].secondaryFIDstuff = NULL;
	  }  
      if(CloneErrorLookup[i].tertiaryFIDstuff!=NULL)
	  { 
	   free(CloneErrorLookup[i].tertiaryFIDstuff);
	   CloneErrorLookup[i].tertiaryFIDstuff = NULL;
	  }  


      if(CloneErrorLookup[i].keepdismiss!=NULL)
	{
	  free(CloneErrorLookup[i].keepdismiss);
	  CloneErrorLookup[i].keepdismiss = NULL;
	}

      if(CloneErrorLookup[i].pos_list_made>0)
	{
	  free(CloneErrorLookup[i].pos_list);
	  CloneErrorLookup[i].pos_list_made = 0;
	}
    }


  if(keeper>0)
  {
    CLONE_DEFINITIONS = keeper;
    CloneErrorLookup = TempCloneErrorLookup;
  }
  else
  {
    if(CLONE_DEFINITIONS>0)
    {
      free(CloneErrorLookup);
    }
  
    CLONE_DEFINITIONS = 0;
    CloneErrorLookup  = NULL;
  }


  
}






void RebuildExeWindow(int nettype)
{
  extern Widget param_net_head,param2_net_head;
  extern int net_head_in_use,net_deader_head,net_deader_phead;
  
  if(nettype==1)
  {
    if(net_head_in_use==0)
    {
      XtDestroyWidget(param_net_head);
      net_deader_head=1;
      net_head_in_use=1;
    }
    else
    {
      XtDestroyWidget(param2_net_head);
      net_deader_phead=1;
      net_head_in_use=0;
    }
  
    NETmodifyCallback(drawing_a, (XtPointer)NULL,(XtPointer)NULL);
  }
  else
  {
    if(head_in_use==0)
    {
      XtDestroyWidget(param_head);
      deader_head=1;
      head_in_use=1;
    }
    else
    {
      XtDestroyWidget(param2_head);
      deader_phead=1;
      head_in_use=0;
    }
    modifyCallback(drawing_a, (XtPointer)NULL,(XtPointer)NULL);
  }

}





int FindEDCSInFile(char *dir)
{
  FILE *temp;
  int lines=0,errnumber,i;
  char aline[1100],part1[1100];


  
  
  
  temp = fopen(dir,"r");
  if(temp==NULL)
    {
      return -1;
    }
  
  
  fgets(aline,1000,temp);
  lines++;
  
  while(!feof(temp))
    {
      if(lines>5000000)
	{
	  fclose(temp);
	  return -1*lines;
	}
      
      
      if((aline==NULL)||(aline[0]=='\0'))
	{
	  fclose(temp);
	  return -1*lines;
	}
      
      if(strlen(aline)<2)
	{
	  
	  fclose(temp);
	  return -1*lines;
	}
      
      
      if(!strncmp(aline,"ATTRATTRATTR",12))
	{
	  fclose(temp);
	  return lines;
	}

      
      
      sscanf(aline,"%s",part1);
      for(i=0;i<(int)strlen(aline);i++)
	{
	  if(aline[i]==' ')
	    {
	      aline[i] = '\0';
	      break;
	    }
	}
      if((lines==1)&&(strcmp(part1,"UNIQUE_CHECKS")))
	{
	  fclose(temp);
	  return -1*lines;
	}
      
      if(lines>1)
	{
	  errnumber = ParseErrNumberWrapper(aline,lines,dir);
	  if(errnumber<0)
	    {
	      fclose(temp);
	      return -2;
	    }
	}


      fgets(aline,1000,temp);  
      lines++;
    }

  fclose(temp);
  return -1;
}


void TurnOffAllChecks(int nettype)
{
  int i;

  for(i=1;i<=CONDITION_DEFINITIONS;i++)
    {
      if(IsNetCheck(i)!=nettype)
	  {
        continue;
	  }
      ErrorLookup[i].active   = 0;
      ErrorLookup[i].viewall  = 0;
      ErrorLookup[i].viewsome = 0;
    }
}


void RevertArrows(int nettype)
{
  int i;



  if(nettype==0)
  {
    for(i=0;i<NUMCHECKGROUPS;i++)
    {
      OnOff2[i] = 0;
    }

    for(i=0;i<NUMCHECKGROUPS;i++)
    {
      VCOnOff2[i]  = 0;
    }
  }


  for(i=0;i<=CONDITION_DEFINITIONS;i++)
  { 
	if(IsNetCheck(i)==nettype)
	{
      VCOnOff3[i]  = 0;
	}
  }


  if(nettype==0)
  {
    OnOff1    = 1;
    VCOnOff1  = 1;
    NETOnOff1 = 1;
  }


  for(i=1;i<=CONDITION_DEFINITIONS;i++)
  {
	if(IsNetCheck(i)==nettype)
	{
      ErrorLookup[i].scrollwidmadeNET = 0;
      ErrorLookup[i].scrollwidmade    = 0;
      ErrorLookup[i].filterout        = 0;

      if(ErrorLookup[i].pos_list_made>0)
	  { 
	    free(ErrorLookup[i].pos_list);
	    ErrorLookup[i].pos_list_made = 0;
	  } 

      if(ErrorLookup[i].NETpos_list_made>0)
	  { 
	    free(ErrorLookup[i].NETpos_list);
	    ErrorLookup[i].NETpos_list_made = 0;
	  } 
	}
  }


  for(i=0;i<CLONE_DEFINITIONS;i++)
  {
	if(IsNetCheck(CloneErrorLookup[i].CloneNumber)==nettype)
	{
      CloneErrorLookup[i].scrollwidmadeNET = 0;
      CloneErrorLookup[i].scrollwidmade    = 0;
      CloneErrorLookup[i].filterout        = 0;

      if(CloneErrorLookup[i].pos_list_made>0)
	  {
	    free(CloneErrorLookup[i].pos_list);
	    CloneErrorLookup[i].pos_list_made = 0;
	  }

      if(CloneErrorLookup[i].NETpos_list_made>0)
	  {
	    free(CloneErrorLookup[i].NETpos_list);
	    CloneErrorLookup[i].NETpos_list_made = 0;
	  }
    }
  }
}



int GetSecondSpace(char *intxt)
{
  int i,len,numspace;

  numspace = 0;

  len = strlen(intxt);

  for(i=0;i<len;i++)
  {
	if(intxt[i]==' ')
	{
	  numspace = numspace + 1;
	  if(numspace==2)
	  {
		return i;
	  }
	}
  }
  printf("Internal Error in GSS: couldn't FSS in %s\n",intxt);
  return 0;
}


int ScrubNewLine(char *intxt)
{
  int i,len;

  

  len = strlen(intxt);

  for(i=len-1;i>0;i--)
  {
	if((intxt[i]<1)||(intxt[i]>31)) 
	{
      return i;
	}
  }

  printf("Internal Error in LQ: couldn't FLQ in %s\n",intxt);
  return len - 1;
}


void CombineExeOptionsFiles(char *file1,char *file2,char *newfilename)
{
  FILE *infile1,*infile2,*outfile;
  int i,Instances1[CONDITION_ARRAY_SIZE],Instances2[CONDITION_ARRAY_SIZE];
  int uniqnum,numinstance,line1,line2,errnumber,thisinstance,startindex,endindex;
  char aline[1000],chk_string[1000],headtxt[1000];



  for(i=0;i<CONDITION_ARRAY_SIZE;i++)
  {
    Instances1[i] = 0;
    Instances2[i] = 0;
  }



  outfile = fopen(newfilename,"w");
  if(outfile==NULL)
  {
    printf("Error: cannot open %s for write\n",newfilename);
	return;
  }

  infile1 = fopen(file1,"r");
  if(infile1==NULL)
  {
    printf("Error: cannot open %s for read\n",file1);
	fclose(outfile);
	return;
  }


  infile2 = fopen(file2,"r");
  if(infile2==NULL)
  {
    printf("Error: cannot open %s for read\n",file2);
	fclose(outfile);
	fclose(infile1);
	return;
  }



  



  fgets(aline,1000,infile1);
  sscanf(aline,"%s%d",headtxt,&uniqnum);
  line1 = 1;



  for(i=0;i<uniqnum;i++)
  {
    fgets(aline,1000,infile1);
	line1 = line1 + 1;
    sscanf(aline,"%s%d",chk_string,&numinstance);
    errnumber = ParseErrNumberWrapper(chk_string,line1,file1);
	if(errnumber<0)
	{
      return;
	}
	Instances1[errnumber] = numinstance;
  }



  fgets(aline,1000,infile2);
  sscanf(aline,"%s%d",headtxt,&uniqnum);
  line2 = 1;



  for(i=0;i<uniqnum;i++)
  {
    fgets(aline,1000,infile2);
	line2 = line2 + 1;
    sscanf(aline,"%s%d",chk_string,&numinstance);
    errnumber = ParseErrNumberWrapper(chk_string,line2,file2);
	if(errnumber<0)
	{
      return;
	}
	Instances2[errnumber] = numinstance;
  }


  


  uniqnum = 0;
  for(i=1;i<=CONDITION_DEFINITIONS;i++)
  {
    if((Instances1[i]+Instances2[i])>0)
	{
      uniqnum = uniqnum + 1;
	}
  }


  fprintf(outfile,"UNIQUE_CHECKS %d\n",uniqnum);

  for(i=1;i<=CONDITION_DEFINITIONS;i++)
  {
    if((Instances1[i]+Instances2[i])>0)
	{
	  fprintf(outfile,"%s %d\n",ParseErrName(i),Instances1[i]+Instances2[i]);
	}
  }



  

  fgets(aline,1000,infile1);
  line1 = line1 + 1;
  while(strncmp(aline,"ATTRATTRATTR",12))
  {
    fprintf(outfile,"%s",aline);
    fgets(aline,1000,infile1);
	line1 = line1 + 1;
  }


  

  fgets(aline,1000,infile2);
  line2 = line2 + 1;
  while(strncmp(aline,"ATTRATTRATTR",12))
  {
    headtxt[0] = '\0';

	

	sscanf(aline,"%s%d",chk_string,&thisinstance);
	startindex = GetSecondSpace(aline);	
	sprintf(headtxt,"%s",&aline[startindex]);

    endindex = ScrubNewLine(headtxt);
	headtxt[endindex+1] = '\0';


    errnumber = ParseErrNumberWrapper(chk_string,line2,file2);

    fprintf(outfile,"%s %d%s\n",chk_string,thisinstance + Instances1[errnumber],headtxt);

    fgets(aline,1000,infile2);
    line2 = line2 + 1;
  }



  fprintf(outfile,"ATTRATTRATTR\n");



  

  fgets(aline,1000,infile1);
  line1 = line1 + 1;
  while(!feof(infile1))
  {
    fprintf(outfile,"%s",aline);
    fgets(aline,1000,infile1);
	line1 = line1 + 1;
  }


  

  fgets(aline,1000,infile2);
  line2 = line2 + 1;
  while(!feof(infile2))
  {
    headtxt[0] = '\0';

	

	sscanf(aline,"%s%d",chk_string,&thisinstance);
	startindex = GetSecondSpace(aline);	
	sprintf(headtxt,"%s",&aline[startindex]);

    endindex = ScrubNewLine(headtxt);
	headtxt[endindex+1] = '\0';

    errnumber = ParseErrNumberWrapper(chk_string,line2,file2);

    fprintf(outfile,"%s %d%s\n",chk_string,thisinstance + Instances1[errnumber],headtxt);

    fgets(aline,1000,infile2);
    line2 = line2 + 1;
  }


  fclose(infile1);
  fclose(infile2);
  fclose(outfile);
}



int IsMaster(char *infilename)
{
  char filename[1000];

  sprintf(filename,"%sinspection_files%sMGCP_master.txt",indirectory,GetSlash());
  if(!strcmp(infilename,filename))
  {
    return 1;
  }
  sprintf(filename,"%sinspection_files%sDFEG_master.txt",indirectory,GetSlash());
  if(!strcmp(infilename,filename))
  {
    return 1;
  }
  sprintf(filename,"%sinspection_files%sUFD1_master.txt",indirectory,GetSlash());
  if(!strcmp(infilename,filename))
  {
    return 1;
  }
  sprintf(filename,"%sinspection_files%sUFD3_master.txt",indirectory,GetSlash());
  if(!strcmp(infilename,filename))
  {
    return 1;
  }
  sprintf(filename,"%sinspection_files%sTDS_master.txt",indirectory,GetSlash());
  if(!strcmp(infilename,filename))
  {
    return 1;
  }
  sprintf(filename,"%sinspection_files%sLTDS_master.txt",indirectory,GetSlash());  
  if(!strcmp(infilename,filename))
  {
    return 1;
  }
  sprintf(filename,"%sinspection_files%sUTDS_master.txt",indirectory,GetSlash());
  if(!strcmp(infilename,filename))
  {
    return 1;
  }
  sprintf(filename,"%sinspection_files%sRTDS_master.txt",indirectory,GetSlash());
  if(!strcmp(infilename,filename))
  {
    return 1;
  }
  sprintf(filename,"%sinspection_files%sGTDS_master.txt",indirectory,GetSlash());
  if(!strcmp(infilename,filename))
  {
    return 1;
  }
  sprintf(filename,"%sinspection_files%sAFD_master.txt",indirectory,GetSlash());
  if(!strcmp(infilename,filename))
  {
    return 1;
  }
  sprintf(filename,"%sinspection_files%sTREX_master.txt",indirectory,GetSlash());
  if(!strcmp(infilename,filename))
  {
    return 1;
  }


  return 0;
}



void PrintCloneOnOff()
{
  int i;

  return;

  printf("\n\nEXTRA_NET prime on %d\n",ErrorLookup[EXTRA_NET].active);
  for(i=0;i<CLONE_DEFINITIONS;i++)
  {
    printf("...cloneindex: %d on %d annotation %s\n",i,CloneErrorLookup[i].active,CloneErrorLookup[i].Annotation);
  }
  printf("\n\n");
}




void loadExeOptionsfile(char *dir, int nettype)
{
  int bad_lines;
  char message[1000],aline[1000],newfile[1000];
  int lines_to_skip;
  FILE *temp,*savefile;
  extern Widget param_net_head,param2_net_head;
  extern int Offchecks;
  extern int net_head_in_use,net_deader_head,net_deader_phead;



  if((GLOBAL_ADDSPECS==1)&&(IsMaster(dir)==0))
  {
    

    sprintf(aline,"%stemp.txt",outdirectory);

    savefile = fopen(aline,"w");
    if(savefile==NULL)
	{ 
      XBell(mydisplay,50);
      printf("Could not open %s for write",aline);
      return;
	}

    SaveAllSettingsFiles(savefile,0,0);
    fclose(savefile);


    sprintf(newfile,"%stemp0.txt",outdirectory);

	CombineExeOptionsFiles(aline,dir,newfile);

	dir = newfile;
  }


  temp = fopen(dir,"r");
  if(temp==NULL)
    {
      sprintf(message,"Unable to open file %s.  Aborting condition load\n",dir);
      
      not_while_running(drawing_a,message,1077,"Could not open file",1);
      return;
    }
  

  
  set_cursor(mydisplay,mywindow,WATCH);

  if((head_in_use==0)&&(deader_head==0))
    {
      set_cursor(mydisplay,XtWindow(param_head),WATCH);
    }
  if((head_in_use==1)&&(deader_phead==0))
    {
      set_cursor(mydisplay,XtWindow(param2_head),WATCH);
    }
  if((net_head_in_use==0)&&(net_deader_head==0))
    {
      set_cursor(mydisplay,XtWindow(param_net_head),WATCH);
    }
  if((net_head_in_use==1)&&(net_deader_phead==0))
    {
      set_cursor(mydisplay,XtWindow(param2_net_head),WATCH);
    }


  fgets(aline,1000,temp);


  if(!strncmp(aline,"Data not available",18))
    {
      sprintf(message,"File %s:\n\
Contains no specifications.  Aborting load of this file\n",dir);
      
      not_while_running(drawing_a,message,1078,"Empty file",1);

      set_cursor(mydisplay,mywindow,GOOD);
      if((head_in_use==0)&&(deader_head==0))
	  {
	    set_cursor(mydisplay,XtWindow(param_head),ARROW);
	  } 
      if((head_in_use==1)&&(deader_phead==0))
	  { 
	    set_cursor(mydisplay,XtWindow(param2_head),ARROW);
	  }       
      if((net_head_in_use==0)&&(net_deader_head==0))
	  { 
        set_cursor(mydisplay,XtWindow(param_net_head),ARROW);
	  } 
      if((net_head_in_use==1)&&(net_deader_phead==0))
	  { 
        set_cursor(mydisplay,XtWindow(param2_net_head),ARROW);
	  } 
      return;
    }
  fclose(temp);



  


  lines_to_skip = FindEDCSInFile(dir);



  if(lines_to_skip==0)
    {
      sprintf(message,"File %s:\n\
Contains no specifications.  Aborting load of this file\n",dir);
      
      not_while_running(drawing_a,message,1079,"Empty file",1);
      set_cursor(mydisplay,mywindow,GOOD);
      if((head_in_use==0)&&(deader_head==0))
	{
	  set_cursor(mydisplay,XtWindow(param_head),ARROW);
	}
      if((head_in_use==1)&&(deader_phead==0))
	{
	  set_cursor(mydisplay,XtWindow(param2_head),ARROW);
	}      
      if((net_head_in_use==0)&&(net_deader_head==0))
	  { 
        set_cursor(mydisplay,XtWindow(param_net_head),ARROW);
	  } 
      if((net_head_in_use==1)&&(net_deader_phead==0))
	  { 
        set_cursor(mydisplay,XtWindow(param2_net_head),ARROW);
	  } 
      return;
    }
  
  if(lines_to_skip==-2)
    {
      
      set_cursor(mydisplay,mywindow,GOOD);
      if((head_in_use==0)&&(deader_head==0))
	{
	  set_cursor(mydisplay,XtWindow(param_head),ARROW);
	}
      if((head_in_use==1)&&(deader_phead==0))
	{
	  set_cursor(mydisplay,XtWindow(param2_head),ARROW);
	}      
      if((net_head_in_use==0)&&(net_deader_head==0))
	  { 
        set_cursor(mydisplay,XtWindow(param_net_head),ARROW);
	  } 
      if((net_head_in_use==1)&&(net_deader_phead==0))
	  { 
        set_cursor(mydisplay,XtWindow(param2_net_head),ARROW);
	  } 
      return;
    }

  if(lines_to_skip<0)
    {
      sprintf(message,"File %s:\n\
Is invalid (line %d)\n",dir,lines_to_skip*-1);
      
      not_while_running(drawing_a,message,1080,"Empty file",1);

      set_cursor(mydisplay,mywindow,GOOD);
      if((head_in_use==0)&&(deader_head==0))
	{
	  set_cursor(mydisplay,XtWindow(param_head),ARROW);
	}
      if((head_in_use==1)&&(deader_phead==0))
	{
	  set_cursor(mydisplay,XtWindow(param2_head),ARROW);
	}      
      if((net_head_in_use==0)&&(net_deader_head==0))
	  { 
        set_cursor(mydisplay,XtWindow(param_net_head),ARROW);
	  } 
      if((net_head_in_use==1)&&(net_deader_phead==0))
	  { 
        set_cursor(mydisplay,XtWindow(param2_net_head),ARROW);
	  } 
      return;
    }



  
  



  if(nettype==1)
  {
    
    revertCallback((Widget)NULL,(XtPointer)9,(XtPointer)9);
  }
  else
  {
    
    revertCallback((Widget)NULL,(XtPointer)5,(XtPointer)5);
  }



  TurnOffAllChecks(nettype);

  RevertArrows(nettype);

  ApplyExecutionOptions(dir,nettype);

  bad_lines = DoBatchEDCSStuff((Widget)NULL,dir,lines_to_skip,1);

  if(bad_lines>0)
    {
      if(NGA_TYPE==0)
	{
	  sprintf(message,
"Completed import of EDCS data in file %s.\n\
%d EDCS specification lines were found in the file that did\n\
not map to data in this database, and were ignored.  See stdout\n\
for these line numbers.",dir,bad_lines);
	  
	  not_while_running(drawing_a,message,1081,"Non-Applicable EDCS data in EDCS file",1);
	}
      else
	{
	  if(Offchecks==1)
	  {
        if(nettype==1)
		{
	      sprintf(message,
"Completed import of attribution data in file:\n\
%s.\n\
%d specification lines were found in the file that did\n\
not map to data in this project, and were ignored.  See stdout\n\
for these line numbers.\n\n\
This has resulted in one or more network specifications being turned off.\n\
This file should be repaired before generating networks.",dir,bad_lines);
		}
		else
		{
	      sprintf(message,
"Completed import of attribution data in file:\n\
%s.\n\
%d specification lines were found in the file that did\n\
not map to data in this project, and were ignored.  See stdout\n\
for these line numbers.\n\n\
This has resulted in one or more specified checks being turned off.\n\
This file should be repaired before executing inspections.",dir,bad_lines);
		}
	  }
	  else
	  {
		if(nettype==1)
		{
	      sprintf(message,
"Completed import of attribution data in file:\n\
%s.\n\
%d specification lines were found in the file that did\n\
not map to data in this project, and were ignored.  See stdout\n\
for these line numbers.\n\n\
Because the \"Turn off networks with invalid/incomplete specifications\"\n\
option was de-selected, the networks involved are active, but care should\n\
be taken with the use of these networks.",dir,bad_lines);
		}
		else
		{
	      sprintf(message,
"Completed import of attribution data in file:\n\
%s.\n\
%d specification lines were found in the file that did\n\
not map to data in this project, and were ignored.  See stdout\n\
for these line numbers.\n\n\
Because the \"Turn off inspections with invalid/incomplete specifications\"\n\
option was de-selected, the inspections involved are active, but care should\n\
be taken with the use of these inspections and their results.",dir,bad_lines);
		}
	  }
	  if(nettype==1)
	  {
	    not_while_running(drawing_a,message,1610,"Non-Applicable attribution data in file",1);
	  }
	  else
	  {
	    not_while_running(drawing_a,message,1082,"Non-Applicable attribution data in file",1);
	  }
	}
    }


  if(nettype==1)
  {
    if(((net_head_in_use==0)&&(net_deader_head==0))||
       ((net_head_in_use==1)&&(net_deader_phead==0)))
    {
      

      RebuildExeWindow(nettype);
    }
  }
  else if((nettype==0)&&(NO_EXE_REBUILD==0))
  {
    if(((head_in_use==0)&&(deader_head==0))||
       ((head_in_use==1)&&(deader_phead==0)))
    {
      

      RebuildExeWindow(nettype);
    }
  }

  
  set_cursor(mydisplay,mywindow,GOOD);
  if((head_in_use==0)&&(deader_head==0))
  {
    set_cursor(mydisplay,XtWindow(param_head),ARROW);
  }
  if((head_in_use==1)&&(deader_phead==0))
  {
    set_cursor(mydisplay,XtWindow(param2_head),ARROW);
  }      
  if((net_head_in_use==0)&&(net_deader_head==0))
  { 
    set_cursor(mydisplay,XtWindow(param_net_head),ARROW);
  } 
  if((net_head_in_use==1)&&(net_deader_phead==0))
  { 
    set_cursor(mydisplay,XtWindow(param2_net_head),ARROW);
  } 
}







void prevsetCallback(Widget w,Widget list_w,char filename[])
{
  XmString *selectlist;
  char *text;
  char message[1000],newname[1000];
  int totalobjs;

  
  
  XtVaGetValues(list_w,
		XmNselectedItemCount,&totalobjs,
		XmNselectedItems    ,&selectlist,
		NULL);
  
  
  if(totalobjs!=1)
    {
      sprintf(message,"To load a condition report, select one from\n\
the list, and then click \"Load Selected Condition Report\",\n\
or double-click it in the list.");

      not_while_running(w,message,1428,"Load Inspection File Help",5);
      
      return;
    }
  
  XmStringGetLtoR(selectlist[0],
		  (XmStringCharSet) XmSTRING_DEFAULT_CHARSET, &text);
  
  
  sscanf(text,"%s",newname);
  
  printf("found project w/ shapefiles %s\n",newname);
  
  
  XtVaSetValues(previousresults, XmNvalue, text,  NULL);
    
  XtDestroyWidget(prev_dialog);
}











void preloadCRsettingCallback(Widget w,Widget list_w,char filename[])
{
  XmString *selectlist;
  char *text;
  char message[1000],newname[1000];
  int totalobjs,temp;
  static int LOCALBUSY = 0;
  

  if(LOCALBUSY==1)
    {
      printf("returning from DCR because too busy\n");
      return;
    }

      
  XtVaGetValues(list_w,
		XmNselectedItemCount,&totalobjs,
		XmNselectedItems    ,&selectlist,
		NULL);
  
  
  if(totalobjs!=1)
    {
      sprintf(message,"To load a condition report, select one from\n\
the list, and then click \"Load Selected Condition Report\",\n\
or double-click it in the list.");

      not_while_running(w,message,1428,"Load Inspection File Help",5);
      
      return;
    }
  
  XmStringGetLtoR(selectlist[0],
		  (XmStringCharSet) XmSTRING_DEFAULT_CHARSET, &text);
  
  
  sscanf(text,"%s",newname);

  

  if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
    {
      sprintf(esname,"%scondition_reports\\%s.es",indirectory,newname);
    }
  else
    {
      sprintf(esname,"%scondition_reports/%s.es",indirectory,newname);
    }
 
  
  printf("load file %s\n",esname);
  
  LOCALBUSY = 1;
  XtPopdown(cond_dialog);
  XtDestroyWidget(cond_dialog);


  

  temp = GLOBAL_ADDSPECS;
  GLOBAL_ADDSPECS = 0;


  reporthandleCallback((Widget)drawing_a, (XtPointer)2, (XtPointer)NULL );

  GLOBAL_ADDSPECS = temp;


  LOCALBUSY = 0;
}



void RealLoadsettingCallback(Widget w,Widget list_w,char filename[], int nettype)
{
  XmString *selectlist;
  MyData userData;
  char *text;
  char message[1000],file1name[1000],file2name[1000],outfilename[1000];
  int totalobjs=-999,errnum,i,cloneindex;
  static int LOCALBUSY = 0;


  if(LOCALBUSY==1)
    {
      printf("load setting: too busy!\n");
      return;
    }


 if(list_w!=NULL)
   { 
  
     XtVaGetValues(list_w,
		   XmNselectedItemCount,&totalobjs,
		   XmNselectedItems    ,&selectlist,
		   NULL);
     
     
     if(totalobjs<1)
       {
		 if(nettype==1)
		 {
	       sprintf(message,"To load a specification file, select one of the files\n\
in the list, and then click \"Load Selected File\",\n\
or double-click it in the list.");

	       not_while_running(w,message,1609,"Load Inspection File Help",5);
		 }
		 else
		 {
	       sprintf(message,"To load an inspection file, select one of the files\n\
in the list, and then click \"Load Selected File\",\n\
or double-click it in the list.");

	       not_while_running(w,message,1420,"Load Inspection File Help",5);
		 }

	     return;
       }


	 if(totalobjs==1)
	 {
       XmStringGetLtoR(selectlist[0],
		     (XmStringCharSet) XmSTRING_DEFAULT_CHARSET, &text);
     
     
       if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
       {
		 if(nettype==1)
		 {
	       sprintf(message,"%sview_network_files\\%s",indirectory,text);
		 }
		 else
		 {
	       sprintf(message,"%sinspection_files\\%s",indirectory,text);
		 }
       }
       else
       {
		 if(nettype==1)
		 {
	       sprintf(message,"%sview_network_files/%s",indirectory,text);
		 }
		 else
		 {
	       sprintf(message,"%sinspection_files/%s",indirectory,text);
		 }
       }
	 }

	 else if(totalobjs>1)
	 {
       XmStringGetLtoR(selectlist[0],
		     (XmStringCharSet) XmSTRING_DEFAULT_CHARSET, &text);

       if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
	   {
		 if(nettype==1)
		 {
	       sprintf(file1name,"%sview_network_files\\%s",indirectory,text);
		 }
		 else
		 {
	       sprintf(file1name,"%sinspection_files\\%s",indirectory,text);
		 }
       } 
       else
	   {
		 if(nettype==1)
		 {
	       sprintf(file1name,"%sview_network_files/%s",indirectory,text);
		 }
		 else
		 {
	       sprintf(file1name,"%sinspection_files/%s",indirectory,text);
		 }
       } 

       XmStringGetLtoR(selectlist[1],
		     (XmStringCharSet) XmSTRING_DEFAULT_CHARSET, &text);

       if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
	   {
         if(nettype==1)
		 {
	       sprintf(file2name,"%sview_network_files\\%s",indirectory,text);
		 }
		 else
		 {
	       sprintf(file2name,"%sinspection_files\\%s",indirectory,text);
		 }
       } 
       else
	   {
         if(nettype==1)
		 {
	       sprintf(file2name,"%sview_network_files/%s",indirectory,text);
		 }
		 else
		 {
	       sprintf(file2name,"%sinspection_files/%s",indirectory,text);
		 }
       } 

       sprintf(outfilename,"%stemp2.txt",outdirectory);
       sprintf(message,"%s",outfilename);

		

       CombineExeOptionsFiles(file1name,file2name,outfilename);

       for(i=2;i<totalobjs;i++)
		{

          sprintf(file1name,"%stemp%d.txt",outdirectory,i);
		 
          XmStringGetLtoR(selectlist[i],
		     (XmStringCharSet) XmSTRING_DEFAULT_CHARSET, &text);

          if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
		  {
            if(nettype==1)
			{
	          sprintf(file2name,"%sview_network_files\\%s",indirectory,text);
			}
			else
			{
	          sprintf(file2name,"%sinspection_files\\%s",indirectory,text);
			}
		  }
          else
		  {
            if(nettype==1)
			{
	          sprintf(file2name,"%sview_network_files/%s",indirectory,text);
			}
			else
			{
	          sprintf(file2name,"%sinspection_files/%s",indirectory,text);
			}
		  }

          sprintf(outfilename,"%stemp%d.txt",outdirectory,i+1);
          sprintf(message,"%s",outfilename);

	      CombineExeOptionsFiles(file1name,file2name,outfilename);
		}
	 }
   }
 else
   {
     sprintf(message,"%s",filename);
   }



 if(nettype==1)
 {
   if(LOAD_NETSETTINGS_UP==1)
   {
     XtPopdown(XtParent(XtParent(XtParent(w))));
     XtDestroyWidget(XtParent(XtParent(XtParent(w))));
     LOAD_NETSETTINGS_UP = 0;
   }
 }
 else if(nettype==0)
 {
   if(LOAD_SETTINGS_UP==1)
   {
     XtPopdown(XtParent(XtParent(XtParent(w))));
     XtDestroyWidget(XtParent(XtParent(XtParent(w))));
     LOAD_SETTINGS_UP = 0;
   }
 }


 


  

  for(errnum=1;errnum<=CONDITION_DEFINITIONS;errnum++)
  {
    if(IsNetCheck(errnum)==nettype)
	{
	  userData.check_num = errnum;
	  userData.clonenum  = 0;

      if(MY_ANN_UP(&userData,0)==1)
	  { 
	    MY_ANN_UP(&userData,-1);

	    if(ErrorLookup[errnum].annot_head==NULL)
		{ 
		  printf("NULL annot_head %d\n",errnum);
		} 
        else
		{ 
		  XtDestroyWidget(ErrorLookup[errnum].annot_head);
		} 
	  } 


      if(MY_SENS_UP(&userData,0)==1)
	  { 
	    MY_SENS_UP(&userData,-1);

	    if(ErrorLookup[errnum].sens_head==NULL)
		{ 
		  printf("NULL sens_head %d\n",errnum);
		} 
        else
		{ 
		  XtDestroyWidget(ErrorLookup[errnum].sens_head);
		} 
	  } 



      if(MY_ACTOR_UP(&userData,0)==1)
	  { 
	    MY_ACTOR_UP(&userData,-1);

	    if(ErrorLookup[errnum].CSD==NULL)
		{ 
		  printf("NULL CSD %d\n",errnum);
		} 
        else
		{ 
		  XtDestroyWidget(ErrorLookup[errnum].CSD);
		} 
	  } 



	  for(i=1;i<=ErrorLookup[errnum].num_clones;i++)
	  {   
        cloneindex = GetCloneIndex(i,errnum);
	    userData.clonenum  = i;

	    if(MY_ANN_UP(&userData,0)==1)
		{ 
		  MY_ANN_UP(&userData,-1);
		  if(CloneErrorLookup[cloneindex].annot_head==NULL)
		  { 
	        printf("NULL Cannot_head %d %d\n",errnum,cloneindex);
		  } 
		  else
		  { 
		    XtDestroyWidget(CloneErrorLookup[cloneindex].annot_head);
		  } 
		} 


	    if(MY_SENS_UP(&userData,0)==1)
		{ 
		  MY_SENS_UP(&userData,-1);
		  if(CloneErrorLookup[cloneindex].sens_head==NULL)
		  { 
	        printf("NULL Csens_head %d %d\n",errnum,cloneindex);
		  } 
		  else
		  { 
		    XtDestroyWidget(CloneErrorLookup[cloneindex].sens_head);
		  } 
		} 


	    if(MY_ACTOR_UP(&userData,0)==1)
		{ 
		  MY_ACTOR_UP(&userData,-1);
		  if(CloneErrorLookup[cloneindex].CSD==NULL)
		  { 
	        printf("NULL CCSD %d %d\n",errnum,cloneindex);
		  } 
		  else
		  { 
		    XtDestroyWidget(CloneErrorLookup[cloneindex].CSD);
		  } 
		} 
	  } 
	} 
  }


  if(nettype==0)
  {
    

    zerooutCallback((Widget)NULL, (XtPointer)1, (XtPointer) 0);
  }
  else
  {
	
  }


  if(LOCALBUSY==0)
    {
      LOCALBUSY = 1;
      loadExeOptionsfile(message,nettype);
      LOCALBUSY = 0;
    }
  else 
    {
      printf("too busy\n");
    }



  if(GLOBAL_ADDSPECS==0)
  {
    if(totalobjs==1)
	{ 
      if(!strcmp(text,"BndryMatch.txt"))
	  { 
        sprintf(masterrun,"Boundary_Edge_Matching");
	  } 
	} 
  }

}





void loadNETsettingCallback(Widget w,Widget list_w,char filename[])
{
  

  RealLoadsettingCallback(w,list_w,filename,1);

  
}

void loadEXEsettingCallback(Widget w,Widget list_w,char filename[])
{

  

  RealLoadsettingCallback(w,list_w,filename,0);

  
}


int ValidNetFile(char *filename)
{
  FILE *infile;
  char aline[1000],firstword[1000];

  infile = fopen(filename,"r");

  if(infile==NULL)
  {
    printf("VNF: could not open %s\n",filename);
	return 0;
  }

  fgets(aline,1000,infile);

  fclose(infile);


  sscanf(aline,"%s",firstword);

  if(!strcmp(firstword,"UNIQUE_CHECKS")) 
  {
      
    return 1;
  }

  return 0;
}



void preloadNETsettingCallback(Widget w,XtPointer intype,XtPointer unused)
{
  

  int type=(int)intype,i,firstfile=0,secondfile=0,tempindex,numfiles,result;
  char file1name[1000],file2name[1000],finalfile[1000],outfilename[1000];
  char *TDS_FileList[]=
  {
	  "TDS_ROAD.txt",
	  "TDS_RAIL.txt",
	  "TDS_HYDRO.txt",
	  "TDS_POWER.txt",
	  "TDS_PIPELINE.txt"
  };
  char *MGCP_FileList[]=
  {
	  "MGCP_ROAD.txt",
	  "MGCP_RAIL.txt",
	  "MGCP_HYDRO.txt"
  };
  char **FileList;


  result = GenerateExeFiles(1);  


  if(type==1)
  {
    numfiles = 5;
	FileList = TDS_FileList;
  }
  else if(type==2)
  {
    numfiles = 3;
	FileList = MGCP_FileList;
  }

  firstfile  = numfiles + 100; 
  secondfile = numfiles + 100;

  for(i=0;i<numfiles;i++)
  {
    if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
	{ 
     sprintf(file1name,"%sview_network_files\\%s",indirectory,FileList[i]);
	} 
    else
	{ 
     sprintf(file1name,"%sview_network_files/%s",indirectory,FileList[i]);
	}  
  
    if(ValidNetFile(file1name))
	{
      firstfile = i;
      break;
	}
  }


  if(firstfile<numfiles)
  {
    for(i=firstfile+1;i<numfiles;i++)
	{ 
      if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
	  {  
        sprintf(file2name,"%sview_network_files\\%s",indirectory,FileList[i]);
	  }  
      else
	  {  
        sprintf(file2name,"%sview_network_files/%s",indirectory,FileList[i]);
	  }   
  
      if(ValidNetFile(file2name))
	  {
        secondfile = i;
        break;
	  } 
	} 
  }
  else
  {
    not_while_running(w,"No appropriate features exist in this project\nto create the specified network(s)",1611,"No Network Data Found",5);
	return;
  }


  if(secondfile>=numfiles)
  {
    
    sprintf(finalfile,"%s",file1name);
  }
  else
  {
    

    sprintf(outfilename,"%stemp2.txt",outdirectory);
    sprintf(finalfile,"%s",outfilename);
    tempindex = 2;

    CombineExeOptionsFiles(file1name,file2name,finalfile);

	for(i=secondfile+1;i<numfiles;i++)
	{
      if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
	  {  
        sprintf(file2name,"%sview_network_files\\%s",indirectory,FileList[i]);
	  }  
      else
	  {  
        sprintf(file2name,"%sview_network_files/%s",indirectory,FileList[i]);
	  }   
  
      if(ValidNetFile(file2name))
	  {
        

		
        sprintf(file1name,"%stemp%d.txt",outdirectory,tempindex);
		
		
		tempindex = tempindex + 1;
        sprintf(outfilename,"%stemp%d.txt",outdirectory,tempindex);

        sprintf(finalfile,"%s",outfilename);

        CombineExeOptionsFiles(file1name,file2name,outfilename);
	  }
	}
  }


  

  loadNETsettingCallback(w,(Widget)NULL,finalfile);

}


void preloadsettingCallback(Widget w,XtPointer intype,XtPointer unused)
{
  

  char filename[1000];
  int type=(int)intype,result;
  
  
  
  
  XtPopdown(exefile_dialog);
  set_cursor(mydisplay,mywindow,WATCH);
  if((head_in_use==0)&&(deader_head==0))
    {
      set_cursor(mydisplay,XtWindow(param_head),WATCH);
    }
  if((head_in_use==1)&&(deader_phead==0))
    {
      set_cursor(mydisplay,XtWindow(param2_head),WATCH);
    }
  
  
  if(type==1)
    {
      
      result = GenerateExeFiles(2);   
      
      if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
	{
	  sprintf(filename,"%sinspection_files\\MGCP_master.txt",indirectory);
	}
      else
	{
	  sprintf(filename,"%sinspection_files/MGCP_master.txt",indirectory);
	}
    }
  else if(type==2)
    {
      
      result = GenerateExeFiles(1);   
      
      if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
	{
	  sprintf(filename,"%sinspection_files\\DFEG_master.txt",indirectory);
	}
      else
	{
	  sprintf(filename,"%sinspection_files/DFEG_master.txt",indirectory);
	}
    }
  else if(type==4)
    {
      
      result = GenerateExeFiles(3);   
      
      if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
	{
	  sprintf(filename,"%sinspection_files\\UFD1_master.txt",indirectory);
	}
      else
	{
	  sprintf(filename,"%sinspection_files/UFD1_master.txt",indirectory);
	}
    }
  else if(type==5)
    {
      
      result = GenerateExeFiles(4);   
      
      if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
	{
	  sprintf(filename,"%sinspection_files\\UFD3_master.txt",indirectory);
	}
      else
	{
	  sprintf(filename,"%sinspection_files/UFD3_master.txt",indirectory);
	}
    }
  else if(type==12)
    {
      
      result = GenerateExeFiles(12);   
      
      if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
	{
	  sprintf(filename,"%sinspection_files\\TREX_master.txt",indirectory);
	}
      else
	{
	  sprintf(filename,"%sinspection_files/TREX_master.txt",indirectory);
	}
    }
  else if(type==13)
    {
      
      result = GenerateExeFiles(11);   
      
      if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
	{
	  sprintf(filename,"%sinspection_files\\TDS_master.txt",indirectory);
	}
      else
	{
	  sprintf(filename,"%sinspection_files/TDS_master.txt",indirectory);
	}
    }
  else if(type==10)
    {
      
      result = GenerateExeFiles(9);   
      
      if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
	{
	  sprintf(filename,"%sinspection_files\\AFD_master.txt",indirectory);
	}
      else
	{
	  sprintf(filename,"%sinspection_files/AFD_master.txt",indirectory);
	}
    }


  loadEXEsettingCallback(w,(Widget)NULL,filename);


  if(type==1)
    {
      sprintf(masterrun,"MGCP_master");
    }
  else if(type==2)
    {
      sprintf(masterrun,"DFEG_master");
    }
  else if(type==4)
    {
      sprintf(masterrun,"UFD1_master");
    }
  else if(type==5)
    {
      sprintf(masterrun,"UFD3_master");
    }
  else if(type==10)
    {
      sprintf(masterrun,"AFD_master");
    }
  else if(type==12)
    {
      sprintf(masterrun,"TREX_master");
    }
  else if(type==13)
    {
      sprintf(masterrun,"TDS_master");
    }
  else
    {
      printf("bad value %d to PLSCB\n",type);
    }
}






void savetempCallback(Widget w, XtPointer userData, XtPointer callData)
{
  int nettype = (int)userData;

  if(nettype==1)
  {
     EnterFileCallback(exe_wid, (XtPointer)17,(XtPointer)999999);
  }
  else
  {
     EnterFileCallback(exe_wid, (XtPointer)17,(XtPointer)17);
  }

}


void saveaoiCallback(Widget w, XtPointer userData, XtPointer callData)
{
  EnterFileCallback(aoi_save_wid, (XtPointer)22,(XtPointer)22);
}


void SaveSettingsCallback(Widget w, XtPointer userData, XtPointer callData)
{
  static Widget dialog;
  Widget rc,form,button,label1;
  Arg resources[15];
  int n=0,nettype=(int)userData;


  if(SAVE_SETTINGS_UP==1)
    {
      ResetWidget(dialog);
      return;
    }



  n=0;
  XtSetArg(resources[n],  XmNdeleteResponse, XmDESTROY); n++;
  XtSetArg(resources[n],  XmNmaxWidth,       800);       n++;
  

  dialog = XtCreatePopupShell("Save Inspection Settings",topLevelShellWidgetClass,w,resources,n);



  
  rc = XtVaCreateManagedWidget
    (
     "XformWidget", xmPanedWindowWidgetClass, dialog,
     XmNrubberPositioning, False,
     XmNresizable,         True,
     XmNseparatorOn,       False,
     XmNsashHeight,        1,
     NULL
     );
  
  form = XtVaCreateWidget ("form7", xmFormWidgetClass, rc,
			   XmNpaneMinimum,     35,
			   XmNpaneMaximum,     35,
			   XmNseparatorOn,     False,
			   XmNfractionBase,    100,  
			   NULL);
  
  
  label1 = XtVaCreateManagedWidget ("Enter name for saved settings:",
				    xmLabelWidgetClass,  form,
				    XmNrightAttachment,  XmATTACH_POSITION,
				    XmNrightPosition,    50,
				    XmNleftAttachment,   XmATTACH_POSITION,
				    XmNleftPosition,     0,
				    XmNalignment,        XmALIGNMENT_CENTER,
				    XmNtopAttachment,    XmATTACH_FORM,
				    XmNbottomAttachment, XmATTACH_FORM,
				    LABELWTRANSLATE,
				    NULL);
  XtManageChild(label1);
  
  
  
  exe_wid = XtVaCreateManagedWidget ("text_w",
				     xmTextFieldWidgetClass, form,	  
				     XmNvalue,               SaveSettingName,
				     XmNmaxLength,           24,
				     XmNtraversalOn,         True,
				     XmNrightAttachment,     XmATTACH_POSITION,
				     XmNrightPosition,       99,
				     XmNleftAttachment,      XmATTACH_POSITION,
				     XmNleftPosition,        51,
				     XmNtopAttachment,       XmATTACH_FORM,
				     XmNbottomAttachment,    XmATTACH_FORM,
                     XmNtranslations,        XtParseTranslationTable ( translations_paste ) ,
				     NULL);
  
  XtAddCallback (exe_wid, XmNactivateCallback,
		 EnterFileCallback, (XtPointer)16);
  XtManageChild(exe_wid);
  XtManageChild(form);



  form = XtVaCreateWidget ("form17f", xmFormWidgetClass, rc,
			   XmNpaneMinimum,   25,
			   XmNpaneMaximum,   25,
			   XmNseparatorOn,   False,
			   XmNfractionBase,  100,  
			   NULL);      

  button  = XtVaCreateManagedWidget("SCR4",xmPushButtonWidgetClass,form,
				    XmNlabelString,       STRING("Help"),
				    XmNtopAttachment,     XmATTACH_FORM,
				    XmNbottomAttachment,  XmATTACH_FORM,
				    XmNrightAttachment,   XmATTACH_POSITION,
				    XmNrightPosition,     33,
				    XmNleftAttachment,    XmATTACH_POSITION,
				    XmNleftPosition,      1,
				    XmNtraversalOn,       False,
				    XmNtranslations, XtParseTranslationTable ( translations_global ) ,
				    NULL
				    );
  
  XtAddCallback(button, XmNactivateCallback, savehelpCallback, (XtPointer) NULL);
  XtManageChild(button);
  
  

  button  = XtVaCreateManagedWidget("SCR3",xmPushButtonWidgetClass,form,
				    XmNlabelString,       STRING("Cancel"),
				    XmNtopAttachment,     XmATTACH_FORM,
				    XmNbottomAttachment,  XmATTACH_FORM,
				    XmNrightAttachment,   XmATTACH_POSITION,
				    XmNrightPosition,     66,
				    XmNleftAttachment,    XmATTACH_POSITION,
				    XmNleftPosition,      33,
				    XmNtraversalOn,       False,
				    XmNtranslations, XtParseTranslationTable ( translations_global ) ,
				    NULL
				    );
  
  XtAddCallback(button, XmNactivateCallback, die_callback, (XtPointer) 11);
  XtManageChild(button);



  button  = XtVaCreateManagedWidget("SCR4",xmPushButtonWidgetClass,form,
				    XmNlabelString,       STRING("Save/Done"),
				    XmNtopAttachment,     XmATTACH_FORM,
				    XmNbottomAttachment,  XmATTACH_FORM,
				    XmNrightAttachment,   XmATTACH_POSITION,
				    XmNrightPosition,     99,
				    XmNleftAttachment,    XmATTACH_POSITION,
				    XmNleftPosition,      66,
				    XmNtraversalOn,       False,
				    XmNtranslations, XtParseTranslationTable ( translations_global ) ,
				    NULL
				    ); 
  
  XtAddCallback(button, XmNactivateCallback, savetempCallback, (XtPointer) nettype);
  XtManageChild(button); 
  XtManageChild(form);


  XtManageChild(rc);
  MyPopup(dialog); 
  
    
  XtAddCallback(dialog,XmNdestroyCallback,ShellDeath,(XtPointer)115);

  
  SAVE_SETTINGS_UP = 1;
}




char * ProcessGAITFolder(char path[])
{
  int pathlen,loclen,i;
  char testloc[1000];
  static char newstr[1000];


  

  

  if(strlen(path)<strlen(PROJECTLOC))
    {
      printf("error: potential project %s less than %s\n",path,PROJECTLOC);
    }

  loclen  = strlen(PROJECTLOC) + 1;  
  pathlen = strlen(path);

  for(i=loclen;i<pathlen;i++)
    {
      newstr[i-loclen] = path[i];
    }
  newstr[i-loclen] = '\0';


  if(!strcmp(newstr,"."))
    {
      return "..";
    }
  if(!strcmp(newstr,".."))
    {
      return "..";
    }



  

  
  if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
    {
      sprintf(testloc,"%s\\%s\\",PROJECTLOC,newstr);
    }
  else
    {
      sprintf(testloc,"%s/%s/",PROJECTLOC,newstr);
    }
  

  if(TestDB(testloc,1)==0)
    {
      return "..";
    }

  return newstr;
}



int TestExeFile(char testfile[])
{
  FILE *infile;
  char test[1000],aline[1000],chk_string[1000];
  int num=-1,line,i,errnumber,thisnum;

  if(strstr(testfile,"VVTERR2WAYTEMP"))
  {
	return 0;
  }

  infile = fopen(testfile,"r");
  if(infile==NULL)
    {
      fclose(infile);
      return 0;
    }

  if(feof(infile))
  {
	fclose(infile);
	return 0;
  }

  fscanf(infile,"%s",test);

  if(feof(infile))
  {
	fclose(infile);
	return 0;
  }

  if(strcmp(test,"UNIQUE_CHECKS"))
    {
      fclose(infile);
      return 0;
    }
  
  fscanf(infile,"%d",&num);
  if(num<0)
    {
      fclose(infile);
      return 0;
    }
  
  if(num==0)
    {
      
      fclose(infile);
      return 1;
    }


  
  rewind(infile);
  fgets(aline,1000,infile);
  fgets(aline,1000,infile);
  line = 2;

  for(i=0;i<num;i++)
    {
      thisnum = -1;
      sscanf(aline,"%s%d",chk_string,&thisnum);

      if(thisnum<=0)
	{
	  printf("error in file %s, line %d:  expected a number greater than 0, got %d\n",
		 testfile,line,thisnum);
	  fclose(infile);
	  return 0;
	}
      
      errnumber = ParseErrNumberWrapper(chk_string,line,testfile);
      if(errnumber<0)
	{
	  fclose(infile);
	  return 0;
	}
      line = line + 1;
      fgets(aline,1000,infile);
    }
  fclose(infile);
  

  return 1;
}





char * ProcessGAITCondReport(char path[], int type)
{
  FILE *tempfile;
  int pathlen,loclen,i,newlen,foundit,numchecks,len1,len2;
  char startloc[1000],test1[1000],test2[1000];
  static char newstr[1000];




  if(type==3)
  { 
    sprintf(startloc,"%scondition_reports",indirectory);
  
    if(strlen(path)<strlen(startloc))
    {
      printf("error: potential project %s less than %s\n",path,PROJECTLOC);
    }
  
    loclen  = strlen(startloc) + 1;  
    pathlen = strlen(path);
  
  
    for(i=loclen;i<pathlen;i++)
	{
      newstr[i-loclen] = path[i];
    }
    newstr[i-loclen] = '\0';
  }
  else
  {
	  

      

     
		      sprintf(esname,"%s",path);
		    
		  
		  SetESName();
		  SetNSName();
		  SetLKName();
		  SetBOName();
		  SetNTName();
		  SetSMName();
		  SetVRName();

		  tempfile = fopen(esname,"r");
		  if(tempfile==NULL)
		    {
		      return "..";
		    }
		  fclose(tempfile);



		  tempfile = fopen(vrname,"r");
		  if(tempfile==NULL)
		    {
		      return "..";
		    }

		  
		  if(feof(tempfile)){fclose(tempfile); return "..";}

		  SEEIT_fread_int   (&numchecks,tempfile);
		  if(feof(tempfile)){fclose(tempfile); return "..";}

		  if(numchecks!=CONDITION_DEFINITIONS)
		  {
		    fclose(tempfile); return "..";
		  }

          SEEIT_fread_int   (&len1,     tempfile);
		  if(feof(tempfile)){fclose(tempfile); return "..";}

          SEEIT_fread_int   (&len2,     tempfile);
		  if(feof(tempfile)){fclose(tempfile); return "..";}

		  if((len1<0)||(len2<0)||(len1>500)||(len2>500))
		  {
		    fclose(tempfile); return "..";
		  }

          fread(&test1[0],len1,1,       tempfile);
		  if(feof(tempfile)){fclose(tempfile); return "..";}
		  test1[len1] = '\0';

          fread(&test2[0],len2,1,       tempfile);
		  test2[len2] = '\0';

          

		  fclose(tempfile);





		  tempfile = fopen(nsname,"r");
		  if(tempfile==NULL)
		    {
		      return "..";
		    }
		  fclose(tempfile);

		  tempfile = fopen(lkname,"r");
		  if(tempfile==NULL)
		    {
		      return "..";
		    }
		  fclose(tempfile);

		  tempfile = fopen(boname,"r");
		  if(tempfile==NULL)
		    {
		      return "..";
		    }
		  fclose(tempfile);

		  tempfile = fopen(ntname,"r");
		  if(tempfile==NULL)
		    {
		      return "..";
		    }
		  fclose(tempfile);










	  pathlen = strlen(path);
	  foundit = -1;
      for(i=0;i<pathlen;i++)
	  {
        if(path[i]=='\\')
		{
			foundit = i;
		}
	  }
	  if(foundit<0)
	  {
		  return "..";
	  }
	  for(i=foundit+1;i<pathlen;i++)
	  {
		  newstr[i-(foundit+1)] = path[i];
	  }
	  newstr[i-(foundit+1)] = '\0';
	  
	  return newstr;
  }
  


  





  newlen  = strlen(newstr);

  for(i=0;i<newlen;i++)
    {
      if(newstr[i]=='.')
	{
	  if(i==newlen-3)
	    {
	      if((newstr[i+1]=='e')&&(newstr[i+2]=='s'))
		{
		  newstr[i]='\0';
		  
		  
		  
		  
		  if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
		    {
		      sprintf(esname,"%scondition_reports\\%s.es",indirectory,newstr);
		    }
		  else
		    {
		      sprintf(esname,"%scondition_reports/%s.es",indirectory,newstr);
		    }
		  
		  SetESName();
		  SetNSName();
		  SetLKName();
		  SetBOName();
		  SetNTName();
		  SetSMName();
		  SetVRName();

		  tempfile = fopen(esname,"r");
		  if(tempfile==NULL)
		    {
		      return "..";
		    }
		  fclose(tempfile);



		  tempfile = fopen(vrname,"r");
		  if(tempfile==NULL)
		    {
		      return "..";
		    }

		  
		  if(feof(tempfile)){fclose(tempfile); printf("a\n");  return "..";}

		  SEEIT_fread_int   (&numchecks,tempfile);
		  if(feof(tempfile)){fclose(tempfile); printf("b\n"); return "..";}

		  if(numchecks!=CONDITION_DEFINITIONS)
		  {
		    fclose(tempfile); return "..";
		  }

          SEEIT_fread_int   (&len1,     tempfile);
		  if(feof(tempfile)){fclose(tempfile); printf("c\n"); return "..";}

          SEEIT_fread_int   (&len2,     tempfile);
		  if(feof(tempfile)){fclose(tempfile); printf("d\n"); return "..";}

		  if((len1<0)||(len2<0)||(len1>500)||(len2>500))
		  {
		    fclose(tempfile); printf("e\n"); return "..";
		  }

          fread(&test1[0],len1,1,       tempfile);
		  if(feof(tempfile)){fclose(tempfile); printf("f\n"); return "..";}
		  test1[len1] = '\0';

          fread(&test2[0],len2,1,       tempfile);
		  test2[len2] = '\0';



		  

          

		  fclose(tempfile);





		  tempfile = fopen(nsname,"r");
		  if(tempfile==NULL)
		    {
		      return "..";
		    }
		  fclose(tempfile);

		  tempfile = fopen(lkname,"r");
		  if(tempfile==NULL)
		    {
		      return "..";
		    }
		  fclose(tempfile);

		  tempfile = fopen(boname,"r");
		  if(tempfile==NULL)
		    {
		      return "..";
		    }
		  fclose(tempfile);

		  tempfile = fopen(ntname,"r");
		  if(tempfile==NULL)
		    {
		      return "..";
		    }
		  fclose(tempfile);

		  return newstr;
		}
	    }
	  else
	    {
	      printf("failed because len was %d found . at %d\n",newlen,i);
	      return "..";
	    }
	}
    }
  return "..";
}



char * ProcessGAITExFile(char path[],int nettype)
{
  int pathlen,loclen,i;
  char startloc[1000];
  static char newstr[1000];

  
  
  
  if(TestExeFile(path)==0)
    {
      
      return "..";
    }
  

  if(nettype==1)
  {
    sprintf(startloc,"%sview_network_files",indirectory);
  }
  else
  {
    sprintf(startloc,"%sinspection_files",indirectory);
  }

  
  
  
  if(strlen(path)<strlen(startloc))
    {
      printf("error: potential project %s less than %s\n",path,PROJECTLOC);
    }
  
  loclen  = strlen(startloc) + 1;  
  pathlen = strlen(path);
  
  
  for(i=loclen;i<pathlen;i++)
    {
      newstr[i-loclen] = path[i];
    }
  newstr[i-loclen] = '\0';
  
  
  
  if(!strcmp(newstr,"."))
    {
      return "..";
    }
  if(!strcmp(newstr,".."))
    {
      return "..";
    }
  if(!strcmp(newstr,"MGCP_master.txt"))
    {
      return "..";
    }
  if(!strcmp(newstr,"DFEG_master.txt"))
    {
      return "..";
    }
  if(!strcmp(newstr,"UFD1_master.txt"))
    {
      return "..";
    }
  if(!strcmp(newstr,"UFD3_master.txt"))
    {
      return "..";
    }
  if(!strcmp(newstr,"LTDS_master.txt"))
    {
      return "..";
    }
  if(!strcmp(newstr,"UTDS_master.txt"))
    {
      return "..";
    }
  if(!strcmp(newstr,"RTDS_master.txt"))   
    {
      return "..";
    }
  if(!strcmp(newstr,"GTDS_master.txt"))
    {
      return "..";
    }
  if(!strcmp(newstr,"TDS_master.txt"))
    {
      return "..";
    }
  if(!strcmp(newstr,"AFD_master.txt"))
    {
      return "..";
    }
  if(!strcmp(newstr,"TREX_master.txt"))
    {
      return "..";
    }

  return newstr;
}



int TestAOIFile(char *newname)
{
  FILE *testfile;
  char aline[1000];
  int num=-10,len,type,numspaces,i;
  double x,y;


 testfile = fopen(newname,"r");
 if(testfile==NULL)
   {
     return 0;
   }
 
 
 fgets(aline,1000,testfile);
 
 sscanf(aline,"%d",&num);
 if(num!=CoordinateSystem)
   {
     fclose(testfile);
     return 0;
   }

 fgets(aline,1000,testfile);

 while(!feof(testfile))
   { 
     sscanf(aline,"%d%lf%lf",&type,&x,&y);
     if((type<1)||(type>16))
       {
	 fclose(testfile);
	 return 0;
       }

     
     numspaces = 0;
     len = strlen(aline);
     for(i=0;i<len;i++)
       {
	 if(aline[i]==' ')
	   {
	     numspaces = numspaces + 1;
	   }
       }

     if(numspaces<3)
       {
	 fclose(testfile);
	 return 0;
       }
     fgets(aline,1000,testfile);
   }
 
 fclose(testfile);
 return 1;
}


char * ProcessGAITAOIFile(char path[])
{
  int pathlen,loclen,i;
  char startloc[1000];
  static char newstr[1000];
  
  
  
  
  if(TestAOIFile(path)==0)
    {
      
      return "..";
    }


  sprintf(startloc,"%spoints_of_interest_files",indirectory);
  
  
  
  
  if(strlen(path)<strlen(startloc))
    {
      printf("error: potential project %s less than %s\n",path,PROJECTLOC);
    }
  
  loclen  = strlen(startloc) + 1;  
  pathlen = strlen(path);
  
  
  for(i=loclen;i<pathlen;i++)
    {
      newstr[i-loclen] = path[i];
    }
  newstr[i-loclen] = '\0';
  
  
  if(!strcmp(newstr,"."))
    {
      return "..";
    }
  if(!strcmp(newstr,".."))
    {
      return "..";
    }
    
  return newstr;
}





int ProjectContainsLNfile(char *value)
{
  FILE *infile;
  char testloc[1000];
  

  if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
    {
      sprintf(testloc,"%s\\%s\\exported_shapefiles\\consolidated1LN.shp",PROJECTLOC,value);
      infile = fopen(testloc,"r");
      if(infile!=NULL)
	{
	  fclose(infile);
	  
	  sprintf(testloc,"%s\\%s\\exported_shapefiles\\consolidated1LN.shx",PROJECTLOC,value);
	  infile = fopen(testloc,"r");
	  if(infile!=NULL)
	    {
	      fclose(infile);
	      
	      sprintf(testloc,"%s\\%s\\exported_shapefiles\\consolidated1LN.dbf",PROJECTLOC,value);
	      infile = fopen(testloc,"r");
	      if(infile!=NULL)
		{
		  fclose(infile);
		  return 1;
		}
	    }
	}
    }
  else
    {
      sprintf(testloc,"%s/%s/exported_shapefiles/consolidated1LN.shp",PROJECTLOC,value);
      infile = fopen(testloc,"r");
      if(infile!=NULL)
	{
	  fclose(infile);
	  
	  sprintf(testloc,"%s/%s/exported_shapefiles/consolidated1LN.shx",PROJECTLOC,value);
	  infile = fopen(testloc,"r");
	  if(infile!=NULL)
	    {
	      fclose(infile);
	      
	      sprintf(testloc,"%s/%s/exported_shapefiles/consolidated1LN.dbf",PROJECTLOC,value);
	      infile = fopen(testloc,"r");
	      if(infile!=NULL)
		{
		  fclose(infile);
		  return 1;
		}
	    }
	}
    }
  return 0;
} 
 
  
int ProjectContainsPTfile(char *value)
{
  FILE *infile;
  char testloc[1000];
  
  if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
    {
      sprintf(testloc,"%s\\%s\\exported_shapefiles\\consolidated1PT.shp",PROJECTLOC,value);
      infile = fopen(testloc,"r");
      if(infile!=NULL)
	{
	  fclose(infile);
	  
	  sprintf(testloc,"%s\\%s\\exported_shapefiles\\consolidated1PT.shx",PROJECTLOC,value);
	  infile = fopen(testloc,"r");
	  if(infile!=NULL)
	    {
	      fclose(infile);
	      
	      sprintf(testloc,"%s\\%s\\exported_shapefiles\\consolidated1PT.dbf",PROJECTLOC,value);
	      infile = fopen(testloc,"r");
	      if(infile!=NULL)
		{
		  fclose(infile);
		  return 1;
		}
	    }
	}
    }
  else
    {
      sprintf(testloc,"%s/%s/exported_shapefiles/consolidated1PT.shp",PROJECTLOC,value);
      infile = fopen(testloc,"r");
      if(infile!=NULL)
	{
	  fclose(infile);
	  
	  sprintf(testloc,"%s/%s/exported_shapefiles/consolidated1PT.shx",PROJECTLOC,value);
	  infile = fopen(testloc,"r");
	  if(infile!=NULL)
	    {
	      fclose(infile);
	      
	      sprintf(testloc,"%s/%s/exported_shapefiles/consolidated1PT.dbf",PROJECTLOC,value);
	      infile = fopen(testloc,"r");
	      if(infile!=NULL)
		{
		  fclose(infile);
		  return 1;
		}
	    }
	}
    }
  return 0;
}



int GetFolders(char startlocation[],int type, int scrubextra)
{
  XmString *items;
  Widget temp_w;
  Arg args[15];
  int n=0,numfound=0,i,ii,retnum=0,good=0,j,lastslash,len,foundsomething,
	  usethis,startlen,nettype=0;
  char *text;
  char shortname[1000];
  #if(USE_DOS==1)
  DWORD attrs;
  #endif


  

  if(type==13)
  {
    type = 2;
	nettype = 1;
  }

  if(NGA_TYPE==1)
    {
      XtSetArg(args[n], XmNdirectory, STRING(startlocation));   n++;
    }
  
  startlen = strlen(startlocation);

  if(type==2)
    {
      XtSetArg(args[n], XmNpattern,    STRING("*.txt"));   n++;
    }
  else if((type==3)||(type==9))
    {
      XtSetArg(args[n], XmNpattern,    STRING("*.es"));    n++;
    }
  else if(type==5)
    {
      XtSetArg(args[n], XmNpattern,    STRING("*.txt"));   n++;
    }
  else if(type==6)
    {
      XtSetArg(args[n], XmNpattern,    STRING("*.txt"));   n++;
    }
  else if(type==7)
    {
      
    }
  else if(type==8)
    {
      
    }
  else if(type==10)
    {
      XtSetArg(args[n], XmNpattern,    STRING("*.xml"));   n++;
    }
  else if(type==11)
    {
      XtSetArg(args[n], XmNpattern,    STRING("*.txt"));   n++;
    }
  else if(type==12)
    {
      XtSetArg(args[n], XmNpattern,    STRING("*.csv"));   n++;
    }



  XtSetArg(args[n], XmNtranslations, XtParseTranslationTable ( translations_global )); n++;
  
  temp_w = XmCreateFileSelectionBox (drawing_a,"mymessagebox",args,n);
  

  
  if(
	  (type==1)||(type==4)||(type==7)
	)
    {
      XtVaGetValues (temp_w,  XmNdirListItemCount, &numfound, NULL);
      XtVaGetValues (temp_w,  XmNdirListItems, &items, NULL);
    }
  
  else if(
	       (type==2)||(type==3)||(type==5)||(type==6)||(type==8)||
		   (type==9)||(type==10)||(type==11)||(type==12)
		 )
    {
      XtVaGetValues (temp_w,  XmNfileListItemCount, &numfound, NULL);
      XtVaGetValues (temp_w,  XmNfileListItems, &items, NULL);
    }
  else
  {
    XBell(mydisplay,50);
    printf("Bad flag %d to GF\n",type); 
  }

 
 

  if(type==1)
    {
      GAITProjList = (char **)malloc(sizeof(char *)*(numfound+1));
      for(i=0;i<numfound+1;i++)
	{
	  GAITProjList[i] = NULL;
	}
    }
  else if(type==2)
    {
      GAITExFileList = (char **)malloc(sizeof(char *)*(numfound+1));
      for(i=0;i<numfound+1;i++)
	{
	  GAITExFileList[i] = NULL;
	}
    }
  else if((type==3)||(type==9))
    {
      GAITCondList = (char **)malloc(sizeof(char *)*(numfound+1));
      for(i=0;i<numfound+1;i++)
	{
	  GAITCondList[i] = NULL;
	}
    }
  else if(type==4)
    {
      GAITPrevList = (char **)malloc(sizeof(char *)*(numfound+1));
      for(i=0;i<numfound+1;i++)
	{
	  GAITPrevList[i] = NULL;
	}
    }
  else if(type==5)
    {
      GAITAOIList = (char **)malloc(sizeof(char *)*(numfound+1));
      for(i=0;i<numfound+1;i++)
	{
	  GAITAOIList[i] = NULL;
	}
    }
  else if(type==6)
    {
      GAITPrefList = (char **)malloc(sizeof(char *)*(numfound+5)); 
      for(i=0;i<numfound+5;i++)
	  {
	   GAITPrefList[i] = NULL;
	  }
    }
  else if(type==7)
    {
      TempFolderList = (char **)malloc(sizeof(char *)*(numfound+5));
      for(i=0;i<numfound+5;i++)
	  {
	   TempFolderList[i] = NULL;
	  }
    }
  else if((type==8)||(type==10)||(type==11)||(type==12))
    {
      TempFileList = (char **)malloc(sizeof(char *)*(numfound+5));
      for(i=0;i<numfound+5;i++)
	  {
	   TempFileList[i] = NULL;
	  }
    }
 

  
  for(i=0;i<numfound;i++)
    {
      XmStringGetLtoR(items[i],
		      (XmStringCharSet) XmSTRING_DEFAULT_CHARSET, &text);

      if((type==1)||(type==4))
	  {
	    

	    sprintf(shortname,"%s",ProcessGAITFolder(text));

	    if(strcmp(shortname,".."))
	    {
	      good = 0;

	      for(j=0;j<(int)strlen(shortname);j++)
		  { 
		    if(
		       ((shortname[j]>=65)&&(shortname[j]<=90))  ||
		       ((shortname[j]>=48)&&(shortname[j]<=57))  ||
		       ((shortname[j]>=97)&&(shortname[j]<=122))  ||
		       (shortname[j]=='-') || (shortname[j]=='_')
		       )
			{ 
		      good = 1;
		    }
		    else
		    {
		      good = 0;
		      break;
		    }
		  } 


	      if((good==1)&&(type==1))
		  { 
		    GAITProjList[retnum] = (char *)malloc(500);
		    sprintf(GAITProjList[retnum],"%s",shortname);
		    retnum = retnum + 1;
		  } 
	      else if((good==1)&&(type==4))
		  { 
		    if( 
		       (ProjectContainsLNfile(shortname)==1) ||
		       (ProjectContainsPTfile(shortname)==1) 
		       )
			{		  
		      GAITPrevList[retnum] = (char *)malloc(500);
		      sprintf(GAITPrevList[retnum],"%s",shortname);
		      retnum = retnum + 1;
		    }
		  }
		}
	  }
      else if(type==2)
	{
	  sprintf(shortname,"%s",ProcessGAITExFile(text,nettype));

	  if(strcmp(shortname,".."))
	    {
	      good = 0;
	      for(j=0;j<(int)strlen(shortname);j++)
		{
		  if(
		     ((shortname[j]>=65)&&(shortname[j]<=90))   ||
		     ((shortname[j]>=48)&&(shortname[j]<=57))   ||
		     ((shortname[j]>=97)&&(shortname[j]<=122))  ||
		     (shortname[j]=='-') || (shortname[j]=='_') || (shortname[j]=='.')
		     )
		    {
		      good = 1;
		    }
		  else
		    {
		      good = 0;
		      break;
		    }
		}
	      
	      if(good==1)
		{
		  GAITExFileList[retnum] = (char *)malloc(500);
		  sprintf(GAITExFileList[retnum],"%s",shortname);
		  retnum = retnum + 1;
		}
	    }
	}
      else if((type==3)||(type==9))
	{

	  sprintf(shortname,"%s",ProcessGAITCondReport(text,type));

	  if(strcmp(shortname,".."))
	    {
	      good = 0;
	      for(j=0;j<(int)strlen(shortname);j++)
		{
		  if(
			 ((shortname[j]=='.')&&(type==9))         ||
		     ((shortname[j]>=65)&&(shortname[j]<=90))  ||
		     ((shortname[j]>=48)&&(shortname[j]<=57))  ||
		     ((shortname[j]>=97)&&(shortname[j]<=122))  ||
		     (shortname[j]=='-') || (shortname[j]=='_')
		     )
		    {
		      good = 1;
		    }
		  else
		    {
		      good = 0;
		      break;
		    }
		}
	      	      
	      if(good==1)
		{
		  GAITCondList[retnum] = (char *)malloc(500);
		  sprintf(GAITCondList[retnum],"%s",shortname);
		  retnum = retnum + 1;
		}
	    }
	}
      else if(type==5)
	{
	  sprintf(shortname,"%s",ProcessGAITAOIFile(text));
	  
	  if(strcmp(shortname,".."))
	    {
	      good = 0;
	      for(j=0;j<(int)strlen(shortname);j++)
		{
		  if(
		     ((shortname[j]>=65)&&(shortname[j]<=90))   ||
		     ((shortname[j]>=48)&&(shortname[j]<=57))   ||
		     ((shortname[j]>=97)&&(shortname[j]<=122))  ||
		     (shortname[j]=='-') || (shortname[j]=='_') || (shortname[j]=='.')
		     )
		    {
		      good = 1;
		    }
		  else
		    {
		      good = 0;
		      break;
		    }
		}
	      
	      
	      if(good==1)
		{
		  GAITAOIList[retnum] = (char *)malloc(500);
		  sprintf(GAITAOIList[retnum],"%s",shortname);
		  retnum = retnum + 1;
		}
	    }
	}
      else if(type==6)
	{
	  sprintf(shortname,"%s",ProcessGAITPrefFile(text));
	  
	  if(strcmp(shortname,".."))
	    {
	      good = 0;
	      for(j=0;j<(int)strlen(shortname);j++)
		{
		  if(
		     ((shortname[j]>=65)&&(shortname[j]<=90))   ||
		     ((shortname[j]>=48)&&(shortname[j]<=57))   ||
		     ((shortname[j]>=97)&&(shortname[j]<=122))  ||
		     (shortname[j]=='-') || (shortname[j]=='_') || (shortname[j]=='.')
		     )
		    {
		      good = 1;
		    }
		  else
		    {
		      good = 0;
		      break;
		    }
		}
	      
	      if(good==1)
		{
		  GAITPrefList[retnum] = (char *)malloc(500);
		  sprintf(GAITPrefList[retnum],"%s",shortname);
		  retnum = retnum + 1;
		}
	    }
	}
	else if(type==7)
	{

      
      lastslash = 0;
	  len = strlen(text);
	  for(ii=0;ii<len;ii++)
	  {
	    if(text[ii]=='\\')
		 {
		  lastslash = ii;
		 }
	  }
	  foundsomething = 0;
	  for(ii=lastslash+1;ii<len;ii++)
	  {
		 if(text[ii]!='.')
		 {
		  foundsomething = 1;
		  break;
		 }
	  }

	  if(foundsomething==1)
	  { 
		usethis = 1;
         
        #if(USE_DOS==1)

        if((numfound<200)||(text[0]=='c')||(text[0]=='C'))
		{ 
	      attrs = GetFileAttributes(text);
	      if(attrs & FILE_ATTRIBUTE_DIRECTORY)
		  {
            if(attrs & FILE_ATTRIBUTE_HIDDEN)
			{
		      if(DOSDEBUG==1)
			  {
			    printf("ignoring %s because it is hidden\n",text);
			  }
			  usethis = 0;
			}

		    if(attrs & FILE_ATTRIBUTE_SYSTEM)
			{
              if(DOSDEBUG==1)
			  {
			    printf("ignoring %s because it is a system file\n",text);
			  }
			  usethis = 0;
			}
		  }
		  else
		  {
			printf("Error:  found pseudo-folder %s.  Trying to use it anyway\n",text);
		  }
		} 
		  
        #endif

	    if(scrubextra==1)
		{ 
          if(len>=5)
		  {
            if(
                (text[len-4]=='.') &&
                ( (text[len-3]=='g') || (text[len-3]=='G') ) &&
                ( (text[len-2]=='d') || (text[len-2]=='D') ) &&
                ( (text[len-1]=='b') || (text[len-1]=='B') )
              )
			{ 
              usethis = 0;
			} 
		  } 
		}

        if(usethis==1)
		{
          TempFolderList[retnum] = (char *)malloc(len+255);
          sprintf(TempFolderList[retnum],"%s\\",text);
          retnum = retnum + 1;
		  }
		}
	}
	else if((type==8)||(type==10)||(type==11)||(type==12))
	{
		usethis = 1;

		#if(USE_DOS==1)

         if((numfound<200)||(text[0]=='c')||(text[0]=='C'))
		  {
	      attrs = GetFileAttributes(text);
	      if(attrs & FILE_ATTRIBUTE_DIRECTORY)
		  {
			
			usethis = 0;
		  }
		  if(attrs & FILE_ATTRIBUTE_HIDDEN)
		  {
		    if(DOSDEBUG==1)
			{
		     printf("ignoring %s because it is hidden\n",text);
			}
		    usethis = 0;
		  }
	      if(attrs & FILE_ATTRIBUTE_SYSTEM)
		  {
		    if(DOSDEBUG==1)
			{
		     printf("ignoring %s because it is a system file\n",text);
			}
		  }
	      if(attrs & FILE_ATTRIBUTE_READONLY)
		  {
		    if(DOSDEBUG==1)
			{
		     printf("ignoring %s because it is readonly\n",text);
			}
		  }
		 }
			 
        #endif


	  if(usethis==1)
	  {
        TempFileList[retnum] = (char *)malloc(strlen(text)+255);
	    
	  
	    for(ii=startlen;ii<(int)strlen(text);ii++)
		{
          TempFileList[retnum][ii-startlen] = text[ii];
		}
        TempFileList[retnum][ii-startlen] = '\0';


        if((!strcmp(TempFileList[retnum],"[   ]"))&&(numfound==1))
		{
		  
		  free(TempFileList[retnum]);
		  continue;
		}

        retnum = retnum + 1;
	  }

	}
      else
	{
	  printf("bad type to GetFolders %d\n",type);
	}
      XtFree(text);
    }  
  return retnum;
}







int SpecialStrcmp(char ina[], char inb[], int type)
{
  

  int alen,blen,maxlen,i,num1,num2,j,astop,bstop;
  char a[1000],b[1000],anum[100],bnum[100];


  if(!strcmp(ina,inb))
    {
      return 0;
    }

  sprintf(a,"%s",ina);
  sprintf(b,"%s",inb);

  alen = strlen(a);
  blen = strlen(b);
  if(alen>blen)
    {
      maxlen = alen;
    }
  else
    {
      maxlen = blen;
    }

  for(i=0;i<(int)strlen(a);i++)
    {
      a[i] = timtoupper(a[i]);
    }
  for(i=0;i<(int)strlen(b);i++)
    {
      b[i] = timtoupper(b[i]);
    }


  if(!strcmp(a,b))
    {
      
      return strcmp(ina,inb);
    }



  for(i=0;i<maxlen;i++)
    {
      if(a[i]=='\0')
	{
	  return 1;
	}
      else if(b[i]=='\0')
	{
	  return -1;
	}
      else if(((a[i]=='-')&&(a[i]!=b[i]))  && (type!=7))
	{
	  return 1;
	}
      else if(((b[i]=='-')&&(a[i]!=b[i]))  && (type!=7))
	{
	  return -1;
	}
      else if(((a[i]=='_')&&(a[i]!=b[i]))  && (type!=7))
	{
	  return 1;
	}
      else if(((b[i]=='_')&&(a[i]!=b[i]))  && (type!=7))
	{
	  return -1;
	}
      else if((a[i]==b[i])&&(!IsNumber(a[i])))
	{
	  continue;
	}

      else if(IsNumber(a[i]) && IsNumber(b[i]))
	{
	  

	  astop = -1;
	  bstop = -1;

	  for(j=i;j<maxlen;j++)
	    {
	      if(IsNumber(a[j]))
		{
		  anum[j-i]   = a[j];
		  astop       = j+1;
		  anum[j-i+1] = '\0';
		}
	      else
		{
		  astop = j;
		  anum[j-i] = '\0';
		  break;
		}
	    }


	  for(j=i;j<maxlen;j++)
	    {
	      if(IsNumber(b[j]))
		{
		  bnum[j-i]   = b[j];
		  bstop       = j+1;
		  bnum[j-i+1] = '\0';
		}
	      else
		{
		  bstop = j;
		  bnum[j-i] = '\0';
		  break;
		}
	    }
	  if(j==maxlen)
	    {
	      bstop = j;
	      bnum[j-i] = '\0';
	    }

	  
	  
	      
	  sscanf(anum,"%d",&num1);
	  sscanf(bnum,"%d",&num2);


	  

	  if((num1==num2)&&(astop==bstop))
	    {
	      i = astop -1;
	      continue;
	    }
	  else if(num1==num2)
	    {
	      

	      if(astop<bstop)
		{
		  return -1;
		}
	      else
		{
		  return 1;
		}
	    }
	  else
	    {
	      if(num1<num2)
		{
		  return 1;
		}
	      else
		{
		  return -1;
		}
	    }


	}

    
      else if(IsLetter(a[i]) && IsLetter(b[i]))
	{
	  if(a[i]<b[i])
	    {
	      return 1;
	    }
	  if(b[i]<a[i])
	    {
	      return -1;
	    }
	}
      else if( IsLetter(a[i]) && IsNumber(b[i]) )
	{	
	  return -1;
	}
      else if( IsLetter(b[i]) && IsNumber(a[i]) )
	{
	  return 1;
	}
      else if((type==2)||(type==3)||(type==4))
	{
	  
	  

	  return -1*strcmp(a,b);
	}
      else if(type==7)
	{
	  
	  
	  if(a[i]=='\\'){return  1;}  
	  if(b[i]=='\\'){return -1;}  
	  
	  
	  if(a[i]=='0') {return  1;}
	  if(b[i]=='0') {return -1;}
	  if(a[i]=='1') {return  1;}
	  if(b[i]=='1') {return -1;}
	  if(a[i]=='2') {return  1;}
	  if(b[i]=='2') {return -1;}
	  if(a[i]=='3') {return  1;}
	  if(b[i]=='3') {return -1;}
	  if(a[i]=='4') {return  1;}
	  if(b[i]=='4') {return -1;}
	  if(a[i]=='5') {return  1;}
	  if(b[i]=='5') {return -1;}
	  if(a[i]=='6') {return  1;}
	  if(b[i]=='6') {return -1;}
	  if(a[i]=='7') {return  1;}
	  if(b[i]=='7') {return -1;}
	  if(a[i]=='8') {return  1;}
	  if(b[i]=='8') {return -1;}
	  if(a[i]=='9') {return  1;}
	  if(b[i]=='9') {return -1;}
	  if(a[i]==' ') {return  1;}
	  if(b[i]==' ') {return -1;}
	  if(a[i]=='!') {return  1;}
	  if(b[i]=='!') {return -1;}
	  if(a[i]=='#') {return  1;}
	  if(b[i]=='#') {return -1;}
	  if(a[i]=='$') {return  1;}
	  if(b[i]=='$') {return -1;}
	  if(a[i]=='%') {return  1;}
	  if(b[i]=='%') {return -1;}
	  if(a[i]=='&') {return  1;}
	  if(b[i]=='&') {return -1;}
	  if(a[i]=='(') {return  1;}
	  if(b[i]=='(') {return -1;}
	  if(a[i]==')') {return  1;}
	  if(b[i]==')') {return -1;}
	  if(a[i]==',') {return  1;}
	  if(b[i]==',') {return -1;}
	  if(a[i]=='.') {return  1;}
	  if(b[i]=='.') {return -1;}
	  if(a[i]==';') {return  1;}
	  if(b[i]==';') {return -1;}
	  if(a[i]=='@') {return  1;}
	  if(b[i]=='@') {return -1;}
	  if(a[i]=='[') {return  1;}
	  if(b[i]=='[') {return -1;}
	  if(a[i]==']') {return  1;}
	  if(b[i]==']') {return -1;}
	  if(a[i]=='^') {return  1;}
	  if(b[i]=='^') {return -1;}
	  if(a[i]=='_') {return  1;}
	  if(b[i]=='_') {return -1;}
	  if(a[i]=='`') {return  1;}
	  if(b[i]=='`') {return -1;}
	  if(a[i]=='{') {return  1;}
	  if(b[i]=='{') {return -1;}
	  if(a[i]=='}') {return  1;}
	  if(b[i]=='}') {return -1;}
	  if(a[i]=='~') {return  1;}
	  if(b[i]=='~') {return -1;}
	  if(a[i]=='+') {return  1;}
	  if(b[i]=='+') {return -1;}
	  if(a[i]=='=') {return  1;}
	  if(b[i]=='=') {return -1;}
	  
	  if(a[i]=='\''){return  1;}
	  if(b[i]=='\''){return -1;}
	  if(a[i]=='-') {return  1;}
	  if(b[i]=='-') {return -1;}
	  
	  printf("unusual sorting case for %s %s\n",ina,inb);
	  
	  return strcmp(a,b);
	}
      else
	{
	  printf("bad case for %s %s\n",ina,inb);
	}

    }
  
  XBell(mydisplay,50);
  printf("error:fail in sorting for %s %s\n",ina,inb);
  return strcmp(ina,inb);
}



int PartitionPrefList(int p,int r, int type)
{
  char x[500];
  int i,j;
  char temp[500];

  sprintf(x,"%s",GAITPrefList[p]);
  i = p-1;
  j = r+1;
  while(1)
    {
      do{j=j-1;}
      while(SpecialStrcmp(GAITPrefList[j],x,type)<0);  
      
      do{i=i+1;}
      while(SpecialStrcmp(GAITPrefList[i],x,type)>0);
      
      if(i<j)
	{
	  sprintf(temp,"%s",GAITPrefList[i]);
	  sprintf(GAITPrefList[i],"%s",GAITPrefList[j]);
	  sprintf(GAITPrefList[j],"%s",temp);
	}
      else
	{
	  return j;
	}
    }
}


int PartitionAOIList(int p,int r, int type)
{
  char x[500];
  int i,j;
  char temp[500];

  sprintf(x,"%s",GAITAOIList[p]);
  i = p-1;
  j = r+1;
  while(1)
    {
      do{j=j-1;}
      while(SpecialStrcmp(GAITAOIList[j],x,type)<0);  
      
      do{i=i+1;}
      while(SpecialStrcmp(GAITAOIList[i],x,type)>0);
      
      if(i<j)
	{
	  sprintf(temp,"%s",GAITAOIList[i]);
	  sprintf(GAITAOIList[i],"%s",GAITAOIList[j]);
	  sprintf(GAITAOIList[j],"%s",temp);
	}
      else
	{
	  return j;
	}
    }
}



int PartitionCondList(int p,int r, int type)
{
  char x[500];
  int i,j;
  char temp[500];

  sprintf(x,"%s",GAITCondList[p]);
  i = p-1;
  j = r+1;
  while(1)
    {
      do{j=j-1;}
      while(SpecialStrcmp(GAITCondList[j],x,type)<0);  

      do{i=i+1;}
      while(SpecialStrcmp(GAITCondList[i],x,type)>0);
    
      if(i<j)
	{
	  sprintf(temp,"%s",GAITCondList[i]);
	  sprintf(GAITCondList[i],"%s",GAITCondList[j]);
	  sprintf(GAITCondList[j],"%s",temp);
	}
      else
	{
	  return j;
	}
    }
}



int PartitionNetList(int p,int r, int type)
{
  char x[500];
  int i,j;
  char temp[500];

  sprintf(x,"%s",NetDriveNames[p]);
  i = p-1;
  j = r+1;
  while(1)
    {
      do{j=j-1;}
      while(SpecialStrcmp(NetDriveNames[j],x,type)<0);  

      do{i=i+1;}
      while(SpecialStrcmp(NetDriveNames[i],x,type)>0);
    
      if(i<j)
	{
	  sprintf(temp,"%s",NetDriveNames[i]);
	  sprintf(NetDriveNames[i],"%s",NetDriveNames[j]);
	  sprintf(NetDriveNames[j],"%s",temp);

	  

	  sprintf(temp,"%s",NetDrivePaths[i]);
	  sprintf(NetDrivePaths[i],"%s",NetDrivePaths[j]);
	  sprintf(NetDrivePaths[j],"%s",temp);

	}
      else
	{
	  return j;
	}
    }
}



int PartitionProjList(int p,int r, int type)
{
  char x[500];
  int i,j;
  char temp[500];

  sprintf(x,"%s",GAITProjList[p]);
  i = p-1;
  j = r+1;
  while(1)
    {
      do{j=j-1;}
      while(SpecialStrcmp(GAITProjList[j],x,type)<0);  

      do{i=i+1;}
      while(SpecialStrcmp(GAITProjList[i],x,type)>0);
    
      if(i<j)
	{
	  sprintf(temp,"%s",GAITProjList[i]);
	  sprintf(GAITProjList[i],"%s",GAITProjList[j]);
	  sprintf(GAITProjList[j],"%s",temp);
	}
      else
	{
	  return j;
	}
    }
}




int PartitionFolderList(int p,int r, int type)
{
  char x[500];
  int i,j;
  char temp[500];

  sprintf(x,"%s",TempFolderList[p]);
  i = p-1;
  j = r+1;
  while(1)
    {
      do{j=j-1;}
      while(SpecialStrcmp(TempFolderList[j],x,type)<0);  

      do{i=i+1;}
      while(SpecialStrcmp(TempFolderList[i],x,type)>0);
    
      if(i<j)
	{
	  sprintf(temp,"%s",TempFolderList[i]);
	  sprintf(TempFolderList[i],"%s",TempFolderList[j]);
	  sprintf(TempFolderList[j],"%s",temp);
	}
      else
	{
	  return j;
	}
    }
}




int PartitionFileList(int p,int r, int type)
{
  char x[500];
  int i,j;
  char temp[500];

  sprintf(x,"%s",TempFileList[p]);
  i = p-1;
  j = r+1;
  while(1)
    {
      do{j=j-1;}
      while(SpecialStrcmp(TempFileList[j],x,type)<0);  

      do{i=i+1;}
      while(SpecialStrcmp(TempFileList[i],x,type)>0);
    
      if(i<j)
	{
	  sprintf(temp,"%s",TempFileList[i]);
	  sprintf(TempFileList[i],"%s",TempFileList[j]);
	  sprintf(TempFileList[j],"%s",temp);
	}
      else
	{
	  return j;
	}
    }
}




int PartitionPrevList(int p,int r, int type)
{
  char x[500];
  int i,j;
  char temp[500];

  sprintf(x,"%s",GAITPrevList[p]);
  i = p-1;
  j = r+1;
  while(1)
    {
      do{j=j-1;}
      while(SpecialStrcmp(GAITPrevList[j],x,type)<0);  

      do{i=i+1;}
      while(SpecialStrcmp(GAITPrevList[i],x,type)>0);
    
      if(i<j)
	{
	  sprintf(temp,"%s",GAITPrevList[i]);
	  sprintf(GAITPrevList[i],"%s",GAITPrevList[j]);
	  sprintf(GAITPrevList[j],"%s",temp);
	}
      else
	{
	  return j;
	}
    }
}



int PartitionExeFileList(int p,int r, int type)
{
  char x[500];
  int i,j;
  char *temp;

  sprintf(x,"%s",GAITExFileList[p]);
  i = p-1;
  j = r+1;
  while(1)
    {
      do{j=j-1;}
      while(SpecialStrcmp(GAITExFileList[j],x,type)<0);

      do{i=i+1;}
      while(SpecialStrcmp(GAITExFileList[i],x,type)>0);
    
      if(i<j)
	{
	  temp              = GAITExFileList[i];
	  GAITExFileList[i] = GAITExFileList[j];
	  GAITExFileList[j] = temp;
	}
      else
	{
	  return j;
	}
    }
}



void SortPrefList(int p,int r, int type)
{
  int q;

  
  
  if(p<r)
    {
      q = PartitionPrefList(p,r,type);
      SortPrefList(p,q,type);
      SortPrefList(q+1,r,type);
    }
}

void SortAOIList(int p,int r, int type)
{
  int q;

  
  
  if(p<r)
    {
      q = PartitionAOIList(p,r,type);
      SortAOIList(p,q,type);
      SortAOIList(q+1,r,type);
    }
}


void SortCondList(int p,int r, int type)
{
  int q;

  
  
  if(p<r)
    {
      q = PartitionCondList(p,r,type);
      SortCondList(p,q,type);
      SortCondList(q+1,r,type);
    }
}



void SortNetList(int p,int r)
{
  int q;
  
  if(p<r)
    {
      q = PartitionNetList(p,r,7);  
      SortNetList(p,q);
      SortNetList(q+1,r);
    }
}



void SortProjList(int p,int r, int type)
{
  int q;

  
  
  if(p<r)
    {
      q = PartitionProjList(p,r,type);
      SortProjList(p,q,type);
      SortProjList(q+1,r,type);
    }
}


void SortFolderList(int p,int r, int type)
{
  int q;

  
  
  if(p<r)
    {
      q = PartitionFolderList(p,r,type);
      SortFolderList(p,q,type);
      SortFolderList(q+1,r,type);
    }
}



void SortFileList(int p,int r, int type)
{
  int q;

  

  if(p<r)
    {
      q = PartitionFileList(p,r,type);
      SortFileList(p,q,type);
      SortFileList(q+1,r,type);
    }
}


void SortPrevList(int p,int r, int type)
{
  int q;

  
  
  if(p<r)
    {
      q = PartitionPrevList(p,r,type);
      SortPrevList(p,q,type);
      SortPrevList(q+1,r,type);
    }
}


void SortExeFileList(int p,int r,int type)
{
  int q;
  
  

  if(p<r)
    {
      q = PartitionExeFileList(p,r,type);
      SortExeFileList(p,q,type);
      SortExeFileList(q+1,r,type);
    }
}





void LoadSettingsCallback(Widget w, XtPointer userData, XtPointer callData)
{
  static Widget dialog,netdialog;
  char startdirectory[1000],message[1000];
  int i,num,nettype=(int)userData;




  if(DEBUG==1){printf("load settings\n");}


  if((nettype==0)&&(LOAD_SETTINGS_UP==1))
    {
      ResetWidget(dialog);
      return;
    }
  if((nettype==1)&&(LOAD_NETSETTINGS_UP==1))
    {
      ResetWidget(netdialog);
      return;
    }


  if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
    {
	  if(nettype==1)
	  {
        sprintf(startdirectory,"%sview_network_files\\",indirectory);
	  }
	  else
	  {
        sprintf(startdirectory,"%sinspection_files\\",indirectory);
	  }
    }
  else
    {
      if(nettype==1)
	  {
        sprintf(startdirectory,"%sview_network_files/",indirectory);
	  }
	  else
	  {
        sprintf(startdirectory,"%sinspection_files/",indirectory);
	  }
    }


  if(nettype==1)
  {
    num = GetFolders(startdirectory,13,1);
  }
  else
  {
    num = GetFolders(startdirectory,2,1);
  }

  
  if(num==0)
    {
	  if(nettype==1)
	  {
        sprintf(message,"No valid, current GAIT network specification\n\
files were found in the current project:\n  %s\n\n\
The \"Re-generate inspection specification files for current project...\"\n\
option under the \"File\" menu can be used to re-create these files.\n",startdirectory);
	  }
	  else
	  {
        sprintf(message,"No valid, current GAIT inspection specification\n\
files were found in the current project:\n  %s\n\n\
The \"Re-generate inspection specification files for current project...\"\n\
option under the \"File\" menu can be used to re-create these files.\n",startdirectory);
      }

      not_while_running(w,message,1419,"No Specification Files Found",1);   
      return;
      
    }
  else
    {

      
      

      SortExeFileList(0,num-1,2); 
      
      

      

    }




       
  
  

  if(nettype==0)
  {
    exefile_dialog = MakePicker(NULL,2,num,-1,-1); 
  }
  else
  {
    exefile_dialog = MakePicker(NULL,9,num,-1,-1); 
  }

  if(nettype==1)
  {
    netdialog         = exefile_dialog;
    LOAD_NETSETTINGS_UP = 1;
  }
  else
  {
    dialog         = exefile_dialog;
    LOAD_SETTINGS_UP = 1;
  }
  
  for(i=0;i<num;i++)
    {
      free(GAITExFileList[i]);
    }
  free(GAITExFileList);
  GAITExFileList = NULL;
  
}





void CloneCallback(Widget w, XtPointer userData, XtPointer callData)
{
  int Clonenum=(int)userData;
  int lowindex,highindex,insertindex,j,axis,nettype=0;
  int override=(int)callData;
  extern int CLONE_RANGE;
  extern void SetDefaultParticipants(int Check, int Clone, int Cloneindex);
  extern void SetDefaultSensitivities(int Check, int Clone, int Cloneindex);


  if(SingleInstance(Clonenum))
  {
    printf("***Cannot create instances of %s (%s)\n",ErrorLookup[Clonenum].name,ParseErrName(Clonenum));
	return;
  }

  if(Clonenum>9990)
  { 
    Clonenum = Clonenum - 10000;
    nettype = 1;
  } 


  if(CLONEDEBUG==1)
    {
      printf("Clone %d\n",Clonenum);
    }

  if(CLONE_RANGE>0)
  {
    CLONE_DEFINITIONS = CLONE_DEFINITIONS  + CLONE_RANGE;
    ErrorLookup[Clonenum].num_clones = ErrorLookup[Clonenum].num_clones + CLONE_RANGE;
  }
  else
  {
    CLONE_DEFINITIONS = CLONE_DEFINITIONS  + 1;
    ErrorLookup[Clonenum].num_clones = ErrorLookup[Clonenum].num_clones + 1;
  }

  

  if(CloneErrorLookup==NULL)
  {
    if(CLONEDEBUG==1)
	{
	  printf("case 1\n");
	}

    CloneErrorLookup = (struct CloneErrorTable *)malloc(CLONE_DEFINITIONS * sizeof(struct CloneErrorTable));
  }
  else
  {
    if(CLONEDEBUG==1)
 	{
	  printf("case 2\n");
	}


      CloneErrorLookup = (struct CloneErrorTable *)
	realloc(CloneErrorLookup,CLONE_DEFINITIONS*sizeof(struct CloneErrorTable));

	  if(CloneErrorLookup==NULL)
	  {
		printf("Error: Out of memory!  (CERA)\n");
		exit(-1);
	  }

      

    }


  if(CLONE_RANGE>0)
  {
	highindex = CLONE_DEFINITIONS-1;
	lowindex = highindex - CLONE_RANGE + 1;
  }
  else
  {
	lowindex  = CLONE_DEFINITIONS-1;
	highindex = CLONE_DEFINITIONS-1;
  }


  for(insertindex=lowindex;insertindex<=highindex;insertindex++)
  {
   CloneErrorLookup[insertindex].groupnums        = NULL;
   CloneErrorLookup[insertindex].Annotation       = NULL;
   CloneErrorLookup[insertindex].CloneNumber      = Clonenum;
   CloneErrorLookup[insertindex].active           = 0;
   CloneErrorLookup[insertindex].onoff            = cond_start_onoff;
   CloneErrorLookup[insertindex].NETonoff         = cond_start_onoff;
   CloneErrorLookup[insertindex].VConoff          = cond_start_onoff;
   CloneErrorLookup[insertindex].pos_list_made    = 0;
   CloneErrorLookup[insertindex].NETpos_list_made = 0;
   CloneErrorLookup[insertindex].scrollwidmadeNET = 0;
   CloneErrorLookup[insertindex].scrollwidmade    = 0;
   CloneErrorLookup[insertindex].filterout        = 0;
   CloneErrorLookup[insertindex].viewall          = 0;
   CloneErrorLookup[insertindex].viewsome         = 0;
   CloneErrorLookup[insertindex].viewallNET       = 0;
   CloneErrorLookup[insertindex].viewsomeNET      = 0;
   CloneErrorLookup[insertindex].keepdismiss      = NULL;
   CloneErrorLookup[insertindex].numberNets       = 0;
   CloneErrorLookup[insertindex].sensitivity      = 0;
   CloneErrorLookup[insertindex].sensitivity2     = 0;
   CloneErrorLookup[insertindex].sensitivity3     = 0;
   CloneErrorLookup[insertindex].sensitivity4     = 0;
   CloneErrorLookup[insertindex].sensitivity5     = 0;
   CloneErrorLookup[insertindex].sensitivity6     = 0;

   SetDefaultParticipants (Clonenum, 1, insertindex);
   SetDefaultSensitivities(Clonenum, 1, insertindex);

   CloneErrorLookup[insertindex].UseBorderConds = ErrorLookup[Clonenum].UseBorderCondsDefault;

   for(j=0;j<NUM_C;j++)
	{
      for(axis=0;axis<(3+1);axis++)
	  {
	   CloneErrorLookup[insertindex].AllConfigOn[axis][j]       = 0;
	   CloneErrorLookup[insertindex].SpecifiedConfigOn[axis][j] = 1;
	  } 
    }

  if(override!=999)
    {
      if(nettype==1)
	  {
        revertCallback((Widget)NULL, (XtPointer) 6, (XtPointer)NULL);
	  }
	  else
	  {
        revertCallback((Widget)NULL, (XtPointer) 4, (XtPointer)NULL);
	  }
    }
  }
}



void DeselectCallback(Widget w, XtPointer userData, XtPointer callData)
{
  
  int i,errnum=(int)userData;
  int madeachange=0,nettype=0;


  if(errnum>9990)
  { 
    errnum = errnum - 10000;
    nettype = 1;
  }


  if(ErrorLookup[errnum].active!=0)
  {
    ErrorLookup[errnum].active = 0;
	madeachange = 1;
  }


  for(i=0;i<CLONE_DEFINITIONS;i++)
  {
    if(CloneErrorLookup[i].CloneNumber==errnum)
	{
      if(CloneErrorLookup[i].active!=0)
	  {
        CloneErrorLookup[i].active = 0;
        madeachange = 1;
	  } 
	}
  } 


  if(madeachange>0)
  {
    if(nettype==1)
	{
      revertCallback((Widget)NULL, (XtPointer) 6, (XtPointer)NULL);
	}
	else
	{
      revertCallback((Widget)NULL, (XtPointer) 4, (XtPointer)NULL);
	}
  }

}


char *GetShapeMessageName()
{
  if(ATTRTYPE_TREX())
  {
    return GetTRExFileName();
  }

  return shape_out_name;
}


void MakeAllShapefiles(Widget widget,XtPointer data,XtPointer callData)
{
  int i;
  char message[1000];
  int total = 0,num_files = 0;


  ABORT_ZOOM = 0;


  for(i=1;i<=CONDITION_DEFINITIONS;i++)
  { 
    ErrorLookup[i].exportnumber = ErrorLookup[i].number;
    total = total + ErrorLookup[i].number; 
  }
  

  for(i=0;i<CLONE_DEFINITIONS;i++)
  { 
    CloneErrorLookup[i].exportnumber = 0;
    CloneErrorLookup[i].exportnumber = CloneErrorLookup[i].number;
    total = total + CloneErrorLookup[i].number;
  }

  
  if(total==0)
  { 
    if(batch_mode==0)
	{ 
	  XtSetSensitive(shapewid, False);
	  XtSetSensitive(condwid1,False);
	  XtSetSensitive(condwid2,False);
	  
	  sprintf(message,"There are no current conditions to make Shapefiles from!\n");
	  not_while_running(drawing_a,message,1083,"No conditions present",1);
	} 
    else
	{ 
	  printf("There are no current conditions to make Shapefiles from!\n");
	} 
    return;
  }



 
  if(batch_mode==0)
  {
    set_cursor(mydisplay,mywindow,WATCH);
  }



  

  if(LLFidTableCount>0)
  {
    BuildFIDTable(1,LLFidTableCount); 
  }

  num_files = MakeConsolidatedShape();

  if(LLFidTableCount>0)
  {
    FreeFidTable();
  }

  if((batch_mode==1)||(num_files==0))
  {
    return;
  }


  set_cursor(mydisplay,mywindow,GOOD);  


  if(num_files==1)
  {
     if(ATTRTYPE_TREX())
	 {
       sprintf(message,"\"%s_1PT\"\n has been created.",GetShapeMessageName());
	 }
	 else
	 {
       sprintf(message,"\"%sPT\" and/or \n\"%sLN\" shapefiles have been created, which\n\
contain the point and non-point conditions, respectively.\n\n\
These Shapefiles are in the folder:\n\n %sexported_shapefiles\n",GetShapeMessageName(),GetShapeMessageName(),indirectory);

	 }
  }
  else
  {
	 if(ATTRTYPE_TREX())
	 {
       sprintf(message,"\"%s_[1..%d]PT\"\n have been created.",GetShapeMessageName(),num_files);
	 }
	 else
	 {
       sprintf(message,"\"%s[1..%d]PT\" and/or \n\"%s[1..%d]LN\" shapefiles have been created, which\n\
contain the point and non-point conditions, respectively.\n\n\
These Shapefiles are in the directory:\n\n %sexported_shapefiles\n",GetShapeMessageName(),num_files,GetShapeMessageName(),num_files,indirectory);
	 }
  }

  if(INCLUDE_PROJECTION>0)
  {
    strcat(message,"\nThese files have GCS WGS 84 projections defined.");
  } 

  not_while_running(drawing_a,message,1084,"Shapefiles Created",5);

}



int SingleConditionSelected(int isclone,int index)
{
  int TotalSpecs,TotalSpecs2,ErrorIndex,SingleBegin,SingleEnd,CloneIndex;


  TotalSpecs  = GetTotalIndiv(&ErrorIndex,&SingleBegin,&SingleEnd,&CloneIndex);
  TotalSpecs2 = GetTotalNonIndiv();


  if( (TotalSpecs>1)||(TotalSpecs2>0) )
  { 	
    

    if(QUICKDEBUG==1)
	{
      printf("Not refreshing because %d %d!\n",TotalSpecs,TotalSpecs2);
	}


    return 0; 
  } 

  if(QUICKDEBUG==1)
  {
    printf("Refreshing!\n");
  }

  return 1;
}


void choose_specific_error(Widget unused,XtPointer client_data,XtPointer call_data)
{ 
  static int LOCALBUSY = 0;
  int *pos_list;
  int errnum = (int)client_data,pos_count,i;


  


  XmListGetSelectedPos(ErrorLookup[errnum].scrollwid,&pos_list,&pos_count);
  
  if(ErrorLookup[errnum].pos_list_made>0)
    {
      free(ErrorLookup[errnum].pos_list);
      ErrorLookup[errnum].pos_list_made = 0;
    }
  
  ErrorLookup[errnum].pos_list = (int *)malloc(SzI*pos_count);
  if(ErrorLookup[errnum].pos_list==NULL)
    {
      printf("Failed to alloc %d PLM\n",pos_count);
      ExitWrapper(-1);
    }


  for(i=0;i<pos_count;i++)
    {
      ErrorLookup[errnum].pos_list[i] = pos_list[i];
    }
  
  ErrorLookup[errnum].pos_list_made = pos_count;




  if(
     (ErrorLookup[errnum].viewall ==0) &&
     (ErrorLookup[errnum].viewsome==0)
     )
    {
      
      return;
    }



  if(LOCALBUSY==1)
    {
      printf("Arrow action ignored due to being too busy\n");
      return;
    }

  if(BUSY==1)
    {
      printf("Action ignored due to being too busy\n");
      return; 
    }

  LOCALBUSY = 1;
  
  if(SingleConditionSelected(0,errnum)==1)
  {
    PossibleToCenterZoom = 1;
    PossibleToPopInfoWin = 1;

    refreshCallback((Widget)NULL,(XtPointer)NULL,(XtPointer)NULL);

    PossibleToCenterZoom = 0;
    PossibleToPopInfoWin = 0;
  }

  UpdateAllTotals();

  LOCALBUSY = 0;
}




void choose_specific_error2(Widget unused,XtPointer client_data,XtPointer call_data)
{ 
  static int LOCALBUSY = 0;
  int *pos_list;
  int cloneindex = (int)client_data,pos_count,i;


  



  XmListGetSelectedPos(CloneErrorLookup[cloneindex].scrollwid,&pos_list,&pos_count);
  
  if(CloneErrorLookup[cloneindex].pos_list_made>0)
    {
      free(CloneErrorLookup[cloneindex].pos_list);
      CloneErrorLookup[cloneindex].pos_list_made = 0;
    }
  
  CloneErrorLookup[cloneindex].pos_list = (int *)malloc(SzI*pos_count);
  if(CloneErrorLookup[cloneindex].pos_list==NULL)
    {
      printf("Failed to alloc %d PLM\n",pos_count);
      ExitWrapper(-1);
    }
  
  
  for(i=0;i<pos_count;i++)
    {
      CloneErrorLookup[cloneindex].pos_list[i] = pos_list[i];
    }
  
  CloneErrorLookup[cloneindex].pos_list_made = pos_count;



  if(
     (CloneErrorLookup[cloneindex].viewall ==0) &&
     (CloneErrorLookup[cloneindex].viewsome==0)
     )
    {
      
      return;
    }


  if(LOCALBUSY==1)
    {
      printf("Arrow action ignored due to being too busy\n");
      return;
    }

  if(BUSY==1)
    {
      printf("Action ignored due to being too busy\n");
      return; 
    }

  LOCALBUSY = 1;


  if(SingleConditionSelected(1,cloneindex)==1)
  {
    PossibleToCenterZoom = 1;
    PossibleToPopInfoWin = 1;

    refreshCallback((Widget)NULL,(XtPointer)NULL,(XtPointer)NULL);

    PossibleToCenterZoom = 0;
    PossibleToPopInfoWin = 0;
  }

  UpdateAllTotals();

  LOCALBUSY = 0;
}



void choose_specific_bo(Widget w,MyData *mydata,XtPointer call_data)
{ 
  int *pos_list;
  int pos_count,foundit,i,viewsome,viewall;
  struct BOList *curr;
  static int LOCALBUSY=0;
  int ob_num     = mydata->object_num;
  int errnum     = mydata->check_num;
  int instance   = mydata->clonenum;
  int boindex    = mydata->axis;
  int condindex  = mydata->ADDER;
  Widget allwid  = mydata->wid_to_pass;
  Widget somewid = mydata->wid2_to_pass;

  

  if(LOCALBUSY==1)
    {
      printf("ignoring button click due to being busy\n");
      return;
    }
  

  LOCALBUSY = 1;
  

  if(BODEBUG==1)
    {
      printf("choose specific called with %d %d %d\n",ob_num,errnum,instance);
    }

  XmListGetSelectedPos(w,&pos_list,&pos_count);
  

  foundit = 0;
  curr = BOOnList;
  while(curr!=NULL)
    {
      if(foundit==1)
	{
	  break;
	}


      if(
	 (curr->errnum  ==errnum)   &&
	 (curr->instance==instance) &&
	 (curr->ob_num  ==ob_num)
	 )
	{
	  foundit = 1;

	  viewsome = curr->viewsome;
	  viewall  = curr->viewall;

	  if(curr->selectcount==0)
	    {
	      if(BODEBUG==1)
		{
		  printf("found %d %d %d with 0 selected, allocating\n",
			 ob_num,errnum,instance);
		}
	    }
	  else
	    {
	      if(BODEBUG==1)
		{
		  printf("found %d %d %d with %d selected, freeing and allocating\n",
			 ob_num,errnum,instance,curr->selectcount);
		}
	      free(curr->selectlist);
	      free(curr->speclist);
	      curr->selectlist = NULL;
	      curr->speclist = NULL;
	      curr->selectcount = 0;
	    }



	  if(pos_count>0)
	    {
	      curr->speclist   = (int *)malloc(SzI*pos_count);
	      curr->selectlist = (int *)malloc(SzI*pos_count);
	      if(curr->selectlist==NULL)
		{
		  printf("12RR: out of memory trying to allocate %d\n",pos_count);
		  ExitWrapper(-1);
		}

	      curr->selectcount = pos_count;
	      for(i=0;i<pos_count;i++)
		{
		  if(BODEBUG==1)
		    {
		      printf("setting %d\n",pos_list[i]);
		    }
		  curr->selectlist[i] = pos_list[i];
		  curr->speclist[i]   = BOSaveArray[boindex].conds[condindex+(pos_list[i]-1)].specnum;
		}
	    }
	  break;
	}
      curr = curr->next;
    }





  if(foundit==0)
    {
      if(BODEBUG==1)
	{
	  printf("didn't find %d %d %d, adding to OnList\n",ob_num,errnum,instance);
	}

      curr = (struct BOList *)malloc(sizeof(struct BOList));
      curr->ob_num      = ob_num;
      curr->errnum      = errnum;
      curr->instance    = instance;
      curr->viewall     = 0;
      curr->viewsome    = 0;
      curr->allwid      = allwid;
      curr->somewid     = somewid;
      curr->next        = BOOnList;
      BOOnList          = curr;

      viewall  = 0;
      viewsome = 0;


      if(pos_count>0)
	{
	  curr->speclist   = (int *)malloc(SzI*pos_count);
	  curr->selectlist = (int *)malloc(SzI*pos_count);
	  if(curr->selectlist==NULL)
	    {
	      printf("12RS: out of memory trying to allocate %d\n",pos_count);
	      ExitWrapper(-1);
	    }
	  
	  curr->selectcount = pos_count;
	  for(i=0;i<pos_count;i++)
	    {
          
		  curr->selectlist[i] = pos_list[i];
	      curr->speclist[i]   = BOSaveArray[boindex].conds[condindex+(pos_list[i]-1)].specnum;
	    }
	}
      else
	{
	  curr->selectcount = 0;
	  curr->selectlist  = NULL;
	  curr->speclist    = NULL;
	}

    }



  if(
     (viewall ==0) &&
     (viewsome==0)
     )
    {
      
      LOCALBUSY = 0;
      return;
    }



  
  PossibleToCenterZoom = 1;
  refreshCallback((Widget)NULL,(XtPointer)NULL,(XtPointer)NULL);
  PossibleToCenterZoom = 0;
  
  


  LOCALBUSY = 0;

}



void SelectRetainedOrIgnored(MyData *mydata, int retainignore)
{  
  Widget listwid;
  int i,totalselected,listwidmade;
  int cloneindex = mydata->clonenum;
  int errnum     = mydata->check_num;
  static int LOCALBUSY=0;
  
  if(LOCALBUSY==1)
    {
      printf("ignoring button click due to being busy\n");
      return;
    }
  
  
  LOCALBUSY = 1;
  
  
  
  
  if(cloneindex<0)
    {
      listwid       = ErrorLookup[errnum].scrollwid;
      listwidmade   = ErrorLookup[errnum].scrollwidmade;
    }
  else
    {
      listwid       = CloneErrorLookup[cloneindex].scrollwid;
      listwidmade   = CloneErrorLookup[cloneindex].scrollwidmade;
    }
  
  
  if(listwidmade==0)
    {
      XBell(mydisplay,50);
      printf("Error: (9) thought list was made but wasnt %d %d\n",errnum,cloneindex);
      return;
    }
  
  
  set_cursor(XtDisplay(listwid),XtWindow(listwid),WATCH);
  set_cursor(mydisplay,mywindow,WATCH);
  set_cursor(XtDisplay(errorhead[Current_head]),XtWindow(errorhead[Current_head]),WATCH);
  
  BUSY = 1;
  
  
  XmListDeselectAllItems(listwid);
  
  
  
  
  
  
 
  totalselected = 0;

  if(cloneindex<0)
    {
      for(i=1;i<=ErrorLookup[errnum].number;i++)
	  {
	    if(ErrorLookup[errnum].keepdismiss[i]==retainignore)
	    {
          totalselected = totalselected + 1;
	    }
	  } 
      
      if(ErrorLookup[errnum].pos_list_made>0)
	  { 
	    free(ErrorLookup[errnum].pos_list);
	  } 
      
      ErrorLookup[errnum].pos_list_made = totalselected;
      ErrorLookup[errnum].pos_list      = (int *)malloc(SzI*totalselected);
      
      
      if(ErrorLookup[errnum].pos_list==NULL)
	{
	  printf("Failed to alloc %d PLM 66\n",totalselected);
	  ExitWrapper(-1);
	}
    }
  else
    {
      for(i=1;i<=CloneErrorLookup[cloneindex].number;i++)
	{
	  if(CloneErrorLookup[cloneindex].keepdismiss[i]==retainignore)
	    {
          totalselected = totalselected + 1;
	    }
	}
      
      if(CloneErrorLookup[cloneindex].pos_list_made>0)
	{
	  free(CloneErrorLookup[cloneindex].pos_list);
	}
      
      CloneErrorLookup[cloneindex].pos_list_made = totalselected;
      CloneErrorLookup[cloneindex].pos_list      = (int *)malloc(SzI*totalselected);
      if(CloneErrorLookup[cloneindex].pos_list==NULL)
	{
	  printf("Failed to alloc %d PLM 77\n",totalselected);
	  ExitWrapper(-1);
	}
    }
  
  

  
  
  if(totalselected==0)
    {
      set_cursor(mydisplay,mywindow,GOOD);
      set_cursor(XtDisplay(listwid),XtWindow(listwid),ARROW);
      set_cursor(XtDisplay(errorhead[Current_head]),XtWindow(errorhead[Current_head]),ARROW);
      LOCALBUSY = 0;
      BUSY      = 0;
      return;
    }
  
  
  XtVaSetValues (listwid,
		 XmNselectionPolicy,  XmMULTIPLE_SELECT,
		 NULL);
  
  totalselected = 0;
  
  if(cloneindex<0)
    {
      for(i=1;i<=ErrorLookup[errnum].number;i++)
	  {  
	    if(ErrorLookup[errnum].keepdismiss[i]==retainignore)
		{
	      XmListSelectPos(ErrorLookup[errnum].scrollwid,i,0);
	      
	      ErrorLookup[errnum].pos_list[totalselected] = i;
	      totalselected = totalselected + 1;
		} 
	  }
    }
  else
    {
      for(i=1;i<=CloneErrorLookup[cloneindex].number;i++)
	  {  
	    if(CloneErrorLookup[cloneindex].keepdismiss[i]==retainignore)
		{ 
	      XmListSelectPos(CloneErrorLookup[cloneindex].scrollwid,i,0);
	      
	      CloneErrorLookup[cloneindex].pos_list[totalselected] = i;
	      totalselected = totalselected + 1;
		} 
	  }  
    }
  
  
  XtVaSetValues (listwid,
		 XmNselectionPolicy,  XmEXTENDED_SELECT,
		 NULL);
  
  XmListSetAddMode(listwid,False);
  
  UpdateAllTotals();
  
  
  set_cursor(mydisplay,mywindow,GOOD);
  set_cursor(XtDisplay(listwid),XtWindow(listwid),ARROW);
  set_cursor(XtDisplay(errorhead[Current_head]),XtWindow(errorhead[Current_head]),ARROW);
  
  BUSY = 0;
  LOCALBUSY = 0;
}





void SelectRetainedCB(Widget w,MyData *mydata,XtPointer call_data)
{
  SelectRetainedOrIgnored(mydata,1);
}





void SelectIgnoredCB(Widget w,MyData *mydata,XtPointer call_data)
{
  SelectRetainedOrIgnored(mydata,0);
}





void SetSelected(int errnum, int cloneindex, int onoff)
{
  Widget listwid;
  int listwidmade,i,pos_count,itemCount;
  XmString *itemlist,replace[1];
  char *thestr;
  char temp[1000];
  int *pos_list;

  if(cloneindex<0)
    {
      listwid       = ErrorLookup[errnum].scrollwid;
      listwidmade   = ErrorLookup[errnum].scrollwidmade;
    }
  else
    {
      listwid       = CloneErrorLookup[cloneindex].scrollwid;
      listwidmade   = CloneErrorLookup[cloneindex].scrollwidmade;
    }

  if(listwidmade==0)
    {
      XBell(mydisplay,50);
      printf("Error: thought list was made but wasnt %d %d\n",errnum,cloneindex);
      return;
    }

  
  XmListGetSelectedPos(listwid,&pos_list,&pos_count);  
  XtVaGetValues(listwid,XmNitems,    &itemlist,NULL);
  XtVaGetValues(listwid,XmNitemCount,&itemCount,NULL);
  


  
  if(pos_count<1)
    {
      return;
    }

  
  set_cursor(mydisplay,mywindow,WATCH);
  set_cursor(XtDisplay(listwid),XtWindow(listwid),WATCH);
  set_cursor(XtDisplay(errorhead[Current_head]),XtWindow(errorhead[Current_head]),WATCH);


  unsavedignore = 1;


  if(pos_count>100)
    {
      
      
      
      for(i=0;i<pos_count;i++)
	{
	  if(onoff==1)
	    {
	      if(cloneindex<0)
		{
          ErrorLookup[errnum].keepdismiss[pos_list[i]] = 1;
		}
	      else
		{ 
          CloneErrorLookup[cloneindex].keepdismiss[pos_list[i]] = 1;
		}
	    }
	  else if(onoff==0)
	    {
	      if(cloneindex<0)
		{ 
          ErrorLookup[errnum].keepdismiss[pos_list[i]] = 0;
		} 
	      else
		{ 
          CloneErrorLookup[cloneindex].keepdismiss[pos_list[i]] = 0;
		} 
	    }
	}      
      GenerateErrorEditor(1);
    }
  else
    {
      
      XtVaSetValues (listwid,
		     XmNselectionPolicy,  XmMULTIPLE_SELECT,
		     NULL);
      
      
      
      for(i=0;i<pos_count;i++)
	{
	  XmStringGetLtoR(itemlist[pos_list[i]-1],
			  (XmStringCharSet) XmSTRING_DEFAULT_CHARSET, &thestr);
	  
	  if((onoff==1)&&(thestr[1]!='R'))
	    {
	      
	      if(cloneindex<0)
		{
          ErrorLookup[errnum].keepdismiss[pos_list[i]] = 1;
		}
	      else
		{
          CloneErrorLookup[cloneindex].keepdismiss[pos_list[i]] = 1;
		}
	      thestr[1] = 'R';
	      thestr[2] = 'E';
	      thestr[3] = 'T';
	      thestr[4] = 'A';
	      thestr[5] = 'I';
	      thestr[6] = 'N';
	      
	      
	      sprintf(temp,"%s",thestr);
	      replace[0] = XmStringCreateLocalized(temp); 
	      XmListReplaceItemsPos(listwid,replace,1,pos_list[i]);
	      XmListSelectPos(listwid,pos_list[i],0);
	    }
	  else if((onoff==0)&&(thestr[1]!='I'))
	    {
	      if(cloneindex<0)
		{
          ErrorLookup[errnum].keepdismiss[pos_list[i]] = 0;
		}
	      else
		{
          CloneErrorLookup[cloneindex].keepdismiss[pos_list[i]] = 0;
		}
	      thestr[1] = 'I';
	      thestr[2] = 'G';
	      thestr[3] = 'N';
	      thestr[4] = 'O';
	      thestr[5] = 'R';
	      thestr[6] = 'E';
	      
	      sprintf(temp,"%s",thestr);
	      replace[0] = XmStringCreateLocalized(temp); 
	      XmListReplaceItemsPos(listwid,replace,1,pos_list[i]);
	      XmListSelectPos(listwid,pos_list[i],0);	  
	    }
	}
      
      
      XtVaSetValues (listwid,
		     XmNselectionPolicy,  XmEXTENDED_SELECT,
		     NULL);

	  XmListSetAddMode(listwid,False);
    }

  set_cursor(mydisplay,mywindow,GOOD);
  set_cursor(XtDisplay(listwid),XtWindow(listwid),ARROW);
  set_cursor(XtDisplay(errorhead[Current_head]),XtWindow(errorhead[Current_head]),ARROW);

}



void RetainSelectedCB(Widget w,MyData *mydata,XtPointer call_data)
{
  SetSelected(mydata->check_num,mydata->clonenum,1);
}



void IgnoreSelectedCB(Widget w,MyData *mydata,XtPointer call_data)
{
  SetSelected(mydata->check_num,mydata->clonenum,0);
}



void remove_add_mode(Widget widget, XEvent *event, String *args, int *num_args)
{
   
   XmListSetAddMode(widget,False);
}



void do_nothing(Widget widget, XEvent *event, String *args, int *num_args)
{
  printf("Trap:  list select translation failed\n");
  XBell(mydisplay,50);
}






void do_nothing2(Widget widget, XEvent *event, String *args, int *num_args)
{
  if(*num_args==1)
  {
    if(!strcmp(args[0],"ignore"))
	 {
	  return;
	 }
  }

 
}





char *GetCondDetails(int type, int len2, int ecc1, int ecc2, double magnitude, int errnum, int j,
		     int codelen, int codelen2, int labellen, int labellen2, int coverfailnum)
{
  static char temp[1000];
  char temp2[1000];


  temp[0] = '\0';

  
  if(type==1)
    {
	  if(ErrorLookup[errnum].keepdismiss[j]==1)
	    {  
	      sprintf(temp,"<RETAIN> Condition %*d",len2,j);
	    }  
	  else
	    {  
	      sprintf(temp,"<IGNORE> Condition %*d",len2,j);
	    }  
    }
  
  
  if(errnum==COVERFAIL) 
    {
      sprintf(temp2," ");
      strcat(temp,temp2);
    }
  else if(ErrorLookup[errnum].usemagnitude==1)
    {
      if(type==1)
	{
	  sprintf(temp2," (Magnitude %s)",GetCoordString(4,magnitude));
	}
      else
	{
	  sprintf(temp2," Magnitude: %s",GetCoordString(4,magnitude));
	}
      strcat(temp,temp2);
    }
  else if(ErrorLookup[errnum].usemagnitude==2)
    {
      if(type==1)
	{
	  sprintf(temp2," (Magnitude %d)",(int)magnitude);
	}
      else
	{
	  sprintf(temp2," Magnitude: %d",(int)magnitude);
	}
      strcat(temp,temp2);
    }
  
  
  if(NGA_TYPE==1)
    {
      if((ecc1>=0)&&(ecc2>=0)&&(errnum!=C_DUPS)&&(errnum!=COVERFAIL)) 
	{
	  sprintf(temp2," Involves %-*s and %-*s (%-*s and %-*s)",
		  codelen,GetECCCode(ecc1),
		  codelen2,GetECCCode(ecc2),
		  labellen,GetECCLabel(ecc1),
		  labellen2,GetECCLabel(ecc2)
		  );
	  strcat(temp,temp2);
	}
      else if((ecc1>=0)&&(errnum!=COVERFAIL))  
	{
	  sprintf(temp2," Involves %-*s (%-*s)",
		  codelen,GetECCCode(ecc1),labellen,GetECCLabel(ecc1));
	  strcat(temp,temp2);
	}
      else if((ecc2>=0)&&(errnum!=C_DUPS)&&(errnum!=COVERFAIL))  
	{
	  sprintf(temp2," Involves %-*s (%-*s)",
		  codelen2,GetECCCode(ecc2),labellen2,GetECCLabel(ecc2));
	  strcat(temp,temp2);
	}
    }
  else
    {
      if(ecc1>=0)
	  { 
	   sprintf(temp2," (Involves %-*s)",
		  labellen,GetECCLabel(ecc2));
	   strcat(temp,temp2);
	  } 
      if((ecc2>=0)&&(errnum!=C_DUPS))
	  { 
	   sprintf(temp2," (Involves %-*s)",
		  labellen2,GetECCLabel(ecc2));
	   strcat(temp,temp2);
	  } 
    }
  return temp;
}



void SetCenterZoom()
{
  

  CenterZoomOnErrors = 1;

  XmToggleButtonSetState(zoom_b,(Boolean)CenterZoomOnErrors,(Boolean)0);
}



void quick_condition(Widget w,XtPointer userData,XtPointer call_data)
{
  int i,errnum = (int)userData;
  int TotalSpecs,TotalSpecs2,ErrorIndex,SingleBegin,SingleEnd,CloneIndex;


  if(QUICKDEBUG==1)
  {
    printf("quickie...should call choose_specific_error on errnum %d\n",errnum);
  }


  


  TotalSpecs  = GetTotalIndiv(&ErrorIndex,&SingleBegin,&SingleEnd,&CloneIndex);
  TotalSpecs2 = GetTotalNonIndiv();
  

  if( (TotalSpecs==1)&&(TotalSpecs2==0) )
  { 
	

	if(CloneIndex<0)
	{
      if(errnum==ErrorIndex)
	  {
        if(QUICKDEBUG==1)
		{ 
          printf("  ...not quicky-ing...\n");
		}
        return;
	  }
	}
  }





  for(i=1;i<=CONDITION_DEFINITIONS;i++)
  {
     ErrorLookup[i].viewsome = 0;
     ErrorLookup[i].viewall  = 0;

     if(ErrorLookup[i].number>0)
	 {
       
       XmToggleButtonSetState(ErrorLookup[i].viewallwid, (Boolean)0,(Boolean)0);
       XmToggleButtonSetState(ErrorLookup[i].viewsomewid,(Boolean)0,(Boolean)0);
	 }
  }

  for(i=0;i<CLONE_DEFINITIONS;i++)
  {
     CloneErrorLookup[i].viewsome = 0;
     CloneErrorLookup[i].viewall  = 0;

     if(CloneErrorLookup[i].number>0)
	 {
       
       XmToggleButtonSetState(CloneErrorLookup[i].viewallwid, (Boolean)0,(Boolean)0);
       XmToggleButtonSetState(CloneErrorLookup[i].viewsomewid,(Boolean)0,(Boolean)0);
	 }
  }


  XmToggleButtonSetState(ErrorLookup[errnum].viewsomewid,(Boolean)1,(Boolean)0);
  ErrorLookup[errnum].viewsome = 1;

  SetCenterZoom();

  choose_specific_error((Widget)NULL,userData,call_data);
}


void quick_condition2(Widget w,XtPointer userData,XtPointer call_data)
{
  int i,cloneindex = (int)userData;
  int TotalSpecs,TotalSpecs2,ErrorIndex,SingleBegin,SingleEnd,CloneIndex;


  if(QUICKDEBUG==1)
  {
    printf("quickie...should call choose_specific_error2 on cloneindex %d\n",cloneindex);
  }

  


  TotalSpecs  = GetTotalIndiv(&ErrorIndex,&SingleBegin,&SingleEnd,&CloneIndex);
  TotalSpecs2 = GetTotalNonIndiv();
  

  if( (TotalSpecs==1)&&(TotalSpecs2==0) )
  { 
	

	if(CloneIndex>=0)
	{
	  if(CloneIndex==cloneindex)
	  {
        if(QUICKDEBUG==1)
		{ 
          printf("  ...not clone quicky-ing...\n");
		}
        return;
	  }
	}
  }


  for(i=1;i<=CONDITION_DEFINITIONS;i++)
  {
     ErrorLookup[i].viewsome = 0;
     ErrorLookup[i].viewall  = 0;

     if(ErrorLookup[i].number>0)
	 {
       
       XmToggleButtonSetState(ErrorLookup[i].viewallwid, (Boolean)0,(Boolean)0);
       XmToggleButtonSetState(ErrorLookup[i].viewsomewid,(Boolean)0,(Boolean)0);
	 }
  }

  for(i=0;i<CLONE_DEFINITIONS;i++)
  {
     CloneErrorLookup[i].viewsome = 0;
     CloneErrorLookup[i].viewall  = 0;

     if(CloneErrorLookup[i].number>0)
	 {
       
       XmToggleButtonSetState(CloneErrorLookup[i].viewallwid, (Boolean)0,(Boolean)0);
       XmToggleButtonSetState(CloneErrorLookup[i].viewsomewid,(Boolean)0,(Boolean)0);
	 }
  }


  XmToggleButtonSetState(CloneErrorLookup[cloneindex].viewsomewid,(Boolean)1,(Boolean)0);
  CloneErrorLookup[cloneindex].viewsome = 1;

  SetCenterZoom();

  choose_specific_error2((Widget)NULL,userData,call_data);
}



void BuildSpecificCond(Widget parent, int errnum, int clonenum, int scr_width)
{
  Widget subhandle,junkwid,rc3,form,button1,button2,button3,button4,widtozero;
  XmString *error_items;
  Dimension width;
  Arg resources[15];
  int cloneindex,total=0,outlen,zeroout,insertindex,indexer;
  int n=0,i=0,j=0,k=0,ind=0,dcounter,len2,labellen=0,codelen=0,labellen2=0,codelen2=0;
  int ConditionFlags[CONDITION_ARRAY_SIZE],startindex,endindex,multiplier;
  double lastmag;
  double *error_mags;
  int *main_eccs,*other_eccs;
  char temp[1000],temp2[1000],scrubout[1000];
  struct ConditionList * NEW_LIST=NULL;
  struct ConditionList * dummy=NULL;
  struct AdditionalConditions * AdditionalConditionFlags=NULL;
  MyData *mydata;


  
  if(clonenum>0)
    {
      cloneindex = GetCloneIndex(clonenum,errnum);
      total      = CloneErrorLookup[cloneindex].number;
    }
  else
    {
      total = ErrorLookup[errnum].number;
    }



  
  if(total==0)
    {
      XBell(mydisplay,50);
      return;
    }
    

  if((total>10000)&&(dead_error==0))
    {
      set_cursor(XtDisplay(errorhead[Current_head]),XtWindow(errorhead[Current_head]),WATCH);
    }

  if(scr_width==-1)
    {
      XtVaGetValues(errorhead[Current_head], XmNwidth, &width, NULL);
      scr_width = width-200;
    }


  error_items = (XmString *) (malloc(sizeof(XmString *) * total));
  if(error_items==NULL){printf("error_items: out of allocation memory!\n"); ExitWrapper(-1);}



    
  error_mags = (double *) (malloc(SzD * total));
  if(error_mags==NULL){printf("error_mags: out of allocation memory!\n"); ExitWrapper(-1);}

  other_eccs = (int *) (malloc(SzI * total));
  if(other_eccs==NULL){printf("other_eccs: out of allocation memory!\n"); ExitWrapper(-1);}

  main_eccs = (int *) (malloc(SzI * total));
  if(main_eccs==NULL){printf("main_eccs: out of allocation memory!\n"); ExitWrapper(-1);}


  
  for(i=1;i<=CONDITION_DEFINITIONS;i++)
    {
      ConditionFlags[i] = 0;
    }


  ind = 0;
  startindex  = 1;
  endindex    = 0;
  insertindex = 0;
  dcounter    = 0;
  codelen     = 0;
  labellen    = 0;
  codelen2    = 0;
  labellen2   = 0;
  multiplier  = 150000;


  while(ind<total)
    {
      

      if(ind==0)
	  { 
	   startindex = 1;
	   endindex   = multiplier;
	  }
      else
	  {
	   startindex = startindex + multiplier;
	   endindex   = endindex   + multiplier;
	  }

      if(endindex>total)
	{
	  endindex = total;
	}


      if(clonenum<=0)
	{
	  
	  
	  sprintf(scrubout,"%s",outdirectory);
	  outlen = strlen(scrubout);
	  scrubout[outlen-1] = '\0';
	  
	  ConditionFlags[errnum] = 1;
	  
	  SEEIT_LoadConditionReport(scrubout);
	  
	  ABORT_ZOOM = 0;

      

	  NEW_LIST =
	    SEEIT_GetConditions(scrubout,
				ConditionFlags,
				startindex,
				endindex,
				AdditionalConditionFlags,  
				1,  
				1,  
				0,  
				NULL,
				-1
				);
	  
	  
      if(endindex>total)
	  { 
	    endindex = total;
	  } 

	  dummy = NEW_LIST;
	  
	  while(dummy!=NULL)
	    {
	      error_mags[dcounter] = dummy->magnitude;
	      main_eccs [dcounter] = dummy->ECC1;
	      other_eccs[dcounter] = dummy->ECC2;
	      
	      
	     if(dummy->ECC1>=0)
		 {
		  sprintf(temp,"%s",GetECCLabel(dummy->ECC1));
		  if((int)strlen(temp)>labellen)
		    {
		      labellen = strlen(temp);
		    }
		  
		  
		  if(NGA_TYPE==1)
		    {
		      sprintf(temp2,"%s",GetECCCode(dummy->ECC1));
		      
		      if((int)strlen(temp2)>codelen)
			{
			  codelen = strlen(temp2);
			}
		    }
		}
	      
	      
	      if(dummy->ECC2>=0)
		{
		  sprintf(temp,"%s",GetECCLabel(dummy->ECC2));
		  if((int)strlen(temp)>labellen2)
		    {
		      labellen2 = strlen(temp);
		    }
		  
	      
		  if(NGA_TYPE==1)
		    {
		      sprintf(temp2,"%s",GetECCCode(dummy->ECC2));
		      
		      if((int)strlen(temp2)>codelen2)
			{
			  codelen2 = strlen(temp2);
			}
		    }
		}
	      
	      	      
	      dcounter = dcounter + 1;
	      if(dcounter>ErrorLookup[errnum].number)
		{
		  printf("error in mag gen: too many errors\n");
		  break;
		}
	      dummy = dummy->next;
	    }
		  
	
	  
	  sprintf(temp2,"%d",ErrorLookup[errnum].number);
	  len2 = strlen(temp2);
	  

	  indexer = 1;
	  for(j=startindex;j<=endindex;j++)
	    {
	        sprintf(temp,"%s",GetCondDetails(1,len2,
					       main_eccs[j-1],other_eccs[j-1],
					       error_mags[j-1],errnum,j,
					       codelen,codelen2,
					       labellen,labellen2,indexer
					       ));
			indexer = indexer + 1;
 	      	
			




	        error_items[insertindex] = XmStringCreateLocalized (temp);

			lastmag = error_mags[j-1];
			insertindex = insertindex + 1;

		  
          ind++;
	    }
	}
      
      else if(clonenum>0)
	{
	  
	  
	  sprintf(scrubout,"%s",outdirectory);
	  outlen = strlen(scrubout);
	  scrubout[outlen-1] = '\0';
	  
	  
	  
	  
	  SEEIT_AddAdditionalFlag(&AdditionalConditionFlags,
				  CloneErrorLookup[cloneindex].CloneNumber, 
				  GetCloneNumber(cloneindex,CloneErrorLookup[cloneindex].CloneNumber)
				  );
	  
	  
	  SEEIT_LoadConditionReport(scrubout);
	  
	  ABORT_ZOOM = 0;
	  
	  NEW_LIST =
	    SEEIT_GetConditions(scrubout,
				ConditionFlags,
				startindex,
				endindex,
				AdditionalConditionFlags, 
				1,   
				1,   
				0,   
				NULL,
				-1
				);

	   if(endindex>total)
	  { 
	    endindex = total;
	  } 

	  dummy = NEW_LIST;

	  while(dummy!=NULL)
	    {
	      error_mags[dcounter] = dummy->magnitude;
	      main_eccs [dcounter] = dummy->ECC1;
	      other_eccs[dcounter] = dummy->ECC2;
	      
	      if(dummy->ECC1>=0)
		{
		  sprintf(temp,"%s",GetECCLabel(dummy->ECC1));
		  if((int)strlen(temp)>labellen)
		    {
		      labellen = strlen(temp);
		    }
		  
		  
		  if(NGA_TYPE==1)
		    {
		      sprintf(temp2,"%s",GetECCCode(dummy->ECC1));
		      
		      if((int)strlen(temp2)>codelen)
			{
			  codelen = strlen(temp2);
			}
		    }
		}
	      
	      
	      if(dummy->ECC2>=0)
		{
		  sprintf(temp,"%s",GetECCLabel(dummy->ECC2));
		  if((int)strlen(temp)>labellen2)
		    {
		      labellen2 = strlen(temp);
		    }
		  
		  
		  if(NGA_TYPE==1)
		    {
		      sprintf(temp2,"%s",GetECCCode(dummy->ECC2));
		      
		      if((int)strlen(temp2)>codelen2)
			{
			  codelen2 = strlen(temp2);
			}
		    }
		}
	      
	      
	      
	      
	      dcounter = dcounter + 1;
	      if(dcounter>CloneErrorLookup[cloneindex].number)
		{
		  printf("error in mag gen 2: too many errors\n");
		  break;
		}
	      dummy = dummy->next;
	    }
	  
	  SEEIT_FreeAdditionalFlags(AdditionalConditionFlags);
	  AdditionalConditionFlags = NULL;
	  
	  	  
	  sprintf(temp2,"%d",CloneErrorLookup[cloneindex].number);
	  len2 = strlen(temp2);


	  for(k=startindex;k<=endindex;k++)
	    {
	      
	      if(CloneErrorLookup[cloneindex].keepdismiss[k]==1)
		{
		  sprintf(temp,"<RETAIN> Condition %*d",len2,k);
		} 
	      else
		{  
		  sprintf(temp,"<IGNORE> Condition %*d",len2,k);
		} 
	      
	      if(ErrorLookup[errnum].usemagnitude==1)
		{
		  sprintf(temp2," (Magnitude %s)",GetCoordString(4,error_mags[k-1]));
		  strcat(temp,temp2);
		}
	      else if(ErrorLookup[errnum].usemagnitude==2)
		{ 
		  sprintf(temp2," (Magnitude %d)",(int)error_mags[k-1]);
		  strcat(temp,temp2);
		}
	      
	      if(NGA_TYPE==1)
		{
		  if((main_eccs[k-1]>=0)&&(other_eccs[k-1]>=0)&&(errnum!=C_DUPS))
		    {
		      sprintf(temp2," Involves %-*s and %-*s (%-*s and %-*s)",
			      codelen,GetECCCode(main_eccs[k-1]),
			      codelen2,GetECCCode(other_eccs[k-1]),
			      labellen,GetECCLabel(main_eccs[k-1]),
			      labellen2,GetECCLabel(other_eccs[k-1])
			      );
		      strcat(temp,temp2);
		    }
		  else if((main_eccs[k-1]>=0))
		    {
		      sprintf(temp2," Involves %-*s (%-*s)",
			      codelen,GetECCCode(main_eccs[k-1]),labellen,GetECCLabel(main_eccs[k-1]));
		      strcat(temp,temp2);
		    } 
		  else if((other_eccs[k-1]>=0)&&(errnum!=C_DUPS))
		    {
		      sprintf(temp2," Involves %-*s (%-*s)",
			      codelen2,GetECCCode(other_eccs[k-1]),labellen2,GetECCLabel(other_eccs[k-1]));
		      strcat(temp,temp2);
		    }
		}
	      else
		{
		  if(main_eccs[k-1]>=0)
		    {
		      sprintf(temp2," (Involves %-*s)",
			      labellen,GetECCLabel(main_eccs[k-1]));
		      strcat(temp,temp2);
		    }
		  if((other_eccs[k-1]>=0)&&(errnum!=C_DUPS))
		    {
		      sprintf(temp2," (Involves %-*s)",
			      labellen2,GetECCLabel(other_eccs[k-1]));
		      strcat(temp,temp2);
		    }
		}
	 
	      error_items[insertindex] = XmStringCreateLocalized (temp);
	      lastmag = error_mags[k-1];
	      insertindex = insertindex + 1;
	      
	      
	      ind++;
	    }
	}
 
      if(NEW_LIST!=NULL)
	{
	  
	  SEEIT_FreeConditions(NEW_LIST);
	  NEW_LIST = NULL;
	}

     }


  


  if(ind!=total){XBell(mydisplay,50);  printf("IND/NUM mismatch %d %d!\n",ind,total);}



  


  
  if(clonenum>0)
    {
      sprintf(list_translations26,"#override\n <Key>osfLeft: RetainError(1,%d,%d)RemoveAddMode()\n <Key>osfRight: RetainError(0,%d,%d)RemoveAddMode()\n <Key>osfUp: ListPrevItem()ListEndSelect()RemoveAddMode()\n <Btn4Up>:          list_scroll_vc(1,%d,%d)ListEndSelect()\n <Btn5Up>:          list_scroll_vc(2,%d,%d)RemoveAddMode()\n <Btn2Down>: do_nothing2(2down)RemoveAddMode()\n <Btn2Up>: do_nothing2(2up)RemoveAddMode()",
	      -1,cloneindex,-1,cloneindex,-1,cloneindex,-1,cloneindex);
      
    }
  else
    {
      sprintf(list_translations26,"#override\n <Key>osfLeft: RetainError(1,%d,%d)RemoveAddMode()\n <Key>osfRight: RetainError(0,%d,%d)RemoveAddMode()\n <Key>osfUp: ListPrevItem()ListEndSelect()RemoveAddMode()\n <Btn4Up>:          list_scroll_vc(1,%d,%d)ListEndSelect()\n <Btn5Up>:          list_scroll_vc(2,%d,%d)RemoveAddMode()\n <Btn2Down>: do_nothing2(2down)RemoveAddMode()\n <Btn2Up>: do_nothing2(2up)RemoveAddMode()",
	      errnum,-1,errnum,-1,errnum,-1,errnum,-1);
    }
  




  
  if(total<10)
    {
      i=total; 
    }
  else
    {
      i=10;
    }

  XtSetArg(resources[n],  XmNlistSizePolicy,    XmCONSTANT);  n++;
  XtSetArg(resources[n],  XmNheight, i*20 + 22);              n++;
  XtSetArg(resources[n], 
	   XmNtranslations, 
	   XtParseTranslationTable (list_translations26));    n++;
 




  subhandle = XtVaCreateManagedWidget("subhandle",
				      xmHandleWidgetClass,
				      parent,
				      NULL);
  


  
  rc3 = XtVaCreateWidget ("rowcol",xmRowColumnWidgetClass, subhandle, 
			  NULL);
  
    
  form = XtVaCreateWidget ("form.error.editor", xmFormWidgetClass, rc3,
			   XmNfractionBase,  100, 
			   NULL);
  
  
  button1 = 
    XtVaCreateManagedWidget ("Select Retained",
			     xmPushButtonWidgetClass, form,
			     XmNtopAttachment,    XmATTACH_FORM,
			     XmNbottomAttachment, XmATTACH_FORM,
			     XmNleftAttachment,   XmATTACH_FORM,
			     XmNlabelString,      STRING("Select Retained"),
			     XmNalignment,        XmALIGNMENT_BEGINNING,
			     XmNtranslations,     
			     XtParseTranslationTable (list_translations8),
			     XmNtraversalOn,      False,
			     NULL);
  button2 = 
    XtVaCreateManagedWidget ("Select Ignored",
			     xmPushButtonWidgetClass, form,
			     XmNtopAttachment,    XmATTACH_FORM,
			     XmNbottomAttachment, XmATTACH_FORM,
			     XmNleftAttachment,   XmATTACH_WIDGET,
			     XmNleftWidget,       button1,
			     XmNlabelString,      STRING("Select Ignored"),
			     XmNalignment,        XmALIGNMENT_BEGINNING,
			     XmNtranslations,
			     XtParseTranslationTable (list_translations8),
			     XmNtraversalOn,      False,
			     NULL);
 
  button3 = 
    XtVaCreateManagedWidget ("Retain Selected",
			     xmPushButtonWidgetClass, form,
			     XmNtopAttachment,    XmATTACH_FORM,
			     XmNbottomAttachment, XmATTACH_FORM,
			     XmNleftAttachment,   XmATTACH_WIDGET,
			     XmNleftWidget,       button2,
			     XmNlabelString,      STRING("Retain Selected"),
			     XmNalignment,        XmALIGNMENT_BEGINNING,
			     XmNtranslations,
			     XtParseTranslationTable (list_translations8),
			     XmNtraversalOn,      False,
			     NULL);
 
  button4 = 
    XtVaCreateManagedWidget ("Ignore Selected",
			     xmPushButtonWidgetClass, form,
			     XmNtopAttachment,    XmATTACH_FORM,
			     XmNbottomAttachment, XmATTACH_FORM,
			     XmNleftAttachment,   XmATTACH_WIDGET,
			     XmNleftWidget,       button3,
			     XmNlabelString,      STRING("Ignore Selected"),
			     XmNalignment,        XmALIGNMENT_BEGINNING,
			     XmNtranslations,
			     XtParseTranslationTable (list_translations8),
			     XmNtraversalOn,      False,
			     NULL);
 

 
  
  
  mydata  = (MyData *) (malloc(sizeof(MyData)));
  if(mydata==NULL){printf("myb: out of allocation memory!\n"); ExitWrapper(-1);}
  mydata->check_num    = errnum;

  if(clonenum>0)
    {
      mydata->clonenum     = cloneindex;
    }
  else
    {
      mydata->clonenum     = -1;
    }



  XtAddCallback(button1, 
		XmNactivateCallback, (XtCallbackProc)SelectRetainedCB, 
		(XtPointer) mydata);
  
  XtAddCallback(button2, 
		XmNactivateCallback, (XtCallbackProc)SelectIgnoredCB, 
		(XtPointer) mydata);

  XtAddCallback(button3, 
		XmNactivateCallback, (XtCallbackProc)RetainSelectedCB, 
		(XtPointer) mydata);
  
  XtAddCallback(button4, 
		XmNactivateCallback, (XtCallbackProc)IgnoreSelectedCB, 
		(XtPointer) mydata);
  
   





  XtManageChild(form);


  







  form = XtVaCreateWidget ("form.error.editor", xmFormWidgetClass, rc3,
			   XmNfractionBase,  100, 
			   NULL);
 
  
  if(clonenum>0)
    {
      
      junkwid = XmCreateScrolledList (form, "list1234",NULL,0);

      


      XtVaSetValues (junkwid,
		     XmNitems,            error_items,
		     XmNitemCount,        total,
		     XmNvisibleItemCount, i,
		     XmNselectionPolicy,  XmEXTENDED_SELECT,
		     NULL);   
      XtManageChild (junkwid);
      

      XtVaGetValues(junkwid, XmNwidth, &width, NULL);
      XtDestroyWidget (junkwid);
      

      CloneErrorLookup[cloneindex].maxscrollsize = mymax(width,scr_width);

      
      
      XtSetArg(resources[n],  XmNwidth,             scr_width);   n++;


      
      CloneErrorLookup[cloneindex].scrollwid = 
	XmCreateScrolledList (form, "list", resources,n);
      
      XtVaSetValues (CloneErrorLookup[cloneindex].scrollwid,
		     XmNitems,            error_items,
		     XmNitemCount,        total,
		     XmNvisibleItemCount, i,
		     XmNselectionPolicy,  XmEXTENDED_SELECT,
		     NULL);





      XtVaGetValues(CloneErrorLookup[cloneindex].scrollwid,
		    XmNverticalScrollBar,&CloneErrorLookup[cloneindex].vertwid ,NULL);
      XtAddCallback (CloneErrorLookup[cloneindex].scrollwid, 
		     XmNextendedSelectionCallback, choose_specific_error2, (XtPointer)cloneindex);
      XtManageChild (CloneErrorLookup[cloneindex].scrollwid);




      XtVaGetValues(CloneErrorLookup[cloneindex].scrollwid,  
		    XmNwidth, &width, NULL);



      XtVaSetValues(CloneErrorLookup[cloneindex].scrollwid,  
		    XmNlistSizePolicy,    XmCONSTANT,
		    NULL); 
      

      if(CloneErrorLookup[cloneindex].pos_list_made>0)
	{
	  
	  XtVaSetValues (CloneErrorLookup[cloneindex].scrollwid,
			 XmNselectionPolicy,  XmMULTIPLE_SELECT,
			 NULL);
	  
	  for(i=0;i<CloneErrorLookup[cloneindex].pos_list_made;i++)
	    {	      
	      XmListSelectPos(CloneErrorLookup[cloneindex].scrollwid,
			      CloneErrorLookup[cloneindex].pos_list[i],0);
	    }
	  XtVaSetValues (CloneErrorLookup[cloneindex].scrollwid,
			 XmNselectionPolicy,  XmEXTENDED_SELECT,
			 NULL);
	  zeroout = 0;
	}
      else
	{
	  widtozero = CloneErrorLookup[cloneindex].scrollwid;
	  zeroout = 1;
	}
      XmListSetAddMode(CloneErrorLookup[cloneindex].scrollwid,False);



      XtAddCallback (CloneErrorLookup[cloneindex].scrollwid,  XmNdefaultActionCallback,quick_condition2, (XtPointer)cloneindex);

    }
  else
    {
      
      junkwid = XmCreateScrolledList (form, "list1234",NULL,0);
      
      XtVaSetValues (junkwid,
		     XmNitems,            error_items,
		     XmNitemCount,        total,
		     XmNvisibleItemCount, i,
		     XmNselectionPolicy,  XmEXTENDED_SELECT,
		     NULL);  
      XtManageChild (junkwid);

      XtVaGetValues(junkwid, XmNwidth, &width, NULL);
      XtDestroyWidget (junkwid);
      
      
      ErrorLookup[errnum].maxscrollsize = mymax(width,scr_width);


      

      XtSetArg(resources[n],  XmNwidth,             scr_width);   n++;



      ErrorLookup[errnum].scrollwid = 
	XmCreateScrolledList (form, "list", resources,n);


      
      XtVaSetValues (ErrorLookup[errnum].scrollwid,
		     XmNitems,            error_items,
		     XmNitemCount,        total,
		     XmNvisibleItemCount, i,
		     XmNselectionPolicy,  XmEXTENDED_SELECT,
		     NULL);
      
      
      XtVaGetValues(ErrorLookup[errnum].scrollwid,
		    XmNverticalScrollBar,&ErrorLookup[errnum].vertwid,NULL);
      XtAddCallback (ErrorLookup[errnum].scrollwid, 
		     XmNextendedSelectionCallback, choose_specific_error, (XtPointer) errnum);
      XtManageChild (ErrorLookup[errnum].scrollwid);



      if(ErrorLookup[errnum].pos_list_made>0)
	{
	  XtVaSetValues (ErrorLookup[errnum].scrollwid,
			 XmNselectionPolicy,  XmMULTIPLE_SELECT,
			 NULL);
	  
	  for(i=0;i<ErrorLookup[errnum].pos_list_made;i++)
	    {
	      XmListSelectPos(ErrorLookup[errnum].scrollwid,ErrorLookup[errnum].pos_list[i],0);
	    }
	  XtVaSetValues (ErrorLookup[errnum].scrollwid,
			 XmNselectionPolicy,  XmEXTENDED_SELECT,
			 NULL);
	  zeroout = 0;
	}
      else
	{
	  widtozero = ErrorLookup[errnum].scrollwid;
	  zeroout = 1;
	}
      XmListSetAddMode(ErrorLookup[errnum].scrollwid,False);

      XtAddCallback (ErrorLookup[errnum].scrollwid,  XmNdefaultActionCallback,quick_condition,(XtPointer)errnum);

    }
  
  
  XtManageChild(form);
  XtManageChild(rc3);
  
  
  
  if(zeroout==1)
    {
      
      XmListDeselectAllItems(widtozero);
    }
  
  for (i = 0; i <  total; i++)
    {
      XmStringFree (error_items[i]);
    }     
  free(error_items);
  free(error_mags);
  free(main_eccs);
  free(other_eccs);


  if((total>10000)&&(dead_error==0))
    {
      set_cursor(XtDisplay(errorhead[Current_head]),XtWindow(errorhead[Current_head]),ARROW);
    }

}















void BuildBOSpecificCond(Widget parent, int boindex, int in_errnum, int in_instance, int in_obnum,
			 Widget allwid, Widget somewid)
{
  Widget subhandle,scrollwid;
  XmString *error_items;
  Arg resources[15];
  double *error_mags;
  int *error_specs;
  int *other_eccs;
  char  temp[1000],temp2[1000];
  int instance,num_errs,totalread,thisone,usemags,errnum;
  int total=0,n=0,i=0,j=0,savetotalread,maxspec,len1,len2;
  MyData *mydata;
  struct BOList *curr;


  

  
  if(BODEBUG==1)
    {
      printf("Object %d has %d conds\n",boindex+1,BOSaveArray[boindex].thisnum);
    }

  usemags   = 0;
  thisone   = 0;
  totalread = 0;


  while(totalread<BOSaveArray[boindex].thisnum)
    {
      if(thisone==1)
	{
	  break;
	}
      savetotalread = totalread;
      num_errs = BOSaveArray[boindex].conds[totalread].num_errs;
      errnum   = BOSaveArray[boindex].conds[totalread].errnum;
      instance = BOSaveArray[boindex].conds[totalread].instance;

      if((in_errnum==errnum)&&(in_instance==instance))
	{
	  if(BODEBUG==1)
	    {
	      printf("  found %d conds for errnum %d instance %d\n",
		     num_errs,errnum,instance);
	    }

	  thisone = 1;
	  total   = num_errs;

	  
	  usemags = ErrorLookup[errnum].usemagnitude;
	  
	  if((usemags==1)||(usemags==2))
	    {
	      error_mags  = (double *)malloc(SzD*num_errs);
	    }
	  error_specs = (int *)   malloc(SzI*num_errs);
	  other_eccs  = (int *)   malloc(SzI*num_errs);
	  if(other_eccs==NULL)
	    {
	      printf("WW2: out of memory trying to alloc %d\n",num_errs);
	      ExitWrapper(-1);
	    }


	  for(j=0;j<num_errs;j++)
	    {
	      if((usemags==1)||(usemags==2))
		{
		  error_mags[j]  = BOSaveArray[boindex].conds[totalread].magnitude;
		}
	      error_specs[j] = BOSaveArray[boindex].conds[totalread].specnum;
	      other_eccs [j] = BOSaveArray[boindex].conds[totalread].ECC2;
	      maxspec        = BOSaveArray[boindex].conds[totalread].specnum;

	      totalread = totalread + 1;
	    }

	  break;
	}
      else
	{
	  totalread = totalread + num_errs;
	}
    }



  sprintf(temp,"%d",maxspec);
  len1 = strlen(temp);

  sprintf(temp,"%d",num_errs);
  len2 = strlen(temp);






  if(thisone==0)
    {
      XBell(mydisplay,50);
      printf("didnt find any for index %d errnum %d instance %d\n",
	     boindex,in_errnum,in_instance);
      return;
    }


    
  
  error_items = (XmString *) (malloc(sizeof(XmString *) * total));
  if(error_items==NULL){printf("error_items: out of allocation memory!\n"); ExitWrapper(-1);}
  
  


  for(j=0;j<total;j++)
    {
      sprintf(temp,"Condition %*d (Individual #%*d)",len2,j+1,len1,error_specs[j]);

      if(usemags==1)
	{
	  sprintf(temp2," (Magnitude %s)",GetCoordString(4,error_mags[j]));
	  strcat(temp,temp2);
	}
      else if(usemags==2)
	{
	  sprintf(temp2," (Magnitude %d)",(int)error_mags[j]);
	  strcat(temp,temp2);
	}
      if(other_eccs[j]>=0)
	{
	  if(NGA_TYPE==1)
	    {
	      sprintf(temp2," Involves %s (%s)",GetECCCode(other_eccs[j]),GetECCLabel(other_eccs[j]));
	    }
	  else
	    {
	      sprintf(temp2," Involves %s",GetECCLabel(other_eccs[j]));
	    }
	  strcat(temp,temp2);
	}
      error_items[j] = XmStringCreateLocalized (temp);
    }

  n = 0;


  

  sprintf(list_translations24,"#override\n <Key>osfUp: ListPrevItem()ListEndSelect()\n <Btn4Up>:          list_scroll_bo(1,%d,%d,%d)\n <Btn5Up>:          list_scroll_bo(2,%d,%d,%d)\n <Btn2Down>: do_nothing2(2down)\n <Btn2Up>: do_nothing2(2up)",
		boindex,in_errnum,in_instance,boindex,in_errnum,in_instance);
		


  XtSetArg(resources[n], 
	  XmNtranslations, XtParseTranslationTable (list_translations24));   n++;
  



  subhandle = XtVaCreateManagedWidget("subhandle",
				      xmHandleWidgetClass,
				      parent,
				      NULL);
  
  scrollwid = 
    XmCreateScrolledList (subhandle, "list", resources,n);
  

  

  if(total<10)
    {
      i=total; 
    }
  else
    {
      i=10;
    }



  
  XtVaSetValues (scrollwid,
		 XmNitems,            error_items,
		 XmNitemCount,        total,
		 XmNvisibleItemCount, i,
		 XmNselectionPolicy,  XmEXTENDED_SELECT,
		 NULL);
  
  
  XtVaGetValues(scrollwid,
		XmNverticalScrollBar,&vert_scroll_bo[boindex][in_errnum][in_instance],NULL);
  





  mydata  = (MyData *) (malloc(sizeof(MyData)));
  if(mydata==NULL){printf("myb: out of allocation memory!\n"); ExitWrapper(-1);}
  mydata->object_num   = in_obnum;
  mydata->check_num    = in_errnum;
  mydata->clonenum     = in_instance;
  mydata->wid_to_pass  = allwid;
  mydata->wid2_to_pass = somewid;
  mydata->axis         = boindex;
  mydata->ADDER        = savetotalread;


  XtAddCallback (scrollwid, 
		 XmNextendedSelectionCallback, (XtCallbackProc)choose_specific_bo, mydata);





  XtManageChild (scrollwid);








  
  
  curr = BOOnList;
  while(curr!=NULL)
    {
      if(
	 (curr->errnum  ==in_errnum)   &&
	 (curr->instance==in_instance) &&
	 (curr->ob_num  ==in_obnum)
	 )
	{
	  if(curr->selectcount>0)
	    {
	      printf("Selecting %d items in %d %d %d\n",curr->selectcount,in_obnum,in_errnum,in_instance);

	      XtVaSetValues (scrollwid,
			     XmNselectionPolicy,  XmMULTIPLE_SELECT,
			     NULL);

	      for(i=0;i<curr->selectcount;i++)
		{	      
		  XmListSelectPos(scrollwid,curr->selectlist[i],0);
		}
	      XtVaSetValues (scrollwid,
			     XmNselectionPolicy,  XmEXTENDED_SELECT,
			     NULL);
	      break;
	    }

	}
     curr = curr->next;
    }

  
  
  for (i = 0; i <  total; i++)
    {
      XmStringFree (error_items[i]);
    }     
  free(error_items);
  free(error_specs);
  free(other_eccs);

  if(usemags>0)
    {
      free(error_mags);
    }
}






void VCToggleButtonHandleCB(Widget w, MyData  *closure, XtPointer call_data)
{
  XmOutlineWidget outline = (XmOutlineWidget) closure->outlinewid;
  int level = closure->level;
  int group_num,check_num,clonenum,cloneindex;
  static int LOCALBUSY=0;

  if(LOCALBUSY==1)
    {
      printf("too busy to expand/collapse\n");
      return;
    }
  
  LOCALBUSY = 1;
  
  
  if(level==1)
    {
      if(VCOnOff1==1)
	{
	  XtUnmanageChild((Widget) outline);
	  XtVaSetValues(w, XmNlabelPixmap, plus_pix, NULL);
	  VCOnOff1 = 0;
	}
      else if(VCOnOff1==0)
	{
	  XtManageChild((Widget) outline);
	  XtVaSetValues(w, XmNlabelPixmap, minus_pix, NULL);
	  VCOnOff1 = 1;
	}
    }
  else if(level==2)
    {
      group_num = closure->group_num;
      if(group_num>=NUMCHECKGROUPS)
	{
	  printf("bad group num %d\n",group_num);
	}
      else if(VCOnOff2[group_num]==1)
	{
	  XtUnmanageChild((Widget) outline);
	  VCOnOff2[group_num] = 0;
	  XtVaSetValues(w, XmNlabelPixmap, plus_pix, NULL);
	}
      else if(VCOnOff2[group_num]==0)
	{
	  XtManageChild((Widget) outline);
	  VCOnOff2[group_num] = 1;
	  XtVaSetValues(w, XmNlabelPixmap, minus_pix, NULL);
	}
    }
  else if(level==3)
    {
      check_num = closure->check_num;
      
      if(check_num>CONDITION_DEFINITIONS)
	{
	  printf("bad check num %d\n",check_num);
	}
      else if(VCOnOff3[check_num]==1)
	{
	  XtUnmanageChild((Widget) outline);
	  VCOnOff3[check_num] = 0;
	  XtVaSetValues(w, XmNlabelPixmap, plus_pix, NULL);
	}
      else if(VCOnOff3[check_num]==0)
	{
	  XtManageChild((Widget) outline);
	  VCOnOff3[check_num] = 1;
	  XtVaSetValues(w, XmNlabelPixmap, minus_pix, NULL);
	}
    }
  else if(level==4)
    {
      
      
      clonenum  = closure->clonenum;
      check_num = closure->check_num;
      
      if(clonenum>0)
	{
	  cloneindex = GetCloneIndex(clonenum,check_num);
	  if(CloneErrorLookup[cloneindex].VConoff==1)
	    {
	      XtUnmanageChild((Widget) outline);
	      CloneErrorLookup[cloneindex].VConoff = 0;
	      XtVaSetValues(w, XmNlabelPixmap, plus_pix, NULL);
	    }
	  else if(CloneErrorLookup[cloneindex].VConoff==0)
	    {
	      if(CloneErrorLookup[cloneindex].scrollwidmade==0)
		{
		  BuildSpecificCond((Widget) outline, check_num, clonenum,-1);
		  
		  CloneErrorLookup[cloneindex].scrollwidmade = 1;
		}
	      
	      XtManageChild((Widget) outline);
	      
	      
	      CloneErrorLookup[cloneindex].VConoff = 1;
	      XtVaSetValues(w, XmNlabelPixmap, minus_pix, NULL);
	    }	  
	}
      else
	{
	  check_num   = closure->check_num;

	  if(check_num>CONDITION_DEFINITIONS)
	    {
	      printf("bad index in VConoff %d\n",check_num);
	    }
	  else if(ErrorLookup[check_num].VConoff==1)
	    {
	      XtUnmanageChild((Widget) outline);
	      ErrorLookup[check_num].VConoff = 0;
	      XtVaSetValues(w, XmNlabelPixmap, plus_pix, NULL);
	    }
	  else if(ErrorLookup[check_num].VConoff==0)
	    {

	      if(ErrorLookup[check_num].scrollwidmade==0)
		{
		  BuildSpecificCond((Widget) outline, check_num, -1,-1);

		  ErrorLookup[check_num].scrollwidmade = 1;
		}


	      XtManageChild((Widget) outline);
	      

	      ErrorLookup[check_num].VConoff = 1;
	      XtVaSetValues(w, XmNlabelPixmap, minus_pix, NULL);
	    }
	}
    }
  else
    {
      printf("got bad level %d\n",level);
    }

  LOCALBUSY = 0;
}
   

























int RemoveBOLevel(int object_num, int group_num, int errnum,int instance)
{
  
  
  
  
  
  struct BOLevelList *temp,*prev;
  
  temp = BOLevelListRoot;
  prev = temp;  

  while(temp!=NULL)
    {
      if(
	 (temp->ob_num   ==object_num)&&
	 (temp->group_num==group_num) &&
	 (temp->errnum   ==errnum)    &&
	 (temp->instance ==instance)
	 )
	{
	  if(temp==BOLevelListRoot)
	    {
	      BOLevelListRoot = BOLevelListRoot->next;
	      free(prev);
	    }
	  else
	    {
	      prev->next = temp->next;
	      free(temp);
	    }
	  return 1;
	}
      prev = temp;
      temp = temp->next;
    }
  return 0;
}




void InsertBOLevel(int object_num, int group_num, int errnum,int instance, Widget outlinewid)
{
  
  
  
  
  struct BOLevelList *temp;


  temp = (struct BOLevelList *)malloc(sizeof(struct BOLevelList));

  temp->ob_num     = object_num;
  temp->group_num  = group_num;
  temp->errnum     = errnum;
  temp->instance   = instance;
  temp->next       = BOLevelListRoot;
  BOLevelListRoot  = temp;
  
}


int FindBOLevel(int object_num, int group_num, int errnum,int instance)
{
  
  
  
  
  
  struct BOLevelList *temp;
  
  temp =  BOLevelListRoot;
  
  while(temp!=NULL)
    {
      if(
	 (temp->ob_num   ==object_num) &&
	 (temp->group_num==group_num)  &&
	 (temp->errnum   ==errnum)     &&
	 (temp->instance ==instance)
	 )
	{
	  return 1;
	}
      temp = temp->next;
    }
  return 0;
}




void BOToggleButtonHandleCB(Widget w,
			    MyData  *closure,
			    XtPointer call_data)
{
  XmOutlineWidget outline = (XmOutlineWidget) closure->outlinewid;
  int level = closure->level;
  int object_num,group_num,errnum,instance;
  static int LOCALBUSY=0;

  if(LOCALBUSY==1)
    {
      printf("ignoring button click due to being busy\n");
      return;
    }


  LOCALBUSY = 1;

  if(BODEBUG==1)
    {
      printf("BO: level %d\n",level);
    }



  if(level==1)
    {
      if(BOOnOff1==1)
	{
	  XtUnmanageChild((Widget) outline);
	  XtVaSetValues(w, XmNlabelPixmap, plus_pix, NULL);
	  BOOnOff1 = 0;
	}
      else if(BOOnOff1==0)
	{
	  XtManageChild((Widget) outline);
	  XtVaSetValues(w, XmNlabelPixmap, minus_pix, NULL);
	  BOOnOff1 = 1;
	}
    }
  else if(level==2)
    {
      object_num = closure->group_num;

      if(BOOnOff2[object_num]==1)
	{
	  XtUnmanageChild((Widget) outline);
	  BOOnOff2[object_num] = 0;
	  XtVaSetValues(w, XmNlabelPixmap, plus_pix, NULL);
	}
      else if(BOOnOff2[object_num]==0)
	{
	  XtManageChild((Widget) outline);
	  BOOnOff2[object_num] = 1;
	  XtVaSetValues(w, XmNlabelPixmap, minus_pix, NULL);
	}
    }
  else if(level==3)
    {
      
      
      object_num = closure->object_num;
      group_num  = closure->group_num;
      errnum     = closure->check_num;
      instance   = closure->clonenum;

      if(RemoveBOLevel(object_num,group_num,errnum,instance)==1)
	{
	  if(BODEBUG==1)
	    {
	      printf("FOUND and removed object %d, group %d was closed\n",
		     object_num,group_num);  
	    }

	  XtManageChild((Widget) outline);
	  XtVaSetValues(w, XmNlabelPixmap, minus_pix, NULL);
	}
      else
	{
	  if(BODEBUG==1)
	    {
	      printf("inserting object %d, group %d was open\n",
		     object_num,group_num);
	    }

	  InsertBOLevel(object_num,group_num,errnum,instance,(Widget)outline);

	  XtUnmanageChild((Widget) outline);
	  XtVaSetValues(w, XmNlabelPixmap, plus_pix, NULL);
	}

    }
  else if(level==4)
    {
      
      
      object_num = closure->object_num;
      group_num  = closure->group_num;
      errnum     = closure->check_num;
      instance   = closure->clonenum;

      if(RemoveBOLevel(object_num,group_num,errnum,instance)==1)
	{
	  if(BODEBUG==1)
	    {
	      printf("FOUND and removed object %d, group %d was closed\n",
		     object_num,group_num);  
	    }

	  XtUnmanageChild((Widget) outline);
	  XtVaSetValues(w, XmNlabelPixmap, plus_pix, NULL);
	}
      else
	{
	  if(BODEBUG==1)
	    {
	      printf("insert object %d, group %d was open\n",
		     object_num,group_num);
	    }

	  
	  InsertBOLevel(object_num,group_num,errnum,instance,(Widget)outline);

	  XtManageChild((Widget) outline);
	  XtVaSetValues(w, XmNlabelPixmap, minus_pix, NULL);
	}
    }
  else
    {
      printf("bad BO level %d\n",level);
    }

  LOCALBUSY = 0;
}
   






void ToggleButtonHandleCB(Widget w,
			  MyData  *closure,
			  XtPointer call_data)
{
  XmOutlineWidget outline = (XmOutlineWidget) closure->outlinewid;
  int level = closure->level;
  int j,group_num,index,cloneindex,clonenum,errnum;


  if(level==1)
    {
      if(OnOff1==1)
	{
	  XtUnmanageChild((Widget) outline);
	  XtVaSetValues(w, XmNlabelPixmap, plus_pix, NULL);
	  OnOff1 = 0;
	}
      else if(OnOff1==0)
	{
	  XtManageChild((Widget) outline);
	  XtVaSetValues(w, XmNlabelPixmap, minus_pix, NULL);
	  OnOff1 = 1;
	}
    }
  else if(level==2)
    {
      group_num = closure->group_num;
      if(group_num>=NUMCHECKGROUPS)
	{
	  printf("bad group num %d\n",group_num);
	}
      else if(OnOff2[group_num]==1)
	{
	  XtUnmanageChild((Widget) outline);
	  OnOff2[group_num] = 0;
	  XtVaSetValues(w, XmNlabelPixmap, plus_pix, NULL);
	}
      else if(OnOff2[group_num]==0)
	{
	  XtManageChild((Widget) outline);
	  OnOff2[group_num] = 1;
	  XtVaSetValues(w, XmNlabelPixmap, minus_pix, NULL);
	}
    }
  else if(level==3)
    {
      clonenum = closure->clonenum;
      errnum   = closure->check_num;
      if(clonenum>0)
	  { 
	   cloneindex = GetCloneIndex(clonenum,errnum);
	   if(CloneErrorLookup[cloneindex].onoff==1)
	    {
	      XtUnmanageChild((Widget) outline);
	      CloneErrorLookup[cloneindex].onoff = 0;
	      XtVaSetValues(w, XmNlabelPixmap, plus_pix, NULL);
	    }
	   else if(CloneErrorLookup[cloneindex].onoff==0)
	    {
	      XtManageChild((Widget) outline);
	      CloneErrorLookup[cloneindex].onoff = 1;
	      XtVaSetValues(w, XmNlabelPixmap, minus_pix, NULL);
	    }

	  } 
      else
	  { 
	   index = closure->check_num;
	   if(index>CONDITION_DEFINITIONS)
	    {
	      printf("bad index inonoff %d\n",index);
	    }
	   else if(ErrorLookup[index].onoff==1)
	    {
	      XtUnmanageChild((Widget) outline);
	      ErrorLookup[index].onoff = 0;
	      XtVaSetValues(w, XmNlabelPixmap, plus_pix, NULL);
	    }
	   else if(ErrorLookup[index].onoff==0)
	    {		   
		  XtManageChild((Widget) outline);
	      ErrorLookup[index].onoff = 1;
	      XtVaSetValues(w, XmNlabelPixmap, minus_pix, NULL);
	    }
	  } 
    }
  else if(level==4)
    {
      

      index   = closure->check_num;

      

      if(index>CONDITION_DEFINITIONS)
	{
	  printf("bad index in masteronoff %d\n",index);
	}
      else if(ErrorLookup[index].masteronoff==1)
	{


	  XtUnmanageChild((Widget) outline);
	  ErrorLookup[index].masteronoff = 0;
	  XtVaSetValues(w, XmNlabelPixmap, plus_pix, NULL);
	}
      else if(ErrorLookup[index].masteronoff<=0)
	{

      if(ErrorLookup[index].masteronoff<0)
	  {
        set_cursor(mydisplay,mywindow,WATCH);
        if(head_in_use==0)
		{
	      set_cursor(XtDisplay(param_head),XtWindow(param_head),WATCH);
		}
        else
		{ 
 	      set_cursor(XtDisplay(param2_head),XtWindow(param2_head),WATCH);
		} 
  
        BuildEntries((Widget) outline,index,0,0);
		  
	    for(j=0;j<ErrorLookup[index].num_clones;j++)
		{
	      BuildEntries((Widget) outline,index,j+1,0);
		} 

		set_cursor(mydisplay,mywindow,GOOD);
        if(head_in_use==0)
		{ 
	      set_cursor(XtDisplay(param_head),XtWindow(param_head),ARROW);
		} 
        else
		{ 
 	      set_cursor(XtDisplay(param2_head),XtWindow(param2_head),ARROW);
		} 

	  }


	  XtManageChild((Widget) outline);
	  ErrorLookup[index].masteronoff = 1;
	  XtVaSetValues(w, XmNlabelPixmap, minus_pix, NULL);
	}
    }


}








void NetConfigToggleButtonHandleCB(Widget w,
			  MyData  *closure,
			  XtPointer call_data)
{
  XmOutlineWidget outline = (XmOutlineWidget) closure->outlinewid;
  int level = closure->level;
  extern int NetConfigOnOff1;

  if(level==1)
    {
      if(NetConfigOnOff1==1)
	{
	  XtUnmanageChild((Widget) outline);
	  XtVaSetValues(w, XmNlabelPixmap, plus_pix, NULL);
	  NetConfigOnOff1 = 0;
	}
      else if(NetConfigOnOff1==0)
	{
	  XtManageChild((Widget) outline);
	  XtVaSetValues(w, XmNlabelPixmap, minus_pix, NULL);
	  NetConfigOnOff1 = 1;
	}
    }
  else
    {
      printf("Internal error: BL %d to NCTBH\n",level);
    }


}





void BuildEntries(Widget suboutline, int i, int clonenum, int nettype)
{
  XmString str;
  Widget tog,button1,buttonA,buttonB,buttonC,subsubhandle,left,handle2,handle3,outline;
  char temp[1000];
  MyData *mydata, *mydata3;
  int cloneindex;
  String use_translations;


  if(nettype==1)
  {
    use_translations = list_translations64;
  }
  else
  {
    use_translations = list_translations7;
  }


  if(clonenum>0)
  {
    cloneindex = GetCloneIndex(clonenum,i);
    
  }



  mydata  = (MyData *) (malloc(sizeof(MyData)));
  if(mydata==NULL){printf("myb: out of allocation memory!\n"); ExitWrapper(-1);}
  
  
  mydata->clonenum  = clonenum;
  mydata->check_num = i;
  
 
  
  subsubhandle = XtVaCreateManagedWidget("subhandle",
					 xmHandleWidgetClass,
					 suboutline,
					 XmNtranslations,     XtParseTranslationTable (use_translations),
					 NULL);
  
  
  left = XtVaCreateManagedWidget("left", xmPushButtonWidgetClass,
				 subsubhandle,
				 XmNlabelType,        XmPIXMAP,
				 XmNlabelPixmap,      minus_pix,
				 XmNshadowThickness,  0,
				 XmNtranslations,     XtParseTranslationTable (use_translations),
				 NULL);
  
  
  

   if(clonenum==0)
    {
      if(ErrorLookup[i].Annotation==NULL)
	{
	  sprintf(temp,"<No Annotation Entered>");
	}
      else
	{
	  sprintf(temp,"%s",ErrorLookup[i].Annotation);
  	}
    }
  else
    {
      if(CloneErrorLookup[cloneindex].Annotation==NULL)
	{
	  sprintf(temp,"<No Annotation Entered>");
	}
      else
	{
	  sprintf(temp,"%s",CloneErrorLookup[cloneindex].Annotation);
	}
    }
  


  str = XmStringCreateLtoR (temp, "mytag1");
  
  
  tog = XtVaCreateManagedWidget ("the_test",
				 xmToggleButtonWidgetClass, subsubhandle,
				 XmNtraversalOn,      True,
				 XmNalignment,        XmALIGNMENT_BEGINNING,
 				 XmNtopAttachment,    XmATTACH_FORM,
				 XmNbottomAttachment, XmATTACH_FORM,
				 XmNlabelString,      STRING(" "), 
				 XmNtranslations,     XtParseTranslationTable (use_translations),
				 TOGGLEINCLUDE,
				 NULL);
  
  XtManageChild(tog);
  if(clonenum!=0)
    {
      XtAddCallback (tog, XmNvalueChangedCallback, (XtCallbackProc)toggledC3, mydata);
      
      XmToggleButtonSetState(tog,(Boolean)CloneErrorLookup[cloneindex].active,(Boolean)0);
    }
  else
    {
      XtAddCallback (tog, XmNvalueChangedCallback, toggled3, (XtPointer)i);
      
      XmToggleButtonSetState(tog,(Boolean)ErrorLookup[i].active,(Boolean)0);
    }




  button1 = XtVaCreateManagedWidget ("Help4",
				     xmPushButtonWidgetClass, subsubhandle,
				     XmNtraversalOn,  False,
				     XmNlabelString,  STRING("Set Annotation..."),
				     XmNtranslations, XtParseTranslationTable (use_translations),
				     NULL);
  XtAddCallback(button1, XmNactivateCallback, (XtCallbackProc)AnnotateCallback, mydata);


  

  if(clonenum==0)
    {
      ErrorLookup[i].annot_label = 
	XtVaCreateManagedWidget("annotation", xmLabelWidgetClass,
				subsubhandle,
				XmNlabelString,      str,
				XmNtopAttachment,    XmATTACH_FORM,
				XmNbottomAttachment, XmATTACH_FORM,
				XmNtranslations,     XtParseTranslationTable (use_translations),
				NULL);
    }
  else
    {
      CloneErrorLookup[cloneindex].annot_label = 
	XtVaCreateManagedWidget("annotation", xmLabelWidgetClass,
				subsubhandle,
				XmNlabelString,      str,
				XmNtopAttachment,    XmATTACH_FORM,
				XmNbottomAttachment, XmATTACH_FORM,
				XmNtranslations,     XtParseTranslationTable (use_translations),
				NULL);
      
    }



  if(nettype==1)
  {
    sprintf(temp," (Network specification #%d)",clonenum+1);
  }
  else
  {
    sprintf(temp," (Instantiation #%d: %s%d)",clonenum+1,ParseErrName(i),clonenum+1);
  }



  str = XmStringCreateLtoR (temp, "mytag1");
  
  button1 = XtVaCreateManagedWidget("annotation", xmLabelWidgetClass,
				    subsubhandle,
				    XmNlabelString,      str,
				    XmNtopAttachment,    XmATTACH_FORM,
				    XmNbottomAttachment, XmATTACH_FORM,
				    XmNtranslations,     XtParseTranslationTable (use_translations),
				    NULL);




  




  outline = XtVaCreateManagedWidget("outline", xmOutlineWidgetClass,
				    subsubhandle,
				    XmNindentation,  20,
				    XmNoutline,      TRUE,
				    XmNtranslations, XtParseTranslationTable (use_translations),
				    NULL);
  
  
  



  mydata3  = (MyData *) (malloc(sizeof(MyData)));
  if(mydata3==NULL){printf("myb: out of allocation memory!\n"); ExitWrapper(-1);}
  mydata3->outlinewid = (XmOutlineWidget)outline;
  mydata3->level = 3;
  mydata3->check_num = i;
  mydata3->clonenum  = clonenum;


  XtAddCallback(left, 
		XmNactivateCallback, (XtCallbackProc)ToggleButtonHandleCB, 
		(XtPointer) mydata3);
  
  XtVaSetValues(subsubhandle, 
		XmNsubWidget, outline,
		NULL);
  

  if(clonenum>0)
    {
      if(CloneErrorLookup[cloneindex].onoff==0)
	{
	  
	  XtUnmanageChild(outline);
	  XtVaSetValues(left, XmNlabelPixmap, plus_pix, NULL);
	}
    }
  else if(ErrorLookup[i].onoff==0)
    {
      
      XtUnmanageChild(outline);
      XtVaSetValues(left, XmNlabelPixmap, plus_pix, NULL);
    }



  handle2 = XtVaCreateManagedWidget("subhandle",
				    xmHandleWidgetClass,
				    outline,
				    XmNtranslations,     XtParseTranslationTable (use_translations),
				    NULL);
  
  

  if(
	  ((clonenum!=0)&&(CloneErrorLookup[cloneindex].UseBorderConds!=2))||
	  ((clonenum==0)&&(ErrorLookup[i].UseBorderConds!=2))
	 )
  {
    handle3 = XtVaCreateManagedWidget("subhandle",
				    xmHandleWidgetClass,
				    outline,
				    XmNtranslations,     XtParseTranslationTable (use_translations),
				    NULL);

    tog = XtVaCreateManagedWidget ("the_test",
				 xmToggleButtonWidgetClass, handle3,
				 XmNtraversalOn,      True,
				 XmNalignment,        XmALIGNMENT_BEGINNING,
 				 XmNtopAttachment,    XmATTACH_FORM,
				 XmNbottomAttachment, XmATTACH_FORM,
				 XmNlabelString,      STRING("Include Conditions on Project Boundary"),
				 XmNtranslations,     XtParseTranslationTable (use_translations),
				 TOGGLEINCLUDE,
				 NULL);
    XtManageChild(tog);

    if(clonenum!=0)
	{ 
      XtAddCallback (tog, XmNvalueChangedCallback, toggledC4, (XtPointer)cloneindex);
      XmToggleButtonSetState(tog,(Boolean)CloneErrorLookup[cloneindex].UseBorderConds,(Boolean)0);
	} 
    else
	{ 
      XtAddCallback (tog, XmNvalueChangedCallback, toggled4, (XtPointer)i);    
      XmToggleButtonSetState(tog,(Boolean)ErrorLookup[i].UseBorderConds,(Boolean)0);
	} 
  }



  buttonA = XtVaCreateManagedWidget ("Help2",
				     xmPushButtonWidgetClass, handle2,
				     XmNtraversalOn,  False,
				     XmNlabelString,  STRING("Definition"),
				     XmNtranslations, XtParseTranslationTable (use_translations),
				     NULL);
  XtAddCallback(buttonA, XmNactivateCallback, DescCallback, (XtPointer)i);

  
  buttonB = XtVaCreateManagedWidget ("Help3",
				     xmPushButtonWidgetClass, handle2,
				     XmNtraversalOn,  False,
				     XmNlabelString,  STRING("Applicability"),
				     XmNtranslations, XtParseTranslationTable (use_translations),
				     NULL);

  if(NGA_TYPE==1)
    {
      XtAddCallback(buttonB, XmNactivateCallback, (XtCallbackProc)NGAActorCallback, mydata);
    }
  else
    {
      XtAddCallback(buttonB, XmNactivateCallback, (XtCallbackProc)ActorCallback, mydata);
    }


  buttonC = XtVaCreateManagedWidget ("Help4",
				     xmPushButtonWidgetClass, handle2,
				     XmNtraversalOn,   False,
				     XmNlabelString,   STRING("Tolerance"),
				     XmNtranslations,  XtParseTranslationTable (use_translations),
				     NULL);
  XtAddCallback(buttonC, XmNactivateCallback, (XtCallbackProc)SensitivityCallback, mydata);
  
  if(ErrorLookup[i].numthresholds == 0)
    {
      XtSetSensitive(buttonC,False);
    }



 
  buttonB = XtVaCreateManagedWidget ("Help4",
				     xmPushButtonWidgetClass, handle2,
				     XmNtraversalOn,  False,
				     XmNlabelString,  STRING("Create new Instantiation"),
				     XmNtranslations, XtParseTranslationTable (use_translations),
				     NULL);

  XtAddCallback(buttonB, XmNactivateCallback, CloneCallback, (XtPointer)(i + nettype*10000));


  if(SingleInstance(i))
  {
    XtSetSensitive(buttonB,False);
  }


  if(nettype==0)
  {
    
    buttonB = XtVaCreateManagedWidget ("Help4",
				     xmPushButtonWidgetClass, handle2,
				     XmNtraversalOn,  False,
				     XmNlabelString,  STRING("De-Select all instances of this inspection"),
				     XmNtranslations, XtParseTranslationTable (use_translations),
				     NULL);
    XtAddCallback(buttonB, XmNactivateCallback, DeselectCallback, (XtPointer)(i + nettype*10000));
  }


  if(i==LODELEVDIF)
    {
      XtSetSensitive(buttonB,False);
    }



  
  
  
  XtManageChild(tog);

  
  
  XmStringFree (str);
}



void FreeBOSave()
{
  int i;
  
  if(BOSaveCount<=0)
    {
      return;
    }

  if(BODEBUG==1)
    {
      printf("freeing BOsave\n");
    }

  for(i=0;i<num_per_page;i++)
    {
	  if((i+1)>numobs)
	  {
	    break;
	  }
      free(BOSaveArray[i].conds);
    }
  
  BOSaveCount = 0;
  
  
  if(BODEBUG==1)
    {
      printf("done\n");
    }
}




void PrintBO()
{
  int i,j;

  
  for(i=0;i<num_per_page;i++)
    {
    
      printf("Object %d (%s) (%s) has %d conditions\n",
	     i,
	     GetShortGeomName(BOSaveArray[i].geomtype),
	     GetECCLabel(BOSaveArray[i].ECC1),
	     BOSaveArray[i].thisnum);

      
      for(j=0;j<BOSaveArray[i].thisnum;j++)
	{
	  if(BOSaveArray[i].conds[j].ECC2>=0)
	    {
	      printf("  FCODE2 %s errnum %d instance %d realnum %d magnitude %lf\n",
		     GetECCLabel(BOSaveArray[i].conds[j].ECC2),
		     BOSaveArray[i].conds[j].errnum,
		     BOSaveArray[i].conds[j].instance,
		     BOSaveArray[i].conds[j].specnum,
		     BOSaveArray[i].conds[j].magnitude);
	    }
	  else
	    {
	      printf("  errnum %d instance %d realnum %d magnitude %lf\n",
		     BOSaveArray[i].conds[j].errnum,
		     BOSaveArray[i].conds[j].instance,
		     BOSaveArray[i].conds[j].specnum,
		     BOSaveArray[i].conds[j].magnitude);
	    }
	}
    }
}









int GetTotalBO(int boindex, int *startindex)
{

  

  int total,k;
  int errnum,instance;

  total = 0;
  errnum   = BOSaveArray[boindex].conds[*startindex].errnum;
  instance = BOSaveArray[boindex].conds[*startindex].instance;
  

  for(k=*startindex;k<BOSaveArray[boindex].thisnum;k++)
    {
      if(
	 (BOSaveArray[boindex].conds[k].errnum  ==errnum)   &&
	 (BOSaveArray[boindex].conds[k].instance==instance)
	 )
	{
	  total = total + BOSaveArray[boindex].conds[k].num_errs;
	}
      else
	{
	  break;
	}

      
      k = k + BOSaveArray[boindex].conds[k].num_errs - 1;
      
    }

  *startindex = k; 
  return total;
}
  


int FindInBoList(int ob_num,int errnum,int instance,Widget allwid,Widget somewid)
{
 struct BOList *curr;

 curr = BOOnList;
 while(curr!=NULL)
   {
     if(
	(curr->errnum  ==errnum)   &&
	(curr->instance==instance) &&
	(curr->ob_num  ==ob_num)
	)
	{
	  

	  curr->allwid  = allwid;
	  curr->somewid = somewid;

	  if(curr->viewsome==1)
	    {
	      return 1;
	    }
	  else if(curr->viewall==1)
	    {
	      return 2;
	    }
	  else
	    {
	      printf("ERROR in FIBL: found %d/%d for %d %d %d\n",
		    curr->viewsome,curr->viewall,ob_num,errnum,instance);
	      return 0;
	    }
	}
     curr = curr->next;
   }
 return 0;
}









void FillPage(int page_num)
{
  

  Widget subhandle,left,suboutline,outline,right,
    checktypehandle,checktypeoutline,thiswid,instancehandle,instanceoutline,
    rc3,tempwid,form;
  XmString str;
  FILE *bofile;
  char geomtype;
  char thislabel[1000],filename[1000],message[1000],junk[100],temp[1000];
  int i,j,errnum,instance,thisnum,ECC1,colwid,boindex,cloneindex,
    colwid2,minindex,maxindex,totalread,num_errs,LLindex1,
    total,startindex,saveindex,result;
  double idindex, sortid;
  MyData *mydata3,*mydata4;
  struct BOList *bolistdata;
  static int LOCALBUSY = 0;
  extern struct CheckGroupNames CGN[NUMCHECKGROUPS];



  if(LOCALBUSY==1)
    {
      printf("BO selection ignored due to being too busy\n");
      return;
    }
  

  if(page_num==-1)
    {
      

      TopHandle = XtVaCreateManagedWidget("roothandle", xmHandleWidgetClass,
					  master_sw2,
					  XmNtranslations, XtParseTranslationTable (list_translations23),
					  NULL);
      
      TopLeft = XtVaCreateManagedWidget("left", xmPushButtonWidgetClass,
					TopHandle,
					XmNlabelType,       XmPIXMAP,
					XmNlabelPixmap,     minus_pix,
					XmNshadowThickness, 0,
					XmNtranslations, XtParseTranslationTable (list_translations23),
					NULL);



      

      sprintf(thislabel,"No features with conditions matching the currently active filters.\n\
Select \"Revert\" to de-activate all filters.\n(\"Note that 100%% Area Coverage Failure\" conditions do not appear here)");

      str = XmStringCreateLtoR (thislabel, "mytag1");


      
      right = XtVaCreateManagedWidget("NC", xmLabelWidgetClass,TopHandle,
				      XmNlabelString,  str,
					  XmNtranslations, XtParseTranslationTable (list_translations23),
				      NULL);
      
      
      return;
    }




  LOCALBUSY = 1;


  





  




  sprintf(filename,"%scondreport.bo2",outdirectory);
  bofile = fopen(filename,"rb");
  if(bofile==NULL)
    {
      sprintf(message,"Error: Unable to open for reading:\n %s\nCan not continue.",
	      filename);	 
      not_while_running(drawing_a,message,1389,"Can not open By Feature file",1);
      return;
    }
      


  
  
  fseek(bofile,pageptrs[page_num],SEEK_SET);


  minindex = num_per_page*(page_num-1) + 1;
  maxindex = minindex + num_per_page - 1;
  

  if(minindex<1)
    {
      XBell(mydisplay,50);
      printf("Error in 1311: trying to set minindex to %d\n",minindex);
      minindex = 1;
    }
  maxindex = minindex + num_per_page - 1;
  if(maxindex>numobs)
    {
      maxindex = numobs;
    }






  sprintf(junk,"%d",maxindex);
  colwid = strlen(junk);

  if(BODEBUG==1)
    {
      printf("min %d max %d width %d\n",minindex,maxindex,colwid);
    }




  if(dead_obhead[current_ob_head]==0)
    {
      

      XtUnmanageChild(TopHandle);
      XtDestroyWidget(TopHandle);
    }




  TopHandle = XtVaCreateManagedWidget("roothandle", xmHandleWidgetClass,
				      master_sw2,
					  XmNtranslations, XtParseTranslationTable (list_translations23),
				      NULL);
  
  TopLeft = XtVaCreateManagedWidget("left", xmPushButtonWidgetClass,
				    TopHandle,
				    XmNlabelType,       XmPIXMAP,
				    XmNlabelPixmap,     minus_pix,
				    XmNshadowThickness, 0,
					XmNtranslations, XtParseTranslationTable (list_translations23),
				    NULL);
  
  
  right = XtVaCreateManagedWidget("Features with Conditions", xmLabelWidgetClass,
				  TopHandle,
				  XmNtranslations, XtParseTranslationTable (list_translations23),
				  NULL);
  
  

  sprintf(temp," (showing [%d-%d] of %d total)",minindex,maxindex,numobs);
  
  topright = XtVaCreateManagedWidget(temp, xmLabelWidgetClass,
				     TopHandle,
					 XmNtranslations, XtParseTranslationTable (list_translations23),
				     NULL);
  
  
  

  
  outline = XtVaCreateManagedWidget("outline", xmOutlineWidgetClass,
				    TopHandle,
				    XmNindentation, 20,
				    XmNoutline,     TRUE,
					XmNtranslations, XtParseTranslationTable (list_translations23),
				    NULL);
  



  
  mydata3  = (MyData *) (malloc(sizeof(MyData)));
  if(mydata3==NULL){printf("myb: out of allocation memory!\n"); ExitWrapper(-1);}
  mydata3->outlinewid = (XmOutlineWidget)outline;
  mydata3->level = 1;
  
  XtAddCallback(TopLeft, 
		XmNactivateCallback, (XtCallbackProc)BOToggleButtonHandleCB, 
		(XtPointer) mydata3);



  XtVaSetValues(TopHandle, 
		XmNsubWidget, outline,
		NULL);
  
  

  if(BOOnOff1==0)
    {
      
      XtUnmanageChild(outline);
      XtVaSetValues(TopLeft, XmNlabelPixmap, plus_pix, NULL);
    }


    


  

  if(BOSaveCount>0)
    {
      if(BODEBUG==1)
	{
	  printf("freeing BO!\n");
	}
      FreeBOSave();
    }


  for(i=0;i<num_per_page;i++)
    {      
      for(j=0;j<NUMCHECKGROUPS;j++)
	{
	  BOSaveArray[i].groupinout[j] = 0;
	}
    }




  BOSaveCount = 1; 
  
  
  for(i=0;i<num_per_page;i++)
    { 
      if((i+1)>numobs)
	{
	  break;
	}
      
      SEEIT_fread_char  (&BOSaveArray[i].geomtype,bofile);
      SEEIT_fread_double(&sortid, bofile);  
      SEEIT_fread_double(&BOSaveArray[i].idindex, bofile);
      SEEIT_fread_int   (&BOSaveArray[i].ECC1,    bofile);
      SEEIT_fread_int   (&BOSaveArray[i].LLindex1,bofile);
      SEEIT_fread_int   (&BOSaveArray[i].thisnum, bofile);
      
      if(BODEBUG==1)
	{
	  printf("top level read %s %lf %d (%s) %d %d\n",
		 GetShortGeomName(BOSaveArray[i].geomtype),
		 BOSaveArray[i].idindex,
		 BOSaveArray[i].ECC1,GetECCLabel(BOSaveArray[i].ECC1),
		 BOSaveArray[i].LLindex1,
		 BOSaveArray[i].thisnum	     
		 );
	}


      BOSaveArray[i].conds = 
	(struct BOSave2 *)malloc(sizeof(struct BOSave2)*BOSaveArray[i].thisnum);

      totalread = 0;
      
      while(totalread<BOSaveArray[i].thisnum)
	{
	  SEEIT_fread_int(&errnum,   bofile);
	  SEEIT_fread_int(&num_errs, bofile);
	  SEEIT_fread_int(&instance, bofile);
	  
	  BOSaveArray[i].groupinout[ErrorLookup[errnum].mygroup] = 
	    BOSaveArray[i].groupinout[ErrorLookup[errnum].mygroup] + num_errs;
	  
	  instance = instance + 1;
	  
	  
	  
	  for(j=0;j<num_errs;j++)
	    {
	      
	      BOSaveArray[i].conds[totalread].errnum   = errnum;
	      BOSaveArray[i].conds[totalread].num_errs = num_errs;
	      BOSaveArray[i].conds[totalread].instance = instance;
	      
	      SEEIT_fread_double(&BOSaveArray[i].conds[totalread].magnitude,bofile);
	      SEEIT_fread_int   (&BOSaveArray[i].conds[totalread].ECC2,     bofile);
	      SEEIT_fread_int   (&BOSaveArray[i].conds[totalread].LLindex2, bofile);
	      SEEIT_fread_int   (&BOSaveArray[i].conds[totalread].specnum,  bofile);

	      totalread = totalread + 1;
	    }
	}
    }





  for(i=minindex;i<=maxindex;i++)
    {       
      boindex = i - minindex;


      ECC1     = BOSaveArray[boindex].ECC1;
      geomtype = BOSaveArray[boindex].geomtype;
      thisnum  = BOSaveArray[boindex].thisnum;
      idindex  = BOSaveArray[boindex].idindex;
      LLindex1 = BOSaveArray[boindex].LLindex1;

      if(i==minindex)
	{
	  
	  sprintf(junk,"%d",thisnum);
	  colwid2 = strlen(junk);
	}
      
      if(NGA_TYPE==1)
	{
	  if(thisnum==1)
	    {
	      sprintf(thislabel,"(%*d): %*d condition   %s: %s (%s)",
		      colwid,i,
		      colwid2,thisnum,
		      GetECCCode(ECC1),GetECCLabel(ECC1),
		      GetShortGeomName(geomtype));
	    }
	  else
	    {
	      sprintf(thislabel,"(%*d): %*d conditions  %s: %s (%s)",
		      colwid,i,
		      colwid2,thisnum,
		      GetECCCode(ECC1),GetECCLabel(ECC1),
		      GetShortGeomName(geomtype));
	    }
	}
      else
	{
	  if(thisnum==1)
	    {
	      sprintf(thislabel,"(%*d): %*d condition   %s (%s)",
		      colwid,i,
		      colwid2,thisnum,
		      GetECCLabel(ECC1),
		      GetShortGeomName(geomtype));
	    }
	  else
	    {
	      sprintf(thislabel,"(%*d): %*d conditions  %s (%s)",
		      colwid,i,
		      colwid2,thisnum,
		      GetECCLabel(ECC1),
		      GetShortGeomName(geomtype));
	    }
	}
	  
      subhandle = XtVaCreateManagedWidget("subhandle",
					  xmHandleWidgetClass,
					  outline,
					  XmNtranslations, XtParseTranslationTable (list_translations23),
					  NULL);

      left = XtVaCreateManagedWidget("left", xmPushButtonWidgetClass,
				     subhandle,
				     XmNlabelType, XmPIXMAP,
				     XmNlabelPixmap, minus_pix,
				     XmNarrowDirection, XmARROW_DOWN,
				     XmNshadowThickness, 0,
					 XmNtranslations, XtParseTranslationTable (list_translations23),
				     NULL);
      
      thiswid = XtVaCreateManagedWidget(thislabel, xmLabelWidgetClass,
					subhandle,
					XmNtranslations, XtParseTranslationTable (list_translations23),
					NULL);
      
      suboutline = XtVaCreateManagedWidget("suboutline",
					   xmOutlineWidgetClass,
					   subhandle, 
					   XmNindentation, 20, 
					   XmNoutline, TRUE,
					   XmNtranslations, XtParseTranslationTable (list_translations23),
					   NULL);
      
      
      
      mydata4  = (MyData *) (malloc(sizeof(MyData)));
      if(mydata4==NULL){printf("myb: out of allocation memory!\n"); ExitWrapper(-1);}
      mydata4->outlinewid = (XmOutlineWidget)suboutline;
      mydata4->level     = 2;
      mydata4->group_num = i;
      
      
      XtAddCallback(left, 
		    XmNactivateCallback, (XtCallbackProc)BOToggleButtonHandleCB, 
		    (XtPointer) mydata4);
      
      
      if(BOOnOff2[i]==0)
	{
	  
	  XtUnmanageChild(suboutline);
	  XtVaSetValues(left, XmNlabelPixmap, plus_pix, NULL);
	}
      
      
      XtVaSetValues(subhandle, 
		    XmNsubWidget, suboutline, 
		    NULL);




    



      

      for(j=0;j<NUMCHECKGROUPS;j++)
	{
	  if(BOSaveArray[boindex].groupinout[j]>0)
	    {

	      if(BODEBUG==1)
		{
		  printf("  Item %d - group %s\n",i,CGN[j].name);
		}

	      
	      
	      if(BOSaveArray[boindex].groupinout[j]==1)
		{
		  sprintf(thislabel,"%s (%d condition)",
			  CGN[j].name,BOSaveArray[boindex].groupinout[j]);
		}
	      else
		{
		  sprintf(thislabel,"%s (%d conditions)",
			  CGN[j].name,BOSaveArray[boindex].groupinout[j]);
		}
	      
	      str = XmStringCreateLtoR (thislabel, "mytag1");
	      
	      


	      checktypehandle = XtVaCreateManagedWidget("checktypehandle",
							xmHandleWidgetClass,
							suboutline,
							XmNtranslations, XtParseTranslationTable (list_translations23),
							NULL);

	      left = XtVaCreateManagedWidget("left", xmPushButtonWidgetClass,
					     checktypehandle,
					     XmNlabelType,       XmPIXMAP,
					     XmNlabelPixmap,     minus_pix,
					     XmNarrowDirection,  XmARROW_DOWN,
					     XmNshadowThickness, 0,
						 XmNtranslations, XtParseTranslationTable (list_translations23),
					     NULL);
	      
	      thiswid = XtVaCreateManagedWidget("test5419", xmLabelWidgetClass,
						checktypehandle,
						XmNlabelString,  str,
						XmNtranslations, XtParseTranslationTable (list_translations23),
						NULL);
	      
	      checktypeoutline = XtVaCreateManagedWidget("suboutline",
							 xmOutlineWidgetClass,
							 checktypehandle, 
							 XmNindentation, 20, 
							 XmNoutline,     TRUE,
							 XmNtranslations, XtParseTranslationTable (list_translations23),
							 NULL);
	      
	      mydata4  = (MyData *) (malloc(sizeof(MyData)));
	      if(mydata4==NULL){printf("myb: out of allocation memory!\n"); ExitWrapper(-1);}
	      mydata4->outlinewid = (XmOutlineWidget)checktypeoutline;
	      mydata4->level      = 3;
	      mydata4->group_num  = j;
	      mydata4->object_num = i;
	      mydata4->check_num  = -1;
	      mydata4->clonenum   = -1;
	      

	      XtAddCallback(left, 
			    XmNactivateCallback, (XtCallbackProc)BOToggleButtonHandleCB, 
			    (XtPointer) mydata4);
	      
	      
	      if(FindBOLevel(mydata4->object_num, 
			     mydata4->group_num,
			     mydata4->check_num,
			     mydata4->clonenum
			     )==1)
		{

		  
		  XtUnmanageChild(checktypeoutline);
		  XtVaSetValues(left, XmNlabelPixmap, plus_pix, NULL);
		}
      


	      
	      XtVaSetValues(checktypehandle,
			    XmNsubWidget, checktypeoutline,
			    NULL);

	      
	    
	      startindex = 0;
	      while(startindex<BOSaveArray[boindex].thisnum)
		{
		  saveindex = startindex;
		  total = GetTotalBO(boindex,&startindex);
		  

		  if(ErrorLookup[BOSaveArray[boindex].conds[saveindex].errnum].mygroup!=j)
		    {
		      continue;
		    }

		  if(BOSaveArray[boindex].conds[saveindex].instance==1)
		    {
		      if(ErrorLookup[BOSaveArray[boindex].conds[saveindex].errnum].Annotation==NULL)
			{
			  sprintf(thislabel,"%s (%d) (instantiation %d)",
				  ParseErrType(BOSaveArray[boindex].conds[saveindex].errnum),
				  total,
				  BOSaveArray[boindex].conds[saveindex].instance);
			}
		      else
			{
			  sprintf(thislabel,"%s (%d) (instantiation %d)\n(%s)",
				  ParseErrType(BOSaveArray[boindex].conds[saveindex].errnum),
				  total,
				  BOSaveArray[boindex].conds[saveindex].instance,
				  ErrorLookup[BOSaveArray[boindex].conds[saveindex].errnum].Annotation);
			}
		    }
		  else
		    {
		      cloneindex = GetCloneIndex(
						 BOSaveArray[boindex].conds[saveindex].instance-1,
						 BOSaveArray[boindex].conds[saveindex].errnum);
		      
		      if(CloneErrorLookup[cloneindex].Annotation==NULL)
			{
			  sprintf(thislabel,"%s (%d) (instantiation %d)",
				  ParseErrType(BOSaveArray[boindex].conds[saveindex].errnum),
				  total,
				  BOSaveArray[boindex].conds[saveindex].instance);
			}
		      else
			{
			  sprintf(thislabel,"%s (%d) (instantiation %d)\n(%s)",
				  ParseErrType(BOSaveArray[boindex].conds[saveindex].errnum),
				  total,
				  BOSaveArray[boindex].conds[saveindex].instance,
				  CloneErrorLookup[cloneindex].Annotation);
			}
		      
		    }
		  
		  str = XmStringCreateLtoR (thislabel, "mytag1");


		  


		  
		  instancehandle = XtVaCreateManagedWidget("checktypehandle",
							   xmHandleWidgetClass,
							   checktypeoutline,
							   XmNtranslations, XtParseTranslationTable (list_translations23),
							   NULL);
		  



		  rc3 = XtVaCreateWidget ("rowcol",xmRowColumnWidgetClass, instancehandle, 
			  XmNtranslations, XtParseTranslationTable (list_translations23),
			  NULL);
		  
		  
		  form = XtVaCreateWidget ("form.error.editor", xmFormWidgetClass, rc3,
					   XmNfractionBase,  100, 
					   XmNtranslations, XtParseTranslationTable (list_translations23),
					   NULL);
		  
		  
		  left = XtVaCreateManagedWidget("left", xmPushButtonWidgetClass,
						 form,
						 XmNlabelType,       XmPIXMAP,
						 XmNlabelPixmap,     minus_pix,
						 XmNarrowDirection,  XmARROW_DOWN,
						 XmNshadowThickness, 0,
						 XmNtraversalOn,     False,
						 XmNtranslations, XtParseTranslationTable (list_translations23),
						 NULL);
		  
		  tempwid = 
		    XtVaCreateManagedWidget ("the_test",
					     xmLabelWidgetClass, form,
					     XmNtopAttachment,    XmATTACH_FORM,
					     XmNtraversalOn,      True,
					     XmNbottomAttachment, XmATTACH_FORM,
					     XmNleftAttachment,   XmATTACH_POSITION,
					     XmNleftPosition,     4,
					     XmNrightAttachment,  XmATTACH_POSITION,
					     XmNrightPosition,    100,
					     XmNlabelString, str,
					     XmNalignment,        XmALIGNMENT_BEGINNING,
					     XmNtranslations,     XtParseTranslationTable (list_translations23),
					     XmNtraversalOn,      False,
					     NULL);
		  
		  XtManageChild(form);
		  
		  
		  form = XtVaCreateWidget ("form.error.editor", xmFormWidgetClass, rc3,
					   XmNfractionBase,  100,  
					   XmNtranslations, XtParseTranslationTable (list_translations23),
					   NULL);



		  bolistdata = (struct BOList *)malloc(sizeof(struct BOList));
		  bolistdata->ob_num   = i;
		  bolistdata->errnum   = BOSaveArray[boindex].conds[saveindex].errnum;
		  bolistdata->instance = BOSaveArray[boindex].conds[saveindex].instance;
		  bolistdata->viewall  = 0;
		  bolistdata->viewsome = 0;
		  


		  bolistdata->allwid = 
		    XtVaCreateManagedWidget ("the_test",
					     xmToggleButtonWidgetClass, form,
					     XmNtopAttachment,    XmATTACH_FORM,
					     XmNtraversalOn,      True,
					     XmNbottomAttachment, XmATTACH_FORM,
					     XmNleftAttachment,   XmATTACH_POSITION,
					     XmNleftPosition,     5,
					     XmNlabelString,      STRING("Highlight All"),
					     XmNalignment,        XmALIGNMENT_BEGINNING,
					     XmNtranslations,     
					     XtParseTranslationTable (list_translations23),
					     XmNtraversalOn,      False,
					     TOGGLEINCLUDE,
					     NULL);
		  
		  bolistdata->somewid = 
		    XtVaCreateManagedWidget ("the_test",
					     xmToggleButtonWidgetClass, form,
					     XmNtopAttachment,    XmATTACH_FORM,
					     XmNtraversalOn,      True,
					     XmNbottomAttachment, XmATTACH_FORM,
					     XmNleftAttachment,   XmATTACH_WIDGET,
					     XmNleftWidget,       bolistdata->allwid,
					     XmNlabelString,      STRING("Highlight Selected"),
					     XmNalignment,        XmALIGNMENT_BEGINNING,
 					     XmNtranslations,     
					     XtParseTranslationTable (list_translations23),
					     XmNtraversalOn,      False,
					     TOGGLEINCLUDE,
					     NULL);
		  XtManageChild(form);
		  XtManageChild(rc3);
		  







		  instanceoutline = XtVaCreateManagedWidget("suboutline",
							    xmOutlineWidgetClass,
							    instancehandle, 
							    XmNindentation, 20, 
							    XmNoutline,     TRUE,
								XmNtranslations, XtParseTranslationTable (list_translations23),
							    NULL);
		  


		
		  XtAddCallback (bolistdata->somewid, 
				 XmNvalueChangedCallback, (XtCallbackProc)toggle_view_some_bo, bolistdata);
		  
		  XtAddCallback (bolistdata->allwid, 
				 XmNvalueChangedCallback, (XtCallbackProc)toggle_view_all_bo,  bolistdata);


		  


		  result = FindInBoList(bolistdata->ob_num,bolistdata->errnum,bolistdata->instance,
					bolistdata->allwid,bolistdata->somewid);


		  if(result==1)
		    {
		      
		      XmToggleButtonSetState(bolistdata->somewid,(Boolean)1,(Boolean)0);
		      XmToggleButtonSetState(bolistdata->allwid, (Boolean)0,(Boolean)0);
		    }
		  else if(result==2)
		    {
		      
		      XmToggleButtonSetState(bolistdata->somewid,(Boolean)0,(Boolean)0);
		      XmToggleButtonSetState(bolistdata->allwid, (Boolean)1,(Boolean)0);
		    }
		  else
		    {
		      
		      XmToggleButtonSetState(bolistdata->somewid,(Boolean)0,(Boolean)0);
		      XmToggleButtonSetState(bolistdata->allwid, (Boolean)0,(Boolean)0);
		    }






		  mydata4  = (MyData *) (malloc(sizeof(MyData)));
		  if(mydata4==NULL){printf("myb: out of allocation memory!\n"); ExitWrapper(-1);}
		  mydata4->outlinewid = (XmOutlineWidget)instanceoutline;
		  mydata4->level      = 4;
		  mydata4->group_num  = j;
		  mydata4->object_num = i;
		  mydata4->check_num  = BOSaveArray[boindex].conds[saveindex].errnum;
		  mydata4->clonenum   = BOSaveArray[boindex].conds[saveindex].instance;


		  XtAddCallback(left, 
				XmNactivateCallback, (XtCallbackProc)BOToggleButtonHandleCB, 
				(XtPointer) mydata4);
		  





		  if(FindBOLevel(mydata4->object_num, 
				 mydata4->group_num,
				 mydata4->check_num,
				 mydata4->clonenum
				 )==0)
		    {
		      

		      BuildBOSpecificCond(instanceoutline,boindex,mydata4->check_num,mydata4->clonenum,i,
					  bolistdata->allwid,bolistdata->somewid);

		      XtUnmanageChild(instanceoutline);
		      XtVaSetValues(left, XmNlabelPixmap, plus_pix, NULL);
		    }
		  else
		    {
		      if(BODEBUG==1)
			{
			  printf("know we need to build it for #%d\n",boindex);
			}
		      
		      BuildBOSpecificCond(instanceoutline,boindex,mydata4->check_num,mydata4->clonenum,i,
					  bolistdata->allwid,bolistdata->somewid);
		    }
				  
		  XtVaSetValues(instancehandle,
				XmNsubWidget, instanceoutline,
				NULL);
		}
	    }
	}
    }

  fclose(bofile);


  


  LOCALBUSY = 0;
}




void borevertCallback(Widget w, XtPointer userData, XtPointer callData)
{
  char filename[1000],filename2[1000],command2[1000];

  if(BODEBUG==1)
    {
      printf("Revert BO\n");
    }

  XtPopdown(ob_head[current_ob_head]);  
  
  sprintf(filename, "%scondreport.bo2",outdirectory);
  sprintf(filename2,"%scondreport.bo", outdirectory);
  
  if((USE_DOS==0)||(SLASHTYPE==NONDOS_TYPE))
    {
      sprintf(command2,"cp \"%s\" \"%s\"",filename2,filename);
    }
  else
    {
      sprintf(command2,"copy \"%s\" \"%s\"",filename2,filename);
    }  
  
  system(command2);


  ResetBOoptions();
  
  view_object_page = 1;
  SetNewPage();

}







void bodeselectCallback(Widget w, XtPointer userData, XtPointer callData)
{
  struct BOList *curr,*prev;
  int minindex,maxindex;
  

  minindex = num_per_page*(view_object_page-1) + 1;
  if(minindex<1)
    {
      XBell(mydisplay,50);
      printf("Error in 311: trying to set minindex to %d\n",minindex);
      minindex = 1;
    }
  maxindex = minindex + num_per_page - 1;
  if(maxindex>numobs)
    {
      maxindex = numobs;
    }



  curr = BOOnList;
  while(curr!=NULL)
    {
      if(curr->viewall==1)
	{
	  curr->viewsome = 0;
	  curr->viewall  = 0;

	  if( (curr->ob_num>=minindex) && (curr->ob_num<=maxindex) )
	    {
	      
	      XmToggleButtonSetState(curr->somewid,0,(Boolean)0);
	      XmToggleButtonSetState(curr->allwid, 0,(Boolean)0);
	    }

	  if(curr->selectcount==0)
	    {
	      if(curr==BOOnList)
		{
		  BOOnList = BOOnList->next;
		  free(curr);
		  curr     = BOOnList;
		}
	      else
		{
		  prev->next = curr->next;
		  free(curr);
		  curr = prev->next;
		}
	    }
	  else
	    {
	      printf("NOT removing it because selectcount==%d\n",curr->selectcount);
	    }
	}
      else if(curr->viewsome==1)
	{
	  curr->viewsome = 0;
	  curr->viewall  = 0;
	  if( (curr->ob_num>=minindex) && (curr->ob_num<=maxindex) )
	    {
	      
	      XmToggleButtonSetState(curr->somewid,0,(Boolean)0);
	      XmToggleButtonSetState(curr->allwid, 0,(Boolean)0);
	    }
	}
      
      if(curr==NULL)
	{
	  break;
	}

      prev = curr;
      curr = curr->next;
    }
  
  
}



void SetFCButtons(int errnum, int onoff)
{
  int i;


  if(ErrorLookup[errnum].totalBO>0)
    {
      if(onoff==1)
	{
	  XmToggleButtonSetState(ErrorLookup[errnum].filterwid, (Boolean)1,(Boolean)0);
	  ErrorLookup[errnum].filterout = 1;
	}
      else
	{
	  XmToggleButtonSetState(ErrorLookup[errnum].filterwid, (Boolean)0,(Boolean)0);
	  ErrorLookup[errnum].filterout = 0;
	}
    }



  for(i=0;i<CLONE_DEFINITIONS;i++)
    {
      if((CloneErrorLookup[i].CloneNumber==errnum)&&(CloneErrorLookup[i].totalBO>0))
	{
	  if(onoff==1)
	    {
	      XmToggleButtonSetState(CloneErrorLookup[i].filterwid, (Boolean)1,(Boolean)0);
	      CloneErrorLookup[i].filterout = 1;
	    }
	  else
	    {
	      XmToggleButtonSetState(CloneErrorLookup[i].filterwid, (Boolean)0,(Boolean)0);
	      CloneErrorLookup[i].filterout = 0;
	    }
	}
    }
}




void select_all_fc_errtype(Widget w,XtPointer data,XtPointer callData)
{ 
  int errnum=(int)data;

  SetFCButtons(errnum,1);
  UpdateAllFCTotals();
}



void deselect_all_fc_errtype(Widget w,XtPointer data,XtPointer callData)
{ 
  int errnum=(int)data;

  SetFCButtons(errnum,0);
  UpdateAllFCTotals();
}




void select_all_fc_error(Widget w,XtPointer data,XtPointer callData)
{ 
  int type=(int)data;
  int i;
  
  
  

  for(i=1;i<=CONDITION_DEFINITIONS;i++)
    {
      if(ErrorLookup[i].totalBO>0)
	{
	  if(type==1)
	    {
	      XmToggleButtonSetState(ErrorLookup[i].filterwid, (Boolean)1,(Boolean)0);
	      ErrorLookup[i].filterout  = 1;
	    }
	  else
	    {
	      XmToggleButtonSetState(ErrorLookup[i].filterwid, (Boolean)0,(Boolean)0);
	      ErrorLookup[i].filterout  = 0;
	    }
	}
    }

  
  for(i=0;i<CLONE_DEFINITIONS;i++)
    {
      if(CloneErrorLookup[i].totalBO>0)
	{
	  if(type==1)
	    {
	      XmToggleButtonSetState(CloneErrorLookup[i].filterwid, (Boolean)1,(Boolean)0);
	      CloneErrorLookup[i].filterout  = 1;
	    }
	  else
	    {
	      XmToggleButtonSetState(CloneErrorLookup[i].filterwid, (Boolean)0,(Boolean)0);
	      CloneErrorLookup[i].filterout  = 0;
	    }
	}
    }




  
  
  if(type==1)
    {
      for(i=1;i<=CONDITION_DEFINITIONS;i++)
	{
	  ErrorLookup[i].filterout  = 1;
	}
      
      for(i=0;i<CLONE_DEFINITIONS;i++)
	{
	  CloneErrorLookup[i].filterout  = 1;
	}
    }
  else
    {
      for(i=1;i<=CONDITION_DEFINITIONS;i++)
	{
	  ErrorLookup[i].filterout  = 0;
	}
      
      for(i=0;i<CLONE_DEFINITIONS;i++)
	{
	  CloneErrorLookup[i].filterout  = 0;
	}
    }
  UpdateAllFCTotals();
}







void FCToggleButtonHandleCB(Widget w, MyData  *closure, XtPointer call_data)
{
  XmOutlineWidget outline = (XmOutlineWidget) closure->outlinewid;
  int level = closure->level;
  int group_num,check_num;
  
  
  if(level==1)
    {
      if(FCOnOff1==1)
	{
	  XtUnmanageChild((Widget) outline);
	  XtVaSetValues(w, XmNlabelPixmap, plus_pix, NULL);
	  FCOnOff1 = 0;
	}
      else if(FCOnOff1==0)
	{
	  XtManageChild((Widget) outline);
	  XtVaSetValues(w, XmNlabelPixmap, minus_pix, NULL);
	  FCOnOff1 = 1;
	}
    }
  else if(level==2)
    {
      group_num = closure->group_num;
      if(group_num>=NUMCHECKGROUPS)
	{
	  printf("bad group num %d\n",group_num);
	}
      else if(FCOnOff2[group_num]==1)
	{
	  XtUnmanageChild((Widget) outline);
	  FCOnOff2[group_num] = 0;
	  XtVaSetValues(w, XmNlabelPixmap, plus_pix, NULL);
	}
      else if(FCOnOff2[group_num]==0)
	{
	  XtManageChild((Widget) outline);
	  FCOnOff2[group_num] = 1;
	  XtVaSetValues(w, XmNlabelPixmap, minus_pix, NULL);
	}
    }
  else if(level==3)
    {
      check_num = closure->check_num;
      
      if(check_num>CONDITION_DEFINITIONS)
	{
	  printf("bad check num %d\n",check_num);
	}
      else if(FCOnOff3[check_num]==1)
	{
	  XtUnmanageChild((Widget) outline);
	  FCOnOff3[check_num] = 0;
	  XtVaSetValues(w, XmNlabelPixmap, plus_pix, NULL);
	}
      else if(FCOnOff3[check_num]==0)
	{
	  XtManageChild((Widget) outline);
	  FCOnOff3[check_num] = 1;
	  XtVaSetValues(w, XmNlabelPixmap, minus_pix, NULL);
	}
    }
  else if(level==4)
    {
      printf("got bad level %d\n",level);
    }
}
  













void CheckFilterCallback(Widget w, XtPointer userData, XtPointer callData)
{
  
  
  Arg resources[15];
  int n=0,i=0,j,checknum,cloneindex,totalSchecks,totalSconds;
  Widget rc,form,Done,sw2,button, handle,subhandle,subsubhandle,left,right,
    rc3,tempwid,outline,suboutline,subsuboutline,checkhandle,junkwid;
  char temp[1000],thislabel[1000],message[1000];
  int totalchecks=0,totalconds=0;
  XmString str;
  MyData *mydata,*mydata3,*mydata4;
  static Widget filterhead;
  extern struct CheckGroupNames CGN[NUMCHECKGROUPS];



   if(numobs==0)
    {
      sprintf(message,"All the conditions have already been filtered out.\n\
Use \"Revert\" to un-filter them.");

      not_while_running(drawing_a,message,1391,"All Conditions Already Filtered",1);
      return;
    }



  if(dead_checkfilter==1)
    {      
      
      n=0;
      XtSetArg(resources[n],  XmNdeleteResponse, XmDESTROY);    n++;
      XtSetArg(resources[n],  XmNminWidth,       250);          n++;
      XtSetArg(resources[n],  XmNminHeight,      300);          n++;

      
      filterhead = 
	XtCreatePopupShell("Filter Conditions Found",topLevelShellWidgetClass,w,resources,n);
      
      
      rc = XtVaCreateManagedWidget
	(
	 "XformWidget", xmPanedWindowWidgetClass, filterhead,
	 XmNrubberPositioning, False,
	 XmNresizable,         True,
	 XmNseparatorOn,       False,
	 XmNsashHeight,        1,
	 XmNtranslations, XtParseTranslationTable (list_translations25),
	 NULL
	 );

      

      
      
      form = XtVaCreateWidget ("form.sw.editor", xmFormWidgetClass, rc,
			       XmNfractionBase,  100,  
			       XmNtranslations, XtParseTranslationTable (list_translations25),
			       NULL);
      
      sw2 = XtVaCreateManagedWidget ("scrolled_win",
				     xmScrolledWindowWidgetClass, form,
				     XmNwidth,                    700,
				     XmNheight,                   300,
				     XmNscrollingPolicy,          XmAUTOMATIC,
				     XmNscrollBarDisplayPolicy,   XmSTATIC,
				     XmNtopAttachment,            XmATTACH_FORM,
				     XmNbottomAttachment,         XmATTACH_FORM,
				     XmNleftAttachment,           XmATTACH_FORM,
				     XmNrightAttachment,          XmATTACH_FORM,
				     XmNtranslations,             XtParseTranslationTable (list_translations25),
				     
				     NULL);
      
      
      XtManageChild(form);
      
      
      
      XtVaGetValues(sw2,XmNverticalScrollBar,&vert_scroll[BO_FILTER],NULL);
      XtVaGetValues(sw2,XmNhorizontalScrollBar,&junkwid,NULL);
      
      
      XtVaSetValues(vert_scroll[BO_FILTER],  
		    XmNtraversalOn,  False, 	
		    
		    NULL);

      XtVaSetValues(junkwid, XmNtraversalOn, False, NULL);

 
      
      
      
      handle = XtVaCreateManagedWidget("roothandle", xmHandleWidgetClass,
				       sw2,
					   XmNtranslations, XtParseTranslationTable (list_translations25),
				       NULL);
      
      left = XtVaCreateManagedWidget("left", xmPushButtonWidgetClass,
				     handle,
				     XmNlabelType,   XmPIXMAP,
				     XmNlabelPixmap, minus_pix,					 
				     XmNtraversalOn, False,
					 XmNtranslations, XtParseTranslationTable (list_translations25),
				     NULL);
      
      right = XtVaCreateManagedWidget("All Inspection Categories Possible to Filter", xmLabelWidgetClass,
				      handle,
					  XmNtranslations, XtParseTranslationTable (list_translations25),
				      NULL);
      
      totalchecks   = 0;
      totalconds    = 0;
      totalSchecks  = 0;
      totalSconds   = 0;

      FCGetGlobalTotals(&totalchecks,&totalconds,&totalSchecks,&totalSconds);
      
      if(totalchecks==1)
	{
	  sprintf(temp," (%d/%d instance (%d/%d conditions) marked for filtering)",
		  totalSchecks,totalchecks,totalSconds,totalconds);
	}
      else
	{
	  sprintf(temp," (%d/%d instances (%d/%d conditions) marked for filtering)",
		  totalSchecks,totalchecks,totalSconds,totalconds);
	}
      
      
      FCGlobalTotals = XtVaCreateManagedWidget(temp, xmLabelWidgetClass,
					       handle,
					       XmNtraversalOn,     False,
						   XmNtranslations, XtParseTranslationTable (list_translations25),
					       NULL);
      
      
      
      outline = XtVaCreateManagedWidget("outline", xmOutlineWidgetClass,
					handle,
					XmNindentation,    20,
					XmNoutline,        TRUE,
					XmNtranslations, XtParseTranslationTable (list_translations25),
					
					NULL);
      
      
      mydata3  = (MyData *) (malloc(sizeof(MyData)));
      if(mydata3==NULL){printf("myb: out of allocation memory!\n"); ExitWrapper(-1);}
      mydata3->outlinewid = (XmOutlineWidget)outline;
      mydata3->level = 1;
      
      XtAddCallback(left, 
		    XmNactivateCallback, (XtCallbackProc)FCToggleButtonHandleCB, 
		    (XtPointer) mydata3);
      
      XtVaSetValues(handle, 
		    XmNsubWidget, outline,
		    NULL);
      
      
      if(FCOnOff1==0)
	{
	  
	  XtUnmanageChild(outline);
	  XtVaSetValues(left, XmNlabelPixmap, plus_pix, NULL);
	}
      
      
      
      for(i=0;i<NUMCHECKGROUPS;i++)
	{
	  totalconds     = 0;
	  totalchecks    = 0;
	  totalSchecks   = 0;
	  totalSconds    = 0;

	  FCGetTotals(i,&totalchecks,&totalconds,&totalSchecks,&totalSconds);
	  
	  if(totalchecks>0)
	    {
	      subhandle = XtVaCreateManagedWidget("subhandle",
						  xmHandleWidgetClass,
						  outline,
						  XmNtranslations, XtParseTranslationTable (list_translations25),
						  
						  NULL);
	      
	      left = XtVaCreateManagedWidget("left", xmPushButtonWidgetClass,
					     subhandle,
					     XmNlabelType,       XmPIXMAP,
					     XmNlabelPixmap,     minus_pix,
					     XmNarrowDirection,  XmARROW_DOWN,
					     XmNshadowThickness, 0,
					     XmNtraversalOn,     False,
						 XmNtranslations,    XtParseTranslationTable (list_translations25),
					     NULL);
	      
	      sprintf(thislabel,"%s (%d/%d instances (%d/%d conditions) marked for filtering)",
		      CGN[i].name,
		      totalSchecks,
		      totalchecks,
		      totalSconds,
		      totalconds);
	      
	      CGN[i].FCgrouplevel = XtVaCreateManagedWidget(thislabel, xmLabelWidgetClass,
							    subhandle,
								XmNtranslations, XtParseTranslationTable (list_translations25),
							    NULL);
	      
	      suboutline = XtVaCreateManagedWidget("suboutline",
						   xmOutlineWidgetClass,
						   subhandle, 
						   XmNindentation,  20, 
						   XmNoutline,      TRUE,
						   XmNtranslations, XtParseTranslationTable (list_translations25),
						   
						   NULL);
	      
	      
	      
	      mydata4  = (MyData *) (malloc(sizeof(MyData)));
	      if(mydata4==NULL){printf("myb: out of allocation memory!\n"); ExitWrapper(-1);}
	      mydata4->outlinewid = (XmOutlineWidget)suboutline;
	      mydata4->level     = 2;
	      mydata4->group_num = i;
	      
	      
	      XtAddCallback(left, 
			    XmNactivateCallback, (XtCallbackProc)FCToggleButtonHandleCB, 
			    (XtPointer) mydata4);
	      
	      
	      if(FCOnOff2[i]==0)
		{
		  
		  XtUnmanageChild(suboutline);
		  XtVaSetValues(left, XmNlabelPixmap, plus_pix, NULL);
		}
	      
	      
	      XtVaSetValues(subhandle, 
			    XmNsubWidget, suboutline, 
			    NULL);
	      

	      
	      
	      
	      
	      
	      for(checknum=1;checknum<=CONDITION_DEFINITIONS;checknum++)
		{
		  
		  
		  if(ErrorLookup[checknum].mygroup!=i)
		    {
		      continue;
		    }
		  
		  
		  totalconds   = 0;
		  totalchecks  = 0;
		  totalSchecks = 0;
		  totalSconds  = 0;
		  
		  FCGetTotal(checknum, &totalconds, &totalchecks,&totalSchecks,&totalSconds);
		  
		  
		  if(totalconds==0)
		    {
		      
		      continue;
		    }
		  
		  
		  
		  
		  subsubhandle = XtVaCreateManagedWidget("subsubhandle",
							 xmHandleWidgetClass,
							 suboutline,
							 XmNtranslations, XtParseTranslationTable (list_translations25),
							 NULL);
		  





		  rc3 = XtVaCreateWidget ("rowcol",xmRowColumnWidgetClass,subsubhandle, 
			  XmNtranslations, XtParseTranslationTable (list_translations25),
			  NULL);
		  
		  
		  form = XtVaCreateWidget ("form.error.editor", xmFormWidgetClass, rc3,
					   XmNfractionBase,  100, 
					   XmNtranslations, XtParseTranslationTable (list_translations25),
					   NULL);
		  

		  left = XtVaCreateManagedWidget("left", xmPushButtonWidgetClass,
						 form,
						 XmNleftAttachment,  XmATTACH_POSITION,
						 XmNleftPosition,    0,
						 XmNrightAttachment, XmATTACH_POSITION,
						 XmNrightPosition,   4,
						 XmNlabelType,       XmPIXMAP,
						 XmNlabelPixmap,     minus_pix,
						 XmNarrowDirection,  XmARROW_DOWN,
						 XmNshadowThickness, 0,
						 XmNtraversalOn,     False,
						 XmNtranslations, XtParseTranslationTable (list_translations25),
						 NULL);
		  
		  
		  sprintf(thislabel,"%s (%d/%d instances (%d/%d conditions) marked for filtering",
			  ParseErrType(checknum),
			  totalSchecks,
			  totalchecks,
			  totalSconds,
			  totalconds);
		 
		  
		  ErrorLookup[checknum].FCchecktype = 
		    XtVaCreateManagedWidget(thislabel, xmLabelWidgetClass,
					    form,
					    XmNleftAttachment,  XmATTACH_POSITION,
					    XmNleftPosition,    4,
					    XmNrightAttachment, XmATTACH_POSITION,
					    XmNrightPosition,   100,
						XmNtranslations, XtParseTranslationTable (list_translations25),
					    NULL);
		  
		  XtManageChild(form);




		  form = XtVaCreateWidget ("form.error.editor", xmFormWidgetClass, rc3,
					   XmNfractionBase,  100,  
					   XmNtranslations, XtParseTranslationTable (list_translations25),
					   NULL);
		  
		  
		  ErrorLookup[checknum].FCselectallwid = 
		    XtVaCreateManagedWidget ("the_test",
					     xmPushButtonWidgetClass, form,
					     XmNtopAttachment,    XmATTACH_FORM,
					     XmNtraversalOn,      True,
					     XmNbottomAttachment, XmATTACH_FORM,
					     XmNleftAttachment,   XmATTACH_POSITION,
					     XmNleftPosition,     5,
					     XmNlabelString,      STRING("Select All"),
					     XmNalignment,        XmALIGNMENT_BEGINNING,
					     XmNtranslations,     
					     XtParseTranslationTable (list_translations25),
					     XmNtraversalOn,      False,
					     NULL);

		  ErrorLookup[checknum].FCdeselectallwid = 
		    XtVaCreateManagedWidget ("the_test",
					     xmPushButtonWidgetClass, form,
					     XmNtopAttachment,    XmATTACH_FORM,
					     XmNtraversalOn,      True,
					     XmNbottomAttachment, XmATTACH_FORM,
					     XmNleftAttachment,   XmATTACH_WIDGET,
					     XmNleftWidget,       ErrorLookup[checknum].FCselectallwid,
					     XmNlabelString,      STRING("De-Select All"),
					     XmNalignment,        XmALIGNMENT_BEGINNING,
					     XmNtranslations,     
					     XtParseTranslationTable (list_translations25),
					     XmNtraversalOn,      False,
					     NULL);
		  
		  XtManageChild(form);
		  XtManageChild(rc3);



		  XtAddCallback(ErrorLookup[checknum].FCselectallwid, XmNactivateCallback,
				select_all_fc_errtype, (XtPointer) checknum);
		  
		  XtAddCallback(ErrorLookup[checknum].FCdeselectallwid, XmNactivateCallback,
				deselect_all_fc_errtype, (XtPointer) checknum);
		  

		  subsuboutline = XtVaCreateManagedWidget("subsuboutline",
							  xmOutlineWidgetClass,
							  subsubhandle, 
							  XmNindentation, 20, 
							  XmNoutline, TRUE,
							  XmNtranslations, XtParseTranslationTable (list_translations25),
							  NULL);
		  
		  mydata4  = (MyData *) (malloc(sizeof(MyData)));
		  if(mydata4==NULL){printf("myb: out of allocation memory!\n"); ExitWrapper(-1);}
		  mydata4->outlinewid = (XmOutlineWidget)subsuboutline;
		  mydata4->level     = 3;
		  mydata4->group_num = i;
		  mydata4->check_num = checknum;
		  
		  
		  XtAddCallback(left, 
				XmNactivateCallback, (XtCallbackProc)FCToggleButtonHandleCB, 
				(XtPointer) mydata4);
		  
		  
		  if(FCOnOff3[checknum]==0)
		    {
		      XtUnmanageChild(subsuboutline);
		      XtVaSetValues(left, XmNlabelPixmap, plus_pix, NULL);
		    }
		  
		  
		  XtVaSetValues(subsubhandle, 
				XmNsubWidget, subsuboutline, 
				NULL);
		  
		  
		
		  
		  
		  if((ErrorLookup[checknum].mygroup==i)&&(ErrorLookup[checknum].totalBO>0))
		    {
		      
		      checkhandle = XtVaCreateManagedWidget("subhandle",
							    xmHandleWidgetClass,
							    subsuboutline,
								XmNtranslations, XtParseTranslationTable (list_translations25),
							    NULL);
		      
		      if(ErrorLookup[checknum].Annotation==NULL)
			{
			  sprintf(temp,"%s (%d) (Instantiation 1)",
				  ParseErrType(checknum),ErrorLookup[checknum].totalBO);
			}
		      else
			{
			  sprintf(temp,"%s (%d) (Instantiation 1)\n(%s)",
				  ParseErrType(checknum),ErrorLookup[checknum].totalBO,
				  ErrorLookup[checknum].Annotation);
			}
		      
		      
		      str = XmStringCreateLtoR (temp, "mytag1");
		      
		      
		      mydata  = (MyData *) (malloc(sizeof(MyData)));
		      if(mydata==NULL){printf("myb: out of allocation memory!\n"); ExitWrapper(-1);}
		      
		      mydata->check_num = checknum;
		      mydata->clonenum  = -1;
		      

		      rc3 = XtVaCreateWidget ("rowcol",xmRowColumnWidgetClass, checkhandle,
				  XmNtranslations, XtParseTranslationTable (list_translations25),
				  NULL);
		      
		      
		      form = XtVaCreateWidget ("form.error.editor", xmFormWidgetClass, rc3,
					       XmNfractionBase,  100, 
						   XmNtranslations, XtParseTranslationTable (list_translations25),
					       NULL);
		      
		      


		      tempwid = 
			XtVaCreateManagedWidget ("the_test",
						 xmLabelWidgetClass, form,
						 XmNtopAttachment,    XmATTACH_FORM,
						 XmNtraversalOn,      True,
						 XmNbottomAttachment, XmATTACH_FORM,
						 XmNleftAttachment,   XmATTACH_POSITION,
						 XmNleftPosition,     4,
						 XmNrightAttachment,  XmATTACH_POSITION,
						 XmNrightPosition,    100,
						 XmNlabelString,      str,
						 XmNalignment,        XmALIGNMENT_BEGINNING,
						 XmNtranslations,     XtParseTranslationTable (list_translations25),
						 XmNtraversalOn,      False,
						 NULL);
		      
		      XtManageChild(form);
		      
		      
		      form = XtVaCreateWidget ("form.error.editor", xmFormWidgetClass, rc3,
					       XmNfractionBase,  100,  
					       XmNtranslations, XtParseTranslationTable (list_translations25),
					       NULL);
		      
		      ErrorLookup[checknum].filterwid = 
			XtVaCreateManagedWidget ("the_test",
						 xmToggleButtonWidgetClass, form,
						 XmNtopAttachment,    XmATTACH_FORM,
						 XmNtraversalOn,      True,
						 XmNbottomAttachment, XmATTACH_FORM,
						 XmNleftAttachment,   XmATTACH_POSITION,
						 XmNleftPosition,     5,
						 XmNlabelString,      STRING("Select for filtering out"),
						 XmNalignment,        XmALIGNMENT_BEGINNING,
						 XmNtranslations,     
						 XtParseTranslationTable (list_translations25),
						 XmNtraversalOn,      False,
						 TOGGLEINCLUDE,
						 NULL);
		      
		      XtManageChild(form);
		      XtManageChild(rc3);
		      
		      

		      XtAddCallback (ErrorLookup[checknum].filterwid, 
				     XmNvalueChangedCallback, (XtCallbackProc)check_filter_callback,  mydata);
		      
		      XmToggleButtonSetState(ErrorLookup[checknum].filterwid,
					     (Boolean)ErrorLookup[checknum].filterout,
					     (Boolean)0);
		      
		      XmStringFree (str);
		      
		     		     		      
		    }







		  
		  
		  
		  
		  for(j=0;j<ErrorLookup[checknum].num_clones;j++)
		    {
		      cloneindex = GetCloneIndex(j+1,checknum);
		      
		      if((CloneErrorLookup[cloneindex].totalBO>0)&&(ErrorLookup[checknum].mygroup==i))
			{
			  
			  checkhandle = XtVaCreateManagedWidget("subhandle",
								xmHandleWidgetClass,
								subsuboutline,
								XmNtranslations, XtParseTranslationTable (list_translations25),
								
								NULL);
			  
			  
			  if(CloneErrorLookup[cloneindex].Annotation==NULL)
			    {
			      sprintf(temp,"%s (%d) (Instantiation %d)",
				      ParseErrType(checknum),CloneErrorLookup[cloneindex].totalBO,j+2);
			    }
			  else
			    {
			      sprintf(temp,"%s (%d) (Instantiation %d)\n(%s)",
				      ParseErrType(checknum),CloneErrorLookup[cloneindex].totalBO,j+2,
				      CloneErrorLookup[cloneindex].Annotation);
			    }
			  
			  
			  str = XmStringCreateLtoR (temp, "mytag1");
			  
			  
			  mydata  = (MyData *) (malloc(sizeof(MyData)));
			  if(mydata==NULL){printf("myb: out of allocation memory!\n"); ExitWrapper(-1);}
			  
			  mydata->check_num = checknum;
			  mydata->clonenum  = cloneindex;
			  
			  
			  rc3 = XtVaCreateWidget ("rowcol",xmRowColumnWidgetClass, checkhandle,
				  XmNtranslations, XtParseTranslationTable (list_translations25),
				  NULL);
			  
			  
			  form = XtVaCreateWidget ("form.error.editor", xmFormWidgetClass, rc3,
						   XmNfractionBase,  100,  
						   XmNtranslations, XtParseTranslationTable (list_translations25),
						   NULL);
			  
			  
			  
			  tempwid = 
			    XtVaCreateManagedWidget ("the_test",
						     xmLabelWidgetClass, form,
						     XmNtopAttachment,    XmATTACH_FORM,
						     XmNtraversalOn,      True,
						     XmNbottomAttachment, XmATTACH_FORM,
						     XmNleftAttachment,   XmATTACH_POSITION,
						     XmNleftPosition,     4,
						     XmNrightAttachment,  XmATTACH_POSITION,
						     XmNrightPosition,    100,
						     XmNlabelString,      str,
						     XmNalignment,        XmALIGNMENT_BEGINNING,
						     XmNtranslations,     
						     XtParseTranslationTable (list_translations25),
						     XmNtraversalOn,     False,
						     NULL);
			  
			  XtManageChild(form);
			  
			  
			  form = XtVaCreateWidget ("form.error.editor", xmFormWidgetClass, rc3,
						   XmNfractionBase,  100,  
						   XmNtranslations, XtParseTranslationTable (list_translations25),
						   NULL);
			  
			  CloneErrorLookup[cloneindex].filterwid = 
			    XtVaCreateManagedWidget ("the_test",
						     xmToggleButtonWidgetClass, form,
						     XmNtopAttachment,    XmATTACH_FORM,
						     XmNtraversalOn,      True,
						     XmNbottomAttachment, XmATTACH_FORM,
						     XmNleftAttachment,   XmATTACH_POSITION,
						     XmNleftPosition,     5,
						     XmNlabelString,      STRING("Select for filtering out"),
						     XmNalignment,        XmALIGNMENT_BEGINNING,
						     XmNtranslations,     
						     XtParseTranslationTable (list_translations25),
						     XmNtraversalOn,     False,
						     TOGGLEINCLUDE,
						     NULL);
			  
			  XtManageChild(form);
			  XtManageChild(rc3);
			  

			  XtAddCallback (CloneErrorLookup[cloneindex].filterwid, 
					 XmNvalueChangedCallback, (XtCallbackProc)check_filter_callback,  mydata);
			  			  			  
			  XmToggleButtonSetState(CloneErrorLookup[cloneindex].filterwid,
						 (Boolean)CloneErrorLookup[cloneindex].filterout,
						 (Boolean)0);
			  
			  XmStringFree (str);


			  
			  
			  
			  			  
			}
		    }
		}
	    }
	}


      
      
      
      
      form = XtVaCreateWidget ("form2", xmFormWidgetClass, rc,
			       XmNpaneMinimum,   25,
			       XmNpaneMaximum,   25,
			       XmNfractionBase,  100,  
			       XmNtraversalOn,   False,
			       NULL);
      
      button  = XtVaCreateManagedWidget("s_all_error",xmPushButtonWidgetClass,form,
					XmNleftAttachment,  XmATTACH_POSITION,
					XmNleftPosition,    0,
					XmNrightAttachment, XmATTACH_POSITION,
					XmNrightPosition,   50,
					XmNlabelString,     STRING("Select All"),
					XmNtraversalOn,     False,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					NULL
					); 
      
      XtAddCallback(button, XmNactivateCallback,
		    select_all_fc_error, (XtPointer) 1);
      XtManageChild(button);
      
      button  = XtVaCreateManagedWidget("s_all_error",xmPushButtonWidgetClass,form,
					XmNleftAttachment,  XmATTACH_POSITION,
					XmNleftPosition,    50,
					XmNrightAttachment, XmATTACH_POSITION,
					XmNrightPosition,   100,
					XmNlabelString,     STRING("De-Select All"),
					XmNtraversalOn,     False,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					NULL
					); 
      
      XtAddCallback(button, XmNactivateCallback,
		    select_all_fc_error, (XtPointer) 0);
      XtManageChild(button);
      
      XtManageChild(form);
      
      






      form = XtVaCreateWidget ("form2", xmFormWidgetClass, rc,
			       XmNpaneMinimum,   25,
			       XmNpaneMaximum,   25,
			       XmNfractionBase,  100,  
			       XmNtraversalOn,   False,
			       NULL);


      Done  = XtVaCreateManagedWidget("Help5",xmPushButtonWidgetClass,form,
				      XmNleftAttachment,  XmATTACH_POSITION,
				      XmNleftPosition,    0,
				      XmNrightAttachment, XmATTACH_POSITION,
				      XmNrightPosition,   50,
				      XmNlabelString, STRING("Help"),
				      XmNtraversalOn,     False,
				      XmNtranslations, XtParseTranslationTable ( translations_global ) ,
				      NULL
				      ); 
      XtAddCallback(Done, XmNactivateCallback,
		    Help_fc_errCallback, (XtPointer) NULL);
      XtManageChild(Done);



      Done  = XtVaCreateManagedWidget("Done7",xmPushButtonWidgetClass,form,
				      XmNleftAttachment,  XmATTACH_POSITION,
				      XmNleftPosition,    50,
				      XmNrightAttachment, XmATTACH_POSITION,
				      XmNrightPosition,   100,
				      XmNlabelString,     STRING("Done"),
				      XmNtraversalOn,     False,
				      XmNtranslations, XtParseTranslationTable ( translations_global ) ,
				      NULL
				      ); 


      XtAddCallback(Done, XmNactivateCallback,
		    die_callback, (XtPointer) 1015);
      XtManageChild(Done);
      XtManageChild(form);
      XtManageChild(rc);
      MyPopup(filterhead); 
      XtAddCallback(filterhead,XmNdestroyCallback,ShellDeath,(XtPointer)4058);
      
      
      XtVaSetValues(vert_scroll[BO_FILTER],XmNincrement,30,NULL);

      dead_checkfilter=0;
    }
  else
    {
      ResetWidget(filterhead);
    }





  
}




void kill_fcode(Widget w,XtPointer data,XtPointer call_data)
{
  XmString *new_names;
  char temp[1000];
  int *pos_list;
  int pos_count,i,j,foundone,insertindex;



  XmListGetSelectedPos(BOlist2_w,&pos_list,&pos_count);
  

  for(i=0;i<pos_count;i++)
    {
      

      foundone = 0;
      for(j=0;j<NumberOfModels;j++)
	{
	  if(MdlNames[j].inout2>0)
	    {
	      foundone = foundone + 1;
	      if(foundone==pos_list[i])
		{
		  MdlNames[j].inout2 = 10;
		  break;
		}
	    }
	}
    }


  new_names = (XmString *) (malloc(sizeof(XmString *) * NumberOfModels));
  if(new_names==NULL){printf("sacn4: out of allocation memory!\n"); ExitWrapper(-1);}
  
  
  
  
  insertindex = 0;
  for(i=0;i<NumberOfModels;i++)
    {
      if(MdlNames[i].inout2==1)
	{
	  if(NGA_TYPE==1)
	    {
	      sprintf(temp,"%s: %s %s (%d/%.0lf)",
		      GetECCCode(MdlNames[i].code),
		      GetECCLabel(MdlNames[i].code),
		      MdlNames[i].name,
		      MdlNames[i].inout,
		      MdlNames[i].occurrences);		  
	    }
	  else
	    {
	      sprintf(temp,"%s %s (%d/%.0lf)",
		      GetECCLabel(MdlNames[i].code),
		      MdlNames[i].name,
		      MdlNames[i].inout,
		      MdlNames[i].occurrences);	
	    }	

	  new_names[insertindex] = XmStringCreate(temp,"mytag1");
	  insertindex = insertindex + 1;
	}
      else if(MdlNames[i].inout2==10)
	{
	  MdlNames[i].inout2 = 0;
	}
    }

  
  sprintf(temp,"         ");
  for(i=insertindex;i<NumberOfModels;i++)
    {
      new_names[i] = XmStringCreate(temp,"mytag1");
    }

  
  XmListDeleteAllItems(BOlist2_w);
  XmListAddItems(BOlist2_w, new_names, NumberOfModels,1);
}






void kill_all_fcode(Widget w,XtPointer data,XtPointer call_data)
{
  XmString *new_names;
  char temp[1000];
  int i;
  
  
  new_names = (XmString *) (malloc(sizeof(XmString *) * NumberOfModels));
  if(new_names==NULL){printf("sacn4: out of allocation memory!\n"); ExitWrapper(-1);}
  
  
  sprintf(temp,"         ");
  for(i=0;i<NumberOfModels;i++)
    {
      new_names[i] = XmStringCreate(temp,"mytag1");
    }
  
  XmListDeleteAllItems(BOlist2_w);
  XmListAddItems(BOlist2_w, new_names, NumberOfModels,1);
  
  
  
  for(i=0;i<NumberOfModels;i++)
    {
      MdlNames[i].inout2 = 0;
    }
  
}

 



void Help_fcodeCallback(Widget w,XtPointer data,XtPointer callData)
{
  if(NGA_TYPE==1)
    {
      not_while_running(w,"This window is used to select feature types with conditions\n\
to filter (remove) from the \"View Conditions By Feature\" display.\n\
Those feature types on the right hand list are \"marked\" to be filtered out.\n\
To put feature types on the right hand list, select them in the left hand\n\
list and use the arrow between the lists to move them onto the right\n\
hand list.\n\n\
Selecting the \"Apply filters\" button on the \"View Conditions By Feature\" window\n\
applies these selections, removing conditions which were marked for filtering.",
		    1392,"Feature Type Filtering Help",5);
    }
  else
    {
      not_while_running(w,"This window is used to select classifiers with conditions\n\
to filter (remove) from the \"View Conditions By Object\" display.\n\
Those classifiers on the right hand list are \"marked\" to be filtered out.\n\
To put classifiers on the right hand list, select them in the left hand\n\
list and use the arrow between the lists to move them onto the right\n\
hand list.\n\n\
Selecting the \"Apply filters\" button on the \"View Conditions By Object\" window\n\
applies these selections, removing conditions which were marked for filtering.",
		    1392,"Classification Filtering Help",5);
    }
}




void Help_modCallback(Widget w,XtPointer data,XtPointer callData)
{
  char junk[5000];

  
  if(NGA_TYPE==1)
    {
      junk[0] = '\0';
      strcat(junk,"This window can be used to select items in the data to highlight \n\
based on their feature types and attribute values.\n\n\
To choose feature types, select them in the \"Feature Types\" list, then click the top\n\
button labeled with a right arrow to \"move\" these items to the \"Selected Feature\n\
Types\" list.\n\n\
For attributes, selecting an attribute in the attribute list will:\n\
   \"Locate COMBINATIONS of features and attributes\":  OFF\n\
     ->show all values for that attribute in the data\n\
   \"Locate COMBINATIONS of features and attributes\":  ON\n\
     ->show all values for that attribute in the data,\n\
       for which the feature also has the selected\n\
       feature type.\n\n\
An attribute may be added to the \"Selected Attribute Items\" list by selecting it\n\
in the attribute list, and clicking the lower right arrow (this selects all values\n\
of the attribute).  Alternatively, certain values of the attribute may be selected\n\
by selecting only the desired values from the attribute value list and clicking the\n\
lower button labeled with a right pointing arrow.\n\n");

      
      strcat(junk,"Highlighted items will be highlighted by drawing them in red if zoomed in enough to\n\
see them, otherwise, the region these items lie in will be marked with red diamonds.  \n\n\
To remove items from the selected list, select them and click either\n\
\"Remove Selected Feature Types\" or \"Remove Selected Attribute Items\".\n\
Or, use either the \"Remove ALL Feature Types\" or \"Remove ALL Attribute Items\"\n\
button to remove all feature types or attribute items, respectively.");
    }
  else
    {
      junk[0] = '\0';
      strcat(junk,"This window can be used to select items in the data to highlight \n\
based on their classification identifiers and attribute values.\n\n\
To choose classification identifiers, select from the classification identifier list,\n\
then click the top button labeled with a right arrow to \"move\" these items to the\n\
selected classification item list.\n\n\
For attributes, selecting an attribute in the attribute list will:\n\
   \"Locate COMBINATIONS of classification and attributes\":  OFF\n\
     ->show all values for that attribute in the data\n\
   \"Locate COMBINATIONS of classification and attributes\":  ON\n\
     ->show all values for that attribute in the data,\n\
       for which the classified object also has the selected\n\
       classification identifier.\n\n\
An attribute may be added to the selected attribute list by selecting the attribute\n\
in the attribute list, and clicking the lower right arrow (this selects all values\n\
of the attribute).  Alternatively, certain values of the attribute may be selected\n\
by selecting only the desired values from the attribute value list and clicking the\n\
lower button labeled with a right pointing arrow.\n\n");
      
      strcat(junk,"Highlighted items will be highlighted by drawing them in red if zoomed in enough to see\n\
them, otherwise, the region these items lie in will be marked with red diamonds.  \n\n\
To remove items from the selected list, select them and click either\n\
\"De-Select classification items\" or \"De-Select attribution items\".  Or, use either\n\
the \"De-Select ALL classification items\" or \"De-Select ALL attribution items\" button\n\
to de-select all classification or attribution items, respectively.");
    }

  not_while_running(w,junk,1236,"Attribution Highlighting Help",5);  
}







